//go:build slow

package dart

import (
	"bytes"
	"regexp"

	meta "mochi/compiler/meta"
)

var dartKeywords = map[string]bool{
	"this":       true,
	"class":      true,
	"enum":       true,
	"mixin":      true,
	"super":      true,
	"switch":     true,
	"case":       true,
	"var":        true,
	"final":      true,
	"void":       true,
	"while":      true,
	"async":      true,
	"await":      true,
	"yield":      true,
	"with":       true,
	"static":     true,
	"implements": true,
	"extends":    true,
	"on":         true,
	"import":     true,
	"export":     true,
	"library":    true,
	"part":       true,
	"const":      true,
	"continue":   true,
	"default":    true,
	"do":         true,
	"else":       true,
	"factory":    true,
	"get":        true,
	"set":        true,
	"new":        true,
	"throw":      true,
	"try":        true,
	"catch":      true,
	"rethrow":    true,
	"return":     true,
}

var identRE = regexp.MustCompile(`^[A-Za-z_][A-Za-z0-9_]*$`)

func escapeIdent(name string) string {
	if dartKeywords[name] || !identRE.MatchString(name) {
		return "_" + name
	}
	return name
}

// formatDart runs `dart format` if available, falling back to simple formatting.
func formatDart(src []byte) []byte {
	header := meta.Header("//")
	if i := bytes.IndexByte(src, '\n'); i != -1 && bytes.HasPrefix(src, []byte("// Generated by Mochi")) {
		src = src[i+1:]
	}

	// Disable external formatter to keep output stable across environments.
	src = append(header, src...)
	src = bytes.ReplaceAll(src, []byte("\t"), []byte("  "))
	if len(src) > 0 && src[len(src)-1] != '\n' {
		src = append(src, '\n')
	}
	return src
}
