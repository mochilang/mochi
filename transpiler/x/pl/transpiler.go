package pl

import (
	"fmt"
	"io"
	"strings"
	"time"

	"mochi/ast"
	"mochi/parser"
	"mochi/types"
)

// Program represents a simple Prolog program.
type Program struct {
	Stmts []Stmt
}

type Stmt interface{ emit(io.Writer) }

type PrintStmt struct{ Value string }

func (p *PrintStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "    write('%s'), nl", escape(p.Value))
}

func escape(s string) string {
	s = strings.ReplaceAll(s, "'", "''")
	return s
}

// Transpile converts a Mochi program to a Prolog AST.
func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	p := &Program{}
	for _, st := range prog.Statements {
		if st.Expr != nil {
			call := st.Expr.Expr.Binary.Left.Value.Target.Call
			if call != nil && call.Func == "print" && len(call.Args) == 1 {
				arg := call.Args[0]
				if arg.Binary != nil && arg.Binary.Left != nil {
					lit := arg.Binary.Left.Value.Target.Lit
					if lit != nil && lit.Str != nil {
						p.Stmts = append(p.Stmts, &PrintStmt{Value: *lit.Str})
						continue
					}
				}
			}
			return nil, fmt.Errorf("unsupported expression")
		} else {
			return nil, fmt.Errorf("unsupported statement")
		}
	}
	_ = env
	return p, nil
}

// Emit writes the Prolog source for the given program.
func Emit(w io.Writer, p *Program) error {
	if _, err := io.WriteString(w, header()); err != nil {
		return err
	}
	io.WriteString(w, ":- initialization(main).\n\n")
	io.WriteString(w, "main :-\n")
	for i, st := range p.Stmts {
		st.emit(w)
		if i < len(p.Stmts)-1 {
			io.WriteString(w, ",\n")
		} else {
			io.WriteString(w, ".\n")
		}
	}
	return nil
}

func header() string {
	t := time.Now().UTC().Format("2006-01-02 15:04:05 MST")
	return fmt.Sprintf("%s %s\n", "% Generated by Mochi transpiler", t)
}

// Print converts the Program to ast.Node and prints it.
func Print(p *Program) {
	toNode(p).Print("")
}

func toNode(p *Program) *ast.Node {
	n := &ast.Node{Kind: "program"}
	for _, s := range p.Stmts {
		n.Children = append(n.Children, stmtNode(s))
	}
	return n
}

func stmtNode(s Stmt) *ast.Node {
	switch st := s.(type) {
	case *PrintStmt:
		return &ast.Node{Kind: "print", Value: st.Value}
	default:
		return &ast.Node{Kind: "unknown"}
	}
}
