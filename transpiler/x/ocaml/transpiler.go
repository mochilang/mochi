//go:build slow

package ocaml

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"mochi/ast"
	"mochi/parser"
	"mochi/types"
)

// Program represents a sequence of OCaml statements.
type Program struct {
	Stmts []Stmt
}

// Stmt can emit itself as OCaml code.
type Stmt interface{ emit(io.Writer) }

// LetStmt represents a simple variable binding.
type LetStmt struct {
	Name string
	Expr Expr
}

func (l *LetStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "  let %s = ", l.Name)
	l.Expr.emit(w)
	io.WriteString(w, " in\n")
}

// PrintStmt represents a call to print_endline.
type PrintStmt struct{ Expr Expr }

func (p *PrintStmt) emit(w io.Writer) {
	io.WriteString(w, "  print_endline (")
	p.Expr.emitPrint(w)
	io.WriteString(w, ");\n")
}

// Expr is any OCaml expression that can emit itself.
type Expr interface {
	emit(io.Writer)
	emitPrint(io.Writer)
}

// UnaryMinus represents negation of an integer expression.
type UnaryMinus struct{ Expr Expr }

func (u *UnaryMinus) emit(w io.Writer) {
	io.WriteString(w, "(-")
	u.Expr.emit(w)
	io.WriteString(w, ")")
}

func (u *UnaryMinus) emitPrint(w io.Writer) {
	io.WriteString(w, "string_of_int (-")
	u.Expr.emit(w)
	io.WriteString(w, ")")
}

// IfExpr represents a conditional expression.
type IfExpr struct {
	Cond Expr
	Then Expr
	Else Expr
	Typ  string
}

func (i *IfExpr) emit(w io.Writer) {
	io.WriteString(w, "if ")
	i.Cond.emit(w)
	io.WriteString(w, " then ")
	i.Then.emit(w)
	io.WriteString(w, " else ")
	i.Else.emit(w)
}

func (i *IfExpr) emitPrint(w io.Writer) {
	switch i.Typ {
	case "int":
		io.WriteString(w, "string_of_int ")
		i.emit(w)
	case "bool":
		io.WriteString(w, "string_of_int (if ")
		i.Cond.emit(w)
		io.WriteString(w, " then (if ")
		i.Then.emit(w)
		io.WriteString(w, " then 1 else 0) else (if ")
		i.Else.emit(w)
		io.WriteString(w, " then 1 else 0))")
	default:
		i.emit(w)
	}
}

// Name represents a variable reference.
type Name struct {
	Ident string
	Typ   string
}

func (n *Name) emit(w io.Writer) { io.WriteString(w, n.Ident) }
func (n *Name) emitPrint(w io.Writer) {
	switch n.Typ {
	case "int":
		fmt.Fprintf(w, "string_of_int %s", n.Ident)
	case "bool":
		fmt.Fprintf(w, "string_of_int (if %s then 1 else 0)", n.Ident)
	default:
		io.WriteString(w, n.Ident)
	}
}

// IntLit represents an integer literal.
type IntLit struct{ Value int }

func (i *IntLit) emit(w io.Writer)      { fmt.Fprintf(w, "%d", i.Value) }
func (i *IntLit) emitPrint(w io.Writer) { fmt.Fprintf(w, "string_of_int %d", i.Value) }

// BoolLit represents a boolean literal.
type BoolLit struct{ Value bool }

func (b *BoolLit) emit(w io.Writer) { fmt.Fprintf(w, "%t", b.Value) }
func (b *BoolLit) emitPrint(w io.Writer) {
	if b.Value {
		io.WriteString(w, "string_of_int 1")
	} else {
		io.WriteString(w, "string_of_int 0")
	}
}

// StringLit represents a string literal.
type StringLit struct{ Value string }

func (s *StringLit) emit(w io.Writer)      { fmt.Fprintf(w, "%q", s.Value) }
func (s *StringLit) emitPrint(w io.Writer) { fmt.Fprintf(w, "%q", s.Value) }

// BinaryExpr represents a binary operation.
type BinaryExpr struct {
	Left  Expr
	Op    string
	Right Expr
	Typ   string
}

func (b *BinaryExpr) emit(w io.Writer) {
	op := b.Op
	if b.Op == "%" {
		op = "mod"
	}
	if b.Op == "+" && b.Typ == "string" {
		op = "^"
	}
	fmt.Fprintf(w, "(")
	b.Left.emit(w)
	fmt.Fprintf(w, " %s ", op)
	b.Right.emit(w)
	fmt.Fprintf(w, ")")
}

func (b *BinaryExpr) emitPrint(w io.Writer) {
	switch b.Typ {
	case "bool":
		io.WriteString(w, "string_of_int (if ")
		b.emit(w)
		io.WriteString(w, " then 1 else 0)")
	case "string":
		b.emit(w)
	default:
		io.WriteString(w, "string_of_int ")
		b.emit(w)
	}
}

func repoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func version() string {
	root := repoRoot()
	if root == "" {
		return "dev"
	}
	b, err := os.ReadFile(filepath.Join(root, "VERSION"))
	if err != nil {
		return "dev"
	}
	return strings.TrimSpace(string(b))
}

func header() string {
	loc := time.FixedZone("GMT+7", 7*3600)
	t := time.Now().In(loc)
	return fmt.Sprintf("(* Generated by Mochi transpiler v%s on %s *)\n", version(), t.Format("2006-01-02 15:04:05 MST"))
}

// Emit renders OCaml source code for the program.
func (p *Program) Emit() []byte {
	var buf bytes.Buffer
	buf.WriteString(header())
	buf.WriteString("\n")
	buf.WriteString("let () =\n")
	for _, s := range p.Stmts {
		s.emit(&buf)
	}
	return buf.Bytes()
}

// Transpile converts a Mochi program into a simple OCaml AST.
func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	pr := &Program{}
	vars := map[string]string{}
	for _, st := range prog.Statements {
		switch {
		case st.Let != nil:
			if st.Let.Value == nil {
				return nil, fmt.Errorf("let without value not supported")
			}
			expr, typ, err := convertExpr(st.Let.Value, env, vars)
			if err != nil {
				return nil, err
			}
			vars[st.Let.Name] = typ
			pr.Stmts = append(pr.Stmts, &LetStmt{Name: st.Let.Name, Expr: expr})
		case st.Expr != nil:
			call := st.Expr.Expr.Binary.Left.Value.Target.Call
			if call != nil && call.Func == "print" && len(call.Args) == 1 {
				expr, _, err := convertExpr(call.Args[0], env, vars)
				if err != nil {
					return nil, err
				}
				pr.Stmts = append(pr.Stmts, &PrintStmt{Expr: expr})
				continue
			}
			return nil, fmt.Errorf("unsupported expression")
		default:
			return nil, fmt.Errorf("unsupported statement")
		}
	}
	return pr, nil
}

// Print converts the custom AST into a generic ast.Node and prints it.
func Print(p *Program) {
	n := &ast.Node{Kind: "program"}
	for _, st := range p.Stmts {
		switch s := st.(type) {
		case *PrintStmt:
			n.Children = append(n.Children, &ast.Node{Kind: "print"})
		case *LetStmt:
			n.Children = append(n.Children, &ast.Node{Kind: "let", Value: s.Name})
		default:
			n.Children = append(n.Children, &ast.Node{Kind: "stmt"})
		}
	}
	n.Print("")
}

// --- Conversion helpers ---

func convertExpr(e *parser.Expr, env *types.Env, vars map[string]string) (Expr, string, error) {
	if e == nil {
		return nil, "", fmt.Errorf("nil expr")
	}
	return convertBinary(e.Binary, env, vars)
}

func convertBinary(b *parser.BinaryExpr, env *types.Env, vars map[string]string) (Expr, string, error) {
	if b == nil {
		return nil, "", fmt.Errorf("nil binary")
	}
	left, typ, err := convertUnary(b.Left, env, vars)
	if err != nil {
		return nil, "", err
	}
	expr := left
	for _, op := range b.Right {
		right, rtyp, err := convertPostfix(op.Right, env, vars)
		if err != nil {
			return nil, "", err
		}
		resTyp := typ
		switch op.Op {
		case "+", "-", "*", "/", "%":
			if op.Op == "+" && typ == "string" && rtyp == "string" {
				resTyp = "string"
			} else {
				resTyp = "int"
			}
		case "==", "!=", "<", "<=", ">", ">=":
			resTyp = "bool"
		default:
			return nil, "", fmt.Errorf("op %s not supported", op.Op)
		}
		expr = &BinaryExpr{Left: expr, Op: op.Op, Right: right, Typ: resTyp}
		typ = resTyp
		_ = rtyp
	}
	return expr, typ, nil
}

func convertUnary(u *parser.Unary, env *types.Env, vars map[string]string) (Expr, string, error) {
	if u == nil {
		return nil, "", fmt.Errorf("nil unary")
	}
	if len(u.Ops) > 0 {
		if len(u.Ops) == 1 && u.Ops[0] == "-" {
			expr, typ, err := convertPostfix(u.Value, env, vars)
			if err != nil {
				return nil, "", err
			}
			if typ != "int" {
				return nil, "", fmt.Errorf("unary - only for ints")
			}
			return &UnaryMinus{Expr: expr}, "int", nil
		}
		return nil, "", fmt.Errorf("unary ops not supported")
	}
	return convertPostfix(u.Value, env, vars)
}

func convertPostfix(p *parser.PostfixExpr, env *types.Env, vars map[string]string) (Expr, string, error) {
	if p == nil {
		return nil, "", fmt.Errorf("nil postfix")
	}
	if len(p.Ops) > 0 {
		return nil, "", fmt.Errorf("postfix ops not supported")
	}
	return convertPrimary(p.Target, env, vars)
}

func convertPrimary(p *parser.Primary, env *types.Env, vars map[string]string) (Expr, string, error) {
	switch {
	case p.Lit != nil:
		return convertLiteral(p.Lit)
	case p.Group != nil:
		return convertExpr(p.Group, env, vars)
	case p.If != nil:
		return convertIf(p.If, env, vars)
	case p.Selector != nil:
		if len(p.Selector.Tail) == 0 {
			typ := vars[p.Selector.Root]
			return &Name{Ident: p.Selector.Root, Typ: typ}, typ, nil
		}
	}
	return nil, "", fmt.Errorf("unsupported expression")
}

func convertLiteral(l *parser.Literal) (Expr, string, error) {
	if l.Int != nil {
		return &IntLit{Value: int(*l.Int)}, "int", nil
	}
	if l.Bool != nil {
		return &BoolLit{Value: bool(*l.Bool)}, "bool", nil
	}
	if l.Str != nil {
		return &StringLit{Value: *l.Str}, "string", nil
	}
	return nil, "", fmt.Errorf("unsupported literal")
}

func convertIf(ifx *parser.IfExpr, env *types.Env, vars map[string]string) (Expr, string, error) {
	cond, _, err := convertExpr(ifx.Cond, env, vars)
	if err != nil {
		return nil, "", err
	}
	thenExpr, thenTyp, err := convertExpr(ifx.Then, env, vars)
	if err != nil {
		return nil, "", err
	}
	var elseExpr Expr
	var elseTyp string
	if ifx.ElseIf != nil {
		elseExpr, elseTyp, err = convertIf(ifx.ElseIf, env, vars)
		if err != nil {
			return nil, "", err
		}
	} else if ifx.Else != nil {
		elseExpr, elseTyp, err = convertExpr(ifx.Else, env, vars)
		if err != nil {
			return nil, "", err
		}
	} else {
		return nil, "", fmt.Errorf("if expression missing else")
	}
	if thenTyp != elseTyp {
		return nil, "", fmt.Errorf("if branches have different types")
	}
	return &IfExpr{Cond: cond, Then: thenExpr, Else: elseExpr, Typ: thenTyp}, thenTyp, nil
}
