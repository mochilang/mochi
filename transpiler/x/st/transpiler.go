package st

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"mochi/ast"
	"mochi/parser"
	"mochi/types"
)

// Program is a simple Smalltalk AST representing a sequence of statements.
type Program struct {
	Stmts []Stmt
}

type Stmt interface{ emit(io.Writer) }

// ExprStmt is a statement consisting solely of an expression.
type ExprStmt struct{ Expr Expr }

func (s *ExprStmt) emit(w io.Writer) { s.Expr.emit(w) }

type Expr interface{ emit(io.Writer) }

// PrintString represents a Transcript show statement.
type PrintString struct{ Value string }

func (p *PrintString) emit(w io.Writer) {
	fmt.Fprintf(w, "Transcript show: '%s'; cr", escape(p.Value))
}

// Emit writes the Smalltalk source code to w with a generated header.
func Emit(w io.Writer, prog *Program) error {
	if prog == nil {
		return nil
	}
	if _, err := io.WriteString(w, header()); err != nil {
		return err
	}
	for i, s := range prog.Stmts {
		s.emit(w)
		if i < len(prog.Stmts)-1 {
			if _, err := io.WriteString(w, "\n"); err != nil {
				return err
			}
		}
	}
	if len(prog.Stmts) > 0 {
		if _, err := io.WriteString(w, "\n"); err != nil {
			return err
		}
	}
	return nil
}

func escape(s string) string { return strings.ReplaceAll(s, "'", "''") }

// Transpile converts a Mochi program into our Smalltalk AST.
func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	p := &Program{}
	for _, st := range prog.Statements {
		if st.Expr == nil {
			return nil, fmt.Errorf("unsupported statement")
		}
		expr := st.Expr.Expr
		if expr == nil || expr.Binary == nil || len(expr.Binary.Right) > 0 {
			return nil, fmt.Errorf("unsupported expression")
		}
		u := expr.Binary.Left
		if u == nil || len(u.Ops) > 0 {
			return nil, fmt.Errorf("unsupported unary")
		}
		pf := u.Value
		if pf == nil || len(pf.Ops) > 0 || pf.Target == nil || pf.Target.Call == nil {
			return nil, fmt.Errorf("unsupported expression")
		}
		call := pf.Target.Call
		if call.Func != "print" || len(call.Args) != 1 {
			return nil, fmt.Errorf("unsupported call")
		}
		arg := call.Args[0]
		if arg == nil || arg.Binary == nil || len(arg.Binary.Right) > 0 {
			return nil, fmt.Errorf("unsupported arg")
		}
		argu := arg.Binary.Left
		if argu == nil || len(argu.Ops) > 0 || argu.Value == nil || argu.Value.Target == nil || argu.Value.Target.Lit == nil || argu.Value.Target.Lit.Str == nil {
			return nil, fmt.Errorf("unsupported arg")
		}
		p.Stmts = append(p.Stmts, &ExprStmt{Expr: &PrintString{Value: *argu.Value.Target.Lit.Str}})
	}
	_ = env
	return p, nil
}

func repoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func version() string {
	root := repoRoot()
	if root == "" {
		return "dev"
	}
	if data, err := os.ReadFile(filepath.Join(root, "VERSION")); err == nil {
		return strings.TrimSpace(string(data))
	}
	return "dev"
}

func header() string {
	loc := time.FixedZone("GMT+7", 7*3600)
	t := time.Now().In(loc)
	return fmt.Sprintf("\" Generated by Mochi transpiler v%s on %s\n", version(), t.Format("2006-01-02 15:04:05 MST"))
}

// Print converts the AST to a generic ast.Node and prints it.
func Print(p *Program) {
	toNode(p).Print("")
}

func toNode(p *Program) *ast.Node {
	n := &ast.Node{Kind: "program"}
	for _, s := range p.Stmts {
		n.Children = append(n.Children, stmtNode(s))
	}
	return n
}

func stmtNode(s Stmt) *ast.Node {
	switch st := s.(type) {
	case *ExprStmt:
		return &ast.Node{Kind: "print", Children: []*ast.Node{{Kind: "string", Value: st.Expr.(*PrintString).Value}}}
	default:
		return &ast.Node{Kind: "unknown"}
	}
}
