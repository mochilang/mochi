//go:build slow

package zigt

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"mochi/parser"
	"mochi/types"
)

// Program represents a Zig source file with one or more functions.
type Program struct {
	Functions []*Func
}

var constLists map[string]*ListLit

type Func struct {
	Name string
	Body []Stmt
}

type Stmt interface{ emit(io.Writer, int) }

type Expr interface{ emit(io.Writer) }

// BoolLit represents a boolean literal.
type BoolLit struct{ Value bool }

// IfStmt represents a simple if-else statement.
type IfStmt struct {
	Cond Expr
	Then []Stmt
	Else []Stmt
}

// WhileStmt represents a basic while loop.
type WhileStmt struct {
	Cond Expr
	Body []Stmt
}

// ForStmt represents iteration over a range or iterable collection.
type ForStmt struct {
	Name     string
	Start    Expr // used for numeric ranges
	End      Expr // end of range (exclusive)
	Iterable Expr // used for foreach loops
	Body     []Stmt
}

// IfExpr represents an if expression returning a value.
type IfExpr struct {
	Cond Expr
	Then Expr
	Else Expr
}

// CallExpr represents a simple function call.
type CallExpr struct {
	Func string
	Args []Expr
}

// PrintStmt writes an expression using std.debug.print.
type PrintStmt struct{ Value Expr }

// VarDecl represents `let` or `var` declarations.
type VarDecl struct {
	Name    string
	Value   Expr
	Mutable bool
}

// AssignStmt represents simple assignments like `x = expr`.
type AssignStmt struct {
	Name  string
	Value Expr
}

// IndexAssignStmt assigns to an indexed expression like `xs[i] = val`.
type IndexAssignStmt struct {
	Target Expr
	Value  Expr
}

// ExprStmt allows top-level expressions.
type ExprStmt struct{ Expr Expr }

type StringLit struct{ Value string }

type IntLit struct{ Value int }

type VarRef struct{ Name string }

type BinaryExpr struct {
	Left  Expr
	Op    string
	Right Expr
}

// ListLit represents a list literal of integer expressions.
type ListLit struct{ Elems []Expr }

// IndexExpr represents list indexing like `xs[i]`.
type IndexExpr struct {
	Target Expr
	Index  Expr
}

func repoRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("go.mod not found")
}

func version() string {
	root, err := repoRoot()
	if err != nil {
		return "dev"
	}
	b, err := os.ReadFile(filepath.Join(root, "VERSION"))
	if err != nil {
		return "dev"
	}
	return strings.TrimSpace(string(b))
}

func header() string {
	ts := time.Now().Format("2006-01-02 15:04 -0700")
	return fmt.Sprintf("// Generated by Mochi Zig transpiler v%s on %s\n", version(), ts)
}

// Emit returns the Zig source code for the program.
func (p *Program) Emit() []byte {
	var buf bytes.Buffer
	buf.WriteString(header())
	buf.WriteString("const std = @import(\"std\");\n\n")
	for i, fn := range p.Functions {
		if i > 0 {
			buf.WriteString("\n")
		}
		fn.emit(&buf)
	}
	return buf.Bytes()
}

func (f *Func) emit(w io.Writer) {
	fmt.Fprintf(w, "pub fn %s() void {\n", f.Name)
	for _, st := range f.Body {
		st.emit(w, 1)
	}
	fmt.Fprintln(w, "}")
}

func writeIndent(w io.Writer, n int) {
	for i := 0; i < n; i++ {
		io.WriteString(w, "    ")
	}
}

func (s *PrintStmt) emit(w io.Writer, indent int) {
	writeIndent(w, indent)
	io.WriteString(w, "std.debug.print(\"{any}\\n\", .{")
	s.Value.emit(w)
	io.WriteString(w, "});\n")
}

func (v *VarDecl) emit(w io.Writer, indent int) {
	writeIndent(w, indent)
	kw := "const"
	if v.Mutable {
		kw = "var"
	}
	typ := ""
	switch val := v.Value.(type) {
	case *IntLit, nil:
		typ = "i64"
	case *StringLit:
		typ = "[]const u8"
	case *BoolLit:
		typ = "bool"
	case *ListLit:
		typ = fmt.Sprintf("[%d]i64", len(val.Elems))
	}

	if v.Value == nil {
		fmt.Fprintf(w, "%s %s: %s = 0;\n", kw, v.Name, typ)
		return
	}
	if typ != "" {
		fmt.Fprintf(w, "%s %s: %s = ", kw, v.Name, typ)
	} else {
		fmt.Fprintf(w, "%s %s = ", kw, v.Name)
	}
	v.Value.emit(w)
	io.WriteString(w, ";\n")
}

func (a *AssignStmt) emit(w io.Writer, indent int) {
	writeIndent(w, indent)
	fmt.Fprintf(w, "%s = ", a.Name)
	a.Value.emit(w)
	io.WriteString(w, ";\n")
}

func (a *IndexAssignStmt) emit(w io.Writer, indent int) {
	writeIndent(w, indent)
	a.Target.emit(w)
	io.WriteString(w, " = ")
	a.Value.emit(w)
	io.WriteString(w, ";\n")
}

func (e *ExprStmt) emit(w io.Writer, indent int) {
	writeIndent(w, indent)
	if e.Expr != nil {
		e.Expr.emit(w)
	}
	io.WriteString(w, "\n")
}

func (s *StringLit) emit(w io.Writer) { fmt.Fprintf(w, "%q", s.Value) }

func (i *IntLit) emit(w io.Writer) { fmt.Fprintf(w, "%d", i.Value) }

func (v *VarRef) emit(w io.Writer) { io.WriteString(w, v.Name) }

func (b *BinaryExpr) emit(w io.Writer) {
	if b.Op == "+" {
		if l, ok := b.Left.(*StringLit); ok {
			if r, ok2 := b.Right.(*StringLit); ok2 {
				fmt.Fprintf(w, "%q", l.Value+r.Value)
				return
			}
		}
	}
	io.WriteString(w, "(")
	b.Left.emit(w)
	fmt.Fprintf(w, " %s ", b.Op)
	b.Right.emit(w)
	io.WriteString(w, ")")
}

func (l *ListLit) emit(w io.Writer) {
	fmt.Fprintf(w, "[%d]i64{", len(l.Elems))
	for i, e := range l.Elems {
		if i > 0 {
			io.WriteString(w, ", ")
		}
		e.emit(w)
	}
	io.WriteString(w, "}")
}

func (i *IndexExpr) emit(w io.Writer) {
	i.Target.emit(w)
	io.WriteString(w, "[")
	i.Index.emit(w)
	io.WriteString(w, "]")
}

func (b *BoolLit) emit(w io.Writer) {
	if b.Value {
		io.WriteString(w, "true")
	} else {
		io.WriteString(w, "false")
	}
}

func (i *IfStmt) emit(w io.Writer, indent int) {
	for j := 0; j < indent; j++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "if (")
	i.Cond.emit(w)
	io.WriteString(w, ") {\n")
	for _, st := range i.Then {
		st.emit(w, indent+1)
	}
	for j := 0; j < indent; j++ {
		io.WriteString(w, "    ")
	}
	if len(i.Else) == 0 {
		io.WriteString(w, "}\n")
		return
	}
	io.WriteString(w, "} else {\n")
	for _, st := range i.Else {
		st.emit(w, indent+1)
	}
	for j := 0; j < indent; j++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "}\n")
}

func (wst *WhileStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "while (")
	wst.Cond.emit(w)
	io.WriteString(w, ") {\n")
	for _, st := range wst.Body {
		st.emit(w, indent+1)
	}
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "}\n")
}

func (f *ForStmt) emit(w io.Writer, indent int) {
	writeIndent(w, indent)
	if f.Iterable != nil {
		io.WriteString(w, "for (")
		f.Iterable.emit(w)
		io.WriteString(w, ") |")
		io.WriteString(w, f.Name)
		io.WriteString(w, "| {\n")
	} else {
		io.WriteString(w, "for (")
		f.Start.emit(w)
		io.WriteString(w, "..")
		f.End.emit(w)
		io.WriteString(w, ") |")
		io.WriteString(w, f.Name)
		io.WriteString(w, "| {\n")
	}
	for _, st := range f.Body {
		st.emit(w, indent+1)
	}
	writeIndent(w, indent)
	io.WriteString(w, "}\n")
}

func (i *IfExpr) emit(w io.Writer) {
	io.WriteString(w, "if (")
	i.Cond.emit(w)
	io.WriteString(w, ") ")
	i.Then.emit(w)
	io.WriteString(w, " else ")
	i.Else.emit(w)
}

func (c *CallExpr) emit(w io.Writer) {
	switch c.Func {
	case "len":
		if len(c.Args) > 0 {
			if s, ok := c.Args[0].(*StringLit); ok {
				fmt.Fprintf(w, "%q.len", s.Value)
			} else if l, ok := c.Args[0].(*ListLit); ok {
				fmt.Fprintf(w, "%d", len(l.Elems))
			} else {
				io.WriteString(w, "std.mem.len(")
				c.Args[0].emit(w)
				io.WriteString(w, ")")
			}
		} else {
			io.WriteString(w, "0")
		}
	default:
		io.WriteString(w, c.Func)
		io.WriteString(w, "(")
		for i, a := range c.Args {
			if i > 0 {
				io.WriteString(w, ", ")
			}
			a.emit(w)
		}
		io.WriteString(w, ")")
	}
}

// Transpile converts a Mochi program into our simple Zig AST.
func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	main := &Func{Name: "main"}
	constLists = map[string]*ListLit{}
	mutables := map[string]bool{}
	for _, st := range prog.Statements {
		if st.Assign != nil && len(st.Assign.Index) == 0 && len(st.Assign.Field) == 0 {
			mutables[st.Assign.Name] = true
		}
	}
	for _, st := range prog.Statements {
		s, err := compileStmt(st, prog)
		if err != nil {
			if st.Test == nil && st.Import == nil && st.Type == nil {
				return nil, err
			}
			continue
		}
		if vd, ok := s.(*VarDecl); ok && !vd.Mutable {
			vd.Mutable = mutables[vd.Name]
		}
		main.Body = append(main.Body, s)
	}
	_ = env
	return &Program{Functions: []*Func{main}}, nil
}

func compileExpr(e *parser.Expr) (Expr, error) {
	if e == nil || e.Binary == nil {
		return nil, fmt.Errorf("unsupported expression")
	}
	left, err := compileUnary(e.Binary.Left)
	if err != nil {
		return nil, err
	}
	expr := left
	for _, op := range e.Binary.Right {
		r, err := compilePostfix(op.Right)
		if err != nil {
			return nil, err
		}
		expr = &BinaryExpr{Left: expr, Op: op.Op, Right: r}
	}
	return expr, nil
}

func compileUnary(u *parser.Unary) (Expr, error) {
	if u == nil {
		return nil, fmt.Errorf("nil unary")
	}
	expr, err := compilePostfix(u.Value)
	if err != nil {
		return nil, err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		if u.Ops[i] == "-" {
			expr = &BinaryExpr{Left: &IntLit{Value: 0}, Op: "-", Right: expr}
		} else {
			return nil, fmt.Errorf("unsupported unary op")
		}
	}
	return expr, nil
}

func compilePostfix(pf *parser.PostfixExpr) (Expr, error) {
	if pf == nil {
		return nil, fmt.Errorf("nil postfix")
	}
	expr, err := compilePrimary(pf.Target)
	if err != nil {
		return nil, err
	}
	for _, op := range pf.Ops {
		if op.Index != nil && op.Index.Colon == nil && op.Index.Colon2 == nil {
			idx, err := compileExpr(op.Index.Start)
			if err != nil {
				return nil, err
			}
			expr = &IndexExpr{Target: expr, Index: idx}
		} else {
			return nil, fmt.Errorf("unsupported postfix")
		}
	}
	return expr, nil
}

func compilePrimary(p *parser.Primary) (Expr, error) {
	switch {
	case p.Call != nil:
		args := make([]Expr, len(p.Call.Args))
		for i, a := range p.Call.Args {
			ex, err := compileExpr(a)
			if err != nil {
				return nil, err
			}
			args[i] = ex
		}
		switch p.Call.Func {
		case "str":
			if len(args) == 1 {
				if lit, ok := args[0].(*IntLit); ok {
					return &StringLit{Value: fmt.Sprintf("%d", lit.Value)}, nil
				}
			}
		case "min":
			if len(args) == 1 {
				switch v := args[0].(type) {
				case *ListLit:
					if len(v.Elems) == 0 {
						return &IntLit{Value: 0}, nil
					}
					m := v.Elems[0].(*IntLit).Value
					for _, e := range v.Elems[1:] {
						if lit, ok := e.(*IntLit); ok {
							if lit.Value < m {
								m = lit.Value
							}
						} else {
							return nil, fmt.Errorf("unsupported min element")
						}
					}
					return &IntLit{Value: m}, nil
				case *VarRef:
					if l, ok := constLists[v.Name]; ok {
						if len(l.Elems) == 0 {
							return &IntLit{Value: 0}, nil
						}
						m := l.Elems[0].(*IntLit).Value
						for _, e := range l.Elems[1:] {
							lit := e.(*IntLit)
							if lit.Value < m {
								m = lit.Value
							}
						}
						return &IntLit{Value: m}, nil
					}
				}
			}
		case "max":
			if len(args) == 1 {
				switch v := args[0].(type) {
				case *ListLit:
					if len(v.Elems) == 0 {
						return &IntLit{Value: 0}, nil
					}
					m := v.Elems[0].(*IntLit).Value
					for _, e := range v.Elems[1:] {
						if lit, ok := e.(*IntLit); ok {
							if lit.Value > m {
								m = lit.Value
							}
						} else {
							return nil, fmt.Errorf("unsupported max element")
						}
					}
					return &IntLit{Value: m}, nil
				case *VarRef:
					if l, ok := constLists[v.Name]; ok {
						if len(l.Elems) == 0 {
							return &IntLit{Value: 0}, nil
						}
						m := l.Elems[0].(*IntLit).Value
						for _, e := range l.Elems[1:] {
							lit := e.(*IntLit)
							if lit.Value > m {
								m = lit.Value
							}
						}
						return &IntLit{Value: m}, nil
					}
				}
			}
		case "substring":
			if len(args) == 3 {
				if s, ok := args[0].(*StringLit); ok {
					if start, ok1 := args[1].(*IntLit); ok1 {
						if end, ok2 := args[2].(*IntLit); ok2 {
							if start.Value >= 0 && end.Value <= len(s.Value) && start.Value <= end.Value {
								return &StringLit{Value: s.Value[start.Value:end.Value]}, nil
							}
						}
					}
				}
			}
		case "sum":
			if len(args) == 1 {
				if list, ok := args[0].(*ListLit); ok {
					total := 0
					for _, e := range list.Elems {
						lit, ok := e.(*IntLit)
						if !ok {
							return nil, fmt.Errorf("unsupported sum element")
						}
						total += lit.Value
					}
					return &IntLit{Value: total}, nil
				}
			}
		}
		return &CallExpr{Func: p.Call.Func, Args: args}, nil
	case p.Lit != nil:
		if p.Lit.Str != nil {
			return &StringLit{Value: *p.Lit.Str}, nil
		}
		if p.Lit.Int != nil {
			return &IntLit{Value: int(*p.Lit.Int)}, nil
		}
		if p.Lit.Bool != nil {
			return &BoolLit{Value: bool(*p.Lit.Bool)}, nil
		}
		return nil, fmt.Errorf("unsupported literal")
	case p.List != nil:
		elems := make([]Expr, len(p.List.Elems))
		for i, e := range p.List.Elems {
			ex, err := compileExpr(e)
			if err != nil {
				return nil, err
			}
			elems[i] = ex
		}
		return &ListLit{Elems: elems}, nil
	case p.If != nil:
		return compileIfExpr(p.If)
	case p.Selector != nil && len(p.Selector.Tail) == 0:
		return &VarRef{Name: p.Selector.Root}, nil
	case p.Group != nil:
		return compileExpr(p.Group)
	default:
		return nil, fmt.Errorf("unsupported primary")
	}
}

func compileIfExpr(ie *parser.IfExpr) (Expr, error) {
	cond, err := compileExpr(ie.Cond)
	if err != nil {
		return nil, err
	}
	thenExpr, err := compileExpr(ie.Then)
	if err != nil {
		return nil, err
	}
	var elseExpr Expr
	if ie.ElseIf != nil {
		elseExpr, err = compileIfExpr(ie.ElseIf)
		if err != nil {
			return nil, err
		}
	} else if ie.Else != nil {
		elseExpr, err = compileExpr(ie.Else)
		if err != nil {
			return nil, err
		}
	} else {
		return nil, fmt.Errorf("missing else expression")
	}
	return &IfExpr{Cond: cond, Then: thenExpr, Else: elseExpr}, nil
}

func compileIfStmt(is *parser.IfStmt, prog *parser.Program) (Stmt, error) {
	cond, err := compileExpr(is.Cond)
	if err != nil {
		return nil, err
	}
	var thenStmts []Stmt
	for _, s := range is.Then {
		st, err := compileStmt(s, prog)
		if err != nil {
			return nil, err
		}
		thenStmts = append(thenStmts, st)
	}
	var elseStmts []Stmt
	if is.ElseIf != nil {
		st, err := compileIfStmt(is.ElseIf, prog)
		if err != nil {
			return nil, err
		}
		elseStmts = []Stmt{st}
	} else if len(is.Else) > 0 {
		for _, s := range is.Else {
			st, err := compileStmt(s, prog)
			if err != nil {
				return nil, err
			}
			elseStmts = append(elseStmts, st)
		}
	}
	return &IfStmt{Cond: cond, Then: thenStmts, Else: elseStmts}, nil
}

func compileWhileStmt(ws *parser.WhileStmt, prog *parser.Program) (Stmt, error) {
	cond, err := compileExpr(ws.Cond)
	if err != nil {
		return nil, err
	}
	body := make([]Stmt, 0, len(ws.Body))
	for _, s := range ws.Body {
		st, err := compileStmt(s, prog)
		if err != nil {
			return nil, err
		}
		body = append(body, st)
	}
	return &WhileStmt{Cond: cond, Body: body}, nil
}

func compileForStmt(fs *parser.ForStmt, prog *parser.Program) (Stmt, error) {
	var start, end, iter Expr
	var err error
	if fs.RangeEnd != nil {
		start, err = compileExpr(fs.Source)
		if err != nil {
			return nil, err
		}
		end, err = compileExpr(fs.RangeEnd)
		if err != nil {
			return nil, err
		}
	} else {
		iter, err = compileExpr(fs.Source)
		if err != nil {
			return nil, err
		}
	}
	body := make([]Stmt, 0, len(fs.Body))
	for _, s := range fs.Body {
		st, err := compileStmt(s, prog)
		if err != nil {
			return nil, err
		}
		body = append(body, st)
	}
	return &ForStmt{Name: fs.Name, Start: start, End: end, Iterable: iter, Body: body}, nil
}

func compileStmt(s *parser.Statement, prog *parser.Program) (Stmt, error) {
	switch {
	case s.Expr != nil:
		call := s.Expr.Expr.Binary.Left.Value.Target.Call
		if call == nil || call.Func != "print" || len(call.Args) != 1 {
			return nil, fmt.Errorf("unsupported expression")
		}
		arg, err := compileExpr(call.Args[0])
		if err != nil {
			return nil, err
		}
		return &PrintStmt{Value: arg}, nil
	case s.Let != nil:
		var expr Expr
		var err error
		if s.Let.Value != nil {
			expr, err = compileExpr(s.Let.Value)
			if err != nil {
				return nil, err
			}
		} else {
			expr = &IntLit{Value: 0}
		}
		if l, ok := expr.(*ListLit); ok {
			constLists[s.Let.Name] = l
		} else {
			delete(constLists, s.Let.Name)
		}
		return &VarDecl{Name: s.Let.Name, Value: expr}, nil
	case s.Var != nil:
		var expr Expr
		var err error
		if s.Var.Value != nil {
			expr, err = compileExpr(s.Var.Value)
			if err != nil {
				return nil, err
			}
		} else {
			expr = &IntLit{Value: 0}
		}
		return &VarDecl{Name: s.Var.Name, Value: expr, Mutable: true}, nil
	case s.Assign != nil && len(s.Assign.Index) == 0 && len(s.Assign.Field) == 0:
		expr, err := compileExpr(s.Assign.Value)
		if err != nil {
			return nil, err
		}
		if l, ok := expr.(*ListLit); ok {
			constLists[s.Assign.Name] = l
		} else {
			delete(constLists, s.Assign.Name)
		}
		return &AssignStmt{Name: s.Assign.Name, Value: expr}, nil
	case s.Assign != nil && len(s.Assign.Index) > 0 && len(s.Assign.Field) == 0:
		target := Expr(&VarRef{Name: s.Assign.Name})
		for _, idx := range s.Assign.Index {
			ix, err := compileExpr(idx.Start)
			if err != nil {
				return nil, err
			}
			target = &IndexExpr{Target: target, Index: ix}
		}
		val, err := compileExpr(s.Assign.Value)
		if err != nil {
			return nil, err
		}
		return &IndexAssignStmt{Target: target, Value: val}, nil
	case s.If != nil:
		return compileIfStmt(s.If, prog)
	case s.While != nil:
		return compileWhileStmt(s.While, prog)
	case s.For != nil:
		return compileForStmt(s.For, prog)
	default:
		return nil, fmt.Errorf("unsupported statement")
	}
}
