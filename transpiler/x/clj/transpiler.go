//go:build slow

package cljt

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"mochi/ast"
	"mochi/parser"
	"mochi/types"
)

// --- Simple Clojure AST ---

// Node represents any Clojure AST node that can be emitted as code.
type Node interface {
	Emit(io.Writer)
}

// Symbol represents a Clojure symbol.
type Symbol string

func (s Symbol) Emit(w io.Writer) {
	io.WriteString(w, string(s))
}

// StringLit represents a quoted string literal.
type StringLit string

func (s StringLit) Emit(w io.Writer) {
	fmt.Fprintf(w, "%q", string(s))
}

// IntLit represents an integer literal.
type IntLit int64

func (i IntLit) Emit(w io.Writer) {
	io.WriteString(w, strconv.FormatInt(int64(i), 10))
}

// List represents a Clojure list form: (elem1 elem2 ...)
type List struct {
	Elems []Node
}

func (l *List) Emit(w io.Writer) {
	io.WriteString(w, "(")
	for i, e := range l.Elems {
		if i > 0 {
			io.WriteString(w, " ")
		}
		if e != nil {
			e.Emit(w)
		}
	}
	io.WriteString(w, ")")
}

// Vector represents a Clojure vector: [elem1 elem2 ...]
type Vector struct {
	Elems []Node
}

func (v *Vector) Emit(w io.Writer) {
	io.WriteString(w, "[")
	for i, e := range v.Elems {
		if i > 0 {
			io.WriteString(w, " ")
		}
		if e != nil {
			e.Emit(w)
		}
	}
	io.WriteString(w, "]")
}

// Program is a sequence of top-level forms.
type Program struct {
	Forms []Node
}

func (p *Program) Emit(w io.Writer) {
	for i, f := range p.Forms {
		if f == nil {
			continue
		}
		f.Emit(w)
		if i < len(p.Forms)-1 {
			io.WriteString(w, "\n")
		}
	}
}

// EmitString returns the program source as a byte slice.
func EmitString(p *Program) []byte {
	var buf bytes.Buffer
	if p != nil {
		p.Emit(&buf)
	}
	return buf.Bytes()
}

// Format returns the Clojure source with a generated header and trailing newline.
func Format(src []byte) []byte {
	if len(src) > 0 && src[len(src)-1] != '\n' {
		src = append(src, '\n')
	}
	return append(header(), src...)
}

func header() []byte {
	t := time.Now().UTC().Format(time.RFC3339)
	return []byte(fmt.Sprintf(";; Generated by Mochi transpiler on %s\n", t))
}

// --- Transpiler ---

// Transpile converts a Mochi program into a Clojure AST. The implementation
// is intentionally minimal and currently only supports very small programs used
// by a subset of tests.
func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	if prog == nil {
		return nil, fmt.Errorf("nil program")
	}

	pr := &Program{}

	// emit (ns main)
	pr.Forms = append(pr.Forms, &List{Elems: []Node{Symbol("ns"), Symbol("main")}})

	body := []Node{}
	for _, st := range prog.Statements {
		if st.Let != nil || st.Var != nil {
			n, err := transpileStmt(st)
			if err != nil {
				return nil, err
			}
			pr.Forms = append(pr.Forms, n)
			continue
		}
		n, err := transpileStmt(st)
		if err != nil {
			return nil, err
		}
		if n != nil {
			body = append(body, n)
		}
	}

	mainElems := []Node{Symbol("defn"), Symbol("-main"), &Vector{}}
	mainElems = append(mainElems, body...)
	pr.Forms = append(pr.Forms, &List{Elems: mainElems})

	// invoke main
	pr.Forms = append(pr.Forms, &List{Elems: []Node{Symbol("-main")}})
	return pr, nil
}

func transpileStmt(s *parser.Statement) (Node, error) {
	switch {
	case s.Expr != nil:
		return transpileExpr(s.Expr.Expr)
	case s.If != nil:
		return transpileIfStmt(s.If)
	case s.Let != nil:
		var v Node
		var err error
		if s.Let.Value != nil {
			v, err = transpileExpr(s.Let.Value)
			if err != nil {
				return nil, err
			}
		} else {
			if s.Let.Type != nil {
				v = defaultValue(s.Let.Type)
			} else {
				v = Symbol("nil")
			}
		}
		return &List{Elems: []Node{Symbol("def"), Symbol(s.Let.Name), v}}, nil
	case s.Var != nil:
		var v Node
		var err error
		if s.Var.Value != nil {
			v, err = transpileExpr(s.Var.Value)
			if err != nil {
				return nil, err
			}
		} else {
			if s.Var.Type != nil {
				v = defaultValue(s.Var.Type)
			} else {
				v = Symbol("nil")
			}
		}
		return &List{Elems: []Node{Symbol("def"), Symbol(s.Var.Name), v}}, nil
	case s.Assign != nil:
		v, err := transpileExpr(s.Assign.Value)
		if err != nil {
			return nil, err
		}
		return &List{Elems: []Node{Symbol("set!"), Symbol(s.Assign.Name), v}}, nil
	default:
		return nil, fmt.Errorf("unsupported statement")
	}
}

var binOp = map[string]string{
	"+":  "+",
	"-":  "-",
	"*":  "*",
	"/":  "/",
	"%":  "mod",
	"==": "=",
	"!=": "not=",
	"<":  "<",
	"<=": "<=",
	">":  ">",
	">=": ">=",
	"&&": "and",
	"||": "or",
}

func isStringNode(n Node) bool {
	switch t := n.(type) {
	case StringLit:
		return true
	case *List:
		if len(t.Elems) > 0 {
			if sym, ok := t.Elems[0].(Symbol); ok && sym == "str" {
				return true
			}
		}
	}
	return false
}

func transpileExpr(e *parser.Expr) (Node, error) {
	if e == nil {
		return nil, fmt.Errorf("nil expr")
	}
	if e.Binary == nil {
		return nil, fmt.Errorf("unsupported expr")
	}
	left, err := transpileUnary(e.Binary.Left)
	if err != nil {
		return nil, err
	}
	n := left
	for _, op := range e.Binary.Right {
		right, err := transpilePostfix(op.Right)
		if err != nil {
			return nil, err
		}
		sym, ok := binOp[op.Op]
		if !ok {
			return nil, fmt.Errorf("binary op not supported")
		}
		if sym == "+" && (isStringNode(n) || isStringNode(right)) {
			n = &List{Elems: []Node{Symbol("str"), n, right}}
		} else {
			n = &List{Elems: []Node{Symbol(sym), n, right}}
		}
	}
	return n, nil
}

func transpileUnary(u *parser.Unary) (Node, error) {
	if u == nil {
		return nil, fmt.Errorf("nil unary")
	}
	n, err := transpilePostfix(u.Value)
	if err != nil {
		return nil, err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		switch u.Ops[i] {
		case "-":
			n = &List{Elems: []Node{Symbol("-"), n}}
		case "!":
			n = &List{Elems: []Node{Symbol("not"), n}}
		default:
			return nil, fmt.Errorf("unary op not supported")
		}
	}
	return n, nil
}

func transpilePostfix(p *parser.PostfixExpr) (Node, error) {
	if p == nil {
		return nil, fmt.Errorf("nil postfix")
	}
	n, err := transpilePrimary(p.Target)
	if err != nil {
		return nil, err
	}
	for _, op := range p.Ops {
		switch {
		case op.Index != nil:
			idx := op.Index
			if idx.Colon != nil || idx.Colon2 != nil || idx.End != nil || idx.Step != nil {
				return nil, fmt.Errorf("slices not supported")
			}
			i, err := transpileExpr(idx.Start)
			if err != nil {
				return nil, err
			}
			n = &List{Elems: []Node{Symbol("nth"), n, i}}
		default:
			return nil, fmt.Errorf("postfix ops not supported")
		}
	}
	return n, nil
}

func transpileBlock(stmts []*parser.Statement) (Node, error) {
	if len(stmts) == 0 {
		return Symbol("nil"), nil
	}
	if len(stmts) == 1 {
		return transpileStmt(stmts[0])
	}
	elems := []Node{Symbol("do")}
	for _, st := range stmts {
		n, err := transpileStmt(st)
		if err != nil {
			return nil, err
		}
		if n != nil {
			elems = append(elems, n)
		}
	}
	return &List{Elems: elems}, nil
}

func transpileIfStmt(s *parser.IfStmt) (Node, error) {
	cond, err := transpileExpr(s.Cond)
	if err != nil {
		return nil, err
	}
	thenNode, err := transpileBlock(s.Then)
	if err != nil {
		return nil, err
	}
	var elseNode Node = Symbol("nil")
	if s.ElseIf != nil {
		elseNode, err = transpileIfStmt(s.ElseIf)
		if err != nil {
			return nil, err
		}
	} else if len(s.Else) > 0 {
		elseNode, err = transpileBlock(s.Else)
		if err != nil {
			return nil, err
		}
	}
	return &List{Elems: []Node{Symbol("if"), cond, thenNode, elseNode}}, nil
}

func transpileIfExpr(e *parser.IfExpr) (Node, error) {
	cond, err := transpileExpr(e.Cond)
	if err != nil {
		return nil, err
	}
	thenNode, err := transpileExpr(e.Then)
	if err != nil {
		return nil, err
	}
	var elseNode Node = Symbol("nil")
	if e.ElseIf != nil {
		elseNode, err = transpileIfExpr(e.ElseIf)
		if err != nil {
			return nil, err
		}
	} else if e.Else != nil {
		elseNode, err = transpileExpr(e.Else)
		if err != nil {
			return nil, err
		}
	}
	return &List{Elems: []Node{Symbol("if"), cond, thenNode, elseNode}}, nil
}

func transpilePrimary(p *parser.Primary) (Node, error) {
	if p == nil {
		return nil, fmt.Errorf("nil primary")
	}
	switch {
	case p.Call != nil:
		return transpileCall(p.Call)
	case p.Lit != nil:
		return transpileLiteral(p.Lit)
	case p.If != nil:
		return transpileIfExpr(p.If)
	case p.List != nil:
		elems := []Node{}
		for _, e := range p.List.Elems {
			n, err := transpileExpr(e)
			if err != nil {
				return nil, err
			}
			elems = append(elems, n)
		}
		return &Vector{Elems: elems}, nil
	case p.Selector != nil && len(p.Selector.Tail) == 0:
		return Symbol(p.Selector.Root), nil
	case p.Group != nil:
		return transpileExpr(p.Group)
	default:
		return nil, fmt.Errorf("unsupported primary")
	}
}

func transpileCall(c *parser.CallExpr) (Node, error) {
	elems := []Node{}
	switch c.Func {
	case "print":
		elems = append(elems, Symbol("println"))
	case "len":
		elems = append(elems, Symbol("count"))
	case "count":
		elems = append(elems, Symbol("count"))
	case "min":
		elems = append(elems, Symbol("apply"), Symbol("min"))
	case "max":
		elems = append(elems, Symbol("apply"), Symbol("max"))
	case "substring":
		elems = append(elems, Symbol("subs"))
	default:
		elems = append(elems, Symbol(c.Func))
	}
	for _, arg := range c.Args {
		a, err := transpileExpr(arg)
		if err != nil {
			return nil, err
		}
		elems = append(elems, a)
	}
	return &List{Elems: elems}, nil
}

func transpileLiteral(l *parser.Literal) (Node, error) {
	switch {
	case l.Str != nil:
		return StringLit(*l.Str), nil
	case l.Int != nil:
		return IntLit(*l.Int), nil
	case l.Bool != nil:
		if bool(*l.Bool) {
			return Symbol("true"), nil
		}
		return Symbol("false"), nil
	default:
		return nil, fmt.Errorf("unsupported literal")
	}
}

func defaultValue(t *parser.TypeRef) Node {
	if t == nil || t.Simple == nil {
		return Symbol("nil")
	}
	switch *t.Simple {
	case "int":
		return IntLit(0)
	case "float":
		return Symbol("0.0")
	case "bool":
		return Symbol("false")
	case "string":
		return StringLit("")
	default:
		return Symbol("nil")
	}
}

// Print converts the AST node n into a generic ast.Node and writes it to stdout.
func Print(n Node) {
	toAst(n).Print("")
}

// toAst recursively converts our simple AST types into a mochi/ast.Node.
func toAst(n Node) *ast.Node {
	switch t := n.(type) {
	case Symbol:
		return &ast.Node{Kind: "symbol", Value: string(t)}
	case StringLit:
		return &ast.Node{Kind: "string", Value: string(t)}
	case IntLit:
		return &ast.Node{Kind: "int", Value: int64(t)}
	case *List:
		m := &ast.Node{Kind: "list"}
		for _, el := range t.Elems {
			m.Children = append(m.Children, toAst(el))
		}
		return m
	case *Program:
		p := &ast.Node{Kind: "program"}
		for _, f := range t.Forms {
			p.Children = append(p.Children, toAst(f))
		}
		return p
	default:
		return &ast.Node{Kind: "unknown"}
	}
}
