//go:build slow

package cpp

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"mochi/ast"
	"mochi/parser"
	"mochi/types"
)

var version string

func init() {
	_, file, _, _ := runtime.Caller(0)
	root := filepath.Join(filepath.Dir(file), "../../..")
	if b, err := os.ReadFile(filepath.Join(root, "VERSION")); err == nil {
		version = strings.TrimSpace(string(b))
	} else {
		version = "unknown"
	}
}

type Program struct {
	Includes  []string
	Functions []*Func
}

type Param struct {
	Name string
	Type string
}

type Func struct {
	Name       string
	Params     []Param
	ReturnType string
	Body       []Stmt
}

type Stmt interface{ emit(io.Writer, int) }

type Expr interface{ emit(io.Writer) }

type PrintStmt struct{ Value Expr }

// WhileStmt represents a simple while loop.
type WhileStmt struct {
	Cond Expr
	Body []Stmt
}

// LenExpr represents the builtin len() for strings.
type LenExpr struct{ Value Expr }

type StringLit struct{ Value string }

type IntLit struct{ Value int }

type BoolLit struct{ Value bool }

// UnaryExpr represents a prefix unary operation like negation or logical not.
type UnaryExpr struct {
	Op   string
	Expr Expr
}

type CallExpr struct {
	Name string
	Args []Expr
}

type LambdaExpr struct {
	Params []Param
	Body   Expr
}

type ReturnStmt struct{ Value Expr }

type VarRef struct{ Name string }

type BinaryExpr struct {
	Left  Expr
	Op    string
	Right Expr
}

type LetStmt struct {
	Name  string
	Type  string
	Value Expr
}

type AssignStmt struct {
	Name  string
	Value Expr
}

type ForStmt struct {
	Var        string
	Start, End Expr
	Body       []Stmt
}

type IfStmt struct {
	Cond   Expr
	Then   []Stmt
	ElseIf *IfStmt
	Else   []Stmt
}

type IfExpr struct {
	Cond   Expr
	Then   Expr
	ElseIf *IfExpr
	Else   Expr
}

func (p *Program) Emit() []byte {
	var buf bytes.Buffer
	p.write(&buf)
	return buf.Bytes()
}

func (p *Program) write(w io.Writer) {
	v := strings.TrimSpace(version)
	loc := time.FixedZone("GMT+7", 7*3600)
	ts := time.Now().In(loc).Format("2006-01-02 15:04:05 MST")
	fmt.Fprintf(w, "// Generated by Mochi transpiler v%s on %s\n", v, ts)
	for _, inc := range p.Includes {
		fmt.Fprintf(w, "#include %s\n", inc)
	}
	fmt.Fprintln(w)
	for i, fn := range p.Functions {
		if i > 0 {
			fmt.Fprintln(w)
		}
		fn.emit(w)
	}
}

func (f *Func) emit(w io.Writer) {
	fmt.Fprintf(w, "%s %s(", f.ReturnType, f.Name)
	for i, p := range f.Params {
		if i > 0 {
			io.WriteString(w, ", ")
		}
		typ := p.Type
		if typ == "" {
			io.WriteString(w, "auto ")
		} else {
			io.WriteString(w, typ+" ")
		}
		io.WriteString(w, p.Name)
	}
	fmt.Fprintln(w, ") {")
	for _, st := range f.Body {
		st.emit(w, 1)
	}
	if f.Name == "main" {
		fmt.Fprintln(w, "    return 0;")
	}
	fmt.Fprintln(w, "}")
}

func (s *PrintStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "std::cout << ")
	s.Value.emit(w)
	io.WriteString(w, " << std::endl;\n")
}

func (wst *WhileStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "while (")
	wst.Cond.emit(w)
	io.WriteString(w, ") {\n")
	for _, st := range wst.Body {
		st.emit(w, indent+1)
	}
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "}\n")
}

func (l *LenExpr) emit(w io.Writer) {
	l.Value.emit(w)
	io.WriteString(w, ".size()")
}

func (s *StringLit) emit(w io.Writer) {
	fmt.Fprintf(w, "std::string(%q)", s.Value)
}

func (i *IntLit) emit(w io.Writer) { fmt.Fprintf(w, "%d", i.Value) }

func (b *BoolLit) emit(w io.Writer) {
	if b.Value {
		io.WriteString(w, "true")
	} else {
		io.WriteString(w, "false")
	}
}

func (u *UnaryExpr) emit(w io.Writer) {
	io.WriteString(w, u.Op)
	u.Expr.emit(w)
}

func (v *VarRef) emit(w io.Writer) { io.WriteString(w, v.Name) }

func (c *CallExpr) emit(w io.Writer) {
	io.WriteString(w, c.Name)
	io.WriteString(w, "(")
	for i, a := range c.Args {
		if i > 0 {
			io.WriteString(w, ", ")
		}
		a.emit(w)
	}
	io.WriteString(w, ")")
}

func (l *LambdaExpr) emit(w io.Writer) {
	io.WriteString(w, "[&](")
	for i, p := range l.Params {
		if i > 0 {
			io.WriteString(w, ", ")
		}
		if p.Type == "" {
			io.WriteString(w, "auto ")
		} else {
			io.WriteString(w, p.Type+" ")
		}
		io.WriteString(w, p.Name)
	}
	io.WriteString(w, ") { return ")
	l.Body.emit(w)
	io.WriteString(w, "; }")
}

func (b *BinaryExpr) emit(w io.Writer) {
	io.WriteString(w, "(")
	b.Left.emit(w)
	io.WriteString(w, " "+b.Op+" ")
	b.Right.emit(w)
	io.WriteString(w, ")")
}

func (s *LetStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	typ := s.Type
	if typ == "" {
		io.WriteString(w, "auto ")
	} else {
		io.WriteString(w, typ+" ")
	}
	io.WriteString(w, s.Name)
	if s.Value != nil {
		io.WriteString(w, " = ")
		s.Value.emit(w)
	} else if typ != "" {
		io.WriteString(w, " = ")
		io.WriteString(w, defaultValueForType(typ))
	}
	io.WriteString(w, ";\n")
}

func (a *AssignStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, a.Name)
	io.WriteString(w, " = ")
	a.Value.emit(w)
	io.WriteString(w, ";\n")
}

func (r *ReturnStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "return")
	if r.Value != nil {
		io.WriteString(w, " ")
		r.Value.emit(w)
	}
	io.WriteString(w, ";\n")
}

func (f *ForStmt) emit(w io.Writer, indent int) {
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "for (int ")
	io.WriteString(w, f.Var)
	io.WriteString(w, " = ")
	f.Start.emit(w)
	io.WriteString(w, "; ")
	io.WriteString(w, f.Var)
	io.WriteString(w, " < ")
	f.End.emit(w)
	io.WriteString(w, "; ")
	io.WriteString(w, f.Var)
	io.WriteString(w, "++ ) {\n")
	for _, st := range f.Body {
		st.emit(w, indent+1)
	}
	for i := 0; i < indent; i++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "}\n")
}

func (i *IfStmt) emit(w io.Writer, indent int) {
	for j := 0; j < indent; j++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "if (")
	i.Cond.emit(w)
	io.WriteString(w, ") {\n")
	for _, st := range i.Then {
		st.emit(w, indent+1)
	}
	for j := 0; j < indent; j++ {
		io.WriteString(w, "    ")
	}
	io.WriteString(w, "}")
	if i.ElseIf != nil {
		io.WriteString(w, " else ")
		i.ElseIf.emit(w, indent)
	} else if len(i.Else) > 0 {
		io.WriteString(w, " else {\n")
		for _, st := range i.Else {
			st.emit(w, indent+1)
		}
		for j := 0; j < indent; j++ {
			io.WriteString(w, "    ")
		}
		io.WriteString(w, "}")
	}
	io.WriteString(w, "\n")
}

func (i *IfExpr) emit(w io.Writer) {
	io.WriteString(w, "(")
	i.Cond.emit(w)
	io.WriteString(w, " ? ")
	i.Then.emit(w)
	io.WriteString(w, " : ")
	if i.ElseIf != nil {
		i.ElseIf.emit(w)
	} else if i.Else != nil {
		i.Else.emit(w)
	}
	io.WriteString(w, ")")
}

func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	_ = env
	cp := &Program{Includes: []string{"<iostream>", "<string>"}}
	var body []Stmt
	for _, stmt := range prog.Statements {
		switch {
		case stmt.Fun != nil:
			fn, err := convertFun(stmt.Fun)
			if err != nil {
				return nil, err
			}
			cp.Functions = append(cp.Functions, fn)
		case stmt.Expr != nil:
			if call := extractCall(stmt.Expr.Expr); call != nil && call.Func == "print" && len(call.Args) == 1 {
				arg, err := convertExpr(call.Args[0])
				if err != nil {
					return nil, err
				}
				body = append(body, &PrintStmt{Value: arg})
			} else {
				return nil, fmt.Errorf("unsupported expression")
			}
		case stmt.Let != nil:
			var val Expr
			var err error
			if stmt.Let.Value != nil {
				val, err = convertExpr(stmt.Let.Value)
				if err != nil {
					return nil, err
				}
			}
			typ := ""
			if stmt.Let.Type != nil && stmt.Let.Type.Simple != nil {
				typ = cppType(*stmt.Let.Type.Simple)
			}
			body = append(body, &LetStmt{Name: stmt.Let.Name, Type: typ, Value: val})
		case stmt.Var != nil:
			var val Expr
			var err error
			if stmt.Var.Value != nil {
				val, err = convertExpr(stmt.Var.Value)
				if err != nil {
					return nil, err
				}
			}
			typ := ""
			if stmt.Var.Type != nil && stmt.Var.Type.Simple != nil {
				typ = cppType(*stmt.Var.Type.Simple)
			}
			body = append(body, &LetStmt{Name: stmt.Var.Name, Type: typ, Value: val})
		case stmt.Assign != nil:
			val, err := convertExpr(stmt.Assign.Value)
			if err != nil {
				return nil, err
			}
			body = append(body, &AssignStmt{Name: stmt.Assign.Name, Value: val})
		case stmt.For != nil:
			start, err := convertExpr(stmt.For.Source)
			if err != nil {
				return nil, err
			}
			end, err := convertExpr(stmt.For.RangeEnd)
			if err != nil {
				return nil, err
			}
			fs := &ForStmt{Var: stmt.For.Name, Start: start, End: end}
			for _, s := range stmt.For.Body {
				st, err := convertStmt(s)
				if err != nil {
					return nil, err
				}
				fs.Body = append(fs.Body, st)
			}
			body = append(body, fs)
		case stmt.While != nil:
			ws, err := convertWhileStmt(stmt.While)
			if err != nil {
				return nil, err
			}
			body = append(body, ws)
		case stmt.If != nil:
			ifs, err := convertIfStmt(stmt.If)
			if err != nil {
				return nil, err
			}
			body = append(body, ifs)
		default:
			return nil, fmt.Errorf("unsupported statement")
		}
	}
	cp.Functions = append(cp.Functions, &Func{Name: "main", ReturnType: "int", Body: body})
	return cp, nil
}

func extractCall(e *parser.Expr) *parser.CallExpr {
	if e == nil || e.Binary == nil || e.Binary.Left == nil {
		return nil
	}
	u := e.Binary.Left
	if u.Value == nil || u.Value.Target == nil || u.Value.Target.Call == nil {
		return nil
	}
	return u.Value.Target.Call
}

func convertStmt(s *parser.Statement) (Stmt, error) {
	switch {
	case s.Expr != nil:
		if call := extractCall(s.Expr.Expr); call != nil && call.Func == "print" && len(call.Args) == 1 {
			arg, err := convertExpr(call.Args[0])
			if err != nil {
				return nil, err
			}
			return &PrintStmt{Value: arg}, nil
		}
	case s.Let != nil:
		var val Expr
		var err error
		if s.Let.Value != nil {
			val, err = convertExpr(s.Let.Value)
			if err != nil {
				return nil, err
			}
		}
		typ := ""
		if s.Let.Type != nil && s.Let.Type.Simple != nil {
			typ = cppType(*s.Let.Type.Simple)
		}
		return &LetStmt{Name: s.Let.Name, Type: typ, Value: val}, nil
	case s.Var != nil:
		var val Expr
		var err error
		if s.Var.Value != nil {
			val, err = convertExpr(s.Var.Value)
			if err != nil {
				return nil, err
			}
		}
		typ := ""
		if s.Var.Type != nil && s.Var.Type.Simple != nil {
			typ = cppType(*s.Var.Type.Simple)
		}
		return &LetStmt{Name: s.Var.Name, Type: typ, Value: val}, nil
	case s.Assign != nil:
		val, err := convertExpr(s.Assign.Value)
		if err != nil {
			return nil, err
		}
		return &AssignStmt{Name: s.Assign.Name, Value: val}, nil
	case s.Return != nil:
		var val Expr
		if s.Return.Value != nil {
			var err error
			val, err = convertExpr(s.Return.Value)
			if err != nil {
				return nil, err
			}
		}
		return &ReturnStmt{Value: val}, nil
	case s.If != nil:
		return convertIfStmt(s.If)
	case s.While != nil:
		return convertWhileStmt(s.While)
	}
	return nil, fmt.Errorf("unsupported statement")
}

func convertExpr(e *parser.Expr) (Expr, error) {
	if e == nil {
		return nil, fmt.Errorf("nil expr")
	}
	return convertBinary(e.Binary)
}

func convertBinary(b *parser.BinaryExpr) (Expr, error) {
	left, err := convertUnary(b.Left)
	if err != nil {
		return nil, err
	}
	if len(b.Right) == 0 {
		return left, nil
	}
	expr := left
	for _, op := range b.Right {
		right, err := convertPostfix(op.Right)
		if err != nil {
			return nil, err
		}
		expr = &BinaryExpr{Left: expr, Op: op.Op, Right: right}
	}
	return expr, nil
}

func convertUnary(u *parser.Unary) (Expr, error) {
	if u == nil {
		return nil, fmt.Errorf("nil unary")
	}
	expr, err := convertPostfix(u.Value)
	if err != nil {
		return nil, err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		op := u.Ops[i]
		expr = &UnaryExpr{Op: op, Expr: expr}
	}
	return expr, nil
}

func convertPostfix(p *parser.PostfixExpr) (Expr, error) {
	if len(p.Ops) > 0 {
		return nil, fmt.Errorf("postfix ops not supported")
	}
	return convertPrimary(p.Target)
}

func convertIfStmt(is *parser.IfStmt) (*IfStmt, error) {
	cond, err := convertExpr(is.Cond)
	if err != nil {
		return nil, err
	}
	var then []Stmt
	for _, st := range is.Then {
		cs, err := convertStmt(st)
		if err != nil {
			return nil, err
		}
		then = append(then, cs)
	}
	var elseStmts []Stmt
	if is.Else != nil {
		for _, st := range is.Else {
			cs, err := convertStmt(st)
			if err != nil {
				return nil, err
			}
			elseStmts = append(elseStmts, cs)
		}
	}
	var elseIf *IfStmt
	if is.ElseIf != nil {
		ei, err := convertIfStmt(is.ElseIf)
		if err != nil {
			return nil, err
		}
		elseIf = ei
	}
	return &IfStmt{Cond: cond, Then: then, ElseIf: elseIf, Else: elseStmts}, nil
}

func convertWhileStmt(ws *parser.WhileStmt) (*WhileStmt, error) {
	cond, err := convertExpr(ws.Cond)
	if err != nil {
		return nil, err
	}
	var body []Stmt
	for _, st := range ws.Body {
		cs, err := convertStmt(st)
		if err != nil {
			return nil, err
		}
		body = append(body, cs)
	}
	return &WhileStmt{Cond: cond, Body: body}, nil
}

func convertFun(fn *parser.FunStmt) (*Func, error) {
	var body []Stmt
	for _, st := range fn.Body {
		s, err := convertStmt(st)
		if err != nil {
			return nil, err
		}
		body = append(body, s)
	}
	var params []Param
	for _, p := range fn.Params {
		typ := ""
		if p.Type != nil && p.Type.Simple != nil {
			typ = cppType(*p.Type.Simple)
		}
		params = append(params, Param{Name: p.Name, Type: typ})
	}
	ret := "int"
	if fn.Return != nil && fn.Return.Simple != nil {
		ret = cppType(*fn.Return.Simple)
	} else if fn.Return == nil {
		ret = "void"
	}
	return &Func{Name: fn.Name, Params: params, ReturnType: ret, Body: body}, nil
}

func convertPrimary(p *parser.Primary) (Expr, error) {
	switch {
	case p.Lit != nil:
		return convertLiteral(p.Lit)
	case p.Call != nil:
		if p.Call.Func == "len" && len(p.Call.Args) == 1 {
			arg, err := convertExpr(p.Call.Args[0])
			if err != nil {
				return nil, err
			}
			return &LenExpr{Value: arg}, nil
		}
		var args []Expr
		for _, a := range p.Call.Args {
			ce, err := convertExpr(a)
			if err != nil {
				return nil, err
			}
			args = append(args, ce)
		}
		return &CallExpr{Name: p.Call.Func, Args: args}, nil
	case p.Selector != nil && len(p.Selector.Tail) == 0:
		return &VarRef{Name: p.Selector.Root}, nil
	case p.If != nil:
		return convertIfExpr(p.If)
	case p.FunExpr != nil && p.FunExpr.ExprBody != nil:
		var params []Param
		for _, pa := range p.FunExpr.Params {
			typ := ""
			if pa.Type != nil && pa.Type.Simple != nil {
				typ = cppType(*pa.Type.Simple)
			}
			params = append(params, Param{Name: pa.Name, Type: typ})
		}
		body, err := convertExpr(p.FunExpr.ExprBody)
		if err != nil {
			return nil, err
		}
		return &LambdaExpr{Params: params, Body: body}, nil
	case p.Group != nil:
		return convertExpr(p.Group)
	default:
		return nil, fmt.Errorf("unsupported expression")
	}
}

func convertLiteral(l *parser.Literal) (Expr, error) {
	switch {
	case l.Str != nil:
		return &StringLit{Value: *l.Str}, nil
	case l.Int != nil:
		return &IntLit{Value: int(*l.Int)}, nil
	case l.Bool != nil:
		return &BoolLit{Value: bool(*l.Bool)}, nil
	default:
		return nil, fmt.Errorf("unsupported literal")
	}
}

func convertIfExpr(ie *parser.IfExpr) (*IfExpr, error) {
	cond, err := convertExpr(ie.Cond)
	if err != nil {
		return nil, err
	}
	thenExpr, err := convertExpr(ie.Then)
	if err != nil {
		return nil, err
	}
	var elseExpr Expr
	var elseIf *IfExpr
	if ie.ElseIf != nil {
		ei, err := convertIfExpr(ie.ElseIf)
		if err != nil {
			return nil, err
		}
		elseIf = ei
	} else if ie.Else != nil {
		elseExpr, err = convertExpr(ie.Else)
		if err != nil {
			return nil, err
		}
	}
	return &IfExpr{Cond: cond, Then: thenExpr, ElseIf: elseIf, Else: elseExpr}, nil
}

func cppType(t string) string {
	switch t {
	case "int":
		return "int"
	case "float":
		return "double"
	case "bool":
		return "bool"
	case "string":
		return "std::string"
	}
	return "auto"
}

func defaultValueForType(t string) string {
	switch t {
	case "int", "double":
		return "0"
	case "bool":
		return "false"
	case "std::string":
		return "\"\""
	}
	return "{}"
}

// print writes a Lisp-like representation of the transpiler AST to stdout.
// It first converts the internal structs to ast.Node using the mochi/ast
// package, then prints the result.
func print(prog *Program) {
	n := prog.toNode()
	fmt.Print(n.String())
}

func (p *Program) toNode() *ast.Node {
	root := &ast.Node{Kind: "program"}
	for _, fn := range p.Functions {
		root.Children = append(root.Children, fn.toNode())
	}
	return root
}

func (f *Func) toNode() *ast.Node {
	n := &ast.Node{Kind: "func", Value: f.Name}
	for _, st := range f.Body {
		n.Children = append(n.Children, toStmtNode(st))
	}
	return n
}

func toStmtNode(s Stmt) *ast.Node {
	switch st := s.(type) {
	case *PrintStmt:
		return &ast.Node{Kind: "print", Children: []*ast.Node{toExprNode(st.Value)}}
	case *LetStmt:
		n := &ast.Node{Kind: "let", Value: st.Name}
		if st.Value != nil {
			n.Children = []*ast.Node{toExprNode(st.Value)}
		}
		return n
	case *AssignStmt:
		return &ast.Node{Kind: "assign", Value: st.Name, Children: []*ast.Node{toExprNode(st.Value)}}
	case *WhileStmt:
		n := &ast.Node{Kind: "while"}
		n.Children = append(n.Children, toExprNode(st.Cond))
		for _, b := range st.Body {
			n.Children = append(n.Children, toStmtNode(b))
		}
		return n
	case *ForStmt:
		n := &ast.Node{Kind: "for", Value: st.Var}
		n.Children = append(n.Children, toExprNode(st.Start))
		n.Children = append(n.Children, toExprNode(st.End))
		for _, b := range st.Body {
			n.Children = append(n.Children, toStmtNode(b))
		}
		return n
	case *IfStmt:
		n := &ast.Node{Kind: "if"}
		n.Children = append(n.Children, toExprNode(st.Cond))
		then := &ast.Node{Kind: "then"}
		for _, b := range st.Then {
			then.Children = append(then.Children, toStmtNode(b))
		}
		n.Children = append(n.Children, then)
		if st.ElseIf != nil {
			n.Children = append(n.Children, toStmtNode(st.ElseIf))
		}
		if len(st.Else) > 0 {
			els := &ast.Node{Kind: "else"}
			for _, b := range st.Else {
				els.Children = append(els.Children, toStmtNode(b))
			}
			n.Children = append(n.Children, els)
		}
		return n
	case *ReturnStmt:
		n := &ast.Node{Kind: "return"}
		if st.Value != nil {
			n.Children = []*ast.Node{toExprNode(st.Value)}
		}
		return n
	default:
		return &ast.Node{Kind: "stmt"}
	}
}

func toExprNode(e Expr) *ast.Node {
	switch ex := e.(type) {
	case *StringLit:
		return &ast.Node{Kind: "str", Value: ex.Value}
	case *IntLit:
		return &ast.Node{Kind: "int", Value: ex.Value}
	case *BoolLit:
		return &ast.Node{Kind: "bool", Value: ex.Value}
	case *VarRef:
		return &ast.Node{Kind: "var", Value: ex.Name}
	case *BinaryExpr:
		return &ast.Node{Kind: ex.Op, Children: []*ast.Node{toExprNode(ex.Left), toExprNode(ex.Right)}}
	case *UnaryExpr:
		return &ast.Node{Kind: ex.Op, Children: []*ast.Node{toExprNode(ex.Expr)}}
	case *LenExpr:
		return &ast.Node{Kind: "len", Children: []*ast.Node{toExprNode(ex.Value)}}
	case *CallExpr:
		n := &ast.Node{Kind: "call", Value: ex.Name}
		for _, a := range ex.Args {
			n.Children = append(n.Children, toExprNode(a))
		}
		return n
	case *LambdaExpr:
		n := &ast.Node{Kind: "lambda"}
		for _, p := range ex.Params {
			n.Children = append(n.Children, &ast.Node{Kind: "param", Value: p.Name})
		}
		n.Children = append(n.Children, toExprNode(ex.Body))
		return n
	case *IfExpr:
		n := &ast.Node{Kind: "ifexpr"}
		n.Children = append(n.Children, toExprNode(ex.Cond))
		n.Children = append(n.Children, toExprNode(ex.Then))
		if ex.ElseIf != nil {
			n.Children = append(n.Children, toExprNode(ex.ElseIf))
		}
		if ex.Else != nil {
			n.Children = append(n.Children, toExprNode(ex.Else))
		}
		return n
	default:
		return &ast.Node{Kind: "expr"}
	}
}
