//go:build slow

package fortran

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"mochi/parser"
	"mochi/types"
)

type Decl struct {
	Name string
	Type string
	Init string
}

type Program struct {
	Decls []Decl
	Stmts []Stmt
}

type Stmt interface{ emit(io.Writer) }

type IfStmt struct {
	Cond string
	Then []Stmt
	Else []Stmt
}

type WhileStmt struct {
	Cond string
	Body []Stmt
}

type AssignStmt struct{ Name, Expr string }

type PrintStmt struct {
	Expr string
	Typ  types.Type
}

func (s *AssignStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "  %s = %s\n", s.Name, s.Expr)
}

func (p *PrintStmt) emit(w io.Writer) {
	switch p.Typ.(type) {
	case types.IntType, types.Int64Type, types.BigIntType:
		fmt.Fprintf(w, "  print '(I0)', %s\n", p.Expr)
	case types.FloatType, types.BigRatType:
		fmt.Fprintf(w, "  print '(F0.6)', %s\n", p.Expr)
	case types.BoolType:
		fmt.Fprintf(w, "  print '(I0)', merge(1,0,%s)\n", p.Expr)
	case types.StringType:
		fmt.Fprintf(w, "  print *, trim(%s)\n", p.Expr)
	default:
		fmt.Fprintf(w, "  print *, %s\n", p.Expr)
	}
}

func (s *IfStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "  if (%s) then\n", s.Cond)
	for _, st := range s.Then {
		st.emit(w)
	}
	if len(s.Else) > 0 {
		io.WriteString(w, "  else\n")
		for _, st := range s.Else {
			st.emit(w)
		}
	}
	io.WriteString(w, "  end if\n")
}

func (s *WhileStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "  do while (%s)\n", s.Cond)
	for _, st := range s.Body {
		st.emit(w)
	}
	io.WriteString(w, "  end do\n")
}

func repoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func version() string {
	root := repoRoot()
	if root == "" {
		return "dev"
	}
	b, err := os.ReadFile(filepath.Join(root, "VERSION"))
	if err != nil {
		return "dev"
	}
	return strings.TrimSpace(string(b))
}

func header() string {
	loc := time.FixedZone("GMT+7", 7*3600)
	t := time.Now().In(loc)
	return fmt.Sprintf("! Generated by Mochi transpiler v%s on %s\n", version(), t.Format("2006-01-02 15:04:05 MST"))
}

func (p *Program) Emit() []byte {
	var buf bytes.Buffer
	buf.WriteString(header())
	buf.WriteString("program main\n")
	for _, d := range p.Decls {
		fmt.Fprintf(&buf, "  %s :: %s", d.Type, d.Name)
		if d.Init != "" {
			fmt.Fprintf(&buf, " = %s", d.Init)
		}
		buf.WriteByte('\n')
	}
	for _, s := range p.Stmts {
		s.emit(&buf)
	}
	buf.WriteString("end program main\n")
	return buf.Bytes()
}

func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	fp := &Program{}
	for _, st := range prog.Statements {
		stmt, err := compileStmt(fp, st, env)
		if err != nil {
			return nil, err
		}
		if stmt != nil {
			fp.Stmts = append(fp.Stmts, stmt)
		}
	}
	return fp, nil
}

func compileStmt(p *Program, st *parser.Statement, env *types.Env) (Stmt, error) {
	switch {
	case st.Let != nil:
		expr := ""
		var err error
		if st.Let.Value != nil {
			expr, err = toExpr(st.Let.Value, env)
			if err != nil {
				return nil, err
			}
		}
		if st.Let.Type != nil || st.Let.Value != nil {
			var typ types.Type = types.AnyType{}
			if st.Let.Type != nil {
				typ = types.ResolveTypeRef(st.Let.Type, env)
			} else {
				typ = types.TypeOfExprBasic(st.Let.Value, env)
			}
			ft, err := mapTypeName(typ)
			if err != nil {
				return nil, err
			}
			init := expr
			if init == "" {
				init = defaultValue(typ)
			}
			p.Decls = append(p.Decls, Decl{Name: st.Let.Name, Type: ft, Init: init})
			return nil, nil
		}
		return nil, fmt.Errorf("unsupported let statement")
	case st.Var != nil:
		expr := ""
		var err error
		if st.Var.Value != nil {
			expr, err = toExpr(st.Var.Value, env)
			if err != nil {
				return nil, err
			}
		}
		var typ types.Type = types.AnyType{}
		if st.Var.Type != nil {
			typ = types.ResolveTypeRef(st.Var.Type, env)
		} else if st.Var.Value != nil {
			typ = types.TypeOfExprBasic(st.Var.Value, env)
		}
		ft, err := mapTypeName(typ)
		if err != nil {
			return nil, err
		}
		init := expr
		if init == "" {
			init = defaultValue(typ)
		}
		p.Decls = append(p.Decls, Decl{Name: st.Var.Name, Type: ft, Init: init})
		return nil, nil
	case st.Assign != nil:
		if len(st.Assign.Index) > 0 || len(st.Assign.Field) > 0 {
			return nil, fmt.Errorf("unsupported assignment")
		}
		expr, err := toExpr(st.Assign.Value, env)
		if err != nil {
			return nil, err
		}
		return &AssignStmt{Name: st.Assign.Name, Expr: expr}, nil
	case st.Expr != nil:
		arg, err := extractPrintArg(st.Expr.Expr)
		if err != nil {
			return nil, err
		}
		expr, err := toExpr(arg, env)
		if err != nil {
			return nil, err
		}
		typ := types.TypeOfExprBasic(arg, env)
		return &PrintStmt{Expr: expr, Typ: typ}, nil
	case st.If != nil:
		if st.If.ElseIf != nil {
			return nil, fmt.Errorf("elseif not supported")
		}
		cond, err := toExpr(st.If.Cond, env)
		if err != nil {
			return nil, err
		}
		thenStmts, err := compileStmtList(p, st.If.Then, env)
		if err != nil {
			return nil, err
		}
		var elseStmts []Stmt
		if len(st.If.Else) > 0 {
			elseStmts, err = compileStmtList(p, st.If.Else, env)
			if err != nil {
				return nil, err
			}
		}
		return &IfStmt{Cond: cond, Then: thenStmts, Else: elseStmts}, nil
	case st.While != nil:
		cond, err := toExpr(st.While.Cond, env)
		if err != nil {
			return nil, err
		}
		body, err := compileStmtList(p, st.While.Body, env)
		if err != nil {
			return nil, err
		}
		return &WhileStmt{Cond: cond, Body: body}, nil
	default:
		return nil, fmt.Errorf("unsupported statement")
	}
}

func compileStmtList(p *Program, list []*parser.Statement, env *types.Env) ([]Stmt, error) {
	var out []Stmt
	for _, s := range list {
		stmt, err := compileStmt(p, s, env)
		if err != nil {
			return nil, err
		}
		if stmt != nil {
			out = append(out, stmt)
		}
	}
	return out, nil
}

func extractPrintArg(e *parser.Expr) (*parser.Expr, error) {
	if e == nil || e.Binary == nil || e.Binary.Left == nil {
		return nil, fmt.Errorf("unsupported expression")
	}
	u := e.Binary.Left
	if u.Value == nil || u.Value.Target == nil || u.Value.Target.Call == nil {
		return nil, fmt.Errorf("unsupported expression")
	}
	call := u.Value.Target.Call
	if call.Func != "print" || len(call.Args) != 1 {
		return nil, fmt.Errorf("unsupported expression")
	}
	return call.Args[0], nil
}

func toExpr(e *parser.Expr, env *types.Env) (string, error) {
	if e == nil || e.Binary == nil || e.Binary.Left == nil {
		return "", fmt.Errorf("unsupported expression")
	}
	left, err := toUnary(e.Binary.Left, env)
	if err != nil {
		return "", err
	}
	expr := left
	leftType := types.TypeOfPostfixBasic(e.Binary.Left, env)
	for _, op := range e.Binary.Right {
		rhs, err := toPostfix(op.Right, env)
		if err != nil {
			return "", err
		}
		rightType := types.TypeOfPostfixBasic(&parser.Unary{Value: op.Right}, env)
		opStr, err := mapOp(op.Op, leftType, rightType)
		if err != nil {
			return "", err
		}
		if opStr == "mod" {
			expr = fmt.Sprintf("mod(%s, %s)", expr, rhs)
		} else {
			expr = fmt.Sprintf("(%s %s %s)", expr, opStr, rhs)
		}
		switch op.Op {
		case "==", "!=", "<", "<=", ">", ">=", "&&", "||":
			leftType = types.BoolType{}
		case "+":
			if types.IsStringType(leftType) && types.IsStringType(rightType) {
				leftType = types.StringType{}
			}
		}
	}
	return expr, nil
}

func mapOp(op string, left, right types.Type) (string, error) {
	switch op {
	case "+", "-", "*", "/":
		if op == "+" && types.IsStringType(left) && types.IsStringType(right) {
			return "//", nil
		}
		return op, nil
	case "%":
		return "mod", nil
	case "==":
		return "==", nil
	case "!=":
		return "/=", nil
	case "<", "<=", ">", ">=":
		return op, nil
	case "&&":
		return ".and.", nil
	case "||":
		return ".or.", nil
	default:
		return "", fmt.Errorf("unsupported op %s", op)
	}
}

func toUnary(u *parser.Unary, env *types.Env) (string, error) {
	val, err := toPostfix(u.Value, env)
	if err != nil {
		return "", err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		switch u.Ops[i] {
		case "-":
			val = "-" + val
		case "!":
			val = ".not." + val
		default:
			return "", fmt.Errorf("unsupported unary %s", u.Ops[i])
		}
	}
	return val, nil
}

func toPostfix(pf *parser.PostfixExpr, env *types.Env) (string, error) {
	if len(pf.Ops) > 0 {
		return "", fmt.Errorf("postfix operations unsupported")
	}
	return toPrimary(pf.Target, env)
}

func toPrimary(p *parser.Primary, env *types.Env) (string, error) {
	switch {
	case p.Lit != nil:
		l := p.Lit
		if l.Int != nil {
			return strconv.Itoa(int(*l.Int)), nil
		}
		if l.Bool != nil {
			if bool(*l.Bool) {
				return ".true.", nil
			}
			return ".false.", nil
		}
		if l.Str != nil {
			s := strings.ReplaceAll(*l.Str, "\"", "\"\"")
			return fmt.Sprintf("\"%s\"", s), nil
		}
	case p.Selector != nil:
		name := p.Selector.Root
		if len(p.Selector.Tail) > 0 {
			name += "_" + strings.Join(p.Selector.Tail, "_")
		}
		return name, nil
	case p.Group != nil:
		expr, err := toExpr(p.Group, env)
		if err != nil {
			return "", err
		}
		return "(" + expr + ")", nil
	}
	return "", fmt.Errorf("unsupported expression")
}

func mapTypeName(t types.Type) (string, error) {
	switch t.(type) {
	case types.IntType, types.Int64Type, types.BigIntType:
		return "integer", nil
	case types.FloatType, types.BigRatType:
		return "real", nil
	case types.StringType:
		return "character(len=100)", nil
	case types.BoolType:
		return "logical", nil
	default:
		return "", fmt.Errorf("unsupported type %s", t.String())
	}
}

func defaultValue(t types.Type) string {
	switch t.(type) {
	case types.IntType, types.Int64Type, types.BigIntType:
		return "0"
	case types.FloatType, types.BigRatType:
		return "0.0"
	case types.BoolType:
		return ".false."
	case types.StringType:
		return "\"\""
	default:
		return ""
	}
}
