//go:build slow

package fortran

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"mochi/parser"
	"mochi/types"
)

type Decl struct {
	Name string
	Type string
	Init string
}

type Program struct {
	Decls []Decl
	Stmts []Stmt
}

type Stmt interface{ emit(io.Writer) }

type AssignStmt struct{ Name, Expr string }

type PrintStmt struct{ Expr string }

func (s *AssignStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "  %s = %s\n", s.Name, s.Expr)
}

func (p *PrintStmt) emit(w io.Writer) {
	fmt.Fprintf(w, "  print *, %s\n", p.Expr)
}

func repoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}

func version() string {
	root := repoRoot()
	if root == "" {
		return "dev"
	}
	b, err := os.ReadFile(filepath.Join(root, "VERSION"))
	if err != nil {
		return "dev"
	}
	return strings.TrimSpace(string(b))
}

func header() string {
	loc := time.FixedZone("GMT+7", 7*3600)
	t := time.Now().In(loc)
	return fmt.Sprintf("! Generated by Mochi transpiler v%s on %s\n", version(), t.Format("2006-01-02 15:04:05 MST"))
}

func (p *Program) Emit() []byte {
	var buf bytes.Buffer
	buf.WriteString(header())
	buf.WriteString("program main\n")
	for _, d := range p.Decls {
		fmt.Fprintf(&buf, "  %s :: %s", d.Type, d.Name)
		if d.Init != "" {
			fmt.Fprintf(&buf, " = %s", d.Init)
		}
		buf.WriteByte('\n')
	}
	for _, s := range p.Stmts {
		s.emit(&buf)
	}
	buf.WriteString("end program main\n")
	return buf.Bytes()
}

func Transpile(prog *parser.Program, env *types.Env) (*Program, error) {
	_ = env
	fp := &Program{}
	for _, st := range prog.Statements {
		switch {
		case st.Let != nil:
			expr := ""
			var err error
			if st.Let.Value != nil {
				expr, err = toExpr(st.Let.Value)
				if err != nil {
					return nil, err
				}
			}
			if st.Let.Type != nil || st.Let.Value != nil {
				var typ types.Type = types.AnyType{}
				if st.Let.Type != nil {
					typ = types.ResolveTypeRef(st.Let.Type, env)
				} else {
					typ = types.TypeOfExprBasic(st.Let.Value, env)
				}
				ft, err := mapTypeName(typ)
				if err != nil {
					return nil, err
				}
				init := expr
				if init == "" {
					init = defaultValue(typ)
				}
				fp.Decls = append(fp.Decls, Decl{Name: st.Let.Name, Type: ft, Init: init})
			} else {
				return nil, fmt.Errorf("unsupported let statement")
			}
		case st.Var != nil:
			expr := ""
			var err error
			if st.Var.Value != nil {
				expr, err = toExpr(st.Var.Value)
				if err != nil {
					return nil, err
				}
			}
			var typ types.Type = types.AnyType{}
			if st.Var.Type != nil {
				typ = types.ResolveTypeRef(st.Var.Type, env)
			} else if st.Var.Value != nil {
				typ = types.TypeOfExprBasic(st.Var.Value, env)
			}
			ft, err := mapTypeName(typ)
			if err != nil {
				return nil, err
			}
			init := expr
			if init == "" {
				init = defaultValue(typ)
			}
			fp.Decls = append(fp.Decls, Decl{Name: st.Var.Name, Type: ft, Init: init})
		case st.Assign != nil:
			if len(st.Assign.Index) > 0 || len(st.Assign.Field) > 0 {
				return nil, fmt.Errorf("unsupported assignment")
			}
			expr, err := toExpr(st.Assign.Value)
			if err != nil {
				return nil, err
			}
			fp.Stmts = append(fp.Stmts, &AssignStmt{Name: st.Assign.Name, Expr: expr})
		case st.Expr != nil:
			arg, err := extractPrintArg(st.Expr.Expr)
			if err != nil {
				return nil, err
			}
			expr, err := toExpr(arg)
			if err != nil {
				return nil, err
			}
			fp.Stmts = append(fp.Stmts, &PrintStmt{Expr: expr})
		default:
			return nil, fmt.Errorf("unsupported statement")
		}
	}
	return fp, nil
}

func extractPrintArg(e *parser.Expr) (*parser.Expr, error) {
	if e == nil || e.Binary == nil || e.Binary.Left == nil {
		return nil, fmt.Errorf("unsupported expression")
	}
	u := e.Binary.Left
	if u.Value == nil || u.Value.Target == nil || u.Value.Target.Call == nil {
		return nil, fmt.Errorf("unsupported expression")
	}
	call := u.Value.Target.Call
	if call.Func != "print" || len(call.Args) != 1 {
		return nil, fmt.Errorf("unsupported expression")
	}
	return call.Args[0], nil
}

func toExpr(e *parser.Expr) (string, error) {
	if e == nil || e.Binary == nil || e.Binary.Left == nil {
		return "", fmt.Errorf("unsupported expression")
	}
	left, err := toUnary(e.Binary.Left)
	if err != nil {
		return "", err
	}
	expr := left
	for _, op := range e.Binary.Right {
		rhs, err := toPostfix(op.Right)
		if err != nil {
			return "", err
		}
		opStr, err := mapOp(op.Op)
		if err != nil {
			return "", err
		}
		if opStr == "mod" {
			expr = fmt.Sprintf("mod(%s, %s)", expr, rhs)
		} else {
			expr = fmt.Sprintf("(%s %s %s)", expr, opStr, rhs)
		}
	}
	return expr, nil
}

func mapOp(op string) (string, error) {
	switch op {
	case "+", "-", "*", "/":
		return op, nil
	case "%":
		return "mod", nil
	case "==":
		return "==", nil
	case "!=":
		return "/=", nil
	case "<", "<=", ">", ">=":
		return op, nil
	case "&&":
		return ".and.", nil
	case "||":
		return ".or.", nil
	default:
		return "", fmt.Errorf("unsupported op %s", op)
	}
}

func toUnary(u *parser.Unary) (string, error) {
	val, err := toPostfix(u.Value)
	if err != nil {
		return "", err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		switch u.Ops[i] {
		case "-":
			val = "-" + val
		case "!":
			val = ".not." + val
		default:
			return "", fmt.Errorf("unsupported unary %s", u.Ops[i])
		}
	}
	return val, nil
}

func toPostfix(pf *parser.PostfixExpr) (string, error) {
	if len(pf.Ops) > 0 {
		return "", fmt.Errorf("postfix operations unsupported")
	}
	return toPrimary(pf.Target)
}

func toPrimary(p *parser.Primary) (string, error) {
	switch {
	case p.Lit != nil:
		l := p.Lit
		if l.Int != nil {
			return strconv.Itoa(int(*l.Int)), nil
		}
		if l.Bool != nil {
			if bool(*l.Bool) {
				return ".true.", nil
			}
			return ".false.", nil
		}
		if l.Str != nil {
			s := strings.ReplaceAll(*l.Str, "\"", "\"\"")
			return fmt.Sprintf("\"%s\"", s), nil
		}
	case p.Selector != nil:
		name := p.Selector.Root
		if len(p.Selector.Tail) > 0 {
			name += "_" + strings.Join(p.Selector.Tail, "_")
		}
		return name, nil
	case p.Group != nil:
		expr, err := toExpr(p.Group)
		if err != nil {
			return "", err
		}
		return "(" + expr + ")", nil
	}
	return "", fmt.Errorf("unsupported expression")
}

func mapTypeName(t types.Type) (string, error) {
	switch t.(type) {
	case types.IntType, types.Int64Type, types.BigIntType:
		return "integer", nil
	case types.FloatType, types.BigRatType:
		return "real", nil
	case types.StringType:
		return "character(len=100)", nil
	case types.BoolType:
		return "logical", nil
	default:
		return "", fmt.Errorf("unsupported type %s", t.String())
	}
}

func defaultValue(t types.Type) string {
	switch t.(type) {
	case types.IntType, types.Int64Type, types.BigIntType:
		return "0"
	case types.FloatType, types.BigRatType:
		return "0.0"
	case types.BoolType:
		return ".false."
	case types.StringType:
		return "\"\""
	default:
		return ""
	}
}
