# Generated by Mochi Python compiler
from __future__ import annotations

import dataclasses
import typing

def buildTree(inorder: list[int], postorder: list[int]) -> Tree:
	if (len(inorder) == 0):
		return Leaf()
	rootVal = postorder[(len(postorder) - 1)]
	idx = 0
	while ((idx < len(inorder)) and (inorder[idx] != rootVal)):
		idx = (idx + 1)
	leftIn = inorder[0:idx]
	rightIn = inorder[(idx + 1):len(inorder)]
	leftPost = postorder[0:idx]
	rightPost = postorder[idx:(len(postorder) - 1)]
	return Node(left=buildTree(leftIn, leftPost), value=rootVal, right=buildTree(rightIn, rightPost))

def isSameTree(a: Tree, b: Tree) -> bool:
	return (lambda _t=a: (lambda _t=b: True if isinstance(_t, Leaf) else False)() if isinstance(_t, Leaf) else (lambda al, av, ar: (lambda _t=b: (lambda bl, bv, br: (((av == bv) and isSameTree(al, bl)) and isSameTree(ar, br)))(_t.left, _t.value, _t.right) if isinstance(_t, Node) else False)())(_t.left, _t.value, _t.right) if isinstance(_t, Node) else None)()

class Tree:
	pass
@dataclasses.dataclass
class Leaf(Tree):
	pass
@dataclasses.dataclass
class Node(Tree):
	left: typing.Any
	value: int
	right: typing.Any

def example_1():
	inorder = [9, 3, 15, 20, 7]
	postorder = [9, 15, 7, 20, 3]
	expected = Node(left=Node(left=Leaf(), value=9, right=Leaf()), value=3, right=Node(left=Node(left=Leaf(), value=15, right=Leaf()), value=20, right=Node(left=Leaf(), value=7, right=Leaf())))
	assert (isSameTree(buildTree(inorder, postorder), expected) == True)

def example_2():
	inorder = [(-1)]
	postorder = [(-1)]
	expected = Node(left=Leaf(), value=(-1), right=Leaf())
	assert (isSameTree(buildTree(inorder, postorder), expected) == True)

def empty():
	result = buildTree([], [])
	assert (lambda _t=result: True if isinstance(_t, Leaf) else False)()

def main():
	example_1()
	example_2()
	empty()

if __name__ == "__main__":
	main()
