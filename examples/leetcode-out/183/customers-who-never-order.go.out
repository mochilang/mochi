package main

import (
	"fmt"
	"reflect"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

type Customer struct {
	Id int `json:"id"`
	Name string `json:"name"`
}

type Order struct {
	Id int `json:"id"`
	CustomerId int `json:"customerId"`
}

func customersWithoutOrders(customers []Customer, orders []Order) []string {
	var result []string = []string{}
	for _, c := range customers {
		var placed bool = false
		for _, o := range orders {
			if (o.CustomerId == c.Id) {
				placed = true
				break
			}
		}
		if !placed {
			result = append(append([]string{}, result...), []string{c.Name}...)
		}
	}
	return result
}

func example() {
	expect(_equal(customersWithoutOrders(customers, orders), []string{"Henry", "Max"}))
}

func all_customers() {
	var emptyOrders []any = []any{}
	_ = emptyOrders
	expect((fmt.Sprint(customersWithoutOrders(customers, emptyOrders)) == fmt.Sprint([]string{"Joe", "Henry", "Sam", "Max"})))
}

func none_left() {
	var allOrders []any = []Order{Order{Id: 1, CustomerId: 1}, Order{Id: 2, CustomerId: 2}, Order{Id: 3, CustomerId: 3}, Order{Id: 4, CustomerId: 4}}
	_ = allOrders
	expect(_equal(customersWithoutOrders(customers, allOrders), []any{}))
}

var customers []any = []Customer{Customer{Id: 1, Name: "Joe"}, Customer{Id: 2, Name: "Henry"}, Customer{Id: 3, Name: "Sam"}, Customer{Id: 4, Name: "Max"}}
var orders []any = []Order{Order{Id: 1, CustomerId: 3}, Order{Id: 2, CustomerId: 1}}
func main() {
	example()
	all_customers()
	none_left()
}

func _equal(a, b any) bool {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice && av.Len() == 0 && bv.Len() == 0 {
        return true
    }
    return reflect.DeepEqual(a, b)
}

