# Generated by Mochi Elixir compiler
defmodule Main do
	def fourSum(nums, target) do
		try do
			sorted = for n <- Enum.sort_by(nums, fn n -> n end), do: n
			n = length(sorted)
			result = []
			_ = result
			{result} = Enum.reduce(0..(n - 1), {result}, fn i, {result} ->
				if ((i > 0) && (Enum.at(sorted, i) == Enum.at(sorted, (i - 1)))) do
					throw :continue
				end
				{result} = Enum.reduce((i + 1)..(n - 1), {result}, fn j, {result} ->
					if ((j > (i + 1)) && (Enum.at(sorted, j) == Enum.at(sorted, (j - 1)))) do
						throw :continue
					end
					left = (j + 1)
					_ = left
					right = (n - 1)
					_ = right
					t1 = fn t1, left, result, right ->
						try do
							if (left < right) do
								sum = (((Enum.at(sorted, i) + Enum.at(sorted, j)) + Enum.at(sorted, left)) + Enum.at(sorted, right))
								if (sum == target) do
									result = result ++ [[Enum.at(sorted, i), Enum.at(sorted, j), Enum.at(sorted, left), Enum.at(sorted, right)]]
									left = (left + 1)
									right = (right - 1)
									t2 = fn t2, left ->
										try do
											if ((left < right) && (Enum.at(sorted, left) == Enum.at(sorted, (left - 1)))) do
												left = (left + 1)
												t2.(t2, left)
											else
												{:ok, left}
											end
										catch :break ->
											{:ok, left}
										end
									end
									{_, left} = t2.(t2, left)
									_ = left
									t3 = fn t3, right ->
										try do
											if ((left < right) && (Enum.at(sorted, right) == Enum.at(sorted, (right + 1)))) do
												right = (right - 1)
												t3.(t3, right)
											else
												{:ok, right}
											end
										catch :break ->
											{:ok, right}
										end
									end
									{_, right} = t3.(t3, right)
									_ = right
								else
									if (sum < target) do
										left = (left + 1)
									else
										right = (right - 1)
									end
								end
								t1.(t1, left, result, right)
							else
								{:ok, left, result, right}
							end
						catch :break ->
							{:ok, left, result, right}
						end
					end
					{_, left, result, right} = t1.(t1, left, result, right)
					_ = left
					_ = result
					_ = right
					{result}
				end)
				_ = result
				{result}
			end)
			_ = result
			throw {:return, result}
		catch {:return, v} -> v end
	end
	
	def main do
	end
	end
Main.main()
