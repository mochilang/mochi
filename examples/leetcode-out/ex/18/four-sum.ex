# Generated by Mochi Elixir compiler
defmodule Main do
  def fourSum(nums, target) do
    try do
      sorted = for n <- Enum.sort_by(nums, fn n -> n end), do: n
      n = length(sorted)
      result = []
      _ = result

      {result} =
        Enum.reduce(0..(n - 1), {result}, fn i, {result} ->
          if i > 0 && Enum.at(sorted, i) == Enum.at(sorted, i - 1) do
            throw(:continue)
          end

          {result} =
            Enum.reduce((i + 1)..(n - 1), {result}, fn j, {result} ->
              if j > i + 1 && Enum.at(sorted, j) == Enum.at(sorted, j - 1) do
                throw(:continue)
              end

              left = j + 1
              _ = left
              right = n - 1
              _ = right

              t1 = fn t1, left, result, right ->
                try do
                  if left < right do
                    sum =
                      Enum.at(sorted, i) + Enum.at(sorted, j) + Enum.at(sorted, left) +
                        Enum.at(sorted, right)

                    if sum == target do
                      result =
                        result ++
                          [
                            [
                              Enum.at(sorted, i),
                              Enum.at(sorted, j),
                              Enum.at(sorted, left),
                              Enum.at(sorted, right)
                            ]
                          ]

                      left = left + 1
                      right = right - 1

                      t2 = fn t2, left ->
                        try do
                          if left < right && Enum.at(sorted, left) == Enum.at(sorted, left - 1) do
                            left = left + 1
                            t2.(t2, left)
                          else
                            {:ok, left}
                          end
                        catch
                          :break ->
                            {:ok, left}
                        end
                      end

                      {_, left} = t2.(t2, left)
                      _ = left

                      t3 = fn t3, right ->
                        try do
                          if left < right && Enum.at(sorted, right) == Enum.at(sorted, right + 1) do
                            right = right - 1
                            t3.(t3, right)
                          else
                            {:ok, right}
                          end
                        catch
                          :break ->
                            {:ok, right}
                        end
                      end

                      {_, right} = t3.(t3, right)
                      _ = right
                    else
                      if sum < target do
                        left = left + 1
                      else
                        right = right - 1
                      end
                    end

                    t1.(t1, left, result, right)
                  else
                    {:ok, left, result, right}
                  end
                catch
                  :break ->
                    {:ok, left, result, right}
                end
              end

              {_, left, result, right} = t1.(t1, left, result, right)
              _ = left
              _ = result
              _ = right
              {result}
            end)

          _ = result
          {result}
        end)

      _ = result
      throw({:return, result})
    catch
      {:return, v} -> v
    end
  end

  def main do
  end
end

Main.main()
