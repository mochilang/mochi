# Generated by Mochi Elixir compiler
defmodule Main do
	def isMatch(s, p) do
		try do
			m = length(s)
			n = length(p)
			dp = []
			_ = dp
			i = 0
			_ = i
			t1 = fn t1, dp, i ->
				try do
					if (i <= m) do
						row = []
						_ = row
						j = 0
						_ = j
						t2 = fn t2, j, row ->
							try do
								if (j <= n) do
									row = row ++ [false]
									j = (j + 1)
									t2.(t2, j, row)
								else
									{:ok, j, row}
								end
							catch :break ->
								{:ok, j, row}
							end
						end
						{_, j, row} = t2.(t2, j, row)
						_ = j
						_ = row
						dp = dp ++ [row]
						i = (i + 1)
						t1.(t1, dp, i)
					else
						{:ok, dp, i}
					end
				catch :break ->
					{:ok, dp, i}
				end
			end
			{_, dp, i} = t1.(t1, dp, i)
			_ = dp
			_ = i
			dp = Map.put(dp, m, true)
			i2 = m
			_ = i2
			t3 = fn t3, dp, i2 ->
				try do
					if (i2 >= 0) do
						j2 = (n - 1)
						_ = j2
						t4 = fn t4, dp, j2 ->
							try do
								if (j2 >= 0) do
									first = false
									_ = first
									if (i2 < m) do
										if ((Enum.at(p, j2) == Enum.at(s, i2)) || (Enum.at(p, j2) == ".")) do
											first = true
										end
									end
									star = false
									_ = star
									if ((j2 + 1) < n) do
										if (Enum.at(p, (j2 + 1)) == "*") do
											star = true
										end
									end
									if star do
										ok = false
										_ = ok
										if Enum.at(Enum.at(dp, i2), (j2 + 2)) do
											ok = true
										else
											if first do
												if Enum.at(Enum.at(dp, (i2 + 1)), j2) do
													ok = true
												end
											end
										end
										dp = Map.put(dp, i2, ok)
									else
										ok = false
										_ = ok
										if first do
											if Enum.at(Enum.at(dp, (i2 + 1)), (j2 + 1)) do
												ok = true
											end
										end
										dp = Map.put(dp, i2, ok)
									end
									j2 = (j2 - 1)
									t4.(t4, dp, j2)
								else
									{:ok, dp, j2}
								end
							catch :break ->
								{:ok, dp, j2}
							end
						end
						{_, dp, j2} = t4.(t4, dp, j2)
						_ = dp
						_ = j2
						i2 = (i2 - 1)
						t3.(t3, dp, i2)
					else
						{:ok, dp, i2}
					end
				catch :break ->
					{:ok, dp, i2}
				end
			end
			{_, dp, i2} = t3.(t3, dp, i2)
			_ = dp
			_ = i2
			throw {:return, Enum.at(Enum.at(dp, 0), 0)}
		catch {:return, v} -> v end
	end
	
	def main do
	end
	end
Main.main()
