# Generated by Mochi Elixir compiler
defmodule Main do
  def isMatch(s, p) do
    try do
      m = length(s)
      n = length(p)
      dp = []
      _ = dp
      i = 0
      _ = i

      t1 = fn t1, dp, i ->
        try do
          if i <= m do
            row = []
            _ = row
            j = 0
            _ = j

            t2 = fn t2, j, row ->
              try do
                if j <= n do
                  row = row ++ [false]
                  j = j + 1
                  t2.(t2, j, row)
                else
                  {:ok, j, row}
                end
              catch
                :break ->
                  {:ok, j, row}
              end
            end

            {_, j, row} = t2.(t2, j, row)
            _ = j
            _ = row
            dp = dp ++ [row]
            i = i + 1
            t1.(t1, dp, i)
          else
            {:ok, dp, i}
          end
        catch
          :break ->
            {:ok, dp, i}
        end
      end

      {_, dp, i} = t1.(t1, dp, i)
      _ = dp
      _ = i
      dp = Map.put(dp, m, true)
      i2 = m
      _ = i2

      t3 = fn t3, dp, i2 ->
        try do
          if i2 >= 0 do
            j2 = n - 1
            _ = j2

            t4 = fn t4, dp, j2 ->
              try do
                if j2 >= 0 do
                  first = false
                  _ = first

                  if i2 < m do
                    if Enum.at(p, j2) == Enum.at(s, i2) || Enum.at(p, j2) == "." do
                      first = true
                    end
                  end

                  star = false
                  _ = star

                  if j2 + 1 < n do
                    if Enum.at(p, j2 + 1) == "*" do
                      star = true
                    end
                  end

                  if star do
                    ok = false
                    _ = ok

                    if Enum.at(Enum.at(dp, i2), j2 + 2) do
                      ok = true
                    else
                      if first do
                        if Enum.at(Enum.at(dp, i2 + 1), j2) do
                          ok = true
                        end
                      end
                    end

                    dp = Map.put(dp, i2, ok)
                  else
                    ok = false
                    _ = ok

                    if first do
                      if Enum.at(Enum.at(dp, i2 + 1), j2 + 1) do
                        ok = true
                      end
                    end

                    dp = Map.put(dp, i2, ok)
                  end

                  j2 = j2 - 1
                  t4.(t4, dp, j2)
                else
                  {:ok, dp, j2}
                end
              catch
                :break ->
                  {:ok, dp, j2}
              end
            end

            {_, dp, j2} = t4.(t4, dp, j2)
            _ = dp
            _ = j2
            i2 = i2 - 1
            t3.(t3, dp, i2)
          else
            {:ok, dp, i2}
          end
        catch
          :break ->
            {:ok, dp, i2}
        end
      end

      {_, dp, i2} = t3.(t3, dp, i2)
      _ = dp
      _ = i2
      throw({:return, Enum.at(Enum.at(dp, 0), 0)})
    catch
      {:return, v} -> v
    end
  end

  def main do
  end
end

Main.main()
