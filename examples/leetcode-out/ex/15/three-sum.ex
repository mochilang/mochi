# Generated by Mochi Elixir compiler
defmodule Main do
	def threeSum(nums) do
		try do
			sorted = for x <- Enum.sort_by(nums, fn x -> x end), do: x
			n = length(sorted)
			res = []
			_ = res
			i = 0
			_ = i
			t1 = fn t1, i, res ->
				try do
					if (i < n) do
						if ((i > 0) && (Enum.at(sorted, i) == Enum.at(sorted, (i - 1)))) do
							i = (i + 1)
							throw :continue
						end
						left = (i + 1)
						_ = left
						right = (n - 1)
						_ = right
						t2 = fn t2, left, res, right ->
							try do
								if (left < right) do
									sum = ((Enum.at(sorted, i) + Enum.at(sorted, left)) + Enum.at(sorted, right))
									if (sum == 0) do
										res = res ++ [[Enum.at(sorted, i), Enum.at(sorted, left), Enum.at(sorted, right)]]
										left = (left + 1)
										t3 = fn t3, left ->
											try do
												if ((left < right) && (Enum.at(sorted, left) == Enum.at(sorted, (left - 1)))) do
													left = (left + 1)
													t3.(t3, left)
												else
													{:ok, left}
												end
											catch :break ->
												{:ok, left}
											end
										end
										{_, left} = t3.(t3, left)
										_ = left
										right = (right - 1)
										t4 = fn t4, right ->
											try do
												if ((left < right) && (Enum.at(sorted, right) == Enum.at(sorted, (right + 1)))) do
													right = (right - 1)
													t4.(t4, right)
												else
													{:ok, right}
												end
											catch :break ->
												{:ok, right}
											end
										end
										{_, right} = t4.(t4, right)
										_ = right
									else
										if (sum < 0) do
											left = (left + 1)
										else
											right = (right - 1)
										end
									end
									t2.(t2, left, res, right)
								else
									{:ok, left, res, right}
								end
							catch :break ->
								{:ok, left, res, right}
							end
						end
						{_, left, res, right} = t2.(t2, left, res, right)
						_ = left
						_ = res
						_ = right
						i = (i + 1)
						t1.(t1, i, res)
					else
						{:ok, i, res}
					end
				catch :break ->
					{:ok, i, res}
				end
			end
			{_, i, res} = t1.(t1, i, res)
			_ = i
			_ = res
			throw {:return, res}
		catch {:return, v} -> v end
	end
	
	def main do
	end
	end
Main.main()
