# Generated by Mochi Elixir compiler
defmodule Main do
  def threeSum(nums) do
    try do
      sorted = for x <- Enum.sort_by(nums, fn x -> x end), do: x
      n = length(sorted)
      res = []
      _ = res
      i = 0
      _ = i

      t1 = fn t1, i, res ->
        try do
          if i < n do
            if i > 0 && Enum.at(sorted, i) == Enum.at(sorted, i - 1) do
              i = i + 1
              throw(:continue)
            end

            left = i + 1
            _ = left
            right = n - 1
            _ = right

            t2 = fn t2, left, res, right ->
              try do
                if left < right do
                  sum = Enum.at(sorted, i) + Enum.at(sorted, left) + Enum.at(sorted, right)

                  if sum == 0 do
                    res =
                      res ++ [[Enum.at(sorted, i), Enum.at(sorted, left), Enum.at(sorted, right)]]

                    left = left + 1

                    t3 = fn t3, left ->
                      try do
                        if left < right && Enum.at(sorted, left) == Enum.at(sorted, left - 1) do
                          left = left + 1
                          t3.(t3, left)
                        else
                          {:ok, left}
                        end
                      catch
                        :break ->
                          {:ok, left}
                      end
                    end

                    {_, left} = t3.(t3, left)
                    _ = left
                    right = right - 1

                    t4 = fn t4, right ->
                      try do
                        if left < right && Enum.at(sorted, right) == Enum.at(sorted, right + 1) do
                          right = right - 1
                          t4.(t4, right)
                        else
                          {:ok, right}
                        end
                      catch
                        :break ->
                          {:ok, right}
                      end
                    end

                    {_, right} = t4.(t4, right)
                    _ = right
                  else
                    if sum < 0 do
                      left = left + 1
                    else
                      right = right - 1
                    end
                  end

                  t2.(t2, left, res, right)
                else
                  {:ok, left, res, right}
                end
              catch
                :break ->
                  {:ok, left, res, right}
              end
            end

            {_, left, res, right} = t2.(t2, left, res, right)
            _ = left
            _ = res
            _ = right
            i = i + 1
            t1.(t1, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t1.(t1, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  def main do
  end
end

Main.main()
