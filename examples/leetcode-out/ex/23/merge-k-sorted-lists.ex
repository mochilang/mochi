# Generated by Mochi Elixir compiler
defmodule Main do
  def mergeKLists(lists) do
    try do
      k = length(lists)
      indices = []
      _ = indices
      i = 0
      _ = i

      t1 = fn t1, i, indices ->
        try do
          if i < k do
            indices = indices ++ [0]
            i = i + 1
            t1.(t1, i, indices)
          else
            {:ok, i, indices}
          end
        catch
          :break ->
            {:ok, i, indices}
        end
      end

      {_, i, indices} = t1.(t1, i, indices)
      _ = i
      _ = indices
      result = []
      _ = result

      t2 = fn t2, indices, result ->
        try do
          if true do
            best = 0
            _ = best
            bestList = -1
            _ = bestList
            found = false
            _ = found
            j = 0
            _ = j

            t3 = fn t3, best, bestList, found, j ->
              try do
                if j < k do
                  idx = Enum.at(indices, j)

                  if idx < length(Enum.at(lists, j)) do
                    val = Enum.at(Enum.at(lists, j), idx)

                    if !found || val < best do
                      best = val
                      bestList = j
                      found = true
                    end
                  end

                  j = j + 1
                  t3.(t3, best, bestList, found, j)
                else
                  {:ok, best, bestList, found, j}
                end
              catch
                :break ->
                  {:ok, best, bestList, found, j}
              end
            end

            {_, best, bestList, found, j} = t3.(t3, best, bestList, found, j)
            _ = best
            _ = bestList
            _ = found
            _ = j

            if !found do
              throw(:break)
            end

            result = result ++ [best]
            indices = Map.put(indices, bestList, Enum.at(indices, bestList) + 1)
            t2.(t2, indices, result)
          else
            {:ok, indices, result}
          end
        catch
          :break ->
            {:ok, indices, result}
        end
      end

      {_, indices, result} = t2.(t2, indices, result)
      _ = indices
      _ = result
      throw({:return, result})
    catch
      {:return, v} -> v
    end
  end

  def main do
  end
end

Main.main()
