# Generated by Mochi Elixir compiler
defmodule Main do
	def mergeKLists(lists) do
		try do
			k = length(lists)
			indices = []
			_ = indices
			i = 0
			_ = i
			t1 = fn t1, i, indices ->
				try do
					if (i < k) do
						indices = indices ++ [0]
						i = (i + 1)
						t1.(t1, i, indices)
					else
						{:ok, i, indices}
					end
				catch :break ->
					{:ok, i, indices}
				end
			end
			{_, i, indices} = t1.(t1, i, indices)
			_ = i
			_ = indices
			result = []
			_ = result
			t2 = fn t2, indices, result ->
				try do
					if true do
						best = 0
						_ = best
						bestList = -1
						_ = bestList
						found = false
						_ = found
						j = 0
						_ = j
						t3 = fn t3, best, bestList, found, j ->
							try do
								if (j < k) do
									idx = Enum.at(indices, j)
									if (idx < length(Enum.at(lists, j))) do
										val = Enum.at(Enum.at(lists, j), idx)
										if (!found || (val < best)) do
											best = val
											bestList = j
											found = true
										end
									end
									j = (j + 1)
									t3.(t3, best, bestList, found, j)
								else
									{:ok, best, bestList, found, j}
								end
							catch :break ->
								{:ok, best, bestList, found, j}
							end
						end
						{_, best, bestList, found, j} = t3.(t3, best, bestList, found, j)
						_ = best
						_ = bestList
						_ = found
						_ = j
						if !found do
							throw :break
						end
						result = result ++ [best]
						indices = Map.put(indices, bestList, (Enum.at(indices, bestList) + 1))
						t2.(t2, indices, result)
					else
						{:ok, indices, result}
					end
				catch :break ->
					{:ok, indices, result}
				end
			end
			{_, indices, result} = t2.(t2, indices, result)
			_ = indices
			_ = result
			throw {:return, result}
		catch {:return, v} -> v end
	end
	
	def main do
	end
	end
Main.main()
