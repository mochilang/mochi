# Generated by Mochi Elixir compiler
defmodule Main do
	convert = fn s, numRows ->
		if ((numRows <= 1) || (numRows >= length(s))) do
			throw {:return, s}
		end
		rows = []
		_ = rows
		i = 0
		_ = i
		t1 = fn t1, i, rows ->
			try do
				if (i < numRows) do
					rows = rows ++ [""]
					i = (i + 1)
					t1.(t1, i, rows)
				else
					{:ok, i, rows}
				end
			catch :break ->
				{:ok, i, rows}
			end
		end
		{_, i, rows} = t1.(t1, i, rows)
		_ = i
		_ = rows
		curr = 0
		_ = curr
		step = 1
		_ = step
		{curr, rows, step} = Enum.reduce(s, {curr, rows, step}, fn ch, {curr, rows, step} ->
			rows = Map.put(rows, curr, (Enum.at(rows, curr) + ch))
			if (curr == 0) do
				step = 1
			else
				if (curr == (numRows - 1)) do
					step = -1
				end
			end
			curr = (curr + step)
			{curr, rows, step}
		end)
		_ = curr
		_ = rows
		_ = step
		result = ""
		_ = result
		{result} = Enum.reduce(rows, {result}, fn row, {result} ->
			result = (result + row)
			{result}
		end)
		_ = result
		throw {:return, result}
	end
	
	def main do
	end
	end
Main.main()
