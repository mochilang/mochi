# Generated by Mochi Elixir compiler
defmodule Main do
	def expand(s, left, right) do
		try do
			l = left
			_ = l
			r = right
			_ = r
			n = length(s)
			t1 = fn t1, l, r ->
				try do
					if ((l >= 0) && (r < n)) do
						if (Enum.at(s, l) != Enum.at(s, r)) do
							throw :break
						end
						l = (l - 1)
						r = (r + 1)
						t1.(t1, l, r)
					else
						{:ok, l, r}
					end
				catch :break ->
					{:ok, l, r}
				end
			end
			{_, l, r} = t1.(t1, l, r)
			_ = l
			_ = r
			throw {:return, ((r - l) - 1)}
		catch {:return, v} -> v end
	end
	
	def longestPalindrome(s) do
		try do
			if (length(s) <= 1) do
				throw {:return, s}
			end
			start = 0
			_ = start
			end_ = 0
			_ = end_
			n = length(s)
			{end_, start} = Enum.reduce(0..(n - 1), {end_, start}, fn i, {end_, start} ->
				len1 = expand(s, i, i)
				len2 = expand(s, i, (i + 1))
				l = len1
				_ = l
				if (len2 > len1) do
					l = len2
				end
				if (l > (end_ - start)) do
					start = (i - ((l - 1) / 2))
					end_ = (i + (l / 2))
				end
				{end_, start}
			end)
			_ = end_
			_ = start
			res = ""
			_ = res
			k = start
			_ = k
			t2 = fn t2, k, res ->
				try do
					if (k <= end_) do
						res = (res + Enum.at(s, k))
						k = (k + 1)
						t2.(t2, k, res)
					else
						{:ok, k, res}
					end
				catch :break ->
					{:ok, k, res}
				end
			end
			{_, k, res} = t2.(t2, k, res)
			_ = k
			_ = res
			throw {:return, res}
		catch {:return, v} -> v end
	end
	
	def main do
	end
	end
Main.main()
