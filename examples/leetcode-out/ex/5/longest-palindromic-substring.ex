# Generated by Mochi Elixir compiler
defmodule Main do
  def expand(s, left, right) do
    try do
      l = left
      _ = l
      r = right
      _ = r
      n = length(s)

      t1 = fn t1, l, r ->
        try do
          if l >= 0 && r < n do
            if Enum.at(s, l) != Enum.at(s, r) do
              throw(:break)
            end

            l = l - 1
            r = r + 1
            t1.(t1, l, r)
          else
            {:ok, l, r}
          end
        catch
          :break ->
            {:ok, l, r}
        end
      end

      {_, l, r} = t1.(t1, l, r)
      _ = l
      _ = r
      throw({:return, r - l - 1})
    catch
      {:return, v} -> v
    end
  end

  def longestPalindrome(s) do
    try do
      if length(s) <= 1 do
        throw({:return, s})
      end

      start = 0
      _ = start
      end_ = 0
      _ = end_
      n = length(s)

      {end_, start} =
        Enum.reduce(0..(n - 1), {end_, start}, fn i, {end_, start} ->
          len1 = expand(s, i, i)
          len2 = expand(s, i, i + 1)
          l = len1
          _ = l

          if len2 > len1 do
            l = len2
          end

          if l > end_ - start do
            start = i - (l - 1) / 2
            end_ = i + l / 2
          end

          {end_, start}
        end)

      _ = end_
      _ = start
      throw({:return, Enum.slice(s, start, end_ + 1 - start)})
    catch
      {:return, v} -> v
    end
  end

  def main do
  end
end

Main.main()
