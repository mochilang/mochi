# Generated by Mochi Elixir compiler
defmodule Main do
	expand = fn s, left, right ->
		l = left
		_ = l
		r = right
		_ = r
		n = length(s)
		t1 = fn t1, l, r ->
			try do
				if ((l >= 0) && (r < n)) do
					if (Enum.at(s, l) != Enum.at(s, r)) do
						throw :break
					end
					l = (l - 1)
					r = (r + 1)
					t1.(t1, l, r)
				else
					{:ok, l, r}
				end
			catch :break ->
				{:ok, l, r}
			end
		end
		{_, l, r} = t1.(t1, l, r)
		_ = l
		_ = r
		throw {:return, ((r - l) - 1)}
	end
	
	longestPalindrome = fn s ->
		if (length(s) <= 1) do
			throw {:return, s}
		end
		start = 0
		_ = start
		end_ = 0
		_ = end_
		n = length(s)
		{end_, start} = Enum.reduce(0..(n - 1), {end_, start}, fn i, {end_, start} ->
			len1 = expand.(s, i, i)
			len2 = expand.(s, i, (i + 1))
			l = len1
			_ = l
			if (len2 > len1) do
				l = len2
			end
			if (l > (end_ - start)) do
				start = (i - ((l - 1) / 2))
				end_ = (i + (l / 2))
			end
			{end_, start}
		end)
		_ = end_
		_ = start
		throw {:return, Enum.at(s, start)}
	end
	
	def main do
	end
	end
Main.main()
