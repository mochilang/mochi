# Generated by Mochi Elixir compiler
defmodule Main do
	def threeSumClosest(nums, target) do
		try do
			sorted = for n <- Enum.sort_by(nums, fn n -> n end), do: n
			n = length(sorted)
			best = ((Enum.at(sorted, 0) + Enum.at(sorted, 1)) + Enum.at(sorted, 2))
			_ = best
			{best} = Enum.reduce(0..(n - 1), {best}, fn i, {best} ->
				left = (i + 1)
				_ = left
				right = (n - 1)
				_ = right
				t1 = fn t1, best, left, right ->
					try do
						if (left < right) do
							sum = ((Enum.at(sorted, i) + Enum.at(sorted, left)) + Enum.at(sorted, right))
							if (sum == target) do
								throw {:return, target}
							end
							diff = 0
							_ = diff
							if (sum > target) do
								diff = (sum - target)
							else
								diff = (target - sum)
							end
							bestDiff = 0
							_ = bestDiff
							if (best > target) do
								bestDiff = (best - target)
							else
								bestDiff = (target - best)
							end
							if (diff < bestDiff) do
								best = sum
							end
							if (sum < target) do
								left = (left + 1)
							else
								right = (right - 1)
							end
							t1.(t1, best, left, right)
						else
							{:ok, best, left, right}
						end
					catch :break ->
						{:ok, best, left, right}
					end
				end
				{_, best, left, right} = t1.(t1, best, left, right)
				_ = best
				_ = left
				_ = right
				{best}
			end)
			_ = best
			throw {:return, best}
		catch {:return, v} -> v end
	end
	
	def main do
	end
	end
Main.main()
