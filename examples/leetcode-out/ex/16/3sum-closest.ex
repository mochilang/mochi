# Generated by Mochi Elixir compiler
defmodule Main do
  def threeSumClosest(nums, target) do
    try do
      sorted = for n <- Enum.sort_by(nums, fn n -> n end), do: n
      n = length(sorted)
      best = Enum.at(sorted, 0) + Enum.at(sorted, 1) + Enum.at(sorted, 2)
      _ = best

      {best} =
        Enum.reduce(0..(n - 1), {best}, fn i, {best} ->
          left = i + 1
          _ = left
          right = n - 1
          _ = right

          t1 = fn t1, best, left, right ->
            try do
              if left < right do
                sum = Enum.at(sorted, i) + Enum.at(sorted, left) + Enum.at(sorted, right)

                if sum == target do
                  throw({:return, target})
                end

                diff = 0
                _ = diff

                if sum > target do
                  diff = sum - target
                else
                  diff = target - sum
                end

                bestDiff = 0
                _ = bestDiff

                if best > target do
                  bestDiff = best - target
                else
                  bestDiff = target - best
                end

                if diff < bestDiff do
                  best = sum
                end

                if sum < target do
                  left = left + 1
                else
                  right = right - 1
                end

                t1.(t1, best, left, right)
              else
                {:ok, best, left, right}
              end
            catch
              :break ->
                {:ok, best, left, right}
            end
          end

          {_, best, left, right} = t1.(t1, best, left, right)
          _ = best
          _ = left
          _ = right
          {best}
        end)

      _ = best
      throw({:return, best})
    catch
      {:return, v} -> v
    end
  end

  def main do
  end
end

Main.main()
