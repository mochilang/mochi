// Generated by Mochi TypeScript compiler

function maxPoints(points: Array<Array<number>>) : number {
	let n: number = points.length
	if ((n <= 2)) {
		return n
	}
	let answer: number = 0
	let i: number = 0
	while ((i < n)) {
		let slopes: Record<any, any> = {}
		let duplicates: number = 1
		let j: number = (i + 1)
		while ((j < n)) {
			let dx: number = (points[j][0] - points[i][0])
			let dy: number = (points[j][1] - points[i][1])
			if (((dx == 0) && (dy == 0))) {
				duplicates = (duplicates + 1)
			} else {
				let g: number = gcd(dx, dy)
				let sx: number = Math.trunc(dx / g)
				let sy: number = Math.trunc(dy / g)
				if ((sx == 0)) {
					sy = 1
				} else 				if ((sx < 0)) {
					sx = (-sx)
					sy = (-sy)
				}
				let key: string = String(sx) + "/" + String(sy)
				if (Object.prototype.hasOwnProperty.call(slopes, String(key))) {
					slopes[key] = (slopes[key] + 1)
				} else {
					slopes[key] = 1
				}
			}
			j = (j + 1)
		}
		let localMax: number = 0
		for (const key of Object.keys(slopes)) {
			let count: any = slopes[key]
			if ((count > localMax)) {
				localMax = count
			}
		}
		if (((localMax + duplicates) > answer)) {
			answer = (localMax + duplicates)
		}
		i = (i + 1)
	}
	return answer
}

function abs(x: number) : number {
	if ((x < 0)) {
		return (-x)
	}
	return x
}

function gcd(a: number, b: number) : number {
	let x: number = abs(a)
	let y: number = abs(b)
	while ((y != 0)) {
		let temp: number = (x % y)
		x = y
		y = temp
	}
	return x
}

function example_1(): void {
	if (!((maxPoints([[1, 1], [2, 2], [3, 3]]) == 3))) { throw new Error('expect failed') }
}

function example_2(): void {
	if (!((maxPoints([[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]) == 4))) { throw new Error('expect failed') }
}

function single_point(): void {
	if (!((maxPoints([[0, 0]]) == 1))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	example_2()
	single_point()
}
main()

