// Generated by Mochi TypeScript compiler

function longestIncreasingPath(matrix: Array<Array<number>>) : number {
	let m: number = matrix.length
	if ((m == 0)) {
		return 0
	}
	let n: number = matrix[0].length
	let memo: Array<any> = []
	let i: number = 0
	while ((i < m)) {
		let row: Array<any> = []
		let j: number = 0
		while ((j < n)) {
			row = row.concat([0])
			j = (j + 1)
		}
		memo = memo.concat([row])
		i = (i + 1)
	}
	function dfs(x: number, y: number) : number {
		let cached: any = (memo[x] as any)[y]
		if (!_equal(cached, 0)) {
			return cached
		}
		let val: number = matrix[x][y]
		let best: number = 1
		if ((x > 0)) {
			if ((matrix[(x - 1)][y] > val)) {
				let candidate: any = (1 + dfs((x - 1), y))
				if ((candidate > best)) {
					best = candidate
				}
			}
		}
		if (((x + 1) < m)) {
			if ((matrix[(x + 1)][y] > val)) {
				let candidate: any = (1 + dfs((x + 1), y))
				if ((candidate > best)) {
					best = candidate
				}
			}
		}
		if ((y > 0)) {
			if ((matrix[x][(y - 1)] > val)) {
				let candidate: any = (1 + dfs(x, (y - 1)))
				if ((candidate > best)) {
					best = candidate
				}
			}
		}
		if (((y + 1) < n)) {
			if ((matrix[x][(y + 1)] > val)) {
				let candidate: any = (1 + dfs(x, (y + 1)))
				if ((candidate > best)) {
					best = candidate
				}
			}
		}
		memo[x][y] = best
		return best
	}
	let result: number = 0
	i = 0
	while ((i < m)) {
		let j: number = 0
		while ((j < n)) {
			let length: any = dfs(i, j)
			if ((length > result)) {
				result = length
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return result
}

function example_1(): void {
	let matrix: Array<Array<number>> = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]
	if (!((longestIncreasingPath(matrix) == 4))) { throw new Error('expect failed') }
}

function example_2(): void {
	let matrix: Array<Array<number>> = [[3, 4, 5], [3, 2, 6], [2, 2, 1]]
	if (!((longestIncreasingPath(matrix) == 4))) { throw new Error('expect failed') }
}

function single_cell(): void {
	if (!((longestIncreasingPath([[1]]) == 1))) { throw new Error('expect failed') }
}

function empty(): void {
	if (!((longestIncreasingPath([]) == 0))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	example_2()
	single_cell()
	empty()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

main()

