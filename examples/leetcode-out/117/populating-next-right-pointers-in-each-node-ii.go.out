package main

import (
	"encoding/json"
	"reflect"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func connect(lefts []int, rights []int, root int) []int {
	var nexts []int = []int{}
	_ = nexts
	var i int = 0
	_ = i
	for (i < len(lefts)) {
		nexts = append(append([]int{}, nexts...), []int{(-1)}...)
		i = (i + 1)
	}
	var queue []int = []int{}
	_ = queue
	if (root != (-1)) {
		queue = []int{root}
	}
	for (len(queue) > 0) {
		var next []int = []int{}
		_ = next
		var prev int = (-1)
		_ = prev
		for _, idx := range queue {
			if (prev != (-1)) {
				nexts[prev] = idx
			}
			prev = idx
			if (lefts[idx] != (-1)) {
				next = append(append([]int{}, next...), []int{lefts[idx]}...)
			}
			if (rights[idx] != (-1)) {
				next = append(append([]int{}, next...), []int{rights[idx]}...)
			}
		}
		queue = next
	}
	return nexts
}

func levels(lefts []int, rights []int, values []int, root int) [][]int {
	var result [][]int = [][]int{}
	_ = result
	var queue []int = []int{}
	_ = queue
	if (root != (-1)) {
		queue = []int{root}
	}
	for (len(queue) > 0) {
		var vals []int = []int{}
		_ = vals
		var next []int = []int{}
		_ = next
		for _, idx := range queue {
			vals = append(append([]int{}, vals...), []int{values[idx]}...)
			if (lefts[idx] != (-1)) {
				next = append(append([]int{}, next...), []int{lefts[idx]}...)
			}
			if (rights[idx] != (-1)) {
				next = append(append([]int{}, next...), []int{rights[idx]}...)
			}
		}
		result = append(append([][]int{}, result...), [][]int{vals}...)
		queue = next
	}
	return result
}

func example() {
	var ns []int = connect(exLefts, exRights, exRoot)
	expect(_equal(levels(exLefts, exRights, exValues, exRoot), [][]int{[]int{1}, []int{2, 3}, []int{4, 5, 7}}))
	expect(_equal(ns, []int{(-1), 2, (-1), 4, 5, (-1)}))
}

func single_node() {
	var lefts []int = _cast[[]int]([]int{(-1)})
	var rights []int = _cast[[]int]([]int{(-1)})
	var values []int = _cast[[]int]([]int{1})
	var root int = 0
	var ns []int = connect(lefts, rights, root)
	expect(_equal(levels(lefts, rights, values, root), [][]int{[]int{1}}))
	expect(_equal(ns, []int{(-1)}))
}

func empty() {
	var lefts []int = _cast[[]int]([]any{})
	var rights []int = _cast[[]int]([]any{})
	var values []int = _cast[[]int]([]any{})
	var ns []int = connect(lefts, rights, (-1))
	expect(_equal(levels(lefts, rights, values, (-1)), []any{}))
	expect(_equal(ns, []any{}))
}

var exLefts []int = _cast[[]int]([]int{1, 3, (-1), (-1), (-1), (-1)})
var exRights []int = _cast[[]int]([]int{2, 4, 5, (-1), (-1), (-1)})
var exValues []int = _cast[[]int]([]int{1, 2, 3, 4, 5, 7})
var exRoot int = 0
func main() {
	example()
	single_node()
	empty()
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

func _equal(a, b any) bool {
    return reflect.DeepEqual(a, b)
}

