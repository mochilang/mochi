package main

import (
	"fmt"
)

func remove_html_tags(text string) string {
	var i int = 0
	_ = i
	var output string = ""
	_ = output
	for (i < len(text)) {
		if (_indexString(text, i) == "<") {
			var j int = (i + 1)
			_ = j
			for ((j < len(text)) && (_indexString(text, j) != ">")) {
				j = (j + 1)
			}
			if (j < len(text)) {
				i = (j + 1)
			} else {
				i = (i + 1)
			}
		} else {
			output = output + _indexString(text, i)
			i = (i + 1)
		}
	}
	return output
}

func get_leetcode_problem(problem_id string) string {
	fmt.Println("=== Step 1: Searching for LeetCode Problem", problem_id, "===")
	var search_response any = _fetch("https://leetcode.com/graphql/", _toAnyMap(map[string]any{"method": "POST", "headers": map[string]string{"Content-Type": "application/json"}, "body": map[string]any{"operationName": "problemsetQuestionList", "variables": map[string]any{"categorySlug": "", "skip": 0, "limit": 1, "filters": map[string]string{"searchKeywords": problem_id}}, "query": "query problemsetQuestionList($categorySlug: String, $limit: Int, $skip: Int, $filters: QuestionListFilterInput) { problemsetQuestionList: questionList(categorySlug: $categorySlug limit: $limit skip: $skip filters: $filters) { total: totalNum questions: data { frontendQuestionId: questionFrontendId title titleSlug difficulty } } }"}}))
	fmt.Println("Search result:", search_response)
	var title_slug string = "maximum-difference-between-even-and-odd-frequency-i"
	fmt.Println("=== Step 2: Fetching full content using titleSlug:", title_slug, "===")
	var content_response any = _fetch("https://leetcode.com/graphql/", _toAnyMap(map[string]any{"method": "POST", "headers": map[string]string{"Content-Type": "application/json", "Cookie": "LEETCODE_SESSION=your_session_token_here"}, "body": map[string]any{"operationName": "questionData", "variables": map[string]string{"titleSlug": title_slug}, "query": "query questionData($titleSlug: String!) { question(titleSlug: $titleSlug) { questionId title content difficulty likes dislikes } }"}}))
	var content_str string = fmt.Sprint(content_response)
	var cleaned string = remove_html_tags(content_str)
	return cleaned
}

func main() {
	var problem_id string = "3442"
	var result string = get_leetcode_problem(problem_id)
	fmt.Println("=== FINAL RESULT: LeetCode Problem", problem_id, "===")
	fmt.Println(result)
}

func _fetch(url string, opts map[string]any) any {
    method := "GET"
    if opts != nil {
        if m, ok := opts["method"].(string); ok {
            method = m
        }
    }
    var body io.Reader
    if opts != nil {
        if b, ok := opts["body"]; ok {
            data, err := json.Marshal(b)
            if err != nil { panic(err) }
            body = bytes.NewReader(data)
        }
    }
    u, err := url.Parse(url)
    if err != nil { panic(err) }
    if opts != nil {
        if q, ok := opts["query"]; ok {
            vals := u.Query()
            for k, v := range _toAnyMap(q) {
                vals.Set(k, fmt.Sprint(v))
            }
            u.RawQuery = vals.Encode()
        }
    }
    req, err := http.NewRequest(method, u.String(), body)
    if err != nil { panic(err) }
    if opts != nil {
        if hs, ok := opts["headers"]; ok {
            for k, v := range _toAnyMap(hs) {
                if s, ok := v.(string); ok {
                    req.Header.Set(k, s)
                }
            }
        }
    }
    client := http.DefaultClient
    if opts != nil {
        if t, ok := opts["timeout"]; ok {
            switch v := t.(type) {
            case int:
                client = &http.Client{Timeout: time.Duration(v) * time.Second}
            case int64:
                client = &http.Client{Timeout: time.Duration(v) * time.Second}
            case float64:
                client = &http.Client{Timeout: time.Duration(v * float64(time.Second))}
            case float32:
                client = &http.Client{Timeout: time.Duration(float64(v) * float64(time.Second))}
            }
        }
    }
    resp, err := client.Do(req)
    if err != nil { panic(err) }
    defer resp.Body.Close()
    data, err := io.ReadAll(resp.Body)
    if err != nil { panic(err) }
    var out any
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

func _indexString(s string, i int) string {
    runes := []rune(s)
    if i < 0 {
        i += len(runes)
    }
    if i < 0 || i >= len(runes) {
        panic("index out of range")
    }
    return string(runes[i])
}

func _toAnyMap(m any) map[string]any {
    switch v := m.(type) {
    case map[string]any:
        return v
    case map[string]string:
        out := make(map[string]any, len(v))
        for k, vv := range v {
            out[k] = vv
        }
        return out
    default:
        return nil
    }
}

