# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def Leaf() -> dict[str, typing.Any]:
	return {"__name": "Leaf"}

def Node(left: dict[str, typing.Any], value: int, right: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return {"__name": "Node", "left": left, "value": value, "right": right}

def isLeaf(t: dict[str, typing.Any]) -> bool:
	return (t["__name"] == "Leaf")

def left(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["left"]

def right(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["right"]

def value(t: dict[str, typing.Any]) -> int:
	return t["value"]

def max(a: int, b: int) -> int:
	if (a > b):
		return a
	else:
		return b

def findLeaves(root: dict[str, typing.Any]) -> list[list[int]]:
	result = []
	def dfs(node: dict[str, typing.Any]) -> int:
		nonlocal result
		if isLeaf(node):
			return (-1)
		lh = dfs(left(node))
		rh = dfs(right(node))
		h = (max(lh, rh) + 1)
		while (len(result) <= h):
			result = (result + [[]])
		result[h] = (result[h] + [value(node)])
		return h
	if isLeaf(root):
		return []
	dfs(root)
	return result

example1 = Node(Node(Node(Leaf(), 4, Leaf()), 2, Node(Leaf(), 5, Leaf())), 1, Node(Leaf(), 3, Leaf()))

def example():
	assert (findLeaves(example1) == [[4, 5, 3], [2], [1]])

def single_node():
	assert (findLeaves(Node(Leaf(), 1, Leaf())) == [[1]])

def main():
	example1 = Node(Node(Node(Leaf(), 4, Leaf()), 2, Node(Leaf(), 5, Leaf())), 1, Node(Leaf(), 3, Leaf()))
	example()
	single_node()

if __name__ == "__main__":
	main()
