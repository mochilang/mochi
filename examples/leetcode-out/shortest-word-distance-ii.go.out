package main

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

type WordDistance struct {
	Index map[string][]int `json:"index"`
}

func newWordDistance(words []string) WordDistance {
	var m map[string][]int = map[string][]int{}
	_ = m
	var i int = 0
	_ = i
	for (i < len(words)) {
		var w string = words[i]
		var lst []int = []int{}
		_ = lst
		_tmp0 := w
		_tmp1 := m
		_, _tmp2 := _tmp1[_tmp0]
		if _tmp2 {
			lst = m[w]
		}
		lst = append(append([]int{}, lst...), []int{i}...)
		m[w] = lst
		i = (i + 1)
	}
	return WordDistance{Index: m}
}

func min(a int, b int) int {
	if (a < b) {
		return a
	}
	return b
}

func shortest(wd WordDistance, word1 string, word2 string) int {
	var list1 []int = wd.Index[word1]
	var list2 []int = wd.Index[word2]
	var i int = 0
	_ = i
	var j int = 0
	_ = j
	var best int = 1000000000
	_ = best
	for ((i < len(list1)) && (j < len(list2))) {
		var a int = list1[i]
		var b int = list2[j]
		var diff int = (a - b)
		_ = diff
		if (diff < 0) {
			diff = -diff
		}
		best = min(best, diff)
		if (a < b) {
			i = (i + 1)
		} else {
			j = (j + 1)
		}
	}
	return best
}

func example() {
	var words []string = []string{"practice", "makes", "perfect", "coding", "makes"}
	var wd WordDistance = newWordDistance(words)
	expect((shortest(wd, "coding", "practice") == 3))
	expect((shortest(wd, "makes", "coding") == 1))
}

func same_word_many_times() {
	var words []string = []string{"a", "a", "b", "a"}
	var wd WordDistance = newWordDistance(words)
	expect((shortest(wd, "a", "b") == 1))
}

func main() {
	example()
	same_word_many_times()
}

