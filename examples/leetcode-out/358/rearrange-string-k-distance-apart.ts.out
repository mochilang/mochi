// Generated by Mochi TypeScript compiler

function rearrangeString(s: string, k: number) : string {
	if ((k <= 1)) {
		return s
	}
	let counts: Record<any, any> = {}
	let i: number = 0
	while ((i < s.length)) {
		let ch: string = s[i]
		if (Object.prototype.hasOwnProperty.call(counts, String(ch))) {
			counts[ch] = (counts[ch] + 1)
		} else {
			counts[ch] = 1
		}
		i = (i + 1)
	}
	let cooldown: Record<any, any> = {}
	let result: string = ""
	let step: number = 0
	let n: number = s.length
	while ((result.length < n)) {
		let bestChar: string = ""
		let bestCount: number = (-1)
		for (const ch of Object.keys(counts)) {
			let remaining: any = counts[ch]
			let next: number = 0
			if (Object.prototype.hasOwnProperty.call(cooldown, String(ch))) {
				next = cooldown[ch]
			}
			if (((remaining > 0) && (next <= step))) {
				if ((remaining > bestCount)) {
					bestCount = remaining
					bestChar = ch
				}
			}
		}
		if ((bestCount == ((-1)))) {
			return ""
		}
		result = result + bestChar
		counts[bestChar] = (counts[bestChar] - 1)
		cooldown[bestChar] = (step + k)
		step = (step + 1)
	}
	return result
}

function sortString(t: string) : string {
	let chars: Array<any> = []
	let i: number = 0
	while ((i < t.length)) {
		chars = chars.concat([t[i]])
		i = (i + 1)
	}
	let sorted: Array<any> = (() => {
	const _src = chars;
	let _items = [];
	for (const c of _src) {
		_items.push(c);
	}
	let _pairs = _items.map(it => { const c = it; return {item: it, key: c}; });
	_pairs.sort((a, b) => {
		const ak = a.key; const bk = b.key;
		if (typeof ak === 'number' && typeof bk === 'number') return ak - bk;
		if (typeof ak === 'string' && typeof bk === 'string') return ak < bk ? -1 : (ak > bk ? 1 : 0);
		return String(ak) < String(bk) ? -1 : (String(ak) > String(bk) ? 1 : 0);
	});
	_items = _pairs.map(p => p.item);
	const _res = [];
	for (const c of _items) {
		_res.push(c)
	}
	return _res;
})()
	let out: string = ""
	for (const c of sorted) {
		out = (out + c)
	}
	return out
}

function isValid(result: string, original: string, k: number) : boolean {
	if ((result == "")) {
		return true
	}
	if ((sortString(result) != sortString(original))) {
		return false
	}
	let pos: Record<any, any> = {}
	let i: number = 0
	while ((i < result.length)) {
		let ch: string = result[i]
		if (Object.prototype.hasOwnProperty.call(pos, String(ch))) {
			if (((i - pos[ch]) < k)) {
				return false
			}
		}
		pos[ch] = i
		i = (i + 1)
	}
	return true
}

function example_1(): void {
	let res: string = rearrangeString("aabbcc", 3)
	if (!(isValid(res, "aabbcc", 3))) { throw new Error('expect failed') }
}

function example_2(): void {
	if (!((rearrangeString("aaabc", 3) == ""))) { throw new Error('expect failed') }
}

function example_3(): void {
	let res: string = rearrangeString("aaadbbcc", 2)
	if (!(isValid(res, "aaadbbcc", 2))) { throw new Error('expect failed') }
}

function k_one(): void {
	let res: string = rearrangeString("aab", 1)
	if (!((res == "aab"))) { throw new Error('expect failed') }
}

function single_char(): void {
	if (!((rearrangeString("a", 2) == "a"))) { throw new Error('expect failed') }
}

function impossible(): void {
	if (!((rearrangeString("aaa", 2) == ""))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	example_2()
	example_3()
	k_one()
	single_char()
	impossible()
}
main()

