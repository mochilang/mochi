package main

import (
	"encoding/json"
	"reflect"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func findSubstring(s string, words []string) []int {
	if (len(words) == 0) {
		return _cast[[]int]([]any{})
	}
	var wordLen int = len(words[0])
	var wordCount int = len(words)
	var totalLen int = (wordLen * wordCount)
	if (len(s) < totalLen) {
		return _cast[[]int]([]any{})
	}
	var freq map[string]int = map[string]int{}
	for _, w := range words {
		_tmp0 := w
		_tmp1 := freq
		_, _tmp2 := _tmp1[_tmp0]
		if _tmp2 {
			freq[w] = (freq[w] + 1)
		} else {
			freq[w] = 1
		}
	}
	var result []int = []int{}
	for offset := 0; offset < wordLen; offset++ {
		var left int = offset
		var count int = 0
		var seen map[string]int = map[string]int{}
		var j int = offset
		for ((j + wordLen) <= len(s)) {
			var word string = string([]rune(s)[j:(j + wordLen)])
			j = (j + wordLen)
			_tmp3 := word
			_tmp4 := freq
			_, _tmp5 := _tmp4[_tmp3]
			if _tmp5 {
				_tmp6 := word
				_tmp7 := seen
				_, _tmp8 := _tmp7[_tmp6]
				if _tmp8 {
					seen[word] = (seen[word] + 1)
				} else {
					seen[word] = 1
				}
				count = (count + 1)
				for (seen[word] > freq[word]) {
					var lw string = string([]rune(s)[left:(left + wordLen)])
					seen[lw] = (seen[lw] - 1)
					left = (left + wordLen)
					count = (count - 1)
				}
				if (count == wordCount) {
					result = append(append([]int{}, result...), []int{left}...)
					var lw string = string([]rune(s)[left:(left + wordLen)])
					seen[lw] = (seen[lw] - 1)
					left = (left + wordLen)
					count = (count - 1)
				}
			} else {
				seen = map[string]int{}
				count = 0
				left = j
			}
		}
	}
	return result
}

func example_1() {
	expect(_equal(findSubstring("barfoothefoobarman", []string{"foo", "bar"}), []int{0, 9}))
}

func example_2() {
	expect(_equal(findSubstring("wordgoodgoodgoodbestword", []string{"word", "good", "best", "word"}), []any{}))
}

func example_3() {
	expect(_equal(findSubstring("barfoofoobarthefoobarman", []string{"bar", "foo", "the"}), []int{6, 9, 12}))
}

func main() {
	example_1()
	example_2()
	example_3()
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

func _equal(a, b any) bool {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice && av.Len() == 0 && bv.Len() == 0 {
        return true
    }
    return reflect.DeepEqual(a, b)
}

