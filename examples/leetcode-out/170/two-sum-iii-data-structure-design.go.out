package main

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

type TwoSum struct {
	Counts map[int]int `json:"counts"`
}

func newTwoSum() TwoSum {
	return TwoSum{Counts: _cast[map[int]int](map[any]any{})}
}

func add(ts TwoSum, number int) TwoSum {
	var counts map[int]int = ts.Counts
	_ = counts
	var current int = 0
	_ = current
	_tmp0 := number
	_tmp1 := counts
	_, _tmp2 := _tmp1[_tmp0]
	if _tmp2 {
		current = counts[number]
	}
	counts[number] = (current + 1)
	return TwoSum{Counts: counts}
}

func find(ts TwoSum, value int) bool {
	for key := range ts.Counts {
		var count func(any) int = ts.Counts[key]
		var complement int = (value - key)
		_tmp3 := complement
		_tmp4 := ts.Counts
		_, _tmp5 := _tmp4[_tmp3]
		if _tmp5 {
			var other int = ts.Counts[complement]
			if (key != complement) {
				return true
			} else {
				if (other > 1) {
					return true
				}
			}
		}
	}
	return false
}

func example() {
	var ts TwoSum = newTwoSum()
	_ = ts
	ts = add(ts, 1)
	ts = add(ts, 3)
	ts = add(ts, 5)
	expect((find(ts, 4) == true))
	expect((find(ts, 7) == false))
}

func duplicate_numbers() {
	var ts TwoSum = newTwoSum()
	_ = ts
	ts = add(ts, 2)
	ts = add(ts, 2)
	expect((find(ts, 4) == true))
	expect((find(ts, 3) == false))
}

func main() {
	example()
	duplicate_numbers()
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

