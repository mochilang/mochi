// Generated by Mochi C++ compiler
#include <bits/stdc++.h>
using namespace std;

template <typename T> T _cast(any v);
template <> inline int _cast<int>(any v) {
  if (v.type() == typeid(int))
    return any_cast<int>(v);
  if (v.type() == typeid(double))
    return int(any_cast<double>(v));
  if (v.type() == typeid(string))
    return stoi(any_cast<string>(v));
  return 0;
}
template <> inline double _cast<double>(any v) {
  if (v.type() == typeid(double))
    return any_cast<double>(v);
  if (v.type() == typeid(int))
    return double(any_cast<int>(v));
  if (v.type() == typeid(string))
    return stod(any_cast<string>(v));
  return 0.0;
}
template <> inline bool _cast<bool>(any v) {
  if (v.type() == typeid(bool))
    return any_cast<bool>(v);
  if (v.type() == typeid(string))
    return any_cast<string>(v) == "true";
  if (v.type() == typeid(int))
    return any_cast<int>(v) != 0;
  return false;
}
template <> inline string _cast<string>(any v) {
  if (v.type() == typeid(string))
    return any_cast<string>(v);
  if (v.type() == typeid(int))
    return to_string(any_cast<int>(v));
  if (v.type() == typeid(double)) {
    stringstream ss;
    ss << any_cast<double>(v);
    return ss.str();
  }
  if (v.type() == typeid(bool))
    return any_cast<bool>(v) ? "true" : "false";
  return "";
}

double findMedianSortedArrays(vector<int> nums1, vector<int> nums2) {
  vector<int> merged = vector<int>{};
  auto i = 0;
  auto j = 0;
  while (i < nums1.size() || j < nums2.size()) {
    if (j >= nums2.size()) {
      merged = ([&](vector<int> a, vector<int> b) {
        a.insert(a.end(), b.begin(), b.end());
        return a;
      })(merged, vector<int>{nums1[i]});
      i = i + 1;
    } else if (i >= nums1.size()) {
      merged = ([&](vector<int> a, vector<int> b) {
        a.insert(a.end(), b.begin(), b.end());
        return a;
      })(merged, vector<int>{nums2[j]});
      j = j + 1;
    } else if (nums1[i] <= nums2[j]) {
      merged = ([&](vector<int> a, vector<int> b) {
        a.insert(a.end(), b.begin(), b.end());
        return a;
      })(merged, vector<int>{nums1[i]});
      i = i + 1;
    } else {
      merged = ([&](vector<int> a, vector<int> b) {
        a.insert(a.end(), b.begin(), b.end());
        return a;
      })(merged, vector<int>{nums2[j]});
      j = j + 1;
    }
  }
  auto total = merged.size();
  if (total % 2 == 1) {
    return _cast<double>(merged[total / 2]);
  }
  auto mid1 = merged[total / 2 - 1];
  auto mid2 = merged[total / 2];
  return _cast<double>((mid1 + mid2)) / 2.0;
}

int main() {
  auto test_example_1 = [&]() {
    if (!(findMedianSortedArrays(vector<int>{1, 3}, vector<int>{2}) == 2.0)) {
      std::cerr << "expect failed\n";
      exit(1);
    }
  };
  test_example_1();
  auto test_example_2 = [&]() {
    if (!(findMedianSortedArrays(vector<int>{1, 2}, vector<int>{3, 4}) ==
          2.5)) {
      std::cerr << "expect failed\n";
      exit(1);
    }
  };
  test_example_2();
  auto test_empty_first = [&]() {
    if (!(findMedianSortedArrays(_cast<vector<int>>(vector<int>{}),
                                 vector<int>{1}) == 1.0)) {
      std::cerr << "expect failed\n";
      exit(1);
    }
  };
  test_empty_first();
  auto test_empty_second = [&]() {
    if (!(findMedianSortedArrays(vector<int>{2},
                                 _cast<vector<int>>(vector<int>{})) == 2.0)) {
      std::cerr << "expect failed\n";
      exit(1);
    }
  };
  test_empty_second();
  return 0;
}
