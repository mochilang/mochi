// Generated by Mochi TypeScript compiler

let example: Record<string, any> = Node(Node(Leaf(), 2, Leaf()), 1, Node(Node(Leaf(), 4, Leaf()), 3, Node(Leaf(), 5, Leaf())))

function parseInt(s: string) : number {
	let result: number = 0
	let i: number = 0
	let digits: Record<string, number> = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	while ((i < s.length)) {
		result = ((result * 10) + digits[s[i]])
		i = (i + 1)
	}
	return result
}

function splitComma(s: string) : Array<string> {
	let parts: Array<any> = []
	let current: string = ""
	let i: number = 0
	while ((i < s.length)) {
		let c: string = s[i]
		if ((c == ",")) {
			parts = parts.concat([current])
			current = ""
		} else {
			current = current + c
		}
		i = (i + 1)
	}
	parts = parts.concat([current])
	return parts
}

function join(parts: Array<string>, sep: string) : string {
	let result: string = ""
	let i: number = 0
	while ((i < parts.length)) {
		if ((i > 0)) {
			result = result + sep
		}
		result = result + parts[i]
		i = (i + 1)
	}
	return result
}

function Leaf() : Record<string, any> {
	return {"__name": "Leaf"}
}

function Node(left: Record<string, any>, value: number, right: Record<string, any>) : Record<string, any> {
	return {"__name": "Node", "left": left, "value": value, "right": right}
}

function isLeaf(t: Record<string, any>) : boolean {
	return _equal(t["__name"], "Leaf")
}

function left(t: Record<string, any>) : Record<string, any> {
	return t["left"]
}

function right(t: Record<string, any>) : Record<string, any> {
	return t["right"]
}

function value(t: Record<string, any>) : number {
	return t["value"]
}

function serialize(root: Record<string, any>) : string {
	if (isLeaf(root)) {
		return ""
	}
	let queue: Array<Record<string, any>> = [root]
	let parts: Array<any> = []
	while ((queue.length > 0)) {
		let node: Record<string, any> = queue[0]
		queue = queue.slice(1, queue.length)
		if (isLeaf(node)) {
			parts = parts.concat(["null"])
		} else {
			parts = parts.concat([String(value(node))])
			queue = queue.concat([left(node)])
			queue = queue.concat([right(node)])
		}
	}
	let i: number = (parts.length - 1)
	while (((i >= 0) && _equal(parts[i], "null"))) {
		i = (i - 1)
	}
	parts = parts.slice(0, (i + 1))
	return join(parts, ",")
}

function deserialize(data: string) : Record<string, any> {
	if ((data == "")) {
		return Leaf()
	}
	let vals: Array<string> = splitComma(data)
	function build(i: number) : Record<string, any> {
		if ((i >= vals.length)) {
			return Leaf()
		}
		let v: string = vals[i]
		if ((v == "null")) {
			return Leaf()
		}
		let leftNode: any = build(((2 * i) + 1))
		let rightNode: any = build(((2 * i) + 2))
		return Node(leftNode, parseInt(v), rightNode)
	}
	return build(0)
}

function serialize_round_trip(): void {
	let s: string = serialize(example)
	let t: Record<string, any> = deserialize(s)
	if (!((serialize(t) == s))) { throw new Error('expect failed') }
}

function empty_tree(): void {
	if (!((serialize(Leaf()) == ""))) { throw new Error('expect failed') }
	if (!((isLeaf(deserialize("")) == true))) { throw new Error('expect failed') }
}

function single_node(): void {
	let s: string = serialize(Node(Leaf(), 7, Leaf()))
	if (!((s == "7"))) { throw new Error('expect failed') }
	if (!((serialize(deserialize(s)) == "7"))) { throw new Error('expect failed') }
}

function main(): void {
	serialize_round_trip()
	empty_tree()
	single_node()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

main()

