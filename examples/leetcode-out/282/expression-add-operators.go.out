package main

import (
	"fmt"
	"reflect"
	"sort"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func parseInt(s string) int {
	var result int = 0
	var i int = 0
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	for (i < len(s)) {
		result = ((result * 10) + digits[_indexString(s, i)])
		i = (i + 1)
	}
	return result
}

func addOperators(num string, target int) []string {
	var result []string = []string{}
	var backtrack func(int, string, int, int)
	backtrack = func(pos int, expr string, value int, prev int) {
		if (pos == len(num)) {
			if (value == target) {
				result = append(append([]string{}, result...), []string{expr}...)
			}
		} else {
			var i int = pos
			for (i < len(num)) {
				if ((i != pos) && (_indexString(num, pos) == "0")) {
					break
				}
				var part string = string([]rune(num)[pos:(i + 1)])
				var cur int = parseInt(part)
				if (pos == 0) {
					backtrack((i + 1), part, cur, cur)
				} else {
					backtrack((i + 1), expr + "+" + part, (value + cur), cur)
					backtrack((i + 1), expr + "-" + part, (value - cur), -cur)
					backtrack((i + 1), expr + "*" + part, ((value - prev) + (prev * cur)), (prev * cur))
				}
				i = (i + 1)
			}
		}
}
	backtrack(0, "", 0, 0)
	return result
}

func example_1() {
	var res []string = addOperators("123", 6)
	var sorted []string = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	_res := []string{}
	for _, x := range items {
		_res = append(_res, x)
	}
	return _res
}()
	_ = sorted
	expect(_equal(sorted, []string{"1*2*3", "1+2+3"}))
}

func example_2() {
	var res []string = addOperators("232", 8)
	var sorted []string = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	_res := []string{}
	for _, x := range items {
		_res = append(_res, x)
	}
	return _res
}()
	_ = sorted
	expect(_equal(sorted, []string{"2*3+2", "2+3*2"}))
}

func example_3() {
	var res []string = addOperators("105", 5)
	var sorted []string = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	_res := []string{}
	for _, x := range items {
		_res = append(_res, x)
	}
	return _res
}()
	_ = sorted
	expect(_equal(sorted, []string{"1*0+5", "10-5"}))
}

func example_4() {
	var res []string = addOperators("00", 0)
	var sorted []string = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	_res := []string{}
	for _, x := range items {
		_res = append(_res, x)
	}
	return _res
}()
	_ = sorted
	expect(_equal(sorted, []string{"0*0", "0+0", "0-0"}))
}

func example_5() {
	expect(_equal(addOperators("3456237490", 9191), []any{}))
}

func single_number() {
	expect(_equal(addOperators("5", 5), []string{"5"}))
}

func main() {
	example_1()
	example_2()
	example_3()
	example_4()
	example_5()
	single_number()
}

func _equal(a, b any) bool {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice && av.Len() == 0 && bv.Len() == 0 {
        return true
    }
    return reflect.DeepEqual(a, b)
}

func _indexString(s string, i int) string {
    runes := []rune(s)
    if i < 0 {
        i += len(runes)
    }
    if i < 0 || i >= len(runes) {
        panic("index out of range")
    }
    return string(runes[i])
}

