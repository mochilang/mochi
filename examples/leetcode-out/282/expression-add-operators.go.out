package main

import (
	"fmt"
	"sort"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func parseInt(s string) int {
	var result int = 0
	var i int = 0
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	for (i < len(s)) {
		result = ((result * 10) + digits[_indexString(s, i)])
		i = (i + 1)
	}
	return result
}

func addOperators(num string, target int) []string {
	var result []any = []any{}
	backtrack(0, "", 0, 0)
	return result
}

func example_1() {
	var res []string = addOperators("123", 6)
	var sorted []any = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	res := []string{}
	for _, x := range items {
		res = append(res, x)
	}
	return res
}()
	expect((sorted == []string{"1*2*3", "1+2+3"}))
}

func example_2() {
	var res []string = addOperators("232", 8)
	var sorted []any = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	res := []string{}
	for _, x := range items {
		res = append(res, x)
	}
	return res
}()
	expect((sorted == []string{"2*3+2", "2+3*2"}))
}

func example_3() {
	var res []string = addOperators("105", 5)
	var sorted []any = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	res := []string{}
	for _, x := range items {
		res = append(res, x)
	}
	return res
}()
	expect((sorted == []string{"1*0+5", "10-5"}))
}

func example_4() {
	var res []string = addOperators("00", 0)
	var sorted []any = func() []string {
	items := []string{}
	for _, x := range res {
		items = append(items, x)
	}
	type pair struct { item string; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		x := it
		pairs[idx] = pair{item: it, key: x}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	res := []string{}
	for _, x := range items {
		res = append(res, x)
	}
	return res
}()
	expect((sorted == []string{"0*0", "0+0", "0-0"}))
}

func example_5() {
	expect((addOperators("3456237490", 9191) == []any{}))
}

func single_number() {
	expect((addOperators("5", 5) == []string{"5"}))
}

func main() {
	example_1()
	example_2()
	example_3()
	example_4()
	example_5()
	single_number()
}

func _indexString(s string, i int) string {
    runes := []rune(s)
    if i < 0 {
        i += len(runes)
    }
    if i < 0 || i >= len(runes) {
        panic("index out of range")
    }
    return string(runes[i])
}

