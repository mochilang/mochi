# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def Int(val: int) -> dict[str, typing.Any]:
	return {"__name": "Int", "value": val}

def List(items: list[dict[str, typing.Any]]) -> dict[str, typing.Any]:
	return {"__name": "List", "items": items}

def isInt(node: dict[str, typing.Any]) -> bool:
	return (node["__name"] == "Int")

def value(node: dict[str, typing.Any]) -> int:
	return node["value"]

def items(node: dict[str, typing.Any]) -> list[dict[str, typing.Any]]:
	return node["items"]

def depthSumInverse(nested: list[dict[str, typing.Any]]) -> int:
	queue = nested
	levels = []
	while (len(queue) > 0):
		next = []
		levelSum = 0
		for node in queue:
			if isInt(node):
				levelSum = (levelSum + value(node))
			else:
				next = (next + items(node))
		levels = ([levelSum] + levels)
		queue = next
	weight = 1
	total = 0
	for s in levels:
		total = (total + (s * weight))
		weight = (weight + 1)
	return total

example1 = [List([Int(1), Int(1)]), Int(2), List([Int(1), Int(1)])]

def example_1():
	assert (depthSumInverse(example1) == 8)

def example_2():
	assert (depthSumInverse(example2) == 17)

def empty():
	assert (depthSumInverse([]) == 0)

def main():
	example1 = [List([Int(1), Int(1)]), Int(2), List([Int(1), Int(1)])]
	example2 = [Int(1), List([Int(4), List([Int(6)])])]
	example_1()
	example_2()
	empty()

if __name__ == "__main__":
	main()
