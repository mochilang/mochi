// Generated by Mochi TypeScript compiler

function newWordDistance(words: Array<string>) : WordDistance {
	let m: Record<any, any> = {}
	let i: number = 0
	while ((i < words.length)) {
		let w: string = words[i]
		let lst: Array<any> = []
		if (Object.prototype.hasOwnProperty.call(m, String(w))) {
			lst = m[w]
		}
		lst = lst.concat([i])
		m[w] = lst
		i = (i + 1)
	}
	return {index: m}
}

function min(a: number, b: number) : number {
	if ((a < b)) {
		return a
	}
	return b
}

function shortest(wd: WordDistance, word1: string, word2: string) : number {
	let list1: Array<number> = wd.index[word1]
	let list2: Array<number> = wd.index[word2]
	let i: number = 0
	let j: number = 0
	let best: number = 1000000000
	while (((i < list1.length) && (j < list2.length))) {
		let a: number = list1[i]
		let b: number = list2[j]
		let diff: number = (a - b)
		if ((diff < 0)) {
			diff = (-diff)
		}
		best = min(best, diff)
		if ((a < b)) {
			i = (i + 1)
		} else {
			j = (j + 1)
		}
	}
	return best
}

function example(): void {
	let words: Array<string> = ["practice", "makes", "perfect", "coding", "makes"]
	let wd: WordDistance = newWordDistance(words)
	if (!((shortest(wd, "coding", "practice") == 3))) { throw new Error('expect failed') }
	if (!((shortest(wd, "makes", "coding") == 1))) { throw new Error('expect failed') }
}

function same_word_many_times(): void {
	let words: Array<string> = ["a", "a", "b", "a"]
	let wd: WordDistance = newWordDistance(words)
	if (!((shortest(wd, "a", "b") == 1))) { throw new Error('expect failed') }
}

function main(): void {
	type WordDistance = {
		index: any;
	}
	example()
	same_word_many_times()
}
main()

