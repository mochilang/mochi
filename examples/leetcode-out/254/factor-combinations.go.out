package main

import (
	"encoding/json"
	"reflect"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func getFactors(n int) [][]int {
	if (n <= 3) {
		return _cast[[][]int]([]any{})
	}
	var result [][]int = [][]int{}
	var dfs func(int, int, []int)
	dfs = func(start int, num int, path []int) {
		var i int = start
		for ((i * i) <= num) {
			if ((num % i) == 0) {
				var next int = (num / i)
				result = append(append([][]int{}, result...), [][]int{append(append([]int{}, path...), []int{i, next}...)}...)
				dfs(i, next, append(append([]int{}, path...), []int{i}...))
			}
			i = (i + 1)
		}
}
	dfs(2, n, []int{})
	return result
}

func example_1() {
	expect(_equal(getFactors(12), [][]int{[]int{2, 6}, []int{2, 2, 3}, []int{3, 4}}))
}

func example_2() {
	expect(_equal(getFactors(15), [][]int{[]int{3, 5}}))
}

func prime() {
	expect(_equal(getFactors(37), []any{}))
}

func main() {
	example_1()
	example_2()
	prime()
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

func _equal(a, b any) bool {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice && av.Len() == 0 && bv.Len() == 0 {
        return true
    }
    return reflect.DeepEqual(a, b)
}

