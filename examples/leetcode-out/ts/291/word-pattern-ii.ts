// Generated by Mochi TypeScript compiler

function wordPatternMatch(pattern: string, s: string): boolean {
  let m: number = pattern.length;
  let n: number = s.length;
  function dfs(
    pi: number,
    si: number,
    mapping: Record<string, string>,
    used: Record<string, boolean>,
  ): boolean {
    if (pi == m && si == n) {
      return true;
    }
    if (pi == m || si == n) {
      return false;
    }
    let ch: string = pattern.slice(pi, pi + 1);
    if (Object.prototype.hasOwnProperty.call(mapping, String(ch))) {
      let word: string = mapping[ch];
      let l: number = word.length;
      if (si + l > n) {
        return false;
      }
      if (s.slice(si, si + l) != word) {
        return false;
      }
      return dfs(pi + 1, si + l, mapping, used);
    }
    let end: number = si + 1;
    while (end <= n) {
      let word: string = s.slice(si, end);
      let already: boolean = false;
      if (Object.prototype.hasOwnProperty.call(used, String(word))) {
        already = used[word];
      }
      if (!already) {
        let nextMap: Record<string, string> = mapping;
        let nextUsed: Record<string, boolean> = used;
        nextMap[ch] = word;
        nextUsed[word] = true;
        if (dfs(pi + 1, end, nextMap, nextUsed)) {
          return true;
        }
      }
      end = end + 1;
    }
    return false;
  }
  return dfs(0, 0, {}, {});
}

function example_1(): void {
  if (!(wordPatternMatch("abab", "redblueredblue") == true)) {
    throw new Error("expect failed");
  }
}

function example_2(): void {
  if (!(wordPatternMatch("aaaa", "asdasdasdasd") == true)) {
    throw new Error("expect failed");
  }
}

function example_3(): void {
  if (!(wordPatternMatch("aabb", "xyzabcxzyabc") == false)) {
    throw new Error("expect failed");
  }
}

function main(): void {
  example_1();
  example_2();
  example_3();
}
main();
