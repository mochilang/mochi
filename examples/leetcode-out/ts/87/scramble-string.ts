// Generated by Mochi TypeScript compiler

function isScramble(s1: string, s2: string): boolean {
  if ((s1.length != s2.length)) {
    return false;
  }
  function sameLetters(a: string, b: string): boolean {
    if ((a.length != b.length)) {
      return false;
    }
    let count: Record<string, number> = {};
    (globalThis as any).count = count;
    let i: number = 0;
    (globalThis as any).i = i;
    while ((i < a.length)) {
      let ch: string = _indexString(a, i);
      (globalThis as any).ch = ch;
      if (Object.prototype.hasOwnProperty.call(count, String(ch))) {
        count[ch] = count[ch] + 1;
      } else {
        count[ch] = 1;
      }
      i = i + 1;
    }
    i = 0;
    while ((i < b.length)) {
      let ch: string = _indexString(b, i);
      (globalThis as any).ch = ch;
      if (Object.prototype.hasOwnProperty.call(count, String(ch))) {
        count[ch] = count[ch] - 1;
      } else {
        return false;
      }
      i = i + 1;
    }
    for (const key of Object.keys(count)) {
      if ((count[key] != 0)) {
        return false;
      }
    }
    return true;
  }
  if ((!sameLetters(s1, s2))) {
    return false;
  }
  let memo: Record<number, boolean> = {};
  (globalThis as any).memo = memo;
  let n: number = s1.length;
  (globalThis as any).n = n;
  function dfs(i1: number, i2: number, length: number): boolean {
    let key: number = (((i1 * n) * 31) + (i2 * 31)) + length;
    (globalThis as any).key = key;
    if (Object.prototype.hasOwnProperty.call(memo, String(key))) {
      return memo[key];
    }
    let a: string = _sliceString(s1, i1, i1 + length);
    (globalThis as any).a = a;
    let b: string = _sliceString(s2, i2, i2 + length);
    (globalThis as any).b = b;
    if ((a == b)) {
      memo[key] = true;
      return true;
    }
    if ((!sameLetters(a, b))) {
      memo[key] = false;
      return false;
    }
    let k: number = 1;
    (globalThis as any).k = k;
    while ((k < length)) {
      if ((dfs(i1, i2, k) && dfs(i1 + k, i2 + k, length - k))) {
        memo[key] = true;
        return true;
      }
      if ((dfs(i1, (i2 + length) - k, k) && dfs(i1 + k, i2, length - k))) {
        memo[key] = true;
        return true;
      }
      k = k + 1;
    }
    memo[key] = false;
    return false;
  }
  return dfs(0, 0, n);
}

function test_example_1(): void {
  if (!(isScramble("great", "rgeat") == true)) throw new Error("expect failed");
}

function test_example_2(): void {
  if (!(isScramble("abcde", "caebd") == false)) {
    throw new Error("expect failed");
  }
}

function test_example_3(): void {
  if (!(isScramble("a", "a") == true)) throw new Error("expect failed");
}

function main(): void {
  test_example_1();
  test_example_2();
  test_example_3();
}
function _indexString(s: string, i: number): string {
  const runes = Array.from(s);
  if (i < 0) i += runes.length;
  if (i < 0 || i >= runes.length) throw new Error("index out of range");
  return runes[i];
}

function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
