// Generated by Mochi TypeScript compiler

function shortestDistance(grid: Array<Array<number>>): number {
  let rows: number = grid.length;
  (globalThis as any).rows = rows;
  if ((rows == 0)) {
    return (-1);
  }
  let cols: number = grid[0].length;
  (globalThis as any).cols = cols;
  let dist: Array<Array<number>> = [];
  (globalThis as any).dist = dist;
  let reach: Array<Array<number>> = [];
  (globalThis as any).reach = reach;
  let r: number = 0;
  (globalThis as any).r = r;
  while ((r < rows)) {
    let distRow: Array<number> = [];
    (globalThis as any).distRow = distRow;
    let reachRow: Array<number> = [];
    (globalThis as any).reachRow = reachRow;
    let c: number = 0;
    (globalThis as any).c = c;
    while ((c < cols)) {
      distRow = distRow.concat([0]);
      reachRow = reachRow.concat([0]);
      c = c + 1;
    }
    dist = dist.concat([distRow]);
    reach = reach.concat([reachRow]);
    r = r + 1;
  }
  let dirs: Array<Array<number>> = [
    [
      1,
      0,
    ],
    [
      -1,
      0,
    ],
    [
      0,
      1,
    ],
    [
      0,
      -1,
    ],
  ];
  (globalThis as any).dirs = dirs;
  let total: number = 0;
  (globalThis as any).total = total;
  r = 0;
  while ((r < rows)) {
    let c: number = 0;
    (globalThis as any).c = c;
    while ((c < cols)) {
      if ((grid[r][c] == 1)) {
        total = total + 1;
        let queue: Array<Array<number>> = [
          [
            r,
            c,
          ],
        ];
        (globalThis as any).queue = queue;
        let visited: Array<Array<boolean>> = [];
        (globalThis as any).visited = visited;
        let vr: number = 0;
        (globalThis as any).vr = vr;
        while ((vr < rows)) {
          let row: Array<boolean> = [];
          (globalThis as any).row = row;
          let vc: number = 0;
          (globalThis as any).vc = vc;
          while ((vc < cols)) {
            row = row.concat([false]);
            vc = vc + 1;
          }
          visited = visited.concat([row]);
          vr = vr + 1;
        }
        visited[r][c] = true;
        let idx: number = 0;
        (globalThis as any).idx = idx;
        let level: number = 0;
        (globalThis as any).level = level;
        while ((idx < queue.length)) {
          let size: number = queue.length - idx;
          (globalThis as any).size = size;
          let i: number = 0;
          (globalThis as any).i = i;
          while ((i < size)) {
            let pos: Array<number> = queue[idx];
            (globalThis as any).pos = pos;
            idx = idx + 1;
            let pr: number = pos[0];
            (globalThis as any).pr = pr;
            let pc: number = pos[1];
            (globalThis as any).pc = pc;
            dist[pr][pc] = dist[pr][pc] + level;
            reach[pr][pc] = reach[pr][pc] + 1;
            let d: number = 0;
            (globalThis as any).d = d;
            while ((d < dirs.length)) {
              let nr: number = pr + dirs[d][0];
              (globalThis as any).nr = nr;
              let nc: number = pc + dirs[d][1];
              (globalThis as any).nc = nc;
              if (((((nr >= 0) && (nr < rows)) && (nc >= 0)) && (nc < cols))) {
                if ((grid[nr][nc] == 0)) {
                  if ((!(visited[nr][nc]))) {
                    visited[nr][nc] = true;
                    queue = queue.concat([
                      [
                        nr,
                        nc,
                      ],
                    ]);
                  }
                }
              }
              d = d + 1;
            }
            i = i + 1;
          }
          level = level + 1;
        }
      }
      c = c + 1;
    }
    r = r + 1;
  }
  let best: number = 2147483647;
  (globalThis as any).best = best;
  r = 0;
  while ((r < rows)) {
    let c: number = 0;
    (globalThis as any).c = c;
    while ((c < cols)) {
      if ((grid[r][c] == 0)) {
        if ((reach[r][c] == total)) {
          if ((dist[r][c] < best)) {
            best = dist[r][c];
          }
        }
      }
      c = c + 1;
    }
    r = r + 1;
  }
  if ((best == 2147483647)) {
    return (-1);
  }
  return best;
}

function test_example_1(): void {
  if (!(shortestDistance(grid1) == 7)) throw new Error("expect failed");
}

function test_simple(): void {
  if (!(shortestDistance(grid2) == 1)) throw new Error("expect failed");
}

function test_empty(): void {
  if (!(shortestDistance(grid3) == (-1))) throw new Error("expect failed");
}

function main(): void {
  let grid1: Array<Array<number>> = [
    [
      1,
      0,
      2,
      0,
      1,
    ],
    [
      0,
      0,
      0,
      0,
      0,
    ],
    [
      0,
      0,
      1,
      0,
      0,
    ],
  ];
  (globalThis as any).grid1 = grid1;
  let grid2: Array<Array<number>> = [
    [
      1,
      0,
    ],
    [
      0,
      0,
    ],
  ];
  (globalThis as any).grid2 = grid2;
  let grid3: Array<any> = [];
  (globalThis as any).grid3 = grid3;
  test_example_1();
  test_simple();
  test_empty();
}
main();
