// Generated by Mochi TypeScript compiler

let grid1: Array<Array<number>> = [
  [1, 0, 2, 0, 1],
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0],
];

let grid2: Array<Array<number>> = [
  [1, 0],
  [0, 0],
];

let grid3: Array<any> = [];

function shortestDistance(grid: Array<Array<number>>): number {
  let rows: number = grid.length;
  if (rows == 0) {
    return -1;
  }
  let cols: number = grid[0].length;
  let dist: Array<Array<number>> = [];
  let reach: Array<Array<number>> = [];
  let r: number = 0;
  while (r < rows) {
    let distRow: Array<number> = [];
    let reachRow: Array<number> = [];
    let c: number = 0;
    while (c < cols) {
      distRow = distRow.concat([0]);
      reachRow = reachRow.concat([0]);
      c = c + 1;
    }
    dist = dist.concat([distRow]);
    reach = reach.concat([reachRow]);
    r = r + 1;
  }
  let dirs: Array<Array<number>> = [
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1],
  ];
  let total: number = 0;
  r = 0;
  while (r < rows) {
    let c: number = 0;
    while (c < cols) {
      if (grid[r][c] == 1) {
        total = total + 1;
        let queue: Array<Array<number>> = [[r, c]];
        let visited: Array<Array<boolean>> = [];
        let vr: number = 0;
        while (vr < rows) {
          let row: Array<boolean> = [];
          let vc: number = 0;
          while (vc < cols) {
            row = row.concat([false]);
            vc = vc + 1;
          }
          visited = visited.concat([row]);
          vr = vr + 1;
        }
        visited[r][c] = true;
        let idx: number = 0;
        let level: number = 0;
        while (idx < queue.length) {
          let size: number = queue.length - idx;
          let i: number = 0;
          while (i < size) {
            let pos: Array<number> = queue[idx];
            idx = idx + 1;
            let pr: number = pos[0];
            let pc: number = pos[1];
            dist[pr][pc] = dist[pr][pc] + level;
            reach[pr][pc] = reach[pr][pc] + 1;
            let d: number = 0;
            while (d < dirs.length) {
              let nr: number = pr + dirs[d][0];
              let nc: number = pc + dirs[d][1];
              if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                if (grid[nr][nc] == 0) {
                  if (!visited[nr][nc]) {
                    visited[nr][nc] = true;
                    queue = queue.concat([[nr, nc]]);
                  }
                }
              }
              d = d + 1;
            }
            i = i + 1;
          }
          level = level + 1;
        }
      }
      c = c + 1;
    }
    r = r + 1;
  }
  let best: number = 2147483647;
  r = 0;
  while (r < rows) {
    let c: number = 0;
    while (c < cols) {
      if (grid[r][c] == 0) {
        if (reach[r][c] == total) {
          if (dist[r][c] < best) {
            best = dist[r][c];
          }
        }
      }
      c = c + 1;
    }
    r = r + 1;
  }
  if (best == 2147483647) {
    return -1;
  }
  return best;
}

function example_1(): void {
  if (!(shortestDistance(grid1) == 7)) {
    throw new Error("expect failed");
  }
}

function simple(): void {
  if (!(shortestDistance(grid2) == 1)) {
    throw new Error("expect failed");
  }
}

function empty(): void {
  if (!(shortestDistance(grid3) == -1)) {
    throw new Error("expect failed");
  }
}

function main(): void {
  example_1();
  simple();
  empty();
}
main();
