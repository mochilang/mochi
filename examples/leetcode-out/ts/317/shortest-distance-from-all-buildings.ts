// Generated by Mochi TypeScript compiler

let grid1: Array<Array<number>> = [[1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]]

let grid2: Array<Array<number>> = [[1, 0], [0, 0]]

let grid3: Array<any> = []

function shortestDistance(grid: Array<Array<number>>) : number {
	let rows: number = grid.length
	if ((rows == 0)) {
		return (-1)
	}
	let cols: number = grid[0].length
	let dist: Array<Array<number>> = []
	let reach: Array<Array<number>> = []
	let r: number = 0
	while ((r < rows)) {
		let distRow: Array<number> = []
		let reachRow: Array<number> = []
		let c: number = 0
		while ((c < cols)) {
			distRow = distRow.concat([0])
			reachRow = reachRow.concat([0])
			c = (c + 1)
		}
		dist = dist.concat([distRow])
		reach = reach.concat([reachRow])
		r = (r + 1)
	}
	let dirs: Array<Array<number>> = [[1, 0], [(-1), 0], [0, 1], [0, (-1)]]
	let total: number = 0
	r = 0
	while ((r < rows)) {
		let c: number = 0
		while ((c < cols)) {
			if ((grid[r][c] == 1)) {
				total = (total + 1)
				let queue: Array<Array<number>> = [[r, c]]
				let visited: Array<Array<boolean>> = []
				let vr: number = 0
				while ((vr < rows)) {
					let row: Array<boolean> = []
					let vc: number = 0
					while ((vc < cols)) {
						row = row.concat([false])
						vc = (vc + 1)
					}
					visited = visited.concat([row])
					vr = (vr + 1)
				}
				visited[r][c] = true
				let idx: number = 0
				let level: number = 0
				while ((idx < queue.length)) {
					let size: number = (queue.length - idx)
					let i: number = 0
					while ((i < size)) {
						let pos: Array<number> = queue[idx]
						idx = (idx + 1)
						let pr: number = pos[0]
						let pc: number = pos[1]
						dist[pr][pc] = (dist[pr][pc] + level)
						reach[pr][pc] = (reach[pr][pc] + 1)
						let d: number = 0
						while ((d < dirs.length)) {
							let nr: number = (pr + dirs[d][0])
							let nc: number = (pc + dirs[d][1])
							if (((((nr >= 0) && (nr < rows)) && (nc >= 0)) && (nc < cols))) {
								if ((grid[nr][nc] == 0)) {
									if ((!(visited[nr][nc]))) {
										visited[nr][nc] = true
										queue = queue.concat([[nr, nc]])
									}
								}
							}
							d = (d + 1)
						}
						i = (i + 1)
					}
					level = (level + 1)
				}
			}
			c = (c + 1)
		}
		r = (r + 1)
	}
	let best: number = 2147483647
	r = 0
	while ((r < rows)) {
		let c: number = 0
		while ((c < cols)) {
			if ((grid[r][c] == 0)) {
				if ((reach[r][c] == total)) {
					if ((dist[r][c] < best)) {
						best = dist[r][c]
					}
				}
			}
			c = (c + 1)
		}
		r = (r + 1)
	}
	if ((best == 2147483647)) {
		return (-1)
	}
	return best
}

function example_1(): void {
	if (!((shortestDistance(grid1) == 7))) { throw new Error('expect failed') }
}

function simple(): void {
	if (!((shortestDistance(grid2) == 1))) { throw new Error('expect failed') }
}

function empty(): void {
	if (!((shortestDistance(grid3) == ((-1))))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	simple()
	empty()
}
main()

