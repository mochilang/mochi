// Generated by Mochi TypeScript compiler

function pickMax(nums: Array<number>, k: number): Array<number> {
  let drop: number = nums.length - k;
  (globalThis as any).drop = drop;
  let stack: Array<number> = [];
  (globalThis as any).stack = stack;
  let i: number = 0;
  (globalThis as any).i = i;
  let toDrop: number = drop;
  (globalThis as any).toDrop = toDrop;
  while ((i < nums.length)) {
    let num: number = nums[i];
    (globalThis as any).num = num;
    while (((toDrop > 0) && (stack.length > 0))) {
      if ((stack[stack.length - 1] < num)) {
        stack = stack.slice(0, stack.length - 1);
        toDrop = toDrop - 1;
      } else {
        break;
      }
    }
    stack = stack.concat([num]);
    i = i + 1;
  }
  return stack.slice(0, k);
}

function greaterSeq(
  a: Array<number>,
  i: number,
  b: Array<number>,
  j: number,
): boolean {
  let x: number = i;
  (globalThis as any).x = x;
  let y: number = j;
  (globalThis as any).y = y;
  while (((x < a.length) && (y < b.length))) {
    if ((a[x] > b[y])) {
      return true;
    }
    if ((a[x] < b[y])) {
      return false;
    }
    x = x + 1;
    y = y + 1;
  }
  return (x != a.length);
}

function maxNumber(
  nums1: Array<number>,
  nums2: Array<number>,
  k: number,
): Array<number> {
  let best: Array<number> = [];
  (globalThis as any).best = best;
  let i: number = 0;
  (globalThis as any).i = i;
  while ((i <= k)) {
    if (((i <= nums1.length) && ((k - i) <= nums2.length))) {
      let part1: Array<number> = pickMax(nums1, i);
      (globalThis as any).part1 = part1;
      let part2: Array<number> = pickMax(nums2, k - i);
      (globalThis as any).part2 = part2;
      let merged: Array<number> = [];
      (globalThis as any).merged = merged;
      let a: number = 0;
      (globalThis as any).a = a;
      let b: number = 0;
      (globalThis as any).b = b;
      while (((a < part1.length) || (b < part2.length))) {
        let use1: boolean = false;
        (globalThis as any).use1 = use1;
        if ((b == part2.length)) {
          use1 = true;
        } else if ((a == part1.length)) {
          use1 = false;
        } else {
          if (greaterSeq(part1, a, part2, b)) {
            use1 = true;
          }
        }
        if (use1) {
          merged = merged.concat([part1[a]]);
          a = a + 1;
        } else {
          merged = merged.concat([part2[b]]);
          b = b + 1;
        }
      }
      if (((best.length == 0) || greaterSeq(merged, 0, best, 0))) {
        best = merged;
      }
    }
    i = i + 1;
  }
  return best;
}

function test_example_1(): void {
  if (
    !(_equal(
      maxNumber([
        3,
        4,
        6,
        5,
      ], [
        9,
        1,
        2,
        5,
        8,
        3,
      ], 5),
      [
        9,
        8,
        6,
        5,
        3,
      ],
    ))
  ) throw new Error("expect failed");
}

function test_example_2(): void {
  if (
    !(_equal(
      maxNumber([
        6,
        7,
      ], [
        6,
        0,
        4,
      ], 5),
      [
        6,
        7,
        6,
        0,
        4,
      ],
    ))
  ) throw new Error("expect failed");
}

function test_example_3(): void {
  if (
    !(_equal(
      maxNumber([
        3,
        9,
      ], [
        8,
        9,
      ], 3),
      [
        9,
        8,
        9,
      ],
    ))
  ) throw new Error("expect failed");
}

function test_all_from_one(): void {
  if (
    !(_equal(
      maxNumber(
        [
          5,
          9,
          1,
        ],
        [],
        2,
      ),
      [
        9,
        1,
      ],
    ))
  ) throw new Error("expect failed");
}

function main(): void {
  test_example_1();
  test_example_2();
  test_example_3();
  test_all_from_one();
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (!_equal(a[i], b[i])) return false;
    return true;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) {
      if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}

main();
