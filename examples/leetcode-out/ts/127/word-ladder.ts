// Generated by Mochi TypeScript compiler

function ladderLength(
  beginWord: string,
  endWord: string,
  wordList: Array<string>,
): number {
  let dict: Record<string, boolean> = {};
  (globalThis as any).dict = dict;
  for (const w of wordList) {
    dict[w] = true;
  }
  if ((!(Object.prototype.hasOwnProperty.call(dict, String(endWord))))) {
    return 0;
  }
  let queue: Array<string> = [beginWord];
  (globalThis as any).queue = queue;
  let visited: Record<string, boolean> = { "beginWord": true };
  (globalThis as any).visited = visited;
  let level: number = 1;
  (globalThis as any).level = level;
  let letters: string = "abcdefghijklmnopqrstuvwxyz";
  (globalThis as any).letters = letters;
  while ((queue.length > 0)) {
    let next: Array<string> = [];
    (globalThis as any).next = next;
    for (const word of queue) {
      if ((word == endWord)) {
        return level;
      }
      for (let i: number = 0; i < word.length; i++) {
        for (let j: number = 0; j < letters.length; j++) {
          let ch: string = _indexString(letters, j);
          (globalThis as any).ch = ch;
          if ((ch != _indexString(word, i))) {
            let candidate: string = _sliceString(word, 0, i) + ch +
              _sliceString(word, i + 1, word.length);
            (globalThis as any).candidate = candidate;
            if (
              (Object.prototype.hasOwnProperty.call(dict, String(candidate)) &&
                ((Object.prototype.hasOwnProperty.call(
                  visited,
                  String(candidate),
                )) == false))
            ) {
              visited[candidate] = true;
              next = next.concat([candidate]);
            }
          }
        }
      }
    }
    queue = next;
    level = level + 1;
  }
  return 0;
}

function test_example_1(): void {
  if (
    !(ladderLength("hit", "cog", [
      "hot",
      "dot",
      "dog",
      "lot",
      "log",
      "cog",
    ]) == 5)
  ) throw new Error("expect failed");
}

function test_example_2(): void {
  if (
    !(ladderLength("hit", "cog", [
      "hot",
      "dot",
      "dog",
      "lot",
      "log",
    ]) == 0)
  ) throw new Error("expect failed");
}

function main(): void {
  test_example_1();
  test_example_2();
}
function _indexString(s: string, i: number): string {
  const runes = Array.from(s);
  if (i < 0) i += runes.length;
  if (i < 0 || i >= runes.length) throw new Error("index out of range");
  return runes[i];
}

function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
