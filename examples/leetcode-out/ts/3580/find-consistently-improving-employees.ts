// Generated by Mochi TypeScript compiler

type Employee = {
  employee_id: number;
  name: string;
};

type Review = {
  review_id: number;
  employee_id: number;
  review_date: string;
  rating: number;
};

type Result = {
  employee_id: number;
  name: string;
  improvement_score: number;
};

function consistentlyImproving(
  employees: Array<Employee>,
  reviews: Array<Review>,
): Array<Result> {
  let grouped: Array<Record<string, any>> = (() => {
    const _src = reviews;
    const _map = new Map<string, any>();
    const _order: string[] = [];
    let _items = [];
    for (const r of _src) {
      const _key = r.employee_id;
      const _ks = String(_key);
      let _g = _map.get(_ks);
      if (!_g) {
        _g = { key: _key, items: [] };
        _map.set(_ks, _g);
        _order.push(_ks);
      }
      _g.items.push(r);
    }
    let _groups = _order.map((k) => _map.get(k)!);
    const _res = [];
    for (const g of _groups) {
      _res.push({
        "id": g.key,
        "reviews": (() => {
          const _src = g.items;
          let _items = [];
          for (const x of _src) {
            _items.push(x);
          }
          let _pairs = _items.map((it) => {
            const x = it;
            return { item: it, key: x.review_date };
          });
          _pairs.sort((a, b) => {
            const ak = a.key;
            const bk = b.key;
            if (typeof ak === "number" && typeof bk === "number") {
              return ak - bk;
            }
            if (typeof ak === "string" && typeof bk === "string") {
              return ak < bk
                ? -1
                : (ak > bk ? 1 : 0);
            }
            return String(ak) < String(bk)
              ? -1
              : (String(ak) > String(bk) ? 1 : 0);
          });
          _items = _pairs.map((p) => p.item);
          const _res = [];
          for (const x of _items) {
            _res.push(x);
          }
          return _res;
        })(),
      });
    }
    return _res;
  })();
  (globalThis as any).grouped = grouped;
  let result: Array<Result> = [];
  (globalThis as any).result = result;
  for (const item of grouped) {
    let rlist: any = item.reviews;
    (globalThis as any).rlist = rlist;
    if (
      ((Array.isArray(rlist) || typeof rlist === "string"
        ? (rlist as any).length
        : (rlist && typeof rlist === "object"
          ? Object.keys(rlist).length
          : 0)) >= 3)
    ) {
      let n: number = Array.isArray(rlist) || typeof rlist === "string"
        ? (rlist as any).length
        : (rlist && typeof rlist === "object" ? Object.keys(rlist).length : 0);
      (globalThis as any).n = n;
      let last3: any = _slice(rlist, n - 3, n);
      (globalThis as any).last3 = last3;
      let r1: any = (last3 as any)[0];
      (globalThis as any).r1 = r1;
      let r2: any = (last3 as any)[1];
      (globalThis as any).r2 = r2;
      let r3: any = (last3 as any)[2];
      (globalThis as any).r3 = r3;
      if (((r1.rating < r2.rating) && (r2.rating < r3.rating))) {
        let diff: any = r3.rating - r1.rating;
        (globalThis as any).diff = diff;
        for (const emp of employees) {
          if (_equal(emp.employee_id, item.id)) {
            result = result.concat([
              {
                employee_id: emp.employee_id,
                name: emp.name,
                improvement_score: diff,
              },
            ]);
            break;
          }
        }
      }
    }
  }
  let byName: Array<Result> = (() => {
    const _src = result;
    let _items = [];
    for (const e of _src) {
      _items.push(e);
    }
    let _pairs = _items.map((it) => {
      const e = it;
      return { item: it, key: e.name };
    });
    _pairs.sort((a, b) => {
      const ak = a.key;
      const bk = b.key;
      if (typeof ak === "number" && typeof bk === "number") return ak - bk;
      if (typeof ak === "string" && typeof bk === "string") {
        return ak < bk
          ? -1
          : (ak > bk ? 1 : 0);
      }
      return String(ak) < String(bk) ? -1 : (String(ak) > String(bk) ? 1 : 0);
    });
    _items = _pairs.map((p) => p.item);
    const _res = [];
    for (const e of _items) {
      _res.push(e);
    }
    return _res;
  })();
  (globalThis as any).byName = byName;
  let sorted: Array<Result> = (() => {
    const _src = byName;
    let _items = [];
    for (const e of _src) {
      _items.push(e);
    }
    let _pairs = _items.map((it) => {
      const e = it;
      return { item: it, key: (-e.improvement_score) };
    });
    _pairs.sort((a, b) => {
      const ak = a.key;
      const bk = b.key;
      if (typeof ak === "number" && typeof bk === "number") return ak - bk;
      if (typeof ak === "string" && typeof bk === "string") {
        return ak < bk
          ? -1
          : (ak > bk ? 1 : 0);
      }
      return String(ak) < String(bk) ? -1 : (String(ak) > String(bk) ? 1 : 0);
    });
    _items = _pairs.map((p) => p.item);
    const _res = [];
    for (const e of _items) {
      _res.push(e);
    }
    return _res;
  })();
  (globalThis as any).sorted = sorted;
  return sorted;
}

function test_example(): void {
  let expected: Array<Result> = [
    {
      employee_id: 2,
      name: "Bob Smith",
      improvement_score: 3,
    },
    {
      employee_id: 1,
      name: "Alice Johnson",
      improvement_score: 2,
    },
    {
      employee_id: 3,
      name: "Carol Davis",
      improvement_score: 2,
    },
  ];
  (globalThis as any).expected = expected;
  if (
    !(String(consistentlyImproving(employees, performance_reviews)) ==
      String(expected))
  ) throw new Error("expect failed");
}

function main(): void {
  let employees: Array<Employee> = [
    {
      employee_id: 1,
      name: "Alice Johnson",
    },
    {
      employee_id: 2,
      name: "Bob Smith",
    },
    {
      employee_id: 3,
      name: "Carol Davis",
    },
    {
      employee_id: 4,
      name: "David Wilson",
    },
    {
      employee_id: 5,
      name: "Emma Brown",
    },
  ];
  (globalThis as any).employees = employees;
  let performance_reviews: Array<Review> = [
    {
      review_id: 1,
      employee_id: 1,
      review_date: "2023-01-15",
      rating: 2,
    },
    {
      review_id: 2,
      employee_id: 1,
      review_date: "2023-04-15",
      rating: 3,
    },
    {
      review_id: 3,
      employee_id: 1,
      review_date: "2023-07-15",
      rating: 4,
    },
    {
      review_id: 4,
      employee_id: 1,
      review_date: "2023-10-15",
      rating: 5,
    },
    {
      review_id: 5,
      employee_id: 2,
      review_date: "2023-02-01",
      rating: 3,
    },
    {
      review_id: 6,
      employee_id: 2,
      review_date: "2023-05-01",
      rating: 2,
    },
    {
      review_id: 7,
      employee_id: 2,
      review_date: "2023-08-01",
      rating: 4,
    },
    {
      review_id: 8,
      employee_id: 2,
      review_date: "2023-11-01",
      rating: 5,
    },
    {
      review_id: 9,
      employee_id: 3,
      review_date: "2023-03-10",
      rating: 1,
    },
    {
      review_id: 10,
      employee_id: 3,
      review_date: "2023-06-10",
      rating: 2,
    },
    {
      review_id: 11,
      employee_id: 3,
      review_date: "2023-09-10",
      rating: 3,
    },
    {
      review_id: 12,
      employee_id: 3,
      review_date: "2023-12-10",
      rating: 4,
    },
    {
      review_id: 13,
      employee_id: 4,
      review_date: "2023-01-20",
      rating: 4,
    },
    {
      review_id: 14,
      employee_id: 4,
      review_date: "2023-04-20",
      rating: 4,
    },
    {
      review_id: 15,
      employee_id: 4,
      review_date: "2023-07-20",
      rating: 4,
    },
    {
      review_id: 16,
      employee_id: 5,
      review_date: "2023-02-15",
      rating: 3,
    },
    {
      review_id: 17,
      employee_id: 5,
      review_date: "2023-05-15",
      rating: 2,
    },
  ];
  (globalThis as any).performance_reviews = performance_reviews;
  test_example();
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (!_equal(a[i], b[i])) return false;
    return true;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) {
      if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}

function _slice(v: any, i: number, j: number): any[] {
  if (typeof v === "string") return _sliceString(v, i, j);
  if (!Array.isArray(v)) return [];
  let start = i;
  let end = j;
  const n = v.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return v.slice(start, end);
}

main();
