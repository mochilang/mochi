// Generated by Mochi TypeScript compiler

type Reader = {
  data: string;
  index: number;
  buffer: string;
};

type Read4Result = {
  reader: Reader;
  chunk: string;
};

type ReadResult = {
  reader: Reader;
  data: string;
  count: number;
};

function newReader(s: string): Reader {
  return {
    data: s,
    index: 0,
    buffer: "",
  };
}

function read4(r: Reader): Read4Result {
  let i: number = 0;
  (globalThis as any).i = i;
  let chunk: string = "";
  (globalThis as any).chunk = chunk;
  let idx: number = r.index;
  (globalThis as any).idx = idx;
  while (((i < 4) && (idx < r.data.length))) {
    chunk = chunk + _indexString(r.data, idx);
    idx = idx + 1;
    i = i + 1;
  }
  let newReader: Reader = {
    data: r.data,
    index: idx,
    buffer: r.buffer,
  };
  (globalThis as any).newReader = newReader;
  return {
    reader: newReader,
    chunk: chunk,
  };
}

function read(reader: Reader, n: number): ReadResult {
  let r: Reader = reader;
  (globalThis as any).r = r;
  let output: string = "";
  (globalThis as any).output = output;
  let total: number = 0;
  (globalThis as any).total = total;
  while (((total < n) && (r.buffer.length > 0))) {
    output = output + _indexString(r.buffer, 0);
    r = {
      data: r.data,
      index: r.index,
      buffer: _sliceString(r.buffer, 1, r.buffer.length),
    };
    total = total + 1;
  }
  while ((total < n)) {
    let r4: Read4Result = read4(r);
    (globalThis as any).r4 = r4;
    r = r4.reader;
    let chunk: string = r4.chunk;
    (globalThis as any).chunk = chunk;
    if ((chunk.length == 0)) {
      break;
    }
    let i: number = 0;
    (globalThis as any).i = i;
    while (((i < chunk.length) && (total < n))) {
      output = output + _indexString(chunk, i);
      i = i + 1;
      total = total + 1;
    }
    r = {
      data: r.data,
      index: r.index,
      buffer: _sliceString(chunk, i, chunk.length),
    };
  }
  return {
    reader: r,
    data: output,
    count: total,
  };
}

function test_multiple_calls(): void {
  let r: Reader = newReader("abc");
  (globalThis as any).r = r;
  let r1: ReadResult = read(r, 1);
  (globalThis as any).r1 = r1;
  if (!(r1.data == "a")) throw new Error("expect failed");
  r = r1.reader;
  let r2: ReadResult = read(r, 2);
  (globalThis as any).r2 = r2;
  if (!(r2.data == "bc")) throw new Error("expect failed");
}

function test_leftover_handling(): void {
  let r: Reader = newReader("abcde");
  (globalThis as any).r = r;
  let r1: ReadResult = read(r, 2);
  (globalThis as any).r1 = r1;
  if (!(r1.data == "ab")) throw new Error("expect failed");
  r = r1.reader;
  let r2: ReadResult = read(r, 3);
  (globalThis as any).r2 = r2;
  if (!(r2.data == "cde")) throw new Error("expect failed");
}

function test_request_past_end(): void {
  let r: Reader = newReader("abcd");
  (globalThis as any).r = r;
  let r1: ReadResult = read(r, 6);
  (globalThis as any).r1 = r1;
  if (!(r1.data == "abcd")) throw new Error("expect failed");
  if (!(r1.count == 4)) throw new Error("expect failed");
}

function main(): void {
  test_multiple_calls();
  test_leftover_handling();
  test_request_past_end();
}
function _indexString(s: string, i: number): string {
  const runes = Array.from(s);
  if (i < 0) i += runes.length;
  if (i < 0 || i >= runes.length) throw new Error("index out of range");
  return runes[i];
}

function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
