// Generated by Mochi TypeScript compiler

function countComponents(n: number, edges: Array<Array<number>>): number {
  let graph: Array<Array<number>> = [];
  let i: number = 0;
  while (i < n) {
    graph = graph.concat([[]]);
    i = i + 1;
  }
  for (const e of edges) {
    let u: number = e[0];
    let v: number = e[1];
    graph[u] = graph[u].concat([v]);
    graph[v] = graph[v].concat([u]);
  }
  let visited: Array<boolean> = [];
  i = 0;
  while (i < n) {
    visited = visited.concat([false]);
    i = i + 1;
  }
  let components: number = 0;
  let start: number = 0;
  while (start < n) {
    if (!visited[start]) {
      components = components + 1;
      let queue: Array<number> = [start];
      visited[start] = true;
      let idx: number = 0;
      while (idx < queue.length) {
        let cur: number = queue[idx];
        idx = idx + 1;
        for (const nei of graph[cur]) {
          if (!visited[nei]) {
            visited[nei] = true;
            queue = queue.concat([nei]);
          }
        }
      }
    }
    start = start + 1;
  }
  return components;
}

function example_1(): void {
  if (
    !(
      countComponents(5, [
        [0, 1],
        [1, 2],
        [3, 4],
      ]) == 2
    )
  ) {
    throw new Error("expect failed");
  }
}

function example_2(): void {
  if (
    !(
      countComponents(5, [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
      ]) == 1
    )
  ) {
    throw new Error("expect failed");
  }
}

function single_node(): void {
  if (!(countComponents(1, []) == 1)) {
    throw new Error("expect failed");
  }
}

function two_disjoint_edges(): void {
  if (
    !(
      countComponents(4, [
        [0, 1],
        [2, 3],
      ]) == 2
    )
  ) {
    throw new Error("expect failed");
  }
}

function no_edges(): void {
  if (!(countComponents(4, []) == 4)) {
    throw new Error("expect failed");
  }
}

function main(): void {
  example_1();
  example_2();
  single_node();
  two_disjoint_edges();
  no_edges();
}
main();
