// Generated by Mochi TypeScript compiler

function canPermutePalindrome(s: string): boolean {
  let counts: Record<string, number> = {};
  (globalThis as any).counts = counts;
  let i: number = 0;
  (globalThis as any).i = i;
  while ((i < s.length)) {
    let ch: string = _indexString(s, i);
    (globalThis as any).ch = ch;
    if (Object.prototype.hasOwnProperty.call(counts, String(ch))) {
      counts[ch] = counts[ch] + 1;
    } else {
      counts[ch] = 1;
    }
    i = i + 1;
  }
  let oddCount: number = 0;
  (globalThis as any).oddCount = oddCount;
  for (const key of Object.keys(counts)) {
    if (((counts[key] % 2) == 1)) {
      oddCount = oddCount + 1;
      if ((oddCount > 1)) {
        return false;
      }
    }
  }
  return true;
}

function test_example_1(): void {
  if (!(canPermutePalindrome("code") == false)) {
    throw new Error("expect failed");
  }
}

function test_example_2(): void {
  if (!(canPermutePalindrome("aab") == true)) throw new Error("expect failed");
}

function test_example_3(): void {
  if (!(canPermutePalindrome("carerac") == true)) {
    throw new Error("expect failed");
  }
}

function test_empty_string(): void {
  if (!(canPermutePalindrome("") == true)) throw new Error("expect failed");
}

function test_single_char(): void {
  if (!(canPermutePalindrome("a") == true)) throw new Error("expect failed");
}

function test_two_odds(): void {
  if (!(canPermutePalindrome("abc") == false)) throw new Error("expect failed");
}

function main(): void {
  test_example_1();
  test_example_2();
  test_example_3();
  test_empty_string();
  test_single_char();
  test_two_odds();
}
function _indexString(s: string, i: number): string {
  const runes = Array.from(s);
  if (i < 0) i += runes.length;
  if (i < 0 || i >= runes.length) throw new Error("index out of range");
  return runes[i];
}

main();
