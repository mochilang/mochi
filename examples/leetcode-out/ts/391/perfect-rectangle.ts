// Generated by Mochi TypeScript compiler

function isRectangleCover(rectangles: Array<Array<number>>): boolean {
  if ((rectangles.length == 0)) {
    return false;
  }
  let minX: number = rectangles[0][0];
  (globalThis as any).minX = minX;
  let minY: number = rectangles[0][1];
  (globalThis as any).minY = minY;
  let maxX: number = rectangles[0][2];
  (globalThis as any).maxX = maxX;
  let maxY: number = rectangles[0][3];
  (globalThis as any).maxY = maxY;
  let area: number = 0;
  (globalThis as any).area = area;
  let counts: Record<string, number> = {};
  (globalThis as any).counts = counts;
  for (const rect of rectangles) {
    let x1: number = rect[0];
    (globalThis as any).x1 = x1;
    let y1: number = rect[1];
    (globalThis as any).y1 = y1;
    let x2: number = rect[2];
    (globalThis as any).x2 = x2;
    let y2: number = rect[3];
    (globalThis as any).y2 = y2;
    if ((x1 < minX)) {
      minX = x1;
    }
    if ((y1 < minY)) {
      minY = y1;
    }
    if ((x2 > maxX)) {
      maxX = x2;
    }
    if ((y2 > maxY)) {
      maxY = y2;
    }
    area = area + ((x2 - x1) * (y2 - y1));
    let i: number = 0;
    (globalThis as any).i = i;
    let pts: Array<Array<number>> = [
      [
        x1,
        y1,
      ],
      [
        x1,
        y2,
      ],
      [
        x2,
        y1,
      ],
      [
        x2,
        y2,
      ],
    ];
    (globalThis as any).pts = pts;
    while ((i < 4)) {
      let pt: Array<number> = pts[i];
      (globalThis as any).pt = pt;
      let key: string = String(pt[0]) + ":" + String(pt[1]);
      (globalThis as any).key = key;
      if (Object.prototype.hasOwnProperty.call(counts, String(key))) {
        counts[key] = counts[key] + 1;
      } else {
        counts[key] = 1;
      }
      i = i + 1;
    }
  }
  let expectArea: number = (maxX - minX) * (maxY - minY);
  (globalThis as any).expectArea = expectArea;
  if ((area != expectArea)) {
    return false;
  }
  let unique: Array<string> = [];
  (globalThis as any).unique = unique;
  for (const key of Object.keys(counts)) {
    if (((counts[key] % 2) == 1)) {
      unique = unique.concat([key]);
    }
  }
  if ((unique.length != 4)) {
    return false;
  }
  let needed: Record<string, boolean> = {};
  (globalThis as any).needed = needed;
  needed[String(minX) + ":" + String(minY)] = true;
  needed[String(minX) + ":" + String(maxY)] = true;
  needed[String(maxX) + ":" + String(minY)] = true;
  needed[String(maxX) + ":" + String(maxY)] = true;
  for (const c of unique) {
    let ok: boolean = false;
    (globalThis as any).ok = ok;
    if (Object.prototype.hasOwnProperty.call(needed, String(c))) {
      ok = needed[c];
    }
    if ((!ok)) {
      return false;
    }
  }
  return true;
}

function test_example_1(): void {
  if (
    !(isRectangleCover([
      [
        1,
        1,
        3,
        3,
      ],
      [
        3,
        1,
        4,
        2,
      ],
      [
        3,
        2,
        4,
        4,
      ],
      [
        1,
        3,
        2,
        4,
      ],
      [
        2,
        3,
        3,
        4,
      ],
    ]) == true)
  ) throw new Error("expect failed");
}

function test_example_2(): void {
  if (
    !(isRectangleCover([
      [
        1,
        1,
        2,
        3,
      ],
      [
        1,
        3,
        2,
        4,
      ],
      [
        3,
        1,
        4,
        2,
      ],
      [
        3,
        2,
        4,
        4,
      ],
    ]) == false)
  ) throw new Error("expect failed");
}

function test_example_3(): void {
  if (
    !(isRectangleCover([
      [
        1,
        1,
        3,
        3,
      ],
      [
        3,
        1,
        4,
        2,
      ],
      [
        1,
        3,
        2,
        4,
      ],
      [
        3,
        2,
        4,
        4,
      ],
    ]) == false)
  ) throw new Error("expect failed");
}

function main(): void {
  test_example_1();
  test_example_2();
  test_example_3();
}
main();
