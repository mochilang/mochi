// Generated by Mochi TypeScript compiler

function calcEquation(
  eqs: Array<Array<string>>,
  vals: Array<number>,
  queries: Array<Array<string>>,
): Array<number> {
  let graph: Record<string, Array<Array<any>>> = {};
  let i: number = 0;
  while (i < eqs.length) {
    let a: string = eqs[i][0];
    let b: string = eqs[i][1];
    let v: number = vals[i];
    let listA: Array<Array<any>> = [];
    if (Object.prototype.hasOwnProperty.call(graph, String(a))) {
      listA = graph[a];
    }
    listA = listA.concat([[b, v]]);
    graph[a] = listA;
    let listB: Array<Array<any>> = [];
    if (Object.prototype.hasOwnProperty.call(graph, String(b))) {
      listB = graph[b];
    }
    listB = listB.concat([[a, 1 / v]]);
    graph[b] = listB;
    i = i + 1;
  }
  let results: Array<number> = [];
  for (const q of queries) {
    let start: string = q[0];
    let end: string = q[1];
    if (
      !Object.prototype.hasOwnProperty.call(graph, String(start)) ||
      !Object.prototype.hasOwnProperty.call(graph, String(end))
    ) {
      results = results.concat([-1]);
      continue;
    }
    let visited: Record<string, boolean> = { start: true };
    let queue: Array<Array<any>> = [[start, 1]];
    let idx: number = 0;
    let found: boolean = false;
    let ans: number = -1;
    while (idx < queue.length) {
      let pair: Array<any> = queue[idx];
      let node: any = pair[0];
      let val: number = pair[1];
      if (_equal(node, end)) {
        ans = val;
        found = true;
        break;
      }
      let neighbors: Array<Array<any>> = graph[node];
      for (const nb of neighbors) {
        let nxt: any = nb[0];
        let ratio: number = nb[1];
        let seen: boolean = false;
        if (Object.prototype.hasOwnProperty.call(visited, String(nxt))) {
          seen = visited[nxt];
        }
        if (!seen) {
          visited[nxt] = true;
          queue = queue.concat([[nxt, val * ratio]]);
        }
      }
      idx = idx + 1;
    }
    if (found) {
      results = results.concat([ans]);
    } else {
      results = results.concat([-1]);
    }
  }
  return results;
}

function example_1(): void {
  let eq: Array<Array<string>> = [
    ["a", "b"],
    ["b", "c"],
  ];
  let val: Array<number> = [2, 3];
  let queries: Array<Array<string>> = [
    ["a", "c"],
    ["b", "a"],
    ["a", "e"],
    ["a", "a"],
    ["x", "x"],
  ];
  if (!_equal(calcEquation(eq, val, queries), [6, 0.5, -1, 1, -1])) {
    throw new Error("expect failed");
  }
}

function disconnected(): void {
  let eq: Array<Array<string>> = [
    ["a", "b"],
    ["c", "d"],
  ];
  let val: Array<number> = [1.5, 2.5];
  let queries: Array<Array<string>> = [
    ["a", "d"],
    ["c", "a"],
  ];
  if (!_equal(calcEquation(eq, val, queries), [-1, -1])) {
    throw new Error("expect failed");
  }
}

function main(): void {
  example_1();
  disconnected();
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!_equal(a[i], b[i])) return false;
    }
    return true;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) {
      if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k]))
        return false;
    }
    return true;
  }
  return a === b;
}

main();
