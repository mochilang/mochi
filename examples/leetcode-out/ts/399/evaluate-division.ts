// Generated by Mochi TypeScript compiler

function calcEquation(eqs: Array<Array<string>>, vals: Array<number>, queries: Array<Array<string>>) : Array<number> {
	let graph: Record<string, Array<Array<any>>> = {}
	let i: number = 0
	while ((i < eqs.length)) {
		let a: string = eqs[i][0]
		let b: string = eqs[i][1]
		let v: number = vals[i]
		let listA: Array<Array<any>> = []
		if (Object.prototype.hasOwnProperty.call(graph, String(a))) {
			listA = graph[a]
		}
		listA = listA.concat([[b, v]])
		graph[a] = listA
		let listB: Array<Array<any>> = []
		if (Object.prototype.hasOwnProperty.call(graph, String(b))) {
			listB = graph[b]
		}
		listB = listB.concat([[a, (1 / v)]])
		graph[b] = listB
		i = (i + 1)
	}
	let results: Array<number> = []
	for (const q of queries) {
		let start: string = q[0]
		let end: string = q[1]
		if ((((!(Object.prototype.hasOwnProperty.call(graph, String(start))))) || ((!(Object.prototype.hasOwnProperty.call(graph, String(end))))))) {
			results = results.concat([(-1)])
			continue
		}
		let visited: Record<string, boolean> = {"start": true}
		let queue: Array<Array<any>> = [[start, 1]]
		let idx: number = 0
		let found: boolean = false
		let ans: number = (-1)
		while ((idx < queue.length)) {
			let pair: Array<any> = queue[idx]
			let node: any = pair[0]
			let val: number = pair[1]
			if (_equal(node, end)) {
				ans = val
				found = true
				break
			}
			let neighbors: Array<Array<any>> = graph[node]
			for (const nb of neighbors) {
				let nxt: any = nb[0]
				let ratio: number = nb[1]
				let seen: boolean = false
				if (Object.prototype.hasOwnProperty.call(visited, String(nxt))) {
					seen = visited[nxt]
				}
				if ((!seen)) {
					visited[nxt] = true
					queue = queue.concat([[nxt, (val * ratio)]])
				}
			}
			idx = (idx + 1)
		}
		if (found) {
			results = results.concat([ans])
		} else {
			results = results.concat([(-1)])
		}
	}
	return results
}

function example_1(): void {
	let eq: Array<Array<string>> = [["a", "b"], ["b", "c"]]
	let val: Array<number> = [2, 3]
	let queries: Array<Array<string>> = [["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"]]
	if (!(_equal(calcEquation(eq, val, queries), [6, 0.5, (-1), 1, (-1)]))) { throw new Error('expect failed') }
}

function disconnected(): void {
	let eq: Array<Array<string>> = [["a", "b"], ["c", "d"]]
	let val: Array<number> = [1.5, 2.5]
	let queries: Array<Array<string>> = [["a", "d"], ["c", "a"]]
	if (!(_equal(calcEquation(eq, val, queries), [(-1), (-1)]))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	disconnected()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

main()

