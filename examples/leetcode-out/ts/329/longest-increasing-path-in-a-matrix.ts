// Generated by Mochi TypeScript compiler

function longestIncreasingPath(matrix: Array<Array<number>>): number {
  let m: number = matrix.length;
  (globalThis as any).m = m;
  if ((m == 0)) {
    return 0;
  }
  let n: number = matrix[0].length;
  (globalThis as any).n = n;
  let memo: Array<Array<number>> = [];
  (globalThis as any).memo = memo;
  let i: number = 0;
  (globalThis as any).i = i;
  while ((i < m)) {
    let row: Array<number> = [];
    (globalThis as any).row = row;
    let j: number = 0;
    (globalThis as any).j = j;
    while ((j < n)) {
      row = row.concat([0]);
      j = j + 1;
    }
    memo = memo.concat([row]);
    i = i + 1;
  }
  function dfs(x: number, y: number): number {
    let cached: number = memo[x][y];
    (globalThis as any).cached = cached;
    if ((cached != 0)) {
      return cached;
    }
    let val: number = matrix[x][y];
    (globalThis as any).val = val;
    let best: number = 1;
    (globalThis as any).best = best;
    if ((x > 0)) {
      if ((matrix[x - 1][y] > val)) {
        let candidate: number = 1 + dfs(x - 1, y);
        (globalThis as any).candidate = candidate;
        if ((candidate > best)) {
          best = candidate;
        }
      }
    }
    if (((x + 1) < m)) {
      if ((matrix[x + 1][y] > val)) {
        let candidate: number = 1 + dfs(x + 1, y);
        (globalThis as any).candidate = candidate;
        if ((candidate > best)) {
          best = candidate;
        }
      }
    }
    if ((y > 0)) {
      if ((matrix[x][y - 1] > val)) {
        let candidate: number = 1 + dfs(x, y - 1);
        (globalThis as any).candidate = candidate;
        if ((candidate > best)) {
          best = candidate;
        }
      }
    }
    if (((y + 1) < n)) {
      if ((matrix[x][y + 1] > val)) {
        let candidate: number = 1 + dfs(x, y + 1);
        (globalThis as any).candidate = candidate;
        if ((candidate > best)) {
          best = candidate;
        }
      }
    }
    memo[x][y] = best;
    return best;
  }
  let result: number = 0;
  (globalThis as any).result = result;
  i = 0;
  while ((i < m)) {
    let j: number = 0;
    (globalThis as any).j = j;
    while ((j < n)) {
      let length: number = dfs(i, j);
      (globalThis as any).length = length;
      if ((length > result)) {
        result = length;
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return result;
}

function test_example_1(): void {
  let matrix: Array<Array<number>> = [
    [
      9,
      9,
      4,
    ],
    [
      6,
      6,
      8,
    ],
    [
      2,
      1,
      1,
    ],
  ];
  (globalThis as any).matrix = matrix;
  if (!(longestIncreasingPath(matrix) == 4)) throw new Error("expect failed");
}

function test_example_2(): void {
  let matrix: Array<Array<number>> = [
    [
      3,
      4,
      5,
    ],
    [
      3,
      2,
      6,
    ],
    [
      2,
      2,
      1,
    ],
  ];
  (globalThis as any).matrix = matrix;
  if (!(longestIncreasingPath(matrix) == 4)) throw new Error("expect failed");
}

function test_single_cell(): void {
  if (!(longestIncreasingPath([[1]]) == 1)) throw new Error("expect failed");
}

function test_empty(): void {
  if (!(longestIncreasingPath([]) == 0)) throw new Error("expect failed");
}

function main(): void {
  test_example_1();
  test_example_2();
  test_single_cell();
  test_empty();
}
main();
