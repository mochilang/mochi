// Generated by Mochi TypeScript compiler

let g4: N = {__name: "N", val: 4, neighbors: []}

let g3: N = {__name: "N", val: 3, neighbors: [g4]}

let g2: N = {__name: "N", val: 2, neighbors: [g3]}

let g1: N = {__name: "N", val: 1, neighbors: [g2]}

function cloneGraph(root: Node) : Node {
	let seen: Record<number, any> = {}
	function dfs(n: any) : any {
		return (() => {
	const _t = n;
	if (_t.__name === "Nil") { return {__name: "Nil"} }
	if (_t.__name === "N") { return ((v, neigh) => (() => {
		if (Object.prototype.hasOwnProperty.call(seen, String(v))) {
			return seen[v]
		}
		seen[v] = {__name: "N", val: v, neighbors: []}
		let resultNeighbors: Array<any> = []
		for (const nb of _iter(neigh)) {
			resultNeighbors = resultNeighbors.concat([dfs(nb)])
		}
		let nodeCopy: N = {__name: "N", val: v, neighbors: resultNeighbors}
		seen[v] = nodeCopy
		return nodeCopy
})())(_t.val, _t.neighbors) }
	return undefined
})()
	}
	return dfs(root)
}

function clone_chain(): void {
	let c: Node = cloneGraph(g1)
	(() => {
	const _t = c;
	if (_t.__name === "N") { return ((v1, neigh1) => (() => {
		if (!(_equal(v1, 1))) { throw new Error('expect failed') }
		let n2: any = (neigh1 as any)[0]
		return (() => {
		const _t = n2;
		if (_t.__name === "N") { return ((v2, neigh2) => (() => {
			if (!(_equal(v2, 2))) { throw new Error('expect failed') }
			let n3: any = (neigh2 as any)[0]
			return (() => {
			const _t = n3;
			if (_t.__name === "N") { return ((v3, neigh3) => (() => {
				if (!(_equal(v3, 3))) { throw new Error('expect failed') }
				let n4: any = (neigh3 as any)[0]
				return (() => {
				const _t = n4;
				if (_t.__name === "N") { return ((v4) => (() => {
					if (!(_equal(v4, 4))) { throw new Error('expect failed') }
			})())(_t.val) }
				return (() => {
					if (!(false)) { throw new Error('expect failed') }
			})()
			})()
		})())(_t.val, _t.neighbors) }
			return (() => {
				if (!(false)) { throw new Error('expect failed') }
		})()
		})()
	})())(_t.val, _t.neighbors) }
		return (() => {
			if (!(false)) { throw new Error('expect failed') }
	})()
	})()
})())(_t.val, _t.neighbors) }
	return (() => {
		if (!(false)) { throw new Error('expect failed') }
})()
})()
}

function independent_copy(): void {
	let c: Node = cloneGraph(g1)
	(() => {
	const _t = c;
	if (_t.__name === "N") { return ((neigh) => (() => {
		return (() => {
		const _t = (neigh as any)[0];
		if (_t.__name === "N") { return ((v) => (() => {
			if (!(_equal(v, 2))) { throw new Error('expect failed') }
	})())(_t.val) }
		return (() => {
			if (!(false)) { throw new Error('expect failed') }
	})()
	})()
})())(_t.neighbors) }
	return (() => {
		if (!(false)) { throw new Error('expect failed') }
})()
})()
}

function main(): void {
	type Nil = {
		__name: "Nil";
	}
	
	type N = {
		__name: "N";
		val: number;
		neighbors: Array<any>;
	}
	
	type Node = Nil | N
	clone_chain()
	independent_copy()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

function _iter(v: any): any {
  if (v && typeof v === 'object' && !Array.isArray(v) && !(Symbol.iterator in v)) {
    return Object.keys(v);
  }
  return v;
}

main()

