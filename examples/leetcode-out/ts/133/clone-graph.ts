// Generated by Mochi TypeScript compiler

let g4: N = { __name: "N", val: 4, neighbors: [] };

let g3: N = { __name: "N", val: 3, neighbors: [g4] };

let g2: N = { __name: "N", val: 2, neighbors: [g3] };

let g1: N = { __name: "N", val: 1, neighbors: [g2] };

function cloneGraph(root: Node): Node {
  let seen: Record<number, any> = {};
  function dfs(n: any): any {
    return (() => {
      const _t = n;
      if (_t.__name === "Nil") {
        return { __name: "Nil" };
      }
      if (_t.__name === "N") {
        return ((v, neigh) =>
          (() => {
            if (Object.prototype.hasOwnProperty.call(seen, String(v))) {
              return seen[v];
            }
            seen[v] = { __name: "N", val: v, neighbors: [] };
            let resultNeighbors: Array<any> = [];
            for (const nb of _iter(neigh)) {
              resultNeighbors = resultNeighbors.concat([dfs(nb)]);
            }
            let nodeCopy: N = {
              __name: "N",
              val: v,
              neighbors: resultNeighbors,
            };
            seen[v] = nodeCopy;
            return nodeCopy;
          })())(_t.val, _t.neighbors);
      }
      return undefined;
    })();
  }
  return dfs(root);
}

function clone_chain(): void {
  let c: Node = cloneGraph(g1)(() => {
    const _t = c;
    if (_t.__name === "N") {
      return ((v1, neigh1) =>
        (() => {
          if (!_equal(v1, 1)) {
            throw new Error("expect failed");
          }
          let n2: any = (neigh1 as any)[0];
          return (() => {
            const _t = n2;
            if (_t.__name === "N") {
              return ((v2, neigh2) =>
                (() => {
                  if (!_equal(v2, 2)) {
                    throw new Error("expect failed");
                  }
                  let n3: any = (neigh2 as any)[0];
                  return (() => {
                    const _t = n3;
                    if (_t.__name === "N") {
                      return ((v3, neigh3) =>
                        (() => {
                          if (!_equal(v3, 3)) {
                            throw new Error("expect failed");
                          }
                          let n4: any = (neigh3 as any)[0];
                          return (() => {
                            const _t = n4;
                            if (_t.__name === "N") {
                              return ((v4) =>
                                (() => {
                                  if (!_equal(v4, 4)) {
                                    throw new Error("expect failed");
                                  }
                                })())(_t.val);
                            }
                            return (() => {
                              if (!false) {
                                throw new Error("expect failed");
                              }
                            })();
                          })();
                        })())(_t.val, _t.neighbors);
                    }
                    return (() => {
                      if (!false) {
                        throw new Error("expect failed");
                      }
                    })();
                  })();
                })())(_t.val, _t.neighbors);
            }
            return (() => {
              if (!false) {
                throw new Error("expect failed");
              }
            })();
          })();
        })())(_t.val, _t.neighbors);
    }
    return (() => {
      if (!false) {
        throw new Error("expect failed");
      }
    })();
  })();
}

function independent_copy(): void {
  let c: Node = cloneGraph(g1)(() => {
    const _t = c;
    if (_t.__name === "N") {
      return ((neigh) =>
        (() => {
          return (() => {
            const _t = (neigh as any)[0];
            if (_t.__name === "N") {
              return ((v) =>
                (() => {
                  if (!_equal(v, 2)) {
                    throw new Error("expect failed");
                  }
                })())(_t.val);
            }
            return (() => {
              if (!false) {
                throw new Error("expect failed");
              }
            })();
          })();
        })())(_t.neighbors);
    }
    return (() => {
      if (!false) {
        throw new Error("expect failed");
      }
    })();
  })();
}

function main(): void {
  type Nil = {
    __name: "Nil";
  };

  type N = {
    __name: "N";
    val: number;
    neighbors: Array<any>;
  };

  type Node = Nil | N;
  clone_chain();
  independent_copy();
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!_equal(a[i], b[i])) return false;
    }
    return true;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) {
      if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k]))
        return false;
    }
    return true;
  }
  return a === b;
}

function _iter(v: any): any {
  if (
    v &&
    typeof v === "object" &&
    !Array.isArray(v) &&
    !(Symbol.iterator in v)
  ) {
    return Object.keys(v);
  }
  return v;
}

main();
