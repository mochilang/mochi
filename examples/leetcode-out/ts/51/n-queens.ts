// Generated by Mochi TypeScript compiler

let result4: Array<Array<string>> = solveNQueens(4)

let expected4: Array<Array<string>> = [[".Q..", "...Q", "Q...", "..Q."], ["..Q.", "Q...", "...Q", ".Q.."]]

function solveNQueens(n: number) : Array<Array<string>> {
	let results: Array<Array<string>> = []
	let cols: Record<number, boolean> = {}
	let diag1: Record<number, boolean> = {}
	let diag2: Record<number, boolean> = {}
	function backtrack(row: number, board: Array<string>) : void {
		if ((row == n)) {
			results = results.concat([board])
		} else {
			let c: number = 0
			while ((c < n)) {
				let usedCol: boolean = false
				if (Object.prototype.hasOwnProperty.call(cols, String(c))) {
					usedCol = cols[c]
				}
				if (usedCol) {
					c = (c + 1)
					continue
				}
				let d1: number = (row - c)
				let d2: number = (row + c)
				let usedD1: boolean = false
				let usedD2: boolean = false
				if (Object.prototype.hasOwnProperty.call(diag1, String(d1))) {
					usedD1 = diag1[d1]
				}
				if (Object.prototype.hasOwnProperty.call(diag2, String(d2))) {
					usedD2 = diag2[d2]
				}
				if ((!((usedD1 || usedD2)))) {
					cols[c] = true
					diag1[d1] = true
					diag2[d2] = true
					let rowStr: string = ""
					let i: number = 0
					while ((i < n)) {
						if ((i == c)) {
							rowStr = rowStr + "Q"
						} else {
							rowStr = rowStr + "."
						}
						i = (i + 1)
					}
					backtrack((row + 1), board.concat([rowStr]))
					cols[c] = false
					diag1[d1] = false
					diag2[d2] = false
				}
				c = (c + 1)
			}
		}
	}
	backtrack(0, [])
	return results
}

function n_4(): void {
	if (!(_equal(result4, expected4))) { throw new Error('expect failed') }
}

function n_1(): void {
	if (!(_equal(solveNQueens(1), [["Q"]]))) { throw new Error('expect failed') }
}

function main(): void {
	n_4()
	n_1()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

main()

