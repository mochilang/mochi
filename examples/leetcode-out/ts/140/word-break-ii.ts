// Generated by Mochi TypeScript compiler

function wordBreak(s: string, wordDict: Array<string>): Array<string> {
  let dict: Record<string, boolean> = {};
  (globalThis as any).dict = dict;
  for (const w of wordDict) {
    dict[w] = true;
  }
  let n: number = s.length;
  (globalThis as any).n = n;
  let memo: Record<number, Array<string>> = {};
  (globalThis as any).memo = memo;
  function dfs(start: number): Array<string> {
    if (Object.prototype.hasOwnProperty.call(memo, String(start))) {
      return memo[start];
    }
    if ((start == n)) {
      return [""];
    }
    let res: Array<string> = [];
    (globalThis as any).res = res;
    let end: number = start + 1;
    (globalThis as any).end = end;
    while ((end <= n)) {
      let word: string = _sliceString(s, start, end);
      (globalThis as any).word = word;
      let exists: boolean = false;
      (globalThis as any).exists = exists;
      if (Object.prototype.hasOwnProperty.call(dict, String(word))) {
        exists = dict[word];
      }
      if (exists) {
        let subs: Array<string> = dfs(end);
        (globalThis as any).subs = subs;
        for (const sub of subs) {
          if ((sub.length == 0)) {
            res = res.concat([word]);
          } else {
            res = res.concat([word + " " + sub]);
          }
        }
      }
      end = end + 1;
    }
    memo[start] = res;
    return res;
  }
  let ans: Array<string> = dfs(0);
  (globalThis as any).ans = ans;
  let sorted: Array<string> = (() => {
    const _src = ans;
    let _items = [];
    for (const x of _src) {
      _items.push(x);
    }
    let _pairs = _items.map((it) => {
      const x = it;
      return { item: it, key: x };
    });
    _pairs.sort((a, b) => {
      const ak = a.key;
      const bk = b.key;
      if (typeof ak === "number" && typeof bk === "number") return ak - bk;
      if (typeof ak === "string" && typeof bk === "string") {
        return ak < bk
          ? -1
          : (ak > bk ? 1 : 0);
      }
      return String(ak) < String(bk) ? -1 : (String(ak) > String(bk) ? 1 : 0);
    });
    _items = _pairs.map((p) => p.item);
    const _res = [];
    for (const x of _items) {
      _res.push(x);
    }
    return _res;
  })();
  (globalThis as any).sorted = sorted;
  return sorted;
}

function test_example_1(): void {
  if (
    !(_equal(wordBreak("catsanddog", dict1), [
      "cat sand dog",
      "cats and dog",
    ]))
  ) throw new Error("expect failed");
}

function test_example_2(): void {
  if (
    !(_equal(wordBreak("pineapplepenapple", dict2), [
      "pine apple pen apple",
      "pine applepen apple",
      "pineapple pen apple",
    ]))
  ) throw new Error("expect failed");
}

function test_example_3(): void {
  if (!(_equal(wordBreak("catsandog", dict1), []))) {
    throw new Error("expect failed");
  }
}

function main(): void {
  let dict1: Array<string> = [
    "cat",
    "cats",
    "and",
    "sand",
    "dog",
  ];
  (globalThis as any).dict1 = dict1;
  let dict2: Array<string> = [
    "apple",
    "pen",
    "applepen",
    "pine",
    "pineapple",
  ];
  (globalThis as any).dict2 = dict2;
  test_example_1();
  test_example_2();
  test_example_3();
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (!_equal(a[i], b[i])) return false;
    return true;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) {
      if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}

function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
