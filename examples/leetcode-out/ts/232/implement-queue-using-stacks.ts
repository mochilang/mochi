// Generated by Mochi TypeScript compiler

function newQueue() : MyQueue {
	return {ins: [], outs: []}
}

function push(q: MyQueue, x: number) : MyQueue {
	let s: Array<number> = q.ins
	s = s.concat([x])
	return {ins: s, outs: q.outs}
}

function ensureOut(q: MyQueue) : MyQueue {
	let inStack: Array<number> = q.ins
	let outStack: Array<number> = q.outs
	if ((outStack.length == 0)) {
		while ((inStack.length > 0)) {
			let v: number = inStack[(inStack.length - 1)]
			inStack = inStack.slice(0, (inStack.length - 1))
			outStack = outStack.concat([v])
		}
	}
	return {ins: inStack, outs: outStack}
}

function pop(q: MyQueue) : PopResult {
	let shifted: MyQueue = ensureOut(q)
	let outStack: Array<number> = shifted.outs
	let v: number = outStack[(outStack.length - 1)]
	outStack = outStack.slice(0, (outStack.length - 1))
	let newQ: MyQueue = {ins: shifted.ins, outs: outStack}
	return {queue: newQ, val: v}
}

function peek(q: MyQueue) : number {
	let shifted: MyQueue = ensureOut(q)
	return shifted.outs[(shifted.outs.length - 1)]
}

function empty(q: MyQueue) : boolean {
	return ((q.ins.length == 0) && (q.outs.length == 0))
}

function example(): void {
	let q: MyQueue = newQueue()
	q = push(q, 1)
	q = push(q, 2)
	if (!((peek(q) == 1))) { throw new Error('expect failed') }
	let r1: PopResult = pop(q)
	q = r1.queue
	if (!((r1.val == 1))) { throw new Error('expect failed') }
	if (!((empty(q) == false))) { throw new Error('expect failed') }
}

function multiple_operations(): void {
	let q: MyQueue = newQueue()
	q = push(q, 3)
	q = push(q, 4)
	let r1: PopResult = pop(q)
	q = r1.queue
	if (!((r1.val == 3))) { throw new Error('expect failed') }
	q = push(q, 5)
	if (!((peek(q) == 4))) { throw new Error('expect failed') }
	let r2: PopResult = pop(q)
	q = r2.queue
	if (!((r2.val == 4))) { throw new Error('expect failed') }
	let r3: PopResult = pop(q)
	q = r3.queue
	if (!((r3.val == 5))) { throw new Error('expect failed') }
	if (!((empty(q) == true))) { throw new Error('expect failed') }
}

function main(): void {
	type MyQueue = {
		ins: Array<number>;
		outs: Array<number>;
	}
	type PopResult = {
		queue: any;
		val: number;
	}
	example()
	multiple_operations()
}
main()

