# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def pickMax(nums: list[int], k: int) -> list[int]:
	drop = (len(nums) - k)
	stack = []
	i = 0
	toDrop = drop
	while (i < len(nums)):
		num = nums[i]
		while ((toDrop > 0) and (len(stack) > 0)):
			if (stack[(len(stack) - 1)] < num):
				stack = stack[0:(len(stack) - 1)]
				toDrop = (toDrop - 1)
			else:
				break
		stack = (stack + [num])
		i = (i + 1)
	return stack[0:k]

def greaterSeq(a: list[int], i: int, b: list[int], j: int) -> bool:
	x = i
	y = j
	while ((x < len(a)) and (y < len(b))):
		if (a[x] > b[y]):
			return True
		if (a[x] < b[y]):
			return False
		x = (x + 1)
		y = (y + 1)
	return (x != len(a))

def maxNumber(nums1: list[int], nums2: list[int], k: int) -> list[int]:
	best = []
	i = 0
	while (i <= k):
		if ((i <= len(nums1)) and ((k - i) <= len(nums2))):
			part1 = pickMax(nums1, i)
			part2 = pickMax(nums2, (k - i))
			merged = []
			a = 0
			b = 0
			while ((a < len(part1)) or (b < len(part2))):
				use1 = False
				if (b == len(part2)):
					use1 = True
				elif (a == len(part1)):
					use1 = False
				else:
					if greaterSeq(part1, a, part2, b):
						use1 = True
				if use1:
					merged = (merged + [part1[a]])
					a = (a + 1)
				else:
					merged = (merged + [part2[b]])
					b = (b + 1)
			if ((len(best) == 0) or greaterSeq(merged, 0, best, 0)):
				best = merged
		i = (i + 1)
	return best

def example_1():
	assert (maxNumber([3, 4, 6, 5], [9, 1, 2, 5, 8, 3], 5) == [9, 8, 6, 5, 3])

def example_2():
	assert (maxNumber([6, 7], [6, 0, 4], 5) == [6, 7, 6, 0, 4])

def example_3():
	assert (maxNumber([3, 9], [8, 9], 3) == [9, 8, 9])

def all_from_one():
	assert (maxNumber([5, 9, 1], [], 2) == [9, 1])

def main():
	example_1()
	example_2()
	example_3()
	all_from_one()

if __name__ == "__main__":
	main()
