# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def lca(lefts: list[int], rights: list[int], root: int, p: int, q: int) -> int:
	if (root == ((-1))):
		return ((-1))
	if ((root == p) or (root == q)):
		return root
	leftRes = lca(lefts, rights, lefts[root], p, q)
	rightRes = lca(lefts, rights, rights[root], p, q)
	if ((leftRes != ((-1))) and (rightRes != ((-1)))):
		return root
	if (leftRes != ((-1))):
		return leftRes
	return rightRes

lefts = [1, 3, 5, ((-1)), 7, ((-1)), ((-1)), ((-1)), ((-1))]
rights = [2, 4, 6, ((-1)), 8, ((-1)), ((-1)), ((-1)), ((-1))]
values = [3, 5, 1, 6, 2, 0, 8, 7, 4]
root = 0

def p_and_q_on_different_sides():
	assert (lca(lefts, rights, root, 1, 2) == 0)

def p_is_ancestor_of_q():
	assert (lca(lefts, rights, root, 1, 8) == 1)

def same_node():
	assert (lca(lefts, rights, root, 1, 1) == 1)

def deep_nodes():
	assert (lca(lefts, rights, root, 3, 5) == 0)

def siblings():
	assert (lca(lefts, rights, root, 7, 8) == 4)

def main():
	lefts = [1, 3, 5, ((-1)), 7, ((-1)), ((-1)), ((-1)), ((-1))]
	rights = [2, 4, 6, ((-1)), 8, ((-1)), ((-1)), ((-1)), ((-1))]
	values = [3, 5, 1, 6, 2, 0, 8, 7, 4]
	root = 0
	p_and_q_on_different_sides()
	p_is_ancestor_of_q()
	same_node()
	deep_nodes()
	siblings()

if __name__ == "__main__":
	main()
