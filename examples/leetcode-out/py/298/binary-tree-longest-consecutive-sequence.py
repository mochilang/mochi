# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def longestConsecutive(lefts: list[int], rights: list[int], values: list[int], root: int) -> int:
	if (root == ((-1))):
		return 0
	def dfs(node: int, parentVal: int, length: int) -> int:
		if (node == ((-1))):
			return length
		curr = 1
		if (values[node] == (parentVal + 1)):
			curr = (length + 1)
		leftLen = dfs(lefts[node], values[node], curr)
		rightLen = dfs(rights[node], values[node], curr)
		best = curr
		if (leftLen > best):
			best = leftLen
		if (rightLen > best):
			best = rightLen
		return best
	return dfs(root, (values[root] - 1), 0)

lefts1 = [1, ((-1)), ((-1))]
rights1 = [2, ((-1)), ((-1))]
values1 = [1, 2, 3]
root1 = 0
lefts2 = [((-1)), 2, ((-1)), ((-1)), ((-1)), ((-1))]
rights2 = [1, 4, 3, 5, ((-1)), ((-1))]
values2 = [1, 2, 3, 4, 5, 6]
root2 = 0
lefts3 = [1, 3, ((-1)), ((-1))]
rights3 = [2, ((-1)), ((-1)), ((-1))]
values3 = [3, 2, 4, 1]
root3 = 0

def simple_chain():
	assert (longestConsecutive(lefts1, rights1, values1, root1) == 2)

def increasing_right():
	assert (longestConsecutive(lefts2, rights2, values2, root2) == 4)

def mixed_values():
	assert (longestConsecutive(lefts3, rights3, values3, root3) == 2)

def main():
	lefts1 = [1, ((-1)), ((-1))]
	rights1 = [2, ((-1)), ((-1))]
	values1 = [1, 2, 3]
	root1 = 0
	lefts2 = [((-1)), 2, ((-1)), ((-1)), ((-1)), ((-1))]
	rights2 = [1, 4, 3, 5, ((-1)), ((-1))]
	values2 = [1, 2, 3, 4, 5, 6]
	root2 = 0
	lefts3 = [1, 3, ((-1)), ((-1))]
	rights3 = [2, ((-1)), ((-1)), ((-1))]
	values3 = [3, 2, 4, 1]
	root3 = 0
	simple_chain()
	increasing_right()
	mixed_values()

if __name__ == "__main__":
	main()
