# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def isRectangleCover(rectangles: list[list[int]]) -> bool:
	if (len(rectangles) == 0):
		return False
	minX = rectangles[0][0]
	minY = rectangles[0][1]
	maxX = rectangles[0][2]
	maxY = rectangles[0][3]
	area = 0
	counts = {}
	for rect in rectangles:
		x1 = rect[0]
		y1 = rect[1]
		x2 = rect[2]
		y2 = rect[3]
		if (x1 < minX):
			minX = x1
		if (y1 < minY):
			minY = y1
		if (x2 > maxX):
			maxX = x2
		if (y2 > maxY):
			maxY = y2
		area = (area + (((x2 - x1)) * ((y2 - y1))))
		i = 0
		pts = [[x1, y1], [x1, y2], [x2, y1], [x2, y2]]
		while (i < 4):
			pt = pts[i]
			key = ((str(pt[0]) + ":") + str(pt[1]))
			if (key in counts):
				counts[key] = (counts[key] + 1)
			else:
				counts[key] = 1
			i = (i + 1)
	expectArea = (((maxX - minX)) * ((maxY - minY)))
	if (area != expectArea):
		return False
	unique = []
	for key in counts:
		if ((counts[key] % 2) == 1):
			unique = (unique + [key])
	if (len(unique) != 4):
		return False
	needed = {}
	needed[((str(minX) + ":") + str(minY))] = True
	needed[((str(minX) + ":") + str(maxY))] = True
	needed[((str(maxX) + ":") + str(minY))] = True
	needed[((str(maxX) + ":") + str(maxY))] = True
	for c in unique:
		ok = False
		if (c in needed):
			ok = needed[c]
		if (not ok):
			return False
	return True

def example_1():
	assert (isRectangleCover([[1, 1, 3, 3], [3, 1, 4, 2], [3, 2, 4, 4], [1, 3, 2, 4], [2, 3, 3, 4]]) == True)

def example_2():
	assert (isRectangleCover([[1, 1, 2, 3], [1, 3, 2, 4], [3, 1, 4, 2], [3, 2, 4, 4]]) == False)

def example_3():
	assert (isRectangleCover([[1, 1, 3, 3], [3, 1, 4, 2], [1, 3, 2, 4], [3, 2, 4, 4]]) == False)

def main():
	example_1()
	example_2()
	example_3()

if __name__ == "__main__":
	main()
