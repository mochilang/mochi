# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def parseInt(s: str) -> int:
	result = 0
	i = 0
	digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	while (i < len(s)):
		result = ((result * 10) + digits[s[i]])
		i = (i + 1)
	return result

def splitComma(s: str) -> list[str]:
	parts = []
	current = ""
	i = 0
	while (i < len(s)):
		c = s[i]
		if (c == ","):
			parts = (parts + [current])
			current = ""
		else:
			current = (current + c)
		i = (i + 1)
	parts = (parts + [current])
	return parts

def join(parts: list[str], sep: str) -> str:
	result = ""
	i = 0
	while (i < len(parts)):
		if (i > 0):
			result = (result + sep)
		result = (result + parts[i])
		i = (i + 1)
	return result

def Leaf() -> dict[str, typing.Any]:
	return {"__name": "Leaf"}

def Node(left: dict[str, typing.Any], value: int, right: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return {"__name": "Node", "left": left, "value": value, "right": right}

def isLeaf(t: dict[str, typing.Any]) -> bool:
	return (t["__name"] == "Leaf")

def left(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["left"]

def right(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["right"]

def value(t: dict[str, typing.Any]) -> int:
	return t["value"]

def serialize(root: dict[str, typing.Any]) -> str:
	if isLeaf(root):
		return ""
	queue = [root]
	parts = []
	while (len(queue) > 0):
		node = queue[0]
		queue = queue[1:len(queue)]
		if isLeaf(node):
			parts = (parts + ["null"])
		else:
			parts = (parts + [str(value(node))])
			queue = (queue + [left(node)])
			queue = (queue + [right(node)])
	i = (len(parts) - 1)
	while ((i >= 0) and (parts[i] == "null")):
		i = (i - 1)
	parts = parts[0:(i + 1)]
	return join(parts, ",")

def deserialize(data: str) -> dict[str, typing.Any]:
	if (data == ""):
		return Leaf()
	vals = splitComma(data)
	def build(i: int) -> dict[str, typing.Any]:
		if (i >= len(vals)):
			return Leaf()
		v = vals[i]
		if (v == "null"):
			return Leaf()
		leftNode = build(((2 * i) + 1))
		rightNode = build(((2 * i) + 2))
		return Node(leftNode, parseInt(v), rightNode)
	return build(0)

example = Node(Node(Leaf(), 2, Leaf()), 1, Node(Node(Leaf(), 4, Leaf()), 3, Node(Leaf(), 5, Leaf())))

def serialize_round_trip():
	s = serialize(example)
	t = deserialize(s)
	assert (serialize(t) == s)

def empty_tree():
	assert (serialize(Leaf()) == "")
	assert (isLeaf(deserialize("")) == True)

def single_node():
	s = serialize(Node(Leaf(), 7, Leaf()))
	assert (s == "7")
	assert (serialize(deserialize(s)) == "7")

def main():
	example = Node(Node(Leaf(), 2, Leaf()), 1, Node(Node(Leaf(), 4, Leaf()), 3, Node(Leaf(), 5, Leaf())))
	serialize_round_trip()
	empty_tree()
	single_node()

if __name__ == "__main__":
	main()
