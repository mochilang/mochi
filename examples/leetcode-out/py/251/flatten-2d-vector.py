# Generated by Mochi Python compiler
from __future__ import annotations

import dataclasses
import typing

def newVector2D(v: list[list[int]]) -> Vector2D:
	return Vector2D(data=v, row=0, col=0)

def advance(vec: Vector2D) -> Vector2D:
	r = vec.row
	c = vec.col
	d = vec.data
	while (r < len(d)):
		if (c >= len(d[r])):
			r = (r + 1)
			c = 0
		else:
			break
	return Vector2D(data=d, row=r, col=c)

def hasNext(vec: Vector2D) -> bool:
	v = advance(vec)
	return (v.row < len(v.data))

def _next(vec: Vector2D) -> NextResult:
	v = advance(vec)
	value = v.data[v.row][v.col]
	v = Vector2D(data=v.data, row=v.row, col=(v.col + 1))
	return NextResult(vec=v, val=value)

@dataclasses.dataclass
class Vector2D:
	data: list[list[int]]
	row: int
	col: int

@dataclasses.dataclass
class NextResult:
	vec: Vector2D
	val: int

def example():
	it = newVector2D([[1, 2], [3], [4]])
	r1 = _next(it)
	it = r1.vec
	assert (r1.val == 1)
	assert (hasNext(it) == True)
	r2 = _next(it)
	it = r2.vec
	assert (r2.val == 2)
	assert (hasNext(it) == True)
	r3 = _next(it)
	it = r3.vec
	assert (r3.val == 3)
	assert (hasNext(it) == True)
	r4 = _next(it)
	it = r4.vec
	assert (r4.val == 4)
	assert (hasNext(it) == False)

def empty_inner_lists():
	it = newVector2D([[], [1], [], [2, 3]])
	assert (hasNext(it) == True)
	r1 = _next(it)
	it = r1.vec
	assert (r1.val == 1)
	r2 = _next(it)
	it = r2.vec
	assert (r2.val == 2)
	r3 = _next(it)
	it = r3.vec
	assert (r3.val == 3)
	assert (hasNext(it) == False)

def main():
	example()
	empty_inner_lists()

if __name__ == "__main__":
	main()
