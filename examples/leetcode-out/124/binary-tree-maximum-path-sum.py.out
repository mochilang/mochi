# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def Leaf() -> dict[str, typing.Any]:
	return {"__name": "Leaf"}

def Node(left: dict[str, typing.Any], value: int, right: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return {"__name": "Node", "left": left, "value": value, "right": right}

def isLeaf(t: dict[str, typing.Any]) -> bool:
	return (t["__name"] == "Leaf")

def left(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["left"]

def right(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["right"]

def value(t: dict[str, typing.Any]) -> int:
	return t["value"]

def max(a: int, b: int) -> int:
	if (a > b):
		return a
	return b

def positive(x: int) -> int:
	if (x > 0):
		return x
	return 0

def maxPathSum(root: dict[str, typing.Any]) -> int:
	best = (-2147483648)
	def dfs(t: dict[str, typing.Any]) -> int:
		nonlocal best
		if isLeaf(t):
			return 0
		leftVal = dfs(left(t))
		rightVal = dfs(right(t))
		leftPos = positive(leftVal)
		rightPos = positive(rightVal)
		candidate = ((value(t) + leftPos) + rightPos)
		if (candidate > best):
			best = candidate
		return positive((value(t) + max(leftPos, rightPos)))
	dfs(root)
	return best

def example_1():
	tree = Node(Node(Leaf(), 2, Leaf()), 1, Node(Leaf(), 3, Leaf()))
	assert (maxPathSum(tree) == 6)

def example_2():
	tree = Node(Node(Leaf(), 9, Leaf()), (-10), Node(Node(Leaf(), 15, Leaf()), 20, Node(Leaf(), 7, Leaf())))
	assert (maxPathSum(tree) == 42)

def single_negative():
	assert (maxPathSum(Node(Leaf(), (-3), Leaf())) == ((-3)))

def all_negative():
	tree = Node(Node(Leaf(), (-5), Leaf()), (-2), Node(Leaf(), (-4), Leaf()))
	assert (maxPathSum(tree) == ((-2)))

def main():
	example_1()
	example_2()
	single_negative()
	all_negative()

if __name__ == "__main__":
	main()
