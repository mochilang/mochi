package main

import (
	"reflect"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func restoreIpAddresses(s string) []string {
	var result []string = []string{}
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	var backtrack func(int, int, string) int
	backtrack = func(start int, part int, current string) int {
		if (part == 4) {
			if (start == len(s)) {
				result = append(append([]string{}, result...), []string{string([]rune(current)[1:len(current)])}...)
			}
			return 0
		}
		for l := 1; l < 4; l++ {
			if ((start + l) > len(s)) {
				break
			}
			var segment string = string([]rune(s)[start:(start + l)])
			if ((len(segment) > 1) && (_indexString(segment, 0) == "0")) {
				continue
			}
			var val int = 0
			for _, r := range []rune(segment) {
				ch := string(r)
				val = ((val * 10) + digits[ch])
			}
			if (val > 255) {
				continue
			}
			backtrack((start + l), (part + 1), current + "." + segment)
		}
		return 0
}
	backtrack(0, 0, "")
	return result
}

func example_1() {
	expect(_equal(restoreIpAddresses("25525511135"), []string{"255.255.11.135", "255.255.111.35"}))
}

func all_zeros() {
	expect(_equal(restoreIpAddresses("0000"), []string{"0.0.0.0"}))
}

func example_2() {
	expect(_equal(restoreIpAddresses("101023"), []string{"1.0.10.23", "1.0.102.3", "10.1.0.23", "10.10.2.3", "101.0.2.3"}))
}

func main() {
	example_1()
	all_zeros()
	example_2()
}

func _equal(a, b any) bool {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice && av.Len() == 0 && bv.Len() == 0 {
        return true
    }
    return reflect.DeepEqual(a, b)
}

func _indexString(s string, i int) string {
    runes := []rune(s)
    if i < 0 {
        i += len(runes)
    }
    if i < 0 || i >= len(runes) {
        panic("index out of range")
    }
    return string(runes[i])
}

