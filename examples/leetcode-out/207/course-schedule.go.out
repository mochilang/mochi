package main

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func canFinish(numCourses int, prerequisites [][]int) bool {
	var graph [][]int = [][]int{}
	_ = graph
	var indegree []int = []int{}
	_ = indegree
	for _ := 0; _ < numCourses; _++ {
		graph = append(append([]any{}, _toAnySlice(graph)...), _toAnySlice([][]any{[]any{}})...)
		indegree = append(append([]int{}, indegree...), []int{0}...)
	}
	for _, pair := range prerequisites {
		var a int = pair[0]
		var b int = pair[1]
		graph[b] = append(append([]int{}, graph[b]...), []int{a}...)
		indegree[a] = (indegree[a] + 1)
	}
	var queue []int = []int{}
	_ = queue
	for i := 0; i < numCourses; i++ {
		if (indegree[i] == 0) {
			queue = append(append([]int{}, queue...), []int{i}...)
		}
	}
	var visited int = 0
	_ = visited
	var idx int = 0
	_ = idx
	for (idx < len(queue)) {
		var course int = queue[idx]
		idx = (idx + 1)
		visited = (visited + 1)
		for _, next := range graph[course] {
			indegree[next] = (indegree[next] - 1)
			if (indegree[next] == 0) {
				queue = append(append([]int{}, queue...), []int{next}...)
			}
		}
	}
	return (visited == numCourses)
}

func simple_acyclic() {
	expect((canFinish(2, [][]int{[]int{1, 0}}) == true))
}

func simple_cycle() {
	expect((canFinish(2, [][]int{[]int{1, 0}, []int{0, 1}}) == false))
}

func long_chain() {
	expect((canFinish(4, [][]int{[]int{1, 0}, []int{2, 1}, []int{3, 2}}) == true))
}

func cycle_with_more_courses() {
	expect((canFinish(3, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 0}}) == false))
}

func main() {
	simple_acyclic()
	simple_cycle()
	long_chain()
	cycle_with_more_courses()
}

func _toAnySlice[T any](s []T) []any {
    out := make([]any, len(s))
    for i, v := range s { out[i] = v }
    return out
}

