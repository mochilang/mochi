# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def Leaf() -> dict[str, typing.Any]:
	return {"__name": "Leaf"}

def Node(left: dict[str, typing.Any], value: int, right: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return {"__name": "Node", "left": left, "value": value, "right": right}

def isLeaf(t: dict[str, typing.Any]) -> bool:
	return (t["__name"] == "Leaf")

def left(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["left"]

def right(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["right"]

def value(t: dict[str, typing.Any]) -> int:
	return t["value"]

def pushLeft(it: dict[str, typing.Any], node: dict[str, typing.Any]) -> None:
	n = node
	st = it["stack"]
	while (not isLeaf(n)):
		st = (st + [n])
		n = left(n)
	it["stack"] = st

def NewBSTIterator(root: dict[str, typing.Any]) -> dict[str, typing.Any]:
	it = {"stack": []}
	pushLeft(it, root)
	return it

def bstNext(it: dict[str, typing.Any]) -> int:
	st = it["stack"]
	node = st[(len(st) - 1)]
	st = st[0:(len(st) - 1)]
	it["stack"] = st
	pushLeft(it, right(node))
	return value(node)

def bstHasNext(it: dict[str, typing.Any]) -> bool:
	st = it["stack"]
	return (len(st) > 0)

def example():
	iterator = NewBSTIterator(Node(Node(Leaf(), 3, Leaf()), 7, Node(Node(Leaf(), 9, Leaf()), 15, Node(Leaf(), 20, Leaf()))))
	assert (bstNext(iterator) == 3)
	assert (bstNext(iterator) == 7)
	assert (bstHasNext(iterator) == True)
	assert (bstNext(iterator) == 9)
	assert (bstHasNext(iterator) == True)
	assert (bstNext(iterator) == 15)
	assert (bstHasNext(iterator) == True)
	assert (bstNext(iterator) == 20)
	assert (bstHasNext(iterator) == False)

def single_node():
	it = NewBSTIterator(Node(Leaf(), 5, Leaf()))
	assert (bstNext(it) == 5)
	assert (bstHasNext(it) == False)

def main():
	example()
	single_node()

if __name__ == "__main__":
	main()
