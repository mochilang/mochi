# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def Leaf() -> dict[str, typing.Any]:
	return {"__name": "Leaf"}

def Node(left: dict[str, typing.Any], value: int, right: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return {"__name": "Node", "left": left, "value": value, "right": right}

def isLeaf(t: dict[str, typing.Any]) -> bool:
	return (t["__name"] == "Leaf")

def left(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["left"]

def right(t: dict[str, typing.Any]) -> dict[str, typing.Any]:
	return t["right"]

def value(t: dict[str, typing.Any]) -> int:
	return t["value"]

def binaryTreePaths(root: dict[str, typing.Any]) -> list[str]:
	def dfs(t: dict[str, typing.Any], path: str) -> list[str]:
		if isLeaf(t):
			return []
		current = path
		if (path == ""):
			current = str(value(t))
		else:
			current = ((path + "->") + str(value(t)))
		l = left(t)
		r = right(t)
		if (isLeaf(l) and isLeaf(r)):
			return [current]
		res = []
		if (not isLeaf(l)):
			res = (res + dfs(l, current))
		if (not isLeaf(r)):
			res = (res + dfs(r, current))
		return res
	return dfs(root, "")

example1 = Node(Node(Leaf(), 2, Node(Leaf(), 5, Leaf())), 1, Node(Leaf(), 3, Leaf()))

def example_1():
	assert (binaryTreePaths(example1) == ["1->2->5", "1->3"])

def single_node():
	assert (binaryTreePaths(Node(Leaf(), 1, Leaf())) == ["1"])

def empty():
	assert (binaryTreePaths(Leaf()) == [])

def main():
	example1 = Node(Node(Leaf(), 2, Node(Leaf(), 5, Leaf())), 1, Node(Leaf(), 3, Leaf()))
	example_1()
	single_node()
	empty()

if __name__ == "__main__":
	main()
