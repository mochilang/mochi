package main

import (
	"encoding/json"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

func lca(lefts []int, rights []int, root int, p int, q int) int {
	if (root == (-1)) {
		return (-1)
	}
	if ((root == p) || (root == q)) {
		return root
	}
	var leftRes int = lca(lefts, rights, lefts[root], p, q)
	var rightRes int = lca(lefts, rights, rights[root], p, q)
	if ((leftRes != (-1)) && (rightRes != (-1))) {
		return root
	}
	if (leftRes != (-1)) {
		return leftRes
	}
	return rightRes
}

func p_and_q_on_different_sides() {
	expect((lca(lefts, rights, root, 1, 2) == 0))
}

func p_is_ancestor_of_q() {
	expect((lca(lefts, rights, root, 1, 8) == 1))
}

func same_node() {
	expect((lca(lefts, rights, root, 1, 1) == 1))
}

func deep_nodes() {
	expect((lca(lefts, rights, root, 3, 5) == 0))
}

func siblings() {
	expect((lca(lefts, rights, root, 7, 8) == 4))
}

var lefts []int = _cast[[]int]([]int{1, 3, 5, (-1), 7, (-1), (-1), (-1), (-1)})
var rights []int = _cast[[]int]([]int{2, 4, 6, (-1), 8, (-1), (-1), (-1), (-1)})
var values []int = _cast[[]int]([]int{3, 5, 1, 6, 2, 0, 8, 7, 4})
var root int = 0
func main() {
	p_and_q_on_different_sides()
	p_is_ancestor_of_q()
	same_node()
	deep_nodes()
	siblings()
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

