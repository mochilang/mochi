// Generated by Mochi C# compiler
using System;
using System.Collections.Generic;
using System.Linq;

public class Program {
	static long[][] fourSum(long[] nums, long target) {
		var sorted = new List<dynamic>(nums.OrderBy(n => n).Select(n => n));
		long n = sorted.Length;
		long[][] result = new long[][] { };
		for (var i = 0L; i < n; i++) {
			if (((i > 0L) && (sorted[i] == sorted[(i - 1L)]))) {
				continue;
			}
			for (var j = (i + 1L); j < n; j++) {
				if (((j > (i + 1L)) && (sorted[j] == sorted[(j - 1L)]))) {
					continue;
				}
				var left = (j + 1L);
				var right = (n - 1L);
				while ((left < right)) {
					var sum = (((sorted[i] + sorted[j]) + sorted[left]) + sorted[right]);
					if ((sum == target)) {
						result = result.Concat(new [] { new [] { sorted[i], sorted[j], sorted[left], sorted[right] } }).ToArray();
						left = (left + 1L);
						right = (right - 1L);
						while (((left < right) && (sorted[left] == sorted[(left - 1L)]))) {
							left = (left + 1L);
						}
						while (((left < right) && (sorted[right] == sorted[(right + 1L)]))) {
							right = (right - 1L);
						}
					} else if ((sum < target)) {
						left = (left + 1L);
					} else {
						right = (right - 1L);
					}
				}
			}
		}
		return result;
	}
	
	static void test_example_1() {
		if (!(_equal(fourSum(new [] { 1L, 0L, (-1L), 0L, (-2L), 2L }, 0L), new [] { new [] { (-2L), (-1L), 1L, 2L }, new [] { (-2L), 0L, 0L, 2L }, new [] { (-1L), 0L, 0L, 1L } }))) throw new Exception("expect failed");
	}
	
	static void test_example_2() {
		if (!(_equal(fourSum(new [] { 2L, 2L, 2L, 2L, 2L }, 8L), new [] { new [] { 2L, 2L, 2L, 2L } }))) throw new Exception("expect failed");
	}
	
	public static void Main() {
		test_example_1();
		test_example_2();
	}
	static bool _equal(dynamic a, dynamic b) {
		if (a is System.Collections.IEnumerable ae && b is System.Collections.IEnumerable be && a is not string && b is not string) {
			var ea = ae.GetEnumerator();
			var eb = be.GetEnumerator();
			while (true) {
				bool ha = ea.MoveNext();
				bool hb = eb.MoveNext();
				if (ha != hb) return false;
				if (!ha) break;
				if (!_equal(ea.Current, eb.Current)) return false;
			}
			return true;
		}
		return Equals(a, b);
	}
	
}
