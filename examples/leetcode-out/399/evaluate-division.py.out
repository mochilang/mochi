# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def calcEquation(eqs: list[list[str]], vals: list[float], queries: list[list[str]]) -> list[float]:
	graph = {}
	i = 0
	while (i < len(eqs)):
		a = eqs[i][0]
		b = eqs[i][1]
		v = vals[i]
		listA = []
		if (a in graph):
			listA = graph[a]
		listA = (listA + [[b, v]])
		graph[a] = listA
		listB = []
		if (b in graph):
			listB = graph[b]
		listB = (listB + [[a, (1 / v)]])
		graph[b] = listB
		i = (i + 1)
	results = []
	for q in queries:
		start = q[0]
		end = q[1]
		if (((not ((start in graph)))) or ((not ((end in graph))))):
			results = (results + [(-1)])
			continue
		visited = {start: True}
		queue = [[start, 1]]
		idx = 0
		found = False
		ans = (-1)
		while (idx < len(queue)):
			pair = queue[idx]
			node = pair[0]
			val = pair[1]
			if (node == end):
				ans = val
				found = True
				break
			neighbors = graph[node]
			for nb in neighbors:
				nxt = nb[0]
				ratio = nb[1]
				seen = False
				if (nxt in visited):
					seen = visited[nxt]
				if (not seen):
					visited[nxt] = True
					queue = (queue + [[nxt, (val * ratio)]])
			idx = (idx + 1)
		if found:
			results = (results + [ans])
		else:
			results = (results + [(-1)])
	return results

def example_1():
	eq = [["a", "b"], ["b", "c"]]
	val = [2, 3]
	queries = [["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"]]
	assert (calcEquation(eq, val, queries) == [6, 0.5, (-1), 1, (-1)])

def disconnected():
	eq = [["a", "b"], ["c", "d"]]
	val = [1.5, 2.5]
	queries = [["a", "d"], ["c", "a"]]
	assert (calcEquation(eq, val, queries) == [(-1), (-1)])

def main():
	example_1()
	disconnected()

if __name__ == "__main__":
	main()
