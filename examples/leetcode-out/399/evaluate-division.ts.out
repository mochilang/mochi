// Generated by Mochi TypeScript compiler

function calcEquation(eqs: Array<Array<string>>, vals: Array<number>, queries: Array<Array<string>>) : Array<number> {
	let graph: Record<any, any> = {}
	let i: number = 0
	while ((i < eqs.length)) {
		let a: string = eqs[i][0]
		let b: string = eqs[i][1]
		let v: number = vals[i]
		let listA: Array<any> = []
		if (Object.prototype.hasOwnProperty.call(graph, String(a))) {
			listA = graph[a]
		}
		listA = listA.concat([[b, v]])
		graph[a] = listA
		let listB: Array<any> = []
		if (Object.prototype.hasOwnProperty.call(graph, String(b))) {
			listB = graph[b]
		}
		listB = listB.concat([[a, (1.000000 / v)]])
		graph[b] = listB
		i = (i + 1)
	}
	let results: Array<any> = []
	for (const q of queries) {
		let start: string = q[0]
		let end: string = q[1]
		if ((((!(Object.prototype.hasOwnProperty.call(graph, String(start))))) || ((!(Object.prototype.hasOwnProperty.call(graph, String(end))))))) {
			results = results.concat([(-1.000000)])
			continue
		}
		let visited: Record<string, boolean> = {"start": true}
		let queue: Array<Array<any>> = [[start, 1.000000]]
		let idx: number = 0
		let found: boolean = false
		let ans: number = (-1.000000)
		while ((idx < queue.length)) {
			let pair: Array<any> = queue[idx]
			let node: any = pair[0]
			let val: number = pair[1]
			if (_equal(node, end)) {
				ans = val
				found = true
				break
			}
			let neighbors: any = graph[node]
			for (const nb of _iter(neighbors)) {
				let nxt: any = (nb as any)[0]
				let ratio: number = (nb as any)[1]
				let seen: boolean = false
				if (Object.prototype.hasOwnProperty.call(visited, String(nxt))) {
					seen = visited[nxt]
				}
				if ((!seen)) {
					visited[nxt] = true
					queue = queue.concat([[nxt, (val * ratio)]])
				}
			}
			idx = (idx + 1)
		}
		if (found) {
			results = results.concat([ans])
		} else {
			results = results.concat([(-1.000000)])
		}
	}
	return results
}

function example_1(): void {
	let eq: Array<Array<string>> = [["a", "b"], ["b", "c"]]
	let val: Array<number> = [2.000000, 3.000000]
	let queries: Array<Array<string>> = [["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"]]
	if (!(_equal(calcEquation(eq, val, queries), [6.000000, 0.500000, (-1.000000), 1.000000, (-1.000000)]))) { throw new Error('expect failed') }
}

function disconnected(): void {
	let eq: Array<Array<string>> = [["a", "b"], ["c", "d"]]
	let val: Array<number> = [1.500000, 2.500000]
	let queries: Array<Array<string>> = [["a", "d"], ["c", "a"]]
	if (!(_equal(calcEquation(eq, val, queries), [(-1.000000), (-1.000000)]))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	disconnected()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

function _iter(v: any): any {
  if (v && typeof v === 'object' && !Array.isArray(v) && !(Symbol.iterator in v)) {
    return Object.keys(v);
  }
  return v;
}

main()

