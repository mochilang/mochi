package main

import (
	"encoding/json"
	"fmt"
	"reflect"
	"sort"
)

func expect(cond bool) {
	if !cond { panic("expect failed") }
}

type Tweet struct {
	Id int `json:"id"`
	Time int `json:"time"`
}

type Twitter struct {
	Tweets map[int][]any `json:"tweets"`
	Follows map[int]map[int]bool `json:"follows"`
	Time int `json:"time"`
}

func newTwitter() Twitter {
	return Twitter{Tweets: _cast[map[int][]any](map[any]any{}), Follows: _cast[map[int]map[int]bool](map[any]any{}), Time: 0}
}

func postTweet(t Twitter, userId int, tweetId int) Twitter {
	var tweets map[int][]Tweet = t.Tweets
	var list []any = []any{}
	_tmp0 := userId
	_tmp1 := tweets
	_, _tmp2 := _tmp1[_tmp0]
	if _tmp2 {
		list = tweets[userId]
	}
	var time int = (t.Time + 1)
	_ = time
	list = append(append([]any{}, _toAnySlice([]Tweet{Tweet{Id: tweetId, Time: time}})...), list...)
	tweets[userId] = list
	return Twitter{Tweets: tweets, Follows: t.Follows, Time: time}
}

func getNewsFeed(t Twitter, userId int) []int {
	var all []any = []any{}
	_tmp3 := userId
	_tmp4 := t.Tweets
	_, _tmp5 := _tmp4[_tmp3]
	if _tmp5 {
		all = append(append([]any{}, all...), _toAnySlice(t.Tweets[userId])...)
	}
	_tmp6 := userId
	_tmp7 := t.Follows
	_, _tmp8 := _tmp7[_tmp6]
	if _tmp8 {
		for f := range t.Follows[userId] {
			_tmp9 := f
			_tmp10 := t.Tweets
			_, _tmp11 := _tmp10[_tmp9]
			if _tmp11 {
				all = append(append([]any{}, all...), _toAnySlice(t.Tweets[f])...)
			}
		}
	}
	var sorted []any = func() []any {
	items := []any{}
	for _, tw := range all {
		items = append(items, tw)
	}
	type pair struct { item any; key any }
	pairs := make([]pair, len(items))
	for idx, it := range items {
		tw := it
		pairs[idx] = pair{item: it, key: -tw.Time}
	}
	sort.Slice(pairs, func(i, j int) bool {
		a, b := pairs[i].key, pairs[j].key
		switch av := a.(type) {
		case int:
			switch bv := b.(type) {
			case int:
				return av < bv
			case float64:
				return float64(av) < bv
			}
		case float64:
			switch bv := b.(type) {
			case int:
				return av < float64(bv)
			case float64:
				return av < bv
			}
		case string:
			bs, _ := b.(string)
			return av < bs
		}
		return fmt.Sprint(a) < fmt.Sprint(b)
	})
	for idx, p := range pairs {
		items[idx] = p.item
	}
	_res := []any{}
	for _, tw := range items {
		_res = append(_res, tw)
	}
	return _res
}()
	var feed []int = []int{}
	var i int = 0
	for ((i < len(sorted)) && (i < 10)) {
		var t any = sorted[i]
		_ = t
		feed = append(append([]any{}, _toAnySlice(feed)...), []any{t.Id}...)
		i = (i + 1)
	}
	return feed
}

func follow(t Twitter, followerId int, followeeId int) Twitter {
	var follows map[int]map[int]bool = t.Follows
	var set map[int]bool = map[int]bool{}
	_tmp12 := followerId
	_tmp13 := follows
	_, _tmp14 := _tmp13[_tmp12]
	if _tmp14 {
		set = follows[followerId]
	}
	set[followeeId] = true
	follows[followerId] = set
	return Twitter{Tweets: t.Tweets, Follows: follows, Time: t.Time}
}

func unfollow(t Twitter, followerId int, followeeId int) Twitter {
	var follows map[int]map[int]bool = t.Follows
	_tmp15 := followerId
	_tmp16 := follows
	_, _tmp17 := _tmp16[_tmp15]
	if _tmp17 {
		var set map[int]bool = follows[followerId]
		_tmp18 := followeeId
		_tmp19 := set
		_, _tmp20 := _tmp19[_tmp18]
		if _tmp20 {
			set = removeKey(set, followeeId)
			follows[followerId] = set
		}
	}
	return Twitter{Tweets: t.Tweets, Follows: follows, Time: t.Time}
}

func removeKey(m map[int]bool, k int) map[int]bool {
	var out map[int]bool = map[int]bool{}
	for key := range m {
		if (key != k) {
			out[key] = m[key]
		}
	}
	return out
}

func example() {
	var tw Twitter = newTwitter()
	tw = postTweet(tw, 1, 5)
	expect(_equal(getNewsFeed(tw, 1), []int{5}))
	tw = follow(tw, 1, 2)
	tw = postTweet(tw, 2, 6)
	expect(_equal(getNewsFeed(tw, 1)[0:2], []int{6, 5}))
	tw = unfollow(tw, 1, 2)
	expect(_equal(getNewsFeed(tw, 1), []int{5}))
}

func empty_feed() {
	var tw Twitter = newTwitter()
	_ = tw
	expect(_equal(getNewsFeed(tw, 1), []any{}))
}

func multiple_tweets() {
	var tw Twitter = newTwitter()
	tw = postTweet(tw, 1, 101)
	tw = postTweet(tw, 1, 102)
	expect(_equal(getNewsFeed(tw, 1), []int{102, 101}))
}

func main() {
	example()
	empty_feed()
	multiple_tweets()
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

func _equal(a, b any) bool {
    av := reflect.ValueOf(a)
    bv := reflect.ValueOf(b)
    if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice && av.Len() == 0 && bv.Len() == 0 {
        return true
    }
    return reflect.DeepEqual(a, b)
}

func _toAnySlice[T any](s []T) []any {
    out := make([]any, len(s))
    for i, v := range s { out[i] = v }
    return out
}

