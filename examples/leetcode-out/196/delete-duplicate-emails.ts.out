// Generated by Mochi TypeScript compiler

let users: Array<User> = [{id: 1, email: "a@b.com"}, {id: 2, email: "c@d.com"}, {id: 3, email: "a@b.com"}]

let expected: Array<User> = [{id: 1, email: "a@b.com"}, {id: 2, email: "c@d.com"}]

function deleteDuplicateEmails(users: Array<User>) : Array<User> {
	let byEmail: Record<any, any> = {}
	for (const u of users) {
		if (Object.prototype.hasOwnProperty.call(byEmail, String(u.email))) {
			let existing: any = byEmail[u.email]
			if ((u.id < existing.id)) {
				byEmail[u.email] = u
			}
		} else {
			byEmail[u.email] = u
		}
	}
	let result: Array<any> = []
	for (const key of Object.keys(byEmail)) {
		result = result.concat([byEmail[key]])
	}
	let sorted: Array<any> = (() => {
	const _src = result;
	let _items = [];
	for (const x of _src) {
		_items.push(x);
	}
	let _pairs = _items.map(it => { const x = it; return {item: it, key: x.id}; });
	_pairs.sort((a, b) => {
		const ak = a.key; const bk = b.key;
		if (typeof ak === 'number' && typeof bk === 'number') return ak - bk;
		if (typeof ak === 'string' && typeof bk === 'string') return ak < bk ? -1 : (ak > bk ? 1 : 0);
		return String(ak) < String(bk) ? -1 : (String(ak) > String(bk) ? 1 : 0);
	});
	_items = _pairs.map(p => p.item);
	const _res = [];
	for (const x of _items) {
		_res.push(x)
	}
	return _res;
})()
	return sorted
}

function remove_duplicates(): void {
	if (!((String(deleteDuplicateEmails(users)) == String(expected)))) { throw new Error('expect failed') }
}

function main(): void {
	type User = {
		id: any;
		email: any;
	}
	remove_duplicates()
}
main()

