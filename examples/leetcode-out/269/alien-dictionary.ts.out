// Generated by Mochi TypeScript compiler

function alienOrder(words: Array<string>) : string {
	let graph: Record<any, any> = {}
	let indegree: Record<any, any> = {}
	for (const w of words) {
		for (const ch of w) {
			if ((!(Object.prototype.hasOwnProperty.call(graph, String(ch))))) {
				graph[ch] = []
			}
			if ((!(Object.prototype.hasOwnProperty.call(indegree, String(ch))))) {
				indegree[ch] = 0
			}
		}
	}
	let i: number = 0
	while ((i < (words.length - 1))) {
		let w1: string = words[i]
		let w2: string = words[(i + 1)]
		let j: number = 0
		let found: boolean = false
		while (((j < w1.length) && (j < w2.length))) {
			let c1: string = w1[j]
			let c2: string = w2[j]
			if ((c1 != c2)) {
				let neighbors: any = graph[c1]
				let exists: boolean = false
				for (const n of _iter(neighbors)) {
					if (_equal(n, c2)) {
						exists = true
					}
				}
				if ((!exists)) {
					graph[c1] = (neighbors + [c2])
					indegree[c2] = (indegree[c2] + 1)
				}
				found = true
				break
			}
			j = (j + 1)
		}
		if (((!found) && (w1.length > w2.length))) {
			return ""
		}
		i = (i + 1)
	}
	let queue: Array<any> = []
	for (const ch of Object.keys(indegree)) {
		if (_equal(indegree[ch], 0)) {
			queue = queue.concat([ch])
		}
	}
	let order: string = ""
	let idx: number = 0
	while ((idx < queue.length)) {
		let ch: any = queue[idx]
		idx = (idx + 1)
		order = (order + ch)
		for (const nxt of _iter(graph[ch])) {
			indegree[nxt] = (indegree[nxt] - 1)
			if (_equal(indegree[nxt], 0)) {
				queue = queue.concat([nxt])
			}
		}
	}
	if ((order.length != Object.keys(indegree).length)) {
		return ""
	}
	return order
}

function example_1(): void {
	if (!((alienOrder(["wrt", "wrf", "er", "ett", "rftt"]) == "wertf"))) { throw new Error('expect failed') }
}

function example_2(): void {
	if (!((alienOrder(["z", "x"]) == "zx"))) { throw new Error('expect failed') }
}

function invalid_order(): void {
	if (!((alienOrder(["z", "x", "z"]) == ""))) { throw new Error('expect failed') }
}

function main(): void {
	example_1()
	example_2()
	invalid_order()
}
function _equal(a: any, b: any): boolean {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
    return true;
  }
  if (a && b && typeof a === 'object' && typeof b === 'object') {
    const ak = Object.keys(a); const bk = Object.keys(b);
    if (ak.length !== bk.length) return false;
    for (const k of ak) { if (!bk.includes(k) || !_equal((a as any)[k], (b as any)[k])) return false; }
    return true;
  }
  return a === b;
}

function _iter(v: any): any {
  if (v && typeof v === 'object' && !Array.isArray(v) && !(Symbol.iterator in v)) {
    return Object.keys(v);
  }
  return v;
}

main()

