# Generated by Mochi Python compiler
from __future__ import annotations

import typing

def combinationSum(candidates: list[int], target: int) -> list[list[int]]:
	_sorted = [ c for c in sorted([ c for c in candidates ], key=lambda c: c) ]
	result = []
	def backtrack(remain: int, start: int, path: list[int]) -> None:
		nonlocal result
		if (remain == 0):
			result = (result + [path])
		else:
			i = start
			n = len(_sorted)
			while (i < n):
				current = _sorted[i]
				if (current > remain):
					break
				backtrack((remain - current), i, (path + [current]))
				i = (i + 1)
	backtrack(target, 0, [])
	return result

def example_1():
	assert (combinationSum([2, 3, 6, 7], 7) == [[2, 2, 3], [7]])

def example_2():
	assert (combinationSum([2, 3, 5], 8) == [[2, 2, 2, 2], [2, 3, 3], [3, 5]])

def example_3():
	assert (combinationSum([2], 1) == [])

def main():
	example_1()
	example_2()
	example_3()

if __name__ == "__main__":
	main()
