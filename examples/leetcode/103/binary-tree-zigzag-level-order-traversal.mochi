// LeetCode 103 - Binary Tree Zigzag Level Order Traversal

// Binary tree helpers implemented without using union types or pattern matching.

fun Leaf(): map<string, any> {
  return {"__name": "Leaf"}
}

fun Node(left: map<string, any>, value: int, right: map<string, any>): map<string, any> {
  return {"__name": "Node", "left": left, "value": value, "right": right}
}

fun isLeaf(t: map<string, any>): bool { return t["__name"] == "Leaf" }
fun left(t: map<string, any>): map<string, any> { return t["left"] }
fun right(t: map<string, any>): map<string, any> { return t["right"] }
fun value(t: map<string, any>): int { return t["value"] as int }

// Helper to reverse a list of integers.
fun reverseList(xs: list<int>): list<int> {
  var out: list<int> = []
  var i = len(xs) - 1
  while i >= 0 {
    out = out + [xs[i]]
    i = i - 1
  }
  return out
}

// Perform a level order traversal alternating direction on each level.
fun zigzagLevelOrder(root: map<string, any>): list<list<int>> {
  if isLeaf(root) {
    return []
  }

  var result: list<list<int>> = []
  var queue: list<map<string, any>> = [root]
  var level = 0

  while len(queue) > 0 {
    var vals: list<int> = []
    var next: list<map<string, any>> = []
    for node in queue {
      if !isLeaf(node) {
        vals = vals + [value(node)]
        let l = left(node)
        let r = right(node)
        if !isLeaf(l) { next = next + [l] }
        if !isLeaf(r) { next = next + [r] }
      }
    }
    if level % 2 == 1 {
      vals = reverseList(vals)
    }
    result = result + [vals]
    queue = next
    level = level + 1
  }

  return result
}

// Test cases derived from LeetCode

test "example 1" {
  let tree = Node(
    Node(Leaf(), 9, Leaf()),
    3,
    Node(
      Node(Leaf(), 15, Leaf()),
      20,
      Node(Leaf(), 7, Leaf())
    )
  )
  expect zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]
}

test "single node" {
  expect zigzagLevelOrder(Node(Leaf(), 1, Leaf())) == [[1]]
}

test "empty" {
  expect zigzagLevelOrder(Leaf()) == []
}

test "unbalanced" {
  let tree = Node(
    Node(
      Node(Leaf(), 4, Leaf()),
      2,
      Leaf()
    ),
    1,
    Node(
      Leaf(),
      3,
      Node(Leaf(), 5, Leaf())
    )
  )
 expect zigzagLevelOrder(tree) == [[1], [3, 2], [4, 5]]
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' when comparing values.
   if level = 1 { }      // ❌ assignment
   if level == 1 { }     // ✅ comparison
2. Reassigning a value declared with 'let'.
   let queue = []
   queue = next            // ❌ cannot modify immutable binding
   var queue = []          // ✅ declare with 'var' if it will change
3. Forgetting to reset `vals` or `next` each loop causes incorrect output.
   Re-initialize them on every iteration as shown above.
4. Missing parentheses on Leaf() when creating empty children.
   Node(Leaf, 1, Leaf)  // ❌ not a call
   Node(Leaf(), 1, Leaf())  // ✅ use Leaf()
*/
