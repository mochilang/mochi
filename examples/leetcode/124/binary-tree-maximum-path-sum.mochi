// LeetCode 124 - Binary Tree Maximum Path Sum

// Binary tree definition used across the examples.
type Tree =
  Leaf
  | Node(left: Tree, value: int, right: Tree)

fun max(a: int, b: int): int {
  if a > b { return a }
  return b
}

// Return `x` if it is positive, otherwise 0.
fun pos(x: int): int {
  if x > 0 { return x }
  return 0
}

// Compute the maximum path sum in the given tree.
fun maxPathSum(root: Tree): int {
  // smallest 32 bit integer: -(2^31)
  var best = -2147483647 - 1

  fun dfs(t: Tree): int {
    return match t {
      Leaf => 0
      Node(l, v, r) => {
        let left = dfs(l)
        let right = dfs(r)
        let leftPos = pos(left)
        let rightPos = pos(right)

        let through = v + leftPos + rightPos
        if through > best { best = through }

        let down = v + max(leftPos, rightPos)
        pos(down)
      }
    }
  }

  dfs(root)
  return best
}

// Test cases based on LeetCode examples

test "example 1" {
  let tree = Node {
    left: Node { left: Leaf, value: 2, right: Leaf },
    value: 1,
    right: Node { left: Leaf, value: 3, right: Leaf }
  }
  expect maxPathSum(tree) == 6
}

test "example 2" {
  let tree = Node {
    left: Node { left: Leaf, value: 9, right: Leaf },
    value: -10,
    right: Node {
      left: Node { left: Leaf, value: 15, right: Leaf },
      value: 20,
      right: Node { left: Leaf, value: 7, right: Leaf }
    }
  }
  expect maxPathSum(tree) == 42
}

test "single negative" {
  expect maxPathSum(Node { left: Leaf, value: -3, right: Leaf }) == (-3)
}

test "all negative" {
  let tree = Node {
    left: Node { left: Leaf, value: -5, right: Leaf },
    value: -2,
    right: Node { left: Leaf, value: -4, right: Leaf }
  }
  expect maxPathSum(tree) == (-2)
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' when comparing values.
   if x = 1 { ... }  // ❌ assignment
   if x == 1 { ... } // ✅ comparison
2. Reassigning a value bound with 'let'.
   let n = 0
   n = 1  // error[E004]
   // Fix: declare with 'var n = 0' if mutation is needed.
3. Using 'None' or 'null' instead of the 'Leaf' variant for empty children.
   Node { left: None, value: 1, right: None } // ❌
   Node { left: Leaf, value: 1, right: Leaf } // ✅
*/
