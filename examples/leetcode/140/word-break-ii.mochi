fun wordBreak(s: string, wordDict: list<string>): list<string> {
  // Build a map for constant-time word lookup
  var dict: map<string, bool> = {}
  for w in wordDict {
    dict[w] = true
  }
  let n = len(s)
  // memo[start] stores all sentences for substring s[start:]
  var memo: map<int, list<string>> = {}

  fun backtrack(start: int): list<string> {
    if start in memo {
      return memo[start]
    }
    var results: list<string> = []
    if start == n {
      results = [""]
    } else {
      var end = start + 1
      while end <= n {
        let word = s[start:end]
        var exists = false
        if word in dict {
          exists = dict[word]
        }
        if exists {
          let tails = backtrack(end)
          for t in tails {
            if len(t) == 0 {
              results = results + [word]
            } else {
              results = results + [word + " " + t]
            }
          }
        }
        end = end + 1
      }
    }
    memo[start] = results
    return results
  }

  let sentences = backtrack(0)
  let ordered = from s in sentences sort by s select s
  return ordered
}

// Test cases based on LeetCode examples

let dict1 = ["cat", "cats", "and", "sand", "dog"]

test "example 1" {
  expect wordBreak("catsanddog", dict1) == ["cat sand dog", "cats and dog"]
}

let dict2 = ["apple", "pen", "applepen", "pine", "pineapple"]

test "example 2" {
  expect wordBreak("pineapplepenapple", dict2) == [
    "pine apple pen apple",
    "pine applepen apple",
    "pineapple pen apple"
  ]
}

test "example 3" {
  expect wordBreak("catsandog", dict1) == []
}

/*
Common Mochi language errors and how to fix them:
1. Confusing '=' with '==' for comparison:
     if word = target { ... }   // ❌ assignment, not comparison
   Use '==' when checking equality.
2. Modifying a value declared with 'let':
     let res: list<string> = []
     res = res + [w]            // ❌ immutable binding
   Declare with 'var' when mutation is required.
3. Missing type annotation on empty collections:
     var memo = {}              // ❌ type cannot be inferred
   Provide explicit types, e.g. 'var memo: map<int, list<string>> = {}'.
*/
