// LeetCode 133 - Clone Graph

// Node definition for an undirected graph.
type Node =
  Node(val: int, neighbors: list<Node>)

// Clone the graph starting from `root` using DFS with memoization.
fun cloneGraph(root: Node): Node {
  var clones: map<int, Node> = {}

  fun dfs(n: Node): Node {
    if n.val in clones {
      return clones[n.val]
    }

    // placeholder node to break cycles
    clones[n.val] = Node { val: n.val, neighbors: [] }

    var clonedNeighbors: list<Node> = []
    for nb in n.neighbors {
      clonedNeighbors = clonedNeighbors + [dfs(nb)]
    }

    let newNode = Node { val: n.val, neighbors: clonedNeighbors }
    clones[n.val] = newNode
    return newNode
  }

  return dfs(root)
}

// Example graph: 1 -> 2 -> 3 -> 4
let g4 = Node { val: 4, neighbors: [] }
let g3 = Node { val: 3, neighbors: [g4] }
let g2 = Node { val: 2, neighbors: [g3] }
let g1 = Node { val: 1, neighbors: [g2] }

test "clone chain" {
  let c = cloneGraph(g1)
  expect c.val == 1
  expect c.neighbors[0].val == 2
  expect c.neighbors[0].neighbors[0].val == 3
  expect c.neighbors[0].neighbors[0].neighbors[0].val == 4
}

test "independent copy" {
  let c = cloneGraph(g1)
  expect c != g1
  expect c.neighbors[0] != g2
}

/*
Common Mochi language errors and how to fix them:
1. Confusing '=' with '==' in conditions:
     if a = b { }   // ❌ assigns to a
     if a == b { }  // ✅ compares values
2. Attempting to mutate a value declared with 'let':
     let m = {}
     m = {1: Node { val: 1, neighbors: [] }} // error[E004]
   Use 'var m: map<int, Node> = {}' when mutation is required.
3. Missing element types for an empty collection:
     var q = []  // error[I012]
   Provide the type, e.g. 'var q: list<Node> = []'.
4. Not returning a value from every branch:
     fun f(x: int): int {
       if x > 0 { return 1 }
       // missing else branch -> error
     }
   Ensure all paths yield the expected type.
*/
