// LeetCode 101 - Symmetric Tree
//
// This version avoids union types and pattern matching by representing
// the tree as an array of nodes indexed by position. A child index of
// -1 means there is no child.

type Node {
  value: int
  left: int
  right: int
}

fun isMirror(tree: list<Node>, i: int, j: int): bool {
  if i == (-1) && j == (-1) { return true }
  if i == (-1) || j == (-1) { return false }
  let n1 = tree[i]
  let n2 = tree[j]
  if n1.value != n2.value { return false }
  return isMirror(tree, n1.left, n2.right) && isMirror(tree, n1.right, n2.left)
}

fun isSymmetric(tree: list<Node>, root: int): bool {
  return isMirror(tree, root, root)
}

// Test cases from LeetCode

test "example 1" {
  let tree: list<Node> = [
    Node { value: 1, left: 1, right: 2 },  // 0
    Node { value: 2, left: 3, right: 4 },  // 1
    Node { value: 2, left: 5, right: 6 },  // 2
    Node { value: 3, left: -1, right: -1 }, // 3
    Node { value: 4, left: -1, right: -1 }, // 4
    Node { value: 4, left: -1, right: -1 }, // 5
    Node { value: 3, left: -1, right: -1 }  // 6
  ]
  expect isSymmetric(tree, 0) == true
}

test "example 2" {
  let tree: list<Node> = [
    Node { value: 1, left: 1, right: 2 }, // 0
    Node { value: 2, left: -1, right: 3 }, // 1
    Node { value: 2, left: -1, right: 4 }, // 2
    Node { value: 3, left: -1, right: -1 }, // 3
    Node { value: 3, left: -1, right: -1 }  // 4
  ]
  expect isSymmetric(tree, 0) == false
}

test "single node" {
  let tree = [Node { value: 1, left: -1, right: -1 }]
  expect isSymmetric(tree, 0) == true
}

test "empty" {
  let empty: list<Node> = []
  expect isSymmetric(empty, -1) == true
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' when comparing values:
     if n1.value = n2.value { }
   // Use '==' when comparing values.
2. Reassigning a value bound with 'let':
     let idx = 0
     idx = 1      // error[E004]
   // Use 'var' when the value needs to change.
3. Creating an empty list without specifying its element type:
     var nodes = []            // error[E027]
   // Provide the type: var nodes: list<Node> = []
4. Accessing a child index that is -1:
     let n = tree[node.left]
   // Check the index is not -1 before indexing.
*/
