// LeetCode 101 - Symmetric Tree

// Definition of a binary tree without using union types or pattern matching.
// A Leaf node is represented as {"__name": "Leaf"} and a regular node as
// {"__name": "Node", "left": left, "value": value, "right": right}.

fun Leaf(): map<string, any> {
  return {"__name": "Leaf"}
}

fun Node(left: map<string, any>, value: int, right: map<string, any>): map<string, any> {
  return {"__name": "Node", "left": left, "value": value, "right": right}
}

fun isLeaf(t: map<string, any>): bool { return t["__name"] == "Leaf" }
fun left(t: map<string, any>): map<string, any> { return t["left"] }
fun right(t: map<string, any>): map<string, any> { return t["right"] }
fun value(t: map<string, any>): int { return t["value"] as int }

// Determine if a binary tree is a mirror of itself.
fun isSymmetric(root: map<string, any>): bool {
  fun isMirror(t1: map<string, any>, t2: map<string, any>): bool {
    if isLeaf(t1) && isLeaf(t2) { return true }
    if isLeaf(t1) || isLeaf(t2) { return false }
    return value(t1) == value(t2) &&
      isMirror(left(t1), right(t2)) &&
      isMirror(right(t1), left(t2))
  }
  return isMirror(root, root)
}

// Test cases from LeetCode

test "example 1" {
  let tree = Node(
    Node(
      Node(Leaf(), 3, Leaf()),
      2,
      Node(Leaf(), 4, Leaf())
    ),
    1,
    Node(
      Node(Leaf(), 4, Leaf()),
      2,
      Node(Leaf(), 3, Leaf())
    )
  )
  expect isSymmetric(tree) == true
}

test "example 2" {
  let tree = Node(
    Node(
      Leaf(),
      2,
      Node(Leaf(), 3, Leaf())
    ),
    1,
    Node(
      Leaf(),
      2,
      Node(Leaf(), 3, Leaf())
    )
  )
  expect isSymmetric(tree) == false
}

test "single node" {
  expect isSymmetric(Node(Leaf(), 1, Leaf())) == true
}

test "empty" {
  expect isSymmetric(Leaf()) == true
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' when comparing values:
   if isLeaf(node) = true { }   // ❌ assignment
   if isLeaf(node) == true { }  // ✅ comparison
2. Reassigning an immutable binding:
   let x = 1
   x = 2                  // ❌ cannot assign
   var x = 1
   x = 2                  // ✅ use 'var' if mutation is needed
3. Accessing a field on a Leaf node without checking:
   value(Leaf())          // ❌ runtime error
   if !isLeaf(node) { value(node) } // ✅ ensure the node is not a Leaf
4. Using 'null' instead of the Leaf constructor:
   let t = null           // ❌ undefined value
   let t = Leaf()         // ✅ represents an empty subtree
*/
