// Solution for LeetCode problem 102 - Binary Tree Level Order Traversal

// Binary tree node helpers implemented without union types or pattern matching
fun Leaf(): map<string, any> {
  return {"__name": "Leaf"}
}

fun Node(left: map<string, any>, value: int, right: map<string, any>): map<string, any> {
  return {"__name": "Node", "left": left, "value": value, "right": right}
}

fun isLeaf(t: map<string, any>): bool { return t["__name"] == "Leaf" }
fun left(t: map<string, any>): map<string, any> { return t["left"] }
fun right(t: map<string, any>): map<string, any> { return t["right"] }
fun value(t: map<string, any>): int { return t["value"] as int }

// Perform a breadth-first traversal returning values level by level
fun levelOrder(root: map<string, any>): list<list<int>> {
  if isLeaf(root) { return [] as list<list<int>> }

  var result: list<list<int>> = []
  var queue: list<map<string, any>> = [root]

  while len(queue) > 0 {
    var level: list<int> = []
    var next: list<map<string, any>> = []

    for node in queue {
      level = level + [value(node)]
      if !isLeaf(left(node)) { next = next + [left(node)] }
      if !isLeaf(right(node)) { next = next + [right(node)] }
    }

    result = result + [level]
    queue = next
  }

  return result
}

// Test cases based on LeetCode examples

test "example 1" {
  let tree = Node(
    Node(Leaf(), 9, Leaf()),
    3,
    Node(
      Node(Leaf(), 15, Leaf()),
      20,
      Node(Leaf(), 7, Leaf())
    )
  )
  expect levelOrder(tree) == [[3], [9,20], [15,7]]
}

test "single node" {
  expect levelOrder(Node(Leaf(), 1, Leaf())) == [[1]]
}

test "empty" {
  expect levelOrder(Leaf()) == []
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' for comparisons.
   if len(q) = 0 { }        // ❌ assignment
   if len(q) == 0 { }       // ✅ comparison
2. Forgetting to give a list its element type.
   var q = []               // ❌ type cannot be inferred
   var q: list<int> = []    // ✅ specify list type
3. Reassigning a variable declared with 'let'.
   let level = []
   level = [1]              // ❌ cannot assign
   var level = []           // ✅ declare with 'var' if mutation is needed
4. Calling Node or Leaf without parentheses.
   Node(Leaf, 1, Leaf)      // ❌ not a function call
   Node(Leaf(), 1, Leaf())  // ✅ include () when calling
*/
