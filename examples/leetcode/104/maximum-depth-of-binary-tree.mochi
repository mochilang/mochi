// LeetCode 104 - Maximum Depth of Binary Tree

// Binary tree helpers without using union types.
fun Leaf(): map<string, any> {
  return {"__name": "Leaf"}
}

fun Node(left: map<string, any>, value: int, right: map<string, any>): map<string, any> {
  return {"__name": "Node", "left": left, "value": value, "right": right}
}

fun isLeaf(t: map<string, any>): bool {
  return t["__name"] == "Leaf"
}

fun left(t: map<string, any>): map<string, any> { return t["left"] }
fun right(t: map<string, any>): map<string, any> { return t["right"] }
fun value(t: map<string, any>): int { return t["value"] as int }

// Return the greater of two integers.
fun max(a: int, b: int): int {
  if a > b {
    return a
  } else {
    return b
  }
}

// Recursively compute the maximum depth of the tree.
fun maxDepth(root: map<string, any>): int {
  if isLeaf(root) {
    return 0
  }
  let l = left(root)
  let r = right(root)
  let ld = maxDepth(l)
  let rd = maxDepth(r)
  return max(ld, rd) + 1
}

// Test cases from LeetCode

test "example 1" {
  let tree = Node(
    Node(Leaf(), 9, Leaf()),
    3,
    Node(Node(Leaf(), 15, Leaf()), 20, Node(Leaf(), 7, Leaf()))
  )
  expect maxDepth(tree) == 3
}

test "example 2" {
  let tree = Node(
    Leaf(),
    1,
    Node(Leaf(), 2, Leaf())
  )
  expect maxDepth(tree) == 2
}

test "single node" {
  expect maxDepth(Node(Leaf(), 0, Leaf())) == 1
}

test "empty" {
  expect maxDepth(Leaf()) == 0
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' when comparing values:
   if depth = 1 { ... }  // ❌ assignment
   if depth == 1 { ... } // ✅ comparison
2. Reassigning a value bound with 'let':
   let d = 0
   d = d + 1          // ❌ cannot reassign immutable binding
   // Fix: declare with 'var' if it needs to change.
3. Forgetting to construct empty nodes with Leaf():
   let t = Leaf       // ❌ missing parentheses
   Node(t, 1, Leaf()) // ✅ call Leaf() to create an empty node
*/
