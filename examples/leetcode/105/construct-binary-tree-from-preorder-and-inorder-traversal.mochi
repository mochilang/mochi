// LeetCode 105 - Construct Binary Tree from Preorder and Inorder Traversal

// Binary tree represented by parallel arrays.
// Each node is an index into these arrays. A value of -1 means "no child".
type BinaryTree {
  lefts: list<int>
  rights: list<int>
  values: list<int>
  root: int
}

// Build the tree using preorder and inorder sequences
fun buildTree(preorder: list<int>, inorder: list<int>): BinaryTree {
  let n = len(preorder)
  // Map values to their index in inorder for fast lookup
  var idxMap: map<int, int> = {}
  for i in 0..n {
    idxMap[inorder[i]] = i
  }

  var preIdx = 0
  var lefts: list<int> = []
  var rights: list<int> = []
  var values: list<int> = []

  fun helper(lo: int, hi: int): int {
    if lo >= hi {
      return (-1)
    }
    let val = preorder[preIdx]
    preIdx = preIdx + 1
    let mid = idxMap[val]

    let idx = len(values)
    values = values + [val]
    lefts = lefts + [(-1)]
    rights = rights + [(-1)]

    let l = helper(lo, mid)
    let r = helper(mid + 1, hi)
    lefts[idx] = l
    rights[idx] = r
    return idx
  }

  let rootIdx = helper(0, n)
  return BinaryTree { lefts: lefts, rights: rights, values: values, root: rootIdx }
}

fun preorderTraversal(t: BinaryTree): list<int> {
  fun dfs(i: int): list<int> {
    if i == (-1) {
      return [] as list<int>
    }
    return [t.values[i]] + dfs(t.lefts[i]) + dfs(t.rights[i])
  }
  return dfs(t.root)
}

fun inorderTraversal(t: BinaryTree): list<int> {
  fun dfs(i: int): list<int> {
    if i == (-1) {
      return [] as list<int>
    }
    return dfs(t.lefts[i]) + [t.values[i]] + dfs(t.rights[i])
  }
  return dfs(t.root)
}

fun isEmpty(t: BinaryTree): bool {
  return t.root == (-1)
}

// Test cases from LeetCode

test "example 1" {
  let preorder = [3,9,20,15,7]
  let inorder = [9,3,15,20,7]
  let tree = buildTree(preorder, inorder)
  expect preorderTraversal(tree) == preorder
  expect inorderTraversal(tree) == inorder
}

test "single node" {
  let preorder = [1]
  let inorder = [1]
  let tree = buildTree(preorder, inorder)
  expect preorderTraversal(tree) == preorder
  expect inorderTraversal(tree) == inorder
}

test "empty" {
  expect isEmpty(buildTree([], [])) == true
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' in conditions:
   if n = 0 { }     // ❌ assignment
   if n == 0 { }    // ✅ comparison
2. Reassigning an immutable binding:
   let i = 0
   i = i + 1        // ❌ cannot reassign 'let' binding
   var i = 0        // ✅ use 'var' when mutation is needed
3. Forgetting to specify a list's element type:
   var xs = []            // ❌ type cannot be inferred
   var xs: list<int> = [] // ✅ element type provided
*/
