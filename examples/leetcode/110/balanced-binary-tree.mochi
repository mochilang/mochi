// LeetCode 110 - Balanced Binary Tree

// Basic binary tree definition used in many examples.
type Tree =
  Leaf
  | Node(left: Tree, value: int, right: Tree)

// Helper struct returned by the recursive check function.
type Info {
  height: int
  balanced: bool
}

// Determine if the tree is height-balanced. A tree is balanced if the depths
// of the left and right subtrees of every node never differ by more than one.
fun isBalanced(root: Tree): bool {
  fun check(t: Tree): Info {
    match t {
      Leaf => Info { height: 0, balanced: true }
      Node(l, _, r) => {
        let left = check(l)
        let right = check(r)
        let diff = if left.height > right.height {
          left.height - right.height
        } else {
          right.height - left.height
        }
        let h = if left.height > right.height { left.height } else { right.height }
        Info {
          height: h + 1,
          balanced: left.balanced && right.balanced && diff <= 1
        }
      }
    }
  }

  let info = check(root)
  info.balanced
}

// Test cases from the LeetCode problem statement

test "example 1" {
  let tree = Node {
    left: Node { left: Leaf {}, value: 9, right: Leaf {} },
    value: 3,
    right: Node {
      left: Node { left: Leaf {}, value: 15, right: Leaf {} },
      value: 20,
      right: Node { left: Leaf {}, value: 7, right: Leaf {} }
    }
  }
  expect isBalanced(tree) == true
}

test "example 2" {
  let tree = Node {
    left: Node {
      left: Node {
        left: Node { left: Leaf {}, value: 4, right: Leaf {} },
        value: 3,
        right: Node { left: Leaf {}, value: 4, right: Leaf {} }
      },
      value: 2,
      right: Node { left: Leaf {}, value: 3, right: Leaf {} }
    },
    value: 1,
    right: Node { left: Leaf {}, value: 2, right: Leaf {} }
  }
  expect isBalanced(tree) == false
}

test "single node" {
  expect isBalanced(Node { left: Leaf {}, value: 1, right: Leaf {} }) == true
}

test "empty" {
  expect isBalanced(Leaf {}) == true
}

/*
Common Mochi language errors and how to fix them:
1. Confusing '=' with '==' in a condition:
     if diff = 1 { }
   // Use '==' for comparisons.
2. Reassigning a constant bound with 'let':
     let h = 0
     h = 1        // error[E004]
   // Declare with 'var' when the value must change.
3. Forgetting the Leaf branch in a match expression:
     match tree {
       Node(l, v, r) => ...
     }
   // Always provide a case for 'Leaf' to handle empty subtrees.
4. Calling Python-style methods on lists:
     stack.append(x)
   // Instead build a new list: stack = stack + [x].
5. Omitting braces when constructing Leaf:
     let t = Leaf
   // The correct syntax is 'Leaf {}'.
*/

