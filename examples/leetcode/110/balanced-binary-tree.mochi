// LeetCode 110 - Balanced Binary Tree

// Definition for a binary tree node used across the examples.
type Tree =
  Leaf
  | Node(left: Tree, value: int, right: Tree)

// Helper struct returned from the recursive check function.
type Info {
  height: int
  balanced: bool
}

// Determine if the tree is height-balanced.  A tree is balanced if
// the depths of the left and right subtrees of every node never
// differ by more than one.
fun max(a: int, b: int): int {
  if a > b { return a } else { return b }
}

fun abs(x: int): int {
  if x < 0 { return -x } else { return x }
}

fun height(t: Tree): int {
  return match t {
    Leaf => 0
    Node(l, _, r) => max(height(l), height(r)) + 1
  }
}

fun balanced(t: Tree): bool {
  return match t {
    Leaf => true
    Node(l, _, r) =>
      balanced(l) && balanced(r) &&
      abs(height(l) - height(r)) <= 1
  }
}

fun isBalanced(root: Tree): bool {
  return balanced(root)
}

// Test cases from the LeetCode problem statement

test "example 1" {
  let tree = Node {
    left: Node { left: Leaf {}, value: 9, right: Leaf {} },
    value: 3,
    right: Node {
      left: Node { left: Leaf {}, value: 15, right: Leaf {} },
      value: 20,
      right: Node { left: Leaf {}, value: 7, right: Leaf {} }
    }
  }
  expect isBalanced(tree) == true
}

test "example 2" {
  let tree = Node {
    left: Node {
      left: Node {
        left: Node { left: Leaf {}, value: 4, right: Leaf {} },
        value: 3,
        right: Node { left: Leaf {}, value: 4, right: Leaf {} }
      },
      value: 2,
      right: Node { left: Leaf {}, value: 3, right: Leaf {} }
    },
    value: 1,
    right: Node { left: Leaf {}, value: 2, right: Leaf {} }
  }
  expect isBalanced(tree) == false
}

test "single node" {
  expect isBalanced(Node { left: Leaf {}, value: 1, right: Leaf {} }) == true
}

test "empty" {
  expect isBalanced(Leaf {}) == true
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' in a condition:
     if diff = 1 { }
   // Use '==' when comparing values.
2. Reassigning a value bound with 'let':
     let h = 0
     h = 1        // error[E004]
   // Use 'var' when the value needs to change.
3. Forgetting the Leaf branch in a match expression:
     match tree {
       Node(l, v, r) => ...
     }
   // Always provide a case for 'Leaf' to handle empty trees.
4. Calling methods like Python lists:
     stack.append(x)
   // Instead build a new list: stack = stack + [x].
5. Omitting braces when creating Leaf:
     let t = Leaf
   // The correct form is 'Leaf {}'.
*/
