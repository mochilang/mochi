// LeetCode 117 - Populating Next Right Pointers in Each Node II

// Binary tree node with an extra `next` pointer for the same level.
type Tree =
  Leaf
  | Node(left: Tree, value: int, right: Tree, next: Tree)

// Return the first child encountered when following `next` pointers.
fun childAfter(node: Tree): Tree {
  var curr = node
  while match curr { Leaf => false _ => true } {
    match curr {
      Node(l, _, r, nxt) => {
        if match l { Leaf => false _ => true } { return l }
        if match r { Leaf => false _ => true } { return r }
        curr = nxt
      }
      Leaf => {}
    }
  }
  return Leaf {}
}

// Connect nodes level by level using already established `next` links.
fun dfs(node: Tree, nxt: Tree): Tree {
  return match node {
    Leaf => Leaf {}
    Node(l, v, r, _) => {
      let right = dfs(r, childAfter(nxt))
      let leftNext = match r {
        Leaf => childAfter(nxt)
        _ => childAfter(right)
      }
      let left = dfs(l, leftNext)
      Node { left: left, value: v, right: right, next: nxt }
    }
  }
}

fun connect(root: Tree): Tree {
  return dfs(root, Leaf {})
}

// Read values level by level by traversing `next` pointers.
fun byLevels(root: Tree): list<list<int>> {
  var result: list<list<int>> = []
  var start = root
  while match start { Leaf => false _ => true } {
    var level: list<int> = []
    var curr = start
    var nextStart = Leaf {}
    while match curr { Leaf => false _ => true } {
      match curr {
        Node(l, v, r, nxt) => {
          level = level + [v]
          if match nextStart { Leaf => true _ => false } {
            if match l { Leaf => false _ => true } { nextStart = l }
            else if match r { Leaf => false _ => true } { nextStart = r }
          }
          curr = nxt
        }
        Leaf => {}
      }
    }
    result = result + [level]
    start = nextStart
  }
  return result
}

// Example tree from LeetCode
let example = Node {
  left: Node {
    left: Node { left: Leaf {}, value: 4, right: Leaf {}, next: Leaf {} },
    value: 2,
    right: Node { left: Leaf {}, value: 5, right: Leaf {}, next: Leaf {} },
    next: Leaf {}
  },
  value: 1,
  right: Node {
    left: Leaf {},
    value: 3,
    right: Node { left: Leaf {}, value: 7, right: Leaf {}, next: Leaf {} },
    next: Leaf {}
  },
  next: Leaf {}
}

test "example" {
  let connected = connect(example)
  expect byLevels(connected) == [[1], [2,3], [4,5,7]]
}

test "single node" {
  let tree = Node { left: Leaf {}, value: 1, right: Leaf {}, next: Leaf {} }
  expect byLevels(connect(tree)) == [[1]]
}

test "empty" {
  expect byLevels(connect(Leaf {})) == []
}

/*
Common Mochi language errors and how to fix them:
1. Reassigning a constant binding. Use `var` when a variable needs to change.
2. Confusing assignment `=` with comparison `==` in conditions.
3. Using `None` or `null` instead of the `Leaf` constructor for empty trees.
4. Forgetting a `Leaf` branch when pattern matching on the `Tree` type.
*/
