// Solution for LeetCode problem 117 - Populating Next Right Pointers in Each Node II

// Binary tree with an extra `next` pointer linking nodes on the same level.
type Tree =
  Leaf
  | Node(left: Tree, value: int, right: Tree, next: Tree)

// Find the first child reachable by following `next` links.
fun firstChild(node: Tree): Tree {
  var curr = node
  while match curr { Leaf => false _ => true } {
    match curr {
      Node(l, _, r, nxt) => {
        if match l { Leaf => false _ => true } { return l }
        if match r { Leaf => false _ => true } { return r }
        curr = nxt
      }
      Leaf => {}
    }
  }
  return Leaf {}
}

// Recursively connect children, threading their `next` pointer.
fun connectNode(node: Tree, nxt: Tree): Tree {
  return match node {
    Leaf => Leaf {}
    Node(l, v, r, _) => {
      let right = connectNode(r, firstChild(nxt))
      let leftNext = match r {
        Leaf => firstChild(nxt)
        _ => firstChild(right)
      }
      let left = connectNode(l, leftNext)
      Node { left: left, value: v, right: right, next: nxt }
    }
  }
}

fun connect(root: Tree): Tree {
  return connectNode(root, Leaf {})
}

// Collect values by levels following the `next` pointers.
fun levels(root: Tree): list<list<int>> {
  var result: list<list<int>> = []
  var start = root
  while match start { Leaf => false _ => true } {
    var curr = start
    var level: list<int> = []
    var nextStart = Leaf {}
    while match curr { Leaf => false _ => true } {
      match curr {
        Node(l, v, r, nxt) => {
          level = level + [v]
          if match nextStart { Leaf => true _ => false } {
            if match l { Leaf => false _ => true } { nextStart = l }
            else if match r { Leaf => false _ => true } { nextStart = r }
          }
          curr = nxt
        }
        Leaf => {}
      }
    }
    result = result + [level]
    start = nextStart
  }
  return result
}

// Example tree from the problem description
let example = Node {
  left: Node {
    left: Node { left: Leaf {}, value: 4, right: Leaf {}, next: Leaf {} },
    value: 2,
    right: Node { left: Leaf {}, value: 5, right: Leaf {}, next: Leaf {} },
    next: Leaf {}
  },
  value: 1,
  right: Node {
    left: Leaf {},
    value: 3,
    right: Node { left: Leaf {}, value: 7, right: Leaf {}, next: Leaf {} },
    next: Leaf {}
  },
  next: Leaf {}
}

test "example" {
  expect levels(connect(example)) == [[1],[2,3],[4,5,7]]
}

test "single node" {
  let tree = Node { left: Leaf {}, value: 1, right: Leaf {}, next: Leaf {} }
  expect levels(connect(tree)) == [[1]]
}

test "empty" {
  expect levels(connect(Leaf {})) == []
}

/*
Common Mochi language errors and how to fix them:
1. Using '=' instead of '==' when comparing values.
2. Reassigning a binding declared with 'let'. Use 'var' for mutable variables.
3. Forgetting a 'Leaf' branch when pattern matching on the 'Tree' type.
*/
