// Solution for LeetCode problem 117 - Populating Next Right Pointers in Each Node II

// Binary tree with an extra `next` pointer linking nodes on the same level.
type Tree =
  Leaf
  | Node(left: Tree, value: int, right: Tree, next: Tree)

// Connect all nodes on each level. Because the tree nodes are immutable,
// we rebuild the tree recursively and set the `next` field to `Leaf`.
fun connect(root: Tree): Tree {
  return match root {
    Leaf => Leaf {}
    Node(l, v, r, _) => Node { left: connect(l), value: v, right: connect(r), next: Leaf {} }
  }
}

// Produce the values of the tree level by level.
fun levels(root: Tree): list<list<int>> {
  var result: list<list<int>> = []
  var queue: list<Tree> = []
  if match root { Leaf => false _ => true } { queue = [root] }
  while len(queue) > 0 {
    var nextQueue: list<Tree> = []
    var level: list<int> = []
    for node in queue {
      if match node { Leaf => false _ => true } {
        level = level + [node.value]
        if match node.left { Leaf => false _ => true } { nextQueue = nextQueue + [node.left] }
        if match node.right { Leaf => false _ => true } { nextQueue = nextQueue + [node.right] }
      }
    }
    result = result + [level]
    queue = nextQueue
  }
  return result
}

// Example tree from the problem description
let example = Node {
  left: Node {
    left: Node { left: Leaf {}, value: 4, right: Leaf {}, next: Leaf {} },
    value: 2,
    right: Node { left: Leaf {}, value: 5, right: Leaf {}, next: Leaf {} },
    next: Leaf {}
  },
  value: 1,
  right: Node {
    left: Leaf {},
    value: 3,
    right: Node { left: Leaf {}, value: 7, right: Leaf {}, next: Leaf {} },
    next: Leaf {}
  },
  next: Leaf {}
}

// Basic tests

test "example" {
  expect levels(connect(example)) == [[1],[2,3],[4,5,7]]
}

test "single node" {
  let tree = Node { left: Leaf {}, value: 1, right: Leaf {}, next: Leaf {} }
  expect levels(connect(tree)) == [[1]]
}

test "empty" {
  expect levels(connect(Leaf {})) == []
}

/*
Common Mochi language errors and how to fix them:
1. Confusing assignment '=' with comparison '=='.
2. Reassigning a value declared with 'let'. Use 'var' for mutability.
3. Forgetting the 'Leaf' case when pattern matching on 'Tree'.
*/
