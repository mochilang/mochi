// Code generated by ccgo from chibicc sources; DO NOT EDIT.

package main

import (
	"unsafe"
	"modernc.org/libc"
)

func fnv_hash(tls *libc.TLS, s uintptr, len int32) uint64_t { /* hashmap.c:17:17: */
	var hash uint64_t = libc.Uint64(0xcbf29ce484222325)
	{
		var i int32 = 0
		for ; i < len; i++ {
			hash = hash * uint64(0x100000001b3)
			hash = hash ^ uint64_t(uint8(*(*int8)(unsafe.Pointer(s + uintptr(i)))))
		}
	}
	return hash
}

// Make room for new entires in a given hashmap by removing
// tombstones and possibly extending the bucket size.
func rehash(tls *libc.TLS, map1 uintptr) { /* hashmap.c:28:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// Compute the size of the new hashmap.
	var nkeys int32 = 0
	{
		var i int32 = 0
		for ; i < (*HashMap)(unsafe.Pointer(map1)).capacity; i++ {
			if (*HashEntry)(unsafe.Pointer((*HashMap)(unsafe.Pointer(map1)).buckets+uintptr(i)*24)).key != 0 && (*HashEntry)(unsafe.Pointer((*HashMap)(unsafe.Pointer(map1)).buckets+uintptr(i)*24)).key != libc.UintptrFromInt32(-1) {
				nkeys++
			}
		}
	}

	var cap int32 = (*HashMap)(unsafe.Pointer(map1)).capacity
	for nkeys*100/cap >= 50 {
		cap = cap * 2
	}
	if cap > 0 {
	} else {
		libc.X__assert_fail(tls, ts+6733, ts+6741, uint32(38), uintptr(unsafe.Pointer(&__func__3)))
	}

	// Create a new hashmap and copy all key-values.
	*(*HashMap)(unsafe.Pointer(bp /* map2 */)) = HashMap{}
	(*HashMap)(unsafe.Pointer(bp /* &map2 */)).buckets = libc.Xcalloc(tls, uint64(cap), uint64(unsafe.Sizeof(HashEntry{})))
	(*HashMap)(unsafe.Pointer(bp /* &map2 */)).capacity = cap

	{
		var i1 int32 = 0
		for ; i1 < (*HashMap)(unsafe.Pointer(map1)).capacity; i1++ {
			var ent uintptr = (*HashMap)(unsafe.Pointer(map1)).buckets + uintptr(i1)*24
			if (*HashEntry)(unsafe.Pointer(ent)).key != 0 && (*HashEntry)(unsafe.Pointer(ent)).key != libc.UintptrFromInt32(-1) {
				hashmap_put2(tls, bp, (*HashEntry)(unsafe.Pointer(ent)).key, (*HashEntry)(unsafe.Pointer(ent)).keylen, (*HashEntry)(unsafe.Pointer(ent)).val)
			}
		}
	}

	if (*HashMap)(unsafe.Pointer(bp)).used == nkeys {
	} else {
		libc.X__assert_fail(tls, ts+6751, ts+6741, uint32(51), uintptr(unsafe.Pointer(&__func__3)))
	}
	*(*HashMap)(unsafe.Pointer(map1)) = *(*HashMap)(unsafe.Pointer(bp /* map2 */))
}

var __func__3 = *(*[7]int8)(unsafe.Pointer(ts + 6770)) /* hashmap.c:28:34 */

func match(tls *libc.TLS, ent uintptr, key uintptr, keylen int32) uint8 { /* hashmap.c:55:13: */
	return uint8(libc.Bool32((*HashEntry)(unsafe.Pointer(ent)).key != 0 && (*HashEntry)(unsafe.Pointer(ent)).key != libc.UintptrFromInt32(-1) && (*HashEntry)(unsafe.Pointer(ent)).keylen == keylen && libc.Xmemcmp(tls, (*HashEntry)(unsafe.Pointer(ent)).key, key, uint64(keylen)) == 0))
}

func get_entry(tls *libc.TLS, map1 uintptr, key uintptr, keylen int32) uintptr { /* hashmap.c:60:18: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if !(int32((*HashMap)(unsafe.Pointer(map1)).buckets) != 0) {
		return uintptr(0)
	}

	var hash uint64_t = fnv_hash(tls, key, keylen)

	{
		var i int32 = 0
		for ; i < (*HashMap)(unsafe.Pointer(map1)).capacity; i++ {
			var ent uintptr = (*HashMap)(unsafe.Pointer(map1)).buckets + uintptr((hash+uint64_t(i))%uint64_t((*HashMap)(unsafe.Pointer(map1)).capacity))*24
			if match(tls, ent, key, keylen) != 0 {
				return ent
			}
			if (*HashEntry)(unsafe.Pointer(ent)).key == uintptr(0) {
				return uintptr(0)
			}
		}
	}
	error(tls, ts+217, libc.VaList(bp, ts+6741, 73))
	return uintptr(0)
}

func get_or_insert_entry(tls *libc.TLS, map1 uintptr, key uintptr, keylen int32) uintptr { /* hashmap.c:76:18: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if !(int32((*HashMap)(unsafe.Pointer(map1)).buckets) != 0) {
		(*HashMap)(unsafe.Pointer(map1)).buckets = libc.Xcalloc(tls, uint64(16), uint64(unsafe.Sizeof(HashEntry{})))
		(*HashMap)(unsafe.Pointer(map1)).capacity = 16
	} else if (*HashMap)(unsafe.Pointer(map1)).used*100/(*HashMap)(unsafe.Pointer(map1)).capacity >= 70 {
		rehash(tls, map1)
	}

	var hash uint64_t = fnv_hash(tls, key, keylen)

	{
		var i int32 = 0
		for ; i < (*HashMap)(unsafe.Pointer(map1)).capacity; i++ {
			var ent uintptr = (*HashMap)(unsafe.Pointer(map1)).buckets + uintptr((hash+uint64_t(i))%uint64_t((*HashMap)(unsafe.Pointer(map1)).capacity))*24

			if match(tls, ent, key, keylen) != 0 {
				return ent
			}

			if (*HashEntry)(unsafe.Pointer(ent)).key == libc.UintptrFromInt32(-1) {
				(*HashEntry)(unsafe.Pointer(ent)).key = key
				(*HashEntry)(unsafe.Pointer(ent)).keylen = keylen
				return ent
			}

			if (*HashEntry)(unsafe.Pointer(ent)).key == uintptr(0) {
				(*HashEntry)(unsafe.Pointer(ent)).key = key
				(*HashEntry)(unsafe.Pointer(ent)).keylen = keylen
				(*HashMap)(unsafe.Pointer(map1)).used++
				return ent
			}
		}
	}
	error(tls, ts+217, libc.VaList(bp, ts+6741, 105))
	return uintptr(0)
}

func hashmap_get(tls *libc.TLS, map1 uintptr, key uintptr) uintptr { /* hashmap.c:108:6: */
	return hashmap_get2(tls, map1, key, int32(libc.Xstrlen(tls, key)))
}

func hashmap_get2(tls *libc.TLS, map1 uintptr, key uintptr, keylen int32) uintptr { /* hashmap.c:112:6: */
	var ent uintptr = get_entry(tls, map1, key, keylen)
	if ent != 0 {
		return (*HashEntry)(unsafe.Pointer(ent)).val
	}
	return uintptr(0)
}

func hashmap_put(tls *libc.TLS, map1 uintptr, key uintptr, val uintptr) { /* hashmap.c:117:6: */
	hashmap_put2(tls, map1, key, int32(libc.Xstrlen(tls, key)), val)
}

func hashmap_put2(tls *libc.TLS, map1 uintptr, key uintptr, keylen int32, val uintptr) { /* hashmap.c:121:6: */
	var ent uintptr = get_or_insert_entry(tls, map1, key, keylen)
	(*HashEntry)(unsafe.Pointer(ent)).val = val
}

func hashmap_delete(tls *libc.TLS, map1 uintptr, key uintptr) { /* hashmap.c:126:6: */
	hashmap_delete2(tls, map1, key, int32(libc.Xstrlen(tls, key)))
}

func hashmap_delete2(tls *libc.TLS, map1 uintptr, key uintptr, keylen int32) { /* hashmap.c:130:6: */
	var ent uintptr = get_entry(tls, map1, key, keylen)
	if ent != 0 {
		(*HashEntry)(unsafe.Pointer(ent)).key = libc.UintptrFromInt32(-1)
	}
}

func hashmap_test(tls *libc.TLS) { /* hashmap.c:136:6: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var map1 uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(HashMap{})))

	{
		var i int32 = 0
		for ; i < 5000; i++ {
			hashmap_put(tls, map1, format(tls, ts+6777, libc.VaList(bp, i)), uintptr(size_t(i)))
		}
	}
	{
		var i1 int32 = 1000
		for ; i1 < 2000; i1++ {
			hashmap_delete(tls, map1, format(tls, ts+6777, libc.VaList(bp+8, i1)))
		}
	}
	{
		var i2 int32 = 1500
		for ; i2 < 1600; i2++ {
			hashmap_put(tls, map1, format(tls, ts+6777, libc.VaList(bp+16, i2)), uintptr(size_t(i2)))
		}
	}
	{
		var i3 int32 = 6000
		for ; i3 < 7000; i3++ {
			hashmap_put(tls, map1, format(tls, ts+6777, libc.VaList(bp+24, i3)), uintptr(size_t(i3)))
		}
	}

	{
		var i4 int32 = 0
		for ; i4 < 1000; i4++ {
			if size_t(hashmap_get(tls, map1, format(tls, ts+6777, libc.VaList(bp+32, i4)))) == size_t(i4) {
			} else {
				libc.X__assert_fail(tls, ts+6784, ts+6741, uint32(149), uintptr(unsafe.Pointer(&__func__4)))
			}
		}
	}
	{
		var i5 int32 = 1000
		for ; i5 < 1500; i5++ {
			if hashmap_get(tls, map1, ts+6835) == uintptr(0) {
			} else {
				libc.X__assert_fail(tls, ts+6847, ts+6741, uint32(151), uintptr(unsafe.Pointer(&__func__4)))
			}
		}
	}
	{
		var i6 int32 = 1500
		for ; i6 < 1600; i6++ {
			if size_t(hashmap_get(tls, map1, format(tls, ts+6777, libc.VaList(bp+48, i6)))) == size_t(i6) {
			} else {
				libc.X__assert_fail(tls, ts+6784, ts+6741, uint32(153), uintptr(unsafe.Pointer(&__func__4)))
			}
		}
	}
	{
		var i7 int32 = 1600
		for ; i7 < 2000; i7++ {
			if hashmap_get(tls, map1, ts+6835) == uintptr(0) {
			} else {
				libc.X__assert_fail(tls, ts+6847, ts+6741, uint32(155), uintptr(unsafe.Pointer(&__func__4)))
			}
		}
	}
	{
		var i8 int32 = 2000
		for ; i8 < 5000; i8++ {
			if size_t(hashmap_get(tls, map1, format(tls, ts+6777, libc.VaList(bp+64, i8)))) == size_t(i8) {
			} else {
				libc.X__assert_fail(tls, ts+6784, ts+6741, uint32(157), uintptr(unsafe.Pointer(&__func__4)))
			}
		}
	}
	{
		var i9 int32 = 5000
		for ; i9 < 6000; i9++ {
			if hashmap_get(tls, map1, ts+6835) == uintptr(0) {
			} else {
				libc.X__assert_fail(tls, ts+6847, ts+6741, uint32(159), uintptr(unsafe.Pointer(&__func__4)))
			}
		}
	}
	{
		var i10 int32 = 6000
		for ; i10 < 7000; i10++ {
			hashmap_put(tls, map1, format(tls, ts+6777, libc.VaList(bp+80, i10)), uintptr(size_t(i10)))
		}
	}

	if hashmap_get(tls, map1, ts+6835) == uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+6847, ts+6741, uint32(163), uintptr(unsafe.Pointer(&__func__4)))
	}
	libc.Xprintf(tls, ts+6887, 0)
}

var __func__4 = *(*[13]int8)(unsafe.Pointer(ts + 6891)) /* hashmap.c:136:25 */

