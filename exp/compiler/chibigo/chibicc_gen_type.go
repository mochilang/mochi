// Code generated by ccgo from chibicc sources; DO NOT EDIT.

package main

import (
	"unsafe"
	"modernc.org/libc"
)

var ty_void_storage = Type{size: 1, align: 1}                /* type.c:3:13 */
var ty_bool_storage = Type{kind: TY_BOOL, size: 1, align: 1} /* type.c:4:13 */

var ty_char_storage = Type{kind: TY_CHAR, size: 1, align: 1}   /* type.c:6:13 */
var ty_short_storage = Type{kind: TY_SHORT, size: 2, align: 2} /* type.c:7:13 */
var ty_int_storage = Type{kind: TY_INT, size: 4, align: 4}     /* type.c:8:13 */
var ty_long_storage = Type{kind: TY_LONG, size: 8, align: 8}   /* type.c:9:13 */

var ty_uchar_storage = Type{kind: TY_CHAR, size: 1, align: 1, is_unsigned: uint8(1)}   /* type.c:11:13 */
var ty_ushort_storage = Type{kind: TY_SHORT, size: 2, align: 2, is_unsigned: uint8(1)} /* type.c:12:13 */
var ty_uint_storage = Type{kind: TY_INT, size: 4, align: 4, is_unsigned: uint8(1)}     /* type.c:13:13 */
var ty_ulong_storage = Type{kind: TY_LONG, size: 8, align: 8, is_unsigned: uint8(1)}   /* type.c:14:13 */

var ty_float_storage = Type{kind: TY_FLOAT, size: 4, align: 4}       /* type.c:16:13 */
var ty_double_storage = Type{kind: TY_DOUBLE, size: 8, align: 8}     /* type.c:17:13 */
var ty_ldouble_storage = Type{kind: TY_LDOUBLE, size: 16, align: 16} /* type.c:18:13 */

var ty_void uintptr = 0 /* type.c:20:6 */
var ty_bool uintptr = 0 /* type.c:21:6 */

var ty_char uintptr = 0  /* type.c:23:6 */
var ty_short uintptr = 0 /* type.c:24:6 */
var ty_int uintptr = 0   /* type.c:25:6 */
var ty_long uintptr = 0  /* type.c:26:6 */

var ty_uchar uintptr = 0  /* type.c:28:6 */
var ty_ushort uintptr = 0 /* type.c:29:6 */
var ty_uint uintptr = 0   /* type.c:30:6 */
var ty_ulong uintptr = 0  /* type.c:31:6 */

var ty_float uintptr = 0   /* type.c:33:6 */
var ty_double uintptr = 0  /* type.c:34:6 */
var ty_ldouble uintptr = 0 /* type.c:35:6 */

func new_type(tls *libc.TLS, kind TypeKind, size int32, align int32) uintptr { /* type.c:37:13: */
	var ty uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Type{})))
	(*Type)(unsafe.Pointer(ty)).kind = kind
	(*Type)(unsafe.Pointer(ty)).size = size
	(*Type)(unsafe.Pointer(ty)).align = align
	return ty
}

func is_integer(tls *libc.TLS, ty uintptr) uint8 { /* type.c:45:6: */
	var k TypeKind = (*Type)(unsafe.Pointer(ty)).kind
	return uint8(libc.Bool32(k == TY_BOOL || k == TY_CHAR || k == TY_SHORT || k == TY_INT || k == TY_LONG || k == TY_ENUM))
}

func is_flonum(tls *libc.TLS, ty uintptr) uint8 { /* type.c:51:6: */
	return uint8(libc.Bool32((*Type)(unsafe.Pointer(ty)).kind == TY_FLOAT || (*Type)(unsafe.Pointer(ty)).kind == TY_DOUBLE || (*Type)(unsafe.Pointer(ty)).kind == TY_LDOUBLE))
}

func is_numeric(tls *libc.TLS, ty uintptr) uint8 { /* type.c:56:6: */
	return uint8(libc.Bool32(is_integer(tls, ty) != 0 || is_flonum(tls, ty) != 0))
}

func is_compatible(tls *libc.TLS, t1 uintptr, t2 uintptr) uint8 { /* type.c:60:6: */
	if t1 == t2 {
		return uint8(1)
	}

	if (*Type)(unsafe.Pointer(t1)).origin != 0 {
		return is_compatible(tls, (*Type)(unsafe.Pointer(t1)).origin, t2)
	}

	if (*Type)(unsafe.Pointer(t2)).origin != 0 {
		return is_compatible(tls, t1, (*Type)(unsafe.Pointer(t2)).origin)
	}

	if (*Type)(unsafe.Pointer(t1)).kind != (*Type)(unsafe.Pointer(t2)).kind {
		return uint8(0)
	}

	switch (*Type)(unsafe.Pointer(t1)).kind {
	case TY_CHAR:
		fallthrough
	case TY_SHORT:
		fallthrough
	case TY_INT:
		fallthrough
	case TY_LONG:
		return uint8(libc.Bool32((*Type)(unsafe.Pointer(t1)).is_unsigned == (*Type)(unsafe.Pointer(t2)).is_unsigned))
	case TY_FLOAT:
		fallthrough
	case TY_DOUBLE:
		fallthrough
	case TY_LDOUBLE:
		return uint8(1)
	case TY_PTR:
		return is_compatible(tls, (*Type)(unsafe.Pointer(t1)).base, (*Type)(unsafe.Pointer(t2)).base)
	case TY_FUNC:
		{
			if !(is_compatible(tls, (*Type)(unsafe.Pointer(t1)).return_ty, (*Type)(unsafe.Pointer(t2)).return_ty) != 0) {
				return uint8(0)
			}
			if (*Type)(unsafe.Pointer(t1)).is_variadic != (*Type)(unsafe.Pointer(t2)).is_variadic {
				return uint8(0)
			}

			var p1 uintptr = (*Type)(unsafe.Pointer(t1)).params
			var p2 uintptr = (*Type)(unsafe.Pointer(t2)).params
		__1:
			if !(p1 != 0 && p2 != 0) {
				goto __3
			}
			if !(is_compatible(tls, p1, p2) != 0) {
				return uint8(0)
			}
			goto __2
		__2:
			p1 = (*Type)(unsafe.Pointer(p1)).next
			p2 = (*Type)(unsafe.Pointer(p2)).next
			goto __1
			goto __3
		__3:
			;
			return uint8(libc.Bool32(p1 == uintptr(0) && p2 == uintptr(0)))

		}
	case TY_ARRAY:
		if !(is_compatible(tls, (*Type)(unsafe.Pointer(t1)).base, (*Type)(unsafe.Pointer(t2)).base) != 0) {
			return uint8(0)
		}
		return uint8(libc.Bool32((*Type)(unsafe.Pointer(t1)).array_len < 0 && (*Type)(unsafe.Pointer(t2)).array_len < 0 && (*Type)(unsafe.Pointer(t1)).array_len == (*Type)(unsafe.Pointer(t2)).array_len))
	}
	return uint8(0)
}

func copy_type(tls *libc.TLS, ty uintptr) uintptr { /* type.c:107:6: */
	var ret uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Type{})))
	*(*Type)(unsafe.Pointer(ret)) = *(*Type)(unsafe.Pointer(ty))
	(*Type)(unsafe.Pointer(ret)).origin = ty
	return ret
}

func pointer_to(tls *libc.TLS, base uintptr) uintptr { /* type.c:114:6: */
	var ty uintptr = new_type(tls, TY_PTR, 8, 8)
	(*Type)(unsafe.Pointer(ty)).base = base
	(*Type)(unsafe.Pointer(ty)).is_unsigned = uint8(1)
	return ty
}

func func_type(tls *libc.TLS, return_ty uintptr) uintptr { /* type.c:121:6: */
	// The C spec disallows sizeof(<function type>), but
	// GCC allows that and the expression is evaluated to 1.
	var ty uintptr = new_type(tls, TY_FUNC, 1, 1)
	(*Type)(unsafe.Pointer(ty)).return_ty = return_ty
	return ty
}

func array_of(tls *libc.TLS, base uintptr, len int32) uintptr { /* type.c:129:6: */
	var ty uintptr = new_type(tls, TY_ARRAY, (*Type)(unsafe.Pointer(base)).size*len, (*Type)(unsafe.Pointer(base)).align)
	(*Type)(unsafe.Pointer(ty)).base = base
	(*Type)(unsafe.Pointer(ty)).array_len = len
	return ty
}

func vla_of(tls *libc.TLS, base uintptr, len uintptr) uintptr { /* type.c:136:6: */
	var ty uintptr = new_type(tls, TY_VLA, 8, 8)
	(*Type)(unsafe.Pointer(ty)).base = base
	(*Type)(unsafe.Pointer(ty)).vla_len = len
	return ty
}

func enum_type(tls *libc.TLS) uintptr { /* type.c:143:6: */
	return new_type(tls, TY_ENUM, 4, 4)
}

func struct_type(tls *libc.TLS) uintptr { /* type.c:147:6: */
	return new_type(tls, TY_STRUCT, 0, 1)
}

func get_common_type(tls *libc.TLS, ty1 uintptr, ty2 uintptr) uintptr { /* type.c:151:13: */
	if (*Type)(unsafe.Pointer(ty1)).base != 0 {
		return pointer_to(tls, (*Type)(unsafe.Pointer(ty1)).base)
	}

	if (*Type)(unsafe.Pointer(ty1)).kind == TY_FUNC {
		return pointer_to(tls, ty1)
	}
	if (*Type)(unsafe.Pointer(ty2)).kind == TY_FUNC {
		return pointer_to(tls, ty2)
	}

	if (*Type)(unsafe.Pointer(ty1)).kind == TY_LDOUBLE || (*Type)(unsafe.Pointer(ty2)).kind == TY_LDOUBLE {
		return ty_ldouble
	}
	if (*Type)(unsafe.Pointer(ty1)).kind == TY_DOUBLE || (*Type)(unsafe.Pointer(ty2)).kind == TY_DOUBLE {
		return ty_double
	}
	if (*Type)(unsafe.Pointer(ty1)).kind == TY_FLOAT || (*Type)(unsafe.Pointer(ty2)).kind == TY_FLOAT {
		return ty_float
	}

	if (*Type)(unsafe.Pointer(ty1)).size < 4 {
		ty1 = ty_int
	}
	if (*Type)(unsafe.Pointer(ty2)).size < 4 {
		ty2 = ty_int
	}

	if (*Type)(unsafe.Pointer(ty1)).size != (*Type)(unsafe.Pointer(ty2)).size {
		if (*Type)(unsafe.Pointer(ty1)).size < (*Type)(unsafe.Pointer(ty2)).size {
			return ty2
		}
		return ty1
	}

	if (*Type)(unsafe.Pointer(ty2)).is_unsigned != 0 {
		return ty2
	}
	return ty1
}

// For many binary operators, we implicitly promote operands so that
// both operands have the same type. Any integral type smaller than
// int is always promoted to int. If the type of one operand is larger
// than the other's (e.g. "long" vs. "int"), the smaller operand will
// be promoted to match with the other.
//
// This operation is called the "usual arithmetic conversion".
func usual_arith_conv(tls *libc.TLS, lhs uintptr, rhs uintptr) { /* type.c:187:13: */
	var ty uintptr = get_common_type(tls, (*Node)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lhs)))).ty, (*Node)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(rhs)))).ty)
	*(*uintptr)(unsafe.Pointer(lhs)) = new_cast(tls, *(*uintptr)(unsafe.Pointer(lhs)), ty)
	*(*uintptr)(unsafe.Pointer(rhs)) = new_cast(tls, *(*uintptr)(unsafe.Pointer(rhs)), ty)
}

func add_type(tls *libc.TLS, node uintptr) { /* type.c:193:6: */
	if !(node != 0) || (*Node)(unsafe.Pointer(node)).ty != 0 {
		return
	}

	add_type(tls, (*Node)(unsafe.Pointer(node)).lhs)
	add_type(tls, (*Node)(unsafe.Pointer(node)).rhs)
	add_type(tls, (*Node)(unsafe.Pointer(node)).cond)
	add_type(tls, (*Node)(unsafe.Pointer(node)).then)
	add_type(tls, (*Node)(unsafe.Pointer(node)).els)
	add_type(tls, (*Node)(unsafe.Pointer(node)).init)
	add_type(tls, (*Node)(unsafe.Pointer(node)).inc)

	{
		var n uintptr = (*Node)(unsafe.Pointer(node)).body
		for ; n != 0; n = (*Node)(unsafe.Pointer(n)).next {
			add_type(tls, n)
		}
	}
	{
		var n1 uintptr = (*Node)(unsafe.Pointer(node)).args
		for ; n1 != 0; n1 = (*Node)(unsafe.Pointer(n1)).next {
			add_type(tls, n1)
		}
	}

	switch (*Node)(unsafe.Pointer(node)).kind {
	case ND_NUM:
		(*Node)(unsafe.Pointer(node)).ty = ty_int
		return
	case ND_ADD:
		fallthrough
	case ND_SUB:
		fallthrough
	case ND_MUL:
		fallthrough
	case ND_DIV:
		fallthrough
	case ND_MOD:
		fallthrough
	case ND_BITAND:
		fallthrough
	case ND_BITOR:
		fallthrough
	case ND_BITXOR:
		usual_arith_conv(tls, node+32, node+40)
		(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty
		return
	case ND_NEG:
		{
			var ty uintptr = get_common_type(tls, ty_int, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)
			(*Node)(unsafe.Pointer(node)).lhs = new_cast(tls, (*Node)(unsafe.Pointer(node)).lhs, ty)
			(*Node)(unsafe.Pointer(node)).ty = ty
			return

		}
	case ND_ASSIGN:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).kind == TY_ARRAY {
			error_tok(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).tok, ts+516, 0)
		}
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).kind != TY_STRUCT {
			(*Node)(unsafe.Pointer(node)).rhs = new_cast(tls, (*Node)(unsafe.Pointer(node)).rhs, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)
		}
		(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty
		return
	case ND_EQ:
		fallthrough
	case ND_NE:
		fallthrough
	case ND_LT:
		fallthrough
	case ND_LE:
		usual_arith_conv(tls, node+32, node+40)
		(*Node)(unsafe.Pointer(node)).ty = ty_int
		return
	case ND_FUNCALL:
		(*Node)(unsafe.Pointer(node)).ty = (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).func_ty)).return_ty
		return
	case ND_NOT:
		fallthrough
	case ND_LOGOR:
		fallthrough
	case ND_LOGAND:
		(*Node)(unsafe.Pointer(node)).ty = ty_int
		return
	case ND_BITNOT:
		fallthrough
	case ND_SHL:
		fallthrough
	case ND_SHR:
		(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty
		return
	case ND_VAR:
		fallthrough
	case ND_VLA_PTR:
		(*Node)(unsafe.Pointer(node)).ty = (*Obj)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).__var)).ty
		return
	case ND_COND:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).then)).ty)).kind == TY_VOID || (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).els)).ty)).kind == TY_VOID {
			(*Node)(unsafe.Pointer(node)).ty = ty_void
		} else {
			usual_arith_conv(tls, node+56, node+64)
			(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).then)).ty
		}
		return
	case ND_COMMA:
		(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).rhs)).ty
		return
	case ND_MEMBER:
		(*Node)(unsafe.Pointer(node)).ty = (*Member)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).member)).ty
		return
	case ND_ADDR:
		{
			var ty uintptr = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty
			if (*Type)(unsafe.Pointer(ty)).kind == TY_ARRAY {
				(*Node)(unsafe.Pointer(node)).ty = pointer_to(tls, (*Type)(unsafe.Pointer(ty)).base)
			} else {
				(*Node)(unsafe.Pointer(node)).ty = pointer_to(tls, ty)
			}
			return

		}
	case ND_DEREF:
		if !(int32((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).base) != 0) {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+11977, 0)
		}
		if (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).base)).kind == TY_VOID {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+12005, 0)
		}

		(*Node)(unsafe.Pointer(node)).ty = (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).base
		return
	case ND_STMT_EXPR:
		if (*Node)(unsafe.Pointer(node)).body != 0 {
			var stmt uintptr = (*Node)(unsafe.Pointer(node)).body
			for (*Node)(unsafe.Pointer(stmt)).next != 0 {
				stmt = (*Node)(unsafe.Pointer(stmt)).next
			}
			if (*Node)(unsafe.Pointer(stmt)).kind == ND_EXPR_STMT {
				(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(stmt)).lhs)).ty
				return
			}
		}
		error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+12034, 0)
		return
	case ND_LABEL_VAL:
		(*Node)(unsafe.Pointer(node)).ty = pointer_to(tls, ty_void)
		return
	case ND_CAS:
		add_type(tls, (*Node)(unsafe.Pointer(node)).cas_addr)
		add_type(tls, (*Node)(unsafe.Pointer(node)).cas_old)
		add_type(tls, (*Node)(unsafe.Pointer(node)).cas_new)
		(*Node)(unsafe.Pointer(node)).ty = ty_bool

		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).cas_addr)).ty)).kind != TY_PTR {
			error_tok(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).cas_addr)).tok, ts+12087, 0)
		}
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).cas_old)).ty)).kind != TY_PTR {
			error_tok(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).cas_old)).tok, ts+12087, 0)
		}
		return
	case ND_EXCH:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).kind != TY_PTR {
			error_tok(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).cas_addr)).tok, ts+12087, 0)
		}
		(*Node)(unsafe.Pointer(node)).ty = (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).base
		return
	}
}

// Encode a given character in UTF-8.
