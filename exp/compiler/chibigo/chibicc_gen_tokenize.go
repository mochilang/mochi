// Code generated by ccgo from chibicc sources; DO NOT EDIT.

package main

import (
	"unsafe"
	"modernc.org/libc"
)

var current_file uintptr /* tokenize.c:4:13: */

// A list of all input files.
var input_files uintptr /* tokenize.c:7:13: */

// True if the current position is at the beginning of a line
var at_bol uint8 /* tokenize.c:10:13: */

// True if the current position follows a space character
var has_space uint8 /* tokenize.c:13:13: */

// Reports an error and exit.
func error(tls *libc.TLS, fmt uintptr, va uintptr) { /* tokenize.c:16:6: */
	var ap va_list
	_ = ap
	ap = va
	libc.Xvfprintf(tls, libc.Xstderr, fmt, ap)
	libc.Xfprintf(tls, libc.Xstderr, ts+112, 0)
	libc.Xexit(tls, 1)
}

// Reports an error message in the following format.
//
// foo.c:10: x = y + 1;
//
//	^ <error message here>
func verror_at(tls *libc.TLS, filename uintptr, input uintptr, line_no int32, loc uintptr, fmt uintptr, ap va_list) { /* tokenize.c:28:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// Find a line containing `loc`.
	var line uintptr = loc
	for input < line && int32(*(*int8)(unsafe.Pointer(line + libc.UintptrFromInt32(-1)))) != '\n' {
		line--
	}

	var end uintptr = loc
	for *(*int8)(unsafe.Pointer(end)) != 0 && int32(*(*int8)(unsafe.Pointer(end))) != '\n' {
		end++
	}

	// Print out the line.
	var indent int32 = libc.Xfprintf(tls, libc.Xstderr, ts+11705, libc.VaList(bp, filename, line_no))
	libc.Xfprintf(tls, libc.Xstderr, ts+11713, libc.VaList(bp+16, int32((int64(end)-int64(line))/1), line))

	// Show the error message.
	var pos int32 = display_width(tls, line, int32((int64(loc)-int64(line))/1)) + indent

	libc.Xfprintf(tls, libc.Xstderr, ts+11719, libc.VaList(bp+32, pos, ts+8912)) // print pos spaces.
	libc.Xfprintf(tls, libc.Xstderr, ts+11723, 0)
	libc.Xvfprintf(tls, libc.Xstderr, fmt, ap)
	libc.Xfprintf(tls, libc.Xstderr, ts+112, 0)
}

func error_at(tls *libc.TLS, loc uintptr, fmt uintptr, va uintptr) { /* tokenize.c:52:6: */
	var line_no int32 = 1
	{
		var p uintptr = (*File)(unsafe.Pointer(current_file)).contents
		for ; p < loc; p++ {
			if int32(*(*int8)(unsafe.Pointer(p))) == '\n' {
				line_no++
			}
		}
	}
	var ap va_list
	_ = ap
	ap = va
	verror_at(tls, (*File)(unsafe.Pointer(current_file)).name, (*File)(unsafe.Pointer(current_file)).contents, line_no, loc, fmt, ap)
	libc.Xexit(tls, 1)
}

func error_tok(tls *libc.TLS, tok uintptr, fmt uintptr, va uintptr) { /* tokenize.c:64:6: */
	var ap va_list
	_ = ap
	ap = va
	verror_at(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).file)).name, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).file)).contents, (*Token)(unsafe.Pointer(tok)).line_no, (*Token)(unsafe.Pointer(tok)).loc, fmt, ap)
	libc.Xexit(tls, 1)
}

func warn_tok(tls *libc.TLS, tok uintptr, fmt uintptr, va uintptr) { /* tokenize.c:71:6: */
	var ap va_list
	_ = ap
	ap = va
	verror_at(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).file)).name, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).file)).contents, (*Token)(unsafe.Pointer(tok)).line_no, (*Token)(unsafe.Pointer(tok)).loc, fmt, ap)
	_ = ap
}

// Consumes the current token if it matches `op`.
func equal(tls *libc.TLS, tok uintptr, op uintptr) uint8 { /* tokenize.c:79:6: */
	return uint8(libc.Bool32(libc.Xmemcmp(tls, (*Token)(unsafe.Pointer(tok)).loc, op, uint64((*Token)(unsafe.Pointer(tok)).len)) == 0 && int32(*(*int8)(unsafe.Pointer(op + uintptr((*Token)(unsafe.Pointer(tok)).len)))) == 0))
}

// Ensure that the current token is `op`.
func skip(tls *libc.TLS, tok uintptr, op uintptr) uintptr { /* tokenize.c:84:7: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if !(equal(tls, tok, op) != 0) {
		error_tok(tls, tok, ts+11726, libc.VaList(bp, op))
	}
	return (*Token)(unsafe.Pointer(tok)).next
}

func consume(tls *libc.TLS, rest uintptr, tok uintptr, str uintptr) uint8 { /* tokenize.c:90:6: */
	if equal(tls, tok, str) != 0 {
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(tok)).next
		return uint8(1)
	}
	*(*uintptr)(unsafe.Pointer(rest)) = tok
	return uint8(0)
}

// Create a new token.
func new_token(tls *libc.TLS, kind TokenKind, start uintptr, end uintptr) uintptr { /* tokenize.c:100:14: */
	var tok uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Token{})))
	(*Token)(unsafe.Pointer(tok)).kind = kind
	(*Token)(unsafe.Pointer(tok)).loc = start
	(*Token)(unsafe.Pointer(tok)).len = int32((int64(end) - int64(start)) / 1)
	(*Token)(unsafe.Pointer(tok)).file = current_file
	(*Token)(unsafe.Pointer(tok)).filename = (*File)(unsafe.Pointer(current_file)).display_name
	(*Token)(unsafe.Pointer(tok)).at_bol = at_bol
	(*Token)(unsafe.Pointer(tok)).has_space = has_space

	at_bol = libc.AssignPtrUint8(uintptr(unsafe.Pointer(&has_space)), uint8(0))
	return tok
}

func startswith(tls *libc.TLS, p uintptr, q uintptr) uint8 { /* tokenize.c:114:13: */
	return uint8(libc.Bool32(libc.Xstrncmp(tls, p, q, libc.Xstrlen(tls, q)) == 0))
}

// Read an identifier and returns the length of it.
// If p does not point to a valid identifier, 0 is returned.
func read_ident(tls *libc.TLS, start uintptr) int32 { /* tokenize.c:120:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*uintptr)(unsafe.Pointer(bp /* p */)) = start
	var c uint32_t = decode_utf8(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* p */)))
	if !(is_ident1(tls, c) != 0) {
		return 0
	}

	for {
		// var q uintptr at bp+8, 8

		c = decode_utf8(tls, bp+8, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if !(is_ident2(tls, c) != 0) {
			return int32((int64(*(*uintptr)(unsafe.Pointer(bp))) - int64(start)) / 1)
		}
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = *(*uintptr)(unsafe.Pointer(bp + 8 /* q */))
	}
	return int32(0)
}

func from_hex(tls *libc.TLS, c int8) int32 { /* tokenize.c:135:12: */
	if '0' <= int32(c) && int32(c) <= '9' {
		return int32(c) - '0'
	}
	if 'a' <= int32(c) && int32(c) <= 'f' {
		return int32(c) - 'a' + 10
	}
	return int32(c) - 'A' + 10
}

// Read a punctuator token from p and returns its length.
func read_punct(tls *libc.TLS, p uintptr) int32 { /* tokenize.c:144:12: */

	{
		var i int32 = 0
		for ; uint64(i) < uint64(unsafe.Sizeof(kw1))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
			if startswith(tls, p, kw1[i]) != 0 {
				return int32(libc.Xstrlen(tls, kw1[i]))
			}
		}
	}

	if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p))))*2)))&int32(_ISpunct) != 0 {
		return 1
	}
	return 0
}

var kw1 = [23]uintptr{
	ts + 9505, ts + 9509, ts + 8862, ts + 9527, ts + 9530, ts + 9535, ts + 9540, ts + 9699, ts + 9481,
	ts + 9484, ts + 9487, ts + 9490, ts + 9606, ts + 9609, ts + 9493, ts + 9496, ts + 9499, ts + 9502, ts + 9518,
	ts + 9515, ts + 9543, ts + 9546, ts + 10506,
} /* tokenize.c:145:15 */

func is_keyword(tls *libc.TLS, tok uintptr) uint8 { /* tokenize.c:158:13: */

	if map2.capacity == 0 {

		{
			var i int32 = 0
			for ; uint64(i) < uint64(unsafe.Sizeof(kw2))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
				hashmap_put(tls, uintptr(unsafe.Pointer(&map2)), kw2[i], uintptr(1))
			}
		}
	}

	return uint8(hashmap_get2(tls, uintptr(unsafe.Pointer(&map2)), (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).len))
}

var map2 HashMap /* tokenize.c:159:18: */
var kw2 = [45]uintptr{
	ts + 9280, ts + 9287, ts + 9290, ts + 9369, ts + 9373, ts + 8803, ts + 9831, ts + 8792,
	ts + 8756, ts + 8763, ts + 8797, ts + 8807, ts + 8781, ts + 8428, ts + 8786,
	ts + 8769, ts + 8436, ts + 9386, ts + 9391, ts + 9409, ts + 9295, ts + 9302,
	ts + 9347, ts + 8443, ts + 9838, ts + 8707, ts + 9379, ts + 8825,
	ts + 8832, ts + 8623, ts + 8629, ts + 8638, ts + 8643, ts + 8652,
	ts + 8661, ts + 8672, ts + 8685, ts + 8812, ts + 8818,
	ts + 8774, ts + 9382, ts + 8457, ts + 8471, ts + 8695,
	ts + 9612,
} /* tokenize.c:162:17 */

func read_escaped_char(tls *libc.TLS, new_pos uintptr, p uintptr) int32 { /* tokenize.c:180:12: */
	if '0' <= int32(*(*int8)(unsafe.Pointer(p))) && int32(*(*int8)(unsafe.Pointer(p))) <= '7' {
		// Read an octal number.
		var c int32 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) - '0'
		if '0' <= int32(*(*int8)(unsafe.Pointer(p))) && int32(*(*int8)(unsafe.Pointer(p))) <= '7' {
			c = c<<3 + (int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) - '0')
			if '0' <= int32(*(*int8)(unsafe.Pointer(p))) && int32(*(*int8)(unsafe.Pointer(p))) <= '7' {
				c = c<<3 + (int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) - '0')
			}
		}
		*(*uintptr)(unsafe.Pointer(new_pos)) = p
		return c
	}

	if int32(*(*int8)(unsafe.Pointer(p))) == 'x' {
		// Read a hexadecimal number.
		p++
		if !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p))))*2)))&int32(_ISxdigit) != 0) {
			error_at(tls, p, ts+11740, 0)
		}

		var c int32 = 0
		for ; int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p))))*2)))&int32(_ISxdigit) != 0; p++ {
			c = c<<4 + from_hex(tls, *(*int8)(unsafe.Pointer(p)))
		}
		*(*uintptr)(unsafe.Pointer(new_pos)) = p
		return c
	}

	*(*uintptr)(unsafe.Pointer(new_pos)) = p + uintptr(1)

	// Escape sequences are defined using themselves here. E.g.
	// '\n' is implemented using '\n'. This tautological definition
	// works because the compiler that compiles our compiler knows
	// what '\n' actually is. In other words, we "inherit" the ASCII
	// code of '\n' from the compiler that compiles our compiler,
	// so we don't have to teach the actual code here.
	//
	// This fact has huge implications not only for the correctness
	// of the compiler but also for the security of the generated code.
	// For more info, read "Reflections on Trusting Trust" by Ken Thompson.
	// https://github.com/rui314/chibicc/wiki/thompson1984.pdf
	switch int32(*(*int8)(unsafe.Pointer(p))) {
	case 'a':
		return '\a'
	case 'b':
		return '\b'
	case 't':
		return '\t'
	case 'n':
		return '\n'
	case 'v':
		return '\v'
	case 'f':
		return '\f'
	case 'r':
		return '\r'
	// [GNU] \e for the ASCII escape character is a GNU C extension.
	case 'e':
		return 27
	default:
		return int32(*(*int8)(unsafe.Pointer(p)))
	}
	return int32(0)
}

// Find a closing double-quote.
func string_literal_end(tls *libc.TLS, p uintptr) uintptr { /* tokenize.c:234:13: */
	var start uintptr = p
	for ; int32(*(*int8)(unsafe.Pointer(p))) != '"'; p++ {
		if int32(*(*int8)(unsafe.Pointer(p))) == '\n' || int32(*(*int8)(unsafe.Pointer(p))) == 0 {
			error_at(tls, start, ts+11768, 0)
		}
		if int32(*(*int8)(unsafe.Pointer(p))) == '\\' {
			p++
		}
	}
	return p
}

func read_string_literal(tls *libc.TLS, start uintptr, quote uintptr) uintptr { /* tokenize.c:245:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var end uintptr = string_literal_end(tls, quote+uintptr(1))
	var buf uintptr = libc.Xcalloc(tls, uint64(1), uint64((int64(end)-int64(quote))/1))
	var len int32 = 0

	{
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = quote + uintptr(1)
		for *(*uintptr)(unsafe.Pointer(bp)) < end {
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\\' {
				*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1)))) = int8(read_escaped_char(tls, bp, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)))
			} else {
				*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1)))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp /* p */)), 1)))
			}
		}
	}

	var tok uintptr = new_token(tls, TK_STR, start, end+uintptr(1))
	(*Token)(unsafe.Pointer(tok)).ty = array_of(tls, ty_char, len+1)
	(*Token)(unsafe.Pointer(tok)).str = buf
	return tok
}

// Read a UTF-8-encoded string literal and transcode it in UTF-16.
//
// UTF-16 is yet another variable-width encoding for Unicode. Code
// points smaller than U+10000 are encoded in 2 bytes. Code points
// equal to or larger than that are encoded in 4 bytes. Each 2 bytes
// in the 4 byte sequence is called "surrogate", and a 4 byte sequence
// is called a "surrogate pair".
func read_utf16_string_literal(tls *libc.TLS, start uintptr, quote uintptr) uintptr { /* tokenize.c:270:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var end uintptr = string_literal_end(tls, quote+uintptr(1))
	var buf uintptr = libc.Xcalloc(tls, uint64(2), uint64((int64(end)-int64(start))/1))
	var len int32 = 0

	{
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = quote + uintptr(1)
		for *(*uintptr)(unsafe.Pointer(bp)) < end {
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\\' {
				*(*uint16_t)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1))*2)) = uint16_t(read_escaped_char(tls, bp, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)))
				continue
			}

			var c uint32_t = decode_utf8(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* p */)))
			if c < uint32_t(0x10000) {
				// Encode a code point in 2 bytes.
				*(*uint16_t)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1))*2)) = uint16_t(c)
			} else {
				// Encode a code point in 4 bytes.
				c = c - uint32_t(0x10000)
				*(*uint16_t)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1))*2)) = uint16_t(uint32_t(0xd800) + c>>10&uint32_t(0x3ff))
				*(*uint16_t)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1))*2)) = uint16_t(uint32_t(0xdc00) + c&uint32_t(0x3ff))
			}
		}
	}

	var tok uintptr = new_token(tls, TK_STR, start, end+uintptr(1))
	(*Token)(unsafe.Pointer(tok)).ty = array_of(tls, ty_ushort, len+1)
	(*Token)(unsafe.Pointer(tok)).str = buf
	return tok
}

// Read a UTF-8-encoded string literal and transcode it in UTF-32.
//
// UTF-32 is a fixed-width encoding for Unicode. Each code point is
// encoded in 4 bytes.
func read_utf32_string_literal(tls *libc.TLS, start uintptr, quote uintptr, ty uintptr) uintptr { /* tokenize.c:303:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var end uintptr = string_literal_end(tls, quote+uintptr(1))
	var buf uintptr = libc.Xcalloc(tls, uint64(4), uint64((int64(end)-int64(quote))/1))
	var len int32 = 0

	{
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = quote + uintptr(1)
		for *(*uintptr)(unsafe.Pointer(bp)) < end {
			if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\\' {
				*(*uint32_t)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1))*4)) = uint32_t(read_escaped_char(tls, bp, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)))
			} else {
				*(*uint32_t)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&len, 1))*4)) = decode_utf8(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* p */)))
			}
		}
	}

	var tok uintptr = new_token(tls, TK_STR, start, end+uintptr(1))
	(*Token)(unsafe.Pointer(tok)).ty = array_of(tls, ty, len+1)
	(*Token)(unsafe.Pointer(tok)).str = buf
	return tok
}

func read_char_literal(tls *libc.TLS, start uintptr, quote uintptr, ty uintptr) uintptr { /* tokenize.c:321:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(bp /* p */)) = quote + uintptr(1)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 0 {
		error_at(tls, start, ts+11792, 0)
	}
	var c int32
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\\' {
		c = read_escaped_char(tls, bp, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1))
	} else {
		c = int32(decode_utf8(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* p */))))
	}

	var end uintptr = libc.Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), '\'')
	if !(end != 0) {
		error_at(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), ts+11792, 0)
	}

	var tok uintptr = new_token(tls, TK_NUM, start, end+uintptr(1))
	(*Token)(unsafe.Pointer(tok)).val = int64_t(c)
	(*Token)(unsafe.Pointer(tok)).ty = ty
	return tok
}

func convert_pp_int(tls *libc.TLS, tok uintptr) uint8 { /* tokenize.c:342:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*Token)(unsafe.Pointer(tok)).loc

	// Read a binary, octal, decimal or hexadecimal number.
	var base int32 = 10
	if !(libc.Xstrncasecmp(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11814, uint64(2)) != 0) && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))))*2)))&int32(_ISxdigit) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* p */)) += uintptr(2)
		base = 16
	} else if !(libc.Xstrncasecmp(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11817, uint64(2)) != 0) && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))) == '0' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))) == '1') {
		*(*uintptr)(unsafe.Pointer(bp /* p */)) += uintptr(2)
		base = 2
	} else if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '0' {
		base = 8
	}

	var val int64_t = int64_t(libc.Xstrtoul(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp, base))

	// Read U, L or LL suffixes.
	var l uint8 = uint8(0)
	var u uint8 = uint8(0)

	if startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11820) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11824) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11828) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11832) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11836) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11840) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11844) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11848) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* p */)) += uintptr(3)
		l = libc.AssignUint8(&u, uint8(1))
	} else if !(libc.Xstrncasecmp(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11852, uint64(2)) != 0) || !(libc.Xstrncasecmp(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11855, uint64(2)) != 0) {
		*(*uintptr)(unsafe.Pointer(bp /* p */)) += uintptr(2)
		l = libc.AssignUint8(&u, uint8(1))
	} else if startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11858) != 0 || startswith(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+11861) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* p */)) += uintptr(2)
		l = uint8(1)
	} else if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'L' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'l' {
		*(*uintptr)(unsafe.Pointer(bp /* p */))++
		l = uint8(1)
	} else if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'U' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'u' {
		*(*uintptr)(unsafe.Pointer(bp /* p */))++
		u = uint8(1)
	}

	if *(*uintptr)(unsafe.Pointer(bp)) != (*Token)(unsafe.Pointer(tok)).loc+uintptr((*Token)(unsafe.Pointer(tok)).len) {
		return uint8(0)
	}

	// Infer a type.
	var ty uintptr
	if base == 10 {
		if l != 0 && u != 0 {
			ty = ty_ulong
		} else if l != 0 {
			ty = ty_long
		} else if u != 0 {
			if val>>32 != 0 {
				ty = ty_ulong
			} else {
				ty = ty_uint
			}
		} else {
			if val>>31 != 0 {
				ty = ty_long
			} else {
				ty = ty_int
			}
		}
	} else {
		if l != 0 && u != 0 {
			ty = ty_ulong
		} else if l != 0 {
			if val>>63 != 0 {
				ty = ty_ulong
			} else {
				ty = ty_long
			}
		} else if u != 0 {
			if val>>32 != 0 {
				ty = ty_ulong
			} else {
				ty = ty_uint
			}
		} else if val>>63 != 0 {
			ty = ty_ulong
		} else if val>>32 != 0 {
			ty = ty_long
		} else if val>>31 != 0 {
			ty = ty_uint
		} else {
			ty = ty_int
		}
	}

	(*Token)(unsafe.Pointer(tok)).kind = TK_NUM
	(*Token)(unsafe.Pointer(tok)).val = val
	(*Token)(unsafe.Pointer(tok)).ty = ty
	return uint8(1)
}

// The definition of the numeric literal at the preprocessing stage
// is more relaxed than the definition of that at the later stages.
// In order to handle that, a numeric literal is tokenized as a
// "pp-number" token first and then converted to a regular number
// token after preprocessing.
//
// This function converts a pp-number token to a regular number token.
func convert_pp_number(tls *libc.TLS, tok uintptr) { /* tokenize.c:427:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Try to parse as an integer constant.
	if convert_pp_int(tls, tok) != 0 {
		return
	}

	// If it's not an integer, it must be a floating point constant.
	// var end uintptr at bp, 8

	var val float64 = libc.Xstrtold(tls, (*Token)(unsafe.Pointer(tok)).loc, bp)
	var ty uintptr
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'f' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'F' {
		ty = ty_float
		*(*uintptr)(unsafe.Pointer(bp /* end */))++
	} else if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'l' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'L' {
		ty = ty_ldouble
		*(*uintptr)(unsafe.Pointer(bp /* end */))++
	} else {
		ty = ty_double
	}

	if (*Token)(unsafe.Pointer(tok)).loc+uintptr((*Token)(unsafe.Pointer(tok)).len) != *(*uintptr)(unsafe.Pointer(bp)) {
		error_tok(tls, tok, ts+11864, 0)
	}

	(*Token)(unsafe.Pointer(tok)).kind = TK_NUM
	(*Token)(unsafe.Pointer(tok)).fval = val
	(*Token)(unsafe.Pointer(tok)).ty = ty
}

func convert_pp_tokens(tls *libc.TLS, tok uintptr) { /* tokenize.c:455:6: */
	{
		var t uintptr = tok
		for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
			if is_keyword(tls, t) != 0 {
				(*Token)(unsafe.Pointer(t)).kind = TK_KEYWORD
			} else if (*Token)(unsafe.Pointer(t)).kind == TK_PP_NUM {
				convert_pp_number(tls, t)
			}
		}
	}
}

// Initialize line info for all tokens.
func add_line_numbers(tls *libc.TLS, tok uintptr) { /* tokenize.c:465:13: */
	var p uintptr = (*File)(unsafe.Pointer(current_file)).contents
	var n int32 = 1

	for __ccgo := true; __ccgo; __ccgo = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) != 0 {
		if p == (*Token)(unsafe.Pointer(tok)).loc {
			(*Token)(unsafe.Pointer(tok)).line_no = n
			tok = (*Token)(unsafe.Pointer(tok)).next
		}
		if int32(*(*int8)(unsafe.Pointer(p))) == '\n' {
			n++
		}
	}
}

func tokenize_string_literal(tls *libc.TLS, tok uintptr, basety uintptr) uintptr { /* tokenize.c:479:7: */
	var t uintptr
	if (*Type)(unsafe.Pointer(basety)).size == 2 {
		t = read_utf16_string_literal(tls, (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).loc)
	} else {
		t = read_utf32_string_literal(tls, (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).loc, basety)
	}
	(*Token)(unsafe.Pointer(t)).next = (*Token)(unsafe.Pointer(tok)).next
	return t
}

// Tokenize a given string and returns new tokens.
func tokenize(tls *libc.TLS, file uintptr) uintptr { /* tokenize.c:490:7: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	current_file = file

	var p uintptr = (*File)(unsafe.Pointer(file)).contents
	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */

	at_bol = uint8(1)
	has_space = uint8(0)

	for *(*int8)(unsafe.Pointer(p)) != 0 {
		// Skip line comments.
		if startswith(tls, p, ts+11889) != 0 {
			p += uintptr(2)
			for int32(*(*int8)(unsafe.Pointer(p))) != '\n' {
				p++
			}
			has_space = uint8(1)
			continue
		}

		// Skip block comments.
		if startswith(tls, p, ts+11892) != 0 {
			var q uintptr = libc.Xstrstr(tls, p+uintptr(2), ts+11895)
			if !(q != 0) {
				error_at(tls, p, ts+11898, 0)
			}
			p = q + uintptr(2)
			has_space = uint8(1)
			continue
		}

		// Skip newline.
		if int32(*(*int8)(unsafe.Pointer(p))) == '\n' {
			p++
			at_bol = uint8(1)
			has_space = uint8(0)
			continue
		}

		// Skip whitespace characters.
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p))))*2)))&int32(_ISspace) != 0 {
			p++
			has_space = uint8(1)
			continue
		}

		// Numeric literal
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p))))*2)))&int32(_ISdigit) != 0 || int32(*(*int8)(unsafe.Pointer(p))) == '.' && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p + 1))))*2)))&int32(_ISdigit) != 0 {
			var q uintptr = libc.PostIncUintptr(&p, 1)
			for {
				if *(*int8)(unsafe.Pointer(p)) != 0 && *(*int8)(unsafe.Pointer(p + 1)) != 0 && libc.Xstrchr(tls, ts+11921, int32(*(*int8)(unsafe.Pointer(p)))) != 0 && libc.Xstrchr(tls, ts+11926, int32(*(*int8)(unsafe.Pointer(p + 1)))) != 0 {
					p += uintptr(2)
				} else if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p))))*2)))&int32(_ISalnum) != 0 || int32(*(*int8)(unsafe.Pointer(p))) == '.' {
					p++
				} else {
					break
				}
			}
			cur = libc.AssignPtrUintptr(cur+8, new_token(tls, TK_PP_NUM, q, p))
			continue
		}

		// String literal
		if int32(*(*int8)(unsafe.Pointer(p))) == '"' {
			cur = libc.AssignPtrUintptr(cur+8, read_string_literal(tls, p, p))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// UTF-8 string literal
		if startswith(tls, p, ts+11929) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_string_literal(tls, p, p+uintptr(2)))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// UTF-16 string literal
		if startswith(tls, p, ts+11933) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_utf16_string_literal(tls, p, p+uintptr(1)))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// Wide string literal
		if startswith(tls, p, ts+11936) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_utf32_string_literal(tls, p, p+uintptr(1), ty_int))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// UTF-32 string literal
		if startswith(tls, p, ts+11939) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_utf32_string_literal(tls, p, p+uintptr(1), ty_uint))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// Character literal
		if int32(*(*int8)(unsafe.Pointer(p))) == '\'' {
			cur = libc.AssignPtrUintptr(cur+8, read_char_literal(tls, p, p, ty_int))
			(*Token)(unsafe.Pointer(cur)).val = int64_t(int8((*Token)(unsafe.Pointer(cur)).val))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// UTF-16 character literal
		if startswith(tls, p, ts+11942) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_char_literal(tls, p, p+uintptr(1), ty_ushort))
			*(*int64_t)(unsafe.Pointer(cur + 16)) &= int64(0xffff)
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// Wide character literal
		if startswith(tls, p, ts+11945) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_char_literal(tls, p, p+uintptr(1), ty_int))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// UTF-32 character literal
		if startswith(tls, p, ts+11948) != 0 {
			cur = libc.AssignPtrUintptr(cur+8, read_char_literal(tls, p, p+uintptr(1), ty_uint))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// Identifier or keyword
		var ident_len int32 = read_ident(tls, p)
		if ident_len != 0 {
			cur = libc.AssignPtrUintptr(cur+8, new_token(tls, TK_IDENT, p, p+uintptr(ident_len)))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		// Punctuators
		var punct_len int32 = read_punct(tls, p)
		if punct_len != 0 {
			cur = libc.AssignPtrUintptr(cur+8, new_token(tls, TK_PUNCT, p, p+uintptr(punct_len)))
			p += uintptr((*Token)(unsafe.Pointer(cur)).len)
			continue
		}

		error_at(tls, p, ts+11951, 0)
	}

	cur = libc.AssignPtrUintptr(cur+8, new_token(tls, TK_EOF, p, p))
	add_line_numbers(tls, (*Token)(unsafe.Pointer(bp /* &head */)).next)
	return (*Token)(unsafe.Pointer(bp /* &head */)).next
}

// Returns the contents of a given file.
func read_file(tls *libc.TLS, path uintptr) uintptr { /* tokenize.c:640:13: */
	bp := tls.Alloc(4096)
	defer tls.Free(4096)

	var fp uintptr

	if libc.Xstrcmp(tls, path, ts+7457) == 0 {
		// By convention, read from stdin if a given filename is "-".
		fp = libc.Xstdin
	} else {
		fp = libc.Xfopen(tls, path, ts+11965)
		if !(fp != 0) {
			return uintptr(0)
		}
	}

	var buf uintptr = uintptr(0)
	var len size_t = uint64(0)
	var cap size_t = uint64(0)

	// Read the entire file.
	for {
		// var buf2 [4096]int8 at bp, 4096

		var n int32 = int32(libc.Xfread(tls, bp, uint64(1), uint64(unsafe.Sizeof([4096]int8{})), fp))
		if n == 0 {
			break
		}
		if len+size_t(n)+uint64(2) > cap {
			cap = func() uint64 {
				if cap*uint64(2) < len+size_t(n)+uint64(2) {
					return len + size_t(n) + uint64(2)
				}
				return cap * uint64(2)
			}()
			buf = libc.Xrealloc(tls, buf, cap)
		}
		libc.Xmemcpy(tls, buf+uintptr(len), bp, uint64(n))
		len = len + size_t(n)
	}

	if fp != libc.Xstdin {
		libc.Xfclose(tls, fp)
	}

	// Make sure that the last line is properly terminated with '\n'.
	if len == uint64(0) || int32(*(*int8)(unsafe.Pointer(buf + uintptr(len-uint64(1))))) != '\n' {
		if len+uint64(2) > cap {
			cap = func() uint64 {
				if cap*uint64(2) < len+uint64(2) {
					return len + uint64(2)
				}
				return cap * uint64(2)
			}()
			buf = libc.Xrealloc(tls, buf, cap)
		}
		*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncUint64(&len, 1)))) = int8('\n')
	}
	*(*int8)(unsafe.Pointer(buf + uintptr(len))) = int8(0)
	return buf
}

func get_input_files(tls *libc.TLS) uintptr { /* tokenize.c:685:6: */
	return input_files
}

func new_file(tls *libc.TLS, name uintptr, file_no int32, contents uintptr) uintptr { /* tokenize.c:689:6: */
	var file uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(File{})))
	(*File)(unsafe.Pointer(file)).name = name
	(*File)(unsafe.Pointer(file)).display_name = name
	(*File)(unsafe.Pointer(file)).file_no = file_no
	(*File)(unsafe.Pointer(file)).contents = contents
	return file
}

// Replaces \r or \r\n with \n.
func canonicalize_newline(tls *libc.TLS, p uintptr) { /* tokenize.c:699:13: */
	var i int32 = 0
	var j int32 = 0

	for *(*int8)(unsafe.Pointer(p + uintptr(i))) != 0 {
		if int32(*(*int8)(unsafe.Pointer(p + uintptr(i)))) == '\r' && int32(*(*int8)(unsafe.Pointer(p + uintptr(i+1)))) == '\n' {
			i = i + 2
			*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = int8('\n')
		} else if int32(*(*int8)(unsafe.Pointer(p + uintptr(i)))) == '\r' {
			i++
			*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = int8('\n')
		} else {
			*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&i, 1))))
		}
	}

	*(*int8)(unsafe.Pointer(p + uintptr(j))) = int8(0)
}

// Removes backslashes followed by a newline.
func remove_backslash_newline(tls *libc.TLS, p uintptr) { /* tokenize.c:718:13: */
	var i int32 = 0
	var j int32 = 0

	// We want to keep the number of newline characters so that
	// the logical line number matches the physical one.
	// This counter maintain the number of newlines we have removed.
	var n int32 = 0

	for *(*int8)(unsafe.Pointer(p + uintptr(i))) != 0 {
		if int32(*(*int8)(unsafe.Pointer(p + uintptr(i)))) == '\\' && int32(*(*int8)(unsafe.Pointer(p + uintptr(i+1)))) == '\n' {
			i = i + 2
			n++
		} else if int32(*(*int8)(unsafe.Pointer(p + uintptr(i)))) == '\n' {
			*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&i, 1))))
			for ; n > 0; n-- {
				*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = int8('\n')
			}
		} else {
			*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&i, 1))))
		}
	}

	for ; n > 0; n-- {
		*(*int8)(unsafe.Pointer(p + uintptr(libc.PostIncInt32(&j, 1)))) = int8('\n')
	}
	*(*int8)(unsafe.Pointer(p + uintptr(j))) = int8(0)
}

func read_universal_char(tls *libc.TLS, p uintptr, len int32) uint32_t { /* tokenize.c:744:17: */
	var c uint32_t = uint32_t(0)
	{
		var i int32 = 0
		for ; i < len; i++ {
			if !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*int8)(unsafe.Pointer(p + uintptr(i)))))*2)))&int32(_ISxdigit) != 0) {
				return uint32_t(0)
			}
			c = c<<4 | uint32_t(from_hex(tls, *(*int8)(unsafe.Pointer(p + uintptr(i)))))
		}
	}
	return c
}

// Replace \u or \U escape sequences with corresponding UTF-8 bytes.
func convert_universal_chars(tls *libc.TLS, p uintptr) { /* tokenize.c:755:13: */
	var q uintptr = p

	for *(*int8)(unsafe.Pointer(p)) != 0 {
		if startswith(tls, p, ts+11967) != 0 {
			var c uint32_t = read_universal_char(tls, p+uintptr(2), 4)
			if c != 0 {
				p += uintptr(6)
				q += uintptr(encode_utf8(tls, q, c))
			} else {
				*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))
			}
		} else if startswith(tls, p, ts+11970) != 0 {
			var c uint32_t = read_universal_char(tls, p+uintptr(2), 8)
			if c != 0 {
				p += uintptr(10)
				q += uintptr(encode_utf8(tls, q, c))
			} else {
				*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))
			}
		} else if int32(*(*int8)(unsafe.Pointer(p))) == '\\' {
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))
		} else {
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))
		}
	}

	*(*int8)(unsafe.Pointer(q)) = int8(0)
}

func tokenize_file(tls *libc.TLS, path uintptr) uintptr { /* tokenize.c:786:7: */
	var p uintptr = read_file(tls, path)
	if !(p != 0) {
		return uintptr(0)
	}

	// UTF-8 texts may start with a 3-byte "BOM" marker sequence.
	// If exists, just skip them because they are useless bytes.
	// (It is actually not recommended to add BOM markers to UTF-8
	// texts, but it's not uncommon particularly on Windows.)
	if !(libc.Xmemcmp(tls, p, ts+11973, uint64(3)) != 0) {
		p += uintptr(3)
	}

	canonicalize_newline(tls, p)
	remove_backslash_newline(tls, p)
	convert_universal_chars(tls, p)
	var file uintptr = new_file(tls, path, file_no+1, p)

	// Save the filename for assembler .file directive.
	input_files = libc.Xrealloc(tls, input_files, uint64(unsafe.Sizeof(uintptr(0)))*uint64(file_no+2))
	*(*uintptr)(unsafe.Pointer(input_files + uintptr(file_no)*8)) = file
	*(*uintptr)(unsafe.Pointer(input_files + uintptr(file_no+1)*8)) = uintptr(0)
	file_no++

	return tokenize(tls, file)
}

var file_no int32 /* tokenize.c:803:14: */

