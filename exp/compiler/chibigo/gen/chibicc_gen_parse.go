// Code generated by ccgo from chibicc sources; DO NOT EDIT.

package chibigo

import (
	"modernc.org/libc"
	"unsafe"
)

type VarScope = struct {
	__var    uintptr
	type_def uintptr
	enum_ty  uintptr
	enum_val int32
	_        [4]byte
} /* parse.c:28:3 */

// Represents a block scope.
type Scope1 = struct {
	next uintptr
	vars HashMap
	tags HashMap
} /* parse.c:31:9 */

// Represents a block scope.
type Scope = Scope1 /* parse.c:31:22 */

// Variable attributes such as typedef or extern.
type VarAttr = struct {
	is_typedef uint8
	is_static  uint8
	is_extern  uint8
	is_inline  uint8
	is_tls     uint8
	_          [3]byte
	align      int32
} /* parse.c:49:3 */

// This struct represents a variable initializer. Since initializers
// can be nested (e.g. `int x[2][2] = {{1, 2}, {3, 4}}`), this struct
// is a tree data structure.
type Initializer1 = struct {
	next        uintptr
	ty          uintptr
	tok         uintptr
	is_flexible uint8
	_           [7]byte
	expr        uintptr
	children    uintptr
	mem         uintptr
} /* parse.c:54:9 */

// This struct represents a variable initializer. Since initializers
// can be nested (e.g. `int x[2][2] = {{1, 2}, {3, 4}}`), this struct
// is a tree data structure.
type Initializer = Initializer1 /* parse.c:54:28 */

// For local variable initializer.
type InitDesg1 = struct {
	next   uintptr
	idx    int32
	_      [4]byte
	member uintptr
	__var  uintptr
} /* parse.c:75:9 */

// For local variable initializer.
type InitDesg = InitDesg1 /* parse.c:75:25 */

// All local variable instances created during parsing are
// accumulated to this list.
var locals uintptr /* parse.c:85:12: */

// Likewise, global variables are accumulated to this list.
var globals uintptr /* parse.c:88:12: */

var scope_storage Scope /* parse.c:90:14: */
var scope uintptr = 0   /* parse.c:91:14 */

// Points to the function object the parser is currently parsing.
var current_fn1 uintptr /* parse.c:94:12: */

// Lists of all goto statements and labels in the curent function.
var gotos uintptr  /* parse.c:97:13: */
var labels uintptr /* parse.c:98:13: */

// Current "goto" and "continue" jump targets.
var brk_label uintptr  /* parse.c:101:13: */
var cont_label uintptr /* parse.c:102:13: */

// Points to a node representing a switch if we are parsing
// a switch statement. Otherwise, NULL.
var current_switch uintptr /* parse.c:106:13: */

var builtin_alloca1 uintptr /* parse.c:108:12: */

func align_down(tls *libc.TLS, n int32, align int32) int32 { /* parse.c:160:12: */
	return align_to(tls, n-align+1, align)
}

func enter_scope(tls *libc.TLS) { /* parse.c:164:13: */
	var sc uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Scope{})))
	(*Scope)(unsafe.Pointer(sc)).next = scope
	scope = sc
}

func leave_scope(tls *libc.TLS) { /* parse.c:170:13: */
	scope = (*Scope)(unsafe.Pointer(scope)).next
}

// Find a variable by name.
func find_var(tls *libc.TLS, tok uintptr) uintptr { /* parse.c:175:17: */
	{
		var sc uintptr = scope
		for ; sc != 0; sc = (*Scope)(unsafe.Pointer(sc)).next {
			var sc2 uintptr = hashmap_get2(tls, sc+8, (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).len)
			if sc2 != 0 {
				return sc2
			}
		}
	}
	return uintptr(0)
}

func find_tag(tls *libc.TLS, tok uintptr) uintptr { /* parse.c:184:13: */
	{
		var sc uintptr = scope
		for ; sc != 0; sc = (*Scope)(unsafe.Pointer(sc)).next {
			var ty uintptr = hashmap_get2(tls, sc+24, (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).len)
			if ty != 0 {
				return ty
			}
		}
	}
	return uintptr(0)
}

func new_node(tls *libc.TLS, kind NodeKind, tok uintptr) uintptr { /* parse.c:193:13: */
	var node uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Node{})))
	(*Node)(unsafe.Pointer(node)).kind = kind
	(*Node)(unsafe.Pointer(node)).tok = tok
	return node
}

func new_binary(tls *libc.TLS, kind NodeKind, lhs uintptr, rhs uintptr, tok uintptr) uintptr { /* parse.c:200:13: */
	var node uintptr = new_node(tls, kind, tok)
	(*Node)(unsafe.Pointer(node)).lhs = lhs
	(*Node)(unsafe.Pointer(node)).rhs = rhs
	return node
}

func new_unary(tls *libc.TLS, kind NodeKind, expr uintptr, tok uintptr) uintptr { /* parse.c:207:13: */
	var node uintptr = new_node(tls, kind, tok)
	(*Node)(unsafe.Pointer(node)).lhs = expr
	return node
}

func new_num(tls *libc.TLS, val int64_t, tok uintptr) uintptr { /* parse.c:213:13: */
	var node uintptr = new_node(tls, ND_NUM, tok)
	(*Node)(unsafe.Pointer(node)).val = val
	return node
}

func new_long(tls *libc.TLS, val int64_t, tok uintptr) uintptr { /* parse.c:219:13: */
	var node uintptr = new_node(tls, ND_NUM, tok)
	(*Node)(unsafe.Pointer(node)).val = val
	(*Node)(unsafe.Pointer(node)).ty = ty_long
	return node
}

func new_ulong(tls *libc.TLS, val int64, tok uintptr) uintptr { /* parse.c:226:13: */
	var node uintptr = new_node(tls, ND_NUM, tok)
	(*Node)(unsafe.Pointer(node)).val = val
	(*Node)(unsafe.Pointer(node)).ty = ty_ulong
	return node
}

func new_var_node(tls *libc.TLS, var1 uintptr, tok uintptr) uintptr { /* parse.c:233:13: */
	var node uintptr = new_node(tls, ND_VAR, tok)
	(*Node)(unsafe.Pointer(node)).__var = var1
	return node
}

func new_vla_ptr(tls *libc.TLS, var1 uintptr, tok uintptr) uintptr { /* parse.c:239:13: */
	var node uintptr = new_node(tls, ND_VLA_PTR, tok)
	(*Node)(unsafe.Pointer(node)).__var = var1
	return node
}

func new_cast(tls *libc.TLS, expr uintptr, ty uintptr) uintptr { /* parse.c:245:6: */
	add_type(tls, expr)

	var node uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Node{})))
	(*Node)(unsafe.Pointer(node)).kind = ND_CAST
	(*Node)(unsafe.Pointer(node)).tok = (*Node)(unsafe.Pointer(expr)).tok
	(*Node)(unsafe.Pointer(node)).lhs = expr
	(*Node)(unsafe.Pointer(node)).ty = copy_type(tls, ty)
	return node
}

func push_scope(tls *libc.TLS, name uintptr) uintptr { /* parse.c:256:17: */
	var sc uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(VarScope{})))
	hashmap_put(tls, scope+8, name, sc)
	return sc
}

func new_initializer(tls *libc.TLS, ty uintptr, is_flexible uint8) uintptr { /* parse.c:262:20: */
	var init1 uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Initializer{})))
	(*Initializer)(unsafe.Pointer(init1)).ty = ty

	if (*Type)(unsafe.Pointer(ty)).kind == TY_ARRAY {
		if is_flexible != 0 && (*Type)(unsafe.Pointer(ty)).size < 0 {
			(*Initializer)(unsafe.Pointer(init1)).is_flexible = uint8(1)
			return init1
		}

		(*Initializer)(unsafe.Pointer(init1)).children = libc.Xcalloc(tls, uint64((*Type)(unsafe.Pointer(ty)).array_len), uint64(unsafe.Sizeof(uintptr(0))))
		{
			var i int32 = 0
			for ; i < (*Type)(unsafe.Pointer(ty)).array_len; i++ {
				*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)) = new_initializer(tls, (*Type)(unsafe.Pointer(ty)).base, uint8(0))
			}
		}
		return init1
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_STRUCT || (*Type)(unsafe.Pointer(ty)).kind == TY_UNION {
		// Count the number of struct members.
		var len int32 = 0
		{
			var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
			for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
				len++
			}
		}

		(*Initializer)(unsafe.Pointer(init1)).children = libc.Xcalloc(tls, uint64(len), uint64(unsafe.Sizeof(uintptr(0))))

		{
			var mem1 uintptr = (*Type)(unsafe.Pointer(ty)).members
			for ; mem1 != 0; mem1 = (*Member)(unsafe.Pointer(mem1)).next {
				if is_flexible != 0 && (*Type)(unsafe.Pointer(ty)).is_flexible != 0 && !(int32((*Member)(unsafe.Pointer(mem1)).next) != 0) {
					var child uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Initializer{})))
					(*Initializer)(unsafe.Pointer(child)).ty = (*Member)(unsafe.Pointer(mem1)).ty
					(*Initializer)(unsafe.Pointer(child)).is_flexible = uint8(1)
					*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem1)).idx)*8)) = child
				} else {
					*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem1)).idx)*8)) = new_initializer(tls, (*Member)(unsafe.Pointer(mem1)).ty, uint8(0))
				}
			}
		}
		return init1
	}

	return init1
}

func new_var(tls *libc.TLS, name uintptr, ty uintptr) uintptr { /* parse.c:302:12: */
	var var1 uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Obj{})))
	(*Obj)(unsafe.Pointer(var1)).name = name
	(*Obj)(unsafe.Pointer(var1)).ty = ty
	(*Obj)(unsafe.Pointer(var1)).align = (*Type)(unsafe.Pointer(ty)).align
	(*VarScope)(unsafe.Pointer(push_scope(tls, name))).__var = var1
	return var1
}

func new_lvar(tls *libc.TLS, name uintptr, ty uintptr) uintptr { /* parse.c:311:12: */
	var var1 uintptr = new_var(tls, name, ty)
	(*Obj)(unsafe.Pointer(var1)).is_local = uint8(1)
	(*Obj)(unsafe.Pointer(var1)).next = locals
	locals = var1
	return var1
}

func new_gvar(tls *libc.TLS, name uintptr, ty uintptr) uintptr { /* parse.c:319:12: */
	var var1 uintptr = new_var(tls, name, ty)
	(*Obj)(unsafe.Pointer(var1)).next = globals
	(*Obj)(unsafe.Pointer(var1)).is_static = uint8(1)
	(*Obj)(unsafe.Pointer(var1)).is_definition = uint8(1)
	globals = var1
	return var1
}

func new_unique_name(tls *libc.TLS) uintptr { /* parse.c:328:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	return format(tls, ts+8398, libc.VaList(bp, libc.PostIncInt32(&id, 1)))
}

var id int32 = 0 /* parse.c:329:14 */

func new_anon_gvar(tls *libc.TLS, ty uintptr) uintptr { /* parse.c:333:12: */
	return new_gvar(tls, new_unique_name(tls), ty)
}

func new_string_literal(tls *libc.TLS, p uintptr, ty uintptr) uintptr { /* parse.c:337:12: */
	var var1 uintptr = new_anon_gvar(tls, ty)
	(*Obj)(unsafe.Pointer(var1)).init_data = p
	return var1
}

func get_ident(tls *libc.TLS, tok uintptr) uintptr { /* parse.c:343:13: */
	if (*Token)(unsafe.Pointer(tok)).kind != TK_IDENT {
		error_tok(tls, tok, ts+8405, 0)
	}
	return xstrndup(tls, (*Token)(unsafe.Pointer(tok)).loc, uint64((*Token)(unsafe.Pointer(tok)).len))
}

func find_typedef(tls *libc.TLS, tok uintptr) uintptr { /* parse.c:349:13: */
	if (*Token)(unsafe.Pointer(tok)).kind == TK_IDENT {
		var sc uintptr = find_var(tls, tok)
		if sc != 0 {
			return (*VarScope)(unsafe.Pointer(sc)).type_def
		}
	}
	return uintptr(0)
}

func push_tag_scope(tls *libc.TLS, tok uintptr, ty uintptr) { /* parse.c:358:13: */
	hashmap_put2(tls, scope+24, (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).len, ty)
}

// declspec = ("void" | "_Bool" | "char" | "short" | "int" | "long"
//
//	| "typedef" | "static" | "extern" | "inline"
//	| "_Thread_local" | "__thread"
//	| "signed" | "unsigned"
//	| struct-decl | union-decl | typedef-name
//	| enum-specifier | typeof-specifier
//	| "const" | "volatile" | "auto" | "register" | "restrict"
//	| "__restrict" | "__restrict__" | "_Noreturn")+
//
// The order of typenames in a type-specifier doesn't matter. For
// example, `int long static` means the same as `static long int`.
// That can also be written as `static long` because you can omit
// `int` if `long` or `short` are specified. However, something like
// `char int` is not a valid type specifier. We have to accept only a
// limited combinations of the typenames.
//
// In this function, we count the number of occurrences of each typename
// while keeping the "current" type object that the typenames up
// until that point represent. When we reach a non-typename token,
// we returns the current type object.
func declspec(tls *libc.TLS, rest uintptr, tok uintptr, attr uintptr) uintptr { /* parse.c:382:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = tok

	var ty uintptr = ty_int
	var counter int32 = 0
	var is_atomic uint8 = uint8(0)

	for is_typename(tls, *(*uintptr)(unsafe.Pointer(bp + 16))) != 0 {
		// Handle storage class specifiers.
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8428) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8436) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8443) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8450) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8457) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8471) != 0 {
			if !(attr != 0) {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+8480, 0)
			}

			if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8428) != 0 {
				(*VarAttr)(unsafe.Pointer(attr)).is_typedef = uint8(1)
			} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8436) != 0 {
				(*VarAttr)(unsafe.Pointer(attr)).is_static = uint8(1)
			} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8443) != 0 {
				(*VarAttr)(unsafe.Pointer(attr)).is_extern = uint8(1)
			} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8450) != 0 {
				(*VarAttr)(unsafe.Pointer(attr)).is_inline = uint8(1)
			} else {
				(*VarAttr)(unsafe.Pointer(attr)).is_tls = uint8(1)
			}

			if (*VarAttr)(unsafe.Pointer(attr)).is_typedef != 0 && int32((*VarAttr)(unsafe.Pointer(attr)).is_static+(*VarAttr)(unsafe.Pointer(attr)).is_extern+(*VarAttr)(unsafe.Pointer(attr)).is_inline+(*VarAttr)(unsafe.Pointer(attr)).is_tls) > 1 {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)),
					ts+8535, 0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next
			continue
		}

		// These keywords are recognized but ignored.
		if consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8623) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8629) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8638) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8643) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8652) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8661) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8672) != 0 || consume(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8685) != 0 {
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8695) != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next
			if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8703) != 0 {
				ty = typename(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next)
				*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+8705)
			}
			is_atomic = uint8(1)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8707) != 0 {
			if !(attr != 0) {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+8716, 0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next, ts+8703)

			if is_typename(tls, *(*uintptr)(unsafe.Pointer(bp + 16))) != 0 {
				(*VarAttr)(unsafe.Pointer(attr)).align = (*Type)(unsafe.Pointer(typename(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */))))).align
			} else {
				(*VarAttr)(unsafe.Pointer(attr)).align = int32(const_expr(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */))))
			}
			*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+8705)
			continue
		}

		// Handle user-defined types.
		var ty2 uintptr = find_typedef(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8756) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8763) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8769) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8774) != 0 || ty2 != 0 {
			if counter != 0 {
				break
			}

			if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8756) != 0 {
				ty = struct_decl(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next)
			} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8763) != 0 {
				ty = union_decl(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next)
			} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8769) != 0 {
				ty = enum_specifier(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next)
			} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8774) != 0 {
				ty = typeof_specifier(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next)
			} else {
				ty = ty2
				*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next
			}

			counter = counter + 65536
			continue
		}

		// Handle built-in types.
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8781) != 0 {
			counter = counter + 1
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8786) != 0 {
			counter = counter + 4
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8792) != 0 {
			counter = counter + 16
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8797) != 0 {
			counter = counter + 64
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8803) != 0 {
			counter = counter + 256
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8807) != 0 {
			counter = counter + 1024
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8812) != 0 {
			counter = counter + 4096
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8818) != 0 {
			counter = counter + 16384
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8825) != 0 {
			counter = counter | 131072
		} else if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8832) != 0 {
			counter = counter | 262144
		} else {
			error(tls, ts+217, libc.VaList(bp, ts+8841, 507))
		}

		switch counter {
		case 1 /* VOID */ :
			ty = ty_void
			break
		case 4 /* BOOL */ :
			ty = ty_bool
			break
		case 16 /* CHAR */ :
			fallthrough
		case 131072 + 16:
			ty = ty_char
			break
		case 262144 + 16:
			ty = ty_uchar
			break
		case 64 /* SHORT */ :
			fallthrough
		case 64 + 256:
			fallthrough
		case 131072 + 64:
			fallthrough
		case 131072 + 64 + 256:
			ty = ty_short
			break
		case 262144 + 64:
			fallthrough
		case 262144 + 64 + 256:
			ty = ty_ushort
			break
		case 256 /* INT */ :
			fallthrough
		case 131072 /* SIGNED */ :
			fallthrough
		case 131072 + 256:
			ty = ty_int
			break
		case 262144 /* UNSIGNED */ :
			fallthrough
		case 262144 + 256:
			ty = ty_uint
			break
		case 1024 /* LONG */ :
			fallthrough
		case 1024 + 256:
			fallthrough
		case 1024 + 1024:
			fallthrough
		case 1024 + 1024 + 256:
			fallthrough
		case 131072 + 1024:
			fallthrough
		case 131072 + 1024 + 256:
			fallthrough
		case 131072 + 1024 + 1024:
			fallthrough
		case 131072 + 1024 + 1024 + 256:
			ty = ty_long
			break
		case 262144 + 1024:
			fallthrough
		case 262144 + 1024 + 256:
			fallthrough
		case 262144 + 1024 + 1024:
			fallthrough
		case 262144 + 1024 + 1024 + 256:
			ty = ty_ulong
			break
		case 4096 /* FLOAT */ :
			ty = ty_float
			break
		case 16384 /* DOUBLE */ :
			ty = ty_double
			break
		case 1024 + 16384:
			ty = ty_ldouble
			break
		default:
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+8849, 0)
		}

		*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next
	}

	if is_atomic != 0 {
		ty = copy_type(tls, ty)
		(*Type)(unsafe.Pointer(ty)).is_atomic = uint8(1)
	}

	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */))
	return ty
}

// func-params = ("void" | param ("," param)* ("," "...")?)? ")"
// param       = declspec declarator
func func_params(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:585:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)
	*(*uintptr)(unsafe.Pointer(bp + 120)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 120)), ts+8781) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 120)))).next, ts+8705) != 0 {
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)))).next)).next
		return func_type(tls, ty)
	}

	*(*Type)(unsafe.Pointer(bp /* head */)) = Type{}
	var cur uintptr = bp /* &head */
	var is_variadic uint8 = uint8(0)

	for !(equal(tls, *(*uintptr)(unsafe.Pointer(bp + 120)), ts+8705) != 0) {
		if cur != bp {
			*(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)), ts+8368)
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 120)), ts+8862) != 0 {
			is_variadic = uint8(1)
			*(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)))).next
			skip(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)), ts+8705)
			break
		}

		var ty2 uintptr = declspec(tls, bp+120, *(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)), uintptr(0))
		ty2 = declarator(tls, bp+120, *(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)), ty2)

		var name uintptr = (*Type)(unsafe.Pointer(ty2)).name

		if (*Type)(unsafe.Pointer(ty2)).kind == TY_ARRAY {
			// "array of T" is converted to "pointer to T" only in the parameter
			// context. For example, *argv[] is converted to **argv by this.
			ty2 = pointer_to(tls, (*Type)(unsafe.Pointer(ty2)).base)
			(*Type)(unsafe.Pointer(ty2)).name = name
		} else if (*Type)(unsafe.Pointer(ty2)).kind == TY_FUNC {
			// Likewise, a function is converted to a pointer to a function
			// only in the parameter context.
			ty2 = pointer_to(tls, ty2)
			(*Type)(unsafe.Pointer(ty2)).name = name
		}

		cur = libc.AssignPtrUintptr(cur+112, copy_type(tls, ty2))
	}

	if cur == bp {
		is_variadic = uint8(1)
	}

	ty = func_type(tls, ty)
	(*Type)(unsafe.Pointer(ty)).params = (*Type)(unsafe.Pointer(bp /* &head */)).next
	(*Type)(unsafe.Pointer(ty)).is_variadic = is_variadic
	*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 120 /* tok */)))).next
	return ty
}

// array-dimensions = ("static" | "restrict")* const-expr? "]" type-suffix
func array_dimensions(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:637:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8436) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8652) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8866) != 0 {
		ty = type_suffix(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ty)
		return array_of(tls, ty, -1)
	}

	var expr uintptr = conditional(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8866)
	ty = type_suffix(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)

	if (*Type)(unsafe.Pointer(ty)).kind == TY_VLA || !(is_const_expr(tls, expr) != 0) {
		return vla_of(tls, ty, expr)
	}
	return array_of(tls, ty, int32(eval(tls, expr)))
}

// type-suffix = "(" func-params
//
//	| "[" array-dimensions
//	| Îµ
func type_suffix(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:658:13: */
	if equal(tls, tok, ts+8703) != 0 {
		return func_params(tls, rest, (*Token)(unsafe.Pointer(tok)).next, ty)
	}

	if equal(tls, tok, ts+8868) != 0 {
		return array_dimensions(tls, rest, (*Token)(unsafe.Pointer(tok)).next, ty)
	}

	*(*uintptr)(unsafe.Pointer(rest)) = tok
	return ty
}

// pointers = ("*" ("const" | "volatile" | "restrict")*)*
func pointers(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:670:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	for consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+8870) != 0 {
		ty = pointer_to(tls, ty)
		for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8623) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8629) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8652) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8661) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8672) != 0 {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
		}
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return ty
}

// declarator = pointers ("(" ident ")" | "(" declarator ")" | ident) type-suffix
func declarator(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:682:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	ty = pointers(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		*(*Type)(unsafe.Pointer(bp + 8 /* dummy */)) = Type{}
		declarator(tls, bp, (*Token)(unsafe.Pointer(start)).next, bp+8)
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		ty = type_suffix(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)
		return declarator(tls, bp, (*Token)(unsafe.Pointer(start)).next, ty)
	}

	var name uintptr = uintptr(0)
	var name_pos uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_IDENT {
		name = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
	}

	ty = type_suffix(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)
	(*Type)(unsafe.Pointer(ty)).name = name
	(*Type)(unsafe.Pointer(ty)).name_pos = name_pos
	return ty
}

// abstract-declarator = pointers ("(" abstract-declarator ")")? type-suffix
func abstract_declarator(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:709:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	ty = pointers(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		*(*Type)(unsafe.Pointer(bp + 8 /* dummy */)) = Type{}
		abstract_declarator(tls, bp, (*Token)(unsafe.Pointer(start)).next, bp+8)
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		ty = type_suffix(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)
		return abstract_declarator(tls, bp, (*Token)(unsafe.Pointer(start)).next, ty)
	}

	return type_suffix(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)
}

// type-name = declspec abstract-declarator
func typename(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:725:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var ty uintptr = declspec(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), uintptr(0))
	return abstract_declarator(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)
}

func is_end(tls *libc.TLS, tok uintptr) uint8 { /* parse.c:730:13: */
	return uint8(libc.Bool32(equal(tls, tok, ts+8872) != 0 || equal(tls, tok, ts+8368) != 0 && equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+8872) != 0))
}

func consume_end(tls *libc.TLS, rest uintptr, tok uintptr) uint8 { /* parse.c:734:13: */
	if equal(tls, tok, ts+8872) != 0 {
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(tok)).next
		return uint8(1)
	}

	if equal(tls, tok, ts+8368) != 0 && equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+8872) != 0 {
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next
		return uint8(1)
	}

	return uint8(0)
}

// enum-specifier = ident? "{" enum-list? "}"
//
//	| ident ("{" enum-list? "}")?
//
// enum-list      = ident ("=" num)? ("," ident ("=" num)?)* ","?
func enum_specifier(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:752:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var ty uintptr = enum_type(tls)

	// Read a struct tag.
	var tag uintptr = uintptr(0)
	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_IDENT {
		tag = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
	}

	if tag != 0 && !(equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0) {
		var ty uintptr = find_tag(tls, tag)
		if !(ty != 0) {
			error_tok(tls, tag, ts+8876, 0)
		}
		if (*Type)(unsafe.Pointer(ty)).kind != TY_ENUM {
			error_tok(tls, tag, ts+8894, 0)
		}
		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return ty
	}

	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8874)

	// Read an enum-list.
	var i int32 = 0
	var val int32 = 0
	for !(consume_end(tls, rest, *(*uintptr)(unsafe.Pointer(bp))) != 0) {
		if libc.PostIncInt32(&i, 1) > 0 {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}

		var name uintptr = get_ident(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8910) != 0 {
			val = int32(const_expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next))
		}

		var sc uintptr = push_scope(tls, name)
		(*VarScope)(unsafe.Pointer(sc)).enum_ty = ty
		(*VarScope)(unsafe.Pointer(sc)).enum_val = libc.PostIncInt32(&val, 1)
	}

	if tag != 0 {
		push_tag_scope(tls, tag, ty)
	}
	return ty
}

// typeof-specifier = "(" (expr | typename) ")"
func typeof_specifier(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:798:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8703)
	var ty uintptr
	if is_typename(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0 {
		ty = typename(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	} else {
		var node uintptr = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		add_type(tls, node)
		ty = (*Node)(unsafe.Pointer(node)).ty
	}
	*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
	return ty
}

// Generate code for computing a VLA size.
func compute_vla_size(tls *libc.TLS, ty uintptr, tok uintptr) uintptr { /* parse.c:814:13: */
	var node uintptr = new_node(tls, ND_NULL_EXPR, tok)
	if (*Type)(unsafe.Pointer(ty)).base != 0 {
		node = new_binary(tls, ND_COMMA, node, compute_vla_size(tls, (*Type)(unsafe.Pointer(ty)).base, tok), tok)
	}

	if (*Type)(unsafe.Pointer(ty)).kind != TY_VLA {
		return node
	}
	var base_sz uintptr
	if (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer(ty)).base)).kind == TY_VLA {
		base_sz = new_var_node(tls, (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer(ty)).base)).vla_size, tok)
	} else {
		base_sz = new_num(tls, int64((*Type)(unsafe.Pointer((*Type)(unsafe.Pointer(ty)).base)).size), tok)
	}

	(*Type)(unsafe.Pointer(ty)).vla_size = new_lvar(tls, ts+8912, ty_ulong)
	var expr uintptr = new_binary(tls, ND_ASSIGN, new_var_node(tls, (*Type)(unsafe.Pointer(ty)).vla_size, tok),
		new_binary(tls, ND_MUL, (*Type)(unsafe.Pointer(ty)).vla_len, base_sz, tok),
		tok)
	return new_binary(tls, ND_COMMA, node, expr, tok)
}

func new_alloca(tls *libc.TLS, sz uintptr) uintptr { /* parse.c:835:13: */
	var node uintptr = new_unary(tls, ND_FUNCALL, new_var_node(tls, builtin_alloca1, (*Node)(unsafe.Pointer(sz)).tok), (*Node)(unsafe.Pointer(sz)).tok)
	(*Node)(unsafe.Pointer(node)).func_ty = (*Obj)(unsafe.Pointer(builtin_alloca1)).ty
	(*Node)(unsafe.Pointer(node)).ty = (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer(builtin_alloca1)).ty)).return_ty
	(*Node)(unsafe.Pointer(node)).args = sz
	add_type(tls, sz)
	return node
}

// declaration = declspec (declarator ("=" expr)? ("," declarator ("=" expr)?)*)? ";"
func declaration(tls *libc.TLS, rest uintptr, tok uintptr, basety uintptr, attr uintptr) uintptr { /* parse.c:845:13: */
	bp := tls.Alloc(288)
	defer tls.Free(288)
	*(*uintptr)(unsafe.Pointer(bp + 280)) = tok

	*(*Node)(unsafe.Pointer(bp /* head */)) = Node{}
	var cur uintptr = bp /* &head */
	var i int32 = 0

	for !(equal(tls, *(*uintptr)(unsafe.Pointer(bp + 280)), ts+8913) != 0) {
		if libc.PostIncInt32(&i, 1) > 0 {
			*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+8368)
		}

		var ty uintptr = declarator(tls, bp+280, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), basety)
		if (*Type)(unsafe.Pointer(ty)).kind == TY_VOID {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+8915, 0)
		}
		if !(int32((*Type)(unsafe.Pointer(ty)).name) != 0) {
			error_tok(tls, (*Type)(unsafe.Pointer(ty)).name_pos, ts+8938, 0)
		}

		if attr != 0 && (*VarAttr)(unsafe.Pointer(attr)).is_static != 0 {
			// static local variable
			var var1 uintptr = new_anon_gvar(tls, ty)
			(*VarScope)(unsafe.Pointer(push_scope(tls, get_ident(tls, (*Type)(unsafe.Pointer(ty)).name)))).__var = var1
			if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 280)), ts+8910) != 0 {
				gvar_initializer(tls, bp+280, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))).next, var1)
			}
			continue
		}

		// Generate code for computing a VLA size. We need to do this
		// even if ty is not VLA because ty may be a pointer to VLA
		// (e.g. int (*foo)[n][m] where n and m are variables.)
		cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT, compute_vla_size(tls, ty, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */))), *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */))))

		if (*Type)(unsafe.Pointer(ty)).kind == TY_VLA {
			if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 280)), ts+8910) != 0 {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+8960, 0)
			}

			// Variable length arrays (VLAs) are translated to alloca() calls.
			// For example, `int x[n+2]` is translated to `tmp = n + 2,
			// x = alloca(tmp)`.
			var var1 uintptr = new_lvar(tls, get_ident(tls, (*Type)(unsafe.Pointer(ty)).name), ty)
			var tok uintptr = (*Type)(unsafe.Pointer(ty)).name
			var expr uintptr = new_binary(tls, ND_ASSIGN, new_vla_ptr(tls, var1, tok),
				new_alloca(tls, new_var_node(tls, (*Type)(unsafe.Pointer(ty)).vla_size, tok)),
				tok)

			cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT, expr, tok))
			continue
		}

		var var1 uintptr = new_lvar(tls, get_ident(tls, (*Type)(unsafe.Pointer(ty)).name), ty)
		if attr != 0 && (*VarAttr)(unsafe.Pointer(attr)).align != 0 {
			(*Obj)(unsafe.Pointer(var1)).align = (*VarAttr)(unsafe.Pointer(attr)).align
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 280)), ts+8910) != 0 {
			var expr uintptr = lvar_initializer(tls, bp+280, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))).next, var1)
			cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT, expr, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */))))
		}

		if (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer(var1)).ty)).size < 0 {
			error_tok(tls, (*Type)(unsafe.Pointer(ty)).name, ts+9005, 0)
		}
		if (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer(var1)).ty)).kind == TY_VOID {
			error_tok(tls, (*Type)(unsafe.Pointer(ty)).name, ts+8915, 0)
		}
	}

	var node uintptr = new_node(tls, ND_BLOCK, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))
	(*Node)(unsafe.Pointer(node)).body = (*Node)(unsafe.Pointer(bp /* &head */)).next
	*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))).next
	return node
}

func skip_excess_element(tls *libc.TLS, tok uintptr) uintptr { /* parse.c:912:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip_excess_element(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		return skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8872)
	}

	assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	return *(*uintptr)(unsafe.Pointer(bp /* tok */))
}

// string-initializer = string-literal
func string_initializer(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr) { /* parse.c:923:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if (*Initializer)(unsafe.Pointer(init1)).is_flexible != 0 {
		*(*Initializer)(unsafe.Pointer(init1)) = *(*Initializer)(unsafe.Pointer(new_initializer(tls, array_of(tls, (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).base, (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).ty)).array_len), uint8(0))))
	}

	var len int32 = func() int32 {
		if (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).array_len < (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).ty)).array_len {
			return (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).array_len
		}
		return (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).ty)).array_len
	}()

	switch (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).base)).size {
	case 1:
		{
			var str uintptr = (*Token)(unsafe.Pointer(tok)).str
			{
				var i int32 = 0
				for ; i < len; i++ {
					(*Initializer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)))).expr = new_num(tls, int64(*(*int8)(unsafe.Pointer(str + uintptr(i)))), tok)
				}
			}
			break

		}
	case 2:
		{
			var str uintptr = (*Token)(unsafe.Pointer(tok)).str
			{
				var i int32 = 0
				for ; i < len; i++ {
					(*Initializer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)))).expr = new_num(tls, int64(*(*uint16_t)(unsafe.Pointer(str + uintptr(i)*2))), tok)
				}
			}
			break

		}
	case 4:
		{
			var str uintptr = (*Token)(unsafe.Pointer(tok)).str
			{
				var i int32 = 0
				for ; i < len; i++ {
					(*Initializer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)))).expr = new_num(tls, int64(*(*uint32_t)(unsafe.Pointer(str + uintptr(i)*4))), tok)
				}
			}
			break

		}
	default:
		error(tls, ts+217, libc.VaList(bp, ts+8841, 949))
	}

	*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(tok)).next
}

// array-designator = "[" const-expr "]"
//
// C99 added the designated initializer to the language, which allows
// programmers to move the "cursor" of an initializer to any element.
// The syntax looks like this:
//
//	int x[10] = { 1, 2, [5]=3, 4, 5, 6, 7 };
//
// `[5]` moves the cursor to the 5th element, so the 5th element of x
// is set to 3. Initialization then continues forward in order, so
// 6th, 7th, 8th and 9th elements are initialized with 4, 5, 6 and 7,
// respectively. Unspecified elements (in this case, 3rd and 4th
// elements) are initialized with zero.
//
// Nesting is allowed, so the following initializer is valid:
//
//	int x[5][10] = { [5][8]=1, 2, 3 };
//
// It sets x[5][8], x[5][9] and x[6][0] to 1, 2 and 3, respectively.
//
// Use `.fieldname` to move the cursor for a struct initializer. E.g.
//
//	struct { int a, b, c; } x = { .c=5 };
//
// The above initializer sets x.c to 5.
func array_designator(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr, begin uintptr, end uintptr) { /* parse.c:980:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = tok

	*(*int32)(unsafe.Pointer(begin)) = int32(const_expr(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next))
	if *(*int32)(unsafe.Pointer(begin)) >= (*Type)(unsafe.Pointer(ty)).array_len {
		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+9034, 0)
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), ts+8862) != 0 {
		*(*int32)(unsafe.Pointer(end)) = int32(const_expr(tls, bp+16, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)))).next))
		if *(*int32)(unsafe.Pointer(end)) >= (*Type)(unsafe.Pointer(ty)).array_len {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+9034, 0)
		}
		if *(*int32)(unsafe.Pointer(end)) < *(*int32)(unsafe.Pointer(begin)) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+9078, libc.VaList(bp, *(*int32)(unsafe.Pointer(begin)), *(*int32)(unsafe.Pointer(end))))
		}
	} else {
		*(*int32)(unsafe.Pointer(end)) = *(*int32)(unsafe.Pointer(begin))
	}

	*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok */)), ts+8866)
}

// struct-designator = "." ident
func struct_designator(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) uintptr { /* parse.c:999:15: */
	var start uintptr = tok
	tok = skip(tls, tok, ts+6708)
	if (*Token)(unsafe.Pointer(tok)).kind != TK_IDENT {
		error_tok(tls, tok, ts+9119, 0)
	}

	{
		var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
		for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
			// Anonymous struct member
			if (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).kind == TY_STRUCT && !(int32((*Member)(unsafe.Pointer(mem)).name) != 0) {
				if get_struct_member(tls, (*Member)(unsafe.Pointer(mem)).ty, tok) != 0 {
					*(*uintptr)(unsafe.Pointer(rest)) = start
					return mem
				}
				continue
			}

			// Regular struct member
			if (*Token)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).name)).len == (*Token)(unsafe.Pointer(tok)).len && !(libc.Xstrncmp(tls, (*Token)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).name)).loc, (*Token)(unsafe.Pointer(tok)).loc, uint64((*Token)(unsafe.Pointer(tok)).len)) != 0) {
				*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(tok)).next
				return mem
			}
		}
	}

	error_tok(tls, tok, ts+9147, 0)
	return uintptr(0)
}

// designation = ("[" const-expr "]" | "." ident)* "="? initializer
func designation(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr) { /* parse.c:1026:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8868) != 0 {
		if (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind != TY_ARRAY {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9173, 0)
		}
		// var begin int32 at bp+8, 4

		// var end int32 at bp+12, 4

		array_designator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty, bp+8, bp+12)
		// var tok2 uintptr at bp+16, 8

		{
			var i int32 = *(*int32)(unsafe.Pointer(bp + 8 /* begin */))
			for ; i <= *(*int32)(unsafe.Pointer(bp + 12)); i++ {
				designation(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)))
			}
		}
		array_initializer2(tls, rest, *(*uintptr)(unsafe.Pointer(bp + 16 /* tok2 */)), init1, *(*int32)(unsafe.Pointer(bp + 8))+1)
		return
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 && (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind == TY_STRUCT {
		var mem uintptr = struct_designator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty)
		designation(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))
		(*Initializer)(unsafe.Pointer(init1)).expr = uintptr(0)
		struct_initializer2(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1, (*Member)(unsafe.Pointer(mem)).next)
		return
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 && (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind == TY_UNION {
		var mem uintptr = struct_designator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty)
		(*Initializer)(unsafe.Pointer(init1)).mem = mem
		designation(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))
		return
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 {
		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9210, 0)
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8910) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
	}
	initializer2(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1)
}

// An array length can be omitted if an array has an initializer
// (e.g. `int x[] = {1,2,3}`). If it's omitted, count the number
// of initializer elements.
func count_array_init_elements(tls *libc.TLS, tok uintptr, ty uintptr) int32 { /* parse.c:1067:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var first uint8 = uint8(1)
	var dummy uintptr = new_initializer(tls, (*Type)(unsafe.Pointer(ty)).base, uint8(1))

	var i int32 = 0
	var max int32 = 0

	for !(consume_end(tls, bp, *(*uintptr)(unsafe.Pointer(bp))) != 0) {
		if !(first != 0) {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}
		first = uint8(0)

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8868) != 0 {
			i = int32(const_expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next))
			if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8862) != 0 {
				i = int32(const_expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next))
			}
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8866)
			designation(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), dummy)
		} else {
			initializer2(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), dummy)
		}

		i++
		max = func() int32 {
			if max < i {
				return i
			}
			return max
		}()
	}
	return max
}

// array-initializer1 = "{" initializer ("," initializer)* ","? "}"
func array_initializer1(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr) { /* parse.c:1095:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8874)

	if (*Initializer)(unsafe.Pointer(init1)).is_flexible != 0 {
		var len int32 = count_array_init_elements(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty)
		*(*Initializer)(unsafe.Pointer(init1)) = *(*Initializer)(unsafe.Pointer(new_initializer(tls, array_of(tls, (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).base, len), uint8(0))))
	}

	var first uint8 = uint8(1)

	if (*Initializer)(unsafe.Pointer(init1)).is_flexible != 0 {
		var len int32 = count_array_init_elements(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty)
		*(*Initializer)(unsafe.Pointer(init1)) = *(*Initializer)(unsafe.Pointer(new_initializer(tls, array_of(tls, (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).base, len), uint8(0))))
	}

	{
		var i int32 = 0
		for ; !(consume_end(tls, rest, *(*uintptr)(unsafe.Pointer(bp))) != 0); i++ {
			if !(first != 0) {
				*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
			}
			first = uint8(0)

			if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8868) != 0 {
				// var begin int32 at bp+8, 4

				// var end int32 at bp+12, 4

				array_designator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty, bp+8, bp+12)
				// var tok2 uintptr at bp+16, 8

				{
					var j int32 = *(*int32)(unsafe.Pointer(bp + 8 /* begin */))
					for ; j <= *(*int32)(unsafe.Pointer(bp + 12)); j++ {
						designation(tls, bp+16, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(j)*8)))
					}
				}
				*(*uintptr)(unsafe.Pointer(bp /* tok */)) = *(*uintptr)(unsafe.Pointer(bp + 16 /* tok2 */))
				i = *(*int32)(unsafe.Pointer(bp + 12 /* end */))
				continue
			}

			if i < (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).array_len {
				initializer2(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)))
			} else {
				*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip_excess_element(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			}
		}
	}
}

// array-initializer2 = initializer ("," initializer)*
func array_initializer2(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr, i int32) { /* parse.c:1135:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if (*Initializer)(unsafe.Pointer(init1)).is_flexible != 0 {
		var len int32 = count_array_init_elements(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty)
		*(*Initializer)(unsafe.Pointer(init1)) = *(*Initializer)(unsafe.Pointer(new_initializer(tls, array_of(tls, (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).base, len), uint8(0))))
	}

	for ; i < (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).array_len && !(is_end(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0); i++ {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		if i > 0 {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8868) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 {
			*(*uintptr)(unsafe.Pointer(rest)) = start
			return
		}

		initializer2(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)))
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
}

// struct-initializer1 = "{" initializer ("," initializer)* ","? "}"
func struct_initializer1(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr) { /* parse.c:1157:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8874)

	var mem uintptr = (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).members
	var first uint8 = uint8(1)

	for !(consume_end(tls, rest, *(*uintptr)(unsafe.Pointer(bp))) != 0) {
		if !(first != 0) {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}
		first = uint8(0)

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 {
			mem = struct_designator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Initializer)(unsafe.Pointer(init1)).ty)
			designation(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))
			mem = (*Member)(unsafe.Pointer(mem)).next
			continue
		}

		if mem != 0 {
			initializer2(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))
			mem = (*Member)(unsafe.Pointer(mem)).next
		} else {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip_excess_element(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}
	}
}

// struct-initializer2 = initializer ("," initializer)*
func struct_initializer2(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr, mem uintptr) { /* parse.c:1185:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var first uint8 = uint8(1)

	for ; mem != 0 && !(is_end(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0); mem = (*Member)(unsafe.Pointer(mem)).next {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		if !(first != 0) {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}
		first = uint8(0)

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8868) != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 {
			*(*uintptr)(unsafe.Pointer(rest)) = start
			return
		}

		initializer2(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
}

func union_initializer(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr) { /* parse.c:1205:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	// Unlike structs, union initializers take only one initializer,
	// and that initializes the first union member by default.
	// You can initialize other member using a designated initializer.
	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+6708) != 0 {
		var mem uintptr = struct_designator(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, (*Initializer)(unsafe.Pointer(init1)).ty)
		(*Initializer)(unsafe.Pointer(init1)).mem = mem
		designation(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8872)
		return
	}

	(*Initializer)(unsafe.Pointer(init1)).mem = (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).members

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
		initializer2(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children)))
		consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8872)
	} else {
		initializer2(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children)))
	}
}

// initializer = string-initializer | array-initializer
//
//	| struct-initializer | union-initializer
//	| assign
func initializer2(tls *libc.TLS, rest uintptr, tok uintptr, init1 uintptr) { /* parse.c:1231:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind == TY_ARRAY && (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_STR {
		string_initializer(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1)
		return
	}

	if (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind == TY_ARRAY {
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
			array_initializer1(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1)
		} else {
			array_initializer2(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1, 0)
		}
		return
	}

	if (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind == TY_STRUCT {
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
			struct_initializer1(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1)
			return
		}

		// A struct can be initialized with another struct. E.g.
		// `struct T x = y;` where y is a variable of type `struct T`.
		// Handle that case first.
		var expr uintptr = assign(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		add_type(tls, expr)
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(expr)).ty)).kind == TY_STRUCT {
			(*Initializer)(unsafe.Pointer(init1)).expr = expr
			return
		}

		struct_initializer2(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1, (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).members)
		return
	}

	if (*Type)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).ty)).kind == TY_UNION {
		union_initializer(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), init1)
		return
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
		// An initializer for a scalar variable can be surrounded by
		// braces. E.g. `int x = {3};`. Handle that case.
		initializer2(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, init1)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8872)
		return
	}

	(*Initializer)(unsafe.Pointer(init1)).expr = assign(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
}

func copy_struct_type(tls *libc.TLS, ty uintptr) uintptr { /* parse.c:1281:13: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	ty = copy_type(tls, ty)

	*(*Member)(unsafe.Pointer(bp /* head */)) = Member{}
	var cur uintptr = bp /* &head */
	{
		var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
		for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
			var m uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Member{})))
			*(*Member)(unsafe.Pointer(m)) = *(*Member)(unsafe.Pointer(mem))
			cur = libc.AssignPtrUintptr(cur, m)
		}
	}

	(*Type)(unsafe.Pointer(ty)).members = (*Member)(unsafe.Pointer(bp /* &head */)).next
	return ty
}

func initializer(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr, new_ty uintptr) uintptr { /* parse.c:1296:20: */
	var init1 uintptr = new_initializer(tls, ty, uint8(1))
	initializer2(tls, rest, tok, init1)

	if ((*Type)(unsafe.Pointer(ty)).kind == TY_STRUCT || (*Type)(unsafe.Pointer(ty)).kind == TY_UNION) && (*Type)(unsafe.Pointer(ty)).is_flexible != 0 {
		ty = copy_struct_type(tls, ty)

		var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
		for (*Member)(unsafe.Pointer(mem)).next != 0 {
			mem = (*Member)(unsafe.Pointer(mem)).next
		}
		(*Member)(unsafe.Pointer(mem)).ty = (*Initializer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))).ty
		*(*int32)(unsafe.Pointer(ty + 4)) += (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size

		*(*uintptr)(unsafe.Pointer(new_ty)) = ty
		return init1
	}

	*(*uintptr)(unsafe.Pointer(new_ty)) = (*Initializer)(unsafe.Pointer(init1)).ty
	return init1
}

func init_desg_expr(tls *libc.TLS, desg uintptr, tok uintptr) uintptr { /* parse.c:1317:13: */
	if (*InitDesg)(unsafe.Pointer(desg)).__var != 0 {
		return new_var_node(tls, (*InitDesg)(unsafe.Pointer(desg)).__var, tok)
	}

	if (*InitDesg)(unsafe.Pointer(desg)).member != 0 {
		var node uintptr = new_unary(tls, ND_MEMBER, init_desg_expr(tls, (*InitDesg)(unsafe.Pointer(desg)).next, tok), tok)
		(*Node)(unsafe.Pointer(node)).member = (*InitDesg)(unsafe.Pointer(desg)).member
		return node
	}

	var lhs uintptr = init_desg_expr(tls, (*InitDesg)(unsafe.Pointer(desg)).next, tok)
	var rhs uintptr = new_num(tls, int64((*InitDesg)(unsafe.Pointer(desg)).idx), tok)
	return new_unary(tls, ND_DEREF, new_add(tls, lhs, rhs, tok), tok)
}

func create_lvar_init(tls *libc.TLS, init1 uintptr, ty uintptr, desg uintptr, tok uintptr) uintptr { /* parse.c:1332:13: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	if (*Type)(unsafe.Pointer(ty)).kind == TY_ARRAY {
		var node uintptr = new_node(tls, ND_NULL_EXPR, tok)
		{
			var i int32 = 0
			for ; i < (*Type)(unsafe.Pointer(ty)).array_len; i++ {
				*(*InitDesg)(unsafe.Pointer(bp /* desg2 */)) = InitDesg{next: desg, idx: i}
				var rhs uintptr = create_lvar_init(tls, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)), (*Type)(unsafe.Pointer(ty)).base, bp, tok)
				node = new_binary(tls, ND_COMMA, node, rhs, tok)
			}
		}
		return node
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_STRUCT && !(int32((*Initializer)(unsafe.Pointer(init1)).expr) != 0) {
		var node uintptr = new_node(tls, ND_NULL_EXPR, tok)

		{
			var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
			for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
				*(*InitDesg)(unsafe.Pointer(bp + 32 /* desg2 */)) = InitDesg{next: desg, member: mem}
				var rhs uintptr = create_lvar_init(tls, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)), (*Member)(unsafe.Pointer(mem)).ty, bp+32, tok)
				node = new_binary(tls, ND_COMMA, node, rhs, tok)
			}
		}
		return node
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_UNION {
		var mem uintptr
		if (*Initializer)(unsafe.Pointer(init1)).mem != 0 {
			mem = (*Initializer)(unsafe.Pointer(init1)).mem
		} else {
			mem = (*Type)(unsafe.Pointer(ty)).members
		}
		*(*InitDesg)(unsafe.Pointer(bp + 64 /* desg2 */)) = InitDesg{next: desg, member: mem}
		return create_lvar_init(tls, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)), (*Member)(unsafe.Pointer(mem)).ty, bp+64, tok)
	}

	if !(int32((*Initializer)(unsafe.Pointer(init1)).expr) != 0) {
		return new_node(tls, ND_NULL_EXPR, tok)
	}

	var lhs uintptr = init_desg_expr(tls, desg, tok)
	return new_binary(tls, ND_ASSIGN, lhs, (*Initializer)(unsafe.Pointer(init1)).expr, tok)
}

// A variable definition with an initializer is a shorthand notation
// for a variable definition followed by assignments. This function
// generates assignment expressions for an initializer. For example,
// `int x[2][2] = {{6, 7}, {8, 9}}` is converted to the following
// expressions:
//
//	x[0][0] = 6;
//	x[0][1] = 7;
//	x[1][0] = 8;
//	x[1][1] = 9;
func lvar_initializer(tls *libc.TLS, rest uintptr, tok uintptr, var1 uintptr) uintptr { /* parse.c:1377:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var init1 uintptr = initializer(tls, rest, tok, (*Obj)(unsafe.Pointer(var1)).ty, var1+16)
	*(*InitDesg)(unsafe.Pointer(bp /* desg */)) = InitDesg{__var: var1}

	// If a partial initializer list is given, the standard requires
	// that unspecified elements are set to 0. Here, we simply
	// zero-initialize the entire memory region of a variable before
	// initializing it with user-supplied values.
	var lhs uintptr = new_node(tls, ND_MEMZERO, tok)
	(*Node)(unsafe.Pointer(lhs)).__var = var1

	var rhs uintptr = create_lvar_init(tls, init1, (*Obj)(unsafe.Pointer(var1)).ty, bp, tok)
	return new_binary(tls, ND_COMMA, lhs, rhs, tok)
}

func read_buf(tls *libc.TLS, buf uintptr, sz int32) uint64_t { /* parse.c:1392:17: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if sz == 1 {
		return uint64_t(*(*int8)(unsafe.Pointer(buf)))
	}
	if sz == 2 {
		return uint64_t(*(*uint16_t)(unsafe.Pointer(buf)))
	}
	if sz == 4 {
		return uint64_t(*(*uint32_t)(unsafe.Pointer(buf)))
	}
	if sz == 8 {
		return *(*uint64_t)(unsafe.Pointer(buf))
	}
	error(tls, ts+217, libc.VaList(bp, ts+8841, 1401))
	return uint64_t(0)
}

func write_buf(tls *libc.TLS, buf uintptr, val uint64_t, sz int32) { /* parse.c:1404:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if sz == 1 {
		*(*int8)(unsafe.Pointer(buf)) = int8(val)
	} else if sz == 2 {
		*(*uint16_t)(unsafe.Pointer(buf)) = uint16_t(val)
	} else if sz == 4 {
		*(*uint32_t)(unsafe.Pointer(buf)) = uint32_t(val)
	} else if sz == 8 {
		*(*uint64_t)(unsafe.Pointer(buf)) = val
	} else {
		error(tls, ts+217, libc.VaList(bp, ts+8841, 1414))
	}
}

func write_gvar_data(tls *libc.TLS, cur uintptr, init1 uintptr, ty uintptr, buf uintptr, offset int32) uintptr { /* parse.c:1417:19: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if (*Type)(unsafe.Pointer(ty)).kind == TY_ARRAY {
		var sz int32 = (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer(ty)).base)).size
		{
			var i int32 = 0
			for ; i < (*Type)(unsafe.Pointer(ty)).array_len; i++ {
				cur = write_gvar_data(tls, cur, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr(i)*8)), (*Type)(unsafe.Pointer(ty)).base, buf, offset+sz*i)
			}
		}
		return cur
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_STRUCT {
		{
			var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
			for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
				if (*Member)(unsafe.Pointer(mem)).is_bitfield != 0 {
					var expr uintptr = (*Initializer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)))).expr
					if !(expr != 0) {
						break
					}

					var loc uintptr = buf + uintptr(offset) + uintptr((*Member)(unsafe.Pointer(mem)).offset)
					var oldval uint64_t = read_buf(tls, loc, (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size)
					var newval uint64_t = uint64_t(eval(tls, expr))
					var mask uint64_t = uint64_t(int64(1)<<(*Member)(unsafe.Pointer(mem)).bit_width - int64(1))
					var combined uint64_t = oldval | newval&mask<<(*Member)(unsafe.Pointer(mem)).bit_offset
					write_buf(tls, loc, combined, (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size)
				} else {
					cur = write_gvar_data(tls, cur, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer(mem)).idx)*8)), (*Member)(unsafe.Pointer(mem)).ty, buf,
						offset+(*Member)(unsafe.Pointer(mem)).offset)
				}
			}
		}
		return cur
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_UNION {
		if !(int32((*Initializer)(unsafe.Pointer(init1)).mem) != 0) {
			return cur
		}
		return write_gvar_data(tls, cur, *(*uintptr)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).children + uintptr((*Member)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).mem)).idx)*8)),
			(*Member)(unsafe.Pointer((*Initializer)(unsafe.Pointer(init1)).mem)).ty, buf, offset)
	}

	if !(int32((*Initializer)(unsafe.Pointer(init1)).expr) != 0) {
		return cur
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_FLOAT {
		*(*float32)(unsafe.Pointer(buf + uintptr(offset))) = float32(eval_double(tls, (*Initializer)(unsafe.Pointer(init1)).expr))
		return cur
	}

	if (*Type)(unsafe.Pointer(ty)).kind == TY_DOUBLE {
		*(*float64)(unsafe.Pointer(buf + uintptr(offset))) = eval_double(tls, (*Initializer)(unsafe.Pointer(init1)).expr)
		return cur
	}

	*(*uintptr)(unsafe.Pointer(bp /* label */)) = uintptr(0)
	var val uint64_t = uint64_t(eval2(tls, (*Initializer)(unsafe.Pointer(init1)).expr, bp))

	if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
		write_buf(tls, buf+uintptr(offset), val, (*Type)(unsafe.Pointer(ty)).size)
		return cur
	}

	var rel uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Relocation{})))
	(*Relocation)(unsafe.Pointer(rel)).offset = offset
	(*Relocation)(unsafe.Pointer(rel)).label = *(*uintptr)(unsafe.Pointer(bp /* label */))
	(*Relocation)(unsafe.Pointer(rel)).addend = int64(val)
	(*Relocation)(unsafe.Pointer(cur)).next = rel
	return (*Relocation)(unsafe.Pointer(cur)).next
}

// Initializers for global variables are evaluated at compile-time and
// embedded to .data section. This function serializes Initializer
// objects to a flat byte array. It is a compile error if an
// initializer list contains a non-constant expression.
func gvar_initializer(tls *libc.TLS, rest uintptr, tok uintptr, var1 uintptr) { /* parse.c:1487:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var init1 uintptr = initializer(tls, rest, tok, (*Obj)(unsafe.Pointer(var1)).ty, var1+16)

	*(*Relocation)(unsafe.Pointer(bp /* head */)) = Relocation{}
	var buf uintptr = libc.Xcalloc(tls, uint64(1), uint64((*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer(var1)).ty)).size))
	write_gvar_data(tls, bp, init1, (*Obj)(unsafe.Pointer(var1)).ty, buf, 0)
	(*Obj)(unsafe.Pointer(var1)).init_data = buf
	(*Obj)(unsafe.Pointer(var1)).rel = (*Relocation)(unsafe.Pointer(bp /* &head */)).next
}

// Returns true if a given token represents a type.
func is_typename(tls *libc.TLS, tok uintptr) uint8 { /* parse.c:1498:13: */

	if map1.capacity == 0 {

		{
			var i int32 = 0
			for ; uint64(i) < uint64(unsafe.Sizeof(kw))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
				hashmap_put(tls, uintptr(unsafe.Pointer(&map1)), kw[i], uintptr(1))
			}
		}
	}

	return uint8(libc.Bool32(hashmap_get2(tls, uintptr(unsafe.Pointer(&map1)), (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).len) != 0 || find_typedef(tls, tok) != 0))
}

var map1 HashMap /* parse.c:1499:18: */
var kw = [30]uintptr{
	ts + 8781, ts + 8786, ts + 8792, ts + 8797, ts + 8803, ts + 8807, ts + 8756, ts + 8763,
	ts + 8428, ts + 8769, ts + 8436, ts + 8443, ts + 8707, ts + 8825, ts + 8832,
	ts + 8623, ts + 8629, ts + 8638, ts + 8643, ts + 8652, ts + 8661,
	ts + 8672, ts + 8685, ts + 8812, ts + 8818, ts + 8774, ts + 8450,
	ts + 8457, ts + 8471, ts + 8695,
} /* parse.c:1502:17 */

// asm-stmt = "asm" ("volatile" | "inline")* "(" string-literal ")"
func asm_stmt(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:1518:13: */
	var node uintptr = new_node(tls, ND_ASM, tok)
	tok = (*Token)(unsafe.Pointer(tok)).next

	for equal(tls, tok, ts+8629) != 0 || equal(tls, tok, ts+8450) != 0 {
		tok = (*Token)(unsafe.Pointer(tok)).next
	}

	tok = skip(tls, tok, ts+8703)
	if (*Token)(unsafe.Pointer(tok)).kind != TK_STR || (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).ty)).base)).kind != TY_CHAR {
		error_tok(tls, tok, ts+9256, 0)
	}
	(*Node)(unsafe.Pointer(node)).asm_str = (*Token)(unsafe.Pointer(tok)).str
	*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, (*Token)(unsafe.Pointer(tok)).next, ts+8705)
	return node
}

// stmt = "return" expr? ";"
//
//	| "if" "(" expr ")" stmt ("else" stmt)?
//	| "switch" "(" expr ")" stmt
//	| "case" const-expr ("..." const-expr)? ":" stmt
//	| "default" ":" stmt
//	| "for" "(" expr-stmt expr? ";" expr? ")" stmt
//	| "while" "(" expr ")" stmt
//	| "do" stmt "while" "(" expr ")" ";"
//	| "asm" asm-stmt
//	| "goto" (ident | "*" expr) ";"
//	| "break" ";"
//	| "continue" ";"
//	| ident ":" stmt
//	| "{" compound-stmt
//	| expr-stmt
func stmt(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:1548:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9280) != 0 {
		var node uintptr = new_node(tls, ND_RETURN, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		if consume(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8913) != 0 {
			return node
		}

		var exp uintptr = expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8913)

		add_type(tls, exp)
		var ty uintptr = (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer(current_fn1)).ty)).return_ty
		if (*Type)(unsafe.Pointer(ty)).kind != TY_STRUCT && (*Type)(unsafe.Pointer(ty)).kind != TY_UNION {
			exp = new_cast(tls, exp, (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer(current_fn1)).ty)).return_ty)
		}

		(*Node)(unsafe.Pointer(node)).lhs = exp
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9287) != 0 {
		var node uintptr = new_node(tls, ND_IF, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		(*Node)(unsafe.Pointer(node)).cond = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		(*Node)(unsafe.Pointer(node)).then = stmt(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9290) != 0 {
			(*Node)(unsafe.Pointer(node)).els = stmt(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		}
		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9295) != 0 {
		var node uintptr = new_node(tls, ND_SWITCH, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		(*Node)(unsafe.Pointer(node)).cond = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		var sw uintptr = current_switch
		current_switch = node

		var brk uintptr = brk_label
		brk_label = libc.AssignPtrUintptr(node+88, new_unique_name(tls))

		(*Node)(unsafe.Pointer(node)).then = stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

		current_switch = sw
		brk_label = brk
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9302) != 0 {
		if !(current_switch != 0) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9307, 0)
		}

		var node uintptr = new_node(tls, ND_CASE, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		var begin int32 = int32(const_expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next))
		var end int32

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8862) != 0 {
			// [GNU] Case ranges, e.g. "case 1 ... 5:"
			end = int32(const_expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next))
			if end < begin {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9318, 0)
			}
		} else {
			end = begin
		}

		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9345)
		(*Node)(unsafe.Pointer(node)).label = new_unique_name(tls)
		(*Node)(unsafe.Pointer(node)).lhs = stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(node)).begin = int64(begin)
		(*Node)(unsafe.Pointer(node)).end = int64(end)
		(*Node)(unsafe.Pointer(node)).case_next = (*Node)(unsafe.Pointer(current_switch)).case_next
		(*Node)(unsafe.Pointer(current_switch)).case_next = node
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9347) != 0 {
		if !(current_switch != 0) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9355, 0)
		}

		var node uintptr = new_node(tls, ND_CASE, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+9345)
		(*Node)(unsafe.Pointer(node)).label = new_unique_name(tls)
		(*Node)(unsafe.Pointer(node)).lhs = stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(current_switch)).default_case = node
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9369) != 0 {
		var node uintptr = new_node(tls, ND_FOR, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)

		enter_scope(tls)

		var brk uintptr = brk_label
		var cont uintptr = cont_label
		brk_label = libc.AssignPtrUintptr(node+88, new_unique_name(tls))
		cont_label = libc.AssignPtrUintptr(node+96, new_unique_name(tls))

		if is_typename(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0 {
			var basety uintptr = declspec(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), uintptr(0))
			(*Node)(unsafe.Pointer(node)).init = declaration(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), basety, uintptr(0))
		} else {
			(*Node)(unsafe.Pointer(node)).init = expr_stmt(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}

		if !(equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8913) != 0) {
			(*Node)(unsafe.Pointer(node)).cond = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8913)

		if !(equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8705) != 0) {
			(*Node)(unsafe.Pointer(node)).inc = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		(*Node)(unsafe.Pointer(node)).then = stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

		leave_scope(tls)
		brk_label = brk
		cont_label = cont
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9373) != 0 {
		var node uintptr = new_node(tls, ND_FOR, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		(*Node)(unsafe.Pointer(node)).cond = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		var brk uintptr = brk_label
		var cont uintptr = cont_label
		brk_label = libc.AssignPtrUintptr(node+88, new_unique_name(tls))
		cont_label = libc.AssignPtrUintptr(node+96, new_unique_name(tls))

		(*Node)(unsafe.Pointer(node)).then = stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

		brk_label = brk
		cont_label = cont
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9379) != 0 {
		var node uintptr = new_node(tls, ND_DO, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

		var brk uintptr = brk_label
		var cont uintptr = cont_label
		brk_label = libc.AssignPtrUintptr(node+88, new_unique_name(tls))
		cont_label = libc.AssignPtrUintptr(node+96, new_unique_name(tls))

		(*Node)(unsafe.Pointer(node)).then = stmt(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)

		brk_label = brk
		cont_label = cont

		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9373)
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8703)
		(*Node)(unsafe.Pointer(node)).cond = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8913)
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9382) != 0 {
		return asm_stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9386) != 0 {
		if equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8870) != 0 {
			// [GNU] `goto *ptr` jumps to the address specified by `ptr`.
			var node uintptr = new_node(tls, ND_GOTO_EXPR, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			(*Node)(unsafe.Pointer(node)).lhs = expr(tls, bp, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next)
			*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8913)
			return node
		}

		var node uintptr = new_node(tls, ND_GOTO, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(node)).label = get_ident(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		(*Node)(unsafe.Pointer(node)).goto_next = gotos
		gotos = node
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next, ts+8913)
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9391) != 0 {
		if !(brk_label != 0) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9397, 0)
		}
		var node uintptr = new_node(tls, ND_GOTO, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(node)).unique_label = brk_label
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8913)
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9409) != 0 {
		if !(cont_label != 0) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9418, 0)
		}
		var node uintptr = new_node(tls, ND_GOTO, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(node)).unique_label = cont_label
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8913)
		return node
	}

	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_IDENT && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+9345) != 0 {
		var node uintptr = new_node(tls, ND_LABEL, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(node)).label = xstrndup(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).loc, uint64((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).len))
		(*Node)(unsafe.Pointer(node)).unique_label = new_unique_name(tls)
		(*Node)(unsafe.Pointer(node)).lhs = stmt(tls, rest, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next)
		(*Node)(unsafe.Pointer(node)).goto_next = labels
		labels = node
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
		return compound_stmt(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
	}

	return expr_stmt(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
}

// compound-stmt = (typedef | declaration | stmt)* "}"
func compound_stmt(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:1764:13: */
	bp := tls.Alloc(300)
	defer tls.Free(300)
	*(*uintptr)(unsafe.Pointer(bp + 280)) = tok

	var node uintptr = new_node(tls, ND_BLOCK, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))
	*(*Node)(unsafe.Pointer(bp /* head */)) = Node{}
	var cur uintptr = bp /* &head */

	enter_scope(tls)

	for !(equal(tls, *(*uintptr)(unsafe.Pointer(bp + 280)), ts+8872) != 0) {
		if is_typename(tls, *(*uintptr)(unsafe.Pointer(bp + 280))) != 0 && !(equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))).next, ts+9345) != 0) {
			*(*VarAttr)(unsafe.Pointer(bp + 288 /* attr */)) = VarAttr{}
			var basety uintptr = declspec(tls, bp+280, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), bp+288)

			if (*VarAttr)(unsafe.Pointer(bp+288)).is_typedef != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)) = parse_typedef(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), basety)
				continue
			}

			if is_function(tls, *(*uintptr)(unsafe.Pointer(bp + 280))) != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)) = function(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), basety, bp+288)
				continue
			}

			if (*VarAttr)(unsafe.Pointer(bp+288)).is_extern != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)) = global_variable(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), basety, bp+288)
				continue
			}

			cur = libc.AssignPtrUintptr(cur+8, declaration(tls, bp+280, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), basety, bp+288))
		} else {
			cur = libc.AssignPtrUintptr(cur+8, stmt(tls, bp+280, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */))))
		}
		add_type(tls, cur)
	}

	leave_scope(tls)

	(*Node)(unsafe.Pointer(node)).body = (*Node)(unsafe.Pointer(bp /* &head */)).next
	*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))).next
	return node
}

// expr-stmt = expr? ";"
func expr_stmt(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:1806:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8913) != 0 {
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
		return new_node(tls, ND_BLOCK, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	var node uintptr = new_node(tls, ND_EXPR_STMT, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	(*Node)(unsafe.Pointer(node)).lhs = expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8913)
	return node
}

// expr = assign ("," expr)?
func expr(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:1819:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8368) != 0 {
		return new_binary(tls, ND_COMMA, node, expr(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

func eval(tls *libc.TLS, node uintptr) int64_t { /* parse.c:1829:16: */
	return eval2(tls, node, uintptr(0))
}

// Evaluate a given node as a constant expression.
//
// A constant expression is either just a number or ptr+n where ptr
// is a pointer to a global variable and n is a postiive/negative
// number. The latter form is accepted only as an initialization
// expression for a global variable.
func eval2(tls *libc.TLS, node uintptr, label uintptr) int64_t { /* parse.c:1839:16: */
	add_type(tls, node)

	if is_flonum(tls, (*Node)(unsafe.Pointer(node)).ty) != 0 {
		return libc.Int64FromFloat64(eval_double(tls, node))
	}

	switch (*Node)(unsafe.Pointer(node)).kind {
	case ND_ADD:
		return eval2(tls, (*Node)(unsafe.Pointer(node)).lhs, label) + eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_SUB:
		return eval2(tls, (*Node)(unsafe.Pointer(node)).lhs, label) - eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_MUL:
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) * eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_DIV:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 {
			return int64_t(uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).lhs)) / uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).rhs)))
		}
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) / eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_NEG:
		return -eval(tls, (*Node)(unsafe.Pointer(node)).lhs)
	case ND_MOD:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 {
			return int64_t(uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).lhs)) % uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).rhs)))
		}
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) % eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_BITAND:
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) & eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_BITOR:
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) | eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_BITXOR:
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) ^ eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_SHL:
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) << eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_SHR:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 && (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).size == 8 {
			return int64_t(uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).lhs)) >> eval(tls, (*Node)(unsafe.Pointer(node)).rhs))
		}
		return eval(tls, (*Node)(unsafe.Pointer(node)).lhs) >> eval(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_EQ:
		return int64_t(libc.Bool32(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) == eval(tls, (*Node)(unsafe.Pointer(node)).rhs)))
	case ND_NE:
		return int64_t(libc.Bool32(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) != eval(tls, (*Node)(unsafe.Pointer(node)).rhs)))
	case ND_LT:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).is_unsigned != 0 {
			return int64_t(libc.Bool32(uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).lhs)) < uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).rhs))))
		}
		return int64_t(libc.Bool32(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) < eval(tls, (*Node)(unsafe.Pointer(node)).rhs)))
	case ND_LE:
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty)).is_unsigned != 0 {
			return int64_t(libc.Bool32(uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).lhs)) <= uint64_t(eval(tls, (*Node)(unsafe.Pointer(node)).rhs))))
		}
		return int64_t(libc.Bool32(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) <= eval(tls, (*Node)(unsafe.Pointer(node)).rhs)))
	case ND_COND:
		if eval(tls, (*Node)(unsafe.Pointer(node)).cond) != 0 {
			return eval2(tls, (*Node)(unsafe.Pointer(node)).then, label)
		}
		return eval2(tls, (*Node)(unsafe.Pointer(node)).els, label)
	case ND_COMMA:
		return eval2(tls, (*Node)(unsafe.Pointer(node)).rhs, label)
	case ND_NOT:
		return libc.BoolInt64(!(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) != 0))
	case ND_BITNOT:
		return ^eval(tls, (*Node)(unsafe.Pointer(node)).lhs)
	case ND_LOGAND:
		return int64_t(libc.Bool32(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) != 0 && eval(tls, (*Node)(unsafe.Pointer(node)).rhs) != 0))
	case ND_LOGOR:
		return int64_t(libc.Bool32(eval(tls, (*Node)(unsafe.Pointer(node)).lhs) != 0 || eval(tls, (*Node)(unsafe.Pointer(node)).rhs) != 0))
	case ND_CAST:
		{
			var val int64_t = eval2(tls, (*Node)(unsafe.Pointer(node)).lhs, label)
			if is_integer(tls, (*Node)(unsafe.Pointer(node)).ty) != 0 {
				switch (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).size {
				case 1:
					if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 {
						return int64(uint8_t(val))
					}
					return int64(int8_t(val))
					fallthrough
				case 2:
					if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 {
						return int64(uint16_t(val))
					}
					return int64(int16_t(val))
					fallthrough
				case 4:
					if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 {
						return int64(uint32_t(val))
					}
					return int64(int32_t(val))
				}
			}
			return val

		}
	case ND_ADDR:
		return eval_rval(tls, (*Node)(unsafe.Pointer(node)).lhs, label)
	case ND_LABEL_VAL:
		*(*uintptr)(unsafe.Pointer(label)) = node + 160
		return int64(0)
	case ND_MEMBER:
		if !(label != 0) {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9433, 0)
		}
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind != TY_ARRAY {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9461, 0)
		}
		return eval_rval(tls, (*Node)(unsafe.Pointer(node)).lhs, label) + int64_t((*Member)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).member)).offset)
	case ND_VAR:
		if !(label != 0) {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9433, 0)
		}
		if (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).__var)).ty)).kind != TY_ARRAY && (*Type)(unsafe.Pointer((*Obj)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).__var)).ty)).kind != TY_FUNC {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9461, 0)
		}
		*(*uintptr)(unsafe.Pointer(label)) = (*Node)(unsafe.Pointer(node)).__var + 8
		return int64(0)
	case ND_NUM:
		return (*Node)(unsafe.Pointer(node)).val
	}

	error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9433, 0)
	return int64_t(0)
}

func eval_rval(tls *libc.TLS, node uintptr, label uintptr) int64_t { /* parse.c:1934:16: */
	switch (*Node)(unsafe.Pointer(node)).kind {
	case ND_VAR:
		if (*Obj)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).__var)).is_local != 0 {
			error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9433, 0)
		}
		*(*uintptr)(unsafe.Pointer(label)) = (*Node)(unsafe.Pointer(node)).__var + 8
		return int64(0)
	case ND_DEREF:
		return eval2(tls, (*Node)(unsafe.Pointer(node)).lhs, label)
	case ND_MEMBER:
		return eval_rval(tls, (*Node)(unsafe.Pointer(node)).lhs, label) + int64_t((*Member)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).member)).offset)
	}

	error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9461, 0)
	return int64_t(0)
}

func is_const_expr(tls *libc.TLS, node uintptr) uint8 { /* parse.c:1950:13: */
	add_type(tls, node)

	switch (*Node)(unsafe.Pointer(node)).kind {
	case ND_ADD:
		fallthrough
	case ND_SUB:
		fallthrough
	case ND_MUL:
		fallthrough
	case ND_DIV:
		fallthrough
	case ND_BITAND:
		fallthrough
	case ND_BITOR:
		fallthrough
	case ND_BITXOR:
		fallthrough
	case ND_SHL:
		fallthrough
	case ND_SHR:
		fallthrough
	case ND_EQ:
		fallthrough
	case ND_NE:
		fallthrough
	case ND_LT:
		fallthrough
	case ND_LE:
		fallthrough
	case ND_LOGAND:
		fallthrough
	case ND_LOGOR:
		return uint8(libc.Bool32(is_const_expr(tls, (*Node)(unsafe.Pointer(node)).lhs) != 0 && is_const_expr(tls, (*Node)(unsafe.Pointer(node)).rhs) != 0))
	case ND_COND:
		if !(is_const_expr(tls, (*Node)(unsafe.Pointer(node)).cond) != 0) {
			return uint8(0)
		}
		return is_const_expr(tls, func() uintptr {
			if eval(tls, (*Node)(unsafe.Pointer(node)).cond) != 0 {
				return (*Node)(unsafe.Pointer(node)).then
			}
			return (*Node)(unsafe.Pointer(node)).els
		}())
	case ND_COMMA:
		return is_const_expr(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_NEG:
		fallthrough
	case ND_NOT:
		fallthrough
	case ND_BITNOT:
		fallthrough
	case ND_CAST:
		return is_const_expr(tls, (*Node)(unsafe.Pointer(node)).lhs)
	case ND_NUM:
		return uint8(1)
	}

	return uint8(0)
}

func const_expr(tls *libc.TLS, rest uintptr, tok uintptr) int64_t { /* parse.c:1988:9: */
	var node uintptr = conditional(tls, rest, tok)
	return eval(tls, node)
}

func eval_double(tls *libc.TLS, node uintptr) float64 { /* parse.c:1993:15: */
	add_type(tls, node)

	if is_integer(tls, (*Node)(unsafe.Pointer(node)).ty) != 0 {
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).is_unsigned != 0 {
			return float64(uint64(eval(tls, node)))
		}
		return float64(eval(tls, node))
	}

	switch (*Node)(unsafe.Pointer(node)).kind {
	case ND_ADD:
		return eval_double(tls, (*Node)(unsafe.Pointer(node)).lhs) + eval_double(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_SUB:
		return eval_double(tls, (*Node)(unsafe.Pointer(node)).lhs) - eval_double(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_MUL:
		return eval_double(tls, (*Node)(unsafe.Pointer(node)).lhs) * eval_double(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_DIV:
		return eval_double(tls, (*Node)(unsafe.Pointer(node)).lhs) / eval_double(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_NEG:
		return -eval_double(tls, (*Node)(unsafe.Pointer(node)).lhs)
	case ND_COND:
		if eval_double(tls, (*Node)(unsafe.Pointer(node)).cond) != 0 {
			return eval_double(tls, (*Node)(unsafe.Pointer(node)).then)
		}
		return eval_double(tls, (*Node)(unsafe.Pointer(node)).els)
	case ND_COMMA:
		return eval_double(tls, (*Node)(unsafe.Pointer(node)).rhs)
	case ND_CAST:
		if is_flonum(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).lhs)).ty) != 0 {
			return eval_double(tls, (*Node)(unsafe.Pointer(node)).lhs)
		}
		return float64(eval(tls, (*Node)(unsafe.Pointer(node)).lhs))
	case ND_NUM:
		return (*Node)(unsafe.Pointer(node)).fval
	}

	error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9433, 0)
	return float64(0)
}

// Convert op= operators to expressions containing an assignment.
//
// In general, `A op= C` is converted to âtmp = &A, *tmp = *tmp op B`.
// However, if a given expression is of form `A.x op= C`, the input is
// converted to `tmp = &A, (*tmp).x = (*tmp).x op C` to handle assignments
// to bitfields.
func to_assign(tls *libc.TLS, binary uintptr) uintptr { /* parse.c:2034:13: */
	bp := tls.Alloc(280)
	defer tls.Free(280)

	add_type(tls, (*Node)(unsafe.Pointer(binary)).lhs)
	add_type(tls, (*Node)(unsafe.Pointer(binary)).rhs)
	var tok uintptr = (*Node)(unsafe.Pointer(binary)).tok

	// Convert `A.x op= C` to `tmp = &A, (*tmp).x = (*tmp).x op C`.
	if (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).kind == ND_MEMBER {
		var var1 uintptr = new_lvar(tls, ts+8912, pointer_to(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).lhs)).ty))

		var expr1 uintptr = new_binary(tls, ND_ASSIGN, new_var_node(tls, var1, tok),
			new_unary(tls, ND_ADDR, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).lhs, tok), tok)

		var expr2 uintptr = new_unary(tls, ND_MEMBER,
			new_unary(tls, ND_DEREF, new_var_node(tls, var1, tok), tok),
			tok)
		(*Node)(unsafe.Pointer(expr2)).member = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).member

		var expr3 uintptr = new_unary(tls, ND_MEMBER,
			new_unary(tls, ND_DEREF, new_var_node(tls, var1, tok), tok),
			tok)
		(*Node)(unsafe.Pointer(expr3)).member = (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).member

		var expr4 uintptr = new_binary(tls, ND_ASSIGN, expr2,
			new_binary(tls, (*Node)(unsafe.Pointer(binary)).kind, expr3, (*Node)(unsafe.Pointer(binary)).rhs, tok),
			tok)

		return new_binary(tls, ND_COMMA, expr1, expr4, tok)
	}

	// If A is an atomic type, Convert `A op= B` to
	//
	// ({
	//   T1 *addr = &A; T2 val = (B); T1 old = *addr; T1 new;
	//   do {
	//    new = old op val;
	//   } while (!atomic_compare_exchange_strong(addr, &old, new));
	//   new;
	// })
	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).ty)).is_atomic != 0 {
		*(*Node)(unsafe.Pointer(bp /* head */)) = Node{}
		var cur uintptr = bp /* &head */

		var addr uintptr = new_lvar(tls, ts+8912, pointer_to(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).ty))
		var val uintptr = new_lvar(tls, ts+8912, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).rhs)).ty)
		var old uintptr = new_lvar(tls, ts+8912, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).ty)
		var new uintptr = new_lvar(tls, ts+8912, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).ty)

		cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT,
			new_binary(tls, ND_ASSIGN, new_var_node(tls, addr, tok),
				new_unary(tls, ND_ADDR, (*Node)(unsafe.Pointer(binary)).lhs, tok), tok),
			tok))

		cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT,
			new_binary(tls, ND_ASSIGN, new_var_node(tls, val, tok), (*Node)(unsafe.Pointer(binary)).rhs, tok),
			tok))

		cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT,
			new_binary(tls, ND_ASSIGN, new_var_node(tls, old, tok),
				new_unary(tls, ND_DEREF, new_var_node(tls, addr, tok), tok), tok),
			tok))

		var loop uintptr = new_node(tls, ND_DO, tok)
		(*Node)(unsafe.Pointer(loop)).brk_label = new_unique_name(tls)
		(*Node)(unsafe.Pointer(loop)).cont_label = new_unique_name(tls)

		var body uintptr = new_binary(tls, ND_ASSIGN,
			new_var_node(tls, new, tok),
			new_binary(tls, (*Node)(unsafe.Pointer(binary)).kind, new_var_node(tls, old, tok),
				new_var_node(tls, val, tok), tok),
			tok)

		(*Node)(unsafe.Pointer(loop)).then = new_node(tls, ND_BLOCK, tok)
		(*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(loop)).then)).body = new_unary(tls, ND_EXPR_STMT, body, tok)

		var cas uintptr = new_node(tls, ND_CAS, tok)
		(*Node)(unsafe.Pointer(cas)).cas_addr = new_var_node(tls, addr, tok)
		(*Node)(unsafe.Pointer(cas)).cas_old = new_unary(tls, ND_ADDR, new_var_node(tls, old, tok), tok)
		(*Node)(unsafe.Pointer(cas)).cas_new = new_var_node(tls, new, tok)
		(*Node)(unsafe.Pointer(loop)).cond = new_unary(tls, ND_NOT, cas, tok)

		cur = libc.AssignPtrUintptr(cur+8, loop)
		cur = libc.AssignPtrUintptr(cur+8, new_unary(tls, ND_EXPR_STMT, new_var_node(tls, new, tok), tok))

		var node uintptr = new_node(tls, ND_STMT_EXPR, tok)
		(*Node)(unsafe.Pointer(node)).body = (*Node)(unsafe.Pointer(bp /* &head */)).next
		return node
	}

	// Convert `A op= B` to ``tmp = &A, *tmp = *tmp op B`.
	var var1 uintptr = new_lvar(tls, ts+8912, pointer_to(tls, (*Node)(unsafe.Pointer((*Node)(unsafe.Pointer(binary)).lhs)).ty))

	var expr1 uintptr = new_binary(tls, ND_ASSIGN, new_var_node(tls, var1, tok),
		new_unary(tls, ND_ADDR, (*Node)(unsafe.Pointer(binary)).lhs, tok), tok)

	var expr2 uintptr = new_binary(tls, ND_ASSIGN,
		new_unary(tls, ND_DEREF, new_var_node(tls, var1, tok), tok),
		new_binary(tls, (*Node)(unsafe.Pointer(binary)).kind,
			new_unary(tls, ND_DEREF, new_var_node(tls, var1, tok), tok),
			(*Node)(unsafe.Pointer(binary)).rhs,
			tok),
		tok)

	return new_binary(tls, ND_COMMA, expr1, expr2, tok)
}

// assign    = conditional (assign-op assign)?
// assign-op = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^="
//
//	| "<<=" | ">>="
func assign(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2146:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = conditional(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8910) != 0 {
		return new_binary(tls, ND_ASSIGN, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9481) != 0 {
		return to_assign(tls, new_add(tls, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9484) != 0 {
		return to_assign(tls, new_sub(tls, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9487) != 0 {
		return to_assign(tls, new_binary(tls, ND_MUL, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9490) != 0 {
		return to_assign(tls, new_binary(tls, ND_DIV, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9493) != 0 {
		return to_assign(tls, new_binary(tls, ND_MOD, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9496) != 0 {
		return to_assign(tls, new_binary(tls, ND_BITAND, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9499) != 0 {
		return to_assign(tls, new_binary(tls, ND_BITOR, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9502) != 0 {
		return to_assign(tls, new_binary(tls, ND_BITXOR, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9505) != 0 {
		return to_assign(tls, new_binary(tls, ND_SHL, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9509) != 0 {
		return to_assign(tls, new_binary(tls, ND_SHR, node, assign(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}

	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

// conditional = logor ("?" expr? ":" conditional)?
func conditional(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2187:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var cond uintptr = logor(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	if !(equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9513) != 0) {
		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return cond
	}

	if equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+9345) != 0 {
		// [GNU] Compile `a ?: b` as `tmp = a, tmp ? tmp : b`.
		add_type(tls, cond)
		var var1 uintptr = new_lvar(tls, ts+8912, (*Node)(unsafe.Pointer(cond)).ty)
		var lhs uintptr = new_binary(tls, ND_ASSIGN, new_var_node(tls, var1, *(*uintptr)(unsafe.Pointer(bp /* tok */))), cond, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		var rhs uintptr = new_node(tls, ND_COND, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(rhs)).cond = new_var_node(tls, var1, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(rhs)).then = new_var_node(tls, var1, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(rhs)).els = conditional(tls, rest, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next)
		return new_binary(tls, ND_COMMA, lhs, rhs, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	var node uintptr = new_node(tls, ND_COND, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	(*Node)(unsafe.Pointer(node)).cond = cond
	(*Node)(unsafe.Pointer(node)).then = expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9345)
	(*Node)(unsafe.Pointer(node)).els = conditional(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	return node
}

// logor = logand ("||" logand)*
func logor(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2216:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = logand(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9515) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		node = new_binary(tls, ND_LOGOR, node, logand(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

// logand = bitor ("&&" bitor)*
func logand(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2227:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = bitor(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9518) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		node = new_binary(tls, ND_LOGAND, node, bitor(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

// bitor = bitxor ("|" bitxor)*
func bitor(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2238:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = bitxor(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9521) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		node = new_binary(tls, ND_BITOR, node, bitxor(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

// bitxor = bitand ("^" bitand)*
func bitxor(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2249:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = bitand(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9523) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		node = new_binary(tls, ND_BITXOR, node, bitand(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

// bitand = equality ("&" equality)*
func bitand(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2260:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = equality(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	for equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9525) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		node = new_binary(tls, ND_BITAND, node, equality(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
	}
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	return node
}

// equality = relational ("==" relational | "!=" relational)*
func equality(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2271:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = relational(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	for {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9527) != 0 {
			node = new_binary(tls, ND_EQ, node, relational(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9530) != 0 {
			node = new_binary(tls, ND_NE, node, relational(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}
	return uintptr(0)
}

// relational = shift ("<" shift | "<=" shift | ">" shift | ">=" shift)*
func relational(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2293:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = shift(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	for {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9533) != 0 {
			node = new_binary(tls, ND_LT, node, shift(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9535) != 0 {
			node = new_binary(tls, ND_LE, node, shift(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9538) != 0 {
			node = new_binary(tls, ND_LT, shift(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), node, start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9540) != 0 {
			node = new_binary(tls, ND_LE, shift(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), node, start)
			continue
		}

		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}
	return uintptr(0)
}

// shift = add ("<<" add | ">>" add)*
func shift(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2325:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = add(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	for {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9543) != 0 {
			node = new_binary(tls, ND_SHL, node, add(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9546) != 0 {
			node = new_binary(tls, ND_SHR, node, add(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}
	return uintptr(0)
}

// In C, `+` operator is overloaded to perform the pointer arithmetic.
// If p is a pointer, p+n adds not n but sizeof(*p)*n to the value of p,
// so that p+n points to the location n elements (not bytes) ahead of p.
// In other words, we need to scale an integer value before adding to a
// pointer value. This function takes care of the scaling.
func new_add(tls *libc.TLS, lhs uintptr, rhs uintptr, tok uintptr) uintptr { /* parse.c:2351:13: */
	add_type(tls, lhs)
	add_type(tls, rhs)

	// num + num
	if is_numeric(tls, (*Node)(unsafe.Pointer(lhs)).ty) != 0 && is_numeric(tls, (*Node)(unsafe.Pointer(rhs)).ty) != 0 {
		return new_binary(tls, ND_ADD, lhs, rhs, tok)
	}

	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base != 0 && (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(rhs)).ty)).base != 0 {
		error_tok(tls, tok, ts+9549, 0)
	}

	// Canonicalize `num + ptr` to `ptr + num`.
	if !(int32((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base) != 0) && (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(rhs)).ty)).base != 0 {
		var tmp uintptr = lhs
		lhs = rhs
		rhs = tmp
	}

	// VLA + num
	if (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).kind == TY_VLA {
		rhs = new_binary(tls, ND_MUL, rhs, new_var_node(tls, (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).vla_size, tok), tok)
		return new_binary(tls, ND_ADD, lhs, rhs, tok)
	}

	// ptr + num
	rhs = new_binary(tls, ND_MUL, rhs, new_long(tls, int64((*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).size), tok), tok)
	return new_binary(tls, ND_ADD, lhs, rhs, tok)
}

// Like `+`, `-` is overloaded for the pointer type.
func new_sub(tls *libc.TLS, lhs uintptr, rhs uintptr, tok uintptr) uintptr { /* parse.c:2381:13: */
	add_type(tls, lhs)
	add_type(tls, rhs)

	// num - num
	if is_numeric(tls, (*Node)(unsafe.Pointer(lhs)).ty) != 0 && is_numeric(tls, (*Node)(unsafe.Pointer(rhs)).ty) != 0 {
		return new_binary(tls, ND_SUB, lhs, rhs, tok)
	}

	// VLA + num
	if (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).kind == TY_VLA {
		rhs = new_binary(tls, ND_MUL, rhs, new_var_node(tls, (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).vla_size, tok), tok)
		add_type(tls, rhs)
		var node uintptr = new_binary(tls, ND_SUB, lhs, rhs, tok)
		(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer(lhs)).ty
		return node
	}

	// ptr - num
	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base != 0 && is_integer(tls, (*Node)(unsafe.Pointer(rhs)).ty) != 0 {
		rhs = new_binary(tls, ND_MUL, rhs, new_long(tls, int64((*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).size), tok), tok)
		add_type(tls, rhs)
		var node uintptr = new_binary(tls, ND_SUB, lhs, rhs, tok)
		(*Node)(unsafe.Pointer(node)).ty = (*Node)(unsafe.Pointer(lhs)).ty
		return node
	}

	// ptr - ptr, which returns how many elements are between the two.
	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base != 0 && (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(rhs)).ty)).base != 0 {
		var node uintptr = new_binary(tls, ND_SUB, lhs, rhs, tok)
		(*Node)(unsafe.Pointer(node)).ty = ty_long
		return new_binary(tls, ND_DIV, node, new_num(tls, int64((*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).ty)).base)).size), tok), tok)
	}

	error_tok(tls, tok, ts+9549, 0)
	return uintptr(0)
}

// add = mul ("+" mul | "-" mul)*
func add(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2418:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = mul(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	for {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9566) != 0 {
			node = new_add(tls, node, mul(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+7457) != 0 {
			node = new_sub(tls, node, mul(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}
	return uintptr(0)
}

// mul = cast ("*" cast | "/" cast | "%" cast)*
func mul(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2440:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var node uintptr = cast1(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	for {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8870) != 0 {
			node = new_binary(tls, ND_MUL, node, cast1(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6710) != 0 {
			node = new_binary(tls, ND_DIV, node, cast1(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9568) != 0 {
			node = new_binary(tls, ND_MOD, node, cast1(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next), start)
			continue
		}

		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}
	return uintptr(0)
}

// cast = "(" type-name ")" cast | unary
func cast1(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2467:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 && is_typename(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next) != 0 {
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		var ty uintptr = typename(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		// compound literal
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0 {
			return unary(tls, rest, start)
		}

		// type cast
		var node uintptr = new_cast(tls, cast1(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */))), ty)
		(*Node)(unsafe.Pointer(node)).tok = start
		return node
	}

	return unary(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
}

// unary = ("+" | "-" | "*" | "&" | "!" | "~") cast
//
//	| ("++" | "--") unary
//	| "&&" ident
//	| postfix
func unary(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2490:13: */
	if equal(tls, tok, ts+9566) != 0 {
		return cast1(tls, rest, (*Token)(unsafe.Pointer(tok)).next)
	}

	if equal(tls, tok, ts+7457) != 0 {
		return new_unary(tls, ND_NEG, cast1(tls, rest, (*Token)(unsafe.Pointer(tok)).next), tok)
	}

	if equal(tls, tok, ts+9525) != 0 {
		var lhs uintptr = cast1(tls, rest, (*Token)(unsafe.Pointer(tok)).next)
		add_type(tls, lhs)
		if (*Node)(unsafe.Pointer(lhs)).kind == ND_MEMBER && (*Member)(unsafe.Pointer((*Node)(unsafe.Pointer(lhs)).member)).is_bitfield != 0 {
			error_tok(tls, tok, ts+9570, 0)
		}
		return new_unary(tls, ND_ADDR, lhs, tok)
	}

	if equal(tls, tok, ts+8870) != 0 {
		// [https://www.sigbus.info/n1570#6.5.3.2p4] This is an oddity
		// in the C spec, but dereferencing a function shouldn't do
		// anything. If foo is a function, `*foo`, `**foo` or `*****foo`
		// are all equivalent to just `foo`.
		var node uintptr = cast1(tls, rest, (*Token)(unsafe.Pointer(tok)).next)
		add_type(tls, node)
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind == TY_FUNC {
			return node
		}
		return new_unary(tls, ND_DEREF, node, tok)
	}

	if equal(tls, tok, ts+9602) != 0 {
		return new_unary(tls, ND_NOT, cast1(tls, rest, (*Token)(unsafe.Pointer(tok)).next), tok)
	}

	if equal(tls, tok, ts+9604) != 0 {
		return new_unary(tls, ND_BITNOT, cast1(tls, rest, (*Token)(unsafe.Pointer(tok)).next), tok)
	}

	// Read ++i as i+=1
	if equal(tls, tok, ts+9606) != 0 {
		return to_assign(tls, new_add(tls, unary(tls, rest, (*Token)(unsafe.Pointer(tok)).next), new_num(tls, int64(1), tok), tok))
	}

	// Read --i as i-=1
	if equal(tls, tok, ts+9609) != 0 {
		return to_assign(tls, new_sub(tls, unary(tls, rest, (*Token)(unsafe.Pointer(tok)).next), new_num(tls, int64(1), tok), tok))
	}

	// [GNU] labels-as-values
	if equal(tls, tok, ts+9518) != 0 {
		var node uintptr = new_node(tls, ND_LABEL_VAL, tok)
		(*Node)(unsafe.Pointer(node)).label = get_ident(tls, (*Token)(unsafe.Pointer(tok)).next)
		(*Node)(unsafe.Pointer(node)).goto_next = gotos
		gotos = node
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next
		return node
	}

	return postfix(tls, rest, tok)
}

// struct-members = (declspec declarator (","  declarator)* ";")*
func struct_members(tls *libc.TLS, rest uintptr, tok uintptr, ty uintptr) { /* parse.c:2545:13: */
	bp := tls.Alloc(76)
	defer tls.Free(76)
	*(*uintptr)(unsafe.Pointer(bp + 56)) = tok

	*(*Member)(unsafe.Pointer(bp /* head */)) = Member{}
	var cur uintptr = bp /* &head */
	var idx int32 = 0

	for !(equal(tls, *(*uintptr)(unsafe.Pointer(bp + 56)), ts+8872) != 0) {
		*(*VarAttr)(unsafe.Pointer(bp + 64 /* attr */)) = VarAttr{}
		var basety uintptr = declspec(tls, bp+56, *(*uintptr)(unsafe.Pointer(bp + 56 /* tok */)), bp+64)
		var first uint8 = uint8(1)

		// Anonymous struct member
		if ((*Type)(unsafe.Pointer(basety)).kind == TY_STRUCT || (*Type)(unsafe.Pointer(basety)).kind == TY_UNION) && consume(tls, bp+56, *(*uintptr)(unsafe.Pointer(bp + 56)), ts+8913) != 0 {
			var mem uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Member{})))
			(*Member)(unsafe.Pointer(mem)).ty = basety
			(*Member)(unsafe.Pointer(mem)).idx = libc.PostIncInt32(&idx, 1)
			(*Member)(unsafe.Pointer(mem)).align = func() int32 {
				if (*VarAttr)(unsafe.Pointer(bp+64)).align != 0 {
					return (*VarAttr)(unsafe.Pointer(bp + 64 /* &attr */)).align
				}
				return (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).align
			}()
			cur = libc.AssignPtrUintptr(cur, mem)
			continue
		}

		// Regular struct members
		for !(consume(tls, bp+56, *(*uintptr)(unsafe.Pointer(bp + 56)), ts+8913) != 0) {
			if !(first != 0) {
				*(*uintptr)(unsafe.Pointer(bp + 56 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* tok */)), ts+8368)
			}
			first = uint8(0)

			var mem uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Member{})))
			(*Member)(unsafe.Pointer(mem)).ty = declarator(tls, bp+56, *(*uintptr)(unsafe.Pointer(bp + 56 /* tok */)), basety)
			(*Member)(unsafe.Pointer(mem)).name = (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).name
			(*Member)(unsafe.Pointer(mem)).idx = libc.PostIncInt32(&idx, 1)
			(*Member)(unsafe.Pointer(mem)).align = func() int32 {
				if (*VarAttr)(unsafe.Pointer(bp+64)).align != 0 {
					return (*VarAttr)(unsafe.Pointer(bp + 64 /* &attr */)).align
				}
				return (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).align
			}()

			if consume(tls, bp+56, *(*uintptr)(unsafe.Pointer(bp + 56)), ts+9345) != 0 {
				(*Member)(unsafe.Pointer(mem)).is_bitfield = uint8(1)
				(*Member)(unsafe.Pointer(mem)).bit_width = int32(const_expr(tls, bp+56, *(*uintptr)(unsafe.Pointer(bp + 56 /* tok */))))
			}

			cur = libc.AssignPtrUintptr(cur, mem)
		}
	}

	// If the last element is an array of incomplete type, it's
	// called a "flexible array member". It should behave as if
	// if were a zero-sized array.
	if cur != bp && (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(cur)).ty)).kind == TY_ARRAY && (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(cur)).ty)).array_len < 0 {
		(*Member)(unsafe.Pointer(cur)).ty = array_of(tls, (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(cur)).ty)).base, 0)
		(*Type)(unsafe.Pointer(ty)).is_flexible = uint8(1)
	}

	*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 56 /* tok */)))).next
	(*Type)(unsafe.Pointer(ty)).members = (*Member)(unsafe.Pointer(bp /* &head */)).next
}

// attribute = ("__attribute__" "(" "(" "packed" ")" ")")*
func attribute_list(tls *libc.TLS, tok uintptr, ty uintptr) uintptr { /* parse.c:2600:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	for consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+9612) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8703)
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8703)

		var first uint8 = uint8(1)

		for !(consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+8705) != 0) {
			if !(first != 0) {
				*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
			}
			first = uint8(0)

			if consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+9626) != 0 {
				(*Type)(unsafe.Pointer(ty)).is_packed = uint8(1)
				continue
			}

			if consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+9633) != 0 {
				*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8703)
				(*Type)(unsafe.Pointer(ty)).align = int32(const_expr(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */))))
				*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
				continue
			}

			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9641, 0)
		}

		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
	}

	return *(*uintptr)(unsafe.Pointer(bp /* tok */))
}

// struct-union-decl = attribute? ident? ("{" struct-members)?
func struct_union_decl(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2634:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var ty uintptr = struct_type(tls)
	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = attribute_list(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)

	// Read a tag.
	var tag uintptr = uintptr(0)
	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_IDENT {
		tag = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
	}

	if tag != 0 && !(equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8874) != 0) {
		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))

		var ty2 uintptr = find_tag(tls, tag)
		if ty2 != 0 {
			return ty2
		}

		(*Type)(unsafe.Pointer(ty)).size = -1
		push_tag_scope(tls, tag, ty)
		return ty
	}

	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8874)

	// Construct a struct object.
	struct_members(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)
	*(*uintptr)(unsafe.Pointer(rest)) = attribute_list(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ty)

	if tag != 0 {
		// If this is a redefinition, overwrite a previous type.
		// Otherwise, register the struct type.
		var ty2 uintptr = hashmap_get2(tls, scope+24, (*Token)(unsafe.Pointer(tag)).loc, (*Token)(unsafe.Pointer(tag)).len)
		if ty2 != 0 {
			*(*Type)(unsafe.Pointer(ty2)) = *(*Type)(unsafe.Pointer(ty))
			return ty2
		}

		push_tag_scope(tls, tag, ty)
	}

	return ty
}

// struct-decl = struct-union-decl
func struct_decl(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2679:13: */
	var ty uintptr = struct_union_decl(tls, rest, tok)
	(*Type)(unsafe.Pointer(ty)).kind = TY_STRUCT

	if (*Type)(unsafe.Pointer(ty)).size < 0 {
		return ty
	}

	// Assign offsets within the struct to members.
	var bits int32 = 0

	{
		var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
		for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
			if (*Member)(unsafe.Pointer(mem)).is_bitfield != 0 && (*Member)(unsafe.Pointer(mem)).bit_width == 0 {
				// Zero-width anonymous bitfield has a special meaning.
				// It affects only alignment.
				bits = align_to(tls, bits, (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size*8)
			} else if (*Member)(unsafe.Pointer(mem)).is_bitfield != 0 {
				var sz int32 = (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size
				if bits/(sz*8) != (bits+(*Member)(unsafe.Pointer(mem)).bit_width-1)/(sz*8) {
					bits = align_to(tls, bits, sz*8)
				}

				(*Member)(unsafe.Pointer(mem)).offset = align_down(tls, bits/8, sz)
				(*Member)(unsafe.Pointer(mem)).bit_offset = bits % (sz * 8)
				bits = bits + (*Member)(unsafe.Pointer(mem)).bit_width
			} else {
				if !(int32((*Type)(unsafe.Pointer(ty)).is_packed) != 0) {
					bits = align_to(tls, bits, (*Member)(unsafe.Pointer(mem)).align*8)
				}
				(*Member)(unsafe.Pointer(mem)).offset = bits / 8
				bits = bits + (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size*8
			}

			if !(int32((*Type)(unsafe.Pointer(ty)).is_packed) != 0) && (*Type)(unsafe.Pointer(ty)).align < (*Member)(unsafe.Pointer(mem)).align {
				(*Type)(unsafe.Pointer(ty)).align = (*Member)(unsafe.Pointer(mem)).align
			}
		}
	}

	(*Type)(unsafe.Pointer(ty)).size = align_to(tls, bits, (*Type)(unsafe.Pointer(ty)).align*8) / 8
	return ty
}

// union-decl = struct-union-decl
func union_decl(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2718:13: */
	var ty uintptr = struct_union_decl(tls, rest, tok)
	(*Type)(unsafe.Pointer(ty)).kind = TY_UNION

	if (*Type)(unsafe.Pointer(ty)).size < 0 {
		return ty
	}

	// If union, we don't have to assign offsets because they
	// are already initialized to zero. We need to compute the
	// alignment and the size though.
	{
		var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
		for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
			if (*Type)(unsafe.Pointer(ty)).align < (*Member)(unsafe.Pointer(mem)).align {
				(*Type)(unsafe.Pointer(ty)).align = (*Member)(unsafe.Pointer(mem)).align
			}
			if (*Type)(unsafe.Pointer(ty)).size < (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size {
				(*Type)(unsafe.Pointer(ty)).size = (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).size
			}
		}
	}
	(*Type)(unsafe.Pointer(ty)).size = align_to(tls, (*Type)(unsafe.Pointer(ty)).size, (*Type)(unsafe.Pointer(ty)).align)
	return ty
}

// Find a struct member by name.
func get_struct_member(tls *libc.TLS, ty uintptr, tok uintptr) uintptr { /* parse.c:2739:15: */
	{
		var mem uintptr = (*Type)(unsafe.Pointer(ty)).members
		for ; mem != 0; mem = (*Member)(unsafe.Pointer(mem)).next {
			// Anonymous struct member
			if ((*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).kind == TY_STRUCT || (*Type)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).ty)).kind == TY_UNION) && !(int32((*Member)(unsafe.Pointer(mem)).name) != 0) {
				if get_struct_member(tls, (*Member)(unsafe.Pointer(mem)).ty, tok) != 0 {
					return mem
				}
				continue
			}

			// Regular struct member
			if (*Token)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).name)).len == (*Token)(unsafe.Pointer(tok)).len && !(libc.Xstrncmp(tls, (*Token)(unsafe.Pointer((*Member)(unsafe.Pointer(mem)).name)).loc, (*Token)(unsafe.Pointer(tok)).loc, uint64((*Token)(unsafe.Pointer(tok)).len)) != 0) {
				return mem
			}
		}
	}
	return uintptr(0)
}

// Create a node representing a struct member access, such as foo.bar
// where foo is a struct and bar is a member name.
//
// C has a feature called "anonymous struct" which allows a struct to
// have another unnamed struct as a member like this:
//
//	struct { struct { int a; }; int b; } x;
//
// The members of an anonymous struct belong to the outer struct's
// member namespace. Therefore, in the above example, you can access
// member "a" of the anonymous struct as "x.a".
//
// This function takes care of anonymous structs.
func struct_ref(tls *libc.TLS, node uintptr, tok uintptr) uintptr { /* parse.c:2770:13: */
	add_type(tls, node)
	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind != TY_STRUCT && (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind != TY_UNION {
		error_tok(tls, (*Node)(unsafe.Pointer(node)).tok, ts+9659, 0)
	}

	var ty uintptr = (*Node)(unsafe.Pointer(node)).ty

	for {
		var mem uintptr = get_struct_member(tls, ty, tok)
		if !(mem != 0) {
			error_tok(tls, tok, ts+9684, 0)
		}
		node = new_unary(tls, ND_MEMBER, node, tok)
		(*Node)(unsafe.Pointer(node)).member = mem
		if (*Member)(unsafe.Pointer(mem)).name != 0 {
			break
		}
		ty = (*Member)(unsafe.Pointer(mem)).ty
	}
	return node
}

// Convert A++ to `(typeof A)((A += 1) - 1)`
func new_inc_dec(tls *libc.TLS, node uintptr, tok uintptr, addend int32) uintptr { /* parse.c:2791:13: */
	add_type(tls, node)
	return new_cast(tls, new_add(tls, to_assign(tls, new_add(tls, node, new_num(tls, int64(addend), tok), tok)),
		new_num(tls, int64(-addend), tok), tok),
		(*Node)(unsafe.Pointer(node)).ty)
}

// postfix = "(" type-name ")" "{" initializer-list "}"
//
//	= ident "(" func-args ")" postfix-tail*
//	| primary postfix-tail*
//
// postfix-tail = "[" expr "]"
//
//	| "(" func-args ")"
//	| "." ident
//	| "->" ident
//	| "++"
//	| "--"
func postfix(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2808:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 && is_typename(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next) != 0 {
		// Compound literal
		var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		var ty uintptr = typename(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		if (*Scope)(unsafe.Pointer(scope)).next == uintptr(0) {
			var var1 uintptr = new_anon_gvar(tls, ty)
			gvar_initializer(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), var1)
			return new_var_node(tls, var1, start)
		}

		var var1 uintptr = new_lvar(tls, ts+8912, ty)
		var lhs uintptr = lvar_initializer(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */)), var1)
		var rhs uintptr = new_var_node(tls, var1, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		return new_binary(tls, ND_COMMA, lhs, rhs, start)
	}

	var node uintptr = primary(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))

	for {
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 {
			node = funcall(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, node)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8868) != 0 {
			// x[y] is short for *(x+y)
			var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
			var idx uintptr = expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8866)
			node = new_unary(tls, ND_DEREF, new_add(tls, node, idx, start), start)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+6708) != 0 {
			node = struct_ref(tls, node, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9699) != 0 {
			// x->y is short for (*x).y
			node = new_unary(tls, ND_DEREF, node, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			node = struct_ref(tls, node, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9606) != 0 {
			node = new_inc_dec(tls, node, *(*uintptr)(unsafe.Pointer(bp /* tok */)), 1)
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9609) != 0 {
			node = new_inc_dec(tls, node, *(*uintptr)(unsafe.Pointer(bp /* tok */)), -1)
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
			continue
		}

		*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp /* tok */))
		return node
	}
	return uintptr(0)
}

// funcall = (assign ("," assign)*)? ")"
func funcall(tls *libc.TLS, rest uintptr, tok uintptr, fn uintptr) uintptr { /* parse.c:2876:13: */
	bp := tls.Alloc(288)
	defer tls.Free(288)
	*(*uintptr)(unsafe.Pointer(bp + 280)) = tok

	add_type(tls, fn)

	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(fn)).ty)).kind != TY_FUNC && ((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(fn)).ty)).kind != TY_PTR || (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(fn)).ty)).base)).kind != TY_FUNC) {
		error_tok(tls, (*Node)(unsafe.Pointer(fn)).tok, ts+9702, 0)
	}

	var ty uintptr
	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(fn)).ty)).kind == TY_FUNC {
		ty = (*Node)(unsafe.Pointer(fn)).ty
	} else {
		ty = (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(fn)).ty)).base
	}
	var param_ty uintptr = (*Type)(unsafe.Pointer(ty)).params

	*(*Node)(unsafe.Pointer(bp /* head */)) = Node{}
	var cur uintptr = bp /* &head */

	for !(equal(tls, *(*uintptr)(unsafe.Pointer(bp + 280)), ts+8705) != 0) {
		if cur != bp {
			*(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+8368)
		}

		var arg uintptr = assign(tls, bp+280, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))
		add_type(tls, arg)

		if !(param_ty != 0) && !(int32((*Type)(unsafe.Pointer(ty)).is_variadic) != 0) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+9717, 0)
		}

		if param_ty != 0 {
			if (*Type)(unsafe.Pointer(param_ty)).kind != TY_STRUCT && (*Type)(unsafe.Pointer(param_ty)).kind != TY_UNION {
				arg = new_cast(tls, arg, param_ty)
			}
			param_ty = (*Type)(unsafe.Pointer(param_ty)).next
		} else if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(arg)).ty)).kind == TY_FLOAT {
			// If parameter type is omitted (e.g. in "..."), float
			// arguments are promoted to double.
			arg = new_cast(tls, arg, ty_double)
		}

		cur = libc.AssignPtrUintptr(cur+8, arg)
	}

	if param_ty != 0 {
		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+9736, 0)
	}

	*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)), ts+8705)

	var node uintptr = new_unary(tls, ND_FUNCALL, fn, *(*uintptr)(unsafe.Pointer(bp + 280 /* tok */)))
	(*Node)(unsafe.Pointer(node)).func_ty = ty
	(*Node)(unsafe.Pointer(node)).ty = (*Type)(unsafe.Pointer(ty)).return_ty
	(*Node)(unsafe.Pointer(node)).args = (*Node)(unsafe.Pointer(bp /* &head */)).next

	// If a function returns a struct, it is caller's responsibility
	// to allocate a space for the return value.
	if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind == TY_STRUCT || (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind == TY_UNION {
		(*Node)(unsafe.Pointer(node)).ret_buffer = new_lvar(tls, ts+8912, (*Node)(unsafe.Pointer(node)).ty)
	}
	return node
}

// generic-selection = "(" assign "," generic-assoc ("," generic-assoc)* ")"
//
// generic-assoc = type-name ":" assign
//
//	| "default" ":" assign
func generic_selection(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2933:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8703)

	var ctrl uintptr = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	add_type(tls, ctrl)

	var t1 uintptr = (*Node)(unsafe.Pointer(ctrl)).ty
	if (*Type)(unsafe.Pointer(t1)).kind == TY_FUNC {
		t1 = pointer_to(tls, t1)
	} else if (*Type)(unsafe.Pointer(t1)).kind == TY_ARRAY {
		t1 = pointer_to(tls, (*Type)(unsafe.Pointer(t1)).base)
	}

	var ret uintptr = uintptr(0)

	for !(consume(tls, rest, *(*uintptr)(unsafe.Pointer(bp)), ts+8705) != 0) {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9347) != 0 {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+9345)
			var node uintptr = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			if !(ret != 0) {
				ret = node
			}
			continue
		}

		var t2 uintptr = typename(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9345)
		var node uintptr = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		if is_compatible(tls, t1, t2) != 0 {
			ret = node
		}
	}

	if !(ret != 0) {
		error_tok(tls, start,
			ts+9754, 0)
	}
	return ret
}

// primary = "(" "{" stmt+ "}" ")"
//
//	| "(" expr ")"
//	| "sizeof" "(" type-name ")"
//	| "sizeof" unary
//	| "_Alignof" "(" type-name ")"
//	| "_Alignof" unary
//	| "_Generic" generic-selection
//	| "__builtin_types_compatible_p" "(" type-name, type-name, ")"
//	| "__builtin_reg_class" "(" type-name ")"
//	| ident
//	| str
//	| num
func primary(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* parse.c:2984:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var start uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8874) != 0 {
		// This is a GNU statement expresssion.
		var node uintptr = new_node(tls, ND_STMT_EXPR, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Node)(unsafe.Pointer(node)).body = (*Node)(unsafe.Pointer(compound_stmt(tls, bp, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next))).body
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 {
		var node uintptr = expr(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9831) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8703) != 0 && is_typename(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next)).next) != 0 {
		var ty uintptr = typename(tls, bp, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		if (*Type)(unsafe.Pointer(ty)).kind == TY_VLA {
			if (*Type)(unsafe.Pointer(ty)).vla_size != 0 {
				return new_var_node(tls, (*Type)(unsafe.Pointer(ty)).vla_size, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			}

			var lhs uintptr = compute_vla_size(tls, ty, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			var rhs uintptr = new_var_node(tls, (*Type)(unsafe.Pointer(ty)).vla_size, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			return new_binary(tls, ND_COMMA, lhs, rhs, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}

		return new_ulong(tls, int64((*Type)(unsafe.Pointer(ty)).size), start)
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9831) != 0 {
		var node uintptr = unary(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		add_type(tls, node)
		if (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).kind == TY_VLA {
			return new_var_node(tls, (*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).vla_size, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}
		return new_ulong(tls, int64((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).size), *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9838) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8703) != 0 && is_typename(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next)).next) != 0 {
		var ty uintptr = typename(tls, bp, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)).next)
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		return new_ulong(tls, int64((*Type)(unsafe.Pointer(ty)).align), *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9838) != 0 {
		var node uintptr = unary(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		add_type(tls, node)
		return new_ulong(tls, int64((*Type)(unsafe.Pointer((*Node)(unsafe.Pointer(node)).ty)).align), *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9847) != 0 {
		return generic_selection(tls, rest, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9856) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		var t1 uintptr = typename(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		var t2 uintptr = typename(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		return new_num(tls, int64(is_compatible(tls, t1, t2)), start)
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9885) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		var ty uintptr = typename(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)

		if is_integer(tls, ty) != 0 || (*Type)(unsafe.Pointer(ty)).kind == TY_PTR {
			return new_num(tls, int64(0), start)
		}
		if is_flonum(tls, ty) != 0 {
			return new_num(tls, int64(1), start)
		}
		return new_num(tls, int64(2), start)
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9905) != 0 {
		var node uintptr = new_node(tls, ND_CAS, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		(*Node)(unsafe.Pointer(node)).cas_addr = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		(*Node)(unsafe.Pointer(node)).cas_old = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		(*Node)(unsafe.Pointer(node)).cas_new = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		return node
	}

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+9932) != 0 {
		var node uintptr = new_node(tls, ND_EXCH, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, ts+8703)
		(*Node)(unsafe.Pointer(node)).lhs = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		(*Node)(unsafe.Pointer(node)).rhs = assign(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8705)
		return node
	}

	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_IDENT {
		// Variable or enum constant
		var sc uintptr = find_var(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next

		// For "static inline" function
		if sc != 0 && (*VarScope)(unsafe.Pointer(sc)).__var != 0 && (*Obj)(unsafe.Pointer((*VarScope)(unsafe.Pointer(sc)).__var)).is_function != 0 {
			if current_fn1 != 0 {
				strarray_push(tls, current_fn1+128, (*Obj)(unsafe.Pointer((*VarScope)(unsafe.Pointer(sc)).__var)).name)
			} else {
				(*Obj)(unsafe.Pointer((*VarScope)(unsafe.Pointer(sc)).__var)).is_root = uint8(1)
			}
		}

		if sc != 0 {
			if (*VarScope)(unsafe.Pointer(sc)).__var != 0 {
				return new_var_node(tls, (*VarScope)(unsafe.Pointer(sc)).__var, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			}
			if (*VarScope)(unsafe.Pointer(sc)).enum_ty != 0 {
				return new_num(tls, int64((*VarScope)(unsafe.Pointer(sc)).enum_val), *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			}
		}

		if equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8703) != 0 {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9958, 0)
		}
		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+9993, 0)
	}

	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_STR {
		var var1 uintptr = new_string_literal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).str, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).ty)
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
		return new_var_node(tls, var1, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	}

	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind == TK_NUM {
		var node uintptr
		if is_flonum(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).ty) != 0 {
			node = new_node(tls, ND_NUM, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
			(*Node)(unsafe.Pointer(node)).fval = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).fval
		} else {
			node = new_num(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).val, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		}

		(*Node)(unsafe.Pointer(node)).ty = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).ty
		*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
		return node
	}

	error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+10012, 0)
	return uintptr(0)
}

func parse_typedef(tls *libc.TLS, tok uintptr, basety uintptr) uintptr { /* parse.c:3131:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var first uint8 = uint8(1)

	for !(consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+8913) != 0) {
		if !(first != 0) {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}
		first = uint8(0)

		var ty uintptr = declarator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), basety)
		if !(int32((*Type)(unsafe.Pointer(ty)).name) != 0) {
			error_tok(tls, (*Type)(unsafe.Pointer(ty)).name_pos, ts+10035, 0)
		}
		(*VarScope)(unsafe.Pointer(push_scope(tls, get_ident(tls, (*Type)(unsafe.Pointer(ty)).name)))).type_def = ty
	}
	return *(*uintptr)(unsafe.Pointer(bp /* tok */))
}

func create_param_lvars(tls *libc.TLS, param uintptr) { /* parse.c:3147:13: */
	if param != 0 {
		create_param_lvars(tls, (*Type)(unsafe.Pointer(param)).next)
		if !(int32((*Type)(unsafe.Pointer(param)).name) != 0) {
			error_tok(tls, (*Type)(unsafe.Pointer(param)).name_pos, ts+10056, 0)
		}
		new_lvar(tls, get_ident(tls, (*Type)(unsafe.Pointer(param)).name), param)
	}
}

// This function matches gotos or labels-as-values with labels.
//
// We cannot resolve gotos as we parse a function because gotos
// can refer a label that appears later in the function.
// So, we need to do this after we parse the entire function.
func resolve_goto_labels(tls *libc.TLS) { /* parse.c:3161:13: */
	{
		var x uintptr = gotos
		for ; x != 0; x = (*Node)(unsafe.Pointer(x)).goto_next {
			{
				var y uintptr = labels
				for ; y != 0; y = (*Node)(unsafe.Pointer(y)).goto_next {
					if !(libc.Xstrcmp(tls, (*Node)(unsafe.Pointer(x)).label, (*Node)(unsafe.Pointer(y)).label) != 0) {
						(*Node)(unsafe.Pointer(x)).unique_label = (*Node)(unsafe.Pointer(y)).unique_label
						break
					}
				}
			}

			if (*Node)(unsafe.Pointer(x)).unique_label == uintptr(0) {
				error_tok(tls, (*Token)(unsafe.Pointer((*Node)(unsafe.Pointer(x)).tok)).next, ts+10079, 0)
			}
		}
	}

	gotos = libc.AssignPtrUintptr(uintptr(unsafe.Pointer(&labels)), uintptr(0))
}

func find_func(tls *libc.TLS, name uintptr) uintptr { /* parse.c:3177:12: */
	var sc uintptr = scope
	for (*Scope)(unsafe.Pointer(sc)).next != 0 {
		sc = (*Scope)(unsafe.Pointer(sc)).next
	}

	var sc2 uintptr = hashmap_get(tls, sc+8, name)
	if sc2 != 0 && (*VarScope)(unsafe.Pointer(sc2)).__var != 0 && (*Obj)(unsafe.Pointer((*VarScope)(unsafe.Pointer(sc2)).__var)).is_function != 0 {
		return (*VarScope)(unsafe.Pointer(sc2)).__var
	}
	return uintptr(0)
}

func mark_live(tls *libc.TLS, var1 uintptr) { /* parse.c:3188:13: */
	if !(int32((*Obj)(unsafe.Pointer(var1)).is_function) != 0) || (*Obj)(unsafe.Pointer(var1)).is_live != 0 {
		return
	}
	(*Obj)(unsafe.Pointer(var1)).is_live = uint8(1)

	{
		var i int32 = 0
		for ; i < (*Obj)(unsafe.Pointer(var1)).refs.len; i++ {
			var fn uintptr = find_func(tls, *(*uintptr)(unsafe.Pointer((*Obj)(unsafe.Pointer(var1)).refs.data + uintptr(i)*8)))
			if fn != 0 {
				mark_live(tls, fn)
			}
		}
	}
}

func function(tls *libc.TLS, tok uintptr, basety uintptr, attr uintptr) uintptr { /* parse.c:3200:14: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = tok

	var ty uintptr = declarator(tls, bp+8, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)), basety)
	if !(int32((*Type)(unsafe.Pointer(ty)).name) != 0) {
		error_tok(tls, (*Type)(unsafe.Pointer(ty)).name_pos, ts+10103, 0)
	}
	var name_str uintptr = get_ident(tls, (*Type)(unsafe.Pointer(ty)).name)

	var fn uintptr = find_func(tls, name_str)
	if fn != 0 {
		// Redeclaration
		if !(int32((*Obj)(unsafe.Pointer(fn)).is_function) != 0) {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)), ts+10125, 0)
		}
		if (*Obj)(unsafe.Pointer(fn)).is_definition != 0 && equal(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+8874) != 0 {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)), ts+10166, libc.VaList(bp, name_str))
		}
		if !(int32((*Obj)(unsafe.Pointer(fn)).is_static) != 0) && (*VarAttr)(unsafe.Pointer(attr)).is_static != 0 {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)), ts+10185, 0)
		}
		(*Obj)(unsafe.Pointer(fn)).is_definition = uint8(libc.Bool32((*Obj)(unsafe.Pointer(fn)).is_definition != 0 || equal(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+8874) != 0))
	} else {
		fn = new_gvar(tls, name_str, ty)
		(*Obj)(unsafe.Pointer(fn)).is_function = uint8(1)
		(*Obj)(unsafe.Pointer(fn)).is_definition = equal(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)), ts+8874)
		(*Obj)(unsafe.Pointer(fn)).is_static = uint8(libc.Bool32((*VarAttr)(unsafe.Pointer(attr)).is_static != 0 || (*VarAttr)(unsafe.Pointer(attr)).is_inline != 0 && !(int32((*VarAttr)(unsafe.Pointer(attr)).is_extern) != 0)))
		(*Obj)(unsafe.Pointer(fn)).is_inline = (*VarAttr)(unsafe.Pointer(attr)).is_inline
	}

	(*Obj)(unsafe.Pointer(fn)).is_root = libc.BoolUint8(!((*Obj)(unsafe.Pointer(fn)).is_static != 0 && (*Obj)(unsafe.Pointer(fn)).is_inline != 0))

	if consume(tls, bp+8, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+8913) != 0 {
		return *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */))
	}

	current_fn1 = fn
	locals = uintptr(0)
	enter_scope(tls)
	create_param_lvars(tls, (*Type)(unsafe.Pointer(ty)).params)

	// A buffer for a struct/union return value is passed
	// as the hidden first parameter.
	var rty uintptr = (*Type)(unsafe.Pointer(ty)).return_ty
	if ((*Type)(unsafe.Pointer(rty)).kind == TY_STRUCT || (*Type)(unsafe.Pointer(rty)).kind == TY_UNION) && (*Type)(unsafe.Pointer(rty)).size > 16 {
		new_lvar(tls, ts+8912, pointer_to(tls, rty))
	}

	(*Obj)(unsafe.Pointer(fn)).params = locals

	if (*Type)(unsafe.Pointer(ty)).is_variadic != 0 {
		(*Obj)(unsafe.Pointer(fn)).va_area = new_lvar(tls, ts+10237, array_of(tls, ty_char, 136))
	}
	(*Obj)(unsafe.Pointer(fn)).alloca_bottom = new_lvar(tls, ts+10249, pointer_to(tls, ty_char))

	*(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)), ts+8874)

	// [https://www.sigbus.info/n1570#6.4.2.2p1] "__func__" is
	// automatically defined as a local variable containing the
	// current function name.
	(*VarScope)(unsafe.Pointer(push_scope(tls, ts+10265))).__var = new_string_literal(tls, (*Obj)(unsafe.Pointer(fn)).name, array_of(tls, ty_char, int32(libc.Xstrlen(tls, (*Obj)(unsafe.Pointer(fn)).name)+uint64(1))))

	// [GNU] __FUNCTION__ is yet another name of __func__.
	(*VarScope)(unsafe.Pointer(push_scope(tls, ts+10274))).__var = new_string_literal(tls, (*Obj)(unsafe.Pointer(fn)).name, array_of(tls, ty_char, int32(libc.Xstrlen(tls, (*Obj)(unsafe.Pointer(fn)).name)+uint64(1))))

	(*Obj)(unsafe.Pointer(fn)).body = compound_stmt(tls, bp+8, *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */)))
	(*Obj)(unsafe.Pointer(fn)).locals = locals
	leave_scope(tls)
	resolve_goto_labels(tls)
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* tok */))
}

func global_variable(tls *libc.TLS, tok uintptr, basety uintptr, attr uintptr) uintptr { /* parse.c:3265:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	var first uint8 = uint8(1)

	for !(consume(tls, bp, *(*uintptr)(unsafe.Pointer(bp)), ts+8913) != 0) {
		if !(first != 0) {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+8368)
		}
		first = uint8(0)

		var ty uintptr = declarator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), basety)
		if !(int32((*Type)(unsafe.Pointer(ty)).name) != 0) {
			error_tok(tls, (*Type)(unsafe.Pointer(ty)).name_pos, ts+8938, 0)
		}

		var var1 uintptr = new_gvar(tls, get_ident(tls, (*Type)(unsafe.Pointer(ty)).name), ty)
		(*Obj)(unsafe.Pointer(var1)).is_definition = libc.BoolUint8(!((*VarAttr)(unsafe.Pointer(attr)).is_extern != 0))
		(*Obj)(unsafe.Pointer(var1)).is_static = (*VarAttr)(unsafe.Pointer(attr)).is_static
		(*Obj)(unsafe.Pointer(var1)).is_tls = (*VarAttr)(unsafe.Pointer(attr)).is_tls
		if (*VarAttr)(unsafe.Pointer(attr)).align != 0 {
			(*Obj)(unsafe.Pointer(var1)).align = (*VarAttr)(unsafe.Pointer(attr)).align
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8910) != 0 {
			gvar_initializer(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, var1)
		} else if !(int32((*VarAttr)(unsafe.Pointer(attr)).is_extern) != 0) && !(int32((*VarAttr)(unsafe.Pointer(attr)).is_tls) != 0) {
			(*Obj)(unsafe.Pointer(var1)).is_tentative = uint8(1)
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp /* tok */))
}

// Lookahead tokens and returns true if a given token is a start
// of a function definition or declaration.
func is_function(tls *libc.TLS, tok uintptr) uint8 { /* parse.c:3294:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8913) != 0 {
		return uint8(0)
	}

	*(*Type)(unsafe.Pointer(bp + 8 /* dummy */)) = Type{}
	var ty uintptr = declarator(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), bp+8)
	return uint8(libc.Bool32((*Type)(unsafe.Pointer(ty)).kind == TY_FUNC))
}

// Remove redundant tentative definitions.
func scan_globals(tls *libc.TLS) { /* parse.c:3304:13: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	// var head Obj at bp, 144

	var cur uintptr = bp /* &head */

	{
		var var1 uintptr = globals
		for ; var1 != 0; var1 = (*Obj)(unsafe.Pointer(var1)).next {
			if !(int32((*Obj)(unsafe.Pointer(var1)).is_tentative) != 0) {
				cur = libc.AssignPtrUintptr(cur, var1)
				continue
			}

			// Find another definition of the same identifier.
			var var2 uintptr = globals
			for ; var2 != 0; var2 = (*Obj)(unsafe.Pointer(var2)).next {
				if var1 != var2 && (*Obj)(unsafe.Pointer(var2)).is_definition != 0 && !(libc.Xstrcmp(tls, (*Obj)(unsafe.Pointer(var1)).name, (*Obj)(unsafe.Pointer(var2)).name) != 0) {
					break
				}
			}

			// If there's another definition, the tentative definition
			// is redundant
			if !(var2 != 0) {
				cur = libc.AssignPtrUintptr(cur, var1)
			}
		}
	}

	(*Obj)(unsafe.Pointer(cur)).next = uintptr(0)
	globals = (*Obj)(unsafe.Pointer(bp /* &head */)).next
}

func declare_builtin_functions(tls *libc.TLS) { /* parse.c:3330:13: */
	var ty uintptr = func_type(tls, pointer_to(tls, ty_void))
	(*Type)(unsafe.Pointer(ty)).params = copy_type(tls, ty_int)
	builtin_alloca1 = new_gvar(tls, ts+4885, ty)
	(*Obj)(unsafe.Pointer(builtin_alloca1)).is_definition = uint8(0)
}

// program = (typedef | function-definition | global-variable)*
func parse(tls *libc.TLS, tok uintptr) uintptr { /* parse.c:3338:5: */
	bp := tls.Alloc(20)
	defer tls.Free(20)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	declare_builtin_functions(tls)
	globals = uintptr(0)

	for (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind != TK_EOF {
		*(*VarAttr)(unsafe.Pointer(bp + 8 /* attr */)) = VarAttr{}
		var basety uintptr = declspec(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), bp+8)

		// Typedef
		if (*VarAttr)(unsafe.Pointer(bp+8)).is_typedef != 0 {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = parse_typedef(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), basety)
			continue
		}

		// Function
		if is_function(tls, *(*uintptr)(unsafe.Pointer(bp))) != 0 {
			*(*uintptr)(unsafe.Pointer(bp /* tok */)) = function(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), basety, bp+8)
			continue
		}

		// Global variable
		*(*uintptr)(unsafe.Pointer(bp /* tok */)) = global_variable(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), basety, bp+8)
	}

	{
		var var1 uintptr = globals
		for ; var1 != 0; var1 = (*Obj)(unsafe.Pointer(var1)).next {
			if (*Obj)(unsafe.Pointer(var1)).is_root != 0 {
				mark_live(tls, var1)
			}
		}
	}

	// Remove redundant tentative definitions.
	scan_globals(tls)
	return globals
}
