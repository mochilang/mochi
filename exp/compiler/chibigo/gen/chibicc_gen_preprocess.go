// Code generated by ccgo from chibicc sources; DO NOT EDIT.

package chibigo

import (
	"modernc.org/libc"
	"unsafe"
)

const ( /* preprocess.c:1117:1: */
	STR_NONE  = 0
	STR_UTF8  = 1
	STR_UTF16 = 2
	STR_UTF32 = 3
	STR_WIDE  = 4
)

type MacroParam1 = struct {
	next uintptr
	name uintptr
} /* preprocess.c:27:9 */

type MacroParam = MacroParam1 /* preprocess.c:27:27 */

type MacroArg1 = struct {
	next       uintptr
	name       uintptr
	is_va_args uint8
	_          [7]byte
	tok        uintptr
} /* preprocess.c:33:9 */

type MacroArg = MacroArg1 /* preprocess.c:33:25 */

type Macro1 = struct {
	name         uintptr
	is_objlike   uint8
	_            [7]byte
	params       uintptr
	va_args_name uintptr
	body         uintptr
	handler      uintptr
} /* preprocess.c:43:9 */

type Macro = Macro1 /* preprocess.c:43:22 */

// `#if` can be nested, so we use a stack to manage nested `#if`s.
type CondIncl1 = struct {
	next     uintptr
	ctx      uint32
	_        [4]byte
	tok      uintptr
	included uint8
	_        [7]byte
} /* preprocess.c:54:9 */

// `#if` can be nested, so we use a stack to manage nested `#if`s.
type CondIncl = CondIncl1 /* preprocess.c:54:25 */
const (                   /* preprocess.c:55:1: */
	IN_THEN = 0
	IN_ELIF = 1
	IN_ELSE = 2
)

var macros HashMap         /* preprocess.c:68:16: */
var cond_incl uintptr      /* preprocess.c:69:17: */
var pragma_once HashMap    /* preprocess.c:70:16: */
var include_next_idx int32 /* preprocess.c:71:12: */

func is_hash(tls *libc.TLS, tok uintptr) uint8 { /* preprocess.c:76:13: */
	return uint8(libc.Bool32((*Token)(unsafe.Pointer(tok)).at_bol != 0 && equal(tls, tok, ts+10287) != 0))
}

// Some preprocessor directives such as #include allow extraneous
// tokens before newline. This function skips such tokens.
func skip_line(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:82:14: */
	if (*Token)(unsafe.Pointer(tok)).at_bol != 0 {
		return tok
	}
	warn_tok(tls, tok, ts+10289, 0)
	for (*Token)(unsafe.Pointer(tok)).at_bol != 0 {
		tok = (*Token)(unsafe.Pointer(tok)).next
	}
	return tok
}

func copy_token(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:91:14: */
	var t uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Token{})))
	*(*Token)(unsafe.Pointer(t)) = *(*Token)(unsafe.Pointer(tok))
	(*Token)(unsafe.Pointer(t)).next = uintptr(0)
	return t
}

func new_eof(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:98:14: */
	var t uintptr = copy_token(tls, tok)
	(*Token)(unsafe.Pointer(t)).kind = TK_EOF
	(*Token)(unsafe.Pointer(t)).len = 0
	return t
}

func new_hideset(tls *libc.TLS, name uintptr) uintptr { /* preprocess.c:105:16: */
	var hs uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Hideset{})))
	(*Hideset)(unsafe.Pointer(hs)).name = name
	return hs
}

func hideset_union(tls *libc.TLS, hs1 uintptr, hs2 uintptr) uintptr { /* preprocess.c:111:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Hideset)(unsafe.Pointer(bp /* head */)) = Hideset{}
	var cur uintptr = bp /* &head */

	for ; hs1 != 0; hs1 = (*Hideset)(unsafe.Pointer(hs1)).next {
		cur = libc.AssignPtrUintptr(cur, new_hideset(tls, (*Hideset)(unsafe.Pointer(hs1)).name))
	}
	(*Hideset)(unsafe.Pointer(cur)).next = hs2
	return (*Hideset)(unsafe.Pointer(bp /* &head */)).next
}

func hideset_contains(tls *libc.TLS, hs uintptr, s uintptr, len int32) uint8 { /* preprocess.c:121:13: */
	for ; hs != 0; hs = (*Hideset)(unsafe.Pointer(hs)).next {
		if libc.Xstrlen(tls, (*Hideset)(unsafe.Pointer(hs)).name) == size_t(len) && !(libc.Xstrncmp(tls, (*Hideset)(unsafe.Pointer(hs)).name, s, uint64(len)) != 0) {
			return uint8(1)
		}
	}
	return uint8(0)
}

func hideset_intersection(tls *libc.TLS, hs1 uintptr, hs2 uintptr) uintptr { /* preprocess.c:128:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*Hideset)(unsafe.Pointer(bp /* head */)) = Hideset{}
	var cur uintptr = bp /* &head */

	for ; hs1 != 0; hs1 = (*Hideset)(unsafe.Pointer(hs1)).next {
		if hideset_contains(tls, hs2, (*Hideset)(unsafe.Pointer(hs1)).name, int32(libc.Xstrlen(tls, (*Hideset)(unsafe.Pointer(hs1)).name))) != 0 {
			cur = libc.AssignPtrUintptr(cur, new_hideset(tls, (*Hideset)(unsafe.Pointer(hs1)).name))
		}
	}
	return (*Hideset)(unsafe.Pointer(bp /* &head */)).next
}

func add_hideset(tls *libc.TLS, tok uintptr, hs uintptr) uintptr { /* preprocess.c:138:14: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */

	for ; tok != 0; tok = (*Token)(unsafe.Pointer(tok)).next {
		var t uintptr = copy_token(tls, tok)
		(*Token)(unsafe.Pointer(t)).hideset = hideset_union(tls, (*Token)(unsafe.Pointer(t)).hideset, hs)
		cur = libc.AssignPtrUintptr(cur+8, t)
	}
	return (*Token)(unsafe.Pointer(bp /* &head */)).next
}

// Append tok2 to the end of tok1.
func append(tls *libc.TLS, tok1 uintptr, tok2 uintptr) uintptr { /* preprocess.c:151:14: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	if (*Token)(unsafe.Pointer(tok1)).kind == TK_EOF {
		return tok2
	}

	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */

	for ; (*Token)(unsafe.Pointer(tok1)).kind != TK_EOF; tok1 = (*Token)(unsafe.Pointer(tok1)).next {
		cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, tok1))
	}
	(*Token)(unsafe.Pointer(cur)).next = tok2
	return (*Token)(unsafe.Pointer(bp /* &head */)).next
}

func skip_cond_incl2(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:164:14: */
	for (*Token)(unsafe.Pointer(tok)).kind != TK_EOF {
		if is_hash(tls, tok) != 0 && (equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+9287) != 0 || equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10301) != 0 || equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10307) != 0) {
			tok = skip_cond_incl2(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next)
			continue
		}
		if is_hash(tls, tok) != 0 && equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10314) != 0 {
			return (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next
		}
		tok = (*Token)(unsafe.Pointer(tok)).next
	}
	return tok
}

// Skip until next `#else`, `#elif` or `#endif`.
// Nested `#if` and `#endif` are skipped.
func skip_cond_incl(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:181:14: */
	for (*Token)(unsafe.Pointer(tok)).kind != TK_EOF {
		if is_hash(tls, tok) != 0 && (equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+9287) != 0 || equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10301) != 0 || equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10307) != 0) {
			tok = skip_cond_incl2(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next)
			continue
		}

		if is_hash(tls, tok) != 0 && (equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10320) != 0 || equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+9290) != 0 || equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10314) != 0) {
			break
		}
		tok = (*Token)(unsafe.Pointer(tok)).next
	}
	return tok
}

// Double-quote a given string and returns it.
func quote_string(tls *libc.TLS, str uintptr) uintptr { /* preprocess.c:200:13: */
	var bufsize int32 = 3
	{
		var i int32 = 0
		for ; *(*int8)(unsafe.Pointer(str + uintptr(i))) != 0; i++ {
			if int32(*(*int8)(unsafe.Pointer(str + uintptr(i)))) == '\\' || int32(*(*int8)(unsafe.Pointer(str + uintptr(i)))) == '"' {
				bufsize++
			}
			bufsize++
		}
	}

	var buf uintptr = libc.Xcalloc(tls, uint64(1), uint64(bufsize))
	var p uintptr = buf
	*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = int8('"')
	{
		var i1 int32 = 0
		for ; *(*int8)(unsafe.Pointer(str + uintptr(i1))) != 0; i1++ {
			if int32(*(*int8)(unsafe.Pointer(str + uintptr(i1)))) == '\\' || int32(*(*int8)(unsafe.Pointer(str + uintptr(i1)))) == '"' {
				*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = int8('\\')
			}
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = *(*int8)(unsafe.Pointer(str + uintptr(i1)))
		}
	}
	*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = int8('"')
	*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = int8(0)
	return buf
}

func new_str_token(tls *libc.TLS, str uintptr, tmpl uintptr) uintptr { /* preprocess.c:221:14: */
	var buf uintptr = quote_string(tls, str)
	return tokenize(tls, new_file(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).name, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).file_no, buf))
}

// Copy all tokens until the next newline, terminate them with
// an EOF token and then returns them. This function is used to
// create a new list of tokens for `#if` arguments.
func copy_line(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* preprocess.c:229:14: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */

	for ; !(int32((*Token)(unsafe.Pointer(tok)).at_bol) != 0); tok = (*Token)(unsafe.Pointer(tok)).next {
		cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, tok))
	}

	(*Token)(unsafe.Pointer(cur)).next = new_eof(tls, tok)
	*(*uintptr)(unsafe.Pointer(rest)) = tok
	return (*Token)(unsafe.Pointer(bp /* &head */)).next
}

func new_num_token(tls *libc.TLS, val int32, tmpl uintptr) uintptr { /* preprocess.c:241:14: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var buf uintptr = format(tls, ts+10325, libc.VaList(bp, val))
	return tokenize(tls, new_file(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).name, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).file_no, buf))
}

func read_const_expr(tls *libc.TLS, rest uintptr, tok uintptr) uintptr { /* preprocess.c:246:14: */
	bp := tls.Alloc(120)
	defer tls.Free(120)
	*(*uintptr)(unsafe.Pointer(bp + 112)) = tok

	*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = copy_line(tls, rest, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))

	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */

	for (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).kind != TK_EOF {
		// "defined(foo)" or "defined foo" becomes "1" if macro "foo"
		// is defined. Otherwise "0".
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), ts+10329) != 0 {
			var start uintptr = *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */))
			var has_paren uint8 = consume(tls, bp+112, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next, ts+8703)

			if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).kind != TK_IDENT {
				error_tok(tls, start, ts+10337, 0)
			}
			var m uintptr = find_macro(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))
			*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next

			if has_paren != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)), ts+8705)
			}

			cur = libc.AssignPtrUintptr(cur+8, new_num_token(tls, func() int32 {
				if m != 0 {
					return 1
				}
				return 0
			}(), start))
			continue
		}

		cur = libc.AssignPtrUintptr(cur+8, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))
		*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next
	}

	(*Token)(unsafe.Pointer(cur)).next = *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */))
	return (*Token)(unsafe.Pointer(bp /* &head */)).next
}

// Read and evaluate a constant expression.
func eval_const_expr(tls *libc.TLS, rest uintptr, tok uintptr) int64 { /* preprocess.c:280:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var start uintptr = tok
	var expr uintptr = read_const_expr(tls, rest, (*Token)(unsafe.Pointer(tok)).next)
	expr = preprocess2(tls, expr)

	if (*Token)(unsafe.Pointer(expr)).kind == TK_EOF {
		error_tok(tls, start, ts+10370, 0)
	}

	// [https://www.sigbus.info/n1570#6.10.1p4] The standard requires
	// we replace remaining non-macro identifiers with "0" before
	// evaluating a constant expression. For example, `#if foo` is
	// equivalent to `#if 0` if foo is not defined.
	{
		var t uintptr = expr
		for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
			if (*Token)(unsafe.Pointer(t)).kind == TK_IDENT {
				var next uintptr = (*Token)(unsafe.Pointer(t)).next
				*(*Token)(unsafe.Pointer(t)) = *(*Token)(unsafe.Pointer(new_num_token(tls, 0, t)))
				(*Token)(unsafe.Pointer(t)).next = next
			}
		}
	}

	// Convert pp-numbers to regular numbers
	convert_pp_tokens(tls, expr)
	// var rest2 uintptr at bp, 8

	var val int64 = const_expr(tls, bp, expr)
	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind != TK_EOF {
		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* rest2 */)), ts+10289, 0)
	}
	return val
}

func push_cond_incl(tls *libc.TLS, tok uintptr, included uint8) uintptr { /* preprocess.c:310:17: */
	var ci uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(CondIncl{})))
	(*CondIncl)(unsafe.Pointer(ci)).next = cond_incl
	(*CondIncl)(unsafe.Pointer(ci)).ctx = IN_THEN
	(*CondIncl)(unsafe.Pointer(ci)).tok = tok
	(*CondIncl)(unsafe.Pointer(ci)).included = included
	cond_incl = ci
	return ci
}

func find_macro(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:320:14: */
	if (*Token)(unsafe.Pointer(tok)).kind != TK_IDENT {
		return uintptr(0)
	}
	return hashmap_get2(tls, uintptr(unsafe.Pointer(&macros)), (*Token)(unsafe.Pointer(tok)).loc, (*Token)(unsafe.Pointer(tok)).len)
}

func add_macro(tls *libc.TLS, name uintptr, is_objlike uint8, body uintptr) uintptr { /* preprocess.c:326:14: */
	var m uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(Macro{})))
	(*Macro)(unsafe.Pointer(m)).name = name
	(*Macro)(unsafe.Pointer(m)).is_objlike = is_objlike
	(*Macro)(unsafe.Pointer(m)).body = body
	hashmap_put(tls, uintptr(unsafe.Pointer(&macros)), name, m)
	return m
}

func read_macro_params(tls *libc.TLS, rest uintptr, tok uintptr, va_args_name uintptr) uintptr { /* preprocess.c:335:19: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*MacroParam)(unsafe.Pointer(bp /* head */)) = MacroParam{}
	var cur uintptr = bp /* &head */

	for !(equal(tls, tok, ts+8705) != 0) {
		if cur != bp {
			tok = skip(tls, tok, ts+8368)
		}

		if equal(tls, tok, ts+8862) != 0 {
			*(*uintptr)(unsafe.Pointer(va_args_name)) = ts + 10384 /* "__VA_ARGS__" */
			*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, (*Token)(unsafe.Pointer(tok)).next, ts+8705)
			return (*MacroParam)(unsafe.Pointer(bp /* &head */)).next
		}

		if (*Token)(unsafe.Pointer(tok)).kind != TK_IDENT {
			error_tok(tls, tok, ts+8405, 0)
		}

		if equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+8862) != 0 {
			*(*uintptr)(unsafe.Pointer(va_args_name)) = xstrndup(tls, (*Token)(unsafe.Pointer(tok)).loc, uint64((*Token)(unsafe.Pointer(tok)).len))
			*(*uintptr)(unsafe.Pointer(rest)) = skip(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next, ts+8705)
			return (*MacroParam)(unsafe.Pointer(bp /* &head */)).next
		}

		var m uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(MacroParam{})))
		(*MacroParam)(unsafe.Pointer(m)).name = xstrndup(tls, (*Token)(unsafe.Pointer(tok)).loc, uint64((*Token)(unsafe.Pointer(tok)).len))
		cur = libc.AssignPtrUintptr(cur, m)
		tok = (*Token)(unsafe.Pointer(tok)).next
	}

	*(*uintptr)(unsafe.Pointer(rest)) = (*Token)(unsafe.Pointer(tok)).next
	return (*MacroParam)(unsafe.Pointer(bp /* &head */)).next
}

func read_macro_definition(tls *libc.TLS, rest uintptr, tok uintptr) { /* preprocess.c:368:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).kind != TK_IDENT {
		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)), ts+10337, 0)
	}
	var name uintptr = xstrndup(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).loc, uint64((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).len))
	*(*uintptr)(unsafe.Pointer(bp /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next

	if !(int32((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).has_space) != 0) && equal(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+8703) != 0 {
		// Function-like macro
		*(*uintptr)(unsafe.Pointer(bp + 8 /* va_args_name */)) = uintptr(0)
		var params uintptr = read_macro_params(tls, bp, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next, bp+8)

		var m uintptr = add_macro(tls, name, uint8(0), copy_line(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */))))
		(*Macro)(unsafe.Pointer(m)).params = params
		(*Macro)(unsafe.Pointer(m)).va_args_name = *(*uintptr)(unsafe.Pointer(bp + 8 /* va_args_name */))
	} else {
		// Object-like macro
		add_macro(tls, name, uint8(1), copy_line(tls, rest, *(*uintptr)(unsafe.Pointer(bp /* tok */))))
	}
}

func read_macro_arg_one(tls *libc.TLS, rest uintptr, tok uintptr, read_rest uint8) uintptr { /* preprocess.c:388:17: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */
	var level int32 = 0

	for {
		if level == 0 && equal(tls, tok, ts+8705) != 0 {
			break
		}
		if level == 0 && !(read_rest != 0) && equal(tls, tok, ts+8368) != 0 {
			break
		}

		if (*Token)(unsafe.Pointer(tok)).kind == TK_EOF {
			error_tok(tls, tok, ts+10396, 0)
		}

		if equal(tls, tok, ts+8703) != 0 {
			level++
		} else if equal(tls, tok, ts+8705) != 0 {
			level--
		}

		cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, tok))
		tok = (*Token)(unsafe.Pointer(tok)).next
	}

	(*Token)(unsafe.Pointer(cur)).next = new_eof(tls, tok)

	var arg uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(MacroArg{})))
	(*MacroArg)(unsafe.Pointer(arg)).tok = (*Token)(unsafe.Pointer(bp /* &head */)).next
	*(*uintptr)(unsafe.Pointer(rest)) = tok
	return arg
}

func read_macro_args(tls *libc.TLS, rest uintptr, tok uintptr, params uintptr, va_args_name uintptr) uintptr { /* preprocess.c:419:17: */
	bp := tls.Alloc(40)
	defer tls.Free(40)
	*(*uintptr)(unsafe.Pointer(bp + 32)) = tok

	var start uintptr = *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */))
	*(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)))).next)).next

	*(*MacroArg)(unsafe.Pointer(bp /* head */)) = MacroArg{}
	var cur uintptr = bp /* &head */

	var pp uintptr = params
	for ; pp != 0; pp = (*MacroParam)(unsafe.Pointer(pp)).next {
		if cur != bp {
			*(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)), ts+8368)
		}
		cur = libc.AssignPtrUintptr(cur, read_macro_arg_one(tls, bp+32, *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)), uint8(0)))
		(*MacroArg)(unsafe.Pointer(cur)).name = (*MacroParam)(unsafe.Pointer(pp)).name
	}

	if va_args_name != 0 {
		var arg uintptr
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), ts+8705) != 0 {
			arg = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(MacroArg{})))
			(*MacroArg)(unsafe.Pointer(arg)).tok = new_eof(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)))
		} else {
			if pp != params {
				*(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)), ts+8368)
			}
			arg = read_macro_arg_one(tls, bp+32, *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)), uint8(1))
		}
		(*MacroArg)(unsafe.Pointer(arg)).name = va_args_name

		(*MacroArg)(unsafe.Pointer(arg)).is_va_args = uint8(1)
		cur = libc.AssignPtrUintptr(cur, arg)
	} else if pp != 0 {
		error_tok(tls, start, ts+9717, 0)
	}

	skip(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */)), ts+8705)
	*(*uintptr)(unsafe.Pointer(rest)) = *(*uintptr)(unsafe.Pointer(bp + 32 /* tok */))
	return (*MacroArg)(unsafe.Pointer(bp /* &head */)).next
}

func find_arg(tls *libc.TLS, args uintptr, tok uintptr) uintptr { /* preprocess.c:457:17: */
	{
		var ap uintptr = args
		for ; ap != 0; ap = (*MacroArg)(unsafe.Pointer(ap)).next {
			if size_t((*Token)(unsafe.Pointer(tok)).len) == libc.Xstrlen(tls, (*MacroArg)(unsafe.Pointer(ap)).name) && !(libc.Xstrncmp(tls, (*Token)(unsafe.Pointer(tok)).loc, (*MacroArg)(unsafe.Pointer(ap)).name, uint64((*Token)(unsafe.Pointer(tok)).len)) != 0) {
				return ap
			}
		}
	}
	return uintptr(0)
}

// Concatenates all tokens in `tok` and returns a new string.
func join_tokens(tls *libc.TLS, tok uintptr, end uintptr) uintptr { /* preprocess.c:465:13: */
	// Compute the length of the resulting token.
	var len int32 = 1
	{
		var t uintptr = tok
		for ; t != end && (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
			if t != tok && (*Token)(unsafe.Pointer(t)).has_space != 0 {
				len++
			}
			len = len + (*Token)(unsafe.Pointer(t)).len
		}
	}

	var buf uintptr = libc.Xcalloc(tls, uint64(1), uint64(len))

	// Copy token texts.
	var pos int32 = 0
	{
		var t1 uintptr = tok
		for ; t1 != end && (*Token)(unsafe.Pointer(t1)).kind != TK_EOF; t1 = (*Token)(unsafe.Pointer(t1)).next {
			if t1 != tok && (*Token)(unsafe.Pointer(t1)).has_space != 0 {
				*(*int8)(unsafe.Pointer(buf + uintptr(libc.PostIncInt32(&pos, 1)))) = int8(' ')
			}
			libc.Xstrncpy(tls, buf+uintptr(pos), (*Token)(unsafe.Pointer(t1)).loc, uint64((*Token)(unsafe.Pointer(t1)).len))
			pos = pos + (*Token)(unsafe.Pointer(t1)).len
		}
	}
	*(*int8)(unsafe.Pointer(buf + uintptr(pos))) = int8(0)
	return buf
}

// Concatenates all tokens in `arg` and returns a new string token.
// This function is used for the stringizing operator (#).
func stringize(tls *libc.TLS, hash uintptr, arg uintptr) uintptr { /* preprocess.c:490:14: */
	// Create a new string token. We need to set some value to its
	// source location for error reporting function, so we use a macro
	// name token as a template.
	var s uintptr = join_tokens(tls, arg, uintptr(0))
	return new_str_token(tls, s, hash)
}

// Concatenate two tokens to create a new token.
func paste(tls *libc.TLS, lhs uintptr, rhs uintptr) uintptr { /* preprocess.c:499:14: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// Paste the two tokens.
	var buf uintptr = format(tls, ts+10419, libc.VaList(bp, (*Token)(unsafe.Pointer(lhs)).len, (*Token)(unsafe.Pointer(lhs)).loc, (*Token)(unsafe.Pointer(rhs)).len, (*Token)(unsafe.Pointer(rhs)).loc))

	// Tokenize the resulting string.
	var tok uintptr = tokenize(tls, new_file(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(lhs)).file)).name, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(lhs)).file)).file_no, buf))
	if (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).kind != TK_EOF {
		error_tok(tls, lhs, ts+10428, libc.VaList(bp+32, buf))
	}
	return tok
}

func has_varargs(tls *libc.TLS, args uintptr) uint8 { /* preprocess.c:510:13: */
	{
		var ap uintptr = args
		for ; ap != 0; ap = (*MacroArg)(unsafe.Pointer(ap)).next {
			if !(libc.Xstrcmp(tls, (*MacroArg)(unsafe.Pointer(ap)).name, ts+10384) != 0) {
				return uint8(libc.Bool32((*Token)(unsafe.Pointer((*MacroArg)(unsafe.Pointer(ap)).tok)).kind != TK_EOF))
			}
		}
	}
	return uint8(0)
}

// Replace func-like macro parameters with given arguments.
func subst(tls *libc.TLS, tok uintptr, args uintptr) uintptr { /* preprocess.c:518:14: */
	bp := tls.Alloc(120)
	defer tls.Free(120)
	*(*uintptr)(unsafe.Pointer(bp + 112)) = tok

	*(*Token)(unsafe.Pointer(bp /* head */)) = Token{}
	var cur uintptr = bp /* &head */

	for (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).kind != TK_EOF {
		// "#" followed by a parameter is replaced with stringized actuals.
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), ts+10287) != 0 {
			var arg uintptr = find_arg(tls, args, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)
			if !(arg != 0) {
				error_tok(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next, ts+10465, 0)
			}
			cur = libc.AssignPtrUintptr(cur+8, stringize(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)), (*MacroArg)(unsafe.Pointer(arg)).tok))
			*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next
			continue
		}

		// [GNU] If __VA_ARG__ is empty, `,##__VA_ARGS__` is expanded
		// to the empty token list. Otherwise, its expaned to `,` and
		// __VA_ARGS__.
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), ts+8368) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).next, ts+10506) != 0 {
			var arg uintptr = find_arg(tls, args, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next)
			if arg != 0 && (*MacroArg)(unsafe.Pointer(arg)).is_va_args != 0 {
				if (*Token)(unsafe.Pointer((*MacroArg)(unsafe.Pointer(arg)).tok)).kind == TK_EOF {
					*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next)).next
				} else {
					cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */))))
					*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next
				}
				continue
			}
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), ts+10506) != 0 {
			if cur == bp {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)), ts+10509, 0)
			}

			if (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).next)).kind == TK_EOF {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)), ts+10556, 0)
			}

			var arg uintptr = find_arg(tls, args, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)
			if arg != 0 {
				if (*Token)(unsafe.Pointer((*MacroArg)(unsafe.Pointer(arg)).tok)).kind != TK_EOF {
					*(*Token)(unsafe.Pointer(cur)) = *(*Token)(unsafe.Pointer(paste(tls, cur, (*MacroArg)(unsafe.Pointer(arg)).tok)))
					{
						var t uintptr = (*Token)(unsafe.Pointer((*MacroArg)(unsafe.Pointer(arg)).tok)).next
						for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
							cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, t))
						}
					}
				}
				*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next
				continue
			}

			*(*Token)(unsafe.Pointer(cur)) = *(*Token)(unsafe.Pointer(paste(tls, cur, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)))
			*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next
			continue
		}

		var arg uintptr = find_arg(tls, args, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))

		if arg != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).next, ts+10506) != 0 {
			var rhs uintptr = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next

			if (*Token)(unsafe.Pointer((*MacroArg)(unsafe.Pointer(arg)).tok)).kind == TK_EOF {
				var arg2 uintptr = find_arg(tls, args, rhs)
				if arg2 != 0 {
					{
						var t uintptr = (*MacroArg)(unsafe.Pointer(arg2)).tok
						for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
							cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, t))
						}
					}
				} else {
					cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, rhs))
				}
				*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer(rhs)).next
				continue
			}

			{
				var t uintptr = (*MacroArg)(unsafe.Pointer(arg)).tok
				for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
					cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, t))
				}
			}
			*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next
			continue
		}

		// If __VA_ARG__ is empty, __VA_OPT__(x) is expanded to the
		// empty token list. Otherwise, __VA_OPT__(x) is expanded to x.
		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 112)), ts+10601) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112)))).next, ts+8703) != 0 {
			var arg uintptr = read_macro_arg_one(tls, bp+112, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next)).next, uint8(1))
			if has_varargs(tls, args) != 0 {
				var t uintptr = (*MacroArg)(unsafe.Pointer(arg)).tok
				for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
					cur = libc.AssignPtrUintptr(cur+8, t)
				}
			}
			*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = skip(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)), ts+8705)
			continue
		}

		// Handle a macro token. Macro arguments are completely macro-expanded
		// before they are substituted into a macro body.
		if arg != 0 {
			var t uintptr = preprocess2(tls, (*MacroArg)(unsafe.Pointer(arg)).tok)
			(*Token)(unsafe.Pointer(t)).at_bol = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).at_bol
			(*Token)(unsafe.Pointer(t)).has_space = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).has_space
			for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
				cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, t))
			}
			*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next
			continue
		}

		// Handle a non-macro token.
		cur = libc.AssignPtrUintptr(cur+8, copy_token(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */))))
		*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112 /* tok */)))).next
		continue
	}

	(*Token)(unsafe.Pointer(cur)).next = *(*uintptr)(unsafe.Pointer(bp + 112 /* tok */))
	return (*Token)(unsafe.Pointer(bp /* &head */)).next
}

// If tok is a macro, expand it and return true.
// Otherwise, do nothing and return false.
func expand_macro(tls *libc.TLS, rest uintptr, tok uintptr) uint8 { /* preprocess.c:632:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = tok

	if hideset_contains(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).hideset, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).loc, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).len) != 0 {
		return uint8(0)
	}

	var m uintptr = find_macro(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
	if !(m != 0) {
		return uint8(0)
	}

	// Built-in dynamic macro application such as __LINE__
	if (*Macro)(unsafe.Pointer(m)).handler != 0 {
		*(*uintptr)(unsafe.Pointer(rest)) = (*struct {
			f func(*libc.TLS, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Macro)(unsafe.Pointer(m)).handler})).f(tls, *(*uintptr)(unsafe.Pointer(bp /* tok */)))
		(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(rest)))).next = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next
		return uint8(1)
	}

	// Object-like macro application
	if (*Macro)(unsafe.Pointer(m)).is_objlike != 0 {
		var hs uintptr = hideset_union(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).hideset, new_hideset(tls, (*Macro)(unsafe.Pointer(m)).name))
		var body uintptr = add_hideset(tls, (*Macro)(unsafe.Pointer(m)).body, hs)
		{
			var t uintptr = body
			for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
				(*Token)(unsafe.Pointer(t)).origin = *(*uintptr)(unsafe.Pointer(bp /* tok */))
			}
		}
		*(*uintptr)(unsafe.Pointer(rest)) = append(tls, body, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
		(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(rest)))).at_bol = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).at_bol
		(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(rest)))).has_space = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).has_space
		return uint8(1)
	}

	// If a funclike macro token is not followed by an argument list,
	// treat it as a normal identifier.
	if !(equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).next, ts+8703) != 0) {
		return uint8(0)
	}

	// Function-like macro application
	var macro_token uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))
	var args uintptr = read_macro_args(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok */)), (*Macro)(unsafe.Pointer(m)).params, (*Macro)(unsafe.Pointer(m)).va_args_name)
	var rparen uintptr = *(*uintptr)(unsafe.Pointer(bp /* tok */))

	// Tokens that consist a func-like macro invocation may have different
	// hidesets, and if that's the case, it's not clear what the hideset
	// for the new tokens should be. We take the interesection of the
	// macro token and the closing parenthesis and use it as a new hideset
	// as explained in the Dave Prossor's algorithm.
	var hs uintptr = hideset_intersection(tls, (*Token)(unsafe.Pointer(macro_token)).hideset, (*Token)(unsafe.Pointer(rparen)).hideset)
	hs = hideset_union(tls, hs, new_hideset(tls, (*Macro)(unsafe.Pointer(m)).name))

	var body uintptr = subst(tls, (*Macro)(unsafe.Pointer(m)).body, args)
	body = add_hideset(tls, body, hs)
	{
		var t uintptr = body
		for ; (*Token)(unsafe.Pointer(t)).kind != TK_EOF; t = (*Token)(unsafe.Pointer(t)).next {
			(*Token)(unsafe.Pointer(t)).origin = macro_token
		}
	}
	*(*uintptr)(unsafe.Pointer(rest)) = append(tls, body, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* tok */)))).next)
	(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(rest)))).at_bol = (*Token)(unsafe.Pointer(macro_token)).at_bol
	(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(rest)))).has_space = (*Token)(unsafe.Pointer(macro_token)).has_space
	return uint8(1)
}

func search_include_paths(tls *libc.TLS, filename uintptr) uintptr { /* preprocess.c:687:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if int32(*(*int8)(unsafe.Pointer(filename))) == '/' {
		return filename
	}
	var cached uintptr = hashmap_get(tls, uintptr(unsafe.Pointer(&cache)), filename)
	if cached != 0 {
		return cached
	}

	// Search a file from the include paths.
	{
		var i int32 = 0
		for ; i < include_paths.len; i++ {
			var path uintptr = format(tls, ts+10612, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(include_paths.data + uintptr(i)*8)), filename))
			if !(file_exists(tls, path) != 0) {
				continue
			}
			hashmap_put(tls, uintptr(unsafe.Pointer(&cache)), filename, path)
			include_next_idx = i + 1
			return path
		}
	}
	return uintptr(0)
}

var cache HashMap /* preprocess.c:691:18: */

func search_include_next(tls *libc.TLS, filename uintptr) uintptr { /* preprocess.c:708:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	for ; include_next_idx < include_paths.len; include_next_idx++ {
		var path uintptr = format(tls, ts+10612, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(include_paths.data + uintptr(include_next_idx)*8)), filename))
		if file_exists(tls, path) != 0 {
			return path
		}
	}
	return uintptr(0)
}

// Read an #include argument.
func read_include_filename(tls *libc.TLS, rest uintptr, tok uintptr, is_dquote uintptr) uintptr { /* preprocess.c:718:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Pattern 1: #include "foo.h"
	if (*Token)(unsafe.Pointer(tok)).kind == TK_STR {
		// A double-quoted filename for #include is a special kind of
		// token, and we don't want to interpret any escape sequences in it.
		// For example, "\f" in "C:\foo" is not a formfeed character but
		// just two non-control characters, backslash and f.
		// So we don't want to use token->str.
		*(*uint8)(unsafe.Pointer(is_dquote)) = uint8(1)
		*(*uintptr)(unsafe.Pointer(rest)) = skip_line(tls, (*Token)(unsafe.Pointer(tok)).next)
		return xstrndup(tls, (*Token)(unsafe.Pointer(tok)).loc+uintptr(1), uint64((*Token)(unsafe.Pointer(tok)).len-2))
	}

	// Pattern 2: #include <foo.h>
	if equal(tls, tok, ts+9533) != 0 {
		// Reconstruct a filename from a sequence of tokens between
		// "<" and ">".
		var start uintptr = tok

		// Find closing ">".
		for ; !(equal(tls, tok, ts+9538) != 0); tok = (*Token)(unsafe.Pointer(tok)).next {
			if (*Token)(unsafe.Pointer(tok)).at_bol != 0 || (*Token)(unsafe.Pointer(tok)).kind == TK_EOF {
				error_tok(tls, tok, ts+10618, 0)
			}
		}

		*(*uint8)(unsafe.Pointer(is_dquote)) = uint8(0)
		*(*uintptr)(unsafe.Pointer(rest)) = skip_line(tls, (*Token)(unsafe.Pointer(tok)).next)
		return join_tokens(tls, (*Token)(unsafe.Pointer(start)).next, tok)
	}

	// Pattern 3: #include FOO
	// In this case FOO must be macro-expanded to either
	// a single string token or a sequence of "<" ... ">".
	if (*Token)(unsafe.Pointer(tok)).kind == TK_IDENT {
		*(*uintptr)(unsafe.Pointer(bp /* tok2 */)) = preprocess2(tls, copy_line(tls, rest, tok))
		return read_include_filename(tls, bp, *(*uintptr)(unsafe.Pointer(bp /* tok2 */)), is_dquote)
	}

	error_tok(tls, tok, ts+10631, 0)
	return uintptr(0)
}

// Detect the following "include guard" pattern.
//
//	#ifndef FOO_H
//	#define FOO_H
//	...
//	#endif
func detect_include_guard(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:764:13: */
	// Detect the first two lines.
	if !(is_hash(tls, tok) != 0) || !(equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10307) != 0) {
		return uintptr(0)
	}
	tok = (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next

	if (*Token)(unsafe.Pointer(tok)).kind != TK_IDENT {
		return uintptr(0)
	}

	var macro uintptr = xstrndup(tls, (*Token)(unsafe.Pointer(tok)).loc, uint64((*Token)(unsafe.Pointer(tok)).len))
	tok = (*Token)(unsafe.Pointer(tok)).next

	if !(is_hash(tls, tok) != 0) || !(equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10651) != 0) || !(equal(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next, macro) != 0) {
		return uintptr(0)
	}

	// Read until the end of the file.
	for (*Token)(unsafe.Pointer(tok)).kind != TK_EOF {
		if !(is_hash(tls, tok) != 0) {
			tok = (*Token)(unsafe.Pointer(tok)).next
			continue
		}

		if equal(tls, (*Token)(unsafe.Pointer(tok)).next, ts+10314) != 0 && (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).next)).next)).kind == TK_EOF {
			return macro
		}

		if equal(tls, tok, ts+9287) != 0 || equal(tls, tok, ts+10301) != 0 || equal(tls, tok, ts+10307) != 0 {
			tok = skip_cond_incl(tls, (*Token)(unsafe.Pointer(tok)).next)
		} else {
			tok = (*Token)(unsafe.Pointer(tok)).next
		}
	}
	return uintptr(0)
}

func include_file(tls *libc.TLS, tok uintptr, path uintptr, filename_tok uintptr) uintptr { /* preprocess.c:797:14: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// Check for "#pragma once"
	if hashmap_get(tls, uintptr(unsafe.Pointer(&pragma_once)), path) != 0 {
		return tok
	}
	var guard_name uintptr = hashmap_get(tls, uintptr(unsafe.Pointer(&include_guards)), path)
	if guard_name != 0 && hashmap_get(tls, uintptr(unsafe.Pointer(&macros)), guard_name) != 0 {
		return tok
	}

	var tok2 uintptr = tokenize_file(tls, path)
	if !(tok2 != 0) {
		error_tok(tls, filename_tok, ts+10658, libc.VaList(bp, path, libc.Xstrerror(tls, *(*int32)(unsafe.Pointer(libc.X__errno_location(tls))))))
	}

	guard_name = detect_include_guard(tls, tok2)
	if guard_name != 0 {
		hashmap_put(tls, uintptr(unsafe.Pointer(&include_guards)), path, guard_name)
	}

	return append(tls, tok2, tok)
}

var include_guards HashMap /* preprocess.c:805:18: */

// Read #line arguments
func read_line_marker(tls *libc.TLS, rest uintptr, tok uintptr) { /* preprocess.c:822:13: */
	var start uintptr = tok
	tok = preprocess(tls, copy_line(tls, rest, tok))

	if (*Token)(unsafe.Pointer(tok)).kind != TK_NUM || (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).ty)).kind != TY_INT {
		error_tok(tls, tok, ts+10683, 0)
	}
	(*File)(unsafe.Pointer((*Token)(unsafe.Pointer(start)).file)).line_delta = int32((*Token)(unsafe.Pointer(tok)).val - int64_t((*Token)(unsafe.Pointer(start)).line_no))

	tok = (*Token)(unsafe.Pointer(tok)).next
	if (*Token)(unsafe.Pointer(tok)).kind == TK_EOF {
		return
	}

	if (*Token)(unsafe.Pointer(tok)).kind != TK_STR {
		error_tok(tls, tok, ts+10703, 0)
	}
	(*File)(unsafe.Pointer((*Token)(unsafe.Pointer(start)).file)).display_name = (*Token)(unsafe.Pointer(tok)).str
}

// Visit all tokens in `tok` while evaluating preprocessing
// macros and directives.
func preprocess2(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:841:14: */
	bp := tls.Alloc(138)
	defer tls.Free(138)
	*(*uintptr)(unsafe.Pointer(bp + 128)) = tok

	*(*Token)(unsafe.Pointer(bp + 16 /* head */)) = Token{}
	var cur uintptr = bp + 16 /* &head */

	for (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))).kind != TK_EOF {
		// If it is a macro, expand it.
		if expand_macro(tls, bp+128, *(*uintptr)(unsafe.Pointer(bp + 128))) != 0 {
			continue
		}

		// Pass through if it is not a "#".
		if !(is_hash(tls, *(*uintptr)(unsafe.Pointer(bp + 128))) != 0) {
			(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).line_delta = (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).file)).line_delta
			(*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).filename = (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).file)).display_name
			cur = libc.AssignPtrUintptr(cur+8, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next
			continue
		}

		var start uintptr = *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */))
		*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10721) != 0 {
			// var is_dquote uint8 at bp+136, 1

			var filename uintptr = read_include_filename(tls, bp+128, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next, bp+136)

			if int32(*(*int8)(unsafe.Pointer(filename))) != '/' && *(*uint8)(unsafe.Pointer(bp + 136)) != 0 {
				var path uintptr = format(tls, ts+10612, libc.VaList(bp, xdirname(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(start)).file)).name), filename))
				if file_exists(tls, path) != 0 {
					*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = include_file(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), path, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(start)).next)).next)
					continue
				}
			}

			var path uintptr = search_include_paths(tls, filename)
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = include_file(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), func() uintptr {
				if path != 0 {
					return path
				}
				return filename
			}(), (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(start)).next)).next)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10729) != 0 {
			// var ignore uint8 at bp+137, 1

			var filename uintptr = read_include_filename(tls, bp+128, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next, bp+137)
			var path uintptr = search_include_next(tls, filename)
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = include_file(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), func() uintptr {
				if path != 0 {
					return path
				}
				return filename
			}(), (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(start)).next)).next)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10651) != 0 {
			read_macro_definition(tls, bp+128, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10742) != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next
			if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))).kind != TK_IDENT {
				error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), ts+10337, 0)
			}
			undef_macro(tls, xstrndup(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).loc, uint64((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).len)))
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_line(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+9287) != 0 {
			var val int64 = eval_const_expr(tls, bp+128, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			push_cond_incl(tls, start, uint8(val))
			if !(val != 0) {
				*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			}
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10301) != 0 {
			var defined uint8 = uint8(find_macro(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next))
			push_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), defined)
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_line(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)).next)
			if !(defined != 0) {
				*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			}
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10307) != 0 {
			var defined uint8 = uint8(find_macro(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next))
			push_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), libc.BoolUint8(!(defined != 0)))
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_line(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)).next)
			if defined != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			}
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10320) != 0 {
			if !(cond_incl != 0) || (*CondIncl)(unsafe.Pointer(cond_incl)).ctx == IN_ELSE {
				error_tok(tls, start, ts+10748, 0)
			}
			(*CondIncl)(unsafe.Pointer(cond_incl)).ctx = IN_ELIF

			if !(int32((*CondIncl)(unsafe.Pointer(cond_incl)).included) != 0) && eval_const_expr(tls, bp+128, *(*uintptr)(unsafe.Pointer(bp + 128))) != 0 {
				(*CondIncl)(unsafe.Pointer(cond_incl)).included = uint8(1)
			} else {
				*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			}
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+9290) != 0 {
			if !(cond_incl != 0) || (*CondIncl)(unsafe.Pointer(cond_incl)).ctx == IN_ELSE {
				error_tok(tls, start, ts+10760, 0)
			}
			(*CondIncl)(unsafe.Pointer(cond_incl)).ctx = IN_ELSE
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_line(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)

			if (*CondIncl)(unsafe.Pointer(cond_incl)).included != 0 {
				*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_cond_incl(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			}
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10314) != 0 {
			if !(cond_incl != 0) {
				error_tok(tls, start, ts+10772, 0)
			}
			cond_incl = (*CondIncl)(unsafe.Pointer(cond_incl)).next
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_line(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10785) != 0 {
			read_line_marker(tls, bp+128, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)
			continue
		}

		if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))).kind == TK_PP_NUM {
			read_line_marker(tls, bp+128, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10790) != 0 && equal(tls, (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))).next, ts+10797) != 0 {
			hashmap_put(tls, uintptr(unsafe.Pointer(&pragma_once)), (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).file)).name, uintptr(1))
			*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = skip_line(tls, (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next)).next)
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10790) != 0 {
			for __ccgo := true; __ccgo; __ccgo = !(int32((*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))).at_bol) != 0) {
				*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)) = (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)))).next
			}
			continue
		}

		if equal(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), ts+10802) != 0 {
			error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), ts+10802, 0)
		}

		// `#`-only line is legal. It's called a null directive.
		if (*Token)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))).at_bol != 0 {
			continue
		}

		error_tok(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */)), ts+10808, 0)
	}

	(*Token)(unsafe.Pointer(cur)).next = *(*uintptr)(unsafe.Pointer(bp + 128 /* tok */))
	return (*Token)(unsafe.Pointer(bp + 16 /* &head */)).next
}

func define_macro(tls *libc.TLS, name uintptr, buf uintptr) { /* preprocess.c:995:6: */
	var tok uintptr = tokenize(tls, new_file(tls, ts+10839, 1, buf))
	add_macro(tls, name, uint8(1), tok)
}

func undef_macro(tls *libc.TLS, name uintptr) { /* preprocess.c:1000:6: */
	hashmap_delete(tls, uintptr(unsafe.Pointer(&macros)), name)
}

func add_builtin(tls *libc.TLS, name uintptr, fn uintptr) uintptr { /* preprocess.c:1004:14: */
	var m uintptr = add_macro(tls, name, uint8(1), uintptr(0))
	(*Macro)(unsafe.Pointer(m)).handler = fn
	return m
}

func file_macro(tls *libc.TLS, tmpl uintptr) uintptr { /* preprocess.c:1010:14: */
	for (*Token)(unsafe.Pointer(tmpl)).origin != 0 {
		tmpl = (*Token)(unsafe.Pointer(tmpl)).origin
	}
	return new_str_token(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).display_name, tmpl)
}

func line_macro(tls *libc.TLS, tmpl uintptr) uintptr { /* preprocess.c:1016:14: */
	for (*Token)(unsafe.Pointer(tmpl)).origin != 0 {
		tmpl = (*Token)(unsafe.Pointer(tmpl)).origin
	}
	var i int32 = (*Token)(unsafe.Pointer(tmpl)).line_no + (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).line_delta
	return new_num_token(tls, i, tmpl)
}

// __COUNTER__ is expanded to serial values starting from 0.
func counter_macro(tls *libc.TLS, tmpl uintptr) uintptr { /* preprocess.c:1024:14: */
	return new_num_token(tls, libc.PostIncInt32(&i1, 1), tmpl)
}

var i1 int32 = 0 /* preprocess.c:1025:14 */

// __TIMESTAMP__ is expanded to a string describing the last
// modification time of the current file. E.g.
// "Fri Jul 24 01:32:50 2020"
func timestamp_macro(tls *libc.TLS, tmpl uintptr) uintptr { /* preprocess.c:1032:14: */
	bp := tls.Alloc(174)
	defer tls.Free(174)

	// var st stat at bp, 144

	if libc.Xstat(tls, (*File)(unsafe.Pointer((*Token)(unsafe.Pointer(tmpl)).file)).name, bp) != 0 {
		return new_str_token(tls, ts+10850, tmpl)
	}
	// var buf [30]int8 at bp+144, 30

	libc.Xctime_r(tls, bp+88, bp+144)
	*(*int8)(unsafe.Pointer(bp + 144 + 24)) = int8(0)
	return new_str_token(tls, bp+144, tmpl)
}

func base_file_macro(tls *libc.TLS, tmpl uintptr) uintptr { /* preprocess.c:1043:14: */
	return new_str_token(tls, base_file, tmpl)
}

// __DATE__ is expanded to the current date, e.g. "May 17 2020".
func format_date(tls *libc.TLS, tm1 uintptr) uintptr { /* preprocess.c:1048:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	return format(tls, ts+10875, libc.VaList(bp, uintptr(unsafe.Pointer(&mon))+uintptr((*tm)(unsafe.Pointer(tm1)).tm_mon)*4, (*tm)(unsafe.Pointer(tm1)).tm_mday, (*tm)(unsafe.Pointer(tm1)).tm_year+1900))
}

var mon = [12][4]int8{
	*(*[4]int8)(unsafe.Pointer(ts + 10887)), *(*[4]int8)(unsafe.Pointer(ts + 10891)), *(*[4]int8)(unsafe.Pointer(ts + 10895)), *(*[4]int8)(unsafe.Pointer(ts + 10899)), *(*[4]int8)(unsafe.Pointer(ts + 10903)), *(*[4]int8)(unsafe.Pointer(ts + 10907)),
	*(*[4]int8)(unsafe.Pointer(ts + 10911)), *(*[4]int8)(unsafe.Pointer(ts + 10915)), *(*[4]int8)(unsafe.Pointer(ts + 10919)), *(*[4]int8)(unsafe.Pointer(ts + 10923)), *(*[4]int8)(unsafe.Pointer(ts + 10927)), *(*[4]int8)(unsafe.Pointer(ts + 10931)),
} /* preprocess.c:1049:15 */

// __TIME__ is expanded to the current time, e.g. "13:34:03".
func format_time(tls *libc.TLS, tm1 uintptr) uintptr { /* preprocess.c:1058:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	return format(tls, ts+10935, libc.VaList(bp, (*tm)(unsafe.Pointer(tm1)).tm_hour, (*tm)(unsafe.Pointer(tm1)).tm_min, (*tm)(unsafe.Pointer(tm1)).tm_sec))
}

func init_macros(tls *libc.TLS) { /* preprocess.c:1062:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Define predefined macros
	define_macro(tls, ts+10952, ts+7069)
	define_macro(tls, ts+10958, ts+7069)
	define_macro(tls, ts+10983, ts+7069)
	define_macro(tls, ts+10991, ts+7069)
	define_macro(tls, ts+11000, ts+11018)
	define_macro(tls, ts+11020, ts+11037)
	define_macro(tls, ts+11039, ts+11037)
	define_macro(tls, ts+11054, ts+11018)
	define_macro(tls, ts+11077, ts+11018)
	define_macro(tls, ts+11098, ts+11018)
	define_macro(tls, ts+11114, ts+11018)
	define_macro(tls, ts+11133, ts+11018)
	define_macro(tls, ts+11154, ts+11171)
	define_macro(tls, ts+11173, ts+11018)
	define_macro(tls, ts+11191, ts+11205)
	define_macro(tls, ts+11219, ts+7069)
	define_macro(tls, ts+11235, ts+7069)
	define_macro(tls, ts+11255, ts+7069)
	define_macro(tls, ts+11271, ts+7069)
	define_macro(tls, ts+11287, ts+11304)
	define_macro(tls, ts+11312, ts+7069)
	define_macro(tls, ts+11321, ts+8912)
	define_macro(tls, ts+11343, ts+9838)
	define_macro(tls, ts+11355, ts+7069)
	define_macro(tls, ts+11363, ts+7069)
	define_macro(tls, ts+11373, ts+7069)
	define_macro(tls, ts+11385, ts+8623)
	define_macro(tls, ts+11395, ts+7069)
	define_macro(tls, ts+11409, ts+8450)
	define_macro(tls, ts+11420, ts+7069)
	define_macro(tls, ts+11428, ts+7069)
	define_macro(tls, ts+11438, ts+8825)
	define_macro(tls, ts+11449, ts+8774)
	define_macro(tls, ts+11460, ts+7069)
	define_macro(tls, ts+11467, ts+7069)
	define_macro(tls, ts+11476, ts+8629)
	define_macro(tls, ts+11489, ts+7069)
	define_macro(tls, ts+11498, ts+7069)
	define_macro(tls, ts+11509, ts+7069)
	define_macro(tls, ts+11515, ts+7069)

	add_builtin(tls, ts+11520, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{file_macro})))
	add_builtin(tls, ts+11529, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{line_macro})))
	add_builtin(tls, ts+11538, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{counter_macro})))
	add_builtin(tls, ts+11550, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{timestamp_macro})))
	add_builtin(tls, ts+11564, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{base_file_macro})))

	*(*time_t)(unsafe.Pointer(bp /* now */)) = libc.Xtime(tls, uintptr(0))
	var tm1 uintptr = libc.Xlocaltime(tls, bp)
	define_macro(tls, ts+11578, format_date(tls, tm1))
	define_macro(tls, ts+11587, format_time(tls, tm1))
}

type StringKind = uint32 /* preprocess.c:1119:3 */

func getStringKind(tls *libc.TLS, tok uintptr) StringKind { /* preprocess.c:1121:19: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if !(libc.Xstrcmp(tls, (*Token)(unsafe.Pointer(tok)).loc, ts+11596) != 0) {
		return STR_UTF8
	}

	switch int32(*(*int8)(unsafe.Pointer((*Token)(unsafe.Pointer(tok)).loc))) {
	case '"':
		return STR_NONE
	case 'u':
		return STR_UTF16
	case 'U':
		return STR_UTF32
	case 'L':
		return STR_WIDE
	}
	error(tls, ts+217, libc.VaList(bp, ts+11599, 1131))
	return StringKind(0)
}

// Concatenate adjacent string literals into a single string literal
// as per the C spec.
func join_adjacent_string_literals(tls *libc.TLS, tok uintptr) { /* preprocess.c:1136:13: */
	// First pass: If regular string literals are adjacent to wide
	// string literals, regular string literals are converted to a wide
	// type before concatenation. In this pass, we do the conversion.
	{
		var tok1 uintptr = tok
		for (*Token)(unsafe.Pointer(tok1)).kind != TK_EOF {
			if (*Token)(unsafe.Pointer(tok1)).kind != TK_STR || (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok1)).next)).kind != TK_STR {
				tok1 = (*Token)(unsafe.Pointer(tok1)).next
				continue
			}

			var kind StringKind = getStringKind(tls, tok1)
			var basety uintptr = (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok1)).ty)).base

			{
				var t uintptr = (*Token)(unsafe.Pointer(tok1)).next
				for ; (*Token)(unsafe.Pointer(t)).kind == TK_STR; t = (*Token)(unsafe.Pointer(t)).next {
					var k StringKind = getStringKind(tls, t)
					if kind == STR_NONE {
						kind = k
						basety = (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(t)).ty)).base
					} else if k != STR_NONE && kind != k {
						error_tok(tls, t, ts+11612, 0)
					}
				}
			}

			if (*Type)(unsafe.Pointer(basety)).size > 1 {
				var t uintptr = tok1
				for ; (*Token)(unsafe.Pointer(t)).kind == TK_STR; t = (*Token)(unsafe.Pointer(t)).next {
					if (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(t)).ty)).base)).size == 1 {
						*(*Token)(unsafe.Pointer(t)) = *(*Token)(unsafe.Pointer(tokenize_string_literal(tls, t, basety)))
					}
				}
			}

			for (*Token)(unsafe.Pointer(tok1)).kind == TK_STR {
				tok1 = (*Token)(unsafe.Pointer(tok1)).next
			}
		}
	}

	// Second pass: concatenate adjacent string literals.
	{
		var tok11 uintptr = tok
		for (*Token)(unsafe.Pointer(tok11)).kind != TK_EOF {
			if (*Token)(unsafe.Pointer(tok11)).kind != TK_STR || (*Token)(unsafe.Pointer((*Token)(unsafe.Pointer(tok11)).next)).kind != TK_STR {
				tok11 = (*Token)(unsafe.Pointer(tok11)).next
				continue
			}

			var tok2 uintptr = (*Token)(unsafe.Pointer(tok11)).next
			for (*Token)(unsafe.Pointer(tok2)).kind == TK_STR {
				tok2 = (*Token)(unsafe.Pointer(tok2)).next
			}

			var len int32 = (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok11)).ty)).array_len
			{
				var t uintptr = (*Token)(unsafe.Pointer(tok11)).next
				for ; t != tok2; t = (*Token)(unsafe.Pointer(t)).next {
					len = len + (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(t)).ty)).array_len - 1
				}
			}

			var buf uintptr = libc.Xcalloc(tls, uint64((*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok11)).ty)).base)).size), uint64(len))

			var i int32 = 0
			{
				var t1 uintptr = tok11
				for ; t1 != tok2; t1 = (*Token)(unsafe.Pointer(t1)).next {
					libc.Xmemcpy(tls, buf+uintptr(i), (*Token)(unsafe.Pointer(t1)).str, uint64((*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(t1)).ty)).size))
					i = i + (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(t1)).ty)).size - (*Type)(unsafe.Pointer((*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(t1)).ty)).base)).size
				}
			}

			*(*Token)(unsafe.Pointer(tok11)) = *(*Token)(unsafe.Pointer(copy_token(tls, tok11)))
			(*Token)(unsafe.Pointer(tok11)).ty = array_of(tls, (*Type)(unsafe.Pointer((*Token)(unsafe.Pointer(tok11)).ty)).base, len)
			(*Token)(unsafe.Pointer(tok11)).str = buf
			(*Token)(unsafe.Pointer(tok11)).next = tok2
			tok11 = tok2
		}
	}
}

// Entry point function of the preprocessor.
func preprocess(tls *libc.TLS, tok uintptr) uintptr { /* preprocess.c:1202:7: */
	tok = preprocess2(tls, tok)
	if cond_incl != 0 {
		error_tok(tls, (*CondIncl)(unsafe.Pointer(cond_incl)).tok, ts+11670, 0)
	}
	convert_pp_tokens(tls, tok)
	join_adjacent_string_literals(tls, tok)

	{
		var t uintptr = tok
		for ; t != 0; t = (*Token)(unsafe.Pointer(t)).next {
			*(*int32)(unsafe.Pointer(t + 80)) += (*Token)(unsafe.Pointer(t)).line_delta
		}
	}
	return tok
}
