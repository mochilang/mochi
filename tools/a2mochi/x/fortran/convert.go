//go:build slow

package fortran

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	mochias "mochi/ast"
	"mochi/parser"
	transpmeta "mochi/transpiler/meta"
)

// Node represents a parsed Fortran program. Only the source lines are kept.
type Node struct {
	Lines []string
}

// Parse splits the source into lines and returns a Node.
func Parse(src string) (*Node, error) {
	lines := strings.Split(strings.ReplaceAll(src, "\r\n", "\n"), "\n")
	return &Node{Lines: lines}, nil
}

// ConvertSource converts the parsed Node into Mochi source code.
func ConvertSource(n *Node) (string, error) {
	if n == nil {
		return "", fmt.Errorf("nil node")
	}
	var b strings.Builder
	b.WriteString(header())
	b.WriteByte('\n')
	b.WriteString("/*\n")
	for _, l := range n.Lines {
		b.WriteString(l)
		if !strings.HasSuffix(l, "\n") {
			b.WriteByte('\n')
		}
	}
	b.WriteString("*/\n")
	return b.String(), nil
}

// Convert parses the Mochi source produced by ConvertSource into an AST node.
func Convert(n *Node) (*mochias.Node, error) {
	src, err := ConvertSource(n)
	if err != nil {
		return nil, err
	}
	prog, err := parser.ParseString(src)
	if err != nil {
		return nil, err
	}
	return mochias.FromProgram(prog), nil
}

// ConvertFile reads a Fortran file and returns the Mochi source string.
func ConvertFileSource(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	node, err := Parse(string(data))
	if err != nil {
		return "", err
	}
	return ConvertSource(node)
}

// ConvertFile reads a Fortran file and converts it to a Mochi AST.
func ConvertFile(path string) (*mochias.Node, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	node, err := Parse(string(data))
	if err != nil {
		return nil, err
	}
	return Convert(node)
}

func header() string {
	loc := time.FixedZone("GMT+7", 7*3600)
	var t time.Time
	if ts := os.Getenv("MOCHI_HEADER_TIME"); ts != "" {
		if tt, err := time.Parse(time.RFC3339, ts); err == nil {
			t = tt.In(loc)
		}
	}
	if t.IsZero() {
		if epoch := os.Getenv("SOURCE_DATE_EPOCH"); epoch != "" {
			if secs, err := strconv.ParseInt(epoch, 10, 64); err == nil {
				t = time.Unix(secs, 0).In(loc)
			}
		}
	}
	if t.IsZero() {
		t = time.Now().In(loc)
	}
	ver := transpmeta.Version()
	return fmt.Sprintf("/* Generated by a2mochi v%s on %s */", ver, t.Format("2006-01-02 15:04:05 MST"))
}

// RepoRoot attempts to locate the repository root directory containing go.mod.
func RepoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}
