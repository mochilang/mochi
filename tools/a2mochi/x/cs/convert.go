//go:build slow

package cs

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"mochi/ast"
	"mochi/parser"
)

var (
	longLit   = regexp.MustCompile(`\b([0-9]+)L\b`)
	varDeclRE = regexp.MustCompile(`^([A-Za-z0-9_<>\[\]]+)\s+([A-Za-z_][A-Za-z0-9_]*)\s*=`)
)

func stripLong(s string) string { return longLit.ReplaceAllString(s, "$1") }

func convertExpr(s string) string {
	s = strings.TrimSpace(s)
	if strings.Contains(s, "string.Join(") {
		s = strings.Replace(s, "string.Join", "join", 1)
	}
	if m := regexp.MustCompile(`(?i)([A-Za-z_][A-Za-z0-9_]*)\.Append\(([^)]*)\)\.ToArray\(\)`).FindStringSubmatch(s); m != nil {
		s = fmt.Sprintf("append(%s, %s)", m[1], m[2])
	}
	if q := strings.Index(s, "?"); q != -1 {
		if c := strings.Index(s[q+1:], ":"); c != -1 {
			cond := strings.TrimSpace(s[:q])
			thenPart := strings.TrimSpace(s[q+1 : q+1+c])
			elsePart := strings.TrimSpace(s[q+1+c+1:])
			s = fmt.Sprintf("if %s { %s } else { %s }", cond, thenPart, elsePart)
		}
	}
	return s
}

// AST represents a very small subset of a C# source file.
type AST struct {
	Types []Type
	Src   string
}

var version string

func init() {
	_, file, _, _ := runtime.Caller(0)
	root := filepath.Join(filepath.Dir(file), "../../../..")
	if b, err := os.ReadFile(filepath.Join(root, "VERSION")); err == nil {
		version = strings.TrimSpace(string(b))
	} else {
		version = "unknown"
	}
}

func timestamp() string {
	loc := time.FixedZone("GMT+7", 7*3600)
	return time.Now().In(loc).Format("2006-01-02 15:04:05")
}

type Type struct {
	Name      string
	Kind      string
	Access    string
	StartLine int
	EndLine   int
	Fields    []Field
	Methods   []Func
	Doc       string
}

type Field struct {
	Name   string
	Type   string
	Access string
	Line   int
	Doc    string
}

type Func struct {
	Name      string
	Params    []Param
	Ret       string
	Access    string
	Static    bool
	Body      []string
	StartLine int
	EndLine   int
	Doc       string
}

type Param struct {
	Name string
	Type string
}

// Parse parses a restricted subset of C# source code.
func Parse(src string) (*AST, error) { return parseSimple(src) }

// ConvertSource converts the parsed AST into Mochi source code.
func ConvertSource(ast *AST) (string, error) {
	code, err := convertAST(ast)
	if err != nil {
		return "", err
	}
	var out strings.Builder
	fmt.Fprintf(&out, "# Generated by a2mochi cs v%s on %s GMT+7\n", version, timestamp())
	if ast != nil && ast.Src != "" {
		out.WriteString("/*\n")
		out.WriteString(ast.Src)
		if !strings.HasSuffix(ast.Src, "\n") {
			out.WriteByte('\n')
		}
		out.WriteString("*/\n")
	}
	out.WriteString(code)
	return out.String(), nil
}

// Convert converts the parsed AST into a Mochi AST node.
func Convert(astNode *AST) (*ast.Node, error) {
	src, err := ConvertSource(astNode)
	if err != nil {
		return nil, err
	}
	prog, err := parser.ParseString(src)
	if err != nil {
		return nil, err
	}
	return ast.FromProgram(prog), nil
}

// --- Implementation below mostly ported from archived any2mochi ---

func convertAST(ast *AST) (string, error) {
	if ast == nil {
		return "", fmt.Errorf("nil ast")
	}
	var out strings.Builder
	for _, t := range ast.Types {
		if t.Doc != "" {
			for _, ln := range strings.Split(t.Doc, "\n") {
				out.WriteString("# ")
				out.WriteString(strings.TrimSpace(ln))
				out.WriteByte('\n')
			}
		}
		out.WriteString("type ")
		out.WriteString(t.Name)
		out.WriteString(" {\n")
		for _, f := range t.Fields {
			if f.Doc != "" {
				for _, ln := range strings.Split(f.Doc, "\n") {
					out.WriteString("  # ")
					out.WriteString(strings.TrimSpace(ln))
					out.WriteByte('\n')
				}
			}
			out.WriteString("  ")
			out.WriteString(f.Name)
			if ft := mapType(f.Type); ft != "" {
				out.WriteString(": ")
				out.WriteString(ft)
			}
			out.WriteByte('\n')
		}
		out.WriteString("}\n")
		for _, fn := range t.Methods {
			if fn.Doc != "" {
				for _, ln := range strings.Split(fn.Doc, "\n") {
					out.WriteString("# ")
					out.WriteString(strings.TrimSpace(ln))
					out.WriteByte('\n')
				}
			}
			out.WriteString("fun ")
			out.WriteString(t.Name)
			out.WriteByte('.')
			out.WriteString(fn.Name)
			out.WriteByte('(')
			for i, p := range fn.Params {
				if i > 0 {
					out.WriteString(", ")
				}
				out.WriteString(p.Name)
				if pt := mapType(p.Type); pt != "" {
					out.WriteString(": ")
					out.WriteString(pt)
				}
			}
			out.WriteByte(')')
			if rt := mapType(fn.Ret); rt != "" {
				out.WriteString(": ")
				out.WriteString(rt)
			}
			body := convertBodyLines(fn.Body)
			if len(body) == 0 {
				out.WriteString(" {}\n")
			} else {
				out.WriteString(" {\n")
				for _, b := range body {
					out.WriteString("  ")
					out.WriteString(b)
					out.WriteByte('\n')
				}
				out.WriteString("}\n")
			}
		}
	}
	if out.Len() == 0 {
		return "", fmt.Errorf("no convertible symbols found")
	}
	return out.String(), nil
}

func convertBodyLines(body []string) []string {
	var out []string
	for _, ln := range body {
		l := strings.TrimSpace(ln)
		if l == "" {
			continue
		}
		if strings.HasSuffix(l, ";") {
			l = strings.TrimSuffix(l, ";")
		}
		l = stripLong(l)
		switch {
		case strings.HasPrefix(l, "Console.WriteLine("):
			l = "print(" + strings.TrimPrefix(strings.TrimSuffix(l, ")"), "Console.WriteLine(") + ")"
		case strings.HasPrefix(l, "return "):
			l = "return " + strings.TrimSpace(strings.TrimPrefix(l, "return "))
		case strings.HasPrefix(l, "foreach ("):
			inner := strings.TrimPrefix(l, "foreach (")
			inner = strings.TrimSuffix(inner, ") {")
			parts := strings.SplitN(inner, " in ", 2)
			if len(parts) == 2 {
				varName := strings.TrimSpace(parts[0])
				fs := strings.Fields(varName)
				if len(fs) > 1 {
					varName = fs[len(fs)-1]
				}
				iter := strings.TrimSpace(parts[1])
				l = fmt.Sprintf("for %s in %s {", varName, iter)
			}
		case strings.HasPrefix(l, "for (") && strings.Contains(l, ";") && strings.Contains(l, ")"):
			l = strings.TrimPrefix(l, "for (")
			l = strings.TrimSuffix(l, ") {")
			parts := strings.Split(l, ";")
			if len(parts) >= 2 {
				init := strings.TrimSpace(parts[0])
				cond := strings.TrimSpace(parts[1])
				if strings.HasPrefix(init, "var ") {
					init = strings.TrimPrefix(init, "var ")
				}
				if eq := strings.Index(init, "="); eq != -1 {
					name := strings.TrimSpace(init[:eq])
					startVal := strings.TrimSpace(init[eq+1:])
					startVal = stripLong(startVal)
					endVal := ""
					if idx := strings.Index(cond, "<"); idx != -1 {
						endVal = strings.TrimSpace(cond[idx+1:])
						endVal = stripLong(endVal)
					}
					l = fmt.Sprintf("for %s in %s..%s {", name, startVal, endVal)
				}
			}
		case strings.HasPrefix(l, "while ("):
			l = strings.TrimPrefix(l, "while (")
			l = strings.TrimSpace(strings.TrimSuffix(l, "{"))
			if strings.HasSuffix(l, ")") {
				idx := strings.LastIndex(l, ")")
				l = l[:idx]
			}
			l = strings.TrimSpace(l)
			l = stripLong(l)
			l = "while " + l + " {"
		case strings.HasPrefix(l, "if ("):
			l = strings.TrimPrefix(l, "if (")
			l = strings.TrimSuffix(l, ") {")
			l = stripLong(l)
			l = "if " + l + " {"
		case l == "}" || l == "} else {":
			// keep as is
		default:
			if m := varDeclRE.FindStringSubmatch(l); m != nil {
				name := m[2]
				rest := strings.TrimSpace(l[len(m[0]):])
				l = "var " + name + " = " + rest
			} else {
				for _, t := range []string{"long ", "int ", "float ", "double ", "string ", "bool "} {
					if strings.HasPrefix(l, t) {
						l = strings.TrimPrefix(l, t)
						if strings.HasPrefix(t, "string") {
							l = "var " + l
						} else {
							l = "var " + stripLong(l)
						}
						break
					}
				}
				l = stripLong(l)
			}
		}
		l = convertExpr(l)
		out = append(out, l)
	}
	return out
}

func mapType(t string) string {
	t = strings.TrimSpace(t)
	for strings.HasSuffix(t, "[]") {
		inner := mapType(strings.TrimSuffix(t, "[]"))
		if inner == "" {
			inner = "any"
		}
		return "list<" + inner + ">"
	}
	if idx := strings.LastIndex(t, "."); idx != -1 {
		t = t[idx+1:]
	}
	switch t {
	case "void", "":
		return ""
	case "int", "long", "short", "uint", "ulong", "ushort", "byte", "sbyte":
		return "int"
	case "float", "double", "decimal":
		return "float"
	case "string", "char":
		return "string"
	case "bool":
		return "bool"
	case "dynamic", "object":
		return "any"
	}
	if strings.HasSuffix(t, ">") {
		if open := strings.Index(t, "<"); open != -1 {
			outer := t[:open]
			inner := t[open+1 : len(t)-1]
			args := splitArgs(inner)
			switch outer {
			case "List", "IEnumerable", "IList", "ICollection", "IReadOnlyList":
				a := "any"
				if len(args) > 0 {
					if at := mapType(args[0]); at != "" {
						a = at
					}
				}
				return "list<" + a + ">"
			case "Dictionary", "IDictionary":
				if len(args) == 2 {
					k := mapType(args[0])
					if k == "" {
						k = "any"
					}
					v := mapType(args[1])
					if v == "" {
						v = "any"
					}
					return "map<" + k + ", " + v + ">"
				}
			case "Nullable":
				if len(args) == 1 {
					return mapType(args[0])
				}
			}
		}
	}
	return ""
}

func splitArgs(s string) []string {
	var parts []string
	depth := 0
	start := 0
	for i, r := range s {
		switch r {
		case '[', '(', '<':
			depth++
		case ']', ')', '>':
			if depth > 0 {
				depth--
			}
		case ',':
			if depth == 0 {
				parts = append(parts, strings.TrimSpace(s[start:i]))
				start = i + 1
			}
		}
	}
	if start < len(s) {
		parts = append(parts, strings.TrimSpace(s[start:]))
	}
	return parts
}

// --- minimal parser ---
func parseSimple(src string) (*AST, error) {
	lines := strings.Split(src, "\n")
	var ast AST
	ast.Src = src
	var cur *Type
	depth := 0
	var pendingDoc []string
	for i := 0; i < len(lines); i++ {
		l := strings.TrimSpace(lines[i])
		if strings.HasPrefix(l, "//") || l == "" {
			if strings.HasPrefix(l, "//") {
				pendingDoc = append(pendingDoc, strings.TrimSpace(strings.TrimPrefix(l, "//")))
			}
			continue
		}
		if m := typeRE.FindStringSubmatch(l); m != nil {
			t := &Type{Name: m[2], Kind: strings.ToLower(m[1]), StartLine: i + 1, Doc: strings.Join(pendingDoc, "\n")}
			if strings.Contains(l, "public") {
				t.Access = "public"
			} else if strings.Contains(l, "protected") {
				t.Access = "protected"
			} else if strings.Contains(l, "private") {
				t.Access = "private"
			}
			pendingDoc = nil
			ast.Types = append(ast.Types, *t)
			cur = &ast.Types[len(ast.Types)-1]
			if strings.Contains(l, "{") {
				depth++
			} else if i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == "{" {
				depth++
				i++
			}
			continue
		}
		if strings.Contains(l, "{") {
			depth++
		}
		if strings.Contains(l, "}") {
			depth--
			if depth == 0 {
				if cur != nil {
					cur.EndLine = i + 1
				}
				cur = nil
			}
			continue
		}
		if cur == nil {
			continue
		}
		if m := funcRE.FindStringSubmatch(l); m != nil {
			fn := Func{Name: m[2], Ret: strings.TrimSpace(m[1]), StartLine: i + 1, Doc: strings.Join(pendingDoc, "\n")}
			if strings.Contains(l, "static") {
				fn.Static = true
			}
			if strings.Contains(l, "public") {
				fn.Access = "public"
			} else if strings.Contains(l, "protected") {
				fn.Access = "protected"
			} else if strings.Contains(l, "private") {
				fn.Access = "private"
			}
			pendingDoc = nil
			params := strings.Split(strings.TrimSpace(m[3]), ",")
			for _, p := range params {
				p = strings.TrimSpace(p)
				if p == "" {
					continue
				}
				parts := strings.Fields(p)
				if len(parts) == 1 {
					fn.Params = append(fn.Params, Param{Name: parts[0]})
				} else {
					fn.Params = append(fn.Params, Param{Type: parts[0], Name: parts[1]})
				}
			}
			if !strings.Contains(l, "{") && i+1 < len(lines) && strings.TrimSpace(lines[i+1]) == "{" {
				i++
			}
			var body []string
			braces := 1
			for j := i + 1; j < len(lines); j++ {
				if strings.Contains(lines[j], "{") {
					braces++
				}
				if strings.Contains(lines[j], "}") {
					braces--
					if braces == 0 {
						i = j
						fn.EndLine = j + 1
						break
					}
				}
				body = append(body, lines[j])
			}
			fn.Body = body
			cur.Methods = append(cur.Methods, fn)
			continue
		}
		if m := fieldRE.FindStringSubmatch(l); m != nil && strings.HasSuffix(l, ";") {
			f := Field{Name: m[2], Type: strings.TrimSpace(m[1]), Line: i + 1, Doc: strings.Join(pendingDoc, "\n")}
			if strings.Contains(l, "public") {
				f.Access = "public"
			} else if strings.Contains(l, "protected") {
				f.Access = "protected"
			} else if strings.Contains(l, "private") {
				f.Access = "private"
			}
			cur.Fields = append(cur.Fields, f)
			pendingDoc = nil
			continue
		}

		if m := propertyRE.FindStringSubmatch(l); m != nil {
			f := Field{Name: m[2], Type: strings.TrimSpace(m[1]), Line: i + 1, Doc: strings.Join(pendingDoc, "\n")}
			if strings.Contains(l, "public") {
				f.Access = "public"
			} else if strings.Contains(l, "protected") {
				f.Access = "protected"
			} else if strings.Contains(l, "private") {
				f.Access = "private"
			}
			cur.Fields = append(cur.Fields, f)
			pendingDoc = nil
			continue
		}

		if usingRE.MatchString(l) || namespaceRE.MatchString(l) {
			continue
		}

		// Ignore unsupported lines instead of failing parsing
	}
	if len(ast.Types) == 0 {
		return nil, fmt.Errorf("no types found")
	}
	return &ast, nil
}

var (
	typeRE      = regexp.MustCompile(`(?i)^\s*(?:public\s+|private\s+|protected\s+)?(class|struct|interface|enum)\s+([A-Za-z_][A-Za-z0-9_]*)`)
	funcRE      = regexp.MustCompile(`(?i)^\s*(?:public\s+|private\s+|protected\s+)?(?:static\s+)?([A-Za-z0-9_<>\[\],\s]+)\s+([A-Za-z_][A-Za-z0-9_]*)(?:<[^>]+>)?\s*\(([^)]*)\)\s*\{?`)
	fieldRE     = regexp.MustCompile(`(?i)^\s*(?:public\s+|private\s+|protected\s+)?([A-Za-z0-9_<>\[\],\s]+)\s+([A-Za-z_][A-Za-z0-9_]*)`)
	propertyRE  = regexp.MustCompile(`(?i)^\s*(?:public\s+|private\s+|protected\s+)?([A-Za-z0-9_<>\[\],\s]+)\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{`)
	usingRE     = regexp.MustCompile(`^\s*using\s+`)
	namespaceRE = regexp.MustCompile(`^\s*namespace\s+`)
)
