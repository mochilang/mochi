//go:build slow

package java

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	mochias "mochi/ast"
	mochiparser "mochi/parser"
)

// Node holds parsed Java source. Parsing is not implemented yet.
type Node struct {
	Lines []string
}

// Parse parses Java source code into a Node. Only splitting lines is done for now.
func Parse(src string) (*Node, error) {
	return &Node{Lines: strings.Split(src, "\n")}, nil
}

// ConvertSource converts a parsed Java node into Mochi source code.
// Only a very small subset of Java is supported, enough for a few examples.
func ConvertSource(n *Node) (string, error) {
	if n == nil {
		return "", fmt.Errorf("nil node")
	}
	var out strings.Builder
	out.WriteString(header())
	out.WriteString("/*\n")
	out.WriteString(strings.Join(n.Lines, "\n"))
	if len(n.Lines) == 0 || n.Lines[len(n.Lines)-1] != "" {
		out.WriteByte('\n')
	}
	out.WriteString("*/\n")

	varDecl := regexp.MustCompile(`^static\s+int\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*([-0-9]+);`)
	typedVar := regexp.MustCompile(`^static\s+int\s+([A-Za-z_][A-Za-z0-9_]*)\s*;`)
	assignStmt := regexp.MustCompile(`^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.+);`)
	whileStart := regexp.MustCompile(`^while\s*\((.*)\)\s*\{`)
	forStart := regexp.MustCompile(`^for\s*\(int\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*([^;]+);\s*[A-Za-z_][A-Za-z0-9_]*\s*<\s*([^;]+);\s*[A-Za-z_][A-Za-z0-9_]*\+\+\)\s*\{`)
	printStmt := regexp.MustCompile(`System\.out\.println\((.*)\);`)

	// detect mutated variables so that we emit `var` declarations
	mutated := map[string]bool{}
	for _, line := range n.Lines {
		line = strings.TrimSpace(line)
		if m := assignStmt.FindStringSubmatch(line); m != nil && !strings.HasPrefix(line, "static") {
			mutated[m[1]] = true
		}
	}

	indent := ""
	var stack []string

	for _, line := range n.Lines {
		line = strings.TrimSpace(line)

		if m := varDecl.FindStringSubmatch(line); m != nil {
			kw := "let"
			if mutated[m[1]] {
				kw = "var"
			}
			fmt.Fprintf(&out, "%s%s %s = %s\n", indent, kw, m[1], m[2])
			continue
		}
		if m := typedVar.FindStringSubmatch(line); m != nil {
			fmt.Fprintf(&out, "%svar %s = 0\n", indent, m[1])
			continue
		}
		if m := assignStmt.FindStringSubmatch(line); m != nil && !strings.HasPrefix(line, "static") {
			fmt.Fprintf(&out, "%s%s = %s\n", indent, m[1], m[2])
			continue
		}
		if m := whileStart.FindStringSubmatch(line); m != nil {
			cond := strings.TrimSpace(m[1])
			fmt.Fprintf(&out, "%swhile (%s) {\n", indent, cond)
			indent += "  "
			stack = append(stack, "while")
			continue
		}
		if m := forStart.FindStringSubmatch(line); m != nil {
			name := m[1]
			start := strings.TrimSpace(m[2])
			end := strings.TrimSpace(m[3])
			fmt.Fprintf(&out, "%sfor %s in %s..%s {\n", indent, name, start, end)
			indent += "  "
			stack = append(stack, "for")
			continue
		}
		if line == "}" && len(stack) > 0 {
			indent = indent[:len(indent)-2]
			fmt.Fprintf(&out, "%s}\n", indent)
			stack = stack[:len(stack)-1]
			continue
		}
		if m := printStmt.FindStringSubmatch(line); m != nil {
			expr := strings.TrimSpace(m[1])
			fmt.Fprintf(&out, "%sprint(%s)\n", indent, expr)
		}
	}
	return out.String(), nil
}

// Convert converts a parsed Java Node into a Mochi AST node.
func Convert(n *Node) (*mochias.Node, error) {
	src, err := ConvertSource(n)
	if err != nil {
		return nil, err
	}
	prog, err := mochiparser.ParseString(src)
	if err != nil {
		return nil, err
	}
	return mochias.FromProgram(prog), nil
}

// ConvertFile reads a Java file and converts it to a Mochi AST node.
func ConvertFile(path string) (*mochias.Node, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	n, err := Parse(string(data))
	if err != nil {
		return nil, err
	}
	return Convert(n)
}

// ConvertFileSource reads a Java file and returns the generated Mochi source.
func ConvertFileSource(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	n, err := Parse(string(data))
	if err != nil {
		return "", err
	}
	return ConvertSource(n)
}

func header() string {
	tz := time.FixedZone("GMT+7", 7*3600)
	t := time.Now().In(tz)
	return fmt.Sprintf("// Generated by a2mochi v%s on %s\n", version(), t.Format("2006-01-02 15:04:05 MST"))
}

func version() string {
	root := repoRoot()
	if root == "" {
		return "dev"
	}
	data, err := os.ReadFile(filepath.Join(root, "VERSION"))
	if err != nil {
		return "dev"
	}
	return strings.TrimSpace(string(data))
}

func repoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}
