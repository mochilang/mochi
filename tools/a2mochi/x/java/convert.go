//go:build slow

package java

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	mochias "mochi/ast"
	mochiparser "mochi/parser"
)

// Node holds parsed Java source. Parsing is not implemented yet.
type Node struct {
	Lines []string
}

// Parse parses Java source code into a Node. Only splitting lines is done for now.
func Parse(src string) (*Node, error) {
	return &Node{Lines: strings.Split(src, "\n")}, nil
}

// ConvertSource converts a parsed Java node into Mochi source code.
// Only a very small subset of Java is supported, enough for a few examples.
func ConvertSource(n *Node) (string, error) {
	if n == nil {
		return "", fmt.Errorf("nil node")
	}
	var out strings.Builder
	out.WriteString(header())
	out.WriteString("/*\n")
	out.WriteString(strings.Join(n.Lines, "\n"))
	if len(n.Lines) == 0 || n.Lines[len(n.Lines)-1] != "" {
		out.WriteByte('\n')
	}
	out.WriteString("*/\n")

	varDecl := regexp.MustCompile(`^static\s+int\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*([-0-9]+);`)
	printStmt := regexp.MustCompile(`System\.out\.println\((.*)\);`)

	for _, line := range n.Lines {
		line = strings.TrimSpace(line)
		if m := varDecl.FindStringSubmatch(line); m != nil {
			fmt.Fprintf(&out, "let %s = %s\n", m[1], m[2])
			continue
		}
		if m := printStmt.FindStringSubmatch(line); m != nil {
			expr := strings.TrimSpace(m[1])
			fmt.Fprintf(&out, "print(%s)\n", expr)
		}
	}
	return out.String(), nil
}

// Convert converts a parsed Java Node into a Mochi AST node.
func Convert(n *Node) (*mochias.Node, error) {
	src, err := ConvertSource(n)
	if err != nil {
		return nil, err
	}
	prog, err := mochiparser.ParseString(src)
	if err != nil {
		return nil, err
	}
	return mochias.FromProgram(prog), nil
}

// ConvertFile reads a Java file and converts it to a Mochi AST node.
func ConvertFile(path string) (*mochias.Node, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	n, err := Parse(string(data))
	if err != nil {
		return nil, err
	}
	return Convert(n)
}

// ConvertFileSource reads a Java file and returns the generated Mochi source.
func ConvertFileSource(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	n, err := Parse(string(data))
	if err != nil {
		return "", err
	}
	return ConvertSource(n)
}

func header() string {
	tz := time.FixedZone("GMT+7", 7*3600)
	t := time.Now().In(tz)
	return fmt.Sprintf("// Generated by a2mochi v%s on %s\n", version(), t.Format("2006-01-02 15:04:05 MST"))
}

func version() string {
	root := repoRoot()
	if root == "" {
		return "dev"
	}
	data, err := os.ReadFile(filepath.Join(root, "VERSION"))
	if err != nil {
		return "dev"
	}
	return strings.TrimSpace(string(data))
}

func repoRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return ""
}
