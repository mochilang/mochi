//go:build slow

package scala

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"mochi/ast"
	"mochi/parser"
)

var version string

func init() {
	_, file, _, _ := runtime.Caller(0)
	root := filepath.Join(filepath.Dir(file), "../../../..")
	if b, err := os.ReadFile(filepath.Join(root, "VERSION")); err == nil {
		version = strings.TrimSpace(string(b))
	} else {
		version = "unknown"
	}
}

// Field describes a parameter or struct field with an optional type.
type Field struct {
	Name string
	Type string
}

// Variant represents a case class belonging to a sealed trait.
type Variant struct {
	Name   string
	Fields []Field
}

// TypeDecl holds a trait name and its case class variants.
type TypeDecl struct {
	Name     string
	Variants []Variant
}

// Func represents a top level Scala function extracted from the source.
type Func struct {
	Name   string
	Params []string
	Return string
	Body   []string
}

func convertType(t string) string {
	t = strings.TrimSpace(t)
	builtin := map[string]string{"Int": "int", "Boolean": "bool", "String": "string"}
	if v, ok := builtin[t]; ok {
		return v
	}
	if strings.Contains(t, "=>") {
		parts := strings.SplitN(t, "=>", 2)
		params := strings.TrimSpace(strings.Trim(parts[0], "()"))
		ret := convertType(strings.TrimSpace(parts[1]))
		return "fun(" + params + "): " + ret
	}
	return t
}

// Var represents a top level variable definition.
type Var struct {
	Name    string
	Expr    string
	Mutable bool
}

// File represents a parsed Scala source file.
type File struct {
	Types  []TypeDecl
	Funcs  []Func
	Vars   []Var
	Source string
}

// Parse parses a limited subset of Scala into a File structure.
func Parse(src string) (*File, error) {
	f := parseSource(src)
	f.Source = src
	return &f, nil
}

// ConvertSource converts a parsed File into Mochi source code.
func ConvertSource(f *File) (string, error) {
	var b strings.Builder
	v := strings.TrimSpace(version)
	loc := time.FixedZone("GMT+7", 7*3600)
	ts := time.Now().In(loc).Format("2006-01-02 15:04:05 MST")
	fmt.Fprintf(&b, "// Generated by a2mochi v%s on %s\n", v, ts)
	if f.Source != "" {
		b.WriteString("/*\n")
		b.WriteString(f.Source)
		if !strings.HasSuffix(f.Source, "\n") {
			b.WriteByte('\n')
		}
		b.WriteString("*/\n")
	}

	for _, t := range f.Types {
		code := convertTypeDecl(t)
		if code != "" {
			b.WriteString(code)
			b.WriteByte('\n')
		}
	}
	for _, v := range f.Vars {
		if v.Mutable {
			b.WriteString("var ")
		} else {
			b.WriteString("let ")
		}
		b.WriteString(v.Name)
		if v.Expr != "" {
			b.WriteString(" = ")
			b.WriteString(convertExpr(f, v.Expr))
		}
		b.WriteByte('\n')
	}
	for _, fn := range f.Funcs {
		code := convertFromAST(f, fn)
		if code == "" {
			continue
		}
		b.WriteString(code)
		b.WriteByte('\n')
	}
	if b.Len() == 0 {
		return "", fmt.Errorf("no convertible symbols found")
	}
	return strings.TrimSuffix(b.String(), "\n"), nil
}

// Convert converts a parsed File into a Mochi AST node.
func Convert(f *File) (*ast.Node, error) {
	src, err := ConvertSource(f)
	if err != nil {
		return nil, err
	}
	prog, err := parser.ParseString(src)
	if err != nil {
		return nil, err
	}
	return ast.FromProgram(prog), nil
}

// --- parsing helpers ---

func parseSource(src string) File {
	lines := strings.Split(strings.ReplaceAll(src, "\r\n", "\n"), "\n")
	reHeader := regexp.MustCompile(`^def\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)(?:\s*:\s*([^=]+(?:=>[^=]+)?))?\s*=\s*(\{)?`)
	reTrait := regexp.MustCompile(`^sealed\s+trait\s+([a-zA-Z0-9_]+)`)
	reCaseClass := regexp.MustCompile(`^case\s+class\s+([a-zA-Z0-9_]+)\(([^)]*)\)(?:\s+extends\s+([a-zA-Z0-9_]+))?`)
	reCaseObj := regexp.MustCompile(`^case\s+object\s+([a-zA-Z0-9_]+)(?:\s+extends\s+([a-zA-Z0-9_]+))?`)
	reGlobal := regexp.MustCompile(`^(var|val)\s+([a-zA-Z0-9_]+)(?:\s*:\s*[^=]+)?\s*=\s*(.*)`)
	var file File
	traitMap := map[string]*TypeDecl{}
	for i := 0; i < len(lines); i++ {
		line := strings.TrimSpace(lines[i])
		if m := reTrait.FindStringSubmatch(line); m != nil {
			name := m[1]
			td := TypeDecl{Name: name}
			file.Types = append(file.Types, td)
			traitMap[name] = &file.Types[len(file.Types)-1]
			continue
		}
		if m := reCaseClass.FindStringSubmatch(line); m != nil {
			name := m[1]
			fields := []Field{}
			for _, part := range strings.Split(m[2], ",") {
				part = strings.TrimSpace(part)
				if part == "" {
					continue
				}
				fname := part
				ftype := ""
				if idx := strings.Index(part, ":"); idx != -1 {
					fname = strings.TrimSpace(part[:idx])
					ftype = strings.TrimSpace(part[idx+1:])
				}
				fields = append(fields, Field{Name: fname, Type: ftype})
			}
			variant := Variant{Name: name, Fields: fields}
			trait := m[3]
			if trait != "" {
				td, ok := traitMap[trait]
				if !ok {
					td = &TypeDecl{Name: trait}
					file.Types = append(file.Types, *td)
					traitMap[trait] = &file.Types[len(file.Types)-1]
				}
				tptr := traitMap[trait]
				tptr.Variants = append(tptr.Variants, variant)
			} else {
				file.Types = append(file.Types, TypeDecl{Name: name, Variants: []Variant{variant}})
			}
			continue
		}
		if m := reCaseObj.FindStringSubmatch(line); m != nil {
			name := m[1]
			variant := Variant{Name: name}
			trait := m[2]
			if trait != "" {
				td, ok := traitMap[trait]
				if !ok {
					td = &TypeDecl{Name: trait}
					file.Types = append(file.Types, *td)
					traitMap[trait] = &file.Types[len(file.Types)-1]
				}
				traitMap[trait].Variants = append(traitMap[trait].Variants, variant)
			} else {
				file.Types = append(file.Types, TypeDecl{Name: name, Variants: []Variant{variant}})
			}
			continue
		}
		if m := reGlobal.FindStringSubmatch(line); m != nil {
			mut := m[1] == "var"
			name := m[2]
			expr := strings.TrimSpace(m[3])
			file.Vars = append(file.Vars, Var{Name: name, Expr: expr, Mutable: mut})
			continue
		}
		if m := reHeader.FindStringSubmatch(line); m != nil {
			name := m[1]
			params := []string{}
			for _, p := range strings.Split(m[2], ",") {
				p = strings.TrimSpace(p)
				if p == "" {
					continue
				}
				if idx := strings.Index(p, ":"); idx != -1 {
					p = strings.TrimSpace(p[:idx])
				}
				params = append(params, p)
			}
			body := []string{}
			ret := convertType(strings.TrimSpace(m[3]))
			if m[4] == "{" {
				depth := 1
				for j := i + 1; j < len(lines); j++ {
					l := strings.TrimSpace(lines[j])
					if strings.Contains(l, "{") {
						depth++
					}
					if strings.Contains(l, "}") {
						depth--
						if depth == 0 {
							i = j
							break
						}
					}
					body = append(body, l)
				}
			}
			file.Funcs = append(file.Funcs, Func{Name: name, Params: params, Return: ret, Body: body})
		}
	}
	file.Source = src
	return file
}

// --- conversion helpers ---

func convertFromAST(file *File, fn Func) string {
	var b strings.Builder
	topLevel := fn.Name == "main"
	if !topLevel {
		b.WriteString("fun ")
		b.WriteString(fn.Name)
		b.WriteByte('(')
		for i, p := range fn.Params {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(p)
		}
		b.WriteString(")")
		if fn.Return != "" {
			b.WriteString(": ")
			b.WriteString(fn.Return)
		}
		b.WriteString(" {\n")
	}
	indent := 1
	if topLevel {
		indent = 0
	}
	write := func(s string) {
		b.WriteString(strings.Repeat("  ", indent))
		b.WriteString(s)
		b.WriteByte('\n')
	}

	reWhile := regexp.MustCompile(`^while\s*\((.*)\)\s*{`)
	reFor := regexp.MustCompile(`^for \(([^<-]+)<-([^\)]+)\)\s*{`)
	reIf := regexp.MustCompile(`^if\s*\((.*)\)\s*{`)
	reElseIf := regexp.MustCompile(`^}\s*else if\s*\((.*)\)\s*{`)
	reElse := regexp.MustCompile(`^}\s*else\s*{`)

	for _, l := range fn.Body {
		line := strings.TrimSpace(l)
		if line == "" {
			continue
		}
		if line == "}" {
			indent--
			write("}")
			if indent == 0 {
				break
			}
			continue
		}
		if m := reElseIf.FindStringSubmatch(line); m != nil {
			indent--
			write("else if " + convertExpr(file, strings.TrimSpace(m[1])) + " {")
			indent++
			continue
		}
		if reElse.MatchString(line) {
			indent--
			write("else {")
			indent++
			continue
		}
		if m := reWhile.FindStringSubmatch(line); m != nil {
			write("while " + convertExpr(file, strings.TrimSpace(m[1])) + " {")
			indent++
			continue
		}
		if m := reFor.FindStringSubmatch(line); m != nil {
			name := strings.TrimSpace(m[1])
			expr := convertExpr(file, strings.TrimSpace(m[2]))
			write("for " + name + " in " + expr + " {")
			indent++
			continue
		}
		if m := reIf.FindStringSubmatch(line); m != nil {
			write("if " + convertExpr(file, strings.TrimSpace(m[1])) + " {")
			indent++
			continue
		}
		switch {
		case strings.HasPrefix(line, "println("):
			expr := strings.TrimSuffix(strings.TrimPrefix(line, "println("), ")")
			write("print(" + convertExpr(file, expr) + ")")
		case strings.HasPrefix(line, "return "):
			expr := strings.TrimSpace(strings.TrimPrefix(line, "return "))
			write("return " + convertExpr(file, expr))
		case strings.HasPrefix(line, "var "):
			content := strings.TrimPrefix(line, "var ")
			if idx := strings.Index(content, "="); idx != -1 {
				left := strings.TrimSpace(content[:idx])
				expr := strings.TrimSpace(content[idx+1:])
				name := left
				if c := strings.Index(left, ":"); c != -1 {
					name = strings.TrimSpace(left[:c])
				}
				write("var " + name + " = " + convertExpr(file, expr))
			} else {
				write("var " + content)
			}
		case strings.HasPrefix(line, "val "):
			if idx := strings.Index(line, "="); idx != -1 {
				left := strings.TrimSpace(line[4:idx])
				expr := strings.TrimSpace(line[idx+1:])
				name := left
				if c := strings.Index(left, ":"); c != -1 {
					name = strings.TrimSpace(left[:c])
				}
				write("let " + name + " = " + convertExpr(file, expr))
			}
		case strings.Contains(line, ".append("):
			idx := strings.Index(line, ".append(")
			recv := strings.TrimSpace(line[:idx])
			arg := strings.TrimSuffix(line[idx+8:], ")")
			write("append(" + recv + ", " + convertExpr(file, arg) + ")")
		case strings.Contains(line, "="):
			parts := strings.SplitN(line, "=", 2)
			left := strings.TrimSpace(parts[0])
			right := strings.TrimSpace(parts[1])
			if left != "" && right != "" {
				write(left + " = " + convertExpr(file, right))
			}
		}
	}
	if !topLevel {
		b.WriteString("}")
	}
	return b.String()
}

var (
	reIndex  = regexp.MustCompile(`^([a-z][a-zA-Z0-9_]*)\(([^()]*)\)$`)
	reLambda = regexp.MustCompile(`^\(([^)]*)\)\s*=>\s*(.*)$`)
)

func convertExpr(file *File, expr string) string {
	expr = strings.TrimSpace(expr)
	if strings.HasSuffix(expr, ".toString()") {
		expr = "str(" + strings.TrimSuffix(expr, ".toString()") + ")"
	}
	if strings.HasSuffix(expr, ".toInt") {
		expr = "int(" + strings.TrimSuffix(expr, ".toInt") + ")"
	}
	if strings.HasSuffix(expr, ".size") {
		inner := strings.TrimSuffix(expr, ".size")
		expr = "len(" + convertExpr(file, inner) + ")"
	}
	if strings.HasSuffix(expr, ".length") {
		inner := strings.TrimSuffix(expr, ".length")
		expr = "len(" + convertExpr(file, inner) + ")"
	}
	if strings.HasPrefix(expr, "ArrayBuffer(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "ArrayBuffer("), ")")
		expr = "[" + inner + "]"
	}
	if strings.Contains(expr, ".append(") {
		idx := strings.Index(expr, ".append(")
		recv := strings.TrimSpace(expr[:idx])
		arg := strings.TrimSuffix(expr[idx+8:], ")")
		return "append(" + recv + ", " + convertExpr(file, arg) + ")"
	}
	if strings.Contains(expr, " :+ ") {
		parts := strings.SplitN(expr, ":+", 2)
		if len(parts) == 2 {
			left := strings.TrimSpace(parts[0])
			right := strings.TrimSpace(parts[1])
			return "append(" + left + ", " + convertExpr(file, right) + ")"
		}
	}
	if m := reIndex.FindStringSubmatch(expr); m != nil {
		name := m[1]
		builtin := map[string]bool{"int": true, "len": true, "str": true, "append": true, "print": true, "range": true}
		if builtin[name] {
			return expr
		}
		for _, fn := range file.Funcs {
			if fn.Name == name {
				return expr
			}
		}
		return name + "[" + convertExpr(file, m[2]) + "]"
	}
	trimmed := strings.TrimSpace(expr)
	for strings.HasPrefix(trimmed, "(") && strings.HasSuffix(trimmed, ")") {
		trimmed = strings.TrimSpace(trimmed[1 : len(trimmed)-1])
	}
	if m := reLambda.FindStringSubmatch(trimmed); m != nil {
		params := strings.TrimSpace(m[1])
		body := strings.TrimSpace(m[2])
		return "fun(" + params + ") => " + convertExpr(file, body)
	}
	return expr
}

func convertTypeDecl(t TypeDecl) string {
	if len(t.Variants) == 0 {
		return ""
	}
	var b strings.Builder
	b.WriteString("type ")
	b.WriteString(t.Name)
	b.WriteString(" =\n")
	for i, v := range t.Variants {
		if i > 0 {
			b.WriteString("  | ")
		} else {
			b.WriteString("  ")
		}
		b.WriteString(v.Name)
		if len(v.Fields) > 0 {
			b.WriteString("(")
			for j, f := range v.Fields {
				if j > 0 {
					b.WriteString(", ")
				}
				b.WriteString(f.Name)
				if f.Type != "" {
					b.WriteString(": ")
					b.WriteString(f.Type)
				} else {
					b.WriteString(": any")
				}
			}
			b.WriteString(")")
		}
		b.WriteByte('\n')
	}
	return strings.TrimSuffix(b.String(), "\n")
}
