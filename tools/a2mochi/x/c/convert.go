package c

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os/exec"
	"strconv"
	"strings"

	"mochi/ast"
	"mochi/parser"
)

type Cnode struct {
	Kind  string  `json:"kind"`
	Name  string  `json:"name"`
	Value string  `json:"value"`
	Inner []Cnode `json:"inner"`
	Ref   *Cnode  `json:"referencedDecl"`
}

func runClang(src string) (*Cnode, error) {
	cmd := exec.Command("clang", "-w", "-x", "c", "-", "-Xclang", "-ast-dump=json", "-fsyntax-only")
	cmd.Stdin = strings.NewReader(src)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out
	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("clang failed: %v", err)
	}
	data := out.Bytes()
	var root Cnode
	if err := json.Unmarshal(data[dataIndex(data):], &root); err != nil {
		return nil, err
	}
	return &root, nil
}

// DebugRoot is exported for testing. It parses C source and returns the AST root.
func DebugRoot(src string) (*Cnode, error) { return runClang(src) }

func dataIndex(b []byte) int {
	for i, c := range b {
		if c == '{' {
			return i
		}
	}
	return 0
}

func ConvertSource(src string) (string, error) {
	root, err := runClang(src)
	if err != nil {
		return "", err
	}
	prints := findPrints(root)
	var b strings.Builder
	b.WriteString("// Generated by a2mochi\n")
	b.WriteString("/*\n")
	b.WriteString(src)
	if !strings.HasSuffix(src, "\n") {
		b.WriteByte('\n')
	}
	b.WriteString("*/\n")
	for _, p := range prints {
		b.WriteString("print(")
		b.WriteString(p)
		b.WriteString(")\n")
	}
	return b.String(), nil
}

func Convert(src string) (*ast.Node, error) {
	code, err := ConvertSource(src)
	if err != nil {
		return nil, err
	}
	prog, err := parser.ParseString(code)
	if err != nil {
		return nil, err
	}
	return ast.FromProgram(prog), nil
}

func findPrints(n *Cnode) []string {
	var prints []string
	if n.Kind == "FunctionDecl" && n.Name == "main" {
		for i := range n.Inner {
			c := n.Inner[i]
			if c.Kind == "CompoundStmt" {
				prints = append(prints, extractPrints(&c)...)
			}
		}
	}
	for i := range n.Inner {
		prints = append(prints, findPrints(&n.Inner[i])...)
	}
	return prints
}

// DebugFindPrints exposes findPrints for debugging.
func DebugFindPrints(n *Cnode) []string { return findPrints(n) }

func extractPrints(n *Cnode) []string {
	var out []string
	for i := range n.Inner {
		c := n.Inner[i]
		if c.Kind == "CallExpr" {
			if callee := calleeName(&c); callee == "printf" || callee == "puts" {
				if arg := firstValue(&c); arg != "" {
					out = append(out, arg)
				}
			}
		}
	}
	return out
}

func calleeName(n *Cnode) string {
	if len(n.Inner) == 0 {
		return ""
	}
	return walkName(&n.Inner[0])
}

func walkName(n *Cnode) string {
	if n.Kind == "DeclRefExpr" {
		if n.Name != "" {
			return n.Name
		}
		if n.Ref != nil && n.Ref.Name != "" {
			return n.Ref.Name
		}
	}
	if len(n.Inner) > 0 {
		return walkName(&n.Inner[0])
	}
	return ""
}

func firstValue(n *Cnode) string {
	start := 1
	if len(n.Inner) > 2 {
		start = 2
	}
	for i := start; i < len(n.Inner); i++ {
		if v := valueOf(&n.Inner[i]); v != "" {
			return v
		}
	}
	return ""
}

func valueOf(n *Cnode) string {
	switch n.Kind {
	case "IntegerLiteral", "FloatingLiteral":
		return n.Value
	case "StringLiteral":
		return strconv.Quote(strings.Trim(n.Value, "\""))
	}
	for i := range n.Inner {
		if v := valueOf(&n.Inner[i]); v != "" {
			return v
		}
	}
	return ""
}
