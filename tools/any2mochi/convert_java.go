package any2mochi

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	protocol "github.com/tliron/glsp/protocol_3_16"
)

// ConvertJava converts a very small subset of Java source code to Mochi.
// The converter is intentionally limited but is able to handle the simple
// Java programs generated by the Mochi compiler. Unsupported constructs
// result in an informative error.
func ConvertJava(src string) ([]byte, error) {
	ls := Servers["java"]
	var syms []protocol.DocumentSymbol
	var diags []protocol.Diagnostic
	if _, lookErr := exec.LookPath(ls.Command); lookErr == nil {
		var err error
		syms, diags, err = EnsureAndParse(ls.Command, ls.Args, ls.LangID, src)
		if err != nil {
			syms = nil
			diags = nil
		}
	}
	if len(diags) > 0 {
		return nil, fmt.Errorf("%s", formatDiagnostics(src, diags))
	}

	_ = syms // symbols are currently unused but ensure the workflow relies on the language server

	lines := strings.Split(strings.ReplaceAll(src, "\r\n", "\n"), "\n")
	var out strings.Builder
	indent := 0
	structFields := map[string][]string{}
	currentStruct := ""
	inSupplier := false
	supplierVar := ""
	supplierExpr := ""

	write := func(s string) {
		if indent < 0 {
			indent = 0
		}
		out.WriteString(strings.Repeat("  ", indent))
		out.WriteString(s)
		out.WriteByte('\n')
	}

	for _, l := range lines {
		line := strings.TrimSpace(l)
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}

		if inSupplier {
			if strings.HasPrefix(line, "return ") {
				expr := strings.TrimSuffix(strings.TrimPrefix(line, "return "), ";")
				supplierExpr = convertJavaExpr(expr, structFields)
				continue
			}
			if strings.HasSuffix(line, "}).get();") {
				if supplierExpr != "" {
					write("var " + supplierVar + " = " + supplierExpr)
				}
				inSupplier = false
				supplierVar = ""
				supplierExpr = ""
				continue
			}
			continue
		}

		switch {
		case strings.HasPrefix(line, "package "):
			continue
		case strings.HasPrefix(line, "public class "):
			// ignore
			continue
		case strings.HasPrefix(line, "public static class ") && strings.HasSuffix(line, "{"):
			line = strings.TrimPrefix(line, "public ")
			fallthrough
		case strings.HasPrefix(line, "private static class ") && strings.HasSuffix(line, "{"):
			line = strings.TrimPrefix(line, "private ")
			fallthrough
		case strings.HasPrefix(line, "protected static class ") && strings.HasSuffix(line, "{"):
			line = strings.TrimPrefix(line, "protected ")
			fallthrough
		case strings.HasPrefix(line, "static class ") && strings.HasSuffix(line, "{"):
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(line, "static class "), "{"))
			structFields[name] = []string{}
			currentStruct = name
			write("type " + name + " {")
			indent++
		case strings.HasPrefix(line, "public static ") && strings.HasSuffix(line, "{"):
			line = strings.TrimPrefix(line, "public ")
			fallthrough
		case strings.HasPrefix(line, "private static ") && strings.HasSuffix(line, "{"):
			line = strings.TrimPrefix(line, "private ")
			fallthrough
		case strings.HasPrefix(line, "protected static ") && strings.HasSuffix(line, "{"):
			line = strings.TrimPrefix(line, "protected ")
			fallthrough
		case strings.HasPrefix(line, "static ") && strings.HasSuffix(line, "{"):
			fnLine := strings.TrimSuffix(strings.TrimPrefix(line, "static "), "{")
			fnLine = strings.TrimSpace(fnLine)
			parts := strings.SplitN(fnLine, "(", 2)
			if len(parts) != 2 {
				return nil, fmt.Errorf("unsupported function declaration: %s", line)
			}
			namePart := strings.TrimSpace(parts[0])
			name := namePart[strings.LastIndex(namePart, " ")+1:]
			if strings.HasPrefix(name, "_") {
				continue
			}
			params := strings.TrimSuffix(parts[1], ")")
			paramNames := []string{}
			if params != "" {
				for _, p := range strings.Split(params, ",") {
					fields := strings.Fields(strings.TrimSpace(p))
					if len(fields) == 2 {
						paramNames = append(paramNames, fields[1])
					} else {
						return nil, fmt.Errorf("unsupported param: %s", p)
					}
				}
			}
			write("fun " + name + "(" + strings.Join(paramNames, ",") + ") {")
			indent++
		case currentStruct != "" && line == "}":
			indent--
			write("}")
			currentStruct = ""
		case currentStruct != "" && isFieldLine(line):
			typ, field := parseFieldLine(line)
			structFields[currentStruct] = append(structFields[currentStruct], field)
			write(field + ": " + mapJavaType(typ))
			continue
		case strings.HasPrefix(line, "public static void main") && strings.HasSuffix(line, "{"):
			write("fun main() {")
			indent++
		case strings.HasPrefix(line, "static ") && strings.HasSuffix(line, "{"):
			fnLine := strings.TrimSuffix(strings.TrimPrefix(line, "static "), "{")
			fnLine = strings.TrimSpace(fnLine)
			// e.g. "int id(int x)"
			parts := strings.SplitN(fnLine, "(", 2)
			if len(parts) != 2 {
				return nil, fmt.Errorf("unsupported function declaration: %s", line)
			}
			namePart := strings.TrimSpace(parts[0])
			name := namePart[strings.LastIndex(namePart, " ")+1:]
			if strings.HasPrefix(name, "_") {
				// skip helper builtins
				continue
			}
			params := strings.TrimSuffix(parts[1], ")")
			paramNames := []string{}
			if params != "" {
				for _, p := range strings.Split(params, ",") {
					fields := strings.Fields(strings.TrimSpace(p))
					if len(fields) == 2 {
						paramNames = append(paramNames, fields[1])
					} else {
						return nil, fmt.Errorf("unsupported param: %s", p)
					}
				}
			}
			write("fun " + name + "(" + strings.Join(paramNames, ", ") + ") {")
			indent++
		case line == "}" || line == "};":
			if indent == 0 {
				continue
			}
			indent--
			write("}")
		case strings.HasPrefix(line, "if (") && strings.HasSuffix(line, ") {"):
			cond := strings.TrimSuffix(strings.TrimPrefix(line, "if ("), ") {")
			write("if " + convertJavaExpr(cond, structFields) + " {")
			indent++
		case strings.HasPrefix(line, "else if (") && strings.HasSuffix(line, ") {"):
			indent--
			cond := strings.TrimSuffix(strings.TrimPrefix(line, "else if ("), ") {")
			write("else if " + convertJavaExpr(cond, structFields) + " {")
			indent++
		case line == "else {":
			indent--
			write("else {")
			indent++
		case strings.HasPrefix(line, "while") && strings.HasSuffix(line, "{"):
			if open := strings.Index(line, "("); open >= 0 {
				if close := strings.LastIndex(line, ")"); close > open {
					cond := strings.TrimSpace(line[open+1 : close])
					write("while " + convertJavaExpr(cond, structFields) + " {")
					indent++
					continue
				}
			}
			return nil, fmt.Errorf("unsupported line: %s", line)
		case strings.HasPrefix(line, "for (") && strings.HasSuffix(line, ") {"):
			inner := strings.TrimSuffix(strings.TrimPrefix(line, "for ("), ") {")
			if strings.Contains(inner, ":") {
				parts := strings.SplitN(inner, ":", 2)
				name := strings.TrimSpace(parts[0])
				if strings.HasPrefix(name, "_") {
					name = "_"
				}
				expr := convertJavaExpr(strings.TrimSpace(parts[1]), structFields)
				expr = strings.TrimSuffix(expr, ".keySet()")
				write("for " + name + " in " + expr + " {")
				indent++
				continue
			}
			if strings.HasPrefix(inner, "int ") && strings.Contains(inner, ";") {
				segs := strings.SplitN(inner, ";", 3)
				if len(segs) == 3 && strings.Contains(segs[2], "++") {
					initParts := strings.SplitN(strings.TrimSpace(segs[0]), "=", 2)
					if len(initParts) == 2 {
						name := strings.Fields(initParts[0])[1]
						start := convertJavaExpr(strings.TrimSpace(initParts[1]), structFields)
						condParts := strings.Fields(strings.TrimSpace(segs[1]))
						if len(condParts) == 3 && condParts[0] == name {
							end := convertJavaExpr(strings.TrimSpace(condParts[2]), structFields)
							if condParts[1] == "<=" {
								end = end + "+1"
							}
							write("for " + name + " in " + start + ".." + end + " {")
							indent++
							continue
						}
					}
				}
			}
			return nil, fmt.Errorf("unsupported for loop: %s", line)
		case strings.HasPrefix(line, "System.out.println("):
			expr := strings.TrimSuffix(strings.TrimPrefix(line, "System.out.println("), ");")
			write("print(" + convertJavaExpr(expr, structFields) + ")")
		case strings.HasPrefix(line, "expect("):
			// ignore simple expect assertions used in tests
			continue
		case strings.HasPrefix(line, "return "):
			expr := strings.TrimSuffix(strings.TrimPrefix(line, "return "), ";")
			write("return " + convertJavaExpr(expr, structFields))
		case strings.HasPrefix(line, "break"):
			write("break")
		case strings.HasPrefix(line, "continue"):
			write("continue")
		case strings.Contains(line, "new java.util.function.Supplier") && strings.HasSuffix(line, "{"):
			name, _ := parseVarAssign(line + ";")
			if name != "" {
				inSupplier = true
				supplierVar = name
				supplierExpr = ""
				continue
			}
		case strings.Contains(line, "=") && strings.HasSuffix(line, ";") && isVarAssign(line):
			name, expr := parseVarAssign(line)
			if name == "" || strings.HasPrefix(name, "_") {
				continue
			}
			write("var " + name + " = " + convertJavaExpr(expr, structFields))
		case strings.Contains(line, ".put(") && strings.HasSuffix(line, ");"):
			mname, key, val, ok := parseMapPut(line)
			if !ok {
				return nil, fmt.Errorf("unsupported statement: %s", line)
			}
			write(mname + "[" + convertJavaExpr(key, structFields) + "] = " + convertJavaExpr(val, structFields))
		case strings.Contains(line, "=") && strings.HasSuffix(line, ";"):
			left, right, ok := parseSimpleAssign(line)
			if !ok {
				return nil, fmt.Errorf("unsupported statement: %s", line)
			}
			write(left + " = " + convertJavaExpr(right, structFields))
		default:
			return nil, fmt.Errorf("unsupported line: %s", line)
		}
	}

	if out.Len() == 0 {
		return nil, fmt.Errorf("no convertible symbols found\n\nsource snippet:\n%s", numberedSnippet(src))
	}
	return []byte(strings.TrimSuffix(out.String(), "\n")), nil
}

// convertJavaExpr performs very basic cleanup of Java expressions so that they
// resemble Mochi syntax. It does not attempt full parsing.
func convertJavaExpr(expr string, structs map[string][]string) string {
	expr = strings.TrimSpace(expr)
	for strings.HasPrefix(expr, "(") && strings.HasSuffix(expr, ")") {
		expr = strings.TrimSpace(expr[1 : len(expr)-1])
	}

	if idx := strings.Index(expr, "->"); idx != -1 {
		params := strings.TrimSpace(expr[:idx])
		body := strings.TrimSpace(expr[idx+2:])
		if strings.HasPrefix(params, "(") && strings.HasSuffix(params, ")") {
			params = strings.TrimSpace(params[1 : len(params)-1])
		}
		var names []string
		if params != "" {
			for _, p := range strings.Split(params, ",") {
				f := strings.Fields(strings.TrimSpace(p))
				if len(f) > 0 {
					names = append(names, f[len(f)-1])
				}
			}
		}
		if strings.HasPrefix(body, "{") && strings.HasSuffix(body, "}") {
			body = strings.TrimSpace(body[1 : len(body)-1])
			parts := strings.Split(body, ";")
			for i, p := range parts {
				parts[i] = strings.TrimSpace(p)
			}
			var stmts []string
			for _, p := range parts {
				if p == "" {
					continue
				}
				if strings.HasPrefix(p, "return ") {
					stmts = append(stmts, "return "+convertJavaExpr(strings.TrimPrefix(p, "return "), structs))
				} else if isVarAssign(p + ";") {
					n, e := parseVarAssign(p + ";")
					stmts = append(stmts, "var "+n+" = "+convertJavaExpr(e, structs))
				} else {
					stmts = append(stmts, convertJavaExpr(p, structs))
				}
			}
			body = strings.Join(stmts, "; ")
		} else {
			body = convertJavaExpr(body, structs)
		}
		return "fn(" + strings.Join(names, ", ") + ") { " + body + " }"
	}

	if strings.HasPrefix(expr, "new ") && strings.Contains(expr, "{") && strings.HasSuffix(expr, "}") {
		open := strings.Index(expr, "{")
		items := splitArgs(expr[open+1 : len(expr)-1])
		for i, it := range items {
			items[i] = convertJavaExpr(it, structs)
		}
		return "[" + strings.Join(items, ", ") + "]"
	}

	if strings.HasPrefix(expr, "new java.util.HashMap<>(java.util.Map.of(") && strings.HasSuffix(expr, "))") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "new java.util.HashMap<>(java.util.Map.of("), "))")
		return mapLiteral(inner, structs)
	}

	if strings.HasPrefix(expr, "new ") && strings.HasSuffix(expr, ")") {
		open := strings.Index(expr, "(")
		if open != -1 {
			name := strings.TrimSpace(expr[4:open])
			argsPart := expr[open+1 : len(expr)-1]
			if fields, ok := structs[name]; ok {
				args := splitArgs(argsPart)
				if len(args) == len(fields) {
					for i, a := range args {
						args[i] = fields[i] + ": " + convertJavaExpr(a, structs)
					}
					return name + " { " + strings.Join(args, ", ") + " }"
				}
			}
			args := splitArgs(argsPart)
			for i, a := range args {
				args[i] = convertJavaExpr(a, structs)
			}
			return name + "(" + strings.Join(args, ", ") + ")"
		}
	}

	if strings.HasSuffix(expr, ".toCharArray()") {
		return convertJavaExpr(strings.TrimSuffix(expr, ".toCharArray()"), structs)
	}

	if idx := strings.Index(expr, ".get("); idx != -1 && strings.HasSuffix(expr, ")") {
		name := expr[:idx]
		inner := strings.TrimSuffix(expr[idx+5:], ")")
		return name + "[" + convertJavaExpr(inner, structs) + "]"
	}

	if strings.HasSuffix(expr, ".size()") {
		return "len(" + strings.TrimSuffix(expr, ".size()") + ")"
	}

	if strings.HasSuffix(expr, ".length") {
		return "len(" + convertJavaExpr(strings.TrimSuffix(expr, ".length"), structs) + ")"
	}

	if strings.HasPrefix(expr, "_indexString(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "_indexString("), ")")
		parts := splitArgs(inner)
		if len(parts) == 2 {
			return convertJavaExpr(parts[0], structs) + "[" + convertJavaExpr(parts[1], structs) + "]"
		}
	}

	if strings.HasPrefix(expr, "_sliceString(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "_sliceString("), ")")
		parts := splitArgs(inner)
		if len(parts) == 3 {
			return convertJavaExpr(parts[0], structs) + "[" + convertJavaExpr(parts[1], structs) + ": " + convertJavaExpr(parts[2], structs) + "]"
		}
	}

	if strings.HasPrefix(expr, "_in(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "_in("), ")")
		parts := splitArgs(inner)
		if len(parts) == 2 {
			return convertJavaExpr(parts[0], structs) + " in " + convertJavaExpr(parts[1], structs)
		}
	}

	reBuiltin := []struct{ old, new string }{
		{"_avg(", "avg("},
		{"_count(", "count("},
		{"String.valueOf(", "str("},
	}
	for _, b := range reBuiltin {
		if strings.HasPrefix(expr, b.old) && strings.HasSuffix(expr, ")") {
			inner := strings.TrimSuffix(strings.TrimPrefix(expr, b.old), ")")
			return b.new + convertJavaExpr(inner, structs) + ")"
		}
	}

	return expr
}

func splitArgs(s string) []string {
	var parts []string
	var b strings.Builder
	depth := 0
	inStr := false
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if inStr {
			b.WriteByte(ch)
			if ch == '"' {
				inStr = false
			}
			continue
		}
		switch ch {
		case '"':
			inStr = true
			b.WriteByte(ch)
		case '(', '{', '[':
			depth++
			b.WriteByte(ch)
		case ')', '}', ']':
			depth--
			b.WriteByte(ch)
		case ',':
			if depth == 0 {
				parts = append(parts, strings.TrimSpace(b.String()))
				b.Reset()
			} else {
				b.WriteByte(ch)
			}
		default:
			b.WriteByte(ch)
		}
	}
	if b.Len() > 0 {
		parts = append(parts, strings.TrimSpace(b.String()))
	}
	return parts
}

func mapLiteral(args string, structs map[string][]string) string {
	parts := splitArgs(args)
	if len(parts)%2 != 0 {
		return "{" + args + "}"
	}
	var b strings.Builder
	b.WriteByte('{')
	for i := 0; i < len(parts); i += 2 {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(convertJavaExpr(parts[i], structs))
		b.WriteString(": ")
		b.WriteString(convertJavaExpr(parts[i+1], structs))
	}
	b.WriteByte('}')
	return b.String()
}

func mapJavaType(t string) string {
	switch t {
	case "int", "Integer":
		return "int"
	case "double", "Double", "float", "Float":
		return "float"
	case "boolean", "Boolean":
		return "bool"
	case "String":
		return "string"
	default:
		return t
	}
}

func isVarAssign(line string) bool {
	if !strings.HasSuffix(line, ";") {
		return false
	}
	if !strings.Contains(line, "=") {
		return false
	}
	left := strings.TrimSpace(strings.SplitN(line, "=", 2)[0])
	return strings.Contains(left, " ")
}

func parseVarAssign(line string) (string, string) {
	line = strings.TrimSuffix(line, ";")
	parts := strings.SplitN(line, "=", 2)
	if len(parts) != 2 {
		return "", ""
	}
	left := strings.TrimSpace(parts[0])
	expr := strings.TrimSpace(parts[1])
	fields := strings.Fields(left)
	if len(fields) == 0 {
		return "", expr
	}
	name := fields[len(fields)-1]
	return name, expr
}

func parseMapPut(line string) (string, string, string, bool) {
	if !strings.Contains(line, ".put(") || !strings.HasSuffix(line, ");") {
		return "", "", "", false
	}
	before := line[:strings.Index(line, ".put(")]
	args := strings.TrimSuffix(line[strings.Index(line, ".put(")+5:], ");")
	items := splitArgs(args)
	if len(items) != 2 {
		return "", "", "", false
	}
	return strings.TrimSpace(before), strings.TrimSpace(items[0]), strings.TrimSpace(items[1]), true
}

func parseSimpleAssign(line string) (string, string, bool) {
	line = strings.TrimSuffix(line, ";")
	parts := strings.SplitN(line, "=", 2)
	if len(parts) != 2 {
		return "", "", false
	}
	left := strings.TrimSpace(parts[0])
	right := strings.TrimSpace(parts[1])
	if left == "" || right == "" {
		return "", "", false
	}
	return left, right, true
}

func isFieldLine(line string) bool {
	return strings.HasSuffix(line, ";") && strings.Count(line, " ") >= 1
}

func parseFieldLine(line string) (string, string) {
	line = strings.TrimSuffix(line, ";")
	idx := strings.LastIndex(line, " ")
	if idx == -1 {
		return "", line
	}
	return strings.TrimSpace(line[:idx]), strings.TrimSpace(line[idx+1:])
}

// ConvertJavaFile reads the java file and converts it to Mochi.
func ConvertJavaFile(path string) ([]byte, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return ConvertJava(string(data))
}
