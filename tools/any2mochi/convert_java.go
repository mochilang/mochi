package any2mochi

import (
	"fmt"
	"os"
	"regexp"
	"strings"
)

// ConvertJava converts a very small subset of Java source code to Mochi.
// The converter is intentionally limited but is able to handle the simple
// Java programs generated by the Mochi compiler. Unsupported constructs
// result in an informative error.
func ConvertJava(src string) ([]byte, error) {
	ls := Servers["java"]
	syms, diags, err := EnsureAndParse(ls.Command, ls.Args, ls.LangID, src)
	if err != nil {
		return nil, err
	}
	if len(diags) > 0 {
		return nil, fmt.Errorf("%s", formatDiagnostics(src, diags))
	}

	_ = syms // symbols are currently unused but ensure the workflow relies on the language server

	lines := strings.Split(strings.ReplaceAll(src, "\r\n", "\n"), "\n")
	var out strings.Builder
	indent := 0
	structFields := map[string][]string{}
	currentStruct := ""

	write := func(s string) {
		out.WriteString(strings.Repeat("  ", indent))
		out.WriteString(s)
		out.WriteByte('\n')
	}

	for _, l := range lines {
		line := strings.TrimSpace(l)
		if line == "" || strings.HasPrefix(line, "//") {
			continue
		}

		switch {
		case strings.HasPrefix(line, "package "):
			continue
		case strings.HasPrefix(line, "public class "):
			// ignore
			continue
		case strings.HasPrefix(line, "static class ") && strings.HasSuffix(line, "{"):
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(line, "static class "), "{"))
			structFields[name] = []string{}
			currentStruct = name
			write("type " + name + " {")
			indent++
		case currentStruct != "" && line == "}":
			indent--
			write("}")
			currentStruct = ""
		case currentStruct != "" && regexp.MustCompile(`^[A-Za-z0-9_\.<>\[\]]+\s+\w+;`).MatchString(line):
			re := regexp.MustCompile(`^([A-Za-z0-9_\.<>\[\]]+)\s+(\w+);$`)
			if m := re.FindStringSubmatch(line); m != nil {
				typ := mapJavaType(m[1])
				field := m[2]
				structFields[currentStruct] = append(structFields[currentStruct], field)
				write(field + ": " + typ)
			}
			continue
		case strings.HasPrefix(line, "public static void main") && strings.HasSuffix(line, "{"):
			write("fun main() {")
			indent++
		case strings.HasPrefix(line, "static ") && strings.HasSuffix(line, "{"):
			fnLine := strings.TrimSuffix(strings.TrimPrefix(line, "static "), "{")
			fnLine = strings.TrimSpace(fnLine)
			// e.g. "int id(int x)"
			parts := strings.SplitN(fnLine, "(", 2)
			if len(parts) != 2 {
				return nil, fmt.Errorf("unsupported function declaration: %s", line)
			}
			namePart := strings.TrimSpace(parts[0])
			name := namePart[strings.LastIndex(namePart, " ")+1:]
			if strings.HasPrefix(name, "_") {
				// skip helper builtins
				continue
			}
			params := strings.TrimSuffix(parts[1], ")")
			paramNames := []string{}
			if params != "" {
				for _, p := range strings.Split(params, ",") {
					fields := strings.Fields(strings.TrimSpace(p))
					if len(fields) == 2 {
						paramNames = append(paramNames, fields[1])
					} else {
						return nil, fmt.Errorf("unsupported param: %s", p)
					}
				}
			}
			write("fun " + name + "(" + strings.Join(paramNames, ", ") + ") {")
			indent++
		case line == "}" || line == "};":
			if indent == 0 {
				continue
			}
			indent--
			write("}")
		case strings.HasPrefix(line, "if (") && strings.HasSuffix(line, ") {"):
			cond := strings.TrimSuffix(strings.TrimPrefix(line, "if ("), ") {")
			write("if " + convertJavaExpr(cond, structFields) + " {")
			indent++
		case strings.HasPrefix(line, "else if (") && strings.HasSuffix(line, ") {"):
			indent--
			cond := strings.TrimSuffix(strings.TrimPrefix(line, "else if ("), ") {")
			write("else if " + convertJavaExpr(cond, structFields) + " {")
			indent++
		case line == "else {":
			indent--
			write("else {")
			indent++
		case strings.HasPrefix(line, "while (") && strings.HasSuffix(line, ") {"):
			cond := strings.TrimSuffix(strings.TrimPrefix(line, "while ("), ") {")
			write("while " + convertJavaExpr(cond, structFields) + " {")
			indent++
		case strings.HasPrefix(line, "for (") && strings.HasSuffix(line, ") {"):
			// support: for (int i = a; i < b; i++) {
			re := regexp.MustCompile(`for \(int (\w+) = ([^;]+); \w+ < ([^;]+); \w+\+\+\) {`)
			if m := re.FindStringSubmatch(line); m != nil {
				write("for " + m[1] + " in " + convertJavaExpr(m[2], structFields) + ".." + convertJavaExpr(m[3], structFields) + " {")
				indent++
				continue
			}
			re = regexp.MustCompile(`for \(var ([^:]+) : ([^\)]+)\) {`)
			if m := re.FindStringSubmatch(line); m != nil {
				name := strings.TrimSpace(m[1])
				if strings.HasPrefix(name, "_") {
					name = "_"
				}
				expr := convertJavaExpr(strings.TrimSpace(m[2]), structFields)
				expr = strings.TrimSuffix(expr, ".keySet()")
				write("for " + name + " in " + expr + " {")
				indent++
				continue
			}
			return nil, fmt.Errorf("unsupported for loop: %s", line)
		case strings.HasPrefix(line, "System.out.println("):
			expr := strings.TrimSuffix(strings.TrimPrefix(line, "System.out.println("), ");")
			write("print(" + convertJavaExpr(expr, structFields) + ")")
		case strings.HasPrefix(line, "return "):
			expr := strings.TrimSuffix(strings.TrimPrefix(line, "return "), ";")
			write("return " + convertJavaExpr(expr, structFields))
		case strings.HasPrefix(line, "break"):
			write("break")
		case strings.HasPrefix(line, "continue"):
			write("continue")
		case regexp.MustCompile(`^(?:static\s+)?[A-Za-z0-9_\.<>\[\]]+\s+\w+ =`).MatchString(line):
			re := regexp.MustCompile(`^(?:static\s+)?[A-Za-z0-9_\.<>\[\]]+\s+(\w+) = (.*);`)
			m := re.FindStringSubmatch(line)
			if m == nil {
				return nil, fmt.Errorf("unsupported declaration: %s", line)
			}
			if strings.HasPrefix(m[1], "_") {
				continue
			}
			write("var " + m[1] + " = " + convertJavaExpr(m[2], structFields))
		case regexp.MustCompile(`^\w+\.put\(`).MatchString(line):
			re := regexp.MustCompile(`^(\w+)\.put\(([^,]+),\s*(.*)\);$`)
			m := re.FindStringSubmatch(line)
			if m == nil {
				return nil, fmt.Errorf("unsupported statement: %s", line)
			}
			write(m[1] + "[" + convertJavaExpr(m[2], structFields) + "] = " + convertJavaExpr(m[3], structFields))
		case regexp.MustCompile(`^\w+ =`).MatchString(line):
			re := regexp.MustCompile(`^(\w+) = (.*);`)
			m := re.FindStringSubmatch(line)
			if m == nil {
				return nil, fmt.Errorf("unsupported statement: %s", line)
			}
			write(m[1] + " = " + convertJavaExpr(m[2], structFields))
		default:
			return nil, fmt.Errorf("unsupported line: %s", line)
		}
	}

	if out.Len() == 0 {
		return nil, fmt.Errorf("no convertible symbols found\n\nsource snippet:\n%s", numberedSnippet(src))
	}
	return []byte(strings.TrimSuffix(out.String(), "\n")), nil
}

// convertJavaExpr performs very basic cleanup of Java expressions so that they
// resemble Mochi syntax. It does not attempt full parsing.
func convertJavaExpr(expr string, structs map[string][]string) string {
	expr = strings.TrimSpace(expr)
	for strings.HasPrefix(expr, "(") && strings.HasSuffix(expr, ")") {
		expr = strings.TrimSpace(expr[1 : len(expr)-1])
	}

	reArray := regexp.MustCompile(`^new [^\[]+\[] \{(.*)\}$`)
	if m := reArray.FindStringSubmatch(expr); m != nil {
		items := splitArgs(m[1])
		for i, it := range items {
			items[i] = convertJavaExpr(it, structs)
		}
		return "[" + strings.Join(items, ", ") + "]"
	}

	reMap := regexp.MustCompile(`new java\.util\.HashMap<>\(java\.util\.Map\.of\((.*)\)\)`)
	if m := reMap.FindStringSubmatch(expr); m != nil {
		return mapLiteral(m[1], structs)
	}

	reStruct := regexp.MustCompile(`^new ([A-Za-z0-9_]+)\((.*)\)$`)
	if m := reStruct.FindStringSubmatch(expr); m != nil {
		name := m[1]
		if fields, ok := structs[name]; ok {
			args := splitArgs(m[2])
			if len(args) == len(fields) {
				for i, a := range args {
					args[i] = fields[i] + ": " + convertJavaExpr(a, structs)
				}
				return name + " { " + strings.Join(args, ", ") + " }"
			}
		}
		args := splitArgs(m[2])
		for i, a := range args {
			args[i] = convertJavaExpr(a, structs)
		}
		return name + "(" + strings.Join(args, ", ") + ")"
	}

	if strings.HasSuffix(expr, ".toCharArray()") {
		return convertJavaExpr(strings.TrimSuffix(expr, ".toCharArray()"), structs)
	}

	reGet := regexp.MustCompile(`(\w+)\.get\((.*)\)$`)
	if m := reGet.FindStringSubmatch(expr); m != nil {
		return m[1] + "[" + convertJavaExpr(m[2], structs) + "]"
	}

	reSize := regexp.MustCompile(`(\w+)\.size\(\)$`)
	if m := reSize.FindStringSubmatch(expr); m != nil {
		return "len(" + m[1] + ")"
	}

	if strings.HasSuffix(expr, ".length") {
		return "len(" + convertJavaExpr(strings.TrimSuffix(expr, ".length"), structs) + ")"
	}

	reIndex := regexp.MustCompile(`_indexString\(([^,]+),\s*(.*)\)`)
	if m := reIndex.FindStringSubmatch(expr); m != nil {
		return convertJavaExpr(m[1], structs) + "[" + convertJavaExpr(m[2], structs) + "]"
	}

	reSlice := regexp.MustCompile(`_sliceString\(([^,]+),\s*([^,]+),\s*(.*)\)`)
	if m := reSlice.FindStringSubmatch(expr); m != nil {
		return convertJavaExpr(m[1], structs) + "[" + convertJavaExpr(m[2], structs) + ": " + convertJavaExpr(m[3], structs) + "]"
	}

	reIn := regexp.MustCompile(`_in\(([^,]+),\s*(.*)\)`)
	if m := reIn.FindStringSubmatch(expr); m != nil {
		return convertJavaExpr(m[1], structs) + " in " + convertJavaExpr(m[2], structs)
	}

	reBuiltin := []struct{ old, new string }{
		{"_avg(", "avg("},
		{"_count(", "count("},
		{"String.valueOf(", "str("},
	}
	for _, b := range reBuiltin {
		if strings.HasPrefix(expr, b.old) && strings.HasSuffix(expr, ")") {
			inner := strings.TrimSuffix(strings.TrimPrefix(expr, b.old), ")")
			return b.new + convertJavaExpr(inner, structs) + ")"
		}
	}

	return expr
}

func splitArgs(s string) []string {
	var parts []string
	var b strings.Builder
	depth := 0
	inStr := false
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if inStr {
			b.WriteByte(ch)
			if ch == '"' {
				inStr = false
			}
			continue
		}
		switch ch {
		case '"':
			inStr = true
			b.WriteByte(ch)
		case '(', '{', '[':
			depth++
			b.WriteByte(ch)
		case ')', '}', ']':
			depth--
			b.WriteByte(ch)
		case ',':
			if depth == 0 {
				parts = append(parts, strings.TrimSpace(b.String()))
				b.Reset()
			} else {
				b.WriteByte(ch)
			}
		default:
			b.WriteByte(ch)
		}
	}
	if b.Len() > 0 {
		parts = append(parts, strings.TrimSpace(b.String()))
	}
	return parts
}

func mapLiteral(args string, structs map[string][]string) string {
	parts := splitArgs(args)
	if len(parts)%2 != 0 {
		return "{" + args + "}"
	}
	var b strings.Builder
	b.WriteByte('{')
	for i := 0; i < len(parts); i += 2 {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(convertJavaExpr(parts[i], structs))
		b.WriteString(": ")
		b.WriteString(convertJavaExpr(parts[i+1], structs))
	}
	b.WriteByte('}')
	return b.String()
}

func mapJavaType(t string) string {
	switch t {
	case "int", "Integer":
		return "int"
	case "double", "Double", "float", "Float":
		return "float"
	case "boolean", "Boolean":
		return "bool"
	case "String":
		return "string"
	default:
		return t
	}
}

// ConvertJavaFile reads the java file and converts it to Mochi.
func ConvertJavaFile(path string) ([]byte, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return ConvertJava(string(data))
}
