//go:build slow

package cpp

import (
	"bytes"
	"fmt"
	"strings"

	"mochi/parser"
)

// Compiler is a minimal Mochi -> C++ translator used for tests. It only
// supports simple features like arithmetic, loops and function calls.
// Unsupported constructs result in an error so the tests can record the
// failure.
type Compiler struct {
	buf    bytes.Buffer
	indent int
}

// New returns a new compiler instance.
func New() *Compiler { return &Compiler{} }

func (c *Compiler) writeln(s string) {
	for i := 0; i < c.indent; i++ {
		c.buf.WriteByte('\t')
	}
	c.buf.WriteString(s)
	c.buf.WriteByte('\n')
}

func (c *Compiler) writeIndent() {
	for i := 0; i < c.indent; i++ {
		c.buf.WriteByte('\t')
	}
}

// Compile converts a parsed program to C++.
func (c *Compiler) Compile(p *parser.Program) ([]byte, error) {
	c.buf.Reset()
	c.writeln("// Generated by the Mochi experimental C++ compiler")
	c.writeln("#include <bits/stdc++.h>")
	c.writeln("using namespace std;")
	c.writeln("")

	// small helpers for type traits
	c.writeln("template<typename T, typename=void> struct has_size : false_type {};")
	c.writeln("template<typename T> struct has_size<T, void_t<decltype(declval<T>().size()), decltype(declval<T>()[0])>> : true_type {};")
	c.writeln("template<typename T, typename=void> struct has_key_type : false_type {};")
	c.writeln("template<typename T> struct has_key_type<T, void_t<typename T::key_type>> : true_type {};")
	c.writeln("")

	for _, st := range p.Statements {
		if st.Type != nil {
			if err := c.compileTypeDecl(st.Type); err != nil {
				return nil, err
			}
			c.writeln("")
		}
	}

	for _, st := range p.Statements {
		if st.Fun != nil {
			if err := c.compileFun(st.Fun); err != nil {
				return nil, err
			}
			c.writeln("")
		}
	}

	c.writeln("int main() {")
	c.indent++
	for _, st := range p.Statements {
		if st.Fun != nil || st.Type != nil {
			continue
		}
		if err := c.compileStmt(st); err != nil {
			return nil, err
		}
	}
	c.writeln("return 0;")
	c.indent--
	c.writeln("}")

	return c.buf.Bytes(), nil
}

func (c *Compiler) compileFun(fn *parser.FunStmt) error {
	c.writeIndent()
	c.buf.WriteString("auto ")
	c.buf.WriteString(fn.Name)
	c.buf.WriteString("(")
	for i, p := range fn.Params {
		if i > 0 {
			c.buf.WriteString(", ")
		}
		c.buf.WriteString("auto ")
		c.buf.WriteString(p.Name)
	}
	c.buf.WriteString(") {\n")
	c.indent++
	for _, st := range fn.Body {
		if err := c.compileStmt(st); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	return nil
}

func (c *Compiler) compileTypeDecl(td *parser.TypeDecl) error {
	if len(td.Variants) > 0 {
		return fmt.Errorf("sum types not supported")
	}
	c.writeIndent()
	c.buf.WriteString("struct ")
	c.buf.WriteString(td.Name)
	c.buf.WriteString(" {\n")
	c.indent++
	for _, m := range td.Members {
		if m.Field == nil {
			return fmt.Errorf("methods in type not supported")
		}
		typ, err := c.compileType(m.Field.Type)
		if err != nil && typ == "auto" {
			return err
		}
		c.writeIndent()
		c.buf.WriteString(fmt.Sprintf("%s %s;\n", typ, m.Field.Name))
	}
	c.indent--
	c.writeln("};")
	return nil
}

func (c *Compiler) compileFunExpr(fe *parser.FunExpr) (string, error) {
	params := []string{}
	for _, p := range fe.Params {
		typ, err := c.compileType(p.Type)
		if err != nil && typ == "auto" {
			return "", err
		}
		params = append(params, fmt.Sprintf("%s %s", typ, p.Name))
	}
	ret := ""
	if fe.Return != nil {
		typ, err := c.compileType(fe.Return)
		if err != nil && typ == "auto" {
			return "", err
		}
		ret = " -> " + typ
	}
	if fe.ExprBody == nil {
		return "", fmt.Errorf("lambda block body not supported")
	}
	body, err := c.compileExpr(fe.ExprBody)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("([=](%s)%s { return %s; })", strings.Join(params, ", "), ret, body), nil
}

func (c *Compiler) compileStmt(s *parser.Statement) error {
	switch {
	case s.Let != nil:
		c.writeIndent()
		typ, err := c.compileType(s.Let.Type)
		if err != nil && typ == "auto" {
			return err
		}
		c.buf.WriteString(typ + " ")
		c.buf.WriteString(s.Let.Name)
		if s.Let.Value != nil {
			c.buf.WriteString(" = ")
			expr, err := c.compileExpr(s.Let.Value)
			if err != nil {
				return err
			}
			c.buf.WriteString(expr)
		} else if s.Let.Type != nil {
			if typ == "int" {
				c.buf.WriteString(" = 0")
			} else if typ == "string" {
				c.buf.WriteString(" = \"\"")
			}
		}
		c.buf.WriteString(";\n")
	case s.Var != nil:
		c.writeIndent()
		typ, err := c.compileType(s.Var.Type)
		if err != nil && typ == "auto" {
			return err
		}
		c.buf.WriteString(typ + " ")
		c.buf.WriteString(s.Var.Name)
		if s.Var.Value != nil {
			c.buf.WriteString(" = ")
			expr, err := c.compileExpr(s.Var.Value)
			if err != nil {
				return err
			}
			c.buf.WriteString(expr)
		} else if s.Var.Type != nil {
			if typ == "int" {
				c.buf.WriteString(" = 0")
			} else if typ == "string" {
				c.buf.WriteString(" = \"\"")
			}
		}
		c.buf.WriteString(";\n")
	case s.Assign != nil:
		c.writeIndent()
		rhs, err := c.compileExpr(s.Assign.Value)
		if err != nil {
			return err
		}
		if len(s.Assign.Index) > 0 && len(s.Assign.Field) == 0 {
			lhs := s.Assign.Name
			for i := 0; i < len(s.Assign.Index)-1; i++ {
				idx, err := c.compileExpr(s.Assign.Index[i].Start)
				if err != nil {
					return err
				}
				lhs = fmt.Sprintf("%s[%s]", lhs, idx)
			}
			idx, err := c.compileExpr(s.Assign.Index[len(s.Assign.Index)-1].Start)
			if err != nil {
				return err
			}
			c.buf.WriteString(fmt.Sprintf("%s[%s] = %s;\n", lhs, idx, rhs))
		} else if len(s.Assign.Index) == 0 && len(s.Assign.Field) == 0 {
			c.buf.WriteString(s.Assign.Name + " = " + rhs + ";\n")
		} else {
			return fmt.Errorf("complex assignment not supported")
		}
	case s.Return != nil:
		c.writeIndent()
		expr, err := c.compileExpr(s.Return.Value)
		if err != nil {
			return err
		}
		c.buf.WriteString("return " + expr + ";\n")
	case s.Expr != nil:
		c.writeIndent()
		expr, err := c.compileExpr(s.Expr.Expr)
		if err != nil {
			return err
		}
		c.buf.WriteString(expr + ";\n")
	case s.If != nil:
		return c.compileIf(s.If)
	case s.While != nil:
		cond, err := c.compileExpr(s.While.Cond)
		if err != nil {
			return err
		}
		c.writeIndent()
		c.buf.WriteString("while(" + cond + ") {\n")
		c.indent++
		for _, b := range s.While.Body {
			if err := c.compileStmt(b); err != nil {
				return err
			}
		}
		c.indent--
		c.writeln("}")
	case s.For != nil:
		return c.compileFor(s.For)
	case s.Break != nil:
		c.writeIndent()
		c.writeln("break;")
	case s.Continue != nil:
		c.writeIndent()
		c.writeln("continue;")
	default:
		return fmt.Errorf("unsupported statement at %v", s.Pos)
	}
	return nil
}

func (c *Compiler) compileIf(st *parser.IfStmt) error {
	cond, err := c.compileExpr(st.Cond)
	if err != nil {
		return err
	}
	c.writeIndent()
	c.buf.WriteString("if(" + cond + ") {\n")
	c.indent++
	for _, s := range st.Then {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	c.writeIndent()
	c.buf.WriteString("}")
	if st.Else != nil {
		c.buf.WriteString(" else {\n")
		c.indent++
		for _, s := range st.Else {
			if err := c.compileStmt(s); err != nil {
				return err
			}
		}
		c.indent--
		c.writeln("}")
	} else {
		c.writeln("")
	}
	return nil
}

func (c *Compiler) compileFor(st *parser.ForStmt) error {
	if st.RangeEnd != nil {
		start, err := c.compileExpr(st.Source)
		if err != nil {
			return err
		}
		end, err := c.compileExpr(st.RangeEnd)
		if err != nil {
			return err
		}
		iter := st.Name
		c.writeIndent()
		c.buf.WriteString(fmt.Sprintf("for(int %s=%s; %s<%s; ++%s) {\n", iter, start, iter, end, iter))
		c.indent++
		for _, b := range st.Body {
			if err := c.compileStmt(b); err != nil {
				return err
			}
		}
		c.indent--
		c.writeln("}")
		return nil
	}
	src, err := c.compileExpr(st.Source)
	if err != nil {
		return err
	}
	iter := st.Name
	c.writeIndent()
	c.buf.WriteString(fmt.Sprintf("for(auto %s : %s) {\n", iter, src))
	c.indent++
	for _, b := range st.Body {
		if err := c.compileStmt(b); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	return nil
}

func (c *Compiler) compileExpr(e *parser.Expr) (string, error) {
	if e == nil {
		return "", nil
	}
	if e.Binary != nil {
		left, err := c.compileUnary(e.Binary.Left)
		if err != nil {
			return "", err
		}
		out := left
		for _, op := range e.Binary.Right {
			rhs, err := c.compilePostfix(op.Right)
			if err != nil {
				return "", err
			}
			if op.Op == "in" {
				out = fmt.Sprintf("([&](const auto& __c,const auto& __e){ using C=decay_t<decltype(__c)>; if constexpr(is_same_v<C,string>) return __c.find(__e) != string::npos; else if constexpr(has_key_type<C>::value) return __c.find(__e) != __c.end(); else return find(__c.begin(), __c.end(), __e) != __c.end(); })(%s,%s)", rhs, out)
			} else {
				out = fmt.Sprintf("(%s %s %s)", out, op.Op, rhs)
			}
		}
		return out, nil
	}
	return "", fmt.Errorf("unsupported expression at %v", e.Pos)
}

func (c *Compiler) compileUnary(u *parser.Unary) (string, error) {
	val, err := c.compilePostfix(u.Value)
	if err != nil {
		return "", err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		val = fmt.Sprintf("(%s%s)", u.Ops[i], val)
	}
	return val, nil
}
func (c *Compiler) compilePostfix(pf *parser.PostfixExpr) (string, error) {
	target, err := c.compilePrimary(pf.Target)
	if err != nil {
		return "", err
	}
	expr := target
	for _, op := range pf.Ops {
		if op.Index != nil {
			if op.Index.Colon != nil {
				start, err := c.compileExpr(op.Index.Start)
				if err != nil {
					return "", err
				}
				end, err := c.compileExpr(op.Index.End)
				if err != nil {
					return "", err
				}
				expr = fmt.Sprintf("([&](const auto& __v){ using V=decay_t<decltype(__v)>; if constexpr(is_same_v<V,string>) return __v.substr(%s, %s-%s); else return vector<typename V::value_type>(__v.begin()+%s, __v.begin()+%s); })(%s)", start, end, start, start, end, expr)
			} else {
				idx, err := c.compileExpr(op.Index.Start)
				if err != nil {
					return "", err
				}
				expr = fmt.Sprintf("%s[%s]", expr, idx)
			}
		} else if op.Call != nil {
			args := []string{}
			for _, a := range op.Call.Args {
				s, err := c.compileExpr(a)
				if err != nil {
					return "", err
				}
				args = append(args, s)
			}
			if expr == "print" && len(args) == 1 {
				expr = fmt.Sprintf("([&](const auto& __v){ if constexpr(has_size<decay_t<decltype(__v)>>::value){ for(size_t i=0;i<__v.size();++i){ if(i) cout<<' '; cout<<__v[i]; } cout<<endl; } else { cout<<__v<<endl; } })(%s)", args[0])
			} else if expr == "print" {
				e := "([&](){ cout"
				for _, a := range args {
					e += " << " + a
				}
				e += " << endl; })()"
				expr = e
			} else if expr == "len" && len(args) == 1 {
				if strings.HasPrefix(args[0], "\"") {
					expr = fmt.Sprintf("((int)string(%s).size())", args[0])
				} else {
					expr = fmt.Sprintf("((int)%s.size())", args[0])
				}
			} else if expr == "count" && len(args) == 1 {
				expr = fmt.Sprintf("((int)%s.size())", args[0])
			} else if expr == "min" && len(args) == 1 {
				expr = fmt.Sprintf("(*min_element(%s.begin(), %s.end()))", args[0], args[0])
			} else if expr == "max" && len(args) == 1 {
				expr = fmt.Sprintf("(*max_element(%s.begin(), %s.end()))", args[0], args[0])
			} else if expr == "str" && len(args) == 1 {
				expr = fmt.Sprintf("to_string(%s)", args[0])
			} else if expr == "append" && len(args) == 2 {
				expr = fmt.Sprintf("([&](auto __v){ __v.push_back(%s); return __v; })(%s)", args[1], args[0])
			} else if expr == "sum" && len(args) == 1 {
				expr = fmt.Sprintf("([&](const auto& __v){ typename decay_t<decltype(__v)>::value_type __s{}; for(const auto& __x: __v) __s += __x; return __s; })(%s)", args[0])
			} else if expr == "avg" && len(args) == 1 {
				expr = fmt.Sprintf("([&](const auto& __v){ typename decay_t<decltype(__v)>::value_type __s{}; for(const auto& __x: __v) __s += __x; return __v.empty()?0:static_cast<double>(__s)/__v.size(); })(%s)", args[0])
			} else if expr == "substring" && len(args) == 3 {
				expr = fmt.Sprintf("%s.substr(%s, %s - %s)", args[0], args[1], args[2], args[1])
			} else if expr == "values" && len(args) == 1 {
				expr = fmt.Sprintf("([&](const auto& __m){ vector<decltype(__m.begin()->second)> __v; for(const auto& __kv: __m) __v.push_back(__kv.second); return __v; })(%s)", args[0])
			} else if strings.HasSuffix(expr, ".contains") && len(args) == 1 {
				base := strings.TrimSuffix(expr, ".contains")
				expr = fmt.Sprintf("(%s.find(%s) != string::npos)", base, args[0])
			} else {
				expr = fmt.Sprintf("%s(%s)", expr, strings.Join(args, ", "))
			}
		} else if op.Field != nil {
			expr = fmt.Sprintf("%s.%s", expr, op.Field.Name)
		} else if op.Cast != nil {
			typ, err := c.compileType(op.Cast.Type)
			if err != nil {
				return "", err
			}
			if typ == "int" {
				expr = fmt.Sprintf("stoi(%s)", expr)
			} else {
				expr = fmt.Sprintf("(%s)(%s)", typ, expr)
			}
		} else {
			return "", fmt.Errorf("unsupported postfix op")
		}
	}
	return expr, nil
}
func (c *Compiler) compilePrimary(p *parser.Primary) (string, error) {
	switch {
	case p.Lit != nil:
		return c.compileLiteral(p.Lit)
	case p.Call != nil:
		args := []string{}
		for _, e := range p.Call.Args {
			s, err := c.compileExpr(e)
			if err != nil {
				return "", err
			}
			args = append(args, s)
		}
		fn := p.Call.Func
		if fn == "print" && len(args) == 1 {
			return fmt.Sprintf("([&](const auto& __v){ if constexpr(has_size<decay_t<decltype(__v)>>::value){ for(size_t i=0;i<__v.size();++i){ if(i) cout<<' '; cout<<__v[i]; } cout<<endl; } else { cout<<__v<<endl; } })(%s)", args[0]), nil
		}
		if fn == "print" {
			out := "([&](){ cout"
			for _, a := range args {
				out += " << " + a
			}
			out += " << endl; })()"
			return out, nil
		}
		if fn == "len" && len(args) == 1 {
			if strings.HasPrefix(args[0], "\"") {
				return fmt.Sprintf("((int)string(%s).size())", args[0]), nil
			}
			return fmt.Sprintf("((int)%s.size())", args[0]), nil
		}
		if fn == "count" && len(args) == 1 {
			return fmt.Sprintf("((int)%s.size())", args[0]), nil
		}
		if fn == "min" && len(args) == 1 {
			return fmt.Sprintf("(*min_element(%s.begin(), %s.end()))", args[0], args[0]), nil
		}
		if fn == "max" && len(args) == 1 {
			return fmt.Sprintf("(*max_element(%s.begin(), %s.end()))", args[0], args[0]), nil
		}
		if fn == "str" && len(args) == 1 {
			return fmt.Sprintf("to_string(%s)", args[0]), nil
		}
		if fn == "append" && len(args) == 2 {
			return fmt.Sprintf("([&](auto __v){ __v.push_back(%s); return __v; })(%s)", args[1], args[0]), nil
		}
		if fn == "sum" && len(args) == 1 {
			return fmt.Sprintf("([&](const auto& __v){ typename decay_t<decltype(__v)>::value_type __s{}; for(const auto& __x: __v) __s += __x; return __s; })(%s)", args[0]), nil
		}
		if fn == "avg" && len(args) == 1 {
			return fmt.Sprintf("([&](const auto& __v){ typename decay_t<decltype(__v)>::value_type __s{}; for(const auto& __x: __v) __s += __x; return __v.empty()?0:static_cast<double>(__s)/__v.size(); })(%s)", args[0]), nil
		}
		if fn == "substring" && len(args) == 3 {
			return fmt.Sprintf("%s.substr(%s, %s - %s)", args[0], args[1], args[2], args[1]), nil
		}
		if fn == "values" && len(args) == 1 {
			return fmt.Sprintf("([&](const auto& __m){ vector<decltype(__m.begin()->second)> __v; for(const auto& __kv: __m) __v.push_back(__kv.second); return __v; })(%s)", args[0]), nil
		}
		return fn + "(" + strings.Join(args, ", ") + ")", nil
	case p.FunExpr != nil:
		return c.compileFunExpr(p.FunExpr)
	case p.Struct != nil:
		fields := []string{}
		for _, f := range p.Struct.Fields {
			s, err := c.compileExpr(f.Value)
			if err != nil {
				return "", err
			}
			fields = append(fields, s)
		}
		return p.Struct.Name + "{" + strings.Join(fields, ", ") + "}", nil
	case p.List != nil:
		elems := []string{}
		for _, e := range p.List.Elems {
			s, err := c.compileExpr(e)
			if err != nil {
				return "", err
			}
			elems = append(elems, s)
		}
		return "vector<int>{" + strings.Join(elems, ", ") + "}", nil
	case p.Map != nil:
		pairs := []string{}
		keyType := "string"
		valType := "int"
		for i, it := range p.Map.Items {
			k, err := c.compileExpr(it.Key)
			if err != nil {
				return "", err
			}
			v, err := c.compileExpr(it.Value)
			if err != nil {
				return "", err
			}
			if i == 0 {
				if strings.HasPrefix(k, "std::string") || strings.HasPrefix(k, "\"") {
					keyType = "string"
				} else {
					keyType = "int"
				}
				if strings.HasPrefix(v, "std::string") || strings.HasPrefix(v, "\"") {
					valType = "string"
				} else if strings.HasPrefix(v, "unordered_map") {
					valType = v[:strings.Index(v, ">")+1]
				} else {
					valType = "int"
				}
			}
			pairs = append(pairs, fmt.Sprintf("{%s, %s}", k, v))
		}
		return fmt.Sprintf("unordered_map<%s, %s>{%s}", keyType, valType, strings.Join(pairs, ", ")), nil
	case p.Selector != nil:
		name := p.Selector.Root
		for _, t := range p.Selector.Tail {
			name += "." + t
		}
		return name, nil
	case p.Group != nil:
		return c.compileExpr(p.Group)
	default:
		return "", fmt.Errorf("unsupported primary at %v", p.Pos)
	}
}

func (c *Compiler) compileLiteral(l *parser.Literal) (string, error) {
	if l.Int != nil {
		return fmt.Sprint(*l.Int), nil
	}
	if l.Float != nil {
		return fmt.Sprint(*l.Float), nil
	}
	if l.Bool != nil {
		if bool(*l.Bool) {
			return "true", nil
		}
		return "false", nil
	}
	if l.Str != nil {
		return fmt.Sprintf("std::string(%q)", *l.Str), nil
	}
	if l.Null {
		return "nullptr", nil
	}
	return "", fmt.Errorf("unknown literal")
}

func (c *Compiler) compileType(t *parser.TypeRef) (string, error) {
	if t == nil {
		return "auto", nil
	}
	if t.Simple != nil {
		switch *t.Simple {
		case "int":
			return "int", nil
		case "string":
			return "string", nil
		default:
			return *t.Simple, nil
		}
	}
	return "auto", fmt.Errorf("unsupported type")
}
