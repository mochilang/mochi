# Elixir Backend

The Elixir backend compiles Mochi programs to `.exs` scripts that can be executed with the `elixir` command. It is invoked by `mochi build --target ex` (or `--target elixir`).

## Files

- `compiler.go` â€“ walks the AST and generates Elixir code
- `compiler_test.go` â€“ golden tests verifying generated programs run correctly
- `tools.go` â€“ utility that ensures the `elixir` binary is available

## Generated Program

`Compile` emits a simple `Main` module containing user-defined functions and a `main/0` entry point:

```go
func (c *Compiler) Compile(prog *parser.Program) ([]byte, error) {
    c.writeln("# Generated by Mochi Elixir compiler")
    c.writeln("defmodule Main do")
    ...
    c.writeln("def main do")
    ...
    c.writeln("end")
    c.writeln("Main.main()")
}
```

ã€F:compile/ex/compiler.goâ€ L39-L65ã€‘

Function bodies wrap statements in a `try`/`catch` block so that `return` can be implemented via exceptions:

```go
c.writeln("try do")
...
c.writeln("catch {:return, v} -> v end")
```

ã€F:compile/ex/compiler.goâ€ L79-L88ã€‘

## Built-in Functions

Several Mochi built-ins translate directly to Elixir equivalents:

```go
switch p.Call.Func {
case "print":
    return fmt.Sprintf("IO.puts(%s)", argStr), nil
case "len":
    return fmt.Sprintf("length(%s)", argStr), nil
case "count":
    c.use("_count")
    return fmt.Sprintf("_count(%s)", argStr), nil
case "avg":
    c.use("_avg")
    return fmt.Sprintf("_avg(%s)", argStr), nil
case "str":
    return fmt.Sprintf("to_string(%s)", argStr), nil
case "input":
    c.use("_input")
    return "_input()", nil
}
```

Helpers also implement `fetch` for HTTP requests and `generate` for text or embedding output using stub functions.

ã€F:compile/ex/compiler.goâ€ L516-L538ã€‘

### Control Flow

`compileIf`, `compileWhile` and `compileFor` generate standard Elixir constructs. Assignments with indexing use `Map.put`:

```go
if len(stmt.Index) > 0 {
    idx, _ := c.compileExpr(stmt.Index[0].Start)
    c.writeln(fmt.Sprintf("%s = Map.put(%s, %s, %s)", stmt.Name, stmt.Name, idx, value))
} else {
    c.writeln(fmt.Sprintf("%s = %s", stmt.Name, value))
}
```

`compileFor` detects string literals and iterates over their graphemes so that
`for ch in "cat"` becomes `for ch <- String.graphemes("cat") do`.

Loops over maps iterate over their keys, so `for k in m` becomes
`for k <- Map.keys(m) do`.


ã€F:compile/ex/compiler.goâ€ L231-L245ã€‘

Query expressions become list comprehensions with optional sorting, skipping and taking:

```go
items := src
if sortExpr != "" {
    items = fmt.Sprintf("Enum.sort_by(%s, fn %s -> %s end)", items, q.Var, sortExpr)
}
...
b.WriteString("for ")
b.WriteString(q.Var)
b.WriteString(" <- ")
b.WriteString(items)
if cond != "" { ... }
b.WriteString(", do: ")
b.WriteString(sel)
```

ã€F:compile/ex/compiler.goâ€ L324-L347ã€‘

Block-style anonymous functions are supported by compiling each statement in the
function body and wrapping the result in `fn` ... `end`:

```go
func (c *Compiler) compileFunExpr(fn *parser.FunExpr) (string, error) {
    params := make([]string, len(fn.Params))
    for i, p := range fn.Params {
        params[i] = p.Name
    }
    if fn.ExprBody != nil {
        expr, err := c.compileExpr(fn.ExprBody)
        if err != nil {
            return "", err
        }
        return fmt.Sprintf("fn %s -> %s end", strings.Join(params, ", "), expr), nil
    }
    if len(fn.BlockBody) > 0 {
        sub := &Compiler{env: c.env, indent: c.indent + 1}
        for _, s := range fn.BlockBody {
            if err := sub.compileStmt(s); err != nil {
                return "", err
            }
        }
        body := sub.buf.String()
        var b strings.Builder
        b.WriteString("fn " + strings.Join(params, ", ") + " ->\n")
        b.WriteString(body)
        for i := 0; i < c.indent; i++ {
            b.WriteByte('\t')
        }
        b.WriteString("end")
        return b.String(), nil
    }
    return "", fmt.Errorf("block function expressions not supported")
}
```

ã€F:compile/ex/compiler.goâ€ L908-L937ã€‘

### Pattern Matching

`match` expressions compile to an inline `cond` block that checks each pattern sequentially:

```go
func (c *Compiler) compileMatchExpr(m *parser.MatchExpr) (string, error) {
    ...
}
```

ã€F:compile/ex/compiler.goâ€ L636-L667ã€‘

## Ensuring Elixir

`EnsureElixir` checks for the `elixir` executable and installs it using `apt-get`, `brew` or `asdf` if necessary:

```go
if _, err := exec.LookPath("elixir"); err == nil {
    return nil
}
fmt.Println("ðŸ”§ Installing Elixir...")
...
return fmt.Errorf("elixir not installed and no supported installer found")
```

ã€F:compile/ex/tools.goâ€ L9-L57ã€‘

## Building

Compile a Mochi program to Elixir with:

```bash
mochi build --target ex main.mochi -o main.exs
```

This corresponds to the `ex`/`elixir` case in the CLI:

```go
case "ex", "elixir":
    if out == "" {
        out = base + ".ex"
    }
    code, err := excode.New(env).Compile(prog)
    ...
```

ã€F:cmd/mochi/main.goâ€ L519-L528ã€‘

## Tests

Golden tests generate Elixir code, run it with the `elixir` command and compare the output:

```go
golden.Run(t, "tests/compiler/ex", ".mochi", ".out", func(src string) ([]byte, error) {
    ...
    cmd := exec.Command("elixir", file)
    ...
})
```

ã€F:compile/ex/compiler_test.goâ€ L19-L48ã€‘

Run them with:

```bash
go test ./compile/ex -tags slow
```

## Elixir to Mochi Conversion

The `any2mochi` tool can also translate small Elixir programs back into Mochi
source. It relies on the Elixir language server for symbol information and then
parses function bodies with simple string matching.

### Supported Features

- Top-level function definitions with parameter and return types from hover data
- `IO.puts` statements become `print` calls, including multi-argument forms
- `if`, `for` and `while` blocks
- Variable assignments and `return`, `break` and `continue`

### Unsupported Features

- Pattern matching clauses or multi-function heads
- Macros, modules and protocol definitions
- Complex comprehensions or dataset queries

## Unsupported Features

The Elixir backend implements most core language features but still lacks support for several advanced constructs:

- Nested recursive functions inside other functions. Problems relying on them, such as LeetCode 22, fail to run.
- Dataset queries with outer joins or complex aggregation.
- Agent and stream constructs (`agent`, `on`, `emit`) and logic programming features (`fact`, `rule`, `query`).
- Model declarations (`model` blocks).
- `load` and `save` now handle CSV and JSON data, but YAML remains unsupported.
- Foreign imports and `extern` declarations.
- Concurrency primitives such as `spawn` and channels.
- Pattern matching on union variants is not yet supported.
- Intent declarations within agents.
- Package declarations and `export` statements.
- Methods defined inside `type` blocks.
- Generic type parameters for functions and user-defined types.
- `generate` helpers currently return placeholder data.
- Reflection or macro facilities and error handling with `try`/`catch`.

Cross join queries do support `where` filters as well as `sort`, `skip` and `take` clauses.
