package java

import (
	"fmt"
	"os"
	"strings"
)

// Convert converts a very small subset of Java source code to Mochi.
// The converter is intentionally limited but is able to handle the simple
// Java programs generated by the Mochi compiler. Unsupported constructs
// result in an informative error.
func Convert(src string) ([]byte, error) {
	lines, err := parse(src)
	if err != nil {
		return nil, err
	}
	if len(lines) == 0 {
		return nil, fmt.Errorf("no convertible symbols found\n\nsource snippet:\n%s", numberedSnippet(src))
	}
	return []byte(strings.Join(lines, "\n")), nil
}

// convertJavaExpr performs very basic cleanup of Java expressions so that they
// resemble Mochi syntax. It does not attempt full parsing.
func convertJavaExpr(expr string, structs map[string][]string) string {
	expr = strings.TrimSpace(expr)
	expr = strings.TrimSuffix(expr, ";")
	for strings.HasPrefix(expr, "(") && strings.HasSuffix(expr, ")") {
		expr = strings.TrimSpace(expr[1 : len(expr)-1])
	}

	if idx := strings.Index(expr, "->"); idx != -1 {
		params := strings.TrimSpace(expr[:idx])
		body := strings.TrimSpace(expr[idx+2:])
		if strings.HasPrefix(params, "(") && strings.HasSuffix(params, ")") {
			params = strings.TrimSpace(params[1 : len(params)-1])
		}
		var names []string
		if params != "" {
			for _, p := range strings.Split(params, ",") {
				f := strings.Fields(strings.TrimSpace(p))
				if len(f) > 0 {
					names = append(names, f[len(f)-1])
				}
			}
		}
		if strings.HasPrefix(body, "{") && strings.HasSuffix(body, "}") {
			body = strings.TrimSpace(body[1 : len(body)-1])
			parts := strings.Split(body, ";")
			for i, p := range parts {
				parts[i] = strings.TrimSpace(p)
			}
			var stmts []string
			for _, p := range parts {
				if p == "" {
					continue
				}
				if strings.HasPrefix(p, "return ") {
					stmts = append(stmts, "return "+convertJavaExpr(strings.TrimPrefix(p, "return "), structs))
				} else if isVarAssign(p + ";") {
					n, e := parseVarAssign(p + ";")
					stmts = append(stmts, "var "+n+" = "+convertJavaExpr(e, structs))
				} else {
					stmts = append(stmts, convertJavaExpr(p, structs))
				}
			}
			body = strings.Join(stmts, "; ")
		} else {
			body = convertJavaExpr(body, structs)
		}
		return "fn(" + strings.Join(names, ", ") + ") { " + body + " }"
	}

	if strings.HasPrefix(expr, "new ") && strings.Contains(expr, "{") && strings.HasSuffix(expr, "}") {
		open := strings.Index(expr, "{")
		items := splitArgs(expr[open+1 : len(expr)-1])
		for i, it := range items {
			items[i] = convertJavaExpr(it, structs)
		}
		return "[" + strings.Join(items, ", ") + "]"
	}

	if strings.HasPrefix(expr, "new java.util.HashMap<>(java.util.Map.of(") && strings.HasSuffix(expr, "))") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "new java.util.HashMap<>(java.util.Map.of("), "))")
		return mapLiteral(inner, structs)
	}

	if strings.HasPrefix(expr, "new ") && strings.HasSuffix(expr, ")") {
		open := strings.Index(expr, "(")
		if open != -1 {
			name := strings.TrimSpace(expr[4:open])
			argsPart := expr[open+1 : len(expr)-1]
			if fields, ok := structs[name]; ok {
				args := splitArgs(argsPart)
				if len(args) == len(fields) {
					for i, a := range args {
						args[i] = fields[i] + ": " + convertJavaExpr(a, structs)
					}
					return name + " { " + strings.Join(args, ", ") + " }"
				}
			}
			args := splitArgs(argsPart)
			for i, a := range args {
				args[i] = convertJavaExpr(a, structs)
			}
			return name + "(" + strings.Join(args, ", ") + ")"
		}
	}

	if strings.HasSuffix(expr, ".toCharArray()") {
		return convertJavaExpr(strings.TrimSuffix(expr, ".toCharArray()"), structs)
	}

	if idx := strings.Index(expr, ".get("); idx != -1 && strings.HasSuffix(expr, ")") {
		name := expr[:idx]
		inner := strings.TrimSuffix(expr[idx+5:], ")")
		return name + "[" + convertJavaExpr(inner, structs) + "]"
	}

	if strings.HasSuffix(expr, ".size()") {
		return "len(" + strings.TrimSuffix(expr, ".size()") + ")"
	}

	if strings.HasSuffix(expr, ".length") {
		return "len(" + convertJavaExpr(strings.TrimSuffix(expr, ".length"), structs) + ")"
	}

	if strings.HasSuffix(expr, ".keySet()") {
		inner := strings.TrimSuffix(expr, ".keySet()")
		return "keys(" + convertJavaExpr(inner, structs) + ")"
	}

	if strings.HasPrefix(expr, "_indexString(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "_indexString("), ")")
		parts := splitArgs(inner)
		if len(parts) == 2 {
			return convertJavaExpr(parts[0], structs) + "[" + convertJavaExpr(parts[1], structs) + "]"
		}
	}

	if strings.HasPrefix(expr, "_sliceString(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "_sliceString("), ")")
		parts := splitArgs(inner)
		if len(parts) == 3 {
			return convertJavaExpr(parts[0], structs) + "[" + convertJavaExpr(parts[1], structs) + ":" + convertJavaExpr(parts[2], structs) + "]"
		}
	}

	if strings.HasPrefix(expr, "_in(") && strings.HasSuffix(expr, ")") {
		inner := strings.TrimSuffix(strings.TrimPrefix(expr, "_in("), ")")
		parts := splitArgs(inner)
		if len(parts) == 2 {
			return convertJavaExpr(parts[0], structs) + " in " + convertJavaExpr(parts[1], structs)
		}
	}

	if idx := strings.Index(expr, ".apply("); idx != -1 && strings.HasSuffix(expr, ")") {
		name := expr[:idx]
		arg := strings.TrimSuffix(expr[idx+7:], ")")
		return convertJavaExpr(name, structs) + "(" + convertJavaExpr(arg, structs) + ")"
	}

	reBuiltin := []struct{ old, new string }{
		{"_avg(", "avg("},
		{"_count(", "count("},
		{"String.valueOf(", "str("},
	}
	for _, b := range reBuiltin {
		if strings.HasPrefix(expr, b.old) && strings.HasSuffix(expr, ")") {
			inner := strings.TrimSuffix(strings.TrimPrefix(expr, b.old), ")")
			return b.new + convertJavaExpr(inner, structs) + ")"
		}
	}

	return expr
}

func splitArgs(s string) []string {
	var parts []string
	var b strings.Builder
	depth := 0
	inStr := false
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if inStr {
			b.WriteByte(ch)
			if ch == '"' {
				inStr = false
			}
			continue
		}
		switch ch {
		case '"':
			inStr = true
			b.WriteByte(ch)
		case '(', '{', '[':
			depth++
			b.WriteByte(ch)
		case ')', '}', ']':
			depth--
			b.WriteByte(ch)
		case ',':
			if depth == 0 {
				parts = append(parts, strings.TrimSpace(b.String()))
				b.Reset()
			} else {
				b.WriteByte(ch)
			}
		default:
			b.WriteByte(ch)
		}
	}
	if b.Len() > 0 {
		parts = append(parts, strings.TrimSpace(b.String()))
	}
	return parts
}

func mapLiteral(args string, structs map[string][]string) string {
	parts := splitArgs(args)
	if len(parts)%2 != 0 {
		return "{" + args + "}"
	}
	var b strings.Builder
	b.WriteByte('{')
	for i := 0; i < len(parts); i += 2 {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(convertJavaExpr(parts[i], structs))
		b.WriteString(": ")
		b.WriteString(convertJavaExpr(parts[i+1], structs))
	}
	b.WriteByte('}')
	return b.String()
}

func mapJavaType(t string) string {
	switch t {
	case "int", "Integer":
		return "int"
	case "double", "Double", "float", "Float":
		return "float"
	case "boolean", "Boolean":
		return "bool"
	case "String":
		return "string"
	default:
		return t
	}
}

func isVarAssign(line string) bool {
	if !strings.HasSuffix(line, ";") {
		return false
	}
	if !strings.Contains(line, "=") {
		return false
	}
	left := strings.TrimSpace(strings.SplitN(line, "=", 2)[0])
	return strings.Contains(left, " ")
}

func parseVarAssign(line string) (string, string) {
	line = strings.TrimSuffix(line, ";")
	parts := strings.SplitN(line, "=", 2)
	if len(parts) != 2 {
		return "", ""
	}
	left := strings.TrimSpace(parts[0])
	expr := strings.TrimSpace(parts[1])
	fields := strings.Fields(left)
	if len(fields) == 0 {
		return "", expr
	}
	name := fields[len(fields)-1]
	return name, expr
}

func parseMapPut(line string) (string, string, string, bool) {
	if !strings.Contains(line, ".put(") || !strings.HasSuffix(line, ");") {
		return "", "", "", false
	}
	before := line[:strings.Index(line, ".put(")]
	args := strings.TrimSuffix(line[strings.Index(line, ".put(")+5:], ");")
	items := splitArgs(args)
	if len(items) != 2 {
		return "", "", "", false
	}
	return strings.TrimSpace(before), strings.TrimSpace(items[0]), strings.TrimSpace(items[1]), true
}

func parseSimpleAssign(line string) (string, string, bool) {
	line = strings.TrimSuffix(line, ";")
	parts := strings.SplitN(line, "=", 2)
	if len(parts) != 2 {
		return "", "", false
	}
	left := strings.TrimSpace(parts[0])
	right := strings.TrimSpace(parts[1])
	if left == "" || right == "" {
		return "", "", false
	}
	return left, right, true
}

func isFieldLine(line string) bool {
	return strings.HasSuffix(line, ";") && strings.Count(line, " ") >= 1
}

func parseFieldLine(line string) (string, string) {
	line = strings.TrimSuffix(line, ";")
	idx := strings.LastIndex(line, " ")
	if idx == -1 {
		return "", line
	}
	return strings.TrimSpace(line[:idx]), strings.TrimSpace(line[idx+1:])
}

// ConvertFile reads the Java file and converts it to Mochi.
func ConvertFile(path string) ([]byte, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return Convert(string(data))
}

func numberedSnippet(src string) string {
	lines := strings.Split(src, "\n")
	if len(lines) > 10 {
		lines = lines[:10]
	}
	for i, l := range lines {
		lines[i] = fmt.Sprintf("%3d: %s", i+1, l)
	}
	return strings.Join(lines, "\n")
}
