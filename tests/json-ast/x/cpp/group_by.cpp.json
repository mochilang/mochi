{
  "funcs": [
    {
      "Name": "__addressof",
      "Params": [
        {
          "Name": "__r",
          "Typ": "_Tp"
        }
      ],
      "Ret": "_Tp",
      "Body": "e(), .avg_age = ([\u0026]{ auto tmp = (["
    },
    {
      "Name": "forward",
      "Params": [
        {
          "Name": "__t",
          "Typ": "typename std::remove_reference\u003c_Tp\u003e::type"
        }
      ],
      "Ret": "_Tp",
      "Body": "lpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::stri"
    },
    {
      "Name": "__is_single_threaded",
      "Params": null,
      "Ret": "bool",
      "Body": "econd].items.push_back(person);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = "
    },
    {
      "Name": "__exchange_and_add",
      "Params": [
        {
          "Name": "__mem",
          "Typ": "volatile _Atomic_word"
        },
        {
          "Name": "__val",
          "Typ": "int"
        }
      ],
      "Ret": "_Atomic_word",
      "Body": "y ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std:"
    },
    {
      "Name": "__atomic_add",
      "Params": [
        {
          "Name": "__mem",
          "Typ": "volatile _Atomic_word"
        },
        {
          "Name": "__val",
          "Typ": "int"
        }
      ],
      "Ret": "",
      "Body": "avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl;\n    }\n  "
    },
    {
      "Name": "__ostream_write",
      "Params": [
        {
          "Name": "__out",
          "Typ": "basic_ostream\u003c_CharT, _Traits\u003e"
        },
        {
          "Name": "__s",
          "Typ": "_CharT"
        },
        {
          "Name": "__n",
          "Typ": "streamsize"
        }
      ],
      "Ret": "",
      "Body": " g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(),"
    },
    {
      "Name": "__iter_less_iter",
      "Params": null,
      "Ret": "_Iter_less_iter",
      "Body": "up g = __g;\n    __items.push"
    },
    {
      "Name": "__iter_less_val",
      "Params": null,
      "Ret": "_Iter_less_val",
      "Body": "oolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c"
    },
    {
      "Name": "__iter_comp_val",
      "Params": [
        {
          "Name": "",
          "Typ": "_Iter_less_iter"
        }
      ],
      "Ret": "_Iter_less_val",
      "Body": "' \u003c\u003c s.avg_age \u003c\u003c std::endl"
    },
    {
      "Name": "__invfwd",
      "Params": [
        {
          "Name": "__t",
          "Typ": "typename remove_reference\u003c_Tp\u003e::type"
        }
      ],
      "Ret": "_Up",
      "Body": "age);\n}\nreturn __items; }()); retu"
    },
    {
      "Name": "__invoke_impl",
      "Params": [
        {
          "Name": "",
          "Typ": "__invoke_other"
        },
        {
          "Name": "__f",
          "Typ": "_Fn"
        },
        {
          "Name": "__args",
          "Typ": "_Args \u0026\u0026..."
        }
      ],
      "Ret": "_Res",
      "Body": ":boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c st"
    },
    {
      "Name": "begin",
      "Params": [
        {
          "Name": "__cont",
          "Typ": "_Container"
        }
      ],
      "Ret": "",
      "Body": "y() ? 0.0 : std::accumula"
    },
    {
      "Name": "begin",
      "Params": [
        {
          "Name": "__cont",
          "Typ": "_Container"
        }
      ],
      "Ret": "",
      "Body": ", avg_age =\") \u003c\u003c ' ' \u003c\u003c s"
    },
    {
      "Name": "__to_unsigned_like",
      "Params": [
        {
          "Name": "__t",
          "Typ": "__max_size_type"
        }
      ],
      "Ret": "__max_size_type",
      "Body": "}()); return t"
    },
    {
      "Name": "__to_unsigned_like",
      "Params": [
        {
          "Name": "__t",
          "Typ": "__max_diff_type"
        }
      ],
      "Ret": "__max_size_type",
      "Body": "turn __items; }());\n\nint main()"
    },
    {
      "Name": "__to_unsigned_like",
      "Params": [
        {
          "Name": "__t",
          "Typ": "_Tp"
        }
      ],
      "Ret": "",
      "Body": "  for (auto s : stats) {\n        std::cout \u003c\u003c std"
    },
    {
      "Name": "__to_unsigned_like",
      "Params": [
        {
          "Name": "__t",
          "Typ": "__int128"
        }
      ],
      "Ret": "__int128",
      "Body": "dl;\n    }\n    "
    },
    {
      "Name": "__sv_check",
      "Params": [
        {
          "Name": "__size",
          "Typ": "int"
        },
        {
          "Name": "__pos",
          "Typ": "int"
        },
        {
          "Name": "__s",
          "Typ": "string"
        }
      ],
      "Ret": "int",
      "Body": ":boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::str"
    },
    {
      "Name": "__bswap_16",
      "Params": [
        {
          "Name": "__bsx",
          "Typ": "__uint16_t"
        }
      ],
      "Ret": "__uint16_t",
      "Body": " auto __key = person.city;\n        auto it = __idx.find(__key);\n        if(it == __idx.end()) {\n            GGroup"
    },
    {
      "Name": "__bswap_32",
      "Params": [
        {
          "Name": "__bsx",
          "Typ": "__uint32_t"
        }
      ],
      "Ret": "__uint32_t",
      "Body": "GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{"
    },
    {
      "Name": "__uint16_identity",
      "Params": [
        {
          "Name": "__x",
          "Typ": "__uint16_t"
        }
      ],
      "Ret": "__uint16_t",
      "Body": "__key = person.c"
    },
    {
      "Name": "__uint32_identity",
      "Params": [
        {
          "Name": "__x",
          "Typ": "__uint32_t"
        }
      ],
      "Ret": "__uint32_t",
      "Body": "end()) {\n       "
    },
    {
      "Name": "__uint64_identity",
      "Params": [
        {
          "Name": "__x",
          "Typ": "__uint64_t"
        }
      ],
      "Ret": "__uint64_t",
      "Body": "n);\n            "
    },
    {
      "Name": "abs",
      "Params": [
        {
          "Name": "__i",
          "Typ": "int"
        }
      ],
      "Ret": "int",
      "Body": ".count = g.size(), .avg_age = "
    },
    {
      "Name": "abs",
      "Params": [
        {
          "Name": "__x",
          "Typ": "long long"
        }
      ],
      "Ret": "long long",
      "Body": "ms.push_back(p.age);\n}\nreturn __"
    },
    {
      "Name": "abs",
      "Params": [
        {
          "Name": "__x",
          "Typ": "float"
        }
      ],
      "Ret": "float",
      "Body": "\u003c std::string(\": count =\") \u003c\u003c "
    },
    {
      "Name": "abs",
      "Params": [
        {
          "Name": "__x",
          "Typ": "float"
        }
      ],
      "Ret": "float",
      "Body": " ' \u003c\u003c s.avg_age \u003c\u003c std::endl;\n "
    },
    {
      "Name": "__check_facet",
      "Params": [
        {
          "Name": "__f",
          "Typ": "_Facet"
        }
      ],
      "Ret": "_Facet",
      "Body": "rson);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = "
    },
    {
      "Name": "__check_facet",
      "Params": [
        {
          "Name": "__f",
          "Typ": "std::ctype\u003cchar\u003e"
        }
      ],
      "Ret": "std::ctype\u003cchar\u003e",
      "Body": "rson);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = "
    },
    {
      "Name": "__erase_nodes_if",
      "Params": [
        {
          "Name": "__cont",
          "Typ": "_Container"
        },
        {
          "Name": "__ucont",
          "Typ": "_UnsafeContainer"
        },
        {
          "Name": "__pred",
          "Typ": "_Predicate"
        }
      ],
      "Ret": "typename _Container::size_type",
      "Body": "tem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size(); }())});\n}\nreturn "
    },
    {
      "Name": "resetiosflags",
      "Params": [
        {
          "Name": "__mask",
          "Typ": "ios_base::fmtflags"
        }
      ],
      "Ret": "_Resetiosflags",
      "Body": " __items; }());\n\nint "
    },
    {
      "Name": "operator\u003e\u003e",
      "Params": [
        {
          "Name": "__is",
          "Typ": "basic_istream\u003c_CharT, _Traits\u003e"
        },
        {
          "Name": "__f",
          "Typ": "_Resetiosflags"
        }
      ],
      "Ret": "basic_istream\u003c_CharT, _Traits\u003e",
      "Body": " s.city \u003c\u003c ' ' \u003c\u003c std::string(\": count =\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::st"
    },
    {
      "Name": "main",
      "Params": null,
      "Ret": "int",
      "Body": "{\n    std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\": count =\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::string(\", avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl;\n    }\n    return 0;\n"
    }
  ],
  "enums": [
    {
      "Name": "_Ord",
      "Variants": [
        "equivalent",
        "less",
        "greater"
      ]
    },
    {
      "Name": "_Ncmp",
      "Variants": [
        "_Unordered"
      ]
    },
    {
      "Name": "dateorder",
      "Variants": [
        "no_order",
        "dmy",
        "mdy",
        "ymd",
        "ydm"
      ]
    },
    {
      "Name": "result",
      "Variants": [
        "ok",
        "partial",
        "error",
        "noconv"
      ]
    }
  ],
  "structs": [
    {
      "Name": "PeopleItem",
      "Fields": [
        {
          "Name": "name",
          "Typ": "string"
        },
        {
          "Name": "age",
          "Typ": "int"
        },
        {
          "Name": "city",
          "Typ": "string"
        }
      ]
    },
    {
      "Name": "GGroup",
      "Fields": [
        {
          "Name": "key",
          "Typ": "string"
        },
        {
          "Name": "items",
          "Typ": "list\u003cPeopleItem\u003e"
        }
      ]
    },
    {
      "Name": "StatsItem",
      "Fields": [
        {
          "Name": "city",
          "Typ": "string"
        },
        {
          "Name": "count",
          "Typ": "int"
        },
        {
          "Name": "avg_age",
          "Typ": "float"
        }
      ]
    }
  ],
  "globals": [
    {
      "Name": "tmp.empty()",
      "Typ": "); } return __items; }()); return",
      "Value": ""
    },
    {
      "Name": "tmp.empty()",
      "Typ": "); } return __items; }()); return",
      "Value": ""
    },
    {
      "Name": "tmp.",
      "Typ": "); } return __items; }()); return",
      "Value": ""
    },
    {
      "Name": "tmp.",
      "Typ": "); } return __items; }()); return",
      "Value": ""
    },
    {
      "Name": "e",
      "Typ": "",
      "Value": "22, .cit"
    },
    {
      "Name": "return",
      "Typ": "\u003c s.avg_age \u003c\u003c std::endl; }",
      "Value": ""
    },
    {
      "Name": "ush_back(StatsItem{.city",
      "Typ": "",
      "Value": "g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items"
    },
    {
      "Name": "std::accumulate(tmp.begin(),",
      "Typ": "ms.push_back(p.age); } return __items; }()); return tmp.empty() ? 0.0 :",
      "Value": ""
    },
    {
      "Name": "city",
      "Typ": "_items; }()); int main() { std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by",
      "Value": ""
    },
    {
      "Name": "count",
      "Typ": "ts) { std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\":",
      "Value": "\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::string(\", avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl"
    },
    {
      "Name": "g",
      "Typ": "} for(auto \u0026__g : __groups) { GGroup",
      "Value": ""
    },
    {
      "Name": "m{.city",
      "Typ": "",
      "Value": "g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items"
    },
    {
      "Name": "ack(person)",
      "Typ": "",
      "Value": ""
    },
    {
      "Name": "g",
      "Typ": "} } for(auto \u0026__g : __groups) { GGroup",
      "Value": "__g;\n    __items.push_back(Stat"
    },
    {
      "Name": "t",
      "Typ": "ector\u003cint\u003e __items; for (auto p : g) { __items.push_back(p.age); } return __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) /",
      "Value": ""
    },
    {
      "Name": "t",
      "Typ": "p.age); } return __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) /",
      "Value": ""
    },
    {
      "Name": "people",
      "Typ": "// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:19:54 GMT+7 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e #include \u003cmap\u003e #include \u003cnumeric\u003e #include \u003csstream\u003e #include \u003ciomanip\u003e #include \u003cunordered_map\u003e struct PeopleItem { std::string name; int age; std::string city; }; struct GGroup { std::string key; std::vector\u003cPeopleItem\u003e items; auto begin() { return items.begin(); } auto end() { return items.end(); } size_t size() const { return items.size(); } }; struct StatsItem { std::string city; int count; double avg_age; }; std::vector\u003cPeopleItem\u003e",
      "Value": "std::vector{PeopleItem{.name = std::string(\"Alice\"), .age = 30, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Bob\"), .age = 15, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Charlie\"), .age = 65, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Diana\"), .age = 45, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Eve\"), .age = 70, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Frank\"), .age = 22, .city = std::string(\"Hanoi\")}};\nstd::vector\u003cStatsItem\u003e stats = ([]{ std::vector\u003cStatsItem\u003e __items;\nstd::vector\u003cGGroup\u003e __groups;\nstd::unordered_map\u003cstd::string, size_t\u003e __idx;\nfor (auto person : people) {\n        auto __key = person.city;\n        auto it = __idx.find(__key);\n        if(it == __idx.end()) {\n            GGroup __g{__key, {}};\n            __g.items.push_back(person);\n            __idx[__key] = __groups.size();\n            __groups.push_back(__g);\n        } else {\n            __groups[it-\u003esecond].items.push_back(person);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size(); }())});\n}\nreturn __items; }());\n\nint main() {\n    std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\": count =\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::string(\", avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl"
    },
    {
      "Name": "for",
      "Typ": "alpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;",
      "Value": ""
    },
    {
      "Name": "count",
      "Typ": "\u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\":",
      "Value": "\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c '"
    },
    {
      "Name": "{",
      "Typ": "} } for(auto \u0026__g : __groups)",
      "Value": ""
    },
    {
      "Name": "__i",
      "Typ": "__items.push_back(p.age); } return",
      "Value": ""
    },
    {
      "Name": "std:",
      "Typ": "()); return tmp.empty() ? 0.0 :",
      "Value": ""
    },
    {
      "Name": "tmp.end(),",
      "Typ": "late(tmp.begin(),",
      "Value": ""
    },
    {
      "Name": "main()",
      "Typ": "mp.size(); }())}); } return __items; }()); int",
      "Value": ""
    },
    {
      "Name": "std::endl",
      "Typ": "t main() { std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c",
      "Value": ""
    },
    {
      "Name": "Peopl",
      "Typ": "ring(\"---",
      "Value": ""
    },
    {
      "Name": ":",
      "Typ": "for (auto s",
      "Value": ""
    },
    {
      "Name": "s",
      "Typ": "ity \u003c\u003c ' ' \u003c\u003c",
      "Value": ""
    },
    {
      "Name": "s.avg_",
      "Typ": "\u003c\u003c ' ' \u003c\u003c",
      "Value": ""
    },
    {
      "Name": "people",
      "Typ": "// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:19:54 GMT+7 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e #include \u003cmap\u003e #include \u003cnumeric\u003e #include \u003csstream\u003e #include \u003ciomanip\u003e #include \u003cunordered_map\u003e struct PeopleItem { std::string name; int age; std::string city; }; struct GGroup { std::string key; std::vector\u003cPeopleItem\u003e items; auto begin() { return items.begin(); } auto end() { return items.end(); } size_t size() const { return items.size(); } }; struct StatsItem { std::string city; int count; double avg_age; }; std::vector\u003cPeopleItem\u003e",
      "Value": "std::vector{PeopleItem{.name = std::string(\"Alice\"), .age = 30, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Bob\"), .age = 15, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Charlie\"), .age = 65, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Diana\"), .age = 45, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Eve\"), .age = 70, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Frank\"), .age = 22, .city = std::string(\"Hanoi\")}};\nstd::vector\u003cStatsItem\u003e stats = ([]{ std::vector\u003cStatsItem\u003e __items;\nstd::vector\u003cGGroup\u003e __groups;\nstd::unordered_map\u003cstd::string, size_t\u003e __idx;\nfor (auto person : people) {\n        auto __key = person.city;\n        auto it = __idx.find(__key);\n        if(it == __idx.end()) {\n            GGroup __g{__key, {}};\n            __g.items.push_back(person);\n            __idx[__key] = __groups.size();\n            __groups.push_back(__g);\n        } else {\n            __groups[it-\u003esecond].items.push_back(person);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size(); }())});\n}\nreturn __items; }());\n\nint main() {\n    std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\": count =\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::string(\", avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl"
    },
    {
      "Name": "people",
      "Typ": "// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:19:54 GMT+7 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e #include \u003cmap\u003e #include \u003cnumeric\u003e #include \u003csstream\u003e #include \u003ciomanip\u003e #include \u003cunordered_map\u003e struct PeopleItem { std::string name; int age; std::string city; }; struct GGroup { std::string key; std::vector\u003cPeopleItem\u003e items; auto begin() { return items.begin(); } auto end() { return items.end(); } size_t size() const { return items.size(); } }; struct StatsItem { std::string city; int count; double avg_age; }; std::vector\u003cPeopleItem\u003e",
      "Value": "std::vector{PeopleItem{.name = std::string(\"Alice\"), .age = 30, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Bob\"), .age = 15, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Charlie\"), .age = 65, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Diana\"), .age = 45, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Eve\"), .age = 70, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Frank\"), .age = 22, .city = std::string(\"Hanoi\")}};\nstd::vector\u003cStatsItem\u003e stats = ([]{ std::vector\u003cStatsItem\u003e __items;\nstd::vector\u003cGGroup\u003e __groups;\nstd::unordered_map\u003cstd::string, size_t\u003e __idx;\nfor (auto person : people) {\n        auto __key = person.city;\n        auto it = __idx.find(__key);\n        if(it == __idx.end()) {\n            GGroup __g{__key, {}};\n            __g.items.push_back(person);\n            __idx[__key] = __groups.size();\n            __groups.push_back(__g);\n        } else {\n            __groups[it-\u003esecond].items.push_back(person);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size(); }())});\n}\nreturn __items; }());\n\nint main() {\n    std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\": count =\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::string(\", avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl;\n    }\n    return 0"
    },
    {
      "Name": "std::accumula",
      "Typ": "urn tmp.empty() ? 0.0 :",
      "Value": ""
    },
    {
      "Name": "std::accumula",
      "Typ": "urn tmp.empty() ? 0.0 :",
      "Value": ""
    },
    {
      "Name": "avg_age",
      "Typ": ".count \u003c\u003c ' ' \u003c\u003c std::string(\",",
      "Value": "\") \u003c"
    },
    {
      "Name": "std::endl",
      "Typ": "\u003c\u003c s.avg_age \u003c\u003c",
      "Value": ""
    },
    {
      "Name": "}())})",
      "Typ": "egin(), tmp.end(), 0.0) / tmp.size();",
      "Value": ""
    },
    {
      "Name": "main",
      "Typ": "urn __items; }()); int",
      "Value": ""
    },
    {
      "Name": "people",
      "Typ": "list\u003cPeopleItem\u003e",
      "Value": "std::vector{PeopleItem{.name = std::string(\"Alice\"), .age = 30, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Bob\"), .age = 15, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Charlie\"), .age = 65, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Diana\"), .age = 45, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Eve\"), .age = 70, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Frank\"), .age = 22, .city = std::string(\"Hanoi\")}}"
    },
    {
      "Name": "stats",
      "Typ": "list\u003cStatsItem\u003e",
      "Value": "[]{ std::vector\u003cStatsItem\u003e __items;\nstd::vector\u003cGGroup\u003e __groups;\nstd::unordered_map\u003cstd::string, size_t\u003e __idx;\nfor (auto person : people) {\n        auto __key = person.city;\n        auto it = __idx.find(__key);\n        if(it == __idx.end()) {\n            GGroup __g{__key, {}};\n            __g.items.push_back(person);\n            __idx[__key] = __groups.size();\n            __groups.push_back(__g);\n        } else {\n            __groups[it-\u003esecond].items.push_back(person);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size(); }())});\n}\nreturn __items; }("
    },
    {
      "Name": "std::vector\u003cStatsItem\u003e",
      "Typ": "",
      "Value": ""
    },
    {
      "Name": "std::vector\u003cGGroup\u003e",
      "Typ": "",
      "Value": ""
    },
    {
      "Name": "size_t\u003e",
      "Typ": "std::unordered_map\u003cstd::string,",
      "Value": ""
    },
    {
      "Name": "person",
      "Typ": "",
      "Value": ""
    },
    {
      "Name": "__key",
      "Typ": "",
      "Value": "person."
    },
    {
      "Name": "it",
      "Typ": "",
      "Value": "__idx.find(__key"
    },
    {
      "Name": "{}}",
      "Typ": "GGroup __g{__key,",
      "Value": ""
    },
    {
      "Name": "\u0026__g",
      "Typ": "",
      "Value": ""
    },
    {
      "Name": "g",
      "Typ": "GGroup",
      "Value": ""
    },
    {
      "Name": "tmp",
      "Typ": "",
      "Value": "[]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }("
    },
    {
      "Name": "std::vector\u003cint\u003e",
      "Typ": "",
      "Value": ""
    },
    {
      "Name": "p",
      "Typ": "",
      "Value": ""
    }
  ],
  "source": "// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:19:54 GMT+7\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n#include \u003cmap\u003e\n#include \u003cnumeric\u003e\n#include \u003csstream\u003e\n#include \u003ciomanip\u003e\n#include \u003cunordered_map\u003e\n\n\nstruct PeopleItem {\n    std::string name;\n    int age;\n    std::string city;\n};\n\nstruct GGroup {\n    std::string key;\n    std::vector\u003cPeopleItem\u003e items;\n    auto begin() { return items.begin(); }\n    auto end() { return items.end(); }\n    size_t size() const { return items.size(); }\n};\n\nstruct StatsItem {\n    std::string city;\n    int count;\n    double avg_age;\n};\n\nstd::vector\u003cPeopleItem\u003e people = std::vector{PeopleItem{.name = std::string(\"Alice\"), .age = 30, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Bob\"), .age = 15, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Charlie\"), .age = 65, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Diana\"), .age = 45, .city = std::string(\"Hanoi\")}, PeopleItem{.name = std::string(\"Eve\"), .age = 70, .city = std::string(\"Paris\")}, PeopleItem{.name = std::string(\"Frank\"), .age = 22, .city = std::string(\"Hanoi\")}};\nstd::vector\u003cStatsItem\u003e stats = ([]{ std::vector\u003cStatsItem\u003e __items;\nstd::vector\u003cGGroup\u003e __groups;\nstd::unordered_map\u003cstd::string, size_t\u003e __idx;\nfor (auto person : people) {\n        auto __key = person.city;\n        auto it = __idx.find(__key);\n        if(it == __idx.end()) {\n            GGroup __g{__key, {}};\n            __g.items.push_back(person);\n            __idx[__key] = __groups.size();\n            __groups.push_back(__g);\n        } else {\n            __groups[it-\u003esecond].items.push_back(person);\n        }\n}\nfor(auto \u0026__g : __groups) {\n    GGroup g = __g;\n    __items.push_back(StatsItem{.city = g.key, .count = g.size(), .avg_age = ([\u0026]{ auto tmp = ([]{ std::vector\u003cint\u003e __items;\nfor (auto p : g) {\n        __items.push_back(p.age);\n}\nreturn __items; }()); return tmp.empty() ? 0.0 : std::accumulate(tmp.begin(), tmp.end(), 0.0) / tmp.size(); }())});\n}\nreturn __items; }());\n\nint main() {\n    std::cout \u003c\u003c std::boolalpha \u003c\u003c std::string(\"--- People grouped by city ---\") \u003c\u003c std::endl;\n    for (auto s : stats) {\n        std::cout \u003c\u003c std::boolalpha \u003c\u003c s.city \u003c\u003c ' ' \u003c\u003c std::string(\": count =\") \u003c\u003c ' ' \u003c\u003c s.count \u003c\u003c ' ' \u003c\u003c std::string(\", avg_age =\") \u003c\u003c ' ' \u003c\u003c s.avg_age \u003c\u003c std::endl;\n    }\n    return 0;\n}\n"
}