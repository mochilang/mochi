//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-11 17:26:23 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

var DIGITS string

var LOWER string

var UPPER string

func index_of(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if string(_index([]rune(s), i)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func is_digit(ch string) bool {
	return (index_of(DIGITS, ch) >= 0)
}

func to_lower(ch string) string {
	var idx int = index_of(UPPER, ch)
	_ = idx
	if idx >= 0 {
		return string([]rune(LOWER)[idx:(idx + 1)])
	}
	return ch
}

func pad_left(s string, width int) string {
	var res string = s
	_ = res
	for len(res) < width {
		res = ("0" + res)
	}
	return res
}

func alphanum_key(s string) []string {
	var key []string = []string{}
	_ = key
	var i int = 0
	_ = i
	for i < len(s) {
		if is_digit(string(_index([]rune(s), i))) {
			var num string = ""
			_ = num
			for (i < len(s)) && is_digit(string(_index([]rune(s), i))) {
				num = (num + string(_index([]rune(s), i)))
				i = (i + 1)
			}
			len_str := pad_left(fmt.Sprint(len(num)), 3)
			_ = len_str
			key = append(key, fmt.Sprint((("#" + fmt.Sprint(len_str)) + num)))
		} else {
			var seg string = ""
			_ = seg
			for i < len(s) {
				if is_digit(string(_index([]rune(s), i))) {
					break
				}
				seg = (seg + to_lower(string(_index([]rune(s), i))))
				i = (i + 1)
			}
			key = append(key, seg)
		}
	}
	return key
}

func compare_keys(a []string, b []string) int {
	var i int = 0
	_ = i
	for (i < len(a)) && (i < len(b)) {
		if _index(a, i) < _index(b, i) {
			return (0 - 1)
		}
		if _index(a, i) > _index(b, i) {
			return 1
		}
		i = (i + 1)
	}
	if len(a) < len(b) {
		return (0 - 1)
	}
	if len(a) > len(b) {
		return 1
	}
	return 0
}

func natural_sort(arr []string) []string {
	var res []string = []string{}
	_ = res
	var keys [][]string = [][]string{}
	_ = keys
	var k int = 0
	_ = k
	for k < len(arr) {
		res = append(res, _index(arr, k))
		keys = append(keys, alphanum_key(_index(arr, k)))
		k = (k + 1)
	}
	var i int = 1
	_ = i
	for i < len(res) {
		var current string = _index(res, i)
		_ = current
		var current_key []string = _index(keys, i)
		_ = current_key
		var j int = (i - 1)
		_ = j
		for (j >= 0) && (compare_keys(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(_index(keys, j)), func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(current_key)) > 0) {
			_setIndex(res, (j + 1), _index(res, j))
			_setIndex(keys, (j + 1), _index(keys, j))
			j = (j - 1)
		}
		_setIndex(res, (j + 1), current)
		_setIndex(keys, (j + 1), current_key)
		i = (i + 1)
	}
	return res
}

var example1 []string

var example2 []string

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		DIGITS = "0123456789"
		LOWER = "abcdefghijklmnopqrstuvwxyz"
		UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		example1 = []string{"2 ft 7 in", "1 ft 5 in", "10 ft 2 in", "2 ft 11 in", "7 ft 6 in"}
		fmt.Println(fmt.Sprint(natural_sort(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(example1))))
		example2 = []string{"Elm11", "Elm12", "Elm2", "elm0", "elm1", "elm10", "elm13", "elm9"}
		fmt.Println(fmt.Sprint(natural_sort(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(example2))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
