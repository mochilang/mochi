//go:build ignore

// Generated by Mochi v0.10.73 on 2025-08-25 16:50:17 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var __name__ string = "__main__"

type Edge struct {
	U int `json:"u"`
	V int `json:"v"`
	W int `json:"w"`
}

type Graph struct {
	NumNodes  int         `json:"num_nodes"`
	Edges     []Edge      `json:"edges"`
	Component map[int]int `json:"component"`
}

type UnionResult struct {
	Graph         Graph `json:"graph"`
	ComponentSize []int `json:"component_size"`
}

func new_graph(num_nodes int) Graph {
	return Graph{
		NumNodes:  num_nodes,
		Edges:     []Edge{},
		Component: map[int]int{},
	}
}

func add_edge(g Graph, u int, v int, w int) Graph {
	var es []Edge = g.Edges
	_ = es
	es = append(es, Edge{
		U: u,
		V: v,
		W: w,
	})
	return Graph{
		NumNodes:  g.NumNodes,
		Edges:     es,
		Component: g.Component,
	}
}

func find_component(g Graph, node int) int {
	if g.Component[node] == node {
		return node
	}
	return find_component(g, g.Component[node])
}

func set_component(g Graph, node int) Graph {
	if g.Component[node] != node {
		var comp map[int]int = g.Component
		if comp == nil {
			comp = map[int]int{}
		}
		_ = comp
		var k int = 0
		_ = k
		for k < g.NumNodes {
			comp[k] = find_component(g, k)
			k = (k + 1)
		}
		g = Graph{
			NumNodes:  g.NumNodes,
			Edges:     g.Edges,
			Component: comp,
		}
	}
	return g
}

func union(g Graph, component_size []int, u int, v int) UnionResult {
	var comp_size []int = component_size
	_ = comp_size
	var comp map[int]int = g.Component
	if comp == nil {
		comp = map[int]int{}
	}
	_ = comp
	if _index(comp_size, u) <= _index(comp_size, v) {
		comp[u] = v
		_setIndex(comp_size, v, (_index(comp_size, v) + _index(comp_size, u)))
		g = Graph{
			NumNodes:  g.NumNodes,
			Edges:     g.Edges,
			Component: comp,
		}
		g = set_component(g, u)
	} else {
		comp[v] = u
		_setIndex(comp_size, u, (_index(comp_size, u) + _index(comp_size, v)))
		g = Graph{
			NumNodes:  g.NumNodes,
			Edges:     g.Edges,
			Component: comp,
		}
		g = set_component(g, v)
	}
	return UnionResult{
		Graph:         g,
		ComponentSize: comp_size,
	}
}

func create_empty_edges(n int) []Edge {
	var res []Edge = []Edge{}
	_ = res
	var i int = 0
	_ = i
	for i < n {
		res = append(res, Edge{
			U: (0 - 1),
			V: (0 - 1),
			W: (0 - 1),
		})
		i = (i + 1)
	}
	return res
}

func boruvka(g *Graph) int {
	var component_size []int = []int{}
	_ = component_size
	var i int = 0
	_ = i
	for i < g.NumNodes {
		component_size = append(component_size, 1)
		var comp map[int]int = g.Component
		if comp == nil {
			comp = map[int]int{}
		}
		_ = comp
		comp[i] = i
		*g = Graph{
			NumNodes:  g.NumNodes,
			Edges:     g.Edges,
			Component: comp,
		}
		i = (i + 1)
	}
	var mst_weight int = 0
	_ = mst_weight
	var num_components int = g.NumNodes
	_ = num_components
	var minimum_weight_edge []Edge = create_empty_edges(g.NumNodes)
	_ = minimum_weight_edge
	for num_components > 1 {
		for _, e := range g.Edges {
			_ = e
			var u int = e.U
			_ = u
			var v int = e.V
			_ = v
			var w int = e.W
			_ = w
			var u_comp int = g.Component[u]
			_ = u_comp
			var v_comp int = g.Component[v]
			_ = v_comp
			if u_comp != v_comp {
				var current_u Edge = _index(minimum_weight_edge, u_comp)
				_ = current_u
				if (current_u.U == (0 - 1)) || (current_u.W > w) {
					_setIndex(minimum_weight_edge, u_comp, Edge{
						U: u,
						V: v,
						W: w,
					})
				}
				var current_v Edge = _index(minimum_weight_edge, v_comp)
				_ = current_v
				if (current_v.U == (0 - 1)) || (current_v.W > w) {
					_setIndex(minimum_weight_edge, v_comp, Edge{
						U: u,
						V: v,
						W: w,
					})
				}
			}
		}
		for _, e := range minimum_weight_edge {
			_ = e
			if e.U != (0 - 1) {
				var u int = e.U
				_ = u
				var v int = e.V
				_ = v
				var w int = e.W
				_ = w
				var u_comp int = g.Component[u]
				_ = u_comp
				var v_comp int = g.Component[v]
				_ = v_comp
				if u_comp != v_comp {
					mst_weight = (mst_weight + w)
					var res UnionResult = union(*g, func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(component_size), u_comp, v_comp)
					_ = res
					*g = res.Graph
					component_size = res.ComponentSize
					fmt.Println((((("Added edge [" + fmt.Sprint(u)) + " - ") + fmt.Sprint(v)) + "]"))
					fmt.Println(("Added weight: " + fmt.Sprint(w)))
					fmt.Println("")
					num_components = (num_components - 1)
				}
			}
		}
		minimum_weight_edge = create_empty_edges(g.NumNodes)
	}
	fmt.Println(("The total weight of the minimal spanning tree is: " + fmt.Sprint(mst_weight)))
	return mst_weight
}

func mochiMain() {
	var g Graph = new_graph(8)
	_ = g
	var edges [][]int = [][]int{[]int{0, 1, 10}, []int{0, 2, 6}, []int{0, 3, 5}, []int{1, 3, 15}, []int{2, 3, 4}, []int{3, 4, 8}, []int{4, 5, 10}, []int{4, 6, 6}, []int{4, 7, 5}, []int{5, 7, 15}, []int{6, 7, 4}}
	_ = edges
	for _, e := range edges {
		_ = e
		g = add_edge(g, _index(e, 0), _index(e, 1), _index(e, 2))
	}
	boruvka(&g)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
