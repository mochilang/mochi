//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-13 12:54:30 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

var HEURISTIC int

var grid [][]int

var delta [][]int

type Pos struct {
	Y int `json:"y"`
	X int `json:"x"`
}

type Node struct {
	Pos   Pos     `json:"pos"`
	GCost int     `json:"g_cost"`
	HCost float64 `json:"h_cost"`
	FCost float64 `json:"f_cost"`
	Path  []Pos   `json:"path"`
}

func abs(x int) int {
	if x < 0 {
		return (0 - x)
	}
	return x
}

func sqrtApprox(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = x
	_ = guess
	var i int = 0
	_ = i
	for i < 10 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func heuristic(a Pos, b Pos) float64 {
	var dy int = (a.Y - b.Y)
	_ = dy
	var dx int = (a.X - b.X)
	_ = dx
	if HEURISTIC == 1 {
		return float64((math.Abs(dy) + math.Abs(dx)))
	}
	var dyf float64 = float64(dy)
	_ = dyf
	_ = dyf
	var dxf float64 = float64(dx)
	_ = dxf
	_ = dxf
	return sqrtApprox(((dyf * dyf) + (dxf * dxf)))
}

func pos_equal(a Pos, b Pos) bool {
	return ((a.Y == b.Y) && (a.X == b.X))
}

func contains_pos(lst []Pos, p Pos) bool {
	var i int = 0
	_ = i
	for i < len(lst) {
		if pos_equal(_index(lst, i), p) {
			return true
		}
		i = (i + 1)
	}
	return false
}

func open_index_of_pos(open []Node, p Pos) int {
	var i int = 0
	_ = i
	for i < len(open) {
		if pos_equal(_index(open, i).Pos, p) {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func remove_node_at(nodes []Node, idx int) []Node {
	var res []Node = []Node{}
	_ = res
	var i int = 0
	_ = i
	for i < len(nodes) {
		if i != idx {
			res = append(res, _index(nodes, i))
		}
		i = (i + 1)
	}
	return res
}

func append_pos_list(path []Pos, p Pos) []Pos {
	var res []Pos = []Pos{}
	_ = res
	var i int = 0
	_ = i
	for i < len(path) {
		res = append(res, _index(path, i))
		i = (i + 1)
	}
	res = append(res, p)
	return res
}

func reverse_pos_list(lst []Pos) []Pos {
	var res []Pos = []Pos{}
	_ = res
	var i int = (len(lst) - 1)
	_ = i
	for i >= 0 {
		res = append(res, _index(lst, i))
		i = (i - 1)
	}
	return res
}

func concat_pos_lists(a []Pos, b []Pos) []Pos {
	var res []Pos = []Pos{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, _index(a, i))
		i = (i + 1)
	}
	var j int = 0
	_ = j
	for j < len(b) {
		res = append(res, _index(b, j))
		j = (j + 1)
	}
	return res
}

func get_successors(p Pos) []Pos {
	var res []Pos = []Pos{}
	_ = res
	var i int = 0
	_ = i
	for i < len(delta) {
		var nx int = (p.X + int(_index(_index(delta, i), 1)))
		_ = nx
		var ny int = (p.Y + int(_index(_index(delta, i), 0)))
		_ = ny
		if (((nx >= 0) && (ny >= 0)) && (nx < len(_index(grid, 0)))) && (ny < len(grid)) {
			if int(_index(_index(grid, ny), nx)) == 0 {
				res = append(res, Pos{
					Y: ny,
					X: nx,
				})
			}
		}
		i = (i + 1)
	}
	return res
}

func find_lowest_f(open []Node) int {
	var best int = 0
	_ = best
	var i int = 1
	_ = i
	for i < len(open) {
		if _index(open, i).FCost < _index(open, best).FCost {
			best = i
		}
		i = (i + 1)
	}
	return best
}

func astar(start Pos, goal Pos) []Pos {
	var h0 float64 = heuristic(start, goal)
	_ = h0
	var open []Node = []Node{Node{
		Pos:   start,
		GCost: 0,
		HCost: h0,
		FCost: h0,
		Path:  []Pos{start},
	}}
	_ = open
	var closed []Pos = []Pos{}
	_ = closed
	for len(open) > 0 {
		var idx int = find_lowest_f(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open))
		_ = idx
		var current Node = _index(open, idx)
		_ = current
		open = remove_node_at(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open), idx)
		if pos_equal(current.Pos, goal) {
			return current.Path
		}
		closed = append(closed, current.Pos)
		var succ []Pos = get_successors(current.Pos)
		_ = succ
		var i int = 0
		_ = i
		for i < len(succ) {
			var pos Pos = _index(succ, i)
			_ = pos
			if contains_pos(func(v any) []Pos {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Pos); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Pos{}
					}
					out := make([]Pos, len(arr))
					for i, x := range arr {
						out[i] = x.(Pos)
					}
					return out
				}
				return v.([]Pos)
			}(closed), pos) {
				i = (i + 1)
				continue
			}
			var tentative_g int = (current.GCost + 1)
			_ = tentative_g
			var idx_open int = open_index_of_pos(func(v any) []Node {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Node); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Node{}
					}
					out := make([]Node, len(arr))
					for i, x := range arr {
						out[i] = x.(Node)
					}
					return out
				}
				return v.([]Node)
			}(open), pos)
			_ = idx_open
			if (idx_open == (0 - 1)) || (tentative_g < _index(open, idx_open).GCost) {
				var new_path []Pos = append_pos_list(func(v any) []Pos {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]Pos); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []Pos{}
						}
						out := make([]Pos, len(arr))
						for i, x := range arr {
							out[i] = x.(Pos)
						}
						return out
					}
					return v.([]Pos)
				}(current.Path), pos)
				_ = new_path
				var h float64 = heuristic(pos, goal)
				_ = h
				var f float64 = (float64(tentative_g) + h)
				_ = f
				if idx_open != (0 - 1) {
					open = remove_node_at(func(v any) []Node {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]Node); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []Node{}
							}
							out := make([]Node, len(arr))
							for i, x := range arr {
								out[i] = x.(Node)
							}
							return out
						}
						return v.([]Node)
					}(open), idx_open)
				}
				open = append(open, Node{
					Pos:   pos,
					GCost: tentative_g,
					HCost: h,
					FCost: f,
					Path:  new_path,
				})
			}
			i = (i + 1)
		}
	}
	return []Pos{start}
}

func combine_paths(fwd Node, bwd Node) []Pos {
	var bwd_copy []Pos = []Pos{}
	_ = bwd_copy
	var i int = 0
	_ = i
	for i < (len(bwd.Path) - 1) {
		bwd_copy = append(bwd_copy, _index(bwd.Path, i))
		i = (i + 1)
	}
	bwd_copy = reverse_pos_list(func(v any) []Pos {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Pos); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Pos{}
			}
			out := make([]Pos, len(arr))
			for i, x := range arr {
				out[i] = x.(Pos)
			}
			return out
		}
		return v.([]Pos)
	}(bwd_copy))
	return concat_pos_lists(func(v any) []Pos {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Pos); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Pos{}
			}
			out := make([]Pos, len(arr))
			for i, x := range arr {
				out[i] = x.(Pos)
			}
			return out
		}
		return v.([]Pos)
	}(fwd.Path), func(v any) []Pos {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Pos); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Pos{}
			}
			out := make([]Pos, len(arr))
			for i, x := range arr {
				out[i] = x.(Pos)
			}
			return out
		}
		return v.([]Pos)
	}(bwd_copy))
}

func bidirectional_astar(start Pos, goal Pos) []Pos {
	var hf float64 = heuristic(start, goal)
	_ = hf
	var hb float64 = heuristic(goal, start)
	_ = hb
	var open_f []Node = []Node{Node{
		Pos:   start,
		GCost: 0,
		HCost: hf,
		FCost: hf,
		Path:  []Pos{start},
	}}
	_ = open_f
	var open_b []Node = []Node{Node{
		Pos:   goal,
		GCost: 0,
		HCost: hb,
		FCost: hb,
		Path:  []Pos{goal},
	}}
	_ = open_b
	var closed_f []Pos = []Pos{}
	_ = closed_f
	var closed_b []Pos = []Pos{}
	_ = closed_b
	for (len(open_f) > 0) && (len(open_b) > 0) {
		var idx_f int = find_lowest_f(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open_f))
		_ = idx_f
		var current_f Node = _index(open_f, idx_f)
		_ = current_f
		open_f = remove_node_at(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open_f), idx_f)
		var idx_b int = find_lowest_f(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open_b))
		_ = idx_b
		var current_b Node = _index(open_b, idx_b)
		_ = current_b
		open_b = remove_node_at(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open_b), idx_b)
		if pos_equal(current_f.Pos, current_b.Pos) {
			return combine_paths(current_f, current_b)
		}
		closed_f = append(closed_f, current_f.Pos)
		closed_b = append(closed_b, current_b.Pos)
		var succ_f []Pos = get_successors(current_f.Pos)
		_ = succ_f
		var i int = 0
		_ = i
		for i < len(succ_f) {
			var pos Pos = _index(succ_f, i)
			_ = pos
			if contains_pos(func(v any) []Pos {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Pos); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Pos{}
					}
					out := make([]Pos, len(arr))
					for i, x := range arr {
						out[i] = x.(Pos)
					}
					return out
				}
				return v.([]Pos)
			}(closed_f), pos) {
				i = (i + 1)
				continue
			}
			var tentative_g int = (current_f.GCost + 1)
			_ = tentative_g
			var h float64 = heuristic(pos, current_b.Pos)
			_ = h
			var f float64 = (float64(tentative_g) + h)
			_ = f
			var idx_open int = open_index_of_pos(func(v any) []Node {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Node); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Node{}
					}
					out := make([]Node, len(arr))
					for i, x := range arr {
						out[i] = x.(Node)
					}
					return out
				}
				return v.([]Node)
			}(open_f), pos)
			_ = idx_open
			if (idx_open == (0 - 1)) || (tentative_g < _index(open_f, idx_open).GCost) {
				var new_path []Pos = append_pos_list(func(v any) []Pos {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]Pos); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []Pos{}
						}
						out := make([]Pos, len(arr))
						for i, x := range arr {
							out[i] = x.(Pos)
						}
						return out
					}
					return v.([]Pos)
				}(current_f.Path), pos)
				_ = new_path
				if idx_open != (0 - 1) {
					open_f = remove_node_at(func(v any) []Node {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]Node); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []Node{}
							}
							out := make([]Node, len(arr))
							for i, x := range arr {
								out[i] = x.(Node)
							}
							return out
						}
						return v.([]Node)
					}(open_f), idx_open)
				}
				open_f = append(open_f, Node{
					Pos:   pos,
					GCost: tentative_g,
					HCost: h,
					FCost: f,
					Path:  new_path,
				})
			}
			i = (i + 1)
		}
		var succ_b []Pos = get_successors(current_b.Pos)
		_ = succ_b
		i = 0
		for i < len(succ_b) {
			var pos Pos = _index(succ_b, i)
			_ = pos
			if contains_pos(func(v any) []Pos {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Pos); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Pos{}
					}
					out := make([]Pos, len(arr))
					for i, x := range arr {
						out[i] = x.(Pos)
					}
					return out
				}
				return v.([]Pos)
			}(closed_b), pos) {
				i = (i + 1)
				continue
			}
			var tentative_g int = (current_b.GCost + 1)
			_ = tentative_g
			var h float64 = heuristic(pos, current_f.Pos)
			_ = h
			var f float64 = (float64(tentative_g) + h)
			_ = f
			var idx_open int = open_index_of_pos(func(v any) []Node {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Node); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Node{}
					}
					out := make([]Node, len(arr))
					for i, x := range arr {
						out[i] = x.(Node)
					}
					return out
				}
				return v.([]Node)
			}(open_b), pos)
			_ = idx_open
			if (idx_open == (0 - 1)) || (tentative_g < _index(open_b, idx_open).GCost) {
				var new_path []Pos = append_pos_list(func(v any) []Pos {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]Pos); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []Pos{}
						}
						out := make([]Pos, len(arr))
						for i, x := range arr {
							out[i] = x.(Pos)
						}
						return out
					}
					return v.([]Pos)
				}(current_b.Path), pos)
				_ = new_path
				if idx_open != (0 - 1) {
					open_b = remove_node_at(func(v any) []Node {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]Node); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []Node{}
							}
							out := make([]Node, len(arr))
							for i, x := range arr {
								out[i] = x.(Node)
							}
							return out
						}
						return v.([]Node)
					}(open_b), idx_open)
				}
				open_b = append(open_b, Node{
					Pos:   pos,
					GCost: tentative_g,
					HCost: h,
					FCost: f,
					Path:  new_path,
				})
			}
			i = (i + 1)
		}
	}
	return []Pos{start}
}

func path_to_string(path []Pos) string {
	if len(path) == 0 {
		return "[]"
	}
	var s string = (((("[(" + fmt.Sprint(_index(path, 0).Y)) + ", ") + fmt.Sprint(_index(path, 0).X)) + ")")
	_ = s
	var i int = 1
	_ = i
	for i < len(path) {
		s = (((((s + ", (") + fmt.Sprint(_index(path, i).Y)) + ", ") + fmt.Sprint(_index(path, i).X)) + ")")
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

var start Pos

var goal Pos

var path1 []Pos

var path2 []Pos

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		HEURISTIC = 0
		grid = [][]int{[]int{0, 0, 0, 0, 0, 0, 0}, []int{0, 1, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0, 0}, []int{0, 0, 1, 0, 0, 0, 0}, []int{1, 0, 1, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 1, 0, 0}}
		delta = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), 0}, []int{0, func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1))}, []int{1, 0}, []int{0, 1}}
		start = Pos{
			Y: 0,
			X: 0,
		}
		goal = Pos{
			Y: (len(grid) - 1),
			X: (len(_index(grid, 0)) - 1),
		}
		path1 = astar(start, goal)
		fmt.Println(path_to_string(func(v any) []Pos {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Pos); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Pos{}
				}
				out := make([]Pos, len(arr))
				for i, x := range arr {
					out[i] = x.(Pos)
				}
				return out
			}
			return v.([]Pos)
		}(path1)))
		path2 = bidirectional_astar(start, goal)
		fmt.Println(path_to_string(func(v any) []Pos {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Pos); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Pos{}
				}
				out := make([]Pos, len(arr))
				for i, x := range arr {
					out[i] = x.(Pos)
				}
				return out
			}
			return v.([]Pos)
		}(path2)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
