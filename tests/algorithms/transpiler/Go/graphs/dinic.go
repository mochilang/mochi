//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:25:22 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

var INF int

type Dinic struct {
	N   int       `json:"n"`
	Lvl []int     `json:"lvl"`
	Ptr []int     `json:"ptr"`
	Q   []int     `json:"q"`
	Adj [][][]int `json:"adj"`
}

func pow2(k int) int {
	var res int = 1
	_ = res
	var i int = 0
	_ = i
	for i < k {
		res = (res * 2)
		i = (i + 1)
	}
	return res
}

func min2(a int, b int) int {
	if a < b {
		return a
	}
	return b
}

func new_dinic(n int) Dinic {
	var lvl []int = []int{}
	_ = lvl
	var ptr []int = []int{}
	_ = ptr
	var q []int = []int{}
	_ = q
	var adj [][][]int = [][][]int{}
	_ = adj
	var i int = 0
	_ = i
	for i < n {
		lvl = append(lvl, 0)
		ptr = append(ptr, 0)
		q = append(q, 0)
		var edges [][]int = [][]int{}
		_ = edges
		adj = append(adj, edges)
		i = (i + 1)
	}
	return Dinic{
		N:   n,
		Lvl: lvl,
		Ptr: ptr,
		Q:   q,
		Adj: adj,
	}
}

func add_edge(g Dinic, a int, b int, c int, rcap int) {
	var adj [][][]int = g.Adj
	_ = adj
	var list_a [][]int = _index(adj, a)
	_ = list_a
	var list_b [][]int = _index(adj, b)
	_ = list_b
	var e1 []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(b), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(len(list_b)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(c), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}
	_ = e1
	var e2 []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(a), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(len(list_a)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(rcap), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}
	_ = e2
	list_a = append(list_a, e1)
	list_b = append(list_b, e2)
	_setIndex(adj, a, list_a)
	_setIndex(adj, b, list_b)
	g.Adj = adj
}

func dfs(g Dinic, v int, sink int, flow int) int {
	if (v == sink) || (flow == 0) {
		return flow
	}
	var ptr []int = g.Ptr
	_ = ptr
	var i int = _index(ptr, v)
	_ = i
	var adj_all [][][]int = g.Adj
	_ = adj_all
	var adj_v [][]int = _index(adj_all, v)
	_ = adj_v
	for i < len(adj_v) {
		var e []int = _index(adj_v, i)
		_ = e
		var to int = _index(e, 0)
		_ = to
		if int(_index(g.Lvl, to)) == (int(_index(g.Lvl, v)) + 1) {
			var avail int = (int(_index(e, 2)) - int(_index(e, 3)))
			_ = avail
			pushed := dfs(g, to, sink, min2(flow, avail))
			_ = pushed
			if pushed > 0 {
				_setIndex(e, 3, (int(_index(e, 3)) + pushed))
				_setIndex(adj_v, i, e)
				var adj_to [][]int = _index(adj_all, to)
				_ = adj_to
				var back []int = _index(adj_to, _index(e, 1))
				_ = back
				_setIndex(back, 3, (int(_index(back, 3)) - pushed))
				_setIndex(adj_to, _index(e, 1), back)
				_setIndex(adj_all, to, adj_to)
				_setIndex(adj_all, v, adj_v)
				g.Adj = adj_all
				return pushed
			}
		}
		i = (i + 1)
		_setIndex(ptr, v, i)
	}
	g.Ptr = ptr
	_setIndex(adj_all, v, adj_v)
	g.Adj = adj_all
	return 0
}

func max_flow(g Dinic, source int, sink int) int {
	var flow int = 0
	_ = flow
	var l int = 0
	_ = l
	for l < 31 {
		threshold := pow2((30 - l))
		_ = threshold
		for {
			var lvl []int = []int{}
			_ = lvl
			var ptr []int = []int{}
			_ = ptr
			var i int = 0
			_ = i
			for i < g.N {
				lvl = append(lvl, 0)
				ptr = append(ptr, 0)
				i = (i + 1)
			}
			g.Lvl = lvl
			g.Ptr = ptr
			var qi int = 0
			_ = qi
			var qe int = 1
			_ = qe
			_setIndex(lvl, source, 1)
			g.Lvl = lvl
			var q []int = g.Q
			_ = q
			_setIndex(q, 0, source)
			for (qi < qe) && (int(_index(g.Lvl, sink)) == 0) {
				var v int = _index(q, qi)
				_ = v
				qi = (qi + 1)
				var edges [][]int = _index(g.Adj, v)
				_ = edges
				var j int = 0
				_ = j
				for j < len(edges) {
					var e []int = _index(edges, j)
					_ = e
					var to int = _index(e, 0)
					_ = to
					var residual int = (int(_index(e, 2)) - int(_index(e, 3)))
					_ = residual
					var lvl_inner []int = g.Lvl
					_ = lvl_inner
					if (int(_index(lvl_inner, to)) == 0) && (residual >= threshold) {
						_setIndex(q, qe, to)
						qe = (qe + 1)
						_setIndex(lvl_inner, to, (int(_index(lvl_inner, v)) + 1))
						g.Lvl = lvl_inner
					}
					j = (j + 1)
				}
			}
			var p int = dfs(g, source, sink, INF)
			_ = p
			for p > 0 {
				flow = (flow + p)
				p = dfs(g, source, sink, INF)
			}
			if int(_index(g.Lvl, sink)) == 0 {
				break
			}
		}
		l = (l + 1)
	}
	return flow
}

var graph Dinic

var source int

var sink int

var v int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		INF = 1000000000
		graph = new_dinic(10)
		source = 0
		sink = 9
		v = 1
		for v < 5 {
			add_edge(graph, source, v, 1, 0)
			v = (v + 1)
		}
		v = 5
		for v < 9 {
			add_edge(graph, v, sink, 1, 0)
			v = (v + 1)
		}
		v = 1
		for v < 5 {
			add_edge(graph, v, (v + 4), 1, 0)
			v = (v + 1)
		}
		fmt.Println(fmt.Sprint(max_flow(graph, source, sink)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
