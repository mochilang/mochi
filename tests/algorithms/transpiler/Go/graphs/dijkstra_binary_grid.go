//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:25:20 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _concat[T any](a, b []T) []T {
	return append(append([]T{}, a...), b...)
}

type Point struct {
	X int `json:"x"`
	Y int `json:"y"`
}

type Result struct {
	Distance float64 `json:"distance"`
	Path     []Point `json:"path"`
}

func key(p Point) string {
	return ((fmt.Sprint(p.X) + ",") + fmt.Sprint(p.Y))
}

func path_to_string(path []Point) string {
	var s string = "["
	_ = s
	var i int = 0
	_ = i
	for i < len(path) {
		var pt Point = _index(path, i)
		_ = pt
		s = (((((s + "(") + fmt.Sprint(pt.X)) + ", ") + fmt.Sprint(pt.Y)) + ")")
		if i < (len(path) - 1) {
			s = (s + ", ")
		}
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

func dijkstra(grid [][]int, source Point, destination Point, allow_diagonal bool) Result {
	rows := len(grid)
	_ = rows
	cols := len(_index(grid, 0))
	_ = cols
	var dx []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}
	_ = dx
	var dy []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}
	_ = dy
	if allow_diagonal {
		dx = _concat(dx, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)})
		dy = _concat(dy, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)})
	}
	var INF float64 = 1000000000000.0
	_ = INF
	_ = INF
	var queue []Point = []Point{source}
	_ = queue
	var front int = 0
	_ = front
	var dist_map map[string]float64 = map[string]float64{key(source): 0.0}
	_ = dist_map
	var prev map[string]Point = map[string]Point{}
	_ = prev
	for front < len(queue) {
		var current Point = _index(queue, front)
		_ = current
		front = (front + 1)
		cur_key := key(current)
		_ = cur_key
		if (current.X == destination.X) && (current.Y == destination.Y) {
			break
		}
		var i int = 0
		_ = i
		for i < len(dx) {
			var nx int = (current.X + int(_index(dx, i)))
			_ = nx
			var ny int = (current.Y + int(_index(dy, i)))
			_ = ny
			if (((nx >= 0) && (nx < rows)) && (ny >= 0)) && (ny < cols) {
				if int(_index(_index(grid, nx), ny)) == 1 {
					var n_key string = ((fmt.Sprint(nx) + ",") + fmt.Sprint(ny))
					_ = n_key
					if !func() bool { _, ok := dist_map[n_key]; return ok }() {
						dist_map[n_key] = (dist_map[cur_key] + 1.0)
						prev[n_key] = current
						queue = append(queue, Point{
							X: nx,
							Y: ny,
						})
					}
				}
			}
			i = (i + 1)
		}
	}
	dest_key := key(destination)
	_ = dest_key
	if func() bool { _, ok := dist_map[dest_key]; return ok }() {
		var path_rev []Point = []Point{destination}
		_ = path_rev
		step_key := dest_key
		_ = step_key
		var step_pt Point = destination
		_ = step_pt
		for fmt.Sprint(step_key) != key(source) {
			step_pt = prev[step_key]
			step_key = key(step_pt)
			path_rev = append(path_rev, step_pt)
		}
		var path []Point = []Point{}
		_ = path
		var k int = (len(path_rev) - 1)
		_ = k
		for k >= 0 {
			path = append(path, _index(path_rev, k))
			k = (k - 1)
		}
		return Result{
			Distance: dist_map[dest_key],
			Path:     path,
		}
	}
	return Result{
		Distance: INF,
		Path:     []Point{},
	}
}

func print_result(res Result) {
	fmt.Println(((fmt.Sprint(res.Distance) + ", ") + path_to_string(func(v any) []Point {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Point); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Point{}
			}
			out := make([]Point, len(arr))
			for i, x := range arr {
				out[i] = x.(Point)
			}
			return out
		}
		return v.([]Point)
	}(res.Path))))
}

var grid1 [][]int

var grid2 [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		grid1 = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}}
		print_result(dijkstra(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid1), Point{
			X: 0,
			Y: 0,
		}, Point{
			X: 2,
			Y: 2,
		}, false))
		print_result(dijkstra(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid1), Point{
			X: 0,
			Y: 0,
		}, Point{
			X: 2,
			Y: 2,
		}, true))
		grid2 = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}}
		print_result(dijkstra(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid2), Point{
			X: 0,
			Y: 0,
		}, Point{
			X: 2,
			Y: 2,
		}, false))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
