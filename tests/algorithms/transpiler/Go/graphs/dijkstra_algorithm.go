//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:25:16 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Edge struct {
	Node   int `json:"node"`
	Weight int `json:"weight"`
}

func make_int_list(n int, value int) []int {
	var lst []int = []int{}
	_ = lst
	var i int = 0
	_ = i
	for i < n {
		lst = append(lst, value)
		i = (i + 1)
	}
	return lst
}

func make_bool_list(n int) []bool {
	var lst []bool = []bool{}
	_ = lst
	var i int = 0
	_ = i
	for i < n {
		lst = append(lst, false)
		i = (i + 1)
	}
	return lst
}

func dijkstra(graph [][]Edge, src int) []int {
	n := len(graph)
	_ = n
	var dist []int = make_int_list(n, 1000000000)
	_ = dist
	var visited []bool = make_bool_list(n)
	_ = visited
	_setIndex(dist, src, 0)
	var count int = 0
	_ = count
	for count < n {
		var u int = (0 - 1)
		_ = u
		var min_dist int = 1000000000
		_ = min_dist
		var i int = 0
		_ = i
		for i < n {
			if !_index(visited, i) && (int(_index(dist, i)) < min_dist) {
				min_dist = _index(dist, i)
				u = i
			}
			i = (i + 1)
		}
		if u < 0 {
			break
		}
		_setIndex(visited, u, true)
		var j int = 0
		_ = j
		for j < len(_index(graph, u)) {
			var e Edge = _index(_index(graph, u), j)
			_ = e
			var v int = e.Node
			_ = v
			var w int = e.Weight
			_ = w
			if !_index(visited, v) {
				var new_dist int = (int(_index(dist, u)) + w)
				_ = new_dist
				if new_dist < int(_index(dist, v)) {
					_setIndex(dist, v, new_dist)
				}
			}
			j = (j + 1)
		}
		count = (count + 1)
	}
	return dist
}

var graph [][]Edge

var dist []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		graph = [][]Edge{[]Edge{Edge{
			Node:   1,
			Weight: 10,
		}, Edge{
			Node:   3,
			Weight: 5,
		}}, []Edge{Edge{
			Node:   2,
			Weight: 1,
		}, Edge{
			Node:   3,
			Weight: 2,
		}}, []Edge{Edge{
			Node:   4,
			Weight: 4,
		}}, []Edge{Edge{
			Node:   1,
			Weight: 3,
		}, Edge{
			Node:   2,
			Weight: 9,
		}, Edge{
			Node:   4,
			Weight: 2,
		}}, []Edge{Edge{
			Node:   0,
			Weight: 7,
		}, Edge{
			Node:   2,
			Weight: 6,
		}}}
		dist = dijkstra(func(v any) [][]Edge {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]Edge); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]Edge{}
				}
				out := make([][]Edge, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []Edge {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]Edge); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []Edge{}
							}
							out := make([]Edge, len(arr))
							for i, x := range arr {
								out[i] = x.(Edge)
							}
							return out
						}
						return v.([]Edge)
					}(x)
				}
				return out
			}
			return v.([][]Edge)
		}(graph), 0)
		fmt.Println(fmt.Sprint(_index(dist, 0)))
		fmt.Println(fmt.Sprint(_index(dist, 1)))
		fmt.Println(fmt.Sprint(_index(dist, 2)))
		fmt.Println(fmt.Sprint(_index(dist, 3)))
		fmt.Println(fmt.Sprint(_index(dist, 4)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
