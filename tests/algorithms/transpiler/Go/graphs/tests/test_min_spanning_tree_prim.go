//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 15:32:57 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

type Neighbor struct {
	Node int `json:"node"`
	Cost int `json:"cost"`
}

type EdgePair struct {
	U int `json:"u"`
	V int `json:"v"`
}

func prims_algorithm(adjacency map[int][]Neighbor) []EdgePair {
	var visited map[int]bool = map[int]bool{}
	_ = visited
	visited[0] = true
	var mst []EdgePair = []EdgePair{}
	_ = mst
	var count int = 1
	_ = count
	var total int = 0
	_ = total
	for _, k := range func() []int {
		keys := make([]int, 0, len(adjacency))
		for k := range adjacency {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		_ = k
		total = (total + 1)
	}
	for count < total {
		var best_u int = 0
		_ = best_u
		var best_v int = 0
		_ = best_v
		var best_cost int = 2147483647
		_ = best_cost
		for _, u_str := range func() []int {
			keys := make([]int, 0, len(adjacency))
			for k := range adjacency {
				keys = append(keys, k)
			}
			sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
			return keys
		}() {
			_ = u_str
			var u int = int(u_str)
			_ = u
			if visited[u] {
				for _, n := range adjacency[u] {
					_ = n
					if !visited[n.Node] && (n.Cost < best_cost) {
						best_cost = n.Cost
						best_u = u
						best_v = n.Node
					}
				}
			}
		}
		visited[best_v] = true
		mst = append(mst, EdgePair{
			U: best_u,
			V: best_v,
		})
		count = (count + 1)
	}
	return mst
}

func test_prim_successful_result() bool {
	var edges [][]int = [][]int{[]int{0, 1, 4}, []int{0, 7, 8}, []int{1, 2, 8}, []int{7, 8, 7}, []int{7, 6, 1}, []int{2, 8, 2}, []int{8, 6, 6}, []int{2, 3, 7}, []int{2, 5, 4}, []int{6, 5, 2}, []int{3, 5, 14}, []int{3, 4, 9}, []int{5, 4, 10}, []int{1, 7, 11}}
	_ = edges
	var adjacency map[int][]Neighbor = map[int][]Neighbor{}
	_ = adjacency
	for _, e := range edges {
		_ = e
		var u int = _index(e, 0)
		_ = u
		var v int = _index(e, 1)
		_ = v
		var w int = _index(e, 2)
		_ = w
		if !func() bool { _, ok := adjacency[u]; return ok }() {
			adjacency[u] = []Neighbor{}
		}
		if !func() bool { _, ok := adjacency[v]; return ok }() {
			adjacency[v] = []Neighbor{}
		}
		adjacency[u] = append(adjacency[u], Neighbor{
			Node: v,
			Cost: w,
		})
		adjacency[v] = append(adjacency[v], Neighbor{
			Node: u,
			Cost: w,
		})
	}
	var result []EdgePair = prims_algorithm(adjacency)
	_ = result
	var seen map[string]bool = map[string]bool{}
	_ = seen
	for _, e := range result {
		_ = e
		var key1 string = ((fmt.Sprint(e.U) + ",") + fmt.Sprint(e.V))
		_ = key1
		var key2 string = ((fmt.Sprint(e.V) + ",") + fmt.Sprint(e.U))
		_ = key2
		seen[key1] = true
		seen[key2] = true
	}
	var expected [][]int = [][]int{[]int{7, 6, 1}, []int{2, 8, 2}, []int{6, 5, 2}, []int{0, 1, 4}, []int{2, 5, 4}, []int{2, 3, 7}, []int{0, 7, 8}, []int{3, 4, 9}}
	_ = expected
	for _, ans := range expected {
		_ = ans
		var key string = ((fmt.Sprint(_index(ans, 0)) + ",") + fmt.Sprint(_index(ans, 1)))
		_ = key
		if !seen[key] {
			return false
		}
	}
	return true
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		fmt.Println(test_prim_successful_result())
		fmt.Println(true)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
