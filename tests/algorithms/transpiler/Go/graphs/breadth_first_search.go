//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:24:54 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func add_edge(graph map[int][]int, from int, to int) {
	if func() bool { _, ok := graph[from]; return ok }() {
		graph[from] = append(graph[from], to)
	} else {
		graph[from] = []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(to)}
	}
}

func print_graph(graph map[int][]int) {
	for _, v := range func() []int {
		keys := make([]int, 0, len(graph))
		for kx := range graph {
			keys = append(keys, kx)
		}
		sort.Ints(keys)
		return keys
	}() {
		var adj []int = graph[v]
		_ = adj
		var line string = (fmt.Sprint(v) + "  :  ")
		_ = line
		var i int = 0
		_ = i
		for i < len(adj) {
			line = (line + fmt.Sprint(_index(adj, i)))
			if i < (len(adj) - 1) {
				line = (line + " -> ")
			}
			i = (i + 1)
		}
		fmt.Println(line)
	}
}

func bfs(graph map[int][]int, start int) []int {
	var visited map[int]bool = map[int]bool{}
	_ = visited
	var queue []int = []int{}
	_ = queue
	var order []int = []int{}
	_ = order
	queue = append(queue, start)
	visited[start] = true
	var head int = 0
	_ = head
	for head < len(queue) {
		var vertex int = _index(queue, head)
		_ = vertex
		head = (head + 1)
		order = append(order, vertex)
		var neighbors []int = graph[vertex]
		_ = neighbors
		var i int = 0
		_ = i
		for i < len(neighbors) {
			var neighbor int = _index(neighbors, i)
			_ = neighbor
			if !func() bool { _, ok := visited[neighbor]; return ok }() {
				visited[neighbor] = true
				queue = append(queue, neighbor)
			}
			i = (i + 1)
		}
	}
	return order
}

var g map[int][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		g = map[int][]int{}
		add_edge(g, 0, 1)
		add_edge(g, 0, 2)
		add_edge(g, 1, 2)
		add_edge(g, 2, 0)
		add_edge(g, 2, 3)
		add_edge(g, 3, 3)
		print_graph(g)
		fmt.Println(func() string {
			b, _ := json.Marshal(bfs(g, 2))
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
