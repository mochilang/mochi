//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-13 12:54:24 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func dfs(g map[int][]int, s int) {
	var visited map[int]bool = map[int]bool{}
	_ = visited
	var stack []int = []int{}
	_ = stack
	visited[s] = true
	stack = append(stack, s)
	fmt.Println(s)
	for len(stack) > 0 {
		var u int = _index(stack, (len(stack) - 1))
		_ = u
		var found bool = false
		_ = found
		for _, v := range g[u] {
			if !func() bool { _, ok := visited[v]; return ok }() {
				visited[v] = true
				stack = append(stack, v)
				fmt.Println(v)
				found = true
				break
			}
		}
		if !found {
			stack = _slice(stack, 0, (len(stack) - 1))
		}
	}
}

func bfs(g map[int][]int, s int) {
	var visited map[int]bool = map[int]bool{}
	_ = visited
	var q []int = []int{}
	_ = q
	visited[s] = true
	q = append(q, s)
	fmt.Println(s)
	for len(q) > 0 {
		var u int = _index(q, 0)
		_ = u
		q = _slice(q, 1, len(q))
		for _, v := range g[u] {
			if !func() bool { _, ok := visited[v]; return ok }() {
				visited[v] = true
				q = append(q, v)
				fmt.Println(v)
			}
		}
	}
}

func sort_ints(a []int) []int {
	var arr []int = a
	_ = arr
	var i int = 0
	_ = i
	for i < len(arr) {
		var j int = 0
		_ = j
		for j < ((len(arr) - i) - 1) {
			if int(_index(arr, j)) > int(_index(arr, (j+1))) {
				var tmp int = _index(arr, j)
				_ = tmp
				_setIndex(arr, j, _index(arr, (j+1)))
				_setIndex(arr, (j + 1), tmp)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return arr
}

func dijkstra(g map[int][][]int, s int) {
	var dist map[int]int = map[int]int{}
	_ = dist
	dist[s] = 0
	var path map[int]int = map[int]int{}
	_ = path
	path[s] = 0
	var known []int = []int{}
	_ = known
	var keys []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(s)}
	_ = keys
	for len(known) < len(keys) {
		var mini int = 100000
		_ = mini
		var u int = (0 - 1)
		_ = u
		var i int = 0
		_ = i
		for i < len(keys) {
			var k int = _index(keys, i)
			_ = k
			var d int = dist[k]
			_ = d
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := k
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == k {
							return true
						}
					}
				}
				return false
			}() && (d < mini) {
				mini = d
				u = k
			}
			i = (i + 1)
		}
		known = append(known, u)
		for _, e := range g[u] {
			var v int = _index(e, 0)
			_ = v
			var w int = _index(e, 1)
			_ = w
			if !func() bool {
				v := reflect.ValueOf(keys)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() {
				keys = append(keys, v)
			}
			var alt int = (int(dist[u]) + w)
			_ = alt
			var cur int = func() int {
				if func() bool { _, ok := dist[v]; return ok }() {
					return dist[v]
				} else {
					return 100000
				}
			}()
			_ = cur
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() && (alt < cur) {
				dist[v] = alt
				path[v] = u
			}
		}
	}
	var ordered []int = sort_ints(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(keys))
	_ = ordered
	var idx int = 0
	_ = idx
	for idx < len(ordered) {
		var k int = _index(ordered, idx)
		_ = k
		if k != s {
			fmt.Println(dist[k])
		}
		idx = (idx + 1)
	}
}

func topo(g map[int][]int, n int) {
	var ind []int = []int{}
	_ = ind
	var i int = 0
	_ = i
	for i <= n {
		ind = append(ind, 0)
		i = (i + 1)
	}
	var node int = 1
	_ = node
	for node <= n {
		for _, v := range g[node] {
			_setIndex(ind, v, (int(_index(ind, v)) + 1))
		}
		node = (node + 1)
	}
	var q []int = []int{}
	_ = q
	var j int = 1
	_ = j
	for j <= n {
		if int(_index(ind, j)) == 0 {
			q = append(q, j)
		}
		j = (j + 1)
	}
	for len(q) > 0 {
		var v int = _index(q, 0)
		_ = v
		q = _slice(q, 1, len(q))
		fmt.Println(v)
		for _, w := range g[v] {
			_setIndex(ind, w, (int(_index(ind, w)) - 1))
			if int(_index(ind, w)) == 0 {
				q = append(q, w)
			}
		}
	}
}

func floyd(a [][]int) {
	var n int = len(a)
	_ = n
	var dist [][]int = [][]int{}
	_ = dist
	var i int = 0
	_ = i
	for i < n {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			row = append(row, _index(_index(a, i), j))
			j = (j + 1)
		}
		dist = append(dist, row)
		i = (i + 1)
	}
	var k int = 0
	_ = k
	for k < n {
		var ii int = 0
		_ = ii
		for ii < n {
			var jj int = 0
			_ = jj
			for jj < n {
				if int(_index(_index(dist, ii), jj)) > (int(_index(_index(dist, ii), k)) + int(_index(_index(dist, k), jj))) {
					_setIndex(_index(dist, ii), jj, (int(_index(_index(dist, ii), k)) + int(_index(_index(dist, k), jj))))
				}
				jj = (jj + 1)
			}
			ii = (ii + 1)
		}
		k = (k + 1)
	}
	fmt.Println(func() string {
		b, _ := json.Marshal(dist)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
}

func prim(g map[int][][]int, s int, n int) int {
	var dist map[int]int = map[int]int{}
	_ = dist
	dist[s] = 0
	var known []int = []int{}
	_ = known
	var keys []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(s)}
	_ = keys
	var total int = 0
	_ = total
	for len(known) < n {
		var mini int = 100000
		_ = mini
		var u int = (0 - 1)
		_ = u
		var i int = 0
		_ = i
		for i < len(keys) {
			var k int = _index(keys, i)
			_ = k
			var d int = dist[k]
			_ = d
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := k
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == k {
							return true
						}
					}
				}
				return false
			}() && (d < mini) {
				mini = d
				u = k
			}
			i = (i + 1)
		}
		known = append(known, u)
		total = (total + mini)
		for _, e := range g[u] {
			var v int = _index(e, 0)
			_ = v
			var w int = _index(e, 1)
			_ = w
			if !func() bool {
				v := reflect.ValueOf(keys)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() {
				keys = append(keys, v)
			}
			var cur int = func() int {
				if func() bool { _, ok := dist[v]; return ok }() {
					return dist[v]
				} else {
					return 100000
				}
			}()
			_ = cur
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() && (w < cur) {
				dist[v] = w
			}
		}
	}
	return total
}

func sort_edges(edges [][]int) [][]int {
	var es [][]int = edges
	_ = es
	var i int = 0
	_ = i
	for i < len(es) {
		var j int = 0
		_ = j
		for j < ((len(es) - i) - 1) {
			if int(_index(_index(es, j), 2)) > int(_index(_index(es, (j+1)), 2)) {
				var tmp []int = _index(es, j)
				_ = tmp
				_setIndex(es, j, _index(es, (j+1)))
				_setIndex(es, (j + 1), tmp)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return es
}

func find_parent(parent []int, x int) int {
	var r int = x
	_ = r
	for int(_index(parent, r)) != r {
		r = _index(parent, r)
	}
	return r
}

func union_parent(parent []int, a int, b int) {
	_setIndex(parent, a, b)
}

func kruskal(edges [][]int, n int) int {
	var es [][]int = sort_edges(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(edges))
	_ = es
	var parent []int = []int{}
	_ = parent
	var i int = 0
	_ = i
	for i <= n {
		parent = append(parent, i)
		i = (i + 1)
	}
	var total int = 0
	_ = total
	var count int = 0
	_ = count
	var idx int = 0
	_ = idx
	for (count < (n - 1)) && (idx < len(es)) {
		var e []int = _index(es, idx)
		_ = e
		idx = (idx + 1)
		var u int = _index(e, 0)
		_ = u
		var v int = _index(e, 1)
		_ = v
		var w int = _index(e, 2)
		_ = w
		var ru int = find_parent(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(parent), u)
		_ = ru
		var rv int = find_parent(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(parent), v)
		_ = rv
		if ru != rv {
			union_parent(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(parent), ru, rv)
			total = (total + w)
			count = (count + 1)
		}
	}
	return total
}

func find_isolated_nodes(g map[int][]int, nodes []int) []int {
	var isolated []int = []int{}
	_ = isolated
	for _, node := range nodes {
		if len(g[node]) == 0 {
			isolated = append(isolated, node)
		}
	}
	return isolated
}

var g_dfs map[int][]int

var g_bfs map[int][]int

var g_weighted map[int][][]int

var g_topo map[int][]int

var matrix [][]int

var g_prim map[int][][]int

var edges_kruskal [][]int

var g_iso map[int][]int

var iso []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		g_dfs = map[int][]int{1: []int{2, 3}, 2: []int{4, 5}, 3: []int{}, 4: []int{}, 5: []int{}}
		g_bfs = map[int][]int{1: []int{2, 3}, 2: []int{4, 5}, 3: []int{6, 7}, 4: []int{}, 5: []int{8}, 6: []int{}, 7: []int{}, 8: []int{}}
		g_weighted = map[int][][]int{1: [][]int{[]int{2, 7}, []int{3, 9}, []int{6, 14}}, 2: [][]int{[]int{1, 7}, []int{3, 10}, []int{4, 15}}, 3: [][]int{[]int{1, 9}, []int{2, 10}, []int{4, 11}, []int{6, 2}}, 4: [][]int{[]int{2, 15}, []int{3, 11}, []int{5, 6}}, 5: [][]int{[]int{4, 6}, []int{6, 9}}, 6: [][]int{[]int{1, 14}, []int{3, 2}, []int{5, 9}}}
		g_topo = map[int][]int{1: []int{2, 3}, 2: []int{4}, 3: []int{4}, 4: []int{}}
		matrix = [][]int{[]int{0, 5, 9, 100000}, []int{100000, 0, 2, 8}, []int{100000, 100000, 0, 7}, []int{4, 100000, 100000, 0}}
		g_prim = map[int][][]int{1: [][]int{[]int{2, 1}, []int{3, 3}}, 2: [][]int{[]int{1, 1}, []int{3, 1}, []int{4, 6}}, 3: [][]int{[]int{1, 3}, []int{2, 1}, []int{4, 2}}, 4: [][]int{[]int{2, 6}, []int{3, 2}}}
		edges_kruskal = [][]int{[]int{1, 2, 1}, []int{2, 3, 2}, []int{1, 3, 2}, []int{3, 4, 1}}
		g_iso = map[int][]int{1: []int{2, 3}, 2: []int{1, 3}, 3: []int{1, 2}, 4: []int{}}
		dfs(g_dfs, 1)
		bfs(g_bfs, 1)
		dijkstra(g_weighted, 1)
		topo(g_topo, 4)
		floyd(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(matrix))
		fmt.Println(prim(g_prim, 1, 4))
		fmt.Println(kruskal(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(edges_kruskal), 4))
		iso = find_isolated_nodes(g_iso, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 2, 3, 4}))
		fmt.Println(func() string {
			b, _ := json.Marshal(iso)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
