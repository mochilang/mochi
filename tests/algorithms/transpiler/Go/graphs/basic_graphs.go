//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:24:43 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

func dfs(g map[int][]int, s int) {
	var visited map[int]bool = map[int]bool{}
	_ = visited
	var stack []int = []int{}
	_ = stack
	visited[s] = true
	stack = append(stack, s)
	fmt.Println(s)
	for len(stack) > 0 {
		var u int = _index(stack, (len(stack) - 1))
		_ = u
		var found bool = false
		_ = found
		for _, v := range g[u] {
			if !func() bool { _, ok := visited[v]; return ok }() {
				visited[v] = true
				stack = append(stack, v)
				fmt.Println(v)
				found = true
				break
			}
		}
		if !found {
			stack = _slice(stack, 0, (len(stack) - 1))
		}
	}
}

func bfs(g map[int][]int, s int) {
	var visited map[int]bool = map[int]bool{}
	_ = visited
	var q []int = []int{}
	_ = q
	visited[s] = true
	q = append(q, s)
	fmt.Println(s)
	for len(q) > 0 {
		var u int = _index(q, 0)
		_ = u
		q = _slice(q, 1, len(q))
		for _, v := range g[u] {
			if !func() bool { _, ok := visited[v]; return ok }() {
				visited[v] = true
				q = append(q, v)
				fmt.Println(v)
			}
		}
	}
}

func sort_ints(a []int) []int {
	var arr []int = a
	_ = arr
	var i int = 0
	_ = i
	for i < len(arr) {
		var j int = 0
		_ = j
		for j < ((len(arr) - i) - 1) {
			if int(_index(arr, j)) > int(_index(arr, (j+1))) {
				var tmp int = _index(arr, j)
				_ = tmp
				_setIndex(arr, j, _index(arr, (j+1)))
				_setIndex(arr, (j + 1), tmp)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return arr
}

func dijkstra(g map[int][][]int, s int) {
	var dist map[int]int = map[int]int{}
	_ = dist
	dist[s] = 0
	var path map[int]int = map[int]int{}
	_ = path
	path[s] = 0
	var known []int = []int{}
	_ = known
	var keys []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(s)}
	_ = keys
	for len(known) < len(keys) {
		var mini int = 100000
		_ = mini
		var u int = (0 - 1)
		_ = u
		var i int = 0
		_ = i
		for i < len(keys) {
			var k int = _index(keys, i)
			_ = k
			var d int = dist[k]
			_ = d
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := k
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == k {
							return true
						}
					}
				}
				return false
			}() && (d < mini) {
				mini = d
				u = k
			}
			i = (i + 1)
		}
		known = append(known, u)
		for _, e := range g[u] {
			var v int = _index(e, 0)
			_ = v
			var w int = _index(e, 1)
			_ = w
			if !func() bool {
				v := reflect.ValueOf(keys)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() {
				keys = append(keys, v)
			}
			var alt int = (int(dist[u]) + w)
			_ = alt
			cur := func() int {
				if func() bool { _, ok := dist[v]; return ok }() {
					return dist[v]
				} else {
					return 100000
				}
			}()
			_ = cur
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() && (alt < cur) {
				dist[v] = alt
				path[v] = u
			}
		}
	}
	ordered := sort_ints(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(keys))
	_ = ordered
	var idx int = 0
	_ = idx
	for idx < _len(ordered) {
		k := _index(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(ordered), idx)
		_ = k
		if k != s {
			fmt.Println(dist[k])
		}
		idx = (idx + 1)
	}
}

func topo(g map[int][]int, n int) {
	var ind []int = []int{}
	_ = ind
	var i int = 0
	_ = i
	for i <= n {
		ind = append(ind, 0)
		i = (i + 1)
	}
	var node int = 1
	_ = node
	for node <= n {
		for _, v := range g[node] {
			_setIndex(ind, v, (int(_index(ind, v)) + 1))
		}
		node = (node + 1)
	}
	var q []int = []int{}
	_ = q
	var j int = 1
	_ = j
	for j <= n {
		if int(_index(ind, j)) == 0 {
			q = append(q, j)
		}
		j = (j + 1)
	}
	for len(q) > 0 {
		var v int = _index(q, 0)
		_ = v
		q = _slice(q, 1, len(q))
		fmt.Println(v)
		for _, w := range g[v] {
			_setIndex(ind, w, (int(_index(ind, w)) - 1))
			if int(_index(ind, w)) == 0 {
				q = append(q, w)
			}
		}
	}
}

func floyd(a [][]int) {
	n := len(a)
	_ = n
	var dist [][]int = [][]int{}
	_ = dist
	var i int = 0
	_ = i
	for i < n {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			row = append(row, _index(_index(a, i), j))
			j = (j + 1)
		}
		dist = append(dist, row)
		i = (i + 1)
	}
	var k int = 0
	_ = k
	for k < n {
		var ii int = 0
		_ = ii
		for ii < n {
			var jj int = 0
			_ = jj
			for jj < n {
				if int(_index(_index(dist, ii), jj)) > (int(_index(_index(dist, ii), k)) + int(_index(_index(dist, k), jj))) {
					_setIndex(_index(dist, ii), jj, (int(_index(_index(dist, ii), k)) + int(_index(_index(dist, k), jj))))
				}
				jj = (jj + 1)
			}
			ii = (ii + 1)
		}
		k = (k + 1)
	}
	fmt.Println(func() string {
		b, _ := json.Marshal(dist)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
}

func prim(g map[int][][]int, s int, n int) int {
	var dist map[int]int = map[int]int{}
	_ = dist
	dist[s] = 0
	var known []int = []int{}
	_ = known
	var keys []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(s)}
	_ = keys
	var total int = 0
	_ = total
	for len(known) < n {
		var mini int = 100000
		_ = mini
		var u int = (0 - 1)
		_ = u
		var i int = 0
		_ = i
		for i < len(keys) {
			var k int = _index(keys, i)
			_ = k
			var d int = dist[k]
			_ = d
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := k
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == k {
							return true
						}
					}
				}
				return false
			}() && (d < mini) {
				mini = d
				u = k
			}
			i = (i + 1)
		}
		known = append(known, u)
		total = (total + mini)
		for _, e := range g[u] {
			var v int = _index(e, 0)
			_ = v
			var w int = _index(e, 1)
			_ = w
			if !func() bool {
				v := reflect.ValueOf(keys)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() {
				keys = append(keys, v)
			}
			cur := func() int {
				if func() bool { _, ok := dist[v]; return ok }() {
					return dist[v]
				} else {
					return 100000
				}
			}()
			_ = cur
			if !func() bool {
				v := reflect.ValueOf(known)
				if v.Kind() == reflect.Map {
					key := v
					return v.MapIndex(reflect.ValueOf(key)).IsValid()
				}
				if v.Kind() == reflect.Slice || v.Kind() == reflect.Array {
					for i := 0; i < v.Len(); i++ {
						if v.Index(i).Interface() == v {
							return true
						}
					}
				}
				return false
			}() && (w < cur) {
				dist[v] = w
			}
		}
	}
	return total
}

func sort_edges(edges [][]int) [][]int {
	var es [][]int = edges
	_ = es
	var i int = 0
	_ = i
	for i < len(es) {
		var j int = 0
		_ = j
		for j < ((len(es) - i) - 1) {
			if int(_index(_index(es, j), 2)) > int(_index(_index(es, (j+1)), 2)) {
				var tmp []int = _index(es, j)
				_ = tmp
				_setIndex(es, j, _index(es, (j+1)))
				_setIndex(es, (j + 1), tmp)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return es
}

func find_parent(parent []int, x int) int {
	var r int = x
	_ = r
	for int(_index(parent, r)) != r {
		r = _index(parent, r)
	}
	return r
}

func union_parent(parent []int, a int, b int) {
	_setIndex(parent, a, b)
}

func kruskal(edges [][]int, n int) int {
	var es [][]int = sort_edges(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(edges))
	_ = es
	var parent []int = []int{}
	_ = parent
	var i int = 0
	_ = i
	for i <= n {
		parent = append(parent, i)
		i = (i + 1)
	}
	var total int = 0
	_ = total
	var count int = 0
	_ = count
	var idx int = 0
	_ = idx
	for (count < (n - 1)) && (idx < len(es)) {
		var e []int = _index(es, idx)
		_ = e
		idx = (idx + 1)
		var u int = _index(e, 0)
		_ = u
		var v int = _index(e, 1)
		_ = v
		var w int = _index(e, 2)
		_ = w
		ru := find_parent(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(parent), u)
		_ = ru
		rv := find_parent(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(parent), v)
		_ = rv
		if _toFloat(ru) != _toFloat(rv) {
			union_parent(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(parent), ru, rv)
			total = (total + w)
			count = (count + 1)
		}
	}
	return total
}

func find_isolated_nodes(g map[int][]int, nodes []int) []int {
	var isolated []int = []int{}
	_ = isolated
	for _, node := range nodes {
		if len(g[node]) == 0 {
			isolated = append(isolated, node)
		}
	}
	return isolated
}

var g_dfs map[int][]int

var g_bfs map[int][]int

var g_weighted map[int][][]int

var g_topo map[int][]int

var matrix [][]int

var g_prim map[int][][]int

var edges_kruskal [][]int

var g_iso map[int][]int

var iso []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		g_dfs = map[int][]int{1: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}, 2: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(5)}, 3: []int{}, 4: []int{}, 5: []int{}}
		g_bfs = map[int][]int{1: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}, 2: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(5)}, 3: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(7)}, 4: []int{}, 5: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(8)}, 6: []int{}, 7: []int{}, 8: []int{}}
		g_weighted = map[int][][]int{1: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(7)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(9)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(14)}}, 2: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(7)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(10)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(15)}}, 3: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(9)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(10)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(11)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}}, 4: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(15)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(11)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(5), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6)}}, 5: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(9)}}, 6: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(14)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(5), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(9)}}}
		g_topo = map[int][]int{1: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}, 2: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4)}, 3: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4)}, 4: []int{}}
		matrix = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(5), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(9), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(100000)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(100000), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(8)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(100000), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(100000), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(7)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(100000), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(100000), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}}
		g_prim = map[int][][]int{1: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}}, 2: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6)}}, 3: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}}, 4: [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(6)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}}}
		edges_kruskal = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}}
		g_iso = map[int][]int{1: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}, 2: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3)}, 3: []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)}, 4: []int{}}
		dfs(g_dfs, 1)
		bfs(g_bfs, 1)
		dijkstra(g_weighted, 1)
		topo(g_topo, 4)
		floyd(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(matrix))
		fmt.Println(prim(g_prim, 1, 4))
		fmt.Println(kruskal(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(edges_kruskal), 4))
		iso = find_isolated_nodes(g_iso, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4)}))
		fmt.Println(func() string {
			b, _ := json.Marshal(iso)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
