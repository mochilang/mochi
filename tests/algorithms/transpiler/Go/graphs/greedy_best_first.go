//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 15:32:48 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type Pos struct {
	Y int `json:"y"`
	X int `json:"x"`
}

type Node struct {
	PosX  int   `json:"pos_x"`
	PosY  int   `json:"pos_y"`
	GoalX int   `json:"goal_x"`
	GoalY int   `json:"goal_y"`
	GCost int   `json:"g_cost"`
	FCost int   `json:"f_cost"`
	Path  []Pos `json:"path"`
}

func abs(x int) int {
	if x < 0 {
		return (0 - x)
	}
	return x
}

func manhattan(x1 int, y1 int, x2 int, y2 int) int {
	return (abs((x1 - x2)) + abs((y1 - y2)))
}

func clone_path(p []Pos) []Pos {
	var res []Pos = []Pos{}
	_ = res
	var i int = 0
	_ = i
	for i < len(p) {
		res = append(res, _index(p, i))
		i = (i + 1)
	}
	return res
}

func make_node(pos_x int, pos_y int, goal_x int, goal_y int, g_cost int, path []Pos) Node {
	var f int = manhattan(pos_x, pos_y, goal_x, goal_y)
	_ = f
	_ = f
	return Node{
		PosX:  pos_x,
		PosY:  pos_y,
		GoalX: goal_x,
		GoalY: goal_y,
		GCost: g_cost,
		FCost: f,
		Path:  path,
	}
}

var delta []Pos

func node_equal(a Node, b Node) bool {
	return ((a.PosX == b.PosX) && (a.PosY == b.PosY))
}

func contains(nodes []Node, node Node) bool {
	var i int = 0
	_ = i
	for i < len(nodes) {
		if node_equal(_index(nodes, i), node) {
			return true
		}
		i = (i + 1)
	}
	return false
}

func sort_nodes(nodes []Node) []Node {
	var arr []Node = nodes
	_ = arr
	var i int = 1
	_ = i
	for i < len(arr) {
		var key_node Node = _index(arr, i)
		_ = key_node
		var j int = (i - 1)
		_ = j
		for j >= 0 {
			var temp Node = _index(arr, j)
			_ = temp
			if temp.FCost > key_node.FCost {
				_setIndex(arr, (j + 1), temp)
				j = (j - 1)
			} else {
				break
			}
		}
		_setIndex(arr, (j + 1), key_node)
		i = (i + 1)
	}
	return arr
}

func get_successors(grid [][]int, parent Node, target Pos) []Node {
	var res []Node = []Node{}
	_ = res
	var i int = 0
	_ = i
	for i < len(delta) {
		var d Pos = _index(delta, i)
		_ = d
		var pos_x int = (parent.PosX + d.X)
		_ = pos_x
		var pos_y int = (parent.PosY + d.Y)
		_ = pos_y
		if ((((pos_x >= 0) && (pos_x < len(_index(grid, 0)))) && (pos_y >= 0)) && (pos_y < len(grid))) && (_index(_index(grid, pos_y), pos_x) == 0) {
			var new_path []Pos = clone_path(func(v any) []Pos {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Pos); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Pos{}
					}
					out := make([]Pos, len(arr))
					for i, x := range arr {
						out[i] = x.(Pos)
					}
					return out
				}
				return v.([]Pos)
			}(parent.Path))
			_ = new_path
			new_path = append(new_path, Pos{
				Y: pos_y,
				X: pos_x,
			})
			res = append(res, make_node(pos_x, pos_y, target.X, target.Y, (parent.GCost+1), func(v any) []Pos {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Pos); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Pos{}
					}
					out := make([]Pos, len(arr))
					for i, x := range arr {
						out[i] = x.(Pos)
					}
					return out
				}
				return v.([]Pos)
			}(new_path)))
		}
		i = (i + 1)
	}
	return res
}

func greedy_best_first(grid [][]int, init Pos, goal Pos) []Pos {
	var start_path []Pos = []Pos{init}
	_ = start_path
	var start Node = make_node(init.X, init.Y, goal.X, goal.Y, 0, func(v any) []Pos {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Pos); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Pos{}
			}
			out := make([]Pos, len(arr))
			for i, x := range arr {
				out[i] = x.(Pos)
			}
			return out
		}
		return v.([]Pos)
	}(start_path))
	_ = start
	var open_nodes []Node = []Node{start}
	_ = open_nodes
	var closed_nodes []Node = []Node{}
	_ = closed_nodes
	for len(open_nodes) > 0 {
		open_nodes = sort_nodes(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(open_nodes))
		var current Node = _index(open_nodes, 0)
		_ = current
		var new_open []Node = []Node{}
		_ = new_open
		var idx int = 1
		_ = idx
		for idx < len(open_nodes) {
			new_open = append(new_open, _index(open_nodes, idx))
			idx = (idx + 1)
		}
		open_nodes = new_open
		if (current.PosX == goal.X) && (current.PosY == goal.Y) {
			return current.Path
		}
		closed_nodes = append(closed_nodes, current)
		var successors []Node = get_successors(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid), current, goal)
		_ = successors
		var i int = 0
		_ = i
		for i < len(successors) {
			var child Node = _index(successors, i)
			_ = child
			if !contains(closed_nodes, child) && !contains(open_nodes, child) {
				open_nodes = append(open_nodes, child)
			}
			i = (i + 1)
		}
	}
	var r []Pos = []Pos{init}
	_ = r
	_ = r
	return r
}

var TEST_GRIDS [][][]int

func print_grid(grid [][]int) {
	var i int = 0
	_ = i
	for i < len(grid) {
		fmt.Println(fmt.Sprint(_index(grid, i)))
		i = (i + 1)
	}
}

func mochiMain() {
	var idx int = 0
	_ = idx
	for idx < len(TEST_GRIDS) {
		fmt.Println((("==grid-" + fmt.Sprint((idx + 1))) + "=="))
		var grid [][]int = _index(TEST_GRIDS, idx)
		_ = grid
		var init Pos = Pos{
			Y: 0,
			X: 0,
		}
		_ = init
		var goal Pos = Pos{
			Y: (len(grid) - 1),
			X: (len(_index(grid, 0)) - 1),
		}
		_ = goal
		print_grid(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid))
		fmt.Println("------")
		var path []Pos = greedy_best_first(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid), init, goal)
		_ = path
		var j int = 0
		_ = j
		for j < len(path) {
			var p Pos = _index(path, j)
			_ = p
			_setIndex(_index(grid, p.Y), p.X, 2)
			j = (j + 1)
		}
		print_grid(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid))
		idx = (idx + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		delta = []Pos{Pos{
			Y: (0 - 1),
			X: 0,
		}, Pos{
			Y: 0,
			X: (0 - 1),
		}, Pos{
			Y: 1,
			X: 0,
		}, Pos{
			Y: 0,
			X: 1,
		}}
		TEST_GRIDS = [][][]int{[][]int{[]int{0, 0, 0, 0, 0, 0, 0}, []int{0, 1, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0, 0}, []int{0, 0, 1, 0, 0, 0, 0}, []int{1, 0, 1, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 1, 0, 0}}, [][]int{[]int{0, 0, 0, 1, 1, 0, 0}, []int{0, 0, 0, 0, 1, 0, 1}, []int{0, 0, 0, 1, 1, 0, 0}, []int{0, 1, 0, 0, 1, 0, 0}, []int{1, 0, 0, 1, 1, 0, 1}, []int{0, 0, 0, 0, 0, 0, 0}}, [][]int{[]int{0, 0, 1, 0, 0}, []int{0, 1, 0, 0, 0}, []int{0, 0, 1, 0, 1}, []int{1, 0, 0, 1, 1}, []int{0, 0, 0, 0, 0}}}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
