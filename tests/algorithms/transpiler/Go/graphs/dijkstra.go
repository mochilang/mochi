//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:25:12 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

type NodeCost struct {
	Node string `json:"node"`
	Cost int    `json:"cost"`
}

var G map[string]map[string]int

var heap []NodeCost

var visited map[string]bool

var result int

var G2 map[string]map[string]int

var heap2 []NodeCost

var visited2 map[string]bool

var result2 int

var G3 map[string]map[string]int

var heap3 []NodeCost

var visited3 map[string]bool

var result3 int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		G = map[string]map[string]int{"A": map[string]int{"B": 2, "C": 5}, "B": map[string]int{"A": 2, "D": 3, "E": 1, "F": 1}, "C": map[string]int{"A": 5, "F": 3}, "D": map[string]int{"B": 3}, "E": map[string]int{"B": 4, "F": 3}, "F": map[string]int{"C": 3, "E": 3}}
		heap = []NodeCost{NodeCost{
			Node: "E",
			Cost: 0,
		}}
		visited = map[string]bool{}
		result = (0 - 1)
		for len(heap) > 0 {
			var best_idx int = 0
			_ = best_idx
			var i int = 1
			_ = i
			for i < len(heap) {
				if _index(heap, i).Cost < _index(heap, best_idx).Cost {
					best_idx = i
				}
				i = (i + 1)
			}
			var best NodeCost = _index(heap, best_idx)
			_ = best
			var new_heap []NodeCost = []NodeCost{}
			_ = new_heap
			var j int = 0
			_ = j
			for j < len(heap) {
				if j != best_idx {
					new_heap = append(new_heap, _index(heap, j))
				}
				j = (j + 1)
			}
			heap = new_heap
			var u string = best.Node
			_ = u
			var cost int = best.Cost
			_ = cost
			if func() bool { _, ok := visited[u]; return ok }() {
				continue
			}
			visited[u] = true
			if u == "C" {
				result = cost
				break
			}
			for _, v := range func() []string {
				keys := make([]string, 0, len(G[u]))
				for k := range G[u] {
					keys = append(keys, k)
				}
				sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
				return keys
			}() {
				if func() bool { _, ok := visited[v]; return ok }() {
					continue
				}
				var next_cost int = (cost + int(G[u][v]))
				_ = next_cost
				heap = append(heap, NodeCost{
					Node: v,
					Cost: next_cost,
				})
			}
		}
		fmt.Println(result)
		G2 = map[string]map[string]int{"B": map[string]int{"C": 1}, "C": map[string]int{"D": 1}, "D": map[string]int{"F": 1}, "E": map[string]int{"B": 1, "F": 3}, "F": map[string]int{}}
		heap2 = []NodeCost{NodeCost{
			Node: "E",
			Cost: 0,
		}}
		visited2 = map[string]bool{}
		result2 = (0 - 1)
		for len(heap2) > 0 {
			var best2_idx int = 0
			_ = best2_idx
			var i2 int = 1
			_ = i2
			for i2 < len(heap2) {
				if _index(heap2, i2).Cost < _index(heap2, best2_idx).Cost {
					best2_idx = i2
				}
				i2 = (i2 + 1)
			}
			var best2 NodeCost = _index(heap2, best2_idx)
			_ = best2
			var new_heap2 []NodeCost = []NodeCost{}
			_ = new_heap2
			var j2 int = 0
			_ = j2
			for j2 < len(heap2) {
				if j2 != best2_idx {
					new_heap2 = append(new_heap2, _index(heap2, j2))
				}
				j2 = (j2 + 1)
			}
			heap2 = new_heap2
			var u2 string = best2.Node
			_ = u2
			var cost2 int = best2.Cost
			_ = cost2
			if func() bool { _, ok := visited2[u2]; return ok }() {
				continue
			}
			visited2[u2] = true
			if u2 == "F" {
				result2 = cost2
				break
			}
			for _, v2 := range func() []string {
				keys := make([]string, 0, len(G2[u2]))
				for k := range G2[u2] {
					keys = append(keys, k)
				}
				sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
				return keys
			}() {
				if func() bool { _, ok := visited2[v2]; return ok }() {
					continue
				}
				var next_cost2 int = (cost2 + int(G2[u2][v2]))
				_ = next_cost2
				heap2 = append(heap2, NodeCost{
					Node: v2,
					Cost: next_cost2,
				})
			}
		}
		fmt.Println(result2)
		G3 = map[string]map[string]int{"B": map[string]int{"C": 1}, "C": map[string]int{"D": 1}, "D": map[string]int{"F": 1}, "E": map[string]int{"B": 1, "G": 2}, "F": map[string]int{}, "G": map[string]int{"F": 1}}
		heap3 = []NodeCost{NodeCost{
			Node: "E",
			Cost: 0,
		}}
		visited3 = map[string]bool{}
		result3 = (0 - 1)
		for len(heap3) > 0 {
			var best3_idx int = 0
			_ = best3_idx
			var i3 int = 1
			_ = i3
			for i3 < len(heap3) {
				if _index(heap3, i3).Cost < _index(heap3, best3_idx).Cost {
					best3_idx = i3
				}
				i3 = (i3 + 1)
			}
			var best3 NodeCost = _index(heap3, best3_idx)
			_ = best3
			var new_heap3 []NodeCost = []NodeCost{}
			_ = new_heap3
			var j3 int = 0
			_ = j3
			for j3 < len(heap3) {
				if j3 != best3_idx {
					new_heap3 = append(new_heap3, _index(heap3, j3))
				}
				j3 = (j3 + 1)
			}
			heap3 = new_heap3
			var u3 string = best3.Node
			_ = u3
			var cost3 int = best3.Cost
			_ = cost3
			if func() bool { _, ok := visited3[u3]; return ok }() {
				continue
			}
			visited3[u3] = true
			if u3 == "F" {
				result3 = cost3
				break
			}
			for _, v3 := range func() []string {
				keys := make([]string, 0, len(G3[u3]))
				for k := range G3[u3] {
					keys = append(keys, k)
				}
				sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
				return keys
			}() {
				if func() bool { _, ok := visited3[v3]; return ok }() {
					continue
				}
				var next_cost3 int = (cost3 + int(G3[u3][v3]))
				_ = next_cost3
				heap3 = append(heap3, NodeCost{
					Node: v3,
					Cost: next_cost3,
				})
			}
		}
		fmt.Println(result3)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
