//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:24:57 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

type Graph struct {
	Graph  map[string][]string `json:"graph"`
	Parent map[string]string   `json:"parent"`
	Source string              `json:"source"`
}

func newGraph(g map[string][]string, s string) Graph {
	return Graph{
		Graph:  g,
		Parent: map[string]string{},
		Source: s,
	}
}

func breath_first_search(g Graph) Graph {
	var parent map[string]string = g.Parent
	_ = parent
	parent[g.Source] = g.Source
	var queue []string = []string{g.Source}
	_ = queue
	var idx int = 0
	_ = idx
	for idx < len(queue) {
		var vertex string = _index(queue, idx)
		_ = vertex
		for _, adj := range g.Graph[vertex] {
			if !func() bool { _, ok := parent[adj]; return ok }() {
				parent[adj] = vertex
				queue = append(queue, adj)
			}
		}
		idx = (idx + 1)
	}
	g.Parent = parent
	return g
}

func shortest_path(g Graph, target string) string {
	if target == g.Source {
		return g.Source
	}
	if !func() bool { _, ok := g.Parent[target]; return ok }() {
		return ((("No path from vertex: " + g.Source) + " to vertex: ") + target)
	}
	var p string = g.Parent[target]
	_ = p
	_ = p
	return ((shortest_path(g, p) + "->") + target)
}

var graph map[string][]string

var g Graph

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		graph = map[string][]string{"A": []string{"B", "C", "E"}, "B": []string{"A", "D", "E"}, "C": []string{"A", "F", "G"}, "D": []string{"B"}, "E": []string{"A", "B", "D"}, "F": []string{"C"}, "G": []string{"C"}}
		g = newGraph(graph, "G")
		g = breath_first_search(g)
		fmt.Println(shortest_path(g, "D"))
		fmt.Println(shortest_path(g, "G"))
		fmt.Println(shortest_path(g, "Foo"))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
