//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:25:01 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Edge struct {
	DestinationVertex int `json:"destination_vertex"`
	Weight            int `json:"weight"`
}

type AdjacencyList struct {
	Graph [][]Edge `json:"graph"`
	Size  int      `json:"size"`
}

func new_adjacency_list(size int) AdjacencyList {
	var g [][]Edge = [][]Edge{}
	_ = g
	var i int = 0
	_ = i
	for i < size {
		g = append(g, []Edge{})
		i = (i + 1)
	}
	return AdjacencyList{
		Graph: g,
		Size:  size,
	}
}

func add_edge(al AdjacencyList, from_vertex int, to_vertex int, weight int) {
	if !((weight == 0) || (weight == 1)) {
		panic("Edge weight must be either 0 or 1.")
	}
	if (to_vertex < 0) || (to_vertex >= al.Size) {
		panic("Vertex indexes must be in [0; size).")
	}
	var g AdjacencyList = al.Graph
	_ = g
	edges := g.FromVertex
	_ = edges
	g[from_vertex] = append(edges, Edge{
		DestinationVertex: to_vertex,
		Weight:            weight,
	})
	al.Graph = g
}

func push_front(q []int, v int) []int {
	var res []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(v)}
	_ = res
	var i int = 0
	_ = i
	for i < len(q) {
		res = append(res, _index(q, i))
		i = (i + 1)
	}
	return res
}

func pop_front(q []int) []int {
	var res []int = []int{}
	_ = res
	var i int = 1
	_ = i
	for i < len(q) {
		res = append(res, _index(q, i))
		i = (i + 1)
	}
	return res
}

func front(q []int) int {
	return _index(q, 0)
}

func get_shortest_path(al AdjacencyList, start_vertex int, finish_vertex int) int {
	var queue []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(start_vertex)}
	_ = queue
	var distances []int = []int{}
	_ = distances
	var i int = 0
	_ = i
	for i < al.Size {
		distances = append(distances, (0 - 1))
		i = (i + 1)
	}
	_setIndex(distances, start_vertex, 0)
	for len(queue) > 0 {
		current_vertex := front(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(queue))
		_ = current_vertex
		queue = pop_front(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(queue))
		var current_distance int = _index(distances, current_vertex)
		_ = current_distance
		var edges []Edge = _index(al.Graph, current_vertex)
		_ = edges
		var j int = 0
		_ = j
		for j < len(edges) {
			var edge Edge = _index(edges, j)
			_ = edge
			var new_distance int = (current_distance + edge.Weight)
			_ = new_distance
			var dest int = edge.DestinationVertex
			_ = dest
			var dest_distance int = _index(distances, dest)
			_ = dest_distance
			if (dest_distance >= 0) && (new_distance >= dest_distance) {
				j = (j + 1)
				continue
			}
			_setIndex(distances, dest, new_distance)
			if edge.Weight == 0 {
				queue = push_front(func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(queue), dest)
			} else {
				queue = append(queue, dest)
			}
			j = (j + 1)
		}
	}
	var result int = _index(distances, finish_vertex)
	_ = result
	if result < 0 {
		panic("No path from start_vertex to finish_vertex.")
	}
	return result
}

var g AdjacencyList

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		g = new_adjacency_list(11)
		add_edge(g, 0, 1, 0)
		add_edge(g, 0, 3, 1)
		add_edge(g, 1, 2, 0)
		add_edge(g, 2, 3, 0)
		add_edge(g, 4, 2, 1)
		add_edge(g, 4, 5, 1)
		add_edge(g, 4, 6, 1)
		add_edge(g, 5, 9, 0)
		add_edge(g, 6, 7, 1)
		add_edge(g, 7, 8, 1)
		add_edge(g, 8, 10, 1)
		add_edge(g, 9, 7, 0)
		add_edge(g, 9, 10, 1)
		fmt.Println(fmt.Sprint(get_shortest_path(g, 0, 3)))
		fmt.Println(fmt.Sprint(get_shortest_path(g, 4, 10)))
		fmt.Println(fmt.Sprint(get_shortest_path(g, 4, 8)))
		fmt.Println(fmt.Sprint(get_shortest_path(g, 0, 1)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
