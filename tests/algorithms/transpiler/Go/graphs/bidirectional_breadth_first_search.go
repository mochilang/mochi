//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-13 12:54:31 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

var grid [][]int

var delta [][]int

func key(y int, x int) string {
	return ((fmt.Sprint(y) + ",") + fmt.Sprint(x))
}

func parse_int(s string) int {
	var value int = 0
	_ = value
	var i int = 0
	_ = i
	for i < len(s) {
		var c string = string(_index([]rune(s), i))
		_ = c
		_ = c
		value = ((value * 10) + func() int { n, _ := strconv.Atoi(fmt.Sprint(c)); return n }())
		i = (i + 1)
	}
	return value
}

func parse_key(k string) []int {
	var idx int = 0
	_ = idx
	for (idx < len(k)) && (_substr(k, idx, (idx+1)) != ",") {
		idx = (idx + 1)
	}
	var y int = parse_int(_substr(k, 0, idx))
	_ = y
	_ = y
	var x int = parse_int(_substr(k, (idx + 1), len(k)))
	_ = x
	_ = x
	return []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(y), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(x)}
}

type Node struct {
	Pos  string   `json:"pos"`
	Path []string `json:"path"`
}

func neighbors(pos string) []string {
	var coords []int = parse_key(pos)
	_ = coords
	var y int = _index(coords, 0)
	_ = y
	var x int = _index(coords, 1)
	_ = x
	var res []string = []string{}
	_ = res
	var i int = 0
	_ = i
	for i < len(delta) {
		var ny int = (y + int(_index(_index(delta, i), 0)))
		_ = ny
		var nx int = (x + int(_index(_index(delta, i), 1)))
		_ = nx
		if (((ny >= 0) && (ny < len(grid))) && (nx >= 0)) && (nx < len(_index(grid, 0))) {
			if int(_index(_index(grid, ny), nx)) == 0 {
				res = append(res, key(ny, nx))
			}
		}
		i = (i + 1)
	}
	return res
}

func reverse_list(lst []string) []string {
	var res []string = []string{}
	_ = res
	var i int = (len(lst) - 1)
	_ = i
	for i >= 0 {
		res = append(res, _index(lst, i))
		i = (i - 1)
	}
	return res
}

func bfs(start string, goal string) []string {
	var queue []Node = []Node{}
	_ = queue
	queue = append(queue, Node{
		Pos:  start,
		Path: []string{start},
	})
	var head int = 0
	_ = head
	var visited map[string]bool = map[string]bool{"start": true}
	_ = visited
	for head < len(queue) {
		var node Node = _index(queue, head)
		_ = node
		head = (head + 1)
		if node.Pos == goal {
			return node.Path
		}
		var neigh []string = neighbors(node.Pos)
		_ = neigh
		var i int = 0
		_ = i
		for i < len(neigh) {
			var npos string = _index(neigh, i)
			_ = npos
			if !func() bool { _, ok := visited[npos]; return ok }() {
				visited[npos] = true
				var new_path []string = append(node.Path, npos)
				_ = new_path
				queue = append(queue, Node{
					Pos:  npos,
					Path: new_path,
				})
			}
			i = (i + 1)
		}
	}
	return func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}([]string{})
}

func bidirectional_bfs(start string, goal string) []string {
	var queue_f []Node = []Node{}
	_ = queue_f
	var queue_b []Node = []Node{}
	_ = queue_b
	queue_f = append(queue_f, Node{
		Pos:  start,
		Path: []string{start},
	})
	queue_b = append(queue_b, Node{
		Pos:  goal,
		Path: []string{goal},
	})
	var head_f int = 0
	_ = head_f
	var head_b int = 0
	_ = head_b
	var visited_f map[string][]string = map[string][]string{"start": []string{start}}
	_ = visited_f
	var visited_b map[string][]string = map[string][]string{"goal": []string{goal}}
	_ = visited_b
	for (head_f < len(queue_f)) && (head_b < len(queue_b)) {
		var node_f Node = _index(queue_f, head_f)
		_ = node_f
		head_f = (head_f + 1)
		var neigh_f []string = neighbors(node_f.Pos)
		_ = neigh_f
		var i int = 0
		_ = i
		for i < len(neigh_f) {
			var npos string = _index(neigh_f, i)
			_ = npos
			if !func() bool { _, ok := visited_f[npos]; return ok }() {
				var new_path []string = append(node_f.Path, npos)
				_ = new_path
				visited_f[npos] = new_path
				if func() bool { _, ok := visited_b[npos]; return ok }() {
					var rev []string = reverse_list(func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = fmt.Sprint(x)
							}
							return out
						}
						return v.([]string)
					}(visited_b[npos]))
					_ = rev
					var j int = 1
					_ = j
					for j < len(rev) {
						new_path = append(new_path, _index(rev, j))
						j = (j + 1)
					}
					return new_path
				}
				queue_f = append(queue_f, Node{
					Pos:  npos,
					Path: new_path,
				})
			}
			i = (i + 1)
		}
		var node_b Node = _index(queue_b, head_b)
		_ = node_b
		head_b = (head_b + 1)
		var neigh_b []string = neighbors(node_b.Pos)
		_ = neigh_b
		var j int = 0
		_ = j
		for j < len(neigh_b) {
			var nposb string = _index(neigh_b, j)
			_ = nposb
			if !func() bool { _, ok := visited_b[nposb]; return ok }() {
				var new_path_b []string = append(node_b.Path, nposb)
				_ = new_path_b
				visited_b[nposb] = new_path_b
				if func() bool { _, ok := visited_f[nposb]; return ok }() {
					var path_f []string = visited_f[nposb]
					_ = path_f
					new_path_b = reverse_list(func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = fmt.Sprint(x)
							}
							return out
						}
						return v.([]string)
					}(new_path_b))
					var t int = 1
					_ = t
					for t < len(new_path_b) {
						path_f = append(path_f, _index(new_path_b, t))
						t = (t + 1)
					}
					return path_f
				}
				queue_b = append(queue_b, Node{
					Pos:  nposb,
					Path: new_path_b,
				})
			}
			j = (j + 1)
		}
	}
	return []string{start}
}

func path_to_string(path []string) string {
	if len(path) == 0 {
		return "[]"
	}
	var first []int = parse_key(_index(path, 0))
	_ = first
	var s string = (((("[(" + fmt.Sprint(_index(first, 0))) + ", ") + fmt.Sprint(_index(first, 1))) + ")")
	_ = s
	var i int = 1
	_ = i
	for i < len(path) {
		var c []int = parse_key(_index(path, i))
		_ = c
		s = (((((s + ", (") + fmt.Sprint(_index(c, 0))) + ", ") + fmt.Sprint(_index(c, 1))) + ")")
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

var start string

var goal string

var path1 []string

var path2 []string

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		grid = [][]int{[]int{0, 0, 0, 0, 0, 0, 0}, []int{0, 1, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0, 0}, []int{0, 0, 1, 0, 0, 0, 0}, []int{1, 0, 1, 0, 0, 0, 0}, []int{0, 0, 0, 0, 0, 0, 0}, []int{0, 0, 0, 0, 1, 0, 0}}
		delta = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), 0}, []int{0, func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1))}, []int{1, 0}, []int{0, 1}}
		start = key(0, 0)
		goal = key((len(grid) - 1), (len(_index(grid, 0)) - 1))
		path1 = bfs(start, goal)
		fmt.Println(path_to_string(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(path1)))
		path2 = bidirectional_bfs(start, goal)
		fmt.Println(path_to_string(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(path2)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
