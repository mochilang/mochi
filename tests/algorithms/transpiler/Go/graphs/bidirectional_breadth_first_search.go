//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:24:50 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

var grid [][]int

var delta [][]int

func key(y int, x int) string {
	return ((fmt.Sprint(y) + ",") + fmt.Sprint(x))
}

func parse_int(s string) int {
	var value int = 0
	_ = value
	var i int = 0
	_ = i
	for i < len(s) {
		c := string(_index([]rune(s), i))
		_ = c
		_ = c
		value = ((value * 10) + func() int { n, _ := strconv.Atoi(fmt.Sprint(c)); return n }())
		i = (i + 1)
	}
	return value
}

func parse_key(k string) []int {
	var idx int = 0
	_ = idx
	for (idx < len(k)) && (_substr(k, idx, (idx+1)) != ",") {
		idx = (idx + 1)
	}
	y := parse_int(_substr(k, 0, idx))
	_ = y
	_ = y
	x := parse_int(_substr(k, (idx + 1), len(k)))
	_ = x
	_ = x
	return func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(y), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(x)})
}

type Node struct {
	Pos  string   `json:"pos"`
	Path []string `json:"path"`
}

func neighbors(pos string) []string {
	coords := parse_key(pos)
	_ = coords
	y := _index(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(coords), 0)
	_ = y
	x := _index(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(coords), 1)
	_ = x
	var res []string = []string{}
	_ = res
	var i int = 0
	_ = i
	for i < len(delta) {
		ny := (y + int(_index(_index(delta, i), 0)))
		_ = ny
		nx := (x + int(_index(_index(delta, i), 1)))
		_ = nx
		if (((ny >= 0) && (ny < len(grid))) && (nx >= 0)) && (nx < len(_index(grid, 0))) {
			if int(_index(_index(grid, ny), nx)) == 0 {
				res = append(res, key(ny, nx))
			}
		}
		i = (i + 1)
	}
	return res
}

func reverse_list(lst []string) []string {
	var res []string = []string{}
	_ = res
	var i int = (len(lst) - 1)
	_ = i
	for i >= 0 {
		res = append(res, _index(lst, i))
		i = (i - 1)
	}
	return res
}

func bfs(start string, goal string) []string {
	var queue []Node = []Node{}
	_ = queue
	queue = append(queue, Node{
		Pos:  start,
		Path: []string{start},
	})
	var head int = 0
	_ = head
	var visited map[string]bool = map[string]bool{"start": true}
	_ = visited
	for head < len(queue) {
		var node Node = _index(queue, head)
		_ = node
		head = (head + 1)
		if node.Pos == goal {
			return node.Path
		}
		neigh := neighbors(node.Pos)
		_ = neigh
		var i int = 0
		_ = i
		for i < _len(neigh) {
			npos := _index(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(neigh), i)
			_ = npos
			if !func() bool { _, ok := visited[npos]; return ok }() {
				visited[npos] = true
				new_path := append(node.Path, npos)
				_ = new_path
				queue = append(queue, Node{
					Pos:  npos,
					Path: new_path,
				})
			}
			i = (i + 1)
		}
	}
	return func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}([]string{})
}

func bidirectional_bfs(start string, goal string) []string {
	var queue_f []Node = []Node{}
	_ = queue_f
	var queue_b []Node = []Node{}
	_ = queue_b
	queue_f = append(queue_f, Node{
		Pos:  start,
		Path: []string{start},
	})
	queue_b = append(queue_b, Node{
		Pos:  goal,
		Path: []string{goal},
	})
	var head_f int = 0
	_ = head_f
	var head_b int = 0
	_ = head_b
	var visited_f map[string][]string = map[string][]string{"start": []string{start}}
	_ = visited_f
	var visited_b map[string][]string = map[string][]string{"goal": []string{goal}}
	_ = visited_b
	for (head_f < len(queue_f)) && (head_b < len(queue_b)) {
		var node_f Node = _index(queue_f, head_f)
		_ = node_f
		head_f = (head_f + 1)
		neigh_f := neighbors(node_f.Pos)
		_ = neigh_f
		var i int = 0
		_ = i
		for i < _len(neigh_f) {
			npos := _index(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(neigh_f), i)
			_ = npos
			if !func() bool { _, ok := visited_f[npos]; return ok }() {
				new_path := append(node_f.Path, npos)
				_ = new_path
				visited_f[npos] = new_path
				if func() bool { _, ok := visited_b[npos]; return ok }() {
					var rev []string = reverse_list(func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = fmt.Sprint(x)
							}
							return out
						}
						return v.([]string)
					}(visited_b[npos]))
					_ = rev
					var j int = 1
					_ = j
					for j < len(rev) {
						new_path = append(new_path, _index(rev, j))
						j = (j + 1)
					}
					return func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = fmt.Sprint(x)
							}
							return out
						}
						return v.([]string)
					}(new_path)
				}
				queue_f = append(queue_f, Node{
					Pos:  npos,
					Path: new_path,
				})
			}
			i = (i + 1)
		}
		var node_b Node = _index(queue_b, head_b)
		_ = node_b
		head_b = (head_b + 1)
		neigh_b := neighbors(node_b.Pos)
		_ = neigh_b
		var j int = 0
		_ = j
		for j < _len(neigh_b) {
			nposb := _index(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(neigh_b), j)
			_ = nposb
			if !func() bool { _, ok := visited_b[nposb]; return ok }() {
				new_path_b := append(node_b.Path, nposb)
				_ = new_path_b
				visited_b[nposb] = new_path_b
				if func() bool { _, ok := visited_f[nposb]; return ok }() {
					var path_f []string = visited_f[nposb]
					_ = path_f
					new_path_b = reverse_list(func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = fmt.Sprint(x)
							}
							return out
						}
						return v.([]string)
					}(func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = fmt.Sprint(x)
							}
							return out
						}
						return v.([]string)
					}(new_path_b)))
					var t int = 1
					_ = t
					for t < _len(new_path_b) {
						path_f = append(path_f, fmt.Sprint(_index(func(v any) []any {
							if v == nil {
								return nil
							}
							if arr, ok := v.([]any); ok {
								return arr
							}
							rv := reflect.ValueOf(v)
							if rv.Kind() != reflect.Slice {
								return v.([]any)
							}
							n := rv.Len()
							out := make([]any, n)
							for i := 0; i < n; i++ {
								out[i] = rv.Index(i).Interface()
							}
							return out
						}(new_path_b), t)))
						t = (t + 1)
					}
					return path_f
				}
				queue_b = append(queue_b, Node{
					Pos:  nposb,
					Path: new_path_b,
				})
			}
			j = (j + 1)
		}
	}
	return []string{start}
}

func path_to_string(path []string) string {
	if len(path) == 0 {
		return "[]"
	}
	var first []int = parse_key(_index(path, 0))
	_ = first
	var s string = (((("[(" + fmt.Sprint(_index(first, 0))) + ", ") + fmt.Sprint(_index(first, 1))) + ")")
	_ = s
	var i int = 1
	_ = i
	for i < len(path) {
		c := parse_key(_index(path, i))
		_ = c
		s = (((((s + ", (") + fmt.Sprint(_index(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(c), 0))) + ", ") + fmt.Sprint(_index(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(c), 1))) + ")")
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

var start string

var goal string

var path1 []string

var path2 []string

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		grid = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}}
		delta = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1))}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1)}}
		start = key(0, 0)
		goal = key((len(grid) - 1), (len(_index(grid, 0)) - 1))
		path1 = bfs(start, goal)
		fmt.Println(path_to_string(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(path1)))
		path2 = bidirectional_bfs(start, goal)
		fmt.Println(path_to_string(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(path2)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
