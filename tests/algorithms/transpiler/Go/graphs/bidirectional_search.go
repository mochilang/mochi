//go:build ignore

// Generated by Mochi v0.10.73 on 2025-08-25 16:50:16 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var __name__ string = "__main__"

type ExpandResult struct {
	Queue        []int        `json:"queue"`
	Head         int          `json:"head"`
	Parents      map[int]int  `json:"parents"`
	Visited      map[int]bool `json:"visited"`
	Intersection int          `json:"intersection"`
	Found        bool         `json:"found"`
}

func expand_search(graph map[int][]int, queue []int, head int, parents map[int]int, visited map[int]bool, opposite_visited map[int]bool) ExpandResult {
	if head >= len(queue) {
		return ExpandResult{
			Queue:        queue,
			Head:         head,
			Parents:      parents,
			Visited:      visited,
			Intersection: (0 - 1),
			Found:        false,
		}
	}
	var current int = _index(queue, head)
	_ = current
	head = (head + 1)
	var neighbors []int = graph[current]
	_ = neighbors
	var q []int = queue
	_ = q
	var p map[int]int = parents
	if p == nil {
		p = map[int]int{}
	}
	_ = p
	var v map[int]bool = visited
	if v == nil {
		v = map[int]bool{}
	}
	_ = v
	var i int = 0
	_ = i
	for i < len(neighbors) {
		var neighbor int = _index(neighbors, i)
		_ = neighbor
		if v[neighbor] {
			i = (i + 1)
			continue
		}
		v[neighbor] = true
		p[neighbor] = current
		q = append(q, neighbor)
		if opposite_visited[neighbor] {
			return ExpandResult{
				Queue:        q,
				Head:         head,
				Parents:      p,
				Visited:      v,
				Intersection: neighbor,
				Found:        true,
			}
		}
		i = (i + 1)
	}
	return ExpandResult{
		Queue:        q,
		Head:         head,
		Parents:      p,
		Visited:      v,
		Intersection: (0 - 1),
		Found:        false,
	}
}

func construct_path(current int, parents map[int]int) []int {
	var path []int = []int{}
	_ = path
	var node int = current
	_ = node
	for node != (0 - 1) {
		path = append(path, node)
		node = parents[node]
	}
	return path
}

func reverse_list(xs []int) []int {
	var res []int = []int{}
	_ = res
	var i int = len(xs)
	_ = i
	for i > 0 {
		i = (i - 1)
		res = append(res, _index(xs, i))
	}
	return res
}

type SearchResult struct {
	Path []int `json:"path"`
	Ok   bool  `json:"ok"`
}

func bidirectional_search(g map[int][]int, start int, goal int) SearchResult {
	if start == goal {
		return SearchResult{
			Path: []int{func(v any) int {
				if vv, ok := v.(int); ok {
					return vv
				}
				return 0
			}(start)},
			Ok: true,
		}
	}
	var forward_parents map[int]int = map[int]int{}
	if forward_parents == nil {
		forward_parents = map[int]int{}
	}
	_ = forward_parents
	forward_parents[start] = (0 - 1)
	var backward_parents map[int]int = map[int]int{}
	if backward_parents == nil {
		backward_parents = map[int]int{}
	}
	_ = backward_parents
	backward_parents[goal] = (0 - 1)
	var forward_visited map[int]bool = map[int]bool{}
	if forward_visited == nil {
		forward_visited = map[int]bool{}
	}
	_ = forward_visited
	forward_visited[start] = true
	var backward_visited map[int]bool = map[int]bool{}
	if backward_visited == nil {
		backward_visited = map[int]bool{}
	}
	_ = backward_visited
	backward_visited[goal] = true
	var forward_queue []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(start)}
	_ = forward_queue
	var backward_queue []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(goal)}
	_ = backward_queue
	var forward_head int = 0
	_ = forward_head
	var backward_head int = 0
	_ = backward_head
	var intersection int = (0 - 1)
	_ = intersection
	for ((forward_head < len(forward_queue)) && (backward_head < len(backward_queue))) && (intersection == (0 - 1)) {
		var res ExpandResult = expand_search(g, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(forward_queue), forward_head, forward_parents, forward_visited, backward_visited)
		_ = res
		forward_queue = res.Queue
		forward_head = res.Head
		forward_parents = res.Parents
		forward_visited = res.Visited
		if res.Found {
			intersection = res.Intersection
			break
		}
		res = expand_search(g, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(backward_queue), backward_head, backward_parents, backward_visited, forward_visited)
		backward_queue = res.Queue
		backward_head = res.Head
		backward_parents = res.Parents
		backward_visited = res.Visited
		if res.Found {
			intersection = res.Intersection
			break
		}
	}
	if intersection == (0 - 1) {
		return SearchResult{
			Path: []int{},
			Ok:   false,
		}
	}
	var forward_path []int = construct_path(intersection, forward_parents)
	_ = forward_path
	forward_path = reverse_list(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(forward_path))
	var back_start int = backward_parents[intersection]
	_ = back_start
	var backward_path []int = construct_path(back_start, backward_parents)
	_ = backward_path
	var result []int = forward_path
	_ = result
	var j int = 0
	_ = j
	for j < len(backward_path) {
		result = append(result, _index(backward_path, j))
		j = (j + 1)
	}
	return SearchResult{
		Path: result,
		Ok:   true,
	}
}

func is_edge(g map[int][]int, u int, v int) bool {
	var neighbors []int = g[u]
	_ = neighbors
	var i int = 0
	_ = i
	for i < len(neighbors) {
		if _index(neighbors, i) == v {
			return true
		}
		i = (i + 1)
	}
	return false
}

func path_exists(g map[int][]int, path []int) bool {
	if len(path) == 0 {
		return false
	}
	var i int = 0
	_ = i
	for (i + 1) < len(path) {
		if !is_edge(g, _index(path, i), _index(path, (i+1))) {
			return false
		}
		i = (i + 1)
	}
	return true
}

func print_path(g map[int][]int, s int, t int) {
	var res SearchResult = bidirectional_search(g, s, t)
	_ = res
	if res.Ok && path_exists(g, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(res.Path)) {
		fmt.Println(((((("Path from " + fmt.Sprint(s)) + " to ") + fmt.Sprint(t)) + ": ") + fmt.Sprint(res.Path)))
	} else {
		fmt.Println((((("Path from " + fmt.Sprint(s)) + " to ") + fmt.Sprint(t)) + ": None"))
	}
}

func mochiMain() {
	var graph map[int][]int = map[int][]int{0: []int{1, 2}, 1: []int{0, 3, 4}, 2: []int{0, 5, 6}, 3: []int{1, 7}, 4: []int{1, 8}, 5: []int{2, 9}, 6: []int{2, 10}, 7: []int{3, 11}, 8: []int{4, 11}, 9: []int{5, 11}, 10: []int{6, 11}, 11: []int{7, 8, 9, 10}}
	if graph == nil {
		graph = map[int][]int{}
	}
	_ = graph
	print_path(graph, 0, 11)
	print_path(graph, 5, 5)
	var disconnected map[int][]int = map[int][]int{0: []int{1, 2}, 1: []int{0}, 2: []int{0}, 3: []int{4}, 4: []int{3}}
	if disconnected == nil {
		disconnected = map[int][]int{}
	}
	_ = disconnected
	print_path(disconnected, 0, 3)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
