//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:24:46 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

type Edge struct {
	To   string `json:"to"`
	Cost int    `json:"cost"`
}

type QItem struct {
	Node string `json:"node"`
	Cost int    `json:"cost"`
}

type PassResult struct {
	Queue []QItem `json:"queue"`
	Dist  int     `json:"dist"`
}

func get_min_index(q []QItem) int {
	var idx int = 0
	_ = idx
	var i int = 1
	_ = i
	for i < len(q) {
		if _index(q, i).Cost < _index(q, idx).Cost {
			idx = i
		}
		i = (i + 1)
	}
	return idx
}

func remove_at(q []QItem, idx int) []QItem {
	var res []QItem = []QItem{}
	_ = res
	var i int = 0
	_ = i
	for i < len(q) {
		if i != idx {
			res = append(res, _index(q, i))
		}
		i = (i + 1)
	}
	return res
}

func pass_and_relaxation(graph map[string][]Edge, v string, visited_forward map[string]bool, visited_backward map[string]bool, cst_fwd map[string]int, cst_bwd map[string]int, queue []QItem, parent map[string]string, shortest_distance int) PassResult {
	var q []QItem = queue
	_ = q
	var sd int = shortest_distance
	_ = sd
	for _, e := range graph[v] {
		var nxt string = e.To
		_ = nxt
		var d int = e.Cost
		_ = d
		if func() bool { _, ok := visited_forward[nxt]; return ok }() {
			continue
		}
		old_cost := func() int {
			if func() bool { _, ok := cst_fwd[nxt]; return ok }() {
				return cst_fwd[nxt]
			} else {
				return 2147483647
			}
		}()
		_ = old_cost
		var new_cost int = (int(cst_fwd[v]) + d)
		_ = new_cost
		if new_cost < old_cost {
			q = append(q, QItem{
				Node: nxt,
				Cost: new_cost,
			})
			cst_fwd[nxt] = new_cost
			parent[nxt] = v
		}
		if func() bool { _, ok := visited_backward[nxt]; return ok }() {
			var alt int = ((int(cst_fwd[v]) + d) + int(cst_bwd[nxt]))
			_ = alt
			if alt < sd {
				sd = alt
			}
		}
	}
	return PassResult{
		Queue: q,
		Dist:  sd,
	}
}

func bidirectional_dij(source string, destination string, graph_forward map[string][]Edge, graph_backward map[string][]Edge) int {
	var shortest_path_distance int = (0 - 1)
	_ = shortest_path_distance
	var visited_forward map[string]bool = map[string]bool{}
	_ = visited_forward
	var visited_backward map[string]bool = map[string]bool{}
	_ = visited_backward
	var cst_fwd map[string]int = map[string]int{}
	_ = cst_fwd
	cst_fwd[source] = 0
	var cst_bwd map[string]int = map[string]int{}
	_ = cst_bwd
	cst_bwd[destination] = 0
	var parent_forward map[string]string = map[string]string{}
	_ = parent_forward
	parent_forward[source] = ""
	var parent_backward map[string]string = map[string]string{}
	_ = parent_backward
	parent_backward[destination] = ""
	var queue_forward []QItem = []QItem{}
	_ = queue_forward
	queue_forward = append(queue_forward, QItem{
		Node: source,
		Cost: 0,
	})
	var queue_backward []QItem = []QItem{}
	_ = queue_backward
	queue_backward = append(queue_backward, QItem{
		Node: destination,
		Cost: 0,
	})
	var shortest_distance int = 2147483647
	_ = shortest_distance
	if source == destination {
		return 0
	}
	for (len(queue_forward) > 0) && (len(queue_backward) > 0) {
		idx_f := get_min_index(func(v any) []QItem {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]QItem); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []QItem{}
				}
				out := make([]QItem, len(arr))
				for i, x := range arr {
					out[i] = x.(QItem)
				}
				return out
			}
			return v.([]QItem)
		}(queue_forward))
		_ = idx_f
		var item_f QItem = _index(queue_forward, idx_f)
		_ = item_f
		queue_forward = remove_at(func(v any) []QItem {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]QItem); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []QItem{}
				}
				out := make([]QItem, len(arr))
				for i, x := range arr {
					out[i] = x.(QItem)
				}
				return out
			}
			return v.([]QItem)
		}(queue_forward), idx_f)
		var v_fwd string = item_f.Node
		_ = v_fwd
		visited_forward[v_fwd] = true
		idx_b := get_min_index(func(v any) []QItem {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]QItem); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []QItem{}
				}
				out := make([]QItem, len(arr))
				for i, x := range arr {
					out[i] = x.(QItem)
				}
				return out
			}
			return v.([]QItem)
		}(queue_backward))
		_ = idx_b
		var item_b QItem = _index(queue_backward, idx_b)
		_ = item_b
		queue_backward = remove_at(func(v any) []QItem {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]QItem); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []QItem{}
				}
				out := make([]QItem, len(arr))
				for i, x := range arr {
					out[i] = x.(QItem)
				}
				return out
			}
			return v.([]QItem)
		}(queue_backward), idx_b)
		var v_bwd string = item_b.Node
		_ = v_bwd
		visited_backward[v_bwd] = true
		res_f := pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, func(v any) []QItem {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]QItem); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []QItem{}
				}
				out := make([]QItem, len(arr))
				for i, x := range arr {
					out[i] = x.(QItem)
				}
				return out
			}
			return v.([]QItem)
		}(queue_forward), parent_forward, shortest_distance)
		_ = res_f
		queue_forward = PassResult(res_f).Queue
		shortest_distance = PassResult(res_f).Dist
		res_b := pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, func(v any) []QItem {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]QItem); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []QItem{}
				}
				out := make([]QItem, len(arr))
				for i, x := range arr {
					out[i] = x.(QItem)
				}
				return out
			}
			return v.([]QItem)
		}(queue_backward), parent_backward, shortest_distance)
		_ = res_b
		queue_backward = PassResult(res_b).Queue
		shortest_distance = PassResult(res_b).Dist
		if (int(cst_fwd[v_fwd]) + int(cst_bwd[v_bwd])) >= shortest_distance {
			break
		}
	}
	if shortest_distance != 2147483647 {
		shortest_path_distance = shortest_distance
	}
	return shortest_path_distance
}

var graph_fwd map[string][]Edge

var graph_bwd map[string][]Edge

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		graph_fwd = map[string][]Edge{"B": []Edge{Edge{
			To:   "C",
			Cost: 1,
		}}, "C": []Edge{Edge{
			To:   "D",
			Cost: 1,
		}}, "D": []Edge{Edge{
			To:   "F",
			Cost: 1,
		}}, "E": []Edge{Edge{
			To:   "B",
			Cost: 1,
		}, Edge{
			To:   "G",
			Cost: 2,
		}}, "F": []Edge{}, "G": []Edge{Edge{
			To:   "F",
			Cost: 1,
		}}}
		graph_bwd = map[string][]Edge{"B": []Edge{Edge{
			To:   "E",
			Cost: 1,
		}}, "C": []Edge{Edge{
			To:   "B",
			Cost: 1,
		}}, "D": []Edge{Edge{
			To:   "C",
			Cost: 1,
		}}, "F": []Edge{Edge{
			To:   "D",
			Cost: 1,
		}, Edge{
			To:   "G",
			Cost: 1,
		}}, "E": []Edge{}, "G": []Edge{Edge{
			To:   "E",
			Cost: 2,
		}}}
		fmt.Println(fmt.Sprint(bidirectional_dij("E", "F", graph_fwd, graph_bwd)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
