//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:25:40 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type GraphAdjacencyList struct {
	AdjList  map[string][]string `json:"adj_list"`
	Directed bool                `json:"directed"`
}

func make_graph(directed bool) GraphAdjacencyList {
	var m map[string][]string = map[string][]string{}
	_ = m
	_ = m
	return GraphAdjacencyList{
		AdjList:  m,
		Directed: directed,
	}
}

func contains_vertex(m map[string][]string, v string) bool {
	return func() bool { _, ok := m[v]; return ok }()
}

func add_edge(g GraphAdjacencyList, s string, d string) GraphAdjacencyList {
	var adj map[string][]string = g.AdjList
	_ = adj
	if !g.Directed {
		if contains_vertex(adj, s) && contains_vertex(adj, d) {
			adj[s] = append(adj[s], d)
			adj[d] = append(adj[d], s)
		} else {
			if contains_vertex(adj, s) {
				adj[s] = append(adj[s], d)
				adj[d] = []string{s}
			} else {
				if contains_vertex(adj, d) {
					adj[d] = append(adj[d], s)
					adj[s] = []string{d}
				} else {
					adj[s] = []string{d}
					adj[d] = []string{s}
				}
			}
		}
	} else {
		if contains_vertex(adj, s) && contains_vertex(adj, d) {
			adj[s] = append(adj[s], d)
		} else {
			if contains_vertex(adj, s) {
				adj[s] = append(adj[s], d)
				adj[d] = []string{}
			} else {
				if contains_vertex(adj, d) {
					adj[s] = []string{d}
				} else {
					adj[s] = []string{d}
					adj[d] = []string{}
				}
			}
		}
	}
	g.AdjList = adj
	return g
}

func graph_to_string(g GraphAdjacencyList) string {
	return fmt.Sprint(g.AdjList)
}

var d_graph GraphAdjacencyList

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		d_graph = make_graph(true)
		d_graph = add_edge(d_graph, fmt.Sprint(0), fmt.Sprint(1))
		fmt.Println(graph_to_string(d_graph))
		d_graph = add_edge(d_graph, fmt.Sprint(1), fmt.Sprint(2))
		d_graph = add_edge(d_graph, fmt.Sprint(1), fmt.Sprint(4))
		d_graph = add_edge(d_graph, fmt.Sprint(1), fmt.Sprint(5))
		fmt.Println(graph_to_string(d_graph))
		d_graph = add_edge(d_graph, fmt.Sprint(2), fmt.Sprint(0))
		d_graph = add_edge(d_graph, fmt.Sprint(2), fmt.Sprint(6))
		d_graph = add_edge(d_graph, fmt.Sprint(2), fmt.Sprint(7))
		fmt.Println(graph_to_string(d_graph))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
