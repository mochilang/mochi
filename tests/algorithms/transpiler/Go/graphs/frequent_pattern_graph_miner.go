//go:build ignore

// Generated by Mochi v0.10.65 on 2025-08-14 16:30:31 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

var EDGE_ARRAY [][][]string

type NodesData struct {
	Map  map[string][]string `json:"map"`
	Keys []string            `json:"keys"`
}

type ClusterData struct {
	Clusters map[int][]string `json:"clusters"`
	Weights  []int            `json:"weights"`
}

type GraphData struct {
	Edges map[string][]string `json:"edges"`
	Keys  []string            `json:"keys"`
}

func contains(lst []string, item string) bool {
	for _, v := range lst {
		if v == item {
			return true
		}
	}
	return false
}

func get_distinct_edge(edge_array [][][]string) []string {
	var distinct []string = []string{}
	_ = distinct
	for _, row := range edge_array {
		for _, item := range row {
			var e string = _index(item, 0)
			_ = e
			if !contains(distinct, e) {
				distinct = append(distinct, e)
			}
		}
	}
	return distinct
}

func get_bitcode(edge_array [][][]string, de string) string {
	var bitcode string = ""
	_ = bitcode
	var i int = 0
	_ = i
	for i < len(edge_array) {
		var found bool = false
		_ = found
		for _, item := range _index(edge_array, i) {
			if _index(item, 0) == de {
				found = true
				break
			}
		}
		if found {
			bitcode = (bitcode + "1")
		} else {
			bitcode = (bitcode + "0")
		}
		i = (i + 1)
	}
	return bitcode
}

func count_ones(s string) int {
	var c int = 0
	_ = c
	var i int = 0
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == "1" {
			c = (c + 1)
		}
		i = (i + 1)
	}
	return c
}

func get_frequency_table(edge_array [][][]string) []map[string]string {
	var distinct []string = get_distinct_edge(func(v any) [][][]string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][][]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][][]string{}
			}
			out := make([][][]string, len(arr))
			for i, x := range arr {
				out[i] = func(v any) [][]string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]string{}
						}
						out := make([][]string, len(arr))
						for i, x := range arr {
							out[i] = x.([]string)
						}
						return out
					}
					return v.([][]string)
				}(x)
			}
			return out
		}
		return v.([][][]string)
	}(edge_array))
	_ = distinct
	var table []map[string]string = []map[string]string{}
	_ = table
	for _, e := range distinct {
		var bit string = get_bitcode(func(v any) [][][]string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][][]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][][]string{}
				}
				out := make([][][]string, len(arr))
				for i, x := range arr {
					out[i] = func(v any) [][]string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([][]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return [][]string{}
							}
							out := make([][]string, len(arr))
							for i, x := range arr {
								out[i] = x.([]string)
							}
							return out
						}
						return v.([][]string)
					}(x)
				}
				return out
			}
			return v.([][][]string)
		}(edge_array), e)
		_ = bit
		var cnt int = count_ones(bit)
		_ = cnt
		var entry map[string]string = map[string]string{"edge": e, "count": fmt.Sprint(cnt), "bit": bit}
		_ = entry
		table = append(table, entry)
	}
	var i int = 0
	_ = i
	for i < len(table) {
		var max_i int = i
		_ = max_i
		var j int = (i + 1)
		_ = j
		for j < len(table) {
			if _toFloat(func() int { n, _ := strconv.Atoi(fmt.Sprint(_index(table, j)["count"])); return n }()) > _toFloat(func() int { n, _ := strconv.Atoi(fmt.Sprint(_index(table, max_i)["count"])); return n }()) {
				max_i = j
			}
			j = (j + 1)
		}
		var tmp map[string]string = _index(table, i)
		_ = tmp
		_setIndex(table, i, _index(table, max_i))
		_setIndex(table, max_i, tmp)
		i = (i + 1)
	}
	return table
}

func get_nodes(freq_table []map[string]string) NodesData {
	var nodes map[string][]string = map[string][]string{}
	_ = nodes
	var keys []string = []string{}
	_ = keys
	for _, f := range freq_table {
		var code string = f["bit"]
		_ = code
		var edge string = f["edge"]
		_ = edge
		if func() bool { _, ok := nodes[code]; return ok }() {
			nodes[code] = append(nodes[code], edge)
		} else {
			nodes[code] = []string{edge}
			keys = append(keys, code)
		}
	}
	return NodesData{
		Map:  nodes,
		Keys: keys,
	}
}

func get_cluster(nodes NodesData) ClusterData {
	var clusters map[int][]string = map[int][]string{}
	_ = clusters
	var weights []int = []int{}
	_ = weights
	var i int = 0
	_ = i
	for i < len(nodes.Keys) {
		var code string = _index(nodes.Keys, i)
		_ = code
		var wt int = count_ones(code)
		_ = wt
		if func() bool { _, ok := clusters[wt]; return ok }() {
			clusters[wt] = append(clusters[wt], code)
		} else {
			clusters[wt] = []string{code}
			weights = append(weights, wt)
		}
		i = (i + 1)
	}
	return ClusterData{
		Clusters: clusters,
		Weights:  weights,
	}
}

func get_support(clusters ClusterData) []int {
	var sup []int = []int{}
	_ = sup
	var i int = 0
	_ = i
	for i < len(clusters.Weights) {
		var w int = _index(clusters.Weights, i)
		_ = w
		sup = append(sup, ((w * 100) / len(clusters.Weights)))
		i = (i + 1)
	}
	return sup
}

func contains_bits(a string, b string) bool {
	var i int = 0
	_ = i
	for i < len(a) {
		var c1 string = _substr(a, i, (i + 1))
		_ = c1
		var c2 string = _substr(b, i, (i + 1))
		_ = c2
		if (c1 == "1") && (c2 != "1") {
			return false
		}
		i = (i + 1)
	}
	return true
}

func max_cluster_key(clusters ClusterData) int {
	var m int = 0
	_ = m
	var i int = 0
	_ = i
	for i < len(clusters.Weights) {
		var w int = _index(clusters.Weights, i)
		_ = w
		if w > m {
			m = w
		}
		i = (i + 1)
	}
	return m
}

func get_cluster_codes(clusters ClusterData, wt int) []string {
	if func() bool { _, ok := clusters.Clusters[wt]; return ok }() {
		return func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(clusters.Clusters[wt])
	}
	return func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}([]string{})
}

func create_edge(nodes NodesData, graph map[string][]string, gkeys []string, clusters ClusterData, c1 int, maxk int) []string {
	var keys []string = gkeys
	_ = keys
	var codes1 []string = get_cluster_codes(clusters, c1)
	_ = codes1
	var idx1 int = 0
	_ = idx1
	for idx1 < len(codes1) {
		var i_code string = _index(codes1, idx1)
		_ = i_code
		var count int = 0
		_ = count
		var c2 int = (c1 + 1)
		_ = c2
		for c2 <= maxk {
			var codes2 []string = get_cluster_codes(clusters, c2)
			_ = codes2
			var j int = 0
			_ = j
			for j < len(codes2) {
				var j_code string = _index(codes2, j)
				_ = j_code
				if contains_bits(i_code, j_code) {
					if func() bool { _, ok := graph[i_code]; return ok }() {
						graph[i_code] = append(graph[i_code], j_code)
					} else {
						graph[i_code] = []string{j_code}
						if !contains(keys, i_code) {
							keys = append(keys, i_code)
						}
					}
					if !contains(keys, j_code) {
						keys = append(keys, j_code)
					}
					count = (count + 1)
				}
				j = (j + 1)
			}
			if count == 0 {
				c2 = (c2 + 1)
			} else {
				break
			}
		}
		idx1 = (idx1 + 1)
	}
	return keys
}

func construct_graph(clusters ClusterData, nodes NodesData) GraphData {
	var maxk int = max_cluster_key(clusters)
	_ = maxk
	var top_codes []string = get_cluster_codes(clusters, maxk)
	_ = top_codes
	var graph map[string][]string = map[string][]string{}
	_ = graph
	var keys []string = []string{"Header"}
	_ = keys
	graph["Header"] = []string{}
	var i int = 0
	_ = i
	for i < len(top_codes) {
		var code string = _index(top_codes, i)
		_ = code
		graph["Header"] = append(graph["Header"], code)
		graph[code] = []string{"Header"}
		keys = append(keys, code)
		i = (i + 1)
	}
	var c int = 1
	_ = c
	for c < maxk {
		keys = create_edge(nodes, graph, func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(keys), clusters, c, maxk)
		c = (c + 1)
	}
	return GraphData{
		Edges: graph,
		Keys:  keys,
	}
}

var paths [][]string

func copy_list(lst []string) []string {
	var n []string = []string{}
	_ = n
	for _, v := range lst {
		n = append(n, v)
	}
	return n
}

func my_dfs(graph map[string][]string, start string, end string, path []string) {
	var new_path []string = copy_list(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(path))
	_ = new_path
	new_path = append(new_path, start)
	if start == end {
		paths = append(paths, new_path)
		return
	}
	for _, node := range graph[start] {
		var seen bool = false
		_ = seen
		for _, p := range new_path {
			if p == node {
				seen = true
			}
		}
		if !seen {
			my_dfs(graph, node, end, func(v any) []string {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]string); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []string{}
					}
					out := make([]string, len(arr))
					for i, x := range arr {
						out[i] = fmt.Sprint(x)
					}
					return out
				}
				return v.([]string)
			}(new_path))
		}
	}
}

func find_freq_subgraph_given_support(s int, clusters ClusterData, graph GraphData) {
	var k int = ((s * len(clusters.Weights)) / 100)
	_ = k
	var codes []string = get_cluster_codes(clusters, k)
	_ = codes
	var i int = 0
	_ = i
	for i < len(codes) {
		my_dfs(graph.Edges, _index(codes, i), "Header", func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}([]string{}))
		i = (i + 1)
	}
}

func node_edges(nodes NodesData, code string) []string {
	return func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(nodes.Map[code])
}

func freq_subgraphs_edge_list(paths [][]string, nodes NodesData) [][][]string {
	var freq_sub_el [][][]string = [][][]string{}
	_ = freq_sub_el
	for _, path := range paths {
		var el [][]string = [][]string{}
		_ = el
		var j int = 0
		_ = j
		for j < (len(path) - 1) {
			var code string = _index(path, j)
			_ = code
			var edge_list []string = node_edges(nodes, code)
			_ = edge_list
			var e int = 0
			_ = e
			for e < len(edge_list) {
				var edge string = _index(edge_list, e)
				_ = edge
				var a string = _substr(edge, 0, 1)
				_ = a
				var b string = _substr(edge, 1, 2)
				_ = b
				el = append(el, []string{a, b})
				e = (e + 1)
			}
			j = (j + 1)
		}
		freq_sub_el = append(freq_sub_el, el)
	}
	return freq_sub_el
}

func print_all(nodes NodesData, support []int, clusters ClusterData, graph GraphData, freq_subgraph_edge_list [][][]string) {
	fmt.Println("\nNodes\n")
	var i int = 0
	_ = i
	for i < len(nodes.Keys) {
		var code string = _index(nodes.Keys, i)
		_ = code
		fmt.Println(code)
		fmt.Println(func() string {
			b, _ := json.Marshal(nodes.Map[code])
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		i = (i + 1)
	}
	fmt.Println("\nSupport\n")
	fmt.Println(func() string {
		b, _ := json.Marshal(support)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
	fmt.Println("\nCluster\n")
	var j int = 0
	_ = j
	for j < len(clusters.Weights) {
		var w int = _index(clusters.Weights, j)
		_ = w
		fmt.Println(((fmt.Sprint(w) + ":") + fmt.Sprint(clusters.Clusters[w])))
		j = (j + 1)
	}
	fmt.Println("\nGraph\n")
	var k int = 0
	_ = k
	for k < len(graph.Keys) {
		var key string = _index(graph.Keys, k)
		_ = key
		fmt.Println(key)
		fmt.Println(func() string {
			b, _ := json.Marshal(graph.Edges[key])
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		k = (k + 1)
	}
	fmt.Println("\nEdge List of Frequent subgraphs\n")
	for _, el := range freq_subgraph_edge_list {
		fmt.Println(func() string {
			b, _ := json.Marshal(el)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
	}
}

func mochiMain() {
	var frequency_table []map[string]string = get_frequency_table(func(v any) [][][]string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][][]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][][]string{}
			}
			out := make([][][]string, len(arr))
			for i, x := range arr {
				out[i] = func(v any) [][]string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]string{}
						}
						out := make([][]string, len(arr))
						for i, x := range arr {
							out[i] = x.([]string)
						}
						return out
					}
					return v.([][]string)
				}(x)
			}
			return out
		}
		return v.([][][]string)
	}(EDGE_ARRAY))
	_ = frequency_table
	var nodes NodesData = get_nodes(func(v any) []map[string]string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]string{}
			}
			out := make([]map[string]string, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]string)
			}
			return out
		}
		return v.([]map[string]string)
	}(frequency_table))
	_ = nodes
	var clusters ClusterData = get_cluster(nodes)
	_ = clusters
	var support []int = get_support(clusters)
	_ = support
	var graph GraphData = construct_graph(clusters, nodes)
	_ = graph
	find_freq_subgraph_given_support(60, clusters, graph)
	var freq_subgraph_edge_list [][][]string = freq_subgraphs_edge_list(func(v any) [][]string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]string{}
			}
			out := make([][]string, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []string{}
						}
						out := make([]string, len(arr))
						for i, x := range arr {
							out[i] = x.(string)
						}
						return out
					}
					return v.([]string)
				}(x)
			}
			return out
		}
		return v.([][]string)
	}(paths), nodes)
	_ = freq_subgraph_edge_list
	print_all(nodes, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(support), clusters, graph, func(v any) [][][]string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][][]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][][]string{}
			}
			out := make([][][]string, len(arr))
			for i, x := range arr {
				out[i] = func(v any) [][]string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]string{}
						}
						out := make([][]string, len(arr))
						for i, x := range arr {
							out[i] = x.([]string)
						}
						return out
					}
					return v.([][]string)
				}(x)
			}
			return out
		}
		return v.([][][]string)
	}(freq_subgraph_edge_list))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		EDGE_ARRAY = [][][]string{[][]string{[]string{"ab", "e1"}, []string{"ac", "e3"}, []string{"ad", "e5"}, []string{"bc", "e4"}, []string{"bd", "e2"}, []string{"be", "e6"}, []string{"bh", "e12"}, []string{"cd", "e2"}, []string{"ce", "e4"}, []string{"de", "e1"}, []string{"df", "e8"}, []string{"dg", "e5"}, []string{"dh", "e10"}, []string{"ef", "e3"}, []string{"eg", "e2"}, []string{"fg", "e6"}, []string{"gh", "e6"}, []string{"hi", "e3"}}, [][]string{[]string{"ab", "e1"}, []string{"ac", "e3"}, []string{"ad", "e5"}, []string{"bc", "e4"}, []string{"bd", "e2"}, []string{"be", "e6"}, []string{"cd", "e2"}, []string{"de", "e1"}, []string{"df", "e8"}, []string{"ef", "e3"}, []string{"eg", "e2"}, []string{"fg", "e6"}}, [][]string{[]string{"ab", "e1"}, []string{"ac", "e3"}, []string{"bc", "e4"}, []string{"bd", "e2"}, []string{"de", "e1"}, []string{"df", "e8"}, []string{"dg", "e5"}, []string{"ef", "e3"}, []string{"eg", "e2"}, []string{"eh", "e12"}, []string{"fg", "e6"}, []string{"fh", "e10"}, []string{"gh", "e6"}}, [][]string{[]string{"ab", "e1"}, []string{"ac", "e3"}, []string{"bc", "e4"}, []string{"bd", "e2"}, []string{"bh", "e12"}, []string{"cd", "e2"}, []string{"df", "e8"}, []string{"dh", "e10"}}, [][]string{[]string{"ab", "e1"}, []string{"ac", "e3"}, []string{"ad", "e5"}, []string{"bc", "e4"}, []string{"bd", "e2"}, []string{"cd", "e2"}, []string{"ce", "e4"}, []string{"de", "e1"}, []string{"df", "e8"}, []string{"dg", "e5"}, []string{"ef", "e3"}, []string{"eg", "e2"}, []string{"fg", "e6"}}}
		paths = [][]string{}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
