//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 16:09:24 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func is_valid(puzzle [][]string, word string, row int, col int, vertical bool) bool {
	for i := 0; i < len(word); i++ {
		if vertical {
			if ((row + i) >= len(puzzle)) || (puzzle[(row + i)][col] != "") {
				return false
			}
		} else {
			if ((col + i) >= len(puzzle[0])) || (puzzle[row][(col+i)] != "") {
				return false
			}
		}
	}
	return true
}

func place_word(puzzle [][]string, word string, row int, col int, vertical bool) {
	for i := 0; i < len(word); i++ {
		var ch string = string([]rune(word)[i])
		_ = ch
		if vertical {
			puzzle[(row + i)][col] = ch
		} else {
			puzzle[row][(col + i)] = ch
		}
	}
}

func remove_word(puzzle [][]string, word string, row int, col int, vertical bool) {
	for i := 0; i < len(word); i++ {
		if vertical {
			puzzle[(row + i)][col] = ""
		} else {
			puzzle[row][(col + i)] = ""
		}
	}
}

func solve_crossword(puzzle [][]string, words []string, used []bool) bool {
	for row := 0; row < len(puzzle); row++ {
		for col := 0; col < len(puzzle[0]); col++ {
			if puzzle[row][col] == "" {
				for i := 0; i < len(words); i++ {
					if !used[i] {
						var word string = words[i]
						_ = word
						for _, vertical := range []bool{true, false} {
							if is_valid(func(v any) [][]string {
								if v == nil {
									return nil
								}
								if vv, ok := v.([][]string); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return [][]string{}
									}
									out := make([][]string, len(arr))
									for i, x := range arr {
										out[i] = func(v any) []string {
											if v == nil {
												return nil
											}
											if vv, ok := v.([]string); ok {
												return vv
											}
											if arr, ok := v.([]any); ok {
												if len(arr) == 0 {
													return []string{}
												}
												out := make([]string, len(arr))
												for i, x := range arr {
													out[i] = x.(string)
												}
												return out
											}
											return v.([]string)
										}(x)
									}
									return out
								}
								return v.([][]string)
							}(puzzle), word, row, col, vertical) {
								place_word(func(v any) [][]string {
									if v == nil {
										return nil
									}
									if vv, ok := v.([][]string); ok {
										return vv
									}
									if arr, ok := v.([]any); ok {
										if len(arr) == 0 {
											return [][]string{}
										}
										out := make([][]string, len(arr))
										for i, x := range arr {
											out[i] = func(v any) []string {
												if v == nil {
													return nil
												}
												if vv, ok := v.([]string); ok {
													return vv
												}
												if arr, ok := v.([]any); ok {
													if len(arr) == 0 {
														return []string{}
													}
													out := make([]string, len(arr))
													for i, x := range arr {
														out[i] = x.(string)
													}
													return out
												}
												return v.([]string)
											}(x)
										}
										return out
									}
									return v.([][]string)
								}(puzzle), word, row, col, vertical)
								used[i] = true
								if solve_crossword(func(v any) [][]string {
									if v == nil {
										return nil
									}
									if vv, ok := v.([][]string); ok {
										return vv
									}
									if arr, ok := v.([]any); ok {
										if len(arr) == 0 {
											return [][]string{}
										}
										out := make([][]string, len(arr))
										for i, x := range arr {
											out[i] = func(v any) []string {
												if v == nil {
													return nil
												}
												if vv, ok := v.([]string); ok {
													return vv
												}
												if arr, ok := v.([]any); ok {
													if len(arr) == 0 {
														return []string{}
													}
													out := make([]string, len(arr))
													for i, x := range arr {
														out[i] = x.(string)
													}
													return out
												}
												return v.([]string)
											}(x)
										}
										return out
									}
									return v.([][]string)
								}(puzzle), func(v any) []string {
									if v == nil {
										return nil
									}
									if vv, ok := v.([]string); ok {
										return vv
									}
									if arr, ok := v.([]any); ok {
										if len(arr) == 0 {
											return []string{}
										}
										out := make([]string, len(arr))
										for i, x := range arr {
											out[i] = x.(string)
										}
										return out
									}
									return v.([]string)
								}(words), func(v any) []bool {
									if v == nil {
										return nil
									}
									if vv, ok := v.([]bool); ok {
										return vv
									}
									if arr, ok := v.([]any); ok {
										if len(arr) == 0 {
											return []bool{}
										}
										out := make([]bool, len(arr))
										for i, x := range arr {
											out[i] = x.(bool)
										}
										return out
									}
									return v.([]bool)
								}(used)) {
									return true
								}
								used[i] = false
								remove_word(func(v any) [][]string {
									if v == nil {
										return nil
									}
									if vv, ok := v.([][]string); ok {
										return vv
									}
									if arr, ok := v.([]any); ok {
										if len(arr) == 0 {
											return [][]string{}
										}
										out := make([][]string, len(arr))
										for i, x := range arr {
											out[i] = func(v any) []string {
												if v == nil {
													return nil
												}
												if vv, ok := v.([]string); ok {
													return vv
												}
												if arr, ok := v.([]any); ok {
													if len(arr) == 0 {
														return []string{}
													}
													out := make([]string, len(arr))
													for i, x := range arr {
														out[i] = x.(string)
													}
													return out
												}
												return v.([]string)
											}(x)
										}
										return out
									}
									return v.([][]string)
								}(puzzle), word, row, col, vertical)
							}
						}
					}
				}
				return false
			}
		}
	}
	return true
}

var puzzle [][]string

var words []string

var used []bool

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		puzzle = [][]string{[]string{"", "", ""}, []string{"", "", ""}, []string{"", "", ""}}
		words = []string{"cat", "dog", "car"}
		used = []bool{false, false, false}
		if solve_crossword(func(v any) [][]string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]string{}
				}
				out := make([][]string, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []string {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]string); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []string{}
							}
							out := make([]string, len(arr))
							for i, x := range arr {
								out[i] = x.(string)
							}
							return out
						}
						return v.([]string)
					}(x)
				}
				return out
			}
			return v.([][]string)
		}(puzzle), func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(words), func(v any) []bool {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]bool); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []bool{}
				}
				out := make([]bool, len(arr))
				for i, x := range arr {
					out[i] = x.(bool)
				}
				return out
			}
			return v.([]bool)
		}(used)) {
			fmt.Println("Solution found:")
			for _, row := range puzzle {
				fmt.Println(func() string {
					b, _ := json.Marshal(row)
					s := string(b)
					s = strings.ReplaceAll(s, ":", ": ")
					s = strings.ReplaceAll(s, ",", ", ")
					s = strings.ReplaceAll(s, "}, {", "},{")
					return s
				}())
			}
		} else {
			fmt.Println("No solution found:")
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
