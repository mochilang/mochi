//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 17:43:25 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func get_valid_pos(position []int, n int) [][]int {
	var y int = position[0]
	_ = y
	var x int = position[1]
	_ = x
	var positions [][]int = [][]int{[]int{(y + 1), (x + 2)}, []int{(y - 1), (x + 2)}, []int{(y + 1), (x - 2)}, []int{(y - 1), (x - 2)}, []int{(y + 2), (x + 1)}, []int{(y + 2), (x - 1)}, []int{(y - 2), (x + 1)}, []int{(y - 2), (x - 1)}}
	_ = positions
	var permissible [][]int = [][]int{}
	_ = permissible
	for idx := 0; idx < len(positions); idx++ {
		var inner []int = positions[idx]
		_ = inner
		var y_test int = inner[0]
		_ = y_test
		var x_test int = inner[1]
		_ = x_test
		if (((y_test >= 0) && (y_test < n)) && (x_test >= 0)) && (x_test < n) {
			permissible = append(permissible, inner)
		}
	}
	return permissible
}

func is_complete(board [][]int) bool {
	for i := 0; i < len(board); i++ {
		var row []int = board[i]
		_ = row
		for j := 0; j < len(row); j++ {
			if row[j] == 0 {
				return false
			}
		}
	}
	return true
}

func open_knight_tour_helper(board [][]int, pos []int, curr int) bool {
	if is_complete(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(board)) {
		return true
	}
	var moves [][]int = get_valid_pos(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(pos), len(board))
	_ = moves
	for i := 0; i < len(moves); i++ {
		var position []int = moves[i]
		_ = position
		var y int = position[0]
		_ = y
		var x int = position[1]
		_ = x
		if board[y][x] == 0 {
			board[y][x] = (curr + 1)
			if open_knight_tour_helper(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(board), func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(position), (curr + 1)) {
				return true
			}
			board[y][x] = 0
		}
	}
	return false
}

func open_knight_tour(n int) [][]int {
	var board [][]int = [][]int{}
	_ = board
	for i := 0; i < n; i++ {
		var row []int = []int{}
		_ = row
		for j := 0; j < n; j++ {
			row = append(row, 0)
		}
		board = append(board, row)
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			board[i][j] = 1
			if open_knight_tour_helper(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(board), func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}([]int{i, j}), 1) {
				return board
			}
			board[i][j] = 0
		}
	}
	fmt.Println(("Open Knight Tour cannot be performed on a board of size " + fmt.Sprint(n)))
	return board
}

var board [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		board = open_knight_tour(1)
		fmt.Println(board[0][0])
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
