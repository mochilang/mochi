//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 17:43:39 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func is_safe(grid [][]int, row int, column int, n int) bool {
	for i := 0; i < 9; i++ {
		if (grid[row][i] == n) || (grid[i][column] == n) {
			return false
		}
	}
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if grid[((row - (row % 3)) + i)][((column-(column%3))+j)] == n {
				return false
			}
		}
	}
	return true
}

func find_empty_location(grid [][]int) []int {
	for i := 0; i < 9; i++ {
		for j := 0; j < 9; j++ {
			if grid[i][j] == 0 {
				return []int{i, j}
			}
		}
	}
	return func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{})
}

func sudoku(grid [][]int) bool {
	var loc []int = find_empty_location(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(grid))
	_ = loc
	if len(loc) == 0 {
		return true
	}
	var row int = loc[0]
	_ = row
	var column int = loc[1]
	_ = column
	for digit := 1; digit < 10; digit++ {
		if is_safe(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(grid), row, column, digit) {
			grid[row][column] = digit
			if sudoku(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(grid)) {
				return true
			}
			grid[row][column] = 0
		}
	}
	return false
}

func print_solution(grid [][]int) {
	for r := 0; r < len(grid); r++ {
		var line string = ""
		_ = line
		for c := 0; c < len(grid[r]); c++ {
			line = (line + fmt.Sprint(grid[r][c]))
			if c < (len(grid[r]) - 1) {
				line = (line + " ")
			}
		}
		fmt.Println(line)
	}
}

var initial_grid [][]int

var no_solution [][]int

var examples [][][]int

var idx int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		initial_grid = [][]int{[]int{3, 0, 6, 5, 0, 8, 4, 0, 0}, []int{5, 2, 0, 0, 0, 0, 0, 0, 0}, []int{0, 8, 7, 0, 0, 0, 0, 3, 1}, []int{0, 0, 3, 0, 1, 0, 0, 8, 0}, []int{9, 0, 0, 8, 6, 3, 0, 0, 5}, []int{0, 5, 0, 0, 9, 0, 6, 0, 0}, []int{1, 3, 0, 0, 0, 0, 2, 5, 0}, []int{0, 0, 0, 0, 0, 0, 0, 7, 4}, []int{0, 0, 5, 2, 0, 6, 3, 0, 0}}
		no_solution = [][]int{[]int{5, 0, 6, 5, 0, 8, 4, 0, 3}, []int{5, 2, 0, 0, 0, 0, 0, 0, 2}, []int{1, 8, 7, 0, 0, 0, 0, 3, 1}, []int{0, 0, 3, 0, 1, 0, 0, 8, 0}, []int{9, 0, 0, 8, 6, 3, 0, 0, 5}, []int{0, 5, 0, 0, 9, 0, 6, 0, 0}, []int{1, 3, 0, 0, 0, 0, 2, 5, 0}, []int{0, 0, 0, 0, 0, 0, 0, 7, 4}, []int{0, 0, 5, 2, 0, 6, 3, 0, 0}}
		examples = [][][]int{initial_grid, no_solution}
		idx = 0
		for idx < len(examples) {
			fmt.Println("\nExample grid:\n====================")
			print_solution(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(examples[idx]))
			fmt.Println("\nExample grid solution:")
			if sudoku(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(examples[idx])) {
				print_solution(func(v any) [][]int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]int{}
						}
						out := make([][]int, len(arr))
						for i, x := range arr {
							out[i] = func(v any) []int {
								if v == nil {
									return nil
								}
								if vv, ok := v.([]int); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return []int{}
									}
									out := make([]int, len(arr))
									for i, x := range arr {
										out[i] = x.(int)
									}
									return out
								}
								return v.([]int)
							}(x)
						}
						return out
					}
					return v.([][]int)
				}(examples[idx]))
			} else {
				fmt.Println("Cannot find a solution.")
			}
			idx = (idx + 1)
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
