//go:build ignore

// Generated by Mochi v0.10.70 on 2025-08-22 23:15:44 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func parse_int(s string) int {
	var value int = 0
	_ = value
	var i int = 0
	_ = i
	for i < len(s) {
		var c string = string(_index([]rune(s), i))
		_ = c
		_ = c
		value = ((value * 10) + func() int { n, _ := strconv.Atoi(fmt.Sprint(c)); return n }())
		i = (i + 1)
	}
	return value
}

func join(xs []string) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < len(xs) {
		s = (s + _index(xs, i))
		i = (i + 1)
	}
	return s
}

func contains(xs []string, c string) bool {
	var i int = 0
	_ = i
	for i < len(xs) {
		if _index(xs, i) == c {
			return true
		}
		i = (i + 1)
	}
	return false
}

func index_of(xs []string, c string) int {
	var i int = 0
	_ = i
	for i < len(xs) {
		if _index(xs, i) == c {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func remove_at(xs []string, idx int) []string {
	var res []string = []string{}
	_ = res
	var i int = 0
	_ = i
	for i < len(xs) {
		if i != idx {
			res = append(res, _index(xs, i))
		}
		i = (i + 1)
	}
	return res
}

func unique_chars(logins []string) []string {
	var chars []string = []string{}
	_ = chars
	var i int = 0
	_ = i
	for i < len(logins) {
		var login string = _index(logins, i)
		_ = login
		var j int = 0
		_ = j
		for j < len(login) {
			var c string = string(_index([]rune(login), j))
			_ = c
			if !contains(chars, c) {
				chars = append(chars, c)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return chars
}

func satisfies(permutation []string, logins []string) bool {
	var i int = 0
	_ = i
	for i < len(logins) {
		var login string = _index(logins, i)
		_ = login
		_ = login
		var i0 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(permutation), string(_index([]rune(login), 0)))
		_ = i0
		var i1 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(permutation), string(_index([]rune(login), 1)))
		_ = i1
		var i2 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(permutation), string(_index([]rune(login), 2)))
		_ = i2
		if !((i0 < i1) && (i1 < i2)) {
			return false
		}
		i = (i + 1)
	}
	return true
}

func search(chars []string, current []string, logins []string) string {
	if len(chars) == 0 {
		if satisfies(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(current), func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(logins)) {
			return join(func(v any) []string {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]string); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []string{}
					}
					out := make([]string, len(arr))
					for i, x := range arr {
						out[i] = fmt.Sprint(x)
					}
					return out
				}
				return v.([]string)
			}(current))
		}
		return ""
	}
	var i int = 0
	_ = i
	for i < len(chars) {
		var c string = _index(chars, i)
		_ = c
		var rest []string = remove_at(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(chars), i)
		_ = rest
		var next []string = append(current, c)
		_ = next
		var res string = search(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(rest), func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(next), func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(logins))
		_ = res
		if res != "" {
			return res
		}
		i = (i + 1)
	}
	return ""
}

func find_secret_passcode(logins []string) int {
	var chars []string = unique_chars(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(logins))
	_ = chars
	var s string = search(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(chars), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}([]string{}), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(logins))
	_ = s
	if s == "" {
		return (0 - 1)
	}
	return parse_int(s)
}

var logins1 []string

var logins2 []string

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		logins1 = []string{"135", "259", "235", "189", "690", "168", "120", "136", "289", "589", "160", "165", "580", "369", "250", "280"}
		fmt.Println(fmt.Sprint(find_secret_passcode(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(logins1))))
		logins2 = []string{"426", "281", "061", "819", "268", "406", "420", "428", "209", "689", "019", "421", "469", "261", "681", "201"}
		fmt.Println(fmt.Sprint(find_secret_passcode(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(logins2))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
