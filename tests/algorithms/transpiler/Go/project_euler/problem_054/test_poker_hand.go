//go:build ignore

// Generated by Mochi v0.10.70 on 2025-08-22 15:33:58 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func split(s string, sep string) []string {
	var parts []string = []string{}
	_ = parts
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		if ((len(sep) > 0) && ((i + len(sep)) <= len(s))) && (_substr(s, i, (i+len(sep))) == sep) {
			parts = append(parts, cur)
			cur = ""
			i = (i + len(sep))
		} else {
			cur = (cur + string([]rune(s)[i:(i+1)]))
			i = (i + 1)
		}
	}
	parts = append(parts, cur)
	return parts
}

func card_value(ch string) int {
	if ch == "A" {
		return 14
	} else {
		if ch == "K" {
			return 13
		} else {
			if ch == "Q" {
				return 12
			} else {
				if ch == "J" {
					return 11
				} else {
					if ch == "T" {
						return 10
					} else {
						if ch == "9" {
							return 9
						} else {
							if ch == "8" {
								return 8
							} else {
								if ch == "7" {
									return 7
								} else {
									if ch == "6" {
										return 6
									} else {
										if ch == "5" {
											return 5
										} else {
											if ch == "4" {
												return 4
											} else {
												if ch == "3" {
													return 3
												} else {
													return 2
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

type Hand struct {
	Rank   int   `json:"rank"`
	Values []int `json:"values"`
}

func parse_hand(hand string) Hand {
	var counts []int = []int{}
	_ = counts
	var i int = 0
	_ = i
	for i <= 14 {
		counts = append(counts, 0)
		i = (i + 1)
	}
	var suits []string = []string{}
	_ = suits
	for _, card := range split(hand, " ") {
		_ = card
		var v int = card_value(string([]rune(card)[0:1]))
		_ = v
		_setIndex(counts, v, (_index(counts, v) + 1))
		suits = append(suits, string([]rune(card)[1:2]))
	}
	var vals []int = []int{}
	_ = vals
	var v int = 14
	_ = v
	for v >= 2 {
		var c int = _index(counts, v)
		_ = c
		var k int = 0
		_ = k
		for k < c {
			vals = append(vals, v)
			k = (k + 1)
		}
		v = (v - 1)
	}
	var is_straight bool = false
	_ = is_straight
	if (((((len(vals) == 5) && (_index(vals, 0) == 14)) && (_index(vals, 1) == 5)) && (_index(vals, 2) == 4)) && (_index(vals, 3) == 3)) && (_index(vals, 4) == 2) {
		is_straight = true
		_setIndex(vals, 0, 5)
		_setIndex(vals, 1, 4)
		_setIndex(vals, 2, 3)
		_setIndex(vals, 3, 2)
		_setIndex(vals, 4, 14)
	} else {
		is_straight = true
		var j int = 0
		_ = j
		for j < 4 {
			if (_index(vals, j) - _index(vals, (j+1))) != 1 {
				is_straight = false
			}
			j = (j + 1)
		}
	}
	var is_flush bool = true
	_ = is_flush
	var s0 string = _index(suits, 0)
	_ = s0
	var t int = 1
	_ = t
	for t < len(suits) {
		if _index(suits, t) != s0 {
			is_flush = false
		}
		t = (t + 1)
	}
	var four_val int = 0
	_ = four_val
	var three_val int = 0
	_ = three_val
	var pair_vals []int = []int{}
	_ = pair_vals
	v = 14
	for v >= 2 {
		if _index(counts, v) == 4 {
			four_val = v
		} else {
			if _index(counts, v) == 3 {
				three_val = v
			} else {
				if _index(counts, v) == 2 {
					pair_vals = append(pair_vals, v)
				}
			}
		}
		v = (v - 1)
	}
	var rank int = 1
	_ = rank
	if ((is_flush && is_straight) && (_index(vals, 0) == 14)) && (_index(vals, 4) == 10) {
		rank = 10
	} else {
		if is_flush && is_straight {
			rank = 9
		} else {
			if four_val != 0 {
				rank = 8
			} else {
				if (three_val != 0) && (len(pair_vals) == 1) {
					rank = 7
				} else {
					if is_flush {
						rank = 6
					} else {
						if is_straight {
							rank = 5
						} else {
							if three_val != 0 {
								rank = 4
							} else {
								if len(pair_vals) == 2 {
									rank = 3
								} else {
									if len(pair_vals) == 1 {
										rank = 2
									} else {
										rank = 1
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return Hand{
		Rank:   rank,
		Values: vals,
	}
}

func compare(a Hand, b Hand) string {
	if a.Rank > b.Rank {
		return "Win"
	}
	if a.Rank < b.Rank {
		return "Loss"
	}
	var i int = 0
	_ = i
	for i < len(a.Values) {
		if _index(a.Values, i) > _index(b.Values, i) {
			return "Win"
		}
		if _index(a.Values, i) < _index(b.Values, i) {
			return "Loss"
		}
		i = (i + 1)
	}
	return "Tie"
}

func mochiMain() {
	var tests [][]string = [][]string{[]string{"2H 3H 4H 5H 6H", "KS AS TS QS JS", "Loss"}, []string{"2H 3H 4H 5H 6H", "AS AD AC AH JD", "Win"}, []string{"AS AH 2H AD AC", "JS JD JC JH 3D", "Win"}, []string{"2S AH 2H AS AC", "JS JD JC JH AD", "Loss"}, []string{"2S AH 2H AS AC", "2H 3H 5H 6H 7H", "Win"}}
	_ = tests
	for _, t := range tests {
		_ = t
		var res string = compare(parse_hand(_index(t, 0)), parse_hand(_index(t, 1)))
		_ = res
		fmt.Println(((res + " expected ") + _index(t, 2)))
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
