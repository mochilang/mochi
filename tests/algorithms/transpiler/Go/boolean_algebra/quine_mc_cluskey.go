//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:05:06 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func compare_string(string1 string, string2 string) string {
	var result string = ""
	_ = result
	var count int = 0
	_ = count
	var i int = 0
	_ = i
	for i < len(string1) {
		var c1 string = _substr(string1, i, (i + 1))
		_ = c1
		var c2 string = _substr(string2, i, (i + 1))
		_ = c2
		if c1 != c2 {
			count = (count + 1)
			result = (result + "_")
		} else {
			result = (result + c1)
		}
		i = (i + 1)
	}
	if count > 1 {
		return ""
	}
	return result
}

func contains_string(arr []string, value string) bool {
	var i int = 0
	_ = i
	for i < len(arr) {
		if arr[i] == value {
			return true
		}
		i = (i + 1)
	}
	return false
}

func unique_strings(arr []string) []string {
	var res []string = []string{}
	_ = res
	var i int = 0
	_ = i
	for i < len(arr) {
		if !contains_string(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(res), arr[i]) {
			res = append(res, arr[i])
		}
		i = (i + 1)
	}
	return res
}

func check(binary []string) []string {
	var pi []string = []string{}
	_ = pi
	var current []string = binary
	_ = current
	for {
		var check1 []string = []string{}
		_ = check1
		var i int = 0
		_ = i
		for i < len(current) {
			check1 = append(check1, "$")
			i = (i + 1)
		}
		var temp []string = []string{}
		_ = temp
		i = 0
		for i < len(current) {
			var j int = (i + 1)
			_ = j
			for j < len(current) {
				var k string = compare_string(current[i], current[j])
				_ = k
				if k == "" {
					check1[i] = "*"
					check1[j] = "*"
					temp = append(temp, "X")
				}
				j = (j + 1)
			}
			i = (i + 1)
		}
		i = 0
		for i < len(current) {
			if check1[i] == "$" {
				pi = append(pi, current[i])
			}
			i = (i + 1)
		}
		if len(temp) == 0 {
			return pi
		}
		current = unique_strings(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(temp))
	}
}

func decimal_to_binary(no_of_variable int, minterms []int) []string {
	var temp []string = []string{}
	_ = temp
	var idx int = 0
	_ = idx
	for idx < len(minterms) {
		var minterm int = minterms[idx]
		_ = minterm
		var string string = ""
		_ = string
		var i int = 0
		_ = i
		for i < no_of_variable {
			string = (fmt.Sprint((minterm % 2)) + string)
			minterm = (minterm / 2)
			i = (i + 1)
		}
		temp = append(temp, string)
		idx = (idx + 1)
	}
	return temp
}

func is_for_table(string1 string, string2 string, count int) bool {
	var count_n int = 0
	_ = count_n
	var i int = 0
	_ = i
	for i < len(string1) {
		var c1 string = _substr(string1, i, (i + 1))
		_ = c1
		var c2 string = _substr(string2, i, (i + 1))
		_ = c2
		if c1 != c2 {
			count_n = (count_n + 1)
		}
		i = (i + 1)
	}
	return (count_n == count)
}

func count_ones(row []int) int {
	var c int = 0
	_ = c
	var j int = 0
	_ = j
	for j < len(row) {
		if row[j] == 1 {
			c = (c + 1)
		}
		j = (j + 1)
	}
	return c
}

func selection(chart [][]int, prime_implicants []string) []string {
	var temp []string = []string{}
	_ = temp
	var select_ []int = []int{}
	_ = select_
	var i int = 0
	_ = i
	for i < len(chart) {
		select_ = append(select_, 0)
		i = (i + 1)
	}
	var col int = 0
	_ = col
	for col < len(chart[0]) {
		var count int = 0
		_ = count
		var row int = 0
		_ = row
		for row < len(chart) {
			if chart[row][col] == 1 {
				count = (count + 1)
			}
			row = (row + 1)
		}
		if count == 1 {
			var rem int = 0
			_ = rem
			row = 0
			for row < len(chart) {
				if chart[row][col] == 1 {
					rem = row
				}
				row = (row + 1)
			}
			select_[rem] = 1
		}
		col = (col + 1)
	}
	i = 0
	for i < len(select_) {
		if select_[i] == 1 {
			var j int = 0
			_ = j
			for j < len(chart[0]) {
				if chart[i][j] == 1 {
					var r int = 0
					_ = r
					for r < len(chart) {
						chart[r][j] = 0
						r = (r + 1)
					}
				}
				j = (j + 1)
			}
			temp = append(temp, prime_implicants[i])
		}
		i = (i + 1)
	}
	for {
		var counts []int = []int{}
		_ = counts
		var r int = 0
		_ = r
		for r < len(chart) {
			counts = append(counts, count_ones(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(chart[r])))
			r = (r + 1)
		}
		var max_n int = counts[0]
		_ = max_n
		var rem int = 0
		_ = rem
		var k int = 1
		_ = k
		for k < len(counts) {
			if counts[k] > max_n {
				max_n = counts[k]
				rem = k
			}
			k = (k + 1)
		}
		if max_n == 0 {
			return temp
		}
		temp = append(temp, prime_implicants[rem])
		var j int = 0
		_ = j
		for j < len(chart[0]) {
			if chart[rem][j] == 1 {
				var r2 int = 0
				_ = r2
				for r2 < len(chart) {
					chart[r2][j] = 0
					r2 = (r2 + 1)
				}
			}
			j = (j + 1)
		}
	}
}

func count_char(s string, ch string) int {
	var cnt int = 0
	_ = cnt
	var i int = 0
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			cnt = (cnt + 1)
		}
		i = (i + 1)
	}
	return cnt
}

func prime_implicant_chart(prime_implicants []string, binary []string) [][]int {
	var chart [][]int = [][]int{}
	_ = chart
	var i int = 0
	_ = i
	for i < len(prime_implicants) {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < len(binary) {
			row = append(row, 0)
			j = (j + 1)
		}
		chart = append(chart, row)
		i = (i + 1)
	}
	i = 0
	for i < len(prime_implicants) {
		var count int = count_char(prime_implicants[i], "_")
		_ = count
		var j int = 0
		_ = j
		for j < len(binary) {
			if is_for_table(prime_implicants[i], binary[j], count) {
				chart[i][j] = 1
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return chart
}

func mochiMain() {
	var no_of_variable int = 3
	_ = no_of_variable
	var minterms []int = []int{1, 5, 7}
	_ = minterms
	var binary []string = decimal_to_binary(no_of_variable, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(minterms))
	_ = binary
	var prime_implicants []string = check(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(binary))
	_ = prime_implicants
	fmt.Println("Prime Implicants are:")
	fmt.Println(fmt.Sprint(prime_implicants))
	var chart [][]int = prime_implicant_chart(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(prime_implicants), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(binary))
	_ = chart
	var essential_prime_implicants []string = selection(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(chart), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(prime_implicants))
	_ = essential_prime_implicants
	fmt.Println("Essential Prime Implicants are:")
	fmt.Println(fmt.Sprint(essential_prime_implicants))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
