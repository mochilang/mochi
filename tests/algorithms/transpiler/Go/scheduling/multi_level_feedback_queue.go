//go:build ignore

// Generated by Mochi v0.10.70 on 2025-08-22 23:16:00 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _concat[T any](a, b []T) []T {
	return append(append([]T{}, a...), b...)
}

type Process struct {
	ProcessName    string `json:"process_name"`
	ArrivalTime    int    `json:"arrival_time"`
	StopTime       int    `json:"stop_time"`
	BurstTime      int    `json:"burst_time"`
	WaitingTime    int    `json:"waiting_time"`
	TurnaroundTime int    `json:"turnaround_time"`
}

func make_process(name string, arrival int, burst int) Process {
	return Process{
		ProcessName:    name,
		ArrivalTime:    arrival,
		StopTime:       arrival,
		BurstTime:      burst,
		WaitingTime:    0,
		TurnaroundTime: 0,
	}
}

type MLFQ struct {
	NumberOfQueues int       `json:"number_of_queues"`
	TimeSlices     []int     `json:"time_slices"`
	ReadyQueue     []Process `json:"ready_queue"`
	CurrentTime    int       `json:"current_time"`
	FinishQueue    []Process `json:"finish_queue"`
}

func make_mlfq(nqueues int, time_slices []int, queue []Process, current_time int) MLFQ {
	return MLFQ{
		NumberOfQueues: nqueues,
		TimeSlices:     time_slices,
		ReadyQueue:     queue,
		CurrentTime:    current_time,
		FinishQueue:    []Process{},
	}
}

func calculate_sequence_of_finish_queue(mlfq MLFQ) []string {
	var seq []string = []string{}
	_ = seq
	var i int = 0
	_ = i
	for i < len(mlfq.FinishQueue) {
		var p Process = _index(mlfq.FinishQueue, i)
		_ = p
		seq = append(seq, p.ProcessName)
		i = (i + 1)
	}
	return seq
}

func calculate_waiting_time(queue []Process) []int {
	var times []int = []int{}
	_ = times
	var i int = 0
	_ = i
	for i < len(queue) {
		var p Process = _index(queue, i)
		_ = p
		times = append(times, p.WaitingTime)
		i = (i + 1)
	}
	return times
}

func calculate_turnaround_time(queue []Process) []int {
	var times []int = []int{}
	_ = times
	var i int = 0
	_ = i
	for i < len(queue) {
		var p Process = _index(queue, i)
		_ = p
		times = append(times, p.TurnaroundTime)
		i = (i + 1)
	}
	return times
}

func calculate_completion_time(queue []Process) []int {
	var times []int = []int{}
	_ = times
	var i int = 0
	_ = i
	for i < len(queue) {
		var p Process = _index(queue, i)
		_ = p
		times = append(times, p.StopTime)
		i = (i + 1)
	}
	return times
}

func calculate_remaining_burst_time_of_processes(queue []Process) []int {
	var times []int = []int{}
	_ = times
	var i int = 0
	_ = i
	for i < len(queue) {
		var p Process = _index(queue, i)
		_ = p
		times = append(times, p.BurstTime)
		i = (i + 1)
	}
	return times
}

func update_waiting_time(mlfq MLFQ, process Process) int {
	process.WaitingTime = (process.WaitingTime + (mlfq.CurrentTime - process.StopTime))
	return process.WaitingTime
}

func first_come_first_served(mlfq *MLFQ, ready_queue []Process) []Process {
	var finished []Process = []Process{}
	_ = finished
	var rq []Process = ready_queue
	_ = rq
	for len(rq) != 0 {
		var cp Process = _index(rq, 0)
		_ = cp
		rq = _slice(rq, 1, len(rq))
		if mlfq.CurrentTime < cp.ArrivalTime {
			mlfq.CurrentTime = cp.ArrivalTime
		}
		update_waiting_time(*mlfq, cp)
		mlfq.CurrentTime = (mlfq.CurrentTime + cp.BurstTime)
		cp.BurstTime = 0
		cp.TurnaroundTime = (mlfq.CurrentTime - cp.ArrivalTime)
		cp.StopTime = mlfq.CurrentTime
		finished = append(finished, cp)
	}
	mlfq.FinishQueue = _concat(mlfq.FinishQueue, finished)
	return finished
}

type RRResult struct {
	Finished []Process `json:"finished"`
	Ready    []Process `json:"ready"`
}

func round_robin(mlfq *MLFQ, ready_queue []Process, time_slice int) RRResult {
	var finished []Process = []Process{}
	_ = finished
	var rq []Process = ready_queue
	_ = rq
	var count int = len(rq)
	_ = count
	var i int = 0
	_ = i
	for i < count {
		var cp Process = _index(rq, 0)
		_ = cp
		rq = _slice(rq, 1, len(rq))
		if mlfq.CurrentTime < cp.ArrivalTime {
			mlfq.CurrentTime = cp.ArrivalTime
		}
		update_waiting_time(*mlfq, cp)
		if cp.BurstTime > time_slice {
			mlfq.CurrentTime = (mlfq.CurrentTime + time_slice)
			cp.BurstTime = (cp.BurstTime - time_slice)
			cp.StopTime = mlfq.CurrentTime
			rq = append(rq, cp)
		} else {
			mlfq.CurrentTime = (mlfq.CurrentTime + cp.BurstTime)
			cp.BurstTime = 0
			cp.StopTime = mlfq.CurrentTime
			cp.TurnaroundTime = (mlfq.CurrentTime - cp.ArrivalTime)
			finished = append(finished, cp)
		}
		i = (i + 1)
	}
	mlfq.FinishQueue = _concat(mlfq.FinishQueue, finished)
	return RRResult{
		Finished: finished,
		Ready:    rq,
	}
}

func multi_level_feedback_queue(mlfq MLFQ) []Process {
	var i int = 0
	_ = i
	for i < (mlfq.NumberOfQueues - 1) {
		var rr RRResult = round_robin(&mlfq, func(v any) []Process {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Process); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Process{}
				}
				out := make([]Process, len(arr))
				for i, x := range arr {
					out[i] = x.(Process)
				}
				return out
			}
			return v.([]Process)
		}(mlfq.ReadyQueue), _index(mlfq.TimeSlices, i))
		_ = rr
		mlfq.ReadyQueue = rr.Ready
		i = (i + 1)
	}
	first_come_first_served(&mlfq, func(v any) []Process {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Process); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Process{}
			}
			out := make([]Process, len(arr))
			for i, x := range arr {
				out[i] = x.(Process)
			}
			return out
		}
		return v.([]Process)
	}(mlfq.ReadyQueue))
	return mlfq.FinishQueue
}

var P1 Process

var P2 Process

var P3 Process

var P4 Process

var number_of_queues int

var time_slices []int

var queue []Process

var mlfq MLFQ

var finish_queue []Process

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		P1 = make_process("P1", 0, 53)
		P2 = make_process("P2", 0, 17)
		P3 = make_process("P3", 0, 68)
		P4 = make_process("P4", 0, 24)
		number_of_queues = 3
		time_slices = []int{17, 25}
		queue = []Process{P1, P2, P3, P4}
		mlfq = make_mlfq(number_of_queues, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(time_slices), func(v any) []Process {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Process); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Process{}
				}
				out := make([]Process, len(arr))
				for i, x := range arr {
					out[i] = x.(Process)
				}
				return out
			}
			return v.([]Process)
		}(queue), 0)
		finish_queue = multi_level_feedback_queue(mlfq)
		fmt.Println(("waiting time:\t\t\t" + fmt.Sprint(calculate_waiting_time(func(v any) []Process {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Process); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Process{}
				}
				out := make([]Process, len(arr))
				for i, x := range arr {
					out[i] = x.(Process)
				}
				return out
			}
			return v.([]Process)
		}([]Process{P1, P2, P3, P4})))))
		fmt.Println(("completion time:\t\t" + fmt.Sprint(calculate_completion_time(func(v any) []Process {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Process); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Process{}
				}
				out := make([]Process, len(arr))
				for i, x := range arr {
					out[i] = x.(Process)
				}
				return out
			}
			return v.([]Process)
		}([]Process{P1, P2, P3, P4})))))
		fmt.Println(("turnaround time:\t\t" + fmt.Sprint(calculate_turnaround_time(func(v any) []Process {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Process); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Process{}
				}
				out := make([]Process, len(arr))
				for i, x := range arr {
					out[i] = x.(Process)
				}
				return out
			}
			return v.([]Process)
		}([]Process{P1, P2, P3, P4})))))
		fmt.Println(("sequence of finished processes:\t" + fmt.Sprint(calculate_sequence_of_finish_queue(mlfq))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
