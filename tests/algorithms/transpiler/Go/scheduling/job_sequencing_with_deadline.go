//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-11 16:26:34 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Job struct {
	ID       int `json:"id"`
	Deadline int `json:"deadline"`
	Profit   int `json:"profit"`
}

func sort_jobs_by_profit(jobs []Job) []Job {
	var js []Job = jobs
	_ = js
	var i int = 0
	_ = i
	for i < len(js) {
		var j int = 0
		_ = j
		for j < ((len(js) - i) - 1) {
			var a Job = _index(js, j)
			_ = a
			var b Job = _index(js, (j + 1))
			_ = b
			if a.Profit < b.Profit {
				_setIndex(js, j, b)
				_setIndex(js, (j + 1), a)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return js
}

func max_deadline(jobs []Job) int {
	var max_d int = 0
	_ = max_d
	var i int = 0
	_ = i
	for i < len(jobs) {
		var job Job = _index(jobs, i)
		_ = job
		var d int = job.Deadline
		_ = d
		if d > max_d {
			max_d = d
		}
		i = (i + 1)
	}
	return max_d
}

func job_sequencing_with_deadlines(jobs []Job) []int {
	var js []Job = sort_jobs_by_profit(func(v any) []Job {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Job); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Job{}
			}
			out := make([]Job, len(arr))
			for i, x := range arr {
				out[i] = x.(Job)
			}
			return out
		}
		return v.([]Job)
	}(jobs))
	_ = js
	max_d := max_deadline(func(v any) []Job {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Job); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Job{}
			}
			out := make([]Job, len(arr))
			for i, x := range arr {
				out[i] = x.(Job)
			}
			return out
		}
		return v.([]Job)
	}(js))
	_ = max_d
	var time_slots []int = []int{}
	_ = time_slots
	var t int = 0
	_ = t
	for t < max_d {
		time_slots = append(time_slots, (0 - 1))
		t = (t + 1)
	}
	var count int = 0
	_ = count
	var max_profit int = 0
	_ = max_profit
	var i int = 0
	_ = i
	for i < len(js) {
		var job Job = _index(js, i)
		_ = job
		var j int = (job.Deadline - 1)
		_ = j
		for j >= 0 {
			if int(_index(time_slots, j)) == (0 - 1) {
				_setIndex(time_slots, j, job.ID)
				count = (count + 1)
				max_profit = (max_profit + job.Profit)
				break
			}
			j = (j - 1)
		}
		i = (i + 1)
	}
	var result []int = []int{}
	_ = result
	result = append(result, count)
	result = append(result, max_profit)
	return result
}

var jobs1 []Job

var jobs2 []Job

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		jobs1 = []Job{}
		jobs1 = append(jobs1, Job{
			ID:       1,
			Deadline: 4,
			Profit:   20,
		})
		jobs1 = append(jobs1, Job{
			ID:       2,
			Deadline: 1,
			Profit:   10,
		})
		jobs1 = append(jobs1, Job{
			ID:       3,
			Deadline: 1,
			Profit:   40,
		})
		jobs1 = append(jobs1, Job{
			ID:       4,
			Deadline: 1,
			Profit:   30,
		})
		fmt.Println(fmt.Sprint(job_sequencing_with_deadlines(func(v any) []Job {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Job); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Job{}
				}
				out := make([]Job, len(arr))
				for i, x := range arr {
					out[i] = x.(Job)
				}
				return out
			}
			return v.([]Job)
		}(jobs1))))
		jobs2 = []Job{}
		jobs2 = append(jobs2, Job{
			ID:       1,
			Deadline: 2,
			Profit:   100,
		})
		jobs2 = append(jobs2, Job{
			ID:       2,
			Deadline: 1,
			Profit:   19,
		})
		jobs2 = append(jobs2, Job{
			ID:       3,
			Deadline: 2,
			Profit:   27,
		})
		jobs2 = append(jobs2, Job{
			ID:       4,
			Deadline: 1,
			Profit:   25,
		})
		jobs2 = append(jobs2, Job{
			ID:       5,
			Deadline: 1,
			Profit:   15,
		})
		fmt.Println(fmt.Sprint(job_sequencing_with_deadlines(func(v any) []Job {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Job); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Job{}
				}
				out := make([]Job, len(arr))
				for i, x := range arr {
					out[i] = x.(Job)
				}
				return out
			}
			return v.([]Job)
		}(jobs2))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
