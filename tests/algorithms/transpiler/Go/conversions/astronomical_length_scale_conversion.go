//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:46:44 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

var UNIT_SYMBOL map[string]string

var METRIC_CONVERSION map[string]int

var ABBREVIATIONS string

func sanitize(unit string) string {
	var res string = strings.ToLower(unit)
	_ = res
	if len(res) > 0 {
		var last string = _substr(res, (len(res) - 1), len(res))
		_ = last
		if last == "s" {
			res = _substr(res, 0, (len(res) - 1))
		}
	}
	if func() bool { _, ok := UNIT_SYMBOL[res]; return ok }() {
		return UNIT_SYMBOL[res]
	}
	return res
}

func pow10(exp int) float64 {
	if exp == 0 {
		return 1.0
	}
	var e int = exp
	_ = e
	var res float64 = 1.0
	_ = res
	if e < 0 {
		e = (0 - e)
	}
	var i int = 0
	_ = i
	for i < e {
		res = (res * 10.0)
		i = (i + 1)
	}
	if exp < 0 {
		return (1.0 / res)
	}
	return res
}

func length_conversion(value float64, from_type string, to_type string) float64 {
	var from_sanitized string = sanitize(from_type)
	_ = from_sanitized
	var to_sanitized string = sanitize(to_type)
	_ = to_sanitized
	if !func() bool { _, ok := METRIC_CONVERSION[from_sanitized]; return ok }() {
		panic(((("Invalid 'from_type' value: '" + from_type) + "'.\nConversion abbreviations are: ") + ABBREVIATIONS))
	}
	if !func() bool { _, ok := METRIC_CONVERSION[to_sanitized]; return ok }() {
		panic(((("Invalid 'to_type' value: '" + to_type) + "'.\nConversion abbreviations are: ") + ABBREVIATIONS))
	}
	var from_exp int = METRIC_CONVERSION[from_sanitized]
	_ = from_exp
	var to_exp int = METRIC_CONVERSION[to_sanitized]
	_ = to_exp
	var exponent int = 0
	_ = exponent
	if from_exp > to_exp {
		exponent = (from_exp - to_exp)
	} else {
		exponent = (0 - (to_exp - from_exp))
	}
	return (value * pow10(exponent))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		UNIT_SYMBOL = map[string]string{"meter": "m", "kilometer": "km", "megametre": "Mm", "gigametre": "Gm", "terametre": "Tm", "petametre": "Pm", "exametre": "Em", "zettametre": "Zm", "yottametre": "Ym"}
		METRIC_CONVERSION = map[string]int{"m": 0, "km": 3, "Mm": 6, "Gm": 9, "Tm": 12, "Pm": 15, "Em": 18, "Zm": 21, "Ym": 24}
		ABBREVIATIONS = "m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym"
		fmt.Println(fmt.Sprint(length_conversion(1.0, "meter", "kilometer")))
		fmt.Println(fmt.Sprint(length_conversion(1.0, "meter", "megametre")))
		fmt.Println(fmt.Sprint(length_conversion(1.0, "gigametre", "meter")))
		fmt.Println(fmt.Sprint(length_conversion(1.0, "terametre", "zettametre")))
		fmt.Println(fmt.Sprint(length_conversion(1.0, "yottametre", "zettametre")))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
