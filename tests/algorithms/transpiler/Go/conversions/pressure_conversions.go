//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:47:24 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type FromTo struct {
	FromFactor float64 `json:"from_factor"`
	ToFactor   float64 `json:"to_factor"`
}

var PRESSURE_CONVERSION map[string]FromTo

func pressure_conversion(value float64, from_type string, to_type string) float64 {
	if !func() bool { _, ok := PRESSURE_CONVERSION[from_type]; return ok }() {
		var keys []any = Object.keys(PRESSURE_CONVERSION)
		_ = keys
		panic(((("Invalid 'from_type' value: '" + from_type) + "'  Supported values are:\n") + fmt.Sprint(keys)))
	}
	if !func() bool { _, ok := PRESSURE_CONVERSION[to_type]; return ok }() {
		var keys []any = Object.keys(PRESSURE_CONVERSION)
		_ = keys
		panic(((("Invalid 'to_type' value: '" + to_type) + ".  Supported values are:\n") + fmt.Sprint(keys)))
	}
	var from FromTo = PRESSURE_CONVERSION[from_type]
	_ = from
	_ = from
	var to FromTo = PRESSURE_CONVERSION[to_type]
	_ = to
	_ = to
	return ((value * from.FromFactor) * to.ToFactor)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PRESSURE_CONVERSION = map[string]FromTo{"atm": FromTo{
			FromFactor: 1.0,
			ToFactor:   1.0,
		}, "pascal": FromTo{
			FromFactor: 9.8e-06,
			ToFactor:   101325.0,
		}, "bar": FromTo{
			FromFactor: 0.986923,
			ToFactor:   1.01325,
		}, "kilopascal": FromTo{
			FromFactor: 0.00986923,
			ToFactor:   101.325,
		}, "megapascal": FromTo{
			FromFactor: 9.86923,
			ToFactor:   0.101325,
		}, "psi": FromTo{
			FromFactor: 0.068046,
			ToFactor:   14.6959,
		}, "inHg": FromTo{
			FromFactor: 0.0334211,
			ToFactor:   29.9213,
		}, "torr": FromTo{
			FromFactor: 0.00131579,
			ToFactor:   760.0,
		}}
		fmt.Println(func() string {
			f := float64(pressure_conversion(4.0, "atm", "pascal"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(1.0, "pascal", "psi"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(1.0, "bar", "atm"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(3.0, "kilopascal", "bar"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(2.0, "megapascal", "psi"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(4.0, "psi", "torr"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(1.0, "inHg", "atm"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(pressure_conversion(1.0, "torr", "psi"))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
