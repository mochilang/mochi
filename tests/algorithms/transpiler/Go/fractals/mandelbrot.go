//go:build ignore

// Generated by Mochi v0.10.62 on 2025-08-09 16:24:58 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

type RGB struct {
	R int `json:"r"`
	G int `json:"g"`
	B int `json:"b"`
}

func round_int(x float64) int {
	return func() int { n, _ := strconv.Atoi(fmt.Sprint((x + 0.5))); return n }()
}

func hsv_to_rgb(h float64, s float64, v float64) RGB {
	var i int = func() int { n, _ := strconv.Atoi(fmt.Sprint((h * 6.0))); return n }()
	_ = i
	var f float64 = ((h * 6.0) - float64(i))
	_ = f
	var p float64 = (v * (1.0 - s))
	_ = p
	var q float64 = (v * (1.0 - (f * s)))
	_ = q
	var t float64 = (v * (1.0 - ((1.0 - f) * s)))
	_ = t
	var mod int = _mod(i, 6)
	_ = mod
	var r float64 = 0.0
	_ = r
	var g float64 = 0.0
	_ = g
	var b float64 = 0.0
	_ = b
	if mod == 0 {
		r = v
		g = t
		b = p
	} else {
		if mod == 1 {
			r = q
			g = v
			b = p
		} else {
			if mod == 2 {
				r = p
				g = v
				b = t
			} else {
				if mod == 3 {
					r = p
					g = q
					b = v
				} else {
					if mod == 4 {
						r = t
						g = p
						b = v
					} else {
						r = v
						g = p
						b = q
					}
				}
			}
		}
	}
	return RGB{
		R: round_int((r * 255.0)),
		G: round_int((g * 255.0)),
		B: round_int((b * 255.0)),
	}
}

func get_distance(x float64, y float64, max_step int) float64 {
	var a float64 = x
	_ = a
	var b float64 = y
	_ = b
	var step int = (0 - 1)
	_ = step
	for step < (max_step - 1) {
		step = (step + 1)
		var a_new float64 = (((a * a) - (b * b)) + x)
		_ = a_new
		b = (((2.0 * a) * b) + y)
		a = a_new
		if ((a * a) + (b * b)) > 4.0 {
			break
		}
	}
	return (float64(step) / float64(float64((max_step - 1))))
}

func get_black_and_white_rgb(distance float64) RGB {
	if distance == 1.0 {
		return RGB{
			R: 0,
			G: 0,
			B: 0,
		}
	} else {
		return RGB{
			R: 255,
			G: 255,
			B: 255,
		}
	}
}

func get_color_coded_rgb(distance float64) RGB {
	if distance == 1.0 {
		return RGB{
			R: 0,
			G: 0,
			B: 0,
		}
	} else {
		return hsv_to_rgb(distance, 1.0, 1.0)
	}
}

func get_image(image_width int, image_height int, figure_center_x float64, figure_center_y float64, figure_width float64, max_step int, use_distance_color_coding bool) [][]RGB {
	var img [][]RGB = [][]RGB{}
	_ = img
	var figure_height float64 = ((float64(figure_width) / float64(image_width)) * float64(image_height))
	_ = figure_height
	var image_y int = 0
	_ = image_y
	for image_y < image_height {
		var row []RGB = []RGB{}
		_ = row
		var image_x int = 0
		_ = image_x
		for image_x < image_width {
			var fx float64 = (figure_center_x + (((float64(image_x) / float64(image_width)) - 0.5) * figure_width))
			_ = fx
			var fy float64 = (figure_center_y + (((float64(image_y) / float64(image_height)) - 0.5) * figure_height))
			_ = fy
			distance := get_distance(fx, fy, max_step)
			_ = distance
			var rgb RGB
			_ = rgb
			if use_distance_color_coding {
				rgb = get_color_coded_rgb(distance)
			} else {
				rgb = get_black_and_white_rgb(distance)
			}
			row = append(row, rgb)
			image_x = (image_x + 1)
		}
		img = append(img, row)
		image_y = (image_y + 1)
	}
	return img
}

func rgb_to_string(c RGB) string {
	return (((((("(" + fmt.Sprint(c.R)) + ", ") + fmt.Sprint(c.G)) + ", ") + fmt.Sprint(c.B)) + ")")
}

var img1 [][]RGB

var img2 [][]RGB

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		img1 = get_image(10, 10, (0 - 0.6), 0.0, 3.2, 50, true)
		fmt.Println(rgb_to_string(_index(_index(img1, 0), 0)))
		img2 = get_image(10, 10, (0 - 0.6), 0.0, 3.2, 50, false)
		fmt.Println(rgb_to_string(_index(_index(img2, 0), 0)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
