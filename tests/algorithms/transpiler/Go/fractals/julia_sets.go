//go:build ignore

// Generated by Mochi v0.10.73 on 2025-08-25 16:49:47 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var __name__ string = "__main__"

type Complex struct {
	Re float64 `json:"re"`
	Im float64 `json:"im"`
}

func complex_add(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re + b.Re),
		Im: (a.Im + b.Im),
	}
}

func complex_mul(a Complex, b Complex) Complex {
	var real float64 = ((a.Re * b.Re) - (a.Im * b.Im))
	_ = real
	_ = real
	var imag float64 = ((a.Re * b.Im) + (a.Im * b.Re))
	_ = imag
	_ = imag
	return Complex{
		Re: real,
		Im: imag,
	}
}

func sqrtApprox(x float64) float64 {
	var guess float64 = (float64(x) / float64(2.0))
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func complex_abs(a Complex) float64 {
	return sqrtApprox(((a.Re * a.Re) + (a.Im * a.Im)))
}

func sin_taylor(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = (2.0 * float64(i))
		_ = k1
		var k2 float64 = ((2.0 * float64(i)) + 1.0)
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func cos_taylor(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = ((2.0 * float64(i)) - 1.0)
		_ = k1
		var k2 float64 = (2.0 * float64(i))
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func exp_taylor(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i float64 = 1.0
	_ = i
	for i < 20.0 {
		term = (float64((term * x)) / float64(i))
		sum = (sum + term)
		i = (i + 1.0)
	}
	return sum
}

func complex_exp(z Complex) Complex {
	var e float64 = exp_taylor(z.Re)
	_ = e
	_ = e
	return Complex{
		Re: (e * cos_taylor(z.Im)),
		Im: (e * sin_taylor(z.Im)),
	}
}

func eval_quadratic(c Complex, z Complex) Complex {
	return complex_add(complex_mul(z, z), c)
}

func eval_exponential(c Complex, z Complex) Complex {
	return complex_add(complex_exp(z), c)
}

func iterate_function(eval_function func(Complex, Complex) Complex, c Complex, nb_iterations int, z0 Complex, infinity float64) Complex {
	var z_n Complex = z0
	_ = z_n
	var i int = 0
	_ = i
	for i < nb_iterations {
		z_n = eval_function(c, z_n)
		if complex_abs(z_n) > infinity {
			return z_n
		}
		i = (i + 1)
	}
	return z_n
}

func prepare_grid(window_size float64, nb_pixels int) [][]Complex {
	var grid [][]Complex = [][]Complex{}
	_ = grid
	var i int = 0
	_ = i
	for i < nb_pixels {
		var row []Complex = []Complex{}
		_ = row
		var j int = 0
		_ = j
		for j < nb_pixels {
			var real float64 = ((0 - window_size) + (float64(((2.0 * window_size) * float64(i))) / float64(float64((nb_pixels - 1)))))
			_ = real
			var imag float64 = ((0 - window_size) + (float64(((2.0 * window_size) * float64(j))) / float64(float64((nb_pixels - 1)))))
			_ = imag
			row = append(row, Complex{
				Re: real,
				Im: imag,
			})
			j = (j + 1)
		}
		grid = append(grid, row)
		i = (i + 1)
	}
	return grid
}

func julia_demo() {
	var grid [][]Complex = prepare_grid(1.0, 5)
	_ = grid
	var c_poly Complex = Complex{
		Re: (0 - 0.4),
		Im: 0.6,
	}
	_ = c_poly
	var c_exp Complex = Complex{
		Re: (0 - 2.0),
		Im: 0.0,
	}
	_ = c_exp
	var poly_result [][]int = [][]int{}
	_ = poly_result
	var exp_result [][]int = [][]int{}
	_ = exp_result
	var y int = 0
	_ = y
	for y < len(grid) {
		var row_poly []int = []int{}
		_ = row_poly
		var row_exp []int = []int{}
		_ = row_exp
		var x int = 0
		_ = x
		for x < len(_index(grid, y)) {
			var z0 Complex = _index(_index(grid, y), x)
			_ = z0
			var z_poly Complex = iterate_function(eval_quadratic, c_poly, 20, z0, 4.0)
			_ = z_poly
			var z_exp Complex = iterate_function(eval_exponential, c_exp, 10, z0, 10000000000.0)
			_ = z_exp
			row_poly = append(row_poly, func() int {
				if complex_abs(z_poly) < 2.0 {
					return 1
				} else {
					return 0
				}
			}())
			row_exp = append(row_exp, func() int {
				if complex_abs(z_exp) < 10000.0 {
					return 1
				} else {
					return 0
				}
			}())
			x = (x + 1)
		}
		poly_result = append(poly_result, row_poly)
		exp_result = append(exp_result, row_exp)
		y = (y + 1)
	}
	fmt.Println(strings.ReplaceAll(fmt.Sprint(poly_result), " ", ", "))
	fmt.Println(strings.ReplaceAll(fmt.Sprint(exp_result), " ", ", "))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		julia_demo()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
