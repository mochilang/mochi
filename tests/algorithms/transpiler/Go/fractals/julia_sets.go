//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 18:16:26 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

type Complex struct {
	Re float64 `json:"re"`
	Im float64 `json:"im"`
}

func complex_add(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re + b.Re),
		Im: (a.Im + b.Im),
	}
}

func complex_mul(a Complex, b Complex) Complex {
	var real float64 = ((a.Re * b.Re) - (a.Im * b.Im))
	_ = real
	_ = real
	var imag float64 = ((a.Re * b.Im) + (a.Im * b.Re))
	_ = imag
	_ = imag
	return Complex{
		Re: real,
		Im: imag,
	}
}

func sqrtApprox(x float64) float64 {
	var guess float64 = (float64(x) / float64(2.0))
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func complex_abs(a Complex) float64 {
	return sqrtApprox(((a.Re * a.Re) + (a.Im * a.Im)))
}

func sin_taylor(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = (2.0 * float64(i))
		_ = k1
		var k2 float64 = ((2.0 * float64(i)) + 1.0)
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func cos_taylor(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = ((2.0 * float64(i)) - 1.0)
		_ = k1
		var k2 float64 = (2.0 * float64(i))
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func exp_taylor(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i float64 = 1.0
	_ = i
	for i < 20.0 {
		term = (float64((term * x)) / float64(i))
		sum = (sum + term)
		i = (i + 1.0)
	}
	return sum
}

func complex_exp(z Complex) Complex {
	e := exp_taylor(z.Re)
	_ = e
	_ = e
	return Complex{
		Re: (_toFloat(e) * cos_taylor(z.Im)),
		Im: (_toFloat(e) * sin_taylor(z.Im)),
	}
}

func eval_quadratic(c Complex, z Complex) Complex {
	return complex_add(complex_mul(z, z), c)
}

func eval_exponential(c Complex, z Complex) Complex {
	return complex_add(complex_exp(z), c)
}

func iterate_function(eval_function func(Complex, Complex) Complex, c Complex, nb_iterations int, z0 Complex, infinity float64) Complex {
	var z_n Complex = z0
	_ = z_n
	var i int = 0
	_ = i
	for i < nb_iterations {
		z_n = eval_function(c, z_n)
		if complex_abs(z_n) > infinity {
			return z_n
		}
		i = (i + 1)
	}
	return z_n
}

func prepare_grid(window_size float64, nb_pixels int) [][]Complex {
	var grid [][]Complex = [][]Complex{}
	_ = grid
	var i int = 0
	_ = i
	for i < nb_pixels {
		var row []Complex = []Complex{}
		_ = row
		var j int = 0
		_ = j
		for j < nb_pixels {
			var real float64 = ((0 - window_size) + (float64(((2.0 * window_size) * float64(i))) / float64(float64((nb_pixels - 1)))))
			_ = real
			var imag float64 = ((0 - window_size) + (float64(((2.0 * window_size) * float64(j))) / float64(float64((nb_pixels - 1)))))
			_ = imag
			row = append(row, Complex{
				Re: real,
				Im: imag,
			})
			j = (j + 1)
		}
		grid = append(grid, row)
		i = (i + 1)
	}
	return grid
}

func julia_demo() {
	grid := prepare_grid(1.0, 5)
	_ = grid
	c_poly := Complex{
		Re: (0 - 0.4),
		Im: 0.6,
	}
	_ = c_poly
	c_exp := Complex{
		Re: (0 - 2.0),
		Im: 0.0,
	}
	_ = c_exp
	var poly_result [][]int = [][]int{}
	_ = poly_result
	var exp_result [][]int = [][]int{}
	_ = exp_result
	var y int = 0
	_ = y
	for y < _len(grid) {
		var row_poly []int = []int{}
		_ = row_poly
		var row_exp []int = []int{}
		_ = row_exp
		var x int = 0
		_ = x
		for x < _len(_index(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(grid), y)) {
			z0 := _index(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(_index(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(grid), y)), x)
			_ = z0
			z_poly := iterate_function(eval_quadratic, Complex(c_poly), 20, Complex(z0), 4.0)
			_ = z_poly
			_ = z_poly
			z_exp := iterate_function(eval_exponential, Complex(c_exp), 10, Complex(z0), 10000000000.0)
			_ = z_exp
			_ = z_exp
			row_poly = append(row_poly, func() int {
				if complex_abs(Complex(z_poly)) < 2.0 {
					return 1
				} else {
					return 0
				}
			}())
			row_exp = append(row_exp, func() int {
				if complex_abs(Complex(z_exp)) < 10000.0 {
					return 1
				} else {
					return 0
				}
			}())
			x = (x + 1)
		}
		poly_result = append(poly_result, row_poly)
		exp_result = append(exp_result, row_exp)
		y = (y + 1)
	}
	fmt.Println(func() string {
		b, _ := json.Marshal(poly_result)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
	fmt.Println(func() string {
		b, _ := json.Marshal(exp_result)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		julia_demo()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
