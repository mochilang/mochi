//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 20:58:34 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func gcd(a int, b int) int {
	var x int = func() int {
		if a < 0 {
			return (0 - a)
		} else {
			return a
		}
	}()
	_ = x
	var y int = func() int {
		if b < 0 {
			return (0 - b)
		} else {
			return b
		}
	}()
	_ = y
	for y != 0 {
		var t int = (x % y)
		_ = t
		x = y
		y = t
	}
	return x
}

func extended_gcd(a int, b int) []int {
	if b == 0 {
		return []int{a, 1, 0}
	}
	var res []int = extended_gcd(b, (a % b))
	_ = res
	var d int = res[0]
	_ = d
	_ = d
	var p int = res[1]
	_ = p
	var q int = res[2]
	_ = q
	var x int = q
	_ = x
	_ = x
	var y int = (p - (q * (a / b)))
	_ = y
	_ = y
	return []int{d, x, y}
}

func diophantine(a int, b int, c int) []int {
	var d int = gcd(a, b)
	_ = d
	if (c % d) != 0 {
		panic("No solution")
	}
	var eg []int = extended_gcd(a, b)
	_ = eg
	var r int = (c / d)
	_ = r
	var x int = (eg[1] * r)
	_ = x
	_ = x
	var y int = (eg[2] * r)
	_ = y
	_ = y
	return []int{x, y}
}

func diophantine_all_soln(a int, b int, c int, n int) [][]int {
	var base []int = diophantine(a, b, c)
	_ = base
	var x0 int = base[0]
	_ = x0
	var y0 int = base[1]
	_ = y0
	var d int = gcd(a, b)
	_ = d
	var p int = (a / d)
	_ = p
	var q int = (b / d)
	_ = q
	var sols [][]int = [][]int{}
	_ = sols
	var i int = 0
	_ = i
	for i < n {
		var x int = (x0 + (i * q))
		_ = x
		var y int = (y0 - (i * p))
		_ = y
		sols = append(sols, []int{x, y})
		i = (i + 1)
	}
	return sols
}

var s1 []int

var sols [][]int

var j int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		s1 = diophantine(10, 6, 14)
		fmt.Println(fmt.Sprint(s1))
		sols = diophantine_all_soln(10, 6, 14, 4)
		j = 0
		for j < len(sols) {
			fmt.Println(fmt.Sprint(sols[j]))
			j = (j + 1)
		}
		fmt.Println(fmt.Sprint(diophantine(391, 299, (0 - 69))))
		fmt.Println(fmt.Sprint(extended_gcd(10, 6)))
		fmt.Println(fmt.Sprint(extended_gcd(7, 5)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
