//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:21:27 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

var PI float64

type Angle struct {
	Degrees float64 `json:"degrees"`
}

func make_angle(deg float64) Angle {
	if (deg < 0.0) || (deg > 360.0) {
		panic("degrees must be between 0 and 360")
	}
	return Angle{
		Degrees: deg,
	}
}

type Side struct {
	Length float64 `json:"length"`
	Angle  Angle   `json:"angle"`
	Next   int     `json:"next"`
}

func make_side(length float64, angle Angle) Side {
	if length <= 0.0 {
		panic("length must be positive")
	}
	return Side{
		Length: length,
		Angle:  angle,
		Next:   (0 - 1),
	}
}

type Ellipse struct {
	Major float64 `json:"major"`
	Minor float64 `json:"minor"`
}

func ellipse_area(e Ellipse) float64 {
	return ((PI * e.Major) * e.Minor)
}

func ellipse_perimeter(e Ellipse) float64 {
	return (PI * (e.Major + e.Minor))
}

type Circle struct {
	Radius float64 `json:"radius"`
}

func circle_area(c Circle) float64 {
	e := Ellipse{
		Major: c.Radius,
		Minor: c.Radius,
	}
	_ = e
	area := ellipse_area(e)
	_ = area
	_ = area
	return area
}

func circle_perimeter(c Circle) float64 {
	e := Ellipse{
		Major: c.Radius,
		Minor: c.Radius,
	}
	_ = e
	per := ellipse_perimeter(e)
	_ = per
	_ = per
	return per
}

func circle_diameter(c Circle) float64 {
	return (c.Radius * 2.0)
}

func circle_max_parts(num_cuts float64) float64 {
	if num_cuts < 0.0 {
		panic("num_cuts must be positive")
	}
	return (((num_cuts + 2.0) + (num_cuts * num_cuts)) * 0.5)
}

type Polygon struct {
	Sides []Side `json:"sides"`
}

func make_polygon() Polygon {
	var s []Side = []Side{}
	_ = s
	_ = s
	return Polygon{
		Sides: s,
	}
}

func polygon_add_side(p Polygon, s Side) {
	p.Sides = append(p.Sides, s)
}

func polygon_get_side(p Polygon, index int) Side {
	return _index(p.Sides, index)
}

func polygon_set_side(p Polygon, index int, s Side) {
	var tmp []Side = p.Sides
	_ = tmp
	_setIndex(tmp, index, s)
	p.Sides = tmp
}

type Rectangle struct {
	ShortSide Side    `json:"short_side"`
	LongSide  Side    `json:"long_side"`
	Poly      Polygon `json:"poly"`
}

func make_rectangle(short_len float64, long_len float64) Rectangle {
	if (short_len <= 0.0) || (long_len <= 0.0) {
		panic("length must be positive")
	}
	short := make_side(short_len, make_angle(90.0))
	_ = short
	long := make_side(long_len, make_angle(90.0))
	_ = long
	var p Polygon = make_polygon()
	_ = p
	polygon_add_side(p, Side(short))
	polygon_add_side(p, Side(long))
	return Rectangle{
		ShortSide: short,
		LongSide:  long,
		Poly:      p,
	}
}

func rectangle_perimeter(r Rectangle) float64 {
	return ((r.ShortSide.Length + r.LongSide.Length) * 2.0)
}

func rectangle_area(r Rectangle) float64 {
	return (r.ShortSide.Length * r.LongSide.Length)
}

type Square struct {
	Side Side      `json:"side"`
	Rect Rectangle `json:"rect"`
}

func make_square(side_len float64) Square {
	rect := make_rectangle(side_len, side_len)
	_ = rect
	_ = rect
	return Square{
		Side: rect.ShortSide,
		Rect: rect,
	}
}

func square_perimeter(s Square) float64 {
	p := rectangle_perimeter(s.Rect)
	_ = p
	_ = p
	return p
}

func square_area(s Square) float64 {
	a := rectangle_area(s.Rect)
	_ = a
	_ = a
	return a
}

func mochiMain() {
	a := make_angle(90.0)
	_ = a
	fmt.Println(Angle(a).Degrees)
	s := make_side(5.0, Angle(a))
	_ = s
	fmt.Println(Side(s).Length)
	e := Ellipse{
		Major: 5.0,
		Minor: 10.0,
	}
	_ = e
	_ = e
	fmt.Println(func() string {
		f := float64(ellipse_area(Ellipse(e)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(ellipse_perimeter(Ellipse(e)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	c := Circle{
		Radius: 5.0,
	}
	_ = c
	_ = c
	fmt.Println(func() string {
		f := float64(circle_area(Circle(c)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(circle_perimeter(Circle(c)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(circle_diameter(Circle(c)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(circle_max_parts(7.0))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	r := make_rectangle(5.0, 10.0)
	_ = r
	_ = r
	fmt.Println(func() string {
		f := float64(rectangle_perimeter(Rectangle(r)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(rectangle_area(Rectangle(r)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	q := make_square(5.0)
	_ = q
	_ = q
	fmt.Println(func() string {
		f := float64(square_perimeter(Square(q)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(square_area(Square(q)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
