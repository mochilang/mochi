//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-09 10:21:24 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

var PI float64

var EQUATORIAL_RADIUS float64

func to_radians(deg float64) float64 {
	return (float64((deg * PI)) / float64(180.0))
}

func sin_approx(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = (2.0 * float64(i))
		_ = k1
		var k2 float64 = (k1 + 1.0)
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func cos_approx(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = ((2.0 * float64(i)) - 1.0)
		_ = k1
		var k2 float64 = (2.0 * float64(i))
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func sqrt_approx(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = (float64(x) / float64(2.0))
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func lamberts_ellipsoidal_distance(lat1 float64, lon1 float64, lat2 float64, lon2 float64) float64 {
	phi1 := to_radians(lat1)
	_ = phi1
	phi2 := to_radians(lat2)
	_ = phi2
	lambda1 := to_radians(lon1)
	_ = lambda1
	lambda2 := to_radians(lon2)
	_ = lambda2
	x := (_toFloat((_toFloat(lambda2) - _toFloat(lambda1))) * cos_approx(float64((float64(_toFloat((_toFloat(phi1) + _toFloat(phi2)))) / float64(2.0)))))
	_ = x
	_ = x
	y := (_toFloat(phi2) - _toFloat(phi1))
	_ = y
	_ = y
	return (EQUATORIAL_RADIUS * sqrt_approx(float64(((_toFloat(x) * _toFloat(x)) + (_toFloat(y) * _toFloat(y))))))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		EQUATORIAL_RADIUS = 6378137.0
		fmt.Println(func() string {
			f := float64(lamberts_ellipsoidal_distance(37.774856, (0 - 122.424227), 37.864742, (0 - 119.537521)))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(lamberts_ellipsoidal_distance(37.774856, (0 - 122.424227), 40.713019, (0 - 74.012647)))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(lamberts_ellipsoidal_distance(37.774856, (0 - 122.424227), 45.443012, 12.313071))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
