//go:build ignore

// Generated by Mochi v0.10.62 on 2025-08-09 16:26:47 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

var PI float64

var AXIS_A float64

var AXIS_B float64

var RADIUS float64

func to_radians(deg float64) float64 {
	return (float64((deg * PI)) / float64(180.0))
}

func sin_taylor(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = (2.0 * float64(i))
		_ = k1
		var k2 float64 = (k1 + 1.0)
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func cos_taylor(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = ((2.0 * float64(i)) - 1.0)
		_ = k1
		var k2 float64 = (2.0 * float64(i))
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func tan_approx(x float64) float64 {
	return (float64(sin_taylor(x)) / float64(cos_taylor(x)))
}

func sqrtApprox(x float64) float64 {
	var guess float64 = (float64(x) / float64(2.0))
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func atanApprox(x float64) float64 {
	if x > 1.0 {
		return ((float64(PI) / float64(2.0)) - (float64(x) / float64(((x * x) + 0.28))))
	}
	if x < (0 - 1.0) {
		return ((float64((0 - PI)) / float64(2.0)) - (float64(x) / float64(((x * x) + 0.28))))
	}
	return (float64(x) / float64((1.0 + ((0.28 * x) * x))))
}

func atan2Approx(y float64, x float64) float64 {
	if x > 0.0 {
		val := atanApprox((float64(y) / float64(x)))
		_ = val
		_ = val
		return val
	}
	if x < 0.0 {
		if y >= 0.0 {
			return (atanApprox((float64(y) / float64(x))) + PI)
		}
		return (atanApprox((float64(y) / float64(x))) - PI)
	}
	if y > 0.0 {
		return (float64(PI) / float64(2.0))
	}
	if y < 0.0 {
		return (float64((0 - PI)) / float64(2.0))
	}
	return 0.0
}

func asinApprox(x float64) float64 {
	denom := sqrtApprox((1.0 - (x * x)))
	_ = denom
	res := atan2Approx(x, denom)
	_ = res
	_ = res
	return res
}

func haversine_distance(lat1 float64, lon1 float64, lat2 float64, lon2 float64) float64 {
	flattening := (float64((AXIS_A - AXIS_B)) / float64(AXIS_A))
	_ = flattening
	phi_1 := atanApprox(float64((_toFloat((1.0 - _toFloat(flattening))) * tan_approx(to_radians(lat1)))))
	_ = phi_1
	phi_2 := atanApprox(float64((_toFloat((1.0 - _toFloat(flattening))) * tan_approx(to_radians(lat2)))))
	_ = phi_2
	lambda_1 := to_radians(lon1)
	_ = lambda_1
	lambda_2 := to_radians(lon2)
	_ = lambda_2
	var sin_sq_phi float64 = sin_taylor(float64((float64(_toFloat((_toFloat(phi_2) - _toFloat(phi_1)))) / float64(2.0))))
	_ = sin_sq_phi
	var sin_sq_lambda float64 = sin_taylor(float64((float64(_toFloat((_toFloat(lambda_2) - _toFloat(lambda_1)))) / float64(2.0))))
	_ = sin_sq_lambda
	sin_sq_phi = (sin_sq_phi * sin_sq_phi)
	sin_sq_lambda = (sin_sq_lambda * sin_sq_lambda)
	h_value := sqrtApprox((sin_sq_phi + ((cos_taylor(phi_1) * cos_taylor(phi_2)) * sin_sq_lambda)))
	_ = h_value
	_ = h_value
	return ((2.0 * RADIUS) * asinApprox(h_value))
}

var SAN_FRANCISCO []float64

var YOSEMITE []float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		AXIS_A = 6378137.0
		AXIS_B = 6.356752314245e+06
		RADIUS = 6378137.0
		SAN_FRANCISCO = []float64{37.774856, (0 - 122.424227)}
		YOSEMITE = []float64{37.864742, (0 - 119.537521)}
		fmt.Println(fmt.Sprint(haversine_distance(_index(SAN_FRANCISCO, 0), _index(SAN_FRANCISCO, 1), _index(YOSEMITE, 0), _index(YOSEMITE, 1))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
