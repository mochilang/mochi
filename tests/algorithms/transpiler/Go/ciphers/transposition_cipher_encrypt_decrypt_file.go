//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:26:42 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func encrypt_message(key int, message string) string {
	var result string = ""
	_ = result
	var col int = 0
	_ = col
	for col < key {
		var pointer int = col
		_ = pointer
		for pointer < len(message) {
			result = (result + string([]rune(message)[pointer]))
			pointer = (pointer + key)
		}
		col = (col + 1)
	}
	return result
}

func decrypt_message(key int, message string) string {
	var msg_len int = len(message)
	_ = msg_len
	var num_cols int = (msg_len / key)
	_ = num_cols
	if _mod(msg_len, key) != 0 {
		num_cols = (num_cols + 1)
	}
	var num_rows int = key
	_ = num_rows
	var num_shaded_boxes int = ((num_cols * num_rows) - msg_len)
	_ = num_shaded_boxes
	var plain []string = []string{}
	_ = plain
	var i int = 0
	_ = i
	for i < num_cols {
		plain = append(plain, "")
		i = (i + 1)
	}
	var col int = 0
	_ = col
	var row int = 0
	_ = row
	var idx int = 0
	_ = idx
	for idx < msg_len {
		var ch string = string([]rune(message)[idx])
		_ = ch
		plain[col] = (plain[col] + ch)
		col = (col + 1)
		if (col == num_cols) || ((col == (num_cols - 1)) && (row >= (num_rows - num_shaded_boxes))) {
			col = 0
			row = (row + 1)
		}
		idx = (idx + 1)
	}
	var result string = ""
	_ = result
	i = 0
	for i < num_cols {
		result = (result + plain[i])
		i = (i + 1)
	}
	return result
}

var key int

var message string

var encrypted string

var decrypted string

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		key = 6
		message = "Harshil Darji"
		encrypted = encrypt_message(key, message)
		fmt.Println(encrypted)
		decrypted = decrypt_message(key, encrypted)
		fmt.Println(decrypted)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
