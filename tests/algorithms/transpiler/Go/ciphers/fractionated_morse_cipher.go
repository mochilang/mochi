//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:26:06 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

var MORSE_CODE_DICT map[string]string

var MORSE_COMBINATIONS []string

var REVERSE_DICT map[string]string

func encodeToMorse(plaintext string) string {
	var morse string = ""
	_ = morse
	var i int = 0
	_ = i
	for i < len(plaintext) {
		var ch string = strings.ToUpper(string([]rune(plaintext)[i:(i + 1)]))
		_ = ch
		var code string = ""
		_ = code
		if func() bool { _, ok := MORSE_CODE_DICT[ch]; return ok }() {
			code = MORSE_CODE_DICT[ch]
		}
		if i > 0 {
			morse = (morse + "x")
		}
		morse = (morse + code)
		i = (i + 1)
	}
	return morse
}

func encryptFractionatedMorse(plaintext string, key string) string {
	var morseCode string = encodeToMorse(plaintext)
	_ = morseCode
	var combinedKey string = (strings.ToUpper(key) + "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	_ = combinedKey
	var dedupKey string = ""
	_ = dedupKey
	var i int = 0
	_ = i
	for i < len(combinedKey) {
		var ch string = string([]rune(combinedKey)[i:(i + 1)])
		_ = ch
		if !strings.Contains(dedupKey, ch) {
			dedupKey = (dedupKey + ch)
		}
		i = (i + 1)
	}
	var paddingLength int = (3 - _mod(len(morseCode), 3))
	_ = paddingLength
	var p int = 0
	_ = p
	for p < paddingLength {
		morseCode = (morseCode + "x")
		p = (p + 1)
	}
	var dict map[string]string = map[string]string{}
	_ = dict
	var j int = 0
	_ = j
	for j < 26 {
		var combo string = MORSE_COMBINATIONS[j]
		_ = combo
		var letter string = string([]rune(dedupKey)[j:(j + 1)])
		_ = letter
		dict[combo] = letter
		j = (j + 1)
	}
	dict["xxx"] = ""
	var encrypted string = ""
	_ = encrypted
	var k int = 0
	_ = k
	for k < len(morseCode) {
		var group string = string([]rune(morseCode)[k:(k + 3)])
		_ = group
		encrypted = (encrypted + dict[group])
		k = (k + 3)
	}
	return encrypted
}

func decryptFractionatedMorse(ciphertext string, key string) string {
	var combinedKey string = (strings.ToUpper(key) + "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	_ = combinedKey
	var dedupKey string = ""
	_ = dedupKey
	var i int = 0
	_ = i
	for i < len(combinedKey) {
		var ch string = string([]rune(combinedKey)[i:(i + 1)])
		_ = ch
		if !strings.Contains(dedupKey, ch) {
			dedupKey = (dedupKey + ch)
		}
		i = (i + 1)
	}
	var inv map[string]string = map[string]string{}
	_ = inv
	var j int = 0
	_ = j
	for j < 26 {
		var letter string = string([]rune(dedupKey)[j:(j + 1)])
		_ = letter
		inv[letter] = MORSE_COMBINATIONS[j]
		j = (j + 1)
	}
	var morse string = ""
	_ = morse
	var k int = 0
	_ = k
	for k < len(ciphertext) {
		var ch string = string([]rune(ciphertext)[k:(k + 1)])
		_ = ch
		if func() bool { _, ok := inv[ch]; return ok }() {
			morse = (morse + inv[ch])
		}
		k = (k + 1)
	}
	var codes []string = []string{}
	_ = codes
	var current string = ""
	_ = current
	var m int = 0
	_ = m
	for m < len(morse) {
		var ch string = string([]rune(morse)[m:(m + 1)])
		_ = ch
		if ch == "x" {
			codes = append(codes, current)
			current = ""
		} else {
			current = (current + ch)
		}
		m = (m + 1)
	}
	codes = append(codes, current)
	var decrypted string = ""
	_ = decrypted
	var idx int = 0
	_ = idx
	for idx < len(codes) {
		var code string = codes[idx]
		_ = code
		decrypted = (decrypted + REVERSE_DICT[code])
		idx = (idx + 1)
	}
	var start int = 0
	_ = start
	for {
		if start < len(decrypted) {
			if string([]rune(decrypted)[start:(start+1)]) == " " {
				start = (start + 1)
				continue
			}
		}
		break
	}
	var end int = len(decrypted)
	_ = end
	for {
		if end > start {
			if string([]rune(decrypted)[(end-1):end]) == " " {
				end = (end - 1)
				continue
			}
		}
		break
	}
	return string([]rune(decrypted)[start:end])
}

var plaintext string

var key string

var ciphertext string

var decrypted string

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		MORSE_CODE_DICT = map[string]string{"A": ".-", "B": "-...", "C": "-.-.", "D": "-..", "E": ".", "F": "..-.", "G": "--.", "H": "....", "I": "..", "J": ".---", "K": "-.-", "L": ".-..", "M": "--", "N": "-.", "O": "---", "P": ".--.", "Q": "--.-", "R": ".-.", "S": "...", "T": "-", "U": "..-", "V": "...-", "W": ".--", "X": "-..-", "Y": "-.--", "Z": "--..", " ": ""}
		MORSE_COMBINATIONS = []string{"...", "..-", "..x", ".-.", ".--", ".-x", ".x.", ".x-", ".xx", "-..", "-.-", "-.x", "--.", "---", "--x", "-x.", "-x-", "-xx", "x..", "x.-", "x.x", "x-.", "x--", "x-x", "xx.", "xx-", "xxx"}
		REVERSE_DICT = map[string]string{".-": "A", "-...": "B", "-.-.": "C", "-..": "D", ".": "E", "..-.": "F", "--.": "G", "....": "H", "..": "I", ".---": "J", "-.-": "K", ".-..": "L", "--": "M", "-.": "N", "---": "O", ".--.": "P", "--.-": "Q", ".-.": "R", "...": "S", "-": "T", "..-": "U", "...-": "V", ".--": "W", "-..-": "X", "-.--": "Y", "--..": "Z", "": " "}
		plaintext = "defend the east"
		fmt.Println("Plain Text:", plaintext)
		key = "ROUNDTABLE"
		ciphertext = encryptFractionatedMorse(plaintext, key)
		fmt.Println("Encrypted:", ciphertext)
		decrypted = decryptFractionatedMorse(ciphertext, key)
		fmt.Println("Decrypted:", decrypted)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
