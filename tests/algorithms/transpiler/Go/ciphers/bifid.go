//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:25:51 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var SQUARE [][]string

func index_of(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if string([]rune(s)[i]) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func to_lower_without_spaces(message string, replace_j bool) string {
	var upper string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper
	var lower string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower
	_ = lower
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(message) {
		var ch string = string([]rune(message)[i])
		_ = ch
		var pos int = index_of(upper, ch)
		_ = pos
		if pos >= 0 {
			ch = string([]rune(lower)[pos])
		}
		if ch != " " {
			if replace_j && (ch == "j") {
				ch = "i"
			}
			res = (res + ch)
		}
		i = (i + 1)
	}
	return res
}

func letter_to_numbers(letter string) []int {
	var r int = 0
	_ = r
	for r < len(SQUARE) {
		var c int = 0
		_ = c
		for c < len(SQUARE[r]) {
			if SQUARE[r][c] == letter {
				return []int{(r + 1), (c + 1)}
			}
			c = (c + 1)
		}
		r = (r + 1)
	}
	return []int{0, 0}
}

func numbers_to_letter(row int, col int) string {
	return SQUARE[(row - 1)][(col - 1)]
}

func encode(message string) string {
	var clean string = to_lower_without_spaces(message, true)
	_ = clean
	var l int = len(clean)
	_ = l
	var rows []int = []int{}
	_ = rows
	var cols []int = []int{}
	_ = cols
	var i int = 0
	_ = i
	for i < l {
		var nums []int = letter_to_numbers(string([]rune(clean)[i]))
		_ = nums
		rows = append(rows, nums[0])
		cols = append(cols, nums[1])
		i = (i + 1)
	}
	var seq []int = []int{}
	_ = seq
	i = 0
	for i < l {
		seq = append(seq, rows[i])
		i = (i + 1)
	}
	i = 0
	for i < l {
		seq = append(seq, cols[i])
		i = (i + 1)
	}
	var encoded string = ""
	_ = encoded
	i = 0
	for i < l {
		var r int = seq[(2 * i)]
		_ = r
		var c int = seq[((2 * i) + 1)]
		_ = c
		encoded = (encoded + numbers_to_letter(r, c))
		i = (i + 1)
	}
	return encoded
}

func decode(message string) string {
	var clean string = to_lower_without_spaces(message, false)
	_ = clean
	var l int = len(clean)
	_ = l
	var first []int = []int{}
	_ = first
	var i int = 0
	_ = i
	for i < l {
		var nums []int = letter_to_numbers(string([]rune(clean)[i]))
		_ = nums
		first = append(first, nums[0])
		first = append(first, nums[1])
		i = (i + 1)
	}
	var top []int = []int{}
	_ = top
	var bottom []int = []int{}
	_ = bottom
	i = 0
	for i < l {
		top = append(top, first[i])
		bottom = append(bottom, first[(i+l)])
		i = (i + 1)
	}
	var decoded string = ""
	_ = decoded
	i = 0
	for i < l {
		var r int = top[i]
		_ = r
		var c int = bottom[i]
		_ = c
		decoded = (decoded + numbers_to_letter(r, c))
		i = (i + 1)
	}
	return decoded
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		SQUARE = [][]string{[]string{"a", "b", "c", "d", "e"}, []string{"f", "g", "h", "i", "k"}, []string{"l", "m", "n", "o", "p"}, []string{"q", "r", "s", "t", "u"}, []string{"v", "w", "x", "y", "z"}}
		fmt.Println(encode("testmessage"))
		fmt.Println(encode("Test Message"))
		fmt.Println(encode("test j"))
		fmt.Println(encode("test i"))
		fmt.Println(decode("qtltbdxrxlk"))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
