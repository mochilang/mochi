//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:07:58 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var LOWER string

var UPPER string

func to_lowercase(s string) string {
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(s) {
		var c string = string([]rune(s)[i])
		_ = c
		var j int = 0
		_ = j
		var found bool = false
		_ = found
		for j < 26 {
			if c == string([]rune(UPPER)[j]) {
				res = (res + string([]rune(LOWER)[j]))
				found = true
				break
			}
			j = (j + 1)
		}
		if !found {
			res = (res + c)
		}
		i = (i + 1)
	}
	return res
}

func char_index(c string) int {
	var i int = 0
	_ = i
	for i < 26 {
		if c == string([]rune(LOWER)[i]) {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func index_char(i int) string {
	return string([]rune(LOWER)[i])
}

func encrypt(plaintext string, key string) string {
	if len(plaintext) == 0 {
		panic("plaintext is empty")
	}
	if len(key) == 0 {
		panic("key is empty")
	}
	var full_key string = (key + plaintext)
	_ = full_key
	plaintext = to_lowercase(plaintext)
	full_key = to_lowercase(full_key)
	var p_i int = 0
	_ = p_i
	var k_i int = 0
	_ = k_i
	var ciphertext string = ""
	_ = ciphertext
	for p_i < len(plaintext) {
		var p_char string = string([]rune(plaintext)[p_i])
		_ = p_char
		var p_idx int = char_index(p_char)
		_ = p_idx
		if p_idx < 0 {
			ciphertext = (ciphertext + p_char)
			p_i = (p_i + 1)
		} else {
			var k_char string = string([]rune(full_key)[k_i])
			_ = k_char
			var k_idx int = char_index(k_char)
			_ = k_idx
			if k_idx < 0 {
				k_i = (k_i + 1)
			} else {
				var c_idx int = ((p_idx + k_idx) % 26)
				_ = c_idx
				ciphertext = (ciphertext + index_char(c_idx))
				k_i = (k_i + 1)
				p_i = (p_i + 1)
			}
		}
	}
	return ciphertext
}

func decrypt(ciphertext string, key string) string {
	if len(ciphertext) == 0 {
		panic("ciphertext is empty")
	}
	if len(key) == 0 {
		panic("key is empty")
	}
	var current_key string = to_lowercase(key)
	_ = current_key
	var c_i int = 0
	_ = c_i
	var k_i int = 0
	_ = k_i
	var plaintext string = ""
	_ = plaintext
	for c_i < len(ciphertext) {
		var c_char string = string([]rune(ciphertext)[c_i])
		_ = c_char
		var c_idx int = char_index(c_char)
		_ = c_idx
		if c_idx < 0 {
			plaintext = (plaintext + c_char)
		} else {
			var k_char string = string([]rune(current_key)[k_i])
			_ = k_char
			var k_idx int = char_index(k_char)
			_ = k_idx
			var p_idx int = (((c_idx - k_idx) + 26) % 26)
			_ = p_idx
			var p_char string = index_char(p_idx)
			_ = p_char
			plaintext = (plaintext + p_char)
			current_key = (current_key + p_char)
			k_i = (k_i + 1)
		}
		c_i = (c_i + 1)
	}
	return plaintext
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		LOWER = "abcdefghijklmnopqrstuvwxyz"
		UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		fmt.Println(encrypt("hello world", "coffee"))
		fmt.Println(decrypt("jsqqs avvwo", "coffee"))
		fmt.Println(encrypt("coffee is good as python", "TheAlgorithms"))
		fmt.Println(decrypt("vvjfpk wj ohvp su ddylsv", "TheAlgorithms"))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
