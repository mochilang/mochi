//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:26:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

var seed int

func rand() int {
	seed = _mod(((seed * 1103515245) + 12345), 2147483647)
	return seed
}

func rand_range(min int, max int) int {
	return (min + _mod(rand(), ((max-min)+1)))
}

func mod_pow(base int, exponent int, modulus int) int {
	var result int = 1
	_ = result
	var b int = _mod(base, modulus)
	_ = b
	var e int = exponent
	_ = e
	for e > 0 {
		if _mod(e, 2) == 1 {
			result = _mod((result * b), modulus)
		}
		e = (e / 2)
		b = _mod((b * b), modulus)
	}
	return result
}

type GCD struct {
	G int `json:"g"`
	X int `json:"x"`
	Y int `json:"y"`
}

func extended_gcd(a int, b int) GCD {
	if b == 0 {
		return GCD{
			G: a,
			X: 1,
			Y: 0,
		}
	}
	var res GCD = extended_gcd(b, _mod(a, b))
	_ = res
	_ = res
	return GCD{
		G: res.G,
		X: res.Y,
		Y: (res.X - ((a / b) * res.Y)),
	}
}

func mod_inverse(a int, m int) int {
	var res GCD = extended_gcd(a, m)
	_ = res
	if res.G != 1 {
		panic("inverse does not exist")
	}
	var r int = _mod(res.X, m)
	_ = r
	if r < 0 {
		return (r + m)
	}
	return r
}

func pow2(n int) int {
	var r int = 1
	_ = r
	var i int = 0
	_ = i
	for i < n {
		r = (r * 2)
		i = (i + 1)
	}
	return r
}

func is_probable_prime(n int, k int) bool {
	if n <= 1 {
		return false
	}
	if n <= 3 {
		return true
	}
	if _mod(n, 2) == 0 {
		return false
	}
	var r int = 0
	_ = r
	var d int = (n - 1)
	_ = d
	for _mod(d, 2) == 0 {
		d = (d / 2)
		r = (r + 1)
	}
	var i int = 0
	_ = i
	for i < k {
		var a int = rand_range(2, (n - 2))
		_ = a
		var x int = mod_pow(a, d, n)
		_ = x
		if (x == 1) || (x == (n - 1)) {
			i = (i + 1)
			continue
		}
		var j int = 1
		_ = j
		var found bool = false
		_ = found
		for j < r {
			x = mod_pow(x, 2, n)
			if x == (n - 1) {
				found = true
				break
			}
			j = (j + 1)
		}
		if !found {
			return false
		}
		i = (i + 1)
	}
	return true
}

func generate_large_prime(bits int) int {
	var min int = pow2((bits - 1))
	_ = min
	var max int = (pow2(bits) - 1)
	_ = max
	var p int = rand_range(min, max)
	_ = p
	if _mod(p, 2) == 0 {
		p = (p + 1)
	}
	for !is_probable_prime(p, 5) {
		p = (p + 2)
		if p > max {
			p = (min + 1)
		}
	}
	return p
}

func primitive_root(p int) int {
	for {
		var g int = rand_range(3, (p - 1))
		_ = g
		if mod_pow(g, 2, p) == 1 {
			continue
		}
		if mod_pow(g, p, p) == 1 {
			continue
		}
		return g
	}
}

type PublicKey struct {
	KeySize int `json:"key_size"`
	G       int `json:"g"`
	E2      int `json:"e2"`
	P       int `json:"p"`
}

type PrivateKey struct {
	KeySize int `json:"key_size"`
	D       int `json:"d"`
}

type KeyPair struct {
	PublicKey  PublicKey  `json:"public_key"`
	PrivateKey PrivateKey `json:"private_key"`
}

func generate_key(key_size int) KeyPair {
	var p int = generate_large_prime(key_size)
	_ = p
	var e1 int = primitive_root(p)
	_ = e1
	var d int = rand_range(3, (p - 1))
	_ = d
	var e2 int = mod_inverse(mod_pow(e1, d, p), p)
	_ = e2
	var public_key PublicKey = PublicKey{
		KeySize: key_size,
		G:       e1,
		E2:      e2,
		P:       p,
	}
	_ = public_key
	_ = public_key
	var private_key PrivateKey = PrivateKey{
		KeySize: key_size,
		D:       d,
	}
	_ = private_key
	_ = private_key
	return KeyPair{
		PublicKey:  public_key,
		PrivateKey: private_key,
	}
}

func mochiMain() {
	var key_size int = 16
	_ = key_size
	var kp KeyPair = generate_key(key_size)
	_ = kp
	var pub PublicKey = kp.PublicKey
	_ = pub
	var priv PrivateKey = kp.PrivateKey
	_ = priv
	fmt.Println((((((((("public key: (" + fmt.Sprint(pub.KeySize)) + ", ") + fmt.Sprint(pub.G)) + ", ") + fmt.Sprint(pub.E2)) + ", ") + fmt.Sprint(pub.P)) + ")"))
	fmt.Println((((("private key: (" + fmt.Sprint(priv.KeySize)) + ", ") + fmt.Sprint(priv.D)) + ")"))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		seed = 123456789
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
