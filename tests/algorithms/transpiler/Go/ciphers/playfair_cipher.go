//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:26:20 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func contains(xs []string, x string) bool {
	var i int = 0
	_ = i
	for i < len(xs) {
		if xs[i] == x {
			return true
		}
		i = (i + 1)
	}
	return false
}

func index_of(xs []string, x string) int {
	var i int = 0
	_ = i
	for i < len(xs) {
		if xs[i] == x {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func prepare_input(dirty string) string {
	var letters string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = letters
	_ = letters
	var upper_dirty string = strings.ToUpper(dirty)
	_ = upper_dirty
	var filtered string = ""
	_ = filtered
	var i int = 0
	_ = i
	for i < len(upper_dirty) {
		var c string = _substr(upper_dirty, i, (i + 1))
		_ = c
		if strings.Contains(letters, c) {
			filtered = (filtered + c)
		}
		i = (i + 1)
	}
	if len(filtered) < 2 {
		return filtered
	}
	var clean string = ""
	_ = clean
	i = 0
	for i < (len(filtered) - 1) {
		var c1 string = _substr(filtered, i, (i + 1))
		_ = c1
		var c2 string = _substr(filtered, (i + 1), (i + 2))
		_ = c2
		clean = (clean + c1)
		if c1 == c2 {
			clean = (clean + "X")
		}
		i = (i + 1)
	}
	clean = (clean + _substr(filtered, (len(filtered)-1), len(filtered)))
	if _mod(len(clean), 2) == 1 {
		clean = (clean + "X")
	}
	return clean
}

func generate_table(key string) []string {
	var alphabet string = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
	_ = alphabet
	var table []string = []string{}
	_ = table
	var upper_key string = strings.ToUpper(key)
	_ = upper_key
	var i int = 0
	_ = i
	for i < len(upper_key) {
		var c string = _substr(upper_key, i, (i + 1))
		_ = c
		if strings.Contains(alphabet, c) {
			if !func() bool {
				for _, el := range table {
					if el == c {
						return true
					}
				}
				return false
			}() {
				table = append(table, c)
			}
		}
		i = (i + 1)
	}
	i = 0
	for i < len(alphabet) {
		var c string = _substr(alphabet, i, (i + 1))
		_ = c
		if !func() bool {
			for _, el := range table {
				if el == c {
					return true
				}
			}
			return false
		}() {
			table = append(table, c)
		}
		i = (i + 1)
	}
	return table
}

func encode(plaintext string, key string) string {
	var table []string = generate_table(key)
	_ = table
	var text string = prepare_input(plaintext)
	_ = text
	var cipher string = ""
	_ = cipher
	var i int = 0
	_ = i
	for i < len(text) {
		var c1 string = _substr(text, i, (i + 1))
		_ = c1
		var c2 string = _substr(text, (i + 1), (i + 2))
		_ = c2
		var idx1 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(table), c1)
		_ = idx1
		var idx2 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(table), c2)
		_ = idx2
		var row1 int = (idx1 / 5)
		_ = row1
		var col1 int = _mod(idx1, 5)
		_ = col1
		var row2 int = (idx2 / 5)
		_ = row2
		var col2 int = _mod(idx2, 5)
		_ = col2
		if row1 == row2 {
			cipher = (cipher + table[((row1*5)+_mod((col1+1), 5))])
			cipher = (cipher + table[((row2*5)+_mod((col2+1), 5))])
		} else {
			if col1 == col2 {
				cipher = (cipher + table[((_mod((row1+1), 5)*5)+col1)])
				cipher = (cipher + table[((_mod((row2+1), 5)*5)+col2)])
			} else {
				cipher = (cipher + table[((row1*5)+col2)])
				cipher = (cipher + table[((row2*5)+col1)])
			}
		}
		i = (i + 2)
	}
	return cipher
}

func decode(cipher string, key string) string {
	var table []string = generate_table(key)
	_ = table
	var plain string = ""
	_ = plain
	var i int = 0
	_ = i
	for i < len(cipher) {
		var c1 string = _substr(cipher, i, (i + 1))
		_ = c1
		var c2 string = _substr(cipher, (i + 1), (i + 2))
		_ = c2
		var idx1 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(table), c1)
		_ = idx1
		var idx2 int = index_of(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(table), c2)
		_ = idx2
		var row1 int = (idx1 / 5)
		_ = row1
		var col1 int = _mod(idx1, 5)
		_ = col1
		var row2 int = (idx2 / 5)
		_ = row2
		var col2 int = _mod(idx2, 5)
		_ = col2
		if row1 == row2 {
			plain = (plain + table[((row1*5)+_mod((col1+4), 5))])
			plain = (plain + table[((row2*5)+_mod((col2+4), 5))])
		} else {
			if col1 == col2 {
				plain = (plain + table[((_mod((row1+4), 5)*5)+col1)])
				plain = (plain + table[((_mod((row2+4), 5)*5)+col2)])
			} else {
				plain = (plain + table[((row1*5)+col2)])
				plain = (plain + table[((row2*5)+col1)])
			}
		}
		i = (i + 2)
	}
	return plain
}

func mochiMain() {
	fmt.Println("Encoded:", encode("BYE AND THANKS", "GREETING"))
	fmt.Println("Decoded:", decode("CXRBANRLBALQ", "GREETING"))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
