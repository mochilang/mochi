//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:26:05 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

var abc string

var low_abc string

var rotor1 string

var rotor2 string

var rotor3 string

var rotor4 string

var rotor5 string

var rotor6 string

var rotor7 string

var rotor8 string

var rotor9 string

var reflector_pairs []string

func list_contains(xs []string, x string) bool {
	var i int = 0
	_ = i
	for i < len(xs) {
		if xs[i] == x {
			return true
		}
		i = (i + 1)
	}
	return false
}

func index_in_string(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func contains_char(s string, ch string) bool {
	return (index_in_string(s, ch) >= 0)
}

func to_uppercase(s string) string {
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(s) {
		var ch string = _substr(s, i, (i + 1))
		_ = ch
		var idx int = index_in_string(low_abc, ch)
		_ = idx
		if idx >= 0 {
			res = (res + _substr(abc, idx, (idx+1)))
		} else {
			res = (res + ch)
		}
		i = (i + 1)
	}
	return res
}

func plugboard_map(pb []string, ch string) string {
	var i int = 0
	_ = i
	for i < len(pb) {
		var pair string = pb[i]
		_ = pair
		var a string = _substr(pair, 0, 1)
		_ = a
		var b string = _substr(pair, 1, 2)
		_ = b
		if ch == a {
			return b
		}
		if ch == b {
			return a
		}
		i = (i + 1)
	}
	return ch
}

func reflector_map(ch string) string {
	var i int = 0
	_ = i
	for i < len(reflector_pairs) {
		var pair string = reflector_pairs[i]
		_ = pair
		var a string = _substr(pair, 0, 1)
		_ = a
		var b string = _substr(pair, 1, 2)
		_ = b
		if ch == a {
			return b
		}
		if ch == b {
			return a
		}
		i = (i + 1)
	}
	return ch
}

func count_unique(xs []string) int {
	var unique []string = []string{}
	_ = unique
	var i int = 0
	_ = i
	for i < len(xs) {
		if !list_contains(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(unique), xs[i]) {
			unique = append(unique, xs[i])
		}
		i = (i + 1)
	}
	return len(unique)
}

func build_plugboard(pbstring string) []string {
	if len(pbstring) == 0 {
		return []string{}
	}
	if _mod(len(pbstring), 2) != 0 {
		panic((("Odd number of symbols(" + fmt.Sprint(len(pbstring))) + ")"))
	}
	var pbstring_nospace string = ""
	_ = pbstring_nospace
	var i int = 0
	_ = i
	for i < len(pbstring) {
		var ch string = _substr(pbstring, i, (i + 1))
		_ = ch
		if ch != " " {
			pbstring_nospace = (pbstring_nospace + ch)
		}
		i = (i + 1)
	}
	var seen []string = []string{}
	_ = seen
	i = 0
	for i < len(pbstring_nospace) {
		var ch string = _substr(pbstring_nospace, i, (i + 1))
		_ = ch
		if !contains_char(abc, ch) {
			panic((("'" + ch) + "' not in list of symbols"))
		}
		if list_contains(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(seen), ch) {
			panic((("Duplicate symbol(" + ch) + ")"))
		}
		seen = append(seen, ch)
		i = (i + 1)
	}
	var pb []string = []string{}
	_ = pb
	i = 0
	for i < (len(pbstring_nospace) - 1) {
		var a string = _substr(pbstring_nospace, i, (i + 1))
		_ = a
		var b string = _substr(pbstring_nospace, (i + 1), (i + 2))
		_ = b
		pb = append(pb, (a + b))
		i = (i + 2)
	}
	return pb
}

func validator(rotpos []int, rotsel []string, pb string) {
	if count_unique(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(rotsel)) < 3 {
		panic((("Please use 3 unique rotors (not " + fmt.Sprint(count_unique(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(rotsel)))) + ")"))
	}
	if len(rotpos) != 3 {
		panic("Rotor position must have 3 values")
	}
	var r1 int = rotpos[0]
	_ = r1
	var r2 int = rotpos[1]
	_ = r2
	var r3 int = rotpos[2]
	_ = r3
	if !((0 < r1) && (r1 <= len(abc))) {
		panic((("First rotor position is not within range of 1..26 (" + fmt.Sprint(r1)) + ")"))
	}
	if !((0 < r2) && (r2 <= len(abc))) {
		panic((("Second rotor position is not within range of 1..26 (" + fmt.Sprint(r2)) + ")"))
	}
	if !((0 < r3) && (r3 <= len(abc))) {
		panic((("Third rotor position is not within range of 1..26 (" + fmt.Sprint(r3)) + ")"))
	}
}

func enigma(text string, rotor_position []int, rotor_selection []string, plugb string) string {
	var up_text string = to_uppercase(text)
	_ = up_text
	var up_pb string = to_uppercase(plugb)
	_ = up_pb
	validator(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(rotor_position), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(rotor_selection), up_pb)
	var plugboard []string = build_plugboard(up_pb)
	_ = plugboard
	var rotorpos1 int = (rotor_position[0] - 1)
	_ = rotorpos1
	var rotorpos2 int = (rotor_position[1] - 1)
	_ = rotorpos2
	var rotorpos3 int = (rotor_position[2] - 1)
	_ = rotorpos3
	var rotor_a string = rotor_selection[0]
	_ = rotor_a
	var rotor_b string = rotor_selection[1]
	_ = rotor_b
	var rotor_c string = rotor_selection[2]
	_ = rotor_c
	var result string = ""
	_ = result
	var i int = 0
	_ = i
	for i < len(up_text) {
		var symbol string = _substr(up_text, i, (i + 1))
		_ = symbol
		if contains_char(abc, symbol) {
			symbol = plugboard_map(func(v any) []string {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]string); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []string{}
					}
					out := make([]string, len(arr))
					for i, x := range arr {
						out[i] = x.(string)
					}
					return out
				}
				return v.([]string)
			}(plugboard), symbol)
			var index int = (index_in_string(abc, symbol) + rotorpos1)
			_ = index
			symbol = _substr(rotor_a, _mod(index, len(abc)), (_mod(index, len(abc)) + 1))
			index = (index_in_string(abc, symbol) + rotorpos2)
			symbol = _substr(rotor_b, _mod(index, len(abc)), (_mod(index, len(abc)) + 1))
			index = (index_in_string(abc, symbol) + rotorpos3)
			symbol = _substr(rotor_c, _mod(index, len(abc)), (_mod(index, len(abc)) + 1))
			symbol = reflector_map(symbol)
			index = (index_in_string(rotor_c, symbol) - rotorpos3)
			if index < 0 {
				index = (index + len(abc))
			}
			symbol = _substr(abc, index, (index + 1))
			index = (index_in_string(rotor_b, symbol) - rotorpos2)
			if index < 0 {
				index = (index + len(abc))
			}
			symbol = _substr(abc, index, (index + 1))
			index = (index_in_string(rotor_a, symbol) - rotorpos1)
			if index < 0 {
				index = (index + len(abc))
			}
			symbol = _substr(abc, index, (index + 1))
			symbol = plugboard_map(func(v any) []string {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]string); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []string{}
					}
					out := make([]string, len(arr))
					for i, x := range arr {
						out[i] = x.(string)
					}
					return out
				}
				return v.([]string)
			}(plugboard), symbol)
			rotorpos1 = (rotorpos1 + 1)
			if rotorpos1 >= len(abc) {
				rotorpos1 = 0
				rotorpos2 = (rotorpos2 + 1)
			}
			if rotorpos2 >= len(abc) {
				rotorpos2 = 0
				rotorpos3 = (rotorpos3 + 1)
			}
			if rotorpos3 >= len(abc) {
				rotorpos3 = 0
			}
		}
		result = (result + symbol)
		i = (i + 1)
	}
	return result
}

func mochiMain() {
	var message string = "This is my Python script that emulates the Enigma machine from WWII."
	_ = message
	var rotor_pos []int = []int{1, 1, 1}
	_ = rotor_pos
	var pb string = "pictures"
	_ = pb
	var rotor_sel []string = []string{rotor2, rotor4, rotor8}
	_ = rotor_sel
	var en string = enigma(message, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(rotor_pos), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(rotor_sel), pb)
	_ = en
	fmt.Println(("Encrypted message: " + en))
	fmt.Println(("Decrypted message: " + enigma(en, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(rotor_pos), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(rotor_sel), pb)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		low_abc = "abcdefghijklmnopqrstuvwxyz"
		rotor1 = "EGZWVONAHDCLFQMSIPJBYUKXTR"
		rotor2 = "FOBHMDKEXQNRAULPGSJVTYICZW"
		rotor3 = "ZJXESIUQLHAVRMDOYGTNFWPBKC"
		rotor4 = "RMDJXFUWGISLHVTCQNKYPBEZOA"
		rotor5 = "SGLCPQWZHKXAREONTFBVIYJUDM"
		rotor6 = "HVSICLTYKQUBXDWAJZOMFGPREN"
		rotor7 = "RZWQHFMVDBKICJLNTUXAGYPSOE"
		rotor8 = "LFKIJODBEGAMQPXVUHYSTCZRWN"
		rotor9 = "KOAEGVDHXPQZMLFTYWJNBRCIUS"
		reflector_pairs = []string{"AN", "BO", "CP", "DQ", "ER", "FS", "GT", "HU", "IV", "JW", "KX", "LY", "MZ"}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
