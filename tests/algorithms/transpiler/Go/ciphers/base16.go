//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:08:09 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func base16_encode(data []int) string {
	var digits string = "0123456789ABCDEF"
	_ = digits
	_ = digits
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(data) {
		var b int = data[i]
		_ = b
		if (b < 0) || (b > 255) {
			panic("byte out of range")
		}
		var hi int = (b / 16)
		_ = hi
		var lo int = (b % 16)
		_ = lo
		res = ((res + string([]rune(digits)[hi:(hi+1)])) + string([]rune(digits)[lo:(lo+1)]))
		i = (i + 1)
	}
	return res
}

func base16_decode(data string) []int {
	var digits string = "0123456789ABCDEF"
	_ = digits
	_ = digits
	if (len(data) % 2) != 0 {
		panic("Base16 encoded data is invalid: Data does not have an even number of hex digits.")
	}
	var hex_value func(string) int
	_ = hex_value
	hex_value = func(ch string) int {
		var j int = 0
		_ = j
		for j < 16 {
			if string([]rune(digits)[j:(j+1)]) == ch {
				return j
			}
			j = (j + 1)
		}
		return (0 - 1)
	}
	var out []int = []int{}
	_ = out
	var i int = 0
	_ = i
	for i < len(data) {
		var hi_char string = string([]rune(data)[i:(i + 1)])
		_ = hi_char
		var lo_char string = string([]rune(data)[(i + 1):(i + 2)])
		_ = lo_char
		var hi int = hex_value(hi_char)
		_ = hi
		var lo int = hex_value(lo_char)
		_ = lo
		if (hi < 0) || (lo < 0) {
			panic("Base16 encoded data is invalid: Data is not uppercase hex or it contains invalid characters.")
		}
		out = append(out, ((hi * 16) + lo))
		i = (i + 2)
	}
	return out
}

var example1 []int

var example2 []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		example1 = []int{72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33}
		example2 = []int{72, 69, 76, 76, 79, 32, 87, 79, 82, 76, 68, 33}
		fmt.Println(base16_encode(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(example1)))
		fmt.Println(base16_encode(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(example2)))
		fmt.Println(base16_encode(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{})))
		fmt.Println(fmt.Sprint(base16_decode("48656C6C6F20576F726C6421")))
		fmt.Println(fmt.Sprint(base16_decode("48454C4C4F20574F524C4421")))
		fmt.Println(fmt.Sprint(base16_decode("")))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
