//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:07:45 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var SYMBOLS string

func gcd(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	for y != 0 {
		var temp int = (x % y)
		_ = temp
		x = y
		y = temp
	}
	return x
}

func mod_inverse(a int, m int) int {
	if gcd(a, m) != 1 {
		panic((((("mod inverse of " + fmt.Sprint(a)) + " and ") + fmt.Sprint(m)) + " does not exist"))
	}
	var u1 int = 1
	_ = u1
	var u2 int = 0
	_ = u2
	var u3 int = a
	_ = u3
	var v1 int = 0
	_ = v1
	var v2 int = 1
	_ = v2
	var v3 int = m
	_ = v3
	for v3 != 0 {
		var q int = (u3 / v3)
		_ = q
		var t1 int = (u1 - (q * v1))
		_ = t1
		var t2 int = (u2 - (q * v2))
		_ = t2
		var t3 int = (u3 - (q * v3))
		_ = t3
		u1 = v1
		u2 = v2
		u3 = v3
		v1 = t1
		v2 = t2
		v3 = t3
	}
	var res int = (u1 % m)
	_ = res
	if res < 0 {
		return (res + m)
	}
	return res
}

func find_symbol(ch string) int {
	var i int = 0
	_ = i
	for i < len(SYMBOLS) {
		if string([]rune(SYMBOLS)[i]) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func check_keys(key_a int, key_b int, mode string) {
	var m int = len(SYMBOLS)
	_ = m
	if mode == "encrypt" {
		if key_a == 1 {
			panic("The affine cipher becomes weak when key A is set to 1. Choose different key")
		}
		if key_b == 0 {
			panic("The affine cipher becomes weak when key B is set to 0. Choose different key")
		}
	}
	if ((key_a < 0) || (key_b < 0)) || (key_b > (m - 1)) {
		panic(("Key A must be greater than 0 and key B must be between 0 and " + fmt.Sprint((m - 1))))
	}
	if gcd(key_a, m) != 1 {
		panic((((("Key A " + fmt.Sprint(key_a)) + " and the symbol set size ") + fmt.Sprint(m)) + " are not relatively prime. Choose a different key."))
	}
}

func encrypt_message(key int, message string) string {
	var m int = len(SYMBOLS)
	_ = m
	var key_a int = (key / m)
	_ = key_a
	var key_b int = (key % m)
	_ = key_b
	check_keys(key_a, key_b, "encrypt")
	var cipher_text string = ""
	_ = cipher_text
	var i int = 0
	_ = i
	for i < len(message) {
		var ch string = string([]rune(message)[i])
		_ = ch
		var index int = find_symbol(ch)
		_ = index
		if index >= 0 {
			cipher_text = (cipher_text + string([]rune(SYMBOLS)[(((index*key_a)+key_b)%m)]))
		} else {
			cipher_text = (cipher_text + ch)
		}
		i = (i + 1)
	}
	return cipher_text
}

func decrypt_message(key int, message string) string {
	var m int = len(SYMBOLS)
	_ = m
	var key_a int = (key / m)
	_ = key_a
	var key_b int = (key % m)
	_ = key_b
	check_keys(key_a, key_b, "decrypt")
	var inv int = mod_inverse(key_a, m)
	_ = inv
	var plain_text string = ""
	_ = plain_text
	var i int = 0
	_ = i
	for i < len(message) {
		var ch string = string([]rune(message)[i])
		_ = ch
		var index int = find_symbol(ch)
		_ = index
		if index >= 0 {
			var n int = ((index - key_b) * inv)
			_ = n
			var pos int = (n % m)
			_ = pos
			_ = pos
			var final int = func() int {
				if pos < 0 {
					return (pos + m)
				} else {
					return pos
				}
			}()
			_ = final
			plain_text = (plain_text + string([]rune(SYMBOLS)[final]))
		} else {
			plain_text = (plain_text + ch)
		}
		i = (i + 1)
	}
	return plain_text
}

func mochiMain() {
	var key int = 4545
	_ = key
	var msg string = "The affine cipher is a type of monoalphabetic substitution cipher."
	_ = msg
	var enc string = encrypt_message(key, msg)
	_ = enc
	fmt.Println(enc)
	fmt.Println(decrypt_message(key, enc))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		SYMBOLS = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
