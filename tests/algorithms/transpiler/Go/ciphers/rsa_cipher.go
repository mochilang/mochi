//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:26:29 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

var BYTE_SIZE int

func pow_int(base int, exp int) int {
	var result int = 1
	_ = result
	var i int = 0
	_ = i
	for i < exp {
		result = (result * base)
		i = (i + 1)
	}
	return result
}

func mod_pow(base int, exponent int, modulus int) int {
	var result int = 1
	_ = result
	var b int = _mod(base, modulus)
	_ = b
	var e int = exponent
	_ = e
	for e > 0 {
		if _mod(e, 2) == 1 {
			result = _mod((result * b), modulus)
		}
		e = (e / 2)
		b = _mod((b * b), modulus)
	}
	return result
}

func ord(ch string) int {
	if ch == " " {
		return 32
	}
	if ch == "a" {
		return 97
	}
	if ch == "b" {
		return 98
	}
	if ch == "c" {
		return 99
	}
	if ch == "d" {
		return 100
	}
	if ch == "e" {
		return 101
	}
	if ch == "f" {
		return 102
	}
	if ch == "g" {
		return 103
	}
	if ch == "h" {
		return 104
	}
	if ch == "i" {
		return 105
	}
	if ch == "j" {
		return 106
	}
	if ch == "k" {
		return 107
	}
	if ch == "l" {
		return 108
	}
	if ch == "m" {
		return 109
	}
	if ch == "n" {
		return 110
	}
	if ch == "o" {
		return 111
	}
	if ch == "p" {
		return 112
	}
	if ch == "q" {
		return 113
	}
	if ch == "r" {
		return 114
	}
	if ch == "s" {
		return 115
	}
	if ch == "t" {
		return 116
	}
	if ch == "u" {
		return 117
	}
	if ch == "v" {
		return 118
	}
	if ch == "w" {
		return 119
	}
	if ch == "x" {
		return 120
	}
	if ch == "y" {
		return 121
	}
	if ch == "z" {
		return 122
	}
	return 0
}

func chr(code int) string {
	if code == 32 {
		return " "
	}
	if code == 97 {
		return "a"
	}
	if code == 98 {
		return "b"
	}
	if code == 99 {
		return "c"
	}
	if code == 100 {
		return "d"
	}
	if code == 101 {
		return "e"
	}
	if code == 102 {
		return "f"
	}
	if code == 103 {
		return "g"
	}
	if code == 104 {
		return "h"
	}
	if code == 105 {
		return "i"
	}
	if code == 106 {
		return "j"
	}
	if code == 107 {
		return "k"
	}
	if code == 108 {
		return "l"
	}
	if code == 109 {
		return "m"
	}
	if code == 110 {
		return "n"
	}
	if code == 111 {
		return "o"
	}
	if code == 112 {
		return "p"
	}
	if code == 113 {
		return "q"
	}
	if code == 114 {
		return "r"
	}
	if code == 115 {
		return "s"
	}
	if code == 116 {
		return "t"
	}
	if code == 117 {
		return "u"
	}
	if code == 118 {
		return "v"
	}
	if code == 119 {
		return "w"
	}
	if code == 120 {
		return "x"
	}
	if code == 121 {
		return "y"
	}
	if code == 122 {
		return "z"
	}
	return ""
}

func get_blocks_from_text(message string, block_size int) []int {
	var block_ints []int = []int{}
	_ = block_ints
	var block_start int = 0
	_ = block_start
	for block_start < len(message) {
		var block_int int = 0
		_ = block_int
		var i int = block_start
		_ = i
		for (i < (block_start + block_size)) && (i < len(message)) {
			block_int = (block_int + (ord(string([]rune(message)[i])) * pow_int(BYTE_SIZE, (i-block_start))))
			i = (i + 1)
		}
		block_ints = append(block_ints, block_int)
		block_start = (block_start + block_size)
	}
	return block_ints
}

func get_text_from_blocks(block_ints []int, message_length int, block_size int) string {
	var message string = ""
	_ = message
	for _, block_int := range block_ints {
		var block int = block_int
		_ = block
		var i int = (block_size - 1)
		_ = i
		var block_message string = ""
		_ = block_message
		for i >= 0 {
			if (len(message) + i) < message_length {
				var ascii_number int = (block / pow_int(BYTE_SIZE, i))
				_ = ascii_number
				block = _mod(block, pow_int(BYTE_SIZE, i))
				block_message = (chr(ascii_number) + block_message)
			}
			i = (i - 1)
		}
		message = (message + block_message)
	}
	return message
}

func encrypt_message(message string, n int, e int, block_size int) []int {
	var encrypted []int = []int{}
	_ = encrypted
	var blocks []int = get_blocks_from_text(message, block_size)
	_ = blocks
	for _, block := range blocks {
		encrypted = append(encrypted, mod_pow(block, e, n))
	}
	return encrypted
}

func decrypt_message(blocks []int, message_length int, n int, d int, block_size int) string {
	var decrypted_blocks []int = []int{}
	_ = decrypted_blocks
	for _, block := range blocks {
		decrypted_blocks = append(decrypted_blocks, mod_pow(block, d, n))
	}
	var message string = ""
	_ = message
	for _, num := range decrypted_blocks {
		message = (message + chr(num))
	}
	return message
}

func mochiMain() {
	var message string = "hello world"
	_ = message
	var n int = 3233
	_ = n
	var e int = 17
	_ = e
	var d int = 2753
	_ = d
	var block_size int = 1
	_ = block_size
	var encrypted []int = encrypt_message(message, n, e, block_size)
	_ = encrypted
	fmt.Println(fmt.Sprint(encrypted))
	var decrypted string = decrypt_message(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(encrypted), len(message), n, d, block_size)
	_ = decrypted
	fmt.Println(decrypted)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		BYTE_SIZE = 256
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
