//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:08:14 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _repeat(s string, n int) string {
	if n <= 0 {
		return ""
	}
	return strings.Repeat(s, n)
}

var B32_CHARSET string

func indexOfChar(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if string([]rune(s)[i]) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func ord(ch string) int {
	var upper string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper
	var lower string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower
	var digits string = "0123456789"
	_ = digits
	var idx int = indexOfChar(upper, ch)
	_ = idx
	if idx >= 0 {
		return (65 + idx)
	}
	idx = indexOfChar(lower, ch)
	if idx >= 0 {
		return (97 + idx)
	}
	idx = indexOfChar(digits, ch)
	if idx >= 0 {
		return (48 + idx)
	}
	if ch == " " {
		return 32
	}
	if ch == "!" {
		return 33
	}
	return 0
}

func chr(code int) string {
	var upper string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper
	var lower string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower
	var digits string = "0123456789"
	_ = digits
	if code == 32 {
		return " "
	}
	if code == 33 {
		return "!"
	}
	var idx int = (code - 65)
	_ = idx
	if (idx >= 0) && (idx < len(upper)) {
		return string([]rune(upper)[idx])
	}
	idx = (code - 97)
	if (idx >= 0) && (idx < len(lower)) {
		return string([]rune(lower)[idx])
	}
	idx = (code - 48)
	if (idx >= 0) && (idx < len(digits)) {
		return string([]rune(digits)[idx])
	}
	return ""
}

func repeat(s string, n int) string {
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < n {
		out = (out + s)
		i = (i + 1)
	}
	return out
}

func to_binary(n int, bits int) string {
	var v int = n
	_ = v
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < bits {
		out = (fmt.Sprint((v % 2)) + out)
		v = (v / 2)
		i = (i + 1)
	}
	return out
}

func binary_to_int(bits string) int {
	var n int = 0
	_ = n
	var i int = 0
	_ = i
	for i < len(bits) {
		n = (n * 2)
		if string([]rune(bits)[i]) == "1" {
			n = (n + 1)
		}
		i = (i + 1)
	}
	return n
}

func base32_encode(data string) string {
	var binary_data string = ""
	_ = binary_data
	var i int = 0
	_ = i
	for i < len(data) {
		binary_data = (binary_data + to_binary(ord(string([]rune(data)[i])), 8))
		i = (i + 1)
	}
	var remainder int = (len(binary_data) % 5)
	_ = remainder
	if remainder != 0 {
		binary_data = (binary_data + _repeat("0", (5-remainder)))
	}
	var b32_result string = ""
	_ = b32_result
	var j int = 0
	_ = j
	for j < len(binary_data) {
		var chunk string = string([]rune(binary_data)[j:(j + 5)])
		_ = chunk
		var index int = binary_to_int(chunk)
		_ = index
		b32_result = (b32_result + string([]rune(B32_CHARSET)[index]))
		j = (j + 5)
	}
	var rem int = (len(b32_result) % 8)
	_ = rem
	if rem != 0 {
		b32_result = (b32_result + _repeat("=", (8-rem)))
	}
	return b32_result
}

func base32_decode(data string) string {
	var clean string = ""
	_ = clean
	var i int = 0
	_ = i
	for i < len(data) {
		var ch string = string([]rune(data)[i])
		_ = ch
		if ch != "=" {
			clean = (clean + ch)
		}
		i = (i + 1)
	}
	var binary_chunks string = ""
	_ = binary_chunks
	i = 0
	for i < len(clean) {
		var idx int = indexOfChar(B32_CHARSET, string([]rune(clean)[i]))
		_ = idx
		binary_chunks = (binary_chunks + to_binary(idx, 5))
		i = (i + 1)
	}
	var result string = ""
	_ = result
	var j int = 0
	_ = j
	for (j + 8) <= len(binary_chunks) {
		var byte_bits string = string([]rune(binary_chunks)[j:(j + 8)])
		_ = byte_bits
		var code int = binary_to_int(byte_bits)
		_ = code
		result = (result + chr(code))
		j = (j + 8)
	}
	return result
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		B32_CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
		fmt.Println(base32_encode("Hello World!"))
		fmt.Println(base32_encode("123456"))
		fmt.Println(base32_encode("some long complex string"))
		fmt.Println(base32_decode("JBSWY3DPEBLW64TMMQQQ===="))
		fmt.Println(base32_decode("GEZDGNBVGY======"))
		fmt.Println(base32_decode("ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY="))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
