//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:08:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

var encode_map map[string]string

func make_decode_map() map[string]string {
	var m map[string]string = map[string]string{}
	_ = m
	for _, k := range func() []string {
		keys := make([]string, 0, len(encode_map))
		for k := range encode_map {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		m[encode_map[k]] = k
	}
	return m
}

var decode_map map[string]string

func split_spaces(s string) []string {
	var parts []string = []string{}
	_ = parts
	var current string = ""
	_ = current
	var i int = 0
	_ = i
	for i < len(s) {
		var ch string = _substr(s, i, (i + 1))
		_ = ch
		if ch == " " {
			parts = append(parts, current)
			current = ""
		} else {
			current = (current + ch)
		}
		i = (i + 1)
	}
	parts = append(parts, current)
	return parts
}

func encode(word string) string {
	var w string = strings.ToLower(word)
	_ = w
	var encoded string = ""
	_ = encoded
	var i int = 0
	_ = i
	for i < len(w) {
		var ch string = _substr(w, i, (i + 1))
		_ = ch
		if func() bool { _, ok := encode_map[ch]; return ok }() {
			encoded = (encoded + encode_map[ch])
		} else {
			panic("encode() accepts only letters of the alphabet and spaces")
		}
		i = (i + 1)
	}
	return encoded
}

func decode(coded string) string {
	var i int = 0
	_ = i
	for i < len(coded) {
		var ch string = _substr(coded, i, (i + 1))
		_ = ch
		if ((ch != "A") && (ch != "B")) && (ch != " ") {
			panic("decode() accepts only 'A', 'B' and spaces")
		}
		i = (i + 1)
	}
	var words []string = split_spaces(coded)
	_ = words
	var decoded string = ""
	_ = decoded
	var w int = 0
	_ = w
	for w < len(words) {
		var word string = words[w]
		_ = word
		var j int = 0
		_ = j
		for j < len(word) {
			var segment string = _substr(word, j, (j + 5))
			_ = segment
			decoded = (decoded + decode_map[segment])
			j = (j + 5)
		}
		if w < (len(words) - 1) {
			decoded = (decoded + " ")
		}
		w = (w + 1)
	}
	return decoded
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		encode_map = map[string]string{"a": "AAAAA", "b": "AAAAB", "c": "AAABA", "d": "AAABB", "e": "AABAA", "f": "AABAB", "g": "AABBA", "h": "AABBB", "i": "ABAAA", "j": "BBBAA", "k": "ABAAB", "l": "ABABA", "m": "ABABB", "n": "ABBAA", "o": "ABBAB", "p": "ABBBA", "q": "ABBBB", "r": "BAAAA", "s": "BAAAB", "t": "BAABA", "u": "BAABB", "v": "BBBAB", "w": "BABAA", "x": "BABAB", "y": "BABBA", "z": "BABBB", " ": " "}
		decode_map = make_decode_map()
		fmt.Println(encode("hello"))
		fmt.Println(encode("hello world"))
		fmt.Println(decode("AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB"))
		fmt.Println(decode("AABBBAABAAABABAABABAABBAB"))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
