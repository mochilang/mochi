//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 18:15:09 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

func score_function(source_char string, target_char string, match_score int, mismatch_score int, gap_score int) int {
	if (source_char == "-") || (target_char == "-") {
		return gap_score
	}
	if source_char == target_char {
		return match_score
	}
	return mismatch_score
}

func smith_waterman(query string, subject string, match_score int, mismatch_score int, gap_score int) [][]int {
	q := strings.ToUpper(query)
	_ = q
	s := strings.ToUpper(subject)
	_ = s
	m := _len(q)
	_ = m
	n := _len(s)
	_ = n
	var score [][]int = [][]int{}
	_ = score
	for _i := 0; _i < (m + 1); _i++ {
		var row []int = []int{}
		_ = row
		for _2 := 0; _2 < (n + 1); _2++ {
			row = append(row, 0)
		}
		score = append(score, row)
	}
	for i := 1; i < (m + 1); i++ {
		for j := 1; j < (n + 1); j++ {
			qc := _substr(fmt.Sprint(q), (i - 1), i)
			_ = qc
			sc := _substr(fmt.Sprint(s), (j - 1), j)
			_ = sc
			var diag int = (int(_index(_index(score, (i-1)), (j-1))) + score_function(qc, sc, match_score, mismatch_score, gap_score))
			_ = diag
			var delete int = (int(_index(_index(score, (i-1)), j)) + gap_score)
			_ = delete
			var insert int = (int(_index(_index(score, i), (j-1))) + gap_score)
			_ = insert
			var max_val int = 0
			_ = max_val
			if diag > max_val {
				max_val = diag
			}
			if delete > max_val {
				max_val = delete
			}
			if insert > max_val {
				max_val = insert
			}
			_setIndex(_index(score, i), j, max_val)
		}
	}
	return score
}

func traceback(score [][]int, query string, subject string, match_score int, mismatch_score int, gap_score int) string {
	q := strings.ToUpper(query)
	_ = q
	s := strings.ToUpper(subject)
	_ = s
	var max_value int = 0
	_ = max_value
	var i_max int = 0
	_ = i_max
	var j_max int = 0
	_ = j_max
	for i := 0; i < len(score); i++ {
		for j := 0; j < len(_index(score, i)); j++ {
			if int(_index(_index(score, i), j)) > max_value {
				max_value = _index(_index(score, i), j)
				i_max = i
				j_max = j
			}
		}
	}
	var i int = i_max
	_ = i
	var j int = j_max
	_ = j
	var align1 string = ""
	_ = align1
	var align2 string = ""
	_ = align2
	gap_penalty := score_function("-", "-", match_score, mismatch_score, gap_score)
	_ = gap_penalty
	if (i == 0) || (j == 0) {
		return ""
	}
	for (i > 0) && (j > 0) {
		qc := _substr(fmt.Sprint(q), (i - 1), i)
		_ = qc
		sc := _substr(fmt.Sprint(s), (j - 1), j)
		_ = sc
		if int(_index(_index(score, i), j)) == (int(_index(_index(score, (i-1)), (j-1))) + score_function(qc, sc, match_score, mismatch_score, gap_score)) {
			align1 = (fmt.Sprint(qc) + align1)
			align2 = (fmt.Sprint(sc) + align2)
			i = (i - 1)
			j = (j - 1)
		} else {
			if int(_index(_index(score, i), j)) == (int(_index(_index(score, (i-1)), j)) + gap_penalty) {
				align1 = (fmt.Sprint(qc) + align1)
				align2 = ("-" + align2)
				i = (i - 1)
			} else {
				align1 = ("-" + align1)
				align2 = (fmt.Sprint(sc) + align2)
				j = (j - 1)
			}
		}
	}
	return ((align1 + "\n") + align2)
}

var query string

var subject string

var score [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		query = "HEAGAWGHEE"
		subject = "PAWHEAE"
		score = smith_waterman(query, subject, 1, (0 - 1), (0 - 2))
		fmt.Println(traceback(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(score), query, subject, 1, (0 - 1), (0 - 2)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
