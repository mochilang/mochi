//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-13 07:26:01 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func recursive_match(text string, pattern string) bool {
	if len(pattern) == 0 {
		return (len(text) == 0)
	}
	if len(text) == 0 {
		if (len(pattern) >= 2) && (_substr(pattern, (len(pattern)-1), len(pattern)) == "*") {
			return recursive_match(text, _substr(pattern, 0, (len(pattern)-2)))
		}
		return false
	}
	var last_text string = _substr(text, (len(text) - 1), len(text))
	_ = last_text
	var last_pattern string = _substr(pattern, (len(pattern) - 1), len(pattern))
	_ = last_pattern
	if (last_text == last_pattern) || (last_pattern == ".") {
		return recursive_match(_substr(text, 0, (len(text)-1)), _substr(pattern, 0, (len(pattern)-1)))
	}
	if last_pattern == "*" {
		if recursive_match(_substr(text, 0, (len(text)-1)), pattern) {
			return true
		}
		return recursive_match(text, _substr(pattern, 0, (len(pattern)-2)))
	}
	return false
}

func dp_match(text string, pattern string) bool {
	var m int = len(text)
	_ = m
	var n int = len(pattern)
	_ = n
	var dp [][]bool = [][]bool{}
	_ = dp
	var i int = 0
	_ = i
	for i <= m {
		var row []bool = []bool{}
		_ = row
		var j int = 0
		_ = j
		for j <= n {
			row = append(row, false)
			j = (j + 1)
		}
		dp = append(dp, row)
		i = (i + 1)
	}
	_setIndex(_index(dp, 0), 0, true)
	var j int = 1
	_ = j
	for j <= n {
		if (_substr(pattern, (j-1), j) == "*") && (j >= 2) {
			if _index(_index(dp, 0), (j - 2)) {
				_setIndex(_index(dp, 0), j, true)
			}
		}
		j = (j + 1)
	}
	i = 1
	for i <= m {
		j = 1
		for j <= n {
			var p_char string = _substr(pattern, (j - 1), j)
			_ = p_char
			var t_char string = _substr(text, (i - 1), i)
			_ = t_char
			if (p_char == ".") || (p_char == t_char) {
				if _index(_index(dp, (i-1)), (j - 1)) {
					_setIndex(_index(dp, i), j, true)
				}
			} else {
				if p_char == "*" {
					if j >= 2 {
						if _index(_index(dp, i), (j - 2)) {
							_setIndex(_index(dp, i), j, true)
						}
						var prev_p string = _substr(pattern, (j - 2), (j - 1))
						_ = prev_p
						if (prev_p == ".") || (prev_p == t_char) {
							if _index(_index(dp, (i-1)), j) {
								_setIndex(_index(dp, i), j, true)
							}
						}
					}
				} else {
					_setIndex(_index(dp, i), j, false)
				}
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return _index(_index(dp, m), n)
}

func print_bool(b bool) {
	if b {
		fmt.Println(true)
	} else {
		fmt.Println(false)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		print_bool(recursive_match("abc", "a.c"))
		print_bool(recursive_match("abc", "af*.c"))
		print_bool(recursive_match("abc", "a.c*"))
		print_bool(recursive_match("abc", "a.c*d"))
		print_bool(recursive_match("aa", ".*"))
		print_bool(dp_match("abc", "a.c"))
		print_bool(dp_match("abc", "af*.c"))
		print_bool(dp_match("abc", "a.c*"))
		print_bool(dp_match("abc", "a.c*d"))
		print_bool(dp_match("aa", ".*"))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
