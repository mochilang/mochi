//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 17:57:40 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func allConstruct(target string, wordBank []string) [][]string {
	tableSize := (len(target) + 1)
	_ = tableSize
	var table [][][]string = [][][]string{}
	_ = table
	var idx int = 0
	_ = idx
	for idx < tableSize {
		var empty [][]string = [][]string{}
		_ = empty
		table = append(table, empty)
		idx = (idx + 1)
	}
	var base []string = []string{}
	_ = base
	_setIndex(table, 0, [][]string{base})
	var i int = 0
	_ = i
	for i < tableSize {
		if len(_index(table, i)) != 0 {
			var w int = 0
			_ = w
			for w < len(wordBank) {
				var word string = _index(wordBank, w)
				_ = word
				wordLen := len(word)
				_ = wordLen
				if string([]rune(target)[i:(i+wordLen)]) == word {
					var k int = 0
					_ = k
					for k < len(_index(table, i)) {
						var way []string = _index(_index(table, i), k)
						_ = way
						var combination []string = []string{}
						_ = combination
						var m int = 0
						_ = m
						for m < len(way) {
							combination = append(combination, _index(way, m))
							m = (m + 1)
						}
						combination = append(combination, word)
						var nextIndex int = (i + wordLen)
						_ = nextIndex
						_setIndex(table, nextIndex, append(_index(table, nextIndex), combination))
						k = (k + 1)
					}
				}
				w = (w + 1)
			}
		}
		i = (i + 1)
	}
	return func(v any) [][]string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]string{}
			}
			out := make([][]string, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []string{}
						}
						out := make([]string, len(arr))
						for i, x := range arr {
							out[i] = x.(string)
						}
						return out
					}
					return v.([]string)
				}(x)
			}
			return out
		}
		return v.([][]string)
	}(_index(table, len(target)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		fmt.Println(fmt.Sprint(allConstruct("jwajalapa", func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}([]string{"jwa", "j", "w", "a", "la", "lapa"}))))
		fmt.Println(fmt.Sprint(allConstruct("rajamati", func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}([]string{"s", "raj", "amat", "raja", "ma", "i", "t"}))))
		fmt.Println(fmt.Sprint(allConstruct("hexagonosaurus", func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}([]string{"h", "ex", "hex", "ag", "ago", "ru", "auru", "rus", "go", "no", "o", "s"}))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
