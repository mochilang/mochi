//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 17:57:52 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

var INF int

type Graph struct {
	N  int     `json:"n"`
	Dp [][]int `json:"dp"`
}

func new_graph(n int) Graph {
	var dp [][]int = [][]int{}
	_ = dp
	var i int = 0
	_ = i
	for i < n {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			if i == j {
				row = append(row, 0)
			} else {
				row = append(row, INF)
			}
			j = (j + 1)
		}
		dp = append(dp, row)
		i = (i + 1)
	}
	return Graph{
		N:  n,
		Dp: dp,
	}
}

func add_edge(g Graph, u int, v int, w int) {
	var dp [][]int = g.Dp
	_ = dp
	var row []int = _index(dp, u)
	_ = row
	_setIndex(row, v, w)
	_setIndex(dp, u, row)
	g.Dp = dp
}

func floyd_warshall(g Graph) {
	var dp [][]int = g.Dp
	_ = dp
	var k int = 0
	_ = k
	for k < g.N {
		var i int = 0
		_ = i
		for i < g.N {
			var j int = 0
			_ = j
			for j < g.N {
				var alt int = (int(_index(_index(dp, i), k)) + int(_index(_index(dp, k), j)))
				_ = alt
				var row []int = _index(dp, i)
				_ = row
				if alt < int(_index(row, j)) {
					_setIndex(row, j, alt)
					_setIndex(dp, i, row)
				}
				j = (j + 1)
			}
			i = (i + 1)
		}
		k = (k + 1)
	}
	g.Dp = dp
}

func show_min(g Graph, u int, v int) int {
	return _index(_index(g.Dp, u), v)
}

var graph Graph

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		INF = 1000000000
		graph = new_graph(5)
		add_edge(graph, 0, 2, 9)
		add_edge(graph, 0, 4, 10)
		add_edge(graph, 1, 3, 5)
		add_edge(graph, 2, 3, 7)
		add_edge(graph, 3, 0, 10)
		add_edge(graph, 3, 1, 2)
		add_edge(graph, 3, 2, 1)
		add_edge(graph, 3, 4, 6)
		add_edge(graph, 4, 1, 3)
		add_edge(graph, 4, 2, 4)
		add_edge(graph, 4, 3, 9)
		floyd_warshall(graph)
		fmt.Println(fmt.Sprint(show_min(graph, 1, 4)))
		fmt.Println(fmt.Sprint(show_min(graph, 0, 3)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
