//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-12 10:09:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

type Particle struct {
	X    float64 `json:"x"`
	Y    float64 `json:"y"`
	Z    float64 `json:"z"`
	Mass float64 `json:"mass"`
}

type Coord3D struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

func round2(x float64) float64 {
	var scaled float64 = (x * 100.0)
	_ = scaled
	_ = scaled
	var rounded float64 = float64(int((scaled + 0.5)))
	_ = rounded
	_ = rounded
	return (float64(rounded) / float64(100.0))
}

func center_of_mass(ps []Particle) Coord3D {
	if len(ps) == 0 {
		panic("No particles provided")
	}
	var i int = 0
	_ = i
	var total_mass float64 = 0.0
	_ = total_mass
	for i < len(ps) {
		var p Particle = _index(ps, i)
		_ = p
		if p.Mass <= 0.0 {
			panic("Mass of all particles must be greater than 0")
		}
		total_mass = (total_mass + p.Mass)
		i = (i + 1)
	}
	var sum_x float64 = 0.0
	_ = sum_x
	var sum_y float64 = 0.0
	_ = sum_y
	var sum_z float64 = 0.0
	_ = sum_z
	i = 0
	for i < len(ps) {
		var p Particle = _index(ps, i)
		_ = p
		sum_x = (sum_x + (p.X * p.Mass))
		sum_y = (sum_y + (p.Y * p.Mass))
		sum_z = (sum_z + (p.Z * p.Mass))
		i = (i + 1)
	}
	var cm_x float64 = round2((float64(sum_x) / float64(total_mass)))
	_ = cm_x
	_ = cm_x
	var cm_y float64 = round2((float64(sum_y) / float64(total_mass)))
	_ = cm_y
	_ = cm_y
	var cm_z float64 = round2((float64(sum_z) / float64(total_mass)))
	_ = cm_z
	_ = cm_z
	return Coord3D{
		X: cm_x,
		Y: cm_y,
		Z: cm_z,
	}
}

func coord_to_string(c Coord3D) string {
	return (((((("Coord3D(x=" + fmt.Sprint(c.X)) + ", y=") + fmt.Sprint(c.Y)) + ", z=") + fmt.Sprint(c.Z)) + ")")
}

var r1 Coord3D

var r2 Coord3D

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		r1 = center_of_mass(func(v any) []Particle {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Particle); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Particle{}
				}
				out := make([]Particle, len(arr))
				for i, x := range arr {
					out[i] = x.(Particle)
				}
				return out
			}
			return v.([]Particle)
		}([]Particle{Particle{
			X:    1.5,
			Y:    4.0,
			Z:    3.4,
			Mass: 4.0,
		}, Particle{
			X:    5.0,
			Y:    6.8,
			Z:    7.0,
			Mass: 8.1,
		}, Particle{
			X:    9.4,
			Y:    10.1,
			Z:    11.6,
			Mass: 12.0,
		}}))
		fmt.Println(coord_to_string(r1))
		r2 = center_of_mass(func(v any) []Particle {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Particle); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Particle{}
				}
				out := make([]Particle, len(arr))
				for i, x := range arr {
					out[i] = x.(Particle)
				}
				return out
			}
			return v.([]Particle)
		}([]Particle{Particle{
			X:    1.0,
			Y:    2.0,
			Z:    3.0,
			Mass: 4.0,
		}, Particle{
			X:    5.0,
			Y:    6.0,
			Z:    7.0,
			Mass: 8.0,
		}, Particle{
			X:    9.0,
			Y:    10.0,
			Z:    11.0,
			Mass: 12.0,
		}}))
		fmt.Println(coord_to_string(r2))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
