//go:build ignore

// Generated by Mochi v0.10.69 on 2025-08-19 16:49:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

var PI float64

var TWO_PI float64

var g float64

func _mod(x float64, m float64) float64 {
	return (x - (float64(int((float64(x) / float64(m)))) * m))
}

func sin(x float64) float64 {
	var y float64 = (_mod((x+PI), TWO_PI) - PI)
	_ = y
	var y2 float64 = (y * y)
	_ = y2
	var y3 float64 = (y2 * y)
	_ = y3
	var y5 float64 = (y3 * y2)
	_ = y5
	var y7 float64 = (y5 * y2)
	_ = y7
	_ = y7
	return (((y - (float64(y3) / float64(6.0))) + (float64(y5) / float64(120.0))) - (float64(y7) / float64(5040.0)))
}

func deg_to_rad(deg float64) float64 {
	return (float64((deg * PI)) / float64(180.0))
}

func floor(x float64) float64 {
	var i int = int(x)
	_ = i
	if float64(i) > x {
		i = (i - 1)
	}
	return float64(i)
}

func pow10(n int) float64 {
	var result float64 = 1.0
	_ = result
	var i int = 0
	_ = i
	for i < n {
		result = (result * 10.0)
		i = (i + 1)
	}
	return result
}

func round(x float64, n int) float64 {
	var m float64 = pow10(n)
	_ = m
	var y float64 = floor(((x * m) + 0.5))
	_ = y
	_ = y
	return (float64(y) / float64(m))
}

func check_args(init_velocity float64, angle float64) {
	if (angle > 90.0) || (angle < 1.0) {
		panic("Invalid angle. Range is 1-90 degrees.")
	}
	if init_velocity < 0.0 {
		panic("Invalid velocity. Should be a positive number.")
	}
}

func horizontal_distance(init_velocity float64, angle float64) float64 {
	check_args(init_velocity, angle)
	var radians float64 = deg_to_rad((2.0 * angle))
	_ = radians
	_ = radians
	return round((float64(((init_velocity * init_velocity) * sin(radians))) / float64(g)), 2)
}

func max_height(init_velocity float64, angle float64) float64 {
	check_args(init_velocity, angle)
	var radians float64 = deg_to_rad(angle)
	_ = radians
	var s float64 = sin(radians)
	_ = s
	_ = s
	return round((float64((((init_velocity * init_velocity) * s) * s)) / float64((2.0 * g))), 2)
}

func total_time(init_velocity float64, angle float64) float64 {
	check_args(init_velocity, angle)
	var radians float64 = deg_to_rad(angle)
	_ = radians
	_ = radians
	return round((float64(((2.0 * init_velocity) * sin(radians))) / float64(g)), 2)
}

var v0 float64

var angle float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		TWO_PI = 6.283185307179586
		g = 9.80665
		v0 = 25.0
		angle = 20.0
		fmt.Println(func() string {
			f := float64(horizontal_distance(v0, angle))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if math.Abs(f-float64(int(f))) < 1e-9 {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(max_height(v0, angle))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if math.Abs(f-float64(int(f))) < 1e-9 {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		fmt.Println(func() string {
			f := float64(total_time(v0, angle))
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if math.Abs(f-float64(int(f))) < 1e-9 {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
