//go:build ignore

// Generated by Mochi v0.10.68 on 2025-08-17 20:41:43 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var c float64

func sqrtApprox(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = (float64(x) / float64(2.0))
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func beta(velocity float64) float64 {
	if velocity > c {
		panic("Speed must not exceed light speed 299,792,458 [m/s]!")
	}
	if velocity < 1.0 {
		panic("Speed must be greater than or equal to 1!")
	}
	return (float64(velocity) / float64(c))
}

func gamma(velocity float64) float64 {
	var b float64 = beta(velocity)
	_ = b
	_ = b
	return (float64(1.0) / float64(sqrtApprox((1.0 - (b * b)))))
}

func transformation_matrix(velocity float64) [][]float64 {
	var g float64 = gamma(velocity)
	_ = g
	_ = g
	var b float64 = beta(velocity)
	_ = b
	_ = b
	return [][]float64{[]float64{g, ((0 - g) * b), 0.0, 0.0}, []float64{((0 - g) * b), g, 0.0, 0.0}, []float64{0.0, 0.0, 1.0, 0.0}, []float64{0.0, 0.0, 0.0, 1.0}}
}

func mat_vec_mul(mat [][]float64, vec []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < 4 {
		var row []float64 = _index(mat, i)
		_ = row
		var value float64 = ((((_index(row, 0) * _index(vec, 0)) + (_index(row, 1) * _index(vec, 1))) + (_index(row, 2) * _index(vec, 2))) + (_index(row, 3) * _index(vec, 3)))
		_ = value
		_ = value
		res = func() []float64 {
			tmp := make([]float64, len(res))
			copy(tmp, res)
			tmp = append(tmp, []float64{value}...)
			return tmp
		}()
		i = (i + 1)
	}
	return res
}

func transform(velocity float64, event []float64) []float64 {
	var g float64 = gamma(velocity)
	_ = g
	_ = g
	var b float64 = beta(velocity)
	_ = b
	_ = b
	var ct float64 = (_index(event, 0) * c)
	_ = ct
	_ = ct
	var x float64 = _index(event, 1)
	_ = x
	_ = x
	return []float64{((g * ct) - ((g * b) * x)), ((((0 - g) * b) * ct) + (g * x)), _index(event, 2), _index(event, 3)}
}

var v []float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		c = 299792458.0
		fmt.Println(fmt.Sprint(beta(c)))
		fmt.Println(fmt.Sprint(beta(199792458.0)))
		fmt.Println(fmt.Sprint(beta(100000.0)))
		fmt.Println(fmt.Sprint(gamma(4.0)))
		fmt.Println(fmt.Sprint(gamma(100000.0)))
		fmt.Println(fmt.Sprint(gamma(30000000.0)))
		fmt.Println(fmt.Sprint(transformation_matrix(29979245.0)))
		v = transform(29979245.0, func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}([]float64{1.0, 2.0, 3.0, 4.0}))
		fmt.Println(fmt.Sprint(v))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
