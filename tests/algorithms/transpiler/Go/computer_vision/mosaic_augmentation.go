//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:46:40 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type MosaicResult struct {
	Img   [][]int     `json:"img"`
	Annos [][]float64 `json:"annos"`
	Path  string      `json:"path"`
}

func update_image_and_anno(all_img_list []string, all_annos [][][]float64, idxs []int, output_size []int, scale_range []float64, filter_scale float64) MosaicResult {
	var height int = output_size[0]
	_ = height
	var width int = output_size[1]
	_ = width
	var output_img [][]int
	_ = output_img
	var r int = 0
	_ = r
	for r < height {
		var row []int
		_ = row
		var c int = 0
		_ = c
		for c < width {
			row = append(row, 0)
			c = (c + 1)
		}
		output_img = append(output_img, row)
		r = (r + 1)
	}
	var scale_x float64 = ((scale_range[0] + scale_range[1]) / 2.0)
	_ = scale_x
	var scale_y float64 = ((scale_range[0] + scale_range[1]) / 2.0)
	_ = scale_y
	var divid_point_x int = any((scale_x * float64(width))).(int)
	_ = divid_point_x
	var divid_point_y int = any((scale_y * float64(height))).(int)
	_ = divid_point_y
	var new_anno [][]float64
	_ = new_anno
	var path_list []string
	_ = path_list
	var i int = 0
	_ = i
	for i < len(idxs) {
		var index int = idxs[i]
		_ = index
		var path string = all_img_list[index]
		_ = path
		path_list = append(path_list, path)
		var img_annos [][]float64 = all_annos[index]
		_ = img_annos
		if i == 0 {
			var y0 int = 0
			_ = y0
			for y0 < divid_point_y {
				var x0 int = 0
				_ = x0
				for x0 < divid_point_x {
					output_img[y0][x0] = (i + 1)
					x0 = (x0 + 1)
				}
				y0 = (y0 + 1)
			}
			var j0 int = 0
			_ = j0
			for j0 < len(img_annos) {
				var bbox []float64 = img_annos[j0]
				_ = bbox
				var xmin float64 = (bbox[1] * scale_x)
				_ = xmin
				var ymin float64 = (bbox[2] * scale_y)
				_ = ymin
				var xmax float64 = (bbox[3] * scale_x)
				_ = xmax
				var ymax float64 = (bbox[4] * scale_y)
				_ = ymax
				new_anno = append(new_anno, []float64{bbox[0], xmin, ymin, xmax, ymax})
				j0 = (j0 + 1)
			}
		} else {
			if i == 1 {
				var y1 int = 0
				_ = y1
				for y1 < divid_point_y {
					var x1 int = divid_point_x
					_ = x1
					for x1 < width {
						output_img[y1][x1] = (i + 1)
						x1 = (x1 + 1)
					}
					y1 = (y1 + 1)
				}
				var j1 int = 0
				_ = j1
				for j1 < len(img_annos) {
					var bbox1 []float64 = img_annos[j1]
					_ = bbox1
					var xmin1 float64 = (scale_x + (bbox1[1] * (1.0 - scale_x)))
					_ = xmin1
					var ymin1 float64 = (bbox1[2] * scale_y)
					_ = ymin1
					var xmax1 float64 = (scale_x + (bbox1[3] * (1.0 - scale_x)))
					_ = xmax1
					var ymax1 float64 = (bbox1[4] * scale_y)
					_ = ymax1
					new_anno = append(new_anno, []float64{bbox1[0], xmin1, ymin1, xmax1, ymax1})
					j1 = (j1 + 1)
				}
			} else {
				if i == 2 {
					var y2 int = divid_point_y
					_ = y2
					for y2 < height {
						var x2 int = 0
						_ = x2
						for x2 < divid_point_x {
							output_img[y2][x2] = (i + 1)
							x2 = (x2 + 1)
						}
						y2 = (y2 + 1)
					}
					var j2 int = 0
					_ = j2
					for j2 < len(img_annos) {
						var bbox2 []float64 = img_annos[j2]
						_ = bbox2
						var xmin2 float64 = (bbox2[1] * scale_x)
						_ = xmin2
						var ymin2 float64 = (scale_y + (bbox2[2] * (1.0 - scale_y)))
						_ = ymin2
						var xmax2 float64 = (bbox2[3] * scale_x)
						_ = xmax2
						var ymax2 float64 = (scale_y + (bbox2[4] * (1.0 - scale_y)))
						_ = ymax2
						new_anno = append(new_anno, []float64{bbox2[0], xmin2, ymin2, xmax2, ymax2})
						j2 = (j2 + 1)
					}
				} else {
					var y3 int = divid_point_y
					_ = y3
					for y3 < height {
						var x3 int = divid_point_x
						_ = x3
						for x3 < width {
							output_img[y3][x3] = (i + 1)
							x3 = (x3 + 1)
						}
						y3 = (y3 + 1)
					}
					var j3 int = 0
					_ = j3
					for j3 < len(img_annos) {
						var bbox3 []float64 = img_annos[j3]
						_ = bbox3
						var xmin3 float64 = (scale_x + (bbox3[1] * (1.0 - scale_x)))
						_ = xmin3
						var ymin3 float64 = (scale_y + (bbox3[2] * (1.0 - scale_y)))
						_ = ymin3
						var xmax3 float64 = (scale_x + (bbox3[3] * (1.0 - scale_x)))
						_ = xmax3
						var ymax3 float64 = (scale_y + (bbox3[4] * (1.0 - scale_y)))
						_ = ymax3
						new_anno = append(new_anno, []float64{bbox3[0], xmin3, ymin3, xmax3, ymax3})
						j3 = (j3 + 1)
					}
				}
			}
		}
		i = (i + 1)
	}
	if filter_scale > 0.0 {
		var filtered [][]float64
		_ = filtered
		var k int = 0
		_ = k
		for k < len(new_anno) {
			var anno []float64 = new_anno[k]
			_ = anno
			var w float64 = (anno[3] - anno[1])
			_ = w
			var h float64 = (anno[4] - anno[2])
			_ = h
			if (filter_scale < w) && (filter_scale < h) {
				filtered = append(filtered, anno)
			}
			k = (k + 1)
		}
		new_anno = filtered
	}
	return MosaicResult{
		Img:   output_img,
		Annos: new_anno,
		Path:  path_list[0],
	}
}

func mochiMain() {
	var all_img_list []string = []string{"img0.jpg", "img1.jpg", "img2.jpg", "img3.jpg"}
	_ = all_img_list
	var all_annos [][][]float64 = [][][]float64{[][]float64{[]float64{0.0, 0.1, 0.1, 0.4, 0.4}}, [][]float64{[]float64{1.0, 0.2, 0.3, 0.5, 0.7}}, [][]float64{[]float64{2.0, 0.6, 0.2, 0.9, 0.5}}, [][]float64{[]float64{3.0, 0.5, 0.5, 0.8, 0.8}}}
	_ = all_annos
	var idxs []int = []int{0, 1, 2, 3}
	_ = idxs
	var output_size []int = []int{100, 100}
	_ = output_size
	var scale_range []float64 = []float64{0.4, 0.6}
	_ = scale_range
	var filter_scale float64 = 0.05
	_ = filter_scale
	var res MosaicResult = update_image_and_anno(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(all_img_list), func(v any) [][][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][][]float64{}
			}
			out := make([][][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) [][]float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]float64{}
						}
						out := make([][]float64, len(arr))
						for i, x := range arr {
							out[i] = func(v any) []float64 {
								if v == nil {
									return nil
								}
								if vv, ok := v.([]float64); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return []float64{}
									}
									out := make([]float64, len(arr))
									for i, x := range arr {
										out[i] = x.(float64)
									}
									return out
								}
								return v.([]float64)
							}(x)
						}
						return out
					}
					return v.([][]float64)
				}(x)
			}
			return out
		}
		return v.([][][]float64)
	}(all_annos), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(idxs), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(output_size), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(scale_range), filter_scale)
	_ = res
	var new_annos [][]float64 = res.Annos
	_ = new_annos
	var path string = res.Path
	_ = path
	fmt.Println(("Base image: " + path))
	fmt.Println(("Mosaic annotation count: " + fmt.Sprint(len(new_annos))))
	var i int = 0
	_ = i
	for i < len(new_annos) {
		var a []float64 = new_annos[i]
		_ = a
		fmt.Println(((((((((fmt.Sprint(a[0]) + " ") + fmt.Sprint(a[1])) + " ") + fmt.Sprint(a[2])) + " ") + fmt.Sprint(a[3])) + " ") + fmt.Sprint(a[4])))
		i = (i + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
