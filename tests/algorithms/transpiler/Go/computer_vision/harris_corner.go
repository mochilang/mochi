//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:46:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func zeros(h int, w int) [][]float64 {
	var m [][]float64 = [][]float64{}
	_ = m
	var y int = 0
	_ = y
	for y < h {
		var row []float64 = []float64{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, 0.0)
			x = (x + 1)
		}
		m = append(m, row)
		y = (y + 1)
	}
	return m
}

func gradient(img [][]int) [][][]float64 {
	var h int = len(img)
	_ = h
	var w int = len(img[0])
	_ = w
	var dx [][]float64 = zeros(h, w)
	_ = dx
	var dy [][]float64 = zeros(h, w)
	_ = dy
	var y int = 1
	_ = y
	for y < (h - 1) {
		var x int = 1
		_ = x
		for x < (w - 1) {
			dx[y][x] = (float64(img[y][(x+1)]) - float64(img[y][(x-1)]))
			dy[y][x] = (float64(img[(y + 1)][x]) - float64(img[(y - 1)][x]))
			x = (x + 1)
		}
		y = (y + 1)
	}
	return [][][]float64{dx, dy}
}

func harris(img [][]int, k float64, window int, thresh float64) [][]int {
	var h int = len(img)
	_ = h
	var w int = len(img[0])
	_ = w
	var grads [][][]float64 = gradient(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(img))
	_ = grads
	var dx [][]float64 = grads[0]
	_ = dx
	var dy [][]float64 = grads[1]
	_ = dy
	var ixx [][]float64 = zeros(h, w)
	_ = ixx
	var iyy [][]float64 = zeros(h, w)
	_ = iyy
	var ixy [][]float64 = zeros(h, w)
	_ = ixy
	var y int = 0
	_ = y
	for y < h {
		var x int = 0
		_ = x
		for x < w {
			var gx float64 = dx[y][x]
			_ = gx
			var gy float64 = dy[y][x]
			_ = gy
			ixx[y][x] = (gx * gx)
			iyy[y][x] = (gy * gy)
			ixy[y][x] = (gx * gy)
			x = (x + 1)
		}
		y = (y + 1)
	}
	var offset int = (window / 2)
	_ = offset
	var corners [][]int = [][]int{}
	_ = corners
	y = offset
	for y < (h - offset) {
		var x int = offset
		_ = x
		for x < (w - offset) {
			var wxx float64 = 0.0
			_ = wxx
			var wyy float64 = 0.0
			_ = wyy
			var wxy float64 = 0.0
			_ = wxy
			var yy int = (y - offset)
			_ = yy
			for yy <= (y + offset) {
				var xx int = (x - offset)
				_ = xx
				for xx <= (x + offset) {
					wxx = (wxx + ixx[yy][xx])
					wyy = (wyy + iyy[yy][xx])
					wxy = (wxy + ixy[yy][xx])
					xx = (xx + 1)
				}
				yy = (yy + 1)
			}
			var det float64 = ((wxx * wyy) - (wxy * wxy))
			_ = det
			var trace float64 = (wxx + wyy)
			_ = trace
			var r float64 = (det - (k * (trace * trace)))
			_ = r
			if r > thresh {
				corners = append(corners, []int{x, y})
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return corners
}

var img [][]int

var corners [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		img = [][]int{[]int{1, 1, 1, 1, 1}, []int{1, 255, 255, 255, 1}, []int{1, 255, 0, 255, 1}, []int{1, 255, 255, 255, 1}, []int{1, 1, 1, 1, 1}}
		corners = harris(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), 0.04, 3, 10000000000.0)
		fmt.Println(func() string {
			b, _ := json.Marshal(corners)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
