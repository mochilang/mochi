//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:35:51 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type CalcResult struct {
	Ok    bool    `json:"ok"`
	Value float64 `json:"value"`
	Error string  `json:"error"`
}

func calc_profit(profit []int, weight []int, max_weight int) CalcResult {
	if len(profit) != len(weight) {
		return CalcResult{
			Ok:    false,
			Value: 0.0,
			Error: "The length of profit and weight must be same.",
		}
	}
	if max_weight <= 0 {
		return CalcResult{
			Ok:    false,
			Value: 0.0,
			Error: "max_weight must greater than zero.",
		}
	}
	var i int = 0
	_ = i
	for i < len(profit) {
		if _index(profit, i) < 0 {
			return CalcResult{
				Ok:    false,
				Value: 0.0,
				Error: "Profit can not be negative.",
			}
		}
		if _index(weight, i) < 0 {
			return CalcResult{
				Ok:    false,
				Value: 0.0,
				Error: "Weight can not be negative.",
			}
		}
		i = (i + 1)
	}
	var used []bool = []bool{}
	_ = used
	var j int = 0
	_ = j
	for j < len(profit) {
		used = append(used, false)
		j = (j + 1)
	}
	var limit int = 0
	_ = limit
	var gain float64 = 0.0
	_ = gain
	for limit < max_weight {
		var max_ratio float64 = (0 - 1.0)
		_ = max_ratio
		var idx int = (0 - 1)
		_ = idx
		var k int = 0
		_ = k
		for k < len(profit) {
			if !_index(used, k) {
				var ratio float64 = (float64(_index(profit, k)) / float64(_index(weight, k)))
				_ = ratio
				if ratio > max_ratio {
					max_ratio = ratio
					idx = k
				}
			}
			k = (k + 1)
		}
		if idx == (0 - 1) {
			break
		}
		_setIndex(used, idx, true)
		if (max_weight - limit) >= _index(weight, idx) {
			limit = (limit + _index(weight, idx))
			gain = (gain + float64(_index(profit, idx)))
		} else {
			gain = (gain + ((float64(float64((max_weight - limit))) / float64(_index(weight, idx))) * float64(_index(profit, idx))))
			break
		}
	}
	return CalcResult{
		Ok:    true,
		Value: gain,
		Error: "",
	}
}

func test_sorted() bool {
	var profit []int = []int{10, 20, 30, 40, 50, 60}
	_ = profit
	var weight []int = []int{2, 4, 6, 8, 10, 12}
	_ = weight
	var res CalcResult = calc_profit(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(profit), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(weight), 100)
	_ = res
	_ = res
	return (res.Ok && (res.Value == 210.0))
}

func test_negative_max_weight() bool {
	var profit []int = []int{10, 20, 30, 40, 50, 60}
	_ = profit
	var weight []int = []int{2, 4, 6, 8, 10, 12}
	_ = weight
	var res CalcResult = calc_profit(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(profit), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(weight), (0 - 15))
	_ = res
	_ = res
	return (!res.Ok && (res.Error == "max_weight must greater than zero."))
}

func test_negative_profit_value() bool {
	var profit []int = []int{10, func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 20)), 30, 40, 50, 60}
	_ = profit
	var weight []int = []int{2, 4, 6, 8, 10, 12}
	_ = weight
	var res CalcResult = calc_profit(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(profit), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(weight), 15)
	_ = res
	_ = res
	return (!res.Ok && (res.Error == "Profit can not be negative."))
}

func test_negative_weight_value() bool {
	var profit []int = []int{10, 20, 30, 40, 50, 60}
	_ = profit
	var weight []int = []int{2, func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 4)), 6, func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 8)), 10, 12}
	_ = weight
	var res CalcResult = calc_profit(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(profit), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(weight), 15)
	_ = res
	_ = res
	return (!res.Ok && (res.Error == "Weight can not be negative."))
}

func test_null_max_weight() bool {
	var profit []int = []int{10, 20, 30, 40, 50, 60}
	_ = profit
	var weight []int = []int{2, 4, 6, 8, 10, 12}
	_ = weight
	var res CalcResult = calc_profit(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(profit), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(weight), 0)
	_ = res
	_ = res
	return (!res.Ok && (res.Error == "max_weight must greater than zero."))
}

func test_unequal_list_length() bool {
	var profit []int = []int{10, 20, 30, 40, 50}
	_ = profit
	var weight []int = []int{2, 4, 6, 8, 10, 12}
	_ = weight
	var res CalcResult = calc_profit(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(profit), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(weight), 100)
	_ = res
	_ = res
	return (!res.Ok && (res.Error == "The length of profit and weight must be same."))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		fmt.Println(test_sorted())
		fmt.Println(test_negative_max_weight())
		fmt.Println(test_negative_profit_value())
		fmt.Println(test_negative_weight_value())
		fmt.Println(test_null_max_weight())
		fmt.Println(test_unequal_list_length())
		fmt.Println(true)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
