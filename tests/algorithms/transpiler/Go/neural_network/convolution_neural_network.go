//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-12 09:24:16 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type CNN struct {
	ConvKernels [][][]float64 `json:"conv_kernels"`
	ConvBias    []float64     `json:"conv_bias"`
	ConvStep    int           `json:"conv_step"`
	PoolSize    int           `json:"pool_size"`
	WHidden     [][]float64   `json:"w_hidden"`
	WOut        [][]float64   `json:"w_out"`
	BHidden     []float64     `json:"b_hidden"`
	BOut        []float64     `json:"b_out"`
	RateWeight  float64       `json:"rate_weight"`
	RateBias    float64       `json:"rate_bias"`
}

var seed int

func random() float64 {
	seed = _mod(((seed * 13) + 7), 100)
	return (float64(seed) / float64(100.0))
}

func sigmoid(x float64) float64 {
	return (float64(1.0) / float64((1.0 + exp((0 - x)))))
}

func to_float(x int) float64 {
	return (float64(x) * 1.0)
}

func exp(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var n int = 1
	_ = n
	for n < 20 {
		term = (float64((term * x)) / float64(n))
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

func convolve(data [][]float64, kernel [][]float64, step int, bias float64) [][]float64 {
	var size_data int = len(data)
	_ = size_data
	var size_kernel int = len(kernel)
	_ = size_kernel
	var out [][]float64 = [][]float64{}
	_ = out
	var i int = 0
	_ = i
	for i <= (size_data - size_kernel) {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j <= (size_data - size_kernel) {
			var sum float64 = 0.0
			_ = sum
			var a int = 0
			_ = a
			for a < size_kernel {
				var b int = 0
				_ = b
				for b < size_kernel {
					sum = (sum + (_index(_index(data, (i+a)), (j+b)) * _index(_index(kernel, a), b)))
					b = (b + 1)
				}
				a = (a + 1)
			}
			row = append(row, sigmoid((sum - bias)))
			j = (j + step)
		}
		out = append(out, row)
		i = (i + step)
	}
	return out
}

func average_pool(map_ [][]float64, size int) [][]float64 {
	var out [][]float64 = [][]float64{}
	_ = out
	var i int = 0
	_ = i
	for i < len(map_) {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < len(_index(map_, i)) {
			var sum float64 = 0.0
			_ = sum
			var a int = 0
			_ = a
			for a < size {
				var b int = 0
				_ = b
				for b < size {
					sum = (sum + _index(_index(map_, (i+a)), (j+b)))
					b = (b + 1)
				}
				a = (a + 1)
			}
			row = append(row, (float64(sum) / float64(float64((size * size)))))
			j = (j + size)
		}
		out = append(out, row)
		i = (i + size)
	}
	return out
}

func flatten(maps [][][]float64) []float64 {
	var out []float64 = []float64{}
	_ = out
	var i int = 0
	_ = i
	for i < len(maps) {
		var j int = 0
		_ = j
		for j < len(_index(maps, i)) {
			var k int = 0
			_ = k
			for k < len(_index(_index(maps, i), j)) {
				out = append(out, _index(_index(_index(maps, i), j), k))
				k = (k + 1)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return out
}

func vec_mul_mat(v []float64, m [][]float64) []float64 {
	var cols int = len(_index(m, 0))
	_ = cols
	var res []float64 = []float64{}
	_ = res
	var j int = 0
	_ = j
	for j < cols {
		var sum float64 = 0.0
		_ = sum
		var i int = 0
		_ = i
		for i < len(v) {
			sum = (sum + (_index(v, i) * _index(_index(m, i), j)))
			i = (i + 1)
		}
		res = append(res, sum)
		j = (j + 1)
	}
	return res
}

func matT_vec_mul(m [][]float64, v []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(m) {
		var sum float64 = 0.0
		_ = sum
		var j int = 0
		_ = j
		for j < len(_index(m, i)) {
			sum = (sum + (_index(_index(m, i), j) * _index(v, j)))
			j = (j + 1)
		}
		res = append(res, sum)
		i = (i + 1)
	}
	return res
}

func vec_add(a []float64, b []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, (_index(a, i) + _index(b, i)))
		i = (i + 1)
	}
	return res
}

func vec_sub(a []float64, b []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, (_index(a, i) - _index(b, i)))
		i = (i + 1)
	}
	return res
}

func vec_mul(a []float64, b []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, (_index(a, i) * _index(b, i)))
		i = (i + 1)
	}
	return res
}

func vec_map_sig(v []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(v) {
		res = append(res, sigmoid(_index(v, i)))
		i = (i + 1)
	}
	return res
}

type TrainSample struct {
	Image  [][]float64 `json:"image"`
	Target []float64   `json:"target"`
}

func new_cnn() CNN {
	var k1 [][]float64 = [][]float64{[]float64{1.0, 0.0}, []float64{0.0, 1.0}}
	_ = k1
	var k2 [][]float64 = [][]float64{[]float64{0.0, 1.0}, []float64{1.0, 0.0}}
	_ = k2
	var conv_kernels [][][]float64 = [][][]float64{k1, k2}
	_ = conv_kernels
	_ = conv_kernels
	var conv_bias []float64 = []float64{0.0, 0.0}
	_ = conv_bias
	_ = conv_bias
	var conv_step int = 2
	_ = conv_step
	_ = conv_step
	var pool_size int = 2
	_ = pool_size
	_ = pool_size
	var input_size int = 2
	_ = input_size
	var hidden_size int = 2
	_ = hidden_size
	var output_size int = 2
	_ = output_size
	var w_hidden [][]float64 = [][]float64{}
	_ = w_hidden
	var i int = 0
	_ = i
	for i < input_size {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < hidden_size {
			row = append(row, (random() - 0.5))
			j = (j + 1)
		}
		w_hidden = append(w_hidden, row)
		i = (i + 1)
	}
	var w_out [][]float64 = [][]float64{}
	_ = w_out
	i = 0
	for i < hidden_size {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < output_size {
			row = append(row, (random() - 0.5))
			j = (j + 1)
		}
		w_out = append(w_out, row)
		i = (i + 1)
	}
	var b_hidden []float64 = []float64{0.0, 0.0}
	_ = b_hidden
	_ = b_hidden
	var b_out []float64 = []float64{0.0, 0.0}
	_ = b_out
	_ = b_out
	return CNN{
		ConvKernels: conv_kernels,
		ConvBias:    conv_bias,
		ConvStep:    conv_step,
		PoolSize:    pool_size,
		WHidden:     w_hidden,
		WOut:        w_out,
		BHidden:     b_hidden,
		BOut:        b_out,
		RateWeight:  0.2,
		RateBias:    0.2,
	}
}

func forward(cnn CNN, data [][]float64) []float64 {
	var maps [][][]float64 = [][][]float64{}
	_ = maps
	var i int = 0
	_ = i
	for i < len(cnn.ConvKernels) {
		var conv_map [][]float64 = convolve(func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(data), func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(_index(cnn.ConvKernels, i)), cnn.ConvStep, _index(cnn.ConvBias, i))
		_ = conv_map
		var pooled [][]float64 = average_pool(func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(conv_map), cnn.PoolSize)
		_ = pooled
		maps = append(maps, pooled)
		i = (i + 1)
	}
	var flat []float64 = flatten(func(v any) [][][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][][]float64{}
			}
			out := make([][][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) [][]float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]float64{}
						}
						out := make([][]float64, len(arr))
						for i, x := range arr {
							out[i] = x.([]float64)
						}
						return out
					}
					return v.([][]float64)
				}(x)
			}
			return out
		}
		return v.([][][]float64)
	}(maps))
	_ = flat
	var hidden_net []float64 = vec_add(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(vec_mul_mat(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(flat), func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(cnn.WHidden))), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(cnn.BHidden))
	_ = hidden_net
	var hidden_out []float64 = vec_map_sig(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(hidden_net))
	_ = hidden_out
	var out_net []float64 = vec_add(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(vec_mul_mat(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(hidden_out), func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(cnn.WOut))), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(cnn.BOut))
	_ = out_net
	var out []float64 = vec_map_sig(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(out_net))
	_ = out
	_ = out
	return out
}

func train(cnn CNN, samples []TrainSample, epochs int) CNN {
	var w_out [][]float64 = cnn.WOut
	_ = w_out
	var b_out []float64 = cnn.BOut
	_ = b_out
	var w_hidden [][]float64 = cnn.WHidden
	_ = w_hidden
	var b_hidden []float64 = cnn.BHidden
	_ = b_hidden
	var e int = 0
	_ = e
	for e < epochs {
		var s int = 0
		_ = s
		for s < len(samples) {
			var data [][]float64 = _index(samples, s).Image
			_ = data
			var target []float64 = _index(samples, s).Target
			_ = target
			var maps [][][]float64 = [][][]float64{}
			_ = maps
			var i int = 0
			_ = i
			for i < len(cnn.ConvKernels) {
				var conv_map [][]float64 = convolve(func(v any) [][]float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]float64{}
						}
						out := make([][]float64, len(arr))
						for i, x := range arr {
							out[i] = func(v any) []float64 {
								if v == nil {
									return nil
								}
								if vv, ok := v.([]float64); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return []float64{}
									}
									out := make([]float64, len(arr))
									for i, x := range arr {
										out[i] = x.(float64)
									}
									return out
								}
								return v.([]float64)
							}(x)
						}
						return out
					}
					return v.([][]float64)
				}(data), func(v any) [][]float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]float64{}
						}
						out := make([][]float64, len(arr))
						for i, x := range arr {
							out[i] = func(v any) []float64 {
								if v == nil {
									return nil
								}
								if vv, ok := v.([]float64); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return []float64{}
									}
									out := make([]float64, len(arr))
									for i, x := range arr {
										out[i] = x.(float64)
									}
									return out
								}
								return v.([]float64)
							}(x)
						}
						return out
					}
					return v.([][]float64)
				}(_index(cnn.ConvKernels, i)), cnn.ConvStep, _index(cnn.ConvBias, i))
				_ = conv_map
				var pooled [][]float64 = average_pool(func(v any) [][]float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]float64{}
						}
						out := make([][]float64, len(arr))
						for i, x := range arr {
							out[i] = func(v any) []float64 {
								if v == nil {
									return nil
								}
								if vv, ok := v.([]float64); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return []float64{}
									}
									out := make([]float64, len(arr))
									for i, x := range arr {
										out[i] = x.(float64)
									}
									return out
								}
								return v.([]float64)
							}(x)
						}
						return out
					}
					return v.([][]float64)
				}(conv_map), cnn.PoolSize)
				_ = pooled
				maps = append(maps, pooled)
				i = (i + 1)
			}
			var flat []float64 = flatten(func(v any) [][][]float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][][]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][][]float64{}
					}
					out := make([][][]float64, len(arr))
					for i, x := range arr {
						out[i] = func(v any) [][]float64 {
							if v == nil {
								return nil
							}
							if vv, ok := v.([][]float64); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return [][]float64{}
								}
								out := make([][]float64, len(arr))
								for i, x := range arr {
									out[i] = x.([]float64)
								}
								return out
							}
							return v.([][]float64)
						}(x)
					}
					return out
				}
				return v.([][][]float64)
			}(maps))
			_ = flat
			var hidden_net []float64 = vec_add(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(vec_mul_mat(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(flat), func(v any) [][]float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]float64{}
					}
					out := make([][]float64, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []float64 {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]float64); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []float64{}
								}
								out := make([]float64, len(arr))
								for i, x := range arr {
									out[i] = x.(float64)
								}
								return out
							}
							return v.([]float64)
						}(x)
					}
					return out
				}
				return v.([][]float64)
			}(w_hidden))), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(b_hidden))
			_ = hidden_net
			var hidden_out []float64 = vec_map_sig(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(hidden_net))
			_ = hidden_out
			var out_net []float64 = vec_add(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(vec_mul_mat(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(hidden_out), func(v any) [][]float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]float64{}
					}
					out := make([][]float64, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []float64 {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]float64); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []float64{}
								}
								out := make([]float64, len(arr))
								for i, x := range arr {
									out[i] = x.(float64)
								}
								return out
							}
							return v.([]float64)
						}(x)
					}
					return out
				}
				return v.([][]float64)
			}(w_out))), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(b_out))
			_ = out_net
			var out []float64 = vec_map_sig(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(out_net))
			_ = out
			var error_out []float64 = vec_sub(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(target), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(out))
			_ = error_out
			var pd_out []float64 = vec_mul(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(error_out), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(vec_mul(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(out), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(vec_sub(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}([]float64{1.0, 1.0}), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(out))))))
			_ = pd_out
			var error_hidden []float64 = matT_vec_mul(func(v any) [][]float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]float64{}
					}
					out := make([][]float64, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []float64 {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]float64); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []float64{}
								}
								out := make([]float64, len(arr))
								for i, x := range arr {
									out[i] = x.(float64)
								}
								return out
							}
							return v.([]float64)
						}(x)
					}
					return out
				}
				return v.([][]float64)
			}(w_out), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(pd_out))
			_ = error_hidden
			var pd_hidden []float64 = vec_mul(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(error_hidden), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(vec_mul(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(hidden_out), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(vec_sub(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}([]float64{1.0, 1.0}), func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(hidden_out))))))
			_ = pd_hidden
			var j int = 0
			_ = j
			for j < len(w_out) {
				var k int = 0
				_ = k
				for k < len(_index(w_out, j)) {
					_setIndex(_index(w_out, j), k, (_index(_index(w_out, j), k) + ((cnn.RateWeight * _index(hidden_out, j)) * _index(pd_out, k))))
					k = (k + 1)
				}
				j = (j + 1)
			}
			j = 0
			for j < len(b_out) {
				_setIndex(b_out, j, (_index(b_out, j) - (cnn.RateBias * _index(pd_out, j))))
				j = (j + 1)
			}
			var i_h int = 0
			_ = i_h
			for i_h < len(w_hidden) {
				var j_h int = 0
				_ = j_h
				for j_h < len(_index(w_hidden, i_h)) {
					_setIndex(_index(w_hidden, i_h), j_h, (_index(_index(w_hidden, i_h), j_h) + ((cnn.RateWeight * _index(flat, i_h)) * _index(pd_hidden, j_h))))
					j_h = (j_h + 1)
				}
				i_h = (i_h + 1)
			}
			j = 0
			for j < len(b_hidden) {
				_setIndex(b_hidden, j, (_index(b_hidden, j) - (cnn.RateBias * _index(pd_hidden, j))))
				j = (j + 1)
			}
			s = (s + 1)
		}
		e = (e + 1)
	}
	return CNN{
		ConvKernels: cnn.ConvKernels,
		ConvBias:    cnn.ConvBias,
		ConvStep:    cnn.ConvStep,
		PoolSize:    cnn.PoolSize,
		WHidden:     w_hidden,
		WOut:        w_out,
		BHidden:     b_hidden,
		BOut:        b_out,
		RateWeight:  cnn.RateWeight,
		RateBias:    cnn.RateBias,
	}
}

func mochiMain() {
	var cnn CNN = new_cnn()
	_ = cnn
	var image [][]float64 = [][]float64{[]float64{1.0, 0.0, 1.0, 0.0}, []float64{0.0, 1.0, 0.0, 1.0}, []float64{1.0, 0.0, 1.0, 0.0}, []float64{0.0, 1.0, 0.0, 1.0}}
	_ = image
	var sample TrainSample = TrainSample{
		Image:  image,
		Target: []float64{1.0, 0.0},
	}
	_ = sample
	fmt.Println("Before training:", func() string {
		b, _ := json.Marshal(forward(cnn, func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(image)))
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
	var trained CNN = train(cnn, func(v any) []TrainSample {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]TrainSample); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []TrainSample{}
			}
			out := make([]TrainSample, len(arr))
			for i, x := range arr {
				out[i] = x.(TrainSample)
			}
			return out
		}
		return v.([]TrainSample)
	}([]TrainSample{sample}), 50)
	_ = trained
	_ = trained
	fmt.Println("After training:", func() string {
		b, _ := json.Marshal(forward(trained, func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(image)))
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		seed = 1
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
