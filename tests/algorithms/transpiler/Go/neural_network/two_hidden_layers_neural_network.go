//go:build ignore

// Generated by Mochi v0.10.69 on 2025-08-22 13:07:54 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

type Network struct {
	W1 [][]float64 `json:"w1"`
	W2 [][]float64 `json:"w2"`
	W3 [][]float64 `json:"w3"`
}

func exp_approx(x float64) float64 {
	var sum float64 = 1.0
	_ = sum
	var term float64 = 1.0
	_ = term
	var i int = 1
	_ = i
	for i < 10 {
		term = (float64((term * x)) / float64(_toFloat(float64(i))))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func sigmoid(x float64) float64 {
	return (float64(1.0) / float64((1.0 + exp_approx((0 - x)))))
}

func sigmoid_derivative(x float64) float64 {
	return (x * (1.0 - x))
}

func new_network() Network {
	return Network{
		W1: [][]float64{[]float64{0.1, 0.2, 0.3, 0.4}, []float64{0.5, 0.6, 0.7, 0.8}, []float64{0.9, 1.0, 1.1, 1.2}},
		W2: [][]float64{[]float64{0.1, 0.2, 0.3}, []float64{0.4, 0.5, 0.6}, []float64{0.7, 0.8, 0.9}, []float64{1.0, 1.1, 1.2}},
		W3: [][]float64{[]float64{0.1}, []float64{0.2}, []float64{0.3}},
	}
}

func feedforward(net Network, input []float64) float64 {
	var hidden1 []float64 = []float64{}
	_ = hidden1
	var j int = 0
	_ = j
	for j < 4 {
		var sum1 float64 = 0.0
		_ = sum1
		var i int = 0
		_ = i
		for i < 3 {
			sum1 = (sum1 + (_index(input, i) * _index(_index(net.W1, i), j)))
			i = (i + 1)
		}
		hidden1 = append(hidden1, sigmoid(sum1))
		j = (j + 1)
	}
	var hidden2 []float64 = []float64{}
	_ = hidden2
	var k int = 0
	_ = k
	for k < 3 {
		var sum2 float64 = 0.0
		_ = sum2
		var j2 int = 0
		_ = j2
		for j2 < 4 {
			sum2 = (sum2 + (_index(hidden1, j2) * _index(_index(net.W2, j2), k)))
			j2 = (j2 + 1)
		}
		hidden2 = append(hidden2, sigmoid(sum2))
		k = (k + 1)
	}
	var sum3 float64 = 0.0
	_ = sum3
	var k2 int = 0
	_ = k2
	for k2 < 3 {
		sum3 = (sum3 + (_index(hidden2, k2) * _index(_index(net.W3, k2), 0)))
		k2 = (k2 + 1)
	}
	var out float64 = sigmoid(sum3)
	_ = out
	_ = out
	return out
}

func train(net *Network, inputs [][]float64, outputs []float64, iterations int) {
	var iter int = 0
	_ = iter
	for iter < iterations {
		var s int = 0
		_ = s
		for s < len(inputs) {
			var inp []float64 = _index(inputs, s)
			_ = inp
			var target float64 = _index(outputs, s)
			_ = target
			var hidden1 []float64 = []float64{}
			_ = hidden1
			var j int = 0
			_ = j
			for j < 4 {
				var sum1 float64 = 0.0
				_ = sum1
				var i int = 0
				_ = i
				for i < 3 {
					sum1 = (sum1 + (_index(inp, i) * _index(_index(net.W1, i), j)))
					i = (i + 1)
				}
				hidden1 = append(hidden1, sigmoid(sum1))
				j = (j + 1)
			}
			var hidden2 []float64 = []float64{}
			_ = hidden2
			var k int = 0
			_ = k
			for k < 3 {
				var sum2 float64 = 0.0
				_ = sum2
				var j2 int = 0
				_ = j2
				for j2 < 4 {
					sum2 = (sum2 + (_index(hidden1, j2) * _index(_index(net.W2, j2), k)))
					j2 = (j2 + 1)
				}
				hidden2 = append(hidden2, sigmoid(sum2))
				k = (k + 1)
			}
			var sum3 float64 = 0.0
			_ = sum3
			var k3 int = 0
			_ = k3
			for k3 < 3 {
				sum3 = (sum3 + (_index(hidden2, k3) * _index(_index(net.W3, k3), 0)))
				k3 = (k3 + 1)
			}
			var output float64 = sigmoid(sum3)
			_ = output
			var error float64 = (target - output)
			_ = error
			var delta_output float64 = (error * sigmoid_derivative(output))
			_ = delta_output
			var new_w3 [][]float64 = [][]float64{}
			_ = new_w3
			var k4 int = 0
			_ = k4
			for k4 < 3 {
				var w3row []float64 = _index(net.W3, k4)
				_ = w3row
				_setIndex(w3row, 0, (_index(w3row, 0) + (_index(hidden2, k4) * delta_output)))
				new_w3 = append(new_w3, w3row)
				k4 = (k4 + 1)
			}
			net.W3 = new_w3
			var delta_hidden2 []float64 = []float64{}
			_ = delta_hidden2
			var k5 int = 0
			_ = k5
			for k5 < 3 {
				var row []float64 = _index(net.W3, k5)
				_ = row
				var dh2 float64 = ((_index(row, 0) * delta_output) * sigmoid_derivative(_index(hidden2, k5)))
				_ = dh2
				delta_hidden2 = append(delta_hidden2, dh2)
				k5 = (k5 + 1)
			}
			var new_w2 [][]float64 = [][]float64{}
			_ = new_w2
			j = 0
			for j < 4 {
				var w2row []float64 = _index(net.W2, j)
				_ = w2row
				var k6 int = 0
				_ = k6
				for k6 < 3 {
					_setIndex(w2row, k6, (_index(w2row, k6) + (_index(hidden1, j) * _index(delta_hidden2, k6))))
					k6 = (k6 + 1)
				}
				new_w2 = append(new_w2, w2row)
				j = (j + 1)
			}
			net.W2 = new_w2
			var delta_hidden1 []float64 = []float64{}
			_ = delta_hidden1
			j = 0
			for j < 4 {
				var sumdh float64 = 0.0
				_ = sumdh
				var k7 int = 0
				_ = k7
				for k7 < 3 {
					var row2 []float64 = _index(net.W2, j)
					_ = row2
					sumdh = (sumdh + (_index(row2, k7) * _index(delta_hidden2, k7)))
					k7 = (k7 + 1)
				}
				delta_hidden1 = append(delta_hidden1, (sumdh * sigmoid_derivative(_index(hidden1, j))))
				j = (j + 1)
			}
			var new_w1 [][]float64 = [][]float64{}
			_ = new_w1
			var i2 int = 0
			_ = i2
			for i2 < 3 {
				var w1row []float64 = _index(net.W1, i2)
				_ = w1row
				j = 0
				for j < 4 {
					_setIndex(w1row, j, (_index(w1row, j) + (_index(inp, i2) * _index(delta_hidden1, j))))
					j = (j + 1)
				}
				new_w1 = append(new_w1, w1row)
				i2 = (i2 + 1)
			}
			net.W1 = new_w1
			s = (s + 1)
		}
		iter = (iter + 1)
	}
}

func predict(net Network, input []float64) int {
	var out float64 = feedforward(net, func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(input))
	_ = out
	if out > 0.6 {
		return 1
	}
	return 0
}

func example() int {
	var inputs [][]float64 = [][]float64{[]float64{0.0, 0.0, 0.0}, []float64{0.0, 0.0, 1.0}, []float64{0.0, 1.0, 0.0}, []float64{0.0, 1.0, 1.0}, []float64{1.0, 0.0, 0.0}, []float64{1.0, 0.0, 1.0}, []float64{1.0, 1.0, 0.0}, []float64{1.0, 1.0, 1.0}}
	_ = inputs
	var outputs []float64 = []float64{0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0}
	_ = outputs
	var net Network = new_network()
	_ = net
	train(&net, func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(inputs), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(outputs), 10)
	var result int = predict(net, func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{1.0, 1.0, 1.0}))
	_ = result
	fmt.Println(fmt.Sprint(result))
	return result
}

func mochiMain() {
	example()
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
