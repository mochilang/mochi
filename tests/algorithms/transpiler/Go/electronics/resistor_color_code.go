//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 18:15:56 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

var valid_colors []string

var significant_figures_color_values map[string]int

var multiplier_color_values map[string]float64

var tolerance_color_values map[string]float64

var temperature_coeffecient_color_values map[string]int

func contains(list []string, value string) bool {
	for _, c := range list {
		if c == value {
			return true
		}
	}
	return false
}

func get_significant_digits(colors []string) int {
	var digit int = 0
	_ = digit
	for _, color := range colors {
		if !func() bool { _, ok := significant_figures_color_values[color]; return ok }() {
			panic((color + " is not a valid color for significant figure bands"))
		}
		digit = ((digit * 10) + int(significant_figures_color_values[color]))
	}
	return digit
}

func get_multiplier(color string) float64 {
	if !func() bool { _, ok := multiplier_color_values[color]; return ok }() {
		panic((color + " is not a valid color for multiplier band"))
	}
	return multiplier_color_values[color]
}

func get_tolerance(color string) float64 {
	if !func() bool { _, ok := tolerance_color_values[color]; return ok }() {
		panic((color + " is not a valid color for tolerance band"))
	}
	return tolerance_color_values[color]
}

func get_temperature_coeffecient(color string) int {
	if !func() bool { _, ok := temperature_coeffecient_color_values[color]; return ok }() {
		panic((color + " is not a valid color for temperature coeffecient band"))
	}
	return temperature_coeffecient_color_values[color]
}

func get_band_type_count(total int, typ string) int {
	if total == 3 {
		if typ == "significant" {
			return 2
		}
		if typ == "multiplier" {
			return 1
		}
		panic((typ + " is not valid for a 3 band resistor"))
	} else {
		if total == 4 {
			if typ == "significant" {
				return 2
			}
			if typ == "multiplier" {
				return 1
			}
			if typ == "tolerance" {
				return 1
			}
			panic((typ + " is not valid for a 4 band resistor"))
		} else {
			if total == 5 {
				if typ == "significant" {
					return 3
				}
				if typ == "multiplier" {
					return 1
				}
				if typ == "tolerance" {
					return 1
				}
				panic((typ + " is not valid for a 5 band resistor"))
			} else {
				if total == 6 {
					if typ == "significant" {
						return 3
					}
					if typ == "multiplier" {
						return 1
					}
					if typ == "tolerance" {
						return 1
					}
					if typ == "temp_coeffecient" {
						return 1
					}
					panic((typ + " is not valid for a 6 band resistor"))
				} else {
					panic((fmt.Sprint(total) + " is not a valid number of bands"))
				}
			}
		}
	}
}

func check_validity(number_of_bands int, colors []string) bool {
	if (number_of_bands < 3) || (number_of_bands > 6) {
		panic("Invalid number of bands. Resistor bands must be 3 to 6")
	}
	if number_of_bands != len(colors) {
		panic((((("Expecting " + fmt.Sprint(number_of_bands)) + " colors, provided ") + fmt.Sprint(len(colors))) + " colors"))
	}
	for _, color := range colors {
		if !contains(valid_colors, color) {
			panic((color + " is not a valid color"))
		}
	}
	return true
}

func calculate_resistance(number_of_bands int, color_code_list []string) string {
	check_validity(number_of_bands, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(color_code_list))
	sig_count := get_band_type_count(number_of_bands, "significant")
	_ = sig_count
	var significant_colors string = color_code_list[0:sig_count]
	_ = significant_colors
	significant_digits := get_significant_digits(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(significant_colors))
	_ = significant_digits
	var multiplier_color string = _index(color_code_list, sig_count)
	_ = multiplier_color
	multiplier := get_multiplier(multiplier_color)
	_ = multiplier
	var tolerance float64 = 20.0
	_ = tolerance
	if number_of_bands >= 4 {
		var tolerance_color string = _index(color_code_list, (sig_count + 1))
		_ = tolerance_color
		tolerance = get_tolerance(tolerance_color)
	}
	var temp_coeff int = 0
	_ = temp_coeff
	if number_of_bands == 6 {
		var temp_color string = _index(color_code_list, (sig_count + 2))
		_ = temp_color
		temp_coeff = get_temperature_coeffecient(temp_color)
	}
	resistance_value := (_toFloat(multiplier) * _toFloat(significant_digits))
	_ = resistance_value
	var resistance_str string = fmt.Sprint(resistance_value)
	_ = resistance_str
	if resistance_value == resistance_value {
		resistance_str = fmt.Sprint(resistance_value)
	}
	var answer string = (((resistance_str + "Î© Â±") + fmt.Sprint(tolerance)) + "% ")
	_ = answer
	if temp_coeff != 0 {
		answer = ((answer + fmt.Sprint(temp_coeff)) + " ppm/K")
	}
	return answer
}

var __mochi_test_header_printed bool

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		valid_colors = []string{"Black", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey", "White", "Gold", "Silver"}
		significant_figures_color_values = map[string]int{"Black": 0, "Brown": 1, "Red": 2, "Orange": 3, "Yellow": 4, "Green": 5, "Blue": 6, "Violet": 7, "Grey": 8, "White": 9}
		multiplier_color_values = map[string]float64{"Black": 1.0, "Brown": 10.0, "Red": 100.0, "Orange": 1000.0, "Yellow": 10000.0, "Green": 100000.0, "Blue": 1000000.0, "Violet": 10000000.0, "Grey": 100000000.0, "White": 1000000000.0, "Gold": 0.1, "Silver": 0.01}
		tolerance_color_values = map[string]float64{"Brown": 1.0, "Red": 2.0, "Orange": 0.05, "Yellow": 0.02, "Green": 0.5, "Blue": 0.25, "Violet": 0.1, "Grey": 0.01, "Gold": 5.0, "Silver": 10.0}
		temperature_coeffecient_color_values = map[string]int{"Black": 250, "Brown": 100, "Red": 50, "Orange": 15, "Yellow": 25, "Green": 20, "Blue": 10, "Violet": 5, "Grey": 1}
		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/electronics/resistor_color_code.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (calculate_resistance(3, func(v any) []string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []string{}
						}
						out := make([]string, len(arr))
						for i, x := range arr {
							out[i] = x.(string)
						}
						return out
					}
					return v.([]string)
				}([]string{"Black", "Blue", "Orange"})) == "6000Î© Â±20% ")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "3 band resistor")
		}()

		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/electronics/resistor_color_code.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (calculate_resistance(4, func(v any) []string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []string{}
						}
						out := make([]string, len(arr))
						for i, x := range arr {
							out[i] = x.(string)
						}
						return out
					}
					return v.([]string)
				}([]string{"Orange", "Green", "Blue", "Gold"})) == "35000000Î© Â±5% ")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "4 band resistor")
		}()

		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/electronics/resistor_color_code.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (calculate_resistance(5, func(v any) []string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []string{}
						}
						out := make([]string, len(arr))
						for i, x := range arr {
							out[i] = x.(string)
						}
						return out
					}
					return v.([]string)
				}([]string{"Violet", "Brown", "Grey", "Silver", "Green"})) == "7.18Î© Â±0.5% ")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "5 band resistor")
		}()

		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/electronics/resistor_color_code.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (calculate_resistance(6, func(v any) []string {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]string); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []string{}
						}
						out := make([]string, len(arr))
						for i, x := range arr {
							out[i] = x.(string)
						}
						return out
					}
					return v.([]string)
				}([]string{"Red", "Green", "Blue", "Yellow", "Orange", "Grey"})) == "2560000Î© Â±0.05% 1 ppm/K")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "6 band resistor")
		}()

		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
