//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:59:05 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var ELECTRON_CHARGE float64

type Result struct {
	Kind  string  `json:"kind"`
	Value float64 `json:"value"`
}

func electric_conductivity(conductivity float64, electron_conc float64, mobility float64) Result {
	var zero_count int = 0
	_ = zero_count
	if conductivity == 0.0 {
		zero_count = (zero_count + 1)
	}
	if electron_conc == 0.0 {
		zero_count = (zero_count + 1)
	}
	if mobility == 0.0 {
		zero_count = (zero_count + 1)
	}
	if zero_count != 1 {
		panic("You cannot supply more or less than 2 values")
	}
	if conductivity < 0.0 {
		panic("Conductivity cannot be negative")
	}
	if electron_conc < 0.0 {
		panic("Electron concentration cannot be negative")
	}
	if mobility < 0.0 {
		panic("mobility cannot be negative")
	}
	if conductivity == 0.0 {
		return Result{
			Kind:  "conductivity",
			Value: ((mobility * electron_conc) * ELECTRON_CHARGE),
		}
	}
	if electron_conc == 0.0 {
		return Result{
			Kind:  "electron_conc",
			Value: (float64(conductivity) / float64((mobility * ELECTRON_CHARGE))),
		}
	}
	return Result{
		Kind:  "mobility",
		Value: (float64(conductivity) / float64((electron_conc * ELECTRON_CHARGE))),
	}
}

var r1 Result

var r2 Result

var r3 Result

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		ELECTRON_CHARGE = 1.6021e-19
		r1 = electric_conductivity(25.0, 100.0, 0.0)
		r2 = electric_conductivity(0.0, 1600.0, 200.0)
		r3 = electric_conductivity(1000.0, 0.0, 1200.0)
		fmt.Println(((r1.Kind + " ") + fmt.Sprint(r1.Value)))
		fmt.Println(((r2.Kind + " ") + fmt.Sprint(r2.Value)))
		fmt.Println(((r3.Kind + " ") + fmt.Sprint(r3.Value)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
