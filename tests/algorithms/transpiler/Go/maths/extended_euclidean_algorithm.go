//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-12 08:22:46 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Coeffs struct {
	X int `json:"x"`
	Y int `json:"y"`
}

func abs_val(n int) int {
	if n < 0 {
		return (0 - n)
	}
	return n
}

func extended_euclidean_algorithm(a int, b int) Coeffs {
	if abs_val(a) == 1 {
		return Coeffs{
			X: a,
			Y: 0,
		}
	}
	if abs_val(b) == 1 {
		return Coeffs{
			X: 0,
			Y: b,
		}
	}
	var old_remainder int = a
	_ = old_remainder
	var remainder int = b
	_ = remainder
	var old_coeff_a int = 1
	_ = old_coeff_a
	var coeff_a int = 0
	_ = coeff_a
	var old_coeff_b int = 0
	_ = old_coeff_b
	var coeff_b int = 1
	_ = coeff_b
	for remainder != 0 {
		var quotient int = (old_remainder / remainder)
		_ = quotient
		var temp_remainder int = (old_remainder - (quotient * remainder))
		_ = temp_remainder
		old_remainder = remainder
		remainder = temp_remainder
		var temp_a int = (old_coeff_a - (quotient * coeff_a))
		_ = temp_a
		old_coeff_a = coeff_a
		coeff_a = temp_a
		var temp_b int = (old_coeff_b - (quotient * coeff_b))
		_ = temp_b
		old_coeff_b = coeff_b
		coeff_b = temp_b
	}
	if a < 0 {
		old_coeff_a = (0 - old_coeff_a)
	}
	if b < 0 {
		old_coeff_b = (0 - old_coeff_b)
	}
	return Coeffs{
		X: old_coeff_a,
		Y: old_coeff_b,
	}
}

func test_extended_euclidean_algorithm() {
	var r1 Coeffs = extended_euclidean_algorithm(1, 24)
	_ = r1
	if (r1.X != 1) || (r1.Y != 0) {
		panic("test1 failed")
	}
	var r2 Coeffs = extended_euclidean_algorithm(8, 14)
	_ = r2
	if (r2.X != 2) || (r2.Y != (0 - 1)) {
		panic("test2 failed")
	}
	var r3 Coeffs = extended_euclidean_algorithm(240, 46)
	_ = r3
	if (r3.X != (0 - 9)) || (r3.Y != 47) {
		panic("test3 failed")
	}
	var r4 Coeffs = extended_euclidean_algorithm(1, (0 - 4))
	_ = r4
	if (r4.X != 1) || (r4.Y != 0) {
		panic("test4 failed")
	}
	var r5 Coeffs = extended_euclidean_algorithm((0 - 2), (0 - 4))
	_ = r5
	if (r5.X != (0 - 1)) || (r5.Y != 0) {
		panic("test5 failed")
	}
	var r6 Coeffs = extended_euclidean_algorithm(0, (0 - 4))
	_ = r6
	if (r6.X != 0) || (r6.Y != (0 - 1)) {
		panic("test6 failed")
	}
	var r7 Coeffs = extended_euclidean_algorithm(2, 0)
	_ = r7
	if (r7.X != 1) || (r7.Y != 0) {
		panic("test7 failed")
	}
}

func mochiMain() {
	test_extended_euclidean_algorithm()
	var res Coeffs = extended_euclidean_algorithm(240, 46)
	_ = res
	fmt.Println((((("(" + fmt.Sprint(res.X)) + ", ") + fmt.Sprint(res.Y)) + ")"))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
