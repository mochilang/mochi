//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 14:58:27 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type Dual struct {
	Real  float64   `json:"real"`
	Duals []float64 `json:"duals"`
}

func make_dual(real float64, rank int) Dual {
	var ds []float64 = []float64{}
	_ = ds
	var i int = 0
	_ = i
	for i < rank {
		ds = append(ds, 1.0)
		i = (i + 1)
	}
	return Dual{
		Real:  real,
		Duals: ds,
	}
}

func dual_from_list(real float64, ds []float64) Dual {
	return Dual{
		Real:  real,
		Duals: ds,
	}
}

func dual_add(a Dual, b Dual) Dual {
	var s_dual []float64 = []float64{}
	_ = s_dual
	var i int = 0
	_ = i
	for i < len(a.Duals) {
		s_dual = append(s_dual, _index(a.Duals, i))
		i = (i + 1)
	}
	var o_dual []float64 = []float64{}
	_ = o_dual
	var j int = 0
	_ = j
	for j < len(b.Duals) {
		o_dual = append(o_dual, _index(b.Duals, j))
		j = (j + 1)
	}
	if len(s_dual) > len(o_dual) {
		var diff int = (len(s_dual) - len(o_dual))
		_ = diff
		var k int = 0
		_ = k
		for k < diff {
			o_dual = append(o_dual, 1.0)
			k = (k + 1)
		}
	} else {
		if len(s_dual) < len(o_dual) {
			var diff2 int = (len(o_dual) - len(s_dual))
			_ = diff2
			var k2 int = 0
			_ = k2
			for k2 < diff2 {
				s_dual = append(s_dual, 1.0)
				k2 = (k2 + 1)
			}
		}
	}
	var new_duals []float64 = []float64{}
	_ = new_duals
	var idx int = 0
	_ = idx
	for idx < len(s_dual) {
		new_duals = append(new_duals, (_index(s_dual, idx) + _index(o_dual, idx)))
		idx = (idx + 1)
	}
	return Dual{
		Real:  (a.Real + b.Real),
		Duals: new_duals,
	}
}

func dual_add_real(a Dual, b float64) Dual {
	var ds []float64 = []float64{}
	_ = ds
	var i int = 0
	_ = i
	for i < len(a.Duals) {
		ds = append(ds, _index(a.Duals, i))
		i = (i + 1)
	}
	return Dual{
		Real:  (a.Real + b),
		Duals: ds,
	}
}

func dual_mul(a Dual, b Dual) Dual {
	var new_len int = ((len(a.Duals) + len(b.Duals)) + 1)
	_ = new_len
	var new_duals []float64 = []float64{}
	_ = new_duals
	var idx int = 0
	_ = idx
	for idx < new_len {
		new_duals = append(new_duals, 0.0)
		idx = (idx + 1)
	}
	var i int = 0
	_ = i
	for i < len(a.Duals) {
		var j int = 0
		_ = j
		for j < len(b.Duals) {
			var pos int = ((i + j) + 1)
			_ = pos
			var val float64 = (_index(new_duals, pos) + (_index(a.Duals, i) * _index(b.Duals, j)))
			_ = val
			_setIndex(new_duals, pos, val)
			j = (j + 1)
		}
		i = (i + 1)
	}
	var k int = 0
	_ = k
	for k < len(a.Duals) {
		var val float64 = (_index(new_duals, k) + (_index(a.Duals, k) * b.Real))
		_ = val
		_setIndex(new_duals, k, val)
		k = (k + 1)
	}
	var l int = 0
	_ = l
	for l < len(b.Duals) {
		var val float64 = (_index(new_duals, l) + (_index(b.Duals, l) * a.Real))
		_ = val
		_setIndex(new_duals, l, val)
		l = (l + 1)
	}
	return Dual{
		Real:  (a.Real * b.Real),
		Duals: new_duals,
	}
}

func dual_mul_real(a Dual, b float64) Dual {
	var ds []float64 = []float64{}
	_ = ds
	var i int = 0
	_ = i
	for i < len(a.Duals) {
		ds = append(ds, (_index(a.Duals, i) * b))
		i = (i + 1)
	}
	return Dual{
		Real:  (a.Real * b),
		Duals: ds,
	}
}

func dual_pow(x Dual, n int) Dual {
	if n < 0 {
		panic("power must be a positive integer")
	}
	if n == 0 {
		return Dual{
			Real:  1.0,
			Duals: []float64{},
		}
	}
	var res Dual = x
	_ = res
	var i int = 1
	_ = i
	for i < n {
		res = dual_mul(res, x)
		i = (i + 1)
	}
	return res
}

func factorial(n int) float64 {
	var res float64 = 1.0
	_ = res
	var i int = 2
	_ = i
	for i <= n {
		res = (res * float64(i))
		i = (i + 1)
	}
	return res
}

func differentiate(func_ func(Dual) Dual, position float64, order int) float64 {
	var d Dual = make_dual(position, 1)
	_ = d
	var result Dual = func_(d)
	_ = result
	_ = result
	if order == 0 {
		return result.Real
	}
	return (_index(result.Duals, (order-1)) * factorial(order))
}

func test_differentiate() {
	var f1 func(Dual) Dual
	_ = f1
	f1 = func(x Dual) Dual {
		return dual_pow(x, 2)
	}
	if differentiate(f1, 2.0, 2) != 2.0 {
		panic("f1 failed")
	}
	var f2 func(Dual) Dual
	_ = f2
	f2 = func(x Dual) Dual {
		return dual_mul(dual_pow(x, 2), dual_pow(x, 4))
	}
	if differentiate(f2, 9.0, 2) != 196830.0 {
		panic("f2 failed")
	}
	var f3 func(Dual) Dual
	_ = f3
	f3 = func(y Dual) Dual {
		return dual_mul_real(dual_pow(dual_add_real(y, 3.0), 6), 0.5)
	}
	if differentiate(f3, 3.5, 4) != 7605.0 {
		panic("f3 failed")
	}
	var f4 func(Dual) Dual
	_ = f4
	f4 = func(y Dual) Dual {
		return dual_pow(y, 2)
	}
	if differentiate(f4, 4.0, 3) != 0.0 {
		panic("f4 failed")
	}
}

func mochiMain() {
	test_differentiate()
	var f func(Dual) Dual
	_ = f
	f = func(y Dual) Dual {
		return dual_mul(dual_pow(y, 2), dual_pow(y, 4))
	}
	var res float64 = differentiate(f, 9.0, 2)
	_ = res
	_ = res
	fmt.Println(func() string {
		f := float64(res)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
