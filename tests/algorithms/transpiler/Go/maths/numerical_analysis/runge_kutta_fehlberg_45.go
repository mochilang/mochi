//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-12 08:26:26 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func runge_kutta_fehlberg_45(func_ func(float64, float64) float64, x_initial float64, y_initial float64, step_size float64, x_final float64) []float64 {
	if x_initial >= x_final {
		panic("The final value of x must be greater than initial value of x.")
	}
	if step_size <= 0.0 {
		panic("Step size must be positive.")
	}
	var n int = int((float64((x_final - x_initial)) / float64(step_size)))
	_ = n
	var ys []float64 = []float64{}
	_ = ys
	var x float64 = x_initial
	_ = x
	var y float64 = y_initial
	_ = y
	ys = append(ys, y)
	var i int = 0
	_ = i
	for i < n {
		var k1 float64 = (step_size * func_(x, y))
		_ = k1
		var k2 float64 = (step_size * func_((x+(float64(step_size)/float64(4.0))), (y+(float64(k1)/float64(4.0)))))
		_ = k2
		var k3 float64 = (step_size * func_((x+((float64(3.0)/float64(8.0))*step_size)), ((y+((float64(3.0)/float64(32.0))*k1))+((float64(9.0)/float64(32.0))*k2))))
		_ = k3
		var k4 float64 = (step_size * func_((x+((float64(12.0)/float64(13.0))*step_size)), (((y+((float64(1932.0)/float64(2197.0))*k1))-((float64(7200.0)/float64(2197.0))*k2))+((float64(7296.0)/float64(2197.0))*k3))))
		_ = k4
		var k5 float64 = (step_size * func_((x+step_size), ((((y+((float64(439.0)/float64(216.0))*k1))-(8.0*k2))+((float64(3680.0)/float64(513.0))*k3))-((float64(845.0)/float64(4104.0))*k4))))
		_ = k5
		var k6 float64 = (step_size * func_((x+(float64(step_size)/float64(2.0))), (((((y-((float64(8.0)/float64(27.0))*k1))+(2.0*k2))-((float64(3544.0)/float64(2565.0))*k3))+((float64(1859.0)/float64(4104.0))*k4))-((float64(11.0)/float64(40.0))*k5))))
		_ = k6
		y = (((((y + ((float64(16.0) / float64(135.0)) * k1)) + ((float64(6656.0) / float64(12825.0)) * k3)) + ((float64(28561.0) / float64(56430.0)) * k4)) - ((float64(9.0) / float64(50.0)) * k5)) + ((float64(2.0) / float64(55.0)) * k6))
		x = (x + step_size)
		ys = append(ys, y)
		i = (i + 1)
	}
	return ys
}

func mochiMain() {
	var f1 func(float64, float64) float64
	_ = f1
	f1 = func(x float64, y float64) float64 {
		return (1.0 + (y * y))
	}
	var y1 []float64 = runge_kutta_fehlberg_45(f1, 0.0, 0.0, 0.2, 1.0)
	_ = y1
	_ = y1
	fmt.Println(func() string {
		f := float64(_index(y1, 1))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var f2 func(float64, float64) float64
	_ = f2
	f2 = func(x float64, y float64) float64 {
		return x
	}
	var y2 []float64 = runge_kutta_fehlberg_45(f2, (0 - 1.0), 0.0, 0.2, 0.0)
	_ = y2
	_ = y2
	fmt.Println(func() string {
		f := float64(_index(y2, 1))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
