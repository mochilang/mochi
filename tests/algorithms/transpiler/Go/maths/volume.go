//go:build ignore

// Generated by Mochi v0.10.67 on 2025-08-17 12:40:11 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

var PI float64

var SQRT5 float64

func minf(a float64, b float64) float64 {
	if a < b {
		return a
	}
	return b
}

func maxf(a float64, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

func vol_cube(side_length float64) float64 {
	if side_length < 0.0 {
		panic("vol_cube() only accepts non-negative values")
	}
	return ((side_length * side_length) * side_length)
}

func vol_spherical_cap(height float64, radius float64) float64 {
	if (height < 0.0) || (radius < 0.0) {
		panic("vol_spherical_cap() only accepts non-negative values")
	}
	return (((((float64(1.0) / float64(3.0)) * PI) * height) * height) * ((3.0 * radius) - height))
}

func vol_sphere(radius float64) float64 {
	if radius < 0.0 {
		panic("vol_sphere() only accepts non-negative values")
	}
	return (((((float64(4.0) / float64(3.0)) * PI) * radius) * radius) * radius)
}

func vol_spheres_intersect(radius_1 float64, radius_2 float64, centers_distance float64) float64 {
	if ((radius_1 < 0.0) || (radius_2 < 0.0)) || (centers_distance < 0.0) {
		panic("vol_spheres_intersect() only accepts non-negative values")
	}
	if centers_distance == 0.0 {
		return vol_sphere(minf(radius_1, radius_2))
	}
	var h1 float64 = (float64((((radius_1 - radius_2) + centers_distance) * ((radius_1 + radius_2) - centers_distance))) / float64((2.0 * centers_distance)))
	_ = h1
	_ = h1
	var h2 float64 = (float64((((radius_2 - radius_1) + centers_distance) * ((radius_2 + radius_1) - centers_distance))) / float64((2.0 * centers_distance)))
	_ = h2
	_ = h2
	return (vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1))
}

func vol_spheres_union(radius_1 float64, radius_2 float64, centers_distance float64) float64 {
	if ((radius_1 <= 0.0) || (radius_2 <= 0.0)) || (centers_distance < 0.0) {
		panic("vol_spheres_union() only accepts non-negative values, non-zero radius")
	}
	if centers_distance == 0.0 {
		return vol_sphere(maxf(radius_1, radius_2))
	}
	return ((vol_sphere(radius_1) + vol_sphere(radius_2)) - vol_spheres_intersect(radius_1, radius_2, centers_distance))
}

func vol_cuboid(width float64, height float64, length float64) float64 {
	if ((width < 0.0) || (height < 0.0)) || (length < 0.0) {
		panic("vol_cuboid() only accepts non-negative values")
	}
	return ((width * height) * length)
}

func vol_cone(area_of_base float64, height float64) float64 {
	if (height < 0.0) || (area_of_base < 0.0) {
		panic("vol_cone() only accepts non-negative values")
	}
	return (float64((area_of_base * height)) / float64(3.0))
}

func vol_right_circ_cone(radius float64, height float64) float64 {
	if (height < 0.0) || (radius < 0.0) {
		panic("vol_right_circ_cone() only accepts non-negative values")
	}
	return (float64((((PI * radius) * radius) * height)) / float64(3.0))
}

func vol_prism(area_of_base float64, height float64) float64 {
	if (height < 0.0) || (area_of_base < 0.0) {
		panic("vol_prism() only accepts non-negative values")
	}
	return (area_of_base * height)
}

func vol_pyramid(area_of_base float64, height float64) float64 {
	if (height < 0.0) || (area_of_base < 0.0) {
		panic("vol_pyramid() only accepts non-negative values")
	}
	return (float64((area_of_base * height)) / float64(3.0))
}

func vol_hemisphere(radius float64) float64 {
	if radius < 0.0 {
		panic("vol_hemisphere() only accepts non-negative values")
	}
	return (float64(((((radius * radius) * radius) * PI) * 2.0)) / float64(3.0))
}

func vol_circular_cylinder(radius float64, height float64) float64 {
	if (height < 0.0) || (radius < 0.0) {
		panic("vol_circular_cylinder() only accepts non-negative values")
	}
	return (((radius * radius) * height) * PI)
}

func vol_hollow_circular_cylinder(inner_radius float64, outer_radius float64, height float64) float64 {
	if ((inner_radius < 0.0) || (outer_radius < 0.0)) || (height < 0.0) {
		panic("vol_hollow_circular_cylinder() only accepts non-negative values")
	}
	if outer_radius <= inner_radius {
		panic("outer_radius must be greater than inner_radius")
	}
	return ((PI * ((outer_radius * outer_radius) - (inner_radius * inner_radius))) * height)
}

func vol_conical_frustum(height float64, radius_1 float64, radius_2 float64) float64 {
	if ((radius_1 < 0.0) || (radius_2 < 0.0)) || (height < 0.0) {
		panic("vol_conical_frustum() only accepts non-negative values")
	}
	return ((((float64(1.0) / float64(3.0)) * PI) * height) * (((radius_1 * radius_1) + (radius_2 * radius_2)) + (radius_1 * radius_2)))
}

func vol_torus(torus_radius float64, tube_radius float64) float64 {
	if (torus_radius < 0.0) || (tube_radius < 0.0) {
		panic("vol_torus() only accepts non-negative values")
	}
	return (((((2.0 * PI) * PI) * torus_radius) * tube_radius) * tube_radius)
}

func vol_icosahedron(tri_side float64) float64 {
	if tri_side < 0.0 {
		panic("vol_icosahedron() only accepts non-negative values")
	}
	return (float64(((((tri_side * tri_side) * tri_side) * (3.0 + SQRT5)) * 5.0)) / float64(12.0))
}

func mochiMain() {
	fmt.Println("Volumes:")
	fmt.Println(("Cube: " + fmt.Sprint(vol_cube(2.0))))
	fmt.Println(("Cuboid: " + fmt.Sprint(vol_cuboid(2.0, 2.0, 2.0))))
	fmt.Println(("Cone: " + fmt.Sprint(vol_cone(2.0, 2.0))))
	fmt.Println(("Right Circular Cone: " + fmt.Sprint(vol_right_circ_cone(2.0, 2.0))))
	fmt.Println(("Prism: " + fmt.Sprint(vol_prism(2.0, 2.0))))
	fmt.Println(("Pyramid: " + fmt.Sprint(vol_pyramid(2.0, 2.0))))
	fmt.Println(("Sphere: " + fmt.Sprint(vol_sphere(2.0))))
	fmt.Println(("Hemisphere: " + fmt.Sprint(vol_hemisphere(2.0))))
	fmt.Println(("Circular Cylinder: " + fmt.Sprint(vol_circular_cylinder(2.0, 2.0))))
	fmt.Println(("Torus: " + fmt.Sprint(vol_torus(2.0, 2.0))))
	fmt.Println(("Conical Frustum: " + fmt.Sprint(vol_conical_frustum(2.0, 2.0, 4.0))))
	fmt.Println(("Spherical cap: " + fmt.Sprint(vol_spherical_cap(1.0, 2.0))))
	fmt.Println(("Spheres intersection: " + fmt.Sprint(vol_spheres_intersect(2.0, 2.0, 1.0))))
	fmt.Println(("Spheres union: " + fmt.Sprint(vol_spheres_union(2.0, 2.0, 1.0))))
	fmt.Println(("Hollow Circular Cylinder: " + fmt.Sprint(vol_hollow_circular_cylinder(1.0, 2.0, 3.0))))
	fmt.Println(("Icosahedron: " + fmt.Sprint(vol_icosahedron(2.5))))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		SQRT5 = 2.23606797749979
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
