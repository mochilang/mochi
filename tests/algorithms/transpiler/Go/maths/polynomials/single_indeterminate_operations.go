//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 12:55:40 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

type Polynomial struct {
	Degree       int       `json:"degree"`
	Coefficients []float64 `json:"coefficients"`
}

func copy_list(xs []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(xs) {
		res = append(res, _index(xs, i))
		i = (i + 1)
	}
	return res
}

func polynomial_new(degree int, coeffs []float64) Polynomial {
	if len(coeffs) != (degree + 1) {
		panic("The number of coefficients should be equal to the degree + 1.")
	}
	return Polynomial{
		Degree: degree,
		Coefficients: copy_list(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(coeffs)),
	}
}

func add(p Polynomial, q Polynomial) Polynomial {
	if p.Degree > q.Degree {
		var coeffs []float64 = copy_list(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(p.Coefficients))
		_ = coeffs
		var i int = 0
		_ = i
		for i <= q.Degree {
			_setIndex(coeffs, i, (_index(coeffs, i) + _index(q.Coefficients, i)))
			i = (i + 1)
		}
		return Polynomial{
			Degree:       p.Degree,
			Coefficients: coeffs,
		}
	} else {
		var coeffs []float64 = copy_list(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(q.Coefficients))
		_ = coeffs
		var i int = 0
		_ = i
		for i <= p.Degree {
			_setIndex(coeffs, i, (_index(coeffs, i) + _index(p.Coefficients, i)))
			i = (i + 1)
		}
		return Polynomial{
			Degree:       q.Degree,
			Coefficients: coeffs,
		}
	}
}

func neg(p Polynomial) Polynomial {
	var coeffs []float64 = []float64{}
	_ = coeffs
	var i int = 0
	_ = i
	for i <= p.Degree {
		coeffs = append(coeffs, (0 - _index(p.Coefficients, i)))
		i = (i + 1)
	}
	return Polynomial{
		Degree:       p.Degree,
		Coefficients: coeffs,
	}
}

func sub(p Polynomial, q Polynomial) Polynomial {
	return add(p, neg(q))
}

func mul(p Polynomial, q Polynomial) Polynomial {
	var size int = ((p.Degree + q.Degree) + 1)
	_ = size
	var coeffs []float64 = []float64{}
	_ = coeffs
	var i int = 0
	_ = i
	for i < size {
		coeffs = append(coeffs, 0.0)
		i = (i + 1)
	}
	i = 0
	for i <= p.Degree {
		var j int = 0
		_ = j
		for j <= q.Degree {
			_setIndex(coeffs, (i + j), (_index(coeffs, (i+j)) + (_index(p.Coefficients, i) * _index(q.Coefficients, j))))
			j = (j + 1)
		}
		i = (i + 1)
	}
	return Polynomial{
		Degree:       (p.Degree + q.Degree),
		Coefficients: coeffs,
	}
}

func power(base float64, exp int) float64 {
	var result float64 = 1.0
	_ = result
	var i int = 0
	_ = i
	for i < exp {
		result = (result * base)
		i = (i + 1)
	}
	return result
}

func evaluate(p Polynomial, x float64) float64 {
	var result float64 = 0.0
	_ = result
	var i int = 0
	_ = i
	for i <= p.Degree {
		result = (result + (_index(p.Coefficients, i) * power(x, i)))
		i = (i + 1)
	}
	return result
}

func poly_to_string(p Polynomial) string {
	var s string = ""
	_ = s
	var i int = p.Degree
	_ = i
	for i >= 0 {
		var coeff float64 = _index(p.Coefficients, i)
		_ = coeff
		if coeff != 0.0 {
			if len(s) > 0 {
				if coeff > 0.0 {
					s = (s + " + ")
				} else {
					s = (s + " - ")
				}
			} else {
				if coeff < 0.0 {
					s = (s + "-")
				}
			}
			var abs_coeff float64 = func() float64 {
				if coeff < 0.0 {
					return (0 - coeff)
				} else {
					return coeff
				}
			}()
			_ = abs_coeff
			if i == 0 {
				s = (s + fmt.Sprint(abs_coeff))
			} else {
				if i == 1 {
					s = ((s + fmt.Sprint(abs_coeff)) + "x")
				} else {
					s = (((s + fmt.Sprint(abs_coeff)) + "x^") + fmt.Sprint(i))
				}
			}
		}
		i = (i - 1)
	}
	if s == "" {
		s = "0"
	}
	return s
}

func derivative(p Polynomial) Polynomial {
	if p.Degree == 0 {
		return Polynomial{
			Degree:       0,
			Coefficients: []float64{0.0},
		}
	}
	var coeffs []float64 = []float64{}
	_ = coeffs
	var i int = 0
	_ = i
	for i < p.Degree {
		coeffs = append(coeffs, float64((_index(p.Coefficients, (i+1)) * _toFloat(float64((i + 1))))))
		i = (i + 1)
	}
	return Polynomial{
		Degree:       (p.Degree - 1),
		Coefficients: coeffs,
	}
}

func integral(p Polynomial, constant float64) Polynomial {
	var coeffs []float64 = []float64{constant}
	_ = coeffs
	var i int = 0
	_ = i
	for i <= p.Degree {
		coeffs = append(coeffs, float64((float64(_index(p.Coefficients, i)) / float64(_toFloat(float64((i + 1)))))))
		i = (i + 1)
	}
	return Polynomial{
		Degree:       (p.Degree + 1),
		Coefficients: coeffs,
	}
}

func equals(p Polynomial, q Polynomial) bool {
	if p.Degree != q.Degree {
		return false
	}
	var i int = 0
	_ = i
	for i <= p.Degree {
		if _index(p.Coefficients, i) != _index(q.Coefficients, i) {
			return false
		}
		i = (i + 1)
	}
	return true
}

func not_equals(p Polynomial, q Polynomial) bool {
	return !equals(p, q)
}

func test_polynomial() {
	var p Polynomial = polynomial_new(2, func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{1.0, 2.0, 3.0}))
	_ = p
	var q Polynomial = polynomial_new(2, func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{1.0, 2.0, 3.0}))
	_ = q
	if poly_to_string(add(p, q)) != "6x^2 + 4x + 2" {
		panic("add failed")
	}
	if poly_to_string(sub(p, q)) != "0" {
		panic("sub failed")
	}
	if evaluate(p, 2.0) != 17.0 {
		panic("evaluate failed")
	}
	if poly_to_string(derivative(p)) != "6x + 2" {
		panic("derivative failed")
	}
	var integ string = poly_to_string(integral(p, 0.0))
	_ = integ
	if integ != "1x^3 + 1x^2 + 1x" {
		panic("integral failed")
	}
	if !equals(p, q) {
		panic("equals failed")
	}
	if not_equals(p, q) {
		panic("not_equals failed")
	}
}

func mochiMain() {
	test_polynomial()
	var p Polynomial = polynomial_new(2, func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{1.0, 2.0, 3.0}))
	_ = p
	var d Polynomial = derivative(p)
	_ = d
	fmt.Println(poly_to_string(d))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
