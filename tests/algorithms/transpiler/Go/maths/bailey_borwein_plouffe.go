//go:build ignore

// Generated by Mochi v0.10.67 on 2025-08-16 19:50:42 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func mod_pow(base int, exponent int, modulus int) int {
	var result int = 1
	_ = result
	var b int = _modi(base, modulus)
	_ = b
	var e int = exponent
	_ = e
	for e > 0 {
		if _modi(e, 2) == 1 {
			result = _modi((result * b), modulus)
		}
		b = _modi((b * b), modulus)
		e = (e / 2)
	}
	return result
}

func pow_float(base float64, exponent int) float64 {
	var exp int = exponent
	_ = exp
	var result float64 = 1.0
	_ = result
	if exp < 0 {
		exp = (0 - exp)
	}
	var i int = 0
	_ = i
	for i < exp {
		result = (result * base)
		i = (i + 1)
	}
	if exponent < 0 {
		result = (float64(1.0) / float64(result))
	}
	return result
}

func hex_digit(n int) string {
	if n < 10 {
		return fmt.Sprint(n)
	}
	var letters []string = []string{"a", "b", "c", "d", "e", "f"}
	_ = letters
	_ = letters
	return _index(letters, (n - 10))
}

func floor_float(x float64) float64 {
	var i int = int(x)
	_ = i
	if float64(i) > x {
		i = (i - 1)
	}
	return float64(i)
}

func subsum(digit_pos_to_extract int, denominator_addend int, precision int) float64 {
	var total float64 = 0.0
	_ = total
	var sum_index int = 0
	_ = sum_index
	for sum_index < (digit_pos_to_extract + precision) {
		var denominator int = ((8 * sum_index) + denominator_addend)
		_ = denominator
		if sum_index < digit_pos_to_extract {
			var exponent int = ((digit_pos_to_extract - 1) - sum_index)
			_ = exponent
			var exponential_term int = mod_pow(16, exponent, denominator)
			_ = exponential_term
			total = (total + (float64(exponential_term) / float64(denominator)))
		} else {
			var exponent int = ((digit_pos_to_extract - 1) - sum_index)
			_ = exponent
			var exponential_term float64 = pow_float(16.0, exponent)
			_ = exponential_term
			total = (total + (float64(exponential_term) / float64(denominator)))
		}
		sum_index = (sum_index + 1)
	}
	return total
}

func bailey_borwein_plouffe(digit_position int, precision int) string {
	if digit_position <= 0 {
		panic("Digit position must be a positive integer")
	}
	if precision < 0 {
		panic("Precision must be a nonnegative integer")
	}
	var sum_result float64 = ((((4.0 * subsum(digit_position, 1, precision)) - (2.0 * subsum(digit_position, 4, precision))) - (1.0 * subsum(digit_position, 5, precision))) - (1.0 * subsum(digit_position, 6, precision)))
	_ = sum_result
	var fraction float64 = (sum_result - floor_float(sum_result))
	_ = fraction
	_ = fraction
	var digit int = int((fraction * 16.0))
	_ = digit
	var hd string = hex_digit(digit)
	_ = hd
	_ = hd
	return hd
}

var digits string

var i int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		digits = ""
		i = 1
		for i <= 10 {
			digits = (digits + bailey_borwein_plouffe(i, 1000))
			i = (i + 1)
		}
		fmt.Println(digits)
		fmt.Println(bailey_borwein_plouffe(5, 10000))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
