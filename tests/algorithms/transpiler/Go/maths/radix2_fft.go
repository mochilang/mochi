//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 12:56:50 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type Complex struct {
	Re float64 `json:"re"`
	Im float64 `json:"im"`
}

func c_add(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re + b.Re),
		Im: (a.Im + b.Im),
	}
}

func c_sub(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re - b.Re),
		Im: (a.Im - b.Im),
	}
}

func c_mul(a Complex, b Complex) Complex {
	return Complex{
		Re: ((a.Re * b.Re) - (a.Im * b.Im)),
		Im: ((a.Re * b.Im) + (a.Im * b.Re)),
	}
}

func c_mul_scalar(a Complex, s float64) Complex {
	return Complex{
		Re: (a.Re * s),
		Im: (a.Im * s),
	}
}

func c_div_scalar(a Complex, s float64) Complex {
	return Complex{
		Re: (float64(a.Re) / float64(s)),
		Im: (float64(a.Im) / float64(s)),
	}
}

var PI float64

func sin_taylor(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = (2.0 * float64(i))
		_ = k1
		var k2 float64 = (k1 + 1.0)
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func cos_taylor(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		var k1 float64 = ((2.0 * float64(i)) - 1.0)
		_ = k1
		var k2 float64 = (2.0 * float64(i))
		_ = k2
		term = (float64((((0 - term) * x) * x)) / float64((k1 * k2)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func exp_i(theta float64) Complex {
	return Complex{
		Re: cos_taylor(theta),
		Im: sin_taylor(theta),
	}
}

func make_complex_list(n int, value Complex) []Complex {
	var arr []Complex = []Complex{}
	_ = arr
	var i int = 0
	_ = i
	for i < n {
		arr = append(arr, value)
		i = (i + 1)
	}
	return arr
}

func fft(a []Complex, invert bool) []Complex {
	var n int = len(a)
	_ = n
	if n == 1 {
		return []Complex{_index(a, 0)}
	}
	var a0 []Complex = []Complex{}
	_ = a0
	var a1 []Complex = []Complex{}
	_ = a1
	var i int = 0
	_ = i
	for i < (n / 2) {
		a0 = append(a0, _index(a, (2*i)))
		a1 = append(a1, _index(a, ((2*i)+1)))
		i = (i + 1)
	}
	var y0 []Complex = fft(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(a0), invert)
	_ = y0
	var y1 []Complex = fft(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(a1), invert)
	_ = y1
	var angle float64 = ((float64((2.0 * PI)) / float64(n)) * func() float64 {
		if invert {
			return (0 - 1.0)
		} else {
			return 1.0
		}
	}())
	_ = angle
	var w Complex = Complex{
		Re: 1.0,
		Im: 0.0,
	}
	_ = w
	var wn Complex = exp_i(angle)
	_ = wn
	var y []Complex = make_complex_list(n, Complex{
		Re: 0.0,
		Im: 0.0,
	})
	_ = y
	i = 0
	for i < (n / 2) {
		var t Complex = c_mul(w, _index(y1, i))
		_ = t
		var u Complex = _index(y0, i)
		_ = u
		var even Complex = c_add(u, t)
		_ = even
		var odd Complex = c_sub(u, t)
		_ = odd
		if invert {
			even = c_div_scalar(even, 2.0)
			odd = c_div_scalar(odd, 2.0)
		}
		_setIndex(y, i, even)
		_setIndex(y, (i + (n / 2)), odd)
		w = c_mul(w, wn)
		i = (i + 1)
	}
	return y
}

func floor(x float64) float64 {
	var i int = int(x)
	_ = i
	if float64(i) > x {
		i = (i - 1)
	}
	return float64(i)
}

func pow10(n int) float64 {
	var p float64 = 1.0
	_ = p
	var i int = 0
	_ = i
	for i < n {
		p = (p * 10.0)
		i = (i + 1)
	}
	return p
}

func round_to(x float64, ndigits int) float64 {
	var m float64 = pow10(ndigits)
	_ = m
	_ = m
	return (float64(floor(((x * m) + 0.5))) / float64(m))
}

func list_to_string(l []float64) string {
	var s string = "["
	_ = s
	var i int = 0
	_ = i
	for i < len(l) {
		s = (s + fmt.Sprint(_index(l, i)))
		if (i + 1) < len(l) {
			s = (s + ", ")
		}
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

func multiply_poly(a []float64, b []float64) []float64 {
	var n int = 1
	_ = n
	for n < ((len(a) + len(b)) - 1) {
		n = (n * 2)
	}
	var fa []Complex = make_complex_list(n, Complex{
		Re: 0.0,
		Im: 0.0,
	})
	_ = fa
	var fb []Complex = make_complex_list(n, Complex{
		Re: 0.0,
		Im: 0.0,
	})
	_ = fb
	var i int = 0
	_ = i
	for i < len(a) {
		_setIndex(fa, i, Complex{
			Re: _index(a, i),
			Im: 0.0,
		})
		i = (i + 1)
	}
	i = 0
	for i < len(b) {
		_setIndex(fb, i, Complex{
			Re: _index(b, i),
			Im: 0.0,
		})
		i = (i + 1)
	}
	fa = fft(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(fa), false)
	fb = fft(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(fb), false)
	i = 0
	for i < n {
		_setIndex(fa, i, c_mul(_index(fa, i), _index(fb, i)))
		i = (i + 1)
	}
	fa = fft(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(fa), true)
	var res []float64 = []float64{}
	_ = res
	i = 0
	for i < ((len(a) + len(b)) - 1) {
		var val Complex = _index(fa, i)
		_ = val
		res = append(res, round_to(val.Re, 8))
		i = (i + 1)
	}
	for (len(res) > 0) && (_index(res, (len(res)-1)) == 0.0) {
		res = res[0:(len(res) - 1)]
	}
	return res
}

var A []float64

var B []float64

var product []float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		A = []float64{0.0, 1.0, 0.0, 2.0}
		B = []float64{2.0, 3.0, 4.0, 0.0}
		product = multiply_poly(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(A), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(B))
		fmt.Println(list_to_string(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(product)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
