//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 14:48:04 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var PI float64

var TWO_PI float64

func _mod(x float64, m float64) float64 {
	return (x - (float64(int((float64(x) / float64(m)))) * m))
}

func sin_approx(x float64) float64 {
	var y float64 = (_mod((x+PI), TWO_PI) - PI)
	_ = y
	var y2 float64 = (y * y)
	_ = y2
	var y3 float64 = (y2 * y)
	_ = y3
	var y5 float64 = (y3 * y2)
	_ = y5
	var y7 float64 = (y5 * y2)
	_ = y7
	_ = y7
	return (((y - (float64(y3) / float64(6.0))) + (float64(y5) / float64(120.0))) - (float64(y7) / float64(5040.0)))
}

func cos_approx(x float64) float64 {
	var y float64 = (_mod((x+PI), TWO_PI) - PI)
	_ = y
	var y2 float64 = (y * y)
	_ = y2
	var y4 float64 = (y2 * y2)
	_ = y4
	var y6 float64 = (y4 * y2)
	_ = y6
	_ = y6
	return (((1.0 - (float64(y2) / float64(2.0))) + (float64(y4) / float64(24.0))) - (float64(y6) / float64(720.0)))
}

func tan_approx(x float64) float64 {
	return (float64(sin_approx(x)) / float64(cos_approx(x)))
}

func sqrt_approx(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = (float64(x) / float64(2.0))
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func surface_area_cube(side_length float64) float64 {
	if side_length < 0.0 {
		fmt.Println("ValueError: surface_area_cube() only accepts non-negative values")
		return 0.0
	}
	return ((6.0 * side_length) * side_length)
}

func surface_area_cuboid(length float64, breadth float64, height float64) float64 {
	if ((length < 0.0) || (breadth < 0.0)) || (height < 0.0) {
		fmt.Println("ValueError: surface_area_cuboid() only accepts non-negative values")
		return 0.0
	}
	return (2.0 * (((length * breadth) + (breadth * height)) + (length * height)))
}

func surface_area_sphere(radius float64) float64 {
	if radius < 0.0 {
		fmt.Println("ValueError: surface_area_sphere() only accepts non-negative values")
		return 0.0
	}
	return (((4.0 * PI) * radius) * radius)
}

func surface_area_hemisphere(radius float64) float64 {
	if radius < 0.0 {
		fmt.Println("ValueError: surface_area_hemisphere() only accepts non-negative values")
		return 0.0
	}
	return (((3.0 * PI) * radius) * radius)
}

func surface_area_cone(radius float64, height float64) float64 {
	if (radius < 0.0) || (height < 0.0) {
		fmt.Println("ValueError: surface_area_cone() only accepts non-negative values")
		return 0.0
	}
	var slant float64 = sqrt_approx(((height * height) + (radius * radius)))
	_ = slant
	_ = slant
	return ((PI * radius) * (radius + slant))
}

func surface_area_conical_frustum(radius1 float64, radius2 float64, height float64) float64 {
	if ((radius1 < 0.0) || (radius2 < 0.0)) || (height < 0.0) {
		fmt.Println("ValueError: surface_area_conical_frustum() only accepts non-negative values")
		return 0.0
	}
	var slant float64 = sqrt_approx(((height * height) + ((radius1 - radius2) * (radius1 - radius2))))
	_ = slant
	_ = slant
	return (PI * (((slant * (radius1 + radius2)) + (radius1 * radius1)) + (radius2 * radius2)))
}

func surface_area_cylinder(radius float64, height float64) float64 {
	if (radius < 0.0) || (height < 0.0) {
		fmt.Println("ValueError: surface_area_cylinder() only accepts non-negative values")
		return 0.0
	}
	return (((2.0 * PI) * radius) * (height + radius))
}

func surface_area_torus(torus_radius float64, tube_radius float64) float64 {
	if (torus_radius < 0.0) || (tube_radius < 0.0) {
		fmt.Println("ValueError: surface_area_torus() only accepts non-negative values")
		return 0.0
	}
	if torus_radius < tube_radius {
		fmt.Println("ValueError: surface_area_torus() does not support spindle or self intersecting tori")
		return 0.0
	}
	return ((((4.0 * PI) * PI) * torus_radius) * tube_radius)
}

func area_rectangle(length float64, width float64) float64 {
	if (length < 0.0) || (width < 0.0) {
		fmt.Println("ValueError: area_rectangle() only accepts non-negative values")
		return 0.0
	}
	return (length * width)
}

func area_square(side_length float64) float64 {
	if side_length < 0.0 {
		fmt.Println("ValueError: area_square() only accepts non-negative values")
		return 0.0
	}
	return (side_length * side_length)
}

func area_triangle(base float64, height float64) float64 {
	if (base < 0.0) || (height < 0.0) {
		fmt.Println("ValueError: area_triangle() only accepts non-negative values")
		return 0.0
	}
	return (float64((base * height)) / float64(2.0))
}

func area_triangle_three_sides(side1 float64, side2 float64, side3 float64) float64 {
	if ((side1 < 0.0) || (side2 < 0.0)) || (side3 < 0.0) {
		fmt.Println("ValueError: area_triangle_three_sides() only accepts non-negative values")
		return 0.0
	}
	if (((side1 + side2) < side3) || ((side1 + side3) < side2)) || ((side2 + side3) < side1) {
		fmt.Println("ValueError: Given three sides do not form a triangle")
		return 0.0
	}
	var s float64 = (float64(((side1 + side2) + side3)) / float64(2.0))
	_ = s
	var prod float64 = (((s * (s - side1)) * (s - side2)) * (s - side3))
	_ = prod
	var res float64 = sqrt_approx(prod)
	_ = res
	_ = res
	return res
}

func area_parallelogram(base float64, height float64) float64 {
	if (base < 0.0) || (height < 0.0) {
		fmt.Println("ValueError: area_parallelogram() only accepts non-negative values")
		return 0.0
	}
	return (base * height)
}

func area_trapezium(base1 float64, base2 float64, height float64) float64 {
	if ((base1 < 0.0) || (base2 < 0.0)) || (height < 0.0) {
		fmt.Println("ValueError: area_trapezium() only accepts non-negative values")
		return 0.0
	}
	return ((0.5 * (base1 + base2)) * height)
}

func area_circle(radius float64) float64 {
	if radius < 0.0 {
		fmt.Println("ValueError: area_circle() only accepts non-negative values")
		return 0.0
	}
	return ((PI * radius) * radius)
}

func area_ellipse(radius_x float64, radius_y float64) float64 {
	if (radius_x < 0.0) || (radius_y < 0.0) {
		fmt.Println("ValueError: area_ellipse() only accepts non-negative values")
		return 0.0
	}
	return ((PI * radius_x) * radius_y)
}

func area_rhombus(diagonal1 float64, diagonal2 float64) float64 {
	if (diagonal1 < 0.0) || (diagonal2 < 0.0) {
		fmt.Println("ValueError: area_rhombus() only accepts non-negative values")
		return 0.0
	}
	return ((0.5 * diagonal1) * diagonal2)
}

func area_reg_polygon(sides int, length float64) float64 {
	if sides < 3 {
		fmt.Println("ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides")
		return 0.0
	}
	if length < 0.0 {
		fmt.Println("ValueError: area_reg_polygon() only accepts non-negative values as length of a side")
		return 0.0
	}
	var n float64 = float64(sides)
	_ = n
	_ = n
	return (float64(((n * length) * length)) / float64((4.0 * tan_approx((float64(PI) / float64(n))))))
}

var TRI_THREE_SIDES float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		TWO_PI = 6.283185307179586
		fmt.Println("[DEMO] Areas of various geometric shapes:")
		fmt.Println(("Rectangle: " + fmt.Sprint(area_rectangle(10.0, 20.0))))
		fmt.Println(("Square: " + fmt.Sprint(area_square(10.0))))
		fmt.Println(("Triangle: " + fmt.Sprint(area_triangle(10.0, 10.0))))
		TRI_THREE_SIDES = area_triangle_three_sides(5.0, 12.0, 13.0)
		fmt.Println(("Triangle Three Sides: " + fmt.Sprint(TRI_THREE_SIDES)))
		fmt.Println(("Parallelogram: " + fmt.Sprint(area_parallelogram(10.0, 20.0))))
		fmt.Println(("Rhombus: " + fmt.Sprint(area_rhombus(10.0, 20.0))))
		fmt.Println(("Trapezium: " + fmt.Sprint(area_trapezium(10.0, 20.0, 30.0))))
		fmt.Println(("Circle: " + fmt.Sprint(area_circle(20.0))))
		fmt.Println(("Ellipse: " + fmt.Sprint(area_ellipse(10.0, 20.0))))
		fmt.Println("")
		fmt.Println("Surface Areas of various geometric shapes:")
		fmt.Println(("Cube: " + fmt.Sprint(surface_area_cube(20.0))))
		fmt.Println(("Cuboid: " + fmt.Sprint(surface_area_cuboid(10.0, 20.0, 30.0))))
		fmt.Println(("Sphere: " + fmt.Sprint(surface_area_sphere(20.0))))
		fmt.Println(("Hemisphere: " + fmt.Sprint(surface_area_hemisphere(20.0))))
		fmt.Println(("Cone: " + fmt.Sprint(surface_area_cone(10.0, 20.0))))
		fmt.Println(("Conical Frustum: " + fmt.Sprint(surface_area_conical_frustum(10.0, 20.0, 30.0))))
		fmt.Println(("Cylinder: " + fmt.Sprint(surface_area_cylinder(10.0, 20.0))))
		fmt.Println(("Torus: " + fmt.Sprint(surface_area_torus(20.0, 10.0))))
		fmt.Println(("Equilateral Triangle: " + fmt.Sprint(area_reg_polygon(3, 10.0))))
		fmt.Println(("Square: " + fmt.Sprint(area_reg_polygon(4, 10.0))))
		fmt.Println(("Regular Pentagon: " + fmt.Sprint(area_reg_polygon(5, 10.0))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
