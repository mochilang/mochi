//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:34:35 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var MOD int

var ASCII string

func ord(ch string) int {
	var i int = 0
	_ = i
	for i < len(ASCII) {
		if string([]rune(ASCII)[i:(i+1)]) == ch {
			return (32 + i)
		}
		i = (i + 1)
	}
	return 0
}

func pow2(n int) int {
	var res int = 1
	_ = res
	var i int = 0
	_ = i
	for i < n {
		res = (res * 2)
		i = (i + 1)
	}
	return res
}

func bit_and(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	var i int = 0
	_ = i
	for i < 32 {
		if (_modi(x, 2) == 1) && (_modi(y, 2) == 1) {
			res = (res + bit)
		}
		x = (x / 2)
		y = (y / 2)
		bit = (bit * 2)
		i = (i + 1)
	}
	return res
}

func bit_or(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	var i int = 0
	_ = i
	for i < 32 {
		var abit int = _modi(x, 2)
		_ = abit
		var bbit int = _modi(y, 2)
		_ = bbit
		if (abit == 1) || (bbit == 1) {
			res = (res + bit)
		}
		x = (x / 2)
		y = (y / 2)
		bit = (bit * 2)
		i = (i + 1)
	}
	return res
}

func bit_xor(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	var i int = 0
	_ = i
	for i < 32 {
		var abit int = _modi(x, 2)
		_ = abit
		var bbit int = _modi(y, 2)
		_ = bbit
		if ((abit == 1) && (bbit == 0)) || ((abit == 0) && (bbit == 1)) {
			res = (res + bit)
		}
		x = (x / 2)
		y = (y / 2)
		bit = (bit * 2)
		i = (i + 1)
	}
	return res
}

func bit_not(a int) int {
	return ((MOD - 1) - a)
}

func rotate_left(n int, b int) int {
	var left int = _modi((n * pow2(b)), MOD)
	_ = left
	_ = left
	var right int = (n / pow2((32 - b)))
	_ = right
	_ = right
	return _modi((left + right), MOD)
}

func to_hex32(n int) string {
	var digits string = "0123456789abcdef"
	_ = digits
	_ = digits
	var num int = n
	_ = num
	var s string = ""
	_ = s
	if num == 0 {
		s = "0"
	}
	for num > 0 {
		var d int = _modi(num, 16)
		_ = d
		s = (string([]rune(digits)[d:(d+1)]) + s)
		num = (num / 16)
	}
	for len(s) < 8 {
		s = ("0" + s)
	}
	if len(s) > 8 {
		s = string([]rune(s)[(len(s) - 8):len(s)])
	}
	return s
}

func sha1(message string) string {
	var bytes []int = []int{}
	_ = bytes
	var i int = 0
	_ = i
	for i < len(message) {
		bytes = append(bytes, ord(string([]rune(message)[i:(i+1)])))
		i = (i + 1)
	}
	bytes = append(bytes, 128)
	for _modi((len(bytes)+8), 64) != 0 {
		bytes = append(bytes, 0)
	}
	var bit_len int = (len(message) * 8)
	_ = bit_len
	var len_bytes []int = []int{0, 0, 0, 0, 0, 0, 0, 0}
	_ = len_bytes
	var bl int = bit_len
	_ = bl
	var k int = 7
	_ = k
	for k >= 0 {
		_setIndex(len_bytes, k, _modi(bl, 256))
		bl = (bl / 256)
		k = (k - 1)
	}
	var j int = 0
	_ = j
	for j < 8 {
		bytes = append(bytes, _index(len_bytes, j))
		j = (j + 1)
	}
	var blocks [][]int = [][]int{}
	_ = blocks
	var pos int = 0
	_ = pos
	for pos < len(bytes) {
		var block []int = []int{}
		_ = block
		var j2 int = 0
		_ = j2
		for j2 < 64 {
			block = append(block, _index(bytes, (pos+j2)))
			j2 = (j2 + 1)
		}
		blocks = append(blocks, block)
		pos = (pos + 64)
	}
	var h0 int = 1732584193
	_ = h0
	var h1 int = 4023233417
	_ = h1
	var h2 int = 2562383102
	_ = h2
	var h3 int = 271733878
	_ = h3
	var h4 int = 3285377520
	_ = h4
	var bindex int = 0
	_ = bindex
	for bindex < len(blocks) {
		var block []int = _index(blocks, bindex)
		_ = block
		var w []int = []int{}
		_ = w
		var t int = 0
		_ = t
		for t < 16 {
			var j3 int = (t * 4)
			_ = j3
			var word int = ((((((_index(block, j3) * 256) + _index(block, (j3+1))) * 256) + _index(block, (j3+2))) * 256) + _index(block, (j3+3)))
			_ = word
			w = append(w, word)
			t = (t + 1)
		}
		for t < 80 {
			var tmp int = bit_xor(bit_xor(bit_xor(_index(w, (t-3)), _index(w, (t-8))), _index(w, (t-14))), _index(w, (t-16)))
			_ = tmp
			w = append(w, rotate_left(tmp, 1))
			t = (t + 1)
		}
		var a int = h0
		_ = a
		var b int = h1
		_ = b
		var c int = h2
		_ = c
		var d int = h3
		_ = d
		var e int = h4
		_ = e
		var i2 int = 0
		_ = i2
		for i2 < 80 {
			var f int = 0
			_ = f
			var kconst int = 0
			_ = kconst
			if i2 < 20 {
				f = bit_or(bit_and(b, c), bit_and(bit_not(b), d))
				kconst = 1518500249
			} else {
				if i2 < 40 {
					f = bit_xor(bit_xor(b, c), d)
					kconst = 1859775393
				} else {
					if i2 < 60 {
						f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d))
						kconst = 2400959708
					} else {
						f = bit_xor(bit_xor(b, c), d)
						kconst = 3395469782
					}
				}
			}
			var temp int = _modi(((((rotate_left(a, 5) + f) + e) + kconst) + _index(w, i2)), MOD)
			_ = temp
			e = d
			d = c
			c = rotate_left(b, 30)
			b = a
			a = temp
			i2 = (i2 + 1)
		}
		h0 = _modi((h0 + a), MOD)
		h1 = _modi((h1 + b), MOD)
		h2 = _modi((h2 + c), MOD)
		h3 = _modi((h3 + d), MOD)
		h4 = _modi((h4 + e), MOD)
		bindex = (bindex + 1)
	}
	return ((((to_hex32(h0) + to_hex32(h1)) + to_hex32(h2)) + to_hex32(h3)) + to_hex32(h4))
}

func mochiMain() {
	fmt.Println(sha1("Test String"))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		MOD = 4294967296
		ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
