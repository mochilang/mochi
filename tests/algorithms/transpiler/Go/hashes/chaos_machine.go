//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:34:12 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var K []float64

var t int

var size int

type Machine struct {
	Buffer []float64 `json:"buffer"`
	Params []float64 `json:"params"`
	Time   int       `json:"time"`
}

type PullResult struct {
	Value   int     `json:"value"`
	Machine Machine `json:"machine"`
}

func round_dec(x float64, n int) float64 {
	var m10 float64 = 1.0
	_ = m10
	var i int = 0
	_ = i
	for i < n {
		m10 = (m10 * 10.0)
		i = (i + 1)
	}
	var y float64 = ((x * m10) + 0.5)
	_ = y
	_ = y
	return (float64((1.0 * float64(int(y)))) / float64(m10))
}

func reset() Machine {
	return Machine{
		Buffer: K,
		Params: []float64{0.0, 0.0, 0.0, 0.0, 0.0},
		Time:   0,
	}
}

func push(m Machine, seed int) Machine {
	var buf []float64 = m.Buffer
	_ = buf
	var par []float64 = m.Params
	_ = par
	var i int = 0
	_ = i
	for i < len(buf) {
		var value float64 = _index(buf, i)
		_ = value
		var e float64 = (float64((1.0 * float64(seed))) / float64(value))
		_ = e
		var next_value float64 = (_index(buf, _modi((i+1), size)) + e)
		_ = next_value
		next_value = (next_value - (1.0 * float64(int(next_value))))
		var r float64 = (_index(par, i) + e)
		_ = r
		r = (r - (1.0 * float64(int(r))))
		r = (r + 3.0)
		_setIndex(buf, i, round_dec(((r*next_value)*(1.0-next_value)), 10))
		_setIndex(par, i, r)
		i = (i + 1)
	}
	return Machine{
		Buffer: buf,
		Params: par,
		Time:   (m.Time + 1),
	}
}

func xor(a int, b int) int {
	var aa int = a
	_ = aa
	var bb int = b
	_ = bb
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	for (aa > 0) || (bb > 0) {
		var abit int = _modi(aa, 2)
		_ = abit
		var bbit int = _modi(bb, 2)
		_ = bbit
		if abit != bbit {
			res = (res + bit)
		}
		aa = (aa / 2)
		bb = (bb / 2)
		bit = (bit * 2)
	}
	return res
}

func xorshift(x int, y int) int {
	var xv int = x
	_ = xv
	var yv int = y
	_ = yv
	xv = xor(xv, (yv / 8192))
	yv = xor(yv, (xv * 131072))
	xv = xor(xv, (yv / 32))
	return xv
}

func pull(m Machine) PullResult {
	var buf []float64 = m.Buffer
	_ = buf
	var par []float64 = m.Params
	_ = par
	var key int = _modi(m.Time, size)
	_ = key
	var i int = 0
	_ = i
	for i < t {
		var r float64 = _index(par, key)
		_ = r
		var value float64 = _index(buf, key)
		_ = value
		_setIndex(buf, key, round_dec(((r*value)*(1.0-value)), 10))
		var new_r float64 = (((1.0 * float64(m.Time)) * 0.01) + (r * 1.01))
		_ = new_r
		new_r = (new_r - (1.0 * float64(int(new_r))))
		_setIndex(par, key, (new_r + 3.0))
		i = (i + 1)
	}
	var x int = int((_index(buf, _modi((key+2), size)) * 10000000000.0))
	_ = x
	var y int = int((_index(buf, _modi(((key+size)-2), size)) * 10000000000.0))
	_ = y
	var new_machine Machine = Machine{
		Buffer: buf,
		Params: par,
		Time:   (m.Time + 1),
	}
	_ = new_machine
	_ = new_machine
	var value int = _modi(xorshift(x, y), 4294967295)
	_ = value
	_ = value
	return PullResult{
		Value:   value,
		Machine: new_machine,
	}
}

var machine Machine

var i int

var res PullResult

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		K = []float64{0.33, 0.44, 0.55, 0.44, 0.33}
		t = 3
		size = 5
		machine = reset()
		i = 0
		for i < 100 {
			machine = push(machine, i)
			i = (i + 1)
		}
		res = pull(machine)
		fmt.Println(res.Value)
		fmt.Println(func() string {
			b, _ := json.Marshal(res.Machine.Buffer)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(res.Machine.Params)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
