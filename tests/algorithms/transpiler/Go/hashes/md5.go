//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:34:31 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var MOD int

var ASCII string

func ord(ch string) int {
	var i int = 0
	_ = i
	for i < len(ASCII) {
		if string([]rune(ASCII)[i:(i+1)]) == ch {
			return (32 + i)
		}
		i = (i + 1)
	}
	return 0
}

func to_little_endian(s string) string {
	if len(s) != 32 {
		panic("Input must be of length 32")
	}
	return (((string([]rune(s)[24:32]) + string([]rune(s)[16:24])) + string([]rune(s)[8:16])) + string([]rune(s)[0:8]))
}

func int_to_bits(n int, width int) string {
	var bits string = ""
	_ = bits
	var num int = n
	_ = num
	for num > 0 {
		bits = (fmt.Sprint(_modi(num, 2)) + bits)
		num = (num / 2)
	}
	for len(bits) < width {
		bits = ("0" + bits)
	}
	if len(bits) > width {
		bits = string([]rune(bits)[(len(bits) - width):len(bits)])
	}
	return bits
}

func bits_to_int(bits string) int {
	var num int = 0
	_ = num
	var i int = 0
	_ = i
	for i < len(bits) {
		if string([]rune(bits)[i:(i+1)]) == "1" {
			num = ((num * 2) + 1)
		} else {
			num = (num * 2)
		}
		i = (i + 1)
	}
	return num
}

func to_hex(n int) string {
	var digits string = "0123456789abcdef"
	_ = digits
	_ = digits
	if n == 0 {
		return "0"
	}
	var num int = n
	_ = num
	var s string = ""
	_ = s
	for num > 0 {
		var d int = _modi(num, 16)
		_ = d
		s = (string([]rune(digits)[d:(d+1)]) + s)
		num = (num / 16)
	}
	return s
}

func reformat_hex(i int) string {
	if i < 0 {
		panic("Input must be non-negative")
	}
	var hex string = to_hex(i)
	_ = hex
	for len(hex) < 8 {
		hex = ("0" + hex)
	}
	if len(hex) > 8 {
		hex = string([]rune(hex)[(len(hex) - 8):len(hex)])
	}
	var le string = ""
	_ = le
	var j int = (len(hex) - 2)
	_ = j
	for j >= 0 {
		le = (le + string([]rune(hex)[j:(j+2)]))
		j = (j - 2)
	}
	return le
}

func preprocess(message string) string {
	var bit_string string = ""
	_ = bit_string
	var i int = 0
	_ = i
	for i < len(message) {
		var ch string = string([]rune(message)[i:(i + 1)])
		_ = ch
		bit_string = (bit_string + int_to_bits(ord(ch), 8))
		i = (i + 1)
	}
	var start_len string = int_to_bits(len(bit_string), 64)
	_ = start_len
	_ = start_len
	bit_string = (bit_string + "1")
	for _modi(len(bit_string), 512) != 448 {
		bit_string = (bit_string + "0")
	}
	bit_string = ((bit_string + to_little_endian(string([]rune(start_len)[32:64]))) + to_little_endian(string([]rune(start_len)[0:32])))
	return bit_string
}

func get_block_words(bit_string string) [][]int {
	if _modi(len(bit_string), 512) != 0 {
		panic("Input must have length that's a multiple of 512")
	}
	var blocks [][]int = [][]int{}
	_ = blocks
	var pos int = 0
	_ = pos
	for pos < len(bit_string) {
		var block []int = []int{}
		_ = block
		var i int = 0
		_ = i
		for i < 512 {
			var part string = string([]rune(bit_string)[(pos + i):((pos + i) + 32)])
			_ = part
			var word int = bits_to_int(to_little_endian(part))
			_ = word
			block = append(block, word)
			i = (i + 32)
		}
		blocks = append(blocks, block)
		pos = (pos + 512)
	}
	return blocks
}

func bit_and(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	var i int = 0
	_ = i
	for i < 32 {
		if (_modi(x, 2) == 1) && (_modi(y, 2) == 1) {
			res = (res + bit)
		}
		x = (x / 2)
		y = (y / 2)
		bit = (bit * 2)
		i = (i + 1)
	}
	return res
}

func bit_or(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	var i int = 0
	_ = i
	for i < 32 {
		var abit int = _modi(x, 2)
		_ = abit
		var bbit int = _modi(y, 2)
		_ = bbit
		if (abit == 1) || (bbit == 1) {
			res = (res + bit)
		}
		x = (x / 2)
		y = (y / 2)
		bit = (bit * 2)
		i = (i + 1)
	}
	return res
}

func bit_xor(a int, b int) int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var res int = 0
	_ = res
	var bit int = 1
	_ = bit
	var i int = 0
	_ = i
	for i < 32 {
		var abit int = _modi(x, 2)
		_ = abit
		var bbit int = _modi(y, 2)
		_ = bbit
		if _modi((abit+bbit), 2) == 1 {
			res = (res + bit)
		}
		x = (x / 2)
		y = (y / 2)
		bit = (bit * 2)
		i = (i + 1)
	}
	return res
}

func not_32(i int) int {
	if i < 0 {
		panic("Input must be non-negative")
	}
	return (4294967295 - i)
}

func sum_32(a int, b int) int {
	return _modi((a + b), MOD)
}

func lshift(num int, k int) int {
	var result int = _modi(num, MOD)
	_ = result
	var i int = 0
	_ = i
	for i < k {
		result = _modi((result * 2), MOD)
		i = (i + 1)
	}
	return result
}

func rshift(num int, k int) int {
	var result int = num
	_ = result
	var i int = 0
	_ = i
	for i < k {
		result = (result / 2)
		i = (i + 1)
	}
	return result
}

func left_rotate_32(i int, shift int) int {
	if i < 0 {
		panic("Input must be non-negative")
	}
	if shift < 0 {
		panic("Shift must be non-negative")
	}
	var left int = lshift(i, shift)
	_ = left
	_ = left
	var right int = rshift(i, (32 - shift))
	_ = right
	_ = right
	return _modi((left + right), MOD)
}

func md5_me(message string) string {
	var bit_string string = preprocess(message)
	_ = bit_string
	var added_consts []int = []int{3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745}
	_ = added_consts
	var shift_amounts []int = []int{7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21}
	_ = shift_amounts
	var a0 int = 1732584193
	_ = a0
	var b0 int = 4023233417
	_ = b0
	var c0 int = 2562383102
	_ = c0
	var d0 int = 271733878
	_ = d0
	var blocks [][]int = get_block_words(bit_string)
	_ = blocks
	var bi int = 0
	_ = bi
	for bi < len(blocks) {
		var block []int = _index(blocks, bi)
		_ = block
		var a int = a0
		_ = a
		var b int = b0
		_ = b
		var c int = c0
		_ = c
		var d int = d0
		_ = d
		var i int = 0
		_ = i
		for i < 64 {
			var f int = 0
			_ = f
			var g int = 0
			_ = g
			if i <= 15 {
				f = bit_xor(d, bit_and(b, bit_xor(c, d)))
				g = i
			} else {
				if i <= 31 {
					f = bit_xor(c, bit_and(d, bit_xor(b, c)))
					g = _modi(((5 * i) + 1), 16)
				} else {
					if i <= 47 {
						f = bit_xor(bit_xor(b, c), d)
						g = _modi(((3 * i) + 5), 16)
					} else {
						f = bit_xor(c, bit_or(b, not_32(d)))
						g = _modi((7 * i), 16)
					}
				}
			}
			f = sum_32(f, a)
			f = sum_32(f, _index(added_consts, i))
			f = sum_32(f, _index(block, g))
			var rotated int = left_rotate_32(f, _index(shift_amounts, i))
			_ = rotated
			var new_b int = sum_32(b, rotated)
			_ = new_b
			a = d
			d = c
			c = b
			b = new_b
			i = (i + 1)
		}
		a0 = sum_32(a0, a)
		b0 = sum_32(b0, b)
		c0 = sum_32(c0, c)
		d0 = sum_32(d0, d)
		bi = (bi + 1)
	}
	var digest string = (((reformat_hex(a0) + reformat_hex(b0)) + reformat_hex(c0)) + reformat_hex(d0))
	_ = digest
	_ = digest
	return digest
}

var __mochi_test_header_printed bool

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		MOD = 4294967296
		ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/hashes/md5.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (md5_me("") == "d41d8cd98f00b204e9800998ecf8427e")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "md5 empty")
		}()

		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/hashes/md5.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (md5_me("The quick brown fox jumps over the lazy dog") == "9e107d9d372bb6826bd81d3542a419d6")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "md5 fox")
		}()

		if !__mochi_test_header_printed {
			fmt.Println("[94;1mtests/github/TheAlgorithms/Mochi/hashes/md5.mochi[0;22m")
			__mochi_test_header_printed = true
		}
		func() {
			func() {
				defer func() { recover() }()
				_ = (md5_me("The quick brown fox jumps over the lazy dog.") == "e4d909c290d0fb1ca068ffaddf22cbd0")
			}()
			fmt.Printf("   \x1b[33mtest\x1b[0m %s                   ... \x1b[32mok\x1b[0m (1.0ms)\n", "md5 fox dot")
		}()

		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
