//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:34:27 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func index_of(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if string(_index([]rune(s), i)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func ord(ch string) int {
	var upper_ string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper_
	var lower_ string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower_
	var idx int = index_of(upper_, ch)
	_ = idx
	if idx >= 0 {
		return (65 + idx)
	}
	idx = index_of(lower_, ch)
	if idx >= 0 {
		return (97 + idx)
	}
	return 0
}

func chr(n int) string {
	var upper_ string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper_
	_ = upper_
	var lower_ string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower_
	_ = lower_
	if (n >= 65) && (n < 91) {
		return string([]rune(upper_)[(n - 65):(n - 64)])
	}
	if (n >= 97) && (n < 123) {
		return string([]rune(lower_)[(n - 97):(n - 96)])
	}
	return "?"
}

func text_to_bits(text string) string {
	var bits string = ""
	_ = bits
	var i int = 0
	_ = i
	for i < len(text) {
		var code int = ord(string(_index([]rune(text), i)))
		_ = code
		var j int = 7
		_ = j
		for j >= 0 {
			var p int = pow2(j)
			_ = p
			if _modi((code/p), 2) == 1 {
				bits = (bits + "1")
			} else {
				bits = (bits + "0")
			}
			j = (j - 1)
		}
		i = (i + 1)
	}
	return bits
}

func text_from_bits(bits string) string {
	var text string = ""
	_ = text
	var i int = 0
	_ = i
	for i < len(bits) {
		var code int = 0
		_ = code
		var j int = 0
		_ = j
		for (j < 8) && ((i + j) < len(bits)) {
			code = (code * 2)
			if string(_index([]rune(bits), (i+j))) == "1" {
				code = (code + 1)
			}
			j = (j + 1)
		}
		text = (text + chr(code))
		i = (i + 8)
	}
	return text
}

func bool_to_string(b bool) string {
	if b {
		return "True"
	}
	return "False"
}

func string_to_bitlist(s string) []int {
	var res []int = []int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(s) {
		if string(_index([]rune(s), i)) == "1" {
			res = append(res, 1)
		} else {
			res = append(res, 0)
		}
		i = (i + 1)
	}
	return res
}

func bitlist_to_string(bits []int) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < len(bits) {
		if _index(bits, i) == 1 {
			s = (s + "1")
		} else {
			s = (s + "0")
		}
		i = (i + 1)
	}
	return s
}

func is_power_of_two(x int) bool {
	if x < 1 {
		return false
	}
	var p int = 1
	_ = p
	for p < x {
		p = (p * 2)
	}
	return (p == x)
}

func list_eq(a []int, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	var i int = 0
	_ = i
	for i < len(a) {
		if _index(a, i) != _index(b, i) {
			return false
		}
		i = (i + 1)
	}
	return true
}

func pow2(e int) int {
	var res int = 1
	_ = res
	var i int = 0
	_ = i
	for i < e {
		res = (res * 2)
		i = (i + 1)
	}
	return res
}

func has_bit(n int, b int) bool {
	var p int = pow2(b)
	_ = p
	if _modi((n/p), 2) == 1 {
		return true
	}
	return false
}

type DecodeResult struct {
	Data []int `json:"data"`
	Ack  bool  `json:"ack"`
}

func hamming_encode(r int, data_bits []int) []int {
	var total int = (r + len(data_bits))
	_ = total
	var data_ord []int = []int{}
	_ = data_ord
	var cont_data int = 0
	_ = cont_data
	var x int = 1
	_ = x
	for x <= total {
		if is_power_of_two(x) {
			data_ord = append(data_ord, (0 - 1))
		} else {
			data_ord = append(data_ord, _index(data_bits, cont_data))
			cont_data = (cont_data + 1)
		}
		x = (x + 1)
	}
	var parity []int = []int{}
	_ = parity
	var bp int = 0
	_ = bp
	for bp < r {
		var cont_bo int = 0
		_ = cont_bo
		var j int = 0
		_ = j
		for j < len(data_ord) {
			var bit int = _index(data_ord, j)
			_ = bit
			if bit >= 0 {
				var pos int = (j + 1)
				_ = pos
				if has_bit(pos, bp) && (bit == 1) {
					cont_bo = (cont_bo + 1)
				}
			}
			j = (j + 1)
		}
		parity = append(parity, _modi(cont_bo, 2))
		bp = (bp + 1)
	}
	var result []int = []int{}
	_ = result
	var cont_bp int = 0
	_ = cont_bp
	var i int = 0
	_ = i
	for i < len(data_ord) {
		if _index(data_ord, i) < 0 {
			result = append(result, _index(parity, cont_bp))
			cont_bp = (cont_bp + 1)
		} else {
			result = append(result, _index(data_ord, i))
		}
		i = (i + 1)
	}
	return result
}

func hamming_decode(r int, code []int) DecodeResult {
	var data_output []int = []int{}
	_ = data_output
	var parity_received []int = []int{}
	_ = parity_received
	var i int = 1
	_ = i
	var idx int = 0
	_ = idx
	for i <= len(code) {
		if is_power_of_two(i) {
			parity_received = append(parity_received, _index(code, idx))
		} else {
			data_output = append(data_output, _index(code, idx))
		}
		idx = (idx + 1)
		i = (i + 1)
	}
	var recomputed []int = hamming_encode(r, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(data_output))
	_ = recomputed
	var parity_calc []int = []int{}
	_ = parity_calc
	var j int = 0
	_ = j
	for j < len(recomputed) {
		if is_power_of_two((j + 1)) {
			parity_calc = append(parity_calc, _index(recomputed, j))
		}
		j = (j + 1)
	}
	var ack bool = list_eq(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(parity_received), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(parity_calc))
	_ = ack
	_ = ack
	return DecodeResult{
		Data: data_output,
		Ack:  ack,
	}
}

func mochiMain() {
	var sizePari int = 4
	_ = sizePari
	var be int = 2
	_ = be
	var text string = "Message01"
	_ = text
	var binary string = text_to_bits(text)
	_ = binary
	fmt.Println((("Text input in binary is '" + binary) + "'"))
	var data_bits []int = string_to_bitlist(binary)
	_ = data_bits
	var encoded []int = hamming_encode(sizePari, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(data_bits))
	_ = encoded
	fmt.Println(("Data converted ----------> " + bitlist_to_string(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(encoded))))
	var decoded DecodeResult = hamming_decode(sizePari, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(encoded))
	_ = decoded
	fmt.Println(((("Data receive ------------> " + bitlist_to_string(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(decoded.Data))) + " -- Data integrity: ") + bool_to_string(decoded.Ack)))
	var corrupted []int = []int{}
	_ = corrupted
	var i int = 0
	_ = i
	for i < len(encoded) {
		corrupted = append(corrupted, _index(encoded, i))
		i = (i + 1)
	}
	var pos int = (be - 1)
	_ = pos
	if _index(corrupted, pos) == 0 {
		_setIndex(corrupted, pos, 1)
	} else {
		_setIndex(corrupted, pos, 0)
	}
	var decoded_err DecodeResult = hamming_decode(sizePari, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(corrupted))
	_ = decoded_err
	fmt.Println(((("Data receive (error) ----> " + bitlist_to_string(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(decoded_err.Data))) + " -- Data integrity: ") + bool_to_string(decoded_err.Ack)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
