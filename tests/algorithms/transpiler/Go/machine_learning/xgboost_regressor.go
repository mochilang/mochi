//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 14:47:17 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type Dataset struct {
	Data   [][]float64 `json:"data"`
	Target []float64   `json:"target"`
}

type Tree struct {
	Threshold  float64 `json:"threshold"`
	LeftValue  float64 `json:"left_value"`
	RightValue float64 `json:"right_value"`
}

func data_handling(dataset Dataset) Dataset {
	return dataset
}

func xgboost(features [][]float64, target []float64, test_features [][]float64) []float64 {
	var learning_rate float64 = 0.5
	_ = learning_rate
	var n_estimators int = 3
	_ = n_estimators
	var trees []Tree = []Tree{}
	_ = trees
	var predictions []float64 = []float64{}
	_ = predictions
	var i int = 0
	_ = i
	for i < len(target) {
		predictions = append(predictions, 0.0)
		i = (i + 1)
	}
	var est int = 0
	_ = est
	for est < n_estimators {
		var residuals []float64 = []float64{}
		_ = residuals
		var j int = 0
		_ = j
		for j < len(target) {
			residuals = append(residuals, (_index(target, j) - _index(predictions, j)))
			j = (j + 1)
		}
		var sum_feat float64 = 0.0
		_ = sum_feat
		j = 0
		for j < len(features) {
			sum_feat = (sum_feat + _index(_index(features, j), 0))
			j = (j + 1)
		}
		var threshold float64 = (float64(sum_feat) / float64(float64(len(features))))
		_ = threshold
		var left_sum float64 = 0.0
		_ = left_sum
		var left_count int = 0
		_ = left_count
		var right_sum float64 = 0.0
		_ = right_sum
		var right_count int = 0
		_ = right_count
		j = 0
		for j < len(features) {
			if _index(_index(features, j), 0) <= threshold {
				left_sum = (left_sum + _index(residuals, j))
				left_count = (left_count + 1)
			} else {
				right_sum = (right_sum + _index(residuals, j))
				right_count = (right_count + 1)
			}
			j = (j + 1)
		}
		var left_value float64 = 0.0
		_ = left_value
		if left_count > 0 {
			left_value = (float64(left_sum) / float64(left_count))
		}
		var right_value float64 = 0.0
		_ = right_value
		if right_count > 0 {
			right_value = (float64(right_sum) / float64(right_count))
		}
		j = 0
		for j < len(features) {
			if _index(_index(features, j), 0) <= threshold {
				_setIndex(predictions, j, (_index(predictions, j) + (learning_rate * left_value)))
			} else {
				_setIndex(predictions, j, (_index(predictions, j) + (learning_rate * right_value)))
			}
			j = (j + 1)
		}
		trees = append(trees, Tree{
			Threshold:  threshold,
			LeftValue:  left_value,
			RightValue: right_value,
		})
		est = (est + 1)
	}
	var preds []float64 = []float64{}
	_ = preds
	var t int = 0
	_ = t
	for t < len(test_features) {
		var pred float64 = 0.0
		_ = pred
		var k int = 0
		_ = k
		for k < len(trees) {
			if _index(_index(test_features, t), 0) <= _index(trees, k).Threshold {
				pred = (pred + (learning_rate * _index(trees, k).LeftValue))
			} else {
				pred = (pred + (learning_rate * _index(trees, k).RightValue))
			}
			k = (k + 1)
		}
		preds = append(preds, pred)
		t = (t + 1)
	}
	return preds
}

func mean_absolute_error(y_true []float64, y_pred []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(y_true) {
		var diff float64 = (_index(y_true, i) - _index(y_pred, i))
		_ = diff
		if diff < 0.0 {
			diff = (0 - diff)
		}
		sum = (sum + diff)
		i = (i + 1)
	}
	return (float64(sum) / float64(float64(len(y_true))))
}

func mean_squared_error(y_true []float64, y_pred []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(y_true) {
		var diff float64 = (_index(y_true, i) - _index(y_pred, i))
		_ = diff
		sum = (sum + (diff * diff))
		i = (i + 1)
	}
	return (float64(sum) / float64(float64(len(y_true))))
}

func mochiMain() {
	var california Dataset = Dataset{
		Data:   [][]float64{[]float64{1.0}, []float64{2.0}, []float64{3.0}, []float64{4.0}},
		Target: []float64{2.0, 3.0, 4.0, 5.0},
	}
	_ = california
	var ds Dataset = data_handling(california)
	_ = ds
	var x_train [][]float64 = ds.Data
	_ = x_train
	var y_train []float64 = ds.Target
	_ = y_train
	var x_test [][]float64 = [][]float64{[]float64{1.5}, []float64{3.5}}
	_ = x_test
	var y_test []float64 = []float64{2.5, 4.5}
	_ = y_test
	_ = y_test
	var predictions []float64 = xgboost(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(x_train), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(y_train), func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(x_test))
	_ = predictions
	_ = predictions
	fmt.Println("Predictions:")
	fmt.Println(func() string {
		b, _ := json.Marshal(predictions)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		return s
	}())
	fmt.Println("Mean Absolute Error:")
	fmt.Println(func() string {
		f := float64(mean_absolute_error(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_test), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(predictions)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println("Mean Square Error:")
	fmt.Println(func() string {
		f := float64(mean_squared_error(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_test), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(predictions)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
