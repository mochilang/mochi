//go:build ignore

// Generated by Mochi v0.10.67 on 2025-08-16 19:48:39 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func absf(x float64) float64 {
	if x < 0.0 {
		return (0 - x)
	}
	return x
}

func maxf(a float64, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

func minf(a float64, b float64) float64 {
	if a < b {
		return a
	}
	return b
}

func clip(x float64, lo float64, hi float64) float64 {
	return maxf(lo, minf(x, hi))
}

func to_float(x int) float64 {
	return (float64(x) * 1.0)
}

func powf(base float64, exp float64) float64 {
	var result float64 = 1.0
	_ = result
	var i int = 0
	_ = i
	var n int = int(exp)
	_ = n
	for i < n {
		result = (result * base)
		i = (i + 1)
	}
	return result
}

func ln(x float64) float64 {
	if x <= 0.0 {
		panic("ln domain error")
	}
	var y float64 = (float64((x - 1.0)) / float64((x + 1.0)))
	_ = y
	var y2 float64 = (y * y)
	_ = y2
	var term float64 = y
	_ = term
	var sum float64 = 0.0
	_ = sum
	var k int = 0
	_ = k
	for k < 10 {
		var denom float64 = float64(((2 * k) + 1))
		_ = denom
		sum = (sum + (float64(term) / float64(denom)))
		term = (term * y2)
		k = (k + 1)
	}
	return (2.0 * sum)
}

func exp(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var n int = 1
	_ = n
	for n < 20 {
		term = (float64((term * x)) / float64(n))
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

func mean(v []float64) float64 {
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(v) {
		total = (total + _index(v, i))
		i = (i + 1)
	}
	return (float64(total) / float64(len(v)))
}

func binary_cross_entropy(y_true []float64, y_pred []float64, epsilon float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var losses []float64 = []float64{}
	_ = losses
	var i int = 0
	_ = i
	for i < len(y_true) {
		var yt float64 = _index(y_true, i)
		_ = yt
		var yp float64 = clip(_index(y_pred, i), epsilon, (1.0 - epsilon))
		_ = yp
		var loss float64 = (0 - ((yt * math.Log(yp)) + ((1.0 - yt) * math.Log((1.0 - yp)))))
		_ = loss
		losses = append(losses, loss)
		i = (i + 1)
	}
	return mean(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(losses))
}

func binary_focal_cross_entropy(y_true []float64, y_pred []float64, gamma float64, alpha float64, epsilon float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var losses []float64 = []float64{}
	_ = losses
	var i int = 0
	_ = i
	for i < len(y_true) {
		var yt float64 = _index(y_true, i)
		_ = yt
		var yp float64 = clip(_index(y_pred, i), epsilon, (1.0 - epsilon))
		_ = yp
		var term1 float64 = (((alpha * powf((1.0-yp), gamma)) * yt) * math.Log(yp))
		_ = term1
		var term2 float64 = ((((1.0 - alpha) * powf(yp, gamma)) * (1.0 - yt)) * math.Log((1.0 - yp)))
		_ = term2
		losses = append(losses, (0 - (term1 + term2)))
		i = (i + 1)
	}
	return mean(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(losses))
}

func categorical_cross_entropy(y_true [][]float64, y_pred [][]float64, epsilon float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same shape.")
	}
	var rows int = len(y_true)
	_ = rows
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < rows {
		if len(_index(y_true, i)) != len(_index(y_pred, i)) {
			panic("Input arrays must have the same shape.")
		}
		var sum_true float64 = 0.0
		_ = sum_true
		var sum_pred float64 = 0.0
		_ = sum_pred
		var j int = 0
		_ = j
		for j < len(_index(y_true, i)) {
			var yt float64 = _index(_index(y_true, i), j)
			_ = yt
			var yp float64 = _index(_index(y_pred, i), j)
			_ = yp
			if (yt != 0.0) && (yt != 1.0) {
				panic("y_true must be one-hot encoded.")
			}
			sum_true = (sum_true + yt)
			sum_pred = (sum_pred + yp)
			j = (j + 1)
		}
		if sum_true != 1.0 {
			panic("y_true must be one-hot encoded.")
		}
		if absf((sum_pred - 1.0)) > epsilon {
			panic("Predicted probabilities must sum to approximately 1.")
		}
		j = 0
		for j < len(_index(y_true, i)) {
			var yp float64 = clip(_index(_index(y_pred, i), j), epsilon, 1.0)
			_ = yp
			total = (total - (_index(_index(y_true, i), j) * math.Log(yp)))
			j = (j + 1)
		}
		i = (i + 1)
	}
	return total
}

func categorical_focal_cross_entropy(y_true [][]float64, y_pred [][]float64, alpha []float64, gamma float64, epsilon float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Shape of y_true and y_pred must be the same.")
	}
	var rows int = len(y_true)
	_ = rows
	var cols int = len(_index(y_true, 0))
	_ = cols
	var a []float64 = alpha
	_ = a
	if len(a) == 0 {
		var tmp []float64 = []float64{}
		_ = tmp
		var j int = 0
		_ = j
		for j < cols {
			tmp = append(tmp, 1.0)
			j = (j + 1)
		}
		a = tmp
	}
	if len(a) != cols {
		panic("Length of alpha must match the number of classes.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < rows {
		if (len(_index(y_true, i)) != cols) || (len(_index(y_pred, i)) != cols) {
			panic("Shape of y_true and y_pred must be the same.")
		}
		var sum_true float64 = 0.0
		_ = sum_true
		var sum_pred float64 = 0.0
		_ = sum_pred
		var j int = 0
		_ = j
		for j < cols {
			var yt float64 = _index(_index(y_true, i), j)
			_ = yt
			var yp float64 = _index(_index(y_pred, i), j)
			_ = yp
			if (yt != 0.0) && (yt != 1.0) {
				panic("y_true must be one-hot encoded.")
			}
			sum_true = (sum_true + yt)
			sum_pred = (sum_pred + yp)
			j = (j + 1)
		}
		if sum_true != 1.0 {
			panic("y_true must be one-hot encoded.")
		}
		if absf((sum_pred - 1.0)) > epsilon {
			panic("Predicted probabilities must sum to approximately 1.")
		}
		var row_loss float64 = 0.0
		_ = row_loss
		j = 0
		for j < cols {
			var yp float64 = clip(_index(_index(y_pred, i), j), epsilon, 1.0)
			_ = yp
			row_loss = (row_loss + (((_index(a, j) * powf((1.0-yp), gamma)) * _index(_index(y_true, i), j)) * math.Log(yp)))
			j = (j + 1)
		}
		total = (total - row_loss)
		i = (i + 1)
	}
	return (float64(total) / float64(rows))
}

func hinge_loss(y_true []float64, y_pred []float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Length of predicted and actual array must be same.")
	}
	var losses []float64 = []float64{}
	_ = losses
	var i int = 0
	_ = i
	for i < len(y_true) {
		var yt float64 = _index(y_true, i)
		_ = yt
		if (yt != (0 - 1.0)) && (yt != 1.0) {
			panic("y_true can have values -1 or 1 only.")
		}
		var pred float64 = _index(y_pred, i)
		_ = pred
		var l float64 = maxf(0.0, (1.0 - (yt * pred)))
		_ = l
		losses = append(losses, l)
		i = (i + 1)
	}
	return mean(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(losses))
}

func huber_loss(y_true []float64, y_pred []float64, delta float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(y_true) {
		var diff float64 = (_index(y_true, i) - _index(y_pred, i))
		_ = diff
		var adiff float64 = absf(diff)
		_ = adiff
		if adiff <= delta {
			total = (total + ((0.5 * diff) * diff))
		} else {
			total = (total + (delta * (adiff - (0.5 * delta))))
		}
		i = (i + 1)
	}
	return (float64(total) / float64(len(y_true)))
}

func mean_squared_error(y_true []float64, y_pred []float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var losses []float64 = []float64{}
	_ = losses
	var i int = 0
	_ = i
	for i < len(y_true) {
		var diff float64 = (_index(y_true, i) - _index(y_pred, i))
		_ = diff
		losses = append(losses, (diff * diff))
		i = (i + 1)
	}
	return mean(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(losses))
}

func mean_absolute_error(y_true []float64, y_pred []float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(y_true) {
		total = (total + absf((_index(y_true, i) - _index(y_pred, i))))
		i = (i + 1)
	}
	return (float64(total) / float64(len(y_true)))
}

func mean_squared_logarithmic_error(y_true []float64, y_pred []float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(y_true) {
		var a float64 = math.Log((1.0 + _index(y_true, i)))
		_ = a
		var b float64 = math.Log((1.0 + _index(y_pred, i)))
		_ = b
		var diff float64 = (a - b)
		_ = diff
		total = (total + (diff * diff))
		i = (i + 1)
	}
	return (float64(total) / float64(len(y_true)))
}

func mean_absolute_percentage_error(y_true []float64, y_pred []float64, epsilon float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("The length of the two arrays should be the same.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(y_true) {
		var yt float64 = _index(y_true, i)
		_ = yt
		if yt == 0.0 {
			yt = epsilon
		}
		total = (total + absf((float64((yt - _index(y_pred, i))) / float64(yt))))
		i = (i + 1)
	}
	return (float64(total) / float64(len(y_true)))
}

func perplexity_loss(y_true [][]int, y_pred [][][]float64, epsilon float64) float64 {
	var batch int = len(y_true)
	_ = batch
	if batch != len(y_pred) {
		panic("Batch size of y_true and y_pred must be equal.")
	}
	var sentence_len int = len(_index(y_true, 0))
	_ = sentence_len
	if sentence_len != len(_index(y_pred, 0)) {
		panic("Sentence length of y_true and y_pred must be equal.")
	}
	var vocab_size int = len(_index(_index(y_pred, 0), 0))
	_ = vocab_size
	var b int = 0
	_ = b
	var total_perp float64 = 0.0
	_ = total_perp
	for b < batch {
		if (len(_index(y_true, b)) != sentence_len) || (len(_index(y_pred, b)) != sentence_len) {
			panic("Sentence length of y_true and y_pred must be equal.")
		}
		var sum_log float64 = 0.0
		_ = sum_log
		var j int = 0
		_ = j
		for j < sentence_len {
			var label int = _index(_index(y_true, b), j)
			_ = label
			if label >= vocab_size {
				panic("Label value must not be greater than vocabulary size.")
			}
			var prob float64 = clip(_index(_index(_index(y_pred, b), j), label), epsilon, 1.0)
			_ = prob
			sum_log = (sum_log + math.Log(prob))
			j = (j + 1)
		}
		var mean_log float64 = (float64(sum_log) / float64(sentence_len))
		_ = mean_log
		var perp float64 = math.Exp((0 - mean_log))
		_ = perp
		total_perp = (total_perp + perp)
		b = (b + 1)
	}
	return (float64(total_perp) / float64(batch))
}

func smooth_l1_loss(y_true []float64, y_pred []float64, beta float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("The length of the two arrays should be the same.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(y_true) {
		var diff float64 = absf((_index(y_true, i) - _index(y_pred, i)))
		_ = diff
		if diff < beta {
			total = (total + (float64(((0.5 * diff) * diff)) / float64(beta)))
		} else {
			total = ((total + diff) - (0.5 * beta))
		}
		i = (i + 1)
	}
	return (float64(total) / float64(len(y_true)))
}

func kullback_leibler_divergence(y_true []float64, y_pred []float64) float64 {
	if len(y_true) != len(y_pred) {
		panic("Input arrays must have the same length.")
	}
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(y_true) {
		total = (total + (_index(y_true, i) * math.Log((float64(_index(y_true, i)) / float64(_index(y_pred, i))))))
		i = (i + 1)
	}
	return total
}

func mochiMain() {
	var y_true_bc []float64 = []float64{0.0, 1.0, 1.0, 0.0, 1.0}
	_ = y_true_bc
	_ = y_true_bc
	var y_pred_bc []float64 = []float64{0.2, 0.7, 0.9, 0.3, 0.8}
	_ = y_pred_bc
	_ = y_pred_bc
	fmt.Println(func() string {
		f := float64(binary_cross_entropy(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_bc), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_bc), 1e-15))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(binary_focal_cross_entropy(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_bc), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_bc), 2.0, 0.25, 1e-15))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_cce [][]float64 = [][]float64{[]float64{1.0, 0.0, 0.0}, []float64{0.0, 1.0, 0.0}, []float64{0.0, 0.0, 1.0}}
	_ = y_true_cce
	_ = y_true_cce
	var y_pred_cce [][]float64 = [][]float64{[]float64{0.9, 0.1, 0.0}, []float64{0.2, 0.7, 0.1}, []float64{0.0, 0.1, 0.9}}
	_ = y_pred_cce
	_ = y_pred_cce
	fmt.Println(func() string {
		f := float64(categorical_cross_entropy(func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(y_true_cce), func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(y_pred_cce), 1e-15))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var alpha []float64 = []float64{0.6, 0.2, 0.7}
	_ = alpha
	_ = alpha
	fmt.Println(func() string {
		f := float64(categorical_focal_cross_entropy(func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(y_true_cce), func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(y_pred_cce), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(alpha), 2.0, 1e-15))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_hinge []float64 = []float64{(0 - 1.0), 1.0, 1.0, (0 - 1.0), 1.0}
	_ = y_true_hinge
	_ = y_true_hinge
	var y_pred_hinge []float64 = []float64{(0 - 4.0), (0 - 0.3), 0.7, 5.0, 10.0}
	_ = y_pred_hinge
	_ = y_pred_hinge
	fmt.Println(func() string {
		f := float64(hinge_loss(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_hinge), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_hinge)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_huber []float64 = []float64{0.9, 10.0, 2.0, 1.0, 5.2}
	_ = y_true_huber
	_ = y_true_huber
	var y_pred_huber []float64 = []float64{0.8, 2.1, 2.9, 4.2, 5.2}
	_ = y_pred_huber
	_ = y_pred_huber
	fmt.Println(func() string {
		f := float64(huber_loss(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_huber), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_huber), 1.0))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(mean_squared_error(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_huber), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_huber)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(mean_absolute_error(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_huber), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_huber)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(mean_squared_logarithmic_error(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_huber), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_huber)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_mape []float64 = []float64{10.0, 20.0, 30.0, 40.0}
	_ = y_true_mape
	_ = y_true_mape
	var y_pred_mape []float64 = []float64{12.0, 18.0, 33.0, 45.0}
	_ = y_pred_mape
	_ = y_pred_mape
	fmt.Println(func() string {
		f := float64(mean_absolute_percentage_error(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_mape), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_mape), 1e-15))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_perp [][]int = [][]int{[]int{1, 4}, []int{2, 3}}
	_ = y_true_perp
	_ = y_true_perp
	var y_pred_perp [][][]float64 = [][][]float64{[][]float64{[]float64{0.28, 0.19, 0.21, 0.15, 0.17}, []float64{0.24, 0.19, 0.09, 0.18, 0.3}}, [][]float64{[]float64{0.03, 0.26, 0.21, 0.18, 0.32}, []float64{0.28, 0.1, 0.33, 0.15, 0.14}}}
	_ = y_pred_perp
	_ = y_pred_perp
	fmt.Println(func() string {
		f := float64(perplexity_loss(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(y_true_perp), func(v any) [][][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][][]float64{}
				}
				out := make([][][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) [][]float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([][]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return [][]float64{}
							}
							out := make([][]float64, len(arr))
							for i, x := range arr {
								out[i] = x.([]float64)
							}
							return out
						}
						return v.([][]float64)
					}(x)
				}
				return out
			}
			return v.([][][]float64)
		}(y_pred_perp), 1e-07))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_smooth []float64 = []float64{3.0, 5.0, 2.0, 7.0}
	_ = y_true_smooth
	_ = y_true_smooth
	var y_pred_smooth []float64 = []float64{2.9, 4.8, 2.1, 7.2}
	_ = y_pred_smooth
	_ = y_pred_smooth
	fmt.Println(func() string {
		f := float64(smooth_l1_loss(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_smooth), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_smooth), 1.0))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	var y_true_kl []float64 = []float64{0.2, 0.3, 0.5}
	_ = y_true_kl
	_ = y_true_kl
	var y_pred_kl []float64 = []float64{0.3, 0.3, 0.4}
	_ = y_pred_kl
	_ = y_pred_kl
	fmt.Println(func() string {
		f := float64(kullback_leibler_divergence(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_true_kl), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y_pred_kl)))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if math.Abs(f-float64(int(f))) < 1e-9 {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
