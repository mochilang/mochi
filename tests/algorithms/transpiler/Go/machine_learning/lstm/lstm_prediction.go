//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 10:31:23 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

type LSTMWeights struct {
	WI float64 `json:"w_i"`
	UI float64 `json:"u_i"`
	BI float64 `json:"b_i"`
	WF float64 `json:"w_f"`
	UF float64 `json:"u_f"`
	BF float64 `json:"b_f"`
	WO float64 `json:"w_o"`
	UO float64 `json:"u_o"`
	BO float64 `json:"b_o"`
	WC float64 `json:"w_c"`
	UC float64 `json:"u_c"`
	BC float64 `json:"b_c"`
	WY float64 `json:"w_y"`
	BY float64 `json:"b_y"`
}

type LSTMState struct {
	I []float64 `json:"i"`
	F []float64 `json:"f"`
	O []float64 `json:"o"`
	G []float64 `json:"g"`
	C []float64 `json:"c"`
	H []float64 `json:"h"`
}

type Samples struct {
	X [][]float64 `json:"x"`
	Y []float64   `json:"y"`
}

func exp_approx(x float64) float64 {
	var sum float64 = 1.0
	_ = sum
	var term float64 = 1.0
	_ = term
	var n int = 1
	_ = n
	for n < 20 {
		term = (float64((term * x)) / float64(n))
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

func sigmoid(x float64) float64 {
	return (float64(1.0) / float64((1.0 + exp_approx((0 - x)))))
}

func tanh_approx(x float64) float64 {
	var e float64 = exp_approx((2.0 * x))
	_ = e
	_ = e
	return (float64((e - 1.0)) / float64((e + 1.0)))
}

func forward(seq []float64, w LSTMWeights) LSTMState {
	var i_arr []float64 = []float64{}
	_ = i_arr
	var f_arr []float64 = []float64{}
	_ = f_arr
	var o_arr []float64 = []float64{}
	_ = o_arr
	var g_arr []float64 = []float64{}
	_ = g_arr
	var c_arr []float64 = []float64{0.0}
	_ = c_arr
	var h_arr []float64 = []float64{0.0}
	_ = h_arr
	var t int = 0
	_ = t
	for t < len(seq) {
		var x float64 = _index(seq, t)
		_ = x
		var h_prev float64 = _index(h_arr, t)
		_ = h_prev
		var c_prev float64 = _index(c_arr, t)
		_ = c_prev
		var i_t float64 = sigmoid((((w.WI * x) + (w.UI * h_prev)) + w.BI))
		_ = i_t
		var f_t float64 = sigmoid((((w.WF * x) + (w.UF * h_prev)) + w.BF))
		_ = f_t
		var o_t float64 = sigmoid((((w.WO * x) + (w.UO * h_prev)) + w.BO))
		_ = o_t
		var g_t float64 = tanh_approx((((w.WC * x) + (w.UC * h_prev)) + w.BC))
		_ = g_t
		var c_t float64 = ((f_t * c_prev) + (i_t * g_t))
		_ = c_t
		var h_t float64 = (o_t * tanh_approx(c_t))
		_ = h_t
		i_arr = append(i_arr, i_t)
		f_arr = append(f_arr, f_t)
		o_arr = append(o_arr, o_t)
		g_arr = append(g_arr, g_t)
		c_arr = append(c_arr, c_t)
		h_arr = append(h_arr, h_t)
		t = (t + 1)
	}
	return LSTMState{
		I: i_arr,
		F: f_arr,
		O: o_arr,
		G: g_arr,
		C: c_arr,
		H: h_arr,
	}
}

func backward(seq []float64, target float64, w LSTMWeights, s LSTMState, lr float64) LSTMWeights {
	var dw_i float64 = 0.0
	_ = dw_i
	var du_i float64 = 0.0
	_ = du_i
	var db_i float64 = 0.0
	_ = db_i
	var dw_f float64 = 0.0
	_ = dw_f
	var du_f float64 = 0.0
	_ = du_f
	var db_f float64 = 0.0
	_ = db_f
	var dw_o float64 = 0.0
	_ = dw_o
	var du_o float64 = 0.0
	_ = du_o
	var db_o float64 = 0.0
	_ = db_o
	var dw_c float64 = 0.0
	_ = dw_c
	var du_c float64 = 0.0
	_ = du_c
	var db_c float64 = 0.0
	_ = db_c
	var dw_y float64 = 0.0
	_ = dw_y
	var db_y float64 = 0.0
	_ = db_y
	var T int = len(seq)
	_ = T
	var h_last float64 = _index(s.H, T)
	_ = h_last
	var y float64 = ((w.WY * h_last) + w.BY)
	_ = y
	var dy float64 = (y - target)
	_ = dy
	dw_y = (dy * h_last)
	db_y = dy
	var dh_next float64 = (dy * w.WY)
	_ = dh_next
	var dc_next float64 = 0.0
	_ = dc_next
	var t int = (T - 1)
	_ = t
	for t >= 0 {
		var i_t float64 = _index(s.I, t)
		_ = i_t
		var f_t float64 = _index(s.F, t)
		_ = f_t
		var o_t float64 = _index(s.O, t)
		_ = o_t
		var g_t float64 = _index(s.G, t)
		_ = g_t
		var c_t float64 = _index(s.C, (t + 1))
		_ = c_t
		var c_prev float64 = _index(s.C, t)
		_ = c_prev
		var h_prev float64 = _index(s.H, t)
		_ = h_prev
		var tanh_c float64 = tanh_approx(c_t)
		_ = tanh_c
		var do_t float64 = (dh_next * tanh_c)
		_ = do_t
		var da_o float64 = ((do_t * o_t) * (1.0 - o_t))
		_ = da_o
		var dc float64 = (((dh_next * o_t) * (1.0 - (tanh_c * tanh_c))) + dc_next)
		_ = dc
		var di_t float64 = (dc * g_t)
		_ = di_t
		var da_i float64 = ((di_t * i_t) * (1.0 - i_t))
		_ = da_i
		var dg_t float64 = (dc * i_t)
		_ = dg_t
		var da_g float64 = (dg_t * (1.0 - (g_t * g_t)))
		_ = da_g
		var df_t float64 = (dc * c_prev)
		_ = df_t
		var da_f float64 = ((df_t * f_t) * (1.0 - f_t))
		_ = da_f
		dw_i = (dw_i + (da_i * _index(seq, t)))
		du_i = (du_i + (da_i * h_prev))
		db_i = (db_i + da_i)
		dw_f = (dw_f + (da_f * _index(seq, t)))
		du_f = (du_f + (da_f * h_prev))
		db_f = (db_f + da_f)
		dw_o = (dw_o + (da_o * _index(seq, t)))
		du_o = (du_o + (da_o * h_prev))
		db_o = (db_o + da_o)
		dw_c = (dw_c + (da_g * _index(seq, t)))
		du_c = (du_c + (da_g * h_prev))
		db_c = (db_c + da_g)
		dh_next = ((((da_i * w.UI) + (da_f * w.UF)) + (da_o * w.UO)) + (da_g * w.UC))
		dc_next = (dc * f_t)
		t = (t - 1)
	}
	w.WY = (w.WY - (lr * dw_y))
	w.BY = (w.BY - (lr * db_y))
	w.WI = (w.WI - (lr * dw_i))
	w.UI = (w.UI - (lr * du_i))
	w.BI = (w.BI - (lr * db_i))
	w.WF = (w.WF - (lr * dw_f))
	w.UF = (w.UF - (lr * du_f))
	w.BF = (w.BF - (lr * db_f))
	w.WO = (w.WO - (lr * dw_o))
	w.UO = (w.UO - (lr * du_o))
	w.BO = (w.BO - (lr * db_o))
	w.WC = (w.WC - (lr * dw_c))
	w.UC = (w.UC - (lr * du_c))
	w.BC = (w.BC - (lr * db_c))
	return w
}

func make_samples(data []float64, look_back int) Samples {
	var X [][]float64 = [][]float64{}
	_ = X
	var Y []float64 = []float64{}
	_ = Y
	var i int = 0
	_ = i
	for (i + look_back) < len(data) {
		seq := _slice(data, i, (i + look_back))
		_ = seq
		X = append(X, func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(seq))
		Y = append(Y, _index(data, (i+look_back)))
		i = (i + 1)
	}
	return Samples{
		X: X,
		Y: Y,
	}
}

func init_weights() LSTMWeights {
	return LSTMWeights{
		WI: 0.1,
		UI: 0.2,
		BI: 0.0,
		WF: 0.1,
		UF: 0.2,
		BF: 0.0,
		WO: 0.1,
		UO: 0.2,
		BO: 0.0,
		WC: 0.1,
		UC: 0.2,
		BC: 0.0,
		WY: 0.1,
		BY: 0.0,
	}
}

func train(data []float64, look_back int, epochs int, lr float64) LSTMWeights {
	var samples Samples = make_samples(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(data), look_back)
	_ = samples
	var w LSTMWeights = init_weights()
	_ = w
	var ep int = 0
	_ = ep
	for ep < epochs {
		var j int = 0
		_ = j
		for j < len(samples.X) {
			var seq []float64 = _index(samples.X, j)
			_ = seq
			var target float64 = _index(samples.Y, j)
			_ = target
			var state LSTMState = forward(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(seq), w)
			_ = state
			w = backward(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(seq), target, w, state, lr)
			j = (j + 1)
		}
		ep = (ep + 1)
	}
	return w
}

func predict(seq []float64, w LSTMWeights) float64 {
	var state LSTMState = forward(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(seq), w)
	_ = state
	var h_last float64 = _index(state.H, (len(state.H) - 1))
	_ = h_last
	_ = h_last
	return ((w.WY * h_last) + w.BY)
}

var data []float64

var look_back int

var epochs int

var lr float64

var w LSTMWeights

var test_seq []float64

var pred float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		data = []float64{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8}
		look_back = 3
		epochs = 200
		lr = 0.1
		w = train(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(data), look_back, epochs, lr)
		test_seq = []float64{0.6, 0.7, 0.8}
		pred = predict(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(test_seq), w)
		fmt.Println(("Predicted value: " + fmt.Sprint(pred)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
