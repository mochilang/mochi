//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 10:31:37 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func _concat[T any](a, b []T) []T {
	return append(append([]T{}, a...), b...)
}

type Stump struct {
	Feature   int     `json:"feature"`
	Threshold float64 `json:"threshold"`
	Left      float64 `json:"left"`
	Right     float64 `json:"right"`
}

func mean(xs []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(xs) {
		sum = (sum + _index(xs, i))
		i = (i + 1)
	}
	return (float64(sum) / float64((float64(len(xs)) * 1.0)))
}

func stump_predict(s Stump, x []float64) float64 {
	if _index(x, s.Feature) < s.Threshold {
		return s.Left
	}
	return s.Right
}

func train_stump(features [][]float64, residuals []float64) Stump {
	var best_feature int = 0
	_ = best_feature
	var best_threshold float64 = 0.0
	_ = best_threshold
	var best_error float64 = 1000000000.0
	_ = best_error
	var best_left float64 = 0.0
	_ = best_left
	var best_right float64 = 0.0
	_ = best_right
	var num_features int = len(_index(features, 0))
	_ = num_features
	var f int = 0
	_ = f
	for f < num_features {
		var i int = 0
		_ = i
		for i < len(features) {
			var threshold float64 = _index(_index(features, i), f)
			_ = threshold
			var left []float64 = []float64{}
			_ = left
			var right []float64 = []float64{}
			_ = right
			var j int = 0
			_ = j
			for j < len(features) {
				if _index(_index(features, j), f) < threshold {
					left = _concat(left, []float64{_index(residuals, j)})
				} else {
					right = _concat(right, []float64{_index(residuals, j)})
				}
				j = (j + 1)
			}
			if (len(left) != 0) && (len(right) != 0) {
				var left_mean float64 = mean(func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(left))
				_ = left_mean
				var right_mean float64 = mean(func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(right))
				_ = right_mean
				var err float64 = 0.0
				_ = err
				j = 0
				for j < len(features) {
					var pred float64 = func() float64 {
						if _index(_index(features, j), f) < threshold {
							return left_mean
						} else {
							return right_mean
						}
					}()
					_ = pred
					var diff float64 = (_index(residuals, j) - pred)
					_ = diff
					err = (err + (diff * diff))
					j = (j + 1)
				}
				if err < best_error {
					best_error = err
					best_feature = f
					best_threshold = threshold
					best_left = left_mean
					best_right = right_mean
				}
			}
			i = (i + 1)
		}
		f = (f + 1)
	}
	return Stump{
		Feature:   best_feature,
		Threshold: best_threshold,
		Left:      best_left,
		Right:     best_right,
	}
}

func boost(features [][]float64, targets []int, rounds int) []Stump {
	var model []Stump = []Stump{}
	_ = model
	var preds []float64 = []float64{}
	_ = preds
	var i int = 0
	_ = i
	for i < len(targets) {
		preds = _concat(preds, []float64{0.0})
		i = (i + 1)
	}
	var r int = 0
	_ = r
	for r < rounds {
		var residuals []float64 = []float64{}
		_ = residuals
		var j int = 0
		_ = j
		for j < len(targets) {
			residuals = _concat(residuals, []float64{(float64(_index(targets, j)) - _index(preds, j))})
			j = (j + 1)
		}
		var stump Stump = train_stump(func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(features), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(residuals))
		_ = stump
		model = _concat(model, []Stump{stump})
		j = 0
		for j < len(preds) {
			_setIndex(preds, j, (_index(preds, j) + stump_predict(stump, func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(_index(features, j)))))
			j = (j + 1)
		}
		r = (r + 1)
	}
	return model
}

func predict(model []Stump, x []float64) float64 {
	var score float64 = 0.0
	_ = score
	var i int = 0
	_ = i
	for i < len(model) {
		var s Stump = _index(model, i)
		_ = s
		if _index(x, s.Feature) < s.Threshold {
			score = (score + s.Left)
		} else {
			score = (score + s.Right)
		}
		i = (i + 1)
	}
	return score
}

func mochiMain() {
	var features [][]float64 = [][]float64{[]float64{5.1, 3.5}, []float64{4.9, 3.0}, []float64{6.2, 3.4}, []float64{5.9, 3.0}}
	_ = features
	var targets []int = []int{0, 0, 1, 1}
	_ = targets
	var model []Stump = boost(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(features), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(targets), 3)
	_ = model
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < len(features) {
		var s float64 = predict(func(v any) []Stump {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Stump); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Stump{}
				}
				out := make([]Stump, len(arr))
				for i, x := range arr {
					out[i] = x.(Stump)
				}
				return out
			}
			return v.([]Stump)
		}(model), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(_index(features, i)))
		_ = s
		var label int = func() int {
			if s >= 0.5 {
				return 1
			} else {
				return 0
			}
		}()
		_ = label
		if i == 0 {
			out = fmt.Sprint(label)
		} else {
			out = ((out + " ") + fmt.Sprint(label))
		}
		i = (i + 1)
	}
	fmt.Println(out)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
