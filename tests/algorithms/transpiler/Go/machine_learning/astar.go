//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 10:29:20 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type Point struct {
	X int `json:"x"`
	Y int `json:"y"`
}

type Node struct {
	Pos    Point `json:"pos"`
	Parent Point `json:"parent"`
	G      int   `json:"g"`
	H      int   `json:"h"`
	F      int   `json:"f"`
}

func get_neighbours(p Point, x_limit int, y_limit int) []Point {
	var deltas []Point = []Point{Point{
		X: (0 - 1),
		Y: (0 - 1),
	}, Point{
		X: (0 - 1),
		Y: 0,
	}, Point{
		X: (0 - 1),
		Y: 1,
	}, Point{
		X: 0,
		Y: (0 - 1),
	}, Point{
		X: 0,
		Y: 1,
	}, Point{
		X: 1,
		Y: (0 - 1),
	}, Point{
		X: 1,
		Y: 0,
	}, Point{
		X: 1,
		Y: 1,
	}}
	_ = deltas
	var neighbours []Point = []Point{}
	_ = neighbours
	for _, d := range deltas {
		var nx int = (p.X + d.X)
		_ = nx
		var ny int = (p.Y + d.Y)
		_ = ny
		if (((0 <= nx) && (nx < x_limit)) && (0 <= ny)) && (ny < y_limit) {
			neighbours = append(neighbours, Point{
				X: nx,
				Y: ny,
			})
		}
	}
	return neighbours
}

func contains(nodes []Node, p Point) bool {
	for _, n := range nodes {
		if (n.Pos.X == p.X) && (n.Pos.Y == p.Y) {
			return true
		}
	}
	return false
}

func get_node(nodes []Node, p Point) Node {
	for _, n := range nodes {
		if (n.Pos.X == p.X) && (n.Pos.Y == p.Y) {
			return n
		}
	}
	return Node{
		Pos: p,
		Parent: Point{
			X: (0 - 1),
			Y: (0 - 1),
		},
		G: 0,
		H: 0,
		F: 0,
	}
}

func astar(x_limit int, y_limit int, start Point, goal Point) []Point {
	var open []Node = []Node{}
	_ = open
	var closed []Node = []Node{}
	_ = closed
	open = append(open, Node{
		Pos: start,
		Parent: Point{
			X: (0 - 1),
			Y: (0 - 1),
		},
		G: 0,
		H: 0,
		F: 0,
	})
	var current Node = _index(open, 0)
	_ = current
	for len(open) > 0 {
		var min_index int = 0
		_ = min_index
		var i int = 1
		_ = i
		for i < len(open) {
			if _index(open, i).F < _index(open, min_index).F {
				min_index = i
			}
			i = (i + 1)
		}
		current = _index(open, min_index)
		var new_open []Node = []Node{}
		_ = new_open
		var j int = 0
		_ = j
		for j < len(open) {
			if j != min_index {
				new_open = append(new_open, _index(open, j))
			}
			j = (j + 1)
		}
		open = new_open
		closed = append(closed, current)
		if (current.Pos.X == goal.X) && (current.Pos.Y == goal.Y) {
			break
		}
		var neighbours []Point = get_neighbours(current.Pos, x_limit, y_limit)
		_ = neighbours
		for _, np := range neighbours {
			if contains(closed, np) {
				continue
			}
			var g int = (current.G + 1)
			_ = g
			var dx int = (goal.X - np.X)
			_ = dx
			var dy int = (goal.Y - np.Y)
			_ = dy
			var h int = ((dx * dx) + (dy * dy))
			_ = h
			var f int = (g + h)
			_ = f
			var skip bool = false
			_ = skip
			for _, node := range open {
				if ((node.Pos.X == np.X) && (node.Pos.Y == np.Y)) && (node.F < f) {
					skip = true
				}
			}
			if skip {
				continue
			}
			open = append(open, Node{
				Pos:    np,
				Parent: current.Pos,
				G:      g,
				H:      h,
				F:      f,
			})
		}
	}
	var path []Point = []Point{}
	_ = path
	path = append(path, current.Pos)
	for !((current.Parent.X == (0 - 1)) && (current.Parent.Y == (0 - 1))) {
		current = get_node(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}(closed), current.Parent)
		path = append(path, current.Pos)
	}
	var rev []Point = []Point{}
	_ = rev
	var k int = (len(path) - 1)
	_ = k
	for k >= 0 {
		rev = append(rev, _index(path, k))
		k = (k - 1)
	}
	return rev
}

func create_world(x_limit int, y_limit int) [][]int {
	var world [][]int = [][]int{}
	_ = world
	var i int = 0
	_ = i
	for i < x_limit {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < y_limit {
			row = append(row, 0)
			j = (j + 1)
		}
		world = append(world, row)
		i = (i + 1)
	}
	return world
}

func mark_path(world [][]int, path []Point) {
	for _, p := range path {
		_setIndex(_index(world, p.X), p.Y, 1)
	}
}

func print_world(world [][]int) {
	for _, row := range world {
		fmt.Println(fmt.Sprint(row))
	}
}

var world_x int

var world_y int

var start Point

var goal Point

var path []Point

var world [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		world_x = 5
		world_y = 5
		start = Point{
			X: 0,
			Y: 0,
		}
		goal = Point{
			X: 4,
			Y: 4,
		}
		path = astar(world_x, world_y, start, goal)
		fmt.Println((((((((("path from (" + fmt.Sprint(start.X)) + ", ") + fmt.Sprint(start.Y)) + ") to (") + fmt.Sprint(goal.X)) + ", ") + fmt.Sprint(goal.Y)) + ")"))
		world = create_world(world_x, world_y)
		mark_path(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(world), func(v any) []Point {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Point); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Point{}
				}
				out := make([]Point, len(arr))
				for i, x := range arr {
					out[i] = x.(Point)
				}
				return out
			}
			return v.([]Point)
		}(path))
		print_world(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(world))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
