//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 11:52:57 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

type Tree interface{ isTree() }
type Leaf struct {
	Prediction float64 `json:"prediction"`
}

func (Leaf) isTree() {}

type Branch struct {
	DecisionBoundary float64 `json:"decision_boundary"`
	Left             any     `json:"left"`
	Right            any     `json:"right"`
}

func (Branch) isTree() {}

var PI float64

var TWO_PI float64

func _mod(x float64, m float64) float64 {
	return (x - (float64(int((float64(x) / float64(m)))) * m))
}

func sin(x float64) float64 {
	var y float64 = (_mod((x+PI), TWO_PI) - PI)
	_ = y
	var y2 float64 = (y * y)
	_ = y2
	var y3 float64 = (y2 * y)
	_ = y3
	var y5 float64 = (y3 * y2)
	_ = y5
	var y7 float64 = (y5 * y2)
	_ = y7
	_ = y7
	return (((y - (float64(y3) / float64(6.0))) + (float64(y5) / float64(120.0))) - (float64(y7) / float64(5040.0)))
}

var seed int

func rand() float64 {
	seed = _modi(((1103515245 * seed) + 12345), 2147483648)
	return (float64(seed) / float64(2147483648.0))
}

func mean(vals []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(vals) {
		sum = (sum + _index(vals, i))
		i = (i + 1)
	}
	return (float64(sum) / float64(len(vals)))
}

func mean_squared_error(labels []float64, prediction float64) float64 {
	var total float64 = 0.0
	_ = total
	var i int = 0
	_ = i
	for i < len(labels) {
		var diff float64 = (_index(labels, i) - prediction)
		_ = diff
		total = (total + (diff * diff))
		i = (i + 1)
	}
	return (float64(total) / float64(len(labels)))
}

func train_tree(x []float64, y []float64, depth int, min_leaf_size int) any {
	if len(x) < (2 * min_leaf_size) {
		return Leaf{
			Prediction: mean(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(y)),
		}
	}
	if depth == 1 {
		return Leaf{
			Prediction: mean(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(y)),
		}
	}
	var best_split int = 0
	_ = best_split
	var min_error float64 = (mean_squared_error(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(x), mean(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(y))) * 2.0)
	_ = min_error
	var i int = 0
	_ = i
	for i < len(x) {
		if len(x[0:i]) < min_leaf_size {
			i = i
		} else {
			if len(x[i:]) < min_leaf_size {
				i = i
			} else {
				var err_left float64 = mean_squared_error(func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x[0:i]), mean(func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(y[0:i])))
				_ = err_left
				var err_right float64 = mean_squared_error(func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x[i:]), mean(func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(y[i:])))
				_ = err_right
				var err float64 = (err_left + err_right)
				_ = err
				if err < min_error {
					best_split = i
					min_error = err
				}
			}
		}
		i = (i + 1)
	}
	if best_split != 0 {
		var left_x []float64 = x[0:best_split]
		_ = left_x
		var left_y []float64 = y[0:best_split]
		_ = left_y
		var right_x []float64 = x[best_split:]
		_ = right_x
		var right_y []float64 = y[best_split:]
		_ = right_y
		var boundary float64 = _index(x, best_split)
		_ = boundary
		_ = boundary
		var left_tree any = train_tree(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(left_x), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(left_y), (depth - 1), min_leaf_size)
		_ = left_tree
		_ = left_tree
		var right_tree any = train_tree(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(right_x), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(right_y), (depth - 1), min_leaf_size)
		_ = right_tree
		_ = right_tree
		return Branch{
			DecisionBoundary: boundary,
			Left:             left_tree,
			Right:            right_tree,
		}
	}
	return Leaf{
		Prediction: mean(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(y)),
	}
}

func predict(tree any, value float64) float64 {
	return func() float64 {
		switch uv := tree.(type) {
		case Leaf:
			p := uv.Prediction
			return p
		case Branch:
			b := uv.DecisionBoundary
			l := uv.Left
			r := uv.Right
			return func() float64 {
				if value >= b {
					return predict(r, value)
				} else {
					return predict(l, value)
				}
			}()
		default:
			var z float64
			return z
		}
	}()
}

func mochiMain() {
	var x []float64 = []float64{}
	_ = x
	var v float64 = (0 - 1.0)
	_ = v
	for v < 1.0 {
		x = append(x, v)
		v = (v + 0.005)
	}
	var y []float64 = []float64{}
	_ = y
	var i int = 0
	_ = i
	for i < len(x) {
		y = append(y, sin(_index(x, i)))
		i = (i + 1)
	}
	var tree any = train_tree(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(x), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(y), 10, 10)
	_ = tree
	var test_cases []float64 = []float64{}
	_ = test_cases
	i = 0
	for i < 10 {
		test_cases = append(test_cases, ((rand() * 2.0) - 1.0))
		i = (i + 1)
	}
	var predictions []float64 = []float64{}
	_ = predictions
	i = 0
	for i < len(test_cases) {
		predictions = append(predictions, predict(tree, _index(test_cases, i)))
		i = (i + 1)
	}
	var sum_err float64 = 0.0
	_ = sum_err
	i = 0
	for i < len(test_cases) {
		var diff float64 = (_index(predictions, i) - _index(test_cases, i))
		_ = diff
		sum_err = (sum_err + (diff * diff))
		i = (i + 1)
	}
	var avg_error float64 = (float64(sum_err) / float64(len(test_cases)))
	_ = avg_error
	fmt.Println(("Test values: " + fmt.Sprint(test_cases)))
	fmt.Println(("Predictions: " + fmt.Sprint(predictions)))
	fmt.Println(("Average error: " + fmt.Sprint(avg_error)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		TWO_PI = 6.283185307179586
		seed = 123456789
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
