//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 10:31:36 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var LOWER string

var UPPER string

var PUNCT string

func to_lowercase(s string) string {
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(s) {
		var c string = string(_index([]rune(s), i))
		_ = c
		var j int = 0
		_ = j
		var found bool = false
		_ = found
		for j < len(UPPER) {
			if c == string(_index([]rune(UPPER), j)) {
				res = (res + string(_index([]rune(LOWER), j)))
				found = true
				break
			}
			j = (j + 1)
		}
		if !found {
			res = (res + c)
		}
		i = (i + 1)
	}
	return res
}

func is_punct(c string) bool {
	var i int = 0
	_ = i
	for i < len(PUNCT) {
		if c == string(_index([]rune(PUNCT), i)) {
			return true
		}
		i = (i + 1)
	}
	return false
}

func clean_text(text string, keep_newlines bool) string {
	var lower string = to_lowercase(text)
	_ = lower
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(lower) {
		var ch string = string(_index([]rune(lower), i))
		_ = ch
		if is_punct(ch) {
		} else {
			if ch == "\n" {
				if keep_newlines {
					res = (res + "\n")
				}
			} else {
				res = (res + ch)
			}
		}
		i = (i + 1)
	}
	return res
}

func split(s string, sep string) []string {
	var res []string = []string{}
	_ = res
	var current string = ""
	_ = current
	var i int = 0
	_ = i
	for i < len(s) {
		var ch string = string(_index([]rune(s), i))
		_ = ch
		if ch == sep {
			res = append(res, current)
			current = ""
		} else {
			current = (current + ch)
		}
		i = (i + 1)
	}
	res = append(res, current)
	return res
}

func contains(s string, sub string) bool {
	var n int = len(s)
	_ = n
	var m int = len(sub)
	_ = m
	if m == 0 {
		return true
	}
	var i int = 0
	_ = i
	for i <= (n - m) {
		var j int = 0
		_ = j
		var is_match bool = true
		_ = is_match
		for j < m {
			if string(_index([]rune(s), (i+j))) != string(_index([]rune(sub), j)) {
				is_match = false
				break
			}
			j = (j + 1)
		}
		if is_match {
			return true
		}
		i = (i + 1)
	}
	return false
}

func floor(x float64) float64 {
	var i int = int(x)
	_ = i
	if float64(i) > x {
		i = (i - 1)
	}
	return float64(i)
}

func round3(x float64) float64 {
	return (float64(math.Floor(((x * 1000.0) + 0.5))) / float64(1000.0))
}

func ln(x float64) float64 {
	var t float64 = (float64((x - 1.0)) / float64((x + 1.0)))
	_ = t
	var term float64 = t
	_ = term
	var sum float64 = 0.0
	_ = sum
	var k int = 1
	_ = k
	for k <= 99 {
		sum = (sum + (float64(term) / float64(k)))
		term = ((term * t) * t)
		k = (k + 2)
	}
	return (2.0 * sum)
}

func log10(x float64) float64 {
	return (float64(math.Log(x)) / float64(math.Log(10.0)))
}

func term_frequency(term string, document string) int {
	var clean string = clean_text(document, false)
	_ = clean
	var tokens []string = split(clean, " ")
	_ = tokens
	var t string = to_lowercase(term)
	_ = t
	var count int = 0
	_ = count
	var i int = 0
	_ = i
	for i < len(tokens) {
		if (_index(tokens, i) != "") && (_index(tokens, i) == t) {
			count = (count + 1)
		}
		i = (i + 1)
	}
	return count
}

func document_frequency(term string, corpus string) []int {
	var clean string = clean_text(corpus, true)
	_ = clean
	var docs []string = split(clean, "\n")
	_ = docs
	var t string = to_lowercase(term)
	_ = t
	var matches int = 0
	_ = matches
	var i int = 0
	_ = i
	for i < len(docs) {
		if contains(_index(docs, i), t) {
			matches = (matches + 1)
		}
		i = (i + 1)
	}
	return []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(matches), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(len(docs))}
}

func inverse_document_frequency(df int, n int, smoothing bool) float64 {
	if smoothing {
		if n == 0 {
			panic("log10(0) is undefined.")
		}
		var ratio float64 = (float64(n) / float64((1.0 + float64(df))))
		_ = ratio
		var l float64 = log10(ratio)
		_ = l
		var result float64 = round3((1.0 + l))
		_ = result
		_ = result
		fmt.Println(func() string {
			f := float64(result)
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
		return result
	}
	if df == 0 {
		panic("df must be > 0")
	}
	if n == 0 {
		panic("log10(0) is undefined.")
	}
	var ratio float64 = (float64(n) / float64(df))
	_ = ratio
	var l float64 = log10(ratio)
	_ = l
	var result float64 = round3(l)
	_ = result
	_ = result
	fmt.Println(func() string {
		f := float64(result)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	return result
}

func tf_idf(tf int, idf float64) float64 {
	var prod float64 = (float64(tf) * idf)
	_ = prod
	var result float64 = round3(prod)
	_ = result
	_ = result
	fmt.Println(func() string {
		f := float64(result)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	return result
}

var corpus string

var idf_val float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		LOWER = "abcdefghijklmnopqrstuvwxyz"
		UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		PUNCT = "!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~"
		fmt.Println(term_frequency("to", "To be, or not to be"))
		corpus = "This is the first document in the corpus.\nThIs is the second document in the corpus.\nTHIS is the third document in the corpus."
		fmt.Println(fmt.Sprint(document_frequency("first", corpus)))
		idf_val = inverse_document_frequency(1, 3, false)
		tf_idf(2, idf_val)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
