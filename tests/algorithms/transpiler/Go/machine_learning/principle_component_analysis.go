//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-16 11:55:56 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type PCAResult struct {
	Transformed   [][]float64 `json:"transformed"`
	VarianceRatio []float64   `json:"variance_ratio"`
}

func sqrt(x float64) float64 {
	var guess float64 = func() float64 {
		if x > 1.0 {
			return (float64(x) / float64(2.0))
		} else {
			return 1.0
		}
	}()
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (0.5 * (guess + (float64(x) / float64(guess))))
		i = (i + 1)
	}
	return guess
}

func mean(xs []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(xs) {
		sum = (sum + _index(xs, i))
		i = (i + 1)
	}
	return (float64(sum) / float64(len(xs)))
}

func standardize(data [][]float64) [][]float64 {
	var n_samples int = len(data)
	_ = n_samples
	var n_features int = len(_index(data, 0))
	_ = n_features
	var means []float64 = []float64{}
	_ = means
	var stds []float64 = []float64{}
	_ = stds
	var j int = 0
	_ = j
	for j < n_features {
		var column []float64 = []float64{}
		_ = column
		var i int = 0
		_ = i
		for i < n_samples {
			column = append(column, _index(_index(data, i), j))
			i = (i + 1)
		}
		var m float64 = mean(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(column))
		_ = m
		means = append(means, m)
		var variance float64 = 0.0
		_ = variance
		var k int = 0
		_ = k
		for k < n_samples {
			var diff float64 = (_index(column, k) - m)
			_ = diff
			variance = (variance + (diff * diff))
			k = (k + 1)
		}
		stds = append(stds, sqrt((float64(variance) / float64((n_samples - 1)))))
		j = (j + 1)
	}
	var standardized [][]float64 = [][]float64{}
	_ = standardized
	var r int = 0
	_ = r
	for r < n_samples {
		var row []float64 = []float64{}
		_ = row
		var c int = 0
		_ = c
		for c < n_features {
			row = append(row, (float64((_index(_index(data, r), c) - _index(means, c))) / float64(_index(stds, c))))
			c = (c + 1)
		}
		standardized = append(standardized, row)
		r = (r + 1)
	}
	return standardized
}

func covariance_matrix(data [][]float64) [][]float64 {
	var n_samples int = len(data)
	_ = n_samples
	var n_features int = len(_index(data, 0))
	_ = n_features
	var cov [][]float64 = [][]float64{}
	_ = cov
	var i int = 0
	_ = i
	for i < n_features {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < n_features {
			var sum float64 = 0.0
			_ = sum
			var k int = 0
			_ = k
			for k < n_samples {
				sum = (sum + (_index(_index(data, k), i) * _index(_index(data, k), j)))
				k = (k + 1)
			}
			row = append(row, (float64(sum) / float64((n_samples - 1))))
			j = (j + 1)
		}
		cov = append(cov, row)
		i = (i + 1)
	}
	return cov
}

func normalize(vec []float64) []float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(vec) {
		sum = (sum + (_index(vec, i) * _index(vec, i)))
		i = (i + 1)
	}
	var n float64 = sqrt(sum)
	_ = n
	var res []float64 = []float64{}
	_ = res
	var j int = 0
	_ = j
	for j < len(vec) {
		res = append(res, (float64(_index(vec, j)) / float64(n)))
		j = (j + 1)
	}
	return res
}

type Eigen struct {
	Values  []float64   `json:"values"`
	Vectors [][]float64 `json:"vectors"`
}

func eigen_decomposition_2x2(matrix [][]float64) Eigen {
	var a float64 = _index(_index(matrix, 0), 0)
	_ = a
	var b float64 = _index(_index(matrix, 0), 1)
	_ = b
	var c float64 = _index(_index(matrix, 1), 1)
	_ = c
	var diff float64 = (a - c)
	_ = diff
	var discriminant float64 = sqrt(((diff * diff) + ((4.0 * b) * b)))
	_ = discriminant
	var lambda1 float64 = (float64(((a + c) + discriminant)) / float64(2.0))
	_ = lambda1
	var lambda2 float64 = (float64(((a + c) - discriminant)) / float64(2.0))
	_ = lambda2
	var v1 []float64
	_ = v1
	var v2 []float64
	_ = v2
	if b != 0.0 {
		v1 = normalize(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}([]float64{(lambda1 - c), b}))
		v2 = normalize(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}([]float64{(lambda2 - c), b}))
	} else {
		v1 = []float64{1.0, 0.0}
		v2 = []float64{0.0, 1.0}
	}
	var eigenvalues []float64 = []float64{lambda1, lambda2}
	_ = eigenvalues
	var eigenvectors [][]float64 = [][]float64{v1, v2}
	_ = eigenvectors
	if _index(eigenvalues, 0) < _index(eigenvalues, 1) {
		var tmp_val float64 = _index(eigenvalues, 0)
		_ = tmp_val
		_setIndex(eigenvalues, 0, _index(eigenvalues, 1))
		_setIndex(eigenvalues, 1, tmp_val)
		var tmp_vec []float64 = _index(eigenvectors, 0)
		_ = tmp_vec
		_setIndex(eigenvectors, 0, _index(eigenvectors, 1))
		_setIndex(eigenvectors, 1, tmp_vec)
	}
	return Eigen{
		Values:  eigenvalues,
		Vectors: eigenvectors,
	}
}

func transpose(matrix [][]float64) [][]float64 {
	var rows int = len(matrix)
	_ = rows
	var cols int = len(_index(matrix, 0))
	_ = cols
	var trans [][]float64 = [][]float64{}
	_ = trans
	var i int = 0
	_ = i
	for i < cols {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < rows {
			row = append(row, _index(_index(matrix, j), i))
			j = (j + 1)
		}
		trans = append(trans, row)
		i = (i + 1)
	}
	return trans
}

func matrix_multiply(a [][]float64, b [][]float64) [][]float64 {
	var rows_a int = len(a)
	_ = rows_a
	var cols_a int = len(_index(a, 0))
	_ = cols_a
	var rows_b int = len(b)
	_ = rows_b
	var cols_b int = len(_index(b, 0))
	_ = cols_b
	if cols_a != rows_b {
		panic("Incompatible matrices")
	}
	var result [][]float64 = [][]float64{}
	_ = result
	var i int = 0
	_ = i
	for i < rows_a {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < cols_b {
			var sum float64 = 0.0
			_ = sum
			var k int = 0
			_ = k
			for k < cols_a {
				sum = (sum + (_index(_index(a, i), k) * _index(_index(b, k), j)))
				k = (k + 1)
			}
			row = append(row, sum)
			j = (j + 1)
		}
		result = append(result, row)
		i = (i + 1)
	}
	return result
}

func apply_pca(data [][]float64, n_components int) PCAResult {
	var standardized [][]float64 = standardize(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(data))
	_ = standardized
	var cov [][]float64 = covariance_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(standardized))
	_ = cov
	var eig Eigen = eigen_decomposition_2x2(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(cov))
	_ = eig
	var eigenvalues []float64 = eig.Values
	_ = eigenvalues
	var eigenvectors [][]float64 = eig.Vectors
	_ = eigenvectors
	var components [][]float64 = transpose(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(eigenvectors))
	_ = components
	var transformed [][]float64 = matrix_multiply(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(standardized), func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(components))
	_ = transformed
	_ = transformed
	var total float64 = (_index(eigenvalues, 0) + _index(eigenvalues, 1))
	_ = total
	var ratios []float64 = []float64{}
	_ = ratios
	var i int = 0
	_ = i
	for i < n_components {
		ratios = append(ratios, (float64(_index(eigenvalues, i)) / float64(total)))
		i = (i + 1)
	}
	return PCAResult{
		Transformed:   transformed,
		VarianceRatio: ratios,
	}
}

var data [][]float64

var result PCAResult

var idx int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		data = [][]float64{[]float64{2.5, 2.4}, []float64{0.5, 0.7}, []float64{2.2, 2.9}, []float64{1.9, 2.2}, []float64{3.1, 3.0}, []float64{2.3, 2.7}, []float64{2.0, 1.6}, []float64{1.0, 1.1}, []float64{1.5, 1.6}, []float64{1.1, 0.9}}
		result = apply_pca(func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(data), 2)
		fmt.Println("Transformed Data (first 5 rows):")
		idx = 0
		for idx < 5 {
			fmt.Println(func() string {
				b, _ := json.Marshal(_index(result.Transformed, idx))
				s := string(b)
				s = strings.ReplaceAll(s, ":", ": ")
				s = strings.ReplaceAll(s, ",", ", ")
				s = strings.ReplaceAll(s, "}, {", "},{")
				return s
			}())
			idx = (idx + 1)
		}
		fmt.Println("Explained Variance Ratio:")
		fmt.Println(func() string {
			b, _ := json.Marshal(result.VarianceRatio)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
