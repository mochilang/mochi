//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 10:30:57 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func int_to_float(x int) float64 {
	return (float64(x) * 1.0)
}

func abs_float(x float64) float64 {
	if x < 0.0 {
		return (0.0 - x)
	}
	return x
}

func exp_approx(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var i int = 1
	_ = i
	for i < 10 {
		term = (float64((term * x)) / float64(int_to_float(i)))
		sum = (sum + term)
		i = (i + 1)
	}
	return sum
}

func floor_int(x float64) int {
	var i int = 0
	_ = i
	for int_to_float((i + 1)) <= x {
		i = (i + 1)
	}
	return i
}

func dot(a []float64, b []float64) float64 {
	var s float64 = 0.0
	_ = s
	var i int = 0
	_ = i
	for i < len(a) {
		s = (s + (_index(a, i) * _index(b, i)))
		i = (i + 1)
	}
	return s
}

func transpose(m [][]float64) [][]float64 {
	var rows int = len(m)
	_ = rows
	var cols int = len(_index(m, 0))
	_ = cols
	var res [][]float64 = [][]float64{}
	_ = res
	var j int = 0
	_ = j
	for j < cols {
		var row []float64 = []float64{}
		_ = row
		var i int = 0
		_ = i
		for i < rows {
			row = append(row, _index(_index(m, i), j))
			i = (i + 1)
		}
		res = append(res, row)
		j = (j + 1)
	}
	return res
}

func matmul(a [][]float64, b [][]float64) [][]float64 {
	var n int = len(a)
	_ = n
	var m int = len(_index(b, 0))
	_ = m
	var p int = len(b)
	_ = p
	var res [][]float64 = [][]float64{}
	_ = res
	var i int = 0
	_ = i
	for i < n {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < m {
			var s float64 = 0.0
			_ = s
			var k int = 0
			_ = k
			for k < p {
				s = (s + (_index(_index(a, i), k) * _index(_index(b, k), j)))
				k = (k + 1)
			}
			row = append(row, s)
			j = (j + 1)
		}
		res = append(res, row)
		i = (i + 1)
	}
	return res
}

func matvec(a [][]float64, b []float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, dot(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(_index(a, i)), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(b)))
		i = (i + 1)
	}
	return res
}

func identity(n int) [][]float64 {
	var res [][]float64 = [][]float64{}
	_ = res
	var i int = 0
	_ = i
	for i < n {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			row = append(row, func() float64 {
				if i == j {
					return 1.0
				} else {
					return 0.0
				}
			}())
			j = (j + 1)
		}
		res = append(res, row)
		i = (i + 1)
	}
	return res
}

func invert(mat [][]float64) [][]float64 {
	var n int = len(mat)
	_ = n
	var a [][]float64 = mat
	_ = a
	var inv [][]float64 = identity(n)
	_ = inv
	var i int = 0
	_ = i
	for i < n {
		var pivot float64 = _index(_index(a, i), i)
		_ = pivot
		var j int = 0
		_ = j
		for j < n {
			_setIndex(_index(a, i), j, (float64(_index(_index(a, i), j)) / float64(pivot)))
			_setIndex(_index(inv, i), j, (float64(_index(_index(inv, i), j)) / float64(pivot)))
			j = (j + 1)
		}
		var k int = 0
		_ = k
		for k < n {
			if k != i {
				var factor float64 = _index(_index(a, k), i)
				_ = factor
				j = 0
				for j < n {
					_setIndex(_index(a, k), j, (_index(_index(a, k), j) - (factor * _index(_index(a, i), j))))
					_setIndex(_index(inv, k), j, (_index(_index(inv, k), j) - (factor * _index(_index(inv, i), j))))
					j = (j + 1)
				}
			}
			k = (k + 1)
		}
		i = (i + 1)
	}
	return inv
}

func normal_equation(X [][]float64, y []float64) []float64 {
	var Xt [][]float64 = transpose(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(X))
	_ = Xt
	var XtX [][]float64 = matmul(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(Xt), func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(X))
	_ = XtX
	var XtX_inv [][]float64 = invert(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(XtX))
	_ = XtX_inv
	_ = XtX_inv
	var Xty []float64 = matvec(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(Xt), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(y))
	_ = Xty
	_ = Xty
	return matvec(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(XtX_inv), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(Xty))
}

func linear_regression_prediction(train_dt []float64, train_usr []float64, train_mtch []float64, test_dt []float64, test_mtch []float64) float64 {
	var X [][]float64 = [][]float64{}
	_ = X
	var i int = 0
	_ = i
	for i < len(train_dt) {
		X = append(X, []float64{1.0, _index(train_dt, i), _index(train_mtch, i)})
		i = (i + 1)
	}
	var beta []float64 = normal_equation(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(X), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(train_usr))
	_ = beta
	_ = beta
	return abs_float(((_index(beta, 0) + (_index(test_dt, 0) * _index(beta, 1))) + (_index(test_mtch, 0) * _index(beta, 2))))
}

func sarimax_predictor(train_user []float64, train_match []float64, test_match []float64) float64 {
	var n int = len(train_user)
	_ = n
	var X [][]float64 = [][]float64{}
	_ = X
	var y []float64 = []float64{}
	_ = y
	var i int = 1
	_ = i
	for i < n {
		X = append(X, []float64{1.0, _index(train_user, (i - 1)), _index(train_match, i)})
		y = append(y, _index(train_user, i))
		i = (i + 1)
	}
	var beta []float64 = normal_equation(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(X), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(y))
	_ = beta
	_ = beta
	return ((_index(beta, 0) + (_index(beta, 1) * _index(train_user, (n-1)))) + (_index(beta, 2) * _index(test_match, 0)))
}

func rbf_kernel(a []float64, b []float64, gamma float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(a) {
		var diff float64 = (_index(a, i) - _index(b, i))
		_ = diff
		sum = (sum + (diff * diff))
		i = (i + 1)
	}
	return exp_approx(((0 - gamma) * sum))
}

func support_vector_regressor(x_train [][]float64, x_test [][]float64, train_user []float64) float64 {
	var gamma float64 = 0.1
	_ = gamma
	var weights []float64 = []float64{}
	_ = weights
	var i int = 0
	_ = i
	for i < len(x_train) {
		weights = append(weights, rbf_kernel(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(_index(x_train, i)), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(_index(x_test, 0)), gamma))
		i = (i + 1)
	}
	var num float64 = 0.0
	_ = num
	var den float64 = 0.0
	_ = den
	i = 0
	for i < len(train_user) {
		num = (num + (_index(weights, i) * _index(train_user, i)))
		den = (den + _index(weights, i))
		i = (i + 1)
	}
	return (float64(num) / float64(den))
}

func set_at_float(xs []float64, idx int, value float64) []float64 {
	var i int = 0
	_ = i
	var res []float64 = []float64{}
	_ = res
	for i < len(xs) {
		if i == idx {
			res = append(res, value)
		} else {
			res = append(res, _index(xs, i))
		}
		i = (i + 1)
	}
	return res
}

func sort_float(xs []float64) []float64 {
	var res []float64 = xs
	_ = res
	var i int = 1
	_ = i
	for i < len(res) {
		var key float64 = _index(res, i)
		_ = key
		var j int = (i - 1)
		_ = j
		for (j >= 0) && (_index(res, j) > key) {
			res = set_at_float(func(v any) []float64 {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]float64); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []float64{}
					}
					out := make([]float64, len(arr))
					for i, x := range arr {
						out[i] = x.(float64)
					}
					return out
				}
				return v.([]float64)
			}(res), (j + 1), _index(res, j))
			j = (j - 1)
		}
		res = set_at_float(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(res), (j + 1), key)
		i = (i + 1)
	}
	return res
}

func percentile(data []float64, q float64) float64 {
	var sorted []float64 = sort_float(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(data))
	_ = sorted
	var n int = len(sorted)
	_ = n
	var pos float64 = ((float64(q) / float64(100.0)) * int_to_float((n - 1)))
	_ = pos
	var idx int = floor_int(pos)
	_ = idx
	var frac float64 = (pos - int_to_float(idx))
	_ = frac
	_ = frac
	if (idx + 1) < n {
		return ((_index(sorted, idx) * (1.0 - frac)) + (_index(sorted, (idx+1)) * frac))
	}
	return _index(sorted, idx)
}

func interquartile_range_checker(train_user []float64) float64 {
	var q1 float64 = percentile(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(train_user), 25.0)
	_ = q1
	var q3 float64 = percentile(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(train_user), 75.0)
	_ = q3
	var iqr float64 = (q3 - q1)
	_ = iqr
	_ = iqr
	return (q1 - (iqr * 0.1))
}

func data_safety_checker(list_vote []float64, actual_result float64) bool {
	var safe int = 0
	_ = safe
	var not_safe int = 0
	_ = not_safe
	var i int = 0
	_ = i
	for i < len(list_vote) {
		var v float64 = _index(list_vote, i)
		_ = v
		if v > actual_result {
			safe = (not_safe + 1)
		} else {
			if abs_float((abs_float(v) - abs_float(actual_result))) <= 0.1 {
				safe = (safe + 1)
			} else {
				not_safe = (not_safe + 1)
			}
		}
		i = (i + 1)
	}
	return (safe > not_safe)
}

func mochiMain() {
	var vote []float64 = []float64{linear_regression_prediction(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{2.0, 3.0, 4.0, 5.0}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{5.0, 3.0, 4.0, 6.0}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{3.0, 1.0, 2.0, 4.0}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{2.0}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{2.0})), sarimax_predictor(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{4.0, 2.0, 6.0, 8.0}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{3.0, 1.0, 2.0, 4.0}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{2.0})), support_vector_regressor(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}([][]float64{[]float64{5.0, 2.0}, []float64{1.0, 5.0}, []float64{6.0, 2.0}}), func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}([][]float64{[]float64{3.0, 2.0}}), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}([]float64{2.0, 1.0, 4.0}))}
	_ = vote
	fmt.Println(func() string {
		f := float64(_index(vote, 0))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(_index(vote, 1))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(_index(vote, 2))
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(data_safety_checker(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(vote), 5.0))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
