//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:39:55 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

type Complex struct {
	Re float64 `json:"re"`
	Im float64 `json:"im"`
}

func complex_conj(z Complex) Complex {
	return Complex{
		Re: z.Re,
		Im: (0 - z.Im),
	}
}

func complex_eq(a Complex, b Complex) bool {
	return ((a.Re == b.Re) && (a.Im == b.Im))
}

func complex_add(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re + b.Re),
		Im: (a.Im + b.Im),
	}
}

func complex_mul(a Complex, b Complex) Complex {
	var real float64 = ((a.Re * b.Re) - (a.Im * b.Im))
	_ = real
	_ = real
	var imag float64 = ((a.Re * b.Im) + (a.Im * b.Re))
	_ = imag
	_ = imag
	return Complex{
		Re: real,
		Im: imag,
	}
}

func conj_vector(v []Complex) []Complex {
	var res []Complex = []Complex{}
	_ = res
	var i int = 0
	_ = i
	for i < len(v) {
		res = append(res, complex_conj(_index(v, i)))
		i = (i + 1)
	}
	return res
}

func vec_mat_mul(v []Complex, m [][]Complex) []Complex {
	var result []Complex = []Complex{}
	_ = result
	var col int = 0
	_ = col
	for col < len(_index(m, 0)) {
		var sum Complex = Complex{
			Re: 0.0,
			Im: 0.0,
		}
		_ = sum
		var row int = 0
		_ = row
		for row < len(v) {
			sum = complex_add(sum, complex_mul(_index(v, row), _index(_index(m, row), col)))
			row = (row + 1)
		}
		result = append(result, sum)
		col = (col + 1)
	}
	return result
}

func dot(a []Complex, b []Complex) Complex {
	var sum Complex = Complex{
		Re: 0.0,
		Im: 0.0,
	}
	_ = sum
	var i int = 0
	_ = i
	for i < len(a) {
		sum = complex_add(sum, complex_mul(_index(a, i), _index(b, i)))
		i = (i + 1)
	}
	return sum
}

func is_hermitian(m [][]Complex) bool {
	var i int = 0
	_ = i
	for i < len(m) {
		var j int = 0
		_ = j
		for j < len(m) {
			if !complex_eq(_index(_index(m, i), j), complex_conj(_index(_index(m, j), i))) {
				return false
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return true
}

func rayleigh_quotient(a [][]Complex, v []Complex) float64 {
	var v_star []Complex = conj_vector(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(v))
	_ = v_star
	var v_star_dot []Complex = vec_mat_mul(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(v_star), func(v any) [][]Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]Complex{}
			}
			out := make([][]Complex, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []Complex {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]Complex); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []Complex{}
						}
						out := make([]Complex, len(arr))
						for i, x := range arr {
							out[i] = x.(Complex)
						}
						return out
					}
					return v.([]Complex)
				}(x)
			}
			return out
		}
		return v.([][]Complex)
	}(a))
	_ = v_star_dot
	var num Complex = dot(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(v_star_dot), func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(v))
	_ = num
	_ = num
	var den Complex = dot(func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(v_star), func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(v))
	_ = den
	_ = den
	return (float64(num.Re) / float64(den.Re))
}

var a [][]Complex

var v []Complex

var b [][]Complex

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		a = [][]Complex{[]Complex{Complex{
			Re: 2.0,
			Im: 0.0,
		}, Complex{
			Re: 2.0,
			Im: 1.0,
		}, Complex{
			Re: 4.0,
			Im: 0.0,
		}}, []Complex{Complex{
			Re: 2.0,
			Im: (0 - 1.0),
		}, Complex{
			Re: 3.0,
			Im: 0.0,
		}, Complex{
			Re: 0.0,
			Im: 1.0,
		}}, []Complex{Complex{
			Re: 4.0,
			Im: 0.0,
		}, Complex{
			Re: 0.0,
			Im: (0 - 1.0),
		}, Complex{
			Re: 1.0,
			Im: 0.0,
		}}}
		v = []Complex{Complex{
			Re: 1.0,
			Im: 0.0,
		}, Complex{
			Re: 2.0,
			Im: 0.0,
		}, Complex{
			Re: 3.0,
			Im: 0.0,
		}}
		if is_hermitian(func(v any) [][]Complex {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]Complex); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]Complex{}
				}
				out := make([][]Complex, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []Complex {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]Complex); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []Complex{}
							}
							out := make([]Complex, len(arr))
							for i, x := range arr {
								out[i] = x.(Complex)
							}
							return out
						}
						return v.([]Complex)
					}(x)
				}
				return out
			}
			return v.([][]Complex)
		}(a)) {
			var r1 float64 = rayleigh_quotient(func(v any) [][]Complex {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]Complex); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]Complex{}
					}
					out := make([][]Complex, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []Complex {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]Complex); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []Complex{}
								}
								out := make([]Complex, len(arr))
								for i, x := range arr {
									out[i] = x.(Complex)
								}
								return out
							}
							return v.([]Complex)
						}(x)
					}
					return out
				}
				return v.([][]Complex)
			}(a), func(v any) []Complex {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Complex); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Complex{}
					}
					out := make([]Complex, len(arr))
					for i, x := range arr {
						out[i] = x.(Complex)
					}
					return out
				}
				return v.([]Complex)
			}(v))
			_ = r1
			_ = r1
			fmt.Println(func() string {
				f := float64(r1)
				if f == 0 && math.Signbit(f) {
					return "-0"
				}
				if f == float64(int(f)) {
					return fmt.Sprintf("%.1f", f)
				}
				return fmt.Sprint(f)
			}())
			fmt.Println("\n")
		}
		b = [][]Complex{[]Complex{Complex{
			Re: 1.0,
			Im: 0.0,
		}, Complex{
			Re: 2.0,
			Im: 0.0,
		}, Complex{
			Re: 4.0,
			Im: 0.0,
		}}, []Complex{Complex{
			Re: 2.0,
			Im: 0.0,
		}, Complex{
			Re: 3.0,
			Im: 0.0,
		}, Complex{
			Re: (0 - 1.0),
			Im: 0.0,
		}}, []Complex{Complex{
			Re: 4.0,
			Im: 0.0,
		}, Complex{
			Re: (0 - 1.0),
			Im: 0.0,
		}, Complex{
			Re: 1.0,
			Im: 0.0,
		}}}
		if is_hermitian(func(v any) [][]Complex {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]Complex); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]Complex{}
				}
				out := make([][]Complex, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []Complex {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]Complex); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []Complex{}
							}
							out := make([]Complex, len(arr))
							for i, x := range arr {
								out[i] = x.(Complex)
							}
							return out
						}
						return v.([]Complex)
					}(x)
				}
				return out
			}
			return v.([][]Complex)
		}(b)) {
			var r2 float64 = rayleigh_quotient(func(v any) [][]Complex {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]Complex); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]Complex{}
					}
					out := make([][]Complex, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []Complex {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]Complex); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []Complex{}
								}
								out := make([]Complex, len(arr))
								for i, x := range arr {
									out[i] = x.(Complex)
								}
								return out
							}
							return v.([]Complex)
						}(x)
					}
					return out
				}
				return v.([][]Complex)
			}(b), func(v any) []Complex {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]Complex); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []Complex{}
					}
					out := make([]Complex, len(arr))
					for i, x := range arr {
						out[i] = x.(Complex)
					}
					return out
				}
				return v.([]Complex)
			}(v))
			_ = r2
			_ = r2
			fmt.Println(func() string {
				f := float64(r2)
				if f == 0 && math.Signbit(f) {
					return "-0"
				}
				if f == float64(int(f)) {
					return fmt.Sprintf("%.1f", f)
				}
				return fmt.Sprint(f)
			}())
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
