//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 10:29:15 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func int_to_string(n int) string {
	if n == 0 {
		return "0"
	}
	var num int = n
	_ = num
	var neg bool = false
	_ = neg
	if num < 0 {
		neg = true
		num = (0 - num)
	}
	var res string = ""
	_ = res
	for num > 0 {
		var digit int = _mod(num, 10)
		_ = digit
		var ch string = _substr("0123456789", digit, (digit + 1))
		_ = ch
		res = (ch + res)
		num = (num / 10)
	}
	if neg {
		res = ("-" + res)
	}
	return res
}

func float_to_string(x float64, dec int) string {
	var neg bool = false
	_ = neg
	var num float64 = x
	_ = num
	if num < 0.0 {
		neg = true
		num = (0 - num)
	}
	var int_part int = int(num)
	_ = int_part
	var res string = int_to_string(int_part)
	_ = res
	if dec > 0 {
		res = (res + ".")
		var frac float64 = (num - float64(int_part))
		_ = frac
		var i int = 0
		_ = i
		for i < dec {
			frac = (frac * 10.0)
			var digit int = int(frac)
			_ = digit
			res = (res + _substr("0123456789", digit, (digit+1)))
			frac = (frac - float64(digit))
			i = (i + 1)
		}
	}
	if neg {
		res = ("-" + res)
	}
	return res
}

func vector_component(v []int, i int) int {
	return _index(v, i)
}

func vector_str_int(v []int) string {
	var s string = "("
	_ = s
	var i int = 0
	_ = i
	for i < len(v) {
		s = (s + int_to_string(_index(v, i)))
		if (i + 1) < len(v) {
			s = (s + ",")
		}
		i = (i + 1)
	}
	s = (s + ")")
	return s
}

func vector_str_float(v []float64, dec int) string {
	var s string = "("
	_ = s
	var i int = 0
	_ = i
	for i < len(v) {
		s = (s + float_to_string(_index(v, i), dec))
		if (i + 1) < len(v) {
			s = (s + ",")
		}
		i = (i + 1)
	}
	s = (s + ")")
	return s
}

func vector_add(a []int, b []int) []int {
	var res []int = []int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, (_index(a, i) + _index(b, i)))
		i = (i + 1)
	}
	return res
}

func vector_sub(a []int, b []int) []int {
	var res []int = []int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		res = append(res, (_index(a, i) - _index(b, i)))
		i = (i + 1)
	}
	return res
}

func vector_scalar_mul(v []int, s float64) []float64 {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < len(v) {
		res = append(res, (float64(_index(v, i)) * s))
		i = (i + 1)
	}
	return res
}

func vector_dot(a []int, b []int) int {
	var sum int = 0
	_ = sum
	var i int = 0
	_ = i
	for i < len(a) {
		sum = (sum + (_index(a, i) * _index(b, i)))
		i = (i + 1)
	}
	return sum
}

func sqrt_newton(x float64) float64 {
	if x == 0.0 {
		return 0.0
	}
	var low float64 = 0.0
	_ = low
	var high float64 = x
	_ = high
	if x < 1.0 {
		high = 1.0
	}
	var mid float64 = 0.0
	_ = mid
	var i int = 0
	_ = i
	for i < 40 {
		mid = (float64((low + high)) / float64(2.0))
		if (mid * mid) > x {
			high = mid
		} else {
			low = mid
		}
		i = (i + 1)
	}
	return mid
}

func euclidean_length(v []int) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(v) {
		var val float64 = float64(_index(v, i))
		_ = val
		sum = (sum + (val * val))
		i = (i + 1)
	}
	return sqrt_newton(sum)
}

func zero_vector(n int) []int {
	var v []int = []int{}
	_ = v
	var i int = 0
	_ = i
	for i < n {
		v = append(v, 0)
		i = (i + 1)
	}
	return v
}

func unit_basis_vector(n int, idx int) []int {
	var v []int = zero_vector(n)
	_ = v
	_setIndex(v, idx, 1)
	return v
}

func axpy(a int, x []int, y []int) []int {
	var res []int = []int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(x) {
		res = append(res, ((a * _index(x, i)) + _index(y, i)))
		i = (i + 1)
	}
	return res
}

func copy_vector(x []int) []int {
	var res []int = []int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(x) {
		res = append(res, _index(x, i))
		i = (i + 1)
	}
	return res
}

func change_component(v []int, idx int, val int) {
	_setIndex(v, idx, val)
}

func matrix_str(m [][]int) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < len(m) {
		s = (s + "|")
		var j int = 0
		_ = j
		for j < len(_index(m, 0)) {
			s = (s + int_to_string(_index(_index(m, i), j)))
			if (j + 1) < len(_index(m, 0)) {
				s = (s + ",")
			}
			j = (j + 1)
		}
		s = (s + "|\n")
		i = (i + 1)
	}
	return s
}

func submatrix(m [][]int, row int, col int) [][]int {
	var res [][]int = [][]int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(m) {
		if i != row {
			var r []int = []int{}
			_ = r
			var j int = 0
			_ = j
			for j < len(_index(m, 0)) {
				if j != col {
					r = append(r, _index(_index(m, i), j))
				}
				j = (j + 1)
			}
			res = append(res, r)
		}
		i = (i + 1)
	}
	return res
}

func determinant(m [][]int) int {
	var n int = len(m)
	_ = n
	if n == 1 {
		return _index(_index(m, 0), 0)
	}
	if n == 2 {
		return ((_index(_index(m, 0), 0) * _index(_index(m, 1), 1)) - (_index(_index(m, 0), 1) * _index(_index(m, 1), 0)))
	}
	var det int = 0
	_ = det
	var c int = 0
	_ = c
	for c < n {
		var sub [][]int = submatrix(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(m), 0, c)
		_ = sub
		var sign int = 1
		_ = sign
		if _mod(c, 2) == 1 {
			sign = (0 - 1)
		}
		det = (det + ((sign * _index(_index(m, 0), c)) * determinant(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(sub))))
		c = (c + 1)
	}
	return det
}

func matrix_minor(m [][]int, row int, col int) int {
	return determinant(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(submatrix(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(m), row, col)))
}

func matrix_cofactor(m [][]int, row int, col int) int {
	var sign int = 1
	_ = sign
	if _mod((row+col), 2) == 1 {
		sign = (0 - 1)
	}
	return (sign * matrix_minor(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(m), row, col))
}

func matrix_mul_vector(m [][]int, v []int) []int {
	var res []int = []int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(m) {
		var sum int = 0
		_ = sum
		var j int = 0
		_ = j
		for j < len(_index(m, 0)) {
			sum = (sum + (_index(_index(m, i), j) * _index(v, j)))
			j = (j + 1)
		}
		res = append(res, sum)
		i = (i + 1)
	}
	return res
}

func matrix_mul_scalar(m [][]int, s int) [][]int {
	var res [][]int = [][]int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(m) {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < len(_index(m, 0)) {
			row = append(row, (_index(_index(m, i), j) * s))
			j = (j + 1)
		}
		res = append(res, row)
		i = (i + 1)
	}
	return res
}

func matrix_change_component(m [][]int, i int, j int, val int) {
	_setIndex(_index(m, i), j, val)
}

func matrix_component(m [][]int, i int, j int) int {
	return _index(_index(m, i), j)
}

func matrix_add(a [][]int, b [][]int) [][]int {
	var res [][]int = [][]int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < len(_index(a, 0)) {
			row = append(row, (_index(_index(a, i), j) + _index(_index(b, i), j)))
			j = (j + 1)
		}
		res = append(res, row)
		i = (i + 1)
	}
	return res
}

func matrix_sub(a [][]int, b [][]int) [][]int {
	var res [][]int = [][]int{}
	_ = res
	var i int = 0
	_ = i
	for i < len(a) {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < len(_index(a, 0)) {
			row = append(row, (_index(_index(a, i), j) - _index(_index(b, i), j)))
			j = (j + 1)
		}
		res = append(res, row)
		i = (i + 1)
	}
	return res
}

func square_zero_matrix(n int) [][]int {
	var m [][]int = [][]int{}
	_ = m
	var i int = 0
	_ = i
	for i < n {
		m = append(m, zero_vector(n))
		i = (i + 1)
	}
	return m
}

func assert_int(name string, actual int, expected int) {
	if actual == expected {
		fmt.Println((name + " ok"))
	} else {
		fmt.Println(((((name + " fail ") + int_to_string(actual)) + " != ") + int_to_string(expected)))
	}
}

func assert_str(name string, actual string, expected string) {
	if actual == expected {
		fmt.Println((name + " ok"))
	} else {
		fmt.Println((name + " fail"))
		fmt.Println(actual)
		fmt.Println(expected)
	}
}

func assert_float(name string, actual float64, expected float64, eps float64) {
	var diff float64 = (actual - expected)
	_ = diff
	if diff < 0.0 {
		diff = (0 - diff)
	}
	if diff <= eps {
		fmt.Println((name + " ok"))
	} else {
		fmt.Println((name + " fail"))
	}
}

var vx []int

var vs []int

var vsize []int

var va []int

var vb []int

var vsum []int

var vsub []int

var vmul []float64

var zvec []int

var zstr string

var zcount int

var zi int

var vcopy []int

var vchange []int

var ma [][]int

var mb [][]int

var mv []int

var msc [][]int

var mc [][]int

var madd [][]int

var msub [][]int

var mzero [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		vx = []int{1, 2, 3}
		assert_int("component0", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vx), 0), 1)
		assert_int("component2", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vx), 2), 3)
		vs = []int{0, 0, 0, 0, 0, 1}
		assert_str("str_vector", vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vs)), "(0,0,0,0,0,1)")
		vsize = []int{1, 2, 3, 4}
		assert_int("size", len(vsize), 4)
		va = []int{1, 2, 3}
		vb = []int{1, 1, 1}
		vsum = vector_add(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(va), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vb))
		assert_int("add0", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vsum), 0), 2)
		assert_int("add1", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vsum), 1), 3)
		assert_int("add2", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vsum), 2), 4)
		vsub = vector_sub(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(va), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vb))
		assert_int("sub0", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vsub), 0), 0)
		assert_int("sub1", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vsub), 1), 1)
		assert_int("sub2", vector_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vsub), 2), 2)
		vmul = vector_scalar_mul(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(va), 3.0)
		assert_str("scalar_mul", vector_str_float(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(vmul), 1), "(3.0,6.0,9.0)")
		assert_int("dot_product", vector_dot(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{2, func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1)), 4}), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 2)), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}((0 - 1))})), 0)
		zvec = zero_vector(10)
		zstr = vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(zvec))
		zcount = 0
		zi = 0
		for zi < len(zstr) {
			if _substr(zstr, zi, (zi+1)) == "0" {
				zcount = (zcount + 1)
			}
			zi = (zi + 1)
		}
		assert_int("zero_vector", zcount, 10)
		assert_str("unit_basis", vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(unit_basis_vector(3, 1))), "(0,1,0)")
		assert_str("axpy", vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(axpy(2, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 2, 3}), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 0, 1})))), "(3,4,7)")
		vcopy = copy_vector(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 0, 0, 0, 0, 0}))
		assert_str("copy", vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vcopy)), "(1,0,0,0,0,0)")
		vchange = []int{1, 0, 0}
		change_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vchange), 0, 0)
		change_component(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vchange), 1, 1)
		assert_str("change_component", vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(vchange)), "(0,1,0)")
		ma = [][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{6, 7, 8}}
		assert_str("matrix_str", matrix_str(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(ma)), "|1,2,3|\n|2,4,5|\n|6,7,8|\n")
		assert_int("determinant", determinant(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(ma)), (0 - 5))
		mb = [][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}
		mv = matrix_mul_vector(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(mb), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 2, 3}))
		assert_str("matrix_vec_mul", vector_str_int(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(mv)), "(14,32,50)")
		msc = matrix_mul_scalar(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(mb), 2)
		assert_str("matrix_scalar_mul", matrix_str(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(msc)), "|2,4,6|\n|8,10,12|\n|14,16,18|\n")
		mc = [][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{6, 7, 8}}
		matrix_change_component(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(mc), 0, 2, 5)
		assert_str("change_component_matrix", matrix_str(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(mc)), "|1,2,5|\n|2,4,5|\n|6,7,8|\n")
		assert_int("matrix_component", matrix_component(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(mc), 2, 1), 7)
		madd = matrix_add(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}([][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{6, 7, 8}}), func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}([][]int{[]int{1, 2, 7}, []int{2, 4, 5}, []int{6, 7, 10}}))
		assert_str("matrix_add", matrix_str(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(madd)), "|2,4,10|\n|4,8,10|\n|12,14,18|\n")
		msub = matrix_sub(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}([][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{6, 7, 8}}), func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}([][]int{[]int{1, 2, 7}, []int{2, 4, 5}, []int{6, 7, 10}}))
		assert_str("matrix_sub", matrix_str(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(msub)), "|0,0,-4|\n|0,0,0|\n|0,0,-2|\n")
		mzero = square_zero_matrix(5)
		assert_str("square_zero_matrix", matrix_str(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(mzero)), "|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n")
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
