//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-15 21:36:07 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var PI float64

var seed int

func rand() int {
	seed = _modi(((seed * 1103515245) + 12345), 2147483648)
	return seed
}

func random_int(a int, b int) int {
	var r int = _modi(rand(), ((b - a) + 1))
	_ = r
	_ = r
	return (a + r)
}

func sqrtApprox(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = x
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = (float64((guess + (float64(x) / float64(guess)))) / float64(2.0))
		i = (i + 1)
	}
	return guess
}

func arcsin_taylor(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var n int = 1
	_ = n
	for n < 10 {
		var num_ float64 = ((((((2.0 * float64(n)) - 1.0) * ((2.0 * float64(n)) - 1.0)) * x) * x) * term)
		_ = num_
		var den float64 = ((2.0 * float64(n)) * ((2.0 * float64(n)) + 1.0))
		_ = den
		term = (float64(num_) / float64(den))
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

func acos_taylor(x float64) float64 {
	return ((float64(PI) / float64(2.0)) - arcsin_taylor(x))
}

type Vector struct {
	Components []float64 `json:"components"`
}

func vector_len(v Vector) int {
	return len(v.Components)
}

func vector_to_string(v Vector) string {
	var s string = "("
	_ = s
	var i int = 0
	_ = i
	for i < len(v.Components) {
		s = (s + fmt.Sprint(_index(v.Components, i)))
		if i < (len(v.Components) - 1) {
			s = (s + ",")
		}
		i = (i + 1)
	}
	s = (s + ")")
	return s
}

func vector_add(a Vector, b Vector) Vector {
	var size int = vector_len(a)
	_ = size
	if size != vector_len(b) {
		return Vector{
			Components: []float64{},
		}
	}
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < size {
		res = append(res, (_index(a.Components, i) + _index(b.Components, i)))
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

func vector_sub(a Vector, b Vector) Vector {
	var size int = vector_len(a)
	_ = size
	if size != vector_len(b) {
		return Vector{
			Components: []float64{},
		}
	}
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < size {
		res = append(res, (_index(a.Components, i) - _index(b.Components, i)))
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

func vector_eq(a Vector, b Vector) bool {
	if vector_len(a) != vector_len(b) {
		return false
	}
	var i int = 0
	_ = i
	for i < vector_len(a) {
		if _index(a.Components, i) != _index(b.Components, i) {
			return false
		}
		i = (i + 1)
	}
	return true
}

func vector_mul_scalar(v Vector, s float64) Vector {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < vector_len(v) {
		res = append(res, (_index(v.Components, i) * s))
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

func vector_dot(a Vector, b Vector) float64 {
	var size int = vector_len(a)
	_ = size
	if size != vector_len(b) {
		return 0.0
	}
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < size {
		sum = (sum + (_index(a.Components, i) * _index(b.Components, i)))
		i = (i + 1)
	}
	return sum
}

func vector_copy(v Vector) Vector {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < vector_len(v) {
		res = append(res, _index(v.Components, i))
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

func vector_component(v Vector, idx int) float64 {
	return _index(v.Components, idx)
}

func vector_change_component(v Vector, pos int, value float64) Vector {
	var comps []float64 = v.Components
	_ = comps
	_setIndex(comps, pos, value)
	return Vector{
		Components: comps,
	}
}

func vector_euclidean_length(v Vector) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(v.Components) {
		sum = (sum + (_index(v.Components, i) * _index(v.Components, i)))
		i = (i + 1)
	}
	var result float64 = sqrtApprox(sum)
	_ = result
	_ = result
	return result
}

func vector_angle(a Vector, b Vector, deg bool) float64 {
	var num_ float64 = vector_dot(a, b)
	_ = num_
	var den float64 = (vector_euclidean_length(a) * vector_euclidean_length(b))
	_ = den
	var ang float64 = acos_taylor((float64(num_) / float64(den)))
	_ = ang
	if deg {
		ang = (float64((ang * 180.0)) / float64(PI))
	}
	return ang
}

func zero_vector(d int) Vector {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < d {
		res = append(res, 0.0)
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

func unit_basis_vector(d int, pos int) Vector {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < d {
		if i == pos {
			res = append(res, 1.0)
		} else {
			res = append(res, 0.0)
		}
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

func axpy(s float64, x Vector, y Vector) Vector {
	return vector_add(vector_mul_scalar(x, s), y)
}

func random_vector(n int, a int, b int) Vector {
	var res []float64 = []float64{}
	_ = res
	var i int = 0
	_ = i
	for i < n {
		res = append(res, float64(random_int(a, b)))
		i = (i + 1)
	}
	return Vector{
		Components: res,
	}
}

type Matrix struct {
	Data   [][]float64 `json:"data"`
	Width  int         `json:"width"`
	Height int         `json:"height"`
}

func matrix_to_string(m Matrix) string {
	var ans string = ""
	_ = ans
	var i int = 0
	_ = i
	for i < m.Height {
		ans = (ans + "|")
		var j int = 0
		_ = j
		for j < m.Width {
			ans = (ans + fmt.Sprint(_index(_index(m.Data, i), j)))
			if j < (m.Width - 1) {
				ans = (ans + ",")
			}
			j = (j + 1)
		}
		ans = (ans + "|\n")
		i = (i + 1)
	}
	return ans
}

func matrix_add(a Matrix, b Matrix) Matrix {
	if (a.Width != b.Width) || (a.Height != b.Height) {
		return Matrix{
			Data:   [][]float64{},
			Width:  0,
			Height: 0,
		}
	}
	var mat [][]float64 = [][]float64{}
	_ = mat
	var i int = 0
	_ = i
	for i < a.Height {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < a.Width {
			row = append(row, (_index(_index(a.Data, i), j) + _index(_index(b.Data, i), j)))
			j = (j + 1)
		}
		mat = append(mat, row)
		i = (i + 1)
	}
	return Matrix{
		Data:   mat,
		Width:  a.Width,
		Height: a.Height,
	}
}

func matrix_sub(a Matrix, b Matrix) Matrix {
	if (a.Width != b.Width) || (a.Height != b.Height) {
		return Matrix{
			Data:   [][]float64{},
			Width:  0,
			Height: 0,
		}
	}
	var mat [][]float64 = [][]float64{}
	_ = mat
	var i int = 0
	_ = i
	for i < a.Height {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < a.Width {
			row = append(row, (_index(_index(a.Data, i), j) - _index(_index(b.Data, i), j)))
			j = (j + 1)
		}
		mat = append(mat, row)
		i = (i + 1)
	}
	return Matrix{
		Data:   mat,
		Width:  a.Width,
		Height: a.Height,
	}
}

func matrix_mul_vector(m Matrix, v Vector) Vector {
	if len(v.Components) != m.Width {
		return Vector{
			Components: []float64{},
		}
	}
	var res Vector = zero_vector(m.Height)
	_ = res
	var i int = 0
	_ = i
	for i < m.Height {
		var sum float64 = 0.0
		_ = sum
		var j int = 0
		_ = j
		for j < m.Width {
			sum = (sum + (_index(_index(m.Data, i), j) * _index(v.Components, j)))
			j = (j + 1)
		}
		res = vector_change_component(res, i, sum)
		i = (i + 1)
	}
	return res
}

func matrix_mul_scalar(m Matrix, s float64) Matrix {
	var mat [][]float64 = [][]float64{}
	_ = mat
	var i int = 0
	_ = i
	for i < m.Height {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < m.Width {
			row = append(row, (_index(_index(m.Data, i), j) * s))
			j = (j + 1)
		}
		mat = append(mat, row)
		i = (i + 1)
	}
	return Matrix{
		Data:   mat,
		Width:  m.Width,
		Height: m.Height,
	}
}

func matrix_component(m Matrix, x int, y int) float64 {
	return _index(_index(m.Data, x), y)
}

func matrix_change_component(m Matrix, x int, y int, value float64) Matrix {
	var data [][]float64 = m.Data
	_ = data
	_setIndex(_index(data, x), y, value)
	return Matrix{
		Data:   data,
		Width:  m.Width,
		Height: m.Height,
	}
}

func matrix_minor(m Matrix, x int, y int) float64 {
	if m.Height != m.Width {
		return 0.0
	}
	var minor [][]float64 = [][]float64{}
	_ = minor
	var i int = 0
	_ = i
	for i < m.Height {
		if i != x {
			var row []float64 = []float64{}
			_ = row
			var j int = 0
			_ = j
			for j < m.Width {
				if j != y {
					row = append(row, _index(_index(m.Data, i), j))
				}
				j = (j + 1)
			}
			minor = append(minor, row)
		}
		i = (i + 1)
	}
	var sub Matrix = Matrix{
		Data:   minor,
		Width:  (m.Width - 1),
		Height: (m.Height - 1),
	}
	_ = sub
	_ = sub
	return matrix_determinant(sub)
}

func matrix_cofactor(m Matrix, x int, y int) float64 {
	var sign float64 = func() float64 {
		if _modi((x+y), 2) == 0 {
			return 1.0
		} else {
			return (0 - 1.0)
		}
	}()
	_ = sign
	_ = sign
	return (sign * matrix_minor(m, x, y))
}

func matrix_determinant(m Matrix) float64 {
	if m.Height != m.Width {
		return 0.0
	}
	if m.Height == 0 {
		return 0.0
	}
	if m.Height == 1 {
		return _index(_index(m.Data, 0), 0)
	}
	if m.Height == 2 {
		return ((_index(_index(m.Data, 0), 0) * _index(_index(m.Data, 1), 1)) - (_index(_index(m.Data, 0), 1) * _index(_index(m.Data, 1), 0)))
	}
	var sum float64 = 0.0
	_ = sum
	var y int = 0
	_ = y
	for y < m.Width {
		sum = (sum + (_index(_index(m.Data, 0), y) * matrix_cofactor(m, 0, y)))
		y = (y + 1)
	}
	return sum
}

func square_zero_matrix(n int) Matrix {
	var mat [][]float64 = [][]float64{}
	_ = mat
	var i int = 0
	_ = i
	for i < n {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			row = append(row, 0.0)
			j = (j + 1)
		}
		mat = append(mat, row)
		i = (i + 1)
	}
	return Matrix{
		Data:   mat,
		Width:  n,
		Height: n,
	}
}

func random_matrix(w int, h int, a int, b int) Matrix {
	var mat [][]float64 = [][]float64{}
	_ = mat
	var i int = 0
	_ = i
	for i < h {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < w {
			row = append(row, float64(random_int(a, b)))
			j = (j + 1)
		}
		mat = append(mat, row)
		i = (i + 1)
	}
	return Matrix{
		Data:   mat,
		Width:  w,
		Height: h,
	}
}

func mochiMain() {
	var v1 Vector = Vector{
		Components: []float64{1.0, 2.0, 3.0},
	}
	_ = v1
	var v2 Vector = Vector{
		Components: []float64{4.0, 5.0, 6.0},
	}
	_ = v2
	fmt.Println(vector_to_string(vector_add(v1, v2)))
	fmt.Println(fmt.Sprint(vector_dot(v1, v2)))
	fmt.Println(fmt.Sprint(vector_euclidean_length(v1)))
	var m Matrix = Matrix{
		Data:   [][]float64{[]float64{1.0, 2.0}, []float64{3.0, 4.0}},
		Width:  2,
		Height: 2,
	}
	_ = m
	fmt.Println(fmt.Sprint(matrix_determinant(m)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		seed = 123456789
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
