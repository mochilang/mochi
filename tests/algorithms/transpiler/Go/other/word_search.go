//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-12 10:09:23 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type WordSearch struct {
	Words  []string   `json:"words"`
	Width  int        `json:"width"`
	Height int        `json:"height"`
	Board  [][]string `json:"board"`
}

var seed int

func rand() int {
	seed = _mod(((seed * 1103515245) + 12345), 2147483648)
	return seed
}

func rand_range(max int) int {
	return _mod(rand(), max)
}

func shuffle(list_int []int) []int {
	var i int = (len(list_int) - 1)
	_ = i
	for i > 0 {
		var j int = rand_range((i + 1))
		_ = j
		var tmp int = _index(list_int, i)
		_ = tmp
		_setIndex(list_int, i, _index(list_int, j))
		_setIndex(list_int, j, tmp)
		i = (i - 1)
	}
	return list_int
}

func rand_letter() string {
	var letters string = "abcdefghijklmnopqrstuvwxyz"
	_ = letters
	_ = letters
	var i int = rand_range(26)
	_ = i
	_ = i
	return string([]rune(letters)[i:(i + 1)])
}

func make_word_search(words []string, width int, height int) WordSearch {
	var board [][]string = [][]string{}
	_ = board
	var r int = 0
	_ = r
	for r < height {
		var row []string = []string{}
		_ = row
		var c int = 0
		_ = c
		for c < width {
			row = append(row, "")
			c = (c + 1)
		}
		board = append(board, row)
		r = (r + 1)
	}
	return WordSearch{
		Words:  words,
		Width:  width,
		Height: height,
		Board:  board,
	}
}

func insert_dir(ws WordSearch, word string, dr int, dc int, rows []int, cols []int) bool {
	var word_len int = len(word)
	_ = word_len
	var ri int = 0
	_ = ri
	for ri < len(rows) {
		var row int = _index(rows, ri)
		_ = row
		var ci int = 0
		_ = ci
		for ci < len(cols) {
			var col int = _index(cols, ci)
			_ = col
			var end_r int = (row + (dr * (word_len - 1)))
			_ = end_r
			var end_c int = (col + (dc * (word_len - 1)))
			_ = end_c
			if (((end_r < 0) || (end_r >= ws.Height)) || (end_c < 0)) || (end_c >= ws.Width) {
				ci = (ci + 1)
				continue
			}
			var k int = 0
			_ = k
			var ok bool = true
			_ = ok
			for k < word_len {
				var rr int = (row + (dr * k))
				_ = rr
				var cc int = (col + (dc * k))
				_ = cc
				if _index(_index(ws.Board, rr), cc) != "" {
					ok = false
					break
				}
				k = (k + 1)
			}
			if ok {
				k = 0
				for k < word_len {
					var rr2 int = (row + (dr * k))
					_ = rr2
					var cc2 int = (col + (dc * k))
					_ = cc2
					var row_list []string = _index(ws.Board, rr2)
					_ = row_list
					_setIndex(row_list, cc2, string([]rune(word)[k:(k+1)]))
					k = (k + 1)
				}
				return true
			}
			ci = (ci + 1)
		}
		ri = (ri + 1)
	}
	return false
}

func generate_board(ws WordSearch) {
	var dirs_r []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}
	_ = dirs_r
	var dirs_c []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}
	_ = dirs_c
	var i int = 0
	_ = i
	for i < len(ws.Words) {
		var word string = _index(ws.Words, i)
		_ = word
		var rows []int = []int{}
		_ = rows
		var r int = 0
		_ = r
		for r < ws.Height {
			rows = append(rows, r)
			r = (r + 1)
		}
		var cols []int = []int{}
		_ = cols
		var c int = 0
		_ = c
		for c < ws.Width {
			cols = append(cols, c)
			c = (c + 1)
		}
		rows = shuffle(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(rows))
		cols = shuffle(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(cols))
		var d int = rand_range(8)
		_ = d
		insert_dir(ws, word, _index(dirs_r, d), _index(dirs_c, d), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(rows), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(cols))
		i = (i + 1)
	}
}

func visualise(ws WordSearch, add_fake_chars bool) string {
	var result string = ""
	_ = result
	var r int = 0
	_ = r
	for r < ws.Height {
		var c int = 0
		_ = c
		for c < ws.Width {
			var ch string = _index(_index(ws.Board, r), c)
			_ = ch
			if ch == "" {
				if add_fake_chars {
					ch = rand_letter()
				} else {
					ch = "#"
				}
			}
			result = ((result + ch) + " ")
			c = (c + 1)
		}
		result = (result + "\n")
		r = (r + 1)
	}
	return result
}

func mochiMain() {
	var words []string = []string{"cat", "dog", "snake", "fish"}
	_ = words
	var ws WordSearch = make_word_search(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(words), 10, 10)
	_ = ws
	generate_board(ws)
	fmt.Println(visualise(ws, true))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		seed = 123456789
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
