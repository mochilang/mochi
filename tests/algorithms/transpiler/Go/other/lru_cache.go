//go:build ignore

// Generated by Mochi v0.10.69 on 2025-08-22 13:08:13 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

type Node struct {
	Key   int `json:"key"`
	Value int `json:"value"`
	Prev  int `json:"prev"`
	Next  int `json:"next"`
}

type DoubleLinkedList struct {
	Nodes []Node `json:"nodes"`
	Head  int    `json:"head"`
	Tail  int    `json:"tail"`
}

func new_list() DoubleLinkedList {
	var nodes []Node = []Node{}
	_ = nodes
	var head Node = Node{
		Key:   0,
		Value: 0,
		Prev:  (0 - 1),
		Next:  1,
	}
	_ = head
	var tail Node = Node{
		Key:   0,
		Value: 0,
		Prev:  0,
		Next:  (0 - 1),
	}
	_ = tail
	nodes = append(nodes, head)
	nodes = append(nodes, tail)
	return DoubleLinkedList{
		Nodes: nodes,
		Head:  0,
		Tail:  1,
	}
}

func dll_add(lst DoubleLinkedList, idx int) DoubleLinkedList {
	var nodes []Node = lst.Nodes
	_ = nodes
	var tail_idx int = lst.Tail
	_ = tail_idx
	var tail_node Node = _index(nodes, tail_idx)
	_ = tail_node
	var prev_idx int = tail_node.Prev
	_ = prev_idx
	var node Node = _index(nodes, idx)
	_ = node
	node.Prev = prev_idx
	node.Next = tail_idx
	_setIndex(nodes, idx, node)
	var prev_node Node = _index(nodes, prev_idx)
	_ = prev_node
	prev_node.Next = idx
	_setIndex(nodes, prev_idx, prev_node)
	tail_node.Prev = idx
	_setIndex(nodes, tail_idx, tail_node)
	lst.Nodes = nodes
	return lst
}

func dll_remove(lst DoubleLinkedList, idx int) DoubleLinkedList {
	var nodes []Node = lst.Nodes
	_ = nodes
	var node Node = _index(nodes, idx)
	_ = node
	var prev_idx int = node.Prev
	_ = prev_idx
	var next_idx int = node.Next
	_ = next_idx
	if (prev_idx == (0 - 1)) || (next_idx == (0 - 1)) {
		return lst
	}
	var prev_node Node = _index(nodes, prev_idx)
	_ = prev_node
	prev_node.Next = next_idx
	_setIndex(nodes, prev_idx, prev_node)
	var next_node Node = _index(nodes, next_idx)
	_ = next_node
	next_node.Prev = prev_idx
	_setIndex(nodes, next_idx, next_node)
	node.Prev = (0 - 1)
	node.Next = (0 - 1)
	_setIndex(nodes, idx, node)
	lst.Nodes = nodes
	return lst
}

type LRUCache struct {
	List     DoubleLinkedList `json:"list"`
	Capacity int              `json:"capacity"`
	NumKeys  int              `json:"num_keys"`
	Hits     int              `json:"hits"`
	Misses   int              `json:"misses"`
	Cache    map[string]int   `json:"cache"`
}

type GetResult struct {
	Cache LRUCache `json:"cache"`
	Value int      `json:"value"`
	Ok    bool     `json:"ok"`
}

func new_cache(cap int) LRUCache {
	var empty_map map[string]int = map[string]int{}
	_ = empty_map
	_ = empty_map
	return LRUCache{
		List:     new_list(),
		Capacity: cap,
		NumKeys:  0,
		Hits:     0,
		Misses:   0,
		Cache:    empty_map,
	}
}

func lru_get(c LRUCache, key int) GetResult {
	var cache LRUCache = c
	_ = cache
	var key_str string = fmt.Sprint(key)
	_ = key_str
	if func() bool { _, ok := cache.Cache[key_str]; return ok }() {
		var idx int = cache.Cache[key_str]
		_ = idx
		if idx != (0 - 1) {
			cache.Hits = (cache.Hits + 1)
			var node Node = _index(cache.List.Nodes, idx)
			_ = node
			var value int = node.Value
			_ = value
			_ = value
			cache.List = dll_remove(cache.List, idx)
			cache.List = dll_add(cache.List, idx)
			return GetResult{
				Cache: cache,
				Value: value,
				Ok:    true,
			}
		}
	}
	cache.Misses = (cache.Misses + 1)
	return GetResult{
		Cache: cache,
		Value: 0,
		Ok:    false,
	}
}

func lru_put(c LRUCache, key int, value int) LRUCache {
	var cache LRUCache = c
	_ = cache
	var key_str string = fmt.Sprint(key)
	_ = key_str
	if !func() bool { _, ok := cache.Cache[key_str]; return ok }() {
		if cache.NumKeys >= cache.Capacity {
			var head_node Node = _index(cache.List.Nodes, cache.List.Head)
			_ = head_node
			var first_idx int = head_node.Next
			_ = first_idx
			var first_node Node = _index(cache.List.Nodes, first_idx)
			_ = first_node
			var old_key int = first_node.Key
			_ = old_key
			cache.List = dll_remove(cache.List, first_idx)
			var mdel map[string]int = cache.Cache
			_ = mdel
			mdel[fmt.Sprint(old_key)] = (0 - 1)
			cache.Cache = mdel
			cache.NumKeys = (cache.NumKeys - 1)
		}
		var nodes []Node = cache.List.Nodes
		_ = nodes
		var new_node Node = Node{
			Key:   key,
			Value: value,
			Prev:  (0 - 1),
			Next:  (0 - 1),
		}
		_ = new_node
		nodes = append(nodes, new_node)
		var idx int = (len(nodes) - 1)
		_ = idx
		cache.List.Nodes = nodes
		cache.List = dll_add(cache.List, idx)
		var m map[string]int = cache.Cache
		_ = m
		m[key_str] = idx
		cache.Cache = m
		cache.NumKeys = (cache.NumKeys + 1)
	} else {
		var m map[string]int = cache.Cache
		_ = m
		var idx int = m[key_str]
		_ = idx
		var nodes []Node = cache.List.Nodes
		_ = nodes
		var node Node = _index(nodes, idx)
		_ = node
		node.Value = value
		_setIndex(nodes, idx, node)
		cache.List.Nodes = nodes
		cache.List = dll_remove(cache.List, idx)
		cache.List = dll_add(cache.List, idx)
		cache.Cache = m
	}
	return cache
}

func cache_info(cache LRUCache) string {
	return (((((((("CacheInfo(hits=" + fmt.Sprint(cache.Hits)) + ", misses=") + fmt.Sprint(cache.Misses)) + ", capacity=") + fmt.Sprint(cache.Capacity)) + ", current size=") + fmt.Sprint(cache.NumKeys)) + ")")
}

func print_result(res GetResult) {
	if res.Ok {
		fmt.Println(fmt.Sprint(res.Value))
	} else {
		fmt.Println("None")
	}
}

func mochiMain() {
	var cache LRUCache = new_cache(2)
	_ = cache
	cache = lru_put(cache, 1, 1)
	cache = lru_put(cache, 2, 2)
	var r1 GetResult = lru_get(cache, 1)
	_ = r1
	cache = r1.Cache
	print_result(r1)
	cache = lru_put(cache, 3, 3)
	var r2 GetResult = lru_get(cache, 2)
	_ = r2
	cache = r2.Cache
	print_result(r2)
	cache = lru_put(cache, 4, 4)
	var r3 GetResult = lru_get(cache, 1)
	_ = r3
	cache = r3.Cache
	print_result(r3)
	var r4 GetResult = lru_get(cache, 3)
	_ = r4
	cache = r4.Cache
	print_result(r4)
	var r5 GetResult = lru_get(cache, 4)
	_ = r5
	cache = r5.Cache
	print_result(r5)
	fmt.Println(cache_info(cache))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
