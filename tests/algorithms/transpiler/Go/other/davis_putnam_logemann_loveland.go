//go:build ignore

// Generated by Mochi v0.10.64 on 2025-08-12 09:24:29 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Clause struct {
	Literals map[string]int `json:"literals"`
	Names    []string       `json:"names"`
}

func new_clause(lits []string) Clause {
	var m map[string]int = map[string]int{}
	_ = m
	var names []string = []string{}
	_ = names
	var i int = 0
	_ = i
	for i < len(lits) {
		var lit string = _index(lits, i)
		_ = lit
		m[lit] = (0 - 1)
		names = append(names, lit)
		i = (i + 1)
	}
	return Clause{
		Literals: m,
		Names:    names,
	}
}

func assign_clause(c Clause, model map[string]int) Clause {
	var lits map[string]int = c.Literals
	_ = lits
	var i int = 0
	_ = i
	for i < len(c.Names) {
		var lit string = _index(c.Names, i)
		_ = lit
		var symbol string = _substr(lit, 0, 2)
		_ = symbol
		if func() bool { _, ok := model[symbol]; return ok }() {
			var value int = model[symbol]
			_ = value
			if (_substr(lit, (len(lit)-1), len(lit)) == "'") && (value != (0 - 1)) {
				value = (1 - value)
			}
			lits[lit] = value
		}
		i = (i + 1)
	}
	c.Literals = lits
	return c
}

type EvalResult struct {
	Value  int    `json:"value"`
	Clause Clause `json:"clause"`
}

func evaluate_clause(c Clause, model map[string]int) EvalResult {
	var i int = 0
	_ = i
	for i < len(c.Names) {
		var lit string = _index(c.Names, i)
		_ = lit
		_ = lit
		var sym string = func() string {
			if _substr(lit, (len(lit)-1), len(lit)) == "'" {
				return _substr(lit, 0, 2)
			} else {
				return (lit + "'")
			}
		}()
		_ = sym
		_ = sym
		if func() bool { _, ok := c.Literals[sym]; return ok }() {
			return EvalResult{
				Value:  1,
				Clause: c,
			}
		}
		i = (i + 1)
	}
	c = assign_clause(c, model)
	i = 0
	for i < len(c.Names) {
		var lit string = _index(c.Names, i)
		_ = lit
		var value int = c.Literals[lit]
		_ = value
		if value == 1 {
			return EvalResult{
				Value:  1,
				Clause: c,
			}
		}
		if value == (0 - 1) {
			return EvalResult{
				Value:  (0 - 1),
				Clause: c,
			}
		}
		i = (i + 1)
	}
	var any_true int = 0
	_ = any_true
	i = 0
	for i < len(c.Names) {
		var lit string = _index(c.Names, i)
		_ = lit
		if int(c.Literals[lit]) == 1 {
			any_true = 1
		}
		i = (i + 1)
	}
	return EvalResult{
		Value:  any_true,
		Clause: c,
	}
}

type Formula struct {
	Clauses []Clause `json:"clauses"`
}

func new_formula(cs []Clause) Formula {
	return Formula{
		Clauses: cs,
	}
}

type DPLLResult struct {
	Sat   bool           `json:"sat"`
	Model map[string]int `json:"model"`
}

func remove_symbol(symbols []string, s string) []string {
	var res []string = []string{}
	_ = res
	var i int = 0
	_ = i
	for i < len(symbols) {
		if _index(symbols, i) != s {
			res = append(res, _index(symbols, i))
		}
		i = (i + 1)
	}
	return res
}

func dpll_algorithm(clauses []Clause, symbols []string, model map[string]int) DPLLResult {
	var all_true bool = true
	_ = all_true
	var i int = 0
	_ = i
	for i < len(clauses) {
		var ev EvalResult = evaluate_clause(_index(clauses, i), model)
		_ = ev
		_setIndex(clauses, i, ev.Clause)
		if ev.Value == 0 {
			return DPLLResult{
				Sat:   false,
				Model: map[string]int{},
			}
		} else {
			if ev.Value == (0 - 1) {
				all_true = false
			}
		}
		i = (i + 1)
	}
	if all_true {
		return DPLLResult{
			Sat:   true,
			Model: model,
		}
	}
	var p string = _index(symbols, 0)
	_ = p
	var rest []string = remove_symbol(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(symbols), p)
	_ = rest
	var tmp1 map[string]int = model
	_ = tmp1
	var tmp2 map[string]int = model
	_ = tmp2
	tmp1[p] = 1
	tmp2[p] = 0
	var res1 DPLLResult = dpll_algorithm(func(v any) []Clause {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Clause); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Clause{}
			}
			out := make([]Clause, len(arr))
			for i, x := range arr {
				out[i] = x.(Clause)
			}
			return out
		}
		return v.([]Clause)
	}(clauses), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(rest), tmp1)
	_ = res1
	if res1.Sat {
		return res1
	}
	return dpll_algorithm(func(v any) []Clause {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Clause); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Clause{}
			}
			out := make([]Clause, len(arr))
			for i, x := range arr {
				out[i] = x.(Clause)
			}
			return out
		}
		return v.([]Clause)
	}(clauses), func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(rest), tmp2)
}

func str_clause(c Clause) string {
	var line string = "{"
	_ = line
	var first bool = true
	_ = first
	var i int = 0
	_ = i
	for i < len(c.Names) {
		var lit string = _index(c.Names, i)
		_ = lit
		if first {
			first = false
		} else {
			line = (line + " , ")
		}
		line = (line + lit)
		i = (i + 1)
	}
	line = (line + "}")
	return line
}

func str_formula(f Formula) string {
	var line string = "{"
	_ = line
	var i int = 0
	_ = i
	for i < len(f.Clauses) {
		line = (line + str_clause(_index(f.Clauses, i)))
		if i < (len(f.Clauses) - 1) {
			line = (line + " , ")
		}
		i = (i + 1)
	}
	line = (line + "}")
	return line
}

var clause1 Clause

var clause2 Clause

var formula Formula

var formula_str string

var clauses []Clause

var symbols []string

var model map[string]int

var result DPLLResult

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		clause1 = new_clause(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}([]string{"A4", "A3", "A5'", "A1", "A3'"}))
		clause2 = new_clause(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}([]string{"A4"}))
		formula = new_formula(func(v any) []Clause {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Clause); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Clause{}
				}
				out := make([]Clause, len(arr))
				for i, x := range arr {
					out[i] = x.(Clause)
				}
				return out
			}
			return v.([]Clause)
		}([]Clause{clause1, clause2}))
		formula_str = str_formula(formula)
		clauses = []Clause{clause1, clause2}
		symbols = []string{"A4", "A3", "A5", "A1"}
		model = map[string]int{}
		result = dpll_algorithm(func(v any) []Clause {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Clause); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Clause{}
				}
				out := make([]Clause, len(arr))
				for i, x := range arr {
					out[i] = x.(Clause)
				}
				return out
			}
			return v.([]Clause)
		}(clauses), func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = fmt.Sprint(x)
				}
				return out
			}
			return v.([]string)
		}(symbols), model)
		if result.Sat {
			fmt.Println((("The formula " + formula_str) + " is satisfiable."))
		} else {
			fmt.Println((("The formula " + formula_str) + " is not satisfiable."))
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
