//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 17:57:31 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

type Result struct {
	Start int     `json:"start"`
	End   int     `json:"end"`
	Sum   float64 `json:"sum"`
}

func max_cross_sum(arr []float64, low int, mid int, high int) Result {
	var left_sum float64 = (0 - 1000000000000000000.0)
	_ = left_sum
	var max_left int = (0 - 1)
	_ = max_left
	var sum float64 = 0.0
	_ = sum
	var i int = mid
	_ = i
	for i >= low {
		sum = (sum + _index(arr, i))
		if sum > left_sum {
			left_sum = sum
			max_left = i
		}
		i = (i - 1)
	}
	var right_sum float64 = (0 - 1000000000000000000.0)
	_ = right_sum
	var max_right int = (0 - 1)
	_ = max_right
	sum = 0.0
	i = (mid + 1)
	for i <= high {
		sum = (sum + _index(arr, i))
		if sum > right_sum {
			right_sum = sum
			max_right = i
		}
		i = (i + 1)
	}
	return Result{
		Start: max_left,
		End:   max_right,
		Sum:   (left_sum + right_sum),
	}
}

func max_subarray(arr []float64, low int, high int) Result {
	if len(arr) == 0 {
		return Result{
			Start: (0 - 1),
			End:   (0 - 1),
			Sum:   0.0,
		}
	}
	if low == high {
		return Result{
			Start: low,
			End:   high,
			Sum:   _index(arr, low),
		}
	}
	mid := ((low + high) / 2)
	_ = mid
	left := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(arr), low, mid)
	_ = left
	right := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(arr), int((mid + 1)), high)
	_ = right
	cross := max_cross_sum(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(arr), low, mid, high)
	_ = cross
	if (_toFloat(Result(left).Sum) >= _toFloat(Result(right).Sum)) && (_toFloat(Result(left).Sum) >= _toFloat(Result(cross).Sum)) {
		return Result(left)
	}
	if (_toFloat(Result(right).Sum) >= _toFloat(Result(left).Sum)) && (_toFloat(Result(right).Sum) >= _toFloat(Result(cross).Sum)) {
		return Result(right)
	}
	return Result(cross)
}

func show(res Result) {
	fmt.Println((((((("[" + fmt.Sprint(res.Start)) + ", ") + fmt.Sprint(res.End)) + ", ") + fmt.Sprint(res.Sum)) + "]"))
}

func mochiMain() {
	var nums1 []float64 = []float64{(0 - 2.0), 1.0, (0 - 3.0), 4.0, (0 - 1.0), 2.0, 1.0, (0 - 5.0), 4.0}
	_ = nums1
	res1 := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(nums1), 0, (len(nums1) - 1))
	_ = res1
	show(Result(res1))
	var nums2 []float64 = []float64{2.0, 8.0, 9.0}
	_ = nums2
	res2 := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(nums2), 0, (len(nums2) - 1))
	_ = res2
	show(Result(res2))
	var nums3 []float64 = []float64{0.0, 0.0}
	_ = nums3
	res3 := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(nums3), 0, (len(nums3) - 1))
	_ = res3
	show(Result(res3))
	var nums4 []float64 = []float64{(0 - 1.0), 0.0, 1.0}
	_ = nums4
	res4 := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(nums4), 0, (len(nums4) - 1))
	_ = res4
	show(Result(res4))
	var nums5 []float64 = []float64{(0 - 2.0), (0 - 3.0), (0 - 1.0), (0 - 4.0), (0 - 6.0)}
	_ = nums5
	res5 := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(nums5), 0, (len(nums5) - 1))
	_ = res5
	show(Result(res5))
	var nums6 []float64 = []float64{}
	_ = nums6
	res6 := max_subarray(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(nums6), 0, 0)
	_ = res6
	show(Result(res6))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
