//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:38:42 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _concat[T any](a, b []T) []T {
	return append(append([]T{}, a...), b...)
}

type InvResult struct {
	Arr []int `json:"arr"`
	Inv int   `json:"inv"`
}

func slice_list(arr []int, start int, end int) []int {
	var res []int = []int{}
	_ = res
	var k int = start
	_ = k
	for k < end {
		res = append(res, _index(arr, k))
		k = (k + 1)
	}
	return res
}

func count_inversions_bf(arr []int) int {
	var n int = len(arr)
	_ = n
	var inv int = 0
	_ = inv
	var i int = 0
	_ = i
	for i < (n - 1) {
		var j int = (i + 1)
		_ = j
		for j < n {
			if int(_index(arr, i)) > int(_index(arr, j)) {
				inv = (inv + 1)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return inv
}

func count_cross_inversions(p []int, q []int) InvResult {
	var r []int = []int{}
	_ = r
	var i int = 0
	_ = i
	var j int = 0
	_ = j
	var inv int = 0
	_ = inv
	for (i < len(p)) && (j < len(q)) {
		if int(_index(p, i)) > int(_index(q, j)) {
			inv = (inv + (len(p) - i))
			r = append(r, _index(q, j))
			j = (j + 1)
		} else {
			r = append(r, _index(p, i))
			i = (i + 1)
		}
	}
	if i < len(p) {
		r = _concat(r, slice_list(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(p), i, len(p)))
	} else {
		r = _concat(r, slice_list(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(q), j, len(q)))
	}
	return InvResult{
		Arr: r,
		Inv: inv,
	}
}

func count_inversions_recursive(arr []int) InvResult {
	if len(arr) <= 1 {
		return InvResult{
			Arr: arr,
			Inv: 0,
		}
	}
	var mid int = (len(arr) / 2)
	_ = mid
	var p []int = slice_list(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(arr), 0, mid)
	_ = p
	var q []int = slice_list(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(arr), mid, len(arr))
	_ = q
	var res_p InvResult = count_inversions_recursive(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(p))
	_ = res_p
	var res_q InvResult = count_inversions_recursive(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(q))
	_ = res_q
	var res_cross InvResult = count_cross_inversions(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(res_p.Arr), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(res_q.Arr))
	_ = res_cross
	var total int = ((res_p.Inv + res_q.Inv) + res_cross.Inv)
	_ = total
	_ = total
	return InvResult{
		Arr: res_cross.Arr,
		Inv: total,
	}
}

var arr_1 []int

var nbf int

var nrec int

var nbf2 int

var nrec2 int

var nbf3 int

var nrec3 int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		arr_1 = []int{10, 2, 1, 5, 5, 2, 11}
		nbf = count_inversions_bf(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(arr_1))
		nrec = count_inversions_recursive(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(arr_1)).Inv
		fmt.Println("number of inversions = ", nbf)
		arr_1 = []int{1, 2, 2, 5, 5, 10, 11}
		nbf2 = count_inversions_bf(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(arr_1))
		nrec2 = count_inversions_recursive(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(arr_1)).Inv
		fmt.Println("number of inversions = ", nbf2)
		arr_1 = []int{}
		nbf3 = count_inversions_bf(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(arr_1))
		nrec3 = count_inversions_recursive(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(arr_1)).Inv
		fmt.Println("number of inversions = ", nbf3)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
