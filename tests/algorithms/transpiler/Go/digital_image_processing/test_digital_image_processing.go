//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:38:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func clamp_byte(x int) int {
	if x < 0 {
		return 0
	}
	if x > 255 {
		return 255
	}
	return x
}

func convert_to_negative(img [][]int) [][]int {
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, (255 - int(_index(_index(img, y), x))))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func change_contrast(img [][]int, factor int) [][]int {
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var p int = _index(_index(img, y), x)
			_ = p
			var v int = ((((p - 128) * factor) / 100) + 128)
			_ = v
			v = clamp_byte(v)
			row = append(row, v)
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func gen_gaussian_kernel(n int, sigma float64) [][]float64 {
	if n == 3 {
		return [][]float64{[]float64{(float64(1.0) / float64(16.0)), (float64(2.0) / float64(16.0)), (float64(1.0) / float64(16.0))}, []float64{(float64(2.0) / float64(16.0)), (float64(4.0) / float64(16.0)), (float64(2.0) / float64(16.0))}, []float64{(float64(1.0) / float64(16.0)), (float64(2.0) / float64(16.0)), (float64(1.0) / float64(16.0))}}
	}
	var k [][]float64 = [][]float64{}
	_ = k
	var i int = 0
	_ = i
	for i < n {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			row = append(row, 0.0)
			j = (j + 1)
		}
		k = append(k, row)
		i = (i + 1)
	}
	return k
}

func img_convolve(img [][]int, kernel [][]float64) [][]int {
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var acc float64 = 0.0
			_ = acc
			var ky int = 0
			_ = ky
			for ky < len(kernel) {
				var kx int = 0
				_ = kx
				for kx < len(_index(kernel, 0)) {
					var iy int = ((y + ky) - 1)
					_ = iy
					var ix int = ((x + kx) - 1)
					_ = ix
					var pixel int = 0
					_ = pixel
					if (((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w) {
						pixel = _index(_index(img, iy), ix)
					}
					acc = (acc + (_index(_index(kernel, ky), kx) * (1.0 * float64(pixel))))
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			row = append(row, int(acc))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func sort_ints(xs []int) []int {
	var arr []int = xs
	_ = arr
	var i int = 0
	_ = i
	for i < len(arr) {
		var j int = 0
		_ = j
		for j < ((len(arr) - 1) - i) {
			if int(_index(arr, j)) > int(_index(arr, (j+1))) {
				var tmp int = _index(arr, j)
				_ = tmp
				_setIndex(arr, j, _index(arr, (j+1)))
				_setIndex(arr, (j + 1), tmp)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return arr
}

func median_filter(img [][]int, k int) [][]int {
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var offset int = (k / 2)
	_ = offset
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var vals []int = []int{}
			_ = vals
			var ky int = 0
			_ = ky
			for ky < k {
				var kx int = 0
				_ = kx
				for kx < k {
					var iy int = ((y + ky) - offset)
					_ = iy
					var ix int = ((x + kx) - offset)
					_ = ix
					var pixel int = 0
					_ = pixel
					if (((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w) {
						pixel = _index(_index(img, iy), ix)
					}
					vals = append(vals, pixel)
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			var sorted []int = sort_ints(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(vals))
			_ = sorted
			row = append(row, _index(sorted, (len(sorted)/2)))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func iabs(x int) int {
	if x < 0 {
		return (0 - x)
	}
	return x
}

func sobel_filter(img [][]int) [][]int {
	var gx [][]int = [][]int{[]int{1, 0, func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}, []int{2, 0, func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 2))}, []int{1, 0, func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}}
	_ = gx
	var gy [][]int = [][]int{[]int{1, 2, 1}, []int{0, 0, 0}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 2)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}}
	_ = gy
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var sx int = 0
			_ = sx
			var sy int = 0
			_ = sy
			var ky int = 0
			_ = ky
			for ky < 3 {
				var kx int = 0
				_ = kx
				for kx < 3 {
					var iy int = ((y + ky) - 1)
					_ = iy
					var ix int = ((x + kx) - 1)
					_ = ix
					var pixel int = 0
					_ = pixel
					if (((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w) {
						pixel = _index(_index(img, iy), ix)
					}
					sx = (sx + (int(_index(_index(gx, ky), kx)) * pixel))
					sy = (sy + (int(_index(_index(gy, ky), kx)) * pixel))
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			row = append(row, (iabs(sx) + iabs(sy)))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func get_neighbors_pixel(img [][]int, x int, y int) []int {
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var neighbors []int = []int{}
	_ = neighbors
	var dy int = (0 - 1)
	_ = dy
	for dy <= 1 {
		var dx int = (0 - 1)
		_ = dx
		for dx <= 1 {
			if !((dx == 0) && (dy == 0)) {
				var ny int = (y + dy)
				_ = ny
				var nx int = (x + dx)
				_ = nx
				var val int = 0
				_ = val
				if (((ny >= 0) && (ny < h)) && (nx >= 0)) && (nx < w) {
					val = _index(_index(img, ny), nx)
				}
				neighbors = append(neighbors, val)
			}
			dx = (dx + 1)
		}
		dy = (dy + 1)
	}
	return neighbors
}

func pow2(e int) int {
	var r int = 1
	_ = r
	var i int = 0
	_ = i
	for i < e {
		r = (r * 2)
		i = (i + 1)
	}
	return r
}

func local_binary_value(img [][]int, x int, y int) int {
	var center int = _index(_index(img, y), x)
	_ = center
	var neighbors []int = get_neighbors_pixel(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(img), x, y)
	_ = neighbors
	var v int = 0
	_ = v
	var i int = 0
	_ = i
	for i < len(neighbors) {
		if int(_index(neighbors, i)) >= center {
			v = (v + pow2(i))
		}
		i = (i + 1)
	}
	return v
}

func local_binary_pattern(img [][]int) [][]int {
	var h int = len(img)
	_ = h
	var w int = len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, local_binary_value(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(img), x, y))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

var img [][]int

var negative [][]int

var contrast [][]int

var kernel [][]float64

var laplace [][]float64

var convolved [][]int

var medianed [][]int

var sobel [][]int

var lbp_img [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		img = [][]int{[]int{52, 55, 61}, []int{62, 59, 55}, []int{63, 65, 66}}
		negative = convert_to_negative(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img))
		contrast = change_contrast(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), 110)
		kernel = gen_gaussian_kernel(3, 1.0)
		laplace = [][]float64{[]float64{0.25, 0.5, 0.25}, []float64{0.5, (0 - 3.0), 0.5}, []float64{0.25, 0.5, 0.25}}
		convolved = img_convolve(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(laplace))
		medianed = median_filter(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), 3)
		sobel = sobel_filter(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img))
		lbp_img = local_binary_pattern(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img))
		fmt.Println(func() string {
			b, _ := json.Marshal(negative)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(contrast)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(kernel)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(convolved)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(medianed)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(sobel)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(lbp_img)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
