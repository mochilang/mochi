//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 17:57:21 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

func clamp_byte(x int) int {
	if x < 0 {
		return 0
	}
	if x > 255 {
		return 255
	}
	return x
}

func convert_to_negative(img [][]int) [][]int {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, (255 - int(_index(_index(img, y), x))))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func change_contrast(img [][]int, factor int) [][]int {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var p int = _index(_index(img, y), x)
			_ = p
			var v int = ((((p - 128) * factor) / 100) + 128)
			_ = v
			v = clamp_byte(v)
			row = append(row, v)
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func gen_gaussian_kernel(n int, sigma float64) [][]float64 {
	if n == 3 {
		return [][]float64{[]float64{(float64(1.0) / float64(16.0)), (float64(2.0) / float64(16.0)), (float64(1.0) / float64(16.0))}, []float64{(float64(2.0) / float64(16.0)), (float64(4.0) / float64(16.0)), (float64(2.0) / float64(16.0))}, []float64{(float64(1.0) / float64(16.0)), (float64(2.0) / float64(16.0)), (float64(1.0) / float64(16.0))}}
	}
	var k [][]float64 = [][]float64{}
	_ = k
	var i int = 0
	_ = i
	for i < n {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < n {
			row = append(row, 0.0)
			j = (j + 1)
		}
		k = append(k, row)
		i = (i + 1)
	}
	return k
}

func img_convolve(img [][]int, kernel [][]float64) [][]int {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var acc float64 = 0.0
			_ = acc
			var ky int = 0
			_ = ky
			for ky < len(kernel) {
				var kx int = 0
				_ = kx
				for kx < len(_index(kernel, 0)) {
					var iy int = ((y + ky) - 1)
					_ = iy
					var ix int = ((x + kx) - 1)
					_ = ix
					var pixel int = 0
					_ = pixel
					if (((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w) {
						pixel = _index(_index(img, iy), ix)
					}
					acc = (acc + (_index(_index(kernel, ky), kx) * (1.0 * float64(pixel))))
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			row = append(row, int(acc))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func sort_ints(xs []int) []int {
	var arr []int = xs
	_ = arr
	var i int = 0
	_ = i
	for i < len(arr) {
		var j int = 0
		_ = j
		for j < ((len(arr) - 1) - i) {
			if int(_index(arr, j)) > int(_index(arr, (j+1))) {
				var tmp int = _index(arr, j)
				_ = tmp
				_setIndex(arr, j, _index(arr, (j+1)))
				_setIndex(arr, (j + 1), tmp)
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return arr
}

func median_filter(img [][]int, k int) [][]int {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var offset int = (k / 2)
	_ = offset
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var vals []int = []int{}
			_ = vals
			var ky int = 0
			_ = ky
			for ky < k {
				var kx int = 0
				_ = kx
				for kx < k {
					var iy int = ((y + ky) - offset)
					_ = iy
					var ix int = ((x + kx) - offset)
					_ = ix
					var pixel int = 0
					_ = pixel
					if (((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w) {
						pixel = _index(_index(img, iy), ix)
					}
					vals = append(vals, pixel)
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			sorted := sort_ints(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(vals))
			_ = sorted
			row = append(row, int(_index(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(sorted), (_len(sorted)/2))))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func iabs(x int) int {
	if x < 0 {
		return (0 - x)
	}
	return x
}

func sobel_filter(img [][]int) [][]int {
	var gx [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(2), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 2))}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}}
	_ = gx
	var gy [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(2), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 2)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}}
	_ = gy
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			var sx int = 0
			_ = sx
			var sy int = 0
			_ = sy
			var ky int = 0
			_ = ky
			for ky < 3 {
				var kx int = 0
				_ = kx
				for kx < 3 {
					var iy int = ((y + ky) - 1)
					_ = iy
					var ix int = ((x + kx) - 1)
					_ = ix
					var pixel int = 0
					_ = pixel
					if (((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w) {
						pixel = _index(_index(img, iy), ix)
					}
					sx = (sx + (int(_index(_index(gx, ky), kx)) * pixel))
					sy = (sy + (int(_index(_index(gy, ky), kx)) * pixel))
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			row = append(row, (iabs(sx) + iabs(sy)))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

func get_neighbors_pixel(img [][]int, x int, y int) []int {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var neighbors []int = []int{}
	_ = neighbors
	var dy int = (0 - 1)
	_ = dy
	for dy <= 1 {
		var dx int = (0 - 1)
		_ = dx
		for dx <= 1 {
			if !((dx == 0) && (dy == 0)) {
				var ny int = (y + dy)
				_ = ny
				var nx int = (x + dx)
				_ = nx
				var val int = 0
				_ = val
				if (((ny >= 0) && (ny < h)) && (nx >= 0)) && (nx < w) {
					val = _index(_index(img, ny), nx)
				}
				neighbors = append(neighbors, val)
			}
			dx = (dx + 1)
		}
		dy = (dy + 1)
	}
	return neighbors
}

func pow2(e int) int {
	var r int = 1
	_ = r
	var i int = 0
	_ = i
	for i < e {
		r = (r * 2)
		i = (i + 1)
	}
	return r
}

func local_binary_value(img [][]int, x int, y int) int {
	var center int = _index(_index(img, y), x)
	_ = center
	neighbors := get_neighbors_pixel(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(img), x, y)
	_ = neighbors
	var v int = 0
	_ = v
	var i int = 0
	_ = i
	for i < _len(neighbors) {
		if int(_index(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(neighbors), i)) >= center {
			v = (v + pow2(i))
		}
		i = (i + 1)
	}
	return v
}

func local_binary_pattern(img [][]int) [][]int {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var out [][]int = [][]int{}
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, local_binary_value(func(v any) [][]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([][]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return [][]int{}
					}
					out := make([][]int, len(arr))
					for i, x := range arr {
						out[i] = func(v any) []int {
							if v == nil {
								return nil
							}
							if vv, ok := v.([]int); ok {
								return vv
							}
							if arr, ok := v.([]any); ok {
								if len(arr) == 0 {
									return []int{}
								}
								out := make([]int, len(arr))
								for i, x := range arr {
									out[i] = x.(int)
								}
								return out
							}
							return v.([]int)
						}(x)
					}
					return out
				}
				return v.([][]int)
			}(img), x, y))
			x = (x + 1)
		}
		out = append(out, row)
		y = (y + 1)
	}
	return out
}

var img [][]int

var negative [][]int

var contrast [][]int

var kernel [][]float64

var laplace [][]float64

var convolved [][]int

var medianed [][]int

var sobel [][]int

var lbp_img [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		img = [][]int{[]int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(52), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(55), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(61)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(62), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(59), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(55)}, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(63), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(65), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(66)}}
		negative = convert_to_negative(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img))
		contrast = change_contrast(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), 110)
		kernel = gen_gaussian_kernel(3, 1.0)
		laplace = [][]float64{[]float64{0.25, 0.5, 0.25}, []float64{0.5, (0 - 3.0), 0.5}, []float64{0.25, 0.5, 0.25}}
		convolved = img_convolve(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), func(v any) [][]float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]float64{}
				}
				out := make([][]float64, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []float64 {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]float64); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []float64{}
							}
							out := make([]float64, len(arr))
							for i, x := range arr {
								out[i] = x.(float64)
							}
							return out
						}
						return v.([]float64)
					}(x)
				}
				return out
			}
			return v.([][]float64)
		}(laplace))
		medianed = median_filter(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img), 3)
		sobel = sobel_filter(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img))
		lbp_img = local_binary_pattern(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(img))
		fmt.Println(func() string {
			b, _ := json.Marshal(negative)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(contrast)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(kernel)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(convolved)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(medianed)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(sobel)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		fmt.Println(func() string {
			b, _ := json.Marshal(lbp_img)
			s := string(b)
			s = strings.ReplaceAll(s, ":", ": ")
			s = strings.ReplaceAll(s, ",", ", ")
			s = strings.ReplaceAll(s, "}, {", "},{")
			return s
		}())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
