//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 17:17:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

var PI float64

func absf(x float64) float64 {
	if x < 0.0 {
		return (0 - x)
	}
	return x
}

func sqrtApprox(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = (x / 2.0)
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = ((guess + (x / guess)) / 2.0)
		i = (i + 1)
	}
	return guess
}

func atanApprox(x float64) float64 {
	if x > 1.0 {
		return ((PI / 2.0) - (x / ((x * x) + 0.28)))
	}
	if x < (0 - 1.0) {
		return (((0 - PI) / 2.0) - (x / ((x * x) + 0.28)))
	}
	return (x / (1.0 + ((0.28 * x) * x)))
}

func atan2Approx(y float64, x float64) float64 {
	if x == 0.0 {
		if y > 0.0 {
			return (PI / 2.0)
		}
		if y < 0.0 {
			return ((0 - PI) / 2.0)
		}
		return 0.0
	}
	a := atanApprox((y / x))
	_ = a
	_ = a
	if x > 0.0 {
		return a
	}
	if y >= 0.0 {
		return float64((_toFloat(a) + PI))
	}
	return float64((_toFloat(a) - PI))
}

func zeros(h int, w int) [][]float64 {
	var m [][]float64 = [][]float64{}
	_ = m
	var y int = 0
	_ = y
	for y < h {
		var row []float64 = []float64{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, 0.0)
			x = (x + 1)
		}
		m = append(m, row)
		y = (y + 1)
	}
	return m
}

func pad_edge(img [][]float64, pad int) [][]float64 {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	var out [][]float64 = zeros(int((h + (pad * 2))), int((w + (pad * 2))))
	_ = out
	var y int = 0
	_ = y
	for y < (h + (pad * 2)) {
		var x int = 0
		_ = x
		for x < (w + (pad * 2)) {
			var sy int = (y - pad)
			_ = sy
			if sy < 0 {
				sy = 0
			}
			if sy >= h {
				sy = (h - 1)
			}
			var sx int = (x - pad)
			_ = sx
			if sx < 0 {
				sx = 0
			}
			if sx >= w {
				sx = (w - 1)
			}
			_setIndex(_index(out, y), x, _index(_index(img, sy), sx))
			x = (x + 1)
		}
		y = (y + 1)
	}
	return out
}

func img_convolve(img [][]float64, kernel [][]int) [][]float64 {
	h := len(img)
	_ = h
	w := len(_index(img, 0))
	_ = w
	k := len(kernel)
	_ = k
	pad := (k / 2)
	_ = pad
	padded := pad_edge(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(img), pad)
	_ = padded
	var out [][]float64 = zeros(h, w)
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var x int = 0
		_ = x
		for x < w {
			var sum float64 = 0.0
			_ = sum
			var i int = 0
			_ = i
			for i < k {
				var j int = 0
				_ = j
				for j < k {
					sum = (sum + (_toFloat(_index(func(v any) []any {
						if v == nil {
							return nil
						}
						if arr, ok := v.([]any); ok {
							return arr
						}
						rv := reflect.ValueOf(v)
						if rv.Kind() != reflect.Slice {
							return v.([]any)
						}
						n := rv.Len()
						out := make([]any, n)
						for i := 0; i < n; i++ {
							out[i] = rv.Index(i).Interface()
						}
						return out
					}(_index(func(v any) []any {
						if v == nil {
							return nil
						}
						if arr, ok := v.([]any); ok {
							return arr
						}
						rv := reflect.ValueOf(v)
						if rv.Kind() != reflect.Slice {
							return v.([]any)
						}
						n := rv.Len()
						out := make([]any, n)
						for i := 0; i < n; i++ {
							out[i] = rv.Index(i).Interface()
						}
						return out
					}(padded), (y+i))), (x+j))) * float64(_index(_index(kernel, i), j))))
					j = (j + 1)
				}
				i = (i + 1)
			}
			_setIndex(_index(out, y), x, sum)
			x = (x + 1)
		}
		y = (y + 1)
	}
	return out
}

func abs_matrix(mat [][]float64) [][]float64 {
	h := len(mat)
	_ = h
	w := len(_index(mat, 0))
	_ = w
	var out [][]float64 = zeros(h, w)
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var x int = 0
		_ = x
		for x < w {
			var v float64 = _index(_index(mat, y), x)
			_ = v
			if v < 0.0 {
				_setIndex(_index(out, y), x, (0 - v))
			} else {
				_setIndex(_index(out, y), x, v)
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return out
}

func max_matrix(mat [][]float64) float64 {
	var max_val float64 = _index(_index(mat, 0), 0)
	_ = max_val
	var y int = 0
	_ = y
	for y < len(mat) {
		var x int = 0
		_ = x
		for x < len(_index(mat, 0)) {
			if _index(_index(mat, y), x) > max_val {
				max_val = _index(_index(mat, y), x)
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return max_val
}

func scale_matrix(mat [][]float64, factor float64) [][]float64 {
	h := len(mat)
	_ = h
	w := len(_index(mat, 0))
	_ = w
	var out [][]float64 = zeros(h, w)
	_ = out
	var y int = 0
	_ = y
	for y < h {
		var x int = 0
		_ = x
		for x < w {
			_setIndex(_index(out, y), x, (_index(_index(mat, y), x) * factor))
			x = (x + 1)
		}
		y = (y + 1)
	}
	return out
}

func sobel_filter(image [][]int) [][][]float64 {
	h := len(image)
	_ = h
	w := len(_index(image, 0))
	_ = w
	var img [][]float64 = [][]float64{}
	_ = img
	var y0 int = 0
	_ = y0
	for y0 < h {
		var row []float64 = []float64{}
		_ = row
		var x0 int = 0
		_ = x0
		for x0 < w {
			row = append(row, float64(_index(_index(image, y0), x0)))
			x0 = (x0 + 1)
		}
		img = append(img, row)
		y0 = (y0 + 1)
	}
	var kernel_x [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 2)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(2)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}}
	_ = kernel_x
	var kernel_y [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(2), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 2)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}}
	_ = kernel_y
	var dst_x [][]float64 = abs_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(img_convolve(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(img), func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(kernel_x))))
	_ = dst_x
	var dst_y [][]float64 = abs_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(img_convolve(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(img), func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(kernel_y))))
	_ = dst_y
	max_x := max_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(dst_x))
	_ = max_x
	max_y := max_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(dst_y))
	_ = max_y
	dst_x = scale_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(dst_x), float64((255.0 / _toFloat(max_x))))
	dst_y = scale_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(dst_y), float64((255.0 / _toFloat(max_y))))
	var mag [][]float64 = zeros(h, w)
	_ = mag
	var theta [][]float64 = zeros(h, w)
	_ = theta
	var y int = 0
	_ = y
	for y < h {
		var x int = 0
		_ = x
		for x < w {
			var gx float64 = _index(_index(dst_x, y), x)
			_ = gx
			var gy float64 = _index(_index(dst_y, y), x)
			_ = gy
			_setIndex(_index(mag, y), x, sqrtApprox(((gx * gx) + (gy * gy))))
			_setIndex(_index(theta, y), x, atan2Approx(gy, gx))
			x = (x + 1)
		}
		y = (y + 1)
	}
	max_m := max_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(mag))
	_ = max_m
	mag = scale_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(mag), float64((255.0 / _toFloat(max_m))))
	return [][][]float64{mag, theta}
}

func print_matrix_int(mat [][]float64) {
	var y int = 0
	_ = y
	for y < len(mat) {
		var line string = ""
		_ = line
		var x int = 0
		_ = x
		for x < len(_index(mat, y)) {
			line = (line + fmt.Sprint(int(_index(_index(mat, y), x))))
			if x < (len(_index(mat, y)) - 1) {
				line = (line + " ")
			}
			x = (x + 1)
		}
		fmt.Println(line)
		y = (y + 1)
	}
}

func print_matrix_float(mat [][]float64) {
	var y int = 0
	_ = y
	for y < len(mat) {
		var line string = ""
		_ = line
		var x int = 0
		_ = x
		for x < len(_index(mat, y)) {
			line = (line + fmt.Sprint(_index(_index(mat, y), x)))
			if x < (len(_index(mat, y)) - 1) {
				line = (line + " ")
			}
			x = (x + 1)
		}
		fmt.Println(line)
		y = (y + 1)
	}
}

func mochiMain() {
	var img [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(80), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(50), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10)}}
	_ = img
	res := sobel_filter(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(img))
	_ = res
	mag := _index(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(res), 0)
	_ = mag
	theta := _index(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(res), 1)
	_ = theta
	print_matrix_int(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(mag)))
	print_matrix_float(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(theta)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
