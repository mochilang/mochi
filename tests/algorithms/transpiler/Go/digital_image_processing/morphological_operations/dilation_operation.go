//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 17:49:16 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func rgb_to_gray(rgb [][][]int) [][]float64 {
	var result [][]float64 = [][]float64{}
	_ = result
	var i int = 0
	_ = i
	for i < len(rgb) {
		var row []float64 = []float64{}
		_ = row
		var j int = 0
		_ = j
		for j < len(_index(rgb, i)) {
			var r int = _index(_index(_index(rgb, i), j), 0)
			_ = r
			var g int = _index(_index(_index(rgb, i), j), 1)
			_ = g
			var b int = _index(_index(_index(rgb, i), j), 2)
			_ = b
			var gray float64 = (((0.2989 * (1.0 * float64(r))) + (0.587 * (1.0 * float64(g)))) + (0.114 * (1.0 * float64(b))))
			_ = gray
			row = append(row, gray)
			j = (j + 1)
		}
		result = append(result, row)
		i = (i + 1)
	}
	return result
}

func gray_to_binary(gray [][]float64) [][]int {
	var result [][]int = [][]int{}
	_ = result
	var i int = 0
	_ = i
	for i < len(gray) {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < len(_index(gray, i)) {
			var v float64 = _index(_index(gray, i), j)
			_ = v
			if (v > 127.0) && (v <= 255.0) {
				row = append(row, 1)
			} else {
				row = append(row, 0)
			}
			j = (j + 1)
		}
		result = append(result, row)
		i = (i + 1)
	}
	return result
}

func dilation(image [][]int, kernel [][]int) [][]int {
	img_h := len(image)
	_ = img_h
	img_w := len(_index(image, 0))
	_ = img_w
	k_h := len(kernel)
	_ = k_h
	k_w := len(_index(kernel, 0))
	_ = k_w
	pad_h := (k_h / 2)
	_ = pad_h
	pad_w := (k_w / 2)
	_ = pad_w
	p_h := (img_h + (2 * pad_h))
	_ = p_h
	p_w := (img_w + (2 * pad_w))
	_ = p_w
	var padded [][]int = [][]int{}
	_ = padded
	var i int = 0
	_ = i
	for i < p_h {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < p_w {
			row = append(row, 0)
			j = (j + 1)
		}
		padded = append(padded, row)
		i = (i + 1)
	}
	i = 0
	for i < img_h {
		var j int = 0
		_ = j
		for j < img_w {
			_setIndex(_index(padded, (pad_h+i)), (pad_w + j), _index(_index(image, i), j))
			j = (j + 1)
		}
		i = (i + 1)
	}
	var output [][]int = [][]int{}
	_ = output
	i = 0
	for i < img_h {
		var row []int = []int{}
		_ = row
		var j int = 0
		_ = j
		for j < img_w {
			var sum int = 0
			_ = sum
			var ky int = 0
			_ = ky
			for ky < k_h {
				var kx int = 0
				_ = kx
				for kx < k_w {
					if int(_index(_index(kernel, ky), kx)) == 1 {
						sum = (sum + int(_index(_index(padded, (i+ky)), (j+kx))))
					}
					kx = (kx + 1)
				}
				ky = (ky + 1)
			}
			if sum > 0 {
				row = append(row, 1)
			} else {
				row = append(row, 0)
			}
			j = (j + 1)
		}
		output = append(output, row)
		i = (i + 1)
	}
	return output
}

func print_float_matrix(mat [][]float64) {
	var i int = 0
	_ = i
	for i < len(mat) {
		var line string = ""
		_ = line
		var j int = 0
		_ = j
		for j < len(_index(mat, i)) {
			line = (line + fmt.Sprint(_index(_index(mat, i), j)))
			if j < (len(_index(mat, i)) - 1) {
				line = (line + " ")
			}
			j = (j + 1)
		}
		fmt.Println(line)
		i = (i + 1)
	}
}

func print_int_matrix(mat [][]int) {
	var i int = 0
	_ = i
	for i < len(mat) {
		var line string = ""
		_ = line
		var j int = 0
		_ = j
		for j < len(_index(mat, i)) {
			line = (line + fmt.Sprint(_index(_index(mat, i), j)))
			if j < (len(_index(mat, i)) - 1) {
				line = (line + " ")
			}
			j = (j + 1)
		}
		fmt.Println(line)
		i = (i + 1)
	}
}

func mochiMain() {
	var rgb_example [][][]int = [][][]int{[][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(127), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(255), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}}}
	_ = rgb_example
	print_float_matrix(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(rgb_to_gray(func(v any) [][][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][][]int{}
			}
			out := make([][][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) [][]int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]int{}
						}
						out := make([][]int, len(arr))
						for i, x := range arr {
							out[i] = x.([]int)
						}
						return out
					}
					return v.([][]int)
				}(x)
			}
			return out
		}
		return v.([][][]int)
	}(rgb_example))))
	var gray_example [][]float64 = [][]float64{[]float64{26.0, 255.0, 14.0}, []float64{5.0, 147.0, 20.0}, []float64{1.0, 200.0, 0.0}}
	_ = gray_example
	print_int_matrix(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(gray_to_binary(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(gray_example))))
	var binary_image [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}}
	_ = binary_image
	var kernel [][]int = [][]int{[]int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(0)}}
	_ = kernel
	print_int_matrix(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(dilation(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(binary_image), func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(x)
			}
			return out
		}
		return v.([][]int)
	}(kernel))))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
