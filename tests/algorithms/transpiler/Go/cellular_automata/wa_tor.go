//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:07:34 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var WIDTH int

var HEIGHT int

var PREY_INITIAL_COUNT int

var PREY_REPRODUCTION_TIME int

var PREDATOR_INITIAL_COUNT int

var PREDATOR_REPRODUCTION_TIME int

var PREDATOR_INITIAL_ENERGY int

var PREDATOR_FOOD_VALUE int

var TYPE_PREY int

var TYPE_PREDATOR int

var seed int

func rand() int {
	seed = (((seed * 1103515245) + 12345) % 2147483648)
	return seed
}

func rand_range(max int) int {
	return (rand() % max)
}

func shuffle(list_int []int) []int {
	var i int = (len(list_int) - 1)
	_ = i
	for i > 0 {
		var j int = rand_range((i + 1))
		_ = j
		var tmp int = list_int[i]
		_ = tmp
		list_int[i] = list_int[j]
		list_int[j] = tmp
		i = (i - 1)
	}
	return list_int
}

func create_board() [][]int {
	var board [][]int = [][]int{}
	_ = board
	var r int = 0
	_ = r
	for r < HEIGHT {
		var row []int = []int{}
		_ = row
		var c int = 0
		_ = c
		for c < WIDTH {
			row = append(row, 0)
			c = (c + 1)
		}
		board = append(board, row)
		r = (r + 1)
	}
	return board
}

func create_prey(r int, c int) []int {
	return []int{TYPE_PREY, r, c, PREY_REPRODUCTION_TIME, 0, 1}
}

func create_predator(r int, c int) []int {
	return []int{TYPE_PREDATOR, r, c, PREDATOR_REPRODUCTION_TIME, PREDATOR_INITIAL_ENERGY, 1}
}

var board [][]int

var entities [][]int

func empty_cell(r int, c int) bool {
	return (board[r][c] == 0)
}

func add_entity(typ int) {
	for {
		var r int = rand_range(HEIGHT)
		_ = r
		var c int = rand_range(WIDTH)
		_ = c
		if empty_cell(r, c) {
			if typ == TYPE_PREY {
				board[r][c] = 1
				entities = append(entities, create_prey(r, c))
			} else {
				board[r][c] = 2
				entities = append(entities, create_predator(r, c))
			}
			return
		}
	}
}

func setup() {
	var i int = 0
	_ = i
	for i < PREY_INITIAL_COUNT {
		add_entity(TYPE_PREY)
		i = (i + 1)
	}
	i = 0
	for i < PREDATOR_INITIAL_COUNT {
		add_entity(TYPE_PREDATOR)
		i = (i + 1)
	}
}

var dr []int

var dc []int

func inside(r int, c int) bool {
	return ((((r >= 0) && (r < HEIGHT)) && (c >= 0)) && (c < WIDTH))
}

func find_prey(r int, c int) int {
	var i int = 0
	_ = i
	for i < len(entities) {
		var e []int = entities[i]
		_ = e
		if (((e[5] == 1) && (e[0] == TYPE_PREY)) && (e[1] == r)) && (e[2] == c) {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func step_world() {
	var i int = 0
	_ = i
	for i < len(entities) {
		var e []int = entities[i]
		_ = e
		if e[5] == 0 {
			i = (i + 1)
			continue
		}
		var typ int = e[0]
		_ = typ
		var row int = e[1]
		_ = row
		var col int = e[2]
		_ = col
		var repro int = e[3]
		_ = repro
		var energy int = e[4]
		_ = energy
		var dirs []int = []int{0, 1, 2, 3}
		_ = dirs
		dirs = shuffle(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(dirs))
		var moved bool = false
		_ = moved
		var old_r int = row
		_ = old_r
		var old_c int = col
		_ = old_c
		if typ == TYPE_PREDATOR {
			var j int = 0
			_ = j
			var ate bool = false
			_ = ate
			for j < 4 {
				var d int = dirs[j]
				_ = d
				var nr int = (row + dr[d])
				_ = nr
				var nc int = (col + dc[d])
				_ = nc
				if inside(nr, nc) && (board[nr][nc] == 1) {
					var prey_index int = find_prey(nr, nc)
					_ = prey_index
					if prey_index >= 0 {
						entities[prey_index][5] = 0
					}
					board[nr][nc] = 2
					board[row][col] = 0
					e[1] = nr
					e[2] = nc
					e[4] = ((energy + PREDATOR_FOOD_VALUE) - 1)
					moved = true
					ate = true
					break
				}
				j = (j + 1)
			}
			if !ate {
				j = 0
				for j < 4 {
					var d int = dirs[j]
					_ = d
					var nr int = (row + dr[d])
					_ = nr
					var nc int = (col + dc[d])
					_ = nc
					if inside(nr, nc) && (board[nr][nc] == 0) {
						board[nr][nc] = 2
						board[row][col] = 0
						e[1] = nr
						e[2] = nc
						moved = true
						break
					}
					j = (j + 1)
				}
				e[4] = (energy - 1)
			}
			if e[4] <= 0 {
				e[5] = 0
				board[e[1]][e[2]] = 0
			}
		} else {
			var j int = 0
			_ = j
			for j < 4 {
				var d int = dirs[j]
				_ = d
				var nr int = (row + dr[d])
				_ = nr
				var nc int = (col + dc[d])
				_ = nc
				if inside(nr, nc) && (board[nr][nc] == 0) {
					board[nr][nc] = 1
					board[row][col] = 0
					e[1] = nr
					e[2] = nc
					moved = true
					break
				}
				j = (j + 1)
			}
		}
		if e[5] == 1 {
			if moved && (repro <= 0) {
				if typ == TYPE_PREY {
					board[old_r][old_c] = 1
					entities = append(entities, create_prey(old_r, old_c))
					e[3] = PREY_REPRODUCTION_TIME
				} else {
					board[old_r][old_c] = 2
					entities = append(entities, create_predator(old_r, old_c))
					e[3] = PREDATOR_REPRODUCTION_TIME
				}
			} else {
				e[3] = (repro - 1)
			}
		}
		i = (i + 1)
	}
	var alive [][]int = [][]int{}
	_ = alive
	var k int = 0
	_ = k
	for k < len(entities) {
		var e2 []int = entities[k]
		_ = e2
		if e2[5] == 1 {
			alive = append(alive, e2)
		}
		k = (k + 1)
	}
	entities = alive
}

func count_entities(typ int) int {
	var cnt int = 0
	_ = cnt
	var i int = 0
	_ = i
	for i < len(entities) {
		if (entities[i][0] == typ) && (entities[i][5] == 1) {
			cnt = (cnt + 1)
		}
		i = (i + 1)
	}
	return cnt
}

var t int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		WIDTH = 10
		HEIGHT = 10
		PREY_INITIAL_COUNT = 20
		PREY_REPRODUCTION_TIME = 5
		PREDATOR_INITIAL_COUNT = 5
		PREDATOR_REPRODUCTION_TIME = 20
		PREDATOR_INITIAL_ENERGY = 15
		PREDATOR_FOOD_VALUE = 5
		TYPE_PREY = 0
		TYPE_PREDATOR = 1
		seed = 123456789
		board = create_board()
		entities = [][]int{}
		dr = []int{(0 - 1), 0, 1, 0}
		dc = []int{0, 1, 0, (0 - 1)}
		setup()
		t = 0
		for t < 10 {
			step_world()
			t = (t + 1)
		}
		fmt.Println(("Prey: " + fmt.Sprint(count_entities(TYPE_PREY))))
		fmt.Println(("Predators: " + fmt.Sprint(count_entities(TYPE_PREDATOR))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
