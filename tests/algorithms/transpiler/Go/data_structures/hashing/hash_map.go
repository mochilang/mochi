//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 18:48:26 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Bucket struct {
	State int `json:"state"`
	Key   int `json:"key"`
	Val   int `json:"val"`
}

type HashMap struct {
	Buckets     []Bucket `json:"buckets"`
	Len         int      `json:"len"`
	CapNum      int      `json:"cap_num"`
	CapDen      int      `json:"cap_den"`
	InitialSize int      `json:"initial_size"`
}

func make_buckets(n int) []Bucket {
	var buckets []Bucket
	_ = buckets
	var i int = 0
	_ = i
	for i < n {
		buckets = append(buckets, Bucket{
			State: 0,
			Key:   0,
			Val:   0,
		})
		i = (i + 1)
	}
	return buckets
}

func hashmap_new(initial_size int) HashMap {
	return HashMap{
		Buckets:     make_buckets(initial_size),
		Len:         0,
		CapNum:      3,
		CapDen:      4,
		InitialSize: initial_size,
	}
}

func bucket_index(hm HashMap, key int) int {
	var ind int = _mod(key, len(hm.Buckets))
	_ = ind
	if ind < 0 {
		ind = (ind + len(hm.Buckets))
	}
	return ind
}

func next_index(hm HashMap, ind int) int {
	return _mod((ind + 1), len(hm.Buckets))
}

func try_set(hm *HashMap, ind int, key int, val int) bool {
	var buckets []Bucket = hm.Buckets
	_ = buckets
	var b Bucket = _index(buckets, ind)
	_ = b
	if (b.State == 0) || (b.State == 2) {
		_setIndex(buckets, ind, Bucket{
			State: 1,
			Key:   key,
			Val:   val,
		})
		hm.Buckets = buckets
		hm.Len = (hm.Len + 1)
		return true
	}
	if b.Key == key {
		_setIndex(buckets, ind, Bucket{
			State: 1,
			Key:   key,
			Val:   val,
		})
		hm.Buckets = buckets
		return true
	}
	return false
}

func is_full(hm HashMap) bool {
	var limit int = ((len(hm.Buckets) * hm.CapNum) / hm.CapDen)
	_ = limit
	_ = limit
	return (hm.Len >= limit)
}

func is_sparse(hm HashMap) bool {
	if len(hm.Buckets) <= hm.InitialSize {
		return false
	}
	var limit int = ((len(hm.Buckets) * hm.CapNum) / (2 * hm.CapDen))
	_ = limit
	_ = limit
	return (hm.Len < limit)
}

func resize(hm *HashMap, new_size int) {
	var old []Bucket = hm.Buckets
	_ = old
	hm.Buckets = make_buckets(new_size)
	hm.Len = 0
	var i int = 0
	_ = i
	for i < len(old) {
		var it Bucket = _index(old, i)
		_ = it
		if it.State == 1 {
			add_item(*hm, it.Key, it.Val)
		}
		i = (i + 1)
	}
}

func size_up(hm HashMap) {
	resize(&hm, (len(hm.Buckets) * 2))
}

func size_down(hm HashMap) {
	resize(&hm, (len(hm.Buckets) / 2))
}

func add_item(hm HashMap, key int, val int) {
	var ind int = bucket_index(hm, key)
	_ = ind
	var i int = 0
	_ = i
	for i < len(hm.Buckets) {
		if try_set(&hm, ind, key, val) {
			break
		}
		ind = next_index(hm, ind)
		i = (i + 1)
	}
}

func hashmap_set(hm HashMap, key int, val int) {
	if is_full(hm) {
		size_up(hm)
	}
	add_item(hm, key, val)
}

func hashmap_get(hm HashMap, key int) int {
	var buckets []Bucket = hm.Buckets
	_ = buckets
	var ind int = bucket_index(hm, key)
	_ = ind
	var i int = 0
	_ = i
	for i < len(buckets) {
		var it Bucket = _index(buckets, ind)
		_ = it
		if it.State == 0 {
			break
		}
		if (it.State == 1) && (it.Key == key) {
			return it.Val
		}
		ind = next_index(hm, ind)
		i = (i + 1)
	}
	return 0
}

func hashmap_del(hm *HashMap, key int) {
	var buckets []Bucket = hm.Buckets
	_ = buckets
	var ind int = bucket_index(*hm, key)
	_ = ind
	var i int = 0
	_ = i
	for i < len(buckets) {
		var it Bucket = _index(buckets, ind)
		_ = it
		if it.State == 0 {
			fmt.Println(("KeyError: " + fmt.Sprint(key)))
			return
		}
		if (it.State == 1) && (it.Key == key) {
			_setIndex(buckets, ind, Bucket{
				State: 2,
				Key:   0,
				Val:   0,
			})
			hm.Buckets = buckets
			hm.Len = (hm.Len - 1)
			break
		}
		ind = next_index(*hm, ind)
		i = (i + 1)
	}
	if is_sparse(*hm) {
		size_down(*hm)
	}
}

func hashmap_len(hm HashMap) int {
	return hm.Len
}

func hashmap_repr(hm HashMap) string {
	var out string = "HashMap("
	_ = out
	var first bool = true
	_ = first
	var i int = 0
	_ = i
	for i < len(hm.Buckets) {
		var b Bucket = _index(hm.Buckets, i)
		_ = b
		if b.State == 1 {
			if !first {
				out = (out + ", ")
			} else {
				first = false
			}
			out = (((out + fmt.Sprint(b.Key)) + ": ") + fmt.Sprint(b.Val))
		}
		i = (i + 1)
	}
	out = (out + ")")
	return out
}

var hm HashMap

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		hm = hashmap_new(5)
		hashmap_set(hm, 1, 10)
		hashmap_set(hm, 2, 20)
		hashmap_set(hm, 3, 30)
		fmt.Println(hashmap_repr(hm))
		fmt.Println(fmt.Sprint(hashmap_get(hm, 2)))
		hashmap_del(&hm, 1)
		fmt.Println(hashmap_repr(hm))
		fmt.Println(fmt.Sprint(hashmap_len(hm)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
