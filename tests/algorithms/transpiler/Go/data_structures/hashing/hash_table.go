//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-24 17:05:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var __name__ string = "__main__"

type HashTable struct {
	SizeTable    int     `json:"size_table"`
	Values       []int   `json:"values"`
	Filled       []bool  `json:"filled"`
	ChargeFactor int     `json:"charge_factor"`
	LimCharge    float64 `json:"lim_charge"`
}

func repeat_int(n int, val int) []int {
	var res []int
	_ = res
	var i int = 0
	_ = i
	for i < n {
		res = append(res, val)
		i = (i + 1)
	}
	return res
}

func repeat_bool(n int, val bool) []bool {
	var res []bool
	_ = res
	var i int = 0
	_ = i
	for i < n {
		res = append(res, val)
		i = (i + 1)
	}
	return res
}

func set_int(xs []int, idx int, value int) []int {
	var res []int
	_ = res
	var i int = 0
	_ = i
	for i < len(xs) {
		if i == idx {
			res = append(res, value)
		} else {
			res = append(res, _index(xs, i))
		}
		i = (i + 1)
	}
	return res
}

func set_bool(xs []bool, idx int, value bool) []bool {
	var res []bool
	_ = res
	var i int = 0
	_ = i
	for i < len(xs) {
		if i == idx {
			res = append(res, value)
		} else {
			res = append(res, _index(xs, i))
		}
		i = (i + 1)
	}
	return res
}

func create_table(size_table int, charge_factor int, lim_charge float64) HashTable {
	return HashTable{
		SizeTable:    size_table,
		Values:       repeat_int(size_table, 0),
		Filled:       repeat_bool(size_table, false),
		ChargeFactor: charge_factor,
		LimCharge:    lim_charge,
	}
}

func hash_function(ht HashTable, key int) int {
	var k int = _modi(key, ht.SizeTable)
	_ = k
	if k < 0 {
		k = (k + ht.SizeTable)
	}
	return k
}

func is_prime(n int) bool {
	if n < 2 {
		return false
	}
	if _modi(n, 2) == 0 {
		return (n == 2)
	}
	var i int = 3
	_ = i
	for (i * i) <= n {
		if _modi(n, i) == 0 {
			return false
		}
		i = (i + 2)
	}
	return true
}

func next_prime(value int, factor int) int {
	var candidate int = ((value * factor) + 1)
	_ = candidate
	for !is_prime(candidate) {
		candidate = (candidate + 1)
	}
	return candidate
}

func set_value(ht HashTable, key int, data int) HashTable {
	var new_values []int = set_int(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(ht.Values), key, data)
	_ = new_values
	_ = new_values
	var new_filled []bool = set_bool(func(v any) []bool {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]bool); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []bool{}
			}
			out := make([]bool, len(arr))
			for i, x := range arr {
				out[i] = x.(bool)
			}
			return out
		}
		return v.([]bool)
	}(ht.Filled), key, true)
	_ = new_filled
	_ = new_filled
	return HashTable{
		SizeTable:    ht.SizeTable,
		Values:       new_values,
		Filled:       new_filled,
		ChargeFactor: ht.ChargeFactor,
		LimCharge:    ht.LimCharge,
	}
}

func collision_resolution(ht HashTable, key int) int {
	var new_key int = hash_function(ht, (key + 1))
	_ = new_key
	var steps int = 0
	_ = steps
	for _index(ht.Filled, new_key) {
		new_key = hash_function(ht, (new_key + 1))
		steps = (steps + 1)
		if steps >= ht.SizeTable {
			return (0 - 1)
		}
	}
	return new_key
}

func rehashing(ht HashTable) HashTable {
	var survivors []int
	_ = survivors
	var i int = 0
	_ = i
	for i < len(ht.Values) {
		if _index(ht.Filled, i) {
			survivors = append(survivors, _index(ht.Values, i))
		}
		i = (i + 1)
	}
	var new_size int = next_prime(ht.SizeTable, 2)
	_ = new_size
	var new_ht HashTable = create_table(new_size, ht.ChargeFactor, ht.LimCharge)
	_ = new_ht
	i = 0
	for i < len(survivors) {
		new_ht = insert_data(new_ht, _index(survivors, i))
		i = (i + 1)
	}
	return new_ht
}

func insert_data(ht HashTable, data int) HashTable {
	var key int = hash_function(ht, data)
	_ = key
	if !_index(ht.Filled, key) {
		return set_value(ht, key, data)
	}
	if _index(ht.Values, key) == data {
		return ht
	}
	var new_key int = collision_resolution(ht, key)
	_ = new_key
	if new_key >= 0 {
		return set_value(ht, new_key, data)
	}
	var resized HashTable = rehashing(ht)
	_ = resized
	_ = resized
	return insert_data(resized, data)
}

func keys(ht HashTable) [][]int {
	var res [][]int
	_ = res
	var i int = 0
	_ = i
	for i < len(ht.Values) {
		if _index(ht.Filled, i) {
			res = append(res, []int{func(v any) int {
				if vv, ok := v.(int); ok {
					return vv
				}
				return 0
			}(i), func(v any) int {
				if vv, ok := v.(int); ok {
					return vv
				}
				return 0
			}(_index(ht.Values, i))})
		}
		i = (i + 1)
	}
	return res
}

func mochiMain() {
	var ht HashTable = create_table(3, 1, 0.75)
	_ = ht
	ht = insert_data(ht, 17)
	ht = insert_data(ht, 18)
	ht = insert_data(ht, 99)
	fmt.Println(fmt.Sprint(keys(ht)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
