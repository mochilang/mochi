//go:build ignore

// Generated by Mochi v0.10.60 on 2025-08-08 10:31:13 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i int) T {
	if i < 0 {
		i += len(s)
	}
	return s[i]
}

func _setIndex[T any](s []T, i int, v T) {
	if i < 0 {
		i += len(s)
	}
	s[i] = v
}

type Node struct {
	Children      map[string]int `json:"children"`
	IsEndOfString bool           `json:"is_end_of_string"`
	Start         int            `json:"start"`
	End           int            `json:"end"`
}

type SuffixTree struct {
	Text  string `json:"text"`
	Nodes []Node `json:"nodes"`
}

func new_node() Node {
	return Node{
		Children:      map[string]int{},
		IsEndOfString: false,
		Start:         (0 - 1),
		End:           (0 - 1),
	}
}

func has_key(m map[string]int, k string) bool {
	for _, key := range func() []string {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		if key == k {
			return true
		}
	}
	return false
}

func add_suffix(tree SuffixTree, suffix string, index int) SuffixTree {
	var nodes []Node = tree.Nodes
	_ = nodes
	var node_idx int = 0
	_ = node_idx
	var j int = 0
	_ = j
	for j < len(suffix) {
		ch := _substr(suffix, j, (j + 1))
		_ = ch
		var node Node = _index(nodes, node_idx)
		_ = node
		var children map[string]int = node.Children
		_ = children
		if !has_key(children, ch) {
			nodes = append(nodes, new_node())
			new_idx := (len(nodes) - 1)
			_ = new_idx
			children[ch] = new_idx
		}
		node.Children = children
		_setIndex(nodes, node_idx, node)
		node_idx = children[ch]
		j = (j + 1)
	}
	var node Node = _index(nodes, node_idx)
	_ = node
	node.IsEndOfString = true
	node.Start = index
	node.End = ((index + len(suffix)) - 1)
	_setIndex(nodes, node_idx, node)
	tree.Nodes = nodes
	return tree
}

func build_suffix_tree(tree SuffixTree) SuffixTree {
	var text string = tree.Text
	_ = text
	n := len(text)
	_ = n
	var i int = 0
	_ = i
	var t SuffixTree = tree
	_ = t
	for i < int(n) {
		var suffix string = ""
		_ = suffix
		var k int = i
		_ = k
		for k < int(n) {
			suffix = (suffix + _substr(text, k, (k+1)))
			k = (k + 1)
		}
		t = add_suffix(t, suffix, i)
		i = (i + 1)
	}
	return t
}

func new_suffix_tree(text string) SuffixTree {
	var tree SuffixTree = SuffixTree{
		Text:  text,
		Nodes: []Node{},
	}
	_ = tree
	tree.Nodes = append(tree.Nodes, new_node())
	tree = build_suffix_tree(tree)
	return tree
}

func search(tree SuffixTree, pattern string) bool {
	var node_idx int = 0
	_ = node_idx
	var i int = 0
	_ = i
	var nodes []Node = tree.Nodes
	_ = nodes
	for i < len(pattern) {
		ch := _substr(pattern, i, (i + 1))
		_ = ch
		var node Node = _index(nodes, node_idx)
		_ = node
		var children map[string]int = node.Children
		_ = children
		if !has_key(children, ch) {
			return false
		}
		node_idx = children[ch]
		i = (i + 1)
	}
	return true
}

var st SuffixTree

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		st = new_suffix_tree("bananas")
		fmt.Println(fmt.Sprint(search(st, "ana")))
		fmt.Println(fmt.Sprint(search(st, "apple")))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
