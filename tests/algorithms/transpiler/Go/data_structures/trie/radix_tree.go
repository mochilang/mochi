//go:build ignore

// Generated by Mochi v0.10.60 on 2025-08-07 19:17:48 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

type RadixNode struct {
	Prefix   string         `json:"prefix"`
	IsLeaf   bool           `json:"is_leaf"`
	Children map[string]int `json:"children"`
}

type RadixTree struct {
	Nodes []RadixNode `json:"nodes"`
}

type MatchResult struct {
	Common    string `json:"common"`
	RemPrefix string `json:"rem_prefix"`
	RemWord   string `json:"rem_word"`
}

func new_node(prefix string, is_leaf bool) RadixNode {
	return RadixNode{
		Prefix:   prefix,
		IsLeaf:   is_leaf,
		Children: map[string]int{},
	}
}

func new_tree() RadixTree {
	var nodes []RadixNode = []RadixNode{new_node("", false)}
	_ = nodes
	_ = nodes
	return RadixTree{
		Nodes: nodes,
	}
}

func match_prefix(node RadixNode, word string) MatchResult {
	var x int = 0
	_ = x
	var p string = node.Prefix
	_ = p
	var w string = word
	_ = w
	var min_len int = len(p)
	_ = min_len
	if len(w) < min_len {
		min_len = len(w)
	}
	for x < min_len {
		if _substr(p, x, (x+1)) != _substr(w, x, (x+1)) {
			break
		}
		x = (x + 1)
	}
	var common string = _substr(p, 0, x)
	_ = common
	_ = common
	var rem_prefix string = _substr(p, x, len(p))
	_ = rem_prefix
	_ = rem_prefix
	var rem_word string = _substr(w, x, len(w))
	_ = rem_word
	_ = rem_word
	return MatchResult{
		Common:    common,
		RemPrefix: rem_prefix,
		RemWord:   rem_word,
	}
}

func insert_many(tree RadixTree, words []string) {
	for _, w := range words {
		insert(tree, 0, w)
	}
}

func insert(tree RadixTree, idx int, word string) {
	var nodes []RadixNode = tree.Nodes
	_ = nodes
	var node RadixNode = nodes[idx]
	_ = node
	if (node.Prefix == word) && !node.IsLeaf {
		node.IsLeaf = true
		nodes[idx] = node
		tree.Nodes = nodes
		return
	}
	var first string = _substr(word, 0, 1)
	_ = first
	var children map[string]int = node.Children
	_ = children
	if !has_key(children, first) {
		var new_idx int = len(nodes)
		_ = new_idx
		nodes = append(nodes, new_node(word, true))
		children[first] = new_idx
		node.Children = children
		nodes[idx] = node
		tree.Nodes = nodes
		return
	}
	var child_idx int = children[first]
	_ = child_idx
	var child RadixNode = nodes[child_idx]
	_ = child
	var res MatchResult = match_prefix(child, word)
	_ = res
	if res.RemPrefix == "" {
		insert(tree, child_idx, res.RemWord)
		return
	}
	child.Prefix = res.RemPrefix
	nodes[child_idx] = child
	var new_children map[string]int = map[string]int{}
	_ = new_children
	new_children[_substr(res.RemPrefix, 0, 1)] = child_idx
	var new_idx int = len(nodes)
	_ = new_idx
	nodes = append(nodes, new_node(res.Common, false))
	nodes[new_idx].Children = new_children
	if res.RemWord == "" {
		nodes[new_idx].IsLeaf = true
	} else {
		insert(tree, new_idx, res.RemWord)
	}
	children[first] = new_idx
	node.Children = children
	nodes[idx] = node
	tree.Nodes = nodes
}

func find(tree RadixTree, idx int, word string) bool {
	var nodes []RadixNode = tree.Nodes
	_ = nodes
	var node RadixNode = nodes[idx]
	_ = node
	var first string = _substr(word, 0, 1)
	_ = first
	var children map[string]int = node.Children
	_ = children
	if !has_key(children, first) {
		return false
	}
	var child_idx int = children[first]
	_ = child_idx
	var child RadixNode = nodes[child_idx]
	_ = child
	var res MatchResult = match_prefix(child, word)
	_ = res
	if res.RemPrefix != "" {
		return false
	}
	if res.RemWord == "" {
		return child.IsLeaf
	}
	return find(tree, child_idx, res.RemWord)
}

func remove_key(m map[string]int, k string) map[string]int {
	var out map[string]int = map[string]int{}
	_ = out
	for _, key := range func() []string {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		if key != k {
			out[key] = m[key]
		}
	}
	return out
}

func has_key(m map[string]int, k string) bool {
	for _, key := range func() []string {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		if key == k {
			return true
		}
	}
	return false
}

func delete(tree RadixTree, idx int, word string) bool {
	var nodes []RadixNode = tree.Nodes
	_ = nodes
	var node RadixNode = nodes[idx]
	_ = node
	var first string = _substr(word, 0, 1)
	_ = first
	var children map[string]int = node.Children
	_ = children
	if !has_key(children, first) {
		return false
	}
	var child_idx int = children[first]
	_ = child_idx
	var child RadixNode = nodes[child_idx]
	_ = child
	var res MatchResult = match_prefix(child, word)
	_ = res
	if res.RemPrefix != "" {
		return false
	}
	if res.RemWord != "" {
		var deleted bool = delete(tree, child_idx, res.RemWord)
		_ = deleted
		if deleted {
			nodes = tree.Nodes
			node = nodes[idx]
		}
		return deleted
	}
	if !child.IsLeaf {
		return false
	}
	if len(child.Children) == 0 {
		children = remove_key(children, first)
		node.Children = children
		nodes[idx] = node
		tree.Nodes = nodes
		if (len(children) == 1) && !node.IsLeaf {
			var only_key string = ""
			_ = only_key
			for _, k := range func() []string {
				keys := make([]string, 0, len(children))
				for k := range children {
					keys = append(keys, k)
				}
				sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
				return keys
			}() {
				only_key = k
			}
			var merge_idx int = children[only_key]
			_ = merge_idx
			var merge_node RadixNode = nodes[merge_idx]
			_ = merge_node
			node.IsLeaf = merge_node.IsLeaf
			node.Prefix = (node.Prefix + merge_node.Prefix)
			node.Children = merge_node.Children
			nodes[idx] = node
			tree.Nodes = nodes
		}
	} else {
		if len(child.Children) > 1 {
			child.IsLeaf = false
			nodes[child_idx] = child
			tree.Nodes = nodes
		} else {
			var only_key string = ""
			_ = only_key
			for _, k := range func() []string {
				keys := make([]string, 0, len(child.Children))
				for k := range child.Children {
					keys = append(keys, k)
				}
				sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
				return keys
			}() {
				only_key = k
			}
			var merge_idx int = child.Children[only_key]
			_ = merge_idx
			var merge_node RadixNode = nodes[merge_idx]
			_ = merge_node
			child.IsLeaf = merge_node.IsLeaf
			child.Prefix = (child.Prefix + merge_node.Prefix)
			child.Children = merge_node.Children
			nodes[child_idx] = child
			tree.Nodes = nodes
		}
	}
	return true
}

func print_tree(tree RadixTree, idx int, height int) {
	var nodes []RadixNode = tree.Nodes
	_ = nodes
	var node RadixNode = nodes[idx]
	_ = node
	if node.Prefix != "" {
		var line string = ""
		_ = line
		var i int = 0
		_ = i
		for i < height {
			line = (line + "-")
			i = (i + 1)
		}
		line = ((line + " ") + node.Prefix)
		if node.IsLeaf {
			line = (line + "  (leaf)")
		}
		fmt.Println(line)
	}
	var children map[string]int = node.Children
	_ = children
	for _, k := range func() []string {
		keys := make([]string, 0, len(children))
		for k := range children {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		var child_idx int = children[k]
		_ = child_idx
		print_tree(tree, child_idx, (height + 1))
	}
}

func test_trie() bool {
	var words []string = []string{"banana", "bananas", "bandana", "band", "apple", "all", "beast"}
	_ = words
	var tree RadixTree = new_tree()
	_ = tree
	insert_many(tree, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(words))
	var ok bool = true
	_ = ok
	for _, w := range words {
		if !find(tree, 0, w) {
			ok = false
		}
	}
	if find(tree, 0, "bandanas") {
		ok = false
	}
	if find(tree, 0, "apps") {
		ok = false
	}
	delete(tree, 0, "all")
	if find(tree, 0, "all") {
		ok = false
	}
	delete(tree, 0, "banana")
	if find(tree, 0, "banana") {
		ok = false
	}
	if !find(tree, 0, "bananas") {
		ok = false
	}
	return ok
}

func pytests() {
	if !test_trie() {
		panic("test failed")
	}
}

func mochiMain() {
	var tree RadixTree = new_tree()
	_ = tree
	var words []string = []string{"banana", "bananas", "bandanas", "bandana", "band", "apple", "all", "beast"}
	_ = words
	insert_many(tree, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(words))
	fmt.Println(("Words: " + fmt.Sprint(words)))
	fmt.Println("Tree:")
	print_tree(tree, 0, 0)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
