//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:36:43 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Node struct {
	Children map[string]int `json:"children"`
	IsLeaf   bool           `json:"is_leaf"`
}

type Trie struct {
	Nodes []Node `json:"nodes"`
}

func new_trie() Trie {
	return Trie{
		Nodes: []Node{Node{
			Children: map[string]int{},
			IsLeaf:   false,
		}},
	}
}

func remove_key(m map[string]int, k string) map[string]int {
	var out map[string]int = map[string]int{}
	_ = out
	for _, key := range func() []string {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		if key != k {
			out[key] = m[key]
		}
	}
	return out
}

func insert(trie *Trie, word string) {
	var nodes []Node = trie.Nodes
	_ = nodes
	var curr int = 0
	_ = curr
	var i int = 0
	_ = i
	for i < len(word) {
		var ch string = string(_index([]rune(word), i))
		_ = ch
		var child_idx int = (0 - 1)
		_ = child_idx
		var children map[string]int = _index(nodes, curr).Children
		_ = children
		if func() bool { _, ok := children[ch]; return ok }() {
			child_idx = children[ch]
		} else {
			var new_node Node = Node{
				Children: map[string]int{},
				IsLeaf:   false,
			}
			_ = new_node
			nodes = append(nodes, new_node)
			child_idx = (len(nodes) - 1)
			var new_children map[string]int = children
			_ = new_children
			new_children[ch] = child_idx
			var node Node = _index(nodes, curr)
			_ = node
			node.Children = new_children
			_setIndex(nodes, curr, node)
		}
		curr = child_idx
		i = (i + 1)
	}
	var node Node = _index(nodes, curr)
	_ = node
	node.IsLeaf = true
	_setIndex(nodes, curr, node)
	trie.Nodes = nodes
}

func insert_many(trie Trie, words []string) {
	for _, w := range words {
		insert(&trie, w)
	}
}

func find(trie Trie, word string) bool {
	var nodes []Node = trie.Nodes
	_ = nodes
	var curr int = 0
	_ = curr
	var i int = 0
	_ = i
	for i < len(word) {
		var ch string = string(_index([]rune(word), i))
		_ = ch
		var children map[string]int = _index(nodes, curr).Children
		_ = children
		if !func() bool { _, ok := children[ch]; return ok }() {
			return false
		}
		curr = children[ch]
		i = (i + 1)
	}
	var node Node = _index(nodes, curr)
	_ = node
	_ = node
	return node.IsLeaf
}

func delete(trie *Trie, word string) {
	var nodes []Node = trie.Nodes
	_ = nodes
	var _delete func(int, int) bool
	_ = _delete
	_delete = func(idx int, pos int) bool {
		if pos == len(word) {
			var node Node = _index(nodes, idx)
			_ = node
			if node.IsLeaf == false {
				return false
			}
			node.IsLeaf = false
			_setIndex(nodes, idx, node)
			return (len(node.Children) == 0)
		}
		var node Node = _index(nodes, idx)
		_ = node
		var children map[string]int = node.Children
		_ = children
		var ch string = string(_index([]rune(word), pos))
		_ = ch
		if !func() bool { _, ok := children[ch]; return ok }() {
			return false
		}
		var child_idx int = children[ch]
		_ = child_idx
		var should_delete bool = _delete(child_idx, (pos + 1))
		_ = should_delete
		node = _index(nodes, idx)
		if should_delete {
			var new_children map[string]int = remove_key(node.Children, ch)
			_ = new_children
			node.Children = new_children
			_setIndex(nodes, idx, node)
			return ((len(new_children) == 0) && (node.IsLeaf == false))
		}
		_setIndex(nodes, idx, node)
		return false
	}
	_delete(0, 0)
	trie.Nodes = nodes
}

func print_words(trie Trie) {
	var dfs func(int, string)
	_ = dfs
	dfs = func(idx int, word string) {
		var node Node = _index(trie.Nodes, idx)
		_ = node
		if node.IsLeaf {
			fmt.Println(word)
		}
		for _, key := range func() []string {
			keys := make([]string, 0, len(node.Children))
			for k := range node.Children {
				keys = append(keys, k)
			}
			sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
			return keys
		}() {
			dfs(node.Children[key], (word + key))
		}
	}
	dfs(0, "")
}

func test_trie() bool {
	var words []string = []string{"banana", "bananas", "bandana", "band", "apple", "all", "beast"}
	_ = words
	var trie Trie = new_trie()
	_ = trie
	insert_many(trie, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = fmt.Sprint(x)
			}
			return out
		}
		return v.([]string)
	}(words))
	var ok bool = true
	_ = ok
	for _, w := range words {
		ok = (ok && find(trie, w))
	}
	ok = (ok && find(trie, "banana"))
	var t bool = find(trie, "bandanas")
	_ = t
	ok = (ok && (t == false))
	var t2 bool = find(trie, "apps")
	_ = t2
	ok = (ok && (t2 == false))
	ok = (ok && find(trie, "apple"))
	ok = (ok && find(trie, "all"))
	delete(&trie, "all")
	var t3 bool = find(trie, "all")
	_ = t3
	ok = (ok && (t3 == false))
	delete(&trie, "banana")
	var t4 bool = find(trie, "banana")
	_ = t4
	ok = (ok && (t4 == false))
	ok = (ok && find(trie, "bananas"))
	return ok
}

func print_results(msg string, passes bool) {
	if passes {
		fmt.Println((msg + " works!"))
	} else {
		fmt.Println((msg + " doesn't work :("))
	}
}

var trie Trie

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		trie = new_trie()
		print_results("Testing trie functionality", test_trie())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
