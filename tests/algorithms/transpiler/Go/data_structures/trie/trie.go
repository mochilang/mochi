//go:build ignore

// Generated by Mochi v0.10.60 on 2025-08-07 19:17:49 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Node struct {
	Children map[string]int `json:"children"`
	IsLeaf   bool           `json:"is_leaf"`
}

type Trie struct {
	Nodes []Node `json:"nodes"`
}

func new_trie() Trie {
	return Trie{
		Nodes: []Node{Node{
			Children: map[string]int{},
			IsLeaf:   false,
		}},
	}
}

func remove_key(m map[string]int, k string) map[string]int {
	var out map[string]int = map[string]int{}
	_ = out
	for _, key := range func() []string {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		if key != k {
			out[key] = m[key]
		}
	}
	return out
}

func insert(trie Trie, word string) {
	var nodes []Node = trie.Nodes
	_ = nodes
	var curr int = 0
	_ = curr
	var i int = 0
	_ = i
	for i < len(word) {
		var ch string = string([]rune(word)[i])
		_ = ch
		var child_idx int = (0 - 1)
		_ = child_idx
		var children Node = nodes[curr].Children
		_ = children
		if func() bool {
			for _, el := range children {
				if el == ch {
					return true
				}
			}
			return false
		}().(bool) {
			child_idx = children.Ch
		} else {
			var new_node Node = Node{
				Children: map[string]int{},
				IsLeaf:   false,
			}
			_ = new_node
			nodes = append(nodes, new_node)
			child_idx = (len(nodes) - 1)
			var new_children Node = children
			_ = new_children
			new_children[ch] = child_idx
			var node Node = nodes[curr]
			_ = node
			node.Children = new_children
			nodes[curr] = node
		}
		curr = child_idx
		i = (i + 1)
	}
	var node Node = nodes[curr]
	_ = node
	node.IsLeaf = true
	nodes[curr] = node
	trie.Nodes = nodes
}

func insert_many(trie Trie, words []string) {
	for _, w := range words {
		insert(trie, w)
	}
}

func find(trie Trie, word string) bool {
	var nodes []Node = trie.Nodes
	_ = nodes
	var curr int = 0
	_ = curr
	var i int = 0
	_ = i
	for i < len(word) {
		var ch string = string([]rune(word)[i])
		_ = ch
		_ = ch
		var children Node = nodes[curr].Children
		_ = children
		if !func() bool {
			for _, el := range children {
				if el == ch {
					return true
				}
			}
			return false
		}().(bool) {
			return false
		}
		curr = children.Ch
		i = (i + 1)
	}
	var node Node = nodes[curr]
	_ = node
	_ = node
	return node.IsLeaf
}

func delete(trie Trie, word string) {
	var nodes []Node = trie.Nodes
	_ = nodes
	var _delete func(int, int) bool
	_ = _delete
	_delete = func(idx int, pos int) bool {
		if pos == len(word) {
			var node Node = nodes[idx]
			_ = node
			if node.IsLeaf == false {
				return false
			}
			node.IsLeaf = false
			nodes[idx] = node
			return (len(node.Children) == 0)
		}
		var node Node = nodes[idx]
		_ = node
		var children map[string]int = node.Children
		_ = children
		var ch string = string([]rune(word)[pos])
		_ = ch
		if !func() bool { _, ok := children[ch]; return ok }() {
			return false
		}
		var child_idx int = children[ch]
		_ = child_idx
		var should_delete bool = _delete(child_idx, (pos + 1))
		_ = should_delete
		node = nodes[idx]
		if should_delete {
			var new_children map[string]int = remove_key(node.Children, ch)
			_ = new_children
			node.Children = new_children
			nodes[idx] = node
			return ((len(new_children) == 0) && (node.IsLeaf == false))
		}
		nodes[idx] = node
		return false
	}
	_delete(0, 0)
	trie.Nodes = nodes
}

func print_words(trie Trie) {
	var dfs func(int, string)
	_ = dfs
	dfs = func(idx int, word string) {
		var node Node = trie.Nodes[idx]
		_ = node
		if node.IsLeaf {
			fmt.Println(word)
		}
		for _, key := range func() []string {
			keys := make([]string, 0, len(node.Children))
			for k := range node.Children {
				keys = append(keys, k)
			}
			sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
			return keys
		}() {
			dfs(node.Children[key], (word + key))
		}
	}
	dfs(0, "")
}

func test_trie() bool {
	var words []string = []string{"banana", "bananas", "bandana", "band", "apple", "all", "beast"}
	_ = words
	var trie Trie = new_trie()
	_ = trie
	insert_many(trie, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(words))
	var ok bool = true
	_ = ok
	for _, w := range words {
		ok = (ok && find(trie, w))
	}
	ok = (ok && find(trie, "banana"))
	var t bool = find(trie, "bandanas")
	_ = t
	ok = (ok && (t == false))
	var t2 bool = find(trie, "apps")
	_ = t2
	ok = (ok && (t2 == false))
	ok = (ok && find(trie, "apple"))
	ok = (ok && find(trie, "all"))
	delete(trie, "all")
	var t3 bool = find(trie, "all")
	_ = t3
	ok = (ok && (t3 == false))
	delete(trie, "banana")
	var t4 bool = find(trie, "banana")
	_ = t4
	ok = (ok && (t4 == false))
	ok = (ok && find(trie, "bananas"))
	return ok
}

func print_results(msg string, passes bool) {
	if passes {
		fmt.Println((msg + " works!"))
	} else {
		fmt.Println((msg + " doesn't work :("))
	}
}

var trie Trie

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		trie = new_trie()
		print_results("Testing trie functionality", test_trie())
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
