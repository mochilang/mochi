//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 22:52:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"math/big"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var NIL *big.Int

var nodes []map[string]int

func new_node(value int) int {
	var node map[string]int = map[string]int{"data": value, "left": int(NIL.Int64()), "right": int(NIL.Int64()), "height": 1}
	_ = node
	nodes = append(nodes, node)
	return (len(nodes) - 1)
}

func get_height(i int) int {
	if i == int(NIL.Int64()) {
		return 0
	}
	return nodes[i]["height"]
}

func my_max(a int, b int) int {
	if a > b {
		return a
	}
	return b
}

func update_height(i int) {
	nodes[i]["height"] = (my_max(get_height(nodes[i]["left"]), get_height(nodes[i]["right"])) + 1)
}

func right_rotation(i int) int {
	var left int = nodes[i]["left"]
	_ = left
	nodes[i]["left"] = nodes[left]["right"]
	nodes[left]["right"] = i
	update_height(i)
	update_height(left)
	return left
}

func left_rotation(i int) int {
	var right int = nodes[i]["right"]
	_ = right
	nodes[i]["right"] = nodes[right]["left"]
	nodes[right]["left"] = i
	update_height(i)
	update_height(right)
	return right
}

func lr_rotation(i int) int {
	nodes[i]["left"] = left_rotation(nodes[i]["left"])
	return right_rotation(i)
}

func rl_rotation(i int) int {
	nodes[i]["right"] = right_rotation(nodes[i]["right"])
	return left_rotation(i)
}

func insert_node(i int, value int) int {
	if i == int(NIL.Int64()) {
		return new_node(value)
	}
	if value < nodes[i]["data"] {
		nodes[i]["left"] = insert_node(nodes[i]["left"], value)
		if (get_height(nodes[i]["left"]) - get_height(nodes[i]["right"])) == 2 {
			if value < nodes[nodes[i]["left"]]["data"] {
				i = right_rotation(i)
			} else {
				i = lr_rotation(i)
			}
		}
	} else {
		nodes[i]["right"] = insert_node(nodes[i]["right"], value)
		if (get_height(nodes[i]["right"]) - get_height(nodes[i]["left"])) == 2 {
			if value < nodes[nodes[i]["right"]]["data"] {
				i = rl_rotation(i)
			} else {
				i = left_rotation(i)
			}
		}
	}
	update_height(i)
	return i
}

func get_left_most(i int) int {
	var cur int = i
	_ = cur
	for nodes[cur]["left"] != int(NIL.Int64()) {
		cur = nodes[cur]["left"]
	}
	return nodes[cur]["data"]
}

func del_node(i int, value int) int {
	if i == int(NIL.Int64()) {
		return int(NIL.Int64())
	}
	if value < nodes[i]["data"] {
		nodes[i]["left"] = del_node(nodes[i]["left"], value)
	} else {
		if value > nodes[i]["data"] {
			nodes[i]["right"] = del_node(nodes[i]["right"], value)
		} else {
			if (nodes[i]["left"] != int(NIL.Int64())) && (nodes[i]["right"] != int(NIL.Int64())) {
				var temp int = get_left_most(nodes[i]["right"])
				_ = temp
				nodes[i]["data"] = temp
				nodes[i]["right"] = del_node(nodes[i]["right"], temp)
			} else {
				if nodes[i]["left"] != int(NIL.Int64()) {
					i = nodes[i]["left"]
				} else {
					i = nodes[i]["right"]
				}
			}
		}
	}
	if i == int(NIL.Int64()) {
		return int(NIL.Int64())
	}
	var lh int = get_height(nodes[i]["left"])
	_ = lh
	var rh int = get_height(nodes[i]["right"])
	_ = rh
	if (rh - lh) == 2 {
		if get_height(nodes[nodes[i]["right"]]["right"]) > get_height(nodes[nodes[i]["right"]]["left"]) {
			i = left_rotation(i)
		} else {
			i = rl_rotation(i)
		}
	} else {
		if (lh - rh) == 2 {
			if get_height(nodes[nodes[i]["left"]]["left"]) > get_height(nodes[nodes[i]["left"]]["right"]) {
				i = right_rotation(i)
			} else {
				i = lr_rotation(i)
			}
		}
	}
	update_height(i)
	return i
}

func inorder(i int) string {
	if i == int(NIL.Int64()) {
		return ""
	}
	var left string = inorder(nodes[i]["left"])
	_ = left
	var right string = inorder(nodes[i]["right"])
	_ = right
	var res string = fmt.Sprint(nodes[i]["data"])
	_ = res
	if left != "" {
		res = ((left + " ") + res)
	}
	if right != "" {
		res = ((res + " ") + right)
	}
	return res
}

func mochiMain() {
	nodes = []map[string]int{}
	var root *big.Int = NIL
	_ = root
	root = big.NewInt(int64(insert_node(int(root.Int64()), 4)))
	root = big.NewInt(int64(insert_node(int(root.Int64()), 2)))
	root = big.NewInt(int64(insert_node(int(root.Int64()), 3)))
	fmt.Println(inorder(int(root.Int64())))
	fmt.Println(fmt.Sprint(get_height(int(root.Int64()))))
	root = big.NewInt(int64(del_node(int(root.Int64()), 3)))
	fmt.Println(inorder(int(root.Int64())))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		NIL = big.NewInt(int64((0 - 1)))
		nodes = []map[string]int{}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
