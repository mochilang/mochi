//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-07 08:27:18 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Tree interface{ isTree() }
type Leaf struct {
}

func (Leaf) isTree() {}

type Node struct {
	Left  any `json:"left"`
	Value int `json:"value"`
	Right any `json:"right"`
}

func (Node) isTree() {}

func merge_two_binary_trees(t1 any, t2 any) any {
	return func() any {
		switch uv := t1.(type) {
		case Leaf:
			return t2
		case Node:
			l1 := uv.Left
			v1 := uv.Value
			r1 := uv.Right
			return func() any {
				switch uv := t2.(type) {
				case Leaf:
					return t1
				case Node:
					l2 := uv.Left
					v2 := uv.Value
					r2 := uv.Right
					return Node{
						Left:  merge_two_binary_trees(l1, l2),
						Value: (v1 + v2),
						Right: merge_two_binary_trees(r1, r2),
					}
				default:
					var z any
					return z
				}
			}()
		default:
			var z any
			return z
		}
	}()
}

func is_leaf(t any) bool {
	return func() bool {
		switch t.(type) {
		case Leaf:
			return true
		default:
			return false
		}
	}()
}

func get_left(t any) any {
	return func() any {
		switch uv := t.(type) {
		case Node:
			l := uv.Left
			_ = uv.Value
			_ = uv.Right
			return l
		default:
			return Leaf{}
		}
	}()
}

func get_right(t any) any {
	return func() any {
		switch uv := t.(type) {
		case Node:
			_ = uv.Left
			_ = uv.Value
			r := uv.Right
			return r
		default:
			return Leaf{}
		}
	}()
}

func get_value(t any) int {
	return int(func() int {
		switch uv := t.(type) {
		case Node:
			_ = uv.Left
			v := uv.Value
			_ = uv.Right
			return v
		default:
			return 0
		}
	}())
}

func print_preorder(t any) {
	if !is_leaf(t) {
		var v int = get_value(t)
		_ = v
		var l any = get_left(t)
		_ = l
		var r any = get_right(t)
		_ = r
		fmt.Println(v)
		print_preorder(l)
		print_preorder(r)
	}
}

var tree1 Node

var tree2 Node

var merged_tree any

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		tree1 = Node{
			Left: Node{
				Left: Node{
					Left:  Leaf{},
					Value: 4,
					Right: Leaf{},
				},
				Value: 2,
				Right: Leaf{},
			},
			Value: 1,
			Right: Node{
				Left:  Leaf{},
				Value: 3,
				Right: Leaf{},
			},
		}
		tree2 = Node{
			Left: Node{
				Left:  Leaf{},
				Value: 4,
				Right: Node{
					Left:  Leaf{},
					Value: 9,
					Right: Leaf{},
				},
			},
			Value: 2,
			Right: Node{
				Left:  Leaf{},
				Value: 6,
				Right: Node{
					Left:  Leaf{},
					Value: 5,
					Right: Leaf{},
				},
			},
		}
		fmt.Println("Tree1 is:")
		print_preorder(tree1)
		fmt.Println("Tree2 is:")
		print_preorder(tree2)
		merged_tree = merge_two_binary_trees(tree1, tree2)
		fmt.Println("Merged Tree is:")
		print_preorder(merged_tree)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
