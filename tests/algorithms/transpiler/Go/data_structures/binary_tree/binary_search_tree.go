//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 23:21:23 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func create_node(value int) []any {
	return []any{value, nil, nil}
}

func insert(node []any, value int) []any {
	if reflect.DeepEqual(node, nil) {
		return create_node(value)
	}
	if value < node[0].(int) {
		node[1] = insert(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(node[1]), value)
	} else {
		if value > node[0] {
			node[2] = insert(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(node[2]), value)
		}
	}
	return func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node)
}

func search(node []any, value int) bool {
	if reflect.DeepEqual(node, nil) {
		return false
	}
	if value == node[0].(int) {
		return true
	}
	if value < node[0].(int) {
		return search(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(node[1]), value)
	}
	return search(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node[2]), value)
}

func inorder(node []any, acc []int) []int {
	if reflect.DeepEqual(node, nil) {
		return acc
	}
	var left_acc []int = inorder(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node[1]), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(acc))
	_ = left_acc
	var with_node []any = append(left_acc, node[0].(int))
	_ = with_node
	_ = with_node
	return inorder(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node[2]), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(with_node))
}

func find_min(node []any) int {
	var current []any = node
	_ = current
	for current[1] != nil {
		current = func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(current[1])
	}
	return current[0].(int)
}

func find_max(node []any) int {
	var current []any = node
	_ = current
	for current[2] != nil {
		current = func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(current[2])
	}
	return current[0].(int)
}

func delete(node []any, value int) []any {
	if reflect.DeepEqual(node, nil) {
		return nil
	}
	if value < node[0].(int) {
		node[1] = delete(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(node[1]), value)
	} else {
		if value > node[0] {
			node[2] = delete(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(node[2]), value)
		} else {
			if reflect.DeepEqual(node[1], nil) {
				return func(v any) []any {
					if v == nil {
						return nil
					}
					if arr, ok := v.([]any); ok {
						return arr
					}
					rv := reflect.ValueOf(v)
					if rv.Kind() != reflect.Slice {
						return v.([]any)
					}
					n := rv.Len()
					out := make([]any, n)
					for i := 0; i < n; i++ {
						out[i] = rv.Index(i).Interface()
					}
					return out
				}(node[2])
			}
			if reflect.DeepEqual(node[2], nil) {
				return func(v any) []any {
					if v == nil {
						return nil
					}
					if arr, ok := v.([]any); ok {
						return arr
					}
					rv := reflect.ValueOf(v)
					if rv.Kind() != reflect.Slice {
						return v.([]any)
					}
					n := rv.Len()
					out := make([]any, n)
					for i := 0; i < n; i++ {
						out[i] = rv.Index(i).Interface()
					}
					return out
				}(node[1])
			}
			var min_val int = find_min(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(node[2]))
			_ = min_val
			node[0] = min_val
			node[2] = delete(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(node[2]), min_val)
		}
	}
	return func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node)
}

func mochiMain() {
	var root []any = nil
	_ = root
	var nums []int = []int{8, 3, 6, 1, 10, 14, 13, 4, 7}
	_ = nums
	for _, v := range nums {
		root = insert(root, v)
	}
	fmt.Println(fmt.Sprint(inorder(root, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{}))))
	fmt.Println(search(root, 6))
	fmt.Println(search(root, 20))
	fmt.Println(find_min(root))
	fmt.Println(find_max(root))
	root = delete(root, 6)
	fmt.Println(fmt.Sprint(inorder(root, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{}))))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
