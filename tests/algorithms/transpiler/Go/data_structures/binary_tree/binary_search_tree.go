//go:build ignore

// Generated by Mochi v0.10.71 on 2025-08-24 15:47:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var __name__ string = "__main__"

func create_node(value int) []any {
	return []any{value, nil, nil}
}

func insert(node []any, value int) []any {
	if reflect.DeepEqual(node, nil) {
		return create_node(value)
	}
	if value < _index(node, 0) {
		_setIndex(node, 1, insert(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(_index(node, 1)), value))
	} else {
		if value > _index(node, 0) {
			_setIndex(node, 2, insert(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(_index(node, 2)), value))
		}
	}
	return func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node)
}

func search(node []any, value int) bool {
	if reflect.DeepEqual(node, nil) {
		return false
	}
	if value == _index(node, 0) {
		return true
	}
	if value < _index(node, 0) {
		return search(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(_index(node, 1)), value)
	}
	return search(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(_index(node, 2)), value)
}

func inorder(node []any, acc []int) []int {
	if reflect.DeepEqual(node, nil) {
		return acc
	}
	var left_acc []int = inorder(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(_index(node, 1)), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(acc))
	_ = left_acc
	var with_node []any = append(left_acc, _index(node, 0))
	_ = with_node
	_ = with_node
	return inorder(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(_index(node, 2)), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(with_node))
}

func find_min(node []any) int {
	var current []any = node
	_ = current
	for _index(current, 1) != nil {
		current = _index(current, 1)
	}
	return _index(current, 0)
}

func find_max(node []any) int {
	var current []any = node
	_ = current
	for _index(current, 2) != nil {
		current = _index(current, 2)
	}
	return _index(current, 0)
}

func delete(node []any, value int) []any {
	if reflect.DeepEqual(node, nil) {
		return nil
	}
	if value < _index(node, 0) {
		_setIndex(node, 1, delete(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(_index(node, 1)), value))
	} else {
		if value > _index(node, 0) {
			_setIndex(node, 2, delete(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(_index(node, 2)), value))
		} else {
			if reflect.DeepEqual(_index(node, 1), nil) {
				return func(v any) []any {
					if v == nil {
						return nil
					}
					if arr, ok := v.([]any); ok {
						return arr
					}
					rv := reflect.ValueOf(v)
					if rv.Kind() != reflect.Slice {
						return v.([]any)
					}
					n := rv.Len()
					out := make([]any, n)
					for i := 0; i < n; i++ {
						out[i] = rv.Index(i).Interface()
					}
					return out
				}(_index(node, 2))
			}
			if reflect.DeepEqual(_index(node, 2), nil) {
				return func(v any) []any {
					if v == nil {
						return nil
					}
					if arr, ok := v.([]any); ok {
						return arr
					}
					rv := reflect.ValueOf(v)
					if rv.Kind() != reflect.Slice {
						return v.([]any)
					}
					n := rv.Len()
					out := make([]any, n)
					for i := 0; i < n; i++ {
						out[i] = rv.Index(i).Interface()
					}
					return out
				}(_index(node, 1))
			}
			var min_val int = find_min(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(_index(node, 2)))
			_ = min_val
			_setIndex(node, 0, min_val)
			_setIndex(node, 2, delete(func(v any) []any {
				if v == nil {
					return nil
				}
				if arr, ok := v.([]any); ok {
					return arr
				}
				rv := reflect.ValueOf(v)
				if rv.Kind() != reflect.Slice {
					return v.([]any)
				}
				n := rv.Len()
				out := make([]any, n)
				for i := 0; i < n; i++ {
					out[i] = rv.Index(i).Interface()
				}
				return out
			}(_index(node, 2)), min_val))
		}
	}
	return func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(node)
}

func mochiMain() {
	var root []any = nil
	_ = root
	var nums []int = []int{8, 3, 6, 1, 10, 14, 13, 4, 7}
	_ = nums
	for _, v := range nums {
		_ = v
		root = insert(root, v)
	}
	fmt.Println(fmt.Sprint(inorder(root, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{}))))
	fmt.Println(search(root, 6))
	fmt.Println(search(root, 20))
	fmt.Println(find_min(root))
	fmt.Println(find_max(root))
	root = delete(root, 6)
	fmt.Println(fmt.Sprint(inorder(root, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{}))))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
