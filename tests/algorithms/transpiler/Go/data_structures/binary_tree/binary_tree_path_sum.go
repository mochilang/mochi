//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-07 08:27:00 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Tree interface{ isTree() }
type Empty struct {
}

func (Empty) isTree() {}

type Node struct {
	Left  any `json:"left"`
	Value int `json:"value"`
	Right any `json:"right"`
}

func (Node) isTree() {}

func dfs(node any, target int, current int) int {
	return func() int {
		switch uv := node.(type) {
		case Empty:
			return 0
		case Node:
			l := uv.Left
			v := uv.Value
			r := uv.Right
			return ((func() int {
				if (current + v) == target {
					return 1
				} else {
					return 0
				}
			}() + dfs(l, target, (current+v))) + dfs(r, target, (current+v)))
		default:
			var z int
			return z
		}
	}()
}

func path_sum(node any, target int) int {
	return func() int {
		switch uv := node.(type) {
		case Empty:
			return 0
		case Node:
			l := uv.Left
			_ = uv.Value
			r := uv.Right
			return ((dfs(node, target, 0) + path_sum(l, target)) + path_sum(r, target))
		default:
			var z int
			return z
		}
	}()
}

func sample_tree_one() any {
	return Node{
		Left: Node{
			Left: Node{
				Left: Node{
					Left:  Empty{},
					Value: 3,
					Right: Empty{},
				},
				Value: 3,
				Right: Node{
					Left:  Empty{},
					Value: (0 - 2),
					Right: Empty{},
				},
			},
			Value: 5,
			Right: Node{
				Left:  Empty{},
				Value: 2,
				Right: Node{
					Left:  Empty{},
					Value: 1,
					Right: Empty{},
				},
			},
		},
		Value: 10,
		Right: Node{
			Left:  Empty{},
			Value: (0 - 3),
			Right: Node{
				Left:  Empty{},
				Value: 11,
				Right: Empty{},
			},
		},
	}
}

func sample_tree_two() any {
	return Node{
		Left: Node{
			Left: Node{
				Left: Node{
					Left:  Empty{},
					Value: 3,
					Right: Empty{},
				},
				Value: 3,
				Right: Node{
					Left:  Empty{},
					Value: (0 - 2),
					Right: Empty{},
				},
			},
			Value: 5,
			Right: Node{
				Left:  Empty{},
				Value: 2,
				Right: Node{
					Left:  Empty{},
					Value: 1,
					Right: Empty{},
				},
			},
		},
		Value: 10,
		Right: Node{
			Left:  Empty{},
			Value: (0 - 3),
			Right: Node{
				Left:  Empty{},
				Value: 10,
				Right: Empty{},
			},
		},
	}
}

func mochiMain() {
	var tree1 any = sample_tree_one()
	_ = tree1
	fmt.Println(path_sum(tree1, 8))
	fmt.Println(path_sum(tree1, 7))
	var tree2 any = sample_tree_two()
	_ = tree2
	fmt.Println(path_sum(tree2, 8))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
