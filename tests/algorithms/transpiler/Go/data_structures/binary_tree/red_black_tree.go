//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 16:37:10 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

var LABEL int

var COLOR int

var PARENT int

var LEFT int

var RIGHT int

var NEG_ONE int

type RBTree struct {
	Nodes [][]int `json:"nodes"`
	Root  int     `json:"root"`
}

func make_tree() RBTree {
	return RBTree{
		Nodes: [][]int{},
		Root:  (0 - 1),
	}
}

func rotate_left(t RBTree, x int) RBTree {
	var nodes [][]int = t.Nodes
	_ = nodes
	var y int = _index(_index(nodes, x), RIGHT)
	_ = y
	var yLeft int = _index(_index(nodes, y), LEFT)
	_ = yLeft
	_setIndex(_index(nodes, x), RIGHT, yLeft)
	if yLeft != NEG_ONE {
		_setIndex(_index(nodes, yLeft), PARENT, x)
	}
	var xParent int = _index(_index(nodes, x), PARENT)
	_ = xParent
	_setIndex(_index(nodes, y), PARENT, xParent)
	if xParent == NEG_ONE {
		t.Root = y
	} else {
		if x == int(_index(_index(nodes, xParent), LEFT)) {
			_setIndex(_index(nodes, xParent), LEFT, y)
		} else {
			_setIndex(_index(nodes, xParent), RIGHT, y)
		}
	}
	_setIndex(_index(nodes, y), LEFT, x)
	_setIndex(_index(nodes, x), PARENT, y)
	t.Nodes = nodes
	return t
}

func rotate_right(t RBTree, x int) RBTree {
	var nodes [][]int = t.Nodes
	_ = nodes
	var y int = _index(_index(nodes, x), LEFT)
	_ = y
	var yRight int = _index(_index(nodes, y), RIGHT)
	_ = yRight
	_setIndex(_index(nodes, x), LEFT, yRight)
	if yRight != NEG_ONE {
		_setIndex(_index(nodes, yRight), PARENT, x)
	}
	var xParent int = _index(_index(nodes, x), PARENT)
	_ = xParent
	_setIndex(_index(nodes, y), PARENT, xParent)
	if xParent == NEG_ONE {
		t.Root = y
	} else {
		if x == int(_index(_index(nodes, xParent), RIGHT)) {
			_setIndex(_index(nodes, xParent), RIGHT, y)
		} else {
			_setIndex(_index(nodes, xParent), LEFT, y)
		}
	}
	_setIndex(_index(nodes, y), RIGHT, x)
	_setIndex(_index(nodes, x), PARENT, y)
	t.Nodes = nodes
	return t
}

func insert_fix(t RBTree, z int) RBTree {
	var nodes [][]int = t.Nodes
	_ = nodes
	for (z != t.Root) && (int(_index(_index(nodes, _index(_index(nodes, z), PARENT)), COLOR)) == 1) {
		if int(_index(_index(nodes, z), PARENT)) == int(_index(_index(nodes, _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)), LEFT)) {
			var y int = _index(_index(nodes, _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)), RIGHT)
			_ = y
			if (y != NEG_ONE) && (int(_index(_index(nodes, y), COLOR)) == 1) {
				_setIndex(_index(nodes, _index(_index(nodes, z), PARENT)), COLOR, 0)
				_setIndex(_index(nodes, y), COLOR, 0)
				var gp int = _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)
				_ = gp
				_setIndex(_index(nodes, gp), COLOR, 1)
				z = gp
			} else {
				if z == int(_index(_index(nodes, _index(_index(nodes, z), PARENT)), RIGHT)) {
					z = _index(_index(nodes, z), PARENT)
					t.Nodes = nodes
					t = rotate_left(t, z)
					nodes = t.Nodes
				}
				_setIndex(_index(nodes, _index(_index(nodes, z), PARENT)), COLOR, 0)
				var gp int = _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)
				_ = gp
				_setIndex(_index(nodes, gp), COLOR, 1)
				t.Nodes = nodes
				t = rotate_right(t, gp)
				nodes = t.Nodes
			}
		} else {
			var y int = _index(_index(nodes, _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)), LEFT)
			_ = y
			if (y != NEG_ONE) && (int(_index(_index(nodes, y), COLOR)) == 1) {
				_setIndex(_index(nodes, _index(_index(nodes, z), PARENT)), COLOR, 0)
				_setIndex(_index(nodes, y), COLOR, 0)
				var gp int = _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)
				_ = gp
				_setIndex(_index(nodes, gp), COLOR, 1)
				z = gp
			} else {
				if z == int(_index(_index(nodes, _index(_index(nodes, z), PARENT)), LEFT)) {
					z = _index(_index(nodes, z), PARENT)
					t.Nodes = nodes
					t = rotate_right(t, z)
					nodes = t.Nodes
				}
				_setIndex(_index(nodes, _index(_index(nodes, z), PARENT)), COLOR, 0)
				var gp int = _index(_index(nodes, _index(_index(nodes, z), PARENT)), PARENT)
				_ = gp
				_setIndex(_index(nodes, gp), COLOR, 1)
				t.Nodes = nodes
				t = rotate_left(t, gp)
				nodes = t.Nodes
			}
		}
	}
	nodes = t.Nodes
	_setIndex(_index(nodes, t.Root), COLOR, 0)
	t.Nodes = nodes
	return t
}

func tree_insert(t RBTree, v int) RBTree {
	var nodes [][]int = t.Nodes
	_ = nodes
	var node []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(v), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1)), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}
	_ = node
	nodes = append(nodes, node)
	idx := (len(nodes) - 1)
	_ = idx
	var y int = NEG_ONE
	_ = y
	var x int = t.Root
	_ = x
	for x != NEG_ONE {
		y = x
		if v < int(_index(_index(nodes, x), LABEL)) {
			x = _index(_index(nodes, x), LEFT)
		} else {
			x = _index(_index(nodes, x), RIGHT)
		}
	}
	_setIndex(_index(nodes, idx), PARENT, y)
	if y == NEG_ONE {
		t.Root = idx
	} else {
		if v < int(_index(_index(nodes, y), LABEL)) {
			_setIndex(_index(nodes, y), LEFT, idx)
		} else {
			_setIndex(_index(nodes, y), RIGHT, idx)
		}
	}
	t.Nodes = nodes
	t = insert_fix(t, idx)
	return t
}

func inorder(t RBTree, x int, acc []int) []int {
	if x == NEG_ONE {
		return acc
	}
	acc = inorder(t, _index(_index(t.Nodes, x), LEFT), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(acc))
	acc = append(acc, _index(_index(t.Nodes, x), LABEL))
	acc = inorder(t, _index(_index(t.Nodes, x), RIGHT), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(acc))
	return acc
}

func mochiMain() {
	var t RBTree = make_tree()
	_ = t
	var values []int = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(10), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(20), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(30), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(15), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(25), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(5), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(1)}
	_ = values
	var i int = 0
	_ = i
	for i < len(values) {
		t = tree_insert(t, _index(values, i))
		i = (i + 1)
	}
	var res []int = []int{}
	_ = res
	res = inorder(t, t.Root, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(res))
	fmt.Println(fmt.Sprint(res))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		LABEL = 0
		COLOR = 1
		PARENT = 2
		LEFT = 3
		RIGHT = 4
		NEG_ONE = (0 - 1)
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
