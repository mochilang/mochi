//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-24 17:04:55 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var __name__ string = "__main__"

type Node struct {
	Start int `json:"start"`
	End   int `json:"end"`
	Val   int `json:"val"`
	Mid   int `json:"mid"`
	Left  int `json:"left"`
	Right int `json:"right"`
}

type BuildResult struct {
	Nodes []Node `json:"nodes"`
	IDx   int    `json:"idx"`
}

type SegmentTree struct {
	Arr []int `json:"arr"`
	Op  int   `json:"op"`
}

func combine(a int, b int, op int) int {
	if op == 0 {
		return (a + b)
	}
	if op == 1 {
		if a > b {
			return a
		}
		return b
	}
	if a < b {
		return a
	}
	return b
}

func build_tree(nodes []Node, arr []int, start int, end int, op int) BuildResult {
	if start == end {
		var node Node = Node{
			Start: start,
			End:   end,
			Val:   _index(arr, start),
			Mid:   start,
			Left:  (0 - 1),
			Right: (0 - 1),
		}
		_ = node
		var new_nodes []Node = append(nodes, node)
		_ = new_nodes
		_ = new_nodes
		return BuildResult{
			Nodes: new_nodes,
			IDx:   (len(new_nodes) - 1),
		}
	}
	var mid int = ((start + end) / 2)
	_ = mid
	var left_res BuildResult = build_tree(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(nodes), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(arr), start, mid, op)
	_ = left_res
	var right_res BuildResult = build_tree(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(left_res.Nodes), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(arr), (mid + 1), end, op)
	_ = right_res
	var left_node Node = _index(right_res.Nodes, left_res.IDx)
	_ = left_node
	var right_node Node = _index(right_res.Nodes, right_res.IDx)
	_ = right_node
	var val int = combine(left_node.Val, right_node.Val, op)
	_ = val
	var parent Node = Node{
		Start: start,
		End:   end,
		Val:   val,
		Mid:   mid,
		Left:  left_res.IDx,
		Right: right_res.IDx,
	}
	_ = parent
	var new_nodes []Node = append(right_res.Nodes, parent)
	_ = new_nodes
	_ = new_nodes
	return BuildResult{
		Nodes: new_nodes,
		IDx:   (len(new_nodes) - 1),
	}
}

func new_segment_tree(collection []int, op int) SegmentTree {
	return SegmentTree{
		Arr: collection,
		Op:  op,
	}
}

func update(tree SegmentTree, i int, val int) SegmentTree {
	var new_arr []int = []int{}
	_ = new_arr
	var idx int = 0
	_ = idx
	for idx < len(tree.Arr) {
		if idx == i {
			new_arr = append(new_arr, val)
		} else {
			new_arr = append(new_arr, _index(tree.Arr, idx))
		}
		idx = (idx + 1)
	}
	return SegmentTree{
		Arr: new_arr,
		Op:  tree.Op,
	}
}

func query_range(tree SegmentTree, i int, j int) int {
	var result int = _index(tree.Arr, i)
	_ = result
	var idx int = (i + 1)
	_ = idx
	for idx <= j {
		result = combine(result, _index(tree.Arr, idx), tree.Op)
		idx = (idx + 1)
	}
	return result
}

func traverse(tree SegmentTree) []Node {
	if len(tree.Arr) == 0 {
		return func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}([]Node{})
	}
	var res BuildResult = build_tree(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}([]Node{}), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(tree.Arr), 0, (len(tree.Arr) - 1), tree.Op)
	_ = res
	_ = res
	return res.Nodes
}

func node_to_string(node Node) string {
	return (((((("SegmentTreeNode(start=" + fmt.Sprint(node.Start)) + ", end=") + fmt.Sprint(node.End)) + ", val=") + fmt.Sprint(node.Val)) + ")")
}

func print_traverse(tree SegmentTree) {
	var nodes []Node = traverse(tree)
	_ = nodes
	var i int = 0
	_ = i
	for i < len(nodes) {
		fmt.Println(node_to_string(_index(nodes, i)))
		i = (i + 1)
	}
	fmt.Println("")
}

var arr []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		arr = []int{2, 1, 5, 3, 4}
		for _, op := range []int{0, 1, 2} {
			_ = op
			fmt.Println("**************************************************")
			var tree SegmentTree = new_segment_tree(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(arr), op)
			_ = tree
			print_traverse(tree)
			tree = update(tree, 1, 5)
			print_traverse(tree)
			fmt.Println(query_range(tree, 3, 4))
			fmt.Println(query_range(tree, 2, 2))
			fmt.Println(query_range(tree, 1, 3))
			fmt.Println("")
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
