//go:build ignore

// Generated by Mochi v0.10.61 on 2025-08-08 16:45:01 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

type Node struct {
	Start int `json:"start"`
	End   int `json:"end"`
	Val   int `json:"val"`
	Mid   int `json:"mid"`
	Left  int `json:"left"`
	Right int `json:"right"`
}

type BuildResult struct {
	Nodes []Node `json:"nodes"`
	IDx   int    `json:"idx"`
}

type SegmentTree struct {
	Arr []int `json:"arr"`
	Op  int   `json:"op"`
}

func combine(a int, b int, op int) int {
	if op == 0 {
		return (a + b)
	}
	if op == 1 {
		if a > b {
			return a
		}
		return b
	}
	if a < b {
		return a
	}
	return b
}

func build_tree(nodes []Node, arr []int, start int, end int, op int) BuildResult {
	if start == end {
		node := Node{
			Start: start,
			End:   end,
			Val:   _index(arr, start),
			Mid:   start,
			Left:  (0 - 1),
			Right: (0 - 1),
		}
		_ = node
		new_nodes := append(nodes, Node(node))
		_ = new_nodes
		_ = new_nodes
		return BuildResult{
			Nodes: new_nodes,
			IDx:   (_len(new_nodes) - 1),
		}
	}
	mid := ((start + end) / 2)
	_ = mid
	left_res := build_tree(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(nodes), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(arr), start, mid, op)
	_ = left_res
	right_res := build_tree(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(BuildResult(left_res).Nodes)), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(arr), (mid + 1), end, op)
	_ = right_res
	left_node := _index(BuildResult(right_res).Nodes, BuildResult(left_res).IDx)
	_ = left_node
	right_node := _index(BuildResult(right_res).Nodes, BuildResult(right_res).IDx)
	_ = right_node
	val := combine(int(Node(left_node).Val), int(Node(right_node).Val), op)
	_ = val
	parent := Node{
		Start: start,
		End:   end,
		Val:   val,
		Mid:   mid,
		Left:  BuildResult(left_res).IDx,
		Right: BuildResult(right_res).IDx,
	}
	_ = parent
	new_nodes := append(BuildResult(right_res).Nodes, parent)
	_ = new_nodes
	_ = new_nodes
	return BuildResult{
		Nodes: new_nodes,
		IDx:   (_len(new_nodes) - 1),
	}
}

func new_segment_tree(collection []int, op int) SegmentTree {
	return SegmentTree{
		Arr: collection,
		Op:  op,
	}
}

func update(tree SegmentTree, i int, val int) SegmentTree {
	var new_arr []int = []int{}
	_ = new_arr
	var idx int = 0
	_ = idx
	for idx < len(tree.Arr) {
		if idx == i {
			new_arr = append(new_arr, val)
		} else {
			new_arr = append(new_arr, _index(tree.Arr, idx))
		}
		idx = (idx + 1)
	}
	return SegmentTree{
		Arr: new_arr,
		Op:  tree.Op,
	}
}

func query_range(tree SegmentTree, i int, j int) int {
	var result int = _index(tree.Arr, i)
	_ = result
	var idx int = (i + 1)
	_ = idx
	for idx <= j {
		result = combine(result, _index(tree.Arr, idx), tree.Op)
		idx = (idx + 1)
	}
	return result
}

func traverse(tree SegmentTree) []Node {
	if len(tree.Arr) == 0 {
		return func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}([]Node{})
	}
	res := build_tree(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}([]Node{}), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(tree.Arr), 0, (len(tree.Arr) - 1), tree.Op)
	_ = res
	_ = res
	return func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(BuildResult(res).Nodes)
}

func node_to_string(node Node) string {
	return (((((("SegmentTreeNode(start=" + fmt.Sprint(node.Start)) + ", end=") + fmt.Sprint(node.End)) + ", val=") + fmt.Sprint(node.Val)) + ")")
}

func print_traverse(tree SegmentTree) {
	nodes := traverse(tree)
	_ = nodes
	var i int = 0
	_ = i
	for i < _len(nodes) {
		fmt.Println(node_to_string(_index(func(v any) []any {
			if v == nil {
				return nil
			}
			if arr, ok := v.([]any); ok {
				return arr
			}
			rv := reflect.ValueOf(v)
			if rv.Kind() != reflect.Slice {
				return v.([]any)
			}
			n := rv.Len()
			out := make([]any, n)
			for i := 0; i < n; i++ {
				out[i] = rv.Index(i).Interface()
			}
			return out
		}(nodes), i).(Node)))
		i = (i + 1)
	}
	fmt.Println("")
}

var arr []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		arr = []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(5), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(3), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(4)}
		for _, op := range []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(0), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(1), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(2)} {
			fmt.Println("**************************************************")
			var tree SegmentTree = new_segment_tree(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(arr), op)
			_ = tree
			print_traverse(tree)
			tree = update(tree, 1, 5)
			print_traverse(tree)
			fmt.Println(query_range(tree, 3, 4))
			fmt.Println(query_range(tree, 2, 2))
			fmt.Println(query_range(tree, 1, 3))
			fmt.Println("")
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
