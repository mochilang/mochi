//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 22:18:06 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func pow2(n int) int {
	var result int = 1
	_ = result
	var i int = 0
	_ = i
	for i < n {
		result = (result * 2)
		i = (i + 1)
	}
	return result
}

func int_log2(n int) int {
	var v int = n
	_ = v
	var res int = 0
	_ = res
	for v > 1 {
		v = (v / 2)
		res = (res + 1)
	}
	return res
}

func build_sparse_table(number_list []int) [][]int {
	if len(number_list) == 0 {
		panic("empty number list not allowed")
	}
	var length int = len(number_list)
	_ = length
	var row int = (int_log2(length) + 1)
	_ = row
	var sparse_table [][]int = [][]int{}
	_ = sparse_table
	var j int = 0
	_ = j
	for j < row {
		var inner []int = []int{}
		_ = inner
		var i int = 0
		_ = i
		for i < length {
			inner = append(inner, 0)
			i = (i + 1)
		}
		sparse_table = append(sparse_table, inner)
		j = (j + 1)
	}
	var i int = 0
	_ = i
	for i < length {
		sparse_table[0][i] = number_list[i]
		i = (i + 1)
	}
	j = 1
	for pow2(j) <= length {
		i = 0
		for ((i + pow2(j)) - 1) < length {
			var left int = sparse_table[(j - 1)][(i + pow2((j - 1)))]
			_ = left
			var right int = sparse_table[(j - 1)][i]
			_ = right
			if left < right {
				sparse_table[j][i] = left
			} else {
				sparse_table[j][i] = right
			}
			i = (i + 1)
		}
		j = (j + 1)
	}
	return sparse_table
}

func query(sparse_table [][]int, left_bound int, right_bound int) int {
	if (left_bound < 0) || (right_bound >= len(sparse_table[0])) {
		panic("list index out of range")
	}
	var interval int = ((right_bound - left_bound) + 1)
	_ = interval
	var j int = int_log2(interval)
	_ = j
	var val1 int = sparse_table[j][((right_bound - pow2(j)) + 1)]
	_ = val1
	var val2 int = sparse_table[j][left_bound]
	_ = val2
	if val1 < val2 {
		return val1
	}
	return val2
}

var st1 [][]int

var st2 [][]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		st1 = build_sparse_table(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{8, 1, 0, 3, 4, 9, 3}))
		fmt.Println(fmt.Sprint(st1))
		st2 = build_sparse_table(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{3, 1, 9}))
		fmt.Println(fmt.Sprint(st2))
		fmt.Println(fmt.Sprint(query(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(st1), 0, 4)))
		fmt.Println(fmt.Sprint(query(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(st1), 4, 6)))
		fmt.Println(fmt.Sprint(query(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(st2), 2, 2)))
		fmt.Println(fmt.Sprint(query(func(v any) [][]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return [][]int{}
				}
				out := make([][]int, len(arr))
				for i, x := range arr {
					out[i] = func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(x)
				}
				return out
			}
			return v.([][]int)
		}(st2), 0, 1)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
