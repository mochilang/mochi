//go:build ignore

// Generated by Mochi v0.10.59 on 2025-08-06 21:47:58 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func sort_triplet(a int, b int, c int) []int {
	var x int = a
	_ = x
	var y int = b
	_ = y
	var z int = c
	_ = z
	if x > y {
		var t int = x
		_ = t
		x = y
		y = t
	}
	if y > z {
		var t int = y
		_ = t
		y = z
		z = t
	}
	if x > y {
		var t int = x
		_ = t
		x = y
		y = t
	}
	return []int{x, y, z}
}

func contains_triplet(arr [][]int, target []int) bool {
	for i := 0; i < len(arr); i++ {
		var item []int = arr[i]
		_ = item
		var same bool = true
		_ = same
		for j := 0; j < len(target); j++ {
			if item[j] != target[j] {
				same = false
				break
			}
		}
		if same {
			return true
		}
	}
	return false
}

func contains_int(arr []int, value int) bool {
	for i := 0; i < len(arr); i++ {
		if arr[i] == value {
			return true
		}
	}
	return false
}

func find_triplets_with_0_sum(nums []int) [][]int {
	var n int = len(nums)
	_ = n
	var result [][]int = [][]int{}
	_ = result
	for i := 0; i < n; i++ {
		for j := (i + 1); j < n; j++ {
			for k := (j + 1); k < n; k++ {
				var a int = nums[i]
				_ = a
				var b int = nums[j]
				_ = b
				var c int = nums[k]
				_ = c
				if ((a + b) + c) == 0 {
					var trip []int = sort_triplet(a, b, c)
					_ = trip
					if !contains_triplet(func(v any) [][]int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([][]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return [][]int{}
							}
							out := make([][]int, len(arr))
							for i, x := range arr {
								out[i] = func(v any) []int {
									if v == nil {
										return nil
									}
									if vv, ok := v.([]int); ok {
										return vv
									}
									if arr, ok := v.([]any); ok {
										if len(arr) == 0 {
											return []int{}
										}
										out := make([]int, len(arr))
										for i, x := range arr {
											out[i] = x.(int)
										}
										return out
									}
									return v.([]int)
								}(x)
							}
							return out
						}
						return v.([][]int)
					}(result), func(v any) []int {
						if v == nil {
							return nil
						}
						if vv, ok := v.([]int); ok {
							return vv
						}
						if arr, ok := v.([]any); ok {
							if len(arr) == 0 {
								return []int{}
							}
							out := make([]int, len(arr))
							for i, x := range arr {
								out[i] = x.(int)
							}
							return out
						}
						return v.([]int)
					}(trip)) {
						result = append(result, trip)
					}
				}
			}
		}
	}
	return result
}

func find_triplets_with_0_sum_hashing(arr []int) [][]int {
	var target_sum int = 0
	_ = target_sum
	var output [][]int = [][]int{}
	_ = output
	for i := 0; i < len(arr); i++ {
		var seen []int = []int{}
		_ = seen
		var current_sum int = (target_sum - arr[i])
		_ = current_sum
		for j := (i + 1); j < len(arr); j++ {
			var other int = arr[j]
			_ = other
			var required int = (current_sum - other)
			_ = required
			if contains_int(func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(seen), required) {
				var trip []int = sort_triplet(arr[i], other, required)
				_ = trip
				if !contains_triplet(func(v any) [][]int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([][]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return [][]int{}
						}
						out := make([][]int, len(arr))
						for i, x := range arr {
							out[i] = func(v any) []int {
								if v == nil {
									return nil
								}
								if vv, ok := v.([]int); ok {
									return vv
								}
								if arr, ok := v.([]any); ok {
									if len(arr) == 0 {
										return []int{}
									}
									out := make([]int, len(arr))
									for i, x := range arr {
										out[i] = x.(int)
									}
									return out
								}
								return v.([]int)
							}(x)
						}
						return out
					}
					return v.([][]int)
				}(output), func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(trip)) {
					output = append(output, trip)
				}
			}
			seen = append(seen, other)
		}
	}
	return output
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{(0 - 1), 0, 1, 2, (0 - 1), (0 - 4)}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{0, 0, 0}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 2, 3, 0, (0 - 1), (0 - 2), (0 - 3)}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum_hashing(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{(0 - 1), 0, 1, 2, (0 - 1), (0 - 4)}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum_hashing(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum_hashing(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{0, 0, 0}))))
		fmt.Println(fmt.Sprint(find_triplets_with_0_sum_hashing(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]int{1, 2, 3, 0, (0 - 1), (0 - 2), (0 - 3)}))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
