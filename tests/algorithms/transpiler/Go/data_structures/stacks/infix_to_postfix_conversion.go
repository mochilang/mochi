//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:00:50 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

var PRECEDENCES map[string]int

var ASSOCIATIVITIES map[string]string

func precedence(ch string) int {
	if func() bool { _, ok := PRECEDENCES[ch]; return ok }() {
		return PRECEDENCES[ch]
	}
	return (0 - 1)
}

func associativity(ch string) string {
	if func() bool { _, ok := ASSOCIATIVITIES[ch]; return ok }() {
		return ASSOCIATIVITIES[ch]
	}
	return ""
}

func balanced_parentheses(expr string) bool {
	var count int = 0
	_ = count
	var i int = 0
	_ = i
	for i < len(expr) {
		var ch string = _substr(expr, i, (i + 1))
		_ = ch
		if ch == "(" {
			count = (count + 1)
		}
		if ch == ")" {
			count = (count - 1)
			if count < 0 {
				return false
			}
		}
		i = (i + 1)
	}
	return (count == 0)
}

func is_letter(ch string) bool {
	return ((("a" <= ch) && (ch <= "z")) || (("A" <= ch) && (ch <= "Z")))
}

func is_digit(ch string) bool {
	return (("0" <= ch) && (ch <= "9"))
}

func is_alnum(ch string) bool {
	return (is_letter(ch) || is_digit(ch))
}

func infix_to_postfix(expression string) string {
	if balanced_parentheses(expression) == false {
		panic("Mismatched parentheses")
	}
	var stack []string = []string{}
	_ = stack
	var postfix []string = []string{}
	_ = postfix
	var i int = 0
	_ = i
	for i < len(expression) {
		var ch string = _substr(expression, i, (i + 1))
		_ = ch
		if is_alnum(ch) {
			postfix = append(postfix, ch)
		} else {
			if ch == "(" {
				stack = append(stack, ch)
			} else {
				if ch == ")" {
					for (len(stack) > 0) && (_index(stack, (len(stack)-1)) != "(") {
						postfix = append(postfix, _index(stack, (len(stack)-1)))
						stack = _slice(stack, 0, (len(stack) - 1))
					}
					if len(stack) > 0 {
						stack = _slice(stack, 0, (len(stack) - 1))
					}
				} else {
					if ch == " " {
					} else {
						for {
							if len(stack) == 0 {
								stack = append(stack, ch)
								break
							}
							var cp int = precedence(ch)
							_ = cp
							var tp int = precedence(_index(stack, (len(stack) - 1)))
							_ = tp
							if cp > tp {
								stack = append(stack, ch)
								break
							}
							if cp < tp {
								postfix = append(postfix, _index(stack, (len(stack)-1)))
								stack = _slice(stack, 0, (len(stack) - 1))
								continue
							}
							if associativity(ch) == "RL" {
								stack = append(stack, ch)
								break
							}
							postfix = append(postfix, _index(stack, (len(stack)-1)))
							stack = _slice(stack, 0, (len(stack) - 1))
						}
					}
				}
			}
		}
		i = (i + 1)
	}
	for len(stack) > 0 {
		postfix = append(postfix, _index(stack, (len(stack)-1)))
		stack = _slice(stack, 0, (len(stack) - 1))
	}
	var res string = ""
	_ = res
	var j int = 0
	_ = j
	for j < len(postfix) {
		if j > 0 {
			res = (res + " ")
		}
		res = (res + _index(postfix, j))
		j = (j + 1)
	}
	return res
}

func mochiMain() {
	var expression string = "a+b*(c^d-e)^(f+g*h)-i"
	_ = expression
	fmt.Println(expression)
	fmt.Println(infix_to_postfix(expression))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PRECEDENCES = map[string]int{"+": 1, "-": 1, "*": 2, "/": 2, "^": 3}
		ASSOCIATIVITIES = map[string]string{"+": "LR", "-": "LR", "*": "LR", "/": "LR", "^": "RL"}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
