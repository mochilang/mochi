//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-25 00:06:08 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

func _concat[T any](a, b []T) []T {
	return append(append([]T{}, a...), b...)
}

var __name__ string = "__main__"

type Node struct {
	Point []float64 `json:"point"`
	Left  int       `json:"left"`
	Right int       `json:"right"`
}

type BuildResult struct {
	Index int    `json:"index"`
	Nodes []Node `json:"nodes"`
}

var seed int

func rand() int {
	seed = _modi(((seed * 1103515245) + 12345), 2147483648)
	return seed
}

func random() float64 {
	return (float64((1.0 * float64(rand()))) / float64(2147483648.0))
}

func hypercube_points(num_points int, cube_size float64, num_dimensions int) [][]float64 {
	var pts [][]float64 = [][]float64{}
	_ = pts
	var i int = 0
	_ = i
	for i < num_points {
		var p []float64 = []float64{}
		_ = p
		var j int = 0
		_ = j
		for j < num_dimensions {
			p = append(p, (cube_size * random()))
			j = (j + 1)
		}
		pts = append(pts, p)
		i = (i + 1)
	}
	return pts
}

func sort_points(points [][]float64, axis int) [][]float64 {
	var n int = len(points)
	_ = n
	var i int = 1
	_ = i
	for i < n {
		var key []float64 = _index(points, i)
		_ = key
		var j int = (i - 1)
		_ = j
		for (j >= 0) && (_index(_index(points, j), axis) > _index(key, axis)) {
			_setIndex(points, (j + 1), _index(points, j))
			j = (j - 1)
		}
		_setIndex(points, (j + 1), key)
		i = (i + 1)
	}
	return points
}

func sublist(arr [][]float64, start int, end int) [][]float64 {
	var res [][]float64 = [][]float64{}
	_ = res
	var i int = start
	_ = i
	for i < end {
		res = append(res, _index(arr, i))
		i = (i + 1)
	}
	return res
}

func shift_nodes(nodes []Node, offset int) []Node {
	var i int = 0
	_ = i
	for i < len(nodes) {
		if _index(nodes, i).Left != (0 - 1) {
			_tmp2 := _index(nodes, i)
			_ = _tmp2
			_tmp2.Left = (_index(nodes, i).Left + offset)
			_setIndex(nodes, i, _tmp2)
		}
		if _index(nodes, i).Right != (0 - 1) {
			_tmp3 := _index(nodes, i)
			_ = _tmp3
			_tmp3.Right = (_index(nodes, i).Right + offset)
			_setIndex(nodes, i, _tmp3)
		}
		i = (i + 1)
	}
	return nodes
}

func build_kdtree(points [][]float64, depth int) BuildResult {
	if len(points) == 0 {
		return BuildResult{
			Index: (0 - 1),
			Nodes: []Node{},
		}
	}
	var k int = len(_index(points, 0))
	_ = k
	var axis int = _modi(depth, k)
	_ = axis
	points = sort_points(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(points), axis)
	var median int = func() int {
		a := len(points)
		b := 2
		q := a / b
		r := a % b
		if (r != 0) && ((r < 0) != (b < 0)) {
			q--
		}
		return q
	}()
	_ = median
	var left_points [][]float64 = sublist(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(points), 0, median)
	_ = left_points
	var right_points [][]float64 = sublist(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(points), (median + 1), len(points))
	_ = right_points
	var left_res BuildResult = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(left_points), (depth + 1))
	_ = left_res
	var right_res BuildResult = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(right_points), (depth + 1))
	_ = right_res
	var offset int = (len(left_res.Nodes) + 1)
	_ = offset
	var shifted_right []Node = shift_nodes(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(right_res.Nodes), offset)
	_ = shifted_right
	var nodes []Node = left_res.Nodes
	_ = nodes
	var left_index int = left_res.Index
	_ = left_index
	var right_index int = func() int {
		if right_res.Index == (0 - 1) {
			return (0 - 1)
		} else {
			return (right_res.Index + offset)
		}
	}()
	_ = right_index
	nodes = append(nodes, Node{
		Point: _index(points, median),
		Left:  left_index,
		Right: right_index,
	})
	nodes = _concat(nodes, shifted_right)
	var root_index int = len(left_res.Nodes)
	_ = root_index
	_ = root_index
	return BuildResult{
		Index: root_index,
		Nodes: nodes,
	}
}

func square_distance(a []float64, b []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(a) {
		var diff float64 = (_index(a, i) - _index(b, i))
		_ = diff
		sum = (sum + (diff * diff))
		i = (i + 1)
	}
	return sum
}

type SearchResult struct {
	Point   []float64 `json:"point"`
	Dist    float64   `json:"dist"`
	Visited int       `json:"visited"`
}

func nearest_neighbour_search(tree []Node, root int, query_point []float64) SearchResult {
	var nearest_point []float64 = []float64{}
	_ = nearest_point
	var nearest_dist float64 = 0.0
	_ = nearest_dist
	var visited int = 0
	_ = visited
	var i int = 0
	_ = i
	for i < len(tree) {
		var node Node = _index(tree, i)
		_ = node
		var dist float64 = square_distance(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(query_point), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(node.Point))
		_ = dist
		visited = (visited + 1)
		if (visited == 1) || (dist < nearest_dist) {
			nearest_point = node.Point
			nearest_dist = dist
		}
		i = (i + 1)
	}
	return SearchResult{
		Point:   nearest_point,
		Dist:    nearest_dist,
		Visited: visited,
	}
}

func list_to_string(arr []float64) string {
	var s string = "["
	_ = s
	var i int = 0
	_ = i
	for i < len(arr) {
		s = (s + fmt.Sprint(_index(arr, i)))
		if i < (len(arr) - 1) {
			s = (s + ", ")
		}
		i = (i + 1)
	}
	return (s + "]")
}

func mochiMain() {
	var num_points int = 5000
	_ = num_points
	var cube_size float64 = 10.0
	_ = cube_size
	var num_dimensions int = 10
	_ = num_dimensions
	var pts [][]float64 = hypercube_points(num_points, cube_size, num_dimensions)
	_ = pts
	var build BuildResult = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(pts), 0)
	_ = build
	var root int = build.Index
	_ = root
	var tree []Node = build.Nodes
	_ = tree
	var query []float64 = []float64{}
	_ = query
	var i int = 0
	_ = i
	for i < num_dimensions {
		query = append(query, random())
		i = (i + 1)
	}
	var res SearchResult = nearest_neighbour_search(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(tree), root, func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(query))
	_ = res
	fmt.Println(("Query point: " + list_to_string(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(query))))
	fmt.Println(("Nearest point: " + list_to_string(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(res.Point))))
	fmt.Println(("Distance: " + fmt.Sprint(res.Dist)))
	fmt.Println(("Nodes visited: " + fmt.Sprint(res.Visited)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		seed = 1
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
