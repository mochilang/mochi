//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-25 00:06:14 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _floatEqual(a, b float64) bool {
	if a > b {
		return a-b < 1e-6
	}
	return b-a < 1e-6
}

var __name__ string = "__main__"

var INF float64

var seed int

func rand_float() float64 {
	seed = _modi(((seed * 1103515245) + 12345), 2147483648)
	return (float64(seed) / float64(2147483648.0))
}

func hypercube_points(num_points int, cube_size float64, num_dimensions int) [][]float64 {
	var pts [][]float64 = [][]float64{}
	_ = pts
	var i int = 0
	_ = i
	for i < num_points {
		var p []float64 = []float64{}
		_ = p
		var j int = 0
		_ = j
		for j < num_dimensions {
			var v float64 = (cube_size * rand_float())
			_ = v
			p = append(p, v)
			j = (j + 1)
		}
		pts = append(pts, p)
		i = (i + 1)
	}
	return pts
}

func build_kdtree(points [][]float64, depth int) [][]float64 {
	return points
}

func distance_sq(a []float64, b []float64) float64 {
	var sum float64 = 0.0
	_ = sum
	var i int = 0
	_ = i
	for i < len(a) {
		var d float64 = (_index(a, i) - _index(b, i))
		_ = d
		sum = (sum + (d * d))
		i = (i + 1)
	}
	return sum
}

func nearest_neighbour_search(points [][]float64, query []float64) map[string]float64 {
	if len(points) == 0 {
		return map[string]float64{"index": (0 - 1.0), "dist": INF, "visited": 0.0}
	}
	var nearest_idx int = 0
	_ = nearest_idx
	var nearest_dist float64 = INF
	_ = nearest_dist
	var visited int = 0
	_ = visited
	var i int = 0
	_ = i
	for i < len(points) {
		var d float64 = distance_sq(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(query), func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(_index(points, i)))
		_ = d
		visited = (visited + 1)
		if d < nearest_dist {
			nearest_dist = d
			nearest_idx = i
		}
		i = (i + 1)
	}
	return map[string]float64{"index": float64(nearest_idx), "dist": nearest_dist, "visited": float64(visited)}
}

func test_build_cases() {
	var empty_pts [][]float64 = [][]float64{}
	_ = empty_pts
	var tree0 [][]float64 = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(empty_pts), 0)
	_ = tree0
	if len(tree0) == 0 {
		fmt.Println("case1 true")
	} else {
		fmt.Println("case1 false")
	}
	var pts1 [][]float64 = hypercube_points(10, 10.0, 2)
	_ = pts1
	var tree1 [][]float64 = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(pts1), 2)
	_ = tree1
	if (len(tree1) > 0) && (len(_index(tree1, 0)) == 2) {
		fmt.Println("case2 true")
	} else {
		fmt.Println("case2 false")
	}
	var pts2 [][]float64 = hypercube_points(10, 10.0, 3)
	_ = pts2
	var tree2 [][]float64 = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(pts2), (0 - 2))
	_ = tree2
	if (len(tree2) > 0) && (len(_index(tree2, 0)) == 3) {
		fmt.Println("case3 true")
	} else {
		fmt.Println("case3 false")
	}
}

func test_search() {
	var pts [][]float64 = hypercube_points(10, 10.0, 2)
	_ = pts
	var tree [][]float64 = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(pts), 0)
	_ = tree
	var qp []float64 = func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(_index(func(v any) []any {
		if v == nil {
			return nil
		}
		if arr, ok := v.([]any); ok {
			return arr
		}
		rv := reflect.ValueOf(v)
		if rv.Kind() != reflect.Slice {
			return v.([]any)
		}
		n := rv.Len()
		out := make([]any, n)
		for i := 0; i < n; i++ {
			out[i] = rv.Index(i).Interface()
		}
		return out
	}(hypercube_points(1, 10.0, 2)), 0))
	_ = qp
	var res map[string]float64 = nearest_neighbour_search(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(tree), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(qp))
	if res == nil {
		res = map[string]float64{}
	}
	_ = res
	if (!_floatEqual(res["index"], (0-1.0)) && (res["dist"] >= 0.0)) && (res["visited"] > 0.0) {
		fmt.Println("search true")
	} else {
		fmt.Println("search false")
	}
}

func test_edge() {
	var empty_pts [][]float64 = [][]float64{}
	_ = empty_pts
	var tree [][]float64 = build_kdtree(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(empty_pts), 0)
	_ = tree
	var query []float64 = []float64{0.0, 0.0}
	_ = query
	var res map[string]float64 = nearest_neighbour_search(func(v any) [][]float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]float64{}
			}
			out := make([][]float64, len(arr))
			for i, x := range arr {
				out[i] = func(v any) []float64 {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]float64); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []float64{}
						}
						out := make([]float64, len(arr))
						for i, x := range arr {
							out[i] = x.(float64)
						}
						return out
					}
					return v.([]float64)
				}(x)
			}
			return out
		}
		return v.([][]float64)
	}(tree), func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(query))
	if res == nil {
		res = map[string]float64{}
	}
	_ = res
	if (_floatEqual(res["index"], (0-1.0)) && (res["dist"] > 100000000.0)) && _floatEqual(res["visited"], 0.0) {
		fmt.Println("edge true")
	} else {
		fmt.Println("edge false")
	}
}

func mochiMain() {
	seed = 1
	test_build_cases()
	test_search()
	test_edge()
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		INF = 1000000000.0
		seed = 1
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
