//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:00:38 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func panic(msg string) {
	fmt.Println(msg)
}

type FixedPriorityQueue struct {
	Queues [][]int `json:"queues"`
}

func fpq_new() FixedPriorityQueue {
	return FixedPriorityQueue{
		Queues: [][]int{[]int{}, []int{}, []int{}},
	}
}

func fpq_enqueue(fpq FixedPriorityQueue, priority int, data int) FixedPriorityQueue {
	if (priority < 0) || (priority >= len(fpq.Queues)) {
		panic("Valid priorities are 0, 1, and 2")
		return fpq
	}
	if len(_index(fpq.Queues, priority)) >= 100 {
		panic("Maximum queue size is 100")
		return fpq
	}
	var qs [][]int = fpq.Queues
	_ = qs
	_setIndex(qs, priority, append(_index(qs, priority), data))
	fpq.Queues = qs
	return fpq
}

type FPQDequeueResult struct {
	Queue FixedPriorityQueue `json:"queue"`
	Value int                `json:"value"`
}

func fpq_dequeue(fpq FixedPriorityQueue) FPQDequeueResult {
	var qs [][]int = fpq.Queues
	_ = qs
	var i int = 0
	_ = i
	for i < len(qs) {
		var q []int = _index(qs, i)
		_ = q
		if len(q) > 0 {
			var val int = _index(q, 0)
			_ = val
			_ = val
			var new_q []int = []int{}
			_ = new_q
			var j int = 1
			_ = j
			for j < len(q) {
				new_q = append(new_q, _index(q, j))
				j = (j + 1)
			}
			_setIndex(qs, i, new_q)
			fpq.Queues = qs
			return FPQDequeueResult{
				Queue: fpq,
				Value: val,
			}
		}
		i = (i + 1)
	}
	panic("All queues are empty")
	return FPQDequeueResult{
		Queue: fpq,
		Value: 0,
	}
}

func fpq_to_string(fpq FixedPriorityQueue) string {
	var lines []string = []string{}
	_ = lines
	var i int = 0
	_ = i
	for i < len(fpq.Queues) {
		var q_str string = "["
		_ = q_str
		var q []int = _index(fpq.Queues, i)
		_ = q
		var j int = 0
		_ = j
		for j < len(q) {
			if j > 0 {
				q_str = (q_str + ", ")
			}
			q_str = (q_str + fmt.Sprint(_index(q, j)))
			j = (j + 1)
		}
		q_str = (q_str + "]")
		lines = append(lines, ((("Priority " + fmt.Sprint(i)) + ": ") + q_str))
		i = (i + 1)
	}
	var res string = ""
	_ = res
	i = 0
	for i < len(lines) {
		if i > 0 {
			res = (res + "\n")
		}
		res = (res + _index(lines, i))
		i = (i + 1)
	}
	return res
}

type ElementPriorityQueue struct {
	Queue []int `json:"queue"`
}

func epq_new() ElementPriorityQueue {
	return ElementPriorityQueue{
		Queue: []int{},
	}
}

func epq_enqueue(epq ElementPriorityQueue, data int) ElementPriorityQueue {
	if len(epq.Queue) >= 100 {
		panic("Maximum queue size is 100")
		return epq
	}
	epq.Queue = append(epq.Queue, data)
	return epq
}

type EPQDequeueResult struct {
	Queue ElementPriorityQueue `json:"queue"`
	Value int                  `json:"value"`
}

func epq_dequeue(epq ElementPriorityQueue) EPQDequeueResult {
	if len(epq.Queue) == 0 {
		panic("The queue is empty")
		return EPQDequeueResult{
			Queue: epq,
			Value: 0,
		}
	}
	var min_val int = _index(epq.Queue, 0)
	_ = min_val
	var idx int = 0
	_ = idx
	var i int = 1
	_ = i
	for i < len(epq.Queue) {
		var v int = _index(epq.Queue, i)
		_ = v
		if v < min_val {
			min_val = v
			idx = i
		}
		i = (i + 1)
	}
	var new_q []int = []int{}
	_ = new_q
	i = 0
	for i < len(epq.Queue) {
		if i != idx {
			new_q = append(new_q, _index(epq.Queue, i))
		}
		i = (i + 1)
	}
	epq.Queue = new_q
	return EPQDequeueResult{
		Queue: epq,
		Value: min_val,
	}
}

func epq_to_string(epq ElementPriorityQueue) string {
	return fmt.Sprint(epq.Queue)
}

func fixed_priority_queue() {
	var fpq FixedPriorityQueue = fpq_new()
	_ = fpq
	fpq = fpq_enqueue(fpq, 0, 10)
	fpq = fpq_enqueue(fpq, 1, 70)
	fpq = fpq_enqueue(fpq, 0, 100)
	fpq = fpq_enqueue(fpq, 2, 1)
	fpq = fpq_enqueue(fpq, 2, 5)
	fpq = fpq_enqueue(fpq, 1, 7)
	fpq = fpq_enqueue(fpq, 2, 4)
	fpq = fpq_enqueue(fpq, 1, 64)
	fpq = fpq_enqueue(fpq, 0, 128)
	fmt.Println(fpq_to_string(fpq))
	var res FPQDequeueResult = fpq_dequeue(fpq)
	_ = res
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	fmt.Println(fpq_to_string(fpq))
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
	res = fpq_dequeue(fpq)
	fpq = res.Queue
	fmt.Println(res.Value)
}

func element_priority_queue() {
	var epq ElementPriorityQueue = epq_new()
	_ = epq
	epq = epq_enqueue(epq, 10)
	epq = epq_enqueue(epq, 70)
	epq = epq_enqueue(epq, 100)
	epq = epq_enqueue(epq, 1)
	epq = epq_enqueue(epq, 5)
	epq = epq_enqueue(epq, 7)
	epq = epq_enqueue(epq, 4)
	epq = epq_enqueue(epq, 64)
	epq = epq_enqueue(epq, 128)
	fmt.Println(epq_to_string(epq))
	var res EPQDequeueResult = epq_dequeue(epq)
	_ = res
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	fmt.Println(epq_to_string(epq))
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
	res = epq_dequeue(epq)
	epq = res.Queue
	fmt.Println(res.Value)
}

func mochiMain() {
	fixed_priority_queue()
	element_priority_queue()
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
