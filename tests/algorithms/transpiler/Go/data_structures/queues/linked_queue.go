//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:00:36 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Node struct {
	Data string `json:"data"`
	Next int    `json:"next"`
}

type LinkedQueue struct {
	Nodes []Node `json:"nodes"`
	Front int    `json:"front"`
	Rear  int    `json:"rear"`
}

func new_queue() LinkedQueue {
	return LinkedQueue{
		Nodes: []Node{},
		Front: (0 - 1),
		Rear:  (0 - 1),
	}
}

func is_empty(q LinkedQueue) bool {
	return (q.Front == (0 - 1))
}

func put(q *LinkedQueue, item string) {
	var node Node = Node{
		Data: item,
		Next: (0 - 1),
	}
	_ = node
	q.Nodes = append(q.Nodes, node)
	var idx int = (len(q.Nodes) - 1)
	_ = idx
	if q.Front == (0 - 1) {
		q.Front = idx
		q.Rear = idx
	} else {
		var nodes []Node = q.Nodes
		_ = nodes
		_tmp1 := _index(nodes, q.Rear)
		_ = _tmp1
		_tmp1.Next = idx
		_setIndex(nodes, q.Rear, _tmp1)
		q.Nodes = nodes
		q.Rear = idx
	}
}

func get(q *LinkedQueue) string {
	if is_empty(*q) {
		panic("dequeue from empty queue")
	}
	var idx int = q.Front
	_ = idx
	var node Node = _index(q.Nodes, idx)
	_ = node
	q.Front = node.Next
	if q.Front == (0 - 1) {
		q.Rear = (0 - 1)
	}
	return node.Data
}

func length(q LinkedQueue) int {
	var count int = 0
	_ = count
	var idx int = q.Front
	_ = idx
	for idx != (0 - 1) {
		count = (count + 1)
		idx = _index(q.Nodes, idx).Next
	}
	return count
}

func to_string(q LinkedQueue) string {
	var res string = ""
	_ = res
	var idx int = q.Front
	_ = idx
	var first bool = true
	_ = first
	for idx != (0 - 1) {
		var node Node = _index(q.Nodes, idx)
		_ = node
		if first {
			res = node.Data
			first = false
		} else {
			res = ((res + " <- ") + node.Data)
		}
		idx = node.Next
	}
	return res
}

func clear(q *LinkedQueue) {
	q.Nodes = []Node{}
	q.Front = (0 - 1)
	q.Rear = (0 - 1)
}

var queue LinkedQueue

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		queue = new_queue()
		fmt.Println(fmt.Sprint(is_empty(queue)))
		put(&queue, "5")
		put(&queue, "9")
		put(&queue, "python")
		fmt.Println(fmt.Sprint(is_empty(queue)))
		fmt.Println(get(&queue))
		put(&queue, "algorithms")
		fmt.Println(get(&queue))
		fmt.Println(get(&queue))
		fmt.Println(get(&queue))
		fmt.Println(fmt.Sprint(is_empty(queue)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
