//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-24 23:22:15 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var __name__ string = "__main__"

type Heap struct {
	Arr    [][]int       `json:"arr"`
	PosMap map[int]int   `json:"pos_map"`
	Size   int           `json:"size"`
	Key    func(int) int `json:"key"`
}

func new_heap(key func(int) int) Heap {
	return Heap{
		Arr:    [][]int{},
		PosMap: map[int]int{},
		Size:   0,
		Key:    key,
	}
}

func parent(i int) int {
	if i > 0 {
		return ((i - 1) / 2)
	}
	return (0 - 1)
}

func left(i int, size int) int {
	var l int = ((2 * i) + 1)
	_ = l
	if l < size {
		return l
	}
	return (0 - 1)
}

func right(i int, size int) int {
	var r int = ((2 * i) + 2)
	_ = r
	if r < size {
		return r
	}
	return (0 - 1)
}

func swap(h *Heap, i int, j int) {
	var arr [][]int = h.Arr
	_ = arr
	var item_i int = _index(_index(arr, i), 0)
	_ = item_i
	var item_j int = _index(_index(arr, j), 0)
	_ = item_j
	var pm map[int]int = h.PosMap
	if pm == nil {
		pm = map[int]int{}
	}
	_ = pm
	pm[item_i] = (j + 1)
	pm[item_j] = (i + 1)
	h.PosMap = pm
	var tmp []int = _index(arr, i)
	_ = tmp
	_setIndex(arr, i, _index(arr, j))
	_setIndex(arr, j, tmp)
	h.Arr = arr
}

func cmp(h Heap, i int, j int) bool {
	var arr [][]int = h.Arr
	_ = arr
	_ = arr
	return (_index(_index(arr, i), 1) < _index(_index(arr, j), 1))
}

func get_valid_parent(h Heap, i int) int {
	var vp int = i
	_ = vp
	var l int = left(i, h.Size)
	_ = l
	if (l != (0 - 1)) && (cmp(h, l, vp) == false) {
		vp = l
	}
	var r int = right(i, h.Size)
	_ = r
	if (r != (0 - 1)) && (cmp(h, r, vp) == false) {
		vp = r
	}
	return vp
}

func heapify_up(h Heap, index int) {
	var idx int = index
	_ = idx
	var p int = parent(idx)
	_ = p
	for (p != (0 - 1)) && (cmp(h, idx, p) == false) {
		swap(&h, idx, p)
		idx = p
		p = parent(p)
	}
}

func heapify_down(h Heap, index int) {
	var idx int = index
	_ = idx
	var vp int = get_valid_parent(h, idx)
	_ = vp
	for vp != idx {
		swap(&h, idx, vp)
		idx = vp
		vp = get_valid_parent(h, idx)
	}
}

func update_item(h *Heap, item int, item_value int) {
	var pm map[int]int = h.PosMap
	if pm == nil {
		pm = map[int]int{}
	}
	_ = pm
	if pm[item] == 0 {
		return
	}
	var index int = (pm[item] - 1)
	_ = index
	var arr [][]int = h.Arr
	_ = arr
	_setIndex(arr, index, []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(item), func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}(h.Key(item_value))})
	h.Arr = arr
	h.PosMap = pm
	heapify_up(*h, index)
	heapify_down(*h, index)
}

func delete_item(h *Heap, item int) {
	var pm map[int]int = h.PosMap
	if pm == nil {
		pm = map[int]int{}
	}
	_ = pm
	if pm[item] == 0 {
		return
	}
	var index int = (pm[item] - 1)
	_ = index
	pm[item] = 0
	var arr [][]int = h.Arr
	_ = arr
	var last_index int = (h.Size - 1)
	_ = last_index
	if index != last_index {
		_setIndex(arr, index, _index(arr, last_index))
		var moved int = _index(_index(arr, index), 0)
		_ = moved
		pm[moved] = (index + 1)
	}
	h.Size = (h.Size - 1)
	h.Arr = arr
	h.PosMap = pm
	if h.Size > index {
		heapify_up(*h, index)
		heapify_down(*h, index)
	}
}

func insert_item(h *Heap, item int, item_value int) {
	var arr [][]int = h.Arr
	_ = arr
	var arr_len int = len(arr)
	_ = arr_len
	if arr_len == h.Size {
		arr = append(arr, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(item), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(h.Key(item_value))})
	} else {
		_setIndex(arr, h.Size, []int{func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(item), func(v any) int {
			if vv, ok := v.(int); ok {
				return vv
			}
			return 0
		}(h.Key(item_value))})
	}
	var pm map[int]int = h.PosMap
	if pm == nil {
		pm = map[int]int{}
	}
	_ = pm
	pm[item] = (h.Size + 1)
	h.Size = (h.Size + 1)
	h.Arr = arr
	h.PosMap = pm
	heapify_up(*h, (h.Size - 1))
}

func get_top(h Heap) []int {
	var arr [][]int = h.Arr
	_ = arr
	_ = arr
	if h.Size > 0 {
		return func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(_index(arr, 0))
	}
	return func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{})
}

func extract_top(h Heap) []int {
	var top []int = get_top(h)
	_ = top
	if len(top) > 0 {
		delete_item(&h, _index(top, 0))
	}
	return top
}

func identity(x int) int {
	return x
}

func negate(x int) int {
	return (0 - x)
}

var h Heap

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		h = new_heap(identity)
		insert_item(&h, 5, 34)
		insert_item(&h, 6, 31)
		insert_item(&h, 7, 37)
		fmt.Println(fmt.Sprint(get_top(h)))
		fmt.Println(fmt.Sprint(extract_top(h)))
		fmt.Println(fmt.Sprint(extract_top(h)))
		fmt.Println(fmt.Sprint(extract_top(h)))
		h = new_heap(negate)
		insert_item(&h, 5, 34)
		insert_item(&h, 6, 31)
		insert_item(&h, 7, 37)
		fmt.Println(fmt.Sprint(get_top(h)))
		fmt.Println(fmt.Sprint(extract_top(h)))
		fmt.Println(fmt.Sprint(extract_top(h)))
		fmt.Println(fmt.Sprint(extract_top(h)))
		insert_item(&h, 8, 45)
		insert_item(&h, 9, 40)
		insert_item(&h, 10, 50)
		fmt.Println(fmt.Sprint(get_top(h)))
		update_item(&h, 10, 30)
		fmt.Println(fmt.Sprint(get_top(h)))
		delete_item(&h, 10)
		fmt.Println(fmt.Sprint(get_top(h)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
