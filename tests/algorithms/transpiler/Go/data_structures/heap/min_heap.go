//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 21:55:39 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"sort"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Node struct {
	Name string `json:"name"`
	Val  int    `json:"val"`
}

type MinHeap struct {
	Heap         []Node         `json:"heap"`
	IDxOfElement map[string]int `json:"idx_of_element"`
	HeapDict     map[string]int `json:"heap_dict"`
}

func get_parent_idx(idx int) int {
	return ((idx - 1) / 2)
}

func get_left_child_idx(idx int) int {
	return ((idx * 2) + 1)
}

func get_right_child_idx(idx int) int {
	return ((idx * 2) + 2)
}

func remove_key(m map[string]int, k string) map[string]int {
	var out map[string]int = map[string]int{}
	_ = out
	for _, key := range func() []string {
		keys := make([]string, 0, len(m))
		for k := range m {
			keys = append(keys, k)
		}
		sort.Slice(keys, func(i, j int) bool { return fmt.Sprint(keys[i]) < fmt.Sprint(keys[j]) })
		return keys
	}() {
		if key != k {
			out[key] = m[key]
		}
	}
	return out
}

func slice_without_last(xs []Node) []Node {
	var res []Node = []Node{}
	_ = res
	var i int = 0
	_ = i
	for i < (len(xs) - 1) {
		res = append(res, _index(xs, i))
		i = (i + 1)
	}
	return res
}

func sift_down(mh *MinHeap, idx int) {
	var heap []Node = mh.Heap
	_ = heap
	var idx_map map[string]int = mh.IDxOfElement
	_ = idx_map
	var i int = idx
	_ = i
	for {
		var left int = get_left_child_idx(i)
		_ = left
		var right int = get_right_child_idx(i)
		_ = right
		var smallest int = i
		_ = smallest
		if (left < len(heap)) && (_index(heap, left).Val < _index(heap, smallest).Val) {
			smallest = left
		}
		if (right < len(heap)) && (_index(heap, right).Val < _index(heap, smallest).Val) {
			smallest = right
		}
		if smallest != i {
			var tmp Node = _index(heap, i)
			_ = tmp
			_setIndex(heap, i, _index(heap, smallest))
			_setIndex(heap, smallest, tmp)
			idx_map[_index(heap, i).Name] = i
			idx_map[_index(heap, smallest).Name] = smallest
			i = smallest
		} else {
			break
		}
	}
	mh.Heap = heap
	mh.IDxOfElement = idx_map
}

func sift_up(mh *MinHeap, idx int) {
	var heap []Node = mh.Heap
	_ = heap
	var idx_map map[string]int = mh.IDxOfElement
	_ = idx_map
	var i int = idx
	_ = i
	var p int = get_parent_idx(i)
	_ = p
	for (p >= 0) && (_index(heap, p).Val > _index(heap, i).Val) {
		var tmp Node = _index(heap, p)
		_ = tmp
		_setIndex(heap, p, _index(heap, i))
		_setIndex(heap, i, tmp)
		idx_map[_index(heap, p).Name] = p
		idx_map[_index(heap, i).Name] = i
		i = p
		p = get_parent_idx(i)
	}
	mh.Heap = heap
	mh.IDxOfElement = idx_map
}

func new_min_heap(array []Node) MinHeap {
	var idx_map map[string]int = map[string]int{}
	_ = idx_map
	var val_map map[string]int = map[string]int{}
	_ = val_map
	var heap []Node = array
	_ = heap
	var i int = 0
	_ = i
	for i < len(array) {
		var n Node = _index(array, i)
		_ = n
		idx_map[n.Name] = i
		val_map[n.Name] = n.Val
		i = (i + 1)
	}
	var mh MinHeap = MinHeap{
		Heap:         heap,
		IDxOfElement: idx_map,
		HeapDict:     val_map,
	}
	_ = mh
	_ = mh
	var start int = get_parent_idx((len(array) - 1))
	_ = start
	for start >= 0 {
		sift_down(&mh, start)
		start = (start - 1)
	}
	return mh
}

func peek(mh MinHeap) Node {
	return _index(mh.Heap, 0)
}

func remove_min(mh *MinHeap) Node {
	var heap []Node = mh.Heap
	_ = heap
	var idx_map map[string]int = mh.IDxOfElement
	_ = idx_map
	var val_map map[string]int = mh.HeapDict
	_ = val_map
	var last_idx int = (len(heap) - 1)
	_ = last_idx
	var top Node = _index(heap, 0)
	_ = top
	var last Node = _index(heap, last_idx)
	_ = last
	_setIndex(heap, 0, last)
	idx_map[last.Name] = 0
	heap = slice_without_last(func(v any) []Node {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Node); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Node{}
			}
			out := make([]Node, len(arr))
			for i, x := range arr {
				out[i] = x.(Node)
			}
			return out
		}
		return v.([]Node)
	}(heap))
	idx_map = remove_key(idx_map, top.Name)
	val_map = remove_key(val_map, top.Name)
	mh.Heap = heap
	mh.IDxOfElement = idx_map
	mh.HeapDict = val_map
	if len(heap) > 0 {
		sift_down(mh, 0)
	}
	return top
}

func insert(mh *MinHeap, node Node) {
	var heap []Node = mh.Heap
	_ = heap
	var idx_map map[string]int = mh.IDxOfElement
	_ = idx_map
	var val_map map[string]int = mh.HeapDict
	_ = val_map
	heap = append(heap, node)
	var idx int = (len(heap) - 1)
	_ = idx
	idx_map[node.Name] = idx
	val_map[node.Name] = node.Val
	mh.Heap = heap
	mh.IDxOfElement = idx_map
	mh.HeapDict = val_map
	sift_up(mh, idx)
}

func is_empty(mh MinHeap) bool {
	return (len(mh.Heap) == 0)
}

func get_value(mh MinHeap, key string) int {
	return mh.HeapDict[key]
}

func decrease_key(mh *MinHeap, node *Node, new_value int) {
	var heap []Node = mh.Heap
	_ = heap
	var val_map map[string]int = mh.HeapDict
	_ = val_map
	var idx_map map[string]int = mh.IDxOfElement
	_ = idx_map
	var idx int = idx_map[node.Name]
	_ = idx
	if !(_index(heap, idx).Val > new_value) {
		panic("newValue must be less than current value")
	}
	node.Val = new_value
	_tmp1 := _index(heap, idx)
	_ = _tmp1
	_tmp1.Val = new_value
	_setIndex(heap, idx, _tmp1)
	val_map[node.Name] = new_value
	mh.Heap = heap
	mh.HeapDict = val_map
	sift_up(mh, idx)
}

func node_to_string(n Node) string {
	return (((("Node(" + n.Name) + ", ") + fmt.Sprint(n.Val)) + ")")
}

var r Node

var b Node

var a Node

var x Node

var e Node

var my_min_heap MinHeap

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		r = Node{
			Name: "R",
			Val:  (0 - 1),
		}
		b = Node{
			Name: "B",
			Val:  6,
		}
		a = Node{
			Name: "A",
			Val:  3,
		}
		x = Node{
			Name: "X",
			Val:  1,
		}
		e = Node{
			Name: "E",
			Val:  4,
		}
		my_min_heap = new_min_heap(func(v any) []Node {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Node); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Node{}
				}
				out := make([]Node, len(arr))
				for i, x := range arr {
					out[i] = x.(Node)
				}
				return out
			}
			return v.([]Node)
		}([]Node{r, b, a, x, e}))
		fmt.Println("Min Heap - before decrease key")
		for _, n := range my_min_heap.Heap {
			fmt.Println(node_to_string(n))
		}
		fmt.Println("Min Heap - After decrease key of node [B -> -17]")
		decrease_key(&my_min_heap, &b, (0 - 17))
		for _, n := range my_min_heap.Heap {
			fmt.Println(node_to_string(n))
		}
		fmt.Println(fmt.Sprint(get_value(my_min_heap, "B")))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
