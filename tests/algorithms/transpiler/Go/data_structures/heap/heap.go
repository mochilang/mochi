//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-25 00:05:48 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var __name__ string = "__main__"

func parent_index(child_idx int) int {
	if child_idx > 0 {
		return func() int {
			a := (child_idx - 1)
			b := 2
			q := a / b
			r := a % b
			if (r != 0) && ((r < 0) != (b < 0)) {
				q--
			}
			return q
		}()
	}
	return (0 - 1)
}

func left_child_idx(parent_idx int) int {
	return ((2 * parent_idx) + 1)
}

func right_child_idx(parent_idx int) int {
	return ((2 * parent_idx) + 2)
}

func max_heapify(h []float64, heap_size int, index int) {
	var largest int = index
	_ = largest
	var left int = left_child_idx(index)
	_ = left
	var right int = right_child_idx(index)
	_ = right
	if (left < heap_size) && (_index(h, left) > _index(h, largest)) {
		largest = left
	}
	if (right < heap_size) && (_index(h, right) > _index(h, largest)) {
		largest = right
	}
	if largest != index {
		var temp float64 = _index(h, index)
		_ = temp
		_setIndex(h, index, _index(h, largest))
		_setIndex(h, largest, temp)
		max_heapify(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(h), heap_size, largest)
	}
}

func build_max_heap(h []float64) int {
	var heap_size int = len(h)
	_ = heap_size
	var i int = (func() int {
		a := heap_size
		b := 2
		q := a / b
		r := a % b
		if (r != 0) && ((r < 0) != (b < 0)) {
			q--
		}
		return q
	}() - 1)
	_ = i
	for i >= 0 {
		max_heapify(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(h), heap_size, i)
		i = (i - 1)
	}
	return heap_size
}

func extract_max(h []float64, heap_size int) float64 {
	var max_value float64 = _index(h, 0)
	_ = max_value
	_ = max_value
	_setIndex(h, 0, _index(h, (heap_size-1)))
	max_heapify(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(h), (heap_size - 1), 0)
	return max_value
}

func insert(h []float64, heap_size int, value float64) int {
	if heap_size < len(h) {
		_setIndex(h, heap_size, value)
	} else {
		h = append(h, value)
	}
	heap_size = (heap_size + 1)
	var idx int = func() int {
		a := (heap_size - 1)
		b := 2
		q := a / b
		r := a % b
		if (r != 0) && ((r < 0) != (b < 0)) {
			q--
		}
		return q
	}()
	_ = idx
	for idx >= 0 {
		max_heapify(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(h), heap_size, idx)
		idx = func() int {
			a := (idx - 1)
			b := 2
			q := a / b
			r := a % b
			if (r != 0) && ((r < 0) != (b < 0)) {
				q--
			}
			return q
		}()
	}
	return heap_size
}

func heap_sort(h []float64, heap_size int) {
	var size int = heap_size
	_ = size
	var j int = (size - 1)
	_ = j
	for j > 0 {
		var temp float64 = _index(h, 0)
		_ = temp
		_setIndex(h, 0, _index(h, j))
		_setIndex(h, j, temp)
		size = (size - 1)
		max_heapify(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(h), size, 0)
		j = (j - 1)
	}
}

func heap_to_string(h []float64, heap_size int) string {
	var s string = "["
	_ = s
	var i int = 0
	_ = i
	for i < heap_size {
		s = (s + fmt.Sprint(_index(h, i)))
		if i < (heap_size - 1) {
			s = (s + ", ")
		}
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

var heap []float64

var size int

var m float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		heap = []float64{103.0, 9.0, 1.0, 7.0, 11.0, 15.0, 25.0, 201.0, 209.0, 107.0, 5.0}
		size = build_max_heap(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap))
		fmt.Println(heap_to_string(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size))
		m = extract_max(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size)
		size = (size - 1)
		fmt.Println(fmt.Sprint(m))
		fmt.Println(heap_to_string(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size))
		size = insert(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size, 100.0)
		fmt.Println(heap_to_string(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size))
		heap_sort(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size)
		fmt.Println(heap_to_string(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(heap), size))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
