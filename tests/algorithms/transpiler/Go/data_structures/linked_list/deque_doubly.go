//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 21:59:26 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

type Node struct {
	Data string `json:"data"`
	Prev int    `json:"prev"`
	Next int    `json:"next"`
}

type LinkedDeque struct {
	Nodes   []Node `json:"nodes"`
	Header  int    `json:"header"`
	Trailer int    `json:"trailer"`
	Size    int    `json:"size"`
}

func new_deque() LinkedDeque {
	var nodes []Node = []Node{}
	_ = nodes
	nodes = append(nodes, Node{
		Data: "",
		Prev: (0 - 1),
		Next: 1,
	})
	nodes = append(nodes, Node{
		Data: "",
		Prev: 0,
		Next: (0 - 1),
	})
	return LinkedDeque{
		Nodes:   nodes,
		Header:  0,
		Trailer: 1,
		Size:    0,
	}
}

func is_empty(d LinkedDeque) bool {
	return (d.Size == 0)
}

func front(d LinkedDeque) string {
	if is_empty(d) {
		panic("List is empty")
	}
	var head Node = _index(d.Nodes, d.Header)
	_ = head
	var idx int = head.Next
	_ = idx
	var node Node = _index(d.Nodes, idx)
	_ = node
	_ = node
	return node.Data
}

func back(d LinkedDeque) string {
	if is_empty(d) {
		panic("List is empty")
	}
	var tail Node = _index(d.Nodes, d.Trailer)
	_ = tail
	var idx int = tail.Prev
	_ = idx
	var node Node = _index(d.Nodes, idx)
	_ = node
	_ = node
	return node.Data
}

func insert(d LinkedDeque, pred int, value string, succ int) LinkedDeque {
	var nodes []Node = d.Nodes
	_ = nodes
	var new_idx int = len(nodes)
	_ = new_idx
	nodes = append(nodes, Node{
		Data: value,
		Prev: pred,
		Next: succ,
	})
	var pred_node Node = _index(nodes, pred)
	_ = pred_node
	pred_node.Next = new_idx
	_setIndex(nodes, pred, pred_node)
	var succ_node Node = _index(nodes, succ)
	_ = succ_node
	succ_node.Prev = new_idx
	_setIndex(nodes, succ, succ_node)
	d.Nodes = nodes
	d.Size = (d.Size + 1)
	return d
}

type DeleteResult struct {
	Deque LinkedDeque `json:"deque"`
	Value string      `json:"value"`
}

func delete(d LinkedDeque, idx int) DeleteResult {
	var nodes []Node = d.Nodes
	_ = nodes
	var node Node = _index(nodes, idx)
	_ = node
	var pred int = node.Prev
	_ = pred
	var succ int = node.Next
	_ = succ
	var pred_node Node = _index(nodes, pred)
	_ = pred_node
	pred_node.Next = succ
	_setIndex(nodes, pred, pred_node)
	var succ_node Node = _index(nodes, succ)
	_ = succ_node
	succ_node.Prev = pred
	_setIndex(nodes, succ, succ_node)
	var val string = node.Data
	_ = val
	_ = val
	d.Nodes = nodes
	d.Size = (d.Size - 1)
	return DeleteResult{
		Deque: d,
		Value: val,
	}
}

func add_first(d LinkedDeque, value string) LinkedDeque {
	var head Node = _index(d.Nodes, d.Header)
	_ = head
	var succ int = head.Next
	_ = succ
	_ = succ
	return insert(d, d.Header, value, succ)
}

func add_last(d LinkedDeque, value string) LinkedDeque {
	var tail Node = _index(d.Nodes, d.Trailer)
	_ = tail
	var pred int = tail.Prev
	_ = pred
	_ = pred
	return insert(d, pred, value, d.Trailer)
}

func remove_first(d LinkedDeque) DeleteResult {
	if is_empty(d) {
		panic("remove_first from empty list")
	}
	var head Node = _index(d.Nodes, d.Header)
	_ = head
	var idx int = head.Next
	_ = idx
	_ = idx
	return delete(d, idx)
}

func remove_last(d LinkedDeque) DeleteResult {
	if is_empty(d) {
		panic("remove_first from empty list")
	}
	var tail Node = _index(d.Nodes, d.Trailer)
	_ = tail
	var idx int = tail.Prev
	_ = idx
	_ = idx
	return delete(d, idx)
}

func mochiMain() {
	var d LinkedDeque = new_deque()
	_ = d
	d = add_first(d, "A")
	fmt.Println(front(d))
	d = add_last(d, "B")
	fmt.Println(back(d))
	var r DeleteResult = remove_first(d)
	_ = r
	d = r.Deque
	fmt.Println(r.Value)
	r = remove_last(d)
	d = r.Deque
	fmt.Println(r.Value)
	fmt.Println(fmt.Sprint(is_empty(d)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
