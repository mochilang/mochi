//go:build ignore

// Generated by Mochi v0.10.72 on 2025-08-24 17:07:52 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		return
	}
	s[idx] = v
}

var __name__ string = "__main__"

type Node struct {
	Data      int `json:"data"`
	PrevIndex int `json:"prev_index"`
	NextIndex int `json:"next_index"`
}

type LinkedList struct {
	Nodes   []Node `json:"nodes"`
	HeadIDx int    `json:"head_idx"`
	TailIDx int    `json:"tail_idx"`
}

func empty_list() LinkedList {
	return LinkedList{
		Nodes:   []Node{},
		HeadIDx: (0 - 1),
		TailIDx: (0 - 1),
	}
}

func get_head_data(ll LinkedList) int {
	if ll.HeadIDx == (0 - 1) {
		return (0 - 1)
	}
	var node Node = _index(ll.Nodes, ll.HeadIDx)
	_ = node
	_ = node
	return node.Data
}

func get_tail_data(ll LinkedList) int {
	if ll.TailIDx == (0 - 1) {
		return (0 - 1)
	}
	var node Node = _index(ll.Nodes, ll.TailIDx)
	_ = node
	_ = node
	return node.Data
}

func insert_before_node(ll *LinkedList, idx int, new_idx int) {
	var nodes []Node = ll.Nodes
	_ = nodes
	var new_node Node = _index(nodes, new_idx)
	_ = new_node
	new_node.NextIndex = idx
	var node Node = _index(nodes, idx)
	_ = node
	var p int = node.PrevIndex
	_ = p
	new_node.PrevIndex = p
	_setIndex(nodes, new_idx, new_node)
	if p == (0 - 1) {
		ll.HeadIDx = new_idx
	} else {
		var prev_node Node = _index(nodes, p)
		_ = prev_node
		prev_node.NextIndex = new_idx
		_setIndex(nodes, p, prev_node)
	}
	node.PrevIndex = new_idx
	_setIndex(nodes, idx, node)
	ll.Nodes = nodes
}

func insert_after_node(ll *LinkedList, idx int, new_idx int) {
	var nodes []Node = ll.Nodes
	_ = nodes
	var new_node Node = _index(nodes, new_idx)
	_ = new_node
	new_node.PrevIndex = idx
	var node Node = _index(nodes, idx)
	_ = node
	var nxt int = node.NextIndex
	_ = nxt
	new_node.NextIndex = nxt
	_setIndex(nodes, new_idx, new_node)
	if nxt == (0 - 1) {
		ll.TailIDx = new_idx
	} else {
		var next_node Node = _index(nodes, nxt)
		_ = next_node
		next_node.PrevIndex = new_idx
		_setIndex(nodes, nxt, next_node)
	}
	node.NextIndex = new_idx
	_setIndex(nodes, idx, node)
	ll.Nodes = nodes
}

func set_head(ll *LinkedList, idx int) {
	if ll.HeadIDx == (0 - 1) {
		ll.HeadIDx = idx
		ll.TailIDx = idx
	} else {
		insert_before_node(ll, ll.HeadIDx, idx)
	}
}

func set_tail(ll *LinkedList, idx int) {
	if ll.TailIDx == (0 - 1) {
		ll.HeadIDx = idx
		ll.TailIDx = idx
	} else {
		insert_after_node(ll, ll.TailIDx, idx)
	}
}

func insert(ll *LinkedList, value int) {
	var nodes []Node = ll.Nodes
	_ = nodes
	nodes = append(nodes, Node{
		Data:      value,
		PrevIndex: (0 - 1),
		NextIndex: (0 - 1),
	})
	var idx int = (len(nodes) - 1)
	_ = idx
	ll.Nodes = nodes
	if ll.HeadIDx == (0 - 1) {
		ll.HeadIDx = idx
		ll.TailIDx = idx
	} else {
		insert_after_node(ll, ll.TailIDx, idx)
	}
}

func insert_at_position(ll *LinkedList, position int, value int) {
	var current int = ll.HeadIDx
	_ = current
	var current_pos int = 1
	_ = current_pos
	for current != (0 - 1) {
		if current_pos == position {
			var nodes []Node = ll.Nodes
			_ = nodes
			nodes = append(nodes, Node{
				Data:      value,
				PrevIndex: (0 - 1),
				NextIndex: (0 - 1),
			})
			var new_idx int = (len(nodes) - 1)
			_ = new_idx
			ll.Nodes = nodes
			insert_before_node(ll, current, new_idx)
			return
		}
		var node Node = _index(ll.Nodes, current)
		_ = node
		current = node.NextIndex
		current_pos = (current_pos + 1)
	}
	insert(ll, value)
}

func get_node(ll LinkedList, item int) int {
	var current int = ll.HeadIDx
	_ = current
	for current != (0 - 1) {
		var node Node = _index(ll.Nodes, current)
		_ = node
		if node.Data == item {
			return current
		}
		current = node.NextIndex
	}
	return (0 - 1)
}

func remove_node_pointers(ll *LinkedList, idx int) {
	var nodes []Node = ll.Nodes
	_ = nodes
	var node Node = _index(nodes, idx)
	_ = node
	var nxt int = node.NextIndex
	_ = nxt
	var p int = node.PrevIndex
	_ = p
	if nxt != (0 - 1) {
		var nxt_node Node = _index(nodes, nxt)
		_ = nxt_node
		nxt_node.PrevIndex = p
		_setIndex(nodes, nxt, nxt_node)
	}
	if p != (0 - 1) {
		var prev_node Node = _index(nodes, p)
		_ = prev_node
		prev_node.NextIndex = nxt
		_setIndex(nodes, p, prev_node)
	}
	node.NextIndex = (0 - 1)
	node.PrevIndex = (0 - 1)
	_setIndex(nodes, idx, node)
	ll.Nodes = nodes
}

func delete_value(ll *LinkedList, value int) {
	var idx int = get_node(*ll, value)
	_ = idx
	if idx == (0 - 1) {
		return
	}
	if idx == ll.HeadIDx {
		var node Node = _index(ll.Nodes, idx)
		_ = node
		ll.HeadIDx = node.NextIndex
	}
	if idx == ll.TailIDx {
		var node Node = _index(ll.Nodes, idx)
		_ = node
		ll.TailIDx = node.PrevIndex
	}
	remove_node_pointers(ll, idx)
}

func contains(ll LinkedList, value int) bool {
	return (get_node(ll, value) != (0 - 1))
}

func is_empty(ll LinkedList) bool {
	return (ll.HeadIDx == (0 - 1))
}

func to_string(ll LinkedList) string {
	var res string = ""
	_ = res
	var first bool = true
	_ = first
	var current int = ll.HeadIDx
	_ = current
	for current != (0 - 1) {
		var node Node = _index(ll.Nodes, current)
		_ = node
		var val string = fmt.Sprint(node.Data)
		_ = val
		if first {
			res = val
			first = false
		} else {
			res = ((res + " ") + val)
		}
		current = node.NextIndex
	}
	return res
}

func print_list(ll LinkedList) {
	var current int = ll.HeadIDx
	_ = current
	for current != (0 - 1) {
		var node Node = _index(ll.Nodes, current)
		_ = node
		fmt.Println(fmt.Sprint(node.Data))
		current = node.NextIndex
	}
}

func mochiMain() {
	var ll LinkedList = empty_list()
	_ = ll
	fmt.Println(fmt.Sprint(get_head_data(ll)))
	fmt.Println(fmt.Sprint(get_tail_data(ll)))
	fmt.Println(fmt.Sprint(is_empty(ll)))
	insert(&ll, 10)
	fmt.Println(fmt.Sprint(get_head_data(ll)))
	fmt.Println(fmt.Sprint(get_tail_data(ll)))
	insert_at_position(&ll, 3, 20)
	fmt.Println(fmt.Sprint(get_head_data(ll)))
	fmt.Println(fmt.Sprint(get_tail_data(ll)))
	var nodes []Node = ll.Nodes
	_ = nodes
	nodes = append(nodes, Node{
		Data:      1000,
		PrevIndex: (0 - 1),
		NextIndex: (0 - 1),
	})
	var idx_head int = (len(nodes) - 1)
	_ = idx_head
	ll.Nodes = nodes
	set_head(&ll, idx_head)
	nodes = ll.Nodes
	nodes = append(nodes, Node{
		Data:      2000,
		PrevIndex: (0 - 1),
		NextIndex: (0 - 1),
	})
	var idx_tail int = (len(nodes) - 1)
	_ = idx_tail
	ll.Nodes = nodes
	set_tail(&ll, idx_tail)
	print_list(ll)
	fmt.Println(fmt.Sprint(is_empty(ll)))
	print_list(ll)
	fmt.Println(fmt.Sprint(contains(ll, 10)))
	delete_value(&ll, 10)
	fmt.Println(fmt.Sprint(contains(ll, 10)))
	delete_value(&ll, 2000)
	fmt.Println(fmt.Sprint(get_tail_data(ll)))
	delete_value(&ll, 1000)
	fmt.Println(fmt.Sprint(get_tail_data(ll)))
	fmt.Println(fmt.Sprint(get_head_data(ll)))
	print_list(ll)
	delete_value(&ll, 20)
	print_list(ll)
	var i int = 1
	_ = i
	for i < 10 {
		insert(&ll, i)
		i = (i + 1)
	}
	print_list(ll)
	var ll2 LinkedList = empty_list()
	_ = ll2
	insert_at_position(&ll2, 1, 10)
	fmt.Println(to_string(ll2))
	insert_at_position(&ll2, 2, 20)
	fmt.Println(to_string(ll2))
	insert_at_position(&ll2, 1, 30)
	fmt.Println(to_string(ll2))
	insert_at_position(&ll2, 3, 40)
	fmt.Println(to_string(ll2))
	insert_at_position(&ll2, 5, 50)
	fmt.Println(to_string(ll2))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
