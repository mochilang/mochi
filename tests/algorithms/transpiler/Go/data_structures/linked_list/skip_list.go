//go:build ignore

// Generated by Mochi v0.10.66 on 2025-08-14 22:00:22 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"math/big"
	"os"
	"runtime"
	"strconv"
	"time"
)

var _ = big.NewInt

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _mod(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

var NIL int

var MAX_LEVEL int

var P float64

var seed int

func random() float64 {
	seed = _mod(((seed * 13) + 7), 100)
	return (float64(seed) / float64(100.0))
}

func random_level() int {
	var lvl int = 1
	_ = lvl
	for (random() < P) && (lvl < MAX_LEVEL) {
		lvl = (lvl + 1)
	}
	return lvl
}

func empty_forward() []int {
	var f []int = []int{}
	_ = f
	var i int = 0
	_ = i
	for i < MAX_LEVEL {
		f = append(f, int(NIL))
		i = (i + 1)
	}
	return f
}

var node_keys []int

var node_vals []int

var node_forwards [][]int

var level int

func init_() {
	node_keys = []int{func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		return 0
	}((0 - 1))}
	node_vals = []int{0}
	node_forwards = [][]int{empty_forward()}
	level = 1
}

func insert(key int, value int) {
	var update []int = []int{}
	_ = update
	var i int = 0
	_ = i
	for i < MAX_LEVEL {
		update = append(update, 0)
		i = (i + 1)
	}
	var x int = 0
	_ = x
	i = (level - 1)
	for i >= 0 {
		for (int(_index(_index(node_forwards, x), i)) != int(NIL)) && (int(_index(node_keys, _index(_index(node_forwards, x), i))) < key) {
			x = _index(_index(node_forwards, x), i)
		}
		_setIndex(update, i, x)
		i = (i - 1)
	}
	x = _index(_index(node_forwards, x), 0)
	if (x != int(NIL)) && (int(_index(node_keys, x)) == key) {
		_setIndex(node_vals, x, value)
		return
	}
	var lvl int = random_level()
	_ = lvl
	if lvl > level {
		var j int = level
		_ = j
		for j < lvl {
			_setIndex(update, j, 0)
			j = (j + 1)
		}
		level = lvl
	}
	node_keys = append(node_keys, key)
	node_vals = append(node_vals, value)
	var forwards []int = empty_forward()
	_ = forwards
	var idx int = (len(node_keys) - 1)
	_ = idx
	i = 0
	for i < lvl {
		_setIndex(forwards, i, _index(_index(node_forwards, _index(update, i)), i))
		_setIndex(_index(node_forwards, _index(update, i)), i, idx)
		i = (i + 1)
	}
	node_forwards = append(node_forwards, forwards)
}

func find(key int) int {
	var x int = 0
	_ = x
	var i int = (level - 1)
	_ = i
	for i >= 0 {
		for (int(_index(_index(node_forwards, x), i)) != int(NIL)) && (int(_index(node_keys, _index(_index(node_forwards, x), i))) < key) {
			x = _index(_index(node_forwards, x), i)
		}
		i = (i - 1)
	}
	x = _index(_index(node_forwards, x), 0)
	if (x != int(NIL)) && (int(_index(node_keys, x)) == key) {
		return _index(node_vals, x)
	}
	return (0 - 1)
}

func delete(key int) {
	var update []int = []int{}
	_ = update
	var i int = 0
	_ = i
	for i < MAX_LEVEL {
		update = append(update, 0)
		i = (i + 1)
	}
	var x int = 0
	_ = x
	i = (level - 1)
	for i >= 0 {
		for (int(_index(_index(node_forwards, x), i)) != int(NIL)) && (int(_index(node_keys, _index(_index(node_forwards, x), i))) < key) {
			x = _index(_index(node_forwards, x), i)
		}
		_setIndex(update, i, x)
		i = (i - 1)
	}
	x = _index(_index(node_forwards, x), 0)
	if (x == int(NIL)) || (int(_index(node_keys, x)) != key) {
		return
	}
	i = 0
	for i < level {
		if int(_index(_index(node_forwards, _index(update, i)), i)) == x {
			_setIndex(_index(node_forwards, _index(update, i)), i, _index(_index(node_forwards, x), i))
		}
		i = (i + 1)
	}
	for (level > 1) && (int(_index(_index(node_forwards, 0), (level-1))) == int(NIL)) {
		level = (level - 1)
	}
}

func to_string() string {
	var s string = ""
	_ = s
	var x int = _index(_index(node_forwards, 0), 0)
	_ = x
	for x != int(NIL) {
		if s != "" {
			s = (s + " -> ")
		}
		s = (((s + fmt.Sprint(_index(node_keys, x))) + ":") + fmt.Sprint(_index(node_vals, x)))
		x = _index(_index(node_forwards, x), 0)
	}
	return s
}

func mochiMain() {
	init_()
	insert(2, 2)
	insert(4, 4)
	insert(6, 4)
	insert(4, 5)
	insert(8, 4)
	insert(9, 4)
	delete(4)
	fmt.Println(to_string())
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		NIL = (0 - 1)
		MAX_LEVEL = 6
		P = 0.5
		seed = 1
		node_keys = []int{}
		node_vals = []int{}
		node_forwards = [][]int{}
		level = 1
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
