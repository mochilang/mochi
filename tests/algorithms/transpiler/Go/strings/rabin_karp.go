//go:build ignore

// Generated by Mochi v0.10.70 on 2025-08-23 13:50:18 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var nowSeed int64 = 1

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
		}
	}
}
func _now() int {
	nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
	return int(nowSeed)
}

func _modi(a, b int) int {
	if b == 0 {
		return 0
	}
	r := a % b
	if (r < 0 && b > 0) || (r > 0 && b < 0) {
		r += b
	}
	return r
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		switch vv := v.(type) {
		case int:
			return vv
		case int64:
			return int(vv)
		case float64:
			return int(vv)
		case float32:
			return int(vv)
		default:
			return v.(int)
		}
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	if idx < 0 || idx >= len(s) {
		var zero T
		return zero
	}
	return s[idx]
}

var alphabet_size int

var modulus int

func index_of_char(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if string(_index([]rune(s), i)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func ord(ch string) int {
	var upper string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper
	var lower string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower
	var digits string = "0123456789"
	_ = digits
	var idx int = index_of_char(upper, ch)
	_ = idx
	if idx >= 0 {
		return (65 + idx)
	}
	idx = index_of_char(lower, ch)
	if idx >= 0 {
		return (97 + idx)
	}
	idx = index_of_char(digits, ch)
	if idx >= 0 {
		return (48 + idx)
	}
	if ch == "ü" {
		return 252
	}
	if ch == "Ü" {
		return 220
	}
	if ch == " " {
		return 32
	}
	return 0
}

func rabin_karp(pattern string, text string) bool {
	var p_len int = len(pattern)
	_ = p_len
	var t_len int = len(text)
	_ = t_len
	if p_len > t_len {
		return false
	}
	var p_hash int = 0
	_ = p_hash
	var t_hash int = 0
	_ = t_hash
	var modulus_power int = 1
	_ = modulus_power
	var i int = 0
	_ = i
	for i < p_len {
		p_hash = _modi((ord(string(_index([]rune(pattern), i))) + (p_hash * alphabet_size)), modulus)
		t_hash = _modi((ord(string(_index([]rune(text), i))) + (t_hash * alphabet_size)), modulus)
		if i != (p_len - 1) {
			modulus_power = _modi((modulus_power * alphabet_size), modulus)
		}
		i = (i + 1)
	}
	var j int = 0
	_ = j
	for j <= (t_len - p_len) {
		if (t_hash == p_hash) && (_substr(text, j, (j+p_len)) == pattern) {
			return true
		}
		if j == (t_len - p_len) {
			j = (j + 1)
			continue
		}
		t_hash = _modi((((t_hash - (ord(string(_index([]rune(text), j))) * modulus_power)) * alphabet_size) + ord(string(_index([]rune(text), (j+p_len))))), modulus)
		if t_hash < 0 {
			t_hash = (t_hash + modulus)
		}
		j = (j + 1)
	}
	return false
}

func test_rabin_karp() {
	var pattern1 string = "abc1abc12"
	_ = pattern1
	var text1 string = "alskfjaldsabc1abc1abc12k23adsfabcabc"
	_ = text1
	var text2 string = "alskfjaldsk23adsfabcabc"
	_ = text2
	if !rabin_karp(pattern1, text1) || rabin_karp(pattern1, text2) {
		fmt.Println("Failure")
		return
	}
	var pattern2 string = "ABABX"
	_ = pattern2
	var text3 string = "ABABZABABYABABX"
	_ = text3
	if !rabin_karp(pattern2, text3) {
		fmt.Println("Failure")
		return
	}
	var pattern3 string = "AAAB"
	_ = pattern3
	var text4 string = "ABAAAAAB"
	_ = text4
	if !rabin_karp(pattern3, text4) {
		fmt.Println("Failure")
		return
	}
	var pattern4 string = "abcdabcy"
	_ = pattern4
	var text5 string = "abcxabcdabxabcdabcdabcy"
	_ = text5
	if !rabin_karp(pattern4, text5) {
		fmt.Println("Failure")
		return
	}
	var pattern5 string = "Lü"
	_ = pattern5
	var text6 string = "Lüsai"
	_ = text6
	if !rabin_karp(pattern5, text6) {
		fmt.Println("Failure")
		return
	}
	var pattern6 string = "Lue"
	_ = pattern6
	if rabin_karp(pattern6, text6) {
		fmt.Println("Failure")
		return
	}
	fmt.Println("Success.")
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		alphabet_size = 256
		modulus = 1000003
		test_rabin_karp()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
