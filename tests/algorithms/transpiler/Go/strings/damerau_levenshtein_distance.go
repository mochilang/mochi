//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-11 17:38:26 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func damerau_levenshtein_distance(first_string string, second_string string) int {
	var len1 int = len(first_string)
	_ = len1
	var len2 int = len(second_string)
	_ = len2
	var dp_matrix [][]int = [][]int{}
	_ = dp_matrix
	for _i := 0; _i < (len1 + 1); _i++ {
		var row []int = []int{}
		_ = row
		for _2 := 0; _2 < (len2 + 1); _2++ {
			row = append(row, 0)
		}
		dp_matrix = append(dp_matrix, row)
	}
	for i := 0; i < (len1 + 1); i++ {
		var row []int = _index(dp_matrix, i)
		_ = row
		_setIndex(row, 0, i)
		_setIndex(dp_matrix, i, row)
	}
	var first_row []int = _index(dp_matrix, 0)
	_ = first_row
	for j := 0; j < (len2 + 1); j++ {
		_setIndex(first_row, j, j)
	}
	_setIndex(dp_matrix, 0, first_row)
	for i := 1; i < (len1 + 1); i++ {
		var row []int = _index(dp_matrix, i)
		_ = row
		var first_char string = _substr(first_string, (i - 1), i)
		_ = first_char
		_ = first_char
		for j := 1; j < (len2 + 1); j++ {
			var second_char string = _substr(second_string, (j - 1), j)
			_ = second_char
			_ = second_char
			var cost int = func() int {
				if first_char == second_char {
					return 0
				} else {
					return 1
				}
			}()
			_ = cost
			var value int = (int(_index(_index(dp_matrix, (i-1)), j)) + 1)
			_ = value
			var insertion int = (int(_index(row, (j-1))) + 1)
			_ = insertion
			if insertion < value {
				value = insertion
			}
			var substitution int = (int(_index(_index(dp_matrix, (i-1)), (j-1))) + cost)
			_ = substitution
			if substitution < value {
				value = substitution
			}
			_setIndex(row, j, value)
			if (((i > 1) && (j > 1)) && (_substr(first_string, (i-1), i) == _substr(second_string, (j-2), (j-1)))) && (_substr(first_string, (i-2), (i-1)) == _substr(second_string, (j-1), j)) {
				var transposition int = (int(_index(_index(dp_matrix, (i-2)), (j-2))) + cost)
				_ = transposition
				if transposition < int(_index(row, j)) {
					_setIndex(row, j, transposition)
				}
			}
		}
		_setIndex(dp_matrix, i, row)
	}
	return _index(_index(dp_matrix, len1), len2)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		fmt.Println(fmt.Sprint(damerau_levenshtein_distance("cat", "cut")))
		fmt.Println(fmt.Sprint(damerau_levenshtein_distance("kitten", "sitting")))
		fmt.Println(fmt.Sprint(damerau_levenshtein_distance("hello", "world")))
		fmt.Println(fmt.Sprint(damerau_levenshtein_distance("book", "back")))
		fmt.Println(fmt.Sprint(damerau_levenshtein_distance("container", "containment")))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
