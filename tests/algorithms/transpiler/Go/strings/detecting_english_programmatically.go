//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-11 15:39:39 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

var LETTERS_AND_SPACE string

var LOWER string

var UPPER string

func to_upper(s string) string {
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(s) {
		c := string([]rune(s)[i:(i + 1)])
		_ = c
		var j int = 0
		_ = j
		up := c
		_ = up
		for j < len(LOWER) {
			if fmt.Sprint(c) == string([]rune(LOWER)[j:(j+1)]) {
				up = string([]rune(UPPER)[j:(j + 1)])
				break
			}
			j = (j + 1)
		}
		res = (res + fmt.Sprint(up))
		i = (i + 1)
	}
	return res
}

func char_in(chars string, c string) bool {
	var i int = 0
	_ = i
	for i < len(chars) {
		if string([]rune(chars)[i:(i+1)]) == c {
			return true
		}
		i = (i + 1)
	}
	return false
}

func remove_non_letters(message string) string {
	var res string = ""
	_ = res
	var i int = 0
	_ = i
	for i < len(message) {
		ch := string([]rune(message)[i:(i + 1)])
		_ = ch
		if char_in(LETTERS_AND_SPACE, ch) {
			res = (res + fmt.Sprint(ch))
		}
		i = (i + 1)
	}
	return res
}

func split_spaces(text string) []string {
	var res []string = []string{}
	_ = res
	var current string = ""
	_ = current
	var i int = 0
	_ = i
	for i < len(text) {
		ch := string([]rune(text)[i:(i + 1)])
		_ = ch
		if fmt.Sprint(ch) == " " {
			res = append(res, current)
			current = ""
		} else {
			current = (current + fmt.Sprint(ch))
		}
		i = (i + 1)
	}
	res = append(res, current)
	return res
}

func load_dictionary() map[string]bool {
	var words []string = []string{"HELLO", "WORLD", "HOW", "ARE", "YOU", "THE", "QUICK", "BROWN", "FOX", "JUMPS", "OVER", "LAZY", "DOG"}
	_ = words
	var dict map[string]bool = map[string]bool{}
	_ = dict
	for _, w := range words {
		dict[w] = true
	}
	return dict
}

var ENGLISH_WORDS map[string]bool

func get_english_count(message string) float64 {
	upper := to_upper(message)
	_ = upper
	cleaned := remove_non_letters(upper)
	_ = cleaned
	possible := split_spaces(cleaned)
	_ = possible
	var matches int = 0
	_ = matches
	var total int = 0
	_ = total
	for _, w := range possible {
		if fmt.Sprint(w) != "" {
			total = (total + 1)
			if func() bool { _, ok := ENGLISH_WORDS[w]; return ok }() {
				matches = (matches + 1)
			}
		}
	}
	if total == 0 {
		return 0.0
	}
	return (float64(matches) / float64(total))
}

func is_english(message string, word_percentage int, letter_percentage int) bool {
	words_match := ((get_english_count(message) * 100.0) >= float64(word_percentage))
	_ = words_match
	_ = words_match
	num_letters := len(remove_non_letters(message))
	_ = num_letters
	_ = num_letters
	letters_pct := func() float64 {
		if len(message) == 0 {
			return 0.0
		} else {
			return ((float64(num_letters) / float64(float64(len(message)))) * 100.0)
		}
	}()
	_ = letters_pct
	letters_match := (_toFloat(letters_pct) >= float64(letter_percentage))
	_ = letters_match
	_ = letters_match
	return (words_match && letters_match)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		LETTERS_AND_SPACE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz \t\n"
		LOWER = "abcdefghijklmnopqrstuvwxyz"
		UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		ENGLISH_WORDS = load_dictionary()
		fmt.Println(fmt.Sprint(is_english("Hello World", 20, 85)))
		fmt.Println(fmt.Sprint(is_english("llold HorWd", 20, 85)))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
