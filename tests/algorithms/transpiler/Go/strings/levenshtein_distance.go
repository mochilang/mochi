//go:build ignore

// Generated by Mochi v0.10.63 on 2025-08-11 15:35:59 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _index[T any](s []T, i any) T {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	return s[idx]
}

func _setIndex[T any](s []T, i any, v T) {
	idx := func(v any) int {
		if vv, ok := v.(int); ok {
			return vv
		}
		if vv, ok := v.(float64); ok {
			return int(vv)
		}
		return v.(int)
	}(i)
	if idx < 0 {
		idx += len(s)
	}
	s[idx] = v
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

func range_list(n int) []int {
	var lst []int = []int{}
	_ = lst
	var i int = 0
	_ = i
	for i < n {
		lst = append(lst, i)
		i = (i + 1)
	}
	return lst
}

func min3(a int, b int, c int) int {
	var m int = a
	_ = m
	if b < m {
		m = b
	}
	if c < m {
		m = c
	}
	return m
}

func levenshtein_distance(first_word string, second_word string) int {
	if len(first_word) < len(second_word) {
		return levenshtein_distance(second_word, first_word)
	}
	if len(second_word) == 0 {
		return len(first_word)
	}
	var previous_row []int = range_list((len(second_word) + 1))
	_ = previous_row
	var i int = 0
	_ = i
	for i < len(first_word) {
		c1 := string(_index([]rune(first_word), i))
		_ = c1
		_ = c1
		var current_row []int = []int{}
		_ = current_row
		current_row = append(current_row, (i + 1))
		var j int = 0
		_ = j
		for j < len(second_word) {
			c2 := string(_index([]rune(second_word), j))
			_ = c2
			_ = c2
			var insertions int = (int(_index(previous_row, (j+1))) + 1)
			_ = insertions
			var deletions int = (int(_index(current_row, j)) + 1)
			_ = deletions
			var substitutions int = (int(_index(previous_row, j)) + func() int {
				if _toFloat(c1) == _toFloat(c2) {
					return 0
				} else {
					return 1
				}
			}())
			_ = substitutions
			min_val := min3(insertions, deletions, substitutions)
			_ = min_val
			current_row = append(current_row, min_val)
			j = (j + 1)
		}
		previous_row = current_row
		i = (i + 1)
	}
	return _index(previous_row, (len(previous_row) - 1))
}

func levenshtein_distance_optimized(first_word string, second_word string) int {
	if len(first_word) < len(second_word) {
		return levenshtein_distance_optimized(second_word, first_word)
	}
	if len(second_word) == 0 {
		return len(first_word)
	}
	var previous_row []int = range_list((len(second_word) + 1))
	_ = previous_row
	var i int = 0
	_ = i
	for i < len(first_word) {
		c1 := string(_index([]rune(first_word), i))
		_ = c1
		_ = c1
		var current_row []int = []int{}
		_ = current_row
		current_row = append(current_row, (i + 1))
		var k int = 0
		_ = k
		for k < len(second_word) {
			current_row = append(current_row, 0)
			k = (k + 1)
		}
		var j int = 0
		_ = j
		for j < len(second_word) {
			c2 := string(_index([]rune(second_word), j))
			_ = c2
			_ = c2
			var insertions int = (int(_index(previous_row, (j+1))) + 1)
			_ = insertions
			var deletions int = (int(_index(current_row, j)) + 1)
			_ = deletions
			var substitutions int = (int(_index(previous_row, j)) + func() int {
				if _toFloat(c1) == _toFloat(c2) {
					return 0
				} else {
					return 1
				}
			}())
			_ = substitutions
			min_val := min3(insertions, deletions, substitutions)
			_ = min_val
			_setIndex(current_row, (j + 1), min_val)
			j = (j + 1)
		}
		previous_row = current_row
		i = (i + 1)
	}
	return _index(previous_row, (len(previous_row) - 1))
}

func mochiMain() {
	var a string = "kitten"
	_ = a
	var b string = "sitting"
	_ = b
	fmt.Println(fmt.Sprint(levenshtein_distance(a, b)))
	fmt.Println(fmt.Sprint(levenshtein_distance_optimized(a, b)))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
