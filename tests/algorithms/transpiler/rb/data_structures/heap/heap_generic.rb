# Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:22 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def new_heap(key)
    return Heap.new(arr: [], pos_map: {}, size: 0, key: key)
  end
  def parent(i)
    if i > 0
      return (i - 1) / 2
    end
    return -1
  end
  def left(i, size)
    l = _add(2 * i, 1)
    if l < size
      return l
    end
    return -1
  end
  def right(i, size)
    r = _add(2 * i, 2)
    if r < size
      return r
    end
    return -1
  end
  def swap(h, i, j)
    arr = h.arr
    item_i = arr[i][0]
    item_j = arr[j][0]
    pm = h.pos_map
    pm[item_i] = _add(j, 1)
    pm[item_j] = _add(i, 1)
    h["pos_map"] = pm
    tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
    h["arr"] = arr
  end
  def cmp(h, i, j)
    arr = h.arr
    return arr[i][1] < arr[j][1]
  end
  def get_valid_parent(h, i)
    vp = i
    l = left(i, h.size)
    if l != 0 - 1 && cmp(h, l, vp) == false
      vp = l
    end
    r = right(i, h.size)
    if r != 0 - 1 && cmp(h, r, vp) == false
      vp = r
    end
    return vp
  end
  def heapify_up(h, index)
    idx = index
    p = parent(idx)
    while p != 0 - 1 && cmp(h, idx, p) == false
      swap(h, idx, p)
      idx = p
      p = parent(p)
    end
  end
  def heapify_down(h, index)
    idx = index
    vp = get_valid_parent(h, idx)
    while vp != idx
      swap(h, idx, vp)
      idx = vp
      vp = get_valid_parent(h, idx)
    end
  end
  def update_item(h, item, item_value)
    pm = h.pos_map
    if pm[item] == 0
      return
    end
    index = pm[item] - 1
    arr = h.arr
    arr[index] = [item, h.key.call(item_value)]
    h["arr"] = arr
    h["pos_map"] = pm
    heapify_up(h, index)
    heapify_down(h, index)
  end
  def delete_item(h, item)
    pm = h.pos_map
    if pm[item] == 0
      return
    end
    index = pm[item] - 1
    pm[item] = 0
    arr = h.arr
    last_index = h.size - 1
    if index != last_index
      arr[index] = arr[last_index]
      moved = arr[index][0]
      pm[moved] = _add(index, 1)
    end
    h["size"] = h.size - 1
    h["arr"] = arr
    h["pos_map"] = pm
    if h.size > index
      heapify_up(h, index)
      heapify_down(h, index)
    end
  end
  def insert_item(h, item, item_value)
    arr = h.arr
    arr_len = arr.length
    if arr_len == h.size
      arr = (arr << [item, h.key.call(item_value)])
    else
      arr[h.size] = [item, h.key.call(item_value)]
    end
    pm = h.pos_map
    pm[item] = _add(h.size, 1)
    h["size"] = _add(h.size, 1)
    h["arr"] = arr
    h["pos_map"] = pm
    heapify_up(h, h.size - 1)
  end
  def get_top(h)
    arr = h.arr
    if h.size > 0
      return arr[0]
    end
    return []
  end
  def extract_top(h)
    top = get_top(h)
    if top.length > 0
      delete_item(h, top[0])
    end
    return top
  end
  def identity(x)
    return x
  end
  def negate(x)
    return 0 - x
  end
  Heap = Struct.new(:arr, :pos_map, :size, :key, keyword_init: true)
  $h = new_heap(method(:identity))
  insert_item($h, 5, 34)
  insert_item($h, 6, 31)
  insert_item($h, 7, 37)
  puts(((x = get_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts(((x = extract_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts(((x = extract_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts(((x = extract_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  $h = new_heap(method(:negate))
  insert_item($h, 5, 34)
  insert_item($h, 6, 31)
  insert_item($h, 7, 37)
  puts(((x = get_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts(((x = extract_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts(((x = extract_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts(((x = extract_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  insert_item($h, 8, 45)
  insert_item($h, 9, 40)
  insert_item($h, 10, 50)
  puts(((x = get_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  update_item($h, 10, 30)
  puts(((x = get_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  delete_item($h, 10)
  puts(((x = get_top($h)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
