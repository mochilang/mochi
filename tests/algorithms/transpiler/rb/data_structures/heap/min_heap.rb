# Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:43 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def get_parent_idx(idx)
    return (idx - 1) / 2
  end
  def get_left_child_idx(idx)
    return _add(idx * 2, 1)
  end
  def get_right_child_idx(idx)
    return _add(idx * 2, 2)
  end
  def remove_key(m, k)
    out = {}
        __tmp1 = m.keys()
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |key|
      if key != k
        out[key] = m[key]
      end
    end
    return out
  end
  def slice_without_last(xs)
    res = []
    i = 0
    while i < xs.length - 1
      res = (res << (xs[i]))
      i = _add(i, 1)
    end
    return res
  end
  def sift_down(mh, idx)
    heap = mh.heap
    idx_map = mh.idx_of_element
    i = idx
    while true
      left = get_left_child_idx(i)
      right = get_right_child_idx(i)
      smallest = i
      if left < heap.length && heap[left].val < heap[smallest].val
        smallest = left
      end
      if right < heap.length && heap[right].val < heap[smallest].val
        smallest = right
      end
      if smallest != i
        tmp = heap[i]
        heap[i] = heap[smallest]
        heap[smallest] = tmp
        idx_map[heap[i].name] = i
        idx_map[heap[smallest].name] = smallest
        i = smallest
      else
        break
      end
    end
    mh["heap"] = heap
    mh["idx_of_element"] = idx_map
  end
  def sift_up(mh, idx)
    heap = mh.heap
    idx_map = mh.idx_of_element
    i = idx
    p = get_parent_idx(i)
    while p >= 0 && heap[p].val > heap[i].val
      tmp = heap[p]
      heap[p] = heap[i]
      heap[i] = tmp
      idx_map[heap[p].name] = p
      idx_map[heap[i].name] = i
      i = p
      p = get_parent_idx(i)
    end
    mh["heap"] = heap
    mh["idx_of_element"] = idx_map
  end
  def new_min_heap(array)
    idx_map = {}
    val_map = {}
    heap = array
    i = 0
    while i < array.length
      n = array[i]
      idx_map[n.name] = i
      val_map[n.name] = n.val
      i = _add(i, 1)
    end
    mh = MinHeap.new(heap: heap, idx_of_element: idx_map, heap_dict: val_map)
    start = get_parent_idx(array.length - 1)
    while start >= 0
      sift_down(mh, start)
      start = start - 1
    end
    return mh
  end
  def peek(mh)
    return mh.heap[0]
  end
  def remove_min(mh)
    heap = mh.heap
    idx_map = mh.idx_of_element
    val_map = mh.heap_dict
    last_idx = heap.length - 1
    top = heap[0]
    last = heap[last_idx]
    heap[0] = last
    idx_map[last.name] = 0
    heap = slice_without_last(heap)
    idx_map = remove_key(idx_map, top.name)
    val_map = remove_key(val_map, top.name)
    mh["heap"] = heap
    mh["idx_of_element"] = idx_map
    mh["heap_dict"] = val_map
    if heap.length > 0
      sift_down(mh, 0)
    end
    return top
  end
  def insert(mh, node)
    heap = mh.heap
    idx_map = mh.idx_of_element
    val_map = mh.heap_dict
    heap = (heap << (node))
    idx = heap.length - 1
    idx_map[node.name] = idx
    val_map[node.name] = node.val
    mh["heap"] = heap
    mh["idx_of_element"] = idx_map
    mh["heap_dict"] = val_map
    sift_up(mh, idx)
  end
  def is_empty(mh)
    return mh.heap.length == 0
  end
  def get_value(mh, key)
    return mh.heap_dict[key]
  end
  def decrease_key(mh, node, new_value)
    heap = mh.heap
    val_map = mh.heap_dict
    idx_map = mh.idx_of_element
    idx = idx_map[node.name]
    if !(heap[idx].val > new_value)
      panic("newValue must be less than current value")
    end
    node["val"] = new_value
    heap[idx]["val"] = new_value
    val_map[node.name] = new_value
    mh["heap"] = heap
    mh["heap_dict"] = val_map
    sift_up(mh, idx)
  end
  def node_to_string(n)
    return _add(_add(_add(_add("Node(", n.name), ", "), (n.val).to_s), ")")
  end
  Node = Struct.new(:name, :val, keyword_init: true)
  MinHeap = Struct.new(:heap, :idx_of_element, :heap_dict, keyword_init: true)
  $r = Node.new(name: "R", val: -1)
  $b = Node.new(name: "B", val: 6)
  $a = Node.new(name: "A", val: 3)
  $x = Node.new(name: "X", val: 1)
  $e = Node.new(name: "E", val: 4)
  $my_min_heap = new_min_heap([$r, $b, $a, $x, $e])
  puts("Min Heap - before decrease key")
    __tmp2 = $my_min_heap.heap
  if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
    __tmp2 = __tmp2.keys
  end
  __tmp2.each do |n|
    puts(node_to_string(n))
  end
  puts("Min Heap - After decrease key of node [B -> -17]")
  decrease_key($my_min_heap, $b, -17)
    __tmp3 = $my_min_heap.heap
  if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
    __tmp3 = __tmp3.keys
  end
  __tmp3.each do |n|
    puts(node_to_string(n))
  end
  puts((get_value($my_min_heap, "B")).to_s)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
