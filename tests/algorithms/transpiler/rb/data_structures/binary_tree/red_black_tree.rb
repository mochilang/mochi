# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:56 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def make_tree()
    return RBTree.new(nodes: [], root: -1)
  end
  def rotate_left(t, x)
    nodes = t["nodes"]
    y = nodes[x][$RIGHT]
    yLeft = nodes[y][$LEFT]
    nodes[x][$RIGHT] = yLeft
    if yLeft != $NEG_ONE
      nodes[yLeft][$PARENT] = x
    end
    xParent = nodes[x][$PARENT]
    nodes[y][$PARENT] = xParent
    if xParent == $NEG_ONE
      t["root"] = y
    else
      if x == nodes[xParent][$LEFT]
        nodes[xParent][$LEFT] = y
      else
        nodes[xParent][$RIGHT] = y
      end
    end
    nodes[y][$LEFT] = x
    nodes[x][$PARENT] = y
    t["nodes"] = nodes
    return t
  end
  def rotate_right(t, x)
    nodes = t["nodes"]
    y = nodes[x][$LEFT]
    yRight = nodes[y][$RIGHT]
    nodes[x][$LEFT] = yRight
    if yRight != $NEG_ONE
      nodes[yRight][$PARENT] = x
    end
    xParent = nodes[x][$PARENT]
    nodes[y][$PARENT] = xParent
    if xParent == $NEG_ONE
      t["root"] = y
    else
      if x == nodes[xParent][$RIGHT]
        nodes[xParent][$RIGHT] = y
      else
        nodes[xParent][$LEFT] = y
      end
    end
    nodes[y][$RIGHT] = x
    nodes[x][$PARENT] = y
    t["nodes"] = nodes
    return t
  end
  def insert_fix(t, z)
    nodes = t["nodes"]
    while z != t["root"] && nodes[nodes[z][$PARENT]][$COLOR] == 1
      if nodes[z][$PARENT] == nodes[nodes[nodes[z][$PARENT]][$PARENT]][$LEFT]
        y = nodes[nodes[nodes[z][$PARENT]][$PARENT]][$RIGHT]
        if y != $NEG_ONE && nodes[y][$COLOR] == 1
          nodes[nodes[z][$PARENT]][$COLOR] = 0
          nodes[y][$COLOR] = 0
          gp = nodes[nodes[z][$PARENT]][$PARENT]
          nodes[gp][$COLOR] = 1
          z = gp
        else
          if z == nodes[nodes[z][$PARENT]][$RIGHT]
            z = nodes[z][$PARENT]
            t["nodes"] = nodes
            t = rotate_left(t, z)
            nodes = t["nodes"]
          end
          nodes[nodes[z][$PARENT]][$COLOR] = 0
          gp = nodes[nodes[z][$PARENT]][$PARENT]
          nodes[gp][$COLOR] = 1
          t["nodes"] = nodes
          t = rotate_right(t, gp)
          nodes = t["nodes"]
        end
      else
        y = nodes[nodes[nodes[z][$PARENT]][$PARENT]][$LEFT]
        if y != $NEG_ONE && nodes[y][$COLOR] == 1
          nodes[nodes[z][$PARENT]][$COLOR] = 0
          nodes[y][$COLOR] = 0
          gp = nodes[nodes[z][$PARENT]][$PARENT]
          nodes[gp][$COLOR] = 1
          z = gp
        else
          if z == nodes[nodes[z][$PARENT]][$LEFT]
            z = nodes[z][$PARENT]
            t["nodes"] = nodes
            t = rotate_right(t, z)
            nodes = t["nodes"]
          end
          nodes[nodes[z][$PARENT]][$COLOR] = 0
          gp = nodes[nodes[z][$PARENT]][$PARENT]
          nodes[gp][$COLOR] = 1
          t["nodes"] = nodes
          t = rotate_left(t, gp)
          nodes = t["nodes"]
        end
      end
    end
    nodes = t["nodes"]
    nodes[t["root"]][$COLOR] = 0
    t["nodes"] = nodes
    return t
  end
  def tree_insert(t, v)
    nodes = t["nodes"]
    node = [v, 1, -1, -1, -1]
    nodes = (nodes << node)
    idx = nodes.length - 1
    y = $NEG_ONE
    x = t["root"]
    while x != $NEG_ONE
      y = x
      if v < nodes[x][$LABEL]
        x = nodes[x][$LEFT]
      else
        x = nodes[x][$RIGHT]
      end
    end
    nodes[idx][$PARENT] = y
    if y == $NEG_ONE
      t["root"] = idx
    else
      if v < nodes[y][$LABEL]
        nodes[y][$LEFT] = idx
      else
        nodes[y][$RIGHT] = idx
      end
    end
    t["nodes"] = nodes
    t = insert_fix(t, idx)
    return t
  end
  def inorder(t, x, acc)
    if x == $NEG_ONE
      return acc
    end
    acc = inorder(t, t["nodes"][x][$LEFT], acc)
    acc = (acc << t["nodes"][x][$LABEL])
    acc = inorder(t, t["nodes"][x][$RIGHT], acc)
    return acc
  end
  def main()
    t = make_tree()
    values = [10, 20, 30, 15, 25, 5, 1]
    i = 0
    while i < values.length
      t = tree_insert(t, values[i])
      i = _add(i, 1)
    end
    res = []
    res = inorder(t, t["root"], res)
    puts(((x = res); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  end
  $LABEL = 0
  $COLOR = 1
  $PARENT = 2
  $LEFT = 3
  $RIGHT = 4
  $NEG_ONE = -1
  RBTree = Struct.new(:nodes, :root, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
