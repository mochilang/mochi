# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:56 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def fenwick_from_list(arr)
    size = arr.length
    tree = []
    i = 0
    while i < size
      tree = (tree + [arr[i]])
      i = _add(i, 1)
    end
    i = 1
    while i < size
      j = fenwick_next(i)
      if j < size
        tree[j] = _add(tree[j], tree[i])
      end
      i = _add(i, 1)
    end
    return FenwickTree.new(size: size, tree: tree)
  end
  def fenwick_empty(size)
    tree = []
    i = 0
    while i < size
      tree = (tree + [0])
      i = _add(i, 1)
    end
    return FenwickTree.new(size: size, tree: tree)
  end
  def fenwick_get_array(f)
    arr = []
    i = 0
    while i < f["size"]
      arr = (arr + [f["tree"][i]])
      i = _add(i, 1)
    end
    i = f["size"] - 1
    while i > 0
      j = fenwick_next(i)
      if j < f["size"]
        arr[j] = arr[j] - arr[i]
      end
      i = i - 1
    end
    return arr
  end
  def bit_and(a, b)
    ua = a
    ub = b
    res = 0
    bit = 1
    while ua != 0 || ub != 0
      if ua % 2 == 1 && ub % 2 == 1
        res = _add(res, bit)
      end
      ua = ((ua / 2)).to_i
      ub = ((ub / 2)).to_i
      bit = bit * 2
    end
    return res
  end
  def low_bit(x)
    if x == 0
      return 0
    end
    return x - bit_and(x, x - 1)
  end
  def fenwick_next(index)
    return _add(index, low_bit(index))
  end
  def fenwick_prev(index)
    return index - low_bit(index)
  end
  def fenwick_add(f, index, value)
    tree = f["tree"]
    if index == 0
      tree[0] = _add(tree[0], value)
      return FenwickTree.new(size: f["size"], tree: tree)
    end
    i = index
    while i < f["size"]
      tree[i] = _add(tree[i], value)
      i = fenwick_next(i)
    end
    return FenwickTree.new(size: f["size"], tree: tree)
  end
  def fenwick_update(f, index, value)
    current = fenwick_get(f, index)
    return fenwick_add(f, index, value - current)
  end
  def fenwick_prefix(f, right)
    if right == 0
      return 0
    end
    result = f["tree"][0]
    r = right - 1
    while r > 0
      result = _add(result, f["tree"][r])
      r = fenwick_prev(r)
    end
    return result
  end
  def fenwick_query(f, left, right)
    return fenwick_prefix(f, right) - fenwick_prefix(f, left)
  end
  def fenwick_get(f, index)
    return fenwick_query(f, index, _add(index, 1))
  end
  def fenwick_rank_query(f, value)
    v = value - f["tree"][0]
    if v < 0
      return -1
    end
    j = 1
    while j * 2 < f["size"]
      j = j * 2
    end
    i = 0
    jj = j
    while jj > 0
      if _add(i, jj) < f["size"] && f["tree"][_add(i, jj)] <= v
        v = v - f["tree"][_add(i, jj)]
        i = _add(i, jj)
      end
      jj = jj / 2
    end
    return i
  end
  FenwickTree = Struct.new(:size, :tree, keyword_init: true)
  $f_base = fenwick_from_list([1, 2, 3, 4, 5])
  puts(((x = fenwick_get_array($f_base)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
  $f = fenwick_from_list([1, 2, 3, 4, 5])
  $f = fenwick_add($f, 0, 1)
  $f = fenwick_add($f, 1, 2)
  $f = fenwick_add($f, 2, 3)
  $f = fenwick_add($f, 3, 4)
  $f = fenwick_add($f, 4, 5)
  puts(((x = fenwick_get_array($f)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
  $f2 = fenwick_from_list([1, 2, 3, 4, 5])
  puts(fenwick_prefix($f2, 3))
  puts(fenwick_query($f2, 1, 4))
  $f3 = fenwick_from_list([1, 2, 0, 3, 0, 5])
  puts(fenwick_rank_query($f3, 0))
  puts(fenwick_rank_query($f3, 2))
  puts(fenwick_rank_query($f3, 1))
  puts(fenwick_rank_query($f3, 3))
  puts(fenwick_rank_query($f3, 5))
  puts(fenwick_rank_query($f3, 6))
  puts(fenwick_rank_query($f3, 11))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
