# Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:22 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def make_list(length, value)
    lst = []
    i = 0
    while i < length
      lst = (lst << value)
      i = _add(i, 1)
    end
    return lst
  end
  def min_list(arr)
    m = arr[0]
    i = 1
    while i < arr.length
      if arr[i] < m
        m = arr[i]
      end
      i = _add(i, 1)
    end
    return m
  end
  def max_list(arr)
    m = arr[0]
    i = 1
    while i < arr.length
      if arr[i] > m
        m = arr[i]
      end
      i = _add(i, 1)
    end
    return m
  end
  def build_tree(arr)
    n = Node.new(minn: min_list(arr), maxx: max_list(arr), map_left: make_list(arr.length, 0), left: -1, right: -1)
    if n.minn == n.maxx
      $nodes = ($nodes << n)
      return $nodes.length - 1
    end
    pivot = (_add(n.minn, n.maxx)) / 2
    left_arr = []
    right_arr = []
    i = 0
    while i < arr.length
      num = arr[i]
      if num <= pivot
        left_arr = (left_arr << num)
      else
        right_arr = (right_arr << num)
      end
      ml = n.map_left
      ml[i] = left_arr.length
      n["map_left"] = ml
      i = _add(i, 1)
    end
    if left_arr.length > 0
      n["left"] = build_tree(left_arr)
    end
    if right_arr.length > 0
      n["right"] = build_tree(right_arr)
    end
    $nodes = ($nodes << n)
    return $nodes.length - 1
  end
  def rank_till_index(node_idx, num, index)
    if index < 0 || node_idx < 0
      return 0
    end
    node = $nodes[node_idx]
    if node["minn"] == node["maxx"]
      if node["minn"] == num
        return _add(index, 1)
      else
        return 0
      end
    end
    pivot = (_add(node["minn"], node["maxx"])) / 2
    if num <= pivot
      return rank_till_index(node["left"], num, node["map_left"][index] - 1)
    else
      return rank_till_index(node["right"], num, index - node["map_left"][index])
    end
  end
  def rank(node_idx, num, start, end_)
    if start > end_
      return 0
    end
    rank_till_end = rank_till_index(node_idx, num, end_)
    rank_before_start = rank_till_index(node_idx, num, start - 1)
    return rank_till_end - rank_before_start
  end
  def quantile(node_idx, index, start, end_)
    if index > (end_ - start) || start > end_ || node_idx < 0
      return -1
    end
    node = $nodes[node_idx]
    if node["minn"] == node["maxx"]
      return node["minn"]
    end
    left_start = (start == 0 ? 0 : node["map_left"][start - 1])
    num_left = node["map_left"][end_] - left_start
    if num_left > index
      return quantile(node["left"], index, left_start, node["map_left"][end_] - 1)
    else
      return quantile(node["right"], index - num_left, start - left_start, end_ - node["map_left"][end_])
    end
  end
  def range_counting(node_idx, start, end_, start_num, end_num)
    if start > end_ || node_idx < 0 || start_num > end_num
      return 0
    end
    node = $nodes[node_idx]
    if node["minn"] > end_num || node["maxx"] < start_num
      return 0
    end
    if start_num <= node["minn"] && node["maxx"] <= end_num
      return _add(end_ - start, 1)
    end
    left = range_counting(node["left"], (start == 0 ? 0 : node["map_left"][start - 1]), node["map_left"][end_] - 1, start_num, end_num)
    right = range_counting(node["right"], start - ((start == 0 ? 0 : node["map_left"][start - 1])), end_ - node["map_left"][end_], start_num, end_num)
    return _add(left, right)
  end
  Node = Struct.new(:minn, :maxx, :map_left, :left, :right, keyword_init: true)
  $nodes = []
  $test_array = [2, 1, 4, 5, 6, 0, 8, 9, 1, 2, 0, 6, 4, 2, 0, 6, 5, 3, 2, 7]
  $root = build_tree($test_array)
  puts(_add("rank_till_index 6 at 6 -> ", (rank_till_index($root, 6, 6)).to_s))
  puts(_add("rank 6 in [3,13] -> ", (rank($root, 6, 3, 13)).to_s))
  puts(_add("quantile index 2 in [2,5] -> ", (quantile($root, 2, 2, 5)).to_s))
  puts(_add("range_counting [3,7] in [1,10] -> ", (range_counting($root, 1, 10, 3, 7)).to_s))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
