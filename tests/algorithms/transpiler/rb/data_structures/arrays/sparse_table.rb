# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def pow2(n)
    result = 1
    i = 0
    while i < n
      result = result * 2
      i = _add(i, 1)
    end
    return result
  end
  def int_log2(n)
    v = n
    res = 0
    while v > 1
      v = v / 2
      res = _add(res, 1)
    end
    return res
  end
  def build_sparse_table(number_list)
    if number_list.length == 0
      panic("empty number list not allowed")
    end
    length = number_list.length
    row = _add(int_log2(length), 1)
    sparse_table = []
    j = 0
    while j < row
      inner = []
      i = 0
      while i < length
        inner = (inner + [0])
        i = _add(i, 1)
      end
      sparse_table = (sparse_table + [inner])
      j = _add(j, 1)
    end
    i = 0
    while i < length
      sparse_table[0][i] = number_list[i]
      i = _add(i, 1)
    end
    j = 1
    while pow2(j) <= length
      i = 0
      while _add(i, pow2(j)) - 1 < length
        left = sparse_table[j - 1][_add(i, pow2(j - 1))]
        right = sparse_table[j - 1][i]
        if left < right
          sparse_table[j][i] = left
        else
          sparse_table[j][i] = right
        end
        i = _add(i, 1)
      end
      j = _add(j, 1)
    end
    return sparse_table
  end
  def query(sparse_table, left_bound, right_bound)
    if left_bound < 0 || right_bound >= sparse_table[0].length
      panic("list index out of range")
    end
    interval = _add(right_bound - left_bound, 1)
    j = int_log2(interval)
    val1 = sparse_table[j][_add(right_bound - pow2(j), 1)]
    val2 = sparse_table[j][left_bound]
    if val1 < val2
      return val1
    end
    return val2
  end
  $st1 = build_sparse_table([8, 1, 0, 3, 4, 9, 3])
  puts(((x = $st1); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  $st2 = build_sparse_table([3, 1, 9])
  puts(((x = $st2); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
  puts((query($st1, 0, 4)).to_s)
  puts((query($st1, 4, 6)).to_s)
  puts((query($st2, 2, 2)).to_s)
  puts((query($st2, 0, 1)).to_s)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
