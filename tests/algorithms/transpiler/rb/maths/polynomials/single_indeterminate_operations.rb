# Generated by Mochi transpiler v0.10.59 on 2025-08-07 00:17 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

start_mem = _mem()
start = _now()
  def copy_list(xs)
    res = [].clone
    i = 0.clone
    while i < xs.length
      res = (res << (xs[i])).clone
      i = _add(i, 1).clone
    end
    return res
  end
  def polynomial_new(degree, coeffs)
    if coeffs.length != _add(degree, 1)
      panic("The number of coefficients should be equal to the degree + 1.")
    end
    return Polynomial.new(degree: degree, coefficients: copy_list(coeffs))
  end
  def add(p, q)
    if p.degree > q.degree
      coeffs = copy_list(p.coefficients).clone
      i = 0.clone
      while i <= q.degree
        coeffs[i] = _add(coeffs[i], q.coefficients[i])
        i = _add(i, 1).clone
      end
      return Polynomial.new(degree: p.degree, coefficients: coeffs)
    else
      coeffs = copy_list(q.coefficients).clone
      i = 0.clone
      while i <= p.degree
        coeffs[i] = _add(coeffs[i], p.coefficients[i])
        i = _add(i, 1).clone
      end
      return Polynomial.new(degree: q.degree, coefficients: coeffs)
    end
  end
  def neg(p)
    coeffs = [].clone
    i = 0.clone
    while i <= p.degree
      coeffs = (coeffs << (-p.coefficients[i])).clone
      i = _add(i, 1).clone
    end
    return Polynomial.new(degree: p.degree, coefficients: coeffs)
  end
  def sub(p, q)
    return add(p, neg(q))
  end
  def mul(p, q)
    size = _add(_add(p.degree, q.degree), 1).clone
    coeffs = [].clone
    i = 0.clone
    while i < size
      coeffs = (coeffs << (0.0)).clone
      i = _add(i, 1).clone
    end
    i = 0.clone
    while i <= p.degree
      j = 0.clone
      while j <= q.degree
        coeffs[_add(i, j)] = _add(coeffs[_add(i, j)], p.coefficients[i] * q.coefficients[j])
        j = _add(j, 1).clone
      end
      i = _add(i, 1).clone
    end
    return Polynomial.new(degree: _add(p.degree, q.degree), coefficients: coeffs)
  end
  def power(base, exp)
    result = 1.0.clone
    i = 0.clone
    while i < exp
      result = result * base.clone
      i = _add(i, 1).clone
    end
    return result
  end
  def evaluate(p, x)
    result = 0.0.clone
    i = 0.clone
    while i <= p.degree
      result = _add(result, p.coefficients[i] * power(x, i)).clone
      i = _add(i, 1).clone
    end
    return result
  end
  def poly_to_string(p)
    s = "".clone
    i = p.degree.clone
    while i >= 0
      coeff = p.coefficients[i]
      if coeff != 0.0
        if s.length > 0
          if coeff > 0.0
            s = _add(s, " + ").clone
          else
            s = _add(s, " - ").clone
          end
        else
          if coeff < 0.0
            s = _add(s, "-").clone
          end
        end
        abs_coeff = (coeff < 0.0 ? -coeff : coeff)
        if i == 0
          s = _add(s, _str(abs_coeff)).clone
        else
          if i == 1
            s = _add(_add(s, _str(abs_coeff)), "x").clone
          else
            s = _add(_add(_add(s, _str(abs_coeff)), "x^"), _str(i)).clone
          end
        end
      end
      i = i - 1.clone
    end
    if s == ""
      s = "0".clone
    end
    return s
  end
  def derivative(p)
    if p.degree == 0
      return Polynomial.new(degree: 0, coefficients: [0.0])
    end
    coeffs = [].clone
    i = 0.clone
    while i < p.degree
      coeffs = (coeffs << (p.coefficients[_add(i, 1)] * (_add(i, 1)).to_f)).clone
      i = _add(i, 1).clone
    end
    return Polynomial.new(degree: p.degree - 1, coefficients: coeffs)
  end
  def integral(p, constant)
    coeffs = [constant].clone
    i = 0.clone
    while i <= p.degree
      coeffs = (coeffs << (p.coefficients[i] / (_add(i, 1)).to_f)).clone
      i = _add(i, 1).clone
    end
    return Polynomial.new(degree: _add(p.degree, 1), coefficients: coeffs)
  end
  def equals(p, q)
    if p.degree != q.degree
      return false
    end
    i = 0.clone
    while i <= p.degree
      if p.coefficients[i] != q.coefficients[i]
        return false
      end
      i = _add(i, 1).clone
    end
    return true
  end
  def not_equals(p, q)
    return !equals(p, q)
  end
  def test_polynomial()
    p = polynomial_new(2, [1.0, 2.0, 3.0])
    q = polynomial_new(2, [1.0, 2.0, 3.0])
    if poly_to_string(add(p, q)) != "6x^2 + 4x + 2"
      panic("add failed")
    end
    if poly_to_string(sub(p, q)) != "0"
      panic("sub failed")
    end
    if evaluate(p, 2.0) != 17.0
      panic("evaluate failed")
    end
    if poly_to_string(derivative(p)) != "6x + 2"
      panic("derivative failed")
    end
    integ = poly_to_string(integral(p, 0.0))
    if integ != "1x^3 + 1x^2 + 1x"
      panic("integral failed")
    end
    if !equals(p, q)
      panic("equals failed")
    end
    if not_equals(p, q)
      panic("not_equals failed")
    end
  end
  def main()
    test_polynomial()
    p = polynomial_new(2, [1.0, 2.0, 3.0])
    d = derivative(p)
    puts(poly_to_string(d))
  end
  Polynomial = Struct.new(:degree, :coefficients, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
