# Generated by Mochi transpiler v0.10.66 on 2025-08-16 14:44 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  x = x.clone if x.is_a?(Array)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def log2(x)
    k = 0.0
    v = x
    while v >= 2.0
      v = v / 2.0
      k = _add(k, 1.0)
    end
    while v < 1.0
      v = v * 2.0
      k = k - 1.0
    end
    z = (v - 1.0) / (_add(v, 1.0))
    zpow = z
    sum = z
    i = 3
    while i <= 9
      zpow = zpow * z * z
      sum = _add(sum, zpow / ((i).to_f))
      i = _add(i, 2)
    end
    ln2 = 0.6931471805599453
    return _add(k, 2.0 * sum / ln2)
  end
  def analyze_text(text)
    single = {}
    double = {}
    n = _len(text)
    if _eq(n, 0)
      return TextCounts.new(single: single, double: double)
    end
    last = text[n - 1...n]
    if _has(single, last)
      single[last] = _add((__tmp1 = single; __tmp1.is_a?(Hash) ? __tmp1[last] : _idx(__tmp1, last)), 1)
    else
      single[last] = 1
    end
    first = text[0...1]
    pair0 = _add(" ", first)
    double[pair0] = 1
    i = 0
    while i < n - 1
      ch = text[i..._add(i, 1)]
      if _has(single, ch)
        single[ch] = _add((__tmp2 = single; __tmp2.is_a?(Hash) ? __tmp2[ch] : _idx(__tmp2, ch)), 1)
      else
        single[ch] = 1
      end
      seq = text[i..._add(i, 2)]
      if _has(double, seq)
        double[seq] = _add((__tmp3 = double; __tmp3.is_a?(Hash) ? __tmp3[seq] : _idx(__tmp3, seq)), 1)
      else
        double[seq] = 1
      end
      i = _add(i, 1)
    end
    return TextCounts.new(single: single, double: double)
  end
  def round_to_int(x)
    if x < 0.0
      return ((x - 0.5)).to_i
    end
    return ((_add(x, 0.5))).to_i
  end
  def calculate_entropy(text)
    counts = analyze_text(text)
    alphas = " abcdefghijklmnopqrstuvwxyz"
    total1 = 0
        __tmp4 = counts.single.keys()
    __tmp4 = [] if __tmp4.nil?
    if __tmp4.respond_to?(:keys) && !__tmp4.is_a?(String)
      __tmp4 = __tmp4.keys
    end
    __tmp4.each do |ch|
      total1 = _add(total1, (__tmp5 = counts.single; __tmp5.is_a?(Hash) ? __tmp5[ch] : _idx(__tmp5, ch)))
    end
    h1 = 0.0
    i = 0
    while i < _len(alphas)
      ch = alphas[i..._add(i, 1)]
      if _has(counts.single, ch)
        prob = (((__tmp6 = counts.single; __tmp6.is_a?(Hash) ? __tmp6[ch] : _idx(__tmp6, ch))).to_f) / ((total1).to_f)
        h1 = _add(h1, prob * log2(prob))
      end
      i = _add(i, 1)
    end
    first_entropy = -h1
    puts(_add(_str(round_to_int(first_entropy)), ".0"))
    total2 = 0
        __tmp7 = counts.double.keys()
    __tmp7 = [] if __tmp7.nil?
    if __tmp7.respond_to?(:keys) && !__tmp7.is_a?(String)
      __tmp7 = __tmp7.keys
    end
    __tmp7.each do |seq|
      total2 = _add(total2, (__tmp8 = counts.double; __tmp8.is_a?(Hash) ? __tmp8[seq] : _idx(__tmp8, seq)))
    end
    h2 = 0.0
    a0 = 0
    while a0 < _len(alphas)
      ch0 = alphas[a0..._add(a0, 1)]
      a1 = 0
      while a1 < _len(alphas)
        ch1 = alphas[a1..._add(a1, 1)]
        seq = _add(ch0, ch1)
        if _has(counts.double, seq)
          prob = (((__tmp9 = counts.double; __tmp9.is_a?(Hash) ? __tmp9[seq] : _idx(__tmp9, seq))).to_f) / ((total2).to_f)
          h2 = _add(h2, prob * log2(prob))
        end
        a1 = _add(a1, 1)
      end
      a0 = _add(a0, 1)
    end
    second_entropy = -h2
    puts(_add(_str(round_to_int(second_entropy)), ".0"))
    diff = second_entropy - first_entropy
    puts(_add(_str(round_to_int(diff)), ".0"))
  end
  Object.send(:remove_const, :TextCounts) if Object.const_defined?(:TextCounts)
  Object.const_set(:TextCounts, Struct.new(:single, :double, keyword_init: true))
  $text1 = _add(_add("Behind Winston's back the voice ", "from the telescreen was still "), "babbling and the overfulfilment")
  calculate_entropy($text1)
  $text3 = _add(_add(_add(_add(_add(_add(_add(_add(_add(_add("Had repulsive dashwoods suspicion sincerity but advantage now him. ", "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. "), "You greatest jointure saw horrible. He private he on be imagine "), "suppose. Fertile beloved evident through no service elderly is. Blind "), "there if every no so at. Own neglected you preferred way sincerity "), "delivered his attempted. To of message cottage windows do besides "), "against uncivil.  Delightful unreserved impossible few estimating "), "men favourable see entreaties. She propriety immediate was improving. "), "He or entrance humoured likewise moderate. Much nor game son say "), "feel. Fat make met can must form into gate. Me we offending prevailed "), "discovery.")
  calculate_entropy($text3)
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
