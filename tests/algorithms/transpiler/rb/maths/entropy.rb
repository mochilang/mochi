# Generated by Mochi transpiler v0.10.59 on 2025-08-06 23:55 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def log2(x)
    k = 0.0.clone
    v = x.clone
    while v >= 2.0
      v = v / 2.0.clone
      k = _add(k, 1.0).clone
    end
    while v < 1.0
      v = v * 2.0.clone
      k = k - 1.0.clone
    end
    z = (v - 1.0) / (_add(v, 1.0))
    zpow = z.clone
    sum = z.clone
    i = 3.clone
    while i <= 9
      zpow = zpow * z * z.clone
      sum = _add(sum, zpow / ((i).to_f)).clone
      i = _add(i, 2).clone
    end
    ln2 = 0.6931471805599453
    return _add(k, 2.0 * sum / ln2)
  end
  def analyze_text(text)
    single = {}.clone
    double = {}.clone
    n = text.length
    if n == 0
      return TextCounts.new(single: single, double: double)
    end
    last = text[n - 1...n]
    if single.key?(last)
      single[last] = _add(single[last], 1)
    else
      single[last] = 1
    end
    first = text[0...1]
    pair0 = _add(" ", first)
    double[pair0] = 1
    i = 0.clone
    while i < n - 1
      ch = text[i..._add(i, 1)]
      if single.key?(ch)
        single[ch] = _add(single[ch], 1)
      else
        single[ch] = 1
      end
      seq = text[i..._add(i, 2)]
      if double.key?(seq)
        double[seq] = _add(double[seq], 1)
      else
        double[seq] = 1
      end
      i = _add(i, 1).clone
    end
    return TextCounts.new(single: single, double: double)
  end
  def round_to_int(x)
    if x < 0.0
      return ((x - 0.5)).to_i
    end
    return ((_add(x, 0.5))).to_i
  end
  def calculate_entropy(text)
    counts = analyze_text(text)
    alphas = " abcdefghijklmnopqrstuvwxyz"
    total1 = 0.clone
        __tmp1 = counts.single.keys()
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |ch|
      total1 = _add(total1, counts.single[ch]).clone
    end
    h1 = 0.0.clone
    i = 0.clone
    while i < alphas.length
      ch = alphas[i..._add(i, 1)]
      if counts.single.key?(ch)
        prob = ((counts.single[ch]).to_f) / ((total1).to_f)
        h1 = _add(h1, prob * log2(prob)).clone
      end
      i = _add(i, 1).clone
    end
    first_entropy = -h1
    puts(_add(_str(round_to_int(first_entropy)), ".0"))
    total2 = 0.clone
        __tmp2 = counts.double.keys()
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |seq|
      total2 = _add(total2, counts.double[seq]).clone
    end
    h2 = 0.0.clone
    a0 = 0.clone
    while a0 < alphas.length
      ch0 = alphas[a0..._add(a0, 1)]
      a1 = 0.clone
      while a1 < alphas.length
        ch1 = alphas[a1..._add(a1, 1)]
        seq = _add(ch0, ch1)
        if counts.double.key?(seq)
          prob = ((counts.double[seq]).to_f) / ((total2).to_f)
          h2 = _add(h2, prob * log2(prob)).clone
        end
        a1 = _add(a1, 1).clone
      end
      a0 = _add(a0, 1).clone
    end
    second_entropy = -h2
    puts(_add(_str(round_to_int(second_entropy)), ".0"))
    diff = second_entropy - first_entropy
    puts(_add(_str(round_to_int(diff)), ".0"))
  end
  TextCounts = Struct.new(:single, :double, keyword_init: true)
  $text1 = _add(_add("Behind Winston's back the voice ", "from the telescreen was still "), "babbling and the overfulfilment")
  calculate_entropy($text1)
  $text3 = _add(_add(_add(_add(_add(_add(_add(_add(_add(_add("Had repulsive dashwoods suspicion sincerity but advantage now him. ", "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. "), "You greatest jointure saw horrible. He private he on be imagine "), "suppose. Fertile beloved evident through no service elderly is. Blind "), "there if every no so at. Own neglected you preferred way sincerity "), "delivered his attempted. To of message cottage windows do besides "), "against uncivil.  Delightful unreserved impossible few estimating "), "men favourable see entreaties. She propriety immediate was improving. "), "He or entrance humoured likewise moderate. Much nor game son say "), "feel. Fat make met can must form into gate. Me we offending prevailed "), "discovery.")
  calculate_entropy($text3)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
