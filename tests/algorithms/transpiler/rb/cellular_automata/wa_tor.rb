# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def rand()
    $seed = (_add($seed * 1103515245, 12345)) % 2147483648
    return $seed
  end
  def rand_range(max)
    return rand() % max
  end
  def shuffle(list_int)
    i = list_int.length - 1
    while i > 0
      j = rand_range(_add(i, 1))
      tmp = list_int[i]
      list_int[i] = list_int[j]
      list_int[j] = tmp
      i = i - 1
    end
    return list_int
  end
  def create_board()
    board = []
    r = 0
    while r < $HEIGHT
      row = []
      c = 0
      while c < $WIDTH
        row = (row + [0])
        c = _add(c, 1)
      end
      board = (board + [row])
      r = _add(r, 1)
    end
    return board
  end
  def create_prey(r, c)
    return [$TYPE_PREY, r, c, $PREY_REPRODUCTION_TIME, 0, 1]
  end
  def create_predator(r, c)
    return [$TYPE_PREDATOR, r, c, $PREDATOR_REPRODUCTION_TIME, $PREDATOR_INITIAL_ENERGY, 1]
  end
  def empty_cell(r, c)
    return $board[r][c] == 0
  end
  def add_entity(typ)
    while true
      r = rand_range($HEIGHT)
      c = rand_range($WIDTH)
      if empty_cell(r, c)
        if typ == $TYPE_PREY
          $board[r][c] = 1
          $entities = ($entities + [create_prey(r, c)])
        else
          $board[r][c] = 2
          $entities = ($entities + [create_predator(r, c)])
        end
        return
      end
    end
  end
  def setup()
    i = 0
    while i < $PREY_INITIAL_COUNT
      add_entity($TYPE_PREY)
      i = _add(i, 1)
    end
    i = 0
    while i < $PREDATOR_INITIAL_COUNT
      add_entity($TYPE_PREDATOR)
      i = _add(i, 1)
    end
  end
  def inside(r, c)
    return r >= 0 && r < $HEIGHT && c >= 0 && c < $WIDTH
  end
  def find_prey(r, c)
    i = 0
    while i < $entities.length
      e = $entities[i]
      if e[5] == 1 && e[0] == $TYPE_PREY && e[1] == r && e[2] == c
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def step_world()
    i = 0
    while i < $entities.length
      e = $entities[i]
      if e[5] == 0
        i = _add(i, 1)
        next
      end
      typ = e[0]
      row = e[1]
      col = e[2]
      repro = e[3]
      energy = e[4]
      dirs = [0, 1, 2, 3]
      dirs = shuffle(dirs)
      moved = false
      old_r = row
      old_c = col
      if typ == $TYPE_PREDATOR
        j = 0
        ate = false
        while j < 4
          d = dirs[j]
          nr = _add(row, $dr[d])
          nc = _add(col, $dc[d])
          if inside(nr, nc) && $board[nr][nc] == 1
            prey_index = find_prey(nr, nc)
            if prey_index >= 0
              $entities[prey_index][5] = 0
            end
            $board[nr][nc] = 2
            $board[row][col] = 0
            e[1] = nr
            e[2] = nc
            e[4] = _add(energy, $PREDATOR_FOOD_VALUE) - 1
            moved = true
            ate = true
            break
          end
          j = _add(j, 1)
        end
        if !ate
          j = 0
          while j < 4
            d = dirs[j]
            nr = _add(row, $dr[d])
            nc = _add(col, $dc[d])
            if inside(nr, nc) && $board[nr][nc] == 0
              $board[nr][nc] = 2
              $board[row][col] = 0
              e[1] = nr
              e[2] = nc
              moved = true
              break
            end
            j = _add(j, 1)
          end
          e[4] = energy - 1
        end
        if e[4] <= 0
          e[5] = 0
          $board[e[1]][e[2]] = 0
        end
      else
        j = 0
        while j < 4
          d = dirs[j]
          nr = _add(row, $dr[d])
          nc = _add(col, $dc[d])
          if inside(nr, nc) && $board[nr][nc] == 0
            $board[nr][nc] = 1
            $board[row][col] = 0
            e[1] = nr
            e[2] = nc
            moved = true
            break
          end
          j = _add(j, 1)
        end
      end
      if e[5] == 1
        if moved && repro <= 0
          if typ == $TYPE_PREY
            $board[old_r][old_c] = 1
            $entities = ($entities + [create_prey(old_r, old_c)])
            e[3] = $PREY_REPRODUCTION_TIME
          else
            $board[old_r][old_c] = 2
            $entities = ($entities + [create_predator(old_r, old_c)])
            e[3] = $PREDATOR_REPRODUCTION_TIME
          end
        else
          e[3] = repro - 1
        end
      end
      i = _add(i, 1)
    end
    alive = []
    k = 0
    while k < $entities.length
      e2 = $entities[k]
      if e2[5] == 1
        alive = (alive + [e2])
      end
      k = _add(k, 1)
    end
    $entities = alive
  end
  def count_entities(typ)
    cnt = 0
    i = 0
    while i < $entities.length
      if $entities[i][0] == typ && $entities[i][5] == 1
        cnt = _add(cnt, 1)
      end
      i = _add(i, 1)
    end
    return cnt
  end
  $WIDTH = 10
  $HEIGHT = 10
  $PREY_INITIAL_COUNT = 20
  $PREY_REPRODUCTION_TIME = 5
  $PREDATOR_INITIAL_COUNT = 5
  $PREDATOR_REPRODUCTION_TIME = 20
  $PREDATOR_INITIAL_ENERGY = 15
  $PREDATOR_FOOD_VALUE = 5
  $TYPE_PREY = 0
  $TYPE_PREDATOR = 1
  $seed = 123456789
  $board = create_board()
  $entities = []
  $dr = [-1, 0, 1, 0]
  $dc = [0, 1, 0, -1]
  setup()
  $t = 0
  while $t < 10
    step_world()
    $t = _add($t, 1)
  end
  puts(_add("Prey: ", (count_entities($TYPE_PREY)).to_s))
  puts(_add("Predators: ", (count_entities($TYPE_PREDATOR)).to_s))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
