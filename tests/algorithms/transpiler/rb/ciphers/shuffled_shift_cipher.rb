# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def ord(ch)
    digits = "0123456789"
    i = 0
    while i < digits.length
      if digits[i..._add(i, 1)] == ch
        return _add(48, i)
      end
      i = _add(i, 1)
    end
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    i = 0
    while i < upper.length
      if upper[i..._add(i, 1)] == ch
        return _add(65, i)
      end
      i = _add(i, 1)
    end
    lower = "abcdefghijklmnopqrstuvwxyz"
    i = 0
    while i < lower.length
      if lower[i..._add(i, 1)] == ch
        return _add(97, i)
      end
      i = _add(i, 1)
    end
    return 0
  end
  def neg_pos(iterlist)
    i = 1
    while i < iterlist.length
      iterlist[i] = -iterlist[i]
      i = _add(i, 2)
    end
    return iterlist
  end
  def passcode_creator()
    choices = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    seed = _now()
    length = _add(10, (seed % 11))
    password = []
    i = 0
    while i < length
      seed = (_add(seed * 1103515245, 12345)) % 2147483647
      idx = seed % choices.length
      password = (password + [choices[idx..._add(idx, 1)]])
      i = _add(i, 1)
    end
    return password
  end
  def unique_sorted(chars)
    uniq = []
    i = 0
    while i < chars.length
      ch = chars[i]
      if !(uniq.include?(ch))
        uniq = (uniq + [ch])
      end
      i = _add(i, 1)
    end
    j = 0
    while j < uniq.length
      k = _add(j, 1)
      min_idx = j
      while k < uniq.length
        if uniq[k] < uniq[min_idx]
          min_idx = k
        end
        k = _add(k, 1)
      end
      if min_idx != j
        tmp = uniq[j]
        uniq[j] = uniq[min_idx]
        uniq[min_idx] = tmp
      end
      j = _add(j, 1)
    end
    return uniq
  end
  def make_key_list(passcode)
    key_list_options = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n"
    breakpoints = unique_sorted(passcode)
    keys_l = []
    temp_list = []
    i = 0
    while i < key_list_options.length
      ch = key_list_options[i..._add(i, 1)]
      temp_list = (temp_list + [ch])
      if breakpoints.include?(ch) || i == key_list_options.length - 1
        k = temp_list.length - 1
        while k >= 0
          keys_l = (keys_l + [temp_list[k]])
          k = k - 1
        end
        temp_list = []
      end
      i = _add(i, 1)
    end
    return keys_l
  end
  def make_shift_key(passcode)
    codes = []
    i = 0
    while i < passcode.length
      codes = (codes + [ord(passcode[i])])
      i = _add(i, 1)
    end
    codes = neg_pos(codes)
    total = 0
    i = 0
    while i < codes.length
      total = _add(total, codes[i])
      i = _add(i, 1)
    end
    if total > 0
      return total
    end
    return passcode.length
  end
  def new_cipher(passcode_str)
    passcode = []
    if passcode_str.length == 0
      passcode = passcode_creator()
    else
      i = 0
      while i < passcode_str.length
        passcode = (passcode + [passcode_str[i..._add(i, 1)]])
        i = _add(i, 1)
      end
    end
    key_list = make_key_list(passcode)
    shift_key = make_shift_key(passcode)
    return Cipher.new(passcode: passcode, key_list: key_list, shift_key: shift_key)
  end
  def index_of(lst, ch)
    i = 0
    while i < lst.length
      if lst[i] == ch
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def encrypt(c, plaintext)
    encoded = ""
    i = 0
    n = c["key_list"].length
    while i < plaintext.length
      ch = plaintext[i..._add(i, 1)]
      position = index_of(c["key_list"], ch)
      new_pos = (_add(position, c["shift_key"])) % n
      encoded = _add(encoded, c["key_list"][new_pos])
      i = _add(i, 1)
    end
    return encoded
  end
  def decrypt(c, encoded_message)
    decoded = ""
    i = 0
    n = c["key_list"].length
    while i < encoded_message.length
      ch = encoded_message[i..._add(i, 1)]
      position = index_of(c["key_list"], ch)
      new_pos = (position - c["shift_key"]) % n
      if new_pos < 0
        new_pos = _add(new_pos, n)
      end
      decoded = _add(decoded, c["key_list"][new_pos])
      i = _add(i, 1)
    end
    return decoded
  end
  def test_end_to_end()
    msg = "Hello, this is a modified Caesar cipher"
    cip = new_cipher("")
    return decrypt(cip, encrypt(cip, msg))
  end
  Cipher = Struct.new(:passcode, :key_list, :shift_key, keyword_init: true)
  $ssc = new_cipher("4PYIXyqeQZr44")
  $encoded = encrypt($ssc, "Hello, this is a modified Caesar cipher")
  puts($encoded)
  puts(decrypt($ssc, $encoded))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
