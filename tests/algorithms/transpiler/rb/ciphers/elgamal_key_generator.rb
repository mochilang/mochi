# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def rand()
    $seed = (_add($seed * 1103515245, 12345)) % 2147483647
    return $seed
  end
  def rand_range(min, max)
    return _add(min, rand() % (_add(max - min, 1)))
  end
  def mod_pow(base, exponent, modulus)
    result = 1
    b = base % modulus
    e = exponent
    while e > 0
      if e % 2 == 1
        result = (result * b) % modulus
      end
      e = e / 2
      b = (b * b) % modulus
    end
    return result
  end
  def extended_gcd(a, b)
    if b == 0
      return GCD.new(g: a, x: 1, y: 0)
    end
    res = extended_gcd(b, a % b)
    return GCD.new(g: res["g"], x: res["y"], y: res["x"] - (a / b) * res["y"])
  end
  def mod_inverse(a, m)
    res = extended_gcd(a, m)
    if res["g"] != 1
      panic("inverse does not exist")
    end
    r = res["x"] % m
    if r < 0
      return _add(r, m)
    end
    return r
  end
  def pow2(n)
    r = 1
    i = 0
    while i < n
      r = r * 2
      i = _add(i, 1)
    end
    return r
  end
  def is_probable_prime(n, k)
    if n <= 1
      return false
    end
    if n <= 3
      return true
    end
    if n % 2 == 0
      return false
    end
    r = 0
    d = n - 1
    while d % 2 == 0
      d = d / 2
      r = _add(r, 1)
    end
    i = 0
    while i < k
      a = rand_range(2, n - 2)
      x = mod_pow(a, d, n)
      if x == 1 || x == n - 1
        i = _add(i, 1)
        next
      end
      j = 1
      found = false
      while j < r
        x = mod_pow(x, 2, n)
        if x == n - 1
          found = true
          break
        end
        j = _add(j, 1)
      end
      if !found
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def generate_large_prime(bits)
    min = pow2(bits - 1)
    max = pow2(bits) - 1
    p = rand_range(min, max)
    if p % 2 == 0
      p = _add(p, 1)
    end
    while !is_probable_prime(p, 5)
      p = _add(p, 2)
      if p > max
        p = _add(min, 1)
      end
    end
    return p
  end
  def primitive_root(p)
    while true
      g = rand_range(3, p - 1)
      if mod_pow(g, 2, p) == 1
        next
      end
      if mod_pow(g, p, p) == 1
        next
      end
      return g
    end
  end
  def generate_key(key_size)
    p = generate_large_prime(key_size)
    e1 = primitive_root(p)
    d = rand_range(3, p - 1)
    e2 = mod_inverse(mod_pow(e1, d, p), p)
    public_key = PublicKey.new(key_size: key_size, g: e1, e2: e2, p: p)
    private_key = PrivateKey.new(key_size: key_size, d: d)
    return KeyPair.new(public_key: public_key, private_key: private_key)
  end
  def main()
    key_size = 16
    kp = generate_key(key_size)
    pub = kp["public_key"]
    priv = kp["private_key"]
    puts(_add(_add(_add(_add(_add(_add(_add(_add("public key: (", (pub["key_size"]).to_s), ", "), (pub["g"]).to_s), ", "), (pub["e2"]).to_s), ", "), (pub["p"]).to_s), ")"))
    puts(_add(_add(_add(_add("private key: (", (priv["key_size"]).to_s), ", "), (priv["d"]).to_s), ")"))
  end
  $seed = 123456789
  GCD = Struct.new(:g, :x, :y, keyword_init: true)
  PublicKey = Struct.new(:key_size, :g, :e2, :p, keyword_init: true)
  PrivateKey = Struct.new(:key_size, :d, keyword_init: true)
  KeyPair = Struct.new(:public_key, :private_key, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
