# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def pow_int(base, exp)
    result = 1
    i = 0
    while i < exp
      result = result * base
      i = _add(i, 1)
    end
    return result
  end
  def mod_pow(base, exponent, modulus)
    result = 1
    b = base % modulus
    e = exponent
    while e > 0
      if e % 2 == 1
        result = (result * b) % modulus
      end
      e = e / 2
      b = (b * b) % modulus
    end
    return result
  end
  def ord(ch)
    if ch == " "
      return 32
    end
    if ch == "a"
      return 97
    end
    if ch == "b"
      return 98
    end
    if ch == "c"
      return 99
    end
    if ch == "d"
      return 100
    end
    if ch == "e"
      return 101
    end
    if ch == "f"
      return 102
    end
    if ch == "g"
      return 103
    end
    if ch == "h"
      return 104
    end
    if ch == "i"
      return 105
    end
    if ch == "j"
      return 106
    end
    if ch == "k"
      return 107
    end
    if ch == "l"
      return 108
    end
    if ch == "m"
      return 109
    end
    if ch == "n"
      return 110
    end
    if ch == "o"
      return 111
    end
    if ch == "p"
      return 112
    end
    if ch == "q"
      return 113
    end
    if ch == "r"
      return 114
    end
    if ch == "s"
      return 115
    end
    if ch == "t"
      return 116
    end
    if ch == "u"
      return 117
    end
    if ch == "v"
      return 118
    end
    if ch == "w"
      return 119
    end
    if ch == "x"
      return 120
    end
    if ch == "y"
      return 121
    end
    if ch == "z"
      return 122
    end
    return 0
  end
  def chr(code)
    if code == 32
      return " "
    end
    if code == 97
      return "a"
    end
    if code == 98
      return "b"
    end
    if code == 99
      return "c"
    end
    if code == 100
      return "d"
    end
    if code == 101
      return "e"
    end
    if code == 102
      return "f"
    end
    if code == 103
      return "g"
    end
    if code == 104
      return "h"
    end
    if code == 105
      return "i"
    end
    if code == 106
      return "j"
    end
    if code == 107
      return "k"
    end
    if code == 108
      return "l"
    end
    if code == 109
      return "m"
    end
    if code == 110
      return "n"
    end
    if code == 111
      return "o"
    end
    if code == 112
      return "p"
    end
    if code == 113
      return "q"
    end
    if code == 114
      return "r"
    end
    if code == 115
      return "s"
    end
    if code == 116
      return "t"
    end
    if code == 117
      return "u"
    end
    if code == 118
      return "v"
    end
    if code == 119
      return "w"
    end
    if code == 120
      return "x"
    end
    if code == 121
      return "y"
    end
    if code == 122
      return "z"
    end
    return ""
  end
  def get_blocks_from_text(message, block_size)
    block_ints = []
    block_start = 0
    while block_start < message.length
      block_int = 0
      i = block_start
      while i < _add(block_start, block_size) && i < message.length
        block_int = _add(block_int, ord(message[i]) * pow_int($BYTE_SIZE, i - block_start))
        i = _add(i, 1)
      end
      block_ints = (block_ints + [block_int])
      block_start = _add(block_start, block_size)
    end
    return block_ints
  end
  def get_text_from_blocks(block_ints, message_length, block_size)
    message = ""
        __tmp11 = block_ints
    if __tmp11.respond_to?(:keys) && !__tmp11.is_a?(String)
      __tmp11 = __tmp11.keys
    end
    __tmp11.each do |block_int|
      block = block_int
      i = block_size - 1
      block_message = ""
      while i >= 0
        if _add(message.length, i) < message_length
          ascii_number = block / pow_int($BYTE_SIZE, i)
          block = block % pow_int($BYTE_SIZE, i)
          block_message = _add(chr(ascii_number), block_message)
        end
        i = i - 1
      end
      message = _add(message, block_message)
    end
    return message
  end
  def encrypt_message(message, n, e, block_size)
    encrypted = []
    blocks = get_blocks_from_text(message, block_size)
        __tmp12 = blocks
    if __tmp12.respond_to?(:keys) && !__tmp12.is_a?(String)
      __tmp12 = __tmp12.keys
    end
    __tmp12.each do |block|
      encrypted = (encrypted + [mod_pow(block, e, n)])
    end
    return encrypted
  end
  def decrypt_message(blocks, message_length, n, d, block_size)
    decrypted_blocks = []
        __tmp13 = blocks
    if __tmp13.respond_to?(:keys) && !__tmp13.is_a?(String)
      __tmp13 = __tmp13.keys
    end
    __tmp13.each do |block|
      decrypted_blocks = (decrypted_blocks + [mod_pow(block, d, n)])
    end
    message = ""
        __tmp14 = decrypted_blocks
    if __tmp14.respond_to?(:keys) && !__tmp14.is_a?(String)
      __tmp14 = __tmp14.keys
    end
    __tmp14.each do |num|
      message = _add(message, chr(num))
    end
    return message
  end
  def main()
    message = "hello world"
    n = 3233
    e = 17
    d = 2753
    block_size = 1
    encrypted = encrypt_message(message, n, e, block_size)
    puts(((x = encrypted); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    decrypted = decrypt_message(encrypted, message.length, n, d, block_size)
    puts(decrypted)
  end
  $BYTE_SIZE = 256
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
