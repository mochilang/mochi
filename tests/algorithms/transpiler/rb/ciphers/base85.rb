# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _indexOf(s, ch)
  idx = s.index(ch)
  idx ? idx : -1
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def indexOf(s, ch)
    i = 0
    while i < s.length
      if s[i] == ch
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def ord(ch)
    idx = _indexOf($ascii85_chars, ch)
    if idx >= 0
      return _add(33, idx)
    end
    return 0
  end
  def chr(n)
    if n >= 33 && n <= 117
      return $ascii85_chars[n - 33...n - 32]
    end
    return "?"
  end
  def to_binary(n, bits)
    b = ""
    val = n
    while val > 0
      b = _add((val % 2).to_s, b)
      val = val / 2
    end
    while b.length < bits
      b = _add("0", b)
    end
    if b.length == 0
      b = "0"
    end
    return b
  end
  def bin_to_int(bits)
    n = 0
    i = 0
    while i < bits.length
      if bits[i] == "1"
        n = _add(n * 2, 1)
      else
        n = n * 2
      end
      i = _add(i, 1)
    end
    return n
  end
  def reverse(s)
    res = ""
    i = s.length - 1
    while i >= 0
      res = _add(res, s[i])
      i = i - 1
    end
    return res
  end
  def base10_to_85(d)
    if d > 0
      return _add(chr(_add(d % 85, 33)), base10_to_85(d / 85))
    end
    return ""
  end
  def base85_to_10(digits)
    value = 0
    i = 0
    while i < digits.length
      value = _add(value * 85, (ord(digits[i]) - 33))
      i = _add(i, 1)
    end
    return value
  end
  def ascii85_encode(data)
    binary_data = ""
        __tmp9 = data
    if __tmp9.respond_to?(:keys) && !__tmp9.is_a?(String)
      __tmp9 = __tmp9.keys
    end
    __tmp9.each_char do |ch|
      binary_data = _add(binary_data, to_binary(ord(ch), 8))
    end
    null_values = (32 * (_add((binary_data.length / 32), 1)) - binary_data.length) / 8
    total_bits = 32 * (_add((binary_data.length / 32), 1))
    while binary_data.length < total_bits
      binary_data = _add(binary_data, "0")
    end
    result = ""
    i = 0
    while i < binary_data.length
      chunk_bits = binary_data[i..._add(i, 32)]
      chunk_val = bin_to_int(chunk_bits)
      encoded = reverse(base10_to_85(chunk_val))
      result = _add(result, encoded)
      i = _add(i, 32)
    end
    if null_values % 4 != 0
      result = result[0...result.length - null_values]
    end
    return result
  end
  def ascii85_decode(data)
    null_values = 5 * (_add((data.length / 5), 1)) - data.length
    binary_data = data
    i = 0
    while i < null_values
      binary_data = _add(binary_data, "u")
      i = _add(i, 1)
    end
    result = ""
    i = 0
    while i < binary_data.length
      chunk = binary_data[i..._add(i, 5)]
      value = base85_to_10(chunk)
      bits = to_binary(value, 32)
      j = 0
      while j < 32
        byte_bits = bits[j..._add(j, 8)]
        c = chr(bin_to_int(byte_bits))
        result = _add(result, c)
        j = _add(j, 8)
      end
      i = _add(i, 5)
    end
    trim = null_values
    if null_values % 5 == 0
      trim = null_values - 1
    end
    return result[0...result.length - trim]
  end
  $ascii85_chars = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"
  puts(ascii85_encode(""))
  puts(ascii85_encode("12345"))
  puts(ascii85_encode("base 85"))
  puts(ascii85_decode(""))
  puts(ascii85_decode("0etOA2#"))
  puts(ascii85_decode("@UX=h+?24"))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
