# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def encodeToMorse(plaintext)
    morse = ""
    i = 0
    while i < plaintext.length
      ch = plaintext[i..._add(i, 1)].upcase()
      code = ""
      if $MORSE_CODE_DICT.include?(ch)
        code = $MORSE_CODE_DICT[ch]
      end
      if i > 0
        morse = _add(morse, "x")
      end
      morse = _add(morse, code)
      i = _add(i, 1)
    end
    return morse
  end
  def encryptFractionatedMorse(plaintext, key)
    morseCode = encodeToMorse(plaintext)
    combinedKey = _add(key.upcase(), "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    dedupKey = ""
    i = 0
    while i < combinedKey.length
      ch = combinedKey[i..._add(i, 1)]
      if !(dedupKey.include?(ch))
        dedupKey = _add(dedupKey, ch)
      end
      i = _add(i, 1)
    end
    paddingLength = 3 - (morseCode.length % 3)
    p = 0
    while p < paddingLength
      morseCode = _add(morseCode, "x")
      p = _add(p, 1)
    end
    dict = {}
    j = 0
    while j < 26
      combo = $MORSE_COMBINATIONS[j]
      letter = dedupKey[j..._add(j, 1)]
      dict[combo] = letter
      j = _add(j, 1)
    end
    dict["xxx"] = ""
    encrypted = ""
    k = 0
    while k < morseCode.length
      group = morseCode[k..._add(k, 3)]
      encrypted = _add(encrypted, dict[group])
      k = _add(k, 3)
    end
    return encrypted
  end
  def decryptFractionatedMorse(ciphertext, key)
    combinedKey = _add(key.upcase(), "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    dedupKey = ""
    i = 0
    while i < combinedKey.length
      ch = combinedKey[i..._add(i, 1)]
      if !(dedupKey.include?(ch))
        dedupKey = _add(dedupKey, ch)
      end
      i = _add(i, 1)
    end
    inv = {}
    j = 0
    while j < 26
      letter = dedupKey[j..._add(j, 1)]
      inv[letter] = $MORSE_COMBINATIONS[j]
      j = _add(j, 1)
    end
    morse = ""
    k = 0
    while k < ciphertext.length
      ch = ciphertext[k..._add(k, 1)]
      if inv.key?(ch)
        morse = _add(morse, inv[ch])
      end
      k = _add(k, 1)
    end
    codes = []
    current = ""
    m = 0
    while m < morse.length
      ch = morse[m..._add(m, 1)]
      if ch == "x"
        codes = (codes + [current])
        current = ""
      else
        current = _add(current, ch)
      end
      m = _add(m, 1)
    end
    codes = (codes + [current])
    decrypted = ""
    idx = 0
    while idx < codes.length
      code = codes[idx]
      decrypted = _add(decrypted, $REVERSE_DICT[code])
      idx = _add(idx, 1)
    end
    start = 0
    while true
      if start < decrypted.length
        if decrypted[start..._add(start, 1)] == " "
          start = _add(start, 1)
          next
        end
      end
      break
    end
    end_ = decrypted.length
    while true
      if end_ > start
        if decrypted[end_ - 1...end_] == " "
          end_ = end_ - 1
          next
        end
      end
      break
    end
    return decrypted[start...end_]
  end
  $MORSE_CODE_DICT = {"A" => ".-", "B" => "-...", "C" => "-.-.", "D" => "-..", "E" => ".", "F" => "..-.", "G" => "--.", "H" => "....", "I" => "..", "J" => ".---", "K" => "-.-", "L" => ".-..", "M" => "--", "N" => "-.", "O" => "---", "P" => ".--.", "Q" => "--.-", "R" => ".-.", "S" => "...", "T" => "-", "U" => "..-", "V" => "...-", "W" => ".--", "X" => "-..-", "Y" => "-.--", "Z" => "--..", " " => ""}
  $MORSE_COMBINATIONS = ["...", "..-", "..x", ".-.", ".--", ".-x", ".x.", ".x-", ".xx", "-..", "-.-", "-.x", "--.", "---", "--x", "-x.", "-x-", "-xx", "x..", "x.-", "x.x", "x-.", "x--", "x-x", "xx.", "xx-", "xxx"]
  $REVERSE_DICT = {".-" => "A", "-..." => "B", "-.-." => "C", "-.." => "D", "." => "E", "..-." => "F", "--." => "G", "...." => "H", ".." => "I", ".---" => "J", "-.-" => "K", ".-.." => "L", "--" => "M", "-." => "N", "---" => "O", ".--." => "P", "--.-" => "Q", ".-." => "R", "..." => "S", "-" => "T", "..-" => "U", "...-" => "V", ".--" => "W", "-..-" => "X", "-.--" => "Y", "--.." => "Z", "" => " "}
  $plaintext = "defend the east"
  puts((["Plain Text:", $plaintext]).map{ |x| if x.nil? then 'None' elsif x == true then 'True' elsif x == false then 'False' elsif x.respond_to?(:to_h) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x end }.join(' ').rstrip())
  $key = "ROUNDTABLE"
  $ciphertext = encryptFractionatedMorse($plaintext, $key)
  puts((["Encrypted:", $ciphertext]).map{ |x| if x.nil? then 'None' elsif x == true then 'True' elsif x == false then 'False' elsif x.respond_to?(:to_h) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x end }.join(' ').rstrip())
  $decrypted = decryptFractionatedMorse($ciphertext, $key)
  puts((["Decrypted:", $decrypted]).map{ |x| if x.nil? then 'None' elsif x == true then 'True' elsif x == false then 'False' elsif x.respond_to?(:to_h) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x end }.join(' ').rstrip())
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
