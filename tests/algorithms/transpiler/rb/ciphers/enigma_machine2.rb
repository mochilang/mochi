# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def list_contains(xs, x)
    i = 0
    while i < xs.length
      if xs[i] == x
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def index_in_string(s, ch)
    i = 0
    while i < s.length
      if s[i..._add(i, 1)] == ch
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def contains_char(s, ch)
    return index_in_string(s, ch) >= 0
  end
  def to_uppercase(s)
    res = ""
    i = 0
    while i < s.length
      ch = s[i..._add(i, 1)]
      idx = index_in_string($low_abc, ch)
      if idx >= 0
        res = _add(res, $abc[idx..._add(idx, 1)])
      else
        res = _add(res, ch)
      end
      i = _add(i, 1)
    end
    return res
  end
  def plugboard_map(pb, ch)
    i = 0
    while i < pb.length
      pair = pb[i]
      a = pair[0...1]
      b = pair[1...2]
      if ch == a
        return b
      end
      if ch == b
        return a
      end
      i = _add(i, 1)
    end
    return ch
  end
  def reflector_map(ch)
    i = 0
    while i < $reflector_pairs.length
      pair = $reflector_pairs[i]
      a = pair[0...1]
      b = pair[1...2]
      if ch == a
        return b
      end
      if ch == b
        return a
      end
      i = _add(i, 1)
    end
    return ch
  end
  def count_unique(xs)
    unique = []
    i = 0
    while i < xs.length
      if !list_contains(unique, xs[i])
        unique = (unique + [xs[i]])
      end
      i = _add(i, 1)
    end
    return unique.length
  end
  def build_plugboard(pbstring)
    if pbstring.length == 0
      return []
    end
    if pbstring.length % 2 != 0
      panic(_add(_add("Odd number of symbols(", (pbstring.length).to_s), ")"))
    end
    pbstring_nospace = ""
    i = 0
    while i < pbstring.length
      ch = pbstring[i..._add(i, 1)]
      if ch != " "
        pbstring_nospace = _add(pbstring_nospace, ch)
      end
      i = _add(i, 1)
    end
    seen = []
    i = 0
    while i < pbstring_nospace.length
      ch = pbstring_nospace[i..._add(i, 1)]
      if !contains_char($abc, ch)
        panic(_add(_add("'", ch), "' not in list of symbols"))
      end
      if list_contains(seen, ch)
        panic(_add(_add("Duplicate symbol(", ch), ")"))
      end
      seen = (seen + [ch])
      i = _add(i, 1)
    end
    pb = []
    i = 0
    while i < pbstring_nospace.length - 1
      a = pbstring_nospace[i..._add(i, 1)]
      b = pbstring_nospace[_add(i, 1)..._add(i, 2)]
      pb = (pb + [_add(a, b)])
      i = _add(i, 2)
    end
    return pb
  end
  def validator(rotpos, rotsel, pb)
    if count_unique(rotsel) < 3
      panic(_add(_add("Please use 3 unique rotors (not ", (count_unique(rotsel)).to_s), ")"))
    end
    if rotpos.length != 3
      panic("Rotor position must have 3 values")
    end
    r1 = rotpos[0]
    r2 = rotpos[1]
    r3 = rotpos[2]
    if !(0 < r1 && r1 <= $abc.length)
      panic(_add(_add("First rotor position is not within range of 1..26 (", (r1).to_s), ")"))
    end
    if !(0 < r2 && r2 <= $abc.length)
      panic(_add(_add("Second rotor position is not within range of 1..26 (", (r2).to_s), ")"))
    end
    if !(0 < r3 && r3 <= $abc.length)
      panic(_add(_add("Third rotor position is not within range of 1..26 (", (r3).to_s), ")"))
    end
  end
  def enigma(text, rotor_position, rotor_selection, plugb)
    up_text = to_uppercase(text)
    up_pb = to_uppercase(plugb)
    validator(rotor_position, rotor_selection, up_pb)
    plugboard = build_plugboard(up_pb)
    rotorpos1 = rotor_position[0] - 1
    rotorpos2 = rotor_position[1] - 1
    rotorpos3 = rotor_position[2] - 1
    rotor_a = rotor_selection[0]
    rotor_b = rotor_selection[1]
    rotor_c = rotor_selection[2]
    result = ""
    i = 0
    while i < up_text.length
      symbol = up_text[i..._add(i, 1)]
      if contains_char($abc, symbol)
        symbol = plugboard_map(plugboard, symbol)
        index = _add(index_in_string($abc, symbol), rotorpos1)
        symbol = rotor_a[index % $abc.length..._add(index % $abc.length, 1)]
        index = _add(index_in_string($abc, symbol), rotorpos2)
        symbol = rotor_b[index % $abc.length..._add(index % $abc.length, 1)]
        index = _add(index_in_string($abc, symbol), rotorpos3)
        symbol = rotor_c[index % $abc.length..._add(index % $abc.length, 1)]
        symbol = reflector_map(symbol)
        index = index_in_string(rotor_c, symbol) - rotorpos3
        if index < 0
          index = _add(index, $abc.length)
        end
        symbol = $abc[index..._add(index, 1)]
        index = index_in_string(rotor_b, symbol) - rotorpos2
        if index < 0
          index = _add(index, $abc.length)
        end
        symbol = $abc[index..._add(index, 1)]
        index = index_in_string(rotor_a, symbol) - rotorpos1
        if index < 0
          index = _add(index, $abc.length)
        end
        symbol = $abc[index..._add(index, 1)]
        symbol = plugboard_map(plugboard, symbol)
        rotorpos1 = _add(rotorpos1, 1)
        if rotorpos1 >= $abc.length
          rotorpos1 = 0
          rotorpos2 = _add(rotorpos2, 1)
        end
        if rotorpos2 >= $abc.length
          rotorpos2 = 0
          rotorpos3 = _add(rotorpos3, 1)
        end
        if rotorpos3 >= $abc.length
          rotorpos3 = 0
        end
      end
      result = _add(result, symbol)
      i = _add(i, 1)
    end
    return result
  end
  def main()
    message = "This is my Python script that emulates the Enigma machine from WWII."
    rotor_pos = [1, 1, 1]
    pb = "pictures"
    rotor_sel = [$rotor2, $rotor4, $rotor8]
    en = enigma(message, rotor_pos, rotor_sel, pb)
    puts(_add("Encrypted message: ", en))
    puts(_add("Decrypted message: ", enigma(en, rotor_pos, rotor_sel, pb)))
  end
  $abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  $low_abc = "abcdefghijklmnopqrstuvwxyz"
  $rotor1 = "EGZWVONAHDCLFQMSIPJBYUKXTR"
  $rotor2 = "FOBHMDKEXQNRAULPGSJVTYICZW"
  $rotor3 = "ZJXESIUQLHAVRMDOYGTNFWPBKC"
  $rotor4 = "RMDJXFUWGISLHVTCQNKYPBEZOA"
  $rotor5 = "SGLCPQWZHKXAREONTFBVIYJUDM"
  $rotor6 = "HVSICLTYKQUBXDWAJZOMFGPREN"
  $rotor7 = "RZWQHFMVDBKICJLNTUXAGYPSOE"
  $rotor8 = "LFKIJODBEGAMQPXVUHYSTCZRWN"
  $rotor9 = "KOAEGVDHXPQZMLFTYWJNBRCIUS"
  $reflector_pairs = ["AN", "BO", "CP", "DQ", "ER", "FS", "GT", "HU", "IV", "JW", "KX", "LY", "MZ"]
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
