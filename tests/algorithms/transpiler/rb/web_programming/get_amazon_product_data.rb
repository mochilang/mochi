# Generated by Mochi transpiler v0.10.59 on 2025-08-07 10:45 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

start_mem = _mem()
start = _now()
  def find_index(s, pat, start)
    i = start.clone
    while i <= s.length - pat.length
      j = 0.clone
      ok = true.clone
      while j < pat.length
        if s[_add(i, j)] != pat[j]
          ok = false.clone
          break
        end
        j = _add(j, 1).clone
      end
      if ok
        return i
      end
      i = _add(i, 1).clone
    end
    return -1
  end
  def slice_between(s, start_pat, end_pat, from)
    a = find_index(s, start_pat, from)
    if a < 0
      return ""
    end
    b = _add(a, start_pat.length)
    c = find_index(s, end_pat, b)
    if c < 0
      return ""
    end
    return s[b...c]
  end
  def char_to_digit(c)
    if c == "0"
      return 0
    end
    if c == "1"
      return 1
    end
    if c == "2"
      return 2
    end
    if c == "3"
      return 3
    end
    if c == "4"
      return 4
    end
    if c == "5"
      return 5
    end
    if c == "6"
      return 6
    end
    if c == "7"
      return 7
    end
    if c == "8"
      return 8
    end
    return 9
  end
  def parse_int(txt)
    n = 0.clone
    i = 0.clone
    while i < txt.length
      c = txt[i]
      if c >= "0" && c <= "9"
        n = _add(n * 10, char_to_digit(c)).clone
      end
      i = _add(i, 1).clone
    end
    return n
  end
  def parse_product(block)
    href = slice_between(block, "href=\"", "\"", 0)
    link = _add("https://www.amazon.in", href)
    title = slice_between(block, ">", "</a>", find_index(block, "<a", 0))
    price = slice_between(block, "<span class=\"a-offscreen\">", "</span>", 0)
    rating = slice_between(block, "<span class=\"a-icon-alt\">", "</span>", 0).clone
    if rating.length == 0
      rating = "Not available".clone
    end
    mrp = slice_between(block, "<span class=\"a-price a-text-price\">", "</span>", 0).clone
    disc = 0.0.clone
    if mrp.length > 0 && price.length > 0
      p = parse_int(price)
      m = parse_int(mrp)
      if m > 0
        disc = (((m - p) * 100)).to_f / ((m).to_f).clone
      end
    else
      mrp = "".clone
      disc = 0.0.clone
    end
    return Product.new(title: title, link: link, price: price, rating: rating, mrp: mrp, discount: disc)
  end
  def get_amazon_product_data(product)
    html = "<div class=\"s-result-item\" data-component-type=\"s-search-result\"><h2><a href=\"/sample_product\">Sample Product</a></h2><span class=\"a-offscreen\">₹900</span><span class=\"a-icon-alt\">4.3 out of 5 stars</span><span class=\"a-price a-text-price\">₹1000</span></div><div class=\"s-result-item\" data-component-type=\"s-search-result\"><h2><a href=\"/item2\">Another Product</a></h2><span class=\"a-offscreen\">₹500</span><span class=\"a-icon-alt\">3.8 out of 5 stars</span><span class=\"a-price a-text-price\">₹800</span></div>"
    out = [].clone
    start = 0.clone
    while true
      div_start = find_index(html, "<div class=\"s-result-item\"", start)
      if div_start < 0
        break
      end
      div_end = find_index(html, "</div>", div_start)
      if div_end < 0
        break
      end
      block = html[div_start...div_end]
      out = (out << (parse_product(block))).clone
      start = _add(div_end, "</div>".length).clone
    end
    return out
  end
  def main()
    products = get_amazon_product_data("laptop")
    i = 0.clone
    while i < products.length
      p = products[i]
      puts(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(p.title, " | "), p.link), " | "), p.price), " | "), p.rating), " | "), p.mrp), " | "), _str(p.discount)))
      i = _add(i, 1).clone
    end
  end
  Product = Struct.new(:title, :link, :price, :rating, :mrp, :discount, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
