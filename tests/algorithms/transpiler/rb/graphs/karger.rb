# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def rand_int(n)
    $seed = (_add($seed * 1103515245, 12345)) % 2147483648.clone
    return $seed % n
  end
  def contains(list, value)
    i = 0.clone
    while i < list.length
      if list[i] == value
        return true
      end
      i = _add(i, 1).clone
    end
    return false
  end
  def remove_all(list, value)
    res = [].clone
    i = 0.clone
    while i < list.length
      if list[i] != value
        res = (res << (list[i])).clone
      end
      i = _add(i, 1).clone
    end
    return res
  end
  def partition_graph(graph)
    contracted = {}.clone
        __tmp1 = graph.keys()
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |node|
      contracted[node] = [node]
    end
    graph_copy = {}.clone
        __tmp2 = graph.keys()
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |node|
      lst = [].clone
      neigh = graph[node].clone
      i = 0.clone
      while i < neigh.length
        lst = (lst << (neigh[i])).clone
        i = _add(i, 1).clone
      end
      graph_copy[node] = lst
    end
    nodes = graph_copy.keys().clone
    while nodes.length > 2
      u = nodes[rand_int(nodes.length)]
      u_neighbors = graph_copy[u]
      v = u_neighbors[rand_int(u_neighbors.length)]
      uv = _add(u, v)
      uv_neighbors = [].clone
      i = 0.clone
      while i < graph_copy[u].length
        n = graph_copy[u][i]
        if n != u && n != v && uv_neighbors.include?(n) == false
          uv_neighbors = (uv_neighbors << (n)).clone
        end
        i = _add(i, 1).clone
      end
      i = 0.clone
      while i < graph_copy[v].length
        n = graph_copy[v][i]
        if n != u && n != v && uv_neighbors.include?(n) == false
          uv_neighbors = (uv_neighbors << (n)).clone
        end
        i = _add(i, 1).clone
      end
      graph_copy[uv] = uv_neighbors
      k = 0.clone
      while k < uv_neighbors.length
        nb = uv_neighbors[k]
        graph_copy[nb] = (graph_copy[nb] << (uv))
        graph_copy[nb] = remove_all(graph_copy[nb], u)
        graph_copy[nb] = remove_all(graph_copy[nb], v)
        k = _add(k, 1).clone
      end
      group = [].clone
      i = 0.clone
      while i < contracted[u].length
        group = (group << (contracted[u][i])).clone
        i = _add(i, 1).clone
      end
      i = 0.clone
      while i < contracted[v].length
        val = contracted[v][i]
        if group.include?(val) == false
          group = (group << (val)).clone
        end
        i = _add(i, 1).clone
      end
      contracted[uv] = group
      nodes = remove_all(nodes, u).clone
      nodes = remove_all(nodes, v).clone
      nodes = (nodes << (uv)).clone
    end
    groups = [].clone
    j = 0.clone
    while j < nodes.length
      n = nodes[j]
      groups = (groups << (contracted[n])).clone
      j = _add(j, 1).clone
    end
    groupA = groups[0]
    groupB = groups[1]
    cut = [].clone
    j = 0.clone
    while j < groupA.length
      node = groupA[j]
      neigh = graph[node].clone
      l = 0.clone
      while l < neigh.length
        nb = neigh[l]
        if groupB.include?(nb)
          cut = (cut << (Pair.new(a: node, b: nb))).clone
        end
        l = _add(l, 1).clone
      end
      j = _add(j, 1).clone
    end
    return cut
  end
  def cut_to_string(cut)
    s = "{".clone
    i = 0.clone
    while i < cut.length
      p = cut[i]
      s = _add(_add(_add(_add(_add(s, "("), p.a), ", "), p.b), ")").clone
      if i < cut.length - 1
        s = _add(s, ", ").clone
      end
      i = _add(i, 1).clone
    end
    s = _add(s, "}").clone
    return s
  end
  $seed = 1.clone
  Pair = Struct.new(:a, :b, keyword_init: true)
  $TEST_GRAPH = {"1" => ["2", "3", "4", "5"], "2" => ["1", "3", "4", "5"], "3" => ["1", "2", "4", "5", "10"], "4" => ["1", "2", "3", "5", "6"], "5" => ["1", "2", "3", "4", "7"], "6" => ["7", "8", "9", "10", "4"], "7" => ["6", "8", "9", "10", "5"], "8" => ["6", "7", "9", "10"], "9" => ["6", "7", "8", "10"], "10" => ["6", "7", "8", "9", "3"]}
  $result = partition_graph($TEST_GRAPH)
  puts(cut_to_string($result))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
