# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  NodeCost = Struct.new(:node, :cost, keyword_init: true)
  $G = {"A" => {"B" => 2, "C" => 5}, "B" => {"A" => 2, "D" => 3, "E" => 1, "F" => 1}, "C" => {"A" => 5, "F" => 3}, "D" => {"B" => 3}, "E" => {"B" => 4, "F" => 3}, "F" => {"C" => 3, "E" => 3}}
  $heap = [NodeCost.new(node: "E", cost: 0)].clone
  $visited = {}.clone
  $result = -1.clone
  while $heap.length > 0
    best_idx = 0.clone
    i = 1.clone
    while i < $heap.length
      if $heap[i].cost < $heap[best_idx].cost
        best_idx = i.clone
      end
      i = _add(i, 1).clone
    end
    best = $heap[best_idx]
    new_heap = [].clone
    j = 0.clone
    while j < $heap.length
      if j != best_idx
        new_heap = (new_heap << ($heap[j])).clone
      end
      j = _add(j, 1).clone
    end
    $heap = new_heap.clone
    u = best.node
    cost = best.cost
    if $visited.key?(u)
      next
    end
    $visited[u] = true
    if u == "C"
      $result = cost.clone
      break
    end
        __tmp1 = $G[u]
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |v|
      if $visited.key?(v)
        next
      end
      next_cost = _add(cost, $G[u][v])
      $heap = ($heap << (NodeCost.new(node: v, cost: next_cost))).clone
    end
  end
  puts($result)
  $G2 = {"B" => {"C" => 1}, "C" => {"D" => 1}, "D" => {"F" => 1}, "E" => {"B" => 1, "F" => 3}, "F" => {}}
  $heap2 = [NodeCost.new(node: "E", cost: 0)].clone
  $visited2 = {}.clone
  $result2 = -1.clone
  while $heap2.length > 0
    best2_idx = 0.clone
    i2 = 1.clone
    while i2 < $heap2.length
      if $heap2[i2].cost < $heap2[best2_idx].cost
        best2_idx = i2.clone
      end
      i2 = _add(i2, 1).clone
    end
    best2 = $heap2[best2_idx]
    new_heap2 = [].clone
    j2 = 0.clone
    while j2 < $heap2.length
      if j2 != best2_idx
        new_heap2 = (new_heap2 << ($heap2[j2])).clone
      end
      j2 = _add(j2, 1).clone
    end
    $heap2 = new_heap2.clone
    u2 = best2.node
    cost2 = best2.cost
    if $visited2.key?(u2)
      next
    end
    $visited2[u2] = true
    if u2 == "F"
      $result2 = cost2.clone
      break
    end
        __tmp2 = $G2[u2]
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |v2|
      if $visited2.key?(v2)
        next
      end
      next_cost2 = _add(cost2, $G2[u2][v2])
      $heap2 = ($heap2 << (NodeCost.new(node: v2, cost: next_cost2))).clone
    end
  end
  puts($result2)
  $G3 = {"B" => {"C" => 1}, "C" => {"D" => 1}, "D" => {"F" => 1}, "E" => {"B" => 1, "G" => 2}, "F" => {}, "G" => {"F" => 1}}
  $heap3 = [NodeCost.new(node: "E", cost: 0)].clone
  $visited3 = {}.clone
  $result3 = -1.clone
  while $heap3.length > 0
    best3_idx = 0.clone
    i3 = 1.clone
    while i3 < $heap3.length
      if $heap3[i3].cost < $heap3[best3_idx].cost
        best3_idx = i3.clone
      end
      i3 = _add(i3, 1).clone
    end
    best3 = $heap3[best3_idx]
    new_heap3 = [].clone
    j3 = 0.clone
    while j3 < $heap3.length
      if j3 != best3_idx
        new_heap3 = (new_heap3 << ($heap3[j3])).clone
      end
      j3 = _add(j3, 1).clone
    end
    $heap3 = new_heap3.clone
    u3 = best3.node
    cost3 = best3.cost
    if $visited3.key?(u3)
      next
    end
    $visited3[u3] = true
    if u3 == "F"
      $result3 = cost3.clone
      break
    end
        __tmp3 = $G3[u3]
    if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
      __tmp3 = __tmp3.keys
    end
    __tmp3.each do |v3|
      if $visited3.key?(v3)
        next
      end
      next_cost3 = _add(cost3, $G3[u3][v3])
      $heap3 = ($heap3 << (NodeCost.new(node: v3, cost: next_cost3))).clone
    end
  end
  puts($result3)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
