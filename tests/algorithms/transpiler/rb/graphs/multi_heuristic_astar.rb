# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def pos_equal(a, b)
    return a.x == b.x && a.y == b.y
  end
  def pos_key(p)
    return _add(_add(_str(p.x), ","), _str(p.y))
  end
  def sqrtApprox(x)
    if x <= 0.0
      return 0.0
    end
    guess = x.clone
    i = 0.clone
    while i < 10
      guess = (_add(guess, x / guess)) / 2.0.clone
      i = _add(i, 1).clone
    end
    return guess
  end
  def consistent_heuristic(p, goal)
    dx = ((p.x - goal.x)).to_f
    dy = ((p.y - goal.y)).to_f
    return sqrtApprox(_add(dx * dx, dy * dy))
  end
  def iabs(x)
    if x < 0
      return -x
    end
    return x
  end
  def heuristic_1(p, goal)
    return ((_add(iabs(p.x - goal.x), iabs(p.y - goal.y)))).to_f
  end
  def heuristic_2(p, goal)
    h = consistent_heuristic(p, goal)
    return h / (($t).to_f)
  end
  def heuristic(i, p, goal)
    if i == 0
      return consistent_heuristic(p, goal)
    end
    if i == 1
      return heuristic_1(p, goal)
    end
    return heuristic_2(p, goal)
  end
  def key_fn(start, i, goal, g_func)
    g = g_func[pos_key(start)]
    return _add(g, $W1 * heuristic(i, start, goal))
  end
  def valid(p)
    if p.x < 0 || p.x > $n - 1
      return false
    end
    if p.y < 0 || p.y > $n - 1
      return false
    end
    return true
  end
  def in_blocks(p)
    i = 0.clone
    while i < $blocks.length
      if pos_equal($blocks[i], p)
        return true
      end
      i = _add(i, 1).clone
    end
    return false
  end
  def pq_put(pq, node, pri)
    updated = false.clone
    i = 0.clone
    while i < pq.length
      if pos_equal(pq[i].pos, node)
        if pri < pq[i].pri
          pq[i] = PQNode.new(pos: node, pri: pri)
        end
        updated = true.clone
      end
      i = _add(i, 1).clone
    end
    if !updated
      pq = (pq << (PQNode.new(pos: node, pri: pri))).clone
    end
    return pq
  end
  def pq_minkey(pq)
    if pq.length == 0
      return $INF
    end
    first = pq[0].clone
    m = first.pri.clone
    i = 1.clone
    while i < pq.length
      item = pq[i].clone
      if item.pri < m
        m = item.pri.clone
      end
      i = _add(i, 1).clone
    end
    return m
  end
  def pq_pop_min(pq)
    best = pq[0].clone
    idx = 0.clone
    i = 1.clone
    while i < pq.length
      if pq[i].pri < best.pri
        best = pq[i].clone
        idx = i.clone
      end
      i = _add(i, 1).clone
    end
    new_pq = [].clone
    i = 0.clone
    while i < pq.length
      if i != idx
        new_pq = (new_pq << (pq[i])).clone
      end
      i = _add(i, 1).clone
    end
    return PQPopResult.new(pq: new_pq, node: best)
  end
  def pq_remove(pq, node)
    new_pq = [].clone
    i = 0.clone
    while i < pq.length
      if !pos_equal(pq[i].pos, node)
        new_pq = (new_pq << (pq[i])).clone
      end
      i = _add(i, 1).clone
    end
    return new_pq
  end
  def reconstruct(back_pointer, goal, start)
    path = [].clone
    current = goal.clone
    key = pos_key(current).clone
    path = (path << (current)).clone
    while !(pos_equal(current, start))
      current = back_pointer[key].clone
      key = pos_key(current).clone
      path = (path << (current)).clone
    end
    rev = [].clone
    i = path.length - 1.clone
    while i >= 0
      rev = (rev << (path[i])).clone
      i = i - 1.clone
    end
    return rev
  end
  def neighbours(p)
    left = Pos.new(x: p.x - 1, y: p.y)
    right = Pos.new(x: _add(p.x, 1), y: p.y)
    up = Pos.new(x: p.x, y: _add(p.y, 1))
    down = Pos.new(x: p.x, y: p.y - 1)
    return [left, right, up, down]
  end
  def multi_a_star(start, goal, n_heuristic)
    g_function = {}.clone
    back_pointer = {}.clone
    visited = {}.clone
    open_list = [].clone
    g_function[pos_key(start)] = 0.0
    g_function[pos_key(goal)] = $INF
    back_pointer[pos_key(start)] = Pos.new(x: -1, y: -1)
    back_pointer[pos_key(goal)] = Pos.new(x: -1, y: -1)
    visited[pos_key(start)] = true
    i = 0.clone
    while i < n_heuristic
      open_list = (open_list << ([])).clone
      pri = key_fn(start, i, goal, g_function)
      open_list[i] = pq_put(open_list[i], start, pri)
      i = _add(i, 1).clone
    end
    while pq_minkey(open_list[0]) < $INF
      chosen = 0.clone
      i = 1.clone
      while i < n_heuristic
        if pq_minkey(open_list[i]) <= $W2 * pq_minkey(open_list[0])
          chosen = i.clone
          break
        end
        i = _add(i, 1).clone
      end
      if chosen != 0
        $t = _add($t, 1).clone
      end
      pair = pq_pop_min(open_list[chosen]).clone
      open_list[chosen] = pair.pq
      current = pair.node
      i = 0.clone
      while i < n_heuristic
        if i != chosen
          open_list[i] = pq_remove(open_list[i], current.pos)
        end
        i = _add(i, 1).clone
      end
      ckey = pos_key(current.pos)
      if visited.key?(ckey)
        next
      end
      visited[ckey] = true
      if pos_equal(current.pos, goal)
        path = reconstruct(back_pointer, goal, start)
        j = 0.clone
        while j < path.length
          p = path[j]
          puts(_add(_add(_add(_add("(", _str(p.x)), ","), _str(p.y)), ")"))
          j = _add(j, 1).clone
        end
        return
      end
      neighs = neighbours(current.pos)
      k = 0.clone
      while k < neighs.length
        nb = neighs[k]
        if valid(nb) && (in_blocks(nb) == false)
          nkey = pos_key(nb)
          tentative = _add(g_function[ckey], 1.0)
          if !(g_function.key?(nkey)) || tentative < g_function[nkey]
            g_function[nkey] = tentative
            back_pointer[nkey] = current.pos
            i = 0.clone
            while i < n_heuristic
              pri2 = _add(tentative, $W1 * heuristic(i, nb, goal))
              open_list[i] = pq_put(open_list[i], nb, pri2)
              i = _add(i, 1).clone
            end
          end
        end
        k = _add(k, 1).clone
      end
    end
    puts("No path found to goal")
  end
  $W1 = 1.0
  $W2 = 1.0
  $n = 20
  $n_heuristic = 3
  Pos = Struct.new(:x, :y, keyword_init: true)
  PQNode = Struct.new(:pos, :pri, keyword_init: true)
  PQPopResult = Struct.new(:pq, :node, keyword_init: true)
  $INF = 1000000000.0
  $t = 1.clone
  $blocks = [Pos.new(x: 0, y: 1), Pos.new(x: 1, y: 1), Pos.new(x: 2, y: 1), Pos.new(x: 3, y: 1), Pos.new(x: 4, y: 1), Pos.new(x: 5, y: 1), Pos.new(x: 6, y: 1), Pos.new(x: 7, y: 1), Pos.new(x: 8, y: 1), Pos.new(x: 9, y: 1), Pos.new(x: 10, y: 1), Pos.new(x: 11, y: 1), Pos.new(x: 12, y: 1), Pos.new(x: 13, y: 1), Pos.new(x: 14, y: 1), Pos.new(x: 15, y: 1), Pos.new(x: 16, y: 1), Pos.new(x: 17, y: 1), Pos.new(x: 18, y: 1), Pos.new(x: 19, y: 1)]
  $start = Pos.new(x: 0, y: 0)
  $goal = Pos.new(x: $n - 1, y: $n - 1)
  multi_a_star($start, $goal, $n_heuristic)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
