# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def prims_algo(graph)
    _INF = 2147483647
    dist = {}.clone
    parent = {}.clone
    queue = [].clone
        __tmp1 = graph.keys()
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |node|
      dist[node] = _INF
      parent[node] = ""
      queue = (queue << (QueueNode.new(node: node, weight: _INF))).clone
    end
    if queue.length == 0
      return MSTResult.new(dist: dist, parent: parent)
    end
    min_idx = 0.clone
    i = 1.clone
    while i < queue.length
      if queue[i]["weight"] < queue[min_idx]["weight"]
        min_idx = i.clone
      end
      i = _add(i, 1).clone
    end
    start_node = queue[min_idx]
    start = start_node["node"]
    new_q = [].clone
    j = 0.clone
    while j < queue.length
      if j != min_idx
        new_q = (new_q << (queue[j])).clone
      end
      j = _add(j, 1).clone
    end
    queue = new_q.clone
    dist[start] = 0
        __tmp2 = graph[start].keys()
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |neighbour|
      w = graph[start][neighbour]
      if dist[neighbour] > _add(dist[start], w)
        dist[neighbour] = _add(dist[start], w)
        parent[neighbour] = start
        k = 0.clone
        while k < queue.length
          if queue[k]["node"] == neighbour
            queue[k]["weight"] = dist[neighbour]
            break
          end
          k = _add(k, 1).clone
        end
      end
    end
    while queue.length > 0
      best_idx = 0.clone
      p = 1.clone
      while p < queue.length
        if queue[p]["weight"] < queue[best_idx]["weight"]
          best_idx = p.clone
        end
        p = _add(p, 1).clone
      end
      node_entry = queue[best_idx]
      node = node_entry["node"]
      tmp = [].clone
      q = 0.clone
      while q < queue.length
        if q != best_idx
          tmp = (tmp << (queue[q])).clone
        end
        q = _add(q, 1).clone
      end
      queue = tmp.clone
            __tmp3 = graph[node].keys()
      if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
        __tmp3 = __tmp3.keys
      end
      __tmp3.each do |neighbour|
        w = graph[node][neighbour]
        if dist[neighbour] > _add(dist[node], w)
          dist[neighbour] = _add(dist[node], w)
          parent[neighbour] = node
          r = 0.clone
          while r < queue.length
            if queue[r]["node"] == neighbour
              queue[r]["weight"] = dist[neighbour]
              break
            end
            r = _add(r, 1).clone
          end
        end
      end
    end
    return MSTResult.new(dist: dist, parent: parent)
  end
  def iabs(x)
    if x < 0
      return -x
    end
    return x
  end
  QueueNode = Struct.new(:node, :weight, keyword_init: true)
  MSTResult = Struct.new(:dist, :parent, keyword_init: true)
  $graph = {}.clone
  $graph["a"] = {"b" => 3, "c" => 15}
  $graph["b"] = {"a" => 3, "c" => 10, "d" => 100}
  $graph["c"] = {"a" => 15, "b" => 10, "d" => 5}
  $graph["d"] = {"b" => 100, "c" => 5}
  $res = prims_algo($graph)
  $dist = $res.dist
  puts(_str(iabs($dist["a"] - $dist["b"])))
  puts(_str(iabs($dist["d"] - $dist["b"])))
  puts(_str(iabs($dist["a"] - $dist["c"])))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
