# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def pow2(k)
    res = 1.clone
    i = 0.clone
    while i < k
      res = res * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def min2(a, b)
    if a < b
      return a
    end
    return b
  end
  def new_dinic(n)
    lvl = [].clone
    ptr = [].clone
    q = [].clone
    adj = [].clone
    i = 0.clone
    while i < n
      lvl = (lvl << (0)).clone
      ptr = (ptr << (0)).clone
      q = (q << (0)).clone
      edges = [].clone
      adj = (adj << (edges)).clone
      i = _add(i, 1).clone
    end
    return Dinic.new(n: n, lvl: lvl, ptr: ptr, q: q, adj: adj)
  end
  def add_edge(g, a, b, c, rcap)
    adj = g.adj.clone
    list_a = adj[a].clone
    list_b = adj[b].clone
    e1 = [b, list_b.length, c, 0]
    e2 = [a, list_a.length, rcap, 0]
    list_a = (list_a << (e1)).clone
    list_b = (list_b << (e2)).clone
    adj[a] = list_a
    adj[b] = list_b
    g["adj"] = adj
  end
  def dfs(g, v, sink, flow)
    if v == sink || flow == 0
      return flow
    end
    ptr = g.ptr.clone
    i = ptr[v].clone
    adj_all = g.adj.clone
    adj_v = adj_all[v].clone
    while i < adj_v.length
      e = adj_v[i].clone
      to = e[0]
      if g.lvl[to] == _add(g.lvl[v], 1)
        avail = e[2] - e[3]
        pushed = dfs(g, to, sink, min2(flow, avail))
        if pushed > 0
          e[3] = _add(e[3], pushed)
          adj_v[i] = e
          adj_to = adj_all[to].clone
          back = adj_to[e[1]].clone
          back[3] = back[3] - pushed
          adj_to[e[1]] = back
          adj_all[to] = adj_to
          adj_all[v] = adj_v
          g["adj"] = adj_all
          return pushed
        end
      end
      i = _add(i, 1).clone
      ptr[v] = i
    end
    g["ptr"] = ptr
    adj_all[v] = adj_v
    g["adj"] = adj_all
    return 0
  end
  def max_flow(g, source, sink)
    flow = 0.clone
    l = 0.clone
    while l < 31
      threshold = pow2(30 - l)
      while true
        lvl = [].clone
        ptr = [].clone
        i = 0.clone
        while i < g.n
          lvl = (lvl << (0)).clone
          ptr = (ptr << (0)).clone
          i = _add(i, 1).clone
        end
        g["lvl"] = lvl
        g["ptr"] = ptr
        qi = 0.clone
        qe = 1.clone
        lvl[source] = 1
        g["lvl"] = lvl
        q = g.q.clone
        q[0] = source
        while qi < qe && g.lvl[sink] == 0
          v = q[qi]
          qi = _add(qi, 1).clone
          edges = g.adj[v].clone
          j = 0.clone
          while j < edges.length
            e = edges[j]
            to = e[0]
            residual = e[2] - e[3]
            lvl_inner = g.lvl.clone
            if lvl_inner[to] == 0 && residual >= threshold
              q[qe] = to
              qe = _add(qe, 1).clone
              lvl_inner[to] = _add(lvl_inner[v], 1)
              g["lvl"] = lvl_inner
            end
            j = _add(j, 1).clone
          end
        end
        p = dfs(g, source, sink, $INF).clone
        while p > 0
          flow = _add(flow, p).clone
          p = dfs(g, source, sink, $INF).clone
        end
        if g.lvl[sink] == 0
          break
        end
      end
      l = _add(l, 1).clone
    end
    return flow
  end
  $INF = 1000000000
  Dinic = Struct.new(:n, :lvl, :ptr, :q, :adj, keyword_init: true)
  $graph = new_dinic(10).clone
  $source = 0
  $sink = 9
  $v = 1.clone
  while $v < 5
    add_edge($graph, $source, $v, 1, 0)
    $v = _add($v, 1).clone
  end
  $v = 5.clone
  while $v < 9
    add_edge($graph, $v, $sink, 1, 0)
    $v = _add($v, 1).clone
  end
  $v = 1.clone
  while $v < 5
    add_edge($graph, $v, _add($v, 4), 1, 0)
    $v = _add($v, 1).clone
  end
  puts(_str(max_flow($graph, $source, $sink)))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
