# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def key(p)
    return _add(_add(_str(p.x), ","), _str(p.y))
  end
  def path_to_string(path)
    s = "[".clone
    i = 0.clone
    while i < path.length
      pt = path[i]
      s = _add(_add(_add(_add(_add(s, "("), _str(pt.x)), ", "), _str(pt.y)), ")").clone
      if i < path.length - 1
        s = _add(s, ", ").clone
      end
      i = _add(i, 1).clone
    end
    s = _add(s, "]").clone
    return s
  end
  def dijkstra(grid, source, destination, allow_diagonal)
    rows = grid.length
    cols = grid[0].length
    dx = [-1, 1, 0, 0].clone
    dy = [0, 0, -1, 1].clone
    if allow_diagonal
      dx = _add(dx, [-1, -1, 1, 1]).clone
      dy = _add(dy, [-1, 1, -1, 1]).clone
    end
    _INF = 1000000000000.0
    queue = [source].clone
    front = 0.clone
    dist_map = {key(source) => 0.0}.clone
    prev = {}.clone
    while front < queue.length
      current = queue[front]
      front = _add(front, 1).clone
      cur_key = key(current)
      if current.x == destination.x && current.y == destination.y
        break
      end
      i = 0.clone
      while i < dx.length
        nx = _add(current.x, dx[i])
        ny = _add(current.y, dy[i])
        if nx >= 0 && nx < rows && ny >= 0 && ny < cols
          if grid[nx][ny] == 1
            n_key = _add(_add(_str(nx), ","), _str(ny))
            if !(dist_map.key?(n_key))
              dist_map[n_key] = _add(dist_map[cur_key], 1.0)
              prev[n_key] = current
              queue = (queue << (Point.new(x: nx, y: ny))).clone
            end
          end
        end
        i = _add(i, 1).clone
      end
    end
    dest_key = key(destination)
    if dist_map.key?(dest_key)
      path_rev = [destination].clone
      step_key = dest_key.clone
      step_pt = destination.clone
      while step_key != key(source)
        step_pt = prev[step_key].clone
        step_key = key(step_pt).clone
        path_rev = (path_rev << (step_pt)).clone
      end
      path = [].clone
      k = path_rev.length - 1.clone
      while k >= 0
        path = (path << (path_rev[k])).clone
        k = k - 1.clone
      end
      return Result.new(distance: dist_map[dest_key], path: path)
    end
    return Result.new(distance: _INF, path: [])
  end
  def print_result(res)
    puts(_add(_add(_str(res.distance), ", "), path_to_string(res.path)))
  end
  Point = Struct.new(:x, :y, keyword_init: true)
  Result = Struct.new(:distance, :path, keyword_init: true)
  $grid1 = [[1, 1, 1], [0, 1, 0], [0, 1, 1]].clone
  print_result(dijkstra($grid1, Point.new(x: 0, y: 0), Point.new(x: 2, y: 2), false))
  print_result(dijkstra($grid1, Point.new(x: 0, y: 0), Point.new(x: 2, y: 2), true))
  $grid2 = [[1, 1, 1], [0, 0, 1], [0, 1, 1]].clone
  print_result(dijkstra($grid2, Point.new(x: 0, y: 0), Point.new(x: 2, y: 2), false))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
