# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def expand_search(graph, queue, head, parents, visited, opposite_visited)
    if head >= queue.length
      return ExpandResult.new(queue: queue, head: head, parents: parents, visited: visited, intersection: 0 - 1, found: false)
    end
    current = queue[head]
    head = _add(head, 1)
    neighbors = graph[current]
    q = queue
    p = parents
    v = visited
    i = 0
    while i < neighbors.length
      neighbor = neighbors[i]
      if v[neighbor]
        i = _add(i, 1)
        next
      end
      v[neighbor] = true
      p[neighbor] = current
      q = (q << (neighbor))
      if opposite_visited[neighbor]
        return ExpandResult.new(queue: q, head: head, parents: p, visited: v, intersection: neighbor, found: true)
      end
      i = _add(i, 1)
    end
    return ExpandResult.new(queue: q, head: head, parents: p, visited: v, intersection: 0 - 1, found: false)
  end
  def construct_path(current, parents)
    path = []
    node = current
    while node != 0 - 1
      path = (path << (node))
      node = parents[node]
    end
    return path
  end
  def reverse_list(xs)
    res = []
    i = xs.length
    while i > 0
      i = i - 1
      res = (res << (xs[i]))
    end
    return res
  end
  def bidirectional_search(g, start, goal)
    if start == goal
      return SearchResult.new(path: [start], ok: true)
    end
    forward_parents = {}
    forward_parents[start] = 0 - 1
    backward_parents = {}
    backward_parents[goal] = 0 - 1
    forward_visited = {}
    forward_visited[start] = true
    backward_visited = {}
    backward_visited[goal] = true
    forward_queue = [start]
    backward_queue = [goal]
    forward_head = 0
    backward_head = 0
    intersection = 0 - 1
    while forward_head < forward_queue.length && backward_head < backward_queue.length && intersection == 0 - 1
      res = expand_search(g, forward_queue, forward_head, forward_parents, forward_visited, backward_visited)
      forward_queue = res.queue
      forward_head = res.head
      forward_parents = res.parents
      forward_visited = res.visited
      if res.found
        intersection = res.intersection
        break
      end
      res = expand_search(g, backward_queue, backward_head, backward_parents, backward_visited, forward_visited)
      backward_queue = res.queue
      backward_head = res.head
      backward_parents = res.parents
      backward_visited = res.visited
      if res.found
        intersection = res.intersection
        break
      end
    end
    if intersection == 0 - 1
      return SearchResult.new(path: [], ok: false)
    end
    forward_path = construct_path(intersection, forward_parents)
    forward_path = reverse_list(forward_path)
    back_start = backward_parents[intersection]
    backward_path = construct_path(back_start, backward_parents)
    result = forward_path
    j = 0
    while j < backward_path.length
      result = (result << (backward_path[j]))
      j = _add(j, 1)
    end
    return SearchResult.new(path: result, ok: true)
  end
  def is_edge(g, u, v)
    neighbors = g[u]
    i = 0
    while i < neighbors.length
      if neighbors[i] == v
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def path_exists(g, path)
    if path.length == 0
      return false
    end
    i = 0
    while _add(i, 1) < path.length
      if !is_edge(g, path[i], path[_add(i, 1)])
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def print_path(g, s, t)
    res = bidirectional_search(g, s, t)
    if res.ok && path_exists(g, res.path)
      puts(_add(_add(_add(_add(_add("Path from ", _str(s)), " to "), _str(t)), ": "), ((x = res.path); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
    else
      puts(_add(_add(_add(_add("Path from ", _str(s)), " to "), _str(t)), ": None"))
    end
  end
  def main()
    graph = {0 => [1, 2], 1 => [0, 3, 4], 2 => [0, 5, 6], 3 => [1, 7], 4 => [1, 8], 5 => [2, 9], 6 => [2, 10], 7 => [3, 11], 8 => [4, 11], 9 => [5, 11], 10 => [6, 11], 11 => [7, 8, 9, 10]}
    print_path(graph, 0, 11)
    print_path(graph, 5, 5)
    disconnected = {0 => [1, 2], 1 => [0], 2 => [0], 3 => [4], 4 => [3]}
    print_path(disconnected, 0, 3)
  end
  ExpandResult = Struct.new(:queue, :head, :parents, :visited, :intersection, :found, keyword_init: true)
  SearchResult = Struct.new(:path, :ok, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
