# Generated by Mochi transpiler v0.10.73 on 2025-08-25 16:44 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if (arr.is_a?(Array) || arr.is_a?(String)) && idx.is_a?(Numeric)
    idx += arr.length if idx < 0
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && b.is_a?(Array)
    a + b
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  arr = [] if arr.nil?
  x = x.clone if x.is_a?(Array)
  arr << x
  arr
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-8 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    "[" + x.map { |e| _str(e) }.join(' ') + "]"
  elsif x.is_a?(Float)
    x.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def expand_search(graph, queue, head, parents, visited, opposite_visited)
    if head >= _len(queue)
      return ExpandResult.new(queue: queue, head: head, parents: parents, visited: visited, intersection: 0 - 1, found: false)
    end
    current = (__tmp1 = queue; __tmp1.is_a?(Hash) ? __tmp1[head] : _idx(__tmp1, head))
    head = _add(head, 1)
    neighbors = (__tmp2 = graph; __tmp2.is_a?(Hash) ? __tmp2[current] : _idx(__tmp2, current))
    q = queue
    p = parents
    v = visited
    i = 0
    while i < _len(neighbors)
      neighbor = (__tmp3 = neighbors; __tmp3.is_a?(Hash) ? __tmp3[i] : _idx(__tmp3, i))
      if (__tmp4 = v; __tmp4.is_a?(Hash) ? __tmp4[neighbor] : _idx(__tmp4, neighbor))
        i = _add(i, 1)
        next
      end
      v[neighbor] = true
      p[neighbor] = current
      q = _append(q, neighbor)
      if (__tmp5 = opposite_visited; __tmp5.is_a?(Hash) ? __tmp5[neighbor] : _idx(__tmp5, neighbor))
        return ExpandResult.new(queue: q, head: head, parents: p, visited: v, intersection: neighbor, found: true)
      end
      i = _add(i, 1)
    end
    return ExpandResult.new(queue: q, head: head, parents: p, visited: v, intersection: 0 - 1, found: false)
  end
  def construct_path(current, parents)
    path = []
    node = current
    while !_eq(node, 0 - 1)
      path = _append(path, node)
      node = (__tmp6 = parents; __tmp6.is_a?(Hash) ? __tmp6[node] : _idx(__tmp6, node))
    end
    return path
  end
  def reverse_list(xs)
    res = []
    i = _len(xs)
    while i > 0
      i = i - 1
      res = _append(res, (__tmp7 = xs; __tmp7.is_a?(Hash) ? __tmp7[i] : _idx(__tmp7, i)))
    end
    return res
  end
  def bidirectional_search(g, start, goal)
    if _eq(start, goal)
      return SearchResult.new(path: [start], ok: true)
    end
    forward_parents = {}
    forward_parents[start] = 0 - 1
    backward_parents = {}
    backward_parents[goal] = 0 - 1
    forward_visited = {}
    forward_visited[start] = true
    backward_visited = {}
    backward_visited[goal] = true
    forward_queue = [start]
    backward_queue = [goal]
    forward_head = 0
    backward_head = 0
    intersection = 0 - 1
    while forward_head < _len(forward_queue) && backward_head < _len(backward_queue) && _eq(intersection, 0 - 1)
      res = expand_search(g, forward_queue, forward_head, forward_parents, forward_visited, backward_visited)
      forward_queue = res.queue
      forward_head = res.head
      forward_parents = res.parents
      forward_visited = res.visited
      if res.found
        intersection = res.intersection
        break
      end
      res = expand_search(g, backward_queue, backward_head, backward_parents, backward_visited, forward_visited)
      backward_queue = res.queue
      backward_head = res.head
      backward_parents = res.parents
      backward_visited = res.visited
      if res.found
        intersection = res.intersection
        break
      end
    end
    if _eq(intersection, 0 - 1)
      return SearchResult.new(path: [], ok: false)
    end
    forward_path = construct_path(intersection, forward_parents)
    forward_path = reverse_list(forward_path)
    back_start = (__tmp8 = backward_parents; __tmp8.is_a?(Hash) ? __tmp8[intersection] : _idx(__tmp8, intersection))
    backward_path = construct_path(back_start, backward_parents)
    result = forward_path
    j = 0
    while j < _len(backward_path)
      result = _append(result, (__tmp9 = backward_path; __tmp9.is_a?(Hash) ? __tmp9[j] : _idx(__tmp9, j)))
      j = _add(j, 1)
    end
    return SearchResult.new(path: result, ok: true)
  end
  def is_edge(g, u, v)
    neighbors = (__tmp10 = g; __tmp10.is_a?(Hash) ? __tmp10[u] : _idx(__tmp10, u))
    i = 0
    while i < _len(neighbors)
      if _eq((__tmp11 = neighbors; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i)), v)
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def path_exists(g, path)
    if _eq(_len(path), 0)
      return false
    end
    i = 0
    while _add(i, 1) < _len(path)
      if !is_edge(g, (__tmp12 = path; __tmp12.is_a?(Hash) ? __tmp12[i] : _idx(__tmp12, i)), (__tmp13 = path; __tmp13.is_a?(Hash) ? __tmp13[_add(i, 1)] : _idx(__tmp13, _add(i, 1))))
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def print_path(g, s, t)
    res = bidirectional_search(g, s, t)
    if res.ok && path_exists(g, res.path)
      puts(_add(_add(_add(_add(_add("Path from ", _str(s)), " to "), _str(t)), ": "), ((x = res.path); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
    else
      puts(_add(_add(_add(_add("Path from ", _str(s)), " to "), _str(t)), ": None"))
    end
  end
  def main()
    graph = {0 => [1, 2], 1 => [0, 3, 4], 2 => [0, 5, 6], 3 => [1, 7], 4 => [1, 8], 5 => [2, 9], 6 => [2, 10], 7 => [3, 11], 8 => [4, 11], 9 => [5, 11], 10 => [6, 11], 11 => [7, 8, 9, 10]}
    print_path(graph, 0, 11)
    print_path(graph, 5, 5)
    disconnected = {0 => [1, 2], 1 => [0], 2 => [0], 3 => [4], 4 => [3]}
    print_path(disconnected, 0, 3)
  end
  Object.send(:remove_const, :ExpandResult) if Object.const_defined?(:ExpandResult)
  Object.const_set(:ExpandResult, Struct.new(:queue, :head, :parents, :visited, :intersection, :found, keyword_init: true))
  Object.send(:remove_const, :SearchResult) if Object.const_defined?(:SearchResult)
  Object.const_set(:SearchResult, Struct.new(:path, :ok, keyword_init: true))
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
