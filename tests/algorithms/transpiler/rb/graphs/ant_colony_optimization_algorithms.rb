# Generated by Mochi transpiler v0.10.64 on 2025-08-13 16:08 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil? || !idx.is_a?(Numeric) || idx < 0 || idx >= arr.length
  arr[idx]
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:to_h)
    obj.to_h.key?(key.to_sym)
  else
    obj.respond_to?(:include?) && obj.include?(key)
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    a + b
  end
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def sqrtApprox(x)
    guess = x / 2.0
    i = 0
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def rand_float()
    return ((_now() % 1000000)).to_f / 1e+06
  end
  def pow_float(base, exp)
    result = 1.0
    i = 0
    e = (exp).to_i
    while i < e
      result = result * base
      i = _add(i, 1)
    end
    return result
  end
  def distance(city1, city2)
    dx = (((__tmp1 = city1; __tmp1.is_a?(Hash) ? __tmp1[0] : _idx(__tmp1, 0)) - (__tmp2 = city2; __tmp2.is_a?(Hash) ? __tmp2[0] : _idx(__tmp2, 0)))).to_f
    dy = (((__tmp3 = city1; __tmp3.is_a?(Hash) ? __tmp3[1] : _idx(__tmp3, 1)) - (__tmp4 = city2; __tmp4.is_a?(Hash) ? __tmp4[1] : _idx(__tmp4, 1)))).to_f
    return sqrtApprox(_add(dx * dx, dy * dy))
  end
  def choose_weighted(options, weights)
    total = 0.0
    i = 0
    while i < _len(weights)
      total = _add(total, (__tmp5 = weights; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i)))
      i = _add(i, 1)
    end
    r = rand_float() * total
    accum = 0.0
    i = 0
    while i < _len(weights)
      accum = _add(accum, (__tmp6 = weights; __tmp6.is_a?(Hash) ? __tmp6[i] : _idx(__tmp6, i)))
      if r <= accum
        return (__tmp7 = options; __tmp7.is_a?(Hash) ? __tmp7[i] : _idx(__tmp7, i))
      end
      i = _add(i, 1)
    end
    return (__tmp8 = options; __tmp8.is_a?(Hash) ? __tmp8[_len(options) - 1] : _idx(__tmp8, _len(options) - 1))
  end
  def city_select(pheromone, current, unvisited, alpha, beta, cities)
    probs = []
    i = 0
    while i < _len(unvisited)
      city = (__tmp9 = unvisited; __tmp9.is_a?(Hash) ? __tmp9[i] : _idx(__tmp9, i))
      dist = distance((__tmp10 = cities; __tmp10.is_a?(Hash) ? __tmp10[city] : _idx(__tmp10, city)), (__tmp11 = cities; __tmp11.is_a?(Hash) ? __tmp11[current] : _idx(__tmp11, current)))
      trail = (__tmp12 = (__tmp13 = pheromone; __tmp13.is_a?(Hash) ? __tmp13[city] : _idx(__tmp13, city)); __tmp12.is_a?(Hash) ? __tmp12[current] : _idx(__tmp12, current))
      prob = pow_float(trail, alpha) * pow_float(1.0 / dist, beta)
      probs = (probs + [prob])
      i = _add(i, 1)
    end
    return choose_weighted(unvisited, probs)
  end
  def pheromone_update(pheromone, cities, evaporation, ants_route, q)
    n = _len(pheromone)
    i = 0
    while i < n
      j = 0
      while j < n
        (__tmp14 = pheromone; __tmp14.is_a?(Hash) ? __tmp14[i] : _idx(__tmp14, i))[j] = (__tmp15 = (__tmp16 = pheromone; __tmp16.is_a?(Hash) ? __tmp16[i] : _idx(__tmp16, i)); __tmp15.is_a?(Hash) ? __tmp15[j] : _idx(__tmp15, j)) * evaporation
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    a = 0
    while a < _len(ants_route)
      route = (__tmp17 = ants_route; __tmp17.is_a?(Hash) ? __tmp17[a] : _idx(__tmp17, a))
      total = 0.0
      r = 0
      while r < _len(route) - 1
        total = _add(total, distance((__tmp18 = cities; __tmp18.is_a?(Hash) ? __tmp18[(__tmp19 = route; __tmp19.is_a?(Hash) ? __tmp19[r] : _idx(__tmp19, r))] : _idx(__tmp18, (__tmp20 = route; __tmp20.is_a?(Hash) ? __tmp20[r] : _idx(__tmp20, r)))), (__tmp21 = cities; __tmp21.is_a?(Hash) ? __tmp21[(__tmp22 = route; __tmp22.is_a?(Hash) ? __tmp22[_add(r, 1)] : _idx(__tmp22, _add(r, 1)))] : _idx(__tmp21, (__tmp23 = route; __tmp23.is_a?(Hash) ? __tmp23[_add(r, 1)] : _idx(__tmp23, _add(r, 1)))))))
        r = _add(r, 1)
      end
      delta = q / total
      r = 0
      while r < _len(route) - 1
        u = (__tmp24 = route; __tmp24.is_a?(Hash) ? __tmp24[r] : _idx(__tmp24, r))
        v = (__tmp25 = route; __tmp25.is_a?(Hash) ? __tmp25[_add(r, 1)] : _idx(__tmp25, _add(r, 1)))
        (__tmp26 = pheromone; __tmp26.is_a?(Hash) ? __tmp26[u] : _idx(__tmp26, u))[v] = _add((__tmp27 = (__tmp28 = pheromone; __tmp28.is_a?(Hash) ? __tmp28[u] : _idx(__tmp28, u)); __tmp27.is_a?(Hash) ? __tmp27[v] : _idx(__tmp27, v)), delta)
        (__tmp29 = pheromone; __tmp29.is_a?(Hash) ? __tmp29[v] : _idx(__tmp29, v))[u] = (__tmp30 = (__tmp31 = pheromone; __tmp31.is_a?(Hash) ? __tmp31[u] : _idx(__tmp31, u)); __tmp30.is_a?(Hash) ? __tmp30[v] : _idx(__tmp30, v))
        r = _add(r, 1)
      end
      a = _add(a, 1)
    end
    return pheromone
  end
  def remove_value(lst, val)
    res = []
    i = 0
    while i < _len(lst)
      if !_eq((__tmp32 = lst; __tmp32.is_a?(Hash) ? __tmp32[i] : _idx(__tmp32, i)), val)
        res = (res + [(__tmp33 = lst; __tmp33.is_a?(Hash) ? __tmp33[i] : _idx(__tmp33, i))])
      end
      i = _add(i, 1)
    end
    return res
  end
  def ant_colony(cities, ants_num, iterations, evaporation, alpha, beta, q)
    n = _len(cities)
    pheromone = []
    i = 0
    while i < n
      row = []
      j = 0
      while j < n
        row = (row + [1.0])
        j = _add(j, 1)
      end
      pheromone = (pheromone + [row])
      i = _add(i, 1)
    end
    best_path = []
    best_distance = 1e+09
    iter = 0
    while iter < iterations
      ants_route = []
      k = 0
      while k < ants_num
        route = [0]
        unvisited = []
                __tmp34 = cities.keys()
        if __tmp34.respond_to?(:keys) && !__tmp34.is_a?(String)
          __tmp34 = __tmp34.keys
        end
        __tmp34.each do |key|
          if !_eq(key, 0)
            unvisited = (unvisited + [key])
          end
        end
        current = 0
        while _len(unvisited) > 0
          next_city = city_select(pheromone, current, unvisited, alpha, beta, cities)
          route = (route + [next_city])
          unvisited = remove_value(unvisited, next_city)
          current = next_city
        end
        route = (route + [0])
        ants_route = (ants_route + [route])
        k = _add(k, 1)
      end
      pheromone = pheromone_update(pheromone, cities, evaporation, ants_route, q)
      a = 0
      while a < _len(ants_route)
        route = (__tmp35 = ants_route; __tmp35.is_a?(Hash) ? __tmp35[a] : _idx(__tmp35, a))
        dist = 0.0
        r = 0
        while r < _len(route) - 1
          dist = _add(dist, distance((__tmp36 = cities; __tmp36.is_a?(Hash) ? __tmp36[(__tmp37 = route; __tmp37.is_a?(Hash) ? __tmp37[r] : _idx(__tmp37, r))] : _idx(__tmp36, (__tmp38 = route; __tmp38.is_a?(Hash) ? __tmp38[r] : _idx(__tmp38, r)))), (__tmp39 = cities; __tmp39.is_a?(Hash) ? __tmp39[(__tmp40 = route; __tmp40.is_a?(Hash) ? __tmp40[_add(r, 1)] : _idx(__tmp40, _add(r, 1)))] : _idx(__tmp39, (__tmp41 = route; __tmp41.is_a?(Hash) ? __tmp41[_add(r, 1)] : _idx(__tmp41, _add(r, 1)))))))
          r = _add(r, 1)
        end
        if dist < best_distance
          best_distance = dist
          best_path = route
        end
        a = _add(a, 1)
      end
      iter = _add(iter, 1)
    end
    puts(_add("best_path = ", ((x = best_path); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
    puts(_add("best_distance = ", _str(best_distance)))
  end
  $cities = {0 => [0, 0], 1 => [0, 5], 2 => [3, 8], 3 => [8, 10], 4 => [12, 8], 5 => [12, 4], 6 => [8, 0], 7 => [6, 2]}
  ant_colony($cities, 10, 20, 0.7, 1.0, 5.0, 10.0)
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
