# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def sqrtApprox(x)
    guess = x / 2.0
    i = 0
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def rand_float()
    return ((_now() % 1000000)).to_f / 1000000.0
  end
  def pow_float(base, exp)
    result = 1.0
    i = 0
    e = (exp).to_i
    while i < e
      result = result * base
      i = _add(i, 1)
    end
    return result
  end
  def distance(city1, city2)
    dx = ((city1[0] - city2[0])).to_f
    dy = ((city1[1] - city2[1])).to_f
    return sqrtApprox(_add(dx * dx, dy * dy))
  end
  def choose_weighted(options, weights)
    total = 0.0
    i = 0
    while i < weights.length
      total = _add(total, weights[i])
      i = _add(i, 1)
    end
    r = rand_float() * total
    accum = 0.0
    i = 0
    while i < weights.length
      accum = _add(accum, weights[i])
      if r <= accum
        return options[i]
      end
      i = _add(i, 1)
    end
    return options[options.length - 1]
  end
  def city_select(pheromone, current, unvisited, alpha, beta, cities)
    probs = []
    i = 0
    while i < unvisited.length
      city = unvisited[i]
      dist = distance(cities[city], cities[current])
      trail = pheromone[city][current]
      prob = pow_float(trail, alpha) * pow_float(1.0 / dist, beta)
      probs = (probs << (prob))
      i = _add(i, 1)
    end
    return choose_weighted(unvisited, probs)
  end
  def pheromone_update(pheromone, cities, evaporation, ants_route, q)
    n = pheromone.length
    i = 0
    while i < n
      j = 0
      while j < n
        pheromone[i][j] = pheromone[i][j] * evaporation
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    a = 0
    while a < ants_route.length
      route = ants_route[a]
      total = 0.0
      r = 0
      while r < route.length - 1
        total = _add(total, distance(cities[route[r]], cities[route[_add(r, 1)]]))
        r = _add(r, 1)
      end
      delta = q / total
      r = 0
      while r < route.length - 1
        u = route[r]
        v = route[_add(r, 1)]
        pheromone[u][v] = _add(pheromone[u][v], delta)
        pheromone[v][u] = pheromone[u][v]
        r = _add(r, 1)
      end
      a = _add(a, 1)
    end
    return pheromone
  end
  def remove_value(lst, val)
    res = []
    i = 0
    while i < lst.length
      if lst[i] != val
        res = (res << (lst[i]))
      end
      i = _add(i, 1)
    end
    return res
  end
  def ant_colony(cities, ants_num, iterations, evaporation, alpha, beta, q)
    n = cities.length
    pheromone = []
    i = 0
    while i < n
      row = []
      j = 0
      while j < n
        row = (row << (1.0))
        j = _add(j, 1)
      end
      pheromone = (pheromone << (row))
      i = _add(i, 1)
    end
    best_path = []
    best_distance = 1000000000.0
    iter = 0
    while iter < iterations
      ants_route = []
      k = 0
      while k < ants_num
        route = [0]
        unvisited = []
                __tmp1 = cities.keys()
        if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
          __tmp1 = __tmp1.keys
        end
        __tmp1.each do |key|
          if key != 0
            unvisited = (unvisited << (key))
          end
        end
        current = 0
        while unvisited.length > 0
          next_city = city_select(pheromone, current, unvisited, alpha, beta, cities)
          route = (route << (next_city))
          unvisited = remove_value(unvisited, next_city)
          current = next_city
        end
        route = (route << (0))
        ants_route = (ants_route << (route))
        k = _add(k, 1)
      end
      pheromone = pheromone_update(pheromone, cities, evaporation, ants_route, q)
      a = 0
      while a < ants_route.length
        route = ants_route[a]
        dist = 0.0
        r = 0
        while r < route.length - 1
          dist = _add(dist, distance(cities[route[r]], cities[route[_add(r, 1)]]))
          r = _add(r, 1)
        end
        if dist < best_distance
          best_distance = dist
          best_path = route
        end
        a = _add(a, 1)
      end
      iter = _add(iter, 1)
    end
    puts(_add("best_path = ", ((x = best_path); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
    puts(_add("best_distance = ", _str(best_distance)))
  end
  $cities = {0 => [0, 0], 1 => [0, 5], 2 => [3, 8], 3 => [8, 10], 4 => [12, 8], 5 => [12, 4], 6 => [8, 0], 7 => [6, 2]}
  ant_colony($cities, 10, 20, 0.7, 1.0, 5.0, 10.0)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
