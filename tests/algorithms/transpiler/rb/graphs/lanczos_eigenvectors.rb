# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def rand()
    $seed = (_add($seed * 1103515245, 12345)) % 2147483648.clone
    return $seed
  end
  def random()
    return (1.0 * rand()) / 2147483648.0
  end
  def sqrtApprox(x)
    if x <= 0.0
      return 0.0
    end
    guess = x.clone
    i = 0.clone
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0.clone
      i = _add(i, 1).clone
    end
    return guess
  end
  def absf(x)
    return (x < 0.0 ? -x : x)
  end
  def dot(a, b)
    s = 0.0.clone
    i = 0.clone
    while i < a.length
      s = _add(s, a[i] * b[i]).clone
      i = _add(i, 1).clone
    end
    return s
  end
  def vector_scale(v, s)
    res = [].clone
    i = 0.clone
    while i < v.length
      res = (res << (v[i] * s)).clone
      i = _add(i, 1).clone
    end
    return res
  end
  def vector_sub(a, b)
    res = [].clone
    i = 0.clone
    while i < a.length
      res = (res << (a[i] - b[i])).clone
      i = _add(i, 1).clone
    end
    return res
  end
  def vector_add(a, b)
    res = [].clone
    i = 0.clone
    while i < a.length
      res = (res << (_add(a[i], b[i]))).clone
      i = _add(i, 1).clone
    end
    return res
  end
  def zeros_matrix(r, c)
    m = [].clone
    i = 0.clone
    while i < r
      row = [].clone
      j = 0.clone
      while j < c
        row = (row << (0.0)).clone
        j = _add(j, 1).clone
      end
      m = (m << (row)).clone
      i = _add(i, 1).clone
    end
    return m
  end
  def column(m, idx)
    col = [].clone
    i = 0.clone
    while i < m.length
      col = (col << (m[i][idx])).clone
      i = _add(i, 1).clone
    end
    return col
  end
  def validate_adjacency_list(graph)
    i = 0.clone
    while i < graph.length
      j = 0.clone
      while j < graph[i].length
        v = graph[i][j]
        if v < 0 || v >= graph.length
          panic("Invalid neighbor")
        end
        j = _add(j, 1).clone
      end
      i = _add(i, 1).clone
    end
  end
  def multiply_matrix_vector(graph, vector)
    n = graph.length
    if vector.length != n
      panic("Vector length must match number of nodes")
    end
    result = [].clone
    i = 0.clone
    while i < n
      sum = 0.0.clone
      j = 0.clone
      while j < graph[i].length
        nb = graph[i][j]
        sum = _add(sum, vector[nb]).clone
        j = _add(j, 1).clone
      end
      result = (result << (sum)).clone
      i = _add(i, 1).clone
    end
    return result
  end
  def lanczos_iteration(graph, k)
    n = graph.length
    if k < 1 || k > n
      panic("invalid number of eigenvectors")
    end
    q = zeros_matrix(n, k).clone
    t = zeros_matrix(k, k).clone
    v = [].clone
    i = 0.clone
    while i < n
      v = (v << (random())).clone
      i = _add(i, 1).clone
    end
    ss = 0.0.clone
    i = 0.clone
    while i < n
      ss = _add(ss, v[i] * v[i]).clone
      i = _add(i, 1).clone
    end
    vnorm = sqrtApprox(ss)
    i = 0.clone
    while i < n
      q[i][0] = v[i] / vnorm
      i = _add(i, 1).clone
    end
    beta = 0.0.clone
    j = 0.clone
    while j < k
      w = multiply_matrix_vector(graph, column(q, j)).clone
      if j > 0
        w = vector_sub(w, vector_scale(column(q, j - 1), beta)).clone
      end
      alpha = dot(column(q, j), w)
      w = vector_sub(w, vector_scale(column(q, j), alpha)).clone
      ss2 = 0.0.clone
      p = 0.clone
      while p < n
        ss2 = _add(ss2, w[p] * w[p]).clone
        p = _add(p, 1).clone
      end
      beta = sqrtApprox(ss2).clone
      t[j][j] = alpha
      if j < k - 1
        t[j][_add(j, 1)] = beta
        t[_add(j, 1)][j] = beta
        if beta > 1e-10
          wnorm = vector_scale(w, 1.0 / beta).clone
          r = 0.clone
          while r < n
            q[r][_add(j, 1)] = wnorm[r]
            r = _add(r, 1).clone
          end
        end
      end
      j = _add(j, 1).clone
    end
    return LanczosResult.new(t: t, q: q)
  end
  def jacobi_eigen(a_in, max_iter)
    n = a_in.length
    a = a_in.clone
    v = zeros_matrix(n, n).clone
    i = 0.clone
    while i < n
      v[i][i] = 1.0
      i = _add(i, 1).clone
    end
    iter = 0.clone
    while iter < max_iter
      p = 0.clone
      q = 1.clone
      max = absf(a[p][q]).clone
      i = 0.clone
      while i < n
        j = _add(i, 1).clone
        while j < n
          val = absf(a[i][j])
          if val > max
            max = val.clone
            p = i.clone
            q = j.clone
          end
          j = _add(j, 1).clone
        end
        i = _add(i, 1).clone
      end
      if max < 1e-08
        break
      end
      app = a[p][p]
      aqq = a[q][q]
      apq = a[p][q]
      theta = (aqq - app) / (2.0 * apq)
      t = 1.0 / (_add(absf(theta), sqrtApprox(_add(theta * theta, 1.0)))).clone
      if theta < 0.0
        t = -t.clone
      end
      c = 1.0 / sqrtApprox(_add(1.0, t * t))
      s = t * c
      tau = s / (_add(1.0, c))
      a[p][p] = app - t * apq
      a[q][q] = _add(aqq, t * apq)
      a[p][q] = 0.0
      a[q][p] = 0.0
      k = 0.clone
      while k < n
        if k != p && k != q
          akp = a[k][p]
          akq = a[k][q]
          a[k][p] = akp - s * (_add(akq, tau * akp))
          a[p][k] = a[k][p]
          a[k][q] = _add(akq, s * (akp - tau * akq))
          a[q][k] = a[k][q]
        end
        k = _add(k, 1).clone
      end
      k = 0.clone
      while k < n
        vkp = v[k][p]
        vkq = v[k][q]
        v[k][p] = vkp - s * (_add(vkq, tau * vkp))
        v[k][q] = _add(vkq, s * (vkp - tau * vkq))
        k = _add(k, 1).clone
      end
      iter = _add(iter, 1).clone
    end
    eigenvalues = [].clone
    i = 0.clone
    while i < n
      eigenvalues = (eigenvalues << (a[i][i])).clone
      i = _add(i, 1).clone
    end
    return EigenResult.new(values: eigenvalues, vectors: v)
  end
  def matmul(a, b)
    rows = a.length
    cols = b[0].length
    inner = b.length
    m = zeros_matrix(rows, cols).clone
    i = 0.clone
    while i < rows
      j = 0.clone
      while j < cols
        s = 0.0.clone
        k = 0.clone
        while k < inner
          s = _add(s, a[i][k] * b[k][j]).clone
          k = _add(k, 1).clone
        end
        m[i][j] = s
        j = _add(j, 1).clone
      end
      i = _add(i, 1).clone
    end
    return m
  end
  def sort_eigenpairs(vals, vecs)
    n = vals.length
    values = vals.clone
    vectors = vecs.clone
    i = 0.clone
    while i < n
      j = 0.clone
      while j < n - 1
        if values[j] < values[_add(j, 1)]
          tmp = values[j]
          values[j] = values[_add(j, 1)]
          values[_add(j, 1)] = tmp
          r = 0.clone
          while r < vectors.length
            tv = vectors[r][j]
            vectors[r][j] = vectors[r][_add(j, 1)]
            vectors[r][_add(j, 1)] = tv
            r = _add(r, 1).clone
          end
        end
        j = _add(j, 1).clone
      end
      i = _add(i, 1).clone
    end
    return EigenResult.new(values: values, vectors: vectors)
  end
  def find_lanczos_eigenvectors(graph, k)
    validate_adjacency_list(graph)
    res = lanczos_iteration(graph, k)
    eig = jacobi_eigen(res.t, 50)
    sorted = sort_eigenpairs(eig.values, eig.vectors)
    final_vectors = matmul(res.q, sorted.vectors)
    return EigenResult.new(values: sorted.values, vectors: final_vectors)
  end
  def list_to_string(arr)
    s = "[".clone
    i = 0.clone
    while i < arr.length
      s = _add(s, _str(arr[i])).clone
      if i < arr.length - 1
        s = _add(s, ", ").clone
      end
      i = _add(i, 1).clone
    end
    return _add(s, "]")
  end
  def matrix_to_string(m)
    s = "[".clone
    i = 0.clone
    while i < m.length
      s = _add(s, list_to_string(m[i])).clone
      if i < m.length - 1
        s = _add(s, "; ").clone
      end
      i = _add(i, 1).clone
    end
    return _add(s, "]")
  end
  $seed = 123456789.clone
  LanczosResult = Struct.new(:t, :q, keyword_init: true)
  EigenResult = Struct.new(:values, :vectors, keyword_init: true)
  $graph = [[1, 2], [0, 2], [0, 1]]
  $result = find_lanczos_eigenvectors($graph, 2)
  puts(list_to_string($result.values))
  puts(matrix_to_string($result.vectors))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
