# Generated by Mochi transpiler v0.10.65 on 2025-08-14 16:08 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def list_contains_int(xs, x)
    i = 0
    while i < _len(xs)
      if _eq((__tmp1 = xs; __tmp1.is_a?(Hash) ? __tmp1[i] : _idx(__tmp1, i)), x)
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def edge_exists(edges, w, v)
    i = 0
    while i < _len(edges)
      if _eq((__tmp2 = (__tmp3 = edges; __tmp3.is_a?(Hash) ? __tmp3[i] : _idx(__tmp3, i)); __tmp2.is_a?(Hash) ? __tmp2[0] : _idx(__tmp2, 0)), w) && _eq((__tmp4 = (__tmp5 = edges; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i)); __tmp4.is_a?(Hash) ? __tmp4[1] : _idx(__tmp4, 1)), v)
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def first_key(m)
        __tmp6 = m.keys()
    __tmp6 = [] if __tmp6.nil?
    if __tmp6.respond_to?(:keys) && !__tmp6.is_a?(String)
      __tmp6 = __tmp6.keys
    end
    __tmp6.each do |k|
      return k
    end
    return 0
  end
  def rand_range(low, high)
    return _add((_now() % (high - low)), low)
  end
  def dg_make_graph()
    return DirectedGraph.new(graph: {})
  end
  def dg_add_pair(g, u, v, w)
    if _has(g.graph, u)
      edges = (__tmp7 = g.graph; __tmp7.is_a?(Hash) ? __tmp7[u] : _idx(__tmp7, u))
      if !edge_exists(edges, w, v)
        edges = _append(edges, [w, v])
        m = g.graph
        m[u] = edges
        g.graph = m
      end
    else
      m0 = g.graph
      m0[u] = [[w, v]]
      g.graph = m0
    end
    if !(_has(g.graph, v))
      m1 = g.graph
      m1[v] = []
      g.graph = m1
    end
  end
  def dg_remove_pair(g, u, v)
    if _has(g.graph, u)
      edges = (__tmp8 = g.graph; __tmp8.is_a?(Hash) ? __tmp8[u] : _idx(__tmp8, u))
      new_edges = []
      i = 0
      while i < _len(edges)
        if !_eq((__tmp9 = (__tmp10 = edges; __tmp10.is_a?(Hash) ? __tmp10[i] : _idx(__tmp10, i)); __tmp9.is_a?(Hash) ? __tmp9[1] : _idx(__tmp9, 1)), v)
          new_edges = _append(new_edges, (__tmp11 = edges; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i)))
        end
        i = _add(i, 1)
      end
      m = g.graph
      m[u] = new_edges
      g.graph = m
    end
  end
  def dg_all_nodes(g)
    res = []
        __tmp12 = g.graph.keys()
    __tmp12 = [] if __tmp12.nil?
    if __tmp12.respond_to?(:keys) && !__tmp12.is_a?(String)
      __tmp12 = __tmp12.keys
    end
    __tmp12.each do |k|
      res = _append(res, k)
    end
    return res
  end
  def dg_dfs_util(g, node, visited, order, d)
    visited[node] = true
    order = _append(order, node)
    if !_eq(d, (-1)) && _eq(node, d)
      return order
    end
    edges = (__tmp13 = g.graph; __tmp13.is_a?(Hash) ? __tmp13[node] : _idx(__tmp13, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp14 = (__tmp15 = edges; __tmp15.is_a?(Hash) ? __tmp15[i] : _idx(__tmp15, i)); __tmp14.is_a?(Hash) ? __tmp14[1] : _idx(__tmp14, 1))
      if !(_has(visited, neigh))
        order = dg_dfs_util(g, neigh, visited, order, d)
        if !_eq(d, (-1)) && _eq((__tmp16 = order; __tmp16.is_a?(Hash) ? __tmp16[_len(order) - 1] : _idx(__tmp16, _len(order) - 1)), d)
          return order
        end
      end
      i = _add(i, 1)
    end
    return order
  end
  def dg_dfs(g, s, d)
    if _eq(s, d)
      return []
    end
    start = (_eq(s, (-2)) ? first_key(g.graph) : s)
    visited = {}
    order = []
    order = dg_dfs_util(g, start, visited, order, d)
    return order
  end
  def dg_bfs(g, s)
    queue = []
    visited = {}
    order = []
    start = (_eq(s, (-2)) ? first_key(g.graph) : s)
    queue = _append(queue, start)
    visited[start] = true
    while _len(queue) > 0
      node = (__tmp17 = queue; __tmp17.is_a?(Hash) ? __tmp17[0] : _idx(__tmp17, 0))
      queue = queue[1..._len(queue)]
      order = _append(order, node)
      edges = (__tmp18 = g.graph; __tmp18.is_a?(Hash) ? __tmp18[node] : _idx(__tmp18, node))
      i = 0
      while i < _len(edges)
        neigh = (__tmp19 = (__tmp20 = edges; __tmp20.is_a?(Hash) ? __tmp20[i] : _idx(__tmp20, i)); __tmp19.is_a?(Hash) ? __tmp19[1] : _idx(__tmp19, 1))
        if !(_has(visited, neigh))
          queue = _append(queue, neigh)
          visited[neigh] = true
        end
        i = _add(i, 1)
      end
    end
    return order
  end
  def dg_in_degree(g, u)
    count = 0
        __tmp21 = g.graph.keys()
    __tmp21 = [] if __tmp21.nil?
    if __tmp21.respond_to?(:keys) && !__tmp21.is_a?(String)
      __tmp21 = __tmp21.keys
    end
    __tmp21.each do |k|
      edges = (__tmp22 = g.graph; __tmp22.is_a?(Hash) ? __tmp22[k] : _idx(__tmp22, k))
      i = 0
      while i < _len(edges)
        if _eq((__tmp23 = (__tmp24 = edges; __tmp24.is_a?(Hash) ? __tmp24[i] : _idx(__tmp24, i)); __tmp23.is_a?(Hash) ? __tmp23[1] : _idx(__tmp23, 1)), u)
          count = _add(count, 1)
        end
        i = _add(i, 1)
      end
    end
    return count
  end
  def dg_out_degree(g, u)
    if _has(g.graph, u)
      return _len((__tmp25 = g.graph; __tmp25.is_a?(Hash) ? __tmp25[u] : _idx(__tmp25, u)))
    end
    return 0
  end
  def dg_topo_util(g, node, visited, stack)
    visited[node] = true
    edges = (__tmp26 = g.graph; __tmp26.is_a?(Hash) ? __tmp26[node] : _idx(__tmp26, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp27 = (__tmp28 = edges; __tmp28.is_a?(Hash) ? __tmp28[i] : _idx(__tmp28, i)); __tmp27.is_a?(Hash) ? __tmp27[1] : _idx(__tmp27, 1))
      if !(_has(visited, neigh))
        stack = dg_topo_util(g, neigh, visited, stack)
      end
      i = _add(i, 1)
    end
    stack = _append(stack, node)
    return stack
  end
  def dg_topological_sort(g)
    visited = {}
    stack = []
        __tmp29 = g.graph.keys()
    __tmp29 = [] if __tmp29.nil?
    if __tmp29.respond_to?(:keys) && !__tmp29.is_a?(String)
      __tmp29 = __tmp29.keys
    end
    __tmp29.each do |k|
      if !(_has(visited, k))
        stack = dg_topo_util(g, k, visited, stack)
      end
    end
    res = []
    i = _len(stack) - 1
    while i >= 0
      res = _append(res, (__tmp30 = stack; __tmp30.is_a?(Hash) ? __tmp30[i] : _idx(__tmp30, i)))
      i = i - 1
    end
    return res
  end
  def dg_cycle_util(g, node, visited, rec, res)
    visited[node] = true
    rec[node] = true
    edges = (__tmp31 = g.graph; __tmp31.is_a?(Hash) ? __tmp31[node] : _idx(__tmp31, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp32 = (__tmp33 = edges; __tmp33.is_a?(Hash) ? __tmp33[i] : _idx(__tmp33, i)); __tmp32.is_a?(Hash) ? __tmp32[1] : _idx(__tmp32, 1))
      if !(_has(visited, neigh))
        res = dg_cycle_util(g, neigh, visited, rec, res)
      else
        if (__tmp34 = rec; __tmp34.is_a?(Hash) ? __tmp34[neigh] : _idx(__tmp34, neigh))
          if !list_contains_int(res, neigh)
            res = _append(res, neigh)
          end
          if !list_contains_int(res, node)
            res = _append(res, node)
          end
        end
      end
      i = _add(i, 1)
    end
    rec[node] = false
    return res
  end
  def dg_cycle_nodes(g)
    visited = {}
    rec = {}
    res = []
        __tmp35 = g.graph.keys()
    __tmp35 = [] if __tmp35.nil?
    if __tmp35.respond_to?(:keys) && !__tmp35.is_a?(String)
      __tmp35 = __tmp35.keys
    end
    __tmp35.each do |k|
      if !(_has(visited, k))
        res = dg_cycle_util(g, k, visited, rec, res)
      end
    end
    return res
  end
  def dg_has_cycle_util(g, node, visited, rec)
    visited[node] = true
    rec[node] = true
    edges = (__tmp36 = g.graph; __tmp36.is_a?(Hash) ? __tmp36[node] : _idx(__tmp36, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp37 = (__tmp38 = edges; __tmp38.is_a?(Hash) ? __tmp38[i] : _idx(__tmp38, i)); __tmp37.is_a?(Hash) ? __tmp37[1] : _idx(__tmp37, 1))
      if !(_has(visited, neigh))
        if dg_has_cycle_util(g, neigh, visited, rec)
          return true
        end
      else
        if (__tmp39 = rec; __tmp39.is_a?(Hash) ? __tmp39[neigh] : _idx(__tmp39, neigh))
          return true
        end
      end
      i = _add(i, 1)
    end
    rec[node] = false
    return false
  end
  def dg_has_cycle(g)
    visited = {}
    rec = {}
        __tmp40 = g.graph.keys()
    __tmp40 = [] if __tmp40.nil?
    if __tmp40.respond_to?(:keys) && !__tmp40.is_a?(String)
      __tmp40 = __tmp40.keys
    end
    __tmp40.each do |k|
      if !(_has(visited, k))
        if dg_has_cycle_util(g, k, visited, rec)
          return true
        end
      end
    end
    return false
  end
  def dg_fill_graph_randomly(g, c)
    count = c
    if _eq(count, (-1))
      count = rand_range(10, 10010)
    end
    i = 0
    while i < count
      edge_count = rand_range(1, 103)
      j = 0
      while j < edge_count
        n = rand_range(0, count)
        if !_eq(n, i)
          dg_add_pair(g, i, n, 1)
        end
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
  end
  def dg_dfs_time(g, s, e)
    begin_ = _now()
    dg_dfs(g, s, e)
    end_ = _now()
    return end_ - begin_
  end
  def dg_bfs_time(g, s)
    begin_ = _now()
    dg_bfs(g, s)
    end_ = _now()
    return end_ - begin_
  end
  def g_make_graph()
    return Graph.new(graph: {})
  end
  def g_add_pair(g, u, v, w)
    if _has(g.graph, u)
      edges = (__tmp41 = g.graph; __tmp41.is_a?(Hash) ? __tmp41[u] : _idx(__tmp41, u))
      if !edge_exists(edges, w, v)
        edges = _append(edges, [w, v])
        m = g.graph
        m[u] = edges
        g.graph = m
      end
    else
      m0 = g.graph
      m0[u] = [[w, v]]
      g.graph = m0
    end
    if _has(g.graph, v)
      edges2 = (__tmp42 = g.graph; __tmp42.is_a?(Hash) ? __tmp42[v] : _idx(__tmp42, v))
      if !edge_exists(edges2, w, u)
        edges2 = _append(edges2, [w, u])
        m2 = g.graph
        m2[v] = edges2
        g.graph = m2
      end
    else
      m3 = g.graph
      m3[v] = [[w, u]]
      g.graph = m3
    end
  end
  def g_remove_pair(g, u, v)
    if _has(g.graph, u)
      edges = (__tmp43 = g.graph; __tmp43.is_a?(Hash) ? __tmp43[u] : _idx(__tmp43, u))
      new_edges = []
      i = 0
      while i < _len(edges)
        if !_eq((__tmp44 = (__tmp45 = edges; __tmp45.is_a?(Hash) ? __tmp45[i] : _idx(__tmp45, i)); __tmp44.is_a?(Hash) ? __tmp44[1] : _idx(__tmp44, 1)), v)
          new_edges = _append(new_edges, (__tmp46 = edges; __tmp46.is_a?(Hash) ? __tmp46[i] : _idx(__tmp46, i)))
        end
        i = _add(i, 1)
      end
      m = g.graph
      m[u] = new_edges
      g.graph = m
    end
    if _has(g.graph, v)
      edges2 = (__tmp47 = g.graph; __tmp47.is_a?(Hash) ? __tmp47[v] : _idx(__tmp47, v))
      new_edges2 = []
      j = 0
      while j < _len(edges2)
        if !_eq((__tmp48 = (__tmp49 = edges2; __tmp49.is_a?(Hash) ? __tmp49[j] : _idx(__tmp49, j)); __tmp48.is_a?(Hash) ? __tmp48[1] : _idx(__tmp48, 1)), u)
          new_edges2 = _append(new_edges2, (__tmp50 = edges2; __tmp50.is_a?(Hash) ? __tmp50[j] : _idx(__tmp50, j)))
        end
        j = _add(j, 1)
      end
      m2 = g.graph
      m2[v] = new_edges2
      g.graph = m2
    end
  end
  def g_all_nodes(g)
    res = []
        __tmp51 = g.graph.keys()
    __tmp51 = [] if __tmp51.nil?
    if __tmp51.respond_to?(:keys) && !__tmp51.is_a?(String)
      __tmp51 = __tmp51.keys
    end
    __tmp51.each do |k|
      res = _append(res, k)
    end
    return res
  end
  def g_dfs_util(g, node, visited, order, d)
    visited[node] = true
    order = _append(order, node)
    if !_eq(d, (-1)) && _eq(node, d)
      return order
    end
    edges = (__tmp52 = g.graph; __tmp52.is_a?(Hash) ? __tmp52[node] : _idx(__tmp52, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp53 = (__tmp54 = edges; __tmp54.is_a?(Hash) ? __tmp54[i] : _idx(__tmp54, i)); __tmp53.is_a?(Hash) ? __tmp53[1] : _idx(__tmp53, 1))
      if !(_has(visited, neigh))
        order = g_dfs_util(g, neigh, visited, order, d)
        if !_eq(d, (-1)) && _eq((__tmp55 = order; __tmp55.is_a?(Hash) ? __tmp55[_len(order) - 1] : _idx(__tmp55, _len(order) - 1)), d)
          return order
        end
      end
      i = _add(i, 1)
    end
    return order
  end
  def g_dfs(g, s, d)
    if _eq(s, d)
      return []
    end
    start = (_eq(s, (-2)) ? first_key(g.graph) : s)
    visited = {}
    order = []
    order = g_dfs_util(g, start, visited, order, d)
    return order
  end
  def g_bfs(g, s)
    queue = []
    visited = {}
    order = []
    start = (_eq(s, (-2)) ? first_key(g.graph) : s)
    queue = _append(queue, start)
    visited[start] = true
    while _len(queue) > 0
      node = (__tmp56 = queue; __tmp56.is_a?(Hash) ? __tmp56[0] : _idx(__tmp56, 0))
      queue = queue[1..._len(queue)]
      order = _append(order, node)
      edges = (__tmp57 = g.graph; __tmp57.is_a?(Hash) ? __tmp57[node] : _idx(__tmp57, node))
      i = 0
      while i < _len(edges)
        neigh = (__tmp58 = (__tmp59 = edges; __tmp59.is_a?(Hash) ? __tmp59[i] : _idx(__tmp59, i)); __tmp58.is_a?(Hash) ? __tmp58[1] : _idx(__tmp58, 1))
        if !(_has(visited, neigh))
          queue = _append(queue, neigh)
          visited[neigh] = true
        end
        i = _add(i, 1)
      end
    end
    return order
  end
  def g_degree(g, u)
    if _has(g.graph, u)
      return _len((__tmp60 = g.graph; __tmp60.is_a?(Hash) ? __tmp60[u] : _idx(__tmp60, u)))
    end
    return 0
  end
  def g_cycle_util(g, node, visited, parent, res)
    visited[node] = true
    edges = (__tmp61 = g.graph; __tmp61.is_a?(Hash) ? __tmp61[node] : _idx(__tmp61, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp62 = (__tmp63 = edges; __tmp63.is_a?(Hash) ? __tmp63[i] : _idx(__tmp63, i)); __tmp62.is_a?(Hash) ? __tmp62[1] : _idx(__tmp62, 1))
      if !(_has(visited, neigh))
        res = g_cycle_util(g, neigh, visited, node, res)
      else
        if !_eq(neigh, parent)
          if !list_contains_int(res, neigh)
            res = _append(res, neigh)
          end
          if !list_contains_int(res, node)
            res = _append(res, node)
          end
        end
      end
      i = _add(i, 1)
    end
    return res
  end
  def g_cycle_nodes(g)
    visited = {}
    res = []
        __tmp64 = g.graph.keys()
    __tmp64 = [] if __tmp64.nil?
    if __tmp64.respond_to?(:keys) && !__tmp64.is_a?(String)
      __tmp64 = __tmp64.keys
    end
    __tmp64.each do |k|
      if !(_has(visited, k))
        res = g_cycle_util(g, k, visited, -1, res)
      end
    end
    return res
  end
  def g_has_cycle_util(g, node, visited, parent)
    visited[node] = true
    edges = (__tmp65 = g.graph; __tmp65.is_a?(Hash) ? __tmp65[node] : _idx(__tmp65, node))
    i = 0
    while i < _len(edges)
      neigh = (__tmp66 = (__tmp67 = edges; __tmp67.is_a?(Hash) ? __tmp67[i] : _idx(__tmp67, i)); __tmp66.is_a?(Hash) ? __tmp66[1] : _idx(__tmp66, 1))
      if !(_has(visited, neigh))
        if g_has_cycle_util(g, neigh, visited, node)
          return true
        end
      else
        if !_eq(neigh, parent)
          return true
        end
      end
      i = _add(i, 1)
    end
    return false
  end
  def g_has_cycle(g)
    visited = {}
        __tmp68 = g.graph.keys()
    __tmp68 = [] if __tmp68.nil?
    if __tmp68.respond_to?(:keys) && !__tmp68.is_a?(String)
      __tmp68 = __tmp68.keys
    end
    __tmp68.each do |k|
      if !(_has(visited, k))
        if g_has_cycle_util(g, k, visited, -1)
          return true
        end
      end
    end
    return false
  end
  def g_fill_graph_randomly(g, c)
    count = c
    if _eq(count, (-1))
      count = rand_range(10, 10010)
    end
    i = 0
    while i < count
      edge_count = rand_range(1, 103)
      j = 0
      while j < edge_count
        n = rand_range(0, count)
        if !_eq(n, i)
          g_add_pair(g, i, n, 1)
        end
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
  end
  def g_dfs_time(g, s, e)
    begin_ = _now()
    g_dfs(g, s, e)
    end_ = _now()
    return end_ - begin_
  end
  def g_bfs_time(g, s)
    begin_ = _now()
    g_bfs(g, s)
    end_ = _now()
    return end_ - begin_
  end
  def main()
    dg = dg_make_graph()
    dg_add_pair(dg, 0, 1, 5)
    dg_add_pair(dg, 0, 2, 3)
    dg_add_pair(dg, 1, 3, 2)
    dg_add_pair(dg, 2, 3, 4)
    puts(((x = dg_dfs(dg, -2, -1)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    puts(((x = dg_bfs(dg, -2)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    puts(_str(dg_in_degree(dg, 3)))
    puts(_str(dg_out_degree(dg, 0)))
    puts(((x = dg_topological_sort(dg)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    puts(_str(dg_has_cycle(dg)))
    ug = g_make_graph()
    g_add_pair(ug, 0, 1, 1)
    g_add_pair(ug, 1, 2, 1)
    g_add_pair(ug, 2, 0, 1)
    puts(((x = g_dfs(ug, -2, -1)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    puts(((x = g_bfs(ug, -2)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    puts(_str(g_degree(ug, 1)))
    puts(_str(g_has_cycle(ug)))
  end
  Object.send(:remove_const, :DirectedGraph) if Object.const_defined?(:DirectedGraph)
  DirectedGraph = Struct.new(:graph, keyword_init: true)
  Object.send(:remove_const, :Graph) if Object.const_defined?(:Graph)
  Graph = Struct.new(:graph, keyword_init: true)
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
