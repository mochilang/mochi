# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def get_min_index(q)
    idx = 0
    i = 1
    while i < q.length
      if q[i].cost < q[idx].cost
        idx = i
      end
      i = _add(i, 1)
    end
    return idx
  end
  def remove_at(q, idx)
    res = []
    i = 0
    while i < q.length
      if i != idx
        res = (res << (q[i]))
      end
      i = _add(i, 1)
    end
    return res
  end
  def pass_and_relaxation(graph, v, visited_forward, visited_backward, cst_fwd, cst_bwd, queue, parent, shortest_distance)
    q = queue
    sd = shortest_distance
        __tmp1 = graph[v]
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |e|
      nxt = e.to
      d = e.cost
      if visited_forward.key?(nxt)
        next
      end
      old_cost = (cst_fwd.key?(nxt) ? cst_fwd[nxt] : 2147483647)
      new_cost = _add(cst_fwd[v], d)
      if new_cost < old_cost
        q = (q << (QItem.new(node: nxt, cost: new_cost)))
        cst_fwd[nxt] = new_cost
        parent[nxt] = v
      end
      if visited_backward.key?(nxt)
        alt = _add(_add(cst_fwd[v], d), cst_bwd[nxt])
        if alt < sd
          sd = alt
        end
      end
    end
    return PassResult.new(queue: q, dist: sd)
  end
  def bidirectional_dij(source, destination, graph_forward, graph_backward)
    shortest_path_distance = -1
    visited_forward = {}
    visited_backward = {}
    cst_fwd = {}
    cst_fwd[source] = 0
    cst_bwd = {}
    cst_bwd[destination] = 0
    parent_forward = {}
    parent_forward[source] = ""
    parent_backward = {}
    parent_backward[destination] = ""
    queue_forward = []
    queue_forward = (queue_forward << (QItem.new(node: source, cost: 0)))
    queue_backward = []
    queue_backward = (queue_backward << (QItem.new(node: destination, cost: 0)))
    shortest_distance = 2147483647
    if source == destination
      return 0
    end
    while queue_forward.length > 0 && queue_backward.length > 0
      idx_f = get_min_index(queue_forward)
      item_f = queue_forward[idx_f]
      queue_forward = remove_at(queue_forward, idx_f)
      v_fwd = item_f["node"]
      visited_forward[v_fwd] = true
      idx_b = get_min_index(queue_backward)
      item_b = queue_backward[idx_b]
      queue_backward = remove_at(queue_backward, idx_b)
      v_bwd = item_b["node"]
      visited_backward[v_bwd] = true
      res_f = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, parent_forward, shortest_distance)
      queue_forward = res_f.queue
      shortest_distance = res_f.dist
      res_b = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, parent_backward, shortest_distance)
      queue_backward = res_b.queue
      shortest_distance = res_b.dist
      if _add(cst_fwd[v_fwd], cst_bwd[v_bwd]) >= shortest_distance
        break
      end
    end
    if shortest_distance != 2147483647
      shortest_path_distance = shortest_distance
    end
    return shortest_path_distance
  end
  Edge = Struct.new(:to, :cost, keyword_init: true)
  QItem = Struct.new(:node, :cost, keyword_init: true)
  PassResult = Struct.new(:queue, :dist, keyword_init: true)
  $graph_fwd = {"B" => [Edge.new(to: "C", cost: 1)], "C" => [Edge.new(to: "D", cost: 1)], "D" => [Edge.new(to: "F", cost: 1)], "E" => [Edge.new(to: "B", cost: 1), Edge.new(to: "G", cost: 2)], "F" => [], "G" => [Edge.new(to: "F", cost: 1)]}
  $graph_bwd = {"B" => [Edge.new(to: "E", cost: 1)], "C" => [Edge.new(to: "B", cost: 1)], "D" => [Edge.new(to: "C", cost: 1)], "F" => [Edge.new(to: "D", cost: 1), Edge.new(to: "G", cost: 1)], "E" => [], "G" => [Edge.new(to: "E", cost: 2)]}
  puts(_str(bidirectional_dij("E", "F", $graph_fwd, $graph_bwd)))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
