# Generated by Mochi transpiler v0.10.65 on 2025-08-14 10:00 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil? || !idx.is_a?(Numeric) || idx < 0 || idx >= arr.length
  arr[idx]
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def abs(x)
    if x < 0
      return -x
    end
    return x
  end
  def sqrtApprox(x)
    if x <= 0.0
      return 0.0
    end
    guess = x
    i = 0
    while i < 10
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def heuristic(a, b)
    dy = a.y - b.y
    dx = a.x - b.x
    if _eq($HEURISTIC, 1)
      return ((_add(dy.abs(), dx.abs()))).to_f
    end
    dyf = ((dy).to_f)
    dxf = ((dx).to_f)
    return sqrtApprox(_add(dyf * dyf, dxf * dxf))
  end
  def pos_equal(a, b)
    return _eq(a.y, b.y) && _eq(a.x, b.x)
  end
  def contains_pos(lst, p)
    i = 0
    while i < _len(lst)
      if pos_equal((__tmp1 = lst; __tmp1.is_a?(Hash) ? __tmp1[i] : _idx(__tmp1, i)), p)
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def open_index_of_pos(open, p)
    i = 0
    while i < _len(open)
      if pos_equal((__tmp2 = open; __tmp2.is_a?(Hash) ? __tmp2[i] : _idx(__tmp2, i)).pos, p)
        return i
      end
      i = _add(i, 1)
    end
    return 0 - 1
  end
  def remove_node_at(nodes, idx)
    res = []
    i = 0
    while i < _len(nodes)
      if !_eq(i, idx)
        res = (res + [(__tmp3 = nodes; __tmp3.is_a?(Hash) ? __tmp3[i] : _idx(__tmp3, i))])
      end
      i = _add(i, 1)
    end
    return res
  end
  def append_pos_list(path, p)
    res = []
    i = 0
    while i < _len(path)
      res = (res + [(__tmp4 = path; __tmp4.is_a?(Hash) ? __tmp4[i] : _idx(__tmp4, i))])
      i = _add(i, 1)
    end
    res = (res + [p])
    return res
  end
  def reverse_pos_list(lst)
    res = []
    i = _len(lst) - 1
    while i >= 0
      res = (res + [(__tmp5 = lst; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i))])
      i = i - 1
    end
    return res
  end
  def concat_pos_lists(a, b)
    res = []
    i = 0
    while i < _len(a)
      res = (res + [(__tmp6 = a; __tmp6.is_a?(Hash) ? __tmp6[i] : _idx(__tmp6, i))])
      i = _add(i, 1)
    end
    j = 0
    while j < _len(b)
      res = (res + [(__tmp7 = b; __tmp7.is_a?(Hash) ? __tmp7[j] : _idx(__tmp7, j))])
      j = _add(j, 1)
    end
    return res
  end
  def get_successors(p)
    res = []
    i = 0
    while i < _len($delta)
      nx = _add(p.x, (__tmp8 = (__tmp9 = $delta; __tmp9.is_a?(Hash) ? __tmp9[i] : _idx(__tmp9, i)); __tmp8.is_a?(Hash) ? __tmp8[1] : _idx(__tmp8, 1)))
      ny = _add(p.y, (__tmp10 = (__tmp11 = $delta; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i)); __tmp10.is_a?(Hash) ? __tmp10[0] : _idx(__tmp10, 0)))
      if nx >= 0 && ny >= 0 && nx < _len((__tmp12 = $grid; __tmp12.is_a?(Hash) ? __tmp12[0] : _idx(__tmp12, 0))) && ny < _len($grid)
        if _eq((__tmp13 = (__tmp14 = $grid; __tmp14.is_a?(Hash) ? __tmp14[ny] : _idx(__tmp14, ny)); __tmp13.is_a?(Hash) ? __tmp13[nx] : _idx(__tmp13, nx)), 0)
          res = (res + [Pos.new(y: ny, x: nx)])
        end
      end
      i = _add(i, 1)
    end
    return res
  end
  def find_lowest_f(open)
    best = 0
    i = 1
    while i < _len(open)
      if (__tmp15 = open; __tmp15.is_a?(Hash) ? __tmp15[i] : _idx(__tmp15, i)).f_cost < (__tmp16 = open; __tmp16.is_a?(Hash) ? __tmp16[best] : _idx(__tmp16, best)).f_cost
        best = i
      end
      i = _add(i, 1)
    end
    return best
  end
  def astar(start, goal)
    h0 = heuristic(start, goal)
    open = [Node.new(pos: start, g_cost: 0, h_cost: h0, f_cost: h0, path: [start])]
    closed = []
    while _len(open) > 0
      idx = find_lowest_f(open)
      current = (__tmp17 = open; __tmp17.is_a?(Hash) ? __tmp17[idx] : _idx(__tmp17, idx))
      open = remove_node_at(open, idx)
      if pos_equal(current.pos, goal)
        return current.path
      end
      closed = (closed + [current.pos])
      succ = get_successors(current.pos)
      i = 0
      while i < _len(succ)
        pos = (__tmp18 = succ; __tmp18.is_a?(Hash) ? __tmp18[i] : _idx(__tmp18, i))
        if contains_pos(closed, pos)
          i = _add(i, 1)
          next
        end
        tentative_g = _add(current.g_cost, 1)
        idx_open = open_index_of_pos(open, pos)
        if _eq(idx_open, 0 - 1) || tentative_g < (__tmp19 = open; __tmp19.is_a?(Hash) ? __tmp19[idx_open] : _idx(__tmp19, idx_open)).g_cost
          new_path = append_pos_list(current.path, pos)
          h = heuristic(pos, goal)
          f = _add(((tentative_g).to_f), h)
          if !_eq(idx_open, 0 - 1)
            open = remove_node_at(open, idx_open)
          end
          open = (open + [Node.new(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)])
        end
        i = _add(i, 1)
      end
    end
    return [start]
  end
  def combine_paths(fwd, bwd)
    bwd_copy = []
    i = 0
    while i < _len(bwd.path) - 1
      bwd_copy = (bwd_copy + [(__tmp20 = bwd.path; __tmp20.is_a?(Hash) ? __tmp20[i] : _idx(__tmp20, i))])
      i = _add(i, 1)
    end
    bwd_copy = reverse_pos_list(bwd_copy)
    return concat_pos_lists(fwd.path, bwd_copy)
  end
  def bidirectional_astar(start, goal)
    hf = heuristic(start, goal)
    hb = heuristic(goal, start)
    open_f = [Node.new(pos: start, g_cost: 0, h_cost: hf, f_cost: hf, path: [start])]
    open_b = [Node.new(pos: goal, g_cost: 0, h_cost: hb, f_cost: hb, path: [goal])]
    closed_f = []
    closed_b = []
    while _len(open_f) > 0 && _len(open_b) > 0
      idx_f = find_lowest_f(open_f)
      current_f = (__tmp21 = open_f; __tmp21.is_a?(Hash) ? __tmp21[idx_f] : _idx(__tmp21, idx_f))
      open_f = remove_node_at(open_f, idx_f)
      idx_b = find_lowest_f(open_b)
      current_b = (__tmp22 = open_b; __tmp22.is_a?(Hash) ? __tmp22[idx_b] : _idx(__tmp22, idx_b))
      open_b = remove_node_at(open_b, idx_b)
      if pos_equal(current_f.pos, current_b.pos)
        return combine_paths(current_f, current_b)
      end
      closed_f = (closed_f + [current_f.pos])
      closed_b = (closed_b + [current_b.pos])
      succ_f = get_successors(current_f.pos)
      i = 0
      while i < _len(succ_f)
        pos = (__tmp23 = succ_f; __tmp23.is_a?(Hash) ? __tmp23[i] : _idx(__tmp23, i))
        if contains_pos(closed_f, pos)
          i = _add(i, 1)
          next
        end
        tentative_g = _add(current_f.g_cost, 1)
        h = heuristic(pos, current_b.pos)
        f = _add(((tentative_g).to_f), h)
        idx_open = open_index_of_pos(open_f, pos)
        if _eq(idx_open, 0 - 1) || tentative_g < (__tmp24 = open_f; __tmp24.is_a?(Hash) ? __tmp24[idx_open] : _idx(__tmp24, idx_open)).g_cost
          new_path = append_pos_list(current_f.path, pos)
          if !_eq(idx_open, 0 - 1)
            open_f = remove_node_at(open_f, idx_open)
          end
          open_f = (open_f + [Node.new(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)])
        end
        i = _add(i, 1)
      end
      succ_b = get_successors(current_b.pos)
      i = 0
      while i < _len(succ_b)
        pos = (__tmp25 = succ_b; __tmp25.is_a?(Hash) ? __tmp25[i] : _idx(__tmp25, i))
        if contains_pos(closed_b, pos)
          i = _add(i, 1)
          next
        end
        tentative_g = _add(current_b.g_cost, 1)
        h = heuristic(pos, current_f.pos)
        f = _add(((tentative_g).to_f), h)
        idx_open = open_index_of_pos(open_b, pos)
        if _eq(idx_open, 0 - 1) || tentative_g < (__tmp26 = open_b; __tmp26.is_a?(Hash) ? __tmp26[idx_open] : _idx(__tmp26, idx_open)).g_cost
          new_path = append_pos_list(current_b.path, pos)
          if !_eq(idx_open, 0 - 1)
            open_b = remove_node_at(open_b, idx_open)
          end
          open_b = (open_b + [Node.new(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)])
        end
        i = _add(i, 1)
      end
    end
    return [start]
  end
  def path_to_string(path)
    if _eq(_len(path), 0)
      return "[]"
    end
    s = _add(_add(_add(_add("[(", _str((__tmp27 = path; __tmp27.is_a?(Hash) ? __tmp27[0] : _idx(__tmp27, 0)).y)), ", "), _str((__tmp28 = path; __tmp28.is_a?(Hash) ? __tmp28[0] : _idx(__tmp28, 0)).x)), ")")
    i = 1
    while i < _len(path)
      s = _add(_add(_add(_add(_add(s, ", ("), _str((__tmp29 = path; __tmp29.is_a?(Hash) ? __tmp29[i] : _idx(__tmp29, i)).y)), ", "), _str((__tmp30 = path; __tmp30.is_a?(Hash) ? __tmp30[i] : _idx(__tmp30, i)).x)), ")")
      i = _add(i, 1)
    end
    s = _add(s, "]")
    return s
  end
  $HEURISTIC = 0
  $grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]
  $delta = [[-1, 0], [0, -1], [1, 0], [0, 1]]
  Object.send(:remove_const, :Pos) if Object.const_defined?(:Pos)
  Pos = Struct.new(:y, :x, keyword_init: true)
  Object.send(:remove_const, :Node) if Object.const_defined?(:Node)
  Node = Struct.new(:pos, :g_cost, :h_cost, :f_cost, :path, keyword_init: true)
  $start = Pos.new(y: 0, x: 0)
  $goal = Pos.new(y: _len($grid) - 1, x: _len((__tmp31 = $grid; __tmp31.is_a?(Hash) ? __tmp31[0] : _idx(__tmp31, 0))) - 1)
  $path1 = astar($start, $goal)
  puts(path_to_string($path1))
  $path2 = bidirectional_astar($start, $goal)
  puts(path_to_string($path2))
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
