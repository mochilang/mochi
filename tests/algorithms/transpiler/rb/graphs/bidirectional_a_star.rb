# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def abs(x)
    if x < 0
      return -x
    end
    return x
  end
  def sqrtApprox(x)
    if x <= 0.0
      return 0.0
    end
    guess = x
    i = 0
    while i < 10
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def heuristic(a, b)
    dy = a.y - b.y
    dx = a.x - b.x
    if $HEURISTIC == 1
      return ((_add(abs(dy), abs(dx)))).to_f
    end
    dyf = ((dy).to_f)
    dxf = ((dx).to_f)
    return sqrtApprox(_add(dyf * dyf, dxf * dxf))
  end
  def pos_equal(a, b)
    return a.y == b.y && a.x == b.x
  end
  def contains_pos(lst, p)
    i = 0
    while i < lst.length
      if pos_equal(lst[i], p)
        return true
      end
      i = _add(i, 1)
    end
    return false
  end
  def open_index_of_pos(open, p)
    i = 0
    while i < open.length
      if pos_equal(open[i].pos, p)
        return i
      end
      i = _add(i, 1)
    end
    return 0 - 1
  end
  def remove_node_at(nodes, idx)
    res = []
    i = 0
    while i < nodes.length
      if i != idx
        res = (res << (nodes[i]))
      end
      i = _add(i, 1)
    end
    return res
  end
  def append_pos_list(path, p)
    res = []
    i = 0
    while i < path.length
      res = (res << (path[i]))
      i = _add(i, 1)
    end
    res = (res << (p))
    return res
  end
  def reverse_pos_list(lst)
    res = []
    i = lst.length - 1
    while i >= 0
      res = (res << (lst[i]))
      i = i - 1
    end
    return res
  end
  def concat_pos_lists(a, b)
    res = []
    i = 0
    while i < a.length
      res = (res << (a[i]))
      i = _add(i, 1)
    end
    j = 0
    while j < b.length
      res = (res << (b[j]))
      j = _add(j, 1)
    end
    return res
  end
  def get_successors(p)
    res = []
    i = 0
    while i < $delta.length
      nx = _add(p.x, $delta[i][1])
      ny = _add(p.y, $delta[i][0])
      if nx >= 0 && ny >= 0 && nx < $grid[0].length && ny < $grid.length
        if $grid[ny][nx] == 0
          res = (res << (Pos.new(y: ny, x: nx)))
        end
      end
      i = _add(i, 1)
    end
    return res
  end
  def find_lowest_f(open)
    best = 0
    i = 1
    while i < open.length
      if open[i].f_cost < open[best].f_cost
        best = i
      end
      i = _add(i, 1)
    end
    return best
  end
  def astar(start, goal)
    h0 = heuristic(start, goal)
    open = [Node.new(pos: start, g_cost: 0, h_cost: h0, f_cost: h0, path: [start])]
    closed = []
    while open.length > 0
      idx = find_lowest_f(open)
      current = open[idx]
      open = remove_node_at(open, idx)
      if pos_equal(current.pos, goal)
        return current.path
      end
      closed = (closed << (current.pos))
      succ = get_successors(current.pos)
      i = 0
      while i < succ.length
        pos = succ[i]
        if contains_pos(closed, pos)
          i = _add(i, 1)
          next
        end
        tentative_g = _add(current.g_cost, 1)
        idx_open = open_index_of_pos(open, pos)
        if idx_open == 0 - 1 || tentative_g < open[idx_open].g_cost
          new_path = append_pos_list(current.path, pos)
          h = heuristic(pos, goal)
          f = _add(((tentative_g).to_f), h)
          if idx_open != 0 - 1
            open = remove_node_at(open, idx_open)
          end
          open = (open << (Node.new(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)))
        end
        i = _add(i, 1)
      end
    end
    return [start]
  end
  def combine_paths(fwd, bwd)
    bwd_copy = []
    i = 0
    while i < bwd.path.length - 1
      bwd_copy = (bwd_copy << (bwd.path[i]))
      i = _add(i, 1)
    end
    bwd_copy = reverse_pos_list(bwd_copy)
    return concat_pos_lists(fwd.path, bwd_copy)
  end
  def bidirectional_astar(start, goal)
    hf = heuristic(start, goal)
    hb = heuristic(goal, start)
    open_f = [Node.new(pos: start, g_cost: 0, h_cost: hf, f_cost: hf, path: [start])]
    open_b = [Node.new(pos: goal, g_cost: 0, h_cost: hb, f_cost: hb, path: [goal])]
    closed_f = []
    closed_b = []
    while open_f.length > 0 && open_b.length > 0
      idx_f = find_lowest_f(open_f)
      current_f = open_f[idx_f]
      open_f = remove_node_at(open_f, idx_f)
      idx_b = find_lowest_f(open_b)
      current_b = open_b[idx_b]
      open_b = remove_node_at(open_b, idx_b)
      if pos_equal(current_f.pos, current_b.pos)
        return combine_paths(current_f, current_b)
      end
      closed_f = (closed_f << (current_f.pos))
      closed_b = (closed_b << (current_b.pos))
      succ_f = get_successors(current_f.pos)
      i = 0
      while i < succ_f.length
        pos = succ_f[i]
        if contains_pos(closed_f, pos)
          i = _add(i, 1)
          next
        end
        tentative_g = _add(current_f.g_cost, 1)
        h = heuristic(pos, current_b.pos)
        f = _add(((tentative_g).to_f), h)
        idx_open = open_index_of_pos(open_f, pos)
        if idx_open == 0 - 1 || tentative_g < open_f[idx_open].g_cost
          new_path = append_pos_list(current_f.path, pos)
          if idx_open != 0 - 1
            open_f = remove_node_at(open_f, idx_open)
          end
          open_f = (open_f << (Node.new(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)))
        end
        i = _add(i, 1)
      end
      succ_b = get_successors(current_b.pos)
      i = 0
      while i < succ_b.length
        pos = succ_b[i]
        if contains_pos(closed_b, pos)
          i = _add(i, 1)
          next
        end
        tentative_g = _add(current_b.g_cost, 1)
        h = heuristic(pos, current_f.pos)
        f = _add(((tentative_g).to_f), h)
        idx_open = open_index_of_pos(open_b, pos)
        if idx_open == 0 - 1 || tentative_g < open_b[idx_open].g_cost
          new_path = append_pos_list(current_b.path, pos)
          if idx_open != 0 - 1
            open_b = remove_node_at(open_b, idx_open)
          end
          open_b = (open_b << (Node.new(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)))
        end
        i = _add(i, 1)
      end
    end
    return [start]
  end
  def path_to_string(path)
    if path.length == 0
      return "[]"
    end
    s = _add(_add(_add(_add("[(", _str(path[0].y)), ", "), _str(path[0].x)), ")")
    i = 1
    while i < path.length
      s = _add(_add(_add(_add(_add(s, ", ("), _str(path[i].y)), ", "), _str(path[i].x)), ")")
      i = _add(i, 1)
    end
    s = _add(s, "]")
    return s
  end
  $HEURISTIC = 0
  $grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]
  $delta = [[-1, 0], [0, -1], [1, 0], [0, 1]]
  Pos = Struct.new(:y, :x, keyword_init: true)
  Node = Struct.new(:pos, :g_cost, :h_cost, :f_cost, :path, keyword_init: true)
  $start = Pos.new(y: 0, x: 0)
  $goal = Pos.new(y: $grid.length - 1, x: $grid[0].length - 1)
  $path1 = astar($start, $goal)
  puts(path_to_string($path1))
  $path2 = bidirectional_astar($start, $goal)
  puts(path_to_string($path2))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
