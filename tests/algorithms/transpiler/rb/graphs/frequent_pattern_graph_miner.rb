# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def contains(lst, item)
        __tmp1 = lst
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |v|
      if v == item
        return true
      end
    end
    return false
  end
  def get_distinct_edge(edge_array)
    distinct = [].clone
        __tmp2 = edge_array
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |row|
            __tmp3 = row
      if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
        __tmp3 = __tmp3.keys
      end
      __tmp3.each do |item|
        e = item[0]
        if !distinct.include?(e)
          distinct = (distinct << (e)).clone
        end
      end
    end
    return distinct
  end
  def get_bitcode(edge_array, de)
    bitcode = "".clone
    i = 0.clone
    while i < edge_array.length
      found = false.clone
            __tmp4 = edge_array[i]
      if __tmp4.respond_to?(:keys) && !__tmp4.is_a?(String)
        __tmp4 = __tmp4.keys
      end
      __tmp4.each do |item|
        if item[0] == de
          found = true.clone
          break
        end
      end
      if found
        bitcode = _add(bitcode, "1").clone
      else
        bitcode = _add(bitcode, "0").clone
      end
      i = _add(i, 1).clone
    end
    return bitcode
  end
  def count_ones(s)
    c = 0.clone
    i = 0.clone
    while i < s.length
      if s[i..._add(i, 1)] == "1"
        c = _add(c, 1).clone
      end
      i = _add(i, 1).clone
    end
    return c
  end
  def get_frequency_table(edge_array)
    distinct = get_distinct_edge(edge_array)
    table = [].clone
        __tmp5 = distinct
    if __tmp5.respond_to?(:keys) && !__tmp5.is_a?(String)
      __tmp5 = __tmp5.keys
    end
    __tmp5.each do |e|
      bit = get_bitcode(edge_array, e)
      cnt = count_ones(bit)
      entry = {"edge" => e, "count" => _str(cnt), "bit" => bit}.clone
      table = (table << (entry)).clone
    end
    i = 0.clone
    while i < table.length
      max_i = i.clone
      j = _add(i, 1).clone
      while j < table.length
        if (table[j]["count"]).to_i > (table[max_i]["count"]).to_i
          max_i = j.clone
        end
        j = _add(j, 1).clone
      end
      tmp = table[i]
      table[i] = table[max_i]
      table[max_i] = tmp
      i = _add(i, 1).clone
    end
    return table
  end
  def get_nodes(freq_table)
    nodes = {}.clone
    keys = [].clone
        __tmp6 = freq_table
    if __tmp6.respond_to?(:keys) && !__tmp6.is_a?(String)
      __tmp6 = __tmp6.keys
    end
    __tmp6.each do |f|
      code = f["bit"]
      edge = f["edge"]
      if nodes.key?(code)
        nodes[code] = (nodes[code] << (edge))
      else
        nodes[code] = [edge]
        keys = (keys << (code)).clone
      end
    end
    return NodesData.new(map: nodes, keys: keys)
  end
  def get_cluster(nodes)
    clusters = {}.clone
    weights = [].clone
    i = 0.clone
    while i < nodes.keys.length
      code = nodes.keys[i]
      wt = count_ones(code)
      if clusters.key?(wt)
        clusters[wt] = (clusters[wt] << (code))
      else
        clusters[wt] = [code]
        weights = (weights << (wt)).clone
      end
      i = _add(i, 1).clone
    end
    return ClusterData.new(clusters: clusters, weights: weights)
  end
  def get_support(clusters)
    sup = [].clone
    i = 0.clone
    while i < clusters.weights.length
      w = clusters.weights[i]
      sup = (sup << (w * 100 / clusters.weights.length)).clone
      i = _add(i, 1).clone
    end
    return sup
  end
  def contains_bits(a, b)
    i = 0.clone
    while i < a.length
      c1 = a[i..._add(i, 1)]
      c2 = b[i..._add(i, 1)]
      if c1 == "1" && c2 != "1"
        return false
      end
      i = _add(i, 1).clone
    end
    return true
  end
  def max_cluster_key(clusters)
    m = 0.clone
    i = 0.clone
    while i < clusters.weights.length
      w = clusters.weights[i]
      if w > m
        m = w.clone
      end
      i = _add(i, 1).clone
    end
    return m
  end
  def get_cluster_codes(clusters, wt)
    if clusters.clusters.key?(wt)
      return clusters.clusters[wt]
    end
    return []
  end
  def create_edge(nodes, graph, gkeys, clusters, c1, maxk)
    keys = gkeys.clone
    codes1 = get_cluster_codes(clusters, c1)
    idx1 = 0.clone
    while idx1 < codes1.length
      i_code = codes1[idx1]
      count = 0.clone
      c2 = _add(c1, 1).clone
      while c2 <= maxk
        codes2 = get_cluster_codes(clusters, c2)
        j = 0.clone
        while j < codes2.length
          j_code = codes2[j]
          if contains_bits(i_code, j_code)
            if graph.key?(i_code)
              graph[i_code] = (graph[i_code] << (j_code))
            else
              graph[i_code] = [j_code]
              if !keys.include?(i_code)
                keys = (keys << (i_code)).clone
              end
            end
            if !keys.include?(j_code)
              keys = (keys << (j_code)).clone
            end
            count = _add(count, 1).clone
          end
          j = _add(j, 1).clone
        end
        if count == 0
          c2 = _add(c2, 1).clone
        else
          break
        end
      end
      idx1 = _add(idx1, 1).clone
    end
    return keys
  end
  def construct_graph(clusters, nodes)
    maxk = max_cluster_key(clusters)
    top_codes = get_cluster_codes(clusters, maxk)
    graph = {}.clone
    keys = ["Header"].clone
    graph["Header"] = []
    i = 0.clone
    while i < top_codes.length
      code = top_codes[i]
      graph["Header"] = (graph["Header"] << (code))
      graph[code] = ["Header"]
      keys = (keys << (code)).clone
      i = _add(i, 1).clone
    end
    c = 1.clone
    while c < maxk
      keys = create_edge(nodes, graph, keys, clusters, c, maxk).clone
      c = _add(c, 1).clone
    end
    return GraphData.new(edges: graph, keys: keys)
  end
  def copy_list(lst)
    n = [].clone
        __tmp7 = lst
    if __tmp7.respond_to?(:keys) && !__tmp7.is_a?(String)
      __tmp7 = __tmp7.keys
    end
    __tmp7.each do |v|
      n = (n << (v)).clone
    end
    return n
  end
  def my_dfs(graph, start, end_, path)
    new_path = copy_list(path).clone
    new_path = (new_path << (start)).clone
    if start == end_
      $paths = ($paths << (new_path)).clone
      return
    end
        __tmp8 = graph[start]
    if __tmp8.respond_to?(:keys) && !__tmp8.is_a?(String)
      __tmp8 = __tmp8.keys
    end
    __tmp8.each do |node|
      seen = false.clone
            __tmp9 = new_path
      if __tmp9.respond_to?(:keys) && !__tmp9.is_a?(String)
        __tmp9 = __tmp9.keys
      end
      __tmp9.each do |p|
        if p == node
          seen = true.clone
        end
      end
      if !seen
        my_dfs(graph, node, end_, new_path)
      end
    end
  end
  def find_freq_subgraph_given_support(s, clusters, graph)
    k = s * clusters.weights.length / 100
    codes = get_cluster_codes(clusters, k)
    i = 0.clone
    while i < codes.length
      my_dfs(graph.edges, codes[i], "Header", [])
      i = _add(i, 1).clone
    end
  end
  def node_edges(nodes, code)
    return nodes.map[code]
  end
  def freq_subgraphs_edge_list(paths, nodes)
    freq_sub_el = [].clone
        __tmp10 = paths
    if __tmp10.respond_to?(:keys) && !__tmp10.is_a?(String)
      __tmp10 = __tmp10.keys
    end
    __tmp10.each do |path|
      el = [].clone
      j = 0.clone
      while j < path.length - 1
        code = path[j]
        edge_list = node_edges(nodes, code)
        e = 0.clone
        while e < edge_list.length
          edge = edge_list[e]
          a = edge[0...1]
          b = edge[1...2]
          el = (el << ([a, b])).clone
          e = _add(e, 1).clone
        end
        j = _add(j, 1).clone
      end
      freq_sub_el = (freq_sub_el << (el)).clone
    end
    return freq_sub_el
  end
  def print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
    puts("\nNodes\n")
    i = 0.clone
    while i < nodes.keys.length
      code = nodes.keys[i]
      puts(code)
      puts(((x = nodes.map[code]); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
      i = _add(i, 1).clone
    end
    puts("\nSupport\n")
    puts(((x = support); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
    puts("\nCluster\n")
    j = 0.clone
    while j < clusters.weights.length
      w = clusters.weights[j]
      puts(_add(_add(_str(w), ":"), ((x = clusters.clusters[w]); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
      j = _add(j, 1).clone
    end
    puts("\nGraph\n")
    k = 0.clone
    while k < graph.keys.length
      key = graph.keys[k]
      puts(key)
      puts(((x = graph.edges[key]); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
      k = _add(k, 1).clone
    end
    puts("\nEdge List of Frequent subgraphs\n")
        __tmp11 = freq_subgraph_edge_list
    if __tmp11.respond_to?(:keys) && !__tmp11.is_a?(String)
      __tmp11 = __tmp11.keys
    end
    __tmp11.each do |el|
      puts(((x = el); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
    end
  end
  def main()
    frequency_table = get_frequency_table($EDGE_ARRAY)
    nodes = get_nodes(frequency_table)
    clusters = get_cluster(nodes)
    support = get_support(clusters)
    graph = construct_graph(clusters, nodes)
    find_freq_subgraph_given_support(60, clusters, graph)
    freq_subgraph_edge_list = freq_subgraphs_edge_list($paths, nodes)
    print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
  end
  $EDGE_ARRAY = [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]]
  NodesData = Struct.new(:map, :keys, keyword_init: true)
  ClusterData = Struct.new(:clusters, :weights, keyword_init: true)
  GraphData = Struct.new(:edges, :keys, keyword_init: true)
  $paths = [].clone
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
