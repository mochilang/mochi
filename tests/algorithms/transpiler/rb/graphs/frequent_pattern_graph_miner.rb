# Generated by Mochi transpiler v0.10.66 on 2025-08-15 09:59 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  x = x.clone if x.is_a?(Array)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def contains(lst, item)
        __tmp1 = lst
    __tmp1 = [] if __tmp1.nil?
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |v|
      if _eq(v, item)
        return true
      end
    end
    return false
  end
  def get_distinct_edge(edge_array)
    distinct = []
        __tmp2 = edge_array
    __tmp2 = [] if __tmp2.nil?
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |row|
            __tmp3 = row
      __tmp3 = [] if __tmp3.nil?
      if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
        __tmp3 = __tmp3.keys
      end
      __tmp3.each do |item|
        e = (__tmp4 = item; __tmp4.is_a?(Hash) ? __tmp4[0] : _idx(__tmp4, 0))
        if !contains(distinct, e)
          distinct = _append(distinct, e)
        end
      end
    end
    return distinct
  end
  def get_bitcode(edge_array, de)
    bitcode = ""
    i = 0
    while i < _len(edge_array)
      found = false
            __tmp5 = (__tmp6 = edge_array; __tmp6.is_a?(Hash) ? __tmp6[i] : _idx(__tmp6, i))
      __tmp5 = [] if __tmp5.nil?
      if __tmp5.respond_to?(:keys) && !__tmp5.is_a?(String)
        __tmp5 = __tmp5.keys
      end
      __tmp5.each do |item|
        if _eq((__tmp7 = item; __tmp7.is_a?(Hash) ? __tmp7[0] : _idx(__tmp7, 0)), de)
          found = true
          break
        end
      end
      if found
        bitcode = _add(bitcode, "1")
      else
        bitcode = _add(bitcode, "0")
      end
      i = _add(i, 1)
    end
    return bitcode
  end
  def count_ones(s)
    c = 0
    i = 0
    while i < _len(s)
      if _eq(s[i..._add(i, 1)], "1")
        c = _add(c, 1)
      end
      i = _add(i, 1)
    end
    return c
  end
  def get_frequency_table(edge_array)
    distinct = get_distinct_edge(edge_array)
    table = []
        __tmp8 = distinct
    __tmp8 = [] if __tmp8.nil?
    if __tmp8.respond_to?(:keys) && !__tmp8.is_a?(String)
      __tmp8 = __tmp8.keys
    end
    __tmp8.each do |e|
      bit = get_bitcode(edge_array, e)
      cnt = count_ones(bit)
      entry = {"edge" => e, "count" => _str(cnt), "bit" => bit}
      table = _append(table, entry)
    end
    i = 0
    while i < _len(table)
      max_i = i
      j = _add(i, 1)
      while j < _len(table)
        if ((__tmp9 = (__tmp10 = table; __tmp10.is_a?(Hash) ? __tmp10[j] : _idx(__tmp10, j)); __tmp9.is_a?(Hash) ? __tmp9["count"] : _idx(__tmp9, "count"))).to_i > ((__tmp11 = (__tmp12 = table; __tmp12.is_a?(Hash) ? __tmp12[max_i] : _idx(__tmp12, max_i)); __tmp11.is_a?(Hash) ? __tmp11["count"] : _idx(__tmp11, "count"))).to_i
          max_i = j
        end
        j = _add(j, 1)
      end
      tmp = (__tmp13 = table; __tmp13.is_a?(Hash) ? __tmp13[i] : _idx(__tmp13, i))
      table[i] = (__tmp14 = table; __tmp14.is_a?(Hash) ? __tmp14[max_i] : _idx(__tmp14, max_i))
      table[max_i] = tmp
      i = _add(i, 1)
    end
    return table
  end
  def get_nodes(freq_table)
    nodes = {}
    keys = []
        __tmp15 = freq_table
    __tmp15 = [] if __tmp15.nil?
    if __tmp15.respond_to?(:keys) && !__tmp15.is_a?(String)
      __tmp15 = __tmp15.keys
    end
    __tmp15.each do |f|
      code = (__tmp16 = f; __tmp16.is_a?(Hash) ? __tmp16["bit"] : _idx(__tmp16, "bit"))
      edge = (__tmp17 = f; __tmp17.is_a?(Hash) ? __tmp17["edge"] : _idx(__tmp17, "edge"))
      if _has(nodes, code)
        nodes[code] = _append((__tmp18 = nodes; __tmp18.is_a?(Hash) ? __tmp18[code] : _idx(__tmp18, code)), edge)
      else
        nodes[code] = [edge]
        keys = _append(keys, code)
      end
    end
    return NodesData.new(map: nodes, keys: keys)
  end
  def get_cluster(nodes)
    clusters = {}
    weights = []
    i = 0
    while i < _len(nodes.keys)
      code = (__tmp19 = nodes.keys; __tmp19.is_a?(Hash) ? __tmp19[i] : _idx(__tmp19, i))
      wt = count_ones(code)
      if _has(clusters, wt)
        clusters[wt] = _append((__tmp20 = clusters; __tmp20.is_a?(Hash) ? __tmp20[wt] : _idx(__tmp20, wt)), code)
      else
        clusters[wt] = [code]
        weights = _append(weights, wt)
      end
      i = _add(i, 1)
    end
    return ClusterData.new(clusters: clusters, weights: weights)
  end
  def get_support(clusters)
    sup = []
    i = 0
    while i < _len(clusters.weights)
      w = (__tmp21 = clusters.weights; __tmp21.is_a?(Hash) ? __tmp21[i] : _idx(__tmp21, i))
      sup = _append(sup, w * 100 / _len(clusters.weights))
      i = _add(i, 1)
    end
    return sup
  end
  def contains_bits(a, b)
    i = 0
    while i < _len(a)
      c1 = a[i..._add(i, 1)]
      c2 = b[i..._add(i, 1)]
      if _eq(c1, "1") && !_eq(c2, "1")
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def max_cluster_key(clusters)
    m = 0
    i = 0
    while i < _len(clusters.weights)
      w = (__tmp22 = clusters.weights; __tmp22.is_a?(Hash) ? __tmp22[i] : _idx(__tmp22, i))
      if w > m
        m = w
      end
      i = _add(i, 1)
    end
    return m
  end
  def get_cluster_codes(clusters, wt)
    if _has(clusters.clusters, wt)
      return (__tmp23 = clusters.clusters; __tmp23.is_a?(Hash) ? __tmp23[wt] : _idx(__tmp23, wt))
    end
    return []
  end
  def create_edge(nodes, graph, gkeys, clusters, c1, maxk)
    keys = gkeys
    codes1 = get_cluster_codes(clusters, c1)
    idx1 = 0
    while idx1 < _len(codes1)
      i_code = (__tmp24 = codes1; __tmp24.is_a?(Hash) ? __tmp24[idx1] : _idx(__tmp24, idx1))
      count = 0
      c2 = _add(c1, 1)
      while c2 <= maxk
        codes2 = get_cluster_codes(clusters, c2)
        j = 0
        while j < _len(codes2)
          j_code = (__tmp25 = codes2; __tmp25.is_a?(Hash) ? __tmp25[j] : _idx(__tmp25, j))
          if contains_bits(i_code, j_code)
            if _has(graph, i_code)
              graph[i_code] = _append((__tmp26 = graph; __tmp26.is_a?(Hash) ? __tmp26[i_code] : _idx(__tmp26, i_code)), j_code)
            else
              graph[i_code] = [j_code]
              if !contains(keys, i_code)
                keys = _append(keys, i_code)
              end
            end
            if !contains(keys, j_code)
              keys = _append(keys, j_code)
            end
            count = _add(count, 1)
          end
          j = _add(j, 1)
        end
        if _eq(count, 0)
          c2 = _add(c2, 1)
        else
          break
        end
      end
      idx1 = _add(idx1, 1)
    end
    return keys
  end
  def construct_graph(clusters, nodes)
    maxk = max_cluster_key(clusters)
    top_codes = get_cluster_codes(clusters, maxk)
    graph = {}
    keys = ["Header"]
    graph["Header"] = []
    i = 0
    while i < _len(top_codes)
      code = (__tmp27 = top_codes; __tmp27.is_a?(Hash) ? __tmp27[i] : _idx(__tmp27, i))
      graph["Header"] = _append((__tmp28 = graph; __tmp28.is_a?(Hash) ? __tmp28["Header"] : _idx(__tmp28, "Header")), code)
      graph[code] = ["Header"]
      keys = _append(keys, code)
      i = _add(i, 1)
    end
    c = 1
    while c < maxk
      keys = create_edge(nodes, graph, keys, clusters, c, maxk)
      c = _add(c, 1)
    end
    return GraphData.new(edges: graph, keys: keys)
  end
  def copy_list(lst)
    n = []
        __tmp29 = lst
    __tmp29 = [] if __tmp29.nil?
    if __tmp29.respond_to?(:keys) && !__tmp29.is_a?(String)
      __tmp29 = __tmp29.keys
    end
    __tmp29.each do |v|
      n = _append(n, v)
    end
    return n
  end
  def my_dfs(graph, start, end_, path)
    new_path = copy_list(path)
    new_path = _append(new_path, start)
    if _eq(start, end_)
      $paths = _append($paths, new_path)
      return
    end
        __tmp30 = (__tmp31 = graph; __tmp31.is_a?(Hash) ? __tmp31[start] : _idx(__tmp31, start))
    __tmp30 = [] if __tmp30.nil?
    if __tmp30.respond_to?(:keys) && !__tmp30.is_a?(String)
      __tmp30 = __tmp30.keys
    end
    __tmp30.each do |node|
      seen = false
            __tmp32 = new_path
      __tmp32 = [] if __tmp32.nil?
      if __tmp32.respond_to?(:keys) && !__tmp32.is_a?(String)
        __tmp32 = __tmp32.keys
      end
      __tmp32.each do |p|
        if _eq(p, node)
          seen = true
        end
      end
      if !seen
        my_dfs(graph, node, end_, new_path)
      end
    end
  end
  def find_freq_subgraph_given_support(s, clusters, graph)
    k = s * _len(clusters.weights) / 100
    codes = get_cluster_codes(clusters, k)
    i = 0
    while i < _len(codes)
      my_dfs(graph.edges, (__tmp33 = codes; __tmp33.is_a?(Hash) ? __tmp33[i] : _idx(__tmp33, i)), "Header", [])
      i = _add(i, 1)
    end
  end
  def node_edges(nodes, code)
    return (__tmp34 = nodes.map; __tmp34.is_a?(Hash) ? __tmp34[code] : _idx(__tmp34, code))
  end
  def freq_subgraphs_edge_list(paths, nodes)
    freq_sub_el = []
        __tmp35 = paths
    __tmp35 = [] if __tmp35.nil?
    if __tmp35.respond_to?(:keys) && !__tmp35.is_a?(String)
      __tmp35 = __tmp35.keys
    end
    __tmp35.each do |path|
      el = []
      j = 0
      while j < _len(path) - 1
        code = (__tmp36 = path; __tmp36.is_a?(Hash) ? __tmp36[j] : _idx(__tmp36, j))
        edge_list = node_edges(nodes, code)
        e = 0
        while e < _len(edge_list)
          edge = (__tmp37 = edge_list; __tmp37.is_a?(Hash) ? __tmp37[e] : _idx(__tmp37, e))
          a = edge[0...1]
          b = edge[1...2]
          el = _append(el, [a, b])
          e = _add(e, 1)
        end
        j = _add(j, 1)
      end
      freq_sub_el = _append(freq_sub_el, el)
    end
    return freq_sub_el
  end
  def print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
    puts("\nNodes\n")
    i = 0
    while i < _len(nodes.keys)
      code = (__tmp38 = nodes.keys; __tmp38.is_a?(Hash) ? __tmp38[i] : _idx(__tmp38, i))
      puts(code)
      puts(((x = (__tmp39 = nodes.map; __tmp39.is_a?(Hash) ? __tmp39[code] : _idx(__tmp39, code))); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
      i = _add(i, 1)
    end
    puts("\nSupport\n")
    puts(((x = support); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
    puts("\nCluster\n")
    j = 0
    while j < _len(clusters.weights)
      w = (__tmp40 = clusters.weights; __tmp40.is_a?(Hash) ? __tmp40[j] : _idx(__tmp40, j))
      puts(_add(_add(_str(w), ":"), ((x = (__tmp41 = clusters.clusters; __tmp41.is_a?(Hash) ? __tmp41[w] : _idx(__tmp41, w))); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
      j = _add(j, 1)
    end
    puts("\nGraph\n")
    k = 0
    while k < _len(graph.keys)
      key = (__tmp42 = graph.keys; __tmp42.is_a?(Hash) ? __tmp42[k] : _idx(__tmp42, k))
      puts(key)
      puts(((x = (__tmp43 = graph.edges; __tmp43.is_a?(Hash) ? __tmp43[key] : _idx(__tmp43, key))); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
      k = _add(k, 1)
    end
    puts("\nEdge List of Frequent subgraphs\n")
        __tmp44 = freq_subgraph_edge_list
    __tmp44 = [] if __tmp44.nil?
    if __tmp44.respond_to?(:keys) && !__tmp44.is_a?(String)
      __tmp44 = __tmp44.keys
    end
    __tmp44.each do |el|
      puts(((x = el); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
    end
  end
  def main()
    frequency_table = get_frequency_table($EDGE_ARRAY)
    nodes = get_nodes(frequency_table)
    clusters = get_cluster(nodes)
    support = get_support(clusters)
    graph = construct_graph(clusters, nodes)
    find_freq_subgraph_given_support(60, clusters, graph)
    freq_subgraph_edge_list = freq_subgraphs_edge_list($paths, nodes)
    print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
  end
  $EDGE_ARRAY = [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]]
  Object.send(:remove_const, :NodesData) if Object.const_defined?(:NodesData)
  Object.const_set(:NodesData, Struct.new(:map, :keys, keyword_init: true))
  Object.send(:remove_const, :ClusterData) if Object.const_defined?(:ClusterData)
  Object.const_set(:ClusterData, Struct.new(:clusters, :weights, keyword_init: true))
  Object.send(:remove_const, :GraphData) if Object.const_defined?(:GraphData)
  Object.const_set(:GraphData, Struct.new(:edges, :keys, keyword_init: true))
  $paths = []
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
