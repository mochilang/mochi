# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def dfs(g, s)
    visited = {}
    stack = []
    visited[s] = true
    stack = (stack << (s))
    puts(s)
    while stack.length > 0
      u = stack[stack.length - 1]
      found = false
            __tmp1 = g[u]
      if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
        __tmp1 = __tmp1.keys
      end
      __tmp1.each do |v|
        if !(visited.key?(v))
          visited[v] = true
          stack = (stack << (v))
          puts(v)
          found = true
          break
        end
      end
      if !found
        stack = stack[0...stack.length - 1]
      end
    end
  end
  def bfs(g, s)
    visited = {}
    q = []
    visited[s] = true
    q = (q << (s))
    puts(s)
    while q.length > 0
      u = q[0]
      q = q[1...q.length]
            __tmp2 = g[u]
      if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
        __tmp2 = __tmp2.keys
      end
      __tmp2.each do |v|
        if !(visited.key?(v))
          visited[v] = true
          q = (q << (v))
          puts(v)
        end
      end
    end
  end
  def sort_ints(a)
    arr = a
    i = 0
    while i < arr.length
      j = 0
      while j < arr.length - i - 1
        if arr[j] > arr[_add(j, 1)]
          tmp = arr[j]
          arr[j] = arr[_add(j, 1)]
          arr[_add(j, 1)] = tmp
        end
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    return arr
  end
  def dijkstra(g, s)
    dist = {}
    dist[s] = 0
    path = {}
    path[s] = 0
    known = []
    keys = [s]
    while known.length < keys.length
      mini = 100000
      u = -1
      i = 0
      while i < keys.length
        k = keys[i]
        d = dist[k]
        if !(known.include?(k)) && d < mini
          mini = d
          u = k
        end
        i = _add(i, 1)
      end
      known = (known << (u))
            __tmp3 = g[u]
      if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
        __tmp3 = __tmp3.keys
      end
      __tmp3.each do |e|
        v = e[0]
        w = e[1]
        if !(keys.include?(v))
          keys = (keys << (v))
        end
        alt = _add(dist[u], w)
        cur = (dist.key?(v) ? dist[v] : 100000)
        if !(known.include?(v)) && alt < cur
          dist[v] = alt
          path[v] = u
        end
      end
    end
    ordered = sort_ints(keys)
    idx = 0
    while idx < ordered.length
      k = ordered[idx]
      if k != s
        puts(dist[k])
      end
      idx = _add(idx, 1)
    end
  end
  def topo(g, n)
    ind = []
    i = 0
    while i <= n
      ind = (ind << (0))
      i = _add(i, 1)
    end
    node = 1
    while node <= n
            __tmp4 = g[node]
      if __tmp4.respond_to?(:keys) && !__tmp4.is_a?(String)
        __tmp4 = __tmp4.keys
      end
      __tmp4.each do |v|
        ind[v] = _add(ind[v], 1)
      end
      node = _add(node, 1)
    end
    q = []
    j = 1
    while j <= n
      if ind[j] == 0
        q = (q << (j))
      end
      j = _add(j, 1)
    end
    while q.length > 0
      v = q[0]
      q = q[1...q.length]
      puts(v)
            __tmp5 = g[v]
      if __tmp5.respond_to?(:keys) && !__tmp5.is_a?(String)
        __tmp5 = __tmp5.keys
      end
      __tmp5.each do |w|
        ind[w] = ind[w] - 1
        if ind[w] == 0
          q = (q << (w))
        end
      end
    end
  end
  def floyd(a)
    n = a.length
    dist = []
    i = 0
    while i < n
      row = []
      j = 0
      while j < n
        row = (row << (a[i][j]))
        j = _add(j, 1)
      end
      dist = (dist << (row))
      i = _add(i, 1)
    end
    k = 0
    while k < n
      ii = 0
      while ii < n
        jj = 0
        while jj < n
          if dist[ii][jj] > _add(dist[ii][k], dist[k][jj])
            dist[ii][jj] = _add(dist[ii][k], dist[k][jj])
          end
          jj = _add(jj, 1)
        end
        ii = _add(ii, 1)
      end
      k = _add(k, 1)
    end
    puts(((x = dist); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
  end
  def prim(g, s, n)
    dist = {}
    dist[s] = 0
    known = []
    keys = [s]
    total = 0
    while known.length < n
      mini = 100000
      u = -1
      i = 0
      while i < keys.length
        k = keys[i]
        d = dist[k]
        if !(known.include?(k)) && d < mini
          mini = d
          u = k
        end
        i = _add(i, 1)
      end
      known = (known << (u))
      total = _add(total, mini)
            __tmp6 = g[u]
      if __tmp6.respond_to?(:keys) && !__tmp6.is_a?(String)
        __tmp6 = __tmp6.keys
      end
      __tmp6.each do |e|
        v = e[0]
        w = e[1]
        if !(keys.include?(v))
          keys = (keys << (v))
        end
        cur = (dist.key?(v) ? dist[v] : 100000)
        if !(known.include?(v)) && w < cur
          dist[v] = w
        end
      end
    end
    return total
  end
  def sort_edges(edges)
    es = edges
    i = 0
    while i < es.length
      j = 0
      while j < es.length - i - 1
        if es[j][2] > es[_add(j, 1)][2]
          tmp = es[j]
          es[j] = es[_add(j, 1)]
          es[_add(j, 1)] = tmp
        end
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    return es
  end
  def find_parent(parent, x)
    r = x
    while parent[r] != r
      r = parent[r]
    end
    return r
  end
  def union_parent(parent, a, b)
    parent[a] = b
  end
  def kruskal(edges, n)
    es = sort_edges(edges)
    parent = []
    i = 0
    while i <= n
      parent = (parent << (i))
      i = _add(i, 1)
    end
    total = 0
    count = 0
    idx = 0
    while count < n - 1 && idx < es.length
      e = es[idx]
      idx = _add(idx, 1)
      u = e[0]
      v = e[1]
      w = e[2]
      ru = find_parent(parent, u)
      rv = find_parent(parent, v)
      if ru != rv
        union_parent(parent, ru, rv)
        total = _add(total, w)
        count = _add(count, 1)
      end
    end
    return total
  end
  def find_isolated_nodes(g, nodes)
    isolated = []
        __tmp7 = nodes
    if __tmp7.respond_to?(:keys) && !__tmp7.is_a?(String)
      __tmp7 = __tmp7.keys
    end
    __tmp7.each do |node|
      if g[node].length == 0
        isolated = (isolated << (node))
      end
    end
    return isolated
  end
  $g_dfs = {1 => [2, 3], 2 => [4, 5], 3 => [], 4 => [], 5 => []}
  $g_bfs = {1 => [2, 3], 2 => [4, 5], 3 => [6, 7], 4 => [], 5 => [8], 6 => [], 7 => [], 8 => []}
  $g_weighted = {1 => [[2, 7], [3, 9], [6, 14]], 2 => [[1, 7], [3, 10], [4, 15]], 3 => [[1, 9], [2, 10], [4, 11], [6, 2]], 4 => [[2, 15], [3, 11], [5, 6]], 5 => [[4, 6], [6, 9]], 6 => [[1, 14], [3, 2], [5, 9]]}
  $g_topo = {1 => [2, 3], 2 => [4], 3 => [4], 4 => []}
  $matrix = [[0, 5, 9, 100000], [100000, 0, 2, 8], [100000, 100000, 0, 7], [4, 100000, 100000, 0]]
  $g_prim = {1 => [[2, 1], [3, 3]], 2 => [[1, 1], [3, 1], [4, 6]], 3 => [[1, 3], [2, 1], [4, 2]], 4 => [[2, 6], [3, 2]]}
  $edges_kruskal = [[1, 2, 1], [2, 3, 2], [1, 3, 2], [3, 4, 1]]
  $g_iso = {1 => [2, 3], 2 => [1, 3], 3 => [1, 2], 4 => []}
  dfs($g_dfs, 1)
  bfs($g_bfs, 1)
  dijkstra($g_weighted, 1)
  topo($g_topo, 4)
  floyd($matrix)
  puts(prim($g_prim, 1, 4))
  puts(kruskal($edges_kruskal, 4))
  $iso = find_isolated_nodes($g_iso, [1, 2, 3, 4])
  puts(((x = $iso); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(String) then '\'' + x + '\'' elsif x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "'#{k}': #{v.is_a?(String) ? '\'' + v + '\'' : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(', ') + "]") : x.to_s))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
