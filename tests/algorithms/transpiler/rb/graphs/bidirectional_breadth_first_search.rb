# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def key(y, x)
    return _add(_add(_str(y), ","), _str(x))
  end
  def parse_int(s)
    value = 0
    i = 0
    while i < s.length
      c = s[i]
      value = _add(value * 10, ((c).to_i))
      i = _add(i, 1)
    end
    return value
  end
  def parse_key(k)
    idx = 0
    while idx < k.length && k[idx..._add(idx, 1)] != ","
      idx = _add(idx, 1)
    end
    y = parse_int(k[0...idx])
    x = parse_int(k[_add(idx, 1)...k.length])
    return [y, x]
  end
  def neighbors(pos)
    coords = parse_key(pos)
    y = coords[0]
    x = coords[1]
    res = []
    i = 0
    while i < $delta.length
      ny = _add(y, $delta[i][0])
      nx = _add(x, $delta[i][1])
      if ny >= 0 && ny < $grid.length && nx >= 0 && nx < $grid[0].length
        if $grid[ny][nx] == 0
          res = (res << (key(ny, nx)))
        end
      end
      i = _add(i, 1)
    end
    return res
  end
  def reverse_list(lst)
    res = []
    i = lst.length - 1
    while i >= 0
      res = (res << (lst[i]))
      i = i - 1
    end
    return res
  end
  def bfs(start, goal)
    queue = []
    queue = (queue << (Node.new(pos: start, path: [start])))
    head = 0
    visited = {"start" => true}
    while head < queue.length
      node = queue[head]
      head = _add(head, 1)
      if node["pos"] == goal
        return node["path"]
      end
      neigh = neighbors(node["pos"])
      i = 0
      while i < neigh.length
        npos = neigh[i]
        if !(visited.include?(npos))
          visited[npos] = true
          new_path = (node["path"] << (npos))
          queue = (queue << (Node.new(pos: npos, path: new_path)))
        end
        i = _add(i, 1)
      end
    end
    return []
  end
  def bidirectional_bfs(start, goal)
    queue_f = []
    queue_b = []
    queue_f = (queue_f << (Node.new(pos: start, path: [start])))
    queue_b = (queue_b << (Node.new(pos: goal, path: [goal])))
    head_f = 0
    head_b = 0
    visited_f = {"start" => [start]}
    visited_b = {"goal" => [goal]}
    while head_f < queue_f.length && head_b < queue_b.length
      node_f = queue_f[head_f]
      head_f = _add(head_f, 1)
      neigh_f = neighbors(node_f["pos"])
      i = 0
      while i < neigh_f.length
        npos = neigh_f[i]
        if !(visited_f.include?(npos))
          new_path = (node_f["path"] << (npos))
          visited_f[npos] = new_path
          if visited_b.include?(npos)
            rev = reverse_list(visited_b[npos])
            j = 1
            while j < rev.length
              new_path = (new_path << (rev[j]))
              j = _add(j, 1)
            end
            return new_path
          end
          queue_f = (queue_f << (Node.new(pos: npos, path: new_path)))
        end
        i = _add(i, 1)
      end
      node_b = queue_b[head_b]
      head_b = _add(head_b, 1)
      neigh_b = neighbors(node_b["pos"])
      j = 0
      while j < neigh_b.length
        nposb = neigh_b[j]
        if !(visited_b.include?(nposb))
          new_path_b = (node_b["path"] << (nposb))
          visited_b[nposb] = new_path_b
          if visited_f.include?(nposb)
            path_f = visited_f[nposb]
            new_path_b = reverse_list(new_path_b)
            t = 1
            while t < new_path_b.length
              path_f = (path_f << (new_path_b[t]))
              t = _add(t, 1)
            end
            return path_f
          end
          queue_b = (queue_b << (Node.new(pos: nposb, path: new_path_b)))
        end
        j = _add(j, 1)
      end
    end
    return [start]
  end
  def path_to_string(path)
    if path.length == 0
      return "[]"
    end
    first = parse_key(path[0])
    s = _add(_add(_add(_add("[(", _str(first[0])), ", "), _str(first[1])), ")")
    i = 1
    while i < path.length
      c = parse_key(path[i])
      s = _add(_add(_add(_add(_add(s, ", ("), _str(c[0])), ", "), _str(c[1])), ")")
      i = _add(i, 1)
    end
    s = _add(s, "]")
    return s
  end
  $grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]
  $delta = [[-1, 0], [0, -1], [1, 0], [0, 1]]
  Node = Struct.new(:pos, :path, keyword_init: true)
  $start = key(0, 0)
  $goal = key($grid.length - 1, $grid[0].length - 1)
  $path1 = bfs($start, $goal)
  puts(path_to_string($path1))
  $path2 = bidirectional_bfs($start, $goal)
  puts(path_to_string($path2))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
