# Generated by Mochi transpiler v0.10.65 on 2025-08-14 17:09 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  x = x.clone if x.is_a?(Array)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def key(y, x)
    return _add(_add(_str(y), ","), _str(x))
  end
  def parse_int(s)
    value = 0
    i = 0
    while i < _len(s)
      c = (__tmp1 = s; __tmp1.is_a?(Hash) ? __tmp1[i] : _idx(__tmp1, i))
      value = _add(value * 10, ((c).to_i))
      i = _add(i, 1)
    end
    return value
  end
  def parse_key(k)
    idx = 0
    while idx < _len(k) && !_eq(k[idx..._add(idx, 1)], ",")
      idx = _add(idx, 1)
    end
    y = parse_int(k[0...idx])
    x = parse_int(k[_add(idx, 1)..._len(k)])
    return [y, x]
  end
  def neighbors(pos)
    coords = parse_key(pos)
    y = (__tmp2 = coords; __tmp2.is_a?(Hash) ? __tmp2[0] : _idx(__tmp2, 0))
    x = (__tmp3 = coords; __tmp3.is_a?(Hash) ? __tmp3[1] : _idx(__tmp3, 1))
    res = []
    i = 0
    while i < _len($delta)
      ny = _add(y, (__tmp4 = (__tmp5 = $delta; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i)); __tmp4.is_a?(Hash) ? __tmp4[0] : _idx(__tmp4, 0)))
      nx = _add(x, (__tmp6 = (__tmp7 = $delta; __tmp7.is_a?(Hash) ? __tmp7[i] : _idx(__tmp7, i)); __tmp6.is_a?(Hash) ? __tmp6[1] : _idx(__tmp6, 1)))
      if ny >= 0 && ny < _len($grid) && nx >= 0 && nx < _len((__tmp8 = $grid; __tmp8.is_a?(Hash) ? __tmp8[0] : _idx(__tmp8, 0)))
        if _eq((__tmp9 = (__tmp10 = $grid; __tmp10.is_a?(Hash) ? __tmp10[ny] : _idx(__tmp10, ny)); __tmp9.is_a?(Hash) ? __tmp9[nx] : _idx(__tmp9, nx)), 0)
          res = _append(res, key(ny, nx))
        end
      end
      i = _add(i, 1)
    end
    return res
  end
  def reverse_list(lst)
    res = []
    i = _len(lst) - 1
    while i >= 0
      res = _append(res, (__tmp11 = lst; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i)))
      i = i - 1
    end
    return res
  end
  def bfs(start, goal)
    queue = []
    queue = _append(queue, Node.new(pos: start, path: [start]))
    head = 0
    visited = {"start" => true}
    while head < _len(queue)
      node = (__tmp12 = queue; __tmp12.is_a?(Hash) ? __tmp12[head] : _idx(__tmp12, head))
      head = _add(head, 1)
      if _eq((__tmp13 = node; __tmp13.is_a?(Hash) ? __tmp13["pos"] : _idx(__tmp13, "pos")), goal)
        return (__tmp14 = node; __tmp14.is_a?(Hash) ? __tmp14["path"] : _idx(__tmp14, "path"))
      end
      neigh = neighbors((__tmp15 = node; __tmp15.is_a?(Hash) ? __tmp15["pos"] : _idx(__tmp15, "pos")))
      i = 0
      while i < _len(neigh)
        npos = (__tmp16 = neigh; __tmp16.is_a?(Hash) ? __tmp16[i] : _idx(__tmp16, i))
        if !(_has(visited, npos))
          visited[npos] = true
          new_path = _append((__tmp17 = node; __tmp17.is_a?(Hash) ? __tmp17["path"] : _idx(__tmp17, "path")), npos)
          queue = _append(queue, Node.new(pos: npos, path: new_path))
        end
        i = _add(i, 1)
      end
    end
    return []
  end
  def bidirectional_bfs(start, goal)
    queue_f = []
    queue_b = []
    queue_f = _append(queue_f, Node.new(pos: start, path: [start]))
    queue_b = _append(queue_b, Node.new(pos: goal, path: [goal]))
    head_f = 0
    head_b = 0
    visited_f = {"start" => [start]}
    visited_b = {"goal" => [goal]}
    while head_f < _len(queue_f) && head_b < _len(queue_b)
      node_f = (__tmp18 = queue_f; __tmp18.is_a?(Hash) ? __tmp18[head_f] : _idx(__tmp18, head_f))
      head_f = _add(head_f, 1)
      neigh_f = neighbors((__tmp19 = node_f; __tmp19.is_a?(Hash) ? __tmp19["pos"] : _idx(__tmp19, "pos")))
      i = 0
      while i < _len(neigh_f)
        npos = (__tmp20 = neigh_f; __tmp20.is_a?(Hash) ? __tmp20[i] : _idx(__tmp20, i))
        if !(_has(visited_f, npos))
          new_path = _append((__tmp21 = node_f; __tmp21.is_a?(Hash) ? __tmp21["path"] : _idx(__tmp21, "path")), npos)
          visited_f[npos] = new_path
          if _has(visited_b, npos)
            rev = reverse_list((__tmp22 = visited_b; __tmp22.is_a?(Hash) ? __tmp22[npos] : _idx(__tmp22, npos)))
            j = 1
            while j < _len(rev)
              new_path = _append(new_path, (__tmp23 = rev; __tmp23.is_a?(Hash) ? __tmp23[j] : _idx(__tmp23, j)))
              j = _add(j, 1)
            end
            return new_path
          end
          queue_f = _append(queue_f, Node.new(pos: npos, path: new_path))
        end
        i = _add(i, 1)
      end
      node_b = (__tmp24 = queue_b; __tmp24.is_a?(Hash) ? __tmp24[head_b] : _idx(__tmp24, head_b))
      head_b = _add(head_b, 1)
      neigh_b = neighbors((__tmp25 = node_b; __tmp25.is_a?(Hash) ? __tmp25["pos"] : _idx(__tmp25, "pos")))
      j = 0
      while j < _len(neigh_b)
        nposb = (__tmp26 = neigh_b; __tmp26.is_a?(Hash) ? __tmp26[j] : _idx(__tmp26, j))
        if !(_has(visited_b, nposb))
          new_path_b = _append((__tmp27 = node_b; __tmp27.is_a?(Hash) ? __tmp27["path"] : _idx(__tmp27, "path")), nposb)
          visited_b[nposb] = new_path_b
          if _has(visited_f, nposb)
            path_f = (__tmp28 = visited_f; __tmp28.is_a?(Hash) ? __tmp28[nposb] : _idx(__tmp28, nposb))
            new_path_b = reverse_list(new_path_b)
            t = 1
            while t < _len(new_path_b)
              path_f = _append(path_f, (__tmp29 = new_path_b; __tmp29.is_a?(Hash) ? __tmp29[t] : _idx(__tmp29, t)))
              t = _add(t, 1)
            end
            return path_f
          end
          queue_b = _append(queue_b, Node.new(pos: nposb, path: new_path_b))
        end
        j = _add(j, 1)
      end
    end
    return [start]
  end
  def path_to_string(path)
    if _eq(_len(path), 0)
      return "[]"
    end
    first = parse_key((__tmp30 = path; __tmp30.is_a?(Hash) ? __tmp30[0] : _idx(__tmp30, 0)))
    s = _add(_add(_add(_add("[(", _str((__tmp31 = first; __tmp31.is_a?(Hash) ? __tmp31[0] : _idx(__tmp31, 0)))), ", "), _str((__tmp32 = first; __tmp32.is_a?(Hash) ? __tmp32[1] : _idx(__tmp32, 1)))), ")")
    i = 1
    while i < _len(path)
      c = parse_key((__tmp33 = path; __tmp33.is_a?(Hash) ? __tmp33[i] : _idx(__tmp33, i)))
      s = _add(_add(_add(_add(_add(s, ", ("), _str((__tmp34 = c; __tmp34.is_a?(Hash) ? __tmp34[0] : _idx(__tmp34, 0)))), ", "), _str((__tmp35 = c; __tmp35.is_a?(Hash) ? __tmp35[1] : _idx(__tmp35, 1)))), ")")
      i = _add(i, 1)
    end
    s = _add(s, "]")
    return s
  end
  $grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]
  $delta = [[-1, 0], [0, -1], [1, 0], [0, 1]]
  Object.send(:remove_const, :Node) if Object.const_defined?(:Node)
  Node = Struct.new(:pos, :path, keyword_init: true)
  $start = key(0, 0)
  $goal = key(_len($grid) - 1, _len((__tmp36 = $grid; __tmp36.is_a?(Hash) ? __tmp36[0] : _idx(__tmp36, 0))) - 1)
  $path1 = bfs($start, $goal)
  puts(path_to_string($path1))
  $path2 = bidirectional_bfs($start, $goal)
  puts(path_to_string($path2))
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
