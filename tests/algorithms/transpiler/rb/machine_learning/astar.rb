# Generated by Mochi transpiler v0.10.66 on 2025-08-16 11:48 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  x = x.clone if x.is_a?(Array)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def get_neighbours(p, x_limit, y_limit)
    deltas = [Point.new(x: (0 - 1), y: (0 - 1)), Point.new(x: (0 - 1), y: 0), Point.new(x: (0 - 1), y: 1), Point.new(x: 0, y: (0 - 1)), Point.new(x: 0, y: 1), Point.new(x: 1, y: (0 - 1)), Point.new(x: 1, y: 0), Point.new(x: 1, y: 1)]
    neighbours = []
        __tmp1 = deltas
    __tmp1 = [] if __tmp1.nil?
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |d|
      nx = _add(p.x, d.x)
      ny = _add(p.y, d.y)
      if 0 <= nx && nx < x_limit && 0 <= ny && ny < y_limit
        neighbours = _append(neighbours, Point.new(x: nx, y: ny))
      end
    end
    return neighbours
  end
  def contains(nodes, p)
        __tmp2 = nodes
    __tmp2 = [] if __tmp2.nil?
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |n|
      if _eq(n.pos.x, p.x) && _eq(n.pos.y, p.y)
        return true
      end
    end
    return false
  end
  def get_node(nodes, p)
        __tmp3 = nodes
    __tmp3 = [] if __tmp3.nil?
    if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
      __tmp3 = __tmp3.keys
    end
    __tmp3.each do |n|
      if _eq(n.pos.x, p.x) && _eq(n.pos.y, p.y)
        return n
      end
    end
    return Node.new(pos: p, parent: Point.new(x: (0 - 1), y: (0 - 1)), g: 0, h: 0, f: 0)
  end
  def astar(x_limit, y_limit, start, goal)
    open = []
    closed = []
    open = _append(open, Node.new(pos: start, parent: Point.new(x: (0 - 1), y: (0 - 1)), g: 0, h: 0, f: 0))
    current = (__tmp4 = open; __tmp4.is_a?(Hash) ? __tmp4[0] : _idx(__tmp4, 0))
    while _len(open) > 0
      min_index = 0
      i = 1
      while i < _len(open)
        if (__tmp5 = (__tmp6 = open; __tmp6.is_a?(Hash) ? __tmp6[i] : _idx(__tmp6, i)); __tmp5.is_a?(Hash) ? __tmp5["f"] : _idx(__tmp5, "f")) < (__tmp7 = (__tmp8 = open; __tmp8.is_a?(Hash) ? __tmp8[min_index] : _idx(__tmp8, min_index)); __tmp7.is_a?(Hash) ? __tmp7["f"] : _idx(__tmp7, "f"))
          min_index = i
        end
        i = _add(i, 1)
      end
      current = (__tmp9 = open; __tmp9.is_a?(Hash) ? __tmp9[min_index] : _idx(__tmp9, min_index))
      new_open = []
      j = 0
      while j < _len(open)
        if !_eq(j, min_index)
          new_open = _append(new_open, (__tmp10 = open; __tmp10.is_a?(Hash) ? __tmp10[j] : _idx(__tmp10, j)))
        end
        j = _add(j, 1)
      end
      open = new_open
      closed = _append(closed, current)
      if _eq((__tmp11 = (__tmp12 = current; __tmp12.is_a?(Hash) ? __tmp12["pos"] : _idx(__tmp12, "pos")); __tmp11.is_a?(Hash) ? __tmp11["x"] : _idx(__tmp11, "x")), goal.x) && _eq((__tmp13 = (__tmp14 = current; __tmp14.is_a?(Hash) ? __tmp14["pos"] : _idx(__tmp14, "pos")); __tmp13.is_a?(Hash) ? __tmp13["y"] : _idx(__tmp13, "y")), goal.y)
        break
      end
      neighbours = get_neighbours((__tmp15 = current; __tmp15.is_a?(Hash) ? __tmp15["pos"] : _idx(__tmp15, "pos")), x_limit, y_limit)
            __tmp16 = neighbours
      __tmp16 = [] if __tmp16.nil?
      if __tmp16.respond_to?(:keys) && !__tmp16.is_a?(String)
        __tmp16 = __tmp16.keys
      end
      __tmp16.each do |np|
        if contains(closed, np)
          next
        end
        g = _add((__tmp17 = current; __tmp17.is_a?(Hash) ? __tmp17["g"] : _idx(__tmp17, "g")), 1)
        dx = goal.x - np.x
        dy = goal.y - np.y
        h = _add(dx * dx, dy * dy)
        f = _add(g, h)
        skip = false
                __tmp18 = open
        __tmp18 = [] if __tmp18.nil?
        if __tmp18.respond_to?(:keys) && !__tmp18.is_a?(String)
          __tmp18 = __tmp18.keys
        end
        __tmp18.each do |node|
          if _eq((__tmp19 = (__tmp20 = node; __tmp20.is_a?(Hash) ? __tmp20["pos"] : _idx(__tmp20, "pos")); __tmp19.is_a?(Hash) ? __tmp19["x"] : _idx(__tmp19, "x")), np.x) && _eq((__tmp21 = (__tmp22 = node; __tmp22.is_a?(Hash) ? __tmp22["pos"] : _idx(__tmp22, "pos")); __tmp21.is_a?(Hash) ? __tmp21["y"] : _idx(__tmp21, "y")), np.y) && (__tmp23 = node; __tmp23.is_a?(Hash) ? __tmp23["f"] : _idx(__tmp23, "f")) < f
            skip = true
          end
        end
        if skip
          next
        end
        open = _append(open, Node.new(pos: np, parent: (__tmp24 = current; __tmp24.is_a?(Hash) ? __tmp24["pos"] : _idx(__tmp24, "pos")), g: g, h: h, f: f))
      end
    end
    path = []
    path = _append(path, (__tmp25 = current; __tmp25.is_a?(Hash) ? __tmp25["pos"] : _idx(__tmp25, "pos")))
    while !(_eq((__tmp26 = (__tmp27 = current; __tmp27.is_a?(Hash) ? __tmp27["parent"] : _idx(__tmp27, "parent")); __tmp26.is_a?(Hash) ? __tmp26["x"] : _idx(__tmp26, "x")), (0 - 1)) && _eq((__tmp28 = (__tmp29 = current; __tmp29.is_a?(Hash) ? __tmp29["parent"] : _idx(__tmp29, "parent")); __tmp28.is_a?(Hash) ? __tmp28["y"] : _idx(__tmp28, "y")), (0 - 1)))
      current = get_node(closed, (__tmp30 = current; __tmp30.is_a?(Hash) ? __tmp30["parent"] : _idx(__tmp30, "parent")))
      path = _append(path, (__tmp31 = current; __tmp31.is_a?(Hash) ? __tmp31["pos"] : _idx(__tmp31, "pos")))
    end
    rev = []
    k = _len(path) - 1
    while k >= 0
      rev = _append(rev, (__tmp32 = path; __tmp32.is_a?(Hash) ? __tmp32[k] : _idx(__tmp32, k)))
      k = k - 1
    end
    return rev
  end
  def create_world(x_limit, y_limit)
    world = []
    i = 0
    while i < x_limit
      row = []
      j = 0
      while j < y_limit
        row = _append(row, 0)
        j = _add(j, 1)
      end
      world = _append(world, row)
      i = _add(i, 1)
    end
    return world
  end
  def mark_path(world, path)
        __tmp33 = path
    __tmp33 = [] if __tmp33.nil?
    if __tmp33.respond_to?(:keys) && !__tmp33.is_a?(String)
      __tmp33 = __tmp33.keys
    end
    __tmp33.each do |p|
      (__tmp34 = world; __tmp34.is_a?(Hash) ? __tmp34[p.x] : _idx(__tmp34, p.x))[p.y] = 1
    end
  end
  def print_world(world)
        __tmp35 = world
    __tmp35 = [] if __tmp35.nil?
    if __tmp35.respond_to?(:keys) && !__tmp35.is_a?(String)
      __tmp35 = __tmp35.keys
    end
    __tmp35.each do |row|
      puts(((x = row); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s))
    end
  end
  Object.send(:remove_const, :Point) if Object.const_defined?(:Point)
  Object.const_set(:Point, Struct.new(:x, :y, keyword_init: true))
  Object.send(:remove_const, :Node) if Object.const_defined?(:Node)
  Object.const_set(:Node, Struct.new(:pos, :parent, :g, :h, :f, keyword_init: true))
  $world_x = 5
  $world_y = 5
  $start = Point.new(x: 0, y: 0)
  $goal = Point.new(x: 4, y: 4)
  $path = astar($world_x, $world_y, $start, $goal)
  puts(_add(_add(_add(_add(_add(_add(_add(_add("path from (", _str($start.x)), ", "), _str($start.y)), ") to ("), _str($goal.x)), ", "), _str($goal.y)), ")"))
  $world = create_world($world_x, $world_y)
  mark_path($world, $path)
  print_world($world)
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
