# Generated by Mochi transpiler v0.10.63 on 2025-08-11 18:28 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    a + b
  end
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    (a.to_f - b.to_f).abs < 1e-6
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = _now()
  def exp_approx(x)
    sum = 1.0
    term = 1.0
    n = 1
    while n < 20
      term = term * x / ((n).to_f)
      sum = _add(sum, term)
      n = _add(n, 1)
    end
    return sum
  end
  def sigmoid(x)
    return 1.0 / (_add(1.0, exp_approx(-x)))
  end
  def tanh_approx(x)
    e = exp_approx(2.0 * x)
    return (e - 1.0) / (_add(e, 1.0))
  end
  def forward(seq, w)
    i_arr = []
    f_arr = []
    o_arr = []
    g_arr = []
    c_arr = [0.0]
    h_arr = [0.0]
    t = 0
    while t < seq.length
      x = seq[t]
      h_prev = h_arr[t]
      c_prev = c_arr[t]
      i_t = sigmoid(_add(_add(w.w_i * x, w.u_i * h_prev), w.b_i))
      f_t = sigmoid(_add(_add(w.w_f * x, w.u_f * h_prev), w.b_f))
      o_t = sigmoid(_add(_add(w.w_o * x, w.u_o * h_prev), w.b_o))
      g_t = tanh_approx(_add(_add(w.w_c * x, w.u_c * h_prev), w.b_c))
      c_t = _add(f_t * c_prev, i_t * g_t)
      h_t = o_t * tanh_approx(c_t)
      i_arr = (i_arr + [i_t])
      f_arr = (f_arr + [f_t])
      o_arr = (o_arr + [o_t])
      g_arr = (g_arr + [g_t])
      c_arr = (c_arr + [c_t])
      h_arr = (h_arr + [h_t])
      t = _add(t, 1)
    end
    return LSTMState.new(i: i_arr, f: f_arr, o: o_arr, g: g_arr, c: c_arr, h: h_arr)
  end
  def backward(seq, target, w, s, lr)
    dw_i = 0.0
    du_i = 0.0
    db_i = 0.0
    dw_f = 0.0
    du_f = 0.0
    db_f = 0.0
    dw_o = 0.0
    du_o = 0.0
    db_o = 0.0
    dw_c = 0.0
    du_c = 0.0
    db_c = 0.0
    dw_y = 0.0
    db_y = 0.0
    _T = seq.length
    h_last = s.h[_T]
    y = _add(w.w_y * h_last, w.b_y)
    dy = y - target
    dw_y = dy * h_last
    db_y = dy
    dh_next = dy * w.w_y
    dc_next = 0.0
    t = _T - 1
    while t >= 0
      i_t = s.i[t]
      f_t = s.f[t]
      o_t = s.o[t]
      g_t = s.g[t]
      c_t = s.c[_add(t, 1)]
      c_prev = s.c[t]
      h_prev = s.h[t]
      tanh_c = tanh_approx(c_t)
      do_t = dh_next * tanh_c
      da_o = do_t * o_t * (1.0 - o_t)
      dc = _add(dh_next * o_t * (1.0 - tanh_c * tanh_c), dc_next)
      di_t = dc * g_t
      da_i = di_t * i_t * (1.0 - i_t)
      dg_t = dc * i_t
      da_g = dg_t * (1.0 - g_t * g_t)
      df_t = dc * c_prev
      da_f = df_t * f_t * (1.0 - f_t)
      dw_i = _add(dw_i, da_i * seq[t])
      du_i = _add(du_i, da_i * h_prev)
      db_i = _add(db_i, da_i)
      dw_f = _add(dw_f, da_f * seq[t])
      du_f = _add(du_f, da_f * h_prev)
      db_f = _add(db_f, da_f)
      dw_o = _add(dw_o, da_o * seq[t])
      du_o = _add(du_o, da_o * h_prev)
      db_o = _add(db_o, da_o)
      dw_c = _add(dw_c, da_g * seq[t])
      du_c = _add(du_c, da_g * h_prev)
      db_c = _add(db_c, da_g)
      dh_next = _add(_add(_add(da_i * w.u_i, da_f * w.u_f), da_o * w.u_o), da_g * w.u_c)
      dc_next = dc * f_t
      t = t - 1
    end
    w["w_y"] = w.w_y - lr * dw_y
    w["b_y"] = w.b_y - lr * db_y
    w["w_i"] = w.w_i - lr * dw_i
    w["u_i"] = w.u_i - lr * du_i
    w["b_i"] = w.b_i - lr * db_i
    w["w_f"] = w.w_f - lr * dw_f
    w["u_f"] = w.u_f - lr * du_f
    w["b_f"] = w.b_f - lr * db_f
    w["w_o"] = w.w_o - lr * dw_o
    w["u_o"] = w.u_o - lr * du_o
    w["b_o"] = w.b_o - lr * db_o
    w["w_c"] = w.w_c - lr * dw_c
    w["u_c"] = w.u_c - lr * du_c
    w["b_c"] = w.b_c - lr * db_c
    return w
  end
  def make_samples(data, look_back)
    _X = []
    _Y = []
    i = 0
    while _add(i, look_back) < data.length
      seq = data[i..._add(i, look_back)]
      _X = (_X + [seq])
      _Y = (_Y + [data[_add(i, look_back)]])
      i = _add(i, 1)
    end
    return Samples.new(x: _X, y: _Y)
  end
  def init_weights()
    return LSTMWeights.new(w_i: 0.1, u_i: 0.2, b_i: 0.0, w_f: 0.1, u_f: 0.2, b_f: 0.0, w_o: 0.1, u_o: 0.2, b_o: 0.0, w_c: 0.1, u_c: 0.2, b_c: 0.0, w_y: 0.1, b_y: 0.0)
  end
  def train(data, look_back, epochs, lr)
    samples = make_samples(data, look_back)
    w = init_weights()
    ep = 0
    while ep < epochs
      j = 0
      while j < samples.x.length
        seq = samples.x[j]
        target = samples.y[j]
        state = forward(seq, w)
        w = backward(seq, target, w, state, lr)
        j = _add(j, 1)
      end
      ep = _add(ep, 1)
    end
    return w
  end
  def predict(seq, w)
    state = forward(seq, w)
    h_last = state.h[state.h.length - 1]
    return _add(w.w_y * h_last, w.b_y)
  end
  LSTMWeights = Struct.new(:w_i, :u_i, :b_i, :w_f, :u_f, :b_f, :w_o, :u_o, :b_o, :w_c, :u_c, :b_c, :w_y, :b_y, keyword_init: true)
  LSTMState = Struct.new(:i, :f, :o, :g, :c, :h, keyword_init: true)
  Samples = Struct.new(:x, :y, keyword_init: true)
  $data = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]
  $look_back = 3
  $epochs = 200
  $lr = 0.1
  $w = train($data, $look_back, $epochs, $lr)
  $test_seq = [0.6, 0.7, 0.8]
  $pred = predict($test_seq, $w)
  puts(_add("Predicted value: ", _str($pred)))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
