# Generated by Mochi transpiler v0.10.67 on 2025-08-17 08:49 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  x = x.clone if x.is_a?(Array)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def exp_approx(x)
    sum = 1.0
    term = 1.0
    n = 1
    while n < 20
      term = term * x / ((n).to_f)
      sum = _add(sum, term)
      n = _add(n, 1)
    end
    return sum
  end
  def sigmoid(x)
    return 1.0 / (_add(1.0, exp_approx(-x)))
  end
  def tanh_approx(x)
    e = exp_approx(2.0 * x)
    return (e - 1.0) / (_add(e, 1.0))
  end
  def forward(seq, w)
    i_arr = []
    f_arr = []
    o_arr = []
    g_arr = []
    c_arr = [0.0]
    h_arr = [0.0]
    t = 0
    while t < _len(seq)
      x = (__tmp1 = seq; __tmp1.is_a?(Hash) ? __tmp1[t] : _idx(__tmp1, t))
      h_prev = (__tmp2 = h_arr; __tmp2.is_a?(Hash) ? __tmp2[t] : _idx(__tmp2, t))
      c_prev = (__tmp3 = c_arr; __tmp3.is_a?(Hash) ? __tmp3[t] : _idx(__tmp3, t))
      i_t = sigmoid(_add(_add(w.w_i * x, w.u_i * h_prev), w.b_i))
      f_t = sigmoid(_add(_add(w.w_f * x, w.u_f * h_prev), w.b_f))
      o_t = sigmoid(_add(_add(w.w_o * x, w.u_o * h_prev), w.b_o))
      g_t = tanh_approx(_add(_add(w.w_c * x, w.u_c * h_prev), w.b_c))
      c_t = _add(f_t * c_prev, i_t * g_t)
      h_t = o_t * tanh_approx(c_t)
      i_arr = _append(i_arr, i_t)
      f_arr = _append(f_arr, f_t)
      o_arr = _append(o_arr, o_t)
      g_arr = _append(g_arr, g_t)
      c_arr = _append(c_arr, c_t)
      h_arr = _append(h_arr, h_t)
      t = _add(t, 1)
    end
    return LSTMState.new(i: i_arr, f: f_arr, o: o_arr, g: g_arr, c: c_arr, h: h_arr)
  end
  def backward(seq, target, w, s, lr)
    dw_i = 0.0
    du_i = 0.0
    db_i = 0.0
    dw_f = 0.0
    du_f = 0.0
    db_f = 0.0
    dw_o = 0.0
    du_o = 0.0
    db_o = 0.0
    dw_c = 0.0
    du_c = 0.0
    db_c = 0.0
    dw_y = 0.0
    db_y = 0.0
    _T = _len(seq)
    h_last = (__tmp4 = s.h; __tmp4.is_a?(Hash) ? __tmp4[_T] : _idx(__tmp4, _T))
    y = _add(w.w_y * h_last, w.b_y)
    dy = y - target
    dw_y = dy * h_last
    db_y = dy
    dh_next = dy * w.w_y
    dc_next = 0.0
    t = _T - 1
    while t >= 0
      i_t = (__tmp5 = s.i; __tmp5.is_a?(Hash) ? __tmp5[t] : _idx(__tmp5, t))
      f_t = (__tmp6 = s.f; __tmp6.is_a?(Hash) ? __tmp6[t] : _idx(__tmp6, t))
      o_t = (__tmp7 = s.o; __tmp7.is_a?(Hash) ? __tmp7[t] : _idx(__tmp7, t))
      g_t = (__tmp8 = s.g; __tmp8.is_a?(Hash) ? __tmp8[t] : _idx(__tmp8, t))
      c_t = (__tmp9 = s.c; __tmp9.is_a?(Hash) ? __tmp9[_add(t, 1)] : _idx(__tmp9, _add(t, 1)))
      c_prev = (__tmp10 = s.c; __tmp10.is_a?(Hash) ? __tmp10[t] : _idx(__tmp10, t))
      h_prev = (__tmp11 = s.h; __tmp11.is_a?(Hash) ? __tmp11[t] : _idx(__tmp11, t))
      tanh_c = tanh_approx(c_t)
      do_t = dh_next * tanh_c
      da_o = do_t * o_t * (1.0 - o_t)
      dc = _add(dh_next * o_t * (1.0 - tanh_c * tanh_c), dc_next)
      di_t = dc * g_t
      da_i = di_t * i_t * (1.0 - i_t)
      dg_t = dc * i_t
      da_g = dg_t * (1.0 - g_t * g_t)
      df_t = dc * c_prev
      da_f = df_t * f_t * (1.0 - f_t)
      dw_i = _add(dw_i, da_i * (__tmp12 = seq; __tmp12.is_a?(Hash) ? __tmp12[t] : _idx(__tmp12, t)))
      du_i = _add(du_i, da_i * h_prev)
      db_i = _add(db_i, da_i)
      dw_f = _add(dw_f, da_f * (__tmp13 = seq; __tmp13.is_a?(Hash) ? __tmp13[t] : _idx(__tmp13, t)))
      du_f = _add(du_f, da_f * h_prev)
      db_f = _add(db_f, da_f)
      dw_o = _add(dw_o, da_o * (__tmp14 = seq; __tmp14.is_a?(Hash) ? __tmp14[t] : _idx(__tmp14, t)))
      du_o = _add(du_o, da_o * h_prev)
      db_o = _add(db_o, da_o)
      dw_c = _add(dw_c, da_g * (__tmp15 = seq; __tmp15.is_a?(Hash) ? __tmp15[t] : _idx(__tmp15, t)))
      du_c = _add(du_c, da_g * h_prev)
      db_c = _add(db_c, da_g)
      dh_next = _add(_add(_add(da_i * w.u_i, da_f * w.u_f), da_o * w.u_o), da_g * w.u_c)
      dc_next = dc * f_t
      t = t - 1
    end
    w.w_y = w.w_y - lr * dw_y
    w.b_y = w.b_y - lr * db_y
    w.w_i = w.w_i - lr * dw_i
    w.u_i = w.u_i - lr * du_i
    w.b_i = w.b_i - lr * db_i
    w.w_f = w.w_f - lr * dw_f
    w.u_f = w.u_f - lr * du_f
    w.b_f = w.b_f - lr * db_f
    w.w_o = w.w_o - lr * dw_o
    w.u_o = w.u_o - lr * du_o
    w.b_o = w.b_o - lr * db_o
    w.w_c = w.w_c - lr * dw_c
    w.u_c = w.u_c - lr * du_c
    w.b_c = w.b_c - lr * db_c
    return w
  end
  def make_samples(data, look_back)
    _X = []
    _Y = []
    i = 0
    while _add(i, look_back) < _len(data)
      seq = data[i..._add(i, look_back)]
      _X = _append(_X, seq)
      _Y = _append(_Y, (__tmp16 = data; __tmp16.is_a?(Hash) ? __tmp16[_add(i, look_back)] : _idx(__tmp16, _add(i, look_back))))
      i = _add(i, 1)
    end
    return Samples.new(x: _X, y: _Y)
  end
  def init_weights()
    return LSTMWeights.new(w_i: 0.1, u_i: 0.2, b_i: 0.0, w_f: 0.1, u_f: 0.2, b_f: 0.0, w_o: 0.1, u_o: 0.2, b_o: 0.0, w_c: 0.1, u_c: 0.2, b_c: 0.0, w_y: 0.1, b_y: 0.0)
  end
  def train(data, look_back, epochs, lr)
    samples = make_samples(data, look_back)
    w = init_weights()
    ep = 0
    while ep < epochs
      j = 0
      while j < _len(samples.x)
        seq = (__tmp17 = samples.x; __tmp17.is_a?(Hash) ? __tmp17[j] : _idx(__tmp17, j))
        target = (__tmp18 = samples.y; __tmp18.is_a?(Hash) ? __tmp18[j] : _idx(__tmp18, j))
        state = forward(seq, w)
        w = backward(seq, target, w, state, lr)
        j = _add(j, 1)
      end
      ep = _add(ep, 1)
    end
    return w
  end
  def predict(seq, w)
    state = forward(seq, w)
    h_last = (__tmp19 = state.h; __tmp19.is_a?(Hash) ? __tmp19[_len(state.h) - 1] : _idx(__tmp19, _len(state.h) - 1))
    return _add(w.w_y * h_last, w.b_y)
  end
  Object.send(:remove_const, :LSTMWeights) if Object.const_defined?(:LSTMWeights)
  Object.const_set(:LSTMWeights, Struct.new(:w_i, :u_i, :b_i, :w_f, :u_f, :b_f, :w_o, :u_o, :b_o, :w_c, :u_c, :b_c, :w_y, :b_y, keyword_init: true))
  Object.send(:remove_const, :LSTMState) if Object.const_defined?(:LSTMState)
  Object.const_set(:LSTMState, Struct.new(:i, :f, :o, :g, :c, :h, keyword_init: true))
  Object.send(:remove_const, :Samples) if Object.const_defined?(:Samples)
  Object.const_set(:Samples, Struct.new(:x, :y, keyword_init: true))
  $data = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]
  $look_back = 3
  $epochs = 200
  $lr = 0.1
  $w = train($data, $look_back, $epochs, $lr)
  $test_seq = [0.6, 0.7, 0.8]
  $pred = predict($test_seq, $w)
  puts(_add("Predicted value: ", _str($pred)))
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
