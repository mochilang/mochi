# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def load_data()
    return [["milk"], ["milk", "butter"], ["milk", "bread"], ["milk", "bread", "chips"]]
  end
  def contains_string(xs, s)
        __tmp1 = xs
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |v|
      if v == s
        return true
      end
    end
    return false
  end
  def is_subset(candidate, transaction)
        __tmp2 = candidate
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |it|
      if !contains_string(transaction, it)
        return false
      end
    end
    return true
  end
  def lists_equal(a, b)
    if a.length != b.length
      return false
    end
    i = 0.clone
    while i < a.length
      if a[i] != b[i]
        return false
      end
      i = _add(i, 1).clone
    end
    return true
  end
  def contains_list(itemset, item)
        __tmp3 = itemset
    if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
      __tmp3 = __tmp3.keys
    end
    __tmp3.each do |l|
      if lists_equal(l, item)
        return true
      end
    end
    return false
  end
  def count_list(itemset, item)
    c = 0.clone
        __tmp4 = itemset
    if __tmp4.respond_to?(:keys) && !__tmp4.is_a?(String)
      __tmp4 = __tmp4.keys
    end
    __tmp4.each do |l|
      if lists_equal(l, item)
        c = _add(c, 1).clone
      end
    end
    return c
  end
  def slice_list(xs, start)
    res = [].clone
    i = start.clone
    while i < xs.length
      res = (res << (xs[i])).clone
      i = _add(i, 1).clone
    end
    return res
  end
  def combinations_lists(xs, k)
    result = [].clone
    if k == 0
      result = (result << ([])).clone
      return result
    end
    i = 0.clone
    while i < xs.length
      head = xs[i]
      tail = slice_list(xs, _add(i, 1))
      tail_combos = combinations_lists(tail, k - 1)
            __tmp5 = tail_combos
      if __tmp5.respond_to?(:keys) && !__tmp5.is_a?(String)
        __tmp5 = __tmp5.keys
      end
      __tmp5.each do |combo|
        new_combo = [].clone
        new_combo = (new_combo << (head)).clone
                __tmp6 = combo
        if __tmp6.respond_to?(:keys) && !__tmp6.is_a?(String)
          __tmp6 = __tmp6.keys
        end
        __tmp6.each do |c|
          new_combo = (new_combo << (c)).clone
        end
        result = (result << (new_combo)).clone
      end
      i = _add(i, 1).clone
    end
    return result
  end
  def prune(itemset, candidates, length)
    pruned = [].clone
        __tmp7 = candidates
    if __tmp7.respond_to?(:keys) && !__tmp7.is_a?(String)
      __tmp7 = __tmp7.keys
    end
    __tmp7.each do |candidate|
      is_subsequence = true.clone
            __tmp8 = candidate
      if __tmp8.respond_to?(:keys) && !__tmp8.is_a?(String)
        __tmp8 = __tmp8.keys
      end
      __tmp8.each do |item|
        if !contains_list(itemset, item) || count_list(itemset, item) < length - 1
          is_subsequence = false.clone
          break
        end
      end
      if is_subsequence
        pruned = (pruned << (candidate)).clone
      end
    end
    return pruned
  end
  def sort_strings(xs)
    res = [].clone
        __tmp9 = xs
    if __tmp9.respond_to?(:keys) && !__tmp9.is_a?(String)
      __tmp9 = __tmp9.keys
    end
    __tmp9.each do |s|
      res = (res << (s)).clone
    end
    i = 0.clone
    while i < res.length
      j = _add(i, 1).clone
      while j < res.length
        if res[j] < res[i]
          tmp = res[i]
          res[i] = res[j]
          res[j] = tmp
        end
        j = _add(j, 1).clone
      end
      i = _add(i, 1).clone
    end
    return res
  end
  def itemset_to_string(xs)
    s = "[".clone
    i = 0.clone
    while i < xs.length
      if i > 0
        s = _add(s, ", ").clone
      end
      s = _add(_add(_add(s, "'"), xs[i]), "'").clone
      i = _add(i, 1).clone
    end
    s = _add(s, "]").clone
    return s
  end
  def apriori(data, min_support)
    itemset = [].clone
        __tmp10 = data
    if __tmp10.respond_to?(:keys) && !__tmp10.is_a?(String)
      __tmp10 = __tmp10.keys
    end
    __tmp10.each do |transaction|
      t = [].clone
            __tmp11 = transaction
      if __tmp11.respond_to?(:keys) && !__tmp11.is_a?(String)
        __tmp11 = __tmp11.keys
      end
      __tmp11.each do |v|
        t = (t << (v)).clone
      end
      itemset = (itemset << (t)).clone
    end
    frequent = [].clone
    length = 1.clone
    while itemset.length > 0
      counts = [].clone
      idx = 0.clone
      while idx < itemset.length
        counts = (counts << (0)).clone
        idx = _add(idx, 1).clone
      end
            __tmp12 = data
      if __tmp12.respond_to?(:keys) && !__tmp12.is_a?(String)
        __tmp12 = __tmp12.keys
      end
      __tmp12.each do |transaction|
        j = 0.clone
        while j < itemset.length
          candidate = itemset[j]
          if is_subset(candidate, transaction)
            counts[j] = _add(counts[j], 1)
          end
          j = _add(j, 1).clone
        end
      end
      new_itemset = [].clone
      k = 0.clone
      while k < itemset.length
        if counts[k] >= min_support
          new_itemset = (new_itemset << (itemset[k])).clone
        end
        k = _add(k, 1).clone
      end
      itemset = new_itemset.clone
      m = 0.clone
      while m < itemset.length
        sorted_item = sort_strings(itemset[m]).clone
        frequent = (frequent << (Itemset.new(items: sorted_item, support: counts[m]))).clone
        m = _add(m, 1).clone
      end
      length = _add(length, 1).clone
      combos = combinations_lists(itemset, length)
      itemset = prune(itemset, combos, length).clone
    end
    return frequent
  end
  Itemset = Struct.new(:items, :support, keyword_init: true)
  $frequent_itemsets = apriori(load_data(), 2).clone
    __tmp13 = $frequent_itemsets
  if __tmp13.respond_to?(:keys) && !__tmp13.is_a?(String)
    __tmp13 = __tmp13.keys
  end
  __tmp13.each do |fi|
    puts(_add(_add(itemset_to_string(fi.items), ": "), _str(fi.support)))
  end
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
