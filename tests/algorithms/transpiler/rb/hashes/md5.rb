# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def ord(ch)
    i = 0.clone
    while i < $ASCII.length
      if $ASCII[i..._add(i, 1)] == ch
        return _add(32, i)
      end
      i = _add(i, 1).clone
    end
    return 0
  end
  def to_little_endian(s)
    if s.length != 32
      panic("Input must be of length 32")
    end
    return _add(_add(_add(s[24...32], s[16...24]), s[8...16]), s[0...8])
  end
  def int_to_bits(n, width)
    bits = "".clone
    num = n.clone
    while num > 0
      bits = _add(_str(num % 2), bits).clone
      num = num / 2.clone
    end
    while bits.length < width
      bits = _add("0", bits).clone
    end
    if bits.length > width
      bits = bits[bits.length - width...bits.length].clone
    end
    return bits
  end
  def bits_to_int(bits)
    num = 0.clone
    i = 0.clone
    while i < bits.length
      if bits[i..._add(i, 1)] == "1"
        num = _add(num * 2, 1).clone
      else
        num = num * 2.clone
      end
      i = _add(i, 1).clone
    end
    return num
  end
  def to_hex(n)
    digits = "0123456789abcdef"
    if n == 0
      return "0"
    end
    num = n.clone
    s = "".clone
    while num > 0
      d = num % 16
      s = _add(digits[d..._add(d, 1)], s).clone
      num = num / 16.clone
    end
    return s
  end
  def reformat_hex(i)
    if i < 0
      panic("Input must be non-negative")
    end
    hex = to_hex(i).clone
    while hex.length < 8
      hex = _add("0", hex).clone
    end
    if hex.length > 8
      hex = hex[hex.length - 8...hex.length].clone
    end
    le = "".clone
    j = hex.length - 2.clone
    while j >= 0
      le = _add(le, hex[j..._add(j, 2)]).clone
      j = j - 2.clone
    end
    return le
  end
  def preprocess(message)
    bit_string = "".clone
    i = 0.clone
    while i < message.length
      ch = message[i..._add(i, 1)]
      bit_string = _add(bit_string, int_to_bits(ord(ch), 8)).clone
      i = _add(i, 1).clone
    end
    start_len = int_to_bits(bit_string.length, 64)
    bit_string = _add(bit_string, "1").clone
    while bit_string.length % 512 != 448
      bit_string = _add(bit_string, "0").clone
    end
    bit_string = _add(_add(bit_string, to_little_endian(start_len[32...64])), to_little_endian(start_len[0...32])).clone
    return bit_string
  end
  def get_block_words(bit_string)
    if bit_string.length % 512 != 0
      panic("Input must have length that's a multiple of 512")
    end
    blocks = [].clone
    pos = 0.clone
    while pos < bit_string.length
      block = [].clone
      i = 0.clone
      while i < 512
        part = bit_string[_add(pos, i)..._add(_add(pos, i), 32)]
        word = bits_to_int(to_little_endian(part))
        block = (block << (word)).clone
        i = _add(i, 32).clone
      end
      blocks = (blocks << (block)).clone
      pos = _add(pos, 512).clone
    end
    return blocks
  end
  def bit_and(a, b)
    x = a.clone
    y = b.clone
    res = 0.clone
    bit = 1.clone
    i = 0.clone
    while i < 32
      if (x % 2 == 1) && (y % 2 == 1)
        res = _add(res, bit).clone
      end
      x = x / 2.clone
      y = y / 2.clone
      bit = bit * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def bit_or(a, b)
    x = a.clone
    y = b.clone
    res = 0.clone
    bit = 1.clone
    i = 0.clone
    while i < 32
      abit = x % 2
      bbit = y % 2
      if abit == 1 || bbit == 1
        res = _add(res, bit).clone
      end
      x = x / 2.clone
      y = y / 2.clone
      bit = bit * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def bit_xor(a, b)
    x = a.clone
    y = b.clone
    res = 0.clone
    bit = 1.clone
    i = 0.clone
    while i < 32
      abit = x % 2
      bbit = y % 2
      if (_add(abit, bbit)) % 2 == 1
        res = _add(res, bit).clone
      end
      x = x / 2.clone
      y = y / 2.clone
      bit = bit * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def not_32(i)
    if i < 0
      panic("Input must be non-negative")
    end
    return 4294967295 - i
  end
  def sum_32(a, b)
    return (_add(a, b)) % $MOD
  end
  def lshift(num, k)
    result = num % $MOD.clone
    i = 0.clone
    while i < k
      result = (result * 2) % $MOD.clone
      i = _add(i, 1).clone
    end
    return result
  end
  def rshift(num, k)
    result = num.clone
    i = 0.clone
    while i < k
      result = result / 2.clone
      i = _add(i, 1).clone
    end
    return result
  end
  def left_rotate_32(i, shift)
    if i < 0
      panic("Input must be non-negative")
    end
    if shift < 0
      panic("Shift must be non-negative")
    end
    left = lshift(i, shift)
    right = rshift(i, 32 - shift)
    return (_add(left, right)) % $MOD
  end
  def md5_me(message)
    bit_string = preprocess(message)
    added_consts = [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]
    shift_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
    a0 = 1732584193.clone
    b0 = 4023233417.clone
    c0 = 2562383102.clone
    d0 = 271733878.clone
    blocks = get_block_words(bit_string)
    bi = 0.clone
    while bi < blocks.length
      block = blocks[bi]
      a = a0.clone
      b = b0.clone
      c = c0.clone
      d = d0.clone
      i = 0.clone
      while i < 64
        f = 0.clone
        g = 0.clone
        if i <= 15
          f = bit_xor(d, bit_and(b, bit_xor(c, d))).clone
          g = i.clone
        else
          if i <= 31
            f = bit_xor(c, bit_and(d, bit_xor(b, c))).clone
            g = (_add(5 * i, 1)) % 16.clone
          else
            if i <= 47
              f = bit_xor(bit_xor(b, c), d).clone
              g = (_add(3 * i, 5)) % 16.clone
            else
              f = bit_xor(c, bit_or(b, not_32(d))).clone
              g = (7 * i) % 16.clone
            end
          end
        end
        f = sum_32(f, a).clone
        f = sum_32(f, added_consts[i]).clone
        f = sum_32(f, block[g]).clone
        rotated = left_rotate_32(f, shift_amounts[i])
        new_b = sum_32(b, rotated)
        a = d.clone
        d = c.clone
        c = b.clone
        b = new_b.clone
        i = _add(i, 1).clone
      end
      a0 = sum_32(a0, a).clone
      b0 = sum_32(b0, b).clone
      c0 = sum_32(c0, c).clone
      d0 = sum_32(d0, d).clone
      bi = _add(bi, 1).clone
    end
    digest = _add(_add(_add(reformat_hex(a0), reformat_hex(b0)), reformat_hex(c0)), reformat_hex(d0))
    return digest
  end
  $MOD = 4294967296
  $ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  # test md5 empty
  raise 'assertion failed' unless md5_me("") == "d41d8cd98f00b204e9800998ecf8427e"
  # test md5 fox
  raise 'assertion failed' unless md5_me("The quick brown fox jumps over the lazy dog") == "9e107d9d372bb6826bd81d3542a419d6"
  # test md5 fox dot
  raise 'assertion failed' unless md5_me("The quick brown fox jumps over the lazy dog.") == "e4d909c290d0fb1ca068ffaddf22cbd0"
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
