# Generated by Mochi transpiler v0.10.66 on 2025-08-15 09:59 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  x = x.clone if x.is_a?(Array)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def ord(ch)
    i = 0
    while i < _len($ASCII)
      if _eq($ASCII[i..._add(i, 1)], ch)
        return _add(32, i)
      end
      i = _add(i, 1)
    end
    return 0
  end
  def to_little_endian(s)
    if !_eq(_len(s), 32)
      panic("Input must be of length 32")
    end
    return _add(_add(_add(s[24...32], s[16...24]), s[8...16]), s[0...8])
  end
  def int_to_bits(n, width)
    bits = ""
    num = n
    while num > 0
      bits = _add(_str(num % 2), bits)
      num = num / 2
    end
    while _len(bits) < width
      bits = _add("0", bits)
    end
    if _len(bits) > width
      bits = bits[_len(bits) - width..._len(bits)]
    end
    return bits
  end
  def bits_to_int(bits)
    num = 0
    i = 0
    while i < _len(bits)
      if _eq(bits[i..._add(i, 1)], "1")
        num = _add(num * 2, 1)
      else
        num = num * 2
      end
      i = _add(i, 1)
    end
    return num
  end
  def to_hex(n)
    digits = "0123456789abcdef"
    if _eq(n, 0)
      return "0"
    end
    num = n
    s = ""
    while num > 0
      d = num % 16
      s = _add(digits[d..._add(d, 1)], s)
      num = num / 16
    end
    return s
  end
  def reformat_hex(i)
    if i < 0
      panic("Input must be non-negative")
    end
    hex = to_hex(i)
    while _len(hex) < 8
      hex = _add("0", hex)
    end
    if _len(hex) > 8
      hex = hex[_len(hex) - 8..._len(hex)]
    end
    le = ""
    j = _len(hex) - 2
    while j >= 0
      le = _add(le, hex[j..._add(j, 2)])
      j = j - 2
    end
    return le
  end
  def preprocess(message)
    bit_string = ""
    i = 0
    while i < _len(message)
      ch = message[i..._add(i, 1)]
      bit_string = _add(bit_string, int_to_bits(ord(ch), 8))
      i = _add(i, 1)
    end
    start_len = int_to_bits(_len(bit_string), 64)
    bit_string = _add(bit_string, "1")
    while !_eq(_len(bit_string) % 512, 448)
      bit_string = _add(bit_string, "0")
    end
    bit_string = _add(_add(bit_string, to_little_endian(start_len[32...64])), to_little_endian(start_len[0...32]))
    return bit_string
  end
  def get_block_words(bit_string)
    if !_eq(_len(bit_string) % 512, 0)
      panic("Input must have length that's a multiple of 512")
    end
    blocks = []
    pos = 0
    while pos < _len(bit_string)
      block = []
      i = 0
      while i < 512
        part = bit_string[_add(pos, i)..._add(_add(pos, i), 32)]
        word = bits_to_int(to_little_endian(part))
        block = _append(block, word)
        i = _add(i, 32)
      end
      blocks = _append(blocks, block)
      pos = _add(pos, 512)
    end
    return blocks
  end
  def bit_and(a, b)
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32
      if (_eq(x % 2, 1)) && (_eq(y % 2, 1))
        res = _add(res, bit)
      end
      x = x / 2
      y = y / 2
      bit = bit * 2
      i = _add(i, 1)
    end
    return res
  end
  def bit_or(a, b)
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32
      abit = x % 2
      bbit = y % 2
      if _eq(abit, 1) || _eq(bbit, 1)
        res = _add(res, bit)
      end
      x = x / 2
      y = y / 2
      bit = bit * 2
      i = _add(i, 1)
    end
    return res
  end
  def bit_xor(a, b)
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32
      abit = x % 2
      bbit = y % 2
      if _eq((_add(abit, bbit)) % 2, 1)
        res = _add(res, bit)
      end
      x = x / 2
      y = y / 2
      bit = bit * 2
      i = _add(i, 1)
    end
    return res
  end
  def not_32(i)
    if i < 0
      panic("Input must be non-negative")
    end
    return 4294967295 - i
  end
  def sum_32(a, b)
    return (_add(a, b)) % $MOD
  end
  def lshift(num, k)
    result = num % $MOD
    i = 0
    while i < k
      result = (result * 2) % $MOD
      i = _add(i, 1)
    end
    return result
  end
  def rshift(num, k)
    result = num
    i = 0
    while i < k
      result = result / 2
      i = _add(i, 1)
    end
    return result
  end
  def left_rotate_32(i, shift)
    if i < 0
      panic("Input must be non-negative")
    end
    if shift < 0
      panic("Shift must be non-negative")
    end
    left = lshift(i, shift)
    right = rshift(i, 32 - shift)
    return (_add(left, right)) % $MOD
  end
  def md5_me(message)
    bit_string = preprocess(message)
    added_consts = [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]
    shift_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
    a0 = 1732584193
    b0 = 4023233417
    c0 = 2562383102
    d0 = 271733878
    blocks = get_block_words(bit_string)
    bi = 0
    while bi < _len(blocks)
      block = (__tmp1 = blocks; __tmp1.is_a?(Hash) ? __tmp1[bi] : _idx(__tmp1, bi))
      a = a0
      b = b0
      c = c0
      d = d0
      i = 0
      while i < 64
        f = 0
        g = 0
        if i <= 15
          f = bit_xor(d, bit_and(b, bit_xor(c, d)))
          g = i
        else
          if i <= 31
            f = bit_xor(c, bit_and(d, bit_xor(b, c)))
            g = (_add(5 * i, 1)) % 16
          else
            if i <= 47
              f = bit_xor(bit_xor(b, c), d)
              g = (_add(3 * i, 5)) % 16
            else
              f = bit_xor(c, bit_or(b, not_32(d)))
              g = (7 * i) % 16
            end
          end
        end
        f = sum_32(f, a)
        f = sum_32(f, (__tmp2 = added_consts; __tmp2.is_a?(Hash) ? __tmp2[i] : _idx(__tmp2, i)))
        f = sum_32(f, (__tmp3 = block; __tmp3.is_a?(Hash) ? __tmp3[g] : _idx(__tmp3, g)))
        rotated = left_rotate_32(f, (__tmp4 = shift_amounts; __tmp4.is_a?(Hash) ? __tmp4[i] : _idx(__tmp4, i)))
        new_b = sum_32(b, rotated)
        a = d
        d = c
        c = b
        b = new_b
        i = _add(i, 1)
      end
      a0 = sum_32(a0, a)
      b0 = sum_32(b0, b)
      c0 = sum_32(c0, c)
      d0 = sum_32(d0, d)
      bi = _add(bi, 1)
    end
    digest = _add(_add(_add(reformat_hex(a0), reformat_hex(b0)), reformat_hex(c0)), reformat_hex(d0))
    return digest
  end
  $MOD = 4294967296
  $ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  # test md5 empty
  raise 'assertion failed' unless _eq(md5_me(""), "d41d8cd98f00b204e9800998ecf8427e")
  # test md5 fox
  raise 'assertion failed' unless _eq(md5_me("The quick brown fox jumps over the lazy dog"), "9e107d9d372bb6826bd81d3542a419d6")
  # test md5 fox dot
  raise 'assertion failed' unless _eq(md5_me("The quick brown fox jumps over the lazy dog."), "e4d909c290d0fb1ca068ffaddf22cbd0")
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
