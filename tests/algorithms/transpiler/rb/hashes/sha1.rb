# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def ord(ch)
    i = 0.clone
    while i < $ASCII.length
      if $ASCII[i..._add(i, 1)] == ch
        return _add(32, i)
      end
      i = _add(i, 1).clone
    end
    return 0
  end
  def pow2(n)
    res = 1.clone
    i = 0.clone
    while i < n
      res = res * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def bit_and(a, b)
    x = a.clone
    y = b.clone
    res = 0.clone
    bit = 1.clone
    i = 0.clone
    while i < 32
      if (x % 2 == 1) && (y % 2 == 1)
        res = _add(res, bit).clone
      end
      x = x / 2.clone
      y = y / 2.clone
      bit = bit * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def bit_or(a, b)
    x = a.clone
    y = b.clone
    res = 0.clone
    bit = 1.clone
    i = 0.clone
    while i < 32
      abit = x % 2
      bbit = y % 2
      if abit == 1 || bbit == 1
        res = _add(res, bit).clone
      end
      x = x / 2.clone
      y = y / 2.clone
      bit = bit * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def bit_xor(a, b)
    x = a.clone
    y = b.clone
    res = 0.clone
    bit = 1.clone
    i = 0.clone
    while i < 32
      abit = x % 2
      bbit = y % 2
      if (abit == 1 && bbit == 0) || (abit == 0 && bbit == 1)
        res = _add(res, bit).clone
      end
      x = x / 2.clone
      y = y / 2.clone
      bit = bit * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def bit_not(a)
    return ($MOD - 1) - a
  end
  def rotate_left(n, b)
    left = (n * pow2(b)) % $MOD
    right = n / pow2(32 - b)
    return (_add(left, right)) % $MOD
  end
  def to_hex32(n)
    digits = "0123456789abcdef"
    num = n.clone
    s = "".clone
    if num == 0
      s = "0".clone
    end
    while num > 0
      d = num % 16
      s = _add(digits[d..._add(d, 1)], s).clone
      num = num / 16.clone
    end
    while s.length < 8
      s = _add("0", s).clone
    end
    if s.length > 8
      s = s[s.length - 8...s.length].clone
    end
    return s
  end
  def sha1(message)
    bytes = [].clone
    i = 0.clone
    while i < message.length
      bytes = (bytes << (ord(message[i..._add(i, 1)]))).clone
      i = _add(i, 1).clone
    end
    bytes = (bytes << (128)).clone
    while (_add(bytes.length, 8)) % 64 != 0
      bytes = (bytes << (0)).clone
    end
    bit_len = message.length * 8
    len_bytes = [0, 0, 0, 0, 0, 0, 0, 0].clone
    bl = bit_len.clone
    k = 7.clone
    while k >= 0
      len_bytes[k] = bl % 256
      bl = bl / 256.clone
      k = k - 1.clone
    end
    j = 0.clone
    while j < 8
      bytes = (bytes << (len_bytes[j])).clone
      j = _add(j, 1).clone
    end
    blocks = [].clone
    pos = 0.clone
    while pos < bytes.length
      block = [].clone
      j2 = 0.clone
      while j2 < 64
        block = (block << (bytes[_add(pos, j2)])).clone
        j2 = _add(j2, 1).clone
      end
      blocks = (blocks << (block)).clone
      pos = _add(pos, 64).clone
    end
    h0 = 1732584193.clone
    h1 = 4023233417.clone
    h2 = 2562383102.clone
    h3 = 271733878.clone
    h4 = 3285377520.clone
    bindex = 0.clone
    while bindex < blocks.length
      block = blocks[bindex]
      w = [].clone
      t = 0.clone
      while t < 16
        j3 = t * 4
        word = (_add((_add((_add(block[j3] * 256, block[_add(j3, 1)])) * 256, block[_add(j3, 2)])) * 256, block[_add(j3, 3)]))
        w = (w << (word)).clone
        t = _add(t, 1).clone
      end
      while t < 80
        tmp = bit_xor(bit_xor(bit_xor(w[t - 3], w[t - 8]), w[t - 14]), w[t - 16])
        w = (w << (rotate_left(tmp, 1))).clone
        t = _add(t, 1).clone
      end
      a = h0.clone
      b = h1.clone
      c = h2.clone
      d = h3.clone
      e = h4.clone
      i2 = 0.clone
      while i2 < 80
        f = 0.clone
        kconst = 0.clone
        if i2 < 20
          f = bit_or(bit_and(b, c), bit_and(bit_not(b), d)).clone
          kconst = 1518500249.clone
        else
          if i2 < 40
            f = bit_xor(bit_xor(b, c), d).clone
            kconst = 1859775393.clone
          else
            if i2 < 60
              f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d)).clone
              kconst = 2400959708.clone
            else
              f = bit_xor(bit_xor(b, c), d).clone
              kconst = 3395469782.clone
            end
          end
        end
        temp = (_add(_add(_add(_add(rotate_left(a, 5), f), e), kconst), w[i2])) % $MOD
        e = d.clone
        d = c.clone
        c = rotate_left(b, 30).clone
        b = a.clone
        a = temp.clone
        i2 = _add(i2, 1).clone
      end
      h0 = (_add(h0, a)) % $MOD.clone
      h1 = (_add(h1, b)) % $MOD.clone
      h2 = (_add(h2, c)) % $MOD.clone
      h3 = (_add(h3, d)) % $MOD.clone
      h4 = (_add(h4, e)) % $MOD.clone
      bindex = _add(bindex, 1).clone
    end
    return _add(_add(_add(_add(to_hex32(h0), to_hex32(h1)), to_hex32(h2)), to_hex32(h3)), to_hex32(h4))
  end
  def main()
    puts(sha1("Test String"))
  end
  $MOD = 4294967296
  $ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
