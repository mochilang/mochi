# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def index_of(s, ch)
    i = 0.clone
    while i < s.length
      if s[i] == ch
        return i
      end
      i = _add(i, 1).clone
    end
    return -1
  end
  def ord(ch)
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    idx = index_of(upper, ch).clone
    if idx >= 0
      return _add(65, idx)
    end
    idx = index_of(lower, ch).clone
    if idx >= 0
      return _add(97, idx)
    end
    return 0
  end
  def chr(n)
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    if n >= 65 && n < 91
      return upper[n - 65...n - 64]
    end
    if n >= 97 && n < 123
      return lower[n - 97...n - 96]
    end
    return "?"
  end
  def text_to_bits(text)
    bits = "".clone
    i = 0.clone
    while i < text.length
      code = ord(text[i])
      j = 7.clone
      while j >= 0
        p = pow2(j)
        if ((code / p) % 2) == 1
          bits = _add(bits, "1").clone
        else
          bits = _add(bits, "0").clone
        end
        j = j - 1.clone
      end
      i = _add(i, 1).clone
    end
    return bits
  end
  def text_from_bits(bits)
    text = "".clone
    i = 0.clone
    while i < bits.length
      code = 0.clone
      j = 0.clone
      while j < 8 && _add(i, j) < bits.length
        code = code * 2.clone
        if bits[_add(i, j)] == "1"
          code = _add(code, 1).clone
        end
        j = _add(j, 1).clone
      end
      text = _add(text, chr(code)).clone
      i = _add(i, 8).clone
    end
    return text
  end
  def bool_to_string(b)
    if b
      return "True"
    end
    return "False"
  end
  def string_to_bitlist(s)
    res = [].clone
    i = 0.clone
    while i < s.length
      if s[i] == "1"
        res = (res << (1)).clone
      else
        res = (res << (0)).clone
      end
      i = _add(i, 1).clone
    end
    return res
  end
  def bitlist_to_string(bits)
    s = "".clone
    i = 0.clone
    while i < bits.length
      if bits[i] == 1
        s = _add(s, "1").clone
      else
        s = _add(s, "0").clone
      end
      i = _add(i, 1).clone
    end
    return s
  end
  def is_power_of_two(x)
    if x < 1
      return false
    end
    p = 1.clone
    while p < x
      p = p * 2.clone
    end
    return p == x
  end
  def list_eq(a, b)
    if a.length != b.length
      return false
    end
    i = 0.clone
    while i < a.length
      if a[i] != b[i]
        return false
      end
      i = _add(i, 1).clone
    end
    return true
  end
  def pow2(e)
    res = 1.clone
    i = 0.clone
    while i < e
      res = res * 2.clone
      i = _add(i, 1).clone
    end
    return res
  end
  def has_bit(n, b)
    p = pow2(b)
    if ((n / p) % 2) == 1
      return true
    end
    return false
  end
  def hamming_encode(r, data_bits)
    total = _add(r, data_bits.length)
    data_ord = [].clone
    cont_data = 0.clone
    x = 1.clone
    while x <= total
      if is_power_of_two(x)
        data_ord = (data_ord << (-1)).clone
      else
        data_ord = (data_ord << (data_bits[cont_data])).clone
        cont_data = _add(cont_data, 1).clone
      end
      x = _add(x, 1).clone
    end
    parity = [].clone
    bp = 0.clone
    while bp < r
      cont_bo = 0.clone
      j = 0.clone
      while j < data_ord.length
        bit = data_ord[j]
        if bit >= 0
          pos = _add(j, 1)
          if has_bit(pos, bp) && bit == 1
            cont_bo = _add(cont_bo, 1).clone
          end
        end
        j = _add(j, 1).clone
      end
      parity = (parity << (cont_bo % 2)).clone
      bp = _add(bp, 1).clone
    end
    result = [].clone
    cont_bp = 0.clone
    i = 0.clone
    while i < data_ord.length
      if data_ord[i] < 0
        result = (result << (parity[cont_bp])).clone
        cont_bp = _add(cont_bp, 1).clone
      else
        result = (result << (data_ord[i])).clone
      end
      i = _add(i, 1).clone
    end
    return result
  end
  def hamming_decode(r, code)
    data_output = [].clone
    parity_received = [].clone
    i = 1.clone
    idx = 0.clone
    while i <= code.length
      if is_power_of_two(i)
        parity_received = (parity_received << (code[idx])).clone
      else
        data_output = (data_output << (code[idx])).clone
      end
      idx = _add(idx, 1).clone
      i = _add(i, 1).clone
    end
    recomputed = hamming_encode(r, data_output)
    parity_calc = [].clone
    j = 0.clone
    while j < recomputed.length
      if is_power_of_two(_add(j, 1))
        parity_calc = (parity_calc << (recomputed[j])).clone
      end
      j = _add(j, 1).clone
    end
    ack = list_eq(parity_received, parity_calc)
    return DecodeResult.new(data: data_output, ack: ack)
  end
  def main()
    sizePari = 4
    be = 2
    text = "Message01"
    binary = text_to_bits(text)
    puts(_add(_add("Text input in binary is '", binary), "'"))
    data_bits = string_to_bitlist(binary)
    encoded = hamming_encode(sizePari, data_bits)
    puts(_add("Data converted ----------> ", bitlist_to_string(encoded)))
    decoded = hamming_decode(sizePari, encoded)
    puts(_add(_add(_add("Data receive ------------> ", bitlist_to_string(decoded.data)), " -- Data integrity: "), bool_to_string(decoded.ack)))
    corrupted = [].clone
    i = 0.clone
    while i < encoded.length
      corrupted = (corrupted << (encoded[i])).clone
      i = _add(i, 1).clone
    end
    pos = be - 1
    if corrupted[pos] == 0
      corrupted[pos] = 1
    else
      corrupted[pos] = 0
    end
    decoded_err = hamming_decode(sizePari, corrupted)
    puts(_add(_add(_add("Data receive (error) ----> ", bitlist_to_string(decoded_err.data)), " -- Data integrity: "), bool_to_string(decoded_err.ack)))
  end
  DecodeResult = Struct.new(:data, :ack, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
