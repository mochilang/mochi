# Generated by Mochi transpiler v0.10.59 on 2025-08-07 09:52 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

start_mem = _mem()
start = _now()
  def make_process(name, arrival, burst)
    return Process.new(process_name: name, arrival_time: arrival, stop_time: arrival, burst_time: burst, waiting_time: 0, turnaround_time: 0)
  end
  def make_mlfq(nqueues, time_slices, queue, current_time)
    return MLFQ.new(number_of_queues: nqueues, time_slices: time_slices, ready_queue: queue, current_time: current_time, finish_queue: [])
  end
  def calculate_sequence_of_finish_queue(mlfq)
    seq = [].clone
    i = 0.clone
    while i < mlfq.finish_queue.length
      p = mlfq.finish_queue[i]
      seq = (seq << (p.process_name)).clone
      i = _add(i, 1).clone
    end
    return seq
  end
  def calculate_waiting_time(queue)
    times = [].clone
    i = 0.clone
    while i < queue.length
      p = queue[i]
      times = (times << (p.waiting_time)).clone
      i = _add(i, 1).clone
    end
    return times
  end
  def calculate_turnaround_time(queue)
    times = [].clone
    i = 0.clone
    while i < queue.length
      p = queue[i]
      times = (times << (p.turnaround_time)).clone
      i = _add(i, 1).clone
    end
    return times
  end
  def calculate_completion_time(queue)
    times = [].clone
    i = 0.clone
    while i < queue.length
      p = queue[i]
      times = (times << (p.stop_time)).clone
      i = _add(i, 1).clone
    end
    return times
  end
  def calculate_remaining_burst_time_of_processes(queue)
    times = [].clone
    i = 0.clone
    while i < queue.length
      p = queue[i]
      times = (times << (p.burst_time)).clone
      i = _add(i, 1).clone
    end
    return times
  end
  def update_waiting_time(mlfq, process)
    process["waiting_time"] = _add(process.waiting_time, (mlfq.current_time - process.stop_time))
    return process.waiting_time
  end
  def first_come_first_served(mlfq, ready_queue)
    finished = [].clone
    rq = ready_queue.clone
    while rq.length != 0
      cp = rq[0]
      rq = rq[1...rq.length].clone
      if mlfq.current_time < cp.arrival_time
        mlfq["current_time"] = cp.arrival_time
      end
      update_waiting_time(mlfq, cp)
      mlfq["current_time"] = _add(mlfq.current_time, cp.burst_time)
      cp["burst_time"] = 0
      cp["turnaround_time"] = mlfq.current_time - cp.arrival_time
      cp["stop_time"] = mlfq.current_time
      finished = (finished << (cp)).clone
    end
    mlfq["finish_queue"] = _add(mlfq.finish_queue, finished)
    return finished
  end
  def round_robin(mlfq, ready_queue, time_slice)
    finished = [].clone
    rq = ready_queue.clone
    count = rq.length.clone
    i = 0.clone
    while i < count
      cp = rq[0]
      rq = rq[1...rq.length].clone
      if mlfq.current_time < cp.arrival_time
        mlfq["current_time"] = cp.arrival_time
      end
      update_waiting_time(mlfq, cp)
      if cp.burst_time > time_slice
        mlfq["current_time"] = _add(mlfq.current_time, time_slice)
        cp["burst_time"] = cp.burst_time - time_slice
        cp["stop_time"] = mlfq.current_time
        rq = (rq << (cp)).clone
      else
        mlfq["current_time"] = _add(mlfq.current_time, cp.burst_time)
        cp["burst_time"] = 0
        cp["stop_time"] = mlfq.current_time
        cp["turnaround_time"] = mlfq.current_time - cp.arrival_time
        finished = (finished << (cp)).clone
      end
      i = _add(i, 1).clone
    end
    mlfq["finish_queue"] = _add(mlfq.finish_queue, finished)
    return RRResult.new(finished: finished, ready: rq)
  end
  def multi_level_feedback_queue(mlfq)
    i = 0.clone
    while i < mlfq.number_of_queues - 1
      rr = round_robin(mlfq, mlfq.ready_queue, mlfq.time_slices[i])
      mlfq["ready_queue"] = rr.ready
      i = _add(i, 1).clone
    end
    first_come_first_served(mlfq, mlfq.ready_queue)
    return mlfq.finish_queue
  end
  Process = Struct.new(:process_name, :arrival_time, :stop_time, :burst_time, :waiting_time, :turnaround_time, keyword_init: true)
  MLFQ = Struct.new(:number_of_queues, :time_slices, :ready_queue, :current_time, :finish_queue, keyword_init: true)
  RRResult = Struct.new(:finished, :ready, keyword_init: true)
  $P1 = make_process("P1", 0, 53)
  $P2 = make_process("P2", 0, 17)
  $P3 = make_process("P3", 0, 68)
  $P4 = make_process("P4", 0, 24)
  $number_of_queues = 3
  $time_slices = [17, 25]
  $queue = [$P1, $P2, $P3, $P4]
  $mlfq = make_mlfq($number_of_queues, $time_slices, $queue, 0)
  $finish_queue = multi_level_feedback_queue($mlfq)
  puts(_add("waiting time:\t\t\t", ((x = calculate_waiting_time([$P1, $P2, $P3, $P4])); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
  puts(_add("completion time:\t\t", ((x = calculate_completion_time([$P1, $P2, $P3, $P4])); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
  puts(_add("turnaround time:\t\t", ((x = calculate_turnaround_time([$P1, $P2, $P3, $P4])); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
  puts(_add("sequence of finished processes:\t", ((x = calculate_sequence_of_finish_queue($mlfq)); x.is_a?(Array) ? ("[" + x.map{ |x| if x.is_a?(Hash) then '{' + x.to_h.map{ |k,v| "#{k}: #{v.is_a?(String) ? v : v.to_s}" }.join(', ') + '}' else x.to_s end }.join(' ') + "]") : x.to_s)))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
