# Generated by Mochi transpiler v0.10.65 on 2025-08-14 16:33 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def int_to_string(n)
    if _eq(n, 0)
      return "0"
    end
    num = n
    neg = false
    if num < 0
      neg = true
      num = -num
    end
    res = ""
    while num > 0
      digit = num % 10
      ch = "0123456789"[digit..._add(digit, 1)]
      res = _add(ch, res)
      num = num / 10
    end
    if neg
      res = _add("-", res)
    end
    return res
  end
  def float_to_string(x, dec)
    neg = false
    num = x
    if num < 0.0
      neg = true
      num = -num
    end
    int_part = (num).to_i
    res = int_to_string(int_part)
    if dec > 0
      res = _add(res, ".")
      frac = num - ((int_part).to_f)
      i = 0
      while i < dec
        frac = frac * 10.0
        digit = (frac).to_i
        res = _add(res, "0123456789"[digit..._add(digit, 1)])
        frac = frac - ((digit).to_f)
        i = _add(i, 1)
      end
    end
    if neg
      res = _add("-", res)
    end
    return res
  end
  def vector_component(v, i)
    return (__tmp1 = v; __tmp1.is_a?(Hash) ? __tmp1[i] : _idx(__tmp1, i))
  end
  def vector_str_int(v)
    s = "("
    i = 0
    while i < _len(v)
      s = _add(s, int_to_string((__tmp2 = v; __tmp2.is_a?(Hash) ? __tmp2[i] : _idx(__tmp2, i))))
      if _add(i, 1) < _len(v)
        s = _add(s, ",")
      end
      i = _add(i, 1)
    end
    s = _add(s, ")")
    return s
  end
  def vector_str_float(v, dec)
    s = "("
    i = 0
    while i < _len(v)
      s = _add(s, float_to_string((__tmp3 = v; __tmp3.is_a?(Hash) ? __tmp3[i] : _idx(__tmp3, i)), dec))
      if _add(i, 1) < _len(v)
        s = _add(s, ",")
      end
      i = _add(i, 1)
    end
    s = _add(s, ")")
    return s
  end
  def vector_add(a, b)
    res = []
    i = 0
    while i < _len(a)
      res = _append(res, _add((__tmp4 = a; __tmp4.is_a?(Hash) ? __tmp4[i] : _idx(__tmp4, i)), (__tmp5 = b; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i))))
      i = _add(i, 1)
    end
    return res
  end
  def vector_sub(a, b)
    res = []
    i = 0
    while i < _len(a)
      res = _append(res, (__tmp6 = a; __tmp6.is_a?(Hash) ? __tmp6[i] : _idx(__tmp6, i)) - (__tmp7 = b; __tmp7.is_a?(Hash) ? __tmp7[i] : _idx(__tmp7, i)))
      i = _add(i, 1)
    end
    return res
  end
  def vector_scalar_mul(v, s)
    res = []
    i = 0
    while i < _len(v)
      res = _append(res, (((__tmp8 = v; __tmp8.is_a?(Hash) ? __tmp8[i] : _idx(__tmp8, i))).to_f) * s)
      i = _add(i, 1)
    end
    return res
  end
  def vector_dot(a, b)
    sum = 0
    i = 0
    while i < _len(a)
      sum = _add(sum, (__tmp9 = a; __tmp9.is_a?(Hash) ? __tmp9[i] : _idx(__tmp9, i)) * (__tmp10 = b; __tmp10.is_a?(Hash) ? __tmp10[i] : _idx(__tmp10, i)))
      i = _add(i, 1)
    end
    return sum
  end
  def sqrt_newton(x)
    if _eq(x, 0.0)
      return 0.0
    end
    low = 0.0
    high = x
    if x < 1.0
      high = 1.0
    end
    mid = 0.0
    i = 0
    while i < 40
      mid = (_add(low, high)) / 2.0
      if mid * mid > x
        high = mid
      else
        low = mid
      end
      i = _add(i, 1)
    end
    return mid
  end
  def euclidean_length(v)
    sum = 0.0
    i = 0
    while i < _len(v)
      val = ((__tmp11 = v; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i))).to_f
      sum = _add(sum, val * val)
      i = _add(i, 1)
    end
    return sqrt_newton(sum)
  end
  def zero_vector(n)
    v = []
    i = 0
    while i < n
      v = _append(v, 0)
      i = _add(i, 1)
    end
    return v
  end
  def unit_basis_vector(n, idx)
    v = zero_vector(n)
    v[idx] = 1
    return v
  end
  def axpy(a, x, y)
    res = []
    i = 0
    while i < _len(x)
      res = _append(res, _add(a * (__tmp12 = x; __tmp12.is_a?(Hash) ? __tmp12[i] : _idx(__tmp12, i)), (__tmp13 = y; __tmp13.is_a?(Hash) ? __tmp13[i] : _idx(__tmp13, i))))
      i = _add(i, 1)
    end
    return res
  end
  def copy_vector(x)
    res = []
    i = 0
    while i < _len(x)
      res = _append(res, (__tmp14 = x; __tmp14.is_a?(Hash) ? __tmp14[i] : _idx(__tmp14, i)))
      i = _add(i, 1)
    end
    return res
  end
  def change_component(v, idx, val)
    v[idx] = val
  end
  def matrix_str(m)
    s = ""
    i = 0
    while i < _len(m)
      s = _add(s, "|")
      j = 0
      while j < _len((__tmp15 = m; __tmp15.is_a?(Hash) ? __tmp15[0] : _idx(__tmp15, 0)))
        s = _add(s, int_to_string((__tmp16 = (__tmp17 = m; __tmp17.is_a?(Hash) ? __tmp17[i] : _idx(__tmp17, i)); __tmp16.is_a?(Hash) ? __tmp16[j] : _idx(__tmp16, j))))
        if _add(j, 1) < _len((__tmp18 = m; __tmp18.is_a?(Hash) ? __tmp18[0] : _idx(__tmp18, 0)))
          s = _add(s, ",")
        end
        j = _add(j, 1)
      end
      s = _add(s, "|\n")
      i = _add(i, 1)
    end
    return s
  end
  def submatrix(m, row, col)
    res = []
    i = 0
    while i < _len(m)
      if !_eq(i, row)
        r = []
        j = 0
        while j < _len((__tmp19 = m; __tmp19.is_a?(Hash) ? __tmp19[0] : _idx(__tmp19, 0)))
          if !_eq(j, col)
            r = _append(r, (__tmp20 = (__tmp21 = m; __tmp21.is_a?(Hash) ? __tmp21[i] : _idx(__tmp21, i)); __tmp20.is_a?(Hash) ? __tmp20[j] : _idx(__tmp20, j)))
          end
          j = _add(j, 1)
        end
        res = _append(res, r)
      end
      i = _add(i, 1)
    end
    return res
  end
  def determinant(m)
    n = _len(m)
    if _eq(n, 1)
      return (__tmp22 = (__tmp23 = m; __tmp23.is_a?(Hash) ? __tmp23[0] : _idx(__tmp23, 0)); __tmp22.is_a?(Hash) ? __tmp22[0] : _idx(__tmp22, 0))
    end
    if _eq(n, 2)
      return (__tmp24 = (__tmp25 = m; __tmp25.is_a?(Hash) ? __tmp25[0] : _idx(__tmp25, 0)); __tmp24.is_a?(Hash) ? __tmp24[0] : _idx(__tmp24, 0)) * (__tmp26 = (__tmp27 = m; __tmp27.is_a?(Hash) ? __tmp27[1] : _idx(__tmp27, 1)); __tmp26.is_a?(Hash) ? __tmp26[1] : _idx(__tmp26, 1)) - (__tmp28 = (__tmp29 = m; __tmp29.is_a?(Hash) ? __tmp29[0] : _idx(__tmp29, 0)); __tmp28.is_a?(Hash) ? __tmp28[1] : _idx(__tmp28, 1)) * (__tmp30 = (__tmp31 = m; __tmp31.is_a?(Hash) ? __tmp31[1] : _idx(__tmp31, 1)); __tmp30.is_a?(Hash) ? __tmp30[0] : _idx(__tmp30, 0))
    end
    det = 0
    c = 0
    while c < n
      sub = submatrix(m, 0, c)
      sign = 1
      if _eq(c % 2, 1)
        sign = -1
      end
      det = _add(det, sign * (__tmp32 = (__tmp33 = m; __tmp33.is_a?(Hash) ? __tmp33[0] : _idx(__tmp33, 0)); __tmp32.is_a?(Hash) ? __tmp32[c] : _idx(__tmp32, c)) * determinant(sub))
      c = _add(c, 1)
    end
    return det
  end
  def matrix_minor(m, row, col)
    return determinant(submatrix(m, row, col))
  end
  def matrix_cofactor(m, row, col)
    sign = 1
    if _eq((_add(row, col)) % 2, 1)
      sign = -1
    end
    return sign * matrix_minor(m, row, col)
  end
  def matrix_mul_vector(m, v)
    res = []
    i = 0
    while i < _len(m)
      sum = 0
      j = 0
      while j < _len((__tmp34 = m; __tmp34.is_a?(Hash) ? __tmp34[0] : _idx(__tmp34, 0)))
        sum = _add(sum, (__tmp35 = (__tmp36 = m; __tmp36.is_a?(Hash) ? __tmp36[i] : _idx(__tmp36, i)); __tmp35.is_a?(Hash) ? __tmp35[j] : _idx(__tmp35, j)) * (__tmp37 = v; __tmp37.is_a?(Hash) ? __tmp37[j] : _idx(__tmp37, j)))
        j = _add(j, 1)
      end
      res = _append(res, sum)
      i = _add(i, 1)
    end
    return res
  end
  def matrix_mul_scalar(m, s)
    res = []
    i = 0
    while i < _len(m)
      row = []
      j = 0
      while j < _len((__tmp38 = m; __tmp38.is_a?(Hash) ? __tmp38[0] : _idx(__tmp38, 0)))
        row = _append(row, (__tmp39 = (__tmp40 = m; __tmp40.is_a?(Hash) ? __tmp40[i] : _idx(__tmp40, i)); __tmp39.is_a?(Hash) ? __tmp39[j] : _idx(__tmp39, j)) * s)
        j = _add(j, 1)
      end
      res = _append(res, row)
      i = _add(i, 1)
    end
    return res
  end
  def matrix_change_component(m, i, j, val)
    (__tmp41 = m; __tmp41.is_a?(Hash) ? __tmp41[i] : _idx(__tmp41, i))[j] = val
  end
  def matrix_component(m, i, j)
    return (__tmp42 = (__tmp43 = m; __tmp43.is_a?(Hash) ? __tmp43[i] : _idx(__tmp43, i)); __tmp42.is_a?(Hash) ? __tmp42[j] : _idx(__tmp42, j))
  end
  def matrix_add(a, b)
    res = []
    i = 0
    while i < _len(a)
      row = []
      j = 0
      while j < _len((__tmp44 = a; __tmp44.is_a?(Hash) ? __tmp44[0] : _idx(__tmp44, 0)))
        row = _append(row, _add((__tmp45 = (__tmp46 = a; __tmp46.is_a?(Hash) ? __tmp46[i] : _idx(__tmp46, i)); __tmp45.is_a?(Hash) ? __tmp45[j] : _idx(__tmp45, j)), (__tmp47 = (__tmp48 = b; __tmp48.is_a?(Hash) ? __tmp48[i] : _idx(__tmp48, i)); __tmp47.is_a?(Hash) ? __tmp47[j] : _idx(__tmp47, j))))
        j = _add(j, 1)
      end
      res = _append(res, row)
      i = _add(i, 1)
    end
    return res
  end
  def matrix_sub(a, b)
    res = []
    i = 0
    while i < _len(a)
      row = []
      j = 0
      while j < _len((__tmp49 = a; __tmp49.is_a?(Hash) ? __tmp49[0] : _idx(__tmp49, 0)))
        row = _append(row, (__tmp50 = (__tmp51 = a; __tmp51.is_a?(Hash) ? __tmp51[i] : _idx(__tmp51, i)); __tmp50.is_a?(Hash) ? __tmp50[j] : _idx(__tmp50, j)) - (__tmp52 = (__tmp53 = b; __tmp53.is_a?(Hash) ? __tmp53[i] : _idx(__tmp53, i)); __tmp52.is_a?(Hash) ? __tmp52[j] : _idx(__tmp52, j)))
        j = _add(j, 1)
      end
      res = _append(res, row)
      i = _add(i, 1)
    end
    return res
  end
  def square_zero_matrix(n)
    m = []
    i = 0
    while i < n
      m = _append(m, zero_vector(n))
      i = _add(i, 1)
    end
    return m
  end
  def assert_int(name, actual, expected)
    if _eq(actual, expected)
      puts(_add(name, " ok"))
    else
      puts(_add(_add(_add(_add(name, " fail "), int_to_string(actual)), " != "), int_to_string(expected)))
    end
  end
  def assert_str(name, actual, expected)
    if _eq(actual, expected)
      puts(_add(name, " ok"))
    else
      puts(_add(name, " fail"))
      puts(actual)
      puts(expected)
    end
  end
  def assert_float(name, actual, expected, eps)
    diff = actual - expected
    if diff < 0.0
      diff = -diff
    end
    if diff <= eps
      puts(_add(name, " ok"))
    else
      puts(_add(name, " fail"))
    end
  end
  $vx = [1, 2, 3]
  assert_int("component0", vector_component($vx, 0), 1)
  assert_int("component2", vector_component($vx, 2), 3)
  $vs = [0, 0, 0, 0, 0, 1]
  assert_str("str_vector", vector_str_int($vs), "(0,0,0,0,0,1)")
  $vsize = [1, 2, 3, 4]
  assert_int("size", _len($vsize), 4)
  $va = [1, 2, 3]
  $vb = [1, 1, 1]
  $vsum = vector_add($va, $vb)
  assert_int("add0", vector_component($vsum, 0), 2)
  assert_int("add1", vector_component($vsum, 1), 3)
  assert_int("add2", vector_component($vsum, 2), 4)
  $vsub = vector_sub($va, $vb)
  assert_int("sub0", vector_component($vsub, 0), 0)
  assert_int("sub1", vector_component($vsub, 1), 1)
  assert_int("sub2", vector_component($vsub, 2), 2)
  $vmul = vector_scalar_mul($va, 3.0)
  assert_str("scalar_mul", vector_str_float($vmul, 1), "(3.0,6.0,9.0)")
  assert_int("dot_product", vector_dot([2, -1, 4], [1, -2, -1]), 0)
  $zvec = zero_vector(10)
  $zstr = vector_str_int($zvec)
  $zcount = 0
  $zi = 0
  while $zi < _len($zstr)
    if _eq($zstr[$zi..._add($zi, 1)], "0")
      $zcount = _add($zcount, 1)
    end
    $zi = _add($zi, 1)
  end
  assert_int("zero_vector", $zcount, 10)
  assert_str("unit_basis", vector_str_int(unit_basis_vector(3, 1)), "(0,1,0)")
  assert_str("axpy", vector_str_int(axpy(2, [1, 2, 3], [1, 0, 1])), "(3,4,7)")
  $vcopy = copy_vector([1, 0, 0, 0, 0, 0])
  assert_str("copy", vector_str_int($vcopy), "(1,0,0,0,0,0)")
  $vchange = [1, 0, 0]
  change_component($vchange, 0, 0)
  change_component($vchange, 1, 1)
  assert_str("change_component", vector_str_int($vchange), "(0,1,0)")
  $ma = [[1, 2, 3], [2, 4, 5], [6, 7, 8]]
  assert_str("matrix_str", matrix_str($ma), "|1,2,3|\n|2,4,5|\n|6,7,8|\n")
  assert_int("determinant", determinant($ma), -5)
  $mb = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  $mv = matrix_mul_vector($mb, [1, 2, 3])
  assert_str("matrix_vec_mul", vector_str_int($mv), "(14,32,50)")
  $msc = matrix_mul_scalar($mb, 2)
  assert_str("matrix_scalar_mul", matrix_str($msc), "|2,4,6|\n|8,10,12|\n|14,16,18|\n")
  $mc = [[1, 2, 3], [2, 4, 5], [6, 7, 8]]
  matrix_change_component($mc, 0, 2, 5)
  assert_str("change_component_matrix", matrix_str($mc), "|1,2,5|\n|2,4,5|\n|6,7,8|\n")
  assert_int("matrix_component", matrix_component($mc, 2, 1), 7)
  $madd = matrix_add([[1, 2, 3], [2, 4, 5], [6, 7, 8]], [[1, 2, 7], [2, 4, 5], [6, 7, 10]])
  assert_str("matrix_add", matrix_str($madd), "|2,4,10|\n|4,8,10|\n|12,14,18|\n")
  $msub = matrix_sub([[1, 2, 3], [2, 4, 5], [6, 7, 8]], [[1, 2, 7], [2, 4, 5], [6, 7, 10]])
  assert_str("matrix_sub", matrix_str($msub), "|0,0,-4|\n|0,0,0|\n|0,0,-2|\n")
  $mzero = square_zero_matrix(5)
  assert_str("square_zero_matrix", matrix_str($mzero), "|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n")
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
