# Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:14 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def rand()
    $seed = (_add($seed * 1103515245, 12345)) % 2147483648.clone
    return $seed
  end
  def random_int(a, b)
    r = rand() % (_add(b - a, 1))
    return _add(a, r)
  end
  def sqrtApprox(x)
    if x <= 0.0
      return 0.0
    end
    guess = x.clone
    i = 0.clone
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0.clone
      i = _add(i, 1).clone
    end
    return guess
  end
  def arcsin_taylor(x)
    term = x.clone
    sum = x.clone
    n = 1.clone
    while n < 10
      num = (2.0 * ((n).to_f) - 1.0) * (2.0 * ((n).to_f) - 1.0) * x * x * term
      den = (2.0 * ((n).to_f)) * (_add(2.0 * ((n).to_f), 1.0))
      term = num / den.clone
      sum = _add(sum, term).clone
      n = _add(n, 1).clone
    end
    return sum
  end
  def acos_taylor(x)
    return $PI / 2.0 - arcsin_taylor(x)
  end
  def vector_len(v)
    return v.components.length
  end
  def vector_to_string(v)
    s = "(".clone
    i = 0.clone
    while i < v.components.length
      s = _add(s, _str(v.components[i])).clone
      if i < v.components.length - 1
        s = _add(s, ",").clone
      end
      i = _add(i, 1).clone
    end
    s = _add(s, ")").clone
    return s
  end
  def vector_add(a, b)
    size = vector_len(a)
    if size != vector_len(b)
      return Vector.new(components: [])
    end
    res = [].clone
    i = 0.clone
    while i < size
      res = (res << (_add(a.components[i], b.components[i]))).clone
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def vector_sub(a, b)
    size = vector_len(a)
    if size != vector_len(b)
      return Vector.new(components: [])
    end
    res = [].clone
    i = 0.clone
    while i < size
      res = (res << (a.components[i] - b.components[i])).clone
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def vector_eq(a, b)
    if vector_len(a) != vector_len(b)
      return false
    end
    i = 0.clone
    while i < vector_len(a)
      if a.components[i] != b.components[i]
        return false
      end
      i = _add(i, 1).clone
    end
    return true
  end
  def vector_mul_scalar(v, s)
    res = [].clone
    i = 0.clone
    while i < vector_len(v)
      res = (res << (v.components[i] * s)).clone
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def vector_dot(a, b)
    size = vector_len(a)
    if size != vector_len(b)
      return 0.0
    end
    sum = 0.0.clone
    i = 0.clone
    while i < size
      sum = _add(sum, a.components[i] * b.components[i]).clone
      i = _add(i, 1).clone
    end
    return sum
  end
  def vector_copy(v)
    res = [].clone
    i = 0.clone
    while i < vector_len(v)
      res = (res << (v.components[i])).clone
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def vector_component(v, idx)
    return v.components[idx]
  end
  def vector_change_component(v, pos, value)
    comps = v.components.clone
    comps[pos] = value
    return Vector.new(components: comps)
  end
  def vector_euclidean_length(v)
    sum = 0.0.clone
    i = 0.clone
    while i < v.components.length
      sum = _add(sum, v.components[i] * v.components[i]).clone
      i = _add(i, 1).clone
    end
    result = sqrtApprox(sum).clone
    return result
  end
  def vector_angle(a, b, deg)
    num = vector_dot(a, b)
    den = vector_euclidean_length(a) * vector_euclidean_length(b)
    ang = acos_taylor(num / den).clone
    if deg
      ang = ang * 180.0 / $PI.clone
    end
    return ang
  end
  def zero_vector(d)
    res = [].clone
    i = 0.clone
    while i < d
      res = (res << (0.0)).clone
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def unit_basis_vector(d, pos)
    res = [].clone
    i = 0.clone
    while i < d
      if i == pos
        res = (res << (1.0)).clone
      else
        res = (res << (0.0)).clone
      end
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def axpy(s, x, y)
    return vector_add(vector_mul_scalar(x, s), y)
  end
  def random_vector(n, a, b)
    res = [].clone
    i = 0.clone
    while i < n
      res = (res << ((random_int(a, b)).to_f)).clone
      i = _add(i, 1).clone
    end
    return Vector.new(components: res)
  end
  def matrix_to_string(m)
    ans = "".clone
    i = 0.clone
    while i < m.height
      ans = _add(ans, "|").clone
      j = 0.clone
      while j < m.width
        ans = _add(ans, _str(m.data[i][j])).clone
        if j < m.width - 1
          ans = _add(ans, ",").clone
        end
        j = _add(j, 1).clone
      end
      ans = _add(ans, "|\n").clone
      i = _add(i, 1).clone
    end
    return ans
  end
  def matrix_add(a, b)
    if a.width != b.width || a.height != b.height
      return Matrix.new(data: [], width: 0, height: 0)
    end
    mat = [].clone
    i = 0.clone
    while i < a.height
      row = [].clone
      j = 0.clone
      while j < a.width
        row = (row << (_add(a.data[i][j], b.data[i][j]))).clone
        j = _add(j, 1).clone
      end
      mat = (mat << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: mat, width: a.width, height: a.height)
  end
  def matrix_sub(a, b)
    if a.width != b.width || a.height != b.height
      return Matrix.new(data: [], width: 0, height: 0)
    end
    mat = [].clone
    i = 0.clone
    while i < a.height
      row = [].clone
      j = 0.clone
      while j < a.width
        row = (row << (a.data[i][j] - b.data[i][j])).clone
        j = _add(j, 1).clone
      end
      mat = (mat << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: mat, width: a.width, height: a.height)
  end
  def matrix_mul_vector(m, v)
    if v.components.length != m.width
      return Vector.new(components: [])
    end
    res = zero_vector(m.height).clone
    i = 0.clone
    while i < m.height
      sum = 0.0.clone
      j = 0.clone
      while j < m.width
        sum = _add(sum, m.data[i][j] * v.components[j]).clone
        j = _add(j, 1).clone
      end
      res = vector_change_component(res, i, sum).clone
      i = _add(i, 1).clone
    end
    return res
  end
  def matrix_mul_scalar(m, s)
    mat = [].clone
    i = 0.clone
    while i < m.height
      row = [].clone
      j = 0.clone
      while j < m.width
        row = (row << (m.data[i][j] * s)).clone
        j = _add(j, 1).clone
      end
      mat = (mat << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: mat, width: m.width, height: m.height)
  end
  def matrix_component(m, x, y)
    return m.data[x][y]
  end
  def matrix_change_component(m, x, y, value)
    data = m.data.clone
    data[x][y] = value
    return Matrix.new(data: data, width: m.width, height: m.height)
  end
  def matrix_minor(m, x, y)
    if m.height != m.width
      return 0.0
    end
    minor = [].clone
    i = 0.clone
    while i < m.height
      if i != x
        row = [].clone
        j = 0.clone
        while j < m.width
          if j != y
            row = (row << (m.data[i][j])).clone
          end
          j = _add(j, 1).clone
        end
        minor = (minor << (row)).clone
      end
      i = _add(i, 1).clone
    end
    sub = Matrix.new(data: minor, width: m.width - 1, height: m.height - 1)
    return matrix_determinant(sub)
  end
  def matrix_cofactor(m, x, y)
    sign = ((_add(x, y)) % 2 == 0 ? 1.0 : -1.0)
    return sign * matrix_minor(m, x, y)
  end
  def matrix_determinant(m)
    if m.height != m.width
      return 0.0
    end
    if m.height == 0
      return 0.0
    end
    if m.height == 1
      return m.data[0][0]
    end
    if m.height == 2
      return m.data[0][0] * m.data[1][1] - m.data[0][1] * m.data[1][0]
    end
    sum = 0.0.clone
    y = 0.clone
    while y < m.width
      sum = _add(sum, m.data[0][y] * matrix_cofactor(m, 0, y)).clone
      y = _add(y, 1).clone
    end
    return sum
  end
  def square_zero_matrix(n)
    mat = [].clone
    i = 0.clone
    while i < n
      row = [].clone
      j = 0.clone
      while j < n
        row = (row << (0.0)).clone
        j = _add(j, 1).clone
      end
      mat = (mat << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: mat, width: n, height: n)
  end
  def random_matrix(w, h, a, b)
    mat = [].clone
    i = 0.clone
    while i < h
      row = [].clone
      j = 0.clone
      while j < w
        row = (row << ((random_int(a, b)).to_f)).clone
        j = _add(j, 1).clone
      end
      mat = (mat << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: mat, width: w, height: h)
  end
  def main()
    v1 = Vector.new(components: [1.0, 2.0, 3.0])
    v2 = Vector.new(components: [4.0, 5.0, 6.0])
    puts(vector_to_string(vector_add(v1, v2)))
    puts(_str(vector_dot(v1, v2)))
    puts(_str(vector_euclidean_length(v1)))
    m = Matrix.new(data: [[1.0, 2.0], [3.0, 4.0]], width: 2, height: 2)
    puts(_str(matrix_determinant(m)))
  end
  $PI = 3.141592653589793
  $seed = 123456789.clone
  Vector = Struct.new(:components, keyword_init: true)
  Matrix = Struct.new(:data, :width, :height, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
