# Generated by Mochi transpiler v0.10.65 on 2025-08-14 16:33 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if arr.is_a?(Array) && idx.is_a?(Numeric)
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  (arr || []) + [x]
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-6 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float)
    s = x.to_s
    if s.include?('e') || s.include?('E')
      s
    elsif x == x.to_i
      x.to_i.to_s
    else
      s
    end
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def rand()
    $seed = (_add($seed * 1103515245, 12345)) % 2147483648
    return $seed
  end
  def random_int(a, b)
    r = rand() % (_add(b - a, 1))
    return _add(a, r)
  end
  def sqrtApprox(x)
    if x <= 0.0
      return 0.0
    end
    guess = x
    i = 0
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def arcsin_taylor(x)
    term = x
    sum = x
    n = 1
    while n < 10
      num = (2.0 * ((n).to_f) - 1.0) * (2.0 * ((n).to_f) - 1.0) * x * x * term
      den = (2.0 * ((n).to_f)) * (_add(2.0 * ((n).to_f), 1.0))
      term = num / den
      sum = _add(sum, term)
      n = _add(n, 1)
    end
    return sum
  end
  def acos_taylor(x)
    return $PI / 2.0 - arcsin_taylor(x)
  end
  def vector_len(v)
    return _len(v.components)
  end
  def vector_to_string(v)
    s = "("
    i = 0
    while i < _len(v.components)
      s = _add(s, _str((__tmp1 = v.components; __tmp1.is_a?(Hash) ? __tmp1[i] : _idx(__tmp1, i))))
      if i < _len(v.components) - 1
        s = _add(s, ",")
      end
      i = _add(i, 1)
    end
    s = _add(s, ")")
    return s
  end
  def vector_add(a, b)
    size = vector_len(a)
    if !_eq(size, vector_len(b))
      return Vector.new(components: [])
    end
    res = []
    i = 0
    while i < size
      res = _append(res, _add((__tmp2 = a.components; __tmp2.is_a?(Hash) ? __tmp2[i] : _idx(__tmp2, i)), (__tmp3 = b.components; __tmp3.is_a?(Hash) ? __tmp3[i] : _idx(__tmp3, i))))
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def vector_sub(a, b)
    size = vector_len(a)
    if !_eq(size, vector_len(b))
      return Vector.new(components: [])
    end
    res = []
    i = 0
    while i < size
      res = _append(res, (__tmp4 = a.components; __tmp4.is_a?(Hash) ? __tmp4[i] : _idx(__tmp4, i)) - (__tmp5 = b.components; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i)))
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def vector_eq(a, b)
    if !_eq(vector_len(a), vector_len(b))
      return false
    end
    i = 0
    while i < vector_len(a)
      if !_eq((__tmp6 = a.components; __tmp6.is_a?(Hash) ? __tmp6[i] : _idx(__tmp6, i)), (__tmp7 = b.components; __tmp7.is_a?(Hash) ? __tmp7[i] : _idx(__tmp7, i)))
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def vector_mul_scalar(v, s)
    res = []
    i = 0
    while i < vector_len(v)
      res = _append(res, (__tmp8 = v.components; __tmp8.is_a?(Hash) ? __tmp8[i] : _idx(__tmp8, i)) * s)
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def vector_dot(a, b)
    size = vector_len(a)
    if !_eq(size, vector_len(b))
      return 0.0
    end
    sum = 0.0
    i = 0
    while i < size
      sum = _add(sum, (__tmp9 = a.components; __tmp9.is_a?(Hash) ? __tmp9[i] : _idx(__tmp9, i)) * (__tmp10 = b.components; __tmp10.is_a?(Hash) ? __tmp10[i] : _idx(__tmp10, i)))
      i = _add(i, 1)
    end
    return sum
  end
  def vector_copy(v)
    res = []
    i = 0
    while i < vector_len(v)
      res = _append(res, (__tmp11 = v.components; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i)))
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def vector_component(v, idx)
    return (__tmp12 = v.components; __tmp12.is_a?(Hash) ? __tmp12[idx] : _idx(__tmp12, idx))
  end
  def vector_change_component(v, pos, value)
    comps = v.components
    comps[pos] = value
    return Vector.new(components: comps)
  end
  def vector_euclidean_length(v)
    sum = 0.0
    i = 0
    while i < _len(v.components)
      sum = _add(sum, (__tmp13 = v.components; __tmp13.is_a?(Hash) ? __tmp13[i] : _idx(__tmp13, i)) * (__tmp14 = v.components; __tmp14.is_a?(Hash) ? __tmp14[i] : _idx(__tmp14, i)))
      i = _add(i, 1)
    end
    result = sqrtApprox(sum)
    return result
  end
  def vector_angle(a, b, deg)
    num = vector_dot(a, b)
    den = vector_euclidean_length(a) * vector_euclidean_length(b)
    ang = acos_taylor(num / den)
    if deg
      ang = ang * 180.0 / $PI
    end
    return ang
  end
  def zero_vector(d)
    res = []
    i = 0
    while i < d
      res = _append(res, 0.0)
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def unit_basis_vector(d, pos)
    res = []
    i = 0
    while i < d
      if _eq(i, pos)
        res = _append(res, 1.0)
      else
        res = _append(res, 0.0)
      end
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def axpy(s, x, y)
    return vector_add(vector_mul_scalar(x, s), y)
  end
  def random_vector(n, a, b)
    res = []
    i = 0
    while i < n
      res = _append(res, (random_int(a, b)).to_f)
      i = _add(i, 1)
    end
    return Vector.new(components: res)
  end
  def matrix_to_string(m)
    ans = ""
    i = 0
    while i < m.height
      ans = _add(ans, "|")
      j = 0
      while j < m.width
        ans = _add(ans, _str((__tmp15 = (__tmp16 = m.data; __tmp16.is_a?(Hash) ? __tmp16[i] : _idx(__tmp16, i)); __tmp15.is_a?(Hash) ? __tmp15[j] : _idx(__tmp15, j))))
        if j < m.width - 1
          ans = _add(ans, ",")
        end
        j = _add(j, 1)
      end
      ans = _add(ans, "|\n")
      i = _add(i, 1)
    end
    return ans
  end
  def matrix_add(a, b)
    if !_eq(a.width, b.width) || !_eq(a.height, b.height)
      return Matrix.new(data: [], width: 0, height: 0)
    end
    mat = []
    i = 0
    while i < a.height
      row = []
      j = 0
      while j < a.width
        row = _append(row, _add((__tmp17 = (__tmp18 = a.data; __tmp18.is_a?(Hash) ? __tmp18[i] : _idx(__tmp18, i)); __tmp17.is_a?(Hash) ? __tmp17[j] : _idx(__tmp17, j)), (__tmp19 = (__tmp20 = b.data; __tmp20.is_a?(Hash) ? __tmp20[i] : _idx(__tmp20, i)); __tmp19.is_a?(Hash) ? __tmp19[j] : _idx(__tmp19, j))))
        j = _add(j, 1)
      end
      mat = _append(mat, row)
      i = _add(i, 1)
    end
    return Matrix.new(data: mat, width: a.width, height: a.height)
  end
  def matrix_sub(a, b)
    if !_eq(a.width, b.width) || !_eq(a.height, b.height)
      return Matrix.new(data: [], width: 0, height: 0)
    end
    mat = []
    i = 0
    while i < a.height
      row = []
      j = 0
      while j < a.width
        row = _append(row, (__tmp21 = (__tmp22 = a.data; __tmp22.is_a?(Hash) ? __tmp22[i] : _idx(__tmp22, i)); __tmp21.is_a?(Hash) ? __tmp21[j] : _idx(__tmp21, j)) - (__tmp23 = (__tmp24 = b.data; __tmp24.is_a?(Hash) ? __tmp24[i] : _idx(__tmp24, i)); __tmp23.is_a?(Hash) ? __tmp23[j] : _idx(__tmp23, j)))
        j = _add(j, 1)
      end
      mat = _append(mat, row)
      i = _add(i, 1)
    end
    return Matrix.new(data: mat, width: a.width, height: a.height)
  end
  def matrix_mul_vector(m, v)
    if !_eq(_len(v.components), m.width)
      return Vector.new(components: [])
    end
    res = zero_vector(m.height)
    i = 0
    while i < m.height
      sum = 0.0
      j = 0
      while j < m.width
        sum = _add(sum, (__tmp25 = (__tmp26 = m.data; __tmp26.is_a?(Hash) ? __tmp26[i] : _idx(__tmp26, i)); __tmp25.is_a?(Hash) ? __tmp25[j] : _idx(__tmp25, j)) * (__tmp27 = v.components; __tmp27.is_a?(Hash) ? __tmp27[j] : _idx(__tmp27, j)))
        j = _add(j, 1)
      end
      res = vector_change_component(res, i, sum)
      i = _add(i, 1)
    end
    return res
  end
  def matrix_mul_scalar(m, s)
    mat = []
    i = 0
    while i < m.height
      row = []
      j = 0
      while j < m.width
        row = _append(row, (__tmp28 = (__tmp29 = m.data; __tmp29.is_a?(Hash) ? __tmp29[i] : _idx(__tmp29, i)); __tmp28.is_a?(Hash) ? __tmp28[j] : _idx(__tmp28, j)) * s)
        j = _add(j, 1)
      end
      mat = _append(mat, row)
      i = _add(i, 1)
    end
    return Matrix.new(data: mat, width: m.width, height: m.height)
  end
  def matrix_component(m, x, y)
    return (__tmp30 = (__tmp31 = m.data; __tmp31.is_a?(Hash) ? __tmp31[x] : _idx(__tmp31, x)); __tmp30.is_a?(Hash) ? __tmp30[y] : _idx(__tmp30, y))
  end
  def matrix_change_component(m, x, y, value)
    data = m.data
    (__tmp32 = data; __tmp32.is_a?(Hash) ? __tmp32[x] : _idx(__tmp32, x))[y] = value
    return Matrix.new(data: data, width: m.width, height: m.height)
  end
  def matrix_minor(m, x, y)
    if !_eq(m.height, m.width)
      return 0.0
    end
    minor = []
    i = 0
    while i < m.height
      if !_eq(i, x)
        row = []
        j = 0
        while j < m.width
          if !_eq(j, y)
            row = _append(row, (__tmp33 = (__tmp34 = m.data; __tmp34.is_a?(Hash) ? __tmp34[i] : _idx(__tmp34, i)); __tmp33.is_a?(Hash) ? __tmp33[j] : _idx(__tmp33, j)))
          end
          j = _add(j, 1)
        end
        minor = _append(minor, row)
      end
      i = _add(i, 1)
    end
    sub = Matrix.new(data: minor, width: m.width - 1, height: m.height - 1)
    return matrix_determinant(sub)
  end
  def matrix_cofactor(m, x, y)
    sign = (_eq((_add(x, y)) % 2, 0) ? 1.0 : -1.0)
    return sign * matrix_minor(m, x, y)
  end
  def matrix_determinant(m)
    if !_eq(m.height, m.width)
      return 0.0
    end
    if _eq(m.height, 0)
      return 0.0
    end
    if _eq(m.height, 1)
      return (__tmp35 = (__tmp36 = m.data; __tmp36.is_a?(Hash) ? __tmp36[0] : _idx(__tmp36, 0)); __tmp35.is_a?(Hash) ? __tmp35[0] : _idx(__tmp35, 0))
    end
    if _eq(m.height, 2)
      return (__tmp37 = (__tmp38 = m.data; __tmp38.is_a?(Hash) ? __tmp38[0] : _idx(__tmp38, 0)); __tmp37.is_a?(Hash) ? __tmp37[0] : _idx(__tmp37, 0)) * (__tmp39 = (__tmp40 = m.data; __tmp40.is_a?(Hash) ? __tmp40[1] : _idx(__tmp40, 1)); __tmp39.is_a?(Hash) ? __tmp39[1] : _idx(__tmp39, 1)) - (__tmp41 = (__tmp42 = m.data; __tmp42.is_a?(Hash) ? __tmp42[0] : _idx(__tmp42, 0)); __tmp41.is_a?(Hash) ? __tmp41[1] : _idx(__tmp41, 1)) * (__tmp43 = (__tmp44 = m.data; __tmp44.is_a?(Hash) ? __tmp44[1] : _idx(__tmp44, 1)); __tmp43.is_a?(Hash) ? __tmp43[0] : _idx(__tmp43, 0))
    end
    sum = 0.0
    y = 0
    while y < m.width
      sum = _add(sum, (__tmp45 = (__tmp46 = m.data; __tmp46.is_a?(Hash) ? __tmp46[0] : _idx(__tmp46, 0)); __tmp45.is_a?(Hash) ? __tmp45[y] : _idx(__tmp45, y)) * matrix_cofactor(m, 0, y))
      y = _add(y, 1)
    end
    return sum
  end
  def square_zero_matrix(n)
    mat = []
    i = 0
    while i < n
      row = []
      j = 0
      while j < n
        row = _append(row, 0.0)
        j = _add(j, 1)
      end
      mat = _append(mat, row)
      i = _add(i, 1)
    end
    return Matrix.new(data: mat, width: n, height: n)
  end
  def random_matrix(w, h, a, b)
    mat = []
    i = 0
    while i < h
      row = []
      j = 0
      while j < w
        row = _append(row, (random_int(a, b)).to_f)
        j = _add(j, 1)
      end
      mat = _append(mat, row)
      i = _add(i, 1)
    end
    return Matrix.new(data: mat, width: w, height: h)
  end
  def main()
    v1 = Vector.new(components: [1.0, 2.0, 3.0])
    v2 = Vector.new(components: [4.0, 5.0, 6.0])
    puts(vector_to_string(vector_add(v1, v2)))
    puts(_str(vector_dot(v1, v2)))
    puts(_str(vector_euclidean_length(v1)))
    m = Matrix.new(data: [[1.0, 2.0], [3.0, 4.0]], width: 2, height: 2)
    puts(_str(matrix_determinant(m)))
  end
  $PI = 3.141592653589793
  $seed = 123456789
  Object.send(:remove_const, :Vector) if Object.const_defined?(:Vector)
  Vector = Struct.new(:components, keyword_init: true)
  Object.send(:remove_const, :Matrix) if Object.const_defined?(:Matrix)
  Matrix = Struct.new(:data, :width, :height, keyword_init: true)
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
