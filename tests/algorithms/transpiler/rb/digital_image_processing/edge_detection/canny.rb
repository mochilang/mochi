# Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:43 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def sqrtApprox(x)
    guess = x / 2.0
    i = 0
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def atanApprox(x)
    if x > 1.0
      return $PI / 2.0 - x / (_add(x * x, 0.28))
    end
    if x < (-1.0)
      return -$PI / 2.0 - x / (_add(x * x, 0.28))
    end
    return x / (_add(1.0, 0.28 * x * x))
  end
  def atan2Approx(y, x)
    if x > 0.0
      r = atanApprox(y / x)
      return r
    end
    if x < 0.0
      if y >= 0.0
        return _add(atanApprox(y / x), $PI)
      end
      return atanApprox(y / x) - $PI
    end
    if y > 0.0
      return $PI / 2.0
    end
    if y < 0.0
      return -$PI / 2.0
    end
    return 0.0
  end
  def deg(rad)
    return rad * 180.0 / $PI
  end
  def zero_matrix(h, w)
    out = []
    i = 0
    while i < h
      row = []
      j = 0
      while j < w
        row = (row << 0.0)
        j = _add(j, 1)
      end
      out = (out << row)
      i = _add(i, 1)
    end
    return out
  end
  def convolve(img, kernel)
    h = img.length
    w = img[0].length
    k = kernel.length
    pad = k / 2
    out = zero_matrix(h, w)
    y = pad
    while y < h - pad
      x = pad
      while x < w - pad
        sum = 0.0
        ky = 0
        while ky < k
          kx = 0
          while kx < k
            pixel = img[_add(y - pad, ky)][_add(x - pad, kx)]
            weight = kernel[ky][kx]
            sum = _add(sum, pixel * weight)
            kx = _add(kx, 1)
          end
          ky = _add(ky, 1)
        end
        out[y][x] = sum
        x = _add(x, 1)
      end
      y = _add(y, 1)
    end
    return out
  end
  def gaussian_blur(img)
    return convolve(img, $GAUSSIAN_KERNEL)
  end
  def sobel_filter(img)
    gx = convolve(img, $SOBEL_GX)
    gy = convolve(img, $SOBEL_GY)
    h = img.length
    w = img[0].length
    grad = zero_matrix(h, w)
    dir = zero_matrix(h, w)
    i = 0
    while i < h
      j = 0
      while j < w
        gxx = gx[i][j]
        gyy = gy[i][j]
        grad[i][j] = sqrtApprox(_add(gxx * gxx, gyy * gyy))
        dir[i][j] = _add(deg(atan2Approx(gyy, gxx)), 180.0)
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    return {"grad" => grad, "dir" => dir}
  end
  def suppress_non_maximum(h, w, direction, grad)
    dest = zero_matrix(h, w)
    r = 1
    while r < h - 1
      c = 1
      while c < w - 1
        angle = direction[r][c]
        q = 0.0
        p = 0.0
        if (angle >= 0.0 && angle < 22.5) || (angle >= 157.5 && angle <= 180.0) || (angle >= 337.5)
          q = grad[r][_add(c, 1)]
          p = grad[r][c - 1]
        else
          if (angle >= 22.5 && angle < 67.5) || (angle >= 202.5 && angle < 247.5)
            q = grad[_add(r, 1)][c - 1]
            p = grad[r - 1][_add(c, 1)]
          else
            if (angle >= 67.5 && angle < 112.5) || (angle >= 247.5 && angle < 292.5)
              q = grad[_add(r, 1)][c]
              p = grad[r - 1][c]
            else
              q = grad[r - 1][c - 1]
              p = grad[_add(r, 1)][_add(c, 1)]
            end
          end
        end
        if grad[r][c] >= q && grad[r][c] >= p
          dest[r][c] = grad[r][c]
        end
        c = _add(c, 1)
      end
      r = _add(r, 1)
    end
    return dest
  end
  def double_threshold(h, w, img, low, high, weak, strong)
    r = 0
    while r < h
      c = 0
      while c < w
        v = img[r][c]
        if v >= high
          img[r][c] = strong
        else
          if v < low
            img[r][c] = 0.0
          else
            img[r][c] = weak
          end
        end
        c = _add(c, 1)
      end
      r = _add(r, 1)
    end
  end
  def track_edge(h, w, img, weak, strong)
    r = 1
    while r < h - 1
      c = 1
      while c < w - 1
        if img[r][c] == weak
          if img[_add(r, 1)][c] == strong || img[r - 1][c] == strong || img[r][_add(c, 1)] == strong || img[r][c - 1] == strong || img[r - 1][c - 1] == strong || img[r - 1][_add(c, 1)] == strong || img[_add(r, 1)][c - 1] == strong || img[_add(r, 1)][_add(c, 1)] == strong
            img[r][c] = strong
          else
            img[r][c] = 0.0
          end
        end
        c = _add(c, 1)
      end
      r = _add(r, 1)
    end
  end
  def canny(image, low, high, weak, strong)
    blurred = gaussian_blur(image)
    sob = sobel_filter(blurred)
    grad = sob["grad"]
    direction = sob["dir"]
    h = image.length
    w = image[0].length
    suppressed = suppress_non_maximum(h, w, direction, grad)
    double_threshold(h, w, suppressed, low, high, weak, strong)
    track_edge(h, w, suppressed, weak, strong)
    return suppressed
  end
  def print_image(img)
    r = 0
    while r < img.length
      c = 0
      line = ""
      while c < img[r].length
        line = _add(_add(line, ((img[r][c]).to_i).to_s), " ")
        c = _add(c, 1)
      end
      puts(line)
      r = _add(r, 1)
    end
  end
  $PI = 3.141592653589793
  $GAUSSIAN_KERNEL = [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]]
  $SOBEL_GX = [[-1.0, 0.0, 1.0], [-2.0, 0.0, 2.0], [-1.0, 0.0, 1.0]]
  $SOBEL_GY = [[1.0, 2.0, 1.0], [0.0, 0.0, 0.0], [-1.0, -2.0, -1.0]]
  $image = [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]]
  $edges = canny($image, 20.0, 40.0, 128.0, 255.0)
  print_image($edges)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
