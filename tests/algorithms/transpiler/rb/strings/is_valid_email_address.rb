# Generated by Mochi transpiler v0.10.59 on 2025-08-07 10:45 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

start_mem = _mem()
start = _now()
  def count_char(s, target)
    cnt = 0.clone
    i = 0.clone
    while i < s.length
      if s[i..._add(i, 1)] == target
        cnt = _add(cnt, 1).clone
      end
      i = _add(i, 1).clone
    end
    return cnt
  end
  def char_in(c, allowed)
    i = 0.clone
    while i < allowed.length
      if allowed[i..._add(i, 1)] == c
        return true
      end
      i = _add(i, 1).clone
    end
    return false
  end
  def starts_with_char(s, c)
    return s.length > 0 && s[0...1] == c
  end
  def ends_with_char(s, c)
    return s.length > 0 && s[s.length - 1...s.length] == c
  end
  def contains_double_dot(s)
    if s.length < 2
      return false
    end
    i = 0.clone
    while i < s.length - 1
      if s[i..._add(i, 2)] == ".."
        return true
      end
      i = _add(i, 1).clone
    end
    return false
  end
  def is_valid_email_address(email)
    if count_char(email, "@") != 1
      return false
    end
    at_idx = 0.clone
    i = 0.clone
    while i < email.length
      if email[i..._add(i, 1)] == "@"
        at_idx = i.clone
        break
      end
      i = _add(i, 1).clone
    end
    local_part = email[0...at_idx]
    domain = email[_add(at_idx, 1)...email.length]
    if local_part.length > $MAX_LOCAL_PART_OCTETS || domain.length > $MAX_DOMAIN_OCTETS
      return false
    end
    i = 0.clone
    while i < local_part.length
      ch = local_part[i..._add(i, 1)]
      if !char_in(ch, _add(_add($ASCII_LETTERS, $DIGITS), $LOCAL_EXTRA))
        return false
      end
      i = _add(i, 1).clone
    end
    if starts_with_char(local_part, ".") || ends_with_char(local_part, ".") || contains_double_dot(local_part)
      return false
    end
    i = 0.clone
    while i < domain.length
      ch = domain[i..._add(i, 1)]
      if !char_in(ch, _add(_add($ASCII_LETTERS, $DIGITS), $DOMAIN_EXTRA))
        return false
      end
      i = _add(i, 1).clone
    end
    if starts_with_char(domain, "-") || ends_with_char(domain, ".")
      return false
    end
    if starts_with_char(domain, ".") || ends_with_char(domain, ".") || contains_double_dot(domain)
      return false
    end
    return true
  end
  $MAX_LOCAL_PART_OCTETS = 64
  $MAX_DOMAIN_OCTETS = 255
  $ASCII_LETTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  $DIGITS = "0123456789"
  $LOCAL_EXTRA = ".(!#$%&'*+-/=?^_`{|}~)"
  $DOMAIN_EXTRA = ".-"
  $email_tests = ["simple@example.com", "very.common@example.com", "disposable.style.email.with+symbol@example.com", "other-email-with-hyphen@and.subdomains.example.com", "fully-qualified-domain@example.com", "user.name+tag+sorting@example.com", "x@example.com", "example-indeed@strange-example.com", "test/test@test.com", "123456789012345678901234567890123456789012345678901234567890123@example.com", "admin@mailserver1", "example@s.example", "Abc.example.com", "A@b@c@example.com", "abc@example..com", "a(c)d,e:f;g<h>i[j\\k]l@example.com", "12345678901234567890123456789012345678901234567890123456789012345@example.com", "i.like.underscores@but_its_not_allowed_in_this_part", ""]
  $idx = 0.clone
  while $idx < $email_tests.length
    email = $email_tests[$idx]
    puts(_str(is_valid_email_address(email)))
    $idx = _add($idx, 1).clone
  end
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
