# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def round_int(x)
    if x >= 0.0
      return (_add(x, 0.5)).to_i
    end
    return (x - 0.5).to_i
  end
  def zeros(rows, cols)
    res = []
    i = 0
    while i < rows
      row = []
      j = 0
      while j < cols
        row = (row + [0.0])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return res
  end
  def warp(image, h_flow, v_flow)
    h = image.length
    w = image[0].length
    out = []
    y = 0
    while y < h
      row = []
      x = 0
      while x < w
        sx = x - round_int(h_flow[y][x])
        sy = y - round_int(v_flow[y][x])
        if sx >= 0 && sx < w && sy >= 0 && sy < h
          row = (row + [image[sy][sx]])
        else
          row = (row + [0.0])
        end
        x = _add(x, 1)
      end
      out = (out + [row])
      y = _add(y, 1)
    end
    return out
  end
  def convolve(img, ker)
    h = img.length
    w = img[0].length
    kh = ker.length
    kw = ker[0].length
    py = kh / 2
    px = kw / 2
    out = []
    y = 0
    while y < h
      row = []
      x = 0
      while x < w
        s = 0.0
        ky = 0
        while ky < kh
          kx = 0
          while kx < kw
            iy = _add(y, ky) - py
            ix = _add(x, kx) - px
            if iy >= 0 && iy < h && ix >= 0 && ix < w
              s = _add(s, img[iy][ix] * ker[ky][kx])
            end
            kx = _add(kx, 1)
          end
          ky = _add(ky, 1)
        end
        row = (row + [s])
        x = _add(x, 1)
      end
      out = (out + [row])
      y = _add(y, 1)
    end
    return out
  end
  def horn_schunck(image0, image1, num_iter, alpha)
    h = image0.length
    w = image0[0].length
    u = zeros(h, w)
    v = zeros(h, w)
    kernel_x = [[-0.25, 0.25], [-0.25, 0.25]]
    kernel_y = [[-0.25, -0.25], [0.25, 0.25]]
    kernel_t = [[0.25, 0.25], [0.25, 0.25]]
    laplacian = [[0.0833333333333, 0.166666666667, 0.0833333333333], [0.166666666667, 0.0, 0.166666666667], [0.0833333333333, 0.166666666667, 0.0833333333333]]
    it = 0
    while it < num_iter
      warped = warp(image0, u, v)
      dx1 = convolve(warped, kernel_x)
      dx2 = convolve(image1, kernel_x)
      dy1 = convolve(warped, kernel_y)
      dy2 = convolve(image1, kernel_y)
      dt1 = convolve(warped, kernel_t)
      dt2 = convolve(image1, kernel_t)
      avg_u = convolve(u, laplacian)
      avg_v = convolve(v, laplacian)
      y = 0
      while y < h
        x = 0
        while x < w
          dx = _add(dx1[y][x], dx2[y][x])
          dy = _add(dy1[y][x], dy2[y][x])
          dt = dt1[y][x] - dt2[y][x]
          au = avg_u[y][x]
          av = avg_v[y][x]
          numer = _add(_add(dx * au, dy * av), dt)
          denom = _add(_add(alpha * alpha, dx * dx), dy * dy)
          upd = numer / denom
          u[y][x] = au - dx * upd
          v[y][x] = av - dy * upd
          x = _add(x, 1)
        end
        y = _add(y, 1)
      end
      it = _add(it, 1)
    end
    return [u, v]
  end
  def print_matrix(mat)
    y = 0
    while y < mat.length
      row = mat[y]
      x = 0
      line = ""
      while x < row.length
        line = _add(line, (round_int(row[x])).to_s)
        if _add(x, 1) < row.length
          line = _add(line, " ")
        end
        x = _add(x, 1)
      end
      puts(line)
      y = _add(y, 1)
    end
  end
  def main()
    image0 = [[0.0, 0.0, 2.0], [0.0, 0.0, 2.0]]
    image1 = [[0.0, 2.0, 0.0], [0.0, 2.0, 0.0]]
    flows = horn_schunck(image0, image1, 20, 0.1)
    u = flows[0]
    v = flows[1]
    print_matrix(u)
    puts("---")
    print_matrix(v)
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
