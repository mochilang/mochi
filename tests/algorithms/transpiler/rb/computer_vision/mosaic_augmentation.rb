# Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:30 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale)
    height = output_size[0]
    width = output_size[1]
    output_img = []
    r = 0
    while r < height
      row = []
      c = 0
      while c < width
        row = (row + [0])
        c = _add(c, 1)
      end
      output_img = (output_img + [row])
      r = _add(r, 1)
    end
    scale_x = (_add(scale_range[0], scale_range[1])) / 2.0
    scale_y = (_add(scale_range[0], scale_range[1])) / 2.0
    divid_point_x = (((scale_x * ((width).to_f))).to_i)
    divid_point_y = (((scale_y * ((height).to_f))).to_i)
    new_anno = []
    path_list = []
    i = 0
    while i < idxs.length
      index = idxs[i]
      path = all_img_list[index]
      path_list = (path_list + [path])
      img_annos = all_annos[index]
      if i == 0
        y0 = 0
        while y0 < divid_point_y
          x0 = 0
          while x0 < divid_point_x
            output_img[y0][x0] = _add(i, 1)
            x0 = _add(x0, 1)
          end
          y0 = _add(y0, 1)
        end
        j0 = 0
        while j0 < img_annos.length
          bbox = img_annos[j0]
          xmin = bbox[1] * scale_x
          ymin = bbox[2] * scale_y
          xmax = bbox[3] * scale_x
          ymax = bbox[4] * scale_y
          new_anno = (new_anno + [[bbox[0], xmin, ymin, xmax, ymax]])
          j0 = _add(j0, 1)
        end
      else
        if i == 1
          y1 = 0
          while y1 < divid_point_y
            x1 = divid_point_x
            while x1 < width
              output_img[y1][x1] = _add(i, 1)
              x1 = _add(x1, 1)
            end
            y1 = _add(y1, 1)
          end
          j1 = 0
          while j1 < img_annos.length
            bbox1 = img_annos[j1]
            xmin1 = _add(scale_x, bbox1[1] * (1.0 - scale_x))
            ymin1 = bbox1[2] * scale_y
            xmax1 = _add(scale_x, bbox1[3] * (1.0 - scale_x))
            ymax1 = bbox1[4] * scale_y
            new_anno = (new_anno + [[bbox1[0], xmin1, ymin1, xmax1, ymax1]])
            j1 = _add(j1, 1)
          end
        else
          if i == 2
            y2 = divid_point_y
            while y2 < height
              x2 = 0
              while x2 < divid_point_x
                output_img[y2][x2] = _add(i, 1)
                x2 = _add(x2, 1)
              end
              y2 = _add(y2, 1)
            end
            j2 = 0
            while j2 < img_annos.length
              bbox2 = img_annos[j2]
              xmin2 = bbox2[1] * scale_x
              ymin2 = _add(scale_y, bbox2[2] * (1.0 - scale_y))
              xmax2 = bbox2[3] * scale_x
              ymax2 = _add(scale_y, bbox2[4] * (1.0 - scale_y))
              new_anno = (new_anno + [[bbox2[0], xmin2, ymin2, xmax2, ymax2]])
              j2 = _add(j2, 1)
            end
          else
            y3 = divid_point_y
            while y3 < height
              x3 = divid_point_x
              while x3 < width
                output_img[y3][x3] = _add(i, 1)
                x3 = _add(x3, 1)
              end
              y3 = _add(y3, 1)
            end
            j3 = 0
            while j3 < img_annos.length
              bbox3 = img_annos[j3]
              xmin3 = _add(scale_x, bbox3[1] * (1.0 - scale_x))
              ymin3 = _add(scale_y, bbox3[2] * (1.0 - scale_y))
              xmax3 = _add(scale_x, bbox3[3] * (1.0 - scale_x))
              ymax3 = _add(scale_y, bbox3[4] * (1.0 - scale_y))
              new_anno = (new_anno + [[bbox3[0], xmin3, ymin3, xmax3, ymax3]])
              j3 = _add(j3, 1)
            end
          end
        end
      end
      i = _add(i, 1)
    end
    if filter_scale > 0.0
      filtered = []
      k = 0
      while k < new_anno.length
        anno = new_anno[k]
        w = anno[3] - anno[1]
        h = anno[4] - anno[2]
        if filter_scale < w && filter_scale < h
          filtered = (filtered + [anno])
        end
        k = _add(k, 1)
      end
      new_anno = filtered
    end
    return MosaicResult.new(img: output_img, annos: new_anno, path: path_list[0])
  end
  def main()
    all_img_list = ["img0.jpg", "img1.jpg", "img2.jpg", "img3.jpg"]
    all_annos = [[[0.0, 0.1, 0.1, 0.4, 0.4]], [[1.0, 0.2, 0.3, 0.5, 0.7]], [[2.0, 0.6, 0.2, 0.9, 0.5]], [[3.0, 0.5, 0.5, 0.8, 0.8]]]
    idxs = [0, 1, 2, 3]
    output_size = [100, 100]
    scale_range = [0.4, 0.6]
    filter_scale = 0.05
    res = update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale)
    new_annos = res["annos"]
    path = res["path"]
    puts(_add("Base image: ", path))
    puts(_add("Mosaic annotation count: ", (new_annos.length).to_s))
    i = 0
    while i < new_annos.length
      a = new_annos[i]
      puts(_add(_add(_add(_add(_add(_add(_add(_add((a[0]).to_s, " "), (a[1]).to_s), " "), (a[2]).to_s), " "), (a[3]).to_s), " "), (a[4]).to_s))
      i = _add(i, 1)
    end
  end
  MosaicResult = Struct.new(:img, :annos, :path, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
