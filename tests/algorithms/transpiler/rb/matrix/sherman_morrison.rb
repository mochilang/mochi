# Generated by Mochi transpiler v0.10.59 on 2025-08-07 00:17 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _str(x)
  if x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

start_mem = _mem()
start = _now()
  def make_matrix(rows, cols, value)
    arr = [].clone
    r = 0.clone
    while r < rows
      row = [].clone
      c = 0.clone
      while c < cols
        row = (row << (value)).clone
        c = _add(c, 1).clone
      end
      arr = (arr << (row)).clone
      r = _add(r, 1).clone
    end
    return Matrix.new(data: arr, rows: rows, cols: cols)
  end
  def matrix_from_lists(vals)
    r = vals.length
    c = (r == 0 ? 0 : vals[0].length)
    return Matrix.new(data: vals, rows: r, cols: c)
  end
  def matrix_to_string(m)
    s = "".clone
    i = 0.clone
    while i < m.rows
      s = _add(s, "[").clone
      j = 0.clone
      while j < m.cols
        s = _add(s, _str(m.data[i][j])).clone
        if j < m.cols - 1
          s = _add(s, ", ").clone
        end
        j = _add(j, 1).clone
      end
      s = _add(s, "]").clone
      if i < m.rows - 1
        s = _add(s, "\n").clone
      end
      i = _add(i, 1).clone
    end
    return s
  end
  def matrix_add(a, b)
    if a.rows != b.rows || a.cols != b.cols
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = [].clone
    i = 0.clone
    while i < a.rows
      row = [].clone
      j = 0.clone
      while j < a.cols
        row = (row << (_add(a.data[i][j], b.data[i][j]))).clone
        j = _add(j, 1).clone
      end
      res = (res << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: res, rows: a.rows, cols: a.cols)
  end
  def matrix_sub(a, b)
    if a.rows != b.rows || a.cols != b.cols
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = [].clone
    i = 0.clone
    while i < a.rows
      row = [].clone
      j = 0.clone
      while j < a.cols
        row = (row << (a.data[i][j] - b.data[i][j])).clone
        j = _add(j, 1).clone
      end
      res = (res << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: res, rows: a.rows, cols: a.cols)
  end
  def matrix_mul_scalar(m, k)
    res = [].clone
    i = 0.clone
    while i < m.rows
      row = [].clone
      j = 0.clone
      while j < m.cols
        row = (row << (m.data[i][j] * k)).clone
        j = _add(j, 1).clone
      end
      res = (res << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: res, rows: m.rows, cols: m.cols)
  end
  def matrix_mul(a, b)
    if a.cols != b.rows
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = [].clone
    i = 0.clone
    while i < a.rows
      row = [].clone
      j = 0.clone
      while j < b.cols
        sum = 0.0.clone
        k = 0.clone
        while k < a.cols
          sum = _add(sum, a.data[i][k] * b.data[k][j]).clone
          k = _add(k, 1).clone
        end
        row = (row << (sum)).clone
        j = _add(j, 1).clone
      end
      res = (res << (row)).clone
      i = _add(i, 1).clone
    end
    return Matrix.new(data: res, rows: a.rows, cols: b.cols)
  end
  def matrix_transpose(m)
    res = [].clone
    c = 0.clone
    while c < m.cols
      row = [].clone
      r = 0.clone
      while r < m.rows
        row = (row << (m.data[r][c])).clone
        r = _add(r, 1).clone
      end
      res = (res << (row)).clone
      c = _add(c, 1).clone
    end
    return Matrix.new(data: res, rows: m.cols, cols: m.rows)
  end
  def sherman_morrison(ainv, u, v)
    vt = matrix_transpose(v)
    vu = matrix_mul(matrix_mul(vt, ainv), u)
    factor = _add(vu.data[0][0], 1.0)
    if factor == 0.0
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    term1 = matrix_mul(ainv, u)
    term2 = matrix_mul(vt, ainv)
    numerator = matrix_mul(term1, term2)
    scaled = matrix_mul_scalar(numerator, 1.0 / factor)
    return matrix_sub(ainv, scaled)
  end
  def main()
    ainv = matrix_from_lists([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])
    u = matrix_from_lists([[1.0], [2.0], [-3.0]])
    v = matrix_from_lists([[4.0], [-2.0], [5.0]])
    result = sherman_morrison(ainv, u, v)
    puts(matrix_to_string(result))
  end
  Matrix = Struct.new(:data, :rows, :cols, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
