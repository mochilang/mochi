# Generated by Mochi transpiler v0.10.64 on 2025-08-12 13:41 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil? || !idx.is_a?(Numeric) || idx < 0 || idx >= arr.length
  arr[idx]
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    a + b
  end
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    (a.to_f - b.to_f).abs < 1e-6
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def make_matrix(rows, cols, value)
    arr = []
    r = 0
    while r < rows
      row = []
      c = 0
      while c < cols
        row = (row + [value])
        c = _add(c, 1)
      end
      arr = (arr + [row])
      r = _add(r, 1)
    end
    return Matrix.new(data: arr, rows: rows, cols: cols)
  end
  def matrix_from_lists(vals)
    r = vals.length
    c = (_eq(r, 0) ? 0 : (__tmp1 = vals; __tmp1.is_a?(Hash) ? __tmp1[0] : _idx(__tmp1, 0)).length)
    return Matrix.new(data: vals, rows: r, cols: c)
  end
  def matrix_to_string(m)
    s = ""
    i = 0
    while i < m.rows
      s = _add(s, "[")
      j = 0
      while j < m.cols
        s = _add(s, _str((__tmp2 = (__tmp3 = m.data; __tmp3.is_a?(Hash) ? __tmp3[i] : _idx(__tmp3, i)); __tmp2.is_a?(Hash) ? __tmp2[j] : _idx(__tmp2, j))))
        if j < m.cols - 1
          s = _add(s, ", ")
        end
        j = _add(j, 1)
      end
      s = _add(s, "]")
      if i < m.rows - 1
        s = _add(s, "\n")
      end
      i = _add(i, 1)
    end
    return s
  end
  def matrix_add(a, b)
    if !_eq(a.rows, b.rows) || !_eq(a.cols, b.cols)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = []
    i = 0
    while i < a.rows
      row = []
      j = 0
      while j < a.cols
        row = (row + [_add((__tmp4 = (__tmp5 = a.data; __tmp5.is_a?(Hash) ? __tmp5[i] : _idx(__tmp5, i)); __tmp4.is_a?(Hash) ? __tmp4[j] : _idx(__tmp4, j)), (__tmp6 = (__tmp7 = b.data; __tmp7.is_a?(Hash) ? __tmp7[i] : _idx(__tmp7, i)); __tmp6.is_a?(Hash) ? __tmp6[j] : _idx(__tmp6, j)))])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: a.rows, cols: a.cols)
  end
  def matrix_sub(a, b)
    if !_eq(a.rows, b.rows) || !_eq(a.cols, b.cols)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = []
    i = 0
    while i < a.rows
      row = []
      j = 0
      while j < a.cols
        row = (row + [(__tmp8 = (__tmp9 = a.data; __tmp9.is_a?(Hash) ? __tmp9[i] : _idx(__tmp9, i)); __tmp8.is_a?(Hash) ? __tmp8[j] : _idx(__tmp8, j)) - (__tmp10 = (__tmp11 = b.data; __tmp11.is_a?(Hash) ? __tmp11[i] : _idx(__tmp11, i)); __tmp10.is_a?(Hash) ? __tmp10[j] : _idx(__tmp10, j))])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: a.rows, cols: a.cols)
  end
  def matrix_mul_scalar(m, k)
    res = []
    i = 0
    while i < m.rows
      row = []
      j = 0
      while j < m.cols
        row = (row + [(__tmp12 = (__tmp13 = m.data; __tmp13.is_a?(Hash) ? __tmp13[i] : _idx(__tmp13, i)); __tmp12.is_a?(Hash) ? __tmp12[j] : _idx(__tmp12, j)) * k])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: m.rows, cols: m.cols)
  end
  def matrix_mul(a, b)
    if !_eq(a.cols, b.rows)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = []
    i = 0
    while i < a.rows
      row = []
      j = 0
      while j < b.cols
        sum = 0.0
        k = 0
        while k < a.cols
          sum = _add(sum, (__tmp14 = (__tmp15 = a.data; __tmp15.is_a?(Hash) ? __tmp15[i] : _idx(__tmp15, i)); __tmp14.is_a?(Hash) ? __tmp14[k] : _idx(__tmp14, k)) * (__tmp16 = (__tmp17 = b.data; __tmp17.is_a?(Hash) ? __tmp17[k] : _idx(__tmp17, k)); __tmp16.is_a?(Hash) ? __tmp16[j] : _idx(__tmp16, j)))
          k = _add(k, 1)
        end
        row = (row + [sum])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: a.rows, cols: b.cols)
  end
  def matrix_transpose(m)
    res = []
    c = 0
    while c < m.cols
      row = []
      r = 0
      while r < m.rows
        row = (row + [(__tmp18 = (__tmp19 = m.data; __tmp19.is_a?(Hash) ? __tmp19[r] : _idx(__tmp19, r)); __tmp18.is_a?(Hash) ? __tmp18[c] : _idx(__tmp18, c))])
        r = _add(r, 1)
      end
      res = (res + [row])
      c = _add(c, 1)
    end
    return Matrix.new(data: res, rows: m.cols, cols: m.rows)
  end
  def sherman_morrison(ainv, u, v)
    vt = matrix_transpose(v)
    vu = matrix_mul(matrix_mul(vt, ainv), u)
    factor = _add((__tmp20 = (__tmp21 = vu.data; __tmp21.is_a?(Hash) ? __tmp21[0] : _idx(__tmp21, 0)); __tmp20.is_a?(Hash) ? __tmp20[0] : _idx(__tmp20, 0)), 1.0)
    if _eq(factor, 0.0)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    term1 = matrix_mul(ainv, u)
    term2 = matrix_mul(vt, ainv)
    numerator = matrix_mul(term1, term2)
    scaled = matrix_mul_scalar(numerator, 1.0 / factor)
    return matrix_sub(ainv, scaled)
  end
  def main()
    ainv = matrix_from_lists([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])
    u = matrix_from_lists([[1.0], [2.0], [-3.0]])
    v = matrix_from_lists([[4.0], [-2.0], [5.0]])
    result = sherman_morrison(ainv, u, v)
    puts(matrix_to_string(result))
  end
  Object.send(:remove_const, :Matrix) if Object.const_defined?(:Matrix)
  Matrix = Struct.new(:data, :rows, :cols, keyword_init: true)
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
