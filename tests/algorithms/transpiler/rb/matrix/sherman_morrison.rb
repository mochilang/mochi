# Generated by Mochi transpiler v0.10.64 on 2025-08-12 09:13 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    a + b
  end
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    (a.to_f - b.to_f).abs < 1e-6
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    x.map { |e| _str(e) }.join(' ')
  elsif x.is_a?(Float) && x == x.to_i
    x.to_i.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = _now()
  def make_matrix(rows, cols, value)
    arr = []
    r = 0
    while r < rows
      row = []
      c = 0
      while c < cols
        row = (row + [value])
        c = _add(c, 1)
      end
      arr = (arr + [row])
      r = _add(r, 1)
    end
    return Matrix.new(data: arr, rows: rows, cols: cols)
  end
  def matrix_from_lists(vals)
    r = vals.length
    c = (_eq(r, 0) ? 0 : vals[0].length)
    return Matrix.new(data: vals, rows: r, cols: c)
  end
  def matrix_to_string(m)
    s = ""
    i = 0
    while i < m.rows
      s = _add(s, "[")
      j = 0
      while j < m.cols
        s = _add(s, _str(m.data[i][j]))
        if j < m.cols - 1
          s = _add(s, ", ")
        end
        j = _add(j, 1)
      end
      s = _add(s, "]")
      if i < m.rows - 1
        s = _add(s, "\n")
      end
      i = _add(i, 1)
    end
    return s
  end
  def matrix_add(a, b)
    if !_eq(a.rows, b.rows) || !_eq(a.cols, b.cols)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = []
    i = 0
    while i < a.rows
      row = []
      j = 0
      while j < a.cols
        row = (row + [_add(a.data[i][j], b.data[i][j])])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: a.rows, cols: a.cols)
  end
  def matrix_sub(a, b)
    if !_eq(a.rows, b.rows) || !_eq(a.cols, b.cols)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = []
    i = 0
    while i < a.rows
      row = []
      j = 0
      while j < a.cols
        row = (row + [a.data[i][j] - b.data[i][j]])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: a.rows, cols: a.cols)
  end
  def matrix_mul_scalar(m, k)
    res = []
    i = 0
    while i < m.rows
      row = []
      j = 0
      while j < m.cols
        row = (row + [m.data[i][j] * k])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: m.rows, cols: m.cols)
  end
  def matrix_mul(a, b)
    if !_eq(a.cols, b.rows)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    res = []
    i = 0
    while i < a.rows
      row = []
      j = 0
      while j < b.cols
        sum = 0.0
        k = 0
        while k < a.cols
          sum = _add(sum, a.data[i][k] * b.data[k][j])
          k = _add(k, 1)
        end
        row = (row + [sum])
        j = _add(j, 1)
      end
      res = (res + [row])
      i = _add(i, 1)
    end
    return Matrix.new(data: res, rows: a.rows, cols: b.cols)
  end
  def matrix_transpose(m)
    res = []
    c = 0
    while c < m.cols
      row = []
      r = 0
      while r < m.rows
        row = (row + [m.data[r][c]])
        r = _add(r, 1)
      end
      res = (res + [row])
      c = _add(c, 1)
    end
    return Matrix.new(data: res, rows: m.cols, cols: m.rows)
  end
  def sherman_morrison(ainv, u, v)
    vt = matrix_transpose(v)
    vu = matrix_mul(matrix_mul(vt, ainv), u)
    factor = _add(vu.data[0][0], 1.0)
    if _eq(factor, 0.0)
      return Matrix.new(data: [], rows: 0, cols: 0)
    end
    term1 = matrix_mul(ainv, u)
    term2 = matrix_mul(vt, ainv)
    numerator = matrix_mul(term1, term2)
    scaled = matrix_mul_scalar(numerator, 1.0 / factor)
    return matrix_sub(ainv, scaled)
  end
  def main()
    ainv = matrix_from_lists([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])
    u = matrix_from_lists([[1.0], [2.0], [-3.0]])
    v = matrix_from_lists([[4.0], [-2.0], [5.0]])
    result = sherman_morrison(ainv, u, v)
    puts(matrix_to_string(result))
  end
  Object.send(:remove_const, :Matrix) if Object.const_defined?(:Matrix)
  Matrix = Struct.new(:data, :rows, :cols, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
