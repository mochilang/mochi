exit status 1
/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:109:58: warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
107 |         var i: Int = 0
108 |         while (i < _int(((v).count))) {
109 |             res = (_append(res, complex_conj((_idx(v, i) as! Complex))) as! [Complex])
    |                                                          `- warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
110 |             i = _int((i &+ 1))
111 |         }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:117:41: warning: forced cast from '[Complex]?' to '[Complex]' only unwraps optionals; did you mean to use '!'?
115 |         var result: [Complex] = ([] as! [Complex])
116 |         var col: Int = 0
117 |         while (col < _int((((_idx(m, 0) as! [Complex])).count))) {
    |                                         `- warning: forced cast from '[Complex]?' to '[Complex]' only unwraps optionals; did you mean to use '!'?
118 |             var sum: Complex = Complex(re: 0.0, im: 0.0)
119 |             var row: Int = 0

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:121:41: warning: forced cast of 'Complex' to same type has no effect
119 |             var row: Int = 0
120 |             while (row < _int(((v).count))) {
121 |                 sum = (complex_add((sum as! Complex), (complex_mul((_idx(v, row) as! Complex), (_idx(_idx(m, row), col) as! Complex)) as! Complex)) as! Complex)
    |                                         `- warning: forced cast of 'Complex' to same type has no effect
122 |                 row = _int((row &+ 1))
123 |             }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:121:82: warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
119 |             var row: Int = 0
120 |             while (row < _int(((v).count))) {
121 |                 sum = (complex_add((sum as! Complex), (complex_mul((_idx(v, row) as! Complex), (_idx(_idx(m, row), col) as! Complex)) as! Complex)) as! Complex)
    |                                                                                  `- warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
122 |                 row = _int((row &+ 1))
123 |             }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:121:102: error: cannot convert value of type '[Complex]?' to expected argument type '[[Complex]?]'
119 |             var row: Int = 0
120 |             while (row < _int(((v).count))) {
121 |                 sum = (complex_add((sum as! Complex), (complex_mul((_idx(v, row) as! Complex), (_idx(_idx(m, row), col) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                      `- error: cannot convert value of type '[Complex]?' to expected argument type '[[Complex]?]'
122 |                 row = _int((row &+ 1))
123 |             }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:121:121: warning: cast from '[Complex]??' to unrelated type 'Complex' always fails
119 |             var row: Int = 0
120 |             while (row < _int(((v).count))) {
121 |                 sum = (complex_add((sum as! Complex), (complex_mul((_idx(v, row) as! Complex), (_idx(_idx(m, row), col) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                                         `- warning: cast from '[Complex]??' to unrelated type 'Complex' always fails
122 |                 row = _int((row &+ 1))
123 |             }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:121:135: warning: forced cast of 'Complex' to same type has no effect
119 |             var row: Int = 0
120 |             while (row < _int(((v).count))) {
121 |                 sum = (complex_add((sum as! Complex), (complex_mul((_idx(v, row) as! Complex), (_idx(_idx(m, row), col) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                                                       `- warning: forced cast of 'Complex' to same type has no effect
122 |                 row = _int((row &+ 1))
123 |             }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:121:149: warning: forced cast of 'Complex' to same type has no effect
119 |             var row: Int = 0
120 |             while (row < _int(((v).count))) {
121 |                 sum = (complex_add((sum as! Complex), (complex_mul((_idx(v, row) as! Complex), (_idx(_idx(m, row), col) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                                                                     `- warning: forced cast of 'Complex' to same type has no effect
122 |                 row = _int((row &+ 1))
123 |             }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:133:37: warning: forced cast of 'Complex' to same type has no effect
131 |         var i: Int = 0
132 |         while (i < _int(((a).count))) {
133 |             sum = (complex_add((sum as! Complex), (complex_mul((_idx(a, i) as! Complex), (_idx(b, i) as! Complex)) as! Complex)) as! Complex)
    |                                     `- warning: forced cast of 'Complex' to same type has no effect
134 |             i = _int((i &+ 1))
135 |         }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:133:76: warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
131 |         var i: Int = 0
132 |         while (i < _int(((a).count))) {
133 |             sum = (complex_add((sum as! Complex), (complex_mul((_idx(a, i) as! Complex), (_idx(b, i) as! Complex)) as! Complex)) as! Complex)
    |                                                                            `- warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
134 |             i = _int((i &+ 1))
135 |         }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:133:102: warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
131 |         var i: Int = 0
132 |         while (i < _int(((a).count))) {
133 |             sum = (complex_add((sum as! Complex), (complex_mul((_idx(a, i) as! Complex), (_idx(b, i) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                      `- warning: forced cast from 'Complex?' to 'Complex' only unwraps optionals; did you mean to use '!'?
134 |             i = _int((i &+ 1))
135 |         }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:133:116: warning: forced cast of 'Complex' to same type has no effect
131 |         var i: Int = 0
132 |         while (i < _int(((a).count))) {
133 |             sum = (complex_add((sum as! Complex), (complex_mul((_idx(a, i) as! Complex), (_idx(b, i) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                                    `- warning: forced cast of 'Complex' to same type has no effect
134 |             i = _int((i &+ 1))
135 |         }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:133:130: warning: forced cast of 'Complex' to same type has no effect
131 |         var i: Int = 0
132 |         while (i < _int(((a).count))) {
133 |             sum = (complex_add((sum as! Complex), (complex_mul((_idx(a, i) as! Complex), (_idx(b, i) as! Complex)) as! Complex)) as! Complex)
    |                                                                                                                                  `- warning: forced cast of 'Complex' to same type has no effect
134 |             i = _int((i &+ 1))
135 |         }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:143:39: error: cannot convert value of type '[Complex]?' to expected argument type '[[Complex]?]'
141 |             var j: Int = 0
142 |             while (j < _int(((m).count))) {
143 |                 if (!complex_eq((_idx(_idx(m, i), j) as! Complex), (complex_conj((_idx(_idx(m, j), i) as! Complex)) as! Complex))) {
    |                                       `- error: cannot convert value of type '[Complex]?' to expected argument type '[[Complex]?]'
144 |                     return false
145 |                 }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:143:54: warning: cast from '[Complex]??' to unrelated type 'Complex' always fails
141 |             var j: Int = 0
142 |             while (j < _int(((m).count))) {
143 |                 if (!complex_eq((_idx(_idx(m, i), j) as! Complex), (complex_conj((_idx(_idx(m, j), i) as! Complex)) as! Complex))) {
    |                                                      `- warning: cast from '[Complex]??' to unrelated type 'Complex' always fails
144 |                     return false
145 |                 }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:143:88: error: cannot convert value of type '[Complex]?' to expected argument type '[[Complex]?]'
141 |             var j: Int = 0
142 |             while (j < _int(((m).count))) {
143 |                 if (!complex_eq((_idx(_idx(m, i), j) as! Complex), (complex_conj((_idx(_idx(m, j), i) as! Complex)) as! Complex))) {
    |                                                                                        `- error: cannot convert value of type '[Complex]?' to expected argument type '[[Complex]?]'
144 |                     return false
145 |                 }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:143:103: warning: cast from '[Complex]??' to unrelated type 'Complex' always fails
141 |             var j: Int = 0
142 |             while (j < _int(((m).count))) {
143 |                 if (!complex_eq((_idx(_idx(m, i), j) as! Complex), (complex_conj((_idx(_idx(m, j), i) as! Complex)) as! Complex))) {
    |                                                                                                       `- warning: cast from '[Complex]??' to unrelated type 'Complex' always fails
144 |                     return false
145 |                 }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:143:117: warning: forced cast of 'Complex' to same type has no effect
141 |             var j: Int = 0
142 |             while (j < _int(((m).count))) {
143 |                 if (!complex_eq((_idx(_idx(m, i), j) as! Complex), (complex_conj((_idx(_idx(m, j), i) as! Complex)) as! Complex))) {
    |                                                                                                                     `- warning: forced cast of 'Complex' to same type has no effect
144 |                     return false
145 |                 }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:153:49: warning: forced cast of '[Complex]' to same type has no effect
151 |     }
152 |     func rayleigh_quotient(_ a: [[Complex]], _ v: [Complex]) -> Double {
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
    |                                                 `- warning: forced cast of '[Complex]' to same type has no effect
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:153:65: warning: forced cast of '[Complex]' to same type has no effect
151 |     }
152 |     func rayleigh_quotient(_ a: [[Complex]], _ v: [Complex]) -> Double {
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
    |                                                                 `- warning: forced cast of '[Complex]' to same type has no effect
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:154:58: warning: forced cast of '[Complex]' to same type has no effect
152 |     func rayleigh_quotient(_ a: [[Complex]], _ v: [Complex]) -> Double {
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
    |                                                          `- warning: forced cast of '[Complex]' to same type has no effect
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:154:77: warning: forced cast of '[[Complex]]' to same type has no effect
152 |     func rayleigh_quotient(_ a: [[Complex]], _ v: [Complex]) -> Double {
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
    |                                                                             `- warning: forced cast of '[[Complex]]' to same type has no effect
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:154:95: warning: forced cast of '[Complex]' to same type has no effect
152 |     func rayleigh_quotient(_ a: [[Complex]], _ v: [Complex]) -> Double {
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
    |                                                                                               `- warning: forced cast of '[Complex]' to same type has no effect
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:155:35: warning: forced cast of '[Complex]' to same type has no effect
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
    |                                   `- warning: forced cast of '[Complex]' to same type has no effect
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))
157 |         return (num.re / den.re)

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:155:54: warning: forced cast of '[Complex]' to same type has no effect
153 |         let v_star: [Complex] = (conj_vector((v as! [Complex])) as! [Complex])
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
    |                                                      `- warning: forced cast of '[Complex]' to same type has no effect
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))
157 |         return (num.re / den.re)

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:156:31: warning: forced cast of '[Complex]' to same type has no effect
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))
    |                               `- warning: forced cast of '[Complex]' to same type has no effect
157 |         return (num.re / den.re)
158 |     }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:156:50: warning: forced cast of '[Complex]' to same type has no effect
154 |         let v_star_dot: [Complex] = (vec_mat_mul((v_star as! [Complex]), (a as! [[Complex]])) as! [Complex])
155 |         let num = dot((v_star_dot as! [Complex]), (v as! [Complex]))
156 |         let den = dot((v_star as! [Complex]), (v as! [Complex]))
    |                                                  `- warning: forced cast of '[Complex]' to same type has no effect
157 |         return (num.re / den.re)
158 |     }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:161:24: warning: forced cast of '[[Complex]]' to same type has no effect
159 |     let a: [[Complex]] = ([([Complex(re: 2.0, im: 0.0), Complex(re: 2.0, im: 1.0), Complex(re: 4.0, im: 0.0)] as! [Complex]), ([Complex(re: 2.0, im: -1.0), Complex(re: 3.0, im: 0.0), Complex(re: 0.0, im: 1.0)] as! [Complex]), ([Complex(re: 4.0, im: 0.0), Complex(re: 0.0, im: -1.0), Complex(re: 1.0, im: 0.0)] as! [Complex])] as! [[Complex]])
160 |     let v: [Complex] = ([Complex(re: 1.0, im: 0.0), Complex(re: 2.0, im: 0.0), Complex(re: 3.0, im: 0.0)] as! [Complex])
161 |     if is_hermitian((a as! [[Complex]])) {
    |                        `- warning: forced cast of '[[Complex]]' to same type has no effect
162 |         let r1 = Double(rayleigh_quotient((a as! [[Complex]]), (v as! [Complex])))
163 |         print(_p(r1))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:162:46: warning: forced cast of '[[Complex]]' to same type has no effect
160 |     let v: [Complex] = ([Complex(re: 1.0, im: 0.0), Complex(re: 2.0, im: 0.0), Complex(re: 3.0, im: 0.0)] as! [Complex])
161 |     if is_hermitian((a as! [[Complex]])) {
162 |         let r1 = Double(rayleigh_quotient((a as! [[Complex]]), (v as! [Complex])))
    |                                              `- warning: forced cast of '[[Complex]]' to same type has no effect
163 |         print(_p(r1))
164 |         print(_p("\n"))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:162:67: warning: forced cast of '[Complex]' to same type has no effect
160 |     let v: [Complex] = ([Complex(re: 1.0, im: 0.0), Complex(re: 2.0, im: 0.0), Complex(re: 3.0, im: 0.0)] as! [Complex])
161 |     if is_hermitian((a as! [[Complex]])) {
162 |         let r1 = Double(rayleigh_quotient((a as! [[Complex]]), (v as! [Complex])))
    |                                                                   `- warning: forced cast of '[Complex]' to same type has no effect
163 |         print(_p(r1))
164 |         print(_p("\n"))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:167:24: warning: forced cast of '[[Complex]]' to same type has no effect
165 |     }
166 |     let b: [[Complex]] = ([([Complex(re: 1.0, im: 0.0), Complex(re: 2.0, im: 0.0), Complex(re: 4.0, im: 0.0)] as! [Complex]), ([Complex(re: 2.0, im: 0.0), Complex(re: 3.0, im: 0.0), Complex(re: -1.0, im: 0.0)] as! [Complex]), ([Complex(re: 4.0, im: 0.0), Complex(re: -1.0, im: 0.0), Complex(re: 1.0, im: 0.0)] as! [Complex])] as! [[Complex]])
167 |     if is_hermitian((b as! [[Complex]])) {
    |                        `- warning: forced cast of '[[Complex]]' to same type has no effect
168 |         let r2 = Double(rayleigh_quotient((b as! [[Complex]]), (v as! [Complex])))
169 |         print(_p(r2))

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:168:46: warning: forced cast of '[[Complex]]' to same type has no effect
166 |     let b: [[Complex]] = ([([Complex(re: 1.0, im: 0.0), Complex(re: 2.0, im: 0.0), Complex(re: 4.0, im: 0.0)] as! [Complex]), ([Complex(re: 2.0, im: 0.0), Complex(re: 3.0, im: 0.0), Complex(re: -1.0, im: 0.0)] as! [Complex]), ([Complex(re: 4.0, im: 0.0), Complex(re: -1.0, im: 0.0), Complex(re: 1.0, im: 0.0)] as! [Complex])] as! [[Complex]])
167 |     if is_hermitian((b as! [[Complex]])) {
168 |         let r2 = Double(rayleigh_quotient((b as! [[Complex]]), (v as! [Complex])))
    |                                              `- warning: forced cast of '[[Complex]]' to same type has no effect
169 |         print(_p(r2))
170 |     }

/tmp/TestSwiftTranspiler_Algorithms_Golden492_linear_algebra_src_rayleigh_quotient1042062292/001/main.swift:168:67: warning: forced cast of '[Complex]' to same type has no effect
166 |     let b: [[Complex]] = ([([Complex(re: 1.0, im: 0.0), Complex(re: 2.0, im: 0.0), Complex(re: 4.0, im: 0.0)] as! [Complex]), ([Complex(re: 2.0, im: 0.0), Complex(re: 3.0, im: 0.0), Complex(re: -1.0, im: 0.0)] as! [Complex]), ([Complex(re: 4.0, im: 0.0), Complex(re: -1.0, im: 0.0), Complex(re: 1.0, im: 0.0)] as! [Complex])] as! [[Complex]])
167 |     if is_hermitian((b as! [[Complex]])) {
168 |         let r2 = Double(rayleigh_quotient((b as! [[Complex]]), (v as! [Complex])))
    |                                                                   `- warning: forced cast of '[Complex]' to same type has no effect
169 |         print(_p(r2))
170 |     }
