// Generated by Mochi transpiler v0.10.61 on 2025-08-08 15:52:55 GMT+7
import Foundation
import Dispatch
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(DispatchTime.now().uptimeNanoseconds)
}
func _int(_ v: Any) -> Int {
    if let s = v as? String { return Int(s) ?? 0 }
    if let i = v as? Int { return i }
    if let i = v as? Int64 { return Int(i) }
    if let d = v as? Double { return Int(d) }
    return 0
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
func _set<T>(_ xs: [T], _ idx: Int, _ v: T) -> [T] {
    var out = xs
    if idx < out.count {
        out[idx] = v
    } else {
        out.append(contentsOf: Array(repeating: v, count: idx - out.count + 1))
        out[idx] = v
    }
    return out
}
func _set<K: Hashable, V>(_ xs: [K: V], _ key: K, _ v: V) -> [K: V] {
    var out = xs
    out[key] = v
    return out
}
struct Machine: Codable {
    var buffer: [Double]
    var params: [Double]
    var time: Int
    init() {
        self.buffer = []
        self.params = []
        self.time = 0
    }
    init(buffer: [Double], params: [Double], time: Int) {
        self.buffer = buffer
        self.params = params
        self.time = time
    }
}
struct PullResult: Codable {
    var value: Int
    var machine: Machine
    init() {
        self.value = 0
        self.machine = Machine()
    }
    init(value: Int, machine: Machine) {
        self.value = value
        self.machine = machine
    }
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    let K: [Double] = ([0.33, 0.44, 0.55, 0.44, 0.33] as! [Double])
    let t: Int = 3
    let size: Int = 5
    func round_dec(_ x: Double, _ n: Int) -> Double {
        var m10: Double = 1.0
        var i: Int = 0
        while (i < n) {
            m10 = Double((m10 * 10.0))
            i = _int((i &+ 1))
        }
        let y = ((x * m10) + 0.5)
        return (Double((1.0 * Double(_int(_int(y))))) / m10)
    }
    func reset() -> Machine {
        return Machine(buffer: K, params: ([0.0, 0.0, 0.0, 0.0, 0.0] as! [Double]), time: 0)
    }
    func push(_ m: Machine, _ seed: Int) -> Machine {
        var buf: [Double] = m.buffer
        var par: [Double] = m.params
        var i: Int = 0
        while (i < _int(((buf).count))) {
            let value = Double(buf[i])
            let e = (Double((1.0 * Double(seed))) / value)
            var next_value: Double = (Double(buf[((_int((i &+ 1)) % size + size) % size)]) + e)
            next_value = Double((next_value - Double((1.0 * Double(_int(_int(next_value)))))))
            var r: Double = (Double(par[i]) + e)
            r = Double((r - Double((1.0 * Double(_int(_int(r)))))))
            r = Double((r + 3.0))
            buf = _set(buf, i, Double(round_dec(Double(((r * next_value) * Double((1.0 - next_value)))), 10)))
            par = _set(par, i, Double(r))
            i = _int((i &+ 1))
        }
        return Machine(buffer: buf, params: par, time: (m.time &+ 1))
    }
    func xor(_ a: Int, _ b: Int) -> Int {
        var aa: Int = a
        var bb: Int = b
        var res: Int = 0
        var bit: Int = 1
        while ((aa > 0) || (bb > 0)) {
            let abit = ((aa % 2 + 2) % 2)
            let bbit = ((bb % 2 + 2) % 2)
            if (abit != bbit) {
                res = _int((res &+ bit))
            }
            aa = _int((aa / 2))
            bb = _int((bb / 2))
            bit = _int((bit &* 2))
        }
        return res
    }
    func xorshift(_ x: Int, _ y: Int) -> Int {
        var xv: Int = x
        var yv: Int = y
        xv = _int(xor(xv, (yv / 8192)))
        yv = _int(xor(yv, (xv &* 131072)))
        xv = _int(xor(xv, (yv / 32)))
        return xv
    }
    func pull(_ m: Machine) -> PullResult {
        var buf: [Double] = m.buffer
        var par: [Double] = m.params
        let key = ((m.time % size + size) % size)
        var i: Int = 0
        while (i < t) {
            let r = Double(par[key])
            let value = Double(buf[key])
            buf = _set(buf, key, Double(round_dec(Double(((r * value) * Double((1.0 - value)))), 10)))
            var new_r: Double = ((Double((1.0 * Double(m.time))) * 0.01) + (r * 1.01))
            new_r = Double((new_r - Double((1.0 * Double(_int(_int(new_r)))))))
            par = _set(par, key, Double((new_r + 3.0)))
            i = _int((i &+ 1))
        }
        let x = _int(_int((Double(buf[((_int((key &+ 2)) % size + size) % size)]) * 10000000000.0)))
        let y = _int(_int((Double(buf[((_int(((key &+ size) &- 2)) % size + size) % size)]) * 10000000000.0)))
        let new_machine = Machine(buffer: buf, params: par, time: (m.time &+ 1))
        let value = ((_int(xorshift(x, y)) % 4294967295 + 4294967295) % 4294967295)
        return PullResult(value: value, machine: new_machine)
    }
    var machine: Machine = reset()
    var i: Int = 0
    while (i < 100) {
        machine = (push((machine as! Machine), i) as! Machine)
        i = _int((i &+ 1))
    }
    var res = pull((machine as! Machine))
    print(_p(res.value))
    print(_p("[" + res.machine.buffer.map{ if let s = $0 as? String { "\"" + s.replacingOccurrences(of: "\"", with: "\\\"") + "\"" } else { _p($0) } }.joined(separator: ", ") + "]"))
    print(_p("[" + res.machine.params.map{ if let s = $0 as? String { "\"" + s.replacingOccurrences(of: "\"", with: "\\\"") + "\"" } else { _p($0) } }.joined(separator: ", ") + "]"))
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
