// Generated by Mochi transpiler v0.10.59 on 2025-08-06 20:58:54 GMT+7
import Foundation
import Dispatch
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(DispatchTime.now().uptimeNanoseconds)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
struct Result: Codable {
    var shift: Int
    var chi: Double
    var decoded: String
    init() {
        self.shift = 0
        self.chi = 0
        self.decoded = ""
    }
    init(shift: Int, chi: Double, decoded: String) {
        self.shift = shift
        self.chi = chi
        self.decoded = decoded
    }
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func default_alphabet() -> [String] {
        return (["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"] as! [String])
    }
    func default_frequencies() -> [String: Double] {
        return (["a": 0.08497, "b": 0.01492, "c": 0.02202, "d": 0.04253, "e": 0.11162, "f": 0.02228, "g": 0.02015, "h": 0.06094, "i": 0.07546, "j": 0.00153, "k": 0.01292, "l": 0.04025, "m": 0.02406, "n": 0.06749, "o": 0.07507, "p": 0.01929, "q": 0.00095, "r": 0.07587, "s": 0.06327, "t": 0.09356, "u": 0.02758, "v": 0.00978, "w": 0.0256, "x": 0.0015, "y": 0.01994, "z": 0.00077] as! [String: Double])
    }
    func index_of(_ xs: [String], _ ch: String) -> Int {
        var i: Int = 0
        while (i < Int(((xs).count))) {
            if ((xs[i] as! String) == ch) {
                return i
            }
            i = Int((i &+ 1))
        }
        return -1
    }
    func count_char(_ s: String, _ ch: String) -> Int {
        var count: Int = 0
        var i: Int = 0
        while (i < Int(((s).count))) {
            if (String(describing: String(Array(String(describing: (s as! String)))[i..<(i &+ 1)])) == ch) {
                count = Int((count &+ 1))
            }
            i = Int((i &+ 1))
        }
        return count
    }
    func decrypt_caesar_with_chi_squared(_ ciphertext: String, _ cipher_alphabet: [String], _ frequencies_dict: [String: Double], _ case_sensitive: Bool) -> Result {
        var ciphertext = ciphertext
        var alphabet_letters: [String] = cipher_alphabet
        if (Int(((alphabet_letters).count)) == 0) {
            alphabet_letters = (default_alphabet() as! [String])
        }
        var frequencies: [String: Double] = frequencies_dict
        if (Int(((frequencies).count)) == 0) {
            frequencies = (default_frequencies() as! [String: Double])
        }
        if (!case_sensitive) {
            ciphertext = String(describing: (ciphertext.lowercased()))
        }
        var best_shift: Int = 0
        var best_chi: Double = 0.0
        var best_text: String = ""
        var shift: Int = 0
        while (shift < Int(((alphabet_letters).count))) {
            var decrypted: String = ""
            var i: Int = 0
            while (i < Int(((ciphertext).count))) {
                let ch = String(describing: String(Array(String(describing: (ciphertext as! String)))[i..<(i &+ 1)]))
                let idx = Int(index_of((alphabet_letters as! [String]), String(describing: (ch.lowercased()))))
                if (idx >= 0) {
                    let m = Int(((alphabet_letters).count))
                    var new_idx: Int = (Int((idx &- shift)) % m)
                    if (new_idx < 0) {
                        new_idx = Int((new_idx &+ m))
                    }
                    let new_char = (alphabet_letters[new_idx] as! String)
                    if (case_sensitive && (ch != String(describing: (ch.lowercased())))) {
                        decrypted = ((decrypted + String(describing: ((new_char as! String).uppercased()))) as! String)
                    } else {
                        decrypted = ((decrypted + new_char) as! String)
                    }
                } else {
                    decrypted = ((decrypted + ch) as! String)
                }
                i = Int((i &+ 1))
            }
            var chi: Double = 0.0
            let lowered = String(describing: (case_sensitive ? String(describing: (decrypted.lowercased())) : decrypted))
            var j: Int = 0
            while (j < Int(((alphabet_letters).count))) {
                let letter = (alphabet_letters[j] as! String)
                let occ = Int(count_char((lowered as! String), (letter as! String)))
                if (occ > 0) {
                    let occf = Double(occ)
                    let expected = (Double(frequencies[String(String(describing: letter))]) * occf)
                    let diff = (occf - expected)
                    chi = Double((chi + (Double((Double((diff * diff)) / expected)) * occf)))
                }
                j = Int((j &+ 1))
            }
            if ((shift == 0) || (chi < best_chi)) {
                best_shift = Int(shift)
                best_chi = Double(chi)
                best_text = (decrypted as! String)
            }
            shift = Int((shift &+ 1))
        }
        return Result(shift: best_shift, chi: best_chi, decoded: best_text)
    }
    let r1 = decrypt_caesar_with_chi_squared("dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!", ([] as! [String]), ([:] as! [String: Double]), false)
    print(_p(((((String(describing: r1.shift) + ", ") + String(describing: r1.chi)) + ", ") + r1.decoded)))
    let r2 = decrypt_caesar_with_chi_squared("crybd cdbsxq", ([] as! [String]), ([:] as! [String: Double]), false)
    print(_p(((((String(describing: r2.shift) + ", ") + String(describing: r2.chi)) + ", ") + r2.decoded)))
    let r3 = decrypt_caesar_with_chi_squared("Crybd Cdbsxq", ([] as! [String]), ([:] as! [String: Double]), true)
    print(_p(((((String(describing: r3.shift) + ", ") + String(describing: r3.chi)) + ", ") + r3.decoded)))
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
