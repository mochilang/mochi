// Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:18:27 GMT+7
import Foundation
import Dispatch
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(DispatchTime.now().uptimeNanoseconds)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func int_pow(_ base: Int, _ exp: Int) -> Int {
        var result: Int = 1
        var i: Int = 0
        while (i < exp) {
            result = Int((result &* base))
            i = Int((i &+ 1))
        }
        return result
    }
    func pow_mod(_ base: Int, _ exp: Int, _ mod: Int) -> Int {
        var result: Int = 1
        var b: Int = (base % mod)
        var e: Int = exp
        while (e > 0) {
            if ((e % 2) == 1) {
                result = Int((Int((result &* b)) % mod))
            }
            e = Int((e / 2))
            b = Int((Int((b &* b)) % mod))
        }
        return result
    }
    func rand_range(_ low: Int, _ high: Int) -> Int {
        return (Int((Int(_now()) % Int((high &- low)))) &+ low)
    }
    func rabin_miller(_ num: Int) -> Bool {
        var s: Int = (num &- 1)
        var t: Int = 0
        while ((s % 2) == 0) {
            s = Int((s / 2))
            t = Int((t &+ 1))
        }
        var k: Int = 0
        while (k < 5) {
            let a = Int(rand_range(2, (num &- 1)))
            var v: Int = Int(pow_mod(a, s, num))
            if (v != 1) {
                var i: Int = 0
                while (v != Int((num &- 1))) {
                    if (i == (t &- 1)) {
                        return false
                    }
                    i = Int((i &+ 1))
                    v = Int((Int((v &* v)) % num))
                }
            }
            k = Int((k &+ 1))
        }
        return true
    }
    func is_prime_low_num(_ num: Int) -> Bool {
        if (num < 2) {
            return false
        }
        let low_primes: [Int] = ([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997] as! [Int])
        if (low_primes.contains(num)) {
            return true
        }
        var i: Int = 0
        while (i < Int(((low_primes).count))) {
            let p = (low_primes[i] as? Int ?? 0)
            if ((num % p) == 0) {
                return false
            }
            i = Int((i &+ 1))
        }
        return rabin_miller(num)
    }
    func generate_large_prime(_ keysize: Int) -> Int {
        var start: Int = Int(int_pow(2, (keysize &- 1)))
        var end: Int = Int(int_pow(2, keysize))
        while true {
            let num = Int(rand_range(start, end))
            if is_prime_low_num(num) {
                return num
            }
        }
    }
    let p = Int(generate_large_prime(16))
    print(_p(("Prime number: " + String(describing: p))))
    print(_p(("is_prime_low_num: " + String(describing: is_prime_low_num(p)))))
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
