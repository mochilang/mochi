// Generated by Mochi transpiler v0.10.66 on 2025-08-15 15:19:49 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <sstream>
#include <algorithm>
#include <type_traits>
#include <iomanip>
#include <cmath>
#include <optional>
#include <any>
#include <limits>
#include <cstdlib>
#include <chrono>
#include <sys/resource.h>
#include <unistd.h>
#include <cstdio>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
static long long _mem() {
#if defined(__linux__)
    long long rss = 0;
    FILE* f = std::fopen("/proc/self/statm", "r");
    if (f) { long long pages; if (std::fscanf(f, "%*s %lld", &pages) == 1) rss = pages * sysconf(_SC_PAGESIZE); std::fclose(f); }
    if (rss == 0) {
        f = std::fopen("/proc/self/status", "r");
        if (f) {
            char buf[256];
            while (std::fgets(buf, sizeof buf, f)) {
                long long val;
                if (std::sscanf(buf, "VmRSS: %lld", &val) == 1 || std::sscanf(buf, "VmHWM: %lld", &val) == 1) {
                    rss = val * 1024;
                    break;
                }
            }
            std::fclose(f);
        }
    }
    if (rss == 0) {
        struct rusage usage{};
        getrusage(RUSAGE_SELF, &usage);
        rss = (long long)usage.ru_maxrss * 1024;
    }
    return rss;
#elif defined(__APPLE__)
    struct rusage usage{};
    getrusage(RUSAGE_SELF, &usage);
    return (long long)usage.ru_maxrss;
#else
    struct rusage usage{};
    getrusage(RUSAGE_SELF, &usage);
    return (long long)usage.ru_maxrss * 1024;
#endif
}
static long long _bench_now() {
    return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
}
static long _parse_int_str(const std::string& s, long base) {
    if(s.empty()) return 0;
    return std::stol(s, nullptr, base);
}
template<typename V> auto _index(const V& v, int64_t i) {
    if (i < 0) i += v.size();
    if (i < 0 || i >= (int64_t)v.size()) return typename V::value_type{};
    return v[static_cast<size_t>(i)];
}
static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ' '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ' '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ' '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ' '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ' '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << " : "; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
static std::string any_to_string(const std::any& v) {
    if(v.type() == typeid(std::string)) return std::any_cast<std::string>(v);
    if(v.type() == typeid(int)) return std::to_string(std::any_cast<int>(v));
    if(v.type() == typeid(int64_t)) return std::to_string(std::any_cast<int64_t>(v));
    if(v.type() == typeid(double)) { std::ostringstream ss; ss << std::any_cast<double>(v); return ss.str(); }
    if(v.type() == typeid(bool)) return std::any_cast<bool>(v) ? "true" : "false";
    return std::string();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ' '; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    if constexpr(std::is_same_v<T, double>) {
        std::ostringstream ss;
        ss << std::defaultfloat << std::setprecision(16) << v;
        auto s = ss.str();
        auto epos = s.find('e');
        if(epos == std::string::npos) epos = s.find('E');
        std::string exp;
        if(epos != std::string::npos){ exp = s.substr(epos); s = s.substr(0, epos); }
        auto pos = s.find('.');
        if(pos != std::string::npos){
            while(!s.empty() && s.back() == '0') s.pop_back();
            if(!s.empty() && s.back() == '.') s.pop_back();
        }
        return s + exp;
    } else {
        std::ostringstream ss;
        ss << std::boolalpha << v;
        return ss.str();
    }
}
struct NodesData;
struct ClusterData;
struct GraphData;

std::ostream& operator<<(std::ostream&, const NodesData&);
std::ostream& operator<<(std::ostream&, const ClusterData&);
std::ostream& operator<<(std::ostream&, const GraphData&);


struct NodesData {
    std::map<std::string, std::vector<std::string>> map;
    std::vector<std::string> keys;
    auto operator<=>(const NodesData&) const = default;
};

struct ClusterData {
    std::map<int64_t, std::vector<std::string>> clusters;
    std::vector<int64_t> weights;
    auto operator<=>(const ClusterData&) const = default;
};

struct GraphData {
    std::map<std::string, std::vector<std::string>> edges;
    std::vector<std::string> keys;
    auto operator<=>(const GraphData&) const = default;
};

std::ostream& operator<<(std::ostream& os, const NodesData& v) {
    os << '{' << "'map': "<< "{"; bool first_0=true; for(const auto& p: v.map){ if(!first_0) os << ", "; first_0=false; os << p.first; os << ': '; os << p.second; } os << "}"
 << ", " << "'keys': "<< "["; for(size_t i=0;i<v.keys.size();++i){ if(i>0) os << ", "; os << v.keys[i]; } os << "]"
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const ClusterData& v) {
    os << '{' << "'clusters': "<< "{"; bool first_0=true; for(const auto& p: v.clusters){ if(!first_0) os << ", "; first_0=false; os << p.first; os << ': '; os << p.second; } os << "}"
 << ", " << "'weights': "<< "["; for(size_t i=0;i<v.weights.size();++i){ if(i>0) os << ", "; os << v.weights[i]; } os << "]"
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const GraphData& v) {
    os << '{' << "'edges': "<< "{"; bool first_0=true; for(const auto& p: v.edges){ if(!first_0) os << ", "; first_0=false; os << p.first; os << ': '; os << p.second; } os << "}"
 << ", " << "'keys': "<< "["; for(size_t i=0;i<v.keys.size();++i){ if(i>0) os << ", "; os << v.keys[i]; } os << "]"
 << '}';
    return os;
}

bool contains(const std::vector<std::string>& lst, std::string item);
std::vector<std::string> get_distinct_edge(const std::vector<std::vector<std::vector<std::string>>>& edge_array);
std::string get_bitcode(const std::vector<std::vector<std::vector<std::string>>>& edge_array, std::string de);
int64_t count_ones(std::string s);
std::vector<std::map<std::string, std::string>> get_frequency_table(const std::vector<std::vector<std::vector<std::string>>>& edge_array);
NodesData get_nodes(const std::vector<std::map<std::string, std::string>>& freq_table);
ClusterData get_cluster(const NodesData& nodes);
std::vector<int64_t> get_support(const ClusterData& clusters);
bool contains_bits(std::string a, std::string b);
int64_t max_cluster_key(const ClusterData& clusters);
std::vector<std::string> get_cluster_codes(const ClusterData& clusters, int64_t wt);
std::vector<std::string> create_edge(const NodesData& nodes, std::map<std::string, std::vector<std::string>>& graph, const std::vector<std::string>& gkeys, const ClusterData& clusters, int64_t c1, int64_t maxk);
GraphData construct_graph(const ClusterData& clusters, const NodesData& nodes);
std::vector<std::string> copy_list(const std::vector<std::string>& lst);
void my_dfs(const std::map<std::string, std::vector<std::string>>& graph, std::string start, std::string end, const std::vector<std::string>& path);
void find_freq_subgraph_given_support(int64_t s, const ClusterData& clusters, const GraphData& graph);
std::vector<std::string> node_edges(const NodesData& nodes, std::string code);
std::vector<std::vector<std::vector<std::string>>> freq_subgraphs_edge_list(const std::vector<std::vector<std::string>>& paths, const NodesData& nodes);
void print_all(const NodesData& nodes, const std::vector<int64_t>& support, const ClusterData& clusters, const GraphData& graph, const std::vector<std::vector<std::vector<std::string>>>& freq_subgraph_edge_list);
int main();

std::vector<std::vector<std::vector<std::string>>> EDGE_ARRAY = std::vector<std::vector<std::vector<std::string>>>{std::vector<std::vector<std::string>>{std::vector<std::string>{std::string("ab"), std::string("e1")}, std::vector<std::string>{std::string("ac"), std::string("e3")}, std::vector<std::string>{std::string("ad"), std::string("e5")}, std::vector<std::string>{std::string("bc"), std::string("e4")}, std::vector<std::string>{std::string("bd"), std::string("e2")}, std::vector<std::string>{std::string("be"), std::string("e6")}, std::vector<std::string>{std::string("bh"), std::string("e12")}, std::vector<std::string>{std::string("cd"), std::string("e2")}, std::vector<std::string>{std::string("ce"), std::string("e4")}, std::vector<std::string>{std::string("de"), std::string("e1")}, std::vector<std::string>{std::string("df"), std::string("e8")}, std::vector<std::string>{std::string("dg"), std::string("e5")}, std::vector<std::string>{std::string("dh"), std::string("e10")}, std::vector<std::string>{std::string("ef"), std::string("e3")}, std::vector<std::string>{std::string("eg"), std::string("e2")}, std::vector<std::string>{std::string("fg"), std::string("e6")}, std::vector<std::string>{std::string("gh"), std::string("e6")}, std::vector<std::string>{std::string("hi"), std::string("e3")}}, std::vector<std::vector<std::string>>{std::vector<std::string>{std::string("ab"), std::string("e1")}, std::vector<std::string>{std::string("ac"), std::string("e3")}, std::vector<std::string>{std::string("ad"), std::string("e5")}, std::vector<std::string>{std::string("bc"), std::string("e4")}, std::vector<std::string>{std::string("bd"), std::string("e2")}, std::vector<std::string>{std::string("be"), std::string("e6")}, std::vector<std::string>{std::string("cd"), std::string("e2")}, std::vector<std::string>{std::string("de"), std::string("e1")}, std::vector<std::string>{std::string("df"), std::string("e8")}, std::vector<std::string>{std::string("ef"), std::string("e3")}, std::vector<std::string>{std::string("eg"), std::string("e2")}, std::vector<std::string>{std::string("fg"), std::string("e6")}}, std::vector<std::vector<std::string>>{std::vector<std::string>{std::string("ab"), std::string("e1")}, std::vector<std::string>{std::string("ac"), std::string("e3")}, std::vector<std::string>{std::string("bc"), std::string("e4")}, std::vector<std::string>{std::string("bd"), std::string("e2")}, std::vector<std::string>{std::string("de"), std::string("e1")}, std::vector<std::string>{std::string("df"), std::string("e8")}, std::vector<std::string>{std::string("dg"), std::string("e5")}, std::vector<std::string>{std::string("ef"), std::string("e3")}, std::vector<std::string>{std::string("eg"), std::string("e2")}, std::vector<std::string>{std::string("eh"), std::string("e12")}, std::vector<std::string>{std::string("fg"), std::string("e6")}, std::vector<std::string>{std::string("fh"), std::string("e10")}, std::vector<std::string>{std::string("gh"), std::string("e6")}}, std::vector<std::vector<std::string>>{std::vector<std::string>{std::string("ab"), std::string("e1")}, std::vector<std::string>{std::string("ac"), std::string("e3")}, std::vector<std::string>{std::string("bc"), std::string("e4")}, std::vector<std::string>{std::string("bd"), std::string("e2")}, std::vector<std::string>{std::string("bh"), std::string("e12")}, std::vector<std::string>{std::string("cd"), std::string("e2")}, std::vector<std::string>{std::string("df"), std::string("e8")}, std::vector<std::string>{std::string("dh"), std::string("e10")}}, std::vector<std::vector<std::string>>{std::vector<std::string>{std::string("ab"), std::string("e1")}, std::vector<std::string>{std::string("ac"), std::string("e3")}, std::vector<std::string>{std::string("ad"), std::string("e5")}, std::vector<std::string>{std::string("bc"), std::string("e4")}, std::vector<std::string>{std::string("bd"), std::string("e2")}, std::vector<std::string>{std::string("cd"), std::string("e2")}, std::vector<std::string>{std::string("ce"), std::string("e4")}, std::vector<std::string>{std::string("de"), std::string("e1")}, std::vector<std::string>{std::string("df"), std::string("e8")}, std::vector<std::string>{std::string("dg"), std::string("e5")}, std::vector<std::string>{std::string("ef"), std::string("e3")}, std::vector<std::string>{std::string("eg"), std::string("e2")}, std::vector<std::string>{std::string("fg"), std::string("e6")}}};
std::vector<std::vector<std::string>> paths = {};

bool contains(const std::vector<std::string>& lst, std::string item) {
    for (std::string v : lst) {
        if ((v == item)) {
            return true;
        }
    }
    return false;
}

std::vector<std::string> get_distinct_edge(const std::vector<std::vector<std::vector<std::string>>>& edge_array) {
    std::vector<std::string> distinct = {};
    for (std::vector<std::vector<std::string>> row : edge_array) {
        for (std::vector<std::string> item : row) {
            std::string e = _index(item, int64_t(0));
            if (!contains(distinct, e)) {
                distinct = ([&]{ auto __tmp = distinct; __tmp.push_back(e); return __tmp; }());
            }
        }
    }
    return distinct;
}

std::string get_bitcode(const std::vector<std::vector<std::vector<std::string>>>& edge_array, std::string de) {
    std::string bitcode = std::string("");
    int64_t i = int64_t(0);
    while ((i < edge_array.size())) {
        bool found = false;
        for (std::vector<std::string> item : _index(edge_array, i)) {
            if ((_index(item, int64_t(0)) == de)) {
                found = true;
                break;
            }
        }
        if (found) {
            bitcode = (bitcode + std::string("1"));
        } else {
            bitcode = (bitcode + std::string("0"));
        }
        i = (i + int64_t(1));
    }
    return bitcode;
}

int64_t count_ones(std::string s) {
    int64_t c = int64_t(0);
    int64_t i = int64_t(0);
    while ((i < s.size())) {
        if ((([&]{ std::string __s = s; long long __start = i; long long __end = (i + int64_t(1)); if(__start < 0) __start = 0; if(__end < __start) __end = __start; if(__start > static_cast<long long>(__s.size())) __start = __s.size(); if(__end > static_cast<long long>(__s.size())) __end = __s.size(); return __s.substr(static_cast<size_t>(__start), static_cast<size_t>(__end - __start)); })() == std::string("1"))) {
            c = (c + int64_t(1));
        }
        i = (i + int64_t(1));
    }
    return c;
}

std::vector<std::map<std::string, std::string>> get_frequency_table(const std::vector<std::vector<std::vector<std::string>>>& edge_array) {
    std::vector<std::string> distinct = get_distinct_edge(edge_array);
    std::vector<std::map<std::string, std::string>> table = {};
    for (std::string e : distinct) {
        std::string bit = get_bitcode(edge_array, e);
        int64_t cnt = count_ones(bit);
        std::map<std::string, std::string> entry = {{"edge", e}, {"count", ([&]{ std::ostringstream ss; ss << std::boolalpha << cnt; return ss.str(); }())}, {"bit", bit}};
        table = ([&]{ auto __tmp = table; __tmp.push_back(entry); return __tmp; }());
    }
    int64_t i = int64_t(0);
    while ((i < table.size())) {
        int64_t max_i = i;
        int64_t j = (i + int64_t(1));
        while ((j < table.size())) {
            if (((double)(_parse_int_str(([&](const auto& __m){ auto __it = __m.find(std::string("count")); if (__it == __m.end()) return std::string{}; return __it->second; })(_index(table, j)), int64_t(10))) > (double)(_parse_int_str(([&](const auto& __m){ auto __it = __m.find(std::string("count")); if (__it == __m.end()) return std::string{}; return __it->second; })(_index(table, max_i)), int64_t(10))))) {
                max_i = j;
            }
            j = (j + int64_t(1));
        }
        std::map<std::string, std::string> tmp = _index(table, i);
        table[static_cast<size_t>(i)] = _index(table, max_i);
        table[static_cast<size_t>(max_i)] = tmp;
        i = (i + int64_t(1));
    }
    return table;
}

NodesData get_nodes(const std::vector<std::map<std::string, std::string>>& freq_table) {
    std::map<std::string, std::vector<std::string>> nodes = {};
    std::vector<std::string> keys = {};
    for (std::map<std::string, std::string> f : freq_table) {
        std::string code = ([&](const auto& __m){ auto __it = __m.find(std::string("bit")); if (__it == __m.end()) return std::string{}; return __it->second; })(f);
        std::string edge = ([&](const auto& __m){ auto __it = __m.find(std::string("edge")); if (__it == __m.end()) return std::string{}; return __it->second; })(f);
        if (([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(nodes, code)) {
            nodes[code] = ([&]{ auto __tmp = ([&](const auto& __m){ auto __it = __m.find(code); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(nodes); __tmp.push_back(edge); return __tmp; }());
        } else {
            nodes[code] = std::vector<std::string>{edge};
            keys = ([&]{ auto __tmp = keys; __tmp.push_back(code); return __tmp; }());
        }
    }
    return NodesData{.map = nodes, .keys = keys};
}

ClusterData get_cluster(const NodesData& nodes) {
    std::map<int64_t, std::vector<std::string>> clusters = {};
    std::vector<int64_t> weights = {};
    int64_t i = int64_t(0);
    while ((i < nodes.keys.size())) {
        std::string code = _index(nodes.keys, i);
        int64_t wt = count_ones(code);
        if (([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(clusters, wt)) {
            clusters[static_cast<size_t>(wt)] = ([&]{ auto __tmp = ([&](const auto& __m){ auto __it = __m.find(wt); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(clusters); __tmp.push_back(code); return __tmp; }());
        } else {
            clusters[static_cast<size_t>(wt)] = std::vector<std::string>{code};
            weights = ([&]{ auto __tmp = weights; __tmp.push_back(wt); return __tmp; }());
        }
        i = (i + int64_t(1));
    }
    return ClusterData{.clusters = clusters, .weights = weights};
}

std::vector<int64_t> get_support(const ClusterData& clusters) {
    std::vector<int64_t> sup = {};
    int64_t i = int64_t(0);
    while ((i < clusters.weights.size())) {
        int64_t w = _index(clusters.weights, i);
        sup = ([&]{ auto __tmp = sup; __tmp.push_back(((w * int64_t(100)) / clusters.weights.size())); return __tmp; }());
        i = (i + int64_t(1));
    }
    return sup;
}

bool contains_bits(std::string a, std::string b) {
    int64_t i = int64_t(0);
    while ((i < a.size())) {
        std::string c1 = ([&]{ std::string __s = a; long long __start = i; long long __end = (i + int64_t(1)); if(__start < 0) __start = 0; if(__end < __start) __end = __start; if(__start > static_cast<long long>(__s.size())) __start = __s.size(); if(__end > static_cast<long long>(__s.size())) __end = __s.size(); return __s.substr(static_cast<size_t>(__start), static_cast<size_t>(__end - __start)); })();
        std::string c2 = ([&]{ std::string __s = b; long long __start = i; long long __end = (i + int64_t(1)); if(__start < 0) __start = 0; if(__end < __start) __end = __start; if(__start > static_cast<long long>(__s.size())) __start = __s.size(); if(__end > static_cast<long long>(__s.size())) __end = __s.size(); return __s.substr(static_cast<size_t>(__start), static_cast<size_t>(__end - __start)); })();
        if (((c1 == std::string("1")) && (c2 != std::string("1")))) {
            return false;
        }
        i = (i + int64_t(1));
    }
    return true;
}

int64_t max_cluster_key(const ClusterData& clusters) {
    int64_t m = int64_t(0);
    int64_t i = int64_t(0);
    while ((i < clusters.weights.size())) {
        int64_t w = _index(clusters.weights, i);
        if ((w > m)) {
            m = w;
        }
        i = (i + int64_t(1));
    }
    return m;
}

std::vector<std::string> get_cluster_codes(const ClusterData& clusters, int64_t wt) {
    if (([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(clusters.clusters, wt)) {
        return ([&](const auto& __m){ auto __it = __m.find(wt); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(clusters.clusters);
    }
    return std::vector<std::string>{};
}

std::vector<std::string> create_edge(const NodesData& nodes, std::map<std::string, std::vector<std::string>>& graph, const std::vector<std::string>& gkeys, const ClusterData& clusters, int64_t c1, int64_t maxk) {
    std::vector<std::string> keys = gkeys;
    std::vector<std::string> codes1 = get_cluster_codes(clusters, c1);
    int64_t idx1 = int64_t(0);
    while ((idx1 < codes1.size())) {
        std::string i_code = _index(codes1, idx1);
        int64_t count = int64_t(0);
        int64_t c2 = (c1 + int64_t(1));
        while ((c2 <= maxk)) {
            std::vector<std::string> codes2 = get_cluster_codes(clusters, c2);
            int64_t j = int64_t(0);
            while ((j < codes2.size())) {
                std::string j_code = _index(codes2, j);
                if (contains_bits(i_code, j_code)) {
                    if (([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(graph, i_code)) {
                        graph[i_code] = ([&]{ auto __tmp = ([&](const auto& __m){ auto __it = __m.find(i_code); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(graph); __tmp.push_back(j_code); return __tmp; }());
                    } else {
                        graph[i_code] = std::vector<std::string>{j_code};
                        if (!contains(keys, i_code)) {
                            keys = ([&]{ auto __tmp = keys; __tmp.push_back(i_code); return __tmp; }());
                        }
                    }
                    if (!contains(keys, j_code)) {
                        keys = ([&]{ auto __tmp = keys; __tmp.push_back(j_code); return __tmp; }());
                    }
                    count = (count + int64_t(1));
                }
                j = (j + int64_t(1));
            }
            if ((count == int64_t(0))) {
                c2 = (c2 + int64_t(1));
            } else {
                break;
            }
        }
        idx1 = (idx1 + int64_t(1));
    }
    return keys;
}

GraphData construct_graph(const ClusterData& clusters, const NodesData& nodes) {
    int64_t maxk = max_cluster_key(clusters);
    std::vector<std::string> top_codes = get_cluster_codes(clusters, maxk);
    std::map<std::string, std::vector<std::string>> graph = {};
    std::vector<std::string> keys = std::vector<std::string>{std::string("Header")};
    graph[std::string("Header")] = std::vector<std::string>{};
    int64_t i = int64_t(0);
    while ((i < top_codes.size())) {
        std::string code = _index(top_codes, i);
        graph[std::string("Header")] = ([&]{ auto __tmp = ([&](const auto& __m){ auto __it = __m.find(std::string("Header")); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(graph); __tmp.push_back(code); return __tmp; }());
        graph[code] = std::vector<std::string>{std::string("Header")};
        keys = ([&]{ auto __tmp = keys; __tmp.push_back(code); return __tmp; }());
        i = (i + int64_t(1));
    }
    int64_t c = int64_t(1);
    while ((c < maxk)) {
        keys = create_edge(nodes, graph, keys, clusters, c, maxk);
        c = (c + int64_t(1));
    }
    return GraphData{.edges = graph, .keys = keys};
}

std::vector<std::string> copy_list(const std::vector<std::string>& lst) {
    std::vector<std::string> n = {};
    for (std::string v : lst) {
        n = ([&]{ auto __tmp = n; __tmp.push_back(v); return __tmp; }());
    }
    return n;
}

void my_dfs(const std::map<std::string, std::vector<std::string>>& graph, std::string start, std::string end, const std::vector<std::string>& path) {
    std::vector<std::string> new_path = copy_list(path);
    new_path = ([&]{ auto __tmp = new_path; __tmp.push_back(start); return __tmp; }());
    if ((start == end)) {
        paths = ([&]{ auto __tmp = paths; __tmp.push_back(new_path); return __tmp; }());
        return;
    }
    for (std::string node : ([&](const auto& __m){ auto __it = __m.find(start); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(graph)) {
        bool seen = false;
        for (std::string p : new_path) {
            if ((p == node)) {
                seen = true;
            }
        }
        if (!seen) {
            my_dfs(graph, node, end, new_path);
        }
    }
}

void find_freq_subgraph_given_support(int64_t s, const ClusterData& clusters, const GraphData& graph) {
    int64_t k = ((s * clusters.weights.size()) / int64_t(100));
    std::vector<std::string> codes = get_cluster_codes(clusters, k);
    int64_t i = int64_t(0);
    while ((i < codes.size())) {
        my_dfs(graph.edges, _index(codes, i), std::string("Header"), std::vector<std::string>{});
        i = (i + int64_t(1));
    }
}

std::vector<std::string> node_edges(const NodesData& nodes, std::string code) {
    return ([&](const auto& __m){ auto __it = __m.find(code); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(nodes.map);
}

std::vector<std::vector<std::vector<std::string>>> freq_subgraphs_edge_list(const std::vector<std::vector<std::string>>& paths, const NodesData& nodes) {
    std::vector<std::vector<std::vector<std::string>>> freq_sub_el = {};
    for (std::vector<std::string> path : paths) {
        std::vector<std::vector<std::string>> el = {};
        int64_t j = int64_t(0);
        while ((j < (path.size() - int64_t(1)))) {
            std::string code = _index(path, j);
            std::vector<std::string> edge_list = node_edges(nodes, code);
            int64_t e = int64_t(0);
            while ((e < edge_list.size())) {
                std::string edge = _index(edge_list, e);
                std::string a = ([&]{ std::string __s = edge; long long __start = int64_t(0); long long __end = int64_t(1); if(__start < 0) __start = 0; if(__end < __start) __end = __start; if(__start > static_cast<long long>(__s.size())) __start = __s.size(); if(__end > static_cast<long long>(__s.size())) __end = __s.size(); return __s.substr(static_cast<size_t>(__start), static_cast<size_t>(__end - __start)); })();
                std::string b = ([&]{ std::string __s = edge; long long __start = int64_t(1); long long __end = int64_t(2); if(__start < 0) __start = 0; if(__end < __start) __end = __start; if(__start > static_cast<long long>(__s.size())) __start = __s.size(); if(__end > static_cast<long long>(__s.size())) __end = __s.size(); return __s.substr(static_cast<size_t>(__start), static_cast<size_t>(__end - __start)); })();
                el = ([&]{ auto __tmp = el; __tmp.push_back(std::vector<std::string>{a, b}); return __tmp; }());
                e = (e + int64_t(1));
            }
            j = (j + int64_t(1));
        }
        freq_sub_el = ([&]{ auto __tmp = freq_sub_el; __tmp.push_back(el); return __tmp; }());
    }
    return freq_sub_el;
}

void print_all(const NodesData& nodes, const std::vector<int64_t>& support, const ClusterData& clusters, const GraphData& graph, const std::vector<std::vector<std::vector<std::string>>>& freq_subgraph_edge_list) {
    std::cout << std::string("\nNodes\n");
    std::cout << std::endl;
    int64_t i = int64_t(0);
    while ((i < nodes.keys.size())) {
        std::string code = _index(nodes.keys, i);
        std::cout << code;
        std::cout << std::endl;
        { auto __tmp1 = ([&](const auto& __m){ auto __it = __m.find(code); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(nodes.map); std::cout << "["; for(size_t i=0;i<__tmp1.size();++i){ if(i>0) std::cout << ' '; std::cout << __tmp1[i]; } std::cout << "]"; }
        std::cout << std::endl;
        i = (i + int64_t(1));
    }
    std::cout << std::string("\nSupport\n");
    std::cout << std::endl;
    { auto __tmp2 = support; std::cout << "["; for(size_t i=0;i<__tmp2.size();++i){ if(i>0) std::cout << ' '; std::cout << __tmp2[i]; } std::cout << "]"; }
    std::cout << std::endl;
    std::cout << std::string("\nCluster\n");
    std::cout << std::endl;
    int64_t j = int64_t(0);
    while ((j < clusters.weights.size())) {
        int64_t w = _index(clusters.weights, j);
        std::cout << ((([&]{ std::ostringstream ss; ss << std::boolalpha << w; return ss.str(); }()) + std::string(":")) + ([&]{ std::ostringstream ss; { auto __tmp3 = ([&](const auto& __m){ auto __it = __m.find(w); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(clusters.clusters); ss << "["; for(size_t i=0;i<__tmp3.size();++i){ if(i>0) ss << ' '; ss << __tmp3[i]; } ss << "]"; }
 return ss.str(); }()));
        std::cout << std::endl;
        j = (j + int64_t(1));
    }
    std::cout << std::string("\nGraph\n");
    std::cout << std::endl;
    int64_t k = int64_t(0);
    while ((k < graph.keys.size())) {
        std::string key = _index(graph.keys, k);
        std::cout << key;
        std::cout << std::endl;
        { auto __tmp4 = ([&](const auto& __m){ auto __it = __m.find(key); if (__it == __m.end()) return std::vector<std::string>{}; return __it->second; })(graph.edges); std::cout << "["; for(size_t i=0;i<__tmp4.size();++i){ if(i>0) std::cout << ' '; std::cout << __tmp4[i]; } std::cout << "]"; }
        std::cout << std::endl;
        k = (k + int64_t(1));
    }
    std::cout << std::string("\nEdge List of Frequent subgraphs\n");
    std::cout << std::endl;
    for (std::vector<std::vector<std::string>> el : freq_subgraph_edge_list) {
        { auto __tmp5 = el; std::cout << "["; for(size_t i=0;i<__tmp5.size();++i){ if(i>0) std::cout << ' '; { std::ostringstream __ss;         { auto __tmp6 = _index(__tmp5, i); __ss << "["; for(size_t i=0;i<__tmp6.size();++i){ if(i>0) __ss << ' '; __ss << __tmp6[i]; } __ss << "]"; }
 std::cout << __ss.str(); }; } std::cout << "]"; }
        std::cout << std::endl;
    }
}

int main() {
    {
        struct __BenchGuard {
            long long start;
            __BenchGuard() : start(_bench_now()) {}
            ~__BenchGuard() {
                    auto __bench_end = _bench_now();
                    auto __bench_mem = _mem();
                    auto __bench_dur = __bench_end - start;
                    std::cout << "{\n  \"duration_us\": " << __bench_dur << ",\n  \"memory_bytes\": " << __bench_mem << ",\n  \"name\": \"main\"\n}" << std::endl;
            }
        } __bench_guard;
        std::vector<std::map<std::string, std::string>> frequency_table = get_frequency_table(EDGE_ARRAY);
        NodesData nodes = get_nodes(frequency_table);
        ClusterData clusters = get_cluster(nodes);
        std::vector<int64_t> support = get_support(clusters);
        GraphData graph = construct_graph(clusters, nodes);
        find_freq_subgraph_given_support(int64_t(60), clusters, graph);
        std::vector<std::vector<std::vector<std::string>>> freq_subgraph_edge_list = freq_subgraphs_edge_list(paths, nodes);
        print_all(nodes, support, clusters, graph, freq_subgraph_edge_list);
    }
    return 0;
}
