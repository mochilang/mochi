// Generated by Mochi Zig transpiler on 2025-08-14 16:41 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Rectangle = struct {
    short_side: Side,
    long_side: Side,
    poly: Polygon,
};

const Square = struct {
    side: Side,
    rect: Rectangle,
};

const Angle = struct {
    degrees: f64,
};

const Side = struct {
    length: f64,
    angle: Angle,
    next: i64,
};

const Ellipse = struct {
    major: f64,
    minor: f64,
};

const Circle = struct {
    radius: f64,
};

const Polygon = struct {
    sides: []Side,
};

const PI_var: f64 = 3.141592653589793;

fn make_angle(deg: f64) Angle {
    if (deg < 0.0 or deg > 360.0) {
        @panic("degrees must be between 0 and 360");
    }
    return .{ .degrees = deg };
}

fn make_side(length: f64, angle: Angle) Side {
    if (length <= 0.0) {
        @panic("length must be positive");
    }
    return .{ .length = length, .angle = angle, .next = 0 - 1 };
}

fn ellipse_area(e: Ellipse) f64 {
    return PI_var * e.major * e.minor;
}

fn ellipse_perimeter(e: Ellipse) f64 {
    return PI_var * (e.major + e.minor);
}

fn circle_area(c: Circle) f64 {
    const e: Ellipse = .{ .major = c.radius, .minor = c.radius };
    const area: f64 = ellipse_area(e);
    return area;
}

fn circle_perimeter(c: Circle) f64 {
    const e: Ellipse = .{ .major = c.radius, .minor = c.radius };
    const per: f64 = ellipse_perimeter(e);
    return per;
}

fn circle_diameter(c: Circle) f64 {
    return c.radius * 2.0;
}

fn circle_max_parts(num_cuts: f64) f64 {
    if (num_cuts < 0.0) {
        @panic("num_cuts must be positive");
    }
    return (num_cuts + 2.0 + num_cuts * num_cuts) * 0.5;
}

fn make_polygon() Polygon {
    const s: []Side = std.heap.page_allocator.alloc(Side, 0) catch unreachable;
    return .{ .sides = s };
}

fn polygon_add_side(p_param: *Polygon, s: Side) void {
    p_param.sides = blk: { var _tmp = std.ArrayList(Side).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const Side, p_param.sides)) catch |err| handleError(err); _tmp.append(s) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
}

fn polygon_get_side(p: Polygon, index: i64) Side {
    return p.sides[_idx(p.sides.len, index)];
}

fn polygon_set_side(p_param: *Polygon, index: i64, s: Side) void {
    var tmp: []Side = p_param.sides;
    tmp = tmp;
    tmp[_idx(tmp.len, index)] = s;
    p_param.sides = tmp;
}

fn make_rectangle(short_len: f64, long_len: f64) Rectangle {
    if (short_len <= 0.0 or long_len <= 0.0) {
        @panic("length must be positive");
    }
    const short: Side = make_side(short_len, make_angle(90.0));
    const long: Side = make_side(long_len, make_angle(90.0));
    const p: Polygon = make_polygon();
    polygon_add_side(@constCast(&p), short);
    polygon_add_side(@constCast(&p), long);
    return .{ .short_side = short, .long_side = long, .poly = p };
}

fn rectangle_perimeter(r: Rectangle) f64 {
    return (r.short_side.length + r.long_side.length) * 2.0;
}

fn rectangle_area(r: Rectangle) f64 {
    return r.short_side.length * r.long_side.length;
}

fn make_square(side_len: f64) Square {
    const rect: Rectangle = make_rectangle(side_len, side_len);
    return .{ .side = rect.short_side, .rect = rect };
}

fn square_perimeter(s: Square) f64 {
    const p: f64 = rectangle_perimeter(s.rect);
    return p;
}

fn square_area(s: Square) f64 {
    const a: f64 = rectangle_area(s.rect);
    return a;
}

fn mochi_main() void {
    const a: Angle = make_angle(90.0);
    std.debug.print("{d}\n", .{a.degrees});
    const s: Side = make_side(5.0, a);
    std.debug.print("{d}\n", .{s.length});
    const e: Ellipse = .{ .major = 5.0, .minor = 10.0 };
    std.debug.print("{d}\n", .{ellipse_area(e)});
    std.debug.print("{d}\n", .{ellipse_perimeter(e)});
    const c: Circle = .{ .radius = 5.0 };
    std.debug.print("{d}\n", .{circle_area(c)});
    std.debug.print("{d}\n", .{circle_perimeter(c)});
    std.debug.print("{d}\n", .{circle_diameter(c)});
    std.debug.print("{d}\n", .{circle_max_parts(7.0)});
    const r: Rectangle = make_rectangle(5.0, 10.0);
    std.debug.print("{d}\n", .{rectangle_perimeter(r)});
    std.debug.print("{d}\n", .{rectangle_area(r)});
    const q: Square = make_square(5.0);
    std.debug.print("{d}\n", .{square_perimeter(q)});
    std.debug.print("{d}\n", .{square_area(q)});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        mochi_main();
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
