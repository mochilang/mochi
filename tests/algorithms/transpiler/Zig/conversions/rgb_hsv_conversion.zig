// Generated by Mochi Zig transpiler on 2025-08-07 14:57 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

var rgb_var: []i64 = &[_]i64{};
var hsv_var: []f64 = &[_]f64{};

fn absf(x: f64) f64 {
    if (x < 0.0) {
        return @as(f64, @floatFromInt(0)) - x;
    }
    return x;
}

fn fmod(a: f64, b: f64) f64 {
    return a - b * @as(f64, @floatFromInt(@as(i64, @intFromFloat(a / b))));
}

fn roundf(x: f64) i64 {
    if (x >= 0.0) {
        return @as(i64, @intFromFloat(x + 0.5));
    }
    return @as(i64, @intFromFloat(x - 0.5));
}

fn maxf(a: f64, b: f64, c: f64) f64 {
    var m: f64 = a;
    m = m;
    if (b > m) {
        m = b;
    }
    if (c > m) {
        m = c;
    }
    return m;
}

fn minf(a: f64, b: f64, c: f64) f64 {
    var m: f64 = a;
    m = m;
    if (b < m) {
        m = b;
    }
    if (c < m) {
        m = c;
    }
    return m;
}

fn hsv_to_rgb(hue: f64, saturation: f64, value: f64) []i64 {
    if (hue < 0.0 or hue > 360.0) {
        std.debug.print("{s}\n", .{"hue should be between 0 and 360"});
        return &[_]i64{};
    }
    if (saturation < 0.0 or saturation > 1.0) {
        std.debug.print("{s}\n", .{"saturation should be between 0 and 1"});
        return &[_]i64{};
    }
    if (value < 0.0 or value > 1.0) {
        std.debug.print("{s}\n", .{"value should be between 0 and 1"});
        return &[_]i64{};
    }
    var chroma: f64 = value * saturation;
    chroma = chroma;
    var hue_section: f64 = hue / 60.0;
    hue_section = hue_section;
    var second_largest_component: f64 = chroma * (1.0 - absf(fmod(hue_section, 2.0) - 1.0));
    second_largest_component = second_largest_component;
    var match_value: f64 = value - chroma;
    match_value = match_value;
    var red: i64 = 0;
    red = red;
    var green: i64 = 0;
    green = green;
    var blue: i64 = 0;
    blue = blue;
    if (hue_section >= 0.0 and hue_section <= 1.0) {
        red = roundf(255.0 * (chroma + match_value));
        green = roundf(255.0 * (second_largest_component + match_value));
        blue = roundf(255.0 * match_value);
    } else {
        if (hue_section > 1.0 and hue_section <= 2.0) {
            red = roundf(255.0 * (second_largest_component + match_value));
            green = roundf(255.0 * (chroma + match_value));
            blue = roundf(255.0 * match_value);
        } else {
            if (hue_section > 2.0 and hue_section <= 3.0) {
                red = roundf(255.0 * match_value);
                green = roundf(255.0 * (chroma + match_value));
                blue = roundf(255.0 * (second_largest_component + match_value));
            } else {
                if (hue_section > 3.0 and hue_section <= 4.0) {
                    red = roundf(255.0 * match_value);
                    green = roundf(255.0 * (second_largest_component + match_value));
                    blue = roundf(255.0 * (chroma + match_value));
                } else {
                    if (hue_section > 4.0 and hue_section <= 5.0) {
                        red = roundf(255.0 * (second_largest_component + match_value));
                        green = roundf(255.0 * match_value);
                        blue = roundf(255.0 * (chroma + match_value));
                    } else {
                        red = roundf(255.0 * (chroma + match_value));
                        green = roundf(255.0 * match_value);
                        blue = roundf(255.0 * (second_largest_component + match_value));
                    }
                }
            }
        }
    }
    return blk0: { var _tmp0 = std.heap.page_allocator.alloc(i64, 3) catch unreachable; _tmp0[0] = red; _tmp0[1] = green; _tmp0[2] = blue; break :blk0 _tmp0; };
}

fn rgb_to_hsv(red: i64, green: i64, blue: i64) []f64 {
    if (red < 0 or red > 255) {
        std.debug.print("{s}\n", .{"red should be between 0 and 255"});
        return &[_]f64{};
    }
    if (green < 0 or green > 255) {
        std.debug.print("{s}\n", .{"green should be between 0 and 255"});
        return &[_]f64{};
    }
    if (blue < 0 or blue > 255) {
        std.debug.print("{s}\n", .{"blue should be between 0 and 255"});
        return &[_]f64{};
    }
    var float_red: f64 = @as(f64, @floatFromInt(red) / 255.0;
    float_red = float_red;
    var float_green: f64 = @as(f64, @floatFromInt(green) / 255.0;
    float_green = float_green;
    var float_blue: f64 = @as(f64, @floatFromInt(blue) / 255.0;
    float_blue = float_blue;
    var value: f64 = maxf(float_red, float_green, float_blue);
    value = value;
    var min_val: f64 = minf(float_red, float_green, float_blue);
    min_val = min_val;
    var chroma: f64 = value - min_val;
    chroma = chroma;
    var saturation: f64 = if (value == 0.0) 0.0 else chroma / value;
    saturation = saturation;
    var hue: f64 = 0;
    hue = hue;
    if (chroma == 0.0) {
        hue = 0.0;
    } else {
        if (value == float_red) {
            hue = 60.0 * (0.0 + (float_green - float_blue) / chroma);
        } else {
            if (value == float_green) {
                hue = 60.0 * (2.0 + (float_blue - float_red) / chroma);
            } else {
                hue = 60.0 * (4.0 + (float_red - float_green) / chroma);
            }
        }
    }
    hue = fmod(hue + 360.0, 360.0);
    return blk1: { var _tmp1 = std.heap.page_allocator.alloc(f64, 3) catch unreachable; _tmp1[0] = hue; _tmp1[1] = saturation; _tmp1[2] = value; break :blk1 _tmp1; };
}

fn approximately_equal_hsv(hsv1: []f64, hsv2: []f64) bool {
    var check_hue: bool = absf(hsv1[@as(usize, @intCast(0))] - hsv2[@as(usize, @intCast(0))]) < 0.2;
    check_hue = check_hue;
    var check_saturation: bool = absf(hsv1[@as(usize, @intCast(1))] - hsv2[@as(usize, @intCast(1))]) < 0.002;
    check_saturation = check_saturation;
    var check_value: bool = absf(hsv1[@as(usize, @intCast(2))] - hsv2[@as(usize, @intCast(2))]) < 0.002;
    check_value = check_value;
    return check_hue and check_saturation and check_value;
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        rgb_var = hsv_to_rgb(180.0, 0.5, 0.5);
        hsv_var = rgb_to_hsv(64, 128, 128);
        std.debug.print("{s}\n", .{_str(rgb_var)});
        std.debug.print("{s}\n", .{_str(hsv_var)});
        std.debug.print("{s}\n", .{_str(approximately_equal_hsv(hsv_var, blk2: { var _tmp2 = std.heap.page_allocator.alloc(f64, 3) catch unreachable; _tmp2[0] = 180.0; _tmp2[1] = 0.5; _tmp2[2] = 0.5; break :blk2 _tmp2; }))});
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .Pointer => |p| {
        if (p.size == .Slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * std.mem.page_size;
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
