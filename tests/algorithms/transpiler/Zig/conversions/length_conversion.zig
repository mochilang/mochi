// Generated by Mochi Zig transpiler on 2025-08-07 00:08 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn rstrip_s(s: []const u8) []const u8 {
    if (@as(i64, @intCast(s.len)) > 0 and std.mem.eql(u8, s[@as(usize, @intCast(@as(i64, @intCast(s.len)) - 1))..@as(usize, @intCast(@as(i64, @intCast(s.len)) - 1)) + 1], "s")) {
        return s[@as(usize, @intCast(0))..@min(@as(usize, @intCast(@as(i64, @intCast(s.len)) - 1)), @as(usize, @intCast(s.len)))];
    }
    return s;
}

fn normalize_alias(u: []const u8) []const u8 {
    if (std.mem.eql(u8, u, "millimeter")) {
        return "mm";
    }
    if (std.mem.eql(u8, u, "centimeter")) {
        return "cm";
    }
    if (std.mem.eql(u8, u, "meter")) {
        return "m";
    }
    if (std.mem.eql(u8, u, "kilometer")) {
        return "km";
    }
    if (std.mem.eql(u8, u, "inch")) {
        return "in";
    }
    if (std.mem.eql(u8, u, "inche")) {
        return "in";
    }
    if (std.mem.eql(u8, u, "feet")) {
        return "ft";
    }
    if (std.mem.eql(u8, u, "foot")) {
        return "ft";
    }
    if (std.mem.eql(u8, u, "yard")) {
        return "yd";
    }
    if (std.mem.eql(u8, u, "mile")) {
        return "mi";
    }
    return u;
}

fn has_unit(u: []const u8) bool {
    return std.mem.eql(u8, u, "mm") or std.mem.eql(u8, u, "cm") or std.mem.eql(u8, u, "m") or std.mem.eql(u8, u, "km") or std.mem.eql(u8, u, "in") or std.mem.eql(u8, u, "ft") or std.mem.eql(u8, u, "yd") or std.mem.eql(u8, u, "mi");
}

fn from_factor(u: []const u8) f64 {
    if (std.mem.eql(u8, u, "mm")) {
        return 0.001;
    }
    if (std.mem.eql(u8, u, "cm")) {
        return 0.01;
    }
    if (std.mem.eql(u8, u, "m")) {
        return 1.0;
    }
    if (std.mem.eql(u8, u, "km")) {
        return 1000.0;
    }
    if (std.mem.eql(u8, u, "in")) {
        return 0.0254;
    }
    if (std.mem.eql(u8, u, "ft")) {
        return 0.3048;
    }
    if (std.mem.eql(u8, u, "yd")) {
        return 0.9144;
    }
    if (std.mem.eql(u8, u, "mi")) {
        return 1609.34;
    }
    return 0.0;
}

fn to_factor(u: []const u8) f64 {
    if (std.mem.eql(u8, u, "mm")) {
        return 1000.0;
    }
    if (std.mem.eql(u8, u, "cm")) {
        return 100.0;
    }
    if (std.mem.eql(u8, u, "m")) {
        return 1.0;
    }
    if (std.mem.eql(u8, u, "km")) {
        return 0.001;
    }
    if (std.mem.eql(u8, u, "in")) {
        return 39.3701;
    }
    if (std.mem.eql(u8, u, "ft")) {
        return 3.28084;
    }
    if (std.mem.eql(u8, u, "yd")) {
        return 1.09361;
    }
    if (std.mem.eql(u8, u, "mi")) {
        return 0.000621371;
    }
    return 0.0;
}

fn length_conversion(value: f64, from_type: []const u8, to_type: []const u8) f64 {
    const new_from: []const u8 = normalize_alias(rstrip_s(_lower(from_type)));
    const new_to: []const u8 = normalize_alias(rstrip_s(_lower(to_type)));
    if (!(has_unit(new_from))) {
        @panic(_concat_string(_concat_string("Invalid 'from_type' value: '", from_type), "'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"));
    }
    if (!(has_unit(new_to))) {
        @panic(_concat_string(_concat_string("Invalid 'to_type' value: '", to_type), "'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"));
    }
    return value * from_factor(new_from) * to_factor(new_to);
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        std.debug.print("{d}\n", .{length_conversion(4.0, "METER", "FEET")});
        std.debug.print("{d}\n", .{length_conversion(1.0, "kilometer", "inch")});
        std.debug.print("{d}\n", .{length_conversion(2.0, "feet", "meter")});
        std.debug.print("{d}\n", .{length_conversion(2.0, "centimeter", "millimeter")});
        std.debug.print("{d}\n", .{length_conversion(4.0, "yard", "kilometer")});
        std.debug.print("{d}\n", .{length_conversion(3.0, "foot", "inch")});
        std.debug.print("{d}\n", .{length_conversion(3.0, "mm", "in")});
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _upper(s: []const u8) []const u8 {
    var out = std.heap.page_allocator.alloc(u8, s.len + 1) catch unreachable;
    _ = std.ascii.upperString(out[0..s.len], s);
    out[s.len] = 0;
    return out[0..s.len];
}

fn _lower(s: []const u8) []const u8 {
    var out = std.heap.page_allocator.alloc(u8, s.len + 1) catch unreachable;
    _ = std.ascii.lowerString(out[0..s.len], s);
    out[s.len] = 0;
    return out[0..s.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * std.mem.page_size;
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
