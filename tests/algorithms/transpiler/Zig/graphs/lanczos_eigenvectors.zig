// Generated by Mochi Zig transpiler on 2025-08-14 22:13 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const LanczosResult = struct {
    t: [][]f64,
    q: [][]f64,
};

const EigenResult = struct {
    values: []f64,
    vectors: [][]f64,
};

var seed_var_1: i64 = 123456789;
const graph_var: [][]i64 = @constCast(([3][]i64{@constCast(([2]i64{1, 2})[0..2]), @constCast(([2]i64{0, 2})[0..2]), @constCast(([2]i64{0, 1})[0..2])})[0..3]);
var result_var: EigenResult = undefined;

fn rand() i64 {
    seed_var_1 = @mod(seed_var_1 * 1103515245 + 12345, 2147483648);
    return seed_var_1;
}

fn random() f64 {
    return 1.0 * @as(f64, @floatFromInt(rand())) / 2147483648.0;
}

fn sqrtApprox(x: f64) f64 {
    if (x <= 0.0) {
        return 0.0;
    }
    var guess: f64 = x;
    guess = guess;
    var i: i64 = 0;
    i = i;
    while (i < 20) {
        guess = (guess + x / guess) / 2.0;
        i = i + 1;
    }
    return guess;
}

fn absf(x: f64) f64 {
    return if (x < 0.0) @as(f64, @floatFromInt(0)) - x else x;
}

fn dot(a: []f64, b: []f64) f64 {
    var s: f64 = 0.0;
    s = s;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(a.len))) {
        s = s + a[_idx(a.len, i)] * b[_idx(b.len, i)];
        i = i + 1;
    }
    return s;
}

fn vector_scale(v: []f64, s: f64) []f64 {
    var res: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res = res;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(v.len))) {
        res = blk: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, res)) catch |err| handleError(err); _tmp.append(v[_idx(v.len, i)] * s) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return res;
}

fn vector_sub(a: []f64, b: []f64) []f64 {
    var res: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res = res;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(a.len))) {
        res = blk: { var _tmp_1 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_1.appendSlice(@as([]const f64, res)) catch |err| handleError(err); _tmp_1.append(a[_idx(a.len, i)] - b[_idx(b.len, i)]) catch |err| handleError(err); break :blk (_tmp_1.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return res;
}

fn vector_add(a: []f64, b: []f64) []f64 {
    var res: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res = res;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(a.len))) {
        res = blk: { var _tmp_2 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_2.appendSlice(@as([]const f64, res)) catch |err| handleError(err); _tmp_2.append(a[_idx(a.len, i)] + b[_idx(b.len, i)]) catch |err| handleError(err); break :blk (_tmp_2.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return res;
}

fn zeros_matrix(r: i64, c: i64) [][]f64 {
    var m: [][]f64 = std.heap.page_allocator.alloc([]f64, 0) catch unreachable;
    m = m;
    var i: i64 = 0;
    i = i;
    while (i < r) {
        var row: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
        row = row;
        var j: i64 = 0;
        j = j;
        while (j < c) {
            row = blk: { var _tmp_3 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_3.appendSlice(@as([]const f64, row)) catch |err| handleError(err); _tmp_3.append(0.0) catch |err| handleError(err); break :blk (_tmp_3.toOwnedSlice() catch |err| handleError(err)); };
            j = j + 1;
        }
        m = blk: { var _tmp_4 = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp_4.appendSlice(@as([]const []f64, m)) catch |err| handleError(err); _tmp_4.append(row) catch |err| handleError(err); break :blk (_tmp_4.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return m;
}

fn column(m: [][]f64, idx: i64) []f64 {
    var col: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    col = col;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(m.len))) {
        col = blk: { var _tmp_5 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_5.appendSlice(@as([]const f64, col)) catch |err| handleError(err); _tmp_5.append(m[_idx(m.len, i)][_idx(m[_idx(m.len, i)].len, idx)]) catch |err| handleError(err); break :blk (_tmp_5.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return col;
}

fn validate_adjacency_list(graph_param: [][]i64) void {
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(graph_param.len))) {
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(graph_param[_idx(graph_param.len, i)].len))) {
            var v: i64 = graph_param[_idx(graph_param.len, i)][_idx(graph_param[_idx(graph_param.len, i)].len, j)];
            v = v;
            if (v < 0 or v >= @as(i64, @intCast(graph_param.len))) {
                @panic("Invalid neighbor");
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn multiply_matrix_vector(graph_param: [][]i64, vector: []f64) []f64 {
    const n: i64 = @as(i64, @intCast(graph_param.len));
    if (@as(i64, @intCast(vector.len)) != n) {
        @panic("Vector length must match number of nodes");
    }
    var result_var_1: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    result_var_1 = result_var_1;
    var i: i64 = 0;
    i = i;
    while (i < n) {
        var sum: f64 = 0.0;
        sum = sum;
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(graph_param[_idx(graph_param.len, i)].len))) {
            const nb: i64 = graph_param[_idx(graph_param.len, i)][_idx(graph_param[_idx(graph_param.len, i)].len, j)];
            sum = sum + vector[_idx(vector.len, nb)];
            j = j + 1;
        }
        result_var_1 = blk: { var _tmp_6 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_6.appendSlice(@as([]const f64, result_var_1)) catch |err| handleError(err); _tmp_6.append(sum) catch |err| handleError(err); break :blk (_tmp_6.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return result_var_1;
}

fn lanczos_iteration(graph_param: [][]i64, k: i64) LanczosResult {
    const n: i64 = @as(i64, @intCast(graph_param.len));
    if (k < 1 or k > n) {
        @panic("invalid number of eigenvectors");
    }
    var q: [][]f64 = zeros_matrix(n, k);
    q = q;
    var t: [][]f64 = zeros_matrix(k, k);
    t = t;
    var v: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    v = v;
    var i: i64 = 0;
    i = i;
    while (i < n) {
        v = blk: { var _tmp_7 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_7.appendSlice(@as([]const f64, v)) catch |err| handleError(err); _tmp_7.append(random()) catch |err| handleError(err); break :blk (_tmp_7.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    var ss: f64 = 0.0;
    ss = ss;
    i = 0;
    while (i < n) {
        ss = ss + v[_idx(v.len, i)] * v[_idx(v.len, i)];
        i = i + 1;
    }
    const vnorm: f64 = sqrtApprox(ss);
    i = 0;
    while (i < n) {
        q[_idx(q.len, i)][_idx(q[_idx(q.len, i)].len, 0)] = v[_idx(v.len, i)] / vnorm;
        i = i + 1;
    }
    var beta: f64 = 0.0;
    beta = beta;
    var j: i64 = 0;
    j = j;
    while (j < k) {
        var w: []f64 = multiply_matrix_vector(graph_param, column(q, j));
        w = w;
        if (j > 0) {
            w = vector_sub(w, vector_scale(column(q, j - 1), beta));
        }
        const alpha: f64 = dot(column(q, j), w);
        w = vector_sub(w, vector_scale(column(q, j), alpha));
        var ss2: f64 = 0.0;
        ss2 = ss2;
        var p: i64 = 0;
        p = p;
        while (p < n) {
            ss2 = ss2 + w[_idx(w.len, p)] * w[_idx(w.len, p)];
            p = p + 1;
        }
        beta = sqrtApprox(ss2);
        t[_idx(t.len, j)][_idx(t[_idx(t.len, j)].len, j)] = alpha;
        if (j < k - 1) {
            t[_idx(t.len, j)][_idx(t[_idx(t.len, j)].len, j + 1)] = beta;
            t[_idx(t.len, j + 1)][_idx(t[_idx(t.len, j + 1)].len, j)] = beta;
            if (beta > 0.0000000001) {
                const wnorm: []f64 = vector_scale(w, 1.0 / beta);
                var r: i64 = 0;
                r = r;
                while (r < n) {
                    q[_idx(q.len, r)][_idx(q[_idx(q.len, r)].len, j + 1)] = wnorm[_idx(wnorm.len, r)];
                    r = r + 1;
                }
            }
        }
        j = j + 1;
    }
    return .{ .t = t, .q = q };
}

fn jacobi_eigen(a_in: [][]f64, max_iter: i64) EigenResult {
    const n: i64 = @as(i64, @intCast(a_in.len));
    var a: [][]f64 = blk: { const tmp = std.heap.page_allocator.alloc([]f64, a_in.len) catch unreachable; @memcpy(tmp, a_in); break :blk tmp; };
    a = a;
    var v: [][]f64 = zeros_matrix(n, n);
    v = v;
    var i: i64 = 0;
    i = i;
    while (i < n) {
        v[_idx(v.len, i)][_idx(v[_idx(v.len, i)].len, i)] = 1.0;
        i = i + 1;
    }
    var iter: i64 = 0;
    iter = iter;
    while (iter < max_iter) {
        var p: i64 = 0;
        p = p;
        var q: i64 = 1;
        q = q;
        var max: f64 = absf(a[_idx(a.len, p)][_idx(a[_idx(a.len, p)].len, q)]);
        max = max;
        i = 0;
        while (i < n) {
            var j: i64 = i + 1;
            j = j;
            while (j < n) {
                const val: f64 = absf(a[_idx(a.len, i)][_idx(a[_idx(a.len, i)].len, j)]);
                if (val > max) {
                    max = val;
                    p = i;
                    q = j;
                }
                j = j + 1;
            }
            i = i + 1;
        }
        if (max < 0.00000001) {
            break;
        }
        const app: f64 = a[_idx(a.len, p)][_idx(a[_idx(a.len, p)].len, p)];
        const aqq: f64 = a[_idx(a.len, q)][_idx(a[_idx(a.len, q)].len, q)];
        const apq: f64 = a[_idx(a.len, p)][_idx(a[_idx(a.len, p)].len, q)];
        const theta: f64 = (aqq - app) / (2.0 * apq);
        var t: f64 = 1.0 / (absf(theta) + sqrtApprox(theta * theta + 1.0));
        t = t;
        if (theta < 0.0) {
            t = @as(f64, @floatFromInt(0)) - t;
        }
        const c: f64 = 1.0 / sqrtApprox(1.0 + t * t);
        var s: f64 = t * c;
        s = s;
        const tau: f64 = s / (1.0 + c);
        a[_idx(a.len, p)][_idx(a[_idx(a.len, p)].len, p)] = app - t * apq;
        a[_idx(a.len, q)][_idx(a[_idx(a.len, q)].len, q)] = aqq + t * apq;
        a[_idx(a.len, p)][_idx(a[_idx(a.len, p)].len, q)] = 0.0;
        a[_idx(a.len, q)][_idx(a[_idx(a.len, q)].len, p)] = 0.0;
        var k: i64 = 0;
        k = k;
        while (k < n) {
            if (k != p and k != q) {
                const akp: f64 = a[_idx(a.len, k)][_idx(a[_idx(a.len, k)].len, p)];
                const akq: f64 = a[_idx(a.len, k)][_idx(a[_idx(a.len, k)].len, q)];
                a[_idx(a.len, k)][_idx(a[_idx(a.len, k)].len, p)] = akp - s * (akq + tau * akp);
                a[_idx(a.len, p)][_idx(a[_idx(a.len, p)].len, k)] = a[_idx(a.len, k)][_idx(a[_idx(a.len, k)].len, p)];
                a[_idx(a.len, k)][_idx(a[_idx(a.len, k)].len, q)] = akq + s * (akp - tau * akq);
                a[_idx(a.len, q)][_idx(a[_idx(a.len, q)].len, k)] = a[_idx(a.len, k)][_idx(a[_idx(a.len, k)].len, q)];
            }
            k = k + 1;
        }
        k = 0;
        while (k < n) {
            const vkp: f64 = v[_idx(v.len, k)][_idx(v[_idx(v.len, k)].len, p)];
            const vkq: f64 = v[_idx(v.len, k)][_idx(v[_idx(v.len, k)].len, q)];
            v[_idx(v.len, k)][_idx(v[_idx(v.len, k)].len, p)] = vkp - s * (vkq + tau * vkp);
            v[_idx(v.len, k)][_idx(v[_idx(v.len, k)].len, q)] = vkq + s * (vkp - tau * vkq);
            k = k + 1;
        }
        iter = iter + 1;
    }
    var eigenvalues: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    eigenvalues = eigenvalues;
    i = 0;
    while (i < n) {
        eigenvalues = blk: { var _tmp_8 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_8.appendSlice(@as([]const f64, eigenvalues)) catch |err| handleError(err); _tmp_8.append(a[_idx(a.len, i)][_idx(a[_idx(a.len, i)].len, i)]) catch |err| handleError(err); break :blk (_tmp_8.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return .{ .values = eigenvalues, .vectors = v };
}

fn matmul(a: [][]f64, b: [][]f64) [][]f64 {
    const rows: i64 = @as(i64, @intCast(a.len));
    const cols: i64 = @as(i64, @intCast(b[_idx(b.len, 0)].len));
    const inner: i64 = @as(i64, @intCast(b.len));
    var m: [][]f64 = zeros_matrix(rows, cols);
    m = m;
    var i: i64 = 0;
    i = i;
    while (i < rows) {
        var j: i64 = 0;
        j = j;
        while (j < cols) {
            var s: f64 = 0.0;
            s = s;
            var k: i64 = 0;
            k = k;
            while (k < inner) {
                s = s + a[_idx(a.len, i)][_idx(a[_idx(a.len, i)].len, k)] * b[_idx(b.len, k)][_idx(b[_idx(b.len, k)].len, j)];
                k = k + 1;
            }
            m[_idx(m.len, i)][_idx(m[_idx(m.len, i)].len, j)] = s;
            j = j + 1;
        }
        i = i + 1;
    }
    return m;
}

fn sort_eigenpairs(vals: []f64, vecs: [][]f64) EigenResult {
    const n: i64 = @as(i64, @intCast(vals.len));
    var values: []f64 = blk: { const tmp = std.heap.page_allocator.alloc(f64, vals.len) catch unreachable; @memcpy(tmp, vals); break :blk tmp; };
    values = values;
    var vectors: [][]f64 = blk: { const tmp = std.heap.page_allocator.alloc([]f64, vecs.len) catch unreachable; @memcpy(tmp, vecs); break :blk tmp; };
    vectors = vectors;
    var i: i64 = 0;
    i = i;
    while (i < n) {
        var j: i64 = 0;
        j = j;
        while (j < n - 1) {
            if (values[_idx(values.len, j)] < values[_idx(values.len, j + 1)]) {
                const tmp: f64 = values[_idx(values.len, j)];
                values[_idx(values.len, j)] = values[_idx(values.len, j + 1)];
                values[_idx(values.len, j + 1)] = tmp;
                var r: i64 = 0;
                r = r;
                while (r < @as(i64, @intCast(vectors.len))) {
                    const tv: f64 = vectors[_idx(vectors.len, r)][_idx(vectors[_idx(vectors.len, r)].len, j)];
                    vectors[_idx(vectors.len, r)][_idx(vectors[_idx(vectors.len, r)].len, j)] = vectors[_idx(vectors.len, r)][_idx(vectors[_idx(vectors.len, r)].len, j + 1)];
                    vectors[_idx(vectors.len, r)][_idx(vectors[_idx(vectors.len, r)].len, j + 1)] = tv;
                    r = r + 1;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return .{ .values = values, .vectors = vectors };
}

fn find_lanczos_eigenvectors(graph_param: [][]i64, k: i64) EigenResult {
    validate_adjacency_list(graph_param);
    var res: LanczosResult = lanczos_iteration(graph_param, k);
    res = res;
    const eig: EigenResult = jacobi_eigen(res.t, 50);
    const sorted: EigenResult = sort_eigenpairs(eig.values, eig.vectors);
    const final_vectors: [][]f64 = matmul(res.q, sorted.vectors);
    return .{ .values = sorted.values, .vectors = final_vectors };
}

fn list_to_string(arr: []f64) []const u8 {
    var s: []const u8 = "[";
    s = s;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(arr.len))) {
        s = _concat_string(s, _str(arr[_idx(arr.len, i)]));
        if (i < @as(i64, @intCast(arr.len)) - 1) {
            s = _concat_string(s, ", ");
        }
        i = i + 1;
    }
    return _concat_string(s, "]");
}

fn matrix_to_string(m: [][]f64) []const u8 {
    var s: []const u8 = "[";
    s = s;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(m.len))) {
        s = _concat_string(s, list_to_string(m[_idx(m.len, i)]));
        if (i < @as(i64, @intCast(m.len)) - 1) {
            s = _concat_string(s, "; ");
        }
        i = i + 1;
    }
    return _concat_string(s, "]");
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        result_var = find_lanczos_eigenvectors(graph_var, 2);
        std.debug.print("{s}\n", .{list_to_string(result_var.values)});
        std.debug.print("{s}\n", .{matrix_to_string(result_var.vectors)});
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .pointer => |p| {
        if (p.size == .slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    .@"struct" => |_| {
        if (@hasDecl(@TypeOf(v), "iterator")) {
            const KVPair = struct{ ks: []const u8, vs: []const u8 };
            var pairs = std.ArrayList(KVPair).init(std.heap.page_allocator);
            defer pairs.deinit();
            var it = v.iterator();
            while (it.next()) |e| {
                const ks = _str(e.key_ptr.*);
                const vs = _str(e.value_ptr.*);
                pairs.append(.{ .ks = ks, .vs = vs }) catch unreachable;
            }
            std.sort.heap(KVPair, pairs.items, {}, struct {
                pub fn less(_: void, a: KVPair, b: KVPair) bool {
                    return std.mem.lessThan(u8, a.ks, b.ks);
                }
            }.less);
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.appendSlice("map[") catch unreachable;
            for (pairs.items, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                out.appendSlice(e.ks) catch unreachable;
                out.append(':') catch unreachable;
                out.appendSlice(e.vs) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.heap.pageSize()));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
