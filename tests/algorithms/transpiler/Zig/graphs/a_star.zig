// Generated by Mochi Zig transpiler on 2025-08-14 16:41 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const SearchResult = struct {
    path: [][]i64,
    action: [][]i64,
};

var DIRECTIONS_var: [][]i64 = &[_][]i64{};

fn iabs(x: i64) i64 {
    if (x < 0) {
        return 0 - x;
    }
    return x;
}

fn search(grid: [][]i64, init: []i64, goal: []i64, cost: i64, heuristic: [][]i64) SearchResult {
    var closed: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
    closed = closed;
    var r: i64 = 0;
    r = r;
    while (r < @as(i64, @intCast(grid.len))) {
        var row: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
        row = row;
        var c: i64 = 0;
        c = c;
        while (c < @as(i64, @intCast(grid[_idx(grid.len, 0)].len))) {
            row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const i64, row)) catch |err| handleError(err); _tmp.append(0) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            c = c + 1;
        }
        closed = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, closed)) catch |err| handleError(err); _tmp.append(row) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        r = r + 1;
    }
    closed[_idx(closed.len, init[_idx(init.len, 0)])][_idx(closed[_idx(closed.len, init[_idx(init.len, 0)])].len, init[_idx(init.len, 1)])] = 1;
    var action: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
    action = action;
    r = 0;
    while (r < @as(i64, @intCast(grid.len))) {
        var row: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
        row = row;
        var c: i64 = 0;
        c = c;
        while (c < @as(i64, @intCast(grid[_idx(grid.len, 0)].len))) {
            row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const i64, row)) catch |err| handleError(err); _tmp.append(0) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            c = c + 1;
        }
        action = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, action)) catch |err| handleError(err); _tmp.append(row) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        r = r + 1;
    }
    var x: i64 = init[_idx(init.len, 0)];
    x = x;
    var y: i64 = init[_idx(init.len, 1)];
    y = y;
    var g: i64 = 0;
    g = g;
    const f: i64 = g + heuristic[_idx(heuristic.len, x)][_idx(heuristic[_idx(heuristic.len, x)].len, y)];
    var cell: [][]i64 = std.heap.page_allocator.dupe([]i64, (&([1][]i64{std.heap.page_allocator.dupe(i64, (&([4]i64{f, g, x, y}))[0..]) catch unreachable}))[0..]) catch unreachable;
    cell = cell;
    var found: bool = false;
    found = found;
    const resign: bool = false;
    while (!(found) and !(resign)) {
        if (@as(i64, @intCast(cell.len)) == 0) {
            @panic("Algorithm is unable to find solution");
        } else {
            var best_i: i64 = 0;
            best_i = best_i;
            var best_f: i64 = cell[_idx(cell.len, 0)][_idx(cell[_idx(cell.len, 0)].len, 0)];
            best_f = best_f;
            var i: i64 = 1;
            i = i;
            while (i < @as(i64, @intCast(cell.len))) {
                if (cell[_idx(cell.len, i)][_idx(cell[_idx(cell.len, i)].len, 0)] < best_f) {
                    best_f = cell[_idx(cell.len, i)][_idx(cell[_idx(cell.len, i)].len, 0)];
                    best_i = i;
                }
                i = i + 1;
            }
            const next_cell: []i64 = cell[_idx(cell.len, best_i)];
            var new_cell: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
            new_cell = new_cell;
            i = 0;
            while (i < @as(i64, @intCast(cell.len))) {
                if (i != best_i) {
                    new_cell = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, new_cell)) catch |err| handleError(err); _tmp.append(cell[_idx(cell.len, i)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
                }
                i = i + 1;
            }
            cell = new_cell;
            x = next_cell[_idx(next_cell.len, 2)];
            y = next_cell[_idx(next_cell.len, 3)];
            g = next_cell[_idx(next_cell.len, 1)];
            if (x == goal[_idx(goal.len, 0)] and y == goal[_idx(goal.len, 1)]) {
                found = true;
            } else {
                var d: i64 = 0;
                d = d;
                while (d < @as(i64, @intCast(DIRECTIONS_var.len))) {
                    const x2: i64 = x + DIRECTIONS_var[_idx(DIRECTIONS_var.len, d)][_idx(DIRECTIONS_var[_idx(DIRECTIONS_var.len, d)].len, 0)];
                    const y2: i64 = y + DIRECTIONS_var[_idx(DIRECTIONS_var.len, d)][_idx(DIRECTIONS_var[_idx(DIRECTIONS_var.len, d)].len, 1)];
                    if (x2 >= 0 and x2 < @as(i64, @intCast(grid.len)) and y2 >= 0 and y2 < @as(i64, @intCast(grid[_idx(grid.len, 0)].len)) and closed[_idx(closed.len, x2)][_idx(closed[_idx(closed.len, x2)].len, y2)] == 0 and grid[_idx(grid.len, x2)][_idx(grid[_idx(grid.len, x2)].len, y2)] == 0) {
                        const g2: i64 = g + cost;
                        const f2: i64 = g2 + heuristic[_idx(heuristic.len, x2)][_idx(heuristic[_idx(heuristic.len, x2)].len, y2)];
                        cell = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, cell)) catch |err| handleError(err); _tmp.append(@constCast(&([4]i64{f2, g2, x2, y2}))[0..]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
                        closed[_idx(closed.len, x2)][_idx(closed[_idx(closed.len, x2)].len, y2)] = 1;
                        action[_idx(action.len, x2)][_idx(action[_idx(action.len, x2)].len, y2)] = d;
                    }
                    d = d + 1;
                }
            }
        }
    }
    var invpath: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
    invpath = invpath;
    x = goal[_idx(goal.len, 0)];
    y = goal[_idx(goal.len, 1)];
    invpath = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, invpath)) catch |err| handleError(err); _tmp.append(@constCast(&([2]i64{x, y}))[0..]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
    while (x != init[_idx(init.len, 0)] or y != init[_idx(init.len, 1)]) {
        const dir: i64 = action[_idx(action.len, x)][_idx(action[_idx(action.len, x)].len, y)];
        const x2: i64 = x - DIRECTIONS_var[_idx(DIRECTIONS_var.len, dir)][_idx(DIRECTIONS_var[_idx(DIRECTIONS_var.len, dir)].len, 0)];
        const y2: i64 = y - DIRECTIONS_var[_idx(DIRECTIONS_var.len, dir)][_idx(DIRECTIONS_var[_idx(DIRECTIONS_var.len, dir)].len, 1)];
        x = x2;
        y = y2;
        invpath = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, invpath)) catch |err| handleError(err); _tmp.append(@constCast(&([2]i64{x, y}))[0..]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
    }
    var path: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
    path = path;
    var idx: i64 = @as(i64, @intCast(invpath.len)) - 1;
    idx = idx;
    while (idx >= 0) {
        path = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, path)) catch |err| handleError(err); _tmp.append(invpath[_idx(invpath.len, idx)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        idx = idx - 1;
    }
    return .{ .path = path, .action = action };
}

fn mochi_main() void {
    const grid: [][]i64 = std.heap.page_allocator.dupe([]i64, (&([5][]i64{std.heap.page_allocator.dupe(i64, (&([6]i64{0, 1, 0, 0, 0, 0}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([6]i64{0, 1, 0, 0, 0, 0}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([6]i64{0, 1, 0, 0, 0, 0}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([6]i64{0, 1, 0, 0, 1, 0}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([6]i64{0, 0, 0, 0, 1, 0}))[0..]) catch unreachable}))[0..]) catch unreachable;
    const init: []i64 = std.heap.page_allocator.dupe(i64, (&([2]i64{0, 0}))[0..]) catch unreachable;
    const goal: []i64 = std.heap.page_allocator.dupe(i64, (&([2]i64{@as(i64, @intCast(grid.len)) - 1, @as(i64, @intCast(grid[_idx(grid.len, 0)].len)) - 1}))[0..]) catch unreachable;
    const cost: i64 = 1;
    var heuristic: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
    heuristic = heuristic;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(grid.len))) {
        var row: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
        row = row;
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(grid[_idx(grid.len, 0)].len))) {
            const h: i64 = iabs(i - goal[_idx(goal.len, 0)]) + iabs(j - goal[_idx(goal.len, 1)]);
            if (grid[_idx(grid.len, i)][_idx(grid[_idx(grid.len, i)].len, j)] == 1) {
                row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const i64, row)) catch |err| handleError(err); _tmp.append(99) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            } else {
                row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const i64, row)) catch |err| handleError(err); _tmp.append(h) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            }
            j = j + 1;
        }
        heuristic = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, heuristic)) catch |err| handleError(err); _tmp.append(row) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    const result: SearchResult = search(grid, init, goal, cost, heuristic);
    std.debug.print("{s}\n", .{"ACTION MAP"});
    var rr: i64 = 0;
    rr = rr;
    while (rr < @as(i64, @intCast(result.action.len))) {
        std.debug.print("{d}\n", .{result.action[_idx(result.action.len, rr)]});
        rr = rr + 1;
    }
    var p: i64 = 0;
    p = p;
    while (p < @as(i64, @intCast(result.path.len))) {
        std.debug.print("{d}\n", .{result.path[_idx(result.path.len, p)]});
        p = p + 1;
    }
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        DIRECTIONS_var = std.heap.page_allocator.dupe([]i64, (&([4][]i64{std.heap.page_allocator.dupe(i64, (&([2]i64{0 - 1, 0}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([2]i64{0, 0 - 1}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([2]i64{1, 0}))[0..]) catch unreachable, std.heap.page_allocator.dupe(i64, (&([2]i64{0, 1}))[0..]) catch unreachable}))[0..]) catch unreachable;
        mochi_main();
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
