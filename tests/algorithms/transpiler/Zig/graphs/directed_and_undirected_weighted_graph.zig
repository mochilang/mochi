// Generated by Mochi Zig transpiler on 2025-08-14 22:13 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const DirectedGraph = struct {
    graph: std.AutoHashMap(i64,[][]i64),
};

const Graph = struct {
    graph: std.AutoHashMap(i64,[][]i64),
};

fn list_contains_int(xs: []i64, x: i64) bool {
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(xs.len))) {
        if (xs[_idx(xs.len, i)] == x) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

fn edge_exists(edges: [][]i64, w: i64, v: i64) bool {
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        if (edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 0)] == w and edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)] == v) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

fn first_key(m: *const std.AutoHashMap(i64,[][]i64)) i64 {
    var __mapit1 = m.keyIterator();
    while (__mapit1.next()) |_| {
        return k;
    }
    return 0;
}

fn rand_range(low: i64, high: i64) i64 {
    return @mod(_now(), high - low) + low;
}

fn dg_make_graph() DirectedGraph {
    return .{ .graph = std.AutoHashMap(i64, [][]i64).init(std.heap.page_allocator) };
}

fn dg_add_pair(g_param: *DirectedGraph, u: i64, v: i64, w: i64) void {
    if (g_param.graph.contains(u)) {
        var edges: [][]i64 = g_param.graph.get(u).?;
        edges = edges;
        if (!(edge_exists(edges, w, v))) {
            edges = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []i64, edges)) catch |err| handleError(err); _tmp.append(@constCast(blk0: { var _tmp_1 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_1.append(w) catch unreachable; _tmp_1.append(v) catch unreachable; break :blk0 (_tmp_1.toOwnedSlice() catch unreachable); })) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            var m: std.AutoHashMap(i64,[][]i64) = g_param.graph;
            m = m;
            m.put(u, edges) catch unreachable;
            g_param.graph = m;
        }
    } else {
        var m0: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m0 = m0;
        m0.put(u, blk1: { var _tmp_2 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_2.append(@constCast(blk2: { var _tmp_3 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_3.append(w) catch unreachable; _tmp_3.append(v) catch unreachable; break :blk2 (_tmp_3.toOwnedSlice() catch unreachable); })) catch unreachable; break :blk1 (_tmp_2.toOwnedSlice() catch unreachable); }) catch unreachable;
        g_param.graph = m0;
    }
    if (!(g_param.graph.contains(v))) {
        var m1: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m1 = m1;
        m1.put(v, @constCast((&[_]i64{}))[0..]) catch unreachable;
        g_param.graph = m1;
    }
}

fn dg_remove_pair(g_param: *DirectedGraph, u: i64, v: i64) void {
    if (g_param.graph.contains(u)) {
        var edges: [][]i64 = g_param.graph.get(u).?;
        edges = edges;
        var new_edges: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
        new_edges = new_edges;
        var i: i64 = 0;
        i = i;
        while (i < @as(i64, @intCast(edges.len))) {
            if (edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)] != v) {
                new_edges = blk: { var _tmp_4 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_4.appendSlice(@as([]const []i64, new_edges)) catch |err| handleError(err); _tmp_4.append(edges[_idx(edges.len, i)]) catch |err| handleError(err); break :blk (_tmp_4.toOwnedSlice() catch |err| handleError(err)); };
            }
            i = i + 1;
        }
        var m: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m = m;
        m.put(u, new_edges) catch unreachable;
        g_param.graph = m;
    }
}

fn dg_all_nodes(g: DirectedGraph) []i64 {
    var res: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    res = res;
    var __mapit3 = g.graph.keyIterator();
    while (__mapit3.next()) |__it2| {
        const k = __it2.*;
        res = blk: { var _tmp_5 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_5.appendSlice(@as([]const i64, res)) catch |err| handleError(err); _tmp_5.append(k) catch |err| handleError(err); break :blk (_tmp_5.toOwnedSlice() catch |err| handleError(err)); };
    }
    return res;
}

fn dg_dfs_util(g: DirectedGraph, node: i64, visited_param: *std.AutoHashMap(i64,bool), order_param: []i64, d: i64) []i64 {
    var order_var: []i64 = order_param;
    order_var = order_var;
    visited_param.put(node, true) catch unreachable;
    order_var = blk: { var _tmp_6 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_6.appendSlice(@as([]const i64, order_var)) catch |err| handleError(err); _tmp_6.append(node) catch |err| handleError(err); break :blk (_tmp_6.toOwnedSlice() catch |err| handleError(err)); };
    if (d != 0 - 1 and node == d) {
        return order_var;
    }
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            order_var = dg_dfs_util(g, neigh, visited_param, order_var, d);
            if (d != 0 - 1 and order_var[_idx(order_var.len, @as(i64, @intCast(order_var.len)) - 1)] == d) {
                return order_var;
            }
        }
        i = i + 1;
    }
    return order_var;
}

fn dg_dfs(g: DirectedGraph, s: i64, d: i64) []i64 {
    if (s == d) {
        return (&[_]i64{})[0..0];
    }
    const start: i64 = if (s == 0 - 2) first_key(&g.graph) else s;
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var order: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    order = order;
    order = dg_dfs_util(g, start, @constCast(&visited), order, d);
    return order;
}

fn dg_bfs(g: DirectedGraph, s: i64) []i64 {
    var queue: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    queue = queue;
    var visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    visited = visited;
    var order: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    order = order;
    const start: i64 = if (s == 0 - 2) first_key(&g.graph) else s;
    queue = blk: { var _tmp_7 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_7.appendSlice(@as([]const i64, queue)) catch |err| handleError(err); _tmp_7.append(start) catch |err| handleError(err); break :blk (_tmp_7.toOwnedSlice() catch |err| handleError(err)); };
    visited.put(start, true) catch unreachable;
    while (@as(i64, @intCast(queue.len)) > 0) {
        const node: i64 = queue[_idx(queue.len, 0)];
        queue = queue[@as(usize, @intCast(1))..@min(@as(usize, @intCast(@as(i64, @intCast(queue.len)))), @as(usize, @intCast(queue.len)))];
        order = blk: { var _tmp_8 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_8.appendSlice(@as([]const i64, order)) catch |err| handleError(err); _tmp_8.append(node) catch |err| handleError(err); break :blk (_tmp_8.toOwnedSlice() catch |err| handleError(err)); };
        var edges: [][]i64 = g.graph.get(node).?;
        edges = edges;
        var i: i64 = 0;
        i = i;
        while (i < @as(i64, @intCast(edges.len))) {
            const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
            if (!(visited.contains(neigh))) {
                queue = blk: { var _tmp_9 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_9.appendSlice(@as([]const i64, queue)) catch |err| handleError(err); _tmp_9.append(neigh) catch |err| handleError(err); break :blk (_tmp_9.toOwnedSlice() catch |err| handleError(err)); };
                visited.put(neigh, true) catch unreachable;
            }
            i = i + 1;
        }
    }
    return order;
}

fn dg_in_degree(g: DirectedGraph, u: i64) i64 {
    var count: i64 = 0;
    count = count;
    var __mapit5 = g.graph.keyIterator();
    while (__mapit5.next()) |__it4| {
        const k = __it4.*;
        var edges: [][]i64 = g.graph.get(k).?;
        edges = edges;
        var i: i64 = 0;
        i = i;
        while (i < @as(i64, @intCast(edges.len))) {
            if (edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)] == u) {
                count = count + 1;
            }
            i = i + 1;
        }
    }
    return count;
}

fn dg_out_degree(g: DirectedGraph, u: i64) i64 {
    if (g.graph.contains(u)) {
        return @as(i64, @intCast(g.graph.get(u).?.len));
    }
    return 0;
}

fn dg_topo_util(g: DirectedGraph, node: i64, visited_param: *std.AutoHashMap(i64,bool), stack_param: []i64) []i64 {
    var stack_var: []i64 = stack_param;
    stack_var = stack_var;
    visited_param.put(node, true) catch unreachable;
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            stack_var = dg_topo_util(g, neigh, visited_param, stack_var);
        }
        i = i + 1;
    }
    stack_var = blk: { var _tmp_10 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_10.appendSlice(@as([]const i64, stack_var)) catch |err| handleError(err); _tmp_10.append(node) catch |err| handleError(err); break :blk (_tmp_10.toOwnedSlice() catch |err| handleError(err)); };
    return stack_var;
}

fn dg_topological_sort(g: DirectedGraph) []i64 {
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var stack: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    stack = stack;
    var __mapit7 = g.graph.keyIterator();
    while (__mapit7.next()) |__it6| {
        const k = __it6.*;
        if (!(visited.contains(k))) {
            stack = dg_topo_util(g, k, @constCast(&visited), stack);
        }
    }
    var res: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    res = res;
    var i: i64 = @as(i64, @intCast(stack.len)) - 1;
    i = i;
    while (i >= 0) {
        res = blk: { var _tmp_11 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_11.appendSlice(@as([]const i64, res)) catch |err| handleError(err); _tmp_11.append(stack[_idx(stack.len, i)]) catch |err| handleError(err); break :blk (_tmp_11.toOwnedSlice() catch |err| handleError(err)); };
        i = i - 1;
    }
    return res;
}

fn dg_cycle_util(g: DirectedGraph, node: i64, visited_param: *std.AutoHashMap(i64,bool), rec_param: *std.AutoHashMap(i64,bool), res_param: []i64) []i64 {
    var res_var: []i64 = res_param;
    res_var = res_var;
    visited_param.put(node, true) catch unreachable;
    rec_param.put(node, true) catch unreachable;
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            res_var = dg_cycle_util(g, neigh, visited_param, rec_param, res_var);
        } else {
            if (rec_param.get(neigh).?) {
                if (!(list_contains_int(res_var, neigh))) {
                    res_var = blk: { var _tmp_12 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_12.appendSlice(@as([]const i64, res_var)) catch |err| handleError(err); _tmp_12.append(neigh) catch |err| handleError(err); break :blk (_tmp_12.toOwnedSlice() catch |err| handleError(err)); };
                }
                if (!(list_contains_int(res_var, node))) {
                    res_var = blk: { var _tmp_13 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_13.appendSlice(@as([]const i64, res_var)) catch |err| handleError(err); _tmp_13.append(node) catch |err| handleError(err); break :blk (_tmp_13.toOwnedSlice() catch |err| handleError(err)); };
                }
            }
        }
        i = i + 1;
    }
    rec_param.put(node, false) catch unreachable;
    return res_var;
}

fn dg_cycle_nodes(g: DirectedGraph) []i64 {
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    const rec: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var res: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    res = res;
    var __mapit9 = g.graph.keyIterator();
    while (__mapit9.next()) |__it8| {
        const k = __it8.*;
        if (!(visited.contains(k))) {
            res = dg_cycle_util(g, k, @constCast(&visited), @constCast(&rec), res);
        }
    }
    return res;
}

fn dg_has_cycle_util(g: DirectedGraph, node: i64, visited_param: *std.AutoHashMap(i64,bool), rec_param: *std.AutoHashMap(i64,bool)) bool {
    visited_param.put(node, true) catch unreachable;
    rec_param.put(node, true) catch unreachable;
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            if (dg_has_cycle_util(g, neigh, visited_param, rec_param)) {
                return true;
            }
        } else {
            if (rec_param.get(neigh).?) {
                return true;
            }
        }
        i = i + 1;
    }
    rec_param.put(node, false) catch unreachable;
    return false;
}

fn dg_has_cycle(g: DirectedGraph) bool {
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    const rec: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var __mapit11 = g.graph.keyIterator();
    while (__mapit11.next()) |__it10| {
        const k = __it10.*;
        if (!(visited.contains(k))) {
            if (dg_has_cycle_util(g, k, @constCast(&visited), @constCast(&rec))) {
                return true;
            }
        }
    }
    return false;
}

fn dg_fill_graph_randomly(g: DirectedGraph, c: i64) void {
    var count: i64 = c;
    count = count;
    if (count == 0 - 1) {
        count = rand_range(10, 10010);
    }
    var i: i64 = 0;
    i = i;
    while (i < count) {
        const edge_count: i64 = rand_range(1, 103);
        var j: i64 = 0;
        j = j;
        while (j < edge_count) {
            const n: i64 = rand_range(0, count);
            if (n != i) {
                dg_add_pair(&g, i, n, 1);
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn dg_dfs_time(g: DirectedGraph, s: i64, e: i64) i64 {
    const begin: i64 = _now();
    _ = dg_dfs(g, s, e);
    const end: i64 = _now();
    return end - begin;
}

fn dg_bfs_time(g: DirectedGraph, s: i64) i64 {
    const begin: i64 = _now();
    _ = dg_bfs(g, s);
    const end: i64 = _now();
    return end - begin;
}

fn g_make_graph() Graph {
    return .{ .graph = std.AutoHashMap(i64, [][]i64).init(std.heap.page_allocator) };
}

fn g_add_pair(g_param: *Graph, u: i64, v: i64, w: i64) void {
    if (g_param.graph.contains(u)) {
        var edges: [][]i64 = g_param.graph.get(u).?;
        edges = edges;
        if (!(edge_exists(edges, w, v))) {
            edges = blk: { var _tmp_14 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_14.appendSlice(@as([]const []i64, edges)) catch |err| handleError(err); _tmp_14.append(@constCast(blk3: { var _tmp_15 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_15.append(w) catch unreachable; _tmp_15.append(v) catch unreachable; break :blk3 (_tmp_15.toOwnedSlice() catch unreachable); })) catch |err| handleError(err); break :blk (_tmp_14.toOwnedSlice() catch |err| handleError(err)); };
            var m: std.AutoHashMap(i64,[][]i64) = g_param.graph;
            m = m;
            m.put(u, edges) catch unreachable;
            g_param.graph = m;
        }
    } else {
        var m0: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m0 = m0;
        m0.put(u, blk4: { var _tmp_16 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_16.append(@constCast(blk5: { var _tmp_17 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_17.append(w) catch unreachable; _tmp_17.append(v) catch unreachable; break :blk5 (_tmp_17.toOwnedSlice() catch unreachable); })) catch unreachable; break :blk4 (_tmp_16.toOwnedSlice() catch unreachable); }) catch unreachable;
        g_param.graph = m0;
    }
    if (g_param.graph.contains(v)) {
        var edges2: [][]i64 = g_param.graph.get(v).?;
        edges2 = edges2;
        if (!(edge_exists(edges2, w, u))) {
            edges2 = blk: { var _tmp_18 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_18.appendSlice(@as([]const []i64, edges2)) catch |err| handleError(err); _tmp_18.append(@constCast(blk6: { var _tmp_19 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_19.append(w) catch unreachable; _tmp_19.append(u) catch unreachable; break :blk6 (_tmp_19.toOwnedSlice() catch unreachable); })) catch |err| handleError(err); break :blk (_tmp_18.toOwnedSlice() catch |err| handleError(err)); };
            var m2: std.AutoHashMap(i64,[][]i64) = g_param.graph;
            m2 = m2;
            m2.put(v, edges2) catch unreachable;
            g_param.graph = m2;
        }
    } else {
        var m3: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m3 = m3;
        m3.put(v, blk7: { var _tmp_20 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_20.append(@constCast(blk8: { var _tmp_21 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_21.append(w) catch unreachable; _tmp_21.append(u) catch unreachable; break :blk8 (_tmp_21.toOwnedSlice() catch unreachable); })) catch unreachable; break :blk7 (_tmp_20.toOwnedSlice() catch unreachable); }) catch unreachable;
        g_param.graph = m3;
    }
}

fn g_remove_pair(g_param: *Graph, u: i64, v: i64) void {
    if (g_param.graph.contains(u)) {
        var edges: [][]i64 = g_param.graph.get(u).?;
        edges = edges;
        var new_edges: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
        new_edges = new_edges;
        var i: i64 = 0;
        i = i;
        while (i < @as(i64, @intCast(edges.len))) {
            if (edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)] != v) {
                new_edges = blk: { var _tmp_22 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_22.appendSlice(@as([]const []i64, new_edges)) catch |err| handleError(err); _tmp_22.append(edges[_idx(edges.len, i)]) catch |err| handleError(err); break :blk (_tmp_22.toOwnedSlice() catch |err| handleError(err)); };
            }
            i = i + 1;
        }
        var m: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m = m;
        m.put(u, new_edges) catch unreachable;
        g_param.graph = m;
    }
    if (g_param.graph.contains(v)) {
        var edges2: [][]i64 = g_param.graph.get(v).?;
        edges2 = edges2;
        var new_edges2: [][]i64 = std.heap.page_allocator.alloc([]i64, 0) catch unreachable;
        new_edges2 = new_edges2;
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(edges2.len))) {
            if (edges2[_idx(edges2.len, j)][_idx(edges2[_idx(edges2.len, j)].len, 1)] != u) {
                new_edges2 = blk: { var _tmp_23 = std.ArrayList([]i64).init(std.heap.page_allocator); _tmp_23.appendSlice(@as([]const []i64, new_edges2)) catch |err| handleError(err); _tmp_23.append(edges2[_idx(edges2.len, j)]) catch |err| handleError(err); break :blk (_tmp_23.toOwnedSlice() catch |err| handleError(err)); };
            }
            j = j + 1;
        }
        var m2: std.AutoHashMap(i64,[][]i64) = g_param.graph;
        m2 = m2;
        m2.put(v, new_edges2) catch unreachable;
        g_param.graph = m2;
    }
}

fn g_all_nodes(g: Graph) []i64 {
    var res: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    res = res;
    var __mapit13 = g.graph.keyIterator();
    while (__mapit13.next()) |__it12| {
        const k = __it12.*;
        res = blk: { var _tmp_24 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_24.appendSlice(@as([]const i64, res)) catch |err| handleError(err); _tmp_24.append(k) catch |err| handleError(err); break :blk (_tmp_24.toOwnedSlice() catch |err| handleError(err)); };
    }
    return res;
}

fn g_dfs_util(g: Graph, node: i64, visited_param: *std.AutoHashMap(i64,bool), order_param_1: []i64, d: i64) []i64 {
    var order_var: []i64 = order_param_1;
    order_var = order_var;
    visited_param.put(node, true) catch unreachable;
    order_var = blk: { var _tmp_25 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_25.appendSlice(@as([]const i64, order_var)) catch |err| handleError(err); _tmp_25.append(node) catch |err| handleError(err); break :blk (_tmp_25.toOwnedSlice() catch |err| handleError(err)); };
    if (d != 0 - 1 and node == d) {
        return order_var;
    }
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            order_var = g_dfs_util(g, neigh, visited_param, order_var, d);
            if (d != 0 - 1 and order_var[_idx(order_var.len, @as(i64, @intCast(order_var.len)) - 1)] == d) {
                return order_var;
            }
        }
        i = i + 1;
    }
    return order_var;
}

fn g_dfs(g: Graph, s: i64, d: i64) []i64 {
    if (s == d) {
        return (&[_]i64{})[0..0];
    }
    const start: i64 = if (s == 0 - 2) first_key(&g.graph) else s;
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var order: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    order = order;
    order = g_dfs_util(g, start, @constCast(&visited), order, d);
    return order;
}

fn g_bfs(g: Graph, s: i64) []i64 {
    var queue: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    queue = queue;
    var visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    visited = visited;
    var order: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    order = order;
    const start: i64 = if (s == 0 - 2) first_key(&g.graph) else s;
    queue = blk: { var _tmp_26 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_26.appendSlice(@as([]const i64, queue)) catch |err| handleError(err); _tmp_26.append(start) catch |err| handleError(err); break :blk (_tmp_26.toOwnedSlice() catch |err| handleError(err)); };
    visited.put(start, true) catch unreachable;
    while (@as(i64, @intCast(queue.len)) > 0) {
        const node: i64 = queue[_idx(queue.len, 0)];
        queue = queue[@as(usize, @intCast(1))..@min(@as(usize, @intCast(@as(i64, @intCast(queue.len)))), @as(usize, @intCast(queue.len)))];
        order = blk: { var _tmp_27 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_27.appendSlice(@as([]const i64, order)) catch |err| handleError(err); _tmp_27.append(node) catch |err| handleError(err); break :blk (_tmp_27.toOwnedSlice() catch |err| handleError(err)); };
        var edges: [][]i64 = g.graph.get(node).?;
        edges = edges;
        var i: i64 = 0;
        i = i;
        while (i < @as(i64, @intCast(edges.len))) {
            const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
            if (!(visited.contains(neigh))) {
                queue = blk: { var _tmp_28 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_28.appendSlice(@as([]const i64, queue)) catch |err| handleError(err); _tmp_28.append(neigh) catch |err| handleError(err); break :blk (_tmp_28.toOwnedSlice() catch |err| handleError(err)); };
                visited.put(neigh, true) catch unreachable;
            }
            i = i + 1;
        }
    }
    return order;
}

fn g_degree(g: Graph, u: i64) i64 {
    if (g.graph.contains(u)) {
        return @as(i64, @intCast(g.graph.get(u).?.len));
    }
    return 0;
}

fn g_cycle_util(g: Graph, node: i64, visited_param: *std.AutoHashMap(i64,bool), parent: i64, res_param_1: []i64) []i64 {
    var res_var: []i64 = res_param_1;
    res_var = res_var;
    visited_param.put(node, true) catch unreachable;
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            res_var = g_cycle_util(g, neigh, visited_param, node, res_var);
        } else {
            if (neigh != parent) {
                if (!(list_contains_int(res_var, neigh))) {
                    res_var = blk: { var _tmp_29 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_29.appendSlice(@as([]const i64, res_var)) catch |err| handleError(err); _tmp_29.append(neigh) catch |err| handleError(err); break :blk (_tmp_29.toOwnedSlice() catch |err| handleError(err)); };
                }
                if (!(list_contains_int(res_var, node))) {
                    res_var = blk: { var _tmp_30 = std.ArrayList(i64).init(std.heap.page_allocator); _tmp_30.appendSlice(@as([]const i64, res_var)) catch |err| handleError(err); _tmp_30.append(node) catch |err| handleError(err); break :blk (_tmp_30.toOwnedSlice() catch |err| handleError(err)); };
                }
            }
        }
        i = i + 1;
    }
    return res_var;
}

fn g_cycle_nodes(g: Graph) []i64 {
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var res: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    res = res;
    var __mapit15 = g.graph.keyIterator();
    while (__mapit15.next()) |__it14| {
        const k = __it14.*;
        if (!(visited.contains(k))) {
            res = g_cycle_util(g, k, @constCast(&visited), 0 - 1, res);
        }
    }
    return res;
}

fn g_has_cycle_util(g: Graph, node: i64, visited_param: *std.AutoHashMap(i64,bool), parent: i64) bool {
    visited_param.put(node, true) catch unreachable;
    var edges: [][]i64 = g.graph.get(node).?;
    edges = edges;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(edges.len))) {
        const neigh: i64 = edges[_idx(edges.len, i)][_idx(edges[_idx(edges.len, i)].len, 1)];
        if (!(visited_param.contains(neigh))) {
            if (g_has_cycle_util(g, neigh, visited_param, node)) {
                return true;
            }
        } else {
            if (neigh != parent) {
                return true;
            }
        }
        i = i + 1;
    }
    return false;
}

fn g_has_cycle(g: Graph) bool {
    const visited: std.AutoHashMap(i64,bool) = std.AutoHashMap(i64, bool).init(std.heap.page_allocator);
    var __mapit17 = g.graph.keyIterator();
    while (__mapit17.next()) |__it16| {
        const k = __it16.*;
        if (!(visited.contains(k))) {
            if (g_has_cycle_util(g, k, @constCast(&visited), 0 - 1)) {
                return true;
            }
        }
    }
    return false;
}

fn g_fill_graph_randomly(g: Graph, c: i64) void {
    var count: i64 = c;
    count = count;
    if (count == 0 - 1) {
        count = rand_range(10, 10010);
    }
    var i: i64 = 0;
    i = i;
    while (i < count) {
        const edge_count: i64 = rand_range(1, 103);
        var j: i64 = 0;
        j = j;
        while (j < edge_count) {
            const n: i64 = rand_range(0, count);
            if (n != i) {
                g_add_pair(&g, i, n, 1);
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn g_dfs_time(g: Graph, s: i64, e: i64) i64 {
    const begin: i64 = _now();
    _ = g_dfs(g, s, e);
    const end: i64 = _now();
    return end - begin;
}

fn g_bfs_time(g: Graph, s: i64) i64 {
    const begin: i64 = _now();
    _ = g_bfs(g, s);
    const end: i64 = _now();
    return end - begin;
}

fn mochi_main() void {
    const dg: DirectedGraph = dg_make_graph();
    dg_add_pair(@constCast(&dg), 0, 1, 5);
    dg_add_pair(@constCast(&dg), 0, 2, 3);
    dg_add_pair(@constCast(&dg), 1, 3, 2);
    dg_add_pair(@constCast(&dg), 2, 3, 4);
    std.debug.print("{s}\n", .{_str(dg_dfs(dg, 0 - 2, 0 - 1))});
    std.debug.print("{s}\n", .{_str(dg_bfs(dg, 0 - 2))});
    std.debug.print("{s}\n", .{_str(dg_in_degree(dg, 3))});
    std.debug.print("{s}\n", .{_str(dg_out_degree(dg, 0))});
    std.debug.print("{s}\n", .{_str(dg_topological_sort(dg))});
    std.debug.print("{s}\n", .{_str(dg_has_cycle(dg))});
    const ug: Graph = g_make_graph();
    g_add_pair(@constCast(&ug), 0, 1, 1);
    g_add_pair(@constCast(&ug), 1, 2, 1);
    g_add_pair(@constCast(&ug), 2, 0, 1);
    std.debug.print("{s}\n", .{_str(g_dfs(ug, 0 - 2, 0 - 1))});
    std.debug.print("{s}\n", .{_str(g_bfs(ug, 0 - 2))});
    std.debug.print("{s}\n", .{_str(g_degree(ug, 1))});
    std.debug.print("{s}\n", .{_str(g_has_cycle(ug))});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        mochi_main();
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .pointer => |p| {
        if (p.size == .slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    .@"struct" => |_| {
        if (@hasDecl(@TypeOf(v), "iterator")) {
            const KVPair = struct{ ks: []const u8, vs: []const u8 };
            var pairs = std.ArrayList(KVPair).init(std.heap.page_allocator);
            defer pairs.deinit();
            var it = v.iterator();
            while (it.next()) |e| {
                const ks = _str(e.key_ptr.*);
                const vs = _str(e.value_ptr.*);
                pairs.append(.{ .ks = ks, .vs = vs }) catch unreachable;
            }
            std.sort.heap(KVPair, pairs.items, {}, struct {
                pub fn less(_: void, a: KVPair, b: KVPair) bool {
                    return std.mem.lessThan(u8, a.ks, b.ks);
                }
            }.less);
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.appendSlice("map[") catch unreachable;
            for (pairs.items, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                out.appendSlice(e.ks) catch unreachable;
                out.append(':') catch unreachable;
                out.appendSlice(e.vs) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.heap.pageSize()));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
