// Generated by Mochi Zig transpiler on 2025-08-14 22:13 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Pos = struct {
    x: i64,
    y: i64,
};

const PQNode = struct {
    pos: Pos,
    pri: f64,
};

const PQPopResult = struct {
    pq: []PQNode,
    node: PQNode,
};

const W1_var: f64 = 1.0;
const W2_var: f64 = 1.0;
const n_var: i64 = 20;
const n_heuristic_var: i64 = 3;
const INF_var: f64 = 1000000000.0;
var t_var_1: i64 = 1;
var blocks_var: []Pos = &[_]Pos{};
var start_var: Pos = undefined;
var goal_var: Pos = undefined;

fn pos_equal(a: Pos, b: Pos) bool {
    return a.x == b.x and a.y == b.y;
}

fn pos_key(p: Pos) []const u8 {
    return _concat_string(_concat_string(_str(p.x), ","), _str(p.y));
}

fn sqrtApprox(x: f64) f64 {
    if (x <= 0.0) {
        return 0.0;
    }
    var guess: f64 = x;
    guess = guess;
    var i: i64 = 0;
    i = i;
    while (i < 10) {
        guess = (guess + x / guess) / 2.0;
        i = i + 1;
    }
    return guess;
}

fn consistent_heuristic(p: Pos, goal_param: Pos) f64 {
    const dx: f64 = @as(f64, @floatFromInt(p.x - goal_param.x));
    const dy: f64 = @as(f64, @floatFromInt(p.y - goal_param.y));
    return sqrtApprox(dx * dx + dy * dy);
}

fn iabs(x: i64) i64 {
    if (x < 0) {
        return 0 - x;
    }
    return x;
}

fn heuristic_1(p: Pos, goal_param: Pos) f64 {
    return @as(f64, @floatFromInt(iabs(p.x - goal_param.x) + iabs(p.y - goal_param.y)));
}

fn heuristic_2(p: Pos, goal_param: Pos) f64 {
    const h: f64 = consistent_heuristic(p, goal_param);
    return h / @as(f64, @floatFromInt(t_var_1));
}

fn heuristic(i: i64, p: Pos, goal_param: Pos) f64 {
    if (i == 0) {
        return consistent_heuristic(p, goal_param);
    }
    if (i == 1) {
        return heuristic_1(p, goal_param);
    }
    return heuristic_2(p, goal_param);
}

fn key_fn(start_param: Pos, i: i64, goal_param: Pos, g_func: *const std.StringHashMap(f64)) f64 {
    const g: f64 = g_func.get(pos_key(start_param)).?;
    return g + W1_var * heuristic(i, start_param, goal_param);
}

fn valid(p: Pos) bool {
    if (p.x < 0 or p.x > n_var - 1) {
        return false;
    }
    if (p.y < 0 or p.y > n_var - 1) {
        return false;
    }
    return true;
}

fn in_blocks(p: Pos) bool {
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(blocks_var.len))) {
        if (pos_equal(blocks_var[_idx(blocks_var.len, i)], p)) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

fn pq_put(pq_param: []PQNode, node: Pos, pri: f64) []PQNode {
    var pq_var: []PQNode = pq_param;
    pq_var = pq_var;
    var updated: bool = false;
    updated = updated;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(pq_var.len))) {
        if (pos_equal(pq_var[_idx(pq_var.len, i)].pos, node)) {
            if (pri < pq_var[_idx(pq_var.len, i)].pri) {
                pq_var[_idx(pq_var.len, i)] = .{ .pos = node, .pri = pri };
            }
            updated = true;
        }
        i = i + 1;
    }
    if (!(updated)) {
        pq_var = blk: { var _tmp = std.ArrayList(PQNode).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const PQNode, pq_var)) catch |err| handleError(err); _tmp.append(.{ .pos = node, .pri = pri }) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
    }
    return pq_var;
}

fn pq_minkey(pq: []PQNode) f64 {
    if (@as(i64, @intCast(pq.len)) == 0) {
        return INF_var;
    }
    const first: PQNode = pq[_idx(pq.len, 0)];
    var m: f64 = first.pri;
    m = m;
    var i: i64 = 1;
    i = i;
    while (i < @as(i64, @intCast(pq.len))) {
        const item: PQNode = pq[_idx(pq.len, i)];
        if (item.pri < m) {
            m = item.pri;
        }
        i = i + 1;
    }
    return m;
}

fn pq_pop_min(pq: []PQNode) PQPopResult {
    var best: PQNode = pq[_idx(pq.len, 0)];
    best = best;
    var idx: i64 = 0;
    idx = idx;
    var i: i64 = 1;
    i = i;
    while (i < @as(i64, @intCast(pq.len))) {
        if (pq[_idx(pq.len, i)].pri < best.pri) {
            best = pq[_idx(pq.len, i)];
            idx = i;
        }
        i = i + 1;
    }
    var new_pq: []PQNode = std.heap.page_allocator.alloc(PQNode, 0) catch unreachable;
    new_pq = new_pq;
    i = 0;
    while (i < @as(i64, @intCast(pq.len))) {
        if (i != idx) {
            new_pq = blk: { var _tmp_1 = std.ArrayList(PQNode).init(std.heap.page_allocator); _tmp_1.appendSlice(@as([]const PQNode, new_pq)) catch |err| handleError(err); _tmp_1.append(pq[_idx(pq.len, i)]) catch |err| handleError(err); break :blk (_tmp_1.toOwnedSlice() catch |err| handleError(err)); };
        }
        i = i + 1;
    }
    return .{ .pq = new_pq, .node = best };
}

fn pq_remove(pq: []PQNode, node: Pos) []PQNode {
    var new_pq: []PQNode = std.heap.page_allocator.alloc(PQNode, 0) catch unreachable;
    new_pq = new_pq;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(pq.len))) {
        if (!(pos_equal(pq[_idx(pq.len, i)].pos, node))) {
            new_pq = blk: { var _tmp_2 = std.ArrayList(PQNode).init(std.heap.page_allocator); _tmp_2.appendSlice(@as([]const PQNode, new_pq)) catch |err| handleError(err); _tmp_2.append(pq[_idx(pq.len, i)]) catch |err| handleError(err); break :blk (_tmp_2.toOwnedSlice() catch |err| handleError(err)); };
        }
        i = i + 1;
    }
    return new_pq;
}

fn reconstruct(back_pointer: *const std.StringHashMap(Pos), goal_param: Pos, start_param: Pos) []Pos {
    var path: []Pos = std.heap.page_allocator.alloc(Pos, 0) catch unreachable;
    path = path;
    var current: Pos = goal_param;
    current = current;
    var key: []const u8 = pos_key(current);
    key = key;
    path = blk: { var _tmp_3 = std.ArrayList(Pos).init(std.heap.page_allocator); _tmp_3.appendSlice(@as([]const Pos, path)) catch |err| handleError(err); _tmp_3.append(current) catch |err| handleError(err); break :blk (_tmp_3.toOwnedSlice() catch |err| handleError(err)); };
    while (!(pos_equal(current, start_param))) {
        current = back_pointer.get(key).?;
        key = pos_key(current);
        path = blk: { var _tmp_4 = std.ArrayList(Pos).init(std.heap.page_allocator); _tmp_4.appendSlice(@as([]const Pos, path)) catch |err| handleError(err); _tmp_4.append(current) catch |err| handleError(err); break :blk (_tmp_4.toOwnedSlice() catch |err| handleError(err)); };
    }
    var rev: []Pos = std.heap.page_allocator.alloc(Pos, 0) catch unreachable;
    rev = rev;
    var i: i64 = @as(i64, @intCast(path.len)) - 1;
    i = i;
    while (i >= 0) {
        rev = blk: { var _tmp_5 = std.ArrayList(Pos).init(std.heap.page_allocator); _tmp_5.appendSlice(@as([]const Pos, rev)) catch |err| handleError(err); _tmp_5.append(path[_idx(path.len, i)]) catch |err| handleError(err); break :blk (_tmp_5.toOwnedSlice() catch |err| handleError(err)); };
        i = i - 1;
    }
    return rev;
}

fn neighbours(p: Pos) []Pos {
    const left: Pos = .{ .x = p.x - 1, .y = p.y };
    const right: Pos = .{ .x = p.x + 1, .y = p.y };
    const up: Pos = .{ .x = p.x, .y = p.y + 1 };
    const down: Pos = .{ .x = p.x, .y = p.y - 1 };
    return blk: { var _tmp = std.ArrayList(Pos).init(std.heap.page_allocator); _tmp.append(left) catch |err| handleError(err); _tmp.append(right) catch |err| handleError(err); _tmp.append(up) catch |err| handleError(err); _tmp.append(down) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
}

fn multi_a_star(start_param: Pos, goal_param: Pos, n_heuristic_param: i64) void {
    var g_function: std.StringHashMap(f64) = std.StringHashMap(f64).init(std.heap.page_allocator);
    g_function = g_function;
    var back_pointer: std.StringHashMap(Pos) = std.StringHashMap(Pos).init(std.heap.page_allocator);
    back_pointer = back_pointer;
    var visited: std.StringHashMap(bool) = std.StringHashMap(bool).init(std.heap.page_allocator);
    visited = visited;
    var open_list: [][]PQNode = std.heap.page_allocator.alloc([]PQNode, 0) catch unreachable;
    open_list = open_list;
    g_function.put(pos_key(start_param), 0.0) catch unreachable;
    g_function.put(pos_key(goal_param), INF_var) catch unreachable;
    back_pointer.put(pos_key(start_param), .{ .x = 0 - 1, .y = 0 - 1 }) catch unreachable;
    back_pointer.put(pos_key(goal_param), .{ .x = 0 - 1, .y = 0 - 1 }) catch unreachable;
    visited.put(pos_key(start_param), true) catch unreachable;
    var i: i64 = 0;
    i = i;
    while (i < n_heuristic_param) {
        open_list = blk: { var _tmp_6 = std.ArrayList([]PQNode).init(std.heap.page_allocator); _tmp_6.appendSlice(@as([]const []PQNode, open_list)) catch |err| handleError(err); _tmp_6.append(@constCast((&[_]PQNode{})[0..0])) catch |err| handleError(err); break :blk (_tmp_6.toOwnedSlice() catch |err| handleError(err)); };
        const pri: f64 = key_fn(start_param, i, goal_param, &g_function);
        open_list[_idx(open_list.len, i)] = pq_put(open_list[_idx(open_list.len, i)], start_param, pri);
        i = i + 1;
    }
    while (pq_minkey(open_list[_idx(open_list.len, 0)]) < INF_var) {
        var chosen: i64 = 0;
        chosen = chosen;
        i = 1;
        while (i < n_heuristic_param) {
            if (pq_minkey(open_list[_idx(open_list.len, i)]) <= W2_var * pq_minkey(open_list[_idx(open_list.len, 0)])) {
                chosen = i;
                break;
            }
            i = i + 1;
        }
        if (chosen != 0) {
            t_var_1 = t_var_1 + 1;
        }
        const pair: PQPopResult = pq_pop_min(open_list[_idx(open_list.len, chosen)]);
        open_list[_idx(open_list.len, chosen)] = pair.pq;
        var current: PQNode = pair.node;
        current = current;
        i = 0;
        while (i < n_heuristic_param) {
            if (i != chosen) {
                open_list[_idx(open_list.len, i)] = pq_remove(open_list[_idx(open_list.len, i)], current.pos);
            }
            i = i + 1;
        }
        const ckey: []const u8 = pos_key(current.pos);
        if (visited.contains(ckey)) {
            continue;
        }
        visited.put(ckey, true) catch unreachable;
        if (pos_equal(current.pos, goal_param)) {
            var path: []Pos = reconstruct(&back_pointer, goal_param, start_param);
            path = path;
            var j: i64 = 0;
            j = j;
            while (j < @as(i64, @intCast(path.len))) {
                const p: Pos = path[_idx(path.len, j)];
                std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("(", _str(p.x)), ","), _str(p.y)), ")")});
                j = j + 1;
            }
            return;
        }
        const neighs: []Pos = neighbours(current.pos);
        var k: i64 = 0;
        k = k;
        while (k < @as(i64, @intCast(neighs.len))) {
            const nb: Pos = neighs[_idx(neighs.len, k)];
            if (valid(nb) and in_blocks(nb) == false) {
                const nkey: []const u8 = pos_key(nb);
                const tentative: f64 = g_function.get(ckey).? + 1.0;
                if (!(g_function.contains(nkey)) or tentative < g_function.get(nkey).?) {
                    g_function.put(nkey, tentative) catch unreachable;
                    back_pointer.put(nkey, current.pos) catch unreachable;
                    i = 0;
                    while (i < n_heuristic_param) {
                        const pri2: f64 = tentative + W1_var * heuristic(i, nb, goal_param);
                        open_list[_idx(open_list.len, i)] = pq_put(open_list[_idx(open_list.len, i)], nb, pri2);
                        i = i + 1;
                    }
                }
            }
            k = k + 1;
        }
    }
    std.debug.print("{s}\n", .{"No path found to goal"});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        blocks_var = blk0: { var _tmp_7 = std.ArrayList(Pos).init(std.heap.page_allocator); _tmp_7.append(.{ .x = 0, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 1, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 2, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 3, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 4, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 5, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 6, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 7, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 8, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 9, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 10, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 11, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 12, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 13, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 14, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 15, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 16, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 17, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 18, .y = 1 }) catch unreachable; _tmp_7.append(.{ .x = 19, .y = 1 }) catch unreachable; break :blk0 (_tmp_7.toOwnedSlice() catch unreachable); };
        start_var = .{ .x = 0, .y = 0 };
        goal_var = .{ .x = n_var - 1, .y = n_var - 1 };
        multi_a_star(start_var, goal_var, n_heuristic_var);
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .pointer => |p| {
        if (p.size == .slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    .@"struct" => |_| {
        if (@hasDecl(@TypeOf(v), "iterator")) {
            const KVPair = struct{ ks: []const u8, vs: []const u8 };
            var pairs = std.ArrayList(KVPair).init(std.heap.page_allocator);
            defer pairs.deinit();
            var it = v.iterator();
            while (it.next()) |e| {
                const ks = _str(e.key_ptr.*);
                const vs = _str(e.value_ptr.*);
                pairs.append(.{ .ks = ks, .vs = vs }) catch unreachable;
            }
            std.sort.heap(KVPair, pairs.items, {}, struct {
                pub fn less(_: void, a: KVPair, b: KVPair) bool {
                    return std.mem.lessThan(u8, a.ks, b.ks);
                }
            }.less);
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.appendSlice("map[") catch unreachable;
            for (pairs.items, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                out.appendSlice(e.ks) catch unreachable;
                out.append(':') catch unreachable;
                out.appendSlice(e.vs) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.heap.pageSize()));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
