// Generated by Mochi Zig transpiler on 2025-08-13 16:10 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

var observations_var: [][]const u8 = &[_][]const u8{};
var states_var: [][]const u8 = &[_][]const u8{};
var start_p_var: std.StringHashMap(f64) = std.StringHashMap(f64).init(std.heap.page_allocator);
var trans_p_var: std.StringHashMap(std.StringHashMap(f64)) = std.StringHashMap(std.StringHashMap(f64)).init(std.heap.page_allocator);
var emit_p_var: std.StringHashMap(std.StringHashMap(f64)) = std.StringHashMap(std.StringHashMap(f64)).init(std.heap.page_allocator);
var result_var: [][]const u8 = &[_][]const u8{};

fn key(state_param: []const u8, obs_param: []const u8) []const u8 {
    var state_var: []const u8 = state_param;
    state_var = state_var;
    var obs_var: []const u8 = obs_param;
    obs_var = obs_var;
    return _concat_string(_concat_string(state_var, "|"), obs_var);
}

fn viterbi(observations_param: [][]const u8, states_param: [][]const u8, start_p_param: *const std.StringHashMap(f64), trans_p_param: *const std.StringHashMap(std.StringHashMap(f64)), emit_p_param: *const std.StringHashMap(std.StringHashMap(f64))) [][]const u8 {
    const observations_var_1: [][]const u8 = observations_param;
    const states_var_1: [][]const u8 = states_param;
    if (@as(i64, @intCast(observations_var_1.len)) == 0 or @as(i64, @intCast(states_var_1.len)) == 0) {
        @panic("empty parameters");
    }
    var probs: std.StringHashMap(f64) = std.StringHashMap(f64).init(std.heap.page_allocator);
    probs = probs;
    var ptrs: std.StringHashMap([]const u8) = std.StringHashMap([]const u8).init(std.heap.page_allocator);
    ptrs = ptrs;
    const first_obs: []const u8 = observations_var_1[_idx(observations_var_1.len, 0)];
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(states_var_1.len))) {
        const state: []const u8 = states_var_1[_idx(states_var_1.len, i)];
        probs.put(key(state, first_obs), start_p_param.get(state).? * emit_p_param.get(state).?.get(first_obs).?) catch unreachable;
        ptrs.put(key(state, first_obs), "") catch unreachable;
        i = i + 1;
    }
    var t: i64 = 1;
    t = t;
    while (t < @as(i64, @intCast(observations_var_1.len))) {
        const obs: []const u8 = observations_var_1[_idx(observations_var_1.len, t)];
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(states_var_1.len))) {
            const state: []const u8 = states_var_1[_idx(states_var_1.len, j)];
            var max_prob: f64 = @as(f64, @floatFromInt(0)) - 1.0;
            max_prob = max_prob;
            var prev_state: []const u8 = "";
            prev_state = prev_state;
            var k: i64 = 0;
            k = k;
            while (k < @as(i64, @intCast(states_var_1.len))) {
                const state0: []const u8 = states_var_1[_idx(states_var_1.len, k)];
                const obs0: []const u8 = observations_var_1[_idx(observations_var_1.len, t - 1)];
                const prob_prev: f64 = probs.get(key(state0, obs0)).?;
                const prob: f64 = prob_prev * trans_p_param.get(state0).?.get(state).? * emit_p_param.get(state).?.get(obs).?;
                if (prob > max_prob) {
                    max_prob = prob;
                    prev_state = state0;
                }
                k = k + 1;
            }
            probs.put(key(state, obs), max_prob) catch unreachable;
            ptrs.put(key(state, obs), prev_state) catch unreachable;
            j = j + 1;
        }
        t = t + 1;
    }
    var path: [][]const u8 = std.heap.page_allocator.alloc([]const u8, 0) catch unreachable;
    path = path;
    var n: i64 = 0;
    n = n;
    while (n < @as(i64, @intCast(observations_var_1.len))) {
        path = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, path)) catch |err| handleError(err); _tmp.append(@constCast("")) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        n = n + 1;
    }
    const last_obs: []const u8 = observations_var_1[_idx(observations_var_1.len, @as(i64, @intCast(observations_var_1.len)) - 1)];
    var max_final: f64 = @as(f64, @floatFromInt(0)) - 1.0;
    max_final = max_final;
    var last_state: []const u8 = "";
    last_state = last_state;
    var m: i64 = 0;
    m = m;
    while (m < @as(i64, @intCast(states_var_1.len))) {
        const state: []const u8 = states_var_1[_idx(states_var_1.len, m)];
        const prob: f64 = probs.get(key(state, last_obs)).?;
        if (prob > max_final) {
            max_final = prob;
            last_state = state;
        }
        m = m + 1;
    }
    const last_index: i64 = @as(i64, @intCast(observations_var_1.len)) - 1;
    path[_idx(path.len, last_index)] = last_state;
    var idx: i64 = last_index;
    idx = idx;
    while (idx > 0) {
        const obs: []const u8 = observations_var_1[_idx(observations_var_1.len, idx)];
        const prev: []const u8 = ptrs.get(key(path[_idx(path.len, idx)], obs)).?;
        path[_idx(path.len, idx - 1)] = prev;
        idx = idx - 1;
    }
    return path;
}

fn join_words(words_param: [][]const u8) []const u8 {
    var words_var: [][]const u8 = words_param;
    words_var = words_var;
    var res: []const u8 = "";
    res = res;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(words_var.len))) {
        if (i > 0) {
            res = _concat_string(res, " ");
        }
        res = _concat_string(res, words_var[_idx(words_var.len, i)]);
        i = i + 1;
    }
    return res;
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        observations_var = std.heap.page_allocator.dupe([]const u8, (&([3][]const u8{"normal", "cold", "dizzy"}))[0..]) catch unreachable;
        states_var = std.heap.page_allocator.dupe([]const u8, (&([2][]const u8{"Healthy", "Fever"}))[0..]) catch unreachable;
        start_p_var = blk0: { var m = std.StringHashMap(f64).init(std.heap.page_allocator); m.put("Healthy", 0.6) catch unreachable; m.put("Fever", 0.4) catch unreachable; break :blk0 m; };
        trans_p_var = blk1: { var m_1 = std.StringHashMap(std.StringHashMap(f64)).init(std.heap.page_allocator); m_1.put("Healthy", blk2: { var m_2 = std.StringHashMap(f64).init(std.heap.page_allocator); m_2.put("Healthy", 0.7) catch unreachable; m_2.put("Fever", 0.3) catch unreachable; break :blk2 m_2; }) catch unreachable; m_1.put("Fever", blk3: { var m_3 = std.StringHashMap(f64).init(std.heap.page_allocator); m_3.put("Healthy", 0.4) catch unreachable; m_3.put("Fever", 0.6) catch unreachable; break :blk3 m_3; }) catch unreachable; break :blk1 m_1; };
        emit_p_var = blk4: { var m_4 = std.StringHashMap(std.StringHashMap(f64)).init(std.heap.page_allocator); m_4.put("Healthy", blk5: { var m_5 = std.StringHashMap(f64).init(std.heap.page_allocator); m_5.put("normal", 0.5) catch unreachable; m_5.put("cold", 0.4) catch unreachable; m_5.put("dizzy", 0.1) catch unreachable; break :blk5 m_5; }) catch unreachable; m_4.put("Fever", blk6: { var m_6 = std.StringHashMap(f64).init(std.heap.page_allocator); m_6.put("normal", 0.1) catch unreachable; m_6.put("cold", 0.3) catch unreachable; m_6.put("dizzy", 0.6) catch unreachable; break :blk6 m_6; }) catch unreachable; break :blk4 m_4; };
        result_var = viterbi(observations_var, states_var, &start_p_var, &trans_p_var, &emit_p_var);
        std.debug.print("{s}\n", .{join_words(result_var)});
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
