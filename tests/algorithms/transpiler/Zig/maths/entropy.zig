// Generated by Mochi Zig transpiler on 2025-08-16 14:44 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const TextCounts = struct {
    single: std.StringHashMap(i64),
    double: std.StringHashMap(i64),
};

var text1_var: []const u8 = &[_]u8{};
var text3_var: []const u8 = &[_]u8{};

fn log2(x: f64) f64 {
    var k: f64 = 0.0;
    k = k;
    var v: f64 = x;
    v = v;
    while (v >= 2.0) {
        v = v / 2.0;
        k = k + 1.0;
    }
    while (v < 1.0) {
        v = v * 2.0;
        k = k - 1.0;
    }
    const z: f64 = (v - 1.0) / (v + 1.0);
    var zpow: f64 = z;
    zpow = zpow;
    var sum: f64 = z;
    sum = sum;
    var i: i64 = 3;
    i = i;
    while (i <= 9) {
        zpow = zpow * z * z;
        sum = sum + zpow / @as(f64, @floatFromInt(i));
        i = i +% 2;
    }
    const ln2: f64 = 0.6931471805599453;
    return k + 2.0 * sum / ln2;
}

fn analyze_text(text: []const u8) TextCounts {
    var single: std.StringHashMap(i64) = std.StringHashMap(i64).init(std.heap.page_allocator);
    single = single;
    var double: std.StringHashMap(i64) = std.StringHashMap(i64).init(std.heap.page_allocator);
    double = double;
    const n: i64 = @as(i64, @intCast(text.len));
    if (n == 0) {
        return .{ .single = single, .double = double };
    }
    const last: []const u8 = text[@as(usize, @intCast(n -% 1))..@min(@as(usize, @intCast(n)), @as(usize, @intCast(text.len)))];
    if (single.contains(last)) {
        single.put(last, single.get(last).? +% 1) catch unreachable;
    } else {
        single.put(last, 1) catch unreachable;
    }
    const first: []const u8 = text[@as(usize, @intCast(0))..@min(@as(usize, @intCast(1)), @as(usize, @intCast(text.len)))];
    const pair0: []const u8 = _concat_string(" ", first);
    double.put(pair0, 1) catch unreachable;
    var i_1: i64 = 0;
    i_1 = i_1;
    while (i_1 < n -% 1) {
        const ch: []const u8 = text[@as(usize, @intCast(i_1))..@min(@as(usize, @intCast(i_1 +% 1)), @as(usize, @intCast(text.len)))];
        if (single.contains(ch)) {
            single.put(ch, single.get(ch).? +% 1) catch unreachable;
        } else {
            single.put(ch, 1) catch unreachable;
        }
        const seq: []const u8 = text[@as(usize, @intCast(i_1))..@min(@as(usize, @intCast(i_1 +% 2)), @as(usize, @intCast(text.len)))];
        if (double.contains(seq)) {
            double.put(seq, double.get(seq).? +% 1) catch unreachable;
        } else {
            double.put(seq, 1) catch unreachable;
        }
        i_1 = i_1 +% 1;
    }
    return .{ .single = single, .double = double };
}

fn round_to_int(x_1: f64) i64 {
    if (x_1 < 0.0) {
        return @as(i64, @intFromFloat(x_1 - 0.5));
    }
    return @as(i64, @intFromFloat(x_1 + 0.5));
}

fn calculate_entropy(text_1: []const u8) void {
    const counts: TextCounts = analyze_text(text_1);
    const alphas: []const u8 = " abcdefghijklmnopqrstuvwxyz";
    var total1: i64 = 0;
    total1 = total1;
    var __mapit1 = counts.single.keyIterator();
    while (__mapit1.next()) |__it0| {
        const ch_1 = __it0.*;
        total1 = total1 +% counts.single.get(ch_1).?;
    }
    var h1: f64 = 0.0;
    h1 = h1;
    var i_2: i64 = 0;
    i_2 = i_2;
    while (i_2 < @as(i64, @intCast(alphas.len))) {
        const ch_2: []const u8 = alphas[@as(usize, @intCast(i_2))..@min(@as(usize, @intCast(i_2 +% 1)), @as(usize, @intCast(alphas.len)))];
        if (counts.single.contains(ch_2)) {
            const prob: f64 = @as(f64, @floatFromInt(counts.single.get(ch_2).?)) / @as(f64, @floatFromInt(total1));
            h1 = h1 + prob * log2(prob);
        }
        i_2 = i_2 +% 1;
    }
    const first_entropy: f64 = @as(f64, @floatFromInt(0)) - h1;
    std.debug.print("{s}\n", .{_concat_string(_str(round_to_int(first_entropy)), ".0")});
    var total2: i64 = 0;
    total2 = total2;
    var __mapit3 = counts.double.keyIterator();
    while (__mapit3.next()) |__it2| {
        const seq_1 = __it2.*;
        total2 = total2 +% counts.double.get(seq_1).?;
    }
    var h2: f64 = 0.0;
    h2 = h2;
    var a0: i64 = 0;
    a0 = a0;
    while (a0 < @as(i64, @intCast(alphas.len))) {
        const ch0: []const u8 = alphas[@as(usize, @intCast(a0))..@min(@as(usize, @intCast(a0 +% 1)), @as(usize, @intCast(alphas.len)))];
        var a1: i64 = 0;
        a1 = a1;
        while (a1 < @as(i64, @intCast(alphas.len))) {
            const ch1: []const u8 = alphas[@as(usize, @intCast(a1))..@min(@as(usize, @intCast(a1 +% 1)), @as(usize, @intCast(alphas.len)))];
            const seq_2: []const u8 = _concat_string(ch0, ch1);
            if (counts.double.contains(seq_2)) {
                const prob_1: f64 = @as(f64, @floatFromInt(counts.double.get(seq_2).?)) / @as(f64, @floatFromInt(total2));
                h2 = h2 + prob_1 * log2(prob_1);
            }
            a1 = a1 +% 1;
        }
        a0 = a0 +% 1;
    }
    const second_entropy: f64 = @as(f64, @floatFromInt(0)) - h2;
    std.debug.print("{s}\n", .{_concat_string(_str(round_to_int(second_entropy)), ".0")});
    const diff: f64 = second_entropy - first_entropy;
    std.debug.print("{s}\n", .{_concat_string(_str(round_to_int(diff)), ".0")});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        text1_var = _concat_string(_concat_string("Behind Winston's back the voice ", "from the telescreen was still "), "babbling and the overfulfilment");
        text3_var = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Had repulsive dashwoods suspicion sincerity but advantage now him. ", "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. "), "You greatest jointure saw horrible. He private he on be imagine "), "suppose. Fertile beloved evident through no service elderly is. Blind "), "there if every no so at. Own neglected you preferred way sincerity "), "delivered his attempted. To of message cottage windows do besides "), "against uncivil.  Delightful unreserved impossible few estimating "), "men favourable see entreaties. She propriety immediate was improving. "), "He or entrance humoured likewise moderate. Much nor game son say "), "feel. Fat make met can must form into gate. Me we offending prevailed "), "discovery.");
        calculate_entropy(text1_var);
        calculate_entropy(text3_var);
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .Pointer => |p| {
        if (p.size == .Slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    .Struct => |_| {
        if (@hasDecl(@TypeOf(v), "iterator")) {
            const KVPair = struct{ ks: []const u8, vs: []const u8 };
            var pairs = std.ArrayList(KVPair).init(std.heap.page_allocator);
            defer pairs.deinit();
            var it = v.iterator();
            while (it.next()) |e| {
                const ks = _str(e.key_ptr.*);
                const vs = _str(e.value_ptr.*);
                pairs.append(.{ .ks = ks, .vs = vs }) catch unreachable;
            }
            std.sort.heap(KVPair, pairs.items, {}, struct {
                pub fn less(_: void, a: KVPair, b: KVPair) bool {
                    return std.mem.lessThan(u8, a.ks, b.ks);
                }
            }.less);
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.appendSlice("map[") catch unreachable;
            for (pairs.items, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                out.appendSlice(e.ks) catch unreachable;
                out.append(':') catch unreachable;
                out.appendSlice(e.vs) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
