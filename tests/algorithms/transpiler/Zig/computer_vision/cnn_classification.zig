// Generated by Mochi Zig transpiler on 2025-08-07 14:57 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

var image_var: [][]f64 = &[_][]f64{};
var kernel_var: [][]f64 = &[_][]f64{};
var conv_var: [][]f64 = &[_][]f64{};
var activated_var: [][]f64 = &[_][]f64{};
var pooled_var: [][]f64 = &[_][]f64{};
var flat_var: []f64 = &[_]f64{};
var weights_var: []f64 = &[_]f64{};
const bias_var: f64 = 0.0;
var output_var: f64 = 0;
var probability_var: f64 = 0;

fn conv2d(image_param: [][]f64, kernel_param: [][]f64) [][]f64 {
    var rows: i64 = @as(i64, @intCast(image_param.len));
    rows = rows;
    var cols: i64 = @as(i64, @intCast(image_param[@as(usize, @intCast(0))].len));
    cols = cols;
    var k: i64 = @as(i64, @intCast(kernel_param.len));
    k = k;
    var output_var_1: [][]f64 = &[_][]f64{};
    output_var_1 = output_var_1;
    var i: i64 = 0;
    i = i;
    while (i <= rows - k) {
        var row: []f64 = &[_]f64{};
        row = row;
        var j: i64 = 0;
        j = j;
        while (j <= cols - k) {
            var sum: f64 = 0.0;
            sum = sum;
            var ki: i64 = 0;
            ki = ki;
            while (ki < k) {
                var kj: i64 = 0;
                kj = kj;
                while (kj < k) {
                    sum = sum + image_param[@as(usize, @intCast(i + ki))][@as(usize, @intCast(j + kj))] * kernel_param[@as(usize, @intCast(ki))][@as(usize, @intCast(kj))];
                    kj = kj + 1;
                }
                ki = ki + 1;
            }
            row = blk: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, row)) catch |err| handleError(err); _tmp.append(sum) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            j = j + 1;
        }
        output_var_1 = blk: { var _tmp = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []f64, output_var_1)) catch |err| handleError(err); _tmp.append(row) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    return output_var_1;
}

fn relu_matrix(m: [][]f64) [][]f64 {
    var out: [][]f64 = &[_][]f64{};
    out = out;
    for (m) |__it0| {
        const row = __it0;
        var new_row: []f64 = &[_]f64{};
        new_row = new_row;
        for (row) |__it1| {
            const v = __it1;
            if (v > 0.0) {
                new_row = blk: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, new_row)) catch |err| handleError(err); _tmp.append(v) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            } else {
                new_row = blk: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, new_row)) catch |err| handleError(err); _tmp.append(0.0) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            }
        }
        out = blk: { var _tmp = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []f64, out)) catch |err| handleError(err); _tmp.append(new_row) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
    }
    return out;
}

fn max_pool2x2(m: [][]f64) [][]f64 {
    var rows: i64 = @as(i64, @intCast(m.len));
    rows = rows;
    var cols: i64 = @as(i64, @intCast(m[@as(usize, @intCast(0))].len));
    cols = cols;
    var out: [][]f64 = &[_][]f64{};
    out = out;
    var i: i64 = 0;
    i = i;
    while (i < rows) {
        var new_row: []f64 = &[_]f64{};
        new_row = new_row;
        var j: i64 = 0;
        j = j;
        while (j < cols) {
            var max_val: f64 = m[@as(usize, @intCast(i))][@as(usize, @intCast(j))];
            max_val = max_val;
            if (m[@as(usize, @intCast(i))][@as(usize, @intCast(j + 1))] > max_val) {
                max_val = m[@as(usize, @intCast(i))][@as(usize, @intCast(j + 1))];
            }
            if (m[@as(usize, @intCast(i + 1))][@as(usize, @intCast(j))] > max_val) {
                max_val = m[@as(usize, @intCast(i + 1))][@as(usize, @intCast(j))];
            }
            if (m[@as(usize, @intCast(i + 1))][@as(usize, @intCast(j + 1))] > max_val) {
                max_val = m[@as(usize, @intCast(i + 1))][@as(usize, @intCast(j + 1))];
            }
            new_row = blk: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, new_row)) catch |err| handleError(err); _tmp.append(max_val) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            j = j + 2;
        }
        out = blk: { var _tmp = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []f64, out)) catch |err| handleError(err); _tmp.append(new_row) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 2;
    }
    return out;
}

fn flatten(m: [][]f64) []f64 {
    var res: []f64 = &[_]f64{};
    res = res;
    for (m) |__it2| {
        const row = __it2;
        for (row) |__it3| {
            const v = __it3;
            res = blk: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, res)) catch |err| handleError(err); _tmp.append(v) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        }
    }
    return res;
}

fn dense(inputs: []f64, weights_param: []f64, bias_param: f64) f64 {
    var s: f64 = bias_param;
    s = s;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(inputs.len))) {
        s = s + inputs[@as(usize, @intCast(i))] * weights_param[@as(usize, @intCast(i))];
        i = i + 1;
    }
    return s;
}

fn exp_approx(x: f64) f64 {
    var sum: f64 = 1.0;
    sum = sum;
    var term: f64 = 1.0;
    term = term;
    var i: i64 = 1;
    i = i;
    while (i <= 10) {
        term = term * x / @as(f64, @floatFromInt(i));
        sum = sum + term;
        i = i + 1;
    }
    return sum;
}

fn sigmoid(x: f64) f64 {
    return 1.0 / (1.0 + exp_approx(@as(f64, @floatFromInt(0)) - x));
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        image_var = blk0: { var _tmp0 = std.heap.page_allocator.alloc([]f64, 6) catch unreachable; _tmp0[0] = blk1: { var _tmp1 = std.heap.page_allocator.alloc(f64, 6) catch unreachable; _tmp1[0] = 0.0; _tmp1[1] = 1.0; _tmp1[2] = 1.0; _tmp1[3] = 0.0; _tmp1[4] = 0.0; _tmp1[5] = 0.0; break :blk1 _tmp1; }; _tmp0[1] = blk2: { var _tmp2 = std.heap.page_allocator.alloc(f64, 6) catch unreachable; _tmp2[0] = 0.0; _tmp2[1] = 1.0; _tmp2[2] = 1.0; _tmp2[3] = 0.0; _tmp2[4] = 0.0; _tmp2[5] = 0.0; break :blk2 _tmp2; }; _tmp0[2] = blk3: { var _tmp3 = std.heap.page_allocator.alloc(f64, 6) catch unreachable; _tmp3[0] = 0.0; _tmp3[1] = 0.0; _tmp3[2] = 1.0; _tmp3[3] = 1.0; _tmp3[4] = 0.0; _tmp3[5] = 0.0; break :blk3 _tmp3; }; _tmp0[3] = blk4: { var _tmp4 = std.heap.page_allocator.alloc(f64, 6) catch unreachable; _tmp4[0] = 0.0; _tmp4[1] = 0.0; _tmp4[2] = 1.0; _tmp4[3] = 1.0; _tmp4[4] = 0.0; _tmp4[5] = 0.0; break :blk4 _tmp4; }; _tmp0[4] = blk5: { var _tmp5 = std.heap.page_allocator.alloc(f64, 6) catch unreachable; _tmp5[0] = 0.0; _tmp5[1] = 0.0; _tmp5[2] = 0.0; _tmp5[3] = 0.0; _tmp5[4] = 0.0; _tmp5[5] = 0.0; break :blk5 _tmp5; }; _tmp0[5] = blk6: { var _tmp6 = std.heap.page_allocator.alloc(f64, 6) catch unreachable; _tmp6[0] = 0.0; _tmp6[1] = 0.0; _tmp6[2] = 0.0; _tmp6[3] = 0.0; _tmp6[4] = 0.0; _tmp6[5] = 0.0; break :blk6 _tmp6; }; break :blk0 _tmp0; };
        kernel_var = blk7: { var _tmp7 = std.heap.page_allocator.alloc([]f64, 3) catch unreachable; _tmp7[0] = blk8: { var _tmp8 = std.heap.page_allocator.alloc(f64, 3) catch unreachable; _tmp8[0] = 1.0; _tmp8[1] = 0.0; _tmp8[2] = @as(f64, @floatFromInt(0)) - 1.0; break :blk8 _tmp8; }; _tmp7[1] = blk9: { var _tmp9 = std.heap.page_allocator.alloc(f64, 3) catch unreachable; _tmp9[0] = 1.0; _tmp9[1] = 0.0; _tmp9[2] = @as(f64, @floatFromInt(0)) - 1.0; break :blk9 _tmp9; }; _tmp7[2] = blk10: { var _tmp10 = std.heap.page_allocator.alloc(f64, 3) catch unreachable; _tmp10[0] = 1.0; _tmp10[1] = 0.0; _tmp10[2] = @as(f64, @floatFromInt(0)) - 1.0; break :blk10 _tmp10; }; break :blk7 _tmp7; };
        conv_var = conv2d(image_var, kernel_var);
        activated_var = relu_matrix(conv_var);
        pooled_var = max_pool2x2(activated_var);
        flat_var = flatten(pooled_var);
        weights_var = blk11: { var _tmp11 = std.heap.page_allocator.alloc(f64, 4) catch unreachable; _tmp11[0] = 0.5; _tmp11[1] = @as(f64, @floatFromInt(0)) - 0.4; _tmp11[2] = 0.3; _tmp11[3] = 0.1; break :blk11 _tmp11; };
        output_var = dense(flat_var, weights_var, bias_var);
        probability_var = sigmoid(output_var);
        if (probability_var >= 0.5) {
            std.debug.print("{s}\n", .{"Abnormality detected"});
        } else {
            std.debug.print("{s}\n", .{"Normal"});
        }
        std.debug.print("{s}\n", .{"Probability:"});
        std.debug.print("{d}\n", .{probability_var});
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * std.mem.page_size;
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
