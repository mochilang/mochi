// Generated by Mochi Zig transpiler on 2025-08-25 16:29 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const SegmentTree = struct {
    arr: []i64,
    op: i64,
};

const Node = struct {
    start: i64,
    end: i64,
    val: i64,
    mid: i64,
    left: i64,
    right: i64,
};

const BuildResult = struct {
    nodes: []Node,
    idx: i64,
};

const arr_var: []i64 = blk0: { var _tmp = [5]i64{2, 1, 5, 3, 4}; break :blk0 _tmp[0..]; };

fn combine(a: i64, b: i64, op: i64) i64 {
    if (op == 0) {
        return a +% b;
    }
    if (op == 1) {
        if (a > b) {
            return a;
        }
        return b;
    }
    if (a < b) {
        return a;
    }
    return b;
}

fn build_tree(nodes: []Node, arr_param: []i64, start: i64, end: i64, op_1: i64) BuildResult {
    if (start == end) {
        const node: Node = .{ .start = start, .end = end, .val = arr_param[_idx(arr_param.len, start)], .mid = start, .left = 0 -% 1, .right = 0 -% 1 };
        const new_nodes: []Node = blk1: { var _tmp_1 = std.ArrayList(Node).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_1.appendSlice(@as([]const Node, nodes)) catch |err| handleError(err); _tmp_1.append(node) catch |err| handleError(err); break :blk1 (_tmp_1.toOwnedSlice() catch |err| handleError(err)); };
        return .{ .nodes = new_nodes, .idx = @as(i64, @intCast(new_nodes.len)) -% 1 };
    }
    const mid: i64 = @divTrunc(start +% end, 2);
    const left_res: BuildResult = build_tree(nodes, arr_param, start, mid, op_1);
    const right_res: BuildResult = build_tree(left_res.nodes, arr_param, mid +% 1, end, op_1);
    const left_node: Node = right_res.nodes[_idx(right_res.nodes.len, left_res.idx)];
    const right_node: Node = right_res.nodes[_idx(right_res.nodes.len, right_res.idx)];
    const val: i64 = combine(left_node.val, right_node.val, op_1);
    const parent: Node = .{ .start = start, .end = end, .val = val, .mid = mid, .left = left_res.idx, .right = right_res.idx };
    const new_nodes_1: []Node = blk2: { var _tmp_2 = std.ArrayList(Node).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_2.appendSlice(@as([]const Node, right_res.nodes)) catch |err| handleError(err); _tmp_2.append(parent) catch |err| handleError(err); break :blk2 (_tmp_2.toOwnedSlice() catch |err| handleError(err)); };
    return .{ .nodes = new_nodes_1, .idx = @as(i64, @intCast(new_nodes_1.len)) -% 1 };
}

fn new_segment_tree(collection: []i64, op_2: i64) SegmentTree {
    return .{ .arr = collection, .op = op_2 };
}

fn update(tree: *const SegmentTree, i: i64, val_1: i64) SegmentTree {
    var new_arr: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    new_arr = new_arr;
    var idx: i64 = 0;
    idx = idx;
    while (idx < @as(i64, @intCast(tree.arr.len))) {
        if (idx == i) {
            new_arr = blk3: { var _tmp_3 = std.ArrayList(i64).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_3.appendSlice(@as([]const i64, new_arr)) catch |err| handleError(err); _tmp_3.append(val_1) catch |err| handleError(err); break :blk3 (_tmp_3.toOwnedSlice() catch |err| handleError(err)); };
        } else {
            new_arr = blk4: { var _tmp_4 = std.ArrayList(i64).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_4.appendSlice(@as([]const i64, new_arr)) catch |err| handleError(err); _tmp_4.append(tree.arr[_idx(tree.arr.len, idx)]) catch |err| handleError(err); break :blk4 (_tmp_4.toOwnedSlice() catch |err| handleError(err)); };
        }
        idx = idx +% 1;
    }
    return .{ .arr = new_arr, .op = tree.op };
}

fn query_range(tree_1: *const SegmentTree, i_1: i64, j: i64) i64 {
    var result: i64 = tree_1.arr[_idx(tree_1.arr.len, i_1)];
    result = result;
    var idx_1: i64 = i_1 +% 1;
    idx_1 = idx_1;
    while (idx_1 <= j) {
        result = combine(result, tree_1.arr[_idx(tree_1.arr.len, idx_1)], tree_1.op);
        idx_1 = idx_1 +% 1;
    }
    return result;
}

fn traverse(tree_2: *const SegmentTree) []Node {
    if (@as(i64, @intCast(tree_2.arr.len)) == 0) {
        return (&[_]Node{})[0..0];
    }
    const res: BuildResult = build_tree(@constCast((&[_]Node{})[0..0]), tree_2.arr, 0, @as(i64, @intCast(tree_2.arr.len)) -% 1, tree_2.op);
    return res.nodes;
}

fn node_to_string(node_1: *const Node) []const u8 {
    return _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("SegmentTreeNode(start=", _str(node_1.start)), ", end="), _str(node_1.end)), ", val="), _str(node_1.val)), ")");
}

fn print_traverse(tree_3: *const SegmentTree) void {
    const nodes_1: []Node = traverse(tree_3);
    var i_2: i64 = 0;
    i_2 = i_2;
    while (i_2 < @as(i64, @intCast(nodes_1.len))) {
        std.debug.print("{s}\n", .{node_to_string(&nodes_1[_idx(nodes_1.len, i_2)])});
        i_2 = i_2 +% 1;
    }
    std.debug.print("{s}\n", .{""});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        for (([3]i64{0, 1, 2})[0..3]) |__it0| {
            const op_3 = __it0;
            std.debug.print("{s}\n", .{"**************************************************"});
            var tree_4: SegmentTree = new_segment_tree(arr_var, op_3);
            tree_4 = tree_4;
            print_traverse(&tree_4);
            tree_4 = update(&tree_4, 1, 5);
            print_traverse(&tree_4);
            std.debug.print("{s}\n", .{_str(query_range(&tree_4, 3, 4))});
            std.debug.print("{s}\n", .{_str(query_range(&tree_4, 2, 2))});
            std.debug.print("{s}\n", .{_str(query_range(&tree_4, 1, 3))});
            std.debug.print("{s}\n", .{""});
        }
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .Pointer => |p| {
        if (p.size == .Slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    .Struct => |_| {
        if (@hasDecl(@TypeOf(v), "iterator")) {
            const KVPair = struct{ ks: []const u8, vs: []const u8 };
            var pairs = std.ArrayList(KVPair).init(std.heap.page_allocator);
            defer pairs.deinit();
            var it = v.iterator();
            while (it.next()) |e| {
                const ks = _str(e.key_ptr.*);
                const vs = _str(e.value_ptr.*);
                pairs.append(.{ .ks = ks, .vs = vs }) catch unreachable;
            }
            std.sort.heap(KVPair, pairs.items, {}, struct {
                pub fn less(_: void, a: KVPair, b: KVPair) bool {
                    return std.mem.lessThan(u8, a.ks, b.ks);
                }
            }.less);
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.appendSlice("map[") catch unreachable;
            for (pairs.items, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                out.appendSlice(e.ks) catch unreachable;
                out.append(':') catch unreachable;
                out.appendSlice(e.vs) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
