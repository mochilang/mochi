// Generated by Mochi Zig transpiler on 2025-08-24 22:16 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const equation_var: []const u8 = "(5 + ((4 * 2) * (2 + 3)))";

fn is_digit(ch: []const u8) bool {
    return std.mem.eql(u8, ch, "0") or std.mem.eql(u8, ch, "1") or std.mem.eql(u8, ch, "2") or std.mem.eql(u8, ch, "3") or std.mem.eql(u8, ch, "4") or std.mem.eql(u8, ch, "5") or std.mem.eql(u8, ch, "6") or std.mem.eql(u8, ch, "7") or std.mem.eql(u8, ch, "8") or std.mem.eql(u8, ch, "9");
}

fn slice_without_last_int(xs: []i64) []i64 {
    var res: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    res = res;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(xs.len)) -% 1) {
        res = blk0: { var _tmp = std.ArrayList(i64).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp.appendSlice(@as([]const i64, res)) catch |err| handleError(err); _tmp.append(xs[_idx(xs.len, i)]) catch |err| handleError(err); break :blk0 (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i +% 1;
    }
    return res;
}

fn slice_without_last_string(xs_1: [][]const u8) [][]const u8 {
    var res_1: [][]const u8 = std.heap.page_allocator.alloc([]const u8, 0) catch unreachable;
    res_1 = res_1;
    var i_1: i64 = 0;
    i_1 = i_1;
    while (i_1 < @as(i64, @intCast(xs_1.len)) -% 1) {
        res_1 = blk1: { var _tmp_1 = std.ArrayList([]const u8).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_1.appendSlice(@as([]const []const u8, res_1)) catch |err| handleError(err); _tmp_1.append(@constCast(xs_1[_idx(xs_1.len, i_1)])) catch |err| handleError(err); break :blk1 (_tmp_1.toOwnedSlice() catch |err| handleError(err)); };
        i_1 = i_1 +% 1;
    }
    return res_1;
}

fn dijkstras_two_stack_algorithm(equation_param: []const u8) i64 {
    var operand_stack: []i64 = std.heap.page_allocator.alloc(i64, 0) catch unreachable;
    operand_stack = operand_stack;
    var operator_stack: [][]const u8 = std.heap.page_allocator.alloc([]const u8, 0) catch unreachable;
    operator_stack = operator_stack;
    var idx: i64 = 0;
    idx = idx;
    while (idx < @as(i64, @intCast(equation_param.len))) {
        const ch_1: []const u8 = equation_param[@as(usize, @intCast(idx))..@min(@as(usize, @intCast(idx +% 1)), @as(usize, @intCast(equation_param.len)))];
        if (is_digit(ch_1)) {
            operand_stack = blk2: { var _tmp_2 = std.ArrayList(i64).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_2.appendSlice(@as([]const i64, operand_stack)) catch |err| handleError(err); _tmp_2.append((std.fmt.parseInt(i64, ch_1, 10) catch 0)) catch |err| handleError(err); break :blk2 (_tmp_2.toOwnedSlice() catch |err| handleError(err)); };
        } else {
            if (std.mem.eql(u8, ch_1, "+") or std.mem.eql(u8, ch_1, "-") or std.mem.eql(u8, ch_1, "*") or std.mem.eql(u8, ch_1, "/")) {
                operator_stack = blk3: { var _tmp_3 = std.ArrayList([]const u8).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_3.appendSlice(@as([]const []const u8, operator_stack)) catch |err| handleError(err); _tmp_3.append(@constCast(ch_1)) catch |err| handleError(err); break :blk3 (_tmp_3.toOwnedSlice() catch |err| handleError(err)); };
            } else {
                if (std.mem.eql(u8, ch_1, ")")) {
                    const opr: []const u8 = operator_stack[_idx(operator_stack.len, @as(i64, @intCast(operator_stack.len)) -% 1)];
                    operator_stack = slice_without_last_string(operator_stack);
                    const num1: i64 = operand_stack[_idx(operand_stack.len, @as(i64, @intCast(operand_stack.len)) -% 1)];
                    operand_stack = slice_without_last_int(operand_stack);
                    const num2: i64 = operand_stack[_idx(operand_stack.len, @as(i64, @intCast(operand_stack.len)) -% 1)];
                    operand_stack = slice_without_last_int(operand_stack);
                    const total: i64 = if (std.mem.eql(u8, opr, "+")) num2 +% num1 else if (std.mem.eql(u8, opr, "-")) num2 -% num1 else if (std.mem.eql(u8, opr, "*")) num2 *% num1 else @divTrunc(num2, num1);
                    operand_stack = blk4: { var _tmp_4 = std.ArrayList(i64).initCapacity(std.heap.page_allocator, 0) catch |err| handleError(err); _tmp_4.appendSlice(@as([]const i64, operand_stack)) catch |err| handleError(err); _tmp_4.append(total) catch |err| handleError(err); break :blk4 (_tmp_4.toOwnedSlice() catch |err| handleError(err)); };
                }
            }
        }
        idx = idx +% 1;
    }
    return operand_stack[_idx(operand_stack.len, @as(i64, @intCast(operand_stack.len)) -% 1)];
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        std.debug.print("{s}\n", .{_concat_string(_concat_string(equation_var, " = "), _str(dijkstras_two_stack_algorithm(equation_var)))});
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    const info = @typeInfo(@TypeOf(v));
    switch (info) {
    .Pointer => |p| {
        if (p.size == .Slice) {
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.append('[') catch unreachable;
            for (v, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                const s = _str(e);
                out.appendSlice(s) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    .Struct => |_| {
        if (@hasDecl(@TypeOf(v), "iterator")) {
            const KVPair = struct{ ks: []const u8, vs: []const u8 };
            var pairs = std.ArrayList(KVPair).init(std.heap.page_allocator);
            defer pairs.deinit();
            var it = v.iterator();
            while (it.next()) |e| {
                const ks = _str(e.key_ptr.*);
                const vs = _str(e.value_ptr.*);
                pairs.append(.{ .ks = ks, .vs = vs }) catch unreachable;
            }
            std.sort.heap(KVPair, pairs.items, {}, struct {
                pub fn less(_: void, a: KVPair, b: KVPair) bool {
                    return std.mem.lessThan(u8, a.ks, b.ks);
                }
            }.less);
            var out = std.ArrayList(u8).init(std.heap.page_allocator);
            defer out.deinit();
            out.appendSlice("map[") catch unreachable;
            for (pairs.items, 0..) |e, i| {
                if (i != 0) { out.append(' ') catch unreachable; }
                out.appendSlice(e.ks) catch unreachable;
                out.append(':') catch unreachable;
                out.appendSlice(e.vs) catch unreachable;
            }
            out.append(']') catch unreachable;
            return out.toOwnedSlice() catch unreachable;
        }
    },
    else => {},
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
