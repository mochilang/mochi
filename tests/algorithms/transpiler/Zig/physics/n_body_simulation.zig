// Generated by Mochi Zig transpiler on 2025-08-19 09:22 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Body = struct {
    position_x: f64,
    position_y: f64,
    velocity_x: f64,
    velocity_y: f64,
    mass: f64,
};

const BodySystem = struct {
    bodies: []Body,
    gravitation_constant: f64,
    time_factor: f64,
    softening_factor: f64,
};

fn make_body(px: f64, py: f64, vx: f64, vy: f64, mass: f64) Body {
    return .{ .position_x = px, .position_y = py, .velocity_x = vx, .velocity_y = vy, .mass = mass };
}

fn update_velocity(body_param: *Body, force_x: f64, force_y: f64, delta_time: f64) Body {
    body_param.velocity_x = body_param.velocity_x + force_x * delta_time;
    body_param.velocity_y = body_param.velocity_y + force_y * delta_time;
    return body_param.*;
}

fn update_position(body_param_1: *Body, delta_time_1: f64) Body {
    body_param_1.position_x = body_param_1.position_x + body_param_1.velocity_x * delta_time_1;
    body_param_1.position_y = body_param_1.position_y + body_param_1.velocity_y * delta_time_1;
    return body_param_1.*;
}

fn make_body_system(bodies: []Body, g: f64, tf: f64, sf: f64) BodySystem {
    return .{ .bodies = bodies, .gravitation_constant = g, .time_factor = tf, .softening_factor = sf };
}

fn sqrtApprox(x: f64) f64 {
    var guess: f64 = x / 2.0;
    guess = guess;
    var i: i64 = 0;
    i = i;
    while (i < 20) {
        guess = (guess + x / guess) / 2.0;
        i = i +% 1;
    }
    return guess;
}

fn update_system(system_param: *BodySystem, delta_time_2: f64) BodySystem {
    var bodies_1: []Body = system_param.bodies;
    bodies_1 = bodies_1;
    var i_1: i64 = 0;
    i_1 = i_1;
    while (i_1 < @as(i64, @intCast(bodies_1.len))) {
        var body1: Body = bodies_1[_idx(bodies_1.len, i_1)];
        body1 = body1;
        var force_x_1: f64 = 0.0;
        force_x_1 = force_x_1;
        var force_y_1: f64 = 0.0;
        force_y_1 = force_y_1;
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(bodies_1.len))) {
            if (i_1 != j) {
                const body2: Body = bodies_1[_idx(bodies_1.len, j)];
                const dif_x: f64 = body2.position_x - body1.position_x;
                const dif_y: f64 = body2.position_y - body1.position_y;
                const distance_sq: f64 = dif_x * dif_x + dif_y * dif_y + system_param.softening_factor;
                const distance: f64 = sqrtApprox(distance_sq);
                const denom: f64 = distance * distance * distance;
                force_x_1 = force_x_1 + system_param.gravitation_constant * body2.mass * dif_x / denom;
                force_y_1 = force_y_1 + system_param.gravitation_constant * body2.mass * dif_y / denom;
            }
            j = j +% 1;
        }
        body1 = update_velocity(&body1, force_x_1, force_y_1, delta_time_2 * system_param.time_factor);
        bodies_1[_idx(bodies_1.len, i_1)] = body1;
        i_1 = i_1 +% 1;
    }
    i_1 = 0;
    while (i_1 < @as(i64, @intCast(bodies_1.len))) {
        var body: Body = bodies_1[_idx(bodies_1.len, i_1)];
        body = body;
        body = update_position(&body, delta_time_2 * system_param.time_factor);
        bodies_1[_idx(bodies_1.len, i_1)] = body;
        i_1 = i_1 +% 1;
    }
    system_param.bodies = bodies_1;
    return system_param.*;
}

fn mochi_main() void {
    const b1: Body = make_body(0.0, 0.0, 0.0, 0.0, 1.0);
    const b2: Body = make_body(10.0, 0.0, 0.0, 0.0, 1.0);
    var sys1: BodySystem = make_body_system(@constCast(blk0: { var _tmp = std.ArrayList(Body).init(std.heap.page_allocator); _tmp.append(b1) catch unreachable; _tmp.append(b2) catch unreachable; break :blk0 (_tmp.toOwnedSlice() catch unreachable); }), 1.0, 1.0, 0.0);
    sys1 = sys1;
    sys1 = update_system(&sys1, 1.0);
    _ = sys1.bodies[_idx(sys1.bodies.len, 0)];
    const __m = blk1: { var m = std.StringHashMap(f64).init(std.heap.page_allocator); m.put("x", b1_after.position_x) catch unreachable; m.put("y", b1_after.position_y) catch unreachable; break :blk1 m; };
    std.debug.print("{{", .{});
    var __it = __m.iterator();
    var __first = true;
    while (__it.next()) |entry| {
        if (!__first) std.debug.print(",", .{});
        __first = false;
        const __val = std.json.stringifyAlloc(std.heap.page_allocator, entry.value_ptr.*, .{}) catch unreachable;
        std.debug.print("\"{s}\":{s}", .{entry.key_ptr.*, __val});
        std.heap.page_allocator.free(__val);
    }
    std.debug.print("}}\n", .{});
    const __m_1 = blk2: { var m_1 = std.StringHashMap(f64).init(std.heap.page_allocator); m_1.put("vx", b1_after.velocity_x) catch unreachable; m_1.put("vy", b1_after.velocity_y) catch unreachable; break :blk2 m_1; };
    std.debug.print("{{", .{});
    var __it_1 = __m_1.iterator();
    var __first_1 = true;
    while (__it_1.next()) |entry| {
        if (!__first_1) std.debug.print(",", .{});
        __first_1 = false;
        const __val = std.json.stringifyAlloc(std.heap.page_allocator, entry.value_ptr.*, .{}) catch unreachable;
        std.debug.print("\"{s}\":{s}", .{entry.key_ptr.*, __val});
        std.heap.page_allocator.free(__val);
    }
    std.debug.print("}}\n", .{});
    const b3: Body = make_body(@as(f64, @floatFromInt(0)) - 10.0, 0.0, 0.0, 0.0, 1.0);
    const b4: Body = make_body(10.0, 0.0, 0.0, 0.0, 4.0);
    var sys2: BodySystem = make_body_system(@constCast(blk3: { var _tmp_1 = std.ArrayList(Body).init(std.heap.page_allocator); _tmp_1.append(b3) catch unreachable; _tmp_1.append(b4) catch unreachable; break :blk3 (_tmp_1.toOwnedSlice() catch unreachable); }), 1.0, 10.0, 0.0);
    sys2 = sys2;
    sys2 = update_system(&sys2, 1.0);
    _ = sys2.bodies[_idx(sys2.bodies.len, 0)];
    const __m_2 = blk4: { var m_2 = std.StringHashMap(f64).init(std.heap.page_allocator); m_2.put("x", b2_after.position_x) catch unreachable; m_2.put("y", b2_after.position_y) catch unreachable; break :blk4 m_2; };
    std.debug.print("{{", .{});
    var __it_2 = __m_2.iterator();
    var __first_2 = true;
    while (__it_2.next()) |entry| {
        if (!__first_2) std.debug.print(",", .{});
        __first_2 = false;
        const __val = std.json.stringifyAlloc(std.heap.page_allocator, entry.value_ptr.*, .{}) catch unreachable;
        std.debug.print("\"{s}\":{s}", .{entry.key_ptr.*, __val});
        std.heap.page_allocator.free(__val);
    }
    std.debug.print("}}\n", .{});
    const __m_3 = blk5: { var m_3 = std.StringHashMap(f64).init(std.heap.page_allocator); m_3.put("vx", b2_after.velocity_x) catch unreachable; m_3.put("vy", b2_after.velocity_y) catch unreachable; break :blk5 m_3; };
    std.debug.print("{{", .{});
    var __it_3 = __m_3.iterator();
    var __first_3 = true;
    while (__it_3.next()) |entry| {
        if (!__first_3) std.debug.print(",", .{});
        __first_3 = false;
        const __val = std.json.stringifyAlloc(std.heap.page_allocator, entry.value_ptr.*, .{}) catch unreachable;
        std.debug.print("\"{s}\":{s}", .{entry.key_ptr.*, __val});
        std.heap.page_allocator.free(__val);
    }
    std.debug.print("}}\n", .{});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        mochi_main();
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}
