// Generated by Mochi Zig transpiler on 2025-08-22 13:08 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Layer = struct {
    units: i64,
    weight: [][]f64,
    bias: []f64,
    output: []f64,
    xdata: []f64,
    learn_rate: f64,
};

const Data = struct {
    x: [][]f64,
    y: [][]f64,
};

var seed_var_1: i64 = 1;

fn rand() i64 {
    seed_var_1 = @mod(seed_var_1 *% 1103515245 +% 12345, 2147483648);
    return seed_var_1;
}

fn random() f64 {
    return 1.0 * @as(f64, @floatFromInt(rand())) / 2147483648.0;
}

fn expApprox(x: f64) f64 {
    var y: f64 = x;
    y = y;
    var is_neg: bool = false;
    is_neg = is_neg;
    if (x < 0.0) {
        is_neg = true;
        y = @as(f64, @floatFromInt(0)) - x;
    }
    var term: f64 = 1.0;
    term = term;
    var sum: f64 = 1.0;
    sum = sum;
    var n: i64 = 1;
    n = n;
    while (n < 30) {
        term = term * y / @as(f64, @floatFromInt(n));
        sum = sum + term;
        n = n +% 1;
    }
    if (is_neg) {
        return 1.0 / sum;
    }
    return sum;
}

fn sigmoid(z: f64) f64 {
    return 1.0 / (1.0 + expApprox(@as(f64, @floatFromInt(0)) - z));
}

fn sigmoid_vec(v: []f64) []f64 {
    var res: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res = res;
    var i: i64 = 0;
    i = i;
    while (i < @as(i64, @intCast(v.len))) {
        res = blk0: { var _tmp = std.ArrayList(f64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const f64, res)) catch |err| handleError(err); _tmp.append(sigmoid(v[_idx(v.len, i)])) catch |err| handleError(err); break :blk0 (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i +% 1;
    }
    return res;
}

fn sigmoid_derivative(out: []f64) []f64 {
    var res_1: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res_1 = res_1;
    var i_1: i64 = 0;
    i_1 = i_1;
    while (i_1 < @as(i64, @intCast(out.len))) {
        const val: f64 = out[_idx(out.len, i_1)];
        res_1 = blk1: { var _tmp_1 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_1.appendSlice(@as([]const f64, res_1)) catch |err| handleError(err); _tmp_1.append(val * (1.0 - val)) catch |err| handleError(err); break :blk1 (_tmp_1.toOwnedSlice() catch |err| handleError(err)); };
        i_1 = i_1 +% 1;
    }
    return res_1;
}

fn random_vector(n_1: i64) []f64 {
    var v_1: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    v_1 = v_1;
    var i_2: i64 = 0;
    i_2 = i_2;
    while (i_2 < n_1) {
        v_1 = blk2: { var _tmp_2 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_2.appendSlice(@as([]const f64, v_1)) catch |err| handleError(err); _tmp_2.append(random() - 0.5) catch |err| handleError(err); break :blk2 (_tmp_2.toOwnedSlice() catch |err| handleError(err)); };
        i_2 = i_2 +% 1;
    }
    return v_1;
}

fn random_matrix(r: i64, c: i64) [][]f64 {
    var m: [][]f64 = std.heap.page_allocator.alloc([]f64, 0) catch unreachable;
    m = m;
    var i_3: i64 = 0;
    i_3 = i_3;
    while (i_3 < r) {
        m = blk3: { var _tmp_3 = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp_3.appendSlice(@as([]const []f64, m)) catch |err| handleError(err); _tmp_3.append(random_vector(c)) catch |err| handleError(err); break :blk3 (_tmp_3.toOwnedSlice() catch |err| handleError(err)); };
        i_3 = i_3 +% 1;
    }
    return m;
}

fn matvec(mat: [][]f64, vec: []f64) []f64 {
    var res_2: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res_2 = res_2;
    var i_4: i64 = 0;
    i_4 = i_4;
    while (i_4 < @as(i64, @intCast(mat.len))) {
        var s: f64 = 0.0;
        s = s;
        var j: i64 = 0;
        j = j;
        while (j < @as(i64, @intCast(vec.len))) {
            s = s + mat[_idx(mat.len, i_4)][_idx(mat[_idx(mat.len, i_4)].len, j)] * vec[_idx(vec.len, j)];
            j = j +% 1;
        }
        res_2 = blk4: { var _tmp_4 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_4.appendSlice(@as([]const f64, res_2)) catch |err| handleError(err); _tmp_4.append(s) catch |err| handleError(err); break :blk4 (_tmp_4.toOwnedSlice() catch |err| handleError(err)); };
        i_4 = i_4 +% 1;
    }
    return res_2;
}

fn matTvec(mat_1: [][]f64, vec_1: []f64) []f64 {
    const cols: i64 = @as(i64, @intCast(mat_1[_idx(mat_1.len, 0)].len));
    var res_3: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res_3 = res_3;
    var j_1: i64 = 0;
    j_1 = j_1;
    while (j_1 < cols) {
        var s_1: f64 = 0.0;
        s_1 = s_1;
        var i_5: i64 = 0;
        i_5 = i_5;
        while (i_5 < @as(i64, @intCast(mat_1.len))) {
            s_1 = s_1 + mat_1[_idx(mat_1.len, i_5)][_idx(mat_1[_idx(mat_1.len, i_5)].len, j_1)] * vec_1[_idx(vec_1.len, i_5)];
            i_5 = i_5 +% 1;
        }
        res_3 = blk5: { var _tmp_5 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_5.appendSlice(@as([]const f64, res_3)) catch |err| handleError(err); _tmp_5.append(s_1) catch |err| handleError(err); break :blk5 (_tmp_5.toOwnedSlice() catch |err| handleError(err)); };
        j_1 = j_1 +% 1;
    }
    return res_3;
}

fn vec_sub(a: []f64, b: []f64) []f64 {
    var res_4: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res_4 = res_4;
    var i_6: i64 = 0;
    i_6 = i_6;
    while (i_6 < @as(i64, @intCast(a.len))) {
        res_4 = blk6: { var _tmp_6 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_6.appendSlice(@as([]const f64, res_4)) catch |err| handleError(err); _tmp_6.append(a[_idx(a.len, i_6)] - b[_idx(b.len, i_6)]) catch |err| handleError(err); break :blk6 (_tmp_6.toOwnedSlice() catch |err| handleError(err)); };
        i_6 = i_6 +% 1;
    }
    return res_4;
}

fn vec_mul(a_1: []f64, b_1: []f64) []f64 {
    var res_5: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res_5 = res_5;
    var i_7: i64 = 0;
    i_7 = i_7;
    while (i_7 < @as(i64, @intCast(a_1.len))) {
        res_5 = blk7: { var _tmp_7 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_7.appendSlice(@as([]const f64, res_5)) catch |err| handleError(err); _tmp_7.append(a_1[_idx(a_1.len, i_7)] * b_1[_idx(b_1.len, i_7)]) catch |err| handleError(err); break :blk7 (_tmp_7.toOwnedSlice() catch |err| handleError(err)); };
        i_7 = i_7 +% 1;
    }
    return res_5;
}

fn vec_scalar_mul(v_2: []f64, s_2: f64) []f64 {
    var res_6: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    res_6 = res_6;
    var i_8: i64 = 0;
    i_8 = i_8;
    while (i_8 < @as(i64, @intCast(v_2.len))) {
        res_6 = blk8: { var _tmp_8 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_8.appendSlice(@as([]const f64, res_6)) catch |err| handleError(err); _tmp_8.append(v_2[_idx(v_2.len, i_8)] * s_2) catch |err| handleError(err); break :blk8 (_tmp_8.toOwnedSlice() catch |err| handleError(err)); };
        i_8 = i_8 +% 1;
    }
    return res_6;
}

fn outer(a_2: []f64, b_2: []f64) [][]f64 {
    var res_7: [][]f64 = std.heap.page_allocator.alloc([]f64, 0) catch unreachable;
    res_7 = res_7;
    var i_9: i64 = 0;
    i_9 = i_9;
    while (i_9 < @as(i64, @intCast(a_2.len))) {
        var row: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
        row = row;
        var j_2: i64 = 0;
        j_2 = j_2;
        while (j_2 < @as(i64, @intCast(b_2.len))) {
            row = blk9: { var _tmp_9 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_9.appendSlice(@as([]const f64, row)) catch |err| handleError(err); _tmp_9.append(a_2[_idx(a_2.len, i_9)] * b_2[_idx(b_2.len, j_2)]) catch |err| handleError(err); break :blk9 (_tmp_9.toOwnedSlice() catch |err| handleError(err)); };
            j_2 = j_2 +% 1;
        }
        res_7 = blk10: { var _tmp_10 = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp_10.appendSlice(@as([]const []f64, res_7)) catch |err| handleError(err); _tmp_10.append(row) catch |err| handleError(err); break :blk10 (_tmp_10.toOwnedSlice() catch |err| handleError(err)); };
        i_9 = i_9 +% 1;
    }
    return res_7;
}

fn mat_scalar_mul(mat_2: [][]f64, s_3: f64) [][]f64 {
    var res_8: [][]f64 = std.heap.page_allocator.alloc([]f64, 0) catch unreachable;
    res_8 = res_8;
    var i_10: i64 = 0;
    i_10 = i_10;
    while (i_10 < @as(i64, @intCast(mat_2.len))) {
        var row_1: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
        row_1 = row_1;
        var j_3: i64 = 0;
        j_3 = j_3;
        while (j_3 < @as(i64, @intCast(mat_2[_idx(mat_2.len, i_10)].len))) {
            row_1 = blk11: { var _tmp_11 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_11.appendSlice(@as([]const f64, row_1)) catch |err| handleError(err); _tmp_11.append(mat_2[_idx(mat_2.len, i_10)][_idx(mat_2[_idx(mat_2.len, i_10)].len, j_3)] * s_3) catch |err| handleError(err); break :blk11 (_tmp_11.toOwnedSlice() catch |err| handleError(err)); };
            j_3 = j_3 +% 1;
        }
        res_8 = blk12: { var _tmp_12 = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp_12.appendSlice(@as([]const []f64, res_8)) catch |err| handleError(err); _tmp_12.append(row_1) catch |err| handleError(err); break :blk12 (_tmp_12.toOwnedSlice() catch |err| handleError(err)); };
        i_10 = i_10 +% 1;
    }
    return res_8;
}

fn mat_sub(a_3: [][]f64, b_3: [][]f64) [][]f64 {
    var res_9: [][]f64 = std.heap.page_allocator.alloc([]f64, 0) catch unreachable;
    res_9 = res_9;
    var i_11: i64 = 0;
    i_11 = i_11;
    while (i_11 < @as(i64, @intCast(a_3.len))) {
        var row_2: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
        row_2 = row_2;
        var j_4: i64 = 0;
        j_4 = j_4;
        while (j_4 < @as(i64, @intCast(a_3[_idx(a_3.len, i_11)].len))) {
            row_2 = blk13: { var _tmp_13 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_13.appendSlice(@as([]const f64, row_2)) catch |err| handleError(err); _tmp_13.append(a_3[_idx(a_3.len, i_11)][_idx(a_3[_idx(a_3.len, i_11)].len, j_4)] - b_3[_idx(b_3.len, i_11)][_idx(b_3[_idx(b_3.len, i_11)].len, j_4)]) catch |err| handleError(err); break :blk13 (_tmp_13.toOwnedSlice() catch |err| handleError(err)); };
            j_4 = j_4 +% 1;
        }
        res_9 = blk14: { var _tmp_14 = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp_14.appendSlice(@as([]const []f64, res_9)) catch |err| handleError(err); _tmp_14.append(row_2) catch |err| handleError(err); break :blk14 (_tmp_14.toOwnedSlice() catch |err| handleError(err)); };
        i_11 = i_11 +% 1;
    }
    return res_9;
}

fn init_layer(units: i64, back_units: i64, lr: f64) Layer {
    return .{ .units = units, .weight = random_matrix(units, back_units), .bias = random_vector(units), .output = (&[_]f64{})[0..0], .xdata = (&[_]f64{})[0..0], .learn_rate = lr };
}

fn forward(layers_param: []Layer, x_1: []f64) []Layer {
    var layers_var: []Layer = layers_param;
    layers_var = layers_var;
    var data: []f64 = blk15: { const tmp = std.heap.page_allocator.alloc(f64, x_1.len) catch unreachable; @memcpy(tmp, x_1); break :blk15 tmp; };
    data = data;
    var i_12: i64 = 0;
    i_12 = i_12;
    while (i_12 < @as(i64, @intCast(layers_var.len))) {
        var layer: Layer = layers_var[_idx(layers_var.len, i_12)];
        layer = layer;
        layer.xdata = data;
        if (i_12 == 0) {
            layer.output = data;
        } else {
            const z_1: []f64 = vec_sub(matvec(layer.weight, data), layer.bias);
            layer.output = sigmoid_vec(z_1);
            data = layer.output;
        }
        layers_var[_idx(layers_var.len, i_12)] = layer;
        i_12 = i_12 +% 1;
    }
    return layers_var;
}

fn backward(layers_param_1: []Layer, grad: []f64) []Layer {
    const layers_var_1: []Layer = layers_param_1;
    var g: []f64 = blk16: { const tmp = std.heap.page_allocator.alloc(f64, grad.len) catch unreachable; @memcpy(tmp, grad); break :blk16 tmp; };
    g = g;
    var i_13: i64 = @as(i64, @intCast(layers_var_1.len)) -% 1;
    i_13 = i_13;
    while (i_13 > 0) {
        var layer_1: Layer = layers_var_1[_idx(layers_var_1.len, i_13)];
        layer_1 = layer_1;
        const deriv: []f64 = sigmoid_derivative(layer_1.output);
        const delta: []f64 = vec_mul(g, deriv);
        const grad_w: [][]f64 = outer(delta, layer_1.xdata);
        layer_1.weight = mat_sub(layer_1.weight, mat_scalar_mul(grad_w, layer_1.learn_rate));
        layer_1.bias = vec_sub(layer_1.bias, vec_scalar_mul(delta, layer_1.learn_rate));
        g = matTvec(layer_1.weight, delta);
        layers_var_1[_idx(layers_var_1.len, i_13)] = layer_1;
        i_13 = i_13 -% 1;
    }
    return layers_var_1;
}

fn calc_loss(y_1: []f64, yhat: []f64) f64 {
    var s_4: f64 = 0.0;
    s_4 = s_4;
    var i_14: i64 = 0;
    i_14 = i_14;
    while (i_14 < @as(i64, @intCast(y_1.len))) {
        const d: f64 = y_1[_idx(y_1.len, i_14)] - yhat[_idx(yhat.len, i_14)];
        s_4 = s_4 + d * d;
        i_14 = i_14 +% 1;
    }
    return s_4;
}

fn calc_gradient(y_2: []f64, yhat_1: []f64) []f64 {
    var g_1: []f64 = std.heap.page_allocator.alloc(f64, 0) catch unreachable;
    g_1 = g_1;
    var i_15: i64 = 0;
    i_15 = i_15;
    while (i_15 < @as(i64, @intCast(y_2.len))) {
        g_1 = blk17: { var _tmp_15 = std.ArrayList(f64).init(std.heap.page_allocator); _tmp_15.appendSlice(@as([]const f64, g_1)) catch |err| handleError(err); _tmp_15.append(2.0 * (yhat_1[_idx(yhat_1.len, i_15)] - y_2[_idx(y_2.len, i_15)])) catch |err| handleError(err); break :blk17 (_tmp_15.toOwnedSlice() catch |err| handleError(err)); };
        i_15 = i_15 +% 1;
    }
    return g_1;
}

fn train(layers_param_2: []Layer, xdata: [][]f64, ydata: [][]f64, rounds: i64, _: f64) f64 {
    var layers_var_2: []Layer = layers_param_2;
    layers_var_2 = layers_var_2;
    var r_1: i64 = 0;
    r_1 = r_1;
    while (r_1 < rounds) {
        var i_16: i64 = 0;
        i_16 = i_16;
        while (i_16 < @as(i64, @intCast(xdata.len))) {
            layers_var_2 = forward(layers_var_2, xdata[_idx(xdata.len, i_16)]);
            const out_1: []f64 = layers_var_2[_idx(layers_var_2.len, @as(i64, @intCast(layers_var_2.len)) -% 1)].output;
            const grad_1: []f64 = calc_gradient(ydata[_idx(ydata.len, i_16)], out_1);
            layers_var_2 = backward(layers_var_2, grad_1);
            i_16 = i_16 +% 1;
        }
        r_1 = r_1 +% 1;
    }
    return 0.0;
}

fn create_data() Data {
    var x_2: [][]f64 = std.heap.page_allocator.alloc([]f64, 0) catch unreachable;
    x_2 = x_2;
    var i_17: i64 = 0;
    i_17 = i_17;
    while (i_17 < 10) {
        x_2 = blk18: { var _tmp_16 = std.ArrayList([]f64).init(std.heap.page_allocator); _tmp_16.appendSlice(@as([]const []f64, x_2)) catch |err| handleError(err); _tmp_16.append(random_vector(10)) catch |err| handleError(err); break :blk18 (_tmp_16.toOwnedSlice() catch |err| handleError(err)); };
        i_17 = i_17 +% 1;
    }
    const y_3: [][]f64 = @constCast(([10][]f64{@constCast(([2]f64{0.800000000000000044, 0.400000000000000022})[0..2]), @constCast(([2]f64{0.400000000000000022, 0.299999999999999989})[0..2]), @constCast(([2]f64{0.340000000000000024, 0.450000000000000011})[0..2]), @constCast(([2]f64{0.67000000000000004, 0.320000000000000007})[0..2]), @constCast(([2]f64{0.880000000000000004, 0.67000000000000004})[0..2]), @constCast(([2]f64{0.780000000000000027, 0.770000000000000018})[0..2]), @constCast(([2]f64{0.550000000000000044, 0.660000000000000031})[0..2]), @constCast(([2]f64{0.550000000000000044, 0.429999999999999993})[0..2]), @constCast(([2]f64{0.540000000000000036, 0.100000000000000006})[0..2]), @constCast(([2]f64{0.100000000000000006, 0.5})[0..2])})[0..10]);
    return .{ .x = x_2, .y = y_3 };
}

fn mochi_main() void {
    const data_1: Data = create_data();
    var layers: []Layer = std.heap.page_allocator.alloc(Layer, 0) catch unreachable;
    layers = layers;
    layers = blk19: { var _tmp_17 = std.ArrayList(Layer).init(std.heap.page_allocator); _tmp_17.appendSlice(@as([]const Layer, layers)) catch |err| handleError(err); _tmp_17.append(init_layer(10, 0, 0.299999999999999989)) catch |err| handleError(err); break :blk19 (_tmp_17.toOwnedSlice() catch |err| handleError(err)); };
    layers = blk20: { var _tmp_18 = std.ArrayList(Layer).init(std.heap.page_allocator); _tmp_18.appendSlice(@as([]const Layer, layers)) catch |err| handleError(err); _tmp_18.append(init_layer(20, 10, 0.299999999999999989)) catch |err| handleError(err); break :blk20 (_tmp_18.toOwnedSlice() catch |err| handleError(err)); };
    layers = blk21: { var _tmp_19 = std.ArrayList(Layer).init(std.heap.page_allocator); _tmp_19.appendSlice(@as([]const Layer, layers)) catch |err| handleError(err); _tmp_19.append(init_layer(30, 20, 0.299999999999999989)) catch |err| handleError(err); break :blk21 (_tmp_19.toOwnedSlice() catch |err| handleError(err)); };
    layers = blk22: { var _tmp_20 = std.ArrayList(Layer).init(std.heap.page_allocator); _tmp_20.appendSlice(@as([]const Layer, layers)) catch |err| handleError(err); _tmp_20.append(init_layer(2, 30, 0.299999999999999989)) catch |err| handleError(err); break :blk22 (_tmp_20.toOwnedSlice() catch |err| handleError(err)); };
    const final_mse: f64 = train(layers, data_1.x, data_1.y, 100, 0.0100000000000000002);
    std.debug.print("{d}\n", .{final_mse});
}

pub fn main() void {
    {
        const __start = _now();
        const __start_mem: i64 = _mem();
        mochi_main();
        const __end = _now();
        const __end_mem: i64 = _mem();
        const __duration_us: i64 = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __mem_diff: i64 = __end_mem - __start_mem;
        const __memory_bytes: i64 = if (__mem_diff < 0) -__mem_diff else __mem_diff;
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _idx(len: usize, i: i64) usize {
    return if (i < 0 or i >= @as(i64, @intCast(len))) 0 else @as(usize, @intCast(i));
}

fn _mem() i64 {
    const path = "/proc/self/statm";
    var file = std.fs.openFileAbsolute(path, .{}) catch return 0;
    defer file.close();
    var buf: [64]u8 = undefined;
    const n = file.readAll(&buf) catch return 0;
    var it = std.mem.tokenizeScalar(u8, buf[0..n], ' ');
    _ = it.next(); // total program size
    if (it.next()) |tok| {
        const pages = std.fmt.parseInt(i64, tok, 10) catch return 0;
        return pages * @as(i64, @intCast(std.mem.page_size));
    }
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
