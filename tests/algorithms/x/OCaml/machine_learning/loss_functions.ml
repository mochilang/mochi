(* Generated by Mochi transpiler v0.10.67 on 2025-08-16 21:23 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec absf x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x < 0.0) then (
  __ret := (Obj.magic ((-.(x))) : float); raise Return
  );
  __ret := (Obj.magic (x) : float); raise Return
  with Return -> !__ret)

and maxf a b =
  let __ret = ref 0.0 in
  (try
  let a = (Obj.magic a : float) in
  let b = (Obj.magic b : float) in
  if (a > b) then (
  __ret := (Obj.magic (a) : float); raise Return
  );
  __ret := (Obj.magic (b) : float); raise Return
  with Return -> !__ret)

and minf a b =
  let __ret = ref 0.0 in
  (try
  let a = (Obj.magic a : float) in
  let b = (Obj.magic b : float) in
  if (a < b) then (
  __ret := (Obj.magic (a) : float); raise Return
  );
  __ret := (Obj.magic (b) : float); raise Return
  with Return -> !__ret)

and clip x lo hi =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let lo = (Obj.magic lo : float) in
  let hi = (Obj.magic hi : float) in
  __ret := (Obj.magic (maxf (Obj.repr (lo)) (Obj.repr (minf (Obj.repr (x)) (Obj.repr (hi))))) : float); raise Return
  with Return -> !__ret)

and to_float x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : int) in
  __ret := (Obj.magic ((float_of_int (x) *. 1.0)) : float); raise Return
  with Return -> !__ret)

and powf base exp =
  let __ret = ref 0.0 in
  (try
  let base = (Obj.magic base : float) in
  let exp = (Obj.magic exp : float) in
  let result = ref (1.0) in
  let i = ref (0) in
  let n = int_of_float (exp) in
  (try while (!i < n) do
    try
  result := (!result *. base);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : float); raise Return
  with Return -> !__ret)

and ln x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x <= 0.0) then (
  (failwith ("ln domain error"));
  );
  let y = ((x -. 1.0) /. (x +. 1.0)) in
  let y2 = (y *. y) in
  let term = ref (y) in
  let sum = ref (0.0) in
  let k = ref (0) in
  (try while (!k < 10) do
    try
  let denom = float_of_int (((2 * !k) + 1)) in
  sum := (!sum +. (!term /. denom));
  term := (!term *. y2);
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((2.0 *. !sum)) : float); raise Return
  with Return -> !__ret)

and exp x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let term = ref (1.0) in
  let sum = ref (1.0) in
  let n = ref (1) in
  (try while (!n < 20) do
    try
  term := ((!term *. x) /. float_of_int (!n));
  sum := (!sum +. !term);
  n := (!n + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and mean v =
  let __ret = ref 0.0 in
  (try
  let v = (Obj.magic v : float list) in
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  total := (!total +. (let __l = v in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (List.length (v)))) : float); raise Return
  with Return -> !__ret)

and binary_cross_entropy y_true y_pred epsilon =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  let epsilon = (Obj.magic epsilon : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let losses = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let yt = (let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let yp = clip (Obj.repr ((let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) (Obj.repr (epsilon)) (Obj.repr ((1.0 -. epsilon))) in
  let loss = (-.(((yt *. Float.log (yp)) +. ((1.0 -. yt) *. Float.log ((1.0 -. yp)))))) in
  losses := (Obj.magic ((List.append (!losses) [(Obj.magic (loss) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (mean (!losses)) : float); raise Return
  with Return -> !__ret)

and binary_focal_cross_entropy y_true y_pred gamma alpha epsilon =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  let gamma = (Obj.magic gamma : float) in
  let alpha = (Obj.magic alpha : float) in
  let epsilon = (Obj.magic epsilon : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let losses = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let yt = (let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let yp = clip (Obj.repr ((let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) (Obj.repr (epsilon)) (Obj.repr ((1.0 -. epsilon))) in
  let term1 = (((alpha *. powf (Obj.repr ((1.0 -. yp))) (Obj.repr (gamma))) *. yt) *. Float.log (yp)) in
  let term2 = ((((1.0 -. alpha) *. powf (Obj.repr (yp)) (Obj.repr (gamma))) *. (1.0 -. yt)) *. Float.log ((1.0 -. yp))) in
  losses := (Obj.magic ((List.append (!losses) [(Obj.magic ((-.((term1 +. term2)))) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (mean (!losses)) : float); raise Return
  with Return -> !__ret)

and categorical_cross_entropy y_true y_pred epsilon =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list list) in
  let y_pred = (Obj.magic y_pred : float list list) in
  let epsilon = (Obj.magic epsilon : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same shape."));
  );
  let rows = List.length (y_true) in
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < rows) do
    try
  if (List.length ((let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) <> List.length ((let __l = y_pred in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) then (
  (failwith ("Input arrays must have the same shape."));
  );
  let sum_true = ref (0.0) in
  let sum_pred = ref (0.0) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) do
    try
  let yt = (let __l = (let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let yp = (let __l = (let __l = y_pred in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  if ((yt <> 0.0) && (yt <> 1.0)) then (
  (failwith ("y_true must be one-hot encoded."));
  );
  sum_true := (!sum_true +. yt);
  sum_pred := (!sum_pred +. yp);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if (!sum_true <> 1.0) then (
  (failwith ("y_true must be one-hot encoded."));
  );
  if (absf (Obj.repr ((!sum_pred -. 1.0))) > epsilon) then (
  (failwith ("Predicted probabilities must sum to approximately 1."));
  );
  j := 0;
  (try while (!j < List.length ((let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) do
    try
  let yp = clip (Obj.repr ((let __l = (let __l = y_pred in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) (Obj.repr (epsilon)) (Obj.repr (1.0)) in
  total := (!total -. ((let __l = (let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. Float.log (yp)));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!total) : float); raise Return
  with Return -> !__ret)

and categorical_focal_cross_entropy y_true y_pred alpha gamma epsilon =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list list) in
  let y_pred = (Obj.magic y_pred : float list list) in
  let alpha = (Obj.magic alpha : float list) in
  let gamma = (Obj.magic gamma : float) in
  let epsilon = (Obj.magic epsilon : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Shape of y_true and y_pred must be the same."));
  );
  let rows = List.length (y_true) in
  let cols = List.length ((let __l = y_true in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let a = ref (alpha) in
  if (List.length (!a) = 0) then (
  let tmp = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < cols) do
    try
  tmp := (Obj.magic ((List.append (!tmp) [(Obj.magic (1.0) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  a := (Obj.magic (!tmp) : float list);
  );
  if (List.length (!a) <> cols) then (
  (failwith ("Length of alpha must match the number of classes."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < rows) do
    try
  if ((List.length ((let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) <> cols) || (List.length ((let __l = y_pred in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) <> cols)) then (
  (failwith ("Shape of y_true and y_pred must be the same."));
  );
  let sum_true = ref (0.0) in
  let sum_pred = ref (0.0) in
  let j = ref (0) in
  (try while (!j < cols) do
    try
  let yt = (let __l = (let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let yp = (let __l = (let __l = y_pred in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  if ((yt <> 0.0) && (yt <> 1.0)) then (
  (failwith ("y_true must be one-hot encoded."));
  );
  sum_true := (!sum_true +. yt);
  sum_pred := (!sum_pred +. yp);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if (!sum_true <> 1.0) then (
  (failwith ("y_true must be one-hot encoded."));
  );
  if (absf (Obj.repr ((!sum_pred -. 1.0))) > epsilon) then (
  (failwith ("Predicted probabilities must sum to approximately 1."));
  );
  let row_loss = ref (0.0) in
  j := 0;
  (try while (!j < cols) do
    try
  let yp = clip (Obj.repr ((let __l = (let __l = y_pred in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) (Obj.repr (epsilon)) (Obj.repr (1.0)) in
  row_loss := (!row_loss +. ((((let __l = !a in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. powf (Obj.repr ((1.0 -. yp))) (Obj.repr (gamma))) *. (let __l = (let __l = y_true in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) *. Float.log (yp)));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  total := (!total -. !row_loss);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (rows))) : float); raise Return
  with Return -> !__ret)

and hinge_loss y_true y_pred =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Length of predicted and actual array must be same."));
  );
  let losses = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let yt = (let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  if ((yt <> (-.(1.0))) && (yt <> 1.0)) then (
  (failwith ("y_true can have values -1 or 1 only."));
  );
  let pred = (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let l = maxf (Obj.repr (0.0)) (Obj.repr ((1.0 -. (yt *. pred)))) in
  losses := (Obj.magic ((List.append (!losses) [(Obj.magic (l) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (mean (!losses)) : float); raise Return
  with Return -> !__ret)

and huber_loss y_true y_pred delta =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  let delta = (Obj.magic delta : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let diff = ((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) in
  let adiff = absf (Obj.repr (diff)) in
  if (adiff <= delta) then (
  total := (!total +. ((0.5 *. diff) *. diff));
  ) else (
  total := (!total +. (delta *. (adiff -. (0.5 *. delta))));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (List.length (y_true)))) : float); raise Return
  with Return -> !__ret)

and mean_squared_error y_true y_pred =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let losses = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let diff = ((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) in
  losses := (Obj.magic ((List.append (!losses) [(Obj.magic ((diff *. diff)) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (mean (!losses)) : float); raise Return
  with Return -> !__ret)

and mean_absolute_error y_true y_pred =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  total := (!total +. absf (Obj.repr (((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (List.length (y_true)))) : float); raise Return
  with Return -> !__ret)

and mean_squared_logarithmic_error y_true y_pred =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let a = Float.log ((1.0 +. (let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) in
  let b = Float.log ((1.0 +. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) in
  let diff = (a -. b) in
  total := (!total +. (diff *. diff));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (List.length (y_true)))) : float); raise Return
  with Return -> !__ret)

and mean_absolute_percentage_error y_true y_pred epsilon =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  let epsilon = (Obj.magic epsilon : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("The length of the two arrays should be the same."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let yt = ref ((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) in
  if (!yt = 0.0) then (
  yt := epsilon;
  );
  total := (!total +. absf (Obj.repr (((!yt -. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) /. !yt))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (List.length (y_true)))) : float); raise Return
  with Return -> !__ret)

and perplexity_loss y_true y_pred epsilon =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : int list list) in
  let y_pred = (Obj.magic y_pred : float list list list) in
  let epsilon = (Obj.magic epsilon : float) in
  let batch = List.length (y_true) in
  if (batch <> List.length (y_pred)) then (
  (failwith ("Batch size of y_true and y_pred must be equal."));
  );
  let sentence_len = List.length ((let __l = y_true in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  if (sentence_len <> List.length ((let __l = y_pred in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) then (
  (failwith ("Sentence length of y_true and y_pred must be equal."));
  );
  let vocab_size = List.length ((let __l = (let __l = y_pred in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let b = ref (0) in
  let total_perp = ref (0.0) in
  (try while (!b < batch) do
    try
  if ((List.length ((let __l = y_true in let __i = !b in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) <> sentence_len) || (List.length ((let __l = y_pred in let __i = !b in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) <> sentence_len)) then (
  (failwith ("Sentence length of y_true and y_pred must be equal."));
  );
  let sum_log = ref (0.0) in
  let j = ref (0) in
  (try while (!j < sentence_len) do
    try
  let label = (let __l = (let __l = y_true in let __i = !b in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  if (label >= vocab_size) then (
  (failwith ("Label value must not be greater than vocabulary size."));
  );
  let prob = clip (Obj.repr ((let __l = (let __l = (let __l = y_pred in let __i = !b in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = label in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) (Obj.repr (epsilon)) (Obj.repr (1.0)) in
  sum_log := (!sum_log +. Float.log (prob));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  let mean_log = (!sum_log /. float_of_int (sentence_len)) in
  let perp = Float.exp ((-.(mean_log))) in
  total_perp := (!total_perp +. perp);
  b := (!b + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total_perp /. float_of_int (batch))) : float); raise Return
  with Return -> !__ret)

and smooth_l1_loss y_true y_pred beta =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  let beta = (Obj.magic beta : float) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("The length of the two arrays should be the same."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  let diff = absf (Obj.repr (((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)))) in
  if (diff < beta) then (
  total := (!total +. (((0.5 *. diff) *. diff) /. beta));
  ) else (
  total := ((!total +. diff) -. (0.5 *. beta));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!total /. float_of_int (List.length (y_true)))) : float); raise Return
  with Return -> !__ret)

and kullback_leibler_divergence y_true y_pred =
  let __ret = ref 0.0 in
  (try
  let y_true = (Obj.magic y_true : float list) in
  let y_pred = (Obj.magic y_pred : float list) in
  if (List.length (y_true) <> List.length (y_pred)) then (
  (failwith ("Input arrays must have the same length."));
  );
  let total = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y_true)) do
    try
  total := (!total +. ((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. Float.log (((let __l = y_true in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) /. (let __l = y_pred in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!total) : float); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let y_true_bc = ref ([0.0; 1.0; 1.0; 0.0; 1.0]) in
  let y_pred_bc = ref ([0.2; 0.7; 0.9; 0.3; 0.8]) in
  print_endline (string_of_float (binary_cross_entropy (!y_true_bc) (!y_pred_bc) (Obj.repr (0.000000000000001))));
  print_endline (string_of_float (binary_focal_cross_entropy (!y_true_bc) (!y_pred_bc) (Obj.repr (2.0)) (Obj.repr (0.25)) (Obj.repr (0.000000000000001))));
  let y_true_cce = ref ([[1.0; 0.0; 0.0]; [0.0; 1.0; 0.0]; [0.0; 0.0; 1.0]]) in
  let y_pred_cce = ref ([[0.9; 0.1; 0.0]; [0.2; 0.7; 0.1]; [0.0; 0.1; 0.9]]) in
  print_endline (string_of_float (categorical_cross_entropy (!y_true_cce) (!y_pred_cce) (Obj.repr (0.000000000000001))));
  let alpha = ref ([0.6; 0.2; 0.7]) in
  print_endline (string_of_float (categorical_focal_cross_entropy (!y_true_cce) (!y_pred_cce) (!alpha) (Obj.repr (2.0)) (Obj.repr (0.000000000000001))));
  let y_true_hinge = ref ([(-.(1.0)); 1.0; 1.0; (-.(1.0)); 1.0]) in
  let y_pred_hinge = ref ([(-.(4.0)); (-.(0.3)); 0.7; 5.0; 10.0]) in
  print_endline (string_of_float (hinge_loss (!y_true_hinge) (!y_pred_hinge)));
  let y_true_huber = ref ([0.9; 10.0; 2.0; 1.0; 5.2]) in
  let y_pred_huber = ref ([0.8; 2.1; 2.9; 4.2; 5.2]) in
  print_endline (string_of_float (huber_loss (!y_true_huber) (!y_pred_huber) (Obj.repr (1.0))));
  print_endline (string_of_float (mean_squared_error (!y_true_huber) (!y_pred_huber)));
  print_endline (string_of_float (mean_absolute_error (!y_true_huber) (!y_pred_huber)));
  print_endline (string_of_float (mean_squared_logarithmic_error (!y_true_huber) (!y_pred_huber)));
  let y_true_mape = ref ([10.0; 20.0; 30.0; 40.0]) in
  let y_pred_mape = ref ([12.0; 18.0; 33.0; 45.0]) in
  print_endline (string_of_float (mean_absolute_percentage_error (!y_true_mape) (!y_pred_mape) (Obj.repr (0.000000000000001))));
  let y_true_perp = ref ([[1; 4]; [2; 3]]) in
  let y_pred_perp = ref ([[[0.28; 0.19; 0.21; 0.15; 0.17]; [0.24; 0.19; 0.09; 0.18; 0.3]]; [[0.03; 0.26; 0.21; 0.18; 0.32]; [0.28; 0.1; 0.33; 0.15; 0.14]]]) in
  print_endline (string_of_float (perplexity_loss (!y_true_perp) (!y_pred_perp) (Obj.repr (0.0000001))));
  let y_true_smooth = ref ([3.0; 5.0; 2.0; 7.0]) in
  let y_pred_smooth = ref ([2.9; 4.8; 2.1; 7.2]) in
  print_endline (string_of_float (smooth_l1_loss (!y_true_smooth) (!y_pred_smooth) (Obj.repr (1.0))));
  let y_true_kl = ref ([0.2; 0.3; 0.5]) in
  let y_pred_kl = ref ([0.3; 0.3; 0.4]) in
  print_endline (string_of_float (kullback_leibler_divergence (!y_true_kl) (!y_pred_kl)));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
