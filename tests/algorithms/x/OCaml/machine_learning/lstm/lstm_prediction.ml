(* Generated by Mochi transpiler v0.10.67 on 2025-08-16 21:23 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec exp_approx x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let sum = ref (1.0) in
  let term = ref (1.0) in
  let n = ref (1) in
  (try while (!n < 20) do
    try
  term := ((!term *. x) /. float_of_int (!n));
  sum := (!sum +. !term);
  n := (!n + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and sigmoid x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  __ret := (Obj.magic ((1.0 /. (1.0 +. exp_approx (Obj.repr ((-.(x))))))) : float); raise Return
  with Return -> !__ret)

and tanh_approx x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let e = exp_approx (Obj.repr ((2.0 *. x))) in
  __ret := (Obj.magic (((e -. 1.0) /. (e +. 1.0))) : float); raise Return
  with Return -> !__ret)

and forward seq w =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let seq = (Obj.magic seq : float list) in
  let w = (Obj.magic w : (string * Obj.t) list) in
  let i_arr = ref (([] : (float) list)) in
  let f_arr = ref (([] : (float) list)) in
  let o_arr = ref (([] : (float) list)) in
  let g_arr = ref (([] : (float) list)) in
  let c_arr = ref ([0.0]) in
  let h_arr = ref ([0.0]) in
  let t = ref (0) in
  (try while (!t < List.length (seq)) do
    try
  let x = (let __l = seq in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let h_prev = (let __l = !h_arr in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let c_prev = (let __l = !c_arr in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let i_t = sigmoid (Obj.repr (((((match List.assoc_opt (__str ("w_i")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. x) +. ((match List.assoc_opt (__str ("u_i")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. h_prev)) +. (match List.assoc_opt (__str ("b_i")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)))) in
  let f_t = sigmoid (Obj.repr (((((match List.assoc_opt (__str ("w_f")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. x) +. ((match List.assoc_opt (__str ("u_f")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. h_prev)) +. (match List.assoc_opt (__str ("b_f")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)))) in
  let o_t = sigmoid (Obj.repr (((((match List.assoc_opt (__str ("w_o")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. x) +. ((match List.assoc_opt (__str ("u_o")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. h_prev)) +. (match List.assoc_opt (__str ("b_o")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)))) in
  let g_t = tanh_approx (Obj.repr (((((match List.assoc_opt (__str ("w_c")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. x) +. ((match List.assoc_opt (__str ("u_c")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. h_prev)) +. (match List.assoc_opt (__str ("b_c")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)))) in
  let c_t = ((f_t *. c_prev) +. (i_t *. g_t)) in
  let h_t = (o_t *. tanh_approx (Obj.repr (c_t))) in
  i_arr := (Obj.magic ((List.append (!i_arr) [(Obj.magic (i_t) : float)])) : float list);
  f_arr := (Obj.magic ((List.append (!f_arr) [(Obj.magic (f_t) : float)])) : float list);
  o_arr := (Obj.magic ((List.append (!o_arr) [(Obj.magic (o_t) : float)])) : float list);
  g_arr := (Obj.magic ((List.append (!g_arr) [(Obj.magic (g_t) : float)])) : float list);
  c_arr := (Obj.magic ((List.append (!c_arr) [(Obj.magic (c_t) : float)])) : float list);
  h_arr := (Obj.magic ((List.append (!h_arr) [(Obj.magic (h_t) : float)])) : float list);
  t := (!t + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("i"), Obj.repr (!i_arr)); (__str ("f"), Obj.repr (!f_arr)); (__str ("o"), Obj.repr (!o_arr)); (__str ("g"), Obj.repr (!g_arr)); (__str ("c"), Obj.repr (!c_arr)); (__str ("h"), Obj.repr (!h_arr))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and backward seq target w s lr =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let seq = (Obj.magic seq : float list) in
  let target = (Obj.magic target : float) in
  w := (Obj.magic !w : (string * Obj.t) list);
  let s = (Obj.magic s : (string * Obj.t) list) in
  let lr = (Obj.magic lr : float) in
  let dw_i = ref (0.0) in
  let du_i = ref (0.0) in
  let db_i = ref (0.0) in
  let dw_f = ref (0.0) in
  let du_f = ref (0.0) in
  let db_f = ref (0.0) in
  let dw_o = ref (0.0) in
  let du_o = ref (0.0) in
  let db_o = ref (0.0) in
  let dw_c = ref (0.0) in
  let du_c = ref (0.0) in
  let db_c = ref (0.0) in
  let dw_y = ref (0.0) in
  let db_y = ref (0.0) in
  let _t = List.length (seq) in
  let h_last = (let __l = (match List.assoc_opt (__str ("h")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = _t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let y = (((match List.assoc_opt (__str ("w_y")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. h_last) +. (match List.assoc_opt (__str ("b_y")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) in
  let dy = (y -. target) in
  dw_y := (dy *. h_last);
  db_y := dy;
  let dh_next = ref ((dy *. (match List.assoc_opt (__str ("w_y")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))) in
  let dc_next = ref (0.0) in
  let t = ref ((_t - 1)) in
  (try while (!t >= 0) do
    try
  let i_t = (let __l = (match List.assoc_opt (__str ("i")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let f_t = (let __l = (match List.assoc_opt (__str ("f")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let o_t = (let __l = (match List.assoc_opt (__str ("o")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let g_t = (let __l = (match List.assoc_opt (__str ("g")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let c_t = (let __l = (match List.assoc_opt (__str ("c")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = (!t + 1) in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let c_prev = (let __l = (match List.assoc_opt (__str ("c")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let h_prev = (let __l = (match List.assoc_opt (__str ("h")) (s) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let tanh_c = tanh_approx (Obj.repr (c_t)) in
  let do_t = (!dh_next *. tanh_c) in
  let da_o = ((do_t *. o_t) *. (1.0 -. o_t)) in
  let dc = (((!dh_next *. o_t) *. (1.0 -. (tanh_c *. tanh_c))) +. !dc_next) in
  let di_t = (dc *. g_t) in
  let da_i = ((di_t *. i_t) *. (1.0 -. i_t)) in
  let dg_t = (dc *. i_t) in
  let da_g = (dg_t *. (1.0 -. (g_t *. g_t))) in
  let df_t = (dc *. c_prev) in
  let da_f = ((df_t *. f_t) *. (1.0 -. f_t)) in
  dw_i := (!dw_i +. (da_i *. (let __l = seq in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  du_i := (!du_i +. (da_i *. h_prev));
  db_i := (!db_i +. da_i);
  dw_f := (!dw_f +. (da_f *. (let __l = seq in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  du_f := (!du_f +. (da_f *. h_prev));
  db_f := (!db_f +. da_f);
  dw_o := (!dw_o +. (da_o *. (let __l = seq in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  du_o := (!du_o +. (da_o *. h_prev));
  db_o := (!db_o +. da_o);
  dw_c := (!dw_c +. (da_g *. (let __l = seq in let __i = !t in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  du_c := (!du_c +. (da_g *. h_prev));
  db_c := (!db_c +. da_g);
  dh_next := ((((da_i *. (match List.assoc_opt (__str ("u_i")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) +. (da_f *. (match List.assoc_opt (__str ("u_f")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))) +. (da_o *. (match List.assoc_opt (__str ("u_o")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))) +. (da_g *. (match List.assoc_opt (__str ("u_c")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)));
  dc_next := (dc *. f_t);
  t := (!t - 1);
    with Continue -> ()
  done with Break -> ());
  w := ((__str ("w_y"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("w_y")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !dw_y))) : float)) :: List.remove_assoc (__str ("w_y")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("b_y"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("b_y")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !db_y))) : float)) :: List.remove_assoc (__str ("b_y")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("w_i"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("w_i")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !dw_i))) : float)) :: List.remove_assoc (__str ("w_i")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("u_i"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("u_i")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !du_i))) : float)) :: List.remove_assoc (__str ("u_i")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("b_i"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("b_i")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !db_i))) : float)) :: List.remove_assoc (__str ("b_i")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("w_f"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("w_f")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !dw_f))) : float)) :: List.remove_assoc (__str ("w_f")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("u_f"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("u_f")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !du_f))) : float)) :: List.remove_assoc (__str ("u_f")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("b_f"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("b_f")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !db_f))) : float)) :: List.remove_assoc (__str ("b_f")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("w_o"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("w_o")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !dw_o))) : float)) :: List.remove_assoc (__str ("w_o")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("u_o"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("u_o")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !du_o))) : float)) :: List.remove_assoc (__str ("u_o")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("b_o"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("b_o")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !db_o))) : float)) :: List.remove_assoc (__str ("b_o")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("w_c"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("w_c")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !dw_c))) : float)) :: List.remove_assoc (__str ("w_c")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("u_c"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("u_c")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !du_c))) : float)) :: List.remove_assoc (__str ("u_c")) (Obj.magic (!w) : (string * Obj.t) list));
  w := ((__str ("b_c"), Obj.repr (Obj.magic (((match List.assoc_opt (__str ("b_c")) (!w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (lr *. !db_c))) : float)) :: List.remove_assoc (__str ("b_c")) (Obj.magic (!w) : (string * Obj.t) list));
  __ret := (Obj.magic (!w) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and make_samples data look_back =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let data = (Obj.magic data : float list) in
  let look_back = (Obj.magic look_back : int) in
  let _x = ref (([] : (float list) list)) in
  let _y = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while ((!i + look_back) < List.length (data)) do
    try
  let seq = ref (List.of_seq (Seq.take ((!i + look_back) - !i) (Seq.drop !i (List.to_seq (data))))) in
  _x := (Obj.magic ((List.append (!_x) [(Obj.magic (!seq) : float list)])) : float list list);
  _y := (Obj.magic ((List.append (!_y) [(Obj.magic ((let __l = data in let __i = (!i + look_back) in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("x"), Obj.repr (!_x)); (__str ("y"), Obj.repr (!_y))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and init_weights () =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  __ret := (Obj.magic ([(__str ("w_i"), Obj.repr (0.1)); (__str ("u_i"), Obj.repr (0.2)); (__str ("b_i"), Obj.repr (0.0)); (__str ("w_f"), Obj.repr (0.1)); (__str ("u_f"), Obj.repr (0.2)); (__str ("b_f"), Obj.repr (0.0)); (__str ("w_o"), Obj.repr (0.1)); (__str ("u_o"), Obj.repr (0.2)); (__str ("b_o"), Obj.repr (0.0)); (__str ("w_c"), Obj.repr (0.1)); (__str ("u_c"), Obj.repr (0.2)); (__str ("b_c"), Obj.repr (0.0)); (__str ("w_y"), Obj.repr (0.1)); (__str ("b_y"), Obj.repr (0.0))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and train data look_back epochs lr =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let data = (Obj.magic data : float list) in
  let look_back = (Obj.magic look_back : int) in
  let epochs = (Obj.magic epochs : int) in
  let lr = (Obj.magic lr : float) in
  let samples = ref (make_samples (data) (Obj.repr (look_back))) in
  let w = ref (init_weights ()) in
  let ep = ref (0) in
  (try while (!ep < epochs) do
    try
  let j = ref (0) in
  (try while (!j < List.length ((match List.assoc_opt (__str ("x")) (!samples) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []))) do
    try
  let seq = ref ((let __l = (match List.assoc_opt (__str ("x")) (!samples) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let target = (let __l = (match List.assoc_opt (__str ("y")) (!samples) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  let state = ref (forward (!seq) (!w)) in
  w := backward (!seq) (Obj.repr (target)) (w) (!state) (Obj.repr (lr));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  ep := (!ep + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!w) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and predict seq w =
  let __ret = ref 0.0 in
  (try
  let seq = (Obj.magic seq : float list) in
  let w = (Obj.magic w : (string * Obj.t) list) in
  let state = ref (forward (seq) ((Obj.magic (w) : (string * Obj.t) list))) in
  let h_last = (let __l = (match List.assoc_opt (__str ("h")) (!state) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []) in let __i = (List.length ((match List.assoc_opt (__str ("h")) (!state) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> [])) - 1) in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  __ret := (Obj.magic ((((match List.assoc_opt (__str ("w_y")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. h_last) +. (match List.assoc_opt (__str ("b_y")) (w) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))) : float); raise Return
  with Return -> !__ret)


let data = ref ([0.1; 0.2; 0.3; 0.4; 0.5; 0.6; 0.7; 0.8])
let look_back = 3
let epochs = 200
let lr = 0.1
let w = ref (train (!data) (Obj.repr (look_back)) (Obj.repr (epochs)) (Obj.repr (lr)))
let test_seq = ref ([0.6; 0.7; 0.8])
let pred = predict (!test_seq) (!w)
let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  print_endline (("Predicted value: " ^ (Printf.sprintf "%.16g" (Obj.magic (pred) : float))));
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
