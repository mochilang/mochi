(* Generated by Mochi transpiler v0.10.61 on 2025-08-08 15:41 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let nodes = ref (([] : ((string * Obj.t) list) list))
let rec make_list length value =
  let __ret = ref ([] : (int) list) in
  (try
  let length = (Obj.magic length : int) in
  let value = (Obj.magic value : int) in
  let lst = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < length) do
    try
  lst := (List.append (!lst) [(Obj.magic (value) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!lst) : int list); raise Return
  with Return -> !__ret)

and min_list arr =
  let __ret = ref 0 in
  (try
  let m = ref (List.nth (arr) (0)) in
  let i = ref (1) in
  (try while (!i < List.length (arr)) do
    try
  if (List.nth (arr) (!i) < !m) then (
  m := List.nth (arr) (!i);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : int); raise Return
  with Return -> !__ret)

and max_list arr =
  let __ret = ref 0 in
  (try
  let m = ref (List.nth (arr) (0)) in
  let i = ref (1) in
  (try while (!i < List.length (arr)) do
    try
  if (List.nth (arr) (!i) > !m) then (
  m := List.nth (arr) (!i);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : int); raise Return
  with Return -> !__ret)

and build_tree arr =
  let __ret = ref 0 in
  (try
  let n = ref ([(__str ("minn"), Obj.repr (min_list (arr))); (__str ("maxx"), Obj.repr (max_list (arr))); (__str ("map_left"), Obj.repr (make_list (Obj.repr (List.length (arr))) (Obj.repr (0)))); (__str ("left"), Obj.repr (-(1))); (__str ("right"), Obj.repr (-(1)))]) in
  if ((Obj.obj (List.assoc (__str ("minn")) (!n) : Obj.t) : int) = (Obj.obj (List.assoc (__str ("maxx")) (!n) : Obj.t) : int)) then (
  nodes := (List.append (!nodes) [(Obj.magic (!n) : (string * Obj.t) list)]);
  __ret := (Obj.magic ((List.length (!nodes) - 1)) : int); raise Return
  );
  let pivot = (((Obj.obj (List.assoc (__str ("minn")) (!n) : Obj.t) : int) + (Obj.obj (List.assoc (__str ("maxx")) (!n) : Obj.t) : int)) / 2) in
  let left_arr = ref (([] : (int) list)) in
  let right_arr = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (arr)) do
    try
  let num = List.nth (arr) (!i) in
  if (num <= pivot) then (
  left_arr := (List.append (!left_arr) [(Obj.magic (num) : int)]);
  ) else (
  right_arr := (List.append (!right_arr) [(Obj.magic (num) : int)]);
  );
  let ml = ref ((Obj.obj (List.assoc (__str ("map_left")) (!n) : Obj.t) : int list)) in
  ml := (List.mapi (fun __i __x -> if __i = !i then List.length (!left_arr) else __x) (!ml));
  n := ((__str ("map_left"), Obj.repr (!ml)) :: List.remove_assoc (__str ("map_left")) (Obj.magic (!n) : (string * Obj.t) list));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (List.length (!left_arr) > 0) then (
  n := ((__str ("left"), Obj.repr (build_tree (!left_arr))) :: List.remove_assoc (__str ("left")) (Obj.magic (!n) : (string * Obj.t) list));
  );
  if (List.length (!right_arr) > 0) then (
  n := ((__str ("right"), Obj.repr (build_tree (!right_arr))) :: List.remove_assoc (__str ("right")) (Obj.magic (!n) : (string * Obj.t) list));
  );
  nodes := (List.append (!nodes) [(Obj.magic (!n) : (string * Obj.t) list)]);
  __ret := (Obj.magic ((List.length (!nodes) - 1)) : int); raise Return
  with Return -> !__ret)

and rank_till_index node_idx num index =
  let __ret = ref 0 in
  (try
  let node_idx = (Obj.magic node_idx : int) in
  let num = (Obj.magic num : int) in
  let index = (Obj.magic index : int) in
  if ((index < 0) || (node_idx < 0)) then (
  __ret := (Obj.magic (0) : int); raise Return
  );
  let node = List.nth (!nodes) (node_idx) in
  if ((Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int) = (Obj.obj (List.assoc (__str ("maxx")) (node) : Obj.t) : int)) then (
  if ((Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int) = num) then (
  __ret := (Obj.magic ((index + 1)) : int); raise Return
  ) else (
  __ret := (Obj.magic (0) : int); raise Return
  );
  );
  let pivot = (((Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int) + (Obj.obj (List.assoc (__str ("maxx")) (node) : Obj.t) : int)) / 2) in
  if (num <= pivot) then (
  __ret := (Obj.magic (rank_till_index (Obj.repr ((Obj.obj (List.assoc (__str ("left")) (node) : Obj.t) : int))) (Obj.repr (num)) (Obj.repr ((List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (index) - 1)))) : int); raise Return
  ) else (
  __ret := (Obj.magic (rank_till_index (Obj.repr ((Obj.obj (List.assoc (__str ("right")) (node) : Obj.t) : int))) (Obj.repr (num)) (Obj.repr ((index - List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (index))))) : int); raise Return
  );
    !__ret
  with Return -> !__ret)

and rank node_idx num start end_ =
  let __ret = ref 0 in
  (try
  let node_idx = (Obj.magic node_idx : int) in
  let num = (Obj.magic num : int) in
  let start = (Obj.magic start : int) in
  let end_ = (Obj.magic end_ : int) in
  if (start > end_) then (
  __ret := (Obj.magic (0) : int); raise Return
  );
  let rank_till_end = rank_till_index (Obj.repr (node_idx)) (Obj.repr (num)) (Obj.repr (end_)) in
  let rank_before_start = rank_till_index (Obj.repr (node_idx)) (Obj.repr (num)) (Obj.repr ((start - 1))) in
  __ret := (Obj.magic ((rank_till_end - rank_before_start)) : int); raise Return
  with Return -> !__ret)

and quantile node_idx index start end_ =
  let __ret = ref 0 in
  (try
  let node_idx = (Obj.magic node_idx : int) in
  let index = (Obj.magic index : int) in
  let start = (Obj.magic start : int) in
  let end_ = (Obj.magic end_ : int) in
  if (((index > (end_ - start)) || (start > end_)) || (node_idx < 0)) then (
  __ret := (Obj.magic (-(1)) : int); raise Return
  );
  let node = List.nth (!nodes) (node_idx) in
  if ((Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int) = (Obj.obj (List.assoc (__str ("maxx")) (node) : Obj.t) : int)) then (
  __ret := (Obj.magic ((Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int)) : int); raise Return
  );
  let left_start = if (start = 0) then 0 else List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) ((start - 1)) in
  let num_left = (List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (end_) - left_start) in
  if (num_left > index) then (
  __ret := (Obj.magic (quantile (Obj.repr ((Obj.obj (List.assoc (__str ("left")) (node) : Obj.t) : int))) (Obj.repr (index)) (Obj.repr (left_start)) (Obj.repr ((List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (end_) - 1)))) : int); raise Return
  ) else (
  __ret := (Obj.magic (quantile (Obj.repr ((Obj.obj (List.assoc (__str ("right")) (node) : Obj.t) : int))) (Obj.repr ((index - num_left))) (Obj.repr ((start - left_start))) (Obj.repr ((end_ - List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (end_))))) : int); raise Return
  );
    !__ret
  with Return -> !__ret)

and range_counting node_idx start end_ start_num end_num =
  let __ret = ref 0 in
  (try
  let node_idx = (Obj.magic node_idx : int) in
  let start = (Obj.magic start : int) in
  let end_ = (Obj.magic end_ : int) in
  let start_num = (Obj.magic start_num : int) in
  let end_num = (Obj.magic end_num : int) in
  if (((start > end_) || (node_idx < 0)) || (start_num > end_num)) then (
  __ret := (Obj.magic (0) : int); raise Return
  );
  let node = List.nth (!nodes) (node_idx) in
  if (((Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int) > end_num) || ((Obj.obj (List.assoc (__str ("maxx")) (node) : Obj.t) : int) < start_num)) then (
  __ret := (Obj.magic (0) : int); raise Return
  );
  if ((start_num <= (Obj.obj (List.assoc (__str ("minn")) (node) : Obj.t) : int)) && ((Obj.obj (List.assoc (__str ("maxx")) (node) : Obj.t) : int) <= end_num)) then (
  __ret := (Obj.magic (((end_ - start) + 1)) : int); raise Return
  );
  let left = range_counting (Obj.repr ((Obj.obj (List.assoc (__str ("left")) (node) : Obj.t) : int))) (Obj.repr (if (start = 0) then 0 else List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) ((start - 1)))) (Obj.repr ((List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (end_) - 1))) (Obj.repr (start_num)) (Obj.repr (end_num)) in
  let right = range_counting (Obj.repr ((Obj.obj (List.assoc (__str ("right")) (node) : Obj.t) : int))) (Obj.repr ((start - if (start = 0) then 0 else List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) ((start - 1))))) (Obj.repr ((end_ - List.nth ((Obj.obj (List.assoc (__str ("map_left")) (node) : Obj.t) : int list)) (end_)))) (Obj.repr (start_num)) (Obj.repr (end_num)) in
  __ret := (Obj.magic ((left + right)) : int); raise Return
  with Return -> !__ret)


let test_array = ref ([2; 1; 4; 5; 6; 0; 8; 9; 1; 2; 0; 6; 4; 2; 0; 6; 5; 3; 2; 7])
let () =
  let mem_start = _mem () in
  let start = _now () in
  let root = build_tree (!test_array) in
  print_endline (("rank_till_index 6 at 6 -> " ^ (string_of_int (rank_till_index (Obj.repr (root)) (Obj.repr (6)) (Obj.repr (6))))));
  print_endline (("rank 6 in [3,13] -> " ^ (string_of_int (rank (Obj.repr (root)) (Obj.repr (6)) (Obj.repr (3)) (Obj.repr (13))))));
  print_endline (("quantile index 2 in [2,5] -> " ^ (string_of_int (quantile (Obj.repr (root)) (Obj.repr (2)) (Obj.repr (2)) (Obj.repr (5))))));
  print_endline (("range_counting [3,7] in [1,10] -> " ^ (string_of_int (range_counting (Obj.repr (root)) (Obj.repr (1)) (Obj.repr (10)) (Obj.repr (3)) (Obj.repr (7))))));
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()