(* Generated by Mochi transpiler v0.10.59 on 2025-08-07 00:30 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec repeat_int n val_ =
  let __ret = ref ([] : (int) list) in
  (try
  let n = (Obj.magic n : int) in
  let val_ = (Obj.magic val_ : int) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  res := (List.append (!res) [(Obj.magic (val_) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and repeat_bool n val_ =
  let __ret = ref ([] : (bool) list) in
  (try
  let n = (Obj.magic n : int) in
  let res = ref (([] : (bool) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  res := (List.append (!res) [(Obj.magic (val_) : bool)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : bool list); raise Return
  with Return -> !__ret)

and set_int xs idx value =
  let __ret = ref ([] : (int) list) in
  (try
  let idx = (Obj.magic idx : int) in
  let value = (Obj.magic value : int) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (xs)) do
    try
  if (!i = idx) then (
  res := (List.append (!res) [(Obj.magic (value) : int)]);
  ) else (
  res := (List.append (!res) [(Obj.magic (List.nth (xs) (!i)) : int)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and set_bool xs idx value =
  let __ret = ref ([] : (bool) list) in
  (try
  let idx = (Obj.magic idx : int) in
  let res = ref (([] : (bool) list)) in
  let i = ref (0) in
  (try while (!i < List.length (xs)) do
    try
  if (!i = idx) then (
  res := (List.append (!res) [(Obj.magic (value) : bool)]);
  ) else (
  res := (List.append (!res) [(Obj.magic (List.nth (xs) (!i)) : bool)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : bool list); raise Return
  with Return -> !__ret)

and create_table size_table charge_factor lim_charge =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let size_table = (Obj.magic size_table : int) in
  let charge_factor = (Obj.magic charge_factor : int) in
  let lim_charge = (Obj.magic lim_charge : float) in
  __ret := (Obj.magic ([(__str ("size_table"), Obj.repr (size_table)); (__str ("values"), Obj.repr (repeat_int (Obj.repr (size_table)) (Obj.repr (0)))); (__str ("filled"), Obj.repr (repeat_bool (Obj.repr (size_table)) (false))); (__str ("charge_factor"), Obj.repr (charge_factor)); (__str ("lim_charge"), Obj.repr (lim_charge))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and hash_function ht key =
  let __ret = ref 0 in
  (try
  let key = (Obj.magic key : int) in
  let k = ref (((key mod (Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int) + (Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int)) mod (Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int))) in
  if (!k < 0) then (
  k := (!k + (Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int));
  );
  __ret := (Obj.magic (!k) : int); raise Return
  with Return -> !__ret)

and is_prime n =
  let __ret = ref false in
  (try
  let n = (Obj.magic n : int) in
  if (n < 2) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  if (((n mod 2 + 2) mod 2) = 0) then (
  __ret := (Obj.magic ((n = 2)) : bool); raise Return
  );
  let i = ref (3) in
  (try while ((!i * !i) <= n) do
    try
  if (((n mod !i + !i) mod !i) = 0) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  i := (!i + 2);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and next_prime value factor =
  let __ret = ref 0 in
  (try
  let value = (Obj.magic value : int) in
  let factor = (Obj.magic factor : int) in
  let candidate = ref (((value * factor) + 1)) in
  (try while not (is_prime (Obj.repr (!candidate))) do
    try
  candidate := (!candidate + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!candidate) : int); raise Return
  with Return -> !__ret)

and set_value ht key data =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let key = (Obj.magic key : int) in
  let data = (Obj.magic data : int) in
  let new_values = ref (set_int ((Obj.obj (List.assoc (__str ("values")) (ht) : Obj.t) : int list)) (Obj.repr (key)) (Obj.repr (data))) in
  let new_filled = ref (set_bool ((Obj.obj (List.assoc (__str ("filled")) (ht) : Obj.t) : bool list)) (Obj.repr (key)) (true)) in
  __ret := (Obj.magic ([(__str ("size_table"), Obj.repr ((Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int))); (__str ("values"), Obj.repr (!new_values)); (__str ("filled"), Obj.repr (!new_filled)); (__str ("charge_factor"), Obj.repr ((Obj.obj (List.assoc (__str ("charge_factor")) (ht) : Obj.t) : int))); (__str ("lim_charge"), Obj.repr ((Obj.obj (List.assoc (__str ("lim_charge")) (ht) : Obj.t) : float)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and collision_resolution ht key =
  let __ret = ref 0 in
  (try
  let key = (Obj.magic key : int) in
  let new_key = ref (hash_function ((Obj.magic ht : (string * Obj.t) list)) (Obj.repr ((key + 1)))) in
  let steps = ref (0) in
  (try while List.nth ((Obj.obj (List.assoc (__str ("filled")) (ht) : Obj.t) : bool list)) (!new_key) do
    try
  new_key := hash_function ((Obj.magic ht : (string * Obj.t) list)) (Obj.repr ((!new_key + 1)));
  steps := (!steps + 1);
  if (!steps >= (Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int)) then (
  __ret := (Obj.magic (-(1)) : int); raise Return
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!new_key) : int); raise Return
  with Return -> !__ret)

and rehashing ht =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let survivors = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length ((Obj.obj (List.assoc (__str ("values")) (ht) : Obj.t) : int list))) do
    try
  if List.nth ((Obj.obj (List.assoc (__str ("filled")) (ht) : Obj.t) : bool list)) (!i) then (
  survivors := (List.append (!survivors) [(Obj.magic (List.nth ((Obj.obj (List.assoc (__str ("values")) (ht) : Obj.t) : int list)) (!i)) : int)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let new_size = next_prime (Obj.repr ((Obj.obj (List.assoc (__str ("size_table")) (ht) : Obj.t) : int))) (Obj.repr (2)) in
  let new_ht = ref (create_table (Obj.repr (new_size)) (Obj.repr ((Obj.obj (List.assoc (__str ("charge_factor")) (ht) : Obj.t) : int))) (Obj.repr ((Obj.obj (List.assoc (__str ("lim_charge")) (ht) : Obj.t) : float)))) in
  i := 0;
  (try while (!i < List.length (!survivors)) do
    try
  new_ht := insert_data (!new_ht) (Obj.repr (List.nth (!survivors) (!i)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!new_ht) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and insert_data ht data =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let data = (Obj.magic data : int) in
  let key = hash_function ((Obj.magic ht : (string * Obj.t) list)) (Obj.repr (data)) in
  if not (List.nth ((Obj.obj (List.assoc (__str ("filled")) (ht) : Obj.t) : bool list)) (key)) then (
  __ret := (Obj.magic (set_value ((Obj.magic ht : (string * Obj.t) list)) (Obj.repr (key)) (Obj.repr (data))) : (string * Obj.t) list); raise Return
  );
  if (List.nth ((Obj.obj (List.assoc (__str ("values")) (ht) : Obj.t) : int list)) (key) = data) then (
  __ret := (Obj.magic (ht) : (string * Obj.t) list); raise Return
  );
  let new_key = collision_resolution ((Obj.magic ht : (string * Obj.t) list)) (Obj.repr (key)) in
  if (new_key >= 0) then (
  __ret := (Obj.magic (set_value ((Obj.magic ht : (string * Obj.t) list)) (Obj.repr (new_key)) (Obj.repr (data))) : (string * Obj.t) list); raise Return
  );
  let resized = rehashing ((Obj.magic ht : (string * Obj.t) list)) in
  __ret := (Obj.magic (insert_data (resized) (Obj.repr (data))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and keys ht =
  let __ret = ref ([] : (int list) list) in
  (try
  let res = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length ((Obj.obj (List.assoc (__str ("values")) (ht) : Obj.t) : int list))) do
    try
  if List.nth ((Obj.obj (List.assoc (__str ("filled")) (ht) : Obj.t) : bool list)) (!i) then (
  res := (List.append (!res) [(Obj.magic ([!i; List.nth ((Obj.obj (List.assoc (__str ("values")) (ht) : Obj.t) : int list)) (!i)]) : int list)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let ht = ref (create_table (Obj.repr (3)) (Obj.repr (1)) (Obj.repr (0.75))) in
  ht := insert_data (!ht) (Obj.repr (17));
  ht := insert_data (!ht) (Obj.repr (18));
  ht := insert_data (!ht) (Obj.repr (99));
  print_endline (__show_list (keys (!ht)));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()