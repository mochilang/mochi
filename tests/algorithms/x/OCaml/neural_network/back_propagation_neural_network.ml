(* Generated by Mochi transpiler v0.10.69 on 2025-08-22 13:05 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic r : int) = 0
  else
    match tag r with
    | 0 -> __is_list (field r 1)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let seed = ref (1)
let rec rand () =
  let __ret = ref 0 in
  (try
  seed := ((((!seed * 1103515245) + 12345) mod 2147483648 + 2147483648) mod 2147483648);
  __ret := (Obj.magic (!seed) : int); raise Return
  with Return -> !__ret)

and random () =
  let __ret = ref 0.0 in
  (try
  __ret := (Obj.magic (((1.0 *. float_of_int (rand ())) /. 2147483648.0)) : float); raise Return
  with Return -> !__ret)

and expApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let y = ref (x) in
  let is_neg = ref (false) in
  if (x < 0.0) then (
  is_neg := true;
  y := (-.(x));
  );
  let term = ref (1.0) in
  let sum = ref (1.0) in
  let n = ref (1) in
  (try while (!n < 30) do
    try
  term := ((!term *. !y) /. float_of_int (!n));
  sum := (!sum +. !term);
  n := (!n + 1);
    with Continue -> ()
  done with Break -> ());
  if !is_neg then (
  __ret := (Obj.magic ((1.0 /. !sum)) : float); raise Return
  );
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and sigmoid z =
  let __ret = ref 0.0 in
  (try
  let z = (Obj.magic z : float) in
  __ret := (Obj.magic ((1.0 /. (1.0 +. expApprox (Obj.repr ((-.(z))))))) : float); raise Return
  with Return -> !__ret)

and sigmoid_vec v =
  let __ret = ref ([] : (float) list) in
  (try
  let v = (Obj.magic v : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  res := (Obj.magic ((List.append (!res) [(Obj.magic (sigmoid (Obj.repr ((let __l = v in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)))) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and sigmoid_derivative out =
  let __ret = ref ([] : (float) list) in
  (try
  let out = (Obj.magic out : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (out)) do
    try
  let val_ = (let __l = out in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) in
  res := (Obj.magic ((List.append (!res) [(Obj.magic ((val_ *. (1.0 -. val_))) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and random_vector n =
  let __ret = ref ([] : (float) list) in
  (try
  let n = (Obj.magic n : int) in
  let v = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  v := (Obj.magic ((List.append (!v) [(Obj.magic ((random () -. 0.5)) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!v) : float list); raise Return
  with Return -> !__ret)

and random_matrix r c =
  let __ret = ref ([] : (float list) list) in
  (try
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let m = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < r) do
    try
  m := (Obj.magic ((List.append (!m) [(Obj.magic (random_vector (Obj.repr (c))) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : float list list); raise Return
  with Return -> !__ret)

and matvec mat vec =
  let __ret = ref ([] : (float) list) in
  (try
  let mat = (Obj.magic mat : float list list) in
  let vec = (Obj.magic vec : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (mat)) do
    try
  let s = ref (0.0) in
  let j = ref (0) in
  (try while (!j < List.length (vec)) do
    try
  s := (!s +. ((let __l = (let __l = mat in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = vec in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic ((List.append (!res) [(Obj.magic (!s) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and matTvec mat vec =
  let __ret = ref ([] : (float) list) in
  (try
  let mat = (Obj.magic mat : float list list) in
  let vec = (Obj.magic vec : float list) in
  let cols = ref (List.length ((let __l = mat in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) in
  let res = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < !cols) do
    try
  let s = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (mat)) do
    try
  s := (!s +. ((let __l = (let __l = mat in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = vec in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic ((List.append (!res) [(Obj.magic (!s) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and vec_sub a b =
  let __ret = ref ([] : (float) list) in
  (try
  let a = (Obj.magic a : float list) in
  let b = (Obj.magic b : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic ((List.append (!res) [(Obj.magic (((let __l = a in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = b in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and vec_mul a b =
  let __ret = ref ([] : (float) list) in
  (try
  let a = (Obj.magic a : float list) in
  let b = (Obj.magic b : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic ((List.append (!res) [(Obj.magic (((let __l = a in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = b in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and vec_scalar_mul v s =
  let __ret = ref ([] : (float) list) in
  (try
  let v = (Obj.magic v : float list) in
  let s = (Obj.magic s : float) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  res := (Obj.magic ((List.append (!res) [(Obj.magic (((let __l = v in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. s)) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and outer a b =
  let __ret = ref ([] : (float list) list) in
  (try
  let a = (Obj.magic a : float list) in
  let b = (Obj.magic b : float list) in
  let res = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < List.length (b)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (((let __l = a in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = b in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic ((List.append (!res) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list list); raise Return
  with Return -> !__ret)

and mat_scalar_mul mat s =
  let __ret = ref ([] : (float list) list) in
  (try
  let mat = (Obj.magic mat : float list list) in
  let s = (Obj.magic s : float) in
  let res = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (mat)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = mat in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (((let __l = (let __l = mat in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. s)) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic ((List.append (!res) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list list); raise Return
  with Return -> !__ret)

and mat_sub a b =
  let __ret = ref ([] : (float list) list) in
  (try
  let a = (Obj.magic a : float list list) in
  let b = (Obj.magic b : float list list) in
  let res = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = a in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (((let __l = (let __l = a in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = (let __l = b in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic ((List.append (!res) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list list); raise Return
  with Return -> !__ret)

and init_layer units back_units lr =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let units = (Obj.magic units : int) in
  let back_units = (Obj.magic back_units : int) in
  let lr = (Obj.magic lr : float) in
  __ret := (Obj.magic ([(__str (Obj.repr ("units")), Obj.repr (units)); (__str (Obj.repr ("weight")), Obj.repr (random_matrix (Obj.repr (units)) (Obj.repr (back_units)))); (__str (Obj.repr ("bias")), Obj.repr (random_vector (Obj.repr (units)))); (__str (Obj.repr ("output")), Obj.repr ([])); (__str (Obj.repr ("xdata")), Obj.repr ([])); (__str (Obj.repr ("learn_rate")), Obj.repr (lr))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and forward layers x =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  layers := (Obj.magic !layers : (string * Obj.t) list list);
  let x = (Obj.magic x : float list) in
  let data = ref (x) in
  let i = ref (0) in
  (try while (!i < List.length (!layers)) do
    try
  let layer = ref ((let __l = !layers in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  layer := ((__str (Obj.repr ("xdata")), Obj.repr (Obj.magic (!data) : float list)) :: List.remove_assoc (__str (Obj.repr ("xdata"))) (Obj.magic (!layer) : (string * Obj.t) list));
  if (!i = 0) then (
  layer := ((__str (Obj.repr ("output")), Obj.repr (Obj.magic (!data) : float list)) :: List.remove_assoc (__str (Obj.repr ("output"))) (Obj.magic (!layer) : (string * Obj.t) list));
  ) else (
  let z = ref (vec_sub (matvec ((match List.assoc_opt (__str (Obj.repr ("weight"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> [])) (!data)) ((match List.assoc_opt (__str (Obj.repr ("bias"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []))) in
  layer := ((__str (Obj.repr ("output")), Obj.repr (Obj.magic (sigmoid_vec (!z)) : float list)) :: List.remove_assoc (__str (Obj.repr ("output"))) (Obj.magic (!layer) : (string * Obj.t) list));
  data := (Obj.magic ((match List.assoc_opt (__str (Obj.repr ("output"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> [])) : float list);
  );
  layers := (List.mapi (fun __i __x -> if __i = !i then !layer else __x) (!layers));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!layers) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and backward layers grad =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  layers := (Obj.magic !layers : (string * Obj.t) list list);
  let grad = (Obj.magic grad : float list) in
  let g = ref (grad) in
  let i = ref ((List.length (!layers) - 1)) in
  (try while (!i > 0) do
    try
  let layer = ref ((let __l = !layers in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let deriv = ref (sigmoid_derivative ((match List.assoc_opt (__str (Obj.repr ("output"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []))) in
  let delta = ref (vec_mul (!g) (!deriv)) in
  let grad_w = ref (outer (!delta) ((match List.assoc_opt (__str (Obj.repr ("xdata"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> []))) in
  layer := ((__str (Obj.repr ("weight")), Obj.repr (Obj.magic (mat_sub ((match List.assoc_opt (__str (Obj.repr ("weight"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> [])) (mat_scalar_mul (!grad_w) (Obj.repr ((match List.assoc_opt (__str (Obj.repr ("learn_rate"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))))) : float list list)) :: List.remove_assoc (__str (Obj.repr ("weight"))) (Obj.magic (!layer) : (string * Obj.t) list));
  layer := ((__str (Obj.repr ("bias")), Obj.repr (Obj.magic (vec_sub ((match List.assoc_opt (__str (Obj.repr ("bias"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> [])) (vec_scalar_mul (!delta) (Obj.repr ((match List.assoc_opt (__str (Obj.repr ("learn_rate"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))))) : float list)) :: List.remove_assoc (__str (Obj.repr ("bias"))) (Obj.magic (!layer) : (string * Obj.t) list));
  g := (Obj.magic (matTvec ((match List.assoc_opt (__str (Obj.repr ("weight"))) (!layer) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> [])) (!delta)) : float list);
  layers := (List.mapi (fun __i __x -> if __i = !i then !layer else __x) (!layers));
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!layers) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and calc_loss y yhat =
  let __ret = ref 0.0 in
  (try
  let y = (Obj.magic y : float list) in
  let yhat = (Obj.magic yhat : float list) in
  let s = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (y)) do
    try
  let d = ((let __l = y in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = yhat in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) in
  s := (!s +. (d *. d));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!s) : float); raise Return
  with Return -> !__ret)

and calc_gradient y yhat =
  let __ret = ref ([] : (float) list) in
  (try
  let y = (Obj.magic y : float list) in
  let yhat = (Obj.magic yhat : float list) in
  let g = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (y)) do
    try
  g := (Obj.magic ((List.append (!g) [(Obj.magic ((2.0 *. ((let __l = yhat in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = y in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)))) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!g) : float list); raise Return
  with Return -> !__ret)

and train layers xdata ydata rounds acc =
  let __ret = ref 0.0 in
  (try
  layers := (Obj.magic !layers : (string * Obj.t) list list);
  let xdata = (Obj.magic xdata : float list list) in
  let ydata = (Obj.magic ydata : float list list) in
  let rounds = (Obj.magic rounds : int) in
  let acc = (Obj.magic acc : float) in
  let r = ref (0) in
  (try while (!r < rounds) do
    try
  let i = ref (0) in
  (try while (!i < List.length (xdata)) do
    try
  layers := forward (layers) ((let __l = xdata in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []));
  let out = ref ((match List.assoc_opt (__str (Obj.repr ("output"))) ((let __l = !layers in let __i = (List.length (!layers) - 1) in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : float list) | None -> [])) in
  let grad = ref (calc_gradient ((let __l = ydata in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) (!out)) in
  layers := backward (layers) (!grad);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (0.0) : float); raise Return
  with Return -> !__ret)

and create_data () =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let x = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < 10) do
    try
  x := (Obj.magic ((List.append (!x) [(Obj.magic (random_vector (Obj.repr (10))) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let y = ref ([[0.8; 0.4]; [0.4; 0.3]; [0.34; 0.45]; [0.67; 0.32]; [0.88; 0.67]; [0.78; 0.77]; [0.55; 0.66]; [0.55; 0.43]; [0.54; 0.1]; [0.1; 0.5]]) in
  __ret := (Obj.magic ([(__str (Obj.repr ("x")), Obj.repr (!x)); (__str (Obj.repr ("y")), Obj.repr (!y))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let data = ref (create_data ()) in
  let x = ref ((match List.assoc_opt (__str (Obj.repr ("x"))) (!data) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> [])) in
  let y = ref ((match List.assoc_opt (__str (Obj.repr ("y"))) (!data) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> [])) in
  let layers = ref (([] : ((string * Obj.t) list) list)) in
  layers := (Obj.magic ((List.append (!layers) [(Obj.magic (init_layer (Obj.repr (10)) (Obj.repr (0)) (Obj.repr (0.3))) : (string * Obj.t) list)])) : (string * Obj.t) list list);
  layers := (Obj.magic ((List.append (!layers) [(Obj.magic (init_layer (Obj.repr (20)) (Obj.repr (10)) (Obj.repr (0.3))) : (string * Obj.t) list)])) : (string * Obj.t) list list);
  layers := (Obj.magic ((List.append (!layers) [(Obj.magic (init_layer (Obj.repr (30)) (Obj.repr (20)) (Obj.repr (0.3))) : (string * Obj.t) list)])) : (string * Obj.t) list list);
  layers := (Obj.magic ((List.append (!layers) [(Obj.magic (init_layer (Obj.repr (2)) (Obj.repr (30)) (Obj.repr (0.3))) : (string * Obj.t) list)])) : (string * Obj.t) list list);
  let final_mse = train (layers) (!x) (!y) (Obj.repr (100)) (Obj.repr (0.01)) in
  print_endline (Printf.sprintf "%.15f" (final_mse));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
