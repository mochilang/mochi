(* Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:17 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec compare_string string1 string2 =
  let __ret = ref "" in
  (try
  let result = ref ("") in
  let count = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (string1)) do
    try
  let c1 = String.sub string1 (!i) ((!i + 1) - !i) in
  let c2 = String.sub string2 (!i) ((!i + 1) - !i) in
  if (c1 <> c2) then (
  count := (!count + 1);
  result := (!result ^ "_");
  ) else (
  result := (!result ^ c1);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (!count > 1) then (
  __ret := (Obj.magic ("") : string); raise Return
  );
  __ret := (Obj.magic (!result) : string); raise Return
  with Return -> !__ret)

and contains_string arr value =
  let __ret = ref false in
  (try
  let i = ref (0) in
  (try while (!i < List.length (arr)) do
    try
  if (List.nth (arr) (!i) = value) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and unique_strings arr =
  let __ret = ref ([] : (string) list) in
  (try
  let res = ref (([] : (string) list)) in
  let i = ref (0) in
  (try while (!i < List.length (arr)) do
    try
  if not (contains_string (!res) (List.nth (arr) (!i))) then (
  res := (List.append (!res) [(Obj.magic (List.nth (arr) (!i)) : string)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string list); raise Return
  with Return -> !__ret)

and check binary =
  let __ret = ref ([] : (string) list) in
  (try
  let pi = ref (([] : (string) list)) in
  let current = ref (binary) in
  (try while true do
    try
  let check1 = ref (([] : (string) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!current)) do
    try
  check1 := (List.append (!check1) [(Obj.magic ("$") : string)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let temp = ref (([] : (string) list)) in
  i := 0;
  (try while (!i < List.length (!current)) do
    try
  let j = ref ((!i + 1)) in
  (try while (!j < List.length (!current)) do
    try
  let k = compare_string (List.nth (!current) (!i)) (List.nth (!current) (!j)) in
  if (k = "") then (
  check1 := (List.mapi (fun __i __x -> if __i = !i then "*" else __x) (!check1));
  check1 := (List.mapi (fun __i __x -> if __i = !j then "*" else __x) (!check1));
  temp := (List.append (!temp) [(Obj.magic ("X") : string)]);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  i := 0;
  (try while (!i < List.length (!current)) do
    try
  if (List.nth (!check1) (!i) = "$") then (
  pi := (List.append (!pi) [(Obj.magic (List.nth (!current) (!i)) : string)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (List.length (!temp) = 0) then (
  __ret := (Obj.magic (!pi) : string list); raise Return
  );
  current := unique_strings (!temp);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and decimal_to_binary no_of_variable minterms =
  let __ret = ref ([] : (string) list) in
  (try
  let no_of_variable = (Obj.magic no_of_variable : int) in
  let temp = ref (([] : (string) list)) in
  let idx = ref (0) in
  (try while (!idx < List.length (minterms)) do
    try
  let minterm = ref (List.nth (minterms) (!idx)) in
  let string = ref ("") in
  let i = ref (0) in
  (try while (!i < no_of_variable) do
    try
  string := ((string_of_int ((!minterm mod 2))) ^ !string);
  minterm := (!minterm / 2);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  temp := (List.append (!temp) [(Obj.magic (!string) : string)]);
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!temp) : string list); raise Return
  with Return -> !__ret)

and is_for_table string1 string2 count =
  let __ret = ref false in
  (try
  let count = (Obj.magic count : int) in
  let count_n = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (string1)) do
    try
  let c1 = String.sub string1 (!i) ((!i + 1) - !i) in
  let c2 = String.sub string2 (!i) ((!i + 1) - !i) in
  if (c1 <> c2) then (
  count_n := (!count_n + 1);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!count_n = count)) : bool); raise Return
  with Return -> !__ret)

and count_ones row =
  let __ret = ref 0 in
  (try
  let c = ref (0) in
  let j = ref (0) in
  (try while (!j < List.length (row)) do
    try
  if (List.nth (row) (!j) = 1) then (
  c := (!c + 1);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!c) : int); raise Return
  with Return -> !__ret)

and selection chart prime_implicants =
  let __ret = ref ([] : (string) list) in
  (try
  let temp = ref (([] : (string) list)) in
  let select = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!chart)) do
    try
  select := (List.append (!select) [(Obj.magic (0) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let col = ref (0) in
  (try while (!col < List.length (List.nth (!chart) (0))) do
    try
  let count = ref (0) in
  let row = ref (0) in
  (try while (!row < List.length (!chart)) do
    try
  if (List.nth (List.nth (!chart) (!row)) (!col) = 1) then (
  count := (!count + 1);
  );
  row := (!row + 1);
    with Continue -> ()
  done with Break -> ());
  if (!count = 1) then (
  let rem = ref (0) in
  row := 0;
  (try while (!row < List.length (!chart)) do
    try
  if (List.nth (List.nth (!chart) (!row)) (!col) = 1) then (
  rem := !row;
  );
  row := (!row + 1);
    with Continue -> ()
  done with Break -> ());
  select := (List.mapi (fun __i __x -> if __i = !rem then 1 else __x) (!select));
  );
  col := (!col + 1);
    with Continue -> ()
  done with Break -> ());
  i := 0;
  (try while (!i < List.length (!select)) do
    try
  if (List.nth (!select) (!i) = 1) then (
  let j = ref (0) in
  (try while (!j < List.length (List.nth (!chart) (0))) do
    try
  if (List.nth (List.nth (!chart) (!i)) (!j) = 1) then (
  let r = ref (0) in
  (try while (!r < List.length (!chart)) do
    try
  chart := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = !j then 0 else __x) (List.nth (!chart) (!r))) else __x) (!chart));
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  temp := (List.append (!temp) [(Obj.magic (List.nth (prime_implicants) (!i)) : string)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  (try while true do
    try
  let counts = ref (([] : (int) list)) in
  let r = ref (0) in
  (try while (!r < List.length (!chart)) do
    try
  counts := (List.append (!counts) [(Obj.magic (count_ones (List.nth (!chart) (!r))) : int)]);
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  let max_n = ref (List.nth (!counts) (0)) in
  let rem = ref (0) in
  let k = ref (1) in
  (try while (!k < List.length (!counts)) do
    try
  if (List.nth (!counts) (!k) > !max_n) then (
  max_n := List.nth (!counts) (!k);
  rem := !k;
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  if (!max_n = 0) then (
  __ret := (Obj.magic (!temp) : string list); raise Return
  );
  temp := (List.append (!temp) [(Obj.magic (List.nth (prime_implicants) (!rem)) : string)]);
  let j = ref (0) in
  (try while (!j < List.length (List.nth (!chart) (0))) do
    try
  if (List.nth (List.nth (!chart) (!rem)) (!j) = 1) then (
  let r2 = ref (0) in
  (try while (!r2 < List.length (!chart)) do
    try
  chart := (List.mapi (fun __i __x -> if __i = !r2 then (List.mapi (fun __i __x -> if __i = !j then 0 else __x) (List.nth (!chart) (!r2))) else __x) (!chart));
  r2 := (!r2 + 1);
    with Continue -> ()
  done with Break -> ());
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and count_char s ch =
  let __ret = ref 0 in
  (try
  let cnt = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (String.sub s (!i) ((!i + 1) - !i) = ch) then (
  cnt := (!cnt + 1);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!cnt) : int); raise Return
  with Return -> !__ret)

and prime_implicant_chart prime_implicants binary =
  let __ret = ref ([] : (int list) list) in
  (try
  let chart = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (prime_implicants)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length (binary)) do
    try
  row := (List.append (!row) [(Obj.magic (0) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  chart := (List.append (!chart) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  i := 0;
  (try while (!i < List.length (prime_implicants)) do
    try
  let count = count_char (List.nth (prime_implicants) (!i)) ("_") in
  let j = ref (0) in
  (try while (!j < List.length (binary)) do
    try
  if is_for_table (List.nth (prime_implicants) (!i)) (List.nth (binary) (!j)) (Obj.repr (count)) then (
  chart := (List.mapi (fun __i __x -> if __i = !i then (List.mapi (fun __i __x -> if __i = !j then 1 else __x) (List.nth (!chart) (!i))) else __x) (!chart));
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!chart) : int list list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let no_of_variable = 3 in
  let minterms = ref ([1; 5; 7]) in
  let binary = ref (decimal_to_binary (Obj.repr (no_of_variable)) (!minterms)) in
  let prime_implicants = ref (check (!binary)) in
  print_endline ("Prime Implicants are:");
  print_endline ((__str (!prime_implicants)));
  let chart = ref (prime_implicant_chart (!prime_implicants) (!binary)) in
  let essential_prime_implicants = ref (selection (chart) (!prime_implicants)) in
  print_endline ("Essential Prime Implicants are:");
  print_endline ((__str (!essential_prime_implicants)));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()