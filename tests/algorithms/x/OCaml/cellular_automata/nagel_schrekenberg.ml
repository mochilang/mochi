(* Generated by Mochi transpiler v0.10.59 on 2025-08-06 21:17 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let seed = ref (1)
let _neg_one = -(1)
let rec rand () =
  let __ret = ref 0 in
  (try
  seed := (((!seed * 1103515245) + 12345) mod 2147483648);
  __ret := (Obj.magic (!seed) : int); raise Return
  with Return -> !__ret)

and randint a b =
  let __ret = ref 0 in
  (try
  let a = (Obj.magic a : int) in
  let b = (Obj.magic b : int) in
  let r = rand () in
  __ret := (Obj.magic ((a + (r mod ((b - a) + 1)))) : int); raise Return
  with Return -> !__ret)

and random () =
  let __ret = ref 0.0 in
  (try
  __ret := (Obj.magic (((1.0 *. float_of_int (rand ())) /. 2147483648.0)) : float); raise Return
  with Return -> !__ret)

and construct_highway number_of_cells frequency initial_speed random_frequency random_speed max_speed =
  let __ret = ref ([] : (int list) list) in
  (try
  let number_of_cells = (Obj.magic number_of_cells : int) in
  let frequency = (Obj.magic frequency : int) in
  initial_speed := (Obj.magic !initial_speed : int);
  let max_speed = (Obj.magic max_speed : int) in
  let row = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < number_of_cells) do
    try
  row := (List.append (!row) [(Obj.magic (-(1)) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let highway = ref (([] : (int list) list)) in
  highway := (List.append (!highway) [(Obj.magic (!row) : int list)]);
  i := 0;
  if (!initial_speed < 0) then (
  initial_speed := 0;
  );
  (try while (!i < number_of_cells) do
    try
  let speed = ref (!initial_speed) in
  if random_speed then (
  speed := randint (Obj.repr (0)) (Obj.repr (max_speed));
  );
  highway := (List.mapi (fun __i __x -> if __i = 0 then (List.mapi (fun __i __x -> if __i = !i then !speed else __x) (List.nth (!highway) (0))) else __x) (!highway));
  let step = ref (frequency) in
  if random_frequency then (
  step := randint (Obj.repr (1)) (Obj.repr ((max_speed * 2)));
  );
  i := (!i + !step);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!highway) : int list list); raise Return
  with Return -> !__ret)

and get_distance highway_now car_index =
  let __ret = ref 0 in
  (try
  let car_index = (Obj.magic car_index : int) in
  let distance = ref (0) in
  let i = ref ((car_index + 1)) in
  (try while (!i < List.length (highway_now)) do
    try
  if (List.nth (highway_now) (!i) > _neg_one) then (
  __ret := (Obj.magic (!distance) : int); raise Return
  );
  distance := (!distance + 1);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!distance + get_distance (highway_now) (Obj.repr (-(1))))) : int); raise Return
  with Return -> !__ret)

and update highway_now probability max_speed =
  let __ret = ref ([] : (int) list) in
  (try
  let probability = (Obj.magic probability : float) in
  let max_speed = (Obj.magic max_speed : int) in
  let number_of_cells = List.length (highway_now) in
  let next_highway = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < number_of_cells) do
    try
  next_highway := (List.append (!next_highway) [(Obj.magic (-(1)) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let car_index = ref (0) in
  (try while (!car_index < number_of_cells) do
    try
  let speed = List.nth (highway_now) (!car_index) in
  if (speed > _neg_one) then (
  let new_speed = ref ((speed + 1)) in
  if (!new_speed > max_speed) then (
  new_speed := max_speed;
  );
  let dn = (get_distance (highway_now) (Obj.repr (!car_index)) - 1) in
  if (!new_speed > dn) then (
  new_speed := dn;
  );
  if (random () < probability) then (
  new_speed := (!new_speed - 1);
  if (!new_speed < 0) then (
  new_speed := 0;
  );
  );
  next_highway := (List.mapi (fun __i __x -> if __i = !car_index then !new_speed else __x) (!next_highway));
  );
  car_index := (!car_index + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!next_highway) : int list); raise Return
  with Return -> !__ret)

and simulate highway number_of_update probability max_speed =
  let __ret = ref ([] : (int list) list) in
  (try
  let number_of_update = (Obj.magic number_of_update : int) in
  let probability = (Obj.magic probability : float) in
  let max_speed = (Obj.magic max_speed : int) in
  let number_of_cells = List.length (List.nth (!highway) (0)) in
  let i = ref (0) in
  (try while (!i < number_of_update) do
    try
  let next_speeds = ref (update (List.nth (!highway) (!i)) (Obj.repr (probability)) (Obj.repr (max_speed))) in
  let real_next = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < number_of_cells) do
    try
  real_next := (List.append (!real_next) [(Obj.magic (-(1)) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  let k = ref (0) in
  (try while (!k < number_of_cells) do
    try
  let speed = List.nth (!next_speeds) (!k) in
  if (speed > _neg_one) then (
  let index = ((!k + speed) mod number_of_cells) in
  real_next := (List.mapi (fun __i __x -> if __i = index then speed else __x) (!real_next));
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  highway := (List.append (!highway) [(Obj.magic (!real_next) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!highway) : int list list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let ex1 = ref (simulate (ref (construct_highway (Obj.repr (6)) (Obj.repr (3)) (ref (0)) (false) (false) (Obj.repr (2)))) (Obj.repr (2)) (Obj.repr (0.0)) (Obj.repr (2))) in
  print_endline ((__str (!ex1)));
  let ex2 = ref (simulate (ref (construct_highway (Obj.repr (5)) (Obj.repr (2)) (ref (-(2))) (false) (false) (Obj.repr (2)))) (Obj.repr (3)) (Obj.repr (0.0)) (Obj.repr (2))) in
  print_endline ((__str (!ex2)));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()