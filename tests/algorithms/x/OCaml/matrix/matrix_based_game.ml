(* Generated by Mochi transpiler v0.10.64 on 2025-08-12 09:13 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic v : int) = 0
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec is_alnum ch =
  let __ret = ref false in
  (try
  __ret := (Obj.magic (((((ch >= "0") && (ch <= "9")) || ((ch >= "A") && (ch <= "Z"))) || ((ch >= "a") && (ch <= "z")))) : bool); raise Return
  with Return -> !__ret)

and to_int token =
  let __ret = ref 0 in
  (try
  let res = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (token)) do
    try
  res := ((!res * 10) + ((Char.code (String.get (token) !i)) - 48));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int); raise Return
  with Return -> !__ret)

and split s sep =
  let __ret = ref ([] : (string) list) in
  (try
  let res = ref (([] : (string) list)) in
  let current = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  let ch = (let __s = s in let __st = !i in let __en = (!i + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  if (ch = sep) then (
  res := (Obj.magic (List.append (!res) [(Obj.magic (!current) : string)]) : string list);
  current := "";
  ) else (
  current := (!current ^ ch);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!current) : string)]) : string list);
  __ret := (Obj.magic (!res) : string list); raise Return
  with Return -> !__ret)

and parse_moves input_str =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let pairs = ref (split (input_str) (",")) in
  let moves = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!pairs)) do
    try
  let pair = (let __l = !pairs in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  let numbers = ref (([] : (string) list)) in
  let num = ref ("") in
  let j = ref (0) in
  (try while (!j < String.length (pair)) do
    try
  let ch = (let __s = pair in let __st = !j in let __en = (!j + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  if (ch = " ") then (
  if (!num <> "") then (
  numbers := (Obj.magic (List.append (!numbers) [(Obj.magic (!num) : string)]) : string list);
  num := "";
  );
  ) else (
  num := (!num ^ ch);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if (!num <> "") then (
  numbers := (Obj.magic (List.append (!numbers) [(Obj.magic (!num) : string)]) : string list);
  );
  if (List.length (!numbers) <> 2) then (
  (failwith ("Each move must have exactly two numbers."));
  );
  let x = to_int ((let __l = !numbers in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  let y = to_int ((let __l = !numbers in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  moves := (Obj.magic (List.append (!moves) [(Obj.magic ([(__str ("x"), Obj.repr (x)); (__str ("y"), Obj.repr (y))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!moves) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and validate_matrix_size size =
  let __ret = ref (Obj.magic 0) in
  (try
  let size = (Obj.magic size : int) in
  if (size <= 0) then (
  (failwith ("Matrix size must be a positive integer."));
  );
    !__ret
  with Return -> !__ret)

and validate_matrix_content matrix size =
  let __ret = ref (Obj.magic 0) in
  (try
  let matrix = (Obj.magic matrix : string list) in
  let size = (Obj.magic size : int) in
  if (List.length (matrix) <> size) then (
  (failwith ("The matrix dont match with size."));
  );
  let i = ref (0) in
  (try while (!i < size) do
    try
  let row = (let __l = matrix in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  if (String.length (row) <> size) then (
  (failwith ((("Each row in the matrix must have exactly " ^ (string_of_int (size))) ^ " characters.")));
  );
  let j = ref (0) in
  (try while (!j < size) do
    try
  let ch = (let __s = row in let __st = !j in let __en = (!j + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  if not (is_alnum (ch)) then (
  (failwith ("Matrix rows can only contain letters and numbers."));
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and validate_moves moves size =
  let __ret = ref (Obj.magic 0) in
  (try
  let moves = (Obj.magic moves : (string * Obj.t) list list) in
  let size = (Obj.magic size : int) in
  let i = ref (0) in
  (try while (!i < List.length (moves)) do
    try
  let mv = ref ((let __l = moves in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  if (((((Obj.obj (List.assoc (__str ("x")) (!mv) : Obj.t) : int) < 0) || ((Obj.obj (List.assoc (__str ("x")) (!mv) : Obj.t) : int) >= size)) || ((Obj.obj (List.assoc (__str ("y")) (!mv) : Obj.t) : int) < 0)) || ((Obj.obj (List.assoc (__str ("y")) (!mv) : Obj.t) : int) >= size)) then (
  (failwith ("Move is out of bounds for a matrix."));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and contains pos r c =
  let __ret = ref false in
  (try
  let pos = (Obj.magic pos : (string * Obj.t) list list) in
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let i = ref (0) in
  (try while (!i < List.length (pos)) do
    try
  let p = ref ((let __l = pos in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  if (((Obj.obj (List.assoc (__str ("x")) (!p) : Obj.t) : int) = r) && ((Obj.obj (List.assoc (__str ("y")) (!p) : Obj.t) : int) = c)) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and find_repeat matrix_g row column size =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let matrix_g = (Obj.magic matrix_g : string list list) in
  let row = (Obj.magic row : int) in
  column := (Obj.magic !column : int);
  let size = (Obj.magic size : int) in
  column := ((size - 1) - !column);
  let visited = ref (([] : ((string * Obj.t) list) list)) in
  let repeated = ref (([] : ((string * Obj.t) list) list)) in
  let color = (let __l = (let __l = matrix_g in let __i = !column in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = row in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  if (color = "-") then (
  __ret := (Obj.magic (!repeated) : (string * Obj.t) list list); raise Return
  );
  let stack = ref ([[(__str ("x"), Obj.repr (!column)); (__str ("y"), Obj.repr (row))]]) in
  (try while (List.length (!stack) > 0) do
    try
  let idx = (List.length (!stack) - 1) in
  let pos = ref ((let __l = !stack in let __i = idx in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  stack := (Obj.magic List.of_seq (Seq.take (idx - 0) (Seq.drop 0 (List.to_seq (!stack)))) : (string * Obj.t) list list);
  if (((((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int) < 0) || ((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int) >= size)) || ((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int) < 0)) || ((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int) >= size)) then (
  raise Continue;
  );
  if contains (!visited) (Obj.repr ((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int))) (Obj.repr ((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int))) then (
  raise Continue;
  );
  visited := (Obj.magic (List.append (!visited) [(Obj.magic (!pos) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  if ((let __l = (let __l = matrix_g in let __i = (Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int) in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = (Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int) in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) = color) then (
  repeated := (Obj.magic (List.append (!repeated) [(Obj.magic (!pos) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  stack := (Obj.magic (List.append (!stack) [(Obj.magic ([(__str ("x"), Obj.repr (((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int) - 1))); (__str ("y"), Obj.repr ((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int)))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  stack := (Obj.magic (List.append (!stack) [(Obj.magic ([(__str ("x"), Obj.repr (((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int) + 1))); (__str ("y"), Obj.repr ((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int)))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  stack := (Obj.magic (List.append (!stack) [(Obj.magic ([(__str ("x"), Obj.repr ((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int))); (__str ("y"), Obj.repr (((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int) - 1)))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  stack := (Obj.magic (List.append (!stack) [(Obj.magic ([(__str ("x"), Obj.repr ((Obj.obj (List.assoc (__str ("x")) (!pos) : Obj.t) : int))); (__str ("y"), Obj.repr (((Obj.obj (List.assoc (__str ("y")) (!pos) : Obj.t) : int) + 1)))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!repeated) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and increment_score count =
  let __ret = ref 0 in
  (try
  let count = (Obj.magic count : int) in
  __ret := (Obj.magic (((count * (count + 1)) / 2)) : int); raise Return
  with Return -> !__ret)

and move_x matrix_g column size =
  let __ret = ref ([] : (string list) list) in
  (try
  matrix_g := (Obj.magic !matrix_g : string list list);
  let column = (Obj.magic column : int) in
  let size = (Obj.magic size : int) in
  let new_list = ref (([] : (string) list)) in
  let row = ref (0) in
  (try while (!row < size) do
    try
  let val_ = (let __l = (let __l = !matrix_g in let __i = !row in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = column in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  if (val_ <> "-") then (
  new_list := (Obj.magic (List.append (!new_list) [(Obj.magic (val_) : string)]) : string list);
  ) else (
  new_list := (Obj.magic ([val_] @ !new_list) : string list);
  );
  row := (!row + 1);
    with Continue -> ()
  done with Break -> ());
  row := 0;
  (try while (!row < size) do
    try
  matrix_g := (List.mapi (fun __i __x -> if __i = !row then (List.mapi (fun __i __x -> if __i = column then (let __l = !new_list in let __i = !row in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) else __x) ((let __l = !matrix_g in let __i = !row in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) else __x) (!matrix_g));
  row := (!row + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!matrix_g) : string list list); raise Return
  with Return -> !__ret)

and move_y matrix_g size =
  let __ret = ref ([] : (string list) list) in
  (try
  matrix_g := (Obj.magic !matrix_g : string list list);
  let size = (Obj.magic size : int) in
  let empty_cols = ref (([] : (int) list)) in
  let column = ref ((size - 1)) in
  (try while (!column >= 0) do
    try
  let row = ref (0) in
  let all_empty = ref (true) in
  (try while (!row < size) do
    try
  if ((let __l = (let __l = !matrix_g in let __i = !row in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !column in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) <> "-") then (
  all_empty := false;
  raise Break;
  );
  row := (!row + 1);
    with Continue -> ()
  done with Break -> ());
  if !all_empty then (
  empty_cols := (Obj.magic (List.append (!empty_cols) [(Obj.magic (!column) : int)]) : int list);
  );
  column := (!column - 1);
    with Continue -> ()
  done with Break -> ());
  let i = ref (0) in
  (try while (!i < List.length (!empty_cols)) do
    try
  let col = (let __l = !empty_cols in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  let c = ref ((col + 1)) in
  (try while (!c < size) do
    try
  let r = ref (0) in
  (try while (!r < size) do
    try
  matrix_g := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = (!c - 1) then (let __l = (let __l = !matrix_g in let __i = !r in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !c in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) else __x) ((let __l = !matrix_g in let __i = !r in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) else __x) (!matrix_g));
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  let r = ref (0) in
  (try while (!r < size) do
    try
  matrix_g := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = (size - 1) then "-" else __x) ((let __l = !matrix_g in let __i = !r in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) else __x) (!matrix_g));
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!matrix_g) : string list list); raise Return
  with Return -> !__ret)

and play matrix_g pos_x pos_y size =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  matrix_g := (Obj.magic !matrix_g : string list list);
  let pos_x = (Obj.magic pos_x : int) in
  let pos_y = (Obj.magic pos_y : int) in
  let size = (Obj.magic size : int) in
  let same_colors = ref (find_repeat (!matrix_g) (Obj.repr (pos_x)) (ref (pos_y)) (Obj.repr (size))) in
  if (List.length (!same_colors) <> 0) then (
  let i = ref (0) in
  (try while (!i < List.length (!same_colors)) do
    try
  let p = (let __l = !same_colors in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  matrix_g := (List.mapi (fun __i __x -> if __i = (Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) then (List.mapi (fun __i __x -> if __i = (Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) then "-" else __x) ((let __l = !matrix_g in let __i = (Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) else __x) (!matrix_g));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let column = ref (0) in
  (try while (!column < size) do
    try
  matrix_g := (Obj.magic move_x (matrix_g) (Obj.repr (!column)) (Obj.repr (size)) : string list list);
  column := (!column + 1);
    with Continue -> ()
  done with Break -> ());
  matrix_g := (Obj.magic move_y (matrix_g) (Obj.repr (size)) : string list list);
  );
  let sc = increment_score (Obj.repr (List.length (!same_colors))) in
  __ret := (Obj.magic ([(__str ("matrix"), Obj.repr (!matrix_g)); (__str ("score"), Obj.repr (sc))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and build_matrix matrix =
  let __ret = ref ([] : (string list) list) in
  (try
  let matrix = (Obj.magic matrix : string list) in
  let res = ref (([] : (string list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (matrix)) do
    try
  let row = (let __l = matrix in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in
  let row_list = ref (([] : (string) list)) in
  let j = ref (0) in
  (try while (!j < String.length (row)) do
    try
  row_list := (Obj.magic (List.append (!row_list) [(Obj.magic ((let __s = row in let __st = !j in let __en = (!j + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st))) : string)]) : string list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!row_list) : string list)]) : string list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string list list); raise Return
  with Return -> !__ret)

and process_game size matrix moves =
  let __ret = ref 0 in
  (try
  let size = (Obj.magic size : int) in
  let matrix = (Obj.magic matrix : string list) in
  let moves = (Obj.magic moves : (string * Obj.t) list list) in
  let game_matrix = ref (build_matrix (matrix)) in
  let total = ref (0) in
  let i = ref (0) in
  (try while (!i < List.length (moves)) do
    try
  let mv = ref ((let __l = moves in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  let res = play (game_matrix) (Obj.repr ((Obj.obj (List.assoc (__str ("x")) (!mv) : Obj.t) : int))) (Obj.repr ((Obj.obj (List.assoc (__str ("y")) (!mv) : Obj.t) : int))) (Obj.repr (size)) in
  game_matrix := (Obj.magic (Obj.obj (List.assoc (__str ("matrix")) (res) : Obj.t) : string list list) : string list list);
  total := (!total + (Obj.obj (List.assoc (__str ("score")) (res) : Obj.t) : int));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!total) : int); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let size = 4 in
  let matrix = ref (["RRBG"; "RBBG"; "YYGG"; "XYGG"]) in
  let moves = ref (parse_moves ("0 1,1 1")) in
  ignore (validate_matrix_size (Obj.repr (size)));
  ignore (validate_matrix_content (!matrix) (Obj.repr (size)));
  ignore (validate_moves ((Obj.magic !moves : (string * Obj.t) list list)) (Obj.repr (size)));
  let score = process_game (Obj.repr (size)) (!matrix) ((Obj.magic !moves : (string * Obj.t) list list)) in
  print_endline ((string_of_int (score)));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
