(* Generated by Mochi transpiler v0.10.67 on 2025-08-17 13:24 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec make_matrix values =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let values = (Obj.magic values : float list list) in
  let r = List.length (values) in
  if (r = 0) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let c = List.length ((let __l = values in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let i = ref (0) in
  (try while (!i < r) do
    try
  if (List.length ((let __l = values in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) <> c) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (values)); (__str ("rows"), Obj.repr (r)); (__str ("cols"), Obj.repr (c))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_columns m =
  let __ret = ref ([] : (float list) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let cols = ref (([] : (float list) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let col = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  col := (Obj.magic ((List.append (!col) [(Obj.magic ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float)])) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  cols := (Obj.magic ((List.append (!cols) [(Obj.magic (!col) : float list)])) : float list list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!cols) : float list list); raise Return
  with Return -> !__ret)

and matrix_identity m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let v = if (!i = !j) then 1.0 else 0.0 in
  row := (Obj.magic ((List.append (!row) [(Obj.magic (v) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_minor m r c =
  let __ret = ref 0.0 in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  if (!i <> r) then (
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  if (!j <> c) then (
  row := (Obj.magic ((List.append (!row) [(Obj.magic ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float)])) : float list);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let sub = ref ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr (((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) - 1))); (__str ("cols"), Obj.repr (((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) - 1)))]) in
  __ret := (Obj.magic (matrix_determinant (!sub)) : float); raise Return
  with Return -> !__ret)

and matrix_cofactor m r c =
  let __ret = ref 0.0 in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let minor = matrix_minor ((Obj.magic (m) : (string * Obj.t) list)) (Obj.repr (r)) (Obj.repr (c)) in
  if ((((r + c) mod 2 + 2) mod 2) = 0) then (
  __ret := (Obj.magic (minor) : float); raise Return
  );
  __ret := (Obj.magic (((-.(1.0)) *. minor)) : float); raise Return
  with Return -> !__ret)

and matrix_minors m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (matrix_minor ((Obj.magic (m) : (string * Obj.t) list)) (Obj.repr (!i)) (Obj.repr (!j))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_cofactors m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (matrix_cofactor ((Obj.magic (m) : (string * Obj.t) list)) (Obj.repr (!i)) (Obj.repr (!j))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_determinant m =
  let __ret = ref 0.0 in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  if ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) <> (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  if ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) = 0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  if ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) = 1) then (
  __ret := (Obj.magic ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 0 in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float); raise Return
  );
  if ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) = 2) then (
  __ret := (Obj.magic ((((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 0 in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = 1 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 1 in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) -. ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 1 in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = 1 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 0 in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)))) : float); raise Return
  );
  let sum = ref (0.0) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  sum := (!sum +. ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. matrix_cofactor ((Obj.magic (m) : (string * Obj.t) list)) (Obj.repr (0)) (Obj.repr (!j))));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and matrix_is_invertible m =
  let __ret = ref false in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  __ret := (Obj.magic ((matrix_determinant ((Obj.magic (m) : (string * Obj.t) list)) <> 0.0)) : bool); raise Return
  with Return -> !__ret)

and matrix_adjugate m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let cof = ref (matrix_cofactors ((Obj.magic (m) : (string * Obj.t) list))) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (!cof) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_inverse m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let det = matrix_determinant ((Obj.magic (m) : (string * Obj.t) list)) in
  if (det = 0.0) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let adj = ref (matrix_adjugate ((Obj.magic (m) : (string * Obj.t) list))) in
  __ret := (Obj.magic (matrix_mul_scalar (!adj) (Obj.repr ((1.0 /. det)))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_add_row m row =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let row = (Obj.magic row : float list) in
  let newData = ref ((match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> [])) in
  newData := (Obj.magic ((List.append (!newData) [(Obj.magic (row) : float list)])) : float list list);
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!newData)); (__str ("rows"), Obj.repr (((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + 1))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_add_column m col =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let col = (Obj.magic col : float list) in
  let newData = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  newData := (Obj.magic ((List.append (!newData) [(Obj.magic ((List.append ((let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) [(Obj.magic ((let __l = col in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float)])) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!newData)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr (((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + 1)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_mul_scalar m s =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let s = (Obj.magic s : float) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. s)) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_neg m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  __ret := (Obj.magic (matrix_mul_scalar ((Obj.magic (m) : (string * Obj.t) list)) (Obj.repr ((-.(1.0))))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_add a b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  if (((match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) <> (match List.assoc_opt (__str ("rows")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) || ((match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) <> (match List.assoc_opt (__str ("cols")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (((let __l = (let __l = (match List.assoc_opt (__str ("data")) (a) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) +. (let __l = (let __l = (match List.assoc_opt (__str ("data")) (b) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_sub a b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  if (((match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) <> (match List.assoc_opt (__str ("rows")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) || ((match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) <> (match List.assoc_opt (__str ("cols")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (((let __l = (let __l = (match List.assoc_opt (__str ("data")) (a) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) -. (let __l = (let __l = (match List.assoc_opt (__str ("data")) (b) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_dot row col =
  let __ret = ref 0.0 in
  (try
  let row = (Obj.magic row : float list) in
  let col = (Obj.magic col : float list) in
  let sum = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (row)) do
    try
  sum := (!sum +. ((let __l = row in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.) *. (let __l = col in let __i = !i in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and matrix_mul a b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  if ((match List.assoc_opt (__str ("cols")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) <> (match List.assoc_opt (__str ("rows")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let bcols = ref (matrix_columns ((Obj.magic (b) : (string * Obj.t) list))) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (matrix_dot ((let __l = (match List.assoc_opt (__str ("data")) (a) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) ((let __l = !bcols in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []))) : float)])) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic ((List.append (!vals) [(Obj.magic (!row) : float list)])) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((match List.assoc_opt (__str ("rows")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))); (__str ("cols"), Obj.repr ((match List.assoc_opt (__str ("cols")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_pow m p =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let p = (Obj.magic p : int) in
  if (p = 0) then (
  __ret := (Obj.magic (matrix_identity ((Obj.magic (m) : (string * Obj.t) list))) : (string * Obj.t) list); raise Return
  );
  if (p < 0) then (
  if matrix_is_invertible ((Obj.magic (m) : (string * Obj.t) list)) then (
  __ret := (Obj.magic (matrix_pow (matrix_inverse ((Obj.magic (m) : (string * Obj.t) list))) (Obj.repr (-(p)))) : (string * Obj.t) list); raise Return
  );
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let result = ref (m) in
  let i = ref (1) in
  (try while (!i < p) do
    try
  result := matrix_mul ((Obj.magic (!result) : (string * Obj.t) list)) ((Obj.magic (m) : (string * Obj.t) list));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_to_string m =
  let __ret = ref "" in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  if ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) = 0) then (
  __ret := (Obj.magic ("[]") : string); raise Return
  );
  let s = ref ("[") in
  let i = ref (0) in
  (try while (!i < (match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  s := (!s ^ "[");
  let j = ref (0) in
  (try while (!j < (match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  s := (!s ^ (Printf.sprintf "%.16g" (Obj.magic ((let __l = (let __l = (match List.assoc_opt (__str ("data")) (m) with Some v -> (Obj.obj (v : Obj.t) : float list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !j in if __i < 0 then 0. else match List.nth_opt __l __i with Some v -> (Obj.magic v : float) | None -> 0.)) : float)));
  if (!j < ((match List.assoc_opt (__str ("cols")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) - 1)) then (
  s := (!s ^ " ");
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  if (!i < ((match List.assoc_opt (__str ("rows")) (m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) - 1)) then (
  s := (!s ^ "\n ");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let m = ref (make_matrix ([[1.0; 2.0; 3.0]; [4.0; 5.0; 6.0]; [7.0; 8.0; 9.0]])) in
  print_endline ((matrix_to_string (!m)));
  print_endline ((__str (Obj.magic (matrix_columns (!m)) : Obj.t)));
  print_endline ((((string_of_int (Obj.magic ((match List.assoc_opt (__str ("rows")) (!m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) : int)) ^ ",") ^ (string_of_int (Obj.magic ((match List.assoc_opt (__str ("cols")) (!m) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) : int))));
  print_endline ((string_of_bool (Obj.magic (matrix_is_invertible (!m)) : bool)));
  print_endline ((matrix_to_string (matrix_identity (!m))));
  print_endline ((Printf.sprintf "%.16g" (Obj.magic (matrix_determinant (!m)) : float)));
  print_endline ((matrix_to_string (matrix_minors (!m))));
  print_endline ((matrix_to_string (matrix_cofactors (!m))));
  print_endline ((matrix_to_string (matrix_adjugate (!m))));
  let m2 = ref (matrix_mul_scalar (!m) (Obj.repr (3.0))) in
  print_endline ((matrix_to_string (!m2)));
  print_endline ((matrix_to_string (matrix_add (!m) (!m2))));
  print_endline ((matrix_to_string (matrix_sub (!m) (!m2))));
  print_endline ((matrix_to_string (matrix_pow (!m) (Obj.repr (3)))));
  let m3 = ref (matrix_add_row (!m) ([10.0; 11.0; 12.0])) in
  print_endline ((matrix_to_string (!m3)));
  let m4 = ref (matrix_add_column (!m2) ([8.0; 16.0; 32.0])) in
  print_endline ((matrix_to_string (matrix_mul (!m3) (!m4))));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
