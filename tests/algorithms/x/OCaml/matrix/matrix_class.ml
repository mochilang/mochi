(* Generated by Mochi transpiler v0.10.64 on 2025-08-12 09:13 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic v : int) = 0
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec make_matrix values =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let values = (Obj.magic values : float list list) in
  let r = List.length (values) in
  if (r = 0) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let c = List.length ((let __l = values in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  let i = ref (0) in
  (try while (!i < r) do
    try
  if (List.length ((let __l = values in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) <> c) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (values)); (__str ("rows"), Obj.repr (r)); (__str ("cols"), Obj.repr (c))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_columns m =
  let __ret = ref ([] : (float list) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let cols = ref (([] : (float list) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  let col = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  col := (Obj.magic (List.append (!col) [(Obj.magic ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  cols := (Obj.magic (List.append (!cols) [(Obj.magic (!col) : float list)]) : float list list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!cols) : float list list); raise Return
  with Return -> !__ret)

and matrix_identity m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  let v = if (!i = !j) then 1.0 else 0.0 in
  row := (Obj.magic (List.append (!row) [(Obj.magic (v) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_minor m r c =
  let __ret = ref 0.0 in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  if (!i <> r) then (
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  if (!j <> c) then (
  row := (Obj.magic (List.append (!row) [(Obj.magic ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : float)]) : float list);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let sub = [(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr (((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) - 1))); (__str ("cols"), Obj.repr (((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int) - 1)))] in
  __ret := (Obj.magic (matrix_determinant (sub)) : float); raise Return
  with Return -> !__ret)

and matrix_cofactor m r c =
  let __ret = ref 0.0 in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let minor = matrix_minor ((Obj.magic m : (string * Obj.t) list)) (Obj.repr (r)) (Obj.repr (c)) in
  if ((((r + c) mod 2 + 2) mod 2) = 0) then (
  __ret := (Obj.magic (minor) : float); raise Return
  );
  __ret := (Obj.magic (((-.(1.0)) *. minor)) : float); raise Return
  with Return -> !__ret)

and matrix_minors m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (matrix_minor ((Obj.magic m : (string * Obj.t) list)) (Obj.repr (!i)) (Obj.repr (!j))) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_cofactors m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (matrix_cofactor ((Obj.magic m : (string * Obj.t) list)) (Obj.repr (!i)) (Obj.repr (!j))) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_determinant m =
  let __ret = ref 0.0 in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  if ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) <> (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  if ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) = 0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  if ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) = 1) then (
  __ret := (Obj.magic ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : float); raise Return
  );
  if ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) = 2) then (
  __ret := (Obj.magic ((((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) *. (let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) -. ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) *. (let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))))) : float); raise Return
  );
  let sum = ref (0.0) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  sum := (!sum +. ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) *. matrix_cofactor ((Obj.magic m : (string * Obj.t) list)) (Obj.repr (0)) (Obj.repr (!j))));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and matrix_is_invertible m =
  let __ret = ref false in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  __ret := (Obj.magic ((matrix_determinant ((Obj.magic m : (string * Obj.t) list)) <> 0.0)) : bool); raise Return
  with Return -> !__ret)

and matrix_adjugate m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let cof = matrix_cofactors ((Obj.magic m : (string * Obj.t) list)) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (cof) : Obj.t) : float list list) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_inverse m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let det = matrix_determinant ((Obj.magic m : (string * Obj.t) list)) in
  if (det = 0.0) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let adj = matrix_adjugate ((Obj.magic m : (string * Obj.t) list)) in
  __ret := (Obj.magic (matrix_mul_scalar (adj) (Obj.repr ((1.0 /. det)))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_add_row m row =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let row = (Obj.magic row : float list) in
  let newData = ref ((Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list)) in
  newData := (Obj.magic (List.append (!newData) [(Obj.magic (row) : float list)]) : float list list);
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!newData)); (__str ("rows"), Obj.repr (((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) + 1))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_add_column m col =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let col = (Obj.magic col : float list) in
  let newData = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  newData := (Obj.magic (List.append (!newData) [(Obj.magic ((List.append ((let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) [(Obj.magic ((let __l = col in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : float)])) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!newData)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))); (__str ("cols"), Obj.repr (((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int) + 1)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_mul_scalar m s =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let s = (Obj.magic s : float) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) *. s)) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_neg m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  __ret := (Obj.magic (matrix_mul_scalar ((Obj.magic m : (string * Obj.t) list)) (Obj.repr ((-.(1.0))))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_add a b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  if (((Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int) <> (Obj.obj (List.assoc (__str ("rows")) (b) : Obj.t) : int)) || ((Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int) <> (Obj.obj (List.assoc (__str ("cols")) (b) : Obj.t) : int))) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (a) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) +. (let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (b) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_sub a b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  if (((Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int) <> (Obj.obj (List.assoc (__str ("rows")) (b) : Obj.t) : int)) || ((Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int) <> (Obj.obj (List.assoc (__str ("cols")) (b) : Obj.t) : int))) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (a) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) -. (let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (b) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_dot row col =
  let __ret = ref 0.0 in
  (try
  let row = (Obj.magic row : float list) in
  let col = (Obj.magic col : float list) in
  let sum = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (row)) do
    try
  sum := (!sum +. ((let __l = row in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) *. (let __l = col in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and matrix_mul a b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  if ((Obj.obj (List.assoc (__str ("cols")) (a) : Obj.t) : int) <> (Obj.obj (List.assoc (__str ("rows")) (b) : Obj.t) : int)) then (
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let bcols = ref (matrix_columns ((Obj.magic b : (string * Obj.t) list))) in
  let vals = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int)) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (b) : Obj.t) : int)) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (matrix_dot ((let __l = (Obj.obj (List.assoc (__str ("data")) (a) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) ((let __l = !bcols in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  vals := (Obj.magic (List.append (!vals) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("data"), Obj.repr (!vals)); (__str ("rows"), Obj.repr ((Obj.obj (List.assoc (__str ("rows")) (a) : Obj.t) : int))); (__str ("cols"), Obj.repr ((Obj.obj (List.assoc (__str ("cols")) (b) : Obj.t) : int)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_pow m p =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  let p = (Obj.magic p : int) in
  if (p = 0) then (
  __ret := (Obj.magic (matrix_identity ((Obj.magic m : (string * Obj.t) list))) : (string * Obj.t) list); raise Return
  );
  if (p < 0) then (
  if matrix_is_invertible ((Obj.magic m : (string * Obj.t) list)) then (
  __ret := (Obj.magic (matrix_pow (matrix_inverse ((Obj.magic m : (string * Obj.t) list))) (Obj.repr (-(p)))) : (string * Obj.t) list); raise Return
  );
  __ret := (Obj.magic ([(__str ("data"), Obj.repr ([])); (__str ("rows"), Obj.repr (0)); (__str ("cols"), Obj.repr (0))]) : (string * Obj.t) list); raise Return
  );
  let result = ref (m) in
  let i = ref (1) in
  (try while (!i < p) do
    try
  result := matrix_mul ((Obj.magic !result : (string * Obj.t) list)) ((Obj.magic m : (string * Obj.t) list));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matrix_to_string m =
  let __ret = ref "" in
  (try
  let m = (Obj.magic m : (string * Obj.t) list) in
  if ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) = 0) then (
  __ret := (Obj.magic ("[]") : string); raise Return
  );
  let s = ref ("[") in
  let i = ref (0) in
  (try while (!i < (Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int)) do
    try
  s := (!s ^ "[");
  let j = ref (0) in
  (try while (!j < (Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)) do
    try
  s := (!s ^ (Printf.sprintf "%.16g" ((let __l = (let __l = (Obj.obj (List.assoc (__str ("data")) (m) : Obj.t) : float list list) in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))));
  if (!j < ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int) - 1)) then (
  s := (!s ^ " ");
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  if (!i < ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int) - 1)) then (
  s := (!s ^ "\n ");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let m = make_matrix ([[1.0; 2.0; 3.0]; [4.0; 5.0; 6.0]; [7.0; 8.0; 9.0]]) in
  print_endline ((matrix_to_string (m)));
  print_endline ((__str (Obj.magic (matrix_columns (m)) : Obj.t)));
  print_endline ((((string_of_int ((Obj.obj (List.assoc (__str ("rows")) (m) : Obj.t) : int))) ^ ",") ^ (string_of_int ((Obj.obj (List.assoc (__str ("cols")) (m) : Obj.t) : int)))));
  print_endline ((string_of_bool (matrix_is_invertible (m))));
  print_endline ((matrix_to_string (matrix_identity (m))));
  print_endline ((Printf.sprintf "%.16g" (matrix_determinant (m))));
  print_endline ((matrix_to_string (matrix_minors (m))));
  print_endline ((matrix_to_string (matrix_cofactors (m))));
  print_endline ((matrix_to_string (matrix_adjugate (m))));
  let m2 = matrix_mul_scalar (m) (Obj.repr (3.0)) in
  print_endline ((matrix_to_string (m2)));
  print_endline ((matrix_to_string (matrix_add (m) (m2))));
  print_endline ((matrix_to_string (matrix_sub (m) (m2))));
  print_endline ((matrix_to_string (matrix_pow (m) (Obj.repr (3)))));
  let m3 = matrix_add_row (m) ([10.0; 11.0; 12.0]) in
  print_endline ((matrix_to_string (m3)));
  let m4 = matrix_add_column (m2) ([8.0; 16.0; 32.0]) in
  print_endline ((matrix_to_string (matrix_mul (m3) (m4))));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
