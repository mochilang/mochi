(* Generated by Mochi transpiler v0.10.67 on 2025-08-17 13:24 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Return

let _pi = 3.141592653589793
let _sqrt5 = 2.23606797749979
let rec minf a b =
  let __ret = ref 0.0 in
  (try
  let a = (Obj.magic a : float) in
  let b = (Obj.magic b : float) in
  if (a < b) then (
  __ret := (Obj.magic (a) : float); raise Return
  );
  __ret := (Obj.magic (b) : float); raise Return
  with Return -> !__ret)

and maxf a b =
  let __ret = ref 0.0 in
  (try
  let a = (Obj.magic a : float) in
  let b = (Obj.magic b : float) in
  if (a > b) then (
  __ret := (Obj.magic (a) : float); raise Return
  );
  __ret := (Obj.magic (b) : float); raise Return
  with Return -> !__ret)

and vol_cube side_length =
  let __ret = ref 0.0 in
  (try
  let side_length = (Obj.magic side_length : float) in
  if (side_length < 0.0) then (
  (failwith ("vol_cube() only accepts non-negative values"));
  );
  __ret := (Obj.magic (((side_length *. side_length) *. side_length)) : float); raise Return
  with Return -> !__ret)

and vol_spherical_cap height radius =
  let __ret = ref 0.0 in
  (try
  let height = (Obj.magic height : float) in
  let radius = (Obj.magic radius : float) in
  if ((height < 0.0) || (radius < 0.0)) then (
  (failwith ("vol_spherical_cap() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((((((1.0 /. 3.0) *. _pi) *. height) *. height) *. ((3.0 *. radius) -. height))) : float); raise Return
  with Return -> !__ret)

and vol_sphere radius =
  let __ret = ref 0.0 in
  (try
  let radius = (Obj.magic radius : float) in
  if (radius < 0.0) then (
  (failwith ("vol_sphere() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((((((4.0 /. 3.0) *. _pi) *. radius) *. radius) *. radius)) : float); raise Return
  with Return -> !__ret)

and vol_spheres_intersect radius_1 radius_2 centers_distance =
  let __ret = ref 0.0 in
  (try
  let radius_1 = (Obj.magic radius_1 : float) in
  let radius_2 = (Obj.magic radius_2 : float) in
  let centers_distance = (Obj.magic centers_distance : float) in
  if (((radius_1 < 0.0) || (radius_2 < 0.0)) || (centers_distance < 0.0)) then (
  (failwith ("vol_spheres_intersect() only accepts non-negative values"));
  );
  if (centers_distance = 0.0) then (
  __ret := (Obj.magic (vol_sphere (Obj.repr (minf (Obj.repr (radius_1)) (Obj.repr (radius_2))))) : float); raise Return
  );
  let h1 = ((((radius_1 -. radius_2) +. centers_distance) *. ((radius_1 +. radius_2) -. centers_distance)) /. (2.0 *. centers_distance)) in
  let h2 = ((((radius_2 -. radius_1) +. centers_distance) *. ((radius_2 +. radius_1) -. centers_distance)) /. (2.0 *. centers_distance)) in
  __ret := (Obj.magic ((vol_spherical_cap (Obj.repr (h1)) (Obj.repr (radius_2)) +. vol_spherical_cap (Obj.repr (h2)) (Obj.repr (radius_1)))) : float); raise Return
  with Return -> !__ret)

and vol_spheres_union radius_1 radius_2 centers_distance =
  let __ret = ref 0.0 in
  (try
  let radius_1 = (Obj.magic radius_1 : float) in
  let radius_2 = (Obj.magic radius_2 : float) in
  let centers_distance = (Obj.magic centers_distance : float) in
  if (((radius_1 <= 0.0) || (radius_2 <= 0.0)) || (centers_distance < 0.0)) then (
  (failwith ("vol_spheres_union() only accepts non-negative values, non-zero radius"));
  );
  if (centers_distance = 0.0) then (
  __ret := (Obj.magic (vol_sphere (Obj.repr (maxf (Obj.repr (radius_1)) (Obj.repr (radius_2))))) : float); raise Return
  );
  __ret := (Obj.magic (((vol_sphere (Obj.repr (radius_1)) +. vol_sphere (Obj.repr (radius_2))) -. vol_spheres_intersect (Obj.repr (radius_1)) (Obj.repr (radius_2)) (Obj.repr (centers_distance)))) : float); raise Return
  with Return -> !__ret)

and vol_cuboid width height length =
  let __ret = ref 0.0 in
  (try
  let width = (Obj.magic width : float) in
  let height = (Obj.magic height : float) in
  let length = (Obj.magic length : float) in
  if (((width < 0.0) || (height < 0.0)) || (length < 0.0)) then (
  (failwith ("vol_cuboid() only accepts non-negative values"));
  );
  __ret := (Obj.magic (((width *. height) *. length)) : float); raise Return
  with Return -> !__ret)

and vol_cone area_of_base height =
  let __ret = ref 0.0 in
  (try
  let area_of_base = (Obj.magic area_of_base : float) in
  let height = (Obj.magic height : float) in
  if ((height < 0.0) || (area_of_base < 0.0)) then (
  (failwith ("vol_cone() only accepts non-negative values"));
  );
  __ret := (Obj.magic (((area_of_base *. height) /. 3.0)) : float); raise Return
  with Return -> !__ret)

and vol_right_circ_cone radius height =
  let __ret = ref 0.0 in
  (try
  let radius = (Obj.magic radius : float) in
  let height = (Obj.magic height : float) in
  if ((height < 0.0) || (radius < 0.0)) then (
  (failwith ("vol_right_circ_cone() only accepts non-negative values"));
  );
  __ret := (Obj.magic (((((_pi *. radius) *. radius) *. height) /. 3.0)) : float); raise Return
  with Return -> !__ret)

and vol_prism area_of_base height =
  let __ret = ref 0.0 in
  (try
  let area_of_base = (Obj.magic area_of_base : float) in
  let height = (Obj.magic height : float) in
  if ((height < 0.0) || (area_of_base < 0.0)) then (
  (failwith ("vol_prism() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((area_of_base *. height)) : float); raise Return
  with Return -> !__ret)

and vol_pyramid area_of_base height =
  let __ret = ref 0.0 in
  (try
  let area_of_base = (Obj.magic area_of_base : float) in
  let height = (Obj.magic height : float) in
  if ((height < 0.0) || (area_of_base < 0.0)) then (
  (failwith ("vol_pyramid() only accepts non-negative values"));
  );
  __ret := (Obj.magic (((area_of_base *. height) /. 3.0)) : float); raise Return
  with Return -> !__ret)

and vol_hemisphere radius =
  let __ret = ref 0.0 in
  (try
  let radius = (Obj.magic radius : float) in
  if (radius < 0.0) then (
  (failwith ("vol_hemisphere() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((((((radius *. radius) *. radius) *. _pi) *. 2.0) /. 3.0)) : float); raise Return
  with Return -> !__ret)

and vol_circular_cylinder radius height =
  let __ret = ref 0.0 in
  (try
  let radius = (Obj.magic radius : float) in
  let height = (Obj.magic height : float) in
  if ((height < 0.0) || (radius < 0.0)) then (
  (failwith ("vol_circular_cylinder() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((((radius *. radius) *. height) *. _pi)) : float); raise Return
  with Return -> !__ret)

and vol_hollow_circular_cylinder inner_radius outer_radius height =
  let __ret = ref 0.0 in
  (try
  let inner_radius = (Obj.magic inner_radius : float) in
  let outer_radius = (Obj.magic outer_radius : float) in
  let height = (Obj.magic height : float) in
  if (((inner_radius < 0.0) || (outer_radius < 0.0)) || (height < 0.0)) then (
  (failwith ("vol_hollow_circular_cylinder() only accepts non-negative values"));
  );
  if (outer_radius <= inner_radius) then (
  (failwith ("outer_radius must be greater than inner_radius"));
  );
  __ret := (Obj.magic (((_pi *. ((outer_radius *. outer_radius) -. (inner_radius *. inner_radius))) *. height)) : float); raise Return
  with Return -> !__ret)

and vol_conical_frustum height radius_1 radius_2 =
  let __ret = ref 0.0 in
  (try
  let height = (Obj.magic height : float) in
  let radius_1 = (Obj.magic radius_1 : float) in
  let radius_2 = (Obj.magic radius_2 : float) in
  if (((radius_1 < 0.0) || (radius_2 < 0.0)) || (height < 0.0)) then (
  (failwith ("vol_conical_frustum() only accepts non-negative values"));
  );
  __ret := (Obj.magic (((((1.0 /. 3.0) *. _pi) *. height) *. (((radius_1 *. radius_1) +. (radius_2 *. radius_2)) +. (radius_1 *. radius_2)))) : float); raise Return
  with Return -> !__ret)

and vol_torus torus_radius tube_radius =
  let __ret = ref 0.0 in
  (try
  let torus_radius = (Obj.magic torus_radius : float) in
  let tube_radius = (Obj.magic tube_radius : float) in
  if ((torus_radius < 0.0) || (tube_radius < 0.0)) then (
  (failwith ("vol_torus() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((((((2.0 *. _pi) *. _pi) *. torus_radius) *. tube_radius) *. tube_radius)) : float); raise Return
  with Return -> !__ret)

and vol_icosahedron tri_side =
  let __ret = ref 0.0 in
  (try
  let tri_side = (Obj.magic tri_side : float) in
  if (tri_side < 0.0) then (
  (failwith ("vol_icosahedron() only accepts non-negative values"));
  );
  __ret := (Obj.magic ((((((tri_side *. tri_side) *. tri_side) *. (3.0 +. _sqrt5)) *. 5.0) /. 12.0)) : float); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  print_endline ("Volumes:");
  print_endline (("Cube: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_cube (Obj.repr (2.0))) : float))));
  print_endline (("Cuboid: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_cuboid (Obj.repr (2.0)) (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Cone: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_cone (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Right Circular Cone: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_right_circ_cone (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Prism: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_prism (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Pyramid: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_pyramid (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Sphere: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_sphere (Obj.repr (2.0))) : float))));
  print_endline (("Hemisphere: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_hemisphere (Obj.repr (2.0))) : float))));
  print_endline (("Circular Cylinder: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_circular_cylinder (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Torus: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_torus (Obj.repr (2.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Conical Frustum: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_conical_frustum (Obj.repr (2.0)) (Obj.repr (2.0)) (Obj.repr (4.0))) : float))));
  print_endline (("Spherical cap: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_spherical_cap (Obj.repr (1.0)) (Obj.repr (2.0))) : float))));
  print_endline (("Spheres intersection: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_spheres_intersect (Obj.repr (2.0)) (Obj.repr (2.0)) (Obj.repr (1.0))) : float))));
  print_endline (("Spheres union: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_spheres_union (Obj.repr (2.0)) (Obj.repr (2.0)) (Obj.repr (1.0))) : float))));
  print_endline (("Hollow Circular Cylinder: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_hollow_circular_cylinder (Obj.repr (1.0)) (Obj.repr (2.0)) (Obj.repr (3.0))) : float))));
  print_endline (("Icosahedron: " ^ (Printf.sprintf "%.16g" (Obj.magic (vol_icosahedron (Obj.repr (2.5))) : float))));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
