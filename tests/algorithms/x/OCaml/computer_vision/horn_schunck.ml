(* Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:21 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec round_int x =
  let __ret = ref 0 in
  (try
  let x = (Obj.magic x : float) in
  if (x >= 0.0) then (
  __ret := (Obj.magic (int_of_float ((x +. 0.5))) : int); raise Return
  );
  __ret := (Obj.magic (int_of_float ((x -. 0.5))) : int); raise Return
  with Return -> !__ret)

and zeros rows cols =
  let __ret = ref ([] : (float list) list) in
  (try
  let rows = (Obj.magic rows : int) in
  let cols = (Obj.magic cols : int) in
  let res = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < rows) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < cols) do
    try
  row := (List.append (!row) [(Obj.magic (0.0) : float)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (List.append (!res) [(Obj.magic (!row) : float list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list list); raise Return
  with Return -> !__ret)

and warp image h_flow v_flow =
  let __ret = ref ([] : (float list) list) in
  (try
  let h = List.length (image) in
  let w = List.length (List.nth (image) (0)) in
  let out = ref (([] : (float list) list)) in
  let y = ref (0) in
  (try while (!y < h) do
    try
  let row = ref (([] : (float) list)) in
  let x = ref (0) in
  (try while (!x < w) do
    try
  let sx = (!x - round_int (Obj.repr (List.nth (List.nth (h_flow) (!y)) (!x)))) in
  let sy = (!y - round_int (Obj.repr (List.nth (List.nth (v_flow) (!y)) (!x)))) in
  if ((((sx >= 0) && (sx < w)) && (sy >= 0)) && (sy < h)) then (
  row := (List.append (!row) [(Obj.magic (List.nth (List.nth (image) (sy)) (sx)) : float)]);
  ) else (
  row := (List.append (!row) [(Obj.magic (0.0) : float)]);
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  out := (List.append (!out) [(Obj.magic (!row) : float list)]);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : float list list); raise Return
  with Return -> !__ret)

and convolve img ker =
  let __ret = ref ([] : (float list) list) in
  (try
  let h = List.length (img) in
  let w = List.length (List.nth (img) (0)) in
  let kh = List.length (ker) in
  let kw = List.length (List.nth (ker) (0)) in
  let py = (kh / 2) in
  let px = (kw / 2) in
  let out = ref (([] : (float list) list)) in
  let y = ref (0) in
  (try while (!y < h) do
    try
  let row = ref (([] : (float) list)) in
  let x = ref (0) in
  (try while (!x < w) do
    try
  let s = ref (0.0) in
  let ky = ref (0) in
  (try while (!ky < kh) do
    try
  let kx = ref (0) in
  (try while (!kx < kw) do
    try
  let iy = ((!y + !ky) - py) in
  let ix = ((!x + !kx) - px) in
  if ((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w)) then (
  s := (!s +. (List.nth (List.nth (img) (iy)) (ix) *. List.nth (List.nth (ker) (!ky)) (!kx)));
  );
  kx := (!kx + 1);
    with Continue -> ()
  done with Break -> ());
  ky := (!ky + 1);
    with Continue -> ()
  done with Break -> ());
  row := (List.append (!row) [(Obj.magic (!s) : float)]);
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  out := (List.append (!out) [(Obj.magic (!row) : float list)]);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : float list list); raise Return
  with Return -> !__ret)

and horn_schunck image0 image1 num_iter alpha =
  let __ret = ref ([] : (float list list) list) in
  (try
  let num_iter = (Obj.magic num_iter : int) in
  let alpha = (Obj.magic alpha : float) in
  let h = List.length (image0) in
  let w = List.length (List.nth (image0) (0)) in
  let u = ref (zeros (Obj.repr (h)) (Obj.repr (w))) in
  let v = ref (zeros (Obj.repr (h)) (Obj.repr (w))) in
  let kernel_x = ref ([[(-.(0.25)); 0.25]; [(-.(0.25)); 0.25]]) in
  let kernel_y = ref ([[(-.(0.25)); (-.(0.25))]; [0.25; 0.25]]) in
  let kernel_t = ref ([[0.25; 0.25]; [0.25; 0.25]]) in
  let laplacian = ref ([[0.0833333333333; 0.166666666667; 0.0833333333333]; [0.166666666667; 0.0; 0.166666666667]; [0.0833333333333; 0.166666666667; 0.0833333333333]]) in
  let it = ref (0) in
  (try while (!it < num_iter) do
    try
  let warped = ref (warp (image0) (!u) (!v)) in
  let dx1 = ref (convolve (!warped) (!kernel_x)) in
  let dx2 = ref (convolve (image1) (!kernel_x)) in
  let dy1 = ref (convolve (!warped) (!kernel_y)) in
  let dy2 = ref (convolve (image1) (!kernel_y)) in
  let dt1 = ref (convolve (!warped) (!kernel_t)) in
  let dt2 = ref (convolve (image1) (!kernel_t)) in
  let avg_u = ref (convolve (!u) (!laplacian)) in
  let avg_v = ref (convolve (!v) (!laplacian)) in
  let y = ref (0) in
  (try while (!y < h) do
    try
  let x = ref (0) in
  (try while (!x < w) do
    try
  let dx = (List.nth (List.nth (!dx1) (!y)) (!x) +. List.nth (List.nth (!dx2) (!y)) (!x)) in
  let dy = (List.nth (List.nth (!dy1) (!y)) (!x) +. List.nth (List.nth (!dy2) (!y)) (!x)) in
  let dt = (List.nth (List.nth (!dt1) (!y)) (!x) -. List.nth (List.nth (!dt2) (!y)) (!x)) in
  let au = List.nth (List.nth (!avg_u) (!y)) (!x) in
  let av = List.nth (List.nth (!avg_v) (!y)) (!x) in
  let numer = (((dx *. au) +. (dy *. av)) +. dt) in
  let denom = (((alpha *. alpha) +. (dx *. dx)) +. (dy *. dy)) in
  let upd = (numer /. denom) in
  u := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then (au -. (dx *. upd)) else __x) (List.nth (!u) (!y))) else __x) (!u));
  v := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then (av -. (dy *. upd)) else __x) (List.nth (!v) (!y))) else __x) (!v));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  it := (!it + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([!u; !v]) : float list list list); raise Return
  with Return -> !__ret)

and print_matrix mat =
  let __ret = ref (Obj.magic 0) in
  (try
  let y = ref (0) in
  (try while (!y < List.length (mat)) do
    try
  let row = ref (List.nth (mat) (!y)) in
  let x = ref (0) in
  let line = ref ("") in
  (try while (!x < List.length (!row)) do
    try
  line := (!line ^ (string_of_int (round_int (Obj.repr (List.nth (!row) (!x))))));
  if ((!x + 1) < List.length (!row)) then (
  line := (!line ^ " ");
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (!line);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let image0 = ref ([[0.0; 0.0; 2.0]; [0.0; 0.0; 2.0]]) in
  let image1 = ref ([[0.0; 2.0; 0.0]; [0.0; 2.0; 0.0]]) in
  let flows = ref (horn_schunck (!image0) (!image1) (Obj.repr (20)) (Obj.repr (0.1))) in
  let u = ref (List.nth (!flows) (0)) in
  let v = ref (List.nth (!flows) (1)) in
  ignore (print_matrix (!u));
  print_endline ("---");
  ignore (print_matrix (!v));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()