(* Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:21 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec update_image_and_anno all_img_list all_annos idxs output_size scale_range filter_scale =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let filter_scale = (Obj.magic filter_scale : float) in
  let height = List.nth (output_size) (0) in
  let width = List.nth (output_size) (1) in
  let output_img = ref (([] : (int list) list)) in
  let r = ref (0) in
  (try while (!r < height) do
    try
  let row = ref (([] : (int) list)) in
  let c = ref (0) in
  (try while (!c < width) do
    try
  row := (List.append (!row) [(Obj.magic (0) : int)]);
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  output_img := (List.append (!output_img) [(Obj.magic (!row) : int list)]);
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  let scale_x = ((List.nth (scale_range) (0) +. List.nth (scale_range) (1)) /. 2.0) in
  let scale_y = ((List.nth (scale_range) (0) +. List.nth (scale_range) (1)) /. 2.0) in
  let divid_point_x = (Obj.magic (scale_x *. float_of_int (width)) : int) in
  let divid_point_y = (Obj.magic (scale_y *. float_of_int (height)) : int) in
  let new_anno = ref (([] : (float list) list)) in
  let path_list = ref (([] : (string) list)) in
  let i = ref (0) in
  (try while (!i < List.length (idxs)) do
    try
  let index = List.nth (idxs) (!i) in
  let path = List.nth (all_img_list) (index) in
  path_list := (List.append (!path_list) [(Obj.magic (path) : string)]);
  let img_annos = ref (List.nth (all_annos) (index)) in
  if (!i = 0) then (
  let y0 = ref (0) in
  (try while (!y0 < divid_point_y) do
    try
  let x0 = ref (0) in
  (try while (!x0 < divid_point_x) do
    try
  output_img := (List.mapi (fun __i __x -> if __i = !y0 then (List.mapi (fun __i __x -> if __i = !x0 then (!i + 1) else __x) (List.nth (!output_img) (!y0))) else __x) (!output_img));
  x0 := (!x0 + 1);
    with Continue -> ()
  done with Break -> ());
  y0 := (!y0 + 1);
    with Continue -> ()
  done with Break -> ());
  let j0 = ref (0) in
  (try while (!j0 < List.length (!img_annos)) do
    try
  let bbox = ref (List.nth (!img_annos) (!j0)) in
  let xmin = (List.nth (!bbox) (1) *. scale_x) in
  let ymin = (List.nth (!bbox) (2) *. scale_y) in
  let xmax = (List.nth (!bbox) (3) *. scale_x) in
  let ymax = (List.nth (!bbox) (4) *. scale_y) in
  new_anno := (List.append (!new_anno) [(Obj.magic ([List.nth (!bbox) (0); xmin; ymin; xmax; ymax]) : float list)]);
  j0 := (!j0 + 1);
    with Continue -> ()
  done with Break -> ());
  ) else (
  if (!i = 1) then (
  let y1 = ref (0) in
  (try while (!y1 < divid_point_y) do
    try
  let x1 = ref (divid_point_x) in
  (try while (!x1 < width) do
    try
  output_img := (List.mapi (fun __i __x -> if __i = !y1 then (List.mapi (fun __i __x -> if __i = !x1 then (!i + 1) else __x) (List.nth (!output_img) (!y1))) else __x) (!output_img));
  x1 := (!x1 + 1);
    with Continue -> ()
  done with Break -> ());
  y1 := (!y1 + 1);
    with Continue -> ()
  done with Break -> ());
  let j1 = ref (0) in
  (try while (!j1 < List.length (!img_annos)) do
    try
  let bbox1 = ref (List.nth (!img_annos) (!j1)) in
  let xmin1 = (scale_x +. (List.nth (!bbox1) (1) *. (1.0 -. scale_x))) in
  let ymin1 = (List.nth (!bbox1) (2) *. scale_y) in
  let xmax1 = (scale_x +. (List.nth (!bbox1) (3) *. (1.0 -. scale_x))) in
  let ymax1 = (List.nth (!bbox1) (4) *. scale_y) in
  new_anno := (List.append (!new_anno) [(Obj.magic ([List.nth (!bbox1) (0); xmin1; ymin1; xmax1; ymax1]) : float list)]);
  j1 := (!j1 + 1);
    with Continue -> ()
  done with Break -> ());
  ) else (
  if (!i = 2) then (
  let y2 = ref (divid_point_y) in
  (try while (!y2 < height) do
    try
  let x2 = ref (0) in
  (try while (!x2 < divid_point_x) do
    try
  output_img := (List.mapi (fun __i __x -> if __i = !y2 then (List.mapi (fun __i __x -> if __i = !x2 then (!i + 1) else __x) (List.nth (!output_img) (!y2))) else __x) (!output_img));
  x2 := (!x2 + 1);
    with Continue -> ()
  done with Break -> ());
  y2 := (!y2 + 1);
    with Continue -> ()
  done with Break -> ());
  let j2 = ref (0) in
  (try while (!j2 < List.length (!img_annos)) do
    try
  let bbox2 = ref (List.nth (!img_annos) (!j2)) in
  let xmin2 = (List.nth (!bbox2) (1) *. scale_x) in
  let ymin2 = (scale_y +. (List.nth (!bbox2) (2) *. (1.0 -. scale_y))) in
  let xmax2 = (List.nth (!bbox2) (3) *. scale_x) in
  let ymax2 = (scale_y +. (List.nth (!bbox2) (4) *. (1.0 -. scale_y))) in
  new_anno := (List.append (!new_anno) [(Obj.magic ([List.nth (!bbox2) (0); xmin2; ymin2; xmax2; ymax2]) : float list)]);
  j2 := (!j2 + 1);
    with Continue -> ()
  done with Break -> ());
  ) else (
  let y3 = ref (divid_point_y) in
  (try while (!y3 < height) do
    try
  let x3 = ref (divid_point_x) in
  (try while (!x3 < width) do
    try
  output_img := (List.mapi (fun __i __x -> if __i = !y3 then (List.mapi (fun __i __x -> if __i = !x3 then (!i + 1) else __x) (List.nth (!output_img) (!y3))) else __x) (!output_img));
  x3 := (!x3 + 1);
    with Continue -> ()
  done with Break -> ());
  y3 := (!y3 + 1);
    with Continue -> ()
  done with Break -> ());
  let j3 = ref (0) in
  (try while (!j3 < List.length (!img_annos)) do
    try
  let bbox3 = ref (List.nth (!img_annos) (!j3)) in
  let xmin3 = (scale_x +. (List.nth (!bbox3) (1) *. (1.0 -. scale_x))) in
  let ymin3 = (scale_y +. (List.nth (!bbox3) (2) *. (1.0 -. scale_y))) in
  let xmax3 = (scale_x +. (List.nth (!bbox3) (3) *. (1.0 -. scale_x))) in
  let ymax3 = (scale_y +. (List.nth (!bbox3) (4) *. (1.0 -. scale_y))) in
  new_anno := (List.append (!new_anno) [(Obj.magic ([List.nth (!bbox3) (0); xmin3; ymin3; xmax3; ymax3]) : float list)]);
  j3 := (!j3 + 1);
    with Continue -> ()
  done with Break -> ());
  );
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (filter_scale > 0.0) then (
  let filtered = ref (([] : (float list) list)) in
  let k = ref (0) in
  (try while (!k < List.length (!new_anno)) do
    try
  let anno = ref (List.nth (!new_anno) (!k)) in
  let w = (List.nth (!anno) (3) -. List.nth (!anno) (1)) in
  let h = (List.nth (!anno) (4) -. List.nth (!anno) (2)) in
  if ((filter_scale < w) && (filter_scale < h)) then (
  filtered := (List.append (!filtered) [(Obj.magic (!anno) : float list)]);
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  new_anno := !filtered;
  );
  __ret := (Obj.magic ([(__str ("img"), Obj.repr (!output_img)); (__str ("annos"), Obj.repr (!new_anno)); (__str ("path"), Obj.repr (List.nth (!path_list) (0)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let all_img_list = ref (["img0.jpg"; "img1.jpg"; "img2.jpg"; "img3.jpg"]) in
  let all_annos = ref ([[[0.0; 0.1; 0.1; 0.4; 0.4]]; [[1.0; 0.2; 0.3; 0.5; 0.7]]; [[2.0; 0.6; 0.2; 0.9; 0.5]]; [[3.0; 0.5; 0.5; 0.8; 0.8]]]) in
  let idxs = ref ([0; 1; 2; 3]) in
  let output_size = ref ([100; 100]) in
  let scale_range = ref ([0.4; 0.6]) in
  let filter_scale = 0.05 in
  let res = update_image_and_anno (!all_img_list) (!all_annos) (!idxs) (!output_size) (!scale_range) (Obj.repr (filter_scale)) in
  let new_annos = ref ((Obj.obj (List.assoc (__str ("annos")) (res) : Obj.t) : float list list)) in
  let path = (Obj.obj (List.assoc (__str ("path")) (res) : Obj.t) : string) in
  print_endline (("Base image: " ^ path));
  print_endline (("Mosaic annotation count: " ^ (string_of_int (List.length (!new_annos)))));
  let i = ref (0) in
  (try while (!i < List.length (!new_annos)) do
    try
  let a = ref (List.nth (!new_annos) (!i)) in
  print_endline ((((((((((Printf.sprintf "%.16g" (List.nth (!a) (0))) ^ " ") ^ (Printf.sprintf "%.16g" (List.nth (!a) (1)))) ^ " ") ^ (Printf.sprintf "%.16g" (List.nth (!a) (2)))) ^ " ") ^ (Printf.sprintf "%.16g" (List.nth (!a) (3)))) ^ " ") ^ (Printf.sprintf "%.16g" (List.nth (!a) (4)))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()