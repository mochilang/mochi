(* Generated by Mochi transpiler v0.10.69 on 2025-08-22 13:05 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic r : int) = 0
  else
    match tag r with
    | 0 -> __is_list (field r 1)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let seed = ref (123456789)
let rec rand () =
  let __ret = ref 0 in
  (try
  seed := ((((!seed * 1103515245) + 12345) mod 2147483648 + 2147483648) mod 2147483648);
  __ret := (Obj.magic (!seed) : int); raise Return
  with Return -> !__ret)

and rand_range max =
  let __ret = ref 0 in
  (try
  let max = (Obj.magic max : int) in
  __ret := (Obj.magic (((rand () mod max + max) mod max)) : int); raise Return
  with Return -> !__ret)

and shuffle list_int =
  let __ret = ref ([] : (int) list) in
  (try
  list_int := (Obj.magic !list_int : int list);
  let i = ref ((List.length (!list_int) - 1)) in
  (try while (!i > 0) do
    try
  let j = rand_range (Obj.repr ((!i + 1))) in
  let tmp = (let __l = !list_int in let __i = !i in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  list_int := (List.mapi (fun __i __x -> if __i = !i then (let __l = !list_int in let __i = j in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) else __x) (!list_int));
  list_int := (List.mapi (fun __i __x -> if __i = j then tmp else __x) (!list_int));
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!list_int) : int list); raise Return
  with Return -> !__ret)

and rand_letter () =
  let __ret = ref "" in
  (try
  let letters = "abcdefghijklmnopqrstuvwxyz" in
  let i = rand_range (Obj.repr (26)) in
  __ret := (Obj.magic ((let __s = letters in let __st = i in let __len = ((i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")) : string); raise Return
  with Return -> !__ret)

and make_word_search words width height =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let words = (Obj.magic words : string list) in
  let width = (Obj.magic width : int) in
  let height = (Obj.magic height : int) in
  let board = ref (([] : (string list) list)) in
  let r = ref (0) in
  (try while (!r < height) do
    try
  let row = ref (([] : (string) list)) in
  let c = ref (0) in
  (try while (!c < width) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic ("") : string)])) : string list);
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  board := (Obj.magic ((List.append (!board) [(Obj.magic (!row) : string list)])) : string list list);
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str (Obj.repr ("words")), Obj.repr (words)); (__str (Obj.repr ("width")), Obj.repr (width)); (__str (Obj.repr ("height")), Obj.repr (height)); (__str (Obj.repr ("board")), Obj.repr (!board))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and insert_dir ws word dr dc rows cols =
  let __ret = ref false in
  (try
  let ws = (Obj.magic ws : (string * Obj.t) list) in
  let dr = (Obj.magic dr : int) in
  let dc = (Obj.magic dc : int) in
  let rows = (Obj.magic rows : int list) in
  let cols = (Obj.magic cols : int list) in
  let word_len = String.length (word) in
  let ri = ref (0) in
  (try while (!ri < List.length (rows)) do
    try
  let row = (let __l = rows in let __i = !ri in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let ci = ref (0) in
  (try while (!ci < List.length (cols)) do
    try
  let col = (let __l = cols in let __i = !ci in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let end_r = (row + (dr * (word_len - 1))) in
  let end_c = (col + (dc * (word_len - 1))) in
  if ((((end_r < 0) || (end_r >= (match List.assoc_opt (__str (Obj.repr ("height"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) || (end_c < 0)) || (end_c >= (match List.assoc_opt (__str (Obj.repr ("width"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) then (
  ci := (!ci + 1);
  raise Continue;
  );
  let k = ref (0) in
  let ok = ref (true) in
  (try while (!k < word_len) do
    try
  let rr = (row + (dr * !k)) in
  let cc = (col + (dc * !k)) in
  if ((let __l = (let __l = (match List.assoc_opt (__str (Obj.repr ("board"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : string list list) | None -> []) in let __i = rr in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = cc in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") <> "") then (
  ok := false;
  raise Break;
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  if !ok then (
  k := 0;
  (try while (!k < word_len) do
    try
  let rr2 = (row + (dr * !k)) in
  let cc2 = (col + (dc * !k)) in
  let row_list = ref ((let __l = (match List.assoc_opt (__str (Obj.repr ("board"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : string list list) | None -> []) in let __i = rr2 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  row_list := (List.mapi (fun __i __x -> if __i = cc2 then (let __s = word in let __st = !k in let __len = ((!k + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") else __x) (!row_list));
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  );
  ci := (!ci + 1);
    with Continue -> ()
  done with Break -> ());
  ri := (!ri + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and generate_board ws =
  let __ret = ref (Obj.magic 0) in
  (try
  let ws = (Obj.magic ws : (string * Obj.t) list) in
  let dirs_r = ref ([-(1); -(1); 0; 1; 1; 1; 0; -(1)]) in
  let dirs_c = ref ([0; 1; 1; 1; 0; -(1); -(1); -(1)]) in
  let i = ref (0) in
  (try while (!i < List.length ((match List.assoc_opt (__str (Obj.repr ("words"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []))) do
    try
  let word = (let __l = (match List.assoc_opt (__str (Obj.repr ("words"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []) in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  let rows = ref (([] : (int) list)) in
  let r = ref (0) in
  (try while (!r < (match List.assoc_opt (__str (Obj.repr ("height"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  rows := (Obj.magic ((List.append (!rows) [(Obj.magic (!r) : int)])) : int list);
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  let cols = ref (([] : (int) list)) in
  let c = ref (0) in
  (try while (!c < (match List.assoc_opt (__str (Obj.repr ("width"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  cols := (Obj.magic ((List.append (!cols) [(Obj.magic (!c) : int)])) : int list);
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  rows := (Obj.magic (shuffle (rows)) : int list);
  cols := (Obj.magic (shuffle (cols)) : int list);
  let d = rand_range (Obj.repr (8)) in
  ignore (insert_dir ((Obj.magic (ws) : (string * Obj.t) list)) (word) (Obj.repr ((let __l = !dirs_r in let __i = d in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0))) (Obj.repr ((let __l = !dirs_c in let __i = d in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0))) (!rows) (!cols));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and visualise ws add_fake_chars =
  let __ret = ref "" in
  (try
  let ws = (Obj.magic ws : (string * Obj.t) list) in
  let result = ref ("") in
  let r = ref (0) in
  (try while (!r < (match List.assoc_opt (__str (Obj.repr ("height"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let c = ref (0) in
  (try while (!c < (match List.assoc_opt (__str (Obj.repr ("width"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) do
    try
  let ch = ref ((let __l = (let __l = (match List.assoc_opt (__str (Obj.repr ("board"))) (ws) with Some v -> (Obj.obj (v : Obj.t) : string list list) | None -> []) in let __i = !r in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = !c in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) in
  if (!ch = "") then (
  if add_fake_chars then (
  ch := rand_letter ();
  ) else (
  ch := "#";
  );
  );
  result := ((!result ^ !ch) ^ " ");
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  result := (!result ^ "\n");
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let words = ref (["cat"; "dog"; "snake"; "fish"]) in
  let ws = ref (make_word_search (!words) (Obj.repr (10)) (Obj.repr (10))) in
  ignore (generate_board (!ws));
  print_endline ((visualise (!ws) (true)));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
