(* Generated by Mochi transpiler v0.10.62 on 2025-08-09 16:24 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __show_list (Obj.magic v) else __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __str_list (Obj.magic v) else __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _w1 = 1.0
let _w2 = 1.0
let n = 20
let n_heuristic = 3
let _inf = 1000000000.0
let t = ref (1)
let rec pos_equal a b =
  let __ret = ref false in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  __ret := (Obj.magic ((((Obj.obj (List.assoc (__str ("x")) (a) : Obj.t) : int) = (Obj.obj (List.assoc (__str ("x")) (b) : Obj.t) : int)) && ((Obj.obj (List.assoc (__str ("y")) (a) : Obj.t) : int) = (Obj.obj (List.assoc (__str ("y")) (b) : Obj.t) : int)))) : bool); raise Return
  with Return -> !__ret)

and pos_key p =
  let __ret = ref "" in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  __ret := (Obj.magic ((((string_of_int ((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int))) ^ ",") ^ (string_of_int ((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int))))) : string); raise Return
  with Return -> !__ret)

and sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x <= 0.0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  let guess = ref (x) in
  let i = ref (0) in
  (try while (!i < 10) do
    try
  guess := ((!guess +. (x /. !guess)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!guess) : float); raise Return
  with Return -> !__ret)

and consistent_heuristic p goal =
  let __ret = ref 0.0 in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let dx = float_of_int (((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) - (Obj.obj (List.assoc (__str ("x")) (goal) : Obj.t) : int))) in
  let dy = float_of_int (((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) - (Obj.obj (List.assoc (__str ("y")) (goal) : Obj.t) : int))) in
  __ret := (Obj.magic (sqrtApprox (Obj.repr (((dx *. dx) +. (dy *. dy))))) : float); raise Return
  with Return -> !__ret)

and iabs x =
  let __ret = ref 0 in
  (try
  let x = (Obj.magic x : int) in
  if (x < 0) then (
  __ret := (Obj.magic (-(x)) : int); raise Return
  );
  __ret := (Obj.magic (x) : int); raise Return
  with Return -> !__ret)

and heuristic_1 p goal =
  let __ret = ref 0.0 in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  __ret := (Obj.magic (float_of_int ((iabs (Obj.repr (((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) - (Obj.obj (List.assoc (__str ("x")) (goal) : Obj.t) : int)))) + iabs (Obj.repr (((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) - (Obj.obj (List.assoc (__str ("y")) (goal) : Obj.t) : int))))))) : float); raise Return
  with Return -> !__ret)

and heuristic_2 p goal =
  let __ret = ref 0.0 in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let h = consistent_heuristic ((Obj.magic p : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list)) in
  __ret := (Obj.magic ((h /. float_of_int (!t))) : float); raise Return
  with Return -> !__ret)

and heuristic i p goal =
  let __ret = ref 0.0 in
  (try
  let i = (Obj.magic i : int) in
  let p = (Obj.magic p : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  if (i = 0) then (
  __ret := (Obj.magic (consistent_heuristic ((Obj.magic p : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list))) : float); raise Return
  );
  if (i = 1) then (
  __ret := (Obj.magic (heuristic_1 ((Obj.magic p : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list))) : float); raise Return
  );
  __ret := (Obj.magic (heuristic_2 ((Obj.magic p : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list))) : float); raise Return
  with Return -> !__ret)

and key_fn start i goal g_func =
  let __ret = ref 0.0 in
  (try
  let start = (Obj.magic start : (string * Obj.t) list) in
  let i = (Obj.magic i : int) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let g_func = (Obj.magic g_func : (string * float) list) in
  let g = List.assoc (__str (pos_key ((Obj.magic start : (string * Obj.t) list)))) (g_func) in
  __ret := (Obj.magic ((g +. (_w1 *. heuristic (Obj.repr (i)) ((Obj.magic start : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list))))) : float); raise Return
  with Return -> !__ret)

and valid p =
  let __ret = ref false in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  if (((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) < 0) || ((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) > (n - 1))) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  if (((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) < 0) || ((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) > (n - 1))) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)


let blocks = ref ([[(__str ("x"), Obj.repr (0)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (1)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (2)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (3)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (4)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (5)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (6)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (7)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (8)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (9)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (10)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (11)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (12)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (13)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (14)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (15)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (16)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (17)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (18)); (__str ("y"), Obj.repr (1))]; [(__str ("x"), Obj.repr (19)); (__str ("y"), Obj.repr (1))]])
let rec in_blocks p =
  let __ret = ref false in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  let i = ref (0) in
  (try while (!i < List.length (!blocks)) do
    try
  if pos_equal (List.nth (!blocks) (!i)) ((Obj.magic p : (string * Obj.t) list)) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and pq_put pq node pri =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  pq := (Obj.magic !pq : (string * Obj.t) list list);
  let node = (Obj.magic node : (string * Obj.t) list) in
  let pri = (Obj.magic pri : float) in
  let updated = ref (false) in
  let i = ref (0) in
  (try while (!i < List.length (!pq)) do
    try
  if pos_equal ((Obj.magic (Obj.obj (List.assoc (__str ("pos")) (List.nth (!pq) (!i)) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list)) ((Obj.magic node : (string * Obj.t) list)) then (
  if (pri < (Obj.obj (List.assoc (__str ("pri")) (List.nth (!pq) (!i)) : Obj.t) : float)) then (
  pq := (List.mapi (fun __i __x -> if __i = !i then [(__str ("pos"), Obj.repr (node)); (__str ("pri"), Obj.repr (pri))] else __x) (!pq));
  );
  updated := true;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if not (!updated) then (
  pq := (Obj.magic (List.append (!pq) [(Obj.magic ([(__str ("pos"), Obj.repr (node)); (__str ("pri"), Obj.repr (pri))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  __ret := (Obj.magic (!pq) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and pq_minkey pq =
  let __ret = ref 0.0 in
  (try
  let pq = (Obj.magic pq : (string * Obj.t) list list) in
  if (List.length (pq) = 0) then (
  __ret := (Obj.magic (_inf) : float); raise Return
  );
  let first = ref (List.nth (pq) (0)) in
  let m = ref ((Obj.obj (List.assoc (__str ("pri")) (!first) : Obj.t) : float)) in
  let i = ref (1) in
  (try while (!i < List.length (pq)) do
    try
  let item = ref (List.nth (pq) (!i)) in
  if ((Obj.obj (List.assoc (__str ("pri")) (!item) : Obj.t) : float) < !m) then (
  m := (Obj.obj (List.assoc (__str ("pri")) (!item) : Obj.t) : float);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : float); raise Return
  with Return -> !__ret)

and pq_pop_min pq =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let pq = (Obj.magic pq : (string * Obj.t) list list) in
  let best = ref (List.nth (pq) (0)) in
  let idx = ref (0) in
  let i = ref (1) in
  (try while (!i < List.length (pq)) do
    try
  if ((Obj.obj (List.assoc (__str ("pri")) (List.nth (pq) (!i)) : Obj.t) : float) < (Obj.obj (List.assoc (__str ("pri")) (!best) : Obj.t) : float)) then (
  best := (Obj.magic List.nth (pq) (!i) : (string * Obj.t) list);
  idx := !i;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let new_pq = ref (([] : ((string * Obj.t) list) list)) in
  i := 0;
  (try while (!i < List.length (pq)) do
    try
  if (!i <> !idx) then (
  new_pq := (Obj.magic (List.append (!new_pq) [(Obj.magic (List.nth (pq) (!i)) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("pq"), Obj.repr (!new_pq)); (__str ("node"), Obj.repr (!best))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and pq_remove pq node =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let pq = (Obj.magic pq : (string * Obj.t) list list) in
  let node = (Obj.magic node : (string * Obj.t) list) in
  let new_pq = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (pq)) do
    try
  if not (pos_equal ((Obj.magic (Obj.obj (List.assoc (__str ("pos")) (List.nth (pq) (!i)) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list)) ((Obj.magic node : (string * Obj.t) list))) then (
  new_pq := (Obj.magic (List.append (!new_pq) [(Obj.magic (List.nth (pq) (!i)) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!new_pq) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and reconstruct back_pointer goal start =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let back_pointer = (Obj.magic back_pointer : (string * (string * Obj.t) list) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let start = (Obj.magic start : (string * Obj.t) list) in
  let path = ref (([] : ((string * Obj.t) list) list)) in
  let current = ref (goal) in
  let key = ref (pos_key ((Obj.magic !current : (string * Obj.t) list))) in
  path := (Obj.magic (List.append (!path) [(Obj.magic (!current) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  (try while not (pos_equal ((Obj.magic !current : (string * Obj.t) list)) ((Obj.magic start : (string * Obj.t) list))) do
    try
  current := (Obj.magic (Obj.obj (List.assoc (__str (!key)) (back_pointer) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list);
  key := pos_key ((Obj.magic !current : (string * Obj.t) list));
  path := (Obj.magic (List.append (!path) [(Obj.magic (!current) : (string * Obj.t) list)]) : (string * Obj.t) list list);
    with Continue -> ()
  done with Break -> ());
  let rev = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref ((List.length (!path) - 1)) in
  (try while (!i >= 0) do
    try
  rev := (Obj.magic (List.append (!rev) [(Obj.magic (List.nth (!path) (!i)) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!rev) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and neighbours p =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  let left = [(__str ("x"), Obj.repr (((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) - 1))); (__str ("y"), Obj.repr ((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int)))] in
  let right = [(__str ("x"), Obj.repr (((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int) + 1))); (__str ("y"), Obj.repr ((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int)))] in
  let up = [(__str ("x"), Obj.repr ((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int))); (__str ("y"), Obj.repr (((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) + 1)))] in
  let down = [(__str ("x"), Obj.repr ((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int))); (__str ("y"), Obj.repr (((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int) - 1)))] in
  __ret := (Obj.magic ([left; right; up; down]) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and multi_a_star start goal n_heuristic =
  let __ret = ref (Obj.magic 0) in
  (try
  let start = (Obj.magic start : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let n_heuristic = (Obj.magic n_heuristic : int) in
  let g_function = ref ([] : (string * float) list) in
  let back_pointer = ref ([] : (string * (string * Obj.t) list) list) in
  let visited = ref ([] : (string * bool) list) in
  let open_list = ref (([] : ((string * Obj.t) list list) list)) in
  g_function := ((__str (pos_key ((Obj.magic start : (string * Obj.t) list))), 0.0) :: List.remove_assoc (__str (pos_key ((Obj.magic start : (string * Obj.t) list)))) (!g_function));
  g_function := ((__str (pos_key ((Obj.magic goal : (string * Obj.t) list))), _inf) :: List.remove_assoc (__str (pos_key ((Obj.magic goal : (string * Obj.t) list)))) (!g_function));
  back_pointer := ((__str (pos_key ((Obj.magic start : (string * Obj.t) list))), Obj.repr ([(__str ("x"), Obj.repr (-(1))); (__str ("y"), Obj.repr (-(1)))])) :: List.remove_assoc (__str (pos_key ((Obj.magic start : (string * Obj.t) list)))) (Obj.magic (!back_pointer) : (string * Obj.t) list));
  back_pointer := ((__str (pos_key ((Obj.magic goal : (string * Obj.t) list))), Obj.repr ([(__str ("x"), Obj.repr (-(1))); (__str ("y"), Obj.repr (-(1)))])) :: List.remove_assoc (__str (pos_key ((Obj.magic goal : (string * Obj.t) list)))) (Obj.magic (!back_pointer) : (string * Obj.t) list));
  visited := ((__str (pos_key ((Obj.magic start : (string * Obj.t) list))), true) :: List.remove_assoc (__str (pos_key ((Obj.magic start : (string * Obj.t) list)))) (!visited));
  let i = ref (0) in
  (try while (!i < n_heuristic) do
    try
  open_list := (Obj.magic (List.append (!open_list) [(Obj.magic ([]) : (string * Obj.t) list list)]) : (string * Obj.t) list list list);
  let pri = key_fn ((Obj.magic start : (string * Obj.t) list)) (Obj.repr (!i)) ((Obj.magic goal : (string * Obj.t) list)) ((Obj.magic !g_function : (string * float) list)) in
  open_list := (List.mapi (fun __i __x -> if __i = !i then pq_put (ref (List.nth (!open_list) (!i))) ((Obj.magic start : (string * Obj.t) list)) (Obj.repr (pri)) else __x) (!open_list));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  (try while (pq_minkey (List.nth (!open_list) (0)) < _inf) do
    try
  let chosen = ref (0) in
  i := 1;
  (try while (!i < n_heuristic) do
    try
  if (pq_minkey (List.nth (!open_list) (!i)) <= (_w2 *. pq_minkey (List.nth (!open_list) (0)))) then (
  chosen := !i;
  raise Break;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (!chosen <> 0) then (
  t := (!t + 1);
  );
  let pair = ref (pq_pop_min (List.nth (!open_list) (!chosen))) in
  open_list := (List.mapi (fun __i __x -> if __i = !chosen then (Obj.obj (List.assoc (__str ("pq")) (!pair) : Obj.t) : (string * Obj.t) list list) else __x) (!open_list));
  let current = ref ((Obj.obj (List.assoc (__str ("node")) (!pair) : Obj.t) : ( string * Obj.t ) list)) in
  i := 0;
  (try while (!i < n_heuristic) do
    try
  if (!i <> !chosen) then (
  open_list := (List.mapi (fun __i __x -> if __i = !i then pq_remove (List.nth (!open_list) (!i)) ((Obj.magic (Obj.obj (List.assoc (__str ("pos")) (!current) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list)) else __x) (!open_list));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let ckey = pos_key ((Obj.magic (Obj.obj (List.assoc (__str ("pos")) (!current) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list)) in
  if (List.mem_assoc ckey !visited) then (
  raise Continue;
  );
  visited := ((__str (ckey), true) :: List.remove_assoc (__str (ckey)) (!visited));
  if pos_equal ((Obj.magic (Obj.obj (List.assoc (__str ("pos")) (!current) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list)) then (
  let path = ref (reconstruct ((Obj.magic !back_pointer : (string * (string * Obj.t) list) list)) ((Obj.magic goal : (string * Obj.t) list)) ((Obj.magic start : (string * Obj.t) list))) in
  let j = ref (0) in
  (try while (!j < List.length (!path)) do
    try
  let p = List.nth (!path) (!j) in
  print_endline ((((("(" ^ (string_of_int ((Obj.obj (List.assoc (__str ("x")) (p) : Obj.t) : int)))) ^ ",") ^ (string_of_int ((Obj.obj (List.assoc (__str ("y")) (p) : Obj.t) : int)))) ^ ")"));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (); raise Return
  );
  let neighs = ref (neighbours ((Obj.magic (Obj.obj (List.assoc (__str ("pos")) (!current) : Obj.t) : ( string * Obj.t ) list) : (string * Obj.t) list))) in
  let k = ref (0) in
  (try while (!k < List.length (!neighs)) do
    try
  let nb = List.nth (!neighs) (!k) in
  if (valid (nb) && (in_blocks (nb) = false)) then (
  let nkey = pos_key (nb) in
  let tentative = (List.assoc (__str (ckey)) (!g_function) +. 1.0) in
  if (not ((List.mem_assoc nkey !g_function)) || (tentative < List.assoc (__str (nkey)) (!g_function))) then (
  g_function := ((__str (nkey), tentative) :: List.remove_assoc (__str (nkey)) (!g_function));
  back_pointer := ((__str (nkey), Obj.repr ((Obj.obj (List.assoc (__str ("pos")) (!current) : Obj.t) : ( string * Obj.t ) list))) :: List.remove_assoc (__str (nkey)) (Obj.magic (!back_pointer) : (string * Obj.t) list));
  i := 0;
  (try while (!i < n_heuristic) do
    try
  let pri2 = (tentative +. (_w1 *. heuristic (Obj.repr (!i)) (nb) ((Obj.magic goal : (string * Obj.t) list)))) in
  open_list := (List.mapi (fun __i __x -> if __i = !i then pq_put (ref (List.nth (!open_list) (!i))) (nb) (Obj.repr (pri2)) else __x) (!open_list));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  );
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  print_endline ("No path found to goal");
    !__ret
  with Return -> !__ret)


let start = [(__str ("x"), Obj.repr (0)); (__str ("y"), Obj.repr (0))]
let goal = [(__str ("x"), Obj.repr ((n - 1))); (__str ("y"), Obj.repr ((n - 1)))]
let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (multi_a_star (start) (goal) (Obj.repr (n_heuristic)));
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
