(* Generated by Mochi transpiler v0.10.62 on 2025-08-09 16:24 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __show_list (Obj.magic v) else __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __str_list (Obj.magic v) else __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec get_min_index q =
  let __ret = ref 0 in
  (try
  let q = (Obj.magic q : (string * Obj.t) list list) in
  let idx = ref (0) in
  let i = ref (1) in
  (try while (!i < List.length (q)) do
    try
  if ((Obj.obj (List.assoc (__str ("cost")) (List.nth (q) (!i)) : Obj.t) : int) < (Obj.obj (List.assoc (__str ("cost")) (List.nth (q) (!idx)) : Obj.t) : int)) then (
  idx := !i;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!idx) : int); raise Return
  with Return -> !__ret)

and remove_at q idx =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let q = (Obj.magic q : (string * Obj.t) list list) in
  let idx = (Obj.magic idx : int) in
  let res = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (q)) do
    try
  if (!i <> idx) then (
  res := (Obj.magic (List.append (!res) [(Obj.magic (List.nth (q) (!i)) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and pass_and_relaxation graph v visited_forward visited_backward cst_fwd cst_bwd queue parent shortest_distance =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let graph = (Obj.magic graph : (string * (string * Obj.t) list list) list) in
  let visited_forward = (Obj.magic visited_forward : (string * bool) list) in
  let visited_backward = (Obj.magic visited_backward : (string * bool) list) in
  cst_fwd := (Obj.magic !cst_fwd : (string * int) list);
  let cst_bwd = (Obj.magic cst_bwd : (string * int) list) in
  let queue = (Obj.magic queue : (string * Obj.t) list list) in
  parent := (Obj.magic !parent : (string * string) list);
  let shortest_distance = (Obj.magic shortest_distance : int) in
  let q = ref (queue) in
  let sd = ref (shortest_distance) in
  (try List.iter (fun e ->
    try
  let nxt = (Obj.obj (List.assoc (__str ("to")) (e) : Obj.t) : string) in
  let d = (Obj.obj (List.assoc (__str ("cost")) (e) : Obj.t) : int) in
  if (List.mem_assoc nxt visited_forward) then (
  raise Continue;
  );
  let old_cost = if (List.mem_assoc nxt !cst_fwd) then List.assoc (__str (nxt)) (!cst_fwd) else 2147483647 in
  let new_cost = (List.assoc (__str (v)) (!cst_fwd) + d) in
  if (new_cost < old_cost) then (
  q := (Obj.magic (List.append (!q) [(Obj.magic ([(__str ("node"), Obj.repr (nxt)); (__str ("cost"), Obj.repr (new_cost))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  cst_fwd := ((__str (nxt), new_cost) :: List.remove_assoc (__str (nxt)) (!cst_fwd));
  parent := ((__str (nxt), v) :: List.remove_assoc (__str (nxt)) (!parent));
  );
  if (List.mem_assoc nxt visited_backward) then (
  let alt = ((List.assoc (__str (v)) (!cst_fwd) + d) + List.assoc (__str (nxt)) (cst_bwd)) in
  if (alt < !sd) then (
  sd := alt;
  );
  );
    with Continue -> ()) (List.assoc (__str (v)) (graph)) with Break -> ());
  __ret := (Obj.magic ([(__str ("queue"), Obj.repr (!q)); (__str ("dist"), Obj.repr (!sd))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and bidirectional_dij source destination graph_forward graph_backward =
  let __ret = ref 0 in
  (try
  let graph_forward = (Obj.magic graph_forward : (string * (string * Obj.t) list list) list) in
  let graph_backward = (Obj.magic graph_backward : (string * (string * Obj.t) list list) list) in
  let shortest_path_distance = ref (-(1)) in
  let visited_forward = ref ([] : (string * bool) list) in
  let visited_backward = ref ([] : (string * bool) list) in
  let cst_fwd = ref ([] : (string * int) list) in
  cst_fwd := ((__str (source), 0) :: List.remove_assoc (__str (source)) (!cst_fwd));
  let cst_bwd = ref ([] : (string * int) list) in
  cst_bwd := ((__str (destination), 0) :: List.remove_assoc (__str (destination)) (!cst_bwd));
  let parent_forward = ref ([] : (string * string) list) in
  parent_forward := ((__str (source), "") :: List.remove_assoc (__str (source)) (!parent_forward));
  let parent_backward = ref ([] : (string * string) list) in
  parent_backward := ((__str (destination), "") :: List.remove_assoc (__str (destination)) (!parent_backward));
  let queue_forward = ref (([] : ((string * Obj.t) list) list)) in
  queue_forward := (Obj.magic (List.append (!queue_forward) [(Obj.magic ([(__str ("node"), Obj.repr (source)); (__str ("cost"), Obj.repr (0))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  let queue_backward = ref (([] : ((string * Obj.t) list) list)) in
  queue_backward := (Obj.magic (List.append (!queue_backward) [(Obj.magic ([(__str ("node"), Obj.repr (destination)); (__str ("cost"), Obj.repr (0))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  let shortest_distance = ref (2147483647) in
  if (source = destination) then (
  __ret := (Obj.magic (0) : int); raise Return
  );
  (try while ((List.length (!queue_forward) > 0) && (List.length (!queue_backward) > 0)) do
    try
  let idx_f = get_min_index (!queue_forward) in
  let item_f = ref (List.nth (!queue_forward) (idx_f)) in
  queue_forward := remove_at (!queue_forward) (Obj.repr (idx_f));
  let v_fwd = (Obj.obj (List.assoc (__str ("node")) (!item_f) : Obj.t) : string) in
  visited_forward := ((__str (v_fwd), true) :: List.remove_assoc (__str (v_fwd)) (!visited_forward));
  let idx_b = get_min_index (!queue_backward) in
  let item_b = ref (List.nth (!queue_backward) (idx_b)) in
  queue_backward := remove_at (!queue_backward) (Obj.repr (idx_b));
  let v_bwd = (Obj.obj (List.assoc (__str ("node")) (!item_b) : Obj.t) : string) in
  visited_backward := ((__str (v_bwd), true) :: List.remove_assoc (__str (v_bwd)) (!visited_backward));
  let res_f = pass_and_relaxation ((Obj.magic graph_forward : (string * (string * Obj.t) list list) list)) (v_fwd) ((Obj.magic !visited_forward : (string * bool) list)) ((Obj.magic !visited_backward : (string * bool) list)) (cst_fwd) ((Obj.magic !cst_bwd : (string * int) list)) (!queue_forward) (parent_forward) (Obj.repr (!shortest_distance)) in
  queue_forward := (Obj.magic (Obj.obj (List.assoc (__str ("queue")) (res_f) : Obj.t) : (string * Obj.t) list list) : (string * Obj.t) list list);
  shortest_distance := (Obj.obj (List.assoc (__str ("dist")) (res_f) : Obj.t) : int);
  let res_b = pass_and_relaxation ((Obj.magic graph_backward : (string * (string * Obj.t) list list) list)) (v_bwd) ((Obj.magic !visited_backward : (string * bool) list)) ((Obj.magic !visited_forward : (string * bool) list)) (cst_bwd) ((Obj.magic !cst_fwd : (string * int) list)) (!queue_backward) (parent_backward) (Obj.repr (!shortest_distance)) in
  queue_backward := (Obj.magic (Obj.obj (List.assoc (__str ("queue")) (res_b) : Obj.t) : (string * Obj.t) list list) : (string * Obj.t) list list);
  shortest_distance := (Obj.obj (List.assoc (__str ("dist")) (res_b) : Obj.t) : int);
  if ((List.assoc (__str (v_fwd)) (!cst_fwd) + List.assoc (__str (v_bwd)) (!cst_bwd)) >= !shortest_distance) then (
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
  if (!shortest_distance <> 2147483647) then (
  shortest_path_distance := !shortest_distance;
  );
  __ret := (Obj.magic (!shortest_path_distance) : int); raise Return
  with Return -> !__ret)


let graph_fwd = ref ([(__str ("B"), Obj.repr ([[(__str ("to"), Obj.repr ("C")); (__str ("cost"), Obj.repr (1))]])); (__str ("C"), Obj.repr ([[(__str ("to"), Obj.repr ("D")); (__str ("cost"), Obj.repr (1))]])); (__str ("D"), Obj.repr ([[(__str ("to"), Obj.repr ("F")); (__str ("cost"), Obj.repr (1))]])); (__str ("E"), Obj.repr ([[(__str ("to"), Obj.repr ("B")); (__str ("cost"), Obj.repr (1))]; [(__str ("to"), Obj.repr ("G")); (__str ("cost"), Obj.repr (2))]])); (__str ("F"), Obj.repr ([])); (__str ("G"), Obj.repr ([[(__str ("to"), Obj.repr ("F")); (__str ("cost"), Obj.repr (1))]]))])
let graph_bwd = ref ([(__str ("B"), Obj.repr ([[(__str ("to"), Obj.repr ("E")); (__str ("cost"), Obj.repr (1))]])); (__str ("C"), Obj.repr ([[(__str ("to"), Obj.repr ("B")); (__str ("cost"), Obj.repr (1))]])); (__str ("D"), Obj.repr ([[(__str ("to"), Obj.repr ("C")); (__str ("cost"), Obj.repr (1))]])); (__str ("F"), Obj.repr ([[(__str ("to"), Obj.repr ("D")); (__str ("cost"), Obj.repr (1))]; [(__str ("to"), Obj.repr ("G")); (__str ("cost"), Obj.repr (1))]])); (__str ("E"), Obj.repr ([])); (__str ("G"), Obj.repr ([[(__str ("to"), Obj.repr ("E")); (__str ("cost"), Obj.repr (2))]]))])
let () =
  let mem_start = _mem () in
  let start = _now () in
  print_endline ((string_of_int (bidirectional_dij ("E") ("F") ((Obj.magic !graph_fwd : (string * (string * Obj.t) list list) list)) ((Obj.magic !graph_bwd : (string * (string * Obj.t) list list) list)))));
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
