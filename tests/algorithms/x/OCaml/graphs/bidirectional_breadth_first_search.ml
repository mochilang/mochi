(* Generated by Mochi transpiler v0.10.65 on 2025-08-14 16:42 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let grid = ref ([[0; 0; 0; 0; 0; 0; 0]; [0; 1; 0; 0; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0]; [0; 0; 1; 0; 0; 0; 0]; [1; 0; 1; 0; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0]; [0; 0; 0; 0; 1; 0; 0]])
let delta = ref ([[-(1); 0]; [0; -(1)]; [1; 0]; [0; 1]])
let rec key y x =
  let __ret = ref "" in
  (try
  let y = (Obj.magic y : int) in
  let x = (Obj.magic x : int) in
  __ret := (Obj.magic ((((string_of_int (Obj.magic (y) : int)) ^ ",") ^ (string_of_int (Obj.magic (x) : int)))) : string); raise Return
  with Return -> !__ret)

and parse_int s =
  let __ret = ref 0 in
  (try
  let value = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  let c = (let __s = s in let __i = !i in let __len = String.length __s in String.make 1 (String.get __s (if __i >= 0 then __i else __len + __i))) in
  value := ((!value * 10) + int_of_string (c));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!value) : int); raise Return
  with Return -> !__ret)

and parse_key k =
  let __ret = ref ([] : (int) list) in
  (try
  let idx = ref (0) in
  (try while ((!idx < String.length (k)) && ((let __s = k in let __st = !idx in let __en = (!idx + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) <> ",")) do
    try
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  let y = parse_int ((let __s = k in let __st = 0 in let __en = !idx in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st))) in
  let x = parse_int ((let __s = k in let __st = (!idx + 1) in let __en = String.length (k) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st))) in
  __ret := (Obj.magic ([y; x]) : int list); raise Return
  with Return -> !__ret)

and neighbors pos =
  let __ret = ref ([] : (string) list) in
  (try
  let coords = ref (parse_key (pos)) in
  let y = (let __l = !coords in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let x = (let __l = !coords in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let res = ref (([] : (string) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!delta)) do
    try
  let ny = (y + (let __l = (let __l = !delta in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) in
  let nx = (x + (let __l = (let __l = !delta in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) in
  if ((((ny >= 0) && (ny < List.length (!grid))) && (nx >= 0)) && (nx < List.length ((let __l = !grid in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])))) then (
  if ((let __l = (let __l = !grid in let __i = ny in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = nx in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) = 0) then (
  res := (Obj.magic (List.append (!res) [(Obj.magic (key (Obj.repr (ny)) (Obj.repr (nx))) : string)]) : string list);
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string list); raise Return
  with Return -> !__ret)

and reverse_list lst =
  let __ret = ref ([] : (string) list) in
  (try
  let lst = (Obj.magic lst : string list) in
  let res = ref (([] : (string) list)) in
  let i = ref ((List.length (lst) - 1)) in
  (try while (!i >= 0) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = lst in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) : string)]) : string list);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string list); raise Return
  with Return -> !__ret)

and bfs start goal =
  let __ret = ref ([] : (string) list) in
  (try
  let queue = ref (([] : ((string * Obj.t) list) list)) in
  queue := (Obj.magic (List.append (!queue) [(Obj.magic ([(__str ("pos"), Obj.repr (start)); (__str ("path"), Obj.repr ([start]))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  let head = ref (0) in
  let visited = ref ([(__str ("start"), true)]) in
  (try while (!head < List.length (!queue)) do
    try
  let node = ref ((let __l = !queue in let __i = !head in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  head := (!head + 1);
  if ((match List.assoc_opt (__str ("pos")) (!node) with Some v -> (Obj.obj (v : Obj.t) : string) | None -> "") = goal) then (
  __ret := (Obj.magic ((match List.assoc_opt (__str ("path")) (!node) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) : string list); raise Return
  );
  let neigh = ref (neighbors ((match List.assoc_opt (__str ("pos")) (!node) with Some v -> (Obj.obj (v : Obj.t) : string) | None -> ""))) in
  let i = ref (0) in
  (try while (!i < List.length (!neigh)) do
    try
  let npos = (let __l = !neigh in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  if not ((List.mem_assoc (__str (npos)) !visited)) then (
  visited := ((__str (npos), true) :: List.remove_assoc (__str (npos)) (!visited));
  let new_path = ref ((List.append ((match List.assoc_opt (__str ("path")) (!node) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) [(Obj.magic (npos) : string)])) in
  queue := (Obj.magic (List.append (!queue) [(Obj.magic ([(__str ("pos"), Obj.repr (npos)); (__str ("path"), Obj.repr (!new_path))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([]) : string list); raise Return
  with Return -> !__ret)

and bidirectional_bfs start goal =
  let __ret = ref ([] : (string) list) in
  (try
  let queue_f = ref (([] : ((string * Obj.t) list) list)) in
  let queue_b = ref (([] : ((string * Obj.t) list) list)) in
  queue_f := (Obj.magic (List.append (!queue_f) [(Obj.magic ([(__str ("pos"), Obj.repr (start)); (__str ("path"), Obj.repr ([start]))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  queue_b := (Obj.magic (List.append (!queue_b) [(Obj.magic ([(__str ("pos"), Obj.repr (goal)); (__str ("path"), Obj.repr ([goal]))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  let head_f = ref (0) in
  let head_b = ref (0) in
  let visited_f = ref ([(__str ("start"), [start])]) in
  let visited_b = ref ([(__str ("goal"), [goal])]) in
  (try while ((!head_f < List.length (!queue_f)) && (!head_b < List.length (!queue_b))) do
    try
  let node_f = ref ((let __l = !queue_f in let __i = !head_f in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  head_f := (!head_f + 1);
  let neigh_f = ref (neighbors ((match List.assoc_opt (__str ("pos")) (!node_f) with Some v -> (Obj.obj (v : Obj.t) : string) | None -> ""))) in
  let i = ref (0) in
  (try while (!i < List.length (!neigh_f)) do
    try
  let npos = (let __l = !neigh_f in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  if not ((List.mem_assoc (__str (npos)) !visited_f)) then (
  let new_path = ref ((List.append ((match List.assoc_opt (__str ("path")) (!node_f) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) [(Obj.magic (npos) : string)])) in
  visited_f := ((__str (npos), !new_path) :: List.remove_assoc (__str (npos)) (!visited_f));
  if (List.mem_assoc (__str (npos)) !visited_b) then (
  let rev = ref (reverse_list ((match List.assoc_opt (__str (npos)) (!visited_b) with Some v -> v | None -> []))) in
  let j = ref (1) in
  (try while (!j < List.length (!rev)) do
    try
  new_path := (Obj.magic (List.append (!new_path) [(Obj.magic ((let __l = !rev in let __i = !j in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) : string)]) : string list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!new_path) : string list); raise Return
  );
  queue_f := (Obj.magic (List.append (!queue_f) [(Obj.magic ([(__str ("pos"), Obj.repr (npos)); (__str ("path"), Obj.repr (!new_path))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let node_b = ref ((let __l = !queue_b in let __i = !head_b in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  head_b := (!head_b + 1);
  let neigh_b = ref (neighbors ((match List.assoc_opt (__str ("pos")) (!node_b) with Some v -> (Obj.obj (v : Obj.t) : string) | None -> ""))) in
  let j = ref (0) in
  (try while (!j < List.length (!neigh_b)) do
    try
  let nposb = (let __l = !neigh_b in let __i = !j in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  if not ((List.mem_assoc (__str (nposb)) !visited_b)) then (
  let new_path_b = ref ((List.append ((match List.assoc_opt (__str ("path")) (!node_b) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) [(Obj.magic (nposb) : string)])) in
  visited_b := ((__str (nposb), !new_path_b) :: List.remove_assoc (__str (nposb)) (!visited_b));
  if (List.mem_assoc (__str (nposb)) !visited_f) then (
  let path_f = ref ((match List.assoc_opt (__str (nposb)) (!visited_f) with Some v -> v | None -> [])) in
  new_path_b := (Obj.magic reverse_list (!new_path_b) : string list);
  let t = ref (1) in
  (try while (!t < List.length (!new_path_b)) do
    try
  path_f := (Obj.magic (List.append (!path_f) [(Obj.magic ((let __l = !new_path_b in let __i = !t in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) : string)]) : string list);
  t := (!t + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!path_f) : string list); raise Return
  );
  queue_b := (Obj.magic (List.append (!queue_b) [(Obj.magic ([(__str ("pos"), Obj.repr (nposb)); (__str ("path"), Obj.repr (!new_path_b))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([start]) : string list); raise Return
  with Return -> !__ret)

and path_to_string path =
  let __ret = ref "" in
  (try
  let path = (Obj.magic path : string list) in
  if (List.length (path) = 0) then (
  __ret := (Obj.magic ("[]") : string); raise Return
  );
  let first = ref (parse_key ((let __l = path in let __i = 0 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> ""))) in
  let s = ref ((((("[(" ^ (string_of_int (Obj.magic ((let __l = !first in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) : int))) ^ ", ") ^ (string_of_int (Obj.magic ((let __l = !first in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) : int))) ^ ")")) in
  let i = ref (1) in
  (try while (!i < List.length (path)) do
    try
  let c = ref (parse_key ((let __l = path in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> ""))) in
  s := (((((!s ^ ", (") ^ (string_of_int (Obj.magic ((let __l = !c in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) : int))) ^ ", ") ^ (string_of_int (Obj.magic ((let __l = !c in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) : int))) ^ ")");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)


let start = key (Obj.repr (0)) (Obj.repr (0))
let goal = key (Obj.repr ((List.length (!grid) - 1))) (Obj.repr ((List.length ((let __l = !grid in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) - 1)))
let path1 = ref (bfs (start) (goal))
let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  print_endline ((path_to_string (!path1)));
  let path2 = ref (bidirectional_bfs (start) (goal)) in
  print_endline ((path_to_string (!path2)));
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
