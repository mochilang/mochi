(* Generated by Mochi transpiler v0.10.62 on 2025-08-09 16:24 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __show_list (Obj.magic v) else __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __str_list (Obj.magic v) else __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let seed = ref (123456789)
let rec rand () =
  let __ret = ref 0 in
  (try
  seed := ((((!seed * 1103515245) + 12345) mod 2147483648 + 2147483648) mod 2147483648);
  __ret := (Obj.magic (!seed) : int); raise Return
  with Return -> !__ret)

and random () =
  let __ret = ref 0.0 in
  (try
  __ret := (Obj.magic (((1.0 *. float_of_int (rand ())) /. 2147483648.0)) : float); raise Return
  with Return -> !__ret)

and sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x <= 0.0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  let guess = ref (x) in
  let i = ref (0) in
  (try while (!i < 20) do
    try
  guess := ((!guess +. (x /. !guess)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!guess) : float); raise Return
  with Return -> !__ret)

and absf x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  __ret := (Obj.magic (if (x < 0.0) then (-.(x)) else x) : float); raise Return
  with Return -> !__ret)

and dot a b =
  let __ret = ref 0.0 in
  (try
  let a = (Obj.magic a : float list) in
  let b = (Obj.magic b : float list) in
  let s = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  s := (!s +. (List.nth (a) (!i) *. List.nth (b) (!i)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!s) : float); raise Return
  with Return -> !__ret)

and vector_scale v s =
  let __ret = ref ([] : (float) list) in
  (try
  let v = (Obj.magic v : float list) in
  let s = (Obj.magic s : float) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((List.nth (v) (!i) *. s)) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and vector_sub a b =
  let __ret = ref ([] : (float) list) in
  (try
  let a = (Obj.magic a : float list) in
  let b = (Obj.magic b : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((List.nth (a) (!i) -. List.nth (b) (!i))) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and vector_add a b =
  let __ret = ref ([] : (float) list) in
  (try
  let a = (Obj.magic a : float list) in
  let b = (Obj.magic b : float list) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((List.nth (a) (!i) +. List.nth (b) (!i))) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and zeros_matrix r c =
  let __ret = ref ([] : (float list) list) in
  (try
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let m = ref (([] : (float list) list)) in
  let i = ref (0) in
  (try while (!i < r) do
    try
  let row = ref (([] : (float) list)) in
  let j = ref (0) in
  (try while (!j < c) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (0.0) : float)]) : float list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  m := (Obj.magic (List.append (!m) [(Obj.magic (!row) : float list)]) : float list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : float list list); raise Return
  with Return -> !__ret)

and column m idx =
  let __ret = ref ([] : (float) list) in
  (try
  let m = (Obj.magic m : float list list) in
  let idx = (Obj.magic idx : int) in
  let col = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (m)) do
    try
  col := (Obj.magic (List.append (!col) [(Obj.magic (List.nth (List.nth (m) (!i)) (idx)) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!col) : float list); raise Return
  with Return -> !__ret)

and validate_adjacency_list graph =
  let __ret = ref (Obj.magic 0) in
  (try
  let graph = (Obj.magic graph : int list list) in
  let i = ref (0) in
  (try while (!i < List.length (graph)) do
    try
  let j = ref (0) in
  (try while (!j < List.length (List.nth (graph) (!i))) do
    try
  let v = List.nth (List.nth (graph) (!i)) (!j) in
  if ((v < 0) || (v >= List.length (graph))) then (
  (failwith ("Invalid neighbor"));
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and multiply_matrix_vector graph vector =
  let __ret = ref ([] : (float) list) in
  (try
  let graph = (Obj.magic graph : int list list) in
  let vector = (Obj.magic vector : float list) in
  let n = List.length (graph) in
  if (List.length (vector) <> n) then (
  (failwith ("Vector length must match number of nodes"));
  );
  let result = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  let sum = ref (0.0) in
  let j = ref (0) in
  (try while (!j < List.length (List.nth (graph) (!i))) do
    try
  let nb = List.nth (List.nth (graph) (!i)) (!j) in
  sum := (!sum +. List.nth (vector) (nb));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  result := (Obj.magic (List.append (!result) [(Obj.magic (!sum) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : float list); raise Return
  with Return -> !__ret)

and lanczos_iteration graph k =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let graph = (Obj.magic graph : int list list) in
  let k = (Obj.magic k : int) in
  let n = List.length (graph) in
  if ((k < 1) || (k > n)) then (
  (failwith ("invalid number of eigenvectors"));
  );
  let q = ref (zeros_matrix (Obj.repr (n)) (Obj.repr (k))) in
  let t = ref (zeros_matrix (Obj.repr (k)) (Obj.repr (k))) in
  let v = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  v := (Obj.magic (List.append (!v) [(Obj.magic (random ()) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let ss = ref (0.0) in
  i := 0;
  (try while (!i < n) do
    try
  ss := (!ss +. (List.nth (!v) (!i) *. List.nth (!v) (!i)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let vnorm = sqrtApprox (Obj.repr (!ss)) in
  i := 0;
  (try while (!i < n) do
    try
  q := (List.mapi (fun __i __x -> if __i = !i then (List.mapi (fun __i __x -> if __i = 0 then (List.nth (!v) (!i) /. vnorm) else __x) (List.nth (!q) (!i))) else __x) (!q));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let beta = ref (0.0) in
  let j = ref (0) in
  (try while (!j < k) do
    try
  let w = ref (multiply_matrix_vector (graph) (column (!q) (Obj.repr (!j)))) in
  if (!j > 0) then (
  w := (Obj.magic vector_sub (!w) (vector_scale (column (!q) (Obj.repr ((!j - 1)))) (Obj.repr (!beta))) : float list);
  );
  let alpha = dot (column (!q) (Obj.repr (!j))) (!w) in
  w := (Obj.magic vector_sub (!w) (vector_scale (column (!q) (Obj.repr (!j))) (Obj.repr (alpha))) : float list);
  let ss2 = ref (0.0) in
  let p = ref (0) in
  (try while (!p < n) do
    try
  ss2 := (!ss2 +. (List.nth (!w) (!p) *. List.nth (!w) (!p)));
  p := (!p + 1);
    with Continue -> ()
  done with Break -> ());
  beta := sqrtApprox (Obj.repr (!ss2));
  t := (List.mapi (fun __i __x -> if __i = !j then (List.mapi (fun __i __x -> if __i = !j then alpha else __x) (List.nth (!t) (!j))) else __x) (!t));
  if (!j < (k - 1)) then (
  t := (List.mapi (fun __i __x -> if __i = !j then (List.mapi (fun __i __x -> if __i = (!j + 1) then !beta else __x) (List.nth (!t) (!j))) else __x) (!t));
  t := (List.mapi (fun __i __x -> if __i = (!j + 1) then (List.mapi (fun __i __x -> if __i = !j then !beta else __x) (List.nth (!t) ((!j + 1)))) else __x) (!t));
  if (!beta > 0.0000000001) then (
  let wnorm = ref (vector_scale (!w) (Obj.repr ((1.0 /. !beta)))) in
  let r = ref (0) in
  (try while (!r < n) do
    try
  q := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = (!j + 1) then List.nth (!wnorm) (!r) else __x) (List.nth (!q) (!r))) else __x) (!q));
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  );
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("t"), Obj.repr (!t)); (__str ("q"), Obj.repr (!q))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and jacobi_eigen a_in max_iter =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let a_in = (Obj.magic a_in : float list list) in
  let max_iter = (Obj.magic max_iter : int) in
  let n = List.length (a_in) in
  let a = ref (a_in) in
  let v = ref (zeros_matrix (Obj.repr (n)) (Obj.repr (n))) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  v := (List.mapi (fun __i __x -> if __i = !i then (List.mapi (fun __i __x -> if __i = !i then 1.0 else __x) (List.nth (!v) (!i))) else __x) (!v));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let iter = ref (0) in
  (try while (!iter < max_iter) do
    try
  let p = ref (0) in
  let q = ref (1) in
  let max = ref (absf (Obj.repr (List.nth (List.nth (!a) (!p)) (!q)))) in
  i := 0;
  (try while (!i < n) do
    try
  let j = ref ((!i + 1)) in
  (try while (!j < n) do
    try
  let val_ = absf (Obj.repr (List.nth (List.nth (!a) (!i)) (!j))) in
  if (val_ > !max) then (
  max := val_;
  p := !i;
  q := !j;
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (!max < 0.00000001) then (
  raise Break;
  );
  let app = List.nth (List.nth (!a) (!p)) (!p) in
  let aqq = List.nth (List.nth (!a) (!q)) (!q) in
  let apq = List.nth (List.nth (!a) (!p)) (!q) in
  let theta = ((aqq -. app) /. (2.0 *. apq)) in
  let t = ref ((1.0 /. (absf (Obj.repr (theta)) +. sqrtApprox (Obj.repr (((theta *. theta) +. 1.0)))))) in
  if (theta < 0.0) then (
  t := (-.(!t));
  );
  let c = (1.0 /. sqrtApprox (Obj.repr ((1.0 +. (!t *. !t))))) in
  let s = (!t *. c) in
  let tau = (s /. (1.0 +. c)) in
  a := (List.mapi (fun __i __x -> if __i = !p then (List.mapi (fun __i __x -> if __i = !p then (app -. (!t *. apq)) else __x) (List.nth (!a) (!p))) else __x) (!a));
  a := (List.mapi (fun __i __x -> if __i = !q then (List.mapi (fun __i __x -> if __i = !q then (aqq +. (!t *. apq)) else __x) (List.nth (!a) (!q))) else __x) (!a));
  a := (List.mapi (fun __i __x -> if __i = !p then (List.mapi (fun __i __x -> if __i = !q then 0.0 else __x) (List.nth (!a) (!p))) else __x) (!a));
  a := (List.mapi (fun __i __x -> if __i = !q then (List.mapi (fun __i __x -> if __i = !p then 0.0 else __x) (List.nth (!a) (!q))) else __x) (!a));
  let k = ref (0) in
  (try while (!k < n) do
    try
  if ((!k <> !p) && (!k <> !q)) then (
  let akp = List.nth (List.nth (!a) (!k)) (!p) in
  let akq = List.nth (List.nth (!a) (!k)) (!q) in
  a := (List.mapi (fun __i __x -> if __i = !k then (List.mapi (fun __i __x -> if __i = !p then (akp -. (s *. (akq +. (tau *. akp)))) else __x) (List.nth (!a) (!k))) else __x) (!a));
  a := (List.mapi (fun __i __x -> if __i = !p then (List.mapi (fun __i __x -> if __i = !k then List.nth (List.nth (!a) (!k)) (!p) else __x) (List.nth (!a) (!p))) else __x) (!a));
  a := (List.mapi (fun __i __x -> if __i = !k then (List.mapi (fun __i __x -> if __i = !q then (akq +. (s *. (akp -. (tau *. akq)))) else __x) (List.nth (!a) (!k))) else __x) (!a));
  a := (List.mapi (fun __i __x -> if __i = !q then (List.mapi (fun __i __x -> if __i = !k then List.nth (List.nth (!a) (!k)) (!q) else __x) (List.nth (!a) (!q))) else __x) (!a));
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  k := 0;
  (try while (!k < n) do
    try
  let vkp = List.nth (List.nth (!v) (!k)) (!p) in
  let vkq = List.nth (List.nth (!v) (!k)) (!q) in
  v := (List.mapi (fun __i __x -> if __i = !k then (List.mapi (fun __i __x -> if __i = !p then (vkp -. (s *. (vkq +. (tau *. vkp)))) else __x) (List.nth (!v) (!k))) else __x) (!v));
  v := (List.mapi (fun __i __x -> if __i = !k then (List.mapi (fun __i __x -> if __i = !q then (vkq +. (s *. (vkp -. (tau *. vkq)))) else __x) (List.nth (!v) (!k))) else __x) (!v));
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  iter := (!iter + 1);
    with Continue -> ()
  done with Break -> ());
  let eigenvalues = ref (([] : (float) list)) in
  i := 0;
  (try while (!i < n) do
    try
  eigenvalues := (Obj.magic (List.append (!eigenvalues) [(Obj.magic (List.nth (List.nth (!a) (!i)) (!i)) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("values"), Obj.repr (!eigenvalues)); (__str ("vectors"), Obj.repr (!v))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and matmul a b =
  let __ret = ref ([] : (float list) list) in
  (try
  let a = (Obj.magic a : float list list) in
  let b = (Obj.magic b : float list list) in
  let rows = List.length (a) in
  let cols = List.length (List.nth (b) (0)) in
  let inner = List.length (b) in
  let m = ref (zeros_matrix (Obj.repr (rows)) (Obj.repr (cols))) in
  let i = ref (0) in
  (try while (!i < rows) do
    try
  let j = ref (0) in
  (try while (!j < cols) do
    try
  let s = ref (0.0) in
  let k = ref (0) in
  (try while (!k < inner) do
    try
  s := (!s +. (List.nth (List.nth (a) (!i)) (!k) *. List.nth (List.nth (b) (!k)) (!j)));
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  m := (List.mapi (fun __i __x -> if __i = !i then (List.mapi (fun __i __x -> if __i = !j then !s else __x) (List.nth (!m) (!i))) else __x) (!m));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : float list list); raise Return
  with Return -> !__ret)

and sort_eigenpairs vals vecs =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let vals = (Obj.magic vals : float list) in
  let vecs = (Obj.magic vecs : float list list) in
  let n = List.length (vals) in
  let values = ref (vals) in
  let vectors = ref (vecs) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  let j = ref (0) in
  (try while (!j < (n - 1)) do
    try
  if (List.nth (!values) (!j) < List.nth (!values) ((!j + 1))) then (
  let tmp = List.nth (!values) (!j) in
  values := (List.mapi (fun __i __x -> if __i = !j then List.nth (!values) ((!j + 1)) else __x) (!values));
  values := (List.mapi (fun __i __x -> if __i = (!j + 1) then tmp else __x) (!values));
  let r = ref (0) in
  (try while (!r < List.length (!vectors)) do
    try
  let tv = List.nth (List.nth (!vectors) (!r)) (!j) in
  vectors := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = !j then List.nth (List.nth (!vectors) (!r)) ((!j + 1)) else __x) (List.nth (!vectors) (!r))) else __x) (!vectors));
  vectors := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = (!j + 1) then tv else __x) (List.nth (!vectors) (!r))) else __x) (!vectors));
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("values"), Obj.repr (!values)); (__str ("vectors"), Obj.repr (!vectors))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and find_lanczos_eigenvectors graph k =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let graph = (Obj.magic graph : int list list) in
  let k = (Obj.magic k : int) in
  ignore (validate_adjacency_list (graph));
  let res = lanczos_iteration (graph) (Obj.repr (k)) in
  let eig = jacobi_eigen ((Obj.obj (List.assoc (__str ("t")) (res) : Obj.t) : float list list)) (Obj.repr (50)) in
  let sorted = sort_eigenpairs ((Obj.obj (List.assoc (__str ("values")) (eig) : Obj.t) : float list)) ((Obj.obj (List.assoc (__str ("vectors")) (eig) : Obj.t) : float list list)) in
  let final_vectors = ref (matmul ((Obj.obj (List.assoc (__str ("q")) (res) : Obj.t) : float list list)) ((Obj.obj (List.assoc (__str ("vectors")) (sorted) : Obj.t) : float list list))) in
  __ret := (Obj.magic ([(__str ("values"), Obj.repr ((Obj.obj (List.assoc (__str ("values")) (sorted) : Obj.t) : float list))); (__str ("vectors"), Obj.repr (!final_vectors))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and list_to_string arr =
  let __ret = ref "" in
  (try
  let arr = (Obj.magic arr : float list) in
  let s = ref ("[") in
  let i = ref (0) in
  (try while (!i < List.length (arr)) do
    try
  s := (!s ^ (Printf.sprintf "%.16g" (List.nth (arr) (!i))));
  if (!i < (List.length (arr) - 1)) then (
  s := (!s ^ ", ");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!s ^ "]")) : string); raise Return
  with Return -> !__ret)

and matrix_to_string m =
  let __ret = ref "" in
  (try
  let m = (Obj.magic m : float list list) in
  let s = ref ("[") in
  let i = ref (0) in
  (try while (!i < List.length (m)) do
    try
  s := (!s ^ list_to_string (List.nth (m) (!i)));
  if (!i < (List.length (m) - 1)) then (
  s := (!s ^ "; ");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!s ^ "]")) : string); raise Return
  with Return -> !__ret)


let graph = ref ([[1; 2]; [0; 2]; [0; 1]])
let result = find_lanczos_eigenvectors (!graph) (Obj.repr (2))
let () =
  let mem_start = _mem () in
  let start = _now () in
  print_endline ((list_to_string ((Obj.obj (List.assoc (__str ("values")) (result) : Obj.t) : float list))));
  print_endline ((matrix_to_string ((Obj.obj (List.assoc (__str ("vectors")) (result) : Obj.t) : float list list))));
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
