(* Generated by Mochi transpiler v0.10.66 on 2025-08-15 10:25 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _edge_array = ref ([[["ab"; "e1"]; ["ac"; "e3"]; ["ad"; "e5"]; ["bc"; "e4"]; ["bd"; "e2"]; ["be"; "e6"]; ["bh"; "e12"]; ["cd"; "e2"]; ["ce"; "e4"]; ["de"; "e1"]; ["df"; "e8"]; ["dg"; "e5"]; ["dh"; "e10"]; ["ef"; "e3"]; ["eg"; "e2"]; ["fg"; "e6"]; ["gh"; "e6"]; ["hi"; "e3"]]; [["ab"; "e1"]; ["ac"; "e3"]; ["ad"; "e5"]; ["bc"; "e4"]; ["bd"; "e2"]; ["be"; "e6"]; ["cd"; "e2"]; ["de"; "e1"]; ["df"; "e8"]; ["ef"; "e3"]; ["eg"; "e2"]; ["fg"; "e6"]]; [["ab"; "e1"]; ["ac"; "e3"]; ["bc"; "e4"]; ["bd"; "e2"]; ["de"; "e1"]; ["df"; "e8"]; ["dg"; "e5"]; ["ef"; "e3"]; ["eg"; "e2"]; ["eh"; "e12"]; ["fg"; "e6"]; ["fh"; "e10"]; ["gh"; "e6"]]; [["ab"; "e1"]; ["ac"; "e3"]; ["bc"; "e4"]; ["bd"; "e2"]; ["bh"; "e12"]; ["cd"; "e2"]; ["df"; "e8"]; ["dh"; "e10"]]; [["ab"; "e1"]; ["ac"; "e3"]; ["ad"; "e5"]; ["bc"; "e4"]; ["bd"; "e2"]; ["cd"; "e2"]; ["ce"; "e4"]; ["de"; "e1"]; ["df"; "e8"]; ["dg"; "e5"]; ["ef"; "e3"]; ["eg"; "e2"]; ["fg"; "e6"]]])
let rec contains lst item =
  let __ret = ref false in
  (try
  let lst = (Obj.magic lst : string list) in
  (try List.iter (fun v ->
    try
  if (v = item) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
    with Continue -> ()) (lst) with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and get_distinct_edge edge_array =
  let __ret = ref ([] : (string) list) in
  (try
  let edge_array = (Obj.magic edge_array : string list list list) in
  let distinct = ref (([] : (string) list)) in
  (try List.iter (fun row ->
    try
  (try List.iter (fun item ->
    try
  let e = (let __l = item in let __i = 0 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  if not (contains (!distinct) (e)) then (
  distinct := (Obj.magic (List.append (!distinct) [(Obj.magic (e) : string)]) : string list);
  );
    with Continue -> ()) (row) with Break -> ());
    with Continue -> ()) (edge_array) with Break -> ());
  __ret := (Obj.magic (!distinct) : string list); raise Return
  with Return -> !__ret)

and get_bitcode edge_array de =
  let __ret = ref "" in
  (try
  let edge_array = (Obj.magic edge_array : string list list list) in
  let bitcode = ref ("") in
  let i = ref (0) in
  (try while (!i < List.length (edge_array)) do
    try
  let found = ref (false) in
  (try List.iter (fun item ->
    try
  if ((let __l = item in let __i = 0 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") = de) then (
  found := true;
  raise Break;
  );
    with Continue -> ()) ((let __l = edge_array in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Break -> ());
  if !found then (
  bitcode := (!bitcode ^ "1");
  ) else (
  bitcode := (!bitcode ^ "0");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!bitcode) : string); raise Return
  with Return -> !__ret)

and count_ones s =
  let __ret = ref 0 in
  (try
  let c = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if ((let __s = s in let __st = !i in let __en = (!i + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) = "1") then (
  c := (!c + 1);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!c) : int); raise Return
  with Return -> !__ret)

and get_frequency_table edge_array =
  let __ret = ref ([] : ((string * string) list) list) in
  (try
  let edge_array = (Obj.magic edge_array : string list list list) in
  let distinct = ref (get_distinct_edge (edge_array)) in
  let table = ref (([] : ((string * string) list) list)) in
  (try List.iter (fun e ->
    try
  let bit = get_bitcode (edge_array) (e) in
  let cnt = count_ones (bit) in
  let entry = ref ([(__str ("edge"), e); (__str ("count"), (string_of_int (Obj.magic (cnt) : int))); (__str ("bit"), bit)]) in
  table := (Obj.magic (List.append (!table) [(Obj.magic (!entry) : (string * string) list)]) : (string * string) list list);
    with Continue -> ()) (!distinct) with Break -> ());
  let i = ref (0) in
  (try while (!i < List.length (!table)) do
    try
  let max_i = ref (!i) in
  let j = ref ((!i + 1)) in
  (try while (!j < List.length (!table)) do
    try
  if (int_of_string ((match List.assoc_opt (__str ("count")) ((let __l = !table in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> v | None -> "")) > int_of_string ((match List.assoc_opt (__str ("count")) ((let __l = !table in let __i = !max_i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> v | None -> ""))) then (
  max_i := !j;
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  let tmp = ref ((let __l = !table in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  table := (List.mapi (fun __i __x -> if __i = !i then (let __l = !table in let __i = !max_i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) else __x) (!table));
  table := (List.mapi (fun __i __x -> if __i = !max_i then !tmp else __x) (!table));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!table) : (string * string) list list); raise Return
  with Return -> !__ret)

and get_nodes freq_table =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let freq_table = (Obj.magic freq_table : (string * string) list list) in
  let nodes = ref ([] : (string * string list) list) in
  let keys = ref (([] : (string) list)) in
  (try List.iter (fun f ->
    try
  let code = (match List.assoc_opt (__str ("bit")) (f) with Some v -> v | None -> "") in
  let edge = (match List.assoc_opt (__str ("edge")) (f) with Some v -> v | None -> "") in
  if (List.mem_assoc (__str (code)) !nodes) then (
  nodes := ((__str (code), (List.append ((match List.assoc_opt (__str (code)) (!nodes) with Some v -> v | None -> [])) [(Obj.magic (edge) : string)])) :: List.remove_assoc (__str (code)) (!nodes));
  ) else (
  nodes := ((__str (code), [edge]) :: List.remove_assoc (__str (code)) (!nodes));
  keys := (Obj.magic (List.append (!keys) [(Obj.magic (code) : string)]) : string list);
  );
    with Continue -> ()) (freq_table) with Break -> ());
  __ret := (Obj.magic ([(__str ("map"), Obj.repr (!nodes)); (__str ("keys"), Obj.repr (!keys))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and get_cluster nodes =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let nodes = (Obj.magic nodes : (string * Obj.t) list) in
  let clusters = ref ([] : (string * string list) list) in
  let weights = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length ((match List.assoc_opt (__str ("keys")) (nodes) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []))) do
    try
  let code = (let __l = (match List.assoc_opt (__str ("keys")) (nodes) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []) in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  let wt = count_ones (code) in
  if (List.mem_assoc (__str (wt)) !clusters) then (
  clusters := ((__str (wt), (List.append ((match List.assoc_opt (__str (wt)) (!clusters) with Some v -> v | None -> [])) [(Obj.magic (code) : string)])) :: List.remove_assoc (__str (wt)) (!clusters));
  ) else (
  clusters := ((__str (wt), [code]) :: List.remove_assoc (__str (wt)) (!clusters));
  weights := (Obj.magic (List.append (!weights) [(Obj.magic (wt) : int)]) : int list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("clusters"), Obj.repr (!clusters)); (__str ("weights"), Obj.repr (!weights))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and get_support clusters =
  let __ret = ref ([] : (int) list) in
  (try
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let sup = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length ((match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []))) do
    try
  let w = (let __l = (match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []) in let __i = !i in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  sup := (Obj.magic (List.append (!sup) [(Obj.magic (((w * 100) / List.length ((match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> [])))) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sup) : int list); raise Return
  with Return -> !__ret)

and contains_bits a b =
  let __ret = ref false in
  (try
  let i = ref (0) in
  (try while (!i < String.length (a)) do
    try
  let c1 = (let __s = a in let __st = !i in let __en = (!i + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  let c2 = (let __s = b in let __st = !i in let __en = (!i + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  if ((c1 = "1") && (c2 <> "1")) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and max_cluster_key clusters =
  let __ret = ref 0 in
  (try
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let m = ref (0) in
  let i = ref (0) in
  (try while (!i < List.length ((match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []))) do
    try
  let w = (let __l = (match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []) in let __i = !i in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  if (w > !m) then (
  m := w;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : int); raise Return
  with Return -> !__ret)

and get_cluster_codes clusters wt =
  let __ret = ref ([] : (string) list) in
  (try
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let wt = (Obj.magic wt : int) in
  if (List.mem_assoc (__str (wt)) (match List.assoc_opt (__str ("clusters")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) then (
  __ret := (Obj.magic ((match List.assoc_opt (__str (wt)) ((match List.assoc_opt (__str ("clusters")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) : string list); raise Return
  );
  __ret := (Obj.magic ([]) : string list); raise Return
  with Return -> !__ret)

and create_edge nodes graph gkeys clusters c1 maxk =
  let __ret = ref ([] : (string) list) in
  (try
  let nodes = (Obj.magic nodes : (string * Obj.t) list) in
  graph := (Obj.magic !graph : (string * string list) list);
  let gkeys = (Obj.magic gkeys : string list) in
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let c1 = (Obj.magic c1 : int) in
  let maxk = (Obj.magic maxk : int) in
  let keys = ref (gkeys) in
  let codes1 = ref (get_cluster_codes ((Obj.magic clusters : (string * Obj.t) list)) (Obj.repr (c1))) in
  let idx1 = ref (0) in
  (try while (!idx1 < List.length (!codes1)) do
    try
  let i_code = (let __l = !codes1 in let __i = !idx1 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  let count = ref (0) in
  let c2 = ref ((c1 + 1)) in
  (try while (!c2 <= maxk) do
    try
  let codes2 = ref (get_cluster_codes ((Obj.magic clusters : (string * Obj.t) list)) (Obj.repr (!c2))) in
  let j = ref (0) in
  (try while (!j < List.length (!codes2)) do
    try
  let j_code = (let __l = !codes2 in let __i = !j in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  if contains_bits (i_code) (j_code) then (
  if (List.mem_assoc (__str (i_code)) !graph) then (
  graph := ((__str (i_code), (List.append ((match List.assoc_opt (__str (i_code)) (!graph) with Some v -> v | None -> [])) [(Obj.magic (j_code) : string)])) :: List.remove_assoc (__str (i_code)) (!graph));
  ) else (
  graph := ((__str (i_code), [j_code]) :: List.remove_assoc (__str (i_code)) (!graph));
  if not (contains (!keys) (i_code)) then (
  keys := (Obj.magic (List.append (!keys) [(Obj.magic (i_code) : string)]) : string list);
  );
  );
  if not (contains (!keys) (j_code)) then (
  keys := (Obj.magic (List.append (!keys) [(Obj.magic (j_code) : string)]) : string list);
  );
  count := (!count + 1);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if (!count = 0) then (
  c2 := (!c2 + 1);
  ) else (
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
  idx1 := (!idx1 + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!keys) : string list); raise Return
  with Return -> !__ret)

and construct_graph clusters nodes =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let nodes = (Obj.magic nodes : (string * Obj.t) list) in
  let maxk = max_cluster_key ((Obj.magic clusters : (string * Obj.t) list)) in
  let top_codes = ref (get_cluster_codes ((Obj.magic clusters : (string * Obj.t) list)) (Obj.repr (maxk))) in
  let graph = ref ([] : (string * string list) list) in
  let keys = ref (["Header"]) in
  graph := ((__str ("Header"), []) :: List.remove_assoc (__str ("Header")) (!graph));
  let i = ref (0) in
  (try while (!i < List.length (!top_codes)) do
    try
  let code = (let __l = !top_codes in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  graph := ((__str ("Header"), (List.append ((match List.assoc_opt (__str ("Header")) (!graph) with Some v -> v | None -> [])) [(Obj.magic (code) : string)])) :: List.remove_assoc (__str ("Header")) (!graph));
  graph := ((__str (code), ["Header"]) :: List.remove_assoc (__str (code)) (!graph));
  keys := (Obj.magic (List.append (!keys) [(Obj.magic (code) : string)]) : string list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let c = ref (1) in
  (try while (!c < maxk) do
    try
  keys := (Obj.magic create_edge ((Obj.magic nodes : (string * Obj.t) list)) (graph) (!keys) ((Obj.magic clusters : (string * Obj.t) list)) (Obj.repr (!c)) (Obj.repr (maxk)) : string list);
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str ("edges"), Obj.repr (!graph)); (__str ("keys"), Obj.repr (!keys))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)


let paths = ref (([] : (string list) list))
let rec copy_list lst =
  let __ret = ref ([] : (string) list) in
  (try
  let lst = (Obj.magic lst : string list) in
  let n = ref (([] : (string) list)) in
  (try List.iter (fun v ->
    try
  n := (Obj.magic (List.append (!n) [(Obj.magic (v) : string)]) : string list);
    with Continue -> ()) (lst) with Break -> ());
  __ret := (Obj.magic (!n) : string list); raise Return
  with Return -> !__ret)

and my_dfs graph start end_ path =
  let __ret = ref (Obj.magic 0) in
  (try
  let graph = (Obj.magic graph : (string * string list) list) in
  let path = (Obj.magic path : string list) in
  let new_path = ref (copy_list (path)) in
  new_path := (Obj.magic (List.append (!new_path) [(Obj.magic (start) : string)]) : string list);
  if (start = end_) then (
  paths := (Obj.magic (List.append (!paths) [(Obj.magic (!new_path) : string list)]) : string list list);
  __ret := (); raise Return
  );
  (try List.iter (fun node ->
    try
  let seen = ref (false) in
  (try List.iter (fun p ->
    try
  if (p = node) then (
  seen := true;
  );
    with Continue -> ()) (!new_path) with Break -> ());
  if not (!seen) then (
  ignore (my_dfs ((Obj.magic graph : (string * string list) list)) (node) (end_) (!new_path));
  );
    with Continue -> ()) ((match List.assoc_opt (__str (start)) (graph) with Some v -> v | None -> [])) with Break -> ());
    !__ret
  with Return -> !__ret)

and find_freq_subgraph_given_support s clusters graph =
  let __ret = ref (Obj.magic 0) in
  (try
  let s = (Obj.magic s : int) in
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let graph = (Obj.magic graph : (string * Obj.t) list) in
  let k = ((s * List.length ((match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []))) / 100) in
  let codes = ref (get_cluster_codes ((Obj.magic clusters : (string * Obj.t) list)) (Obj.repr (k))) in
  let i = ref (0) in
  (try while (!i < List.length (!codes)) do
    try
  ignore (my_dfs ((Obj.magic (match List.assoc_opt (__str ("edges")) (graph) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * string list) list)) ((let __l = !codes in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) ("Header") ((Obj.magic [] : string list)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and node_edges nodes code =
  let __ret = ref ([] : (string) list) in
  (try
  let nodes = (Obj.magic nodes : (string * Obj.t) list) in
  __ret := (Obj.magic ((match List.assoc_opt (__str (code)) ((match List.assoc_opt (__str ("map")) (nodes) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) : string list); raise Return
  with Return -> !__ret)

and freq_subgraphs_edge_list paths nodes =
  let __ret = ref ([] : (string list list) list) in
  (try
  let paths = (Obj.magic paths : string list list) in
  let nodes = (Obj.magic nodes : (string * Obj.t) list) in
  let freq_sub_el = ref (([] : (string list list) list)) in
  (try List.iter (fun path ->
    try
  let el = ref (([] : (string list) list)) in
  let j = ref (0) in
  (try while (!j < (List.length (path) - 1)) do
    try
  let code = (let __l = path in let __i = !j in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  let edge_list = ref (node_edges ((Obj.magic nodes : (string * Obj.t) list)) (code)) in
  let e = ref (0) in
  (try while (!e < List.length (!edge_list)) do
    try
  let edge = (let __l = !edge_list in let __i = !e in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  let a = (let __s = edge in let __st = 0 in let __en = 1 in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  let b = (let __s = edge in let __st = 1 in let __en = 2 in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  el := (Obj.magic (List.append (!el) [(Obj.magic ([a; b]) : string list)]) : string list list);
  e := (!e + 1);
    with Continue -> ()
  done with Break -> ());
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  freq_sub_el := (Obj.magic (List.append (!freq_sub_el) [(Obj.magic (!el) : string list list)]) : string list list list);
    with Continue -> ()) (paths) with Break -> ());
  __ret := (Obj.magic (!freq_sub_el) : string list list list); raise Return
  with Return -> !__ret)

and print_all nodes support clusters graph freq_subgraph_edge_list =
  let __ret = ref (Obj.magic 0) in
  (try
  let nodes = (Obj.magic nodes : (string * Obj.t) list) in
  let support = (Obj.magic support : int list) in
  let clusters = (Obj.magic clusters : (string * Obj.t) list) in
  let graph = (Obj.magic graph : (string * Obj.t) list) in
  let freq_subgraph_edge_list = (Obj.magic freq_subgraph_edge_list : string list list list) in
  print_string "\nNodes\n";
  let i = ref (0) in
  (try while (!i < List.length ((match List.assoc_opt (__str ("keys")) (nodes) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []))) do
    try
  let code = (let __l = (match List.assoc_opt (__str ("keys")) (nodes) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []) in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  print_endline (code);
  print_endline (__show (match List.assoc_opt (__str (code)) ((match List.assoc_opt (__str ("map")) (nodes) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  print_string "\nSupport\n";
  print_endline (__show_list support);
  print_string "\nCluster\n";
  let j = ref (0) in
  (try while (!j < List.length ((match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []))) do
    try
  let w = (let __l = (match List.assoc_opt (__str ("weights")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : int list) | None -> []) in let __i = !j in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  print_endline ((((string_of_int (Obj.magic (w) : int)) ^ ":") ^ (__str (Obj.magic ((match List.assoc_opt (__str (w)) ((match List.assoc_opt (__str ("clusters")) (clusters) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> [])) : Obj.t))));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  print_string "\nGraph\n";
  let k = ref (0) in
  (try while (!k < List.length ((match List.assoc_opt (__str ("keys")) (graph) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []))) do
    try
  let key = (let __l = (match List.assoc_opt (__str ("keys")) (graph) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []) in let __i = !k in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  print_endline (key);
  print_endline (__show (match List.assoc_opt (__str (key)) ((match List.assoc_opt (__str ("edges")) (graph) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : string list) | None -> []));
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  print_string "\nEdge List of Frequent subgraphs\n";
  (try List.iter (fun el ->
    try
  print_endline (__show_list el);
    with Continue -> ()) (freq_subgraph_edge_list) with Break -> ());
    !__ret
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let frequency_table = ref (get_frequency_table (!_edge_array)) in
  let nodes = ref (get_nodes (!frequency_table)) in
  let clusters = ref (get_cluster (!nodes)) in
  let support = ref (get_support (!clusters)) in
  let graph = ref (construct_graph (!clusters) (!nodes)) in
  ignore (find_freq_subgraph_given_support (Obj.repr (60)) (!clusters) (!graph));
  let freq_subgraph_edge_list = ref (freq_subgraphs_edge_list (!paths) (!nodes)) in
  ignore (print_all (!nodes) (!support) (!clusters) (!graph) (!freq_subgraph_edge_list));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
