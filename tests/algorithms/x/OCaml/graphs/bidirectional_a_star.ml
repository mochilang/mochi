(* Generated by Mochi transpiler v0.10.65 on 2025-08-14 10:04 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0 else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _heuristic = 0
let grid = ref ([[0; 0; 0; 0; 0; 0; 0]; [0; 1; 0; 0; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0]; [0; 0; 1; 0; 0; 0; 0]; [1; 0; 1; 0; 0; 0; 0]; [0; 0; 0; 0; 0; 0; 0]; [0; 0; 0; 0; 1; 0; 0]])
let delta = ref ([[-(1); 0]; [0; -(1)]; [1; 0]; [0; 1]])
let rec abs x =
  let __ret = ref 0 in
  (try
  let x = (Obj.magic x : int) in
  if (x < 0) then (
  __ret := (Obj.magic (-(x)) : int); raise Return
  );
  __ret := (Obj.magic (x) : int); raise Return
  with Return -> !__ret)

and sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x <= 0.0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  let guess = ref (x) in
  let i = ref (0) in
  (try while (!i < 10) do
    try
  guess := ((!guess +. (x /. !guess)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!guess) : float); raise Return
  with Return -> !__ret)

and heuristic a b =
  let __ret = ref 0.0 in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  let dy = ((match List.assoc_opt (__str ("y")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) - (match List.assoc_opt (__str ("y")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) in
  let dx = ((match List.assoc_opt (__str ("x")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) - (match List.assoc_opt (__str ("x")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) in
  if (_heuristic = 1) then (
  __ret := (Obj.magic (float_of_int ((abs dy + abs dx))) : float); raise Return
  );
  let dyf = float_of_int (dy) in
  let dxf = float_of_int (dx) in
  __ret := (Obj.magic (sqrtApprox (Obj.repr (((dyf *. dyf) +. (dxf *. dxf))))) : float); raise Return
  with Return -> !__ret)

and pos_equal a b =
  let __ret = ref false in
  (try
  let a = (Obj.magic a : (string * Obj.t) list) in
  let b = (Obj.magic b : (string * Obj.t) list) in
  __ret := (Obj.magic ((((match List.assoc_opt (__str ("y")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) = (match List.assoc_opt (__str ("y")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) && ((match List.assoc_opt (__str ("x")) (a) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) = (match List.assoc_opt (__str ("x")) (b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)))) : bool); raise Return
  with Return -> !__ret)

and contains_pos lst p =
  let __ret = ref false in
  (try
  let lst = (Obj.magic lst : (string * Obj.t) list list) in
  let p = (Obj.magic p : (string * Obj.t) list) in
  let i = ref (0) in
  (try while (!i < List.length (lst)) do
    try
  if pos_equal ((Obj.magic (let __l = lst in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) : (string * Obj.t) list)) ((Obj.magic p : (string * Obj.t) list)) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and open_index_of_pos open_ p =
  let __ret = ref 0 in
  (try
  let open_ = (Obj.magic open_ : (string * Obj.t) list list) in
  let p = (Obj.magic p : (string * Obj.t) list) in
  let i = ref (0) in
  (try while (!i < List.length (open_)) do
    try
  if pos_equal ((Obj.magic (match List.assoc_opt (__str ("pos")) ((let __l = open_ in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list)) ((Obj.magic p : (string * Obj.t) list)) then (
  __ret := (Obj.magic (!i) : int); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((0 - 1)) : int); raise Return
  with Return -> !__ret)

and remove_node_at nodes idx =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let nodes = (Obj.magic nodes : (string * Obj.t) list list) in
  let idx = (Obj.magic idx : int) in
  let res = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (nodes)) do
    try
  if (!i <> idx) then (
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = nodes in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and append_pos_list path p =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let path = (Obj.magic path : (string * Obj.t) list list) in
  let p = (Obj.magic p : (string * Obj.t) list) in
  let res = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (path)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = path in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (p) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  __ret := (Obj.magic (!res) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and reverse_pos_list lst =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let lst = (Obj.magic lst : (string * Obj.t) list list) in
  let res = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref ((List.length (lst) - 1)) in
  (try while (!i >= 0) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = lst in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and concat_pos_lists a b =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let a = (Obj.magic a : (string * Obj.t) list list) in
  let b = (Obj.magic b : (string * Obj.t) list list) in
  let res = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = a in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let j = ref (0) in
  (try while (!j < List.length (b)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = b in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and get_successors p =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let p = (Obj.magic p : (string * Obj.t) list) in
  let res = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!delta)) do
    try
  let nx = ((match List.assoc_opt (__str ("x")) (p) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + (let __l = (let __l = !delta in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) in
  let ny = ((match List.assoc_opt (__str ("y")) (p) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + (let __l = (let __l = !delta in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) in
  if ((((nx >= 0) && (ny >= 0)) && (nx < List.length ((let __l = !grid in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])))) && (ny < List.length (!grid))) then (
  if ((let __l = (let __l = !grid in let __i = ny in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in let __i = nx in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) = 0) then (
  res := (Obj.magic (List.append (!res) [(Obj.magic ([(__str ("y"), Obj.repr (ny)); (__str ("x"), Obj.repr (nx))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and find_lowest_f open_ =
  let __ret = ref 0 in
  (try
  let open_ = (Obj.magic open_ : (string * Obj.t) list list) in
  let best = ref (0) in
  let i = ref (1) in
  (try while (!i < List.length (open_)) do
    try
  if ((match List.assoc_opt (__str ("f_cost")) ((let __l = open_ in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) < (match List.assoc_opt (__str ("f_cost")) ((let __l = open_ in let __i = !best in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) then (
  best := !i;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!best) : int); raise Return
  with Return -> !__ret)

and astar start goal =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let start = (Obj.magic start : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let h0 = heuristic ((Obj.magic start : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list)) in
  let open_ = ref ([[(__str ("pos"), Obj.repr (start)); (__str ("g_cost"), Obj.repr (0)); (__str ("h_cost"), Obj.repr (h0)); (__str ("f_cost"), Obj.repr (h0)); (__str ("path"), Obj.repr ([start]))]]) in
  let closed = ref (([] : ((string * Obj.t) list) list)) in
  (try while (List.length (!open_) > 0) do
    try
  let idx = find_lowest_f (!open_) in
  let current = ref ((let __l = !open_ in let __i = idx in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  open_ := remove_node_at (!open_) (Obj.repr (idx));
  if pos_equal ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list)) then (
  __ret := (Obj.magic ((match List.assoc_opt (__str ("path")) (!current) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) : (string * Obj.t) list list); raise Return
  );
  closed := (Obj.magic (List.append (!closed) [(Obj.magic ((match List.assoc_opt (__str ("pos")) (!current) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  let succ = ref (get_successors ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list))) in
  let i = ref (0) in
  (try while (!i < List.length (!succ)) do
    try
  let pos = (let __l = !succ in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in
  if contains_pos (!closed) (pos) then (
  i := (!i + 1);
  raise Continue;
  );
  let tentative_g = ((match List.assoc_opt (__str ("g_cost")) (!current) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + 1) in
  let idx_open = open_index_of_pos (!open_) (pos) in
  if ((idx_open = (0 - 1)) || (tentative_g < (match List.assoc_opt (__str ("g_cost")) ((let __l = !open_ in let __i = idx_open in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) then (
  let new_path = ref (append_pos_list ((match List.assoc_opt (__str ("path")) (!current) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) (pos)) in
  let h = heuristic (pos) ((Obj.magic goal : (string * Obj.t) list)) in
  let f = (float_of_int (tentative_g) +. h) in
  if (idx_open <> (0 - 1)) then (
  open_ := remove_node_at (!open_) (Obj.repr (idx_open));
  );
  open_ := (Obj.magic (List.append (!open_) [(Obj.magic ([(__str ("pos"), Obj.repr (pos)); (__str ("g_cost"), Obj.repr (tentative_g)); (__str ("h_cost"), Obj.repr (h)); (__str ("f_cost"), Obj.repr (f)); (__str ("path"), Obj.repr (!new_path))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([start]) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and combine_paths fwd bwd =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let fwd = (Obj.magic fwd : (string * Obj.t) list) in
  let bwd = (Obj.magic bwd : (string * Obj.t) list) in
  let bwd_copy = ref (([] : ((string * Obj.t) list) list)) in
  let i = ref (0) in
  (try while (!i < (List.length ((match List.assoc_opt (__str ("path")) (bwd) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) - 1)) do
    try
  bwd_copy := (Obj.magic (List.append (!bwd_copy) [(Obj.magic ((let __l = (match List.assoc_opt (__str ("path")) (bwd) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> []) in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  bwd_copy := reverse_pos_list (!bwd_copy);
  __ret := (Obj.magic (concat_pos_lists ((match List.assoc_opt (__str ("path")) (fwd) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) (!bwd_copy)) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and bidirectional_astar start goal =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let start = (Obj.magic start : (string * Obj.t) list) in
  let goal = (Obj.magic goal : (string * Obj.t) list) in
  let hf = heuristic ((Obj.magic start : (string * Obj.t) list)) ((Obj.magic goal : (string * Obj.t) list)) in
  let hb = heuristic ((Obj.magic goal : (string * Obj.t) list)) ((Obj.magic start : (string * Obj.t) list)) in
  let open_f = ref ([[(__str ("pos"), Obj.repr (start)); (__str ("g_cost"), Obj.repr (0)); (__str ("h_cost"), Obj.repr (hf)); (__str ("f_cost"), Obj.repr (hf)); (__str ("path"), Obj.repr ([start]))]]) in
  let open_b = ref ([[(__str ("pos"), Obj.repr (goal)); (__str ("g_cost"), Obj.repr (0)); (__str ("h_cost"), Obj.repr (hb)); (__str ("f_cost"), Obj.repr (hb)); (__str ("path"), Obj.repr ([goal]))]]) in
  let closed_f = ref (([] : ((string * Obj.t) list) list)) in
  let closed_b = ref (([] : ((string * Obj.t) list) list)) in
  (try while ((List.length (!open_f) > 0) && (List.length (!open_b) > 0)) do
    try
  let idx_f = find_lowest_f (!open_f) in
  let current_f = ref ((let __l = !open_f in let __i = idx_f in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  open_f := remove_node_at (!open_f) (Obj.repr (idx_f));
  let idx_b = find_lowest_f (!open_b) in
  let current_b = ref ((let __l = !open_b in let __i = idx_b in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  open_b := remove_node_at (!open_b) (Obj.repr (idx_b));
  if pos_equal ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current_f) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list)) ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current_b) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list)) then (
  __ret := (Obj.magic (combine_paths ((Obj.magic !current_f : (string * Obj.t) list)) ((Obj.magic !current_b : (string * Obj.t) list))) : (string * Obj.t) list list); raise Return
  );
  closed_f := (Obj.magic (List.append (!closed_f) [(Obj.magic ((match List.assoc_opt (__str ("pos")) (!current_f) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  closed_b := (Obj.magic (List.append (!closed_b) [(Obj.magic ((match List.assoc_opt (__str ("pos")) (!current_b) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> [])) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  let succ_f = ref (get_successors ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current_f) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list))) in
  let i = ref (0) in
  (try while (!i < List.length (!succ_f)) do
    try
  let pos = (let __l = !succ_f in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in
  if contains_pos (!closed_f) (pos) then (
  i := (!i + 1);
  raise Continue;
  );
  let tentative_g = ((match List.assoc_opt (__str ("g_cost")) (!current_f) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + 1) in
  let h = heuristic (pos) ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current_b) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list)) in
  let f = (float_of_int (tentative_g) +. h) in
  let idx_open = open_index_of_pos (!open_f) (pos) in
  if ((idx_open = (0 - 1)) || (tentative_g < (match List.assoc_opt (__str ("g_cost")) ((let __l = !open_f in let __i = idx_open in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) then (
  let new_path = ref (append_pos_list ((match List.assoc_opt (__str ("path")) (!current_f) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) (pos)) in
  if (idx_open <> (0 - 1)) then (
  open_f := remove_node_at (!open_f) (Obj.repr (idx_open));
  );
  open_f := (Obj.magic (List.append (!open_f) [(Obj.magic ([(__str ("pos"), Obj.repr (pos)); (__str ("g_cost"), Obj.repr (tentative_g)); (__str ("h_cost"), Obj.repr (h)); (__str ("f_cost"), Obj.repr (f)); (__str ("path"), Obj.repr (!new_path))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let succ_b = ref (get_successors ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current_b) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list))) in
  i := 0;
  (try while (!i < List.length (!succ_b)) do
    try
  let pos = (let __l = !succ_b in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> []) in
  if contains_pos (!closed_b) (pos) then (
  i := (!i + 1);
  raise Continue;
  );
  let tentative_g = ((match List.assoc_opt (__str ("g_cost")) (!current_b) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0) + 1) in
  let h = heuristic (pos) ((Obj.magic (match List.assoc_opt (__str ("pos")) (!current_f) with Some v -> (Obj.obj (v : Obj.t) : ( string * Obj.t ) list) | None -> []) : (string * Obj.t) list)) in
  let f = (float_of_int (tentative_g) +. h) in
  let idx_open = open_index_of_pos (!open_b) (pos) in
  if ((idx_open = (0 - 1)) || (tentative_g < (match List.assoc_opt (__str ("g_cost")) ((let __l = !open_b in let __i = idx_open in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0))) then (
  let new_path = ref (append_pos_list ((match List.assoc_opt (__str ("path")) (!current_b) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) (pos)) in
  if (idx_open <> (0 - 1)) then (
  open_b := remove_node_at (!open_b) (Obj.repr (idx_open));
  );
  open_b := (Obj.magic (List.append (!open_b) [(Obj.magic ([(__str ("pos"), Obj.repr (pos)); (__str ("g_cost"), Obj.repr (tentative_g)); (__str ("h_cost"), Obj.repr (h)); (__str ("f_cost"), Obj.repr (f)); (__str ("path"), Obj.repr (!new_path))]) : (string * Obj.t) list)]) : (string * Obj.t) list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([start]) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and path_to_string path =
  let __ret = ref "" in
  (try
  let path = (Obj.magic path : (string * Obj.t) list list) in
  if (List.length (path) = 0) then (
  __ret := (Obj.magic ("[]") : string); raise Return
  );
  let s = ref ((((("[(" ^ (string_of_int (Obj.magic ((match List.assoc_opt (__str ("y")) ((let __l = path in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) : int))) ^ ", ") ^ (string_of_int (Obj.magic ((match List.assoc_opt (__str ("x")) ((let __l = path in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) : int))) ^ ")")) in
  let i = ref (1) in
  (try while (!i < List.length (path)) do
    try
  s := (((((!s ^ ", (") ^ (string_of_int (Obj.magic ((match List.assoc_opt (__str ("y")) ((let __l = path in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) : int))) ^ ", ") ^ (string_of_int (Obj.magic ((match List.assoc_opt (__str ("x")) ((let __l = path in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) with Some v -> (Obj.obj (v : Obj.t) : int) | None -> 0)) : int))) ^ ")");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)


let start = [(__str ("y"), Obj.repr (0)); (__str ("x"), Obj.repr (0))]
let goal = [(__str ("y"), Obj.repr ((List.length (!grid) - 1))); (__str ("x"), Obj.repr ((List.length ((let __l = !grid in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) - 1)))]
let path1 = ref (astar (start) (goal))
let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  print_endline ((path_to_string ((Obj.magic !path1 : (string * Obj.t) list list))));
  let path2 = ref (bidirectional_astar (start) (goal)) in
  print_endline ((path_to_string ((Obj.magic !path2 : (string * Obj.t) list list))));
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
