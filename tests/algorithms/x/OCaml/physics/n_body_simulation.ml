(* Generated by Mochi transpiler v0.10.69 on 2025-08-22 13:05 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic r : int) = 0
  else
    match tag r with
    | 0 -> __is_list (field r 1)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec make_body px py vx vy mass =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let px = (Obj.magic px : float) in
  let py = (Obj.magic py : float) in
  let vx = (Obj.magic vx : float) in
  let vy = (Obj.magic vy : float) in
  let mass = (Obj.magic mass : float) in
  __ret := (Obj.magic ([(__str (Obj.repr ("position_x")), Obj.repr (px)); (__str (Obj.repr ("position_y")), Obj.repr (py)); (__str (Obj.repr ("velocity_x")), Obj.repr (vx)); (__str (Obj.repr ("velocity_y")), Obj.repr (vy)); (__str (Obj.repr ("mass")), Obj.repr (mass))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and update_velocity body force_x force_y delta_time =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  body := (Obj.magic !body : (string * Obj.t) list);
  let force_x = (Obj.magic force_x : float) in
  let force_y = (Obj.magic force_y : float) in
  let delta_time = (Obj.magic delta_time : float) in
  body := ((__str (Obj.repr ("velocity_x")), Obj.repr (Obj.magic (((match List.assoc_opt (__str (Obj.repr ("velocity_x"))) (!body) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) +. (force_x *. delta_time))) : float)) :: List.remove_assoc (__str (Obj.repr ("velocity_x"))) (Obj.magic (!body) : (string * Obj.t) list));
  body := ((__str (Obj.repr ("velocity_y")), Obj.repr (Obj.magic (((match List.assoc_opt (__str (Obj.repr ("velocity_y"))) (!body) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) +. (force_y *. delta_time))) : float)) :: List.remove_assoc (__str (Obj.repr ("velocity_y"))) (Obj.magic (!body) : (string * Obj.t) list));
  __ret := (Obj.magic (!body) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and update_position body delta_time =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  body := (Obj.magic !body : (string * Obj.t) list);
  let delta_time = (Obj.magic delta_time : float) in
  body := ((__str (Obj.repr ("position_x")), Obj.repr (Obj.magic (((match List.assoc_opt (__str (Obj.repr ("position_x"))) (!body) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) +. ((match List.assoc_opt (__str (Obj.repr ("velocity_x"))) (!body) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. delta_time))) : float)) :: List.remove_assoc (__str (Obj.repr ("position_x"))) (Obj.magic (!body) : (string * Obj.t) list));
  body := ((__str (Obj.repr ("position_y")), Obj.repr (Obj.magic (((match List.assoc_opt (__str (Obj.repr ("position_y"))) (!body) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) +. ((match List.assoc_opt (__str (Obj.repr ("velocity_y"))) (!body) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. delta_time))) : float)) :: List.remove_assoc (__str (Obj.repr ("position_y"))) (Obj.magic (!body) : (string * Obj.t) list));
  __ret := (Obj.magic (!body) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and make_body_system bodies g tf sf =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let bodies = (Obj.magic bodies : (string * Obj.t) list list) in
  let g = (Obj.magic g : float) in
  let tf = (Obj.magic tf : float) in
  let sf = (Obj.magic sf : float) in
  __ret := (Obj.magic ([(__str (Obj.repr ("bodies")), Obj.repr (bodies)); (__str (Obj.repr ("gravitation_constant")), Obj.repr (g)); (__str (Obj.repr ("time_factor")), Obj.repr (tf)); (__str (Obj.repr ("softening_factor")), Obj.repr (sf))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let guess = ref ((x /. 2.0)) in
  let i = ref (0) in
  (try while (!i < 20) do
    try
  guess := ((!guess +. (x /. !guess)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!guess) : float); raise Return
  with Return -> !__ret)

and update_system system delta_time =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  system := (Obj.magic !system : (string * Obj.t) list);
  let delta_time = (Obj.magic delta_time : float) in
  let bodies = ref ((match List.assoc_opt (__str (Obj.repr ("bodies"))) (!system) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> [])) in
  let i = ref (0) in
  (try while (!i < List.length (!bodies)) do
    try
  let body1 = ref ((let __l = !bodies in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let force_x = ref (0.0) in
  let force_y = ref (0.0) in
  let j = ref (0) in
  (try while (!j < List.length (!bodies)) do
    try
  if (!i <> !j) then (
  let body2 = ref ((let __l = !bodies in let __i = !j in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let dif_x = ((match List.assoc_opt (__str (Obj.repr ("position_x"))) (!body2) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (match List.assoc_opt (__str (Obj.repr ("position_x"))) (!body1) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) in
  let dif_y = ((match List.assoc_opt (__str (Obj.repr ("position_y"))) (!body2) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) -. (match List.assoc_opt (__str (Obj.repr ("position_y"))) (!body1) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) in
  let distance_sq = (((dif_x *. dif_x) +. (dif_y *. dif_y)) +. (match List.assoc_opt (__str (Obj.repr ("softening_factor"))) (!system) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) in
  let distance = sqrtApprox (Obj.repr (distance_sq)) in
  let denom = ((distance *. distance) *. distance) in
  force_x := (!force_x +. ((((match List.assoc_opt (__str (Obj.repr ("gravitation_constant"))) (!system) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. (match List.assoc_opt (__str (Obj.repr ("mass"))) (!body2) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) *. dif_x) /. denom));
  force_y := (!force_y +. ((((match List.assoc_opt (__str (Obj.repr ("gravitation_constant"))) (!system) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) *. (match List.assoc_opt (__str (Obj.repr ("mass"))) (!body2) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.)) *. dif_y) /. denom));
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  body1 := update_velocity (body1) (Obj.repr (!force_x)) (Obj.repr (!force_y)) (Obj.repr ((delta_time *. (match List.assoc_opt (__str (Obj.repr ("time_factor"))) (!system) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))));
  bodies := (List.mapi (fun __i __x -> if __i = !i then !body1 else __x) (!bodies));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  i := 0;
  (try while (!i < List.length (!bodies)) do
    try
  let body = ref ((let __l = !bodies in let __i = !i in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  body := update_position (body) (Obj.repr ((delta_time *. (match List.assoc_opt (__str (Obj.repr ("time_factor"))) (!system) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.))));
  bodies := (List.mapi (fun __i __x -> if __i = !i then !body else __x) (!bodies));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  system := ((__str (Obj.repr ("bodies")), Obj.repr (Obj.magic (!bodies) : (string * Obj.t) list list)) :: List.remove_assoc (__str (Obj.repr ("bodies"))) (Obj.magic (!system) : (string * Obj.t) list));
  __ret := (Obj.magic (!system) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let b1 = ref (make_body (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (1.0))) in
  let b2 = ref (make_body (Obj.repr (10.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (1.0))) in
  let sys1 = ref (make_body_system ((Obj.magic ([!b1; !b2]) : (string * Obj.t) list list)) (Obj.repr (1.0)) (Obj.repr (1.0)) (Obj.repr (0.0))) in
  sys1 := update_system (sys1) (Obj.repr (1.0));
  let b1_after = ref ((let __l = (match List.assoc_opt (__str (Obj.repr ("bodies"))) (!sys1) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let pos1x = (match List.assoc_opt (__str (Obj.repr ("position_x"))) (!b1_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  let pos1y = (match List.assoc_opt (__str (Obj.repr ("position_y"))) (!b1_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  print_endline (__str (Obj.repr ([(__str (Obj.repr ("x")), pos1x); (__str (Obj.repr ("y")), pos1y)])));
  let vel1x = (match List.assoc_opt (__str (Obj.repr ("velocity_x"))) (!b1_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  let vel1y = (match List.assoc_opt (__str (Obj.repr ("velocity_y"))) (!b1_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  print_endline (__str (Obj.repr ([(__str (Obj.repr ("vx")), vel1x); (__str (Obj.repr ("vy")), vel1y)])));
  let b3 = ref (make_body (Obj.repr ((-.(10.0)))) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (1.0))) in
  let b4 = ref (make_body (Obj.repr (10.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (0.0)) (Obj.repr (4.0))) in
  let sys2 = ref (make_body_system ((Obj.magic ([!b3; !b4]) : (string * Obj.t) list list)) (Obj.repr (1.0)) (Obj.repr (10.0)) (Obj.repr (0.0))) in
  sys2 := update_system (sys2) (Obj.repr (1.0));
  let b2_after = ref ((let __l = (match List.assoc_opt (__str (Obj.repr ("bodies"))) (!sys2) with Some v -> (Obj.obj (v : Obj.t) : (string * Obj.t) list list) | None -> []) in let __i = 0 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> v | None -> [])) in
  let pos2x = (match List.assoc_opt (__str (Obj.repr ("position_x"))) (!b2_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  let pos2y = (match List.assoc_opt (__str (Obj.repr ("position_y"))) (!b2_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  print_endline (__str (Obj.repr ([(__str (Obj.repr ("x")), pos2x); (__str (Obj.repr ("y")), pos2y)])));
  let vel2x = (match List.assoc_opt (__str (Obj.repr ("velocity_x"))) (!b2_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  let vel2y = (match List.assoc_opt (__str (Obj.repr ("velocity_y"))) (!b2_after) with Some v -> (Obj.obj (v : Obj.t) : float) | None -> 0.) in
  print_endline (__str (Obj.repr ([(__str (Obj.repr ("vx")), vel2x); (__str (Obj.repr ("vy")), vel2y)])));
    !__ret
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  ignore (main ());
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
