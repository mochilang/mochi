(* Generated by Mochi transpiler v0.10.60 on 2025-08-08 10:08 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat ", " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat ", " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec default_matrix_multiplication a b =
  let __ret = ref ([] : (int list) list) in
  (try
  __ret := (Obj.magic ([[((List.nth (List.nth (a) (0)) (0) * List.nth (List.nth (b) (0)) (0)) + (List.nth (List.nth (a) (0)) (1) * List.nth (List.nth (b) (1)) (0))); ((List.nth (List.nth (a) (0)) (0) * List.nth (List.nth (b) (0)) (1)) + (List.nth (List.nth (a) (0)) (1) * List.nth (List.nth (b) (1)) (1)))]; [((List.nth (List.nth (a) (1)) (0) * List.nth (List.nth (b) (0)) (0)) + (List.nth (List.nth (a) (1)) (1) * List.nth (List.nth (b) (1)) (0))); ((List.nth (List.nth (a) (1)) (0) * List.nth (List.nth (b) (0)) (1)) + (List.nth (List.nth (a) (1)) (1) * List.nth (List.nth (b) (1)) (1)))]]) : int list list); raise Return
  with Return -> !__ret)

and matrix_addition matrix_a matrix_b =
  let __ret = ref ([] : (int list) list) in
  (try
  let result = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (matrix_a)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length (List.nth (matrix_a) (!i))) do
    try
  row := (List.append (!row) [(Obj.magic ((List.nth (List.nth (matrix_a) (!i)) (!j) + List.nth (List.nth (matrix_b) (!i)) (!j))) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  result := (List.append (!result) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : int list list); raise Return
  with Return -> !__ret)

and matrix_subtraction matrix_a matrix_b =
  let __ret = ref ([] : (int list) list) in
  (try
  let result = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (matrix_a)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length (List.nth (matrix_a) (!i))) do
    try
  row := (List.append (!row) [(Obj.magic ((List.nth (List.nth (matrix_a) (!i)) (!j) - List.nth (List.nth (matrix_b) (!i)) (!j))) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  result := (List.append (!result) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : int list list); raise Return
  with Return -> !__ret)

and split_matrix a =
  let __ret = ref ([] : (int list list) list) in
  (try
  let n = List.length (a) in
  let mid = (n / 2) in
  let top_left = ref (([] : (int list) list)) in
  let top_right = ref (([] : (int list) list)) in
  let bot_left = ref (([] : (int list) list)) in
  let bot_right = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < mid) do
    try
  let left_row = ref (([] : (int) list)) in
  let right_row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < mid) do
    try
  left_row := (List.append (!left_row) [(Obj.magic (List.nth (List.nth (a) (!i)) (!j)) : int)]);
  right_row := (List.append (!right_row) [(Obj.magic (List.nth (List.nth (a) (!i)) ((!j + mid))) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  top_left := (List.append (!top_left) [(Obj.magic (!left_row) : int list)]);
  top_right := (List.append (!top_right) [(Obj.magic (!right_row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  i := mid;
  (try while (!i < n) do
    try
  let left_row = ref (([] : (int) list)) in
  let right_row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < mid) do
    try
  left_row := (List.append (!left_row) [(Obj.magic (List.nth (List.nth (a) (!i)) (!j)) : int)]);
  right_row := (List.append (!right_row) [(Obj.magic (List.nth (List.nth (a) (!i)) ((!j + mid))) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  bot_left := (List.append (!bot_left) [(Obj.magic (!left_row) : int list)]);
  bot_right := (List.append (!bot_right) [(Obj.magic (!right_row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([!top_left; !top_right; !bot_left; !bot_right]) : int list list list); raise Return
  with Return -> !__ret)

and matrix_dimensions matrix =
  let __ret = ref ([] : (int) list) in
  (try
  __ret := (Obj.magic ([List.length (matrix); List.length (List.nth (matrix) (0))]) : int list); raise Return
  with Return -> !__ret)

and next_power_of_two n =
  let __ret = ref 0 in
  (try
  let n = (Obj.magic n : int) in
  let p = ref (1) in
  (try while (!p < n) do
    try
  p := (!p * 2);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!p) : int); raise Return
  with Return -> !__ret)

and pad_matrix mat rows cols =
  let __ret = ref ([] : (int list) list) in
  (try
  let rows = (Obj.magic rows : int) in
  let cols = (Obj.magic cols : int) in
  let res = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < rows) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < cols) do
    try
  let v = ref (0) in
  if ((!i < List.length (mat)) && (!j < List.length (List.nth (mat) (0)))) then (
  v := List.nth (List.nth (mat) (!i)) (!j);
  );
  row := (List.append (!row) [(Obj.magic (!v) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (List.append (!res) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and actual_strassen matrix_a matrix_b =
  let __ret = ref ([] : (int list) list) in
  (try
  if (List.nth (matrix_dimensions (matrix_a)) (0) = 2) then (
  __ret := (Obj.magic (default_matrix_multiplication (matrix_a) (matrix_b)) : int list list); raise Return
  );
  let parts_a = ref (split_matrix (matrix_a)) in
  let a = ref (List.nth (!parts_a) (0)) in
  let b = ref (List.nth (!parts_a) (1)) in
  let c = ref (List.nth (!parts_a) (2)) in
  let d = ref (List.nth (!parts_a) (3)) in
  let parts_b = ref (split_matrix (matrix_b)) in
  let e = ref (List.nth (!parts_b) (0)) in
  let f = ref (List.nth (!parts_b) (1)) in
  let g = ref (List.nth (!parts_b) (2)) in
  let h = ref (List.nth (!parts_b) (3)) in
  let t1 = ref (actual_strassen (!a) (matrix_subtraction (!f) (!h))) in
  let t2 = ref (actual_strassen (matrix_addition (!a) (!b)) (!h)) in
  let t3 = ref (actual_strassen (matrix_addition (!c) (!d)) (!e)) in
  let t4 = ref (actual_strassen (!d) (matrix_subtraction (!g) (!e))) in
  let t5 = ref (actual_strassen (matrix_addition (!a) (!d)) (matrix_addition (!e) (!h))) in
  let t6 = ref (actual_strassen (matrix_subtraction (!b) (!d)) (matrix_addition (!g) (!h))) in
  let t7 = ref (actual_strassen (matrix_subtraction (!a) (!c)) (matrix_addition (!e) (!f))) in
  let top_left = ref (matrix_addition (matrix_subtraction (matrix_addition (!t5) (!t4)) (!t2)) (!t6)) in
  let top_right = ref (matrix_addition (!t1) (!t2)) in
  let bot_left = ref (matrix_addition (!t3) (!t4)) in
  let bot_right = ref (matrix_subtraction (matrix_subtraction (matrix_addition (!t1) (!t5)) (!t3)) (!t7)) in
  let new_matrix = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!top_right)) do
    try
  new_matrix := (List.append (!new_matrix) [(Obj.magic ((List.nth (!top_left) (!i) @ List.nth (!top_right) (!i))) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  i := 0;
  (try while (!i < List.length (!bot_right)) do
    try
  new_matrix := (List.append (!new_matrix) [(Obj.magic ((List.nth (!bot_left) (!i) @ List.nth (!bot_right) (!i))) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!new_matrix) : int list list); raise Return
  with Return -> !__ret)

and strassen matrix1 matrix2 =
  let __ret = ref ([] : (int list) list) in
  (try
  let dims1 = ref (matrix_dimensions (matrix1)) in
  let dims2 = ref (matrix_dimensions (matrix2)) in
  if (List.nth (!dims1) (1) <> List.nth (!dims2) (0)) then (
  __ret := (Obj.magic ([]) : int list list); raise Return
  );
  let maximum = (List.fold_left max min_int [List.nth (!dims1) (0); List.nth (!dims1) (1); List.nth (!dims2) (0); List.nth (!dims2) (1)]) in
  let size = next_power_of_two (Obj.repr (maximum)) in
  let new_matrix1 = ref (pad_matrix (matrix1) (Obj.repr (size)) (Obj.repr (size))) in
  let new_matrix2 = ref (pad_matrix (matrix2) (Obj.repr (size)) (Obj.repr (size))) in
  let result_padded = ref (actual_strassen (!new_matrix1) (!new_matrix2)) in
  let final_matrix = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.nth (!dims1) (0)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.nth (!dims2) (1)) do
    try
  row := (List.append (!row) [(Obj.magic (List.nth (List.nth (!result_padded) (!i)) (!j)) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  final_matrix := (List.append (!final_matrix) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!final_matrix) : int list list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let matrix1 = ref ([[2; 3; 4; 5]; [6; 4; 3; 1]; [2; 3; 6; 7]; [3; 1; 2; 4]; [2; 3; 4; 5]; [6; 4; 3; 1]; [2; 3; 6; 7]; [3; 1; 2; 4]; [2; 3; 4; 5]; [6; 2; 3; 1]]) in
  let matrix2 = ref ([[0; 2; 1; 1]; [16; 2; 3; 3]; [2; 2; 7; 7]; [13; 11; 22; 4]]) in
  let res = ref (strassen (!matrix1) (!matrix2)) in
  print_endline (__show_list !res);
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()