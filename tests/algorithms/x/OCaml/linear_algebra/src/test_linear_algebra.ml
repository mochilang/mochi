(* Generated by Mochi transpiler v0.10.63 on 2025-08-12 08:38 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic v : int) = 0
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec int_to_string n =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  if (n = 0) then (
  __ret := (Obj.magic ("0") : string); raise Return
  );
  let num = ref (n) in
  let neg = ref (false) in
  if (!num < 0) then (
  neg := true;
  num := -(!num);
  );
  let res = ref ("") in
  (try while (!num > 0) do
    try
  let digit = ((!num mod 10 + 10) mod 10) in
  let ch = (let __s = "0123456789" in let __st = digit in let __en = (digit + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) in
  res := (ch ^ !res);
  num := (!num / 10);
    with Continue -> ()
  done with Break -> ());
  if !neg then (
  res := ("-" ^ !res);
  );
  __ret := (Obj.magic (!res) : string); raise Return
  with Return -> !__ret)

and float_to_string x dec =
  let __ret = ref "" in
  (try
  let x = (Obj.magic x : float) in
  let dec = (Obj.magic dec : int) in
  let neg = ref (false) in
  let num = ref (x) in
  if (!num < 0.0) then (
  neg := true;
  num := (-.(!num));
  );
  let int_part = int_of_float (!num) in
  let res = ref (int_to_string (Obj.repr (int_part))) in
  if (dec > 0) then (
  res := (!res ^ ".");
  let frac = ref ((!num -. float_of_int (int_part))) in
  let i = ref (0) in
  (try while (!i < dec) do
    try
  frac := (!frac *. 10.0);
  let digit = int_of_float (!frac) in
  res := (!res ^ (let __s = "0123456789" in let __st = digit in let __en = (digit + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)));
  frac := (!frac -. float_of_int (digit));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  );
  if !neg then (
  res := ("-" ^ !res);
  );
  __ret := (Obj.magic (!res) : string); raise Return
  with Return -> !__ret)

and vector_component v i =
  let __ret = ref 0 in
  (try
  let v = (Obj.magic v : int list) in
  let i = (Obj.magic i : int) in
  __ret := (Obj.magic ((let __l = v in let __i = i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : int); raise Return
  with Return -> !__ret)

and vector_str_int v =
  let __ret = ref "" in
  (try
  let v = (Obj.magic v : int list) in
  let s = ref ("(") in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  s := (!s ^ int_to_string (Obj.repr ((let __l = v in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))));
  if ((!i + 1) < List.length (v)) then (
  s := (!s ^ ",");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ ")");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and vector_str_float v dec =
  let __ret = ref "" in
  (try
  let v = (Obj.magic v : float list) in
  let dec = (Obj.magic dec : int) in
  let s = ref ("(") in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  s := (!s ^ float_to_string (Obj.repr ((let __l = v in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) (Obj.repr (dec)));
  if ((!i + 1) < List.length (v)) then (
  s := (!s ^ ",");
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ ")");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and vector_add a b =
  let __ret = ref ([] : (int) list) in
  (try
  let a = (Obj.magic a : int list) in
  let b = (Obj.magic b : int list) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic (((let __l = a in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) + (let __l = b in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and vector_sub a b =
  let __ret = ref ([] : (int) list) in
  (try
  let a = (Obj.magic a : int list) in
  let b = (Obj.magic b : int list) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic (((let __l = a in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) - (let __l = b in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and vector_scalar_mul v s =
  let __ret = ref ([] : (float) list) in
  (try
  let v = (Obj.magic v : int list) in
  let s = (Obj.magic s : float) in
  let res = ref (([] : (float) list)) in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((float_of_int ((let __l = v in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) *. s)) : float)]) : float list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : float list); raise Return
  with Return -> !__ret)

and vector_dot a b =
  let __ret = ref 0 in
  (try
  let a = (Obj.magic a : int list) in
  let b = (Obj.magic b : int list) in
  let sum = ref (0) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  sum := (!sum + ((let __l = a in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) * (let __l = b in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : int); raise Return
  with Return -> !__ret)

and sqrt_newton x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x = 0.0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  let low = ref (0.0) in
  let high = ref (x) in
  if (x < 1.0) then (
  high := 1.0;
  );
  let mid = ref (0.0) in
  let i = ref (0) in
  (try while (!i < 40) do
    try
  mid := ((!low +. !high) /. 2.0);
  if ((!mid *. !mid) > x) then (
  high := !mid;
  ) else (
  low := !mid;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!mid) : float); raise Return
  with Return -> !__ret)

and euclidean_length v =
  let __ret = ref 0.0 in
  (try
  let v = (Obj.magic v : int list) in
  let sum = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (v)) do
    try
  let val_ = float_of_int ((let __l = v in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) in
  sum := (!sum +. (val_ *. val_));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (sqrt_newton (Obj.repr (!sum))) : float); raise Return
  with Return -> !__ret)

and zero_vector n =
  let __ret = ref ([] : (int) list) in
  (try
  let n = (Obj.magic n : int) in
  let v = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  v := (Obj.magic (List.append (!v) [(Obj.magic (0) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!v) : int list); raise Return
  with Return -> !__ret)

and unit_basis_vector n idx =
  let __ret = ref ([] : (int) list) in
  (try
  let n = (Obj.magic n : int) in
  let idx = (Obj.magic idx : int) in
  let v = ref (zero_vector (Obj.repr (n))) in
  v := (List.mapi (fun __i __x -> if __i = idx then 1 else __x) (!v));
  __ret := (Obj.magic (!v) : int list); raise Return
  with Return -> !__ret)

and axpy a x y =
  let __ret = ref ([] : (int) list) in
  (try
  let a = (Obj.magic a : int) in
  let x = (Obj.magic x : int list) in
  let y = (Obj.magic y : int list) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (x)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic (((a * (let __l = x in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) + (let __l = y in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and copy_vector x =
  let __ret = ref ([] : (int) list) in
  (try
  let x = (Obj.magic x : int list) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (x)) do
    try
  res := (Obj.magic (List.append (!res) [(Obj.magic ((let __l = x in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and change_component v idx val_ =
  let __ret = ref (Obj.magic 0) in
  (try
  v := (Obj.magic !v : int list);
  let idx = (Obj.magic idx : int) in
  let val_ = (Obj.magic val_ : int) in
  v := (List.mapi (fun __i __x -> if __i = idx then val_ else __x) (!v));
    !__ret
  with Return -> !__ret)

and matrix_str m =
  let __ret = ref "" in
  (try
  let m = (Obj.magic m : int list list) in
  let s = ref ("") in
  let i = ref (0) in
  (try while (!i < List.length (m)) do
    try
  s := (!s ^ "|");
  let j = ref (0) in
  (try while (!j < List.length ((let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) do
    try
  s := (!s ^ int_to_string (Obj.repr ((let __l = (let __l = m in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))));
  if ((!j + 1) < List.length ((let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) then (
  s := (!s ^ ",");
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "|\n");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and submatrix m row col =
  let __ret = ref ([] : (int list) list) in
  (try
  let m = (Obj.magic m : int list list) in
  let row = (Obj.magic row : int) in
  let col = (Obj.magic col : int) in
  let res = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (m)) do
    try
  if (!i <> row) then (
  let r = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) do
    try
  if (!j <> col) then (
  r := (Obj.magic (List.append (!r) [(Obj.magic ((let __l = (let __l = m in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : int)]) : int list);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!r) : int list)]) : int list list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and determinant m =
  let __ret = ref 0 in
  (try
  let m = (Obj.magic m : int list list) in
  let n = List.length (m) in
  if (n = 1) then (
  __ret := (Obj.magic ((let __l = (let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : int); raise Return
  );
  if (n = 2) then (
  __ret := (Obj.magic ((((let __l = (let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) * (let __l = (let __l = m in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) - ((let __l = (let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) * (let __l = (let __l = m in let __i = 1 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))))) : int); raise Return
  );
  let det = ref (0) in
  let c = ref (0) in
  (try while (!c < n) do
    try
  let sub = ref (submatrix (m) (Obj.repr (0)) (Obj.repr (!c))) in
  let sign = ref (1) in
  if (((!c mod 2 + 2) mod 2) = 1) then (
  sign := -(1);
  );
  det := (!det + ((!sign * (let __l = (let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !c in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) * determinant (!sub)));
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!det) : int); raise Return
  with Return -> !__ret)

and matrix_minor m row col =
  let __ret = ref 0 in
  (try
  let m = (Obj.magic m : int list list) in
  let row = (Obj.magic row : int) in
  let col = (Obj.magic col : int) in
  __ret := (Obj.magic (determinant (submatrix (m) (Obj.repr (row)) (Obj.repr (col)))) : int); raise Return
  with Return -> !__ret)

and matrix_cofactor m row col =
  let __ret = ref 0 in
  (try
  let m = (Obj.magic m : int list list) in
  let row = (Obj.magic row : int) in
  let col = (Obj.magic col : int) in
  let sign = ref (1) in
  if ((((row + col) mod 2 + 2) mod 2) = 1) then (
  sign := -(1);
  );
  __ret := (Obj.magic ((!sign * matrix_minor (m) (Obj.repr (row)) (Obj.repr (col)))) : int); raise Return
  with Return -> !__ret)

and matrix_mul_vector m v =
  let __ret = ref ([] : (int) list) in
  (try
  let m = (Obj.magic m : int list list) in
  let v = (Obj.magic v : int list) in
  let res = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (m)) do
    try
  let sum = ref (0) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) do
    try
  sum := (!sum + ((let __l = (let __l = m in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) * (let __l = v in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!sum) : int)]) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list); raise Return
  with Return -> !__ret)

and matrix_mul_scalar m s =
  let __ret = ref ([] : (int list) list) in
  (try
  let m = (Obj.magic m : int list list) in
  let s = (Obj.magic s : int) in
  let res = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (m)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = m in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (((let __l = (let __l = m in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) * s)) : int)]) : int list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!row) : int list)]) : int list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and matrix_change_component m i j val_ =
  let __ret = ref (Obj.magic 0) in
  (try
  m := (Obj.magic !m : int list list);
  let i = (Obj.magic i : int) in
  let j = (Obj.magic j : int) in
  let val_ = (Obj.magic val_ : int) in
  m := (List.mapi (fun __i __x -> if __i = i then (List.mapi (fun __i __x -> if __i = j then val_ else __x) ((let __l = !m in let __i = i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) else __x) (!m));
    !__ret
  with Return -> !__ret)

and matrix_component m i j =
  let __ret = ref 0 in
  (try
  let m = (Obj.magic m : int list list) in
  let i = (Obj.magic i : int) in
  let j = (Obj.magic j : int) in
  __ret := (Obj.magic ((let __l = (let __l = m in let __i = i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i))) : int); raise Return
  with Return -> !__ret)

and matrix_add a b =
  let __ret = ref ([] : (int list) list) in
  (try
  let a = (Obj.magic a : int list list) in
  let b = (Obj.magic b : int list list) in
  let res = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = a in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (((let __l = (let __l = a in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) + (let __l = (let __l = b in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : int)]) : int list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!row) : int list)]) : int list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and matrix_sub a b =
  let __ret = ref ([] : (int list) list) in
  (try
  let a = (Obj.magic a : int list list) in
  let b = (Obj.magic b : int list list) in
  let res = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length ((let __l = a in let __i = 0 in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) do
    try
  row := (Obj.magic (List.append (!row) [(Obj.magic (((let __l = (let __l = a in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) - (let __l = (let __l = b in let __i = !i in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)) in let __i = !j in let __len = List.length __l in List.nth __l (if __i >= 0 then __i else __len + __i)))) : int)]) : int list);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (Obj.magic (List.append (!res) [(Obj.magic (!row) : int list)]) : int list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and square_zero_matrix n =
  let __ret = ref ([] : (int list) list) in
  (try
  let n = (Obj.magic n : int) in
  let m = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  m := (Obj.magic (List.append (!m) [(Obj.magic (zero_vector (Obj.repr (n))) : int list)]) : int list list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!m) : int list list); raise Return
  with Return -> !__ret)

and assert_int name actual expected =
  let __ret = ref (Obj.magic 0) in
  (try
  let actual = (Obj.magic actual : int) in
  let expected = (Obj.magic expected : int) in
  if (actual = expected) then (
  print_endline ((name ^ " ok"));
  ) else (
  print_endline (((((name ^ " fail ") ^ int_to_string (Obj.repr (actual))) ^ " != ") ^ int_to_string (Obj.repr (expected))));
  );
    !__ret
  with Return -> !__ret)

and assert_str name actual expected =
  let __ret = ref (Obj.magic 0) in
  (try
  if (actual = expected) then (
  print_endline ((name ^ " ok"));
  ) else (
  print_endline ((name ^ " fail"));
  print_endline (actual);
  print_endline (expected);
  );
    !__ret
  with Return -> !__ret)

and assert_float name actual expected eps =
  let __ret = ref (Obj.magic 0) in
  (try
  let actual = (Obj.magic actual : float) in
  let expected = (Obj.magic expected : float) in
  let eps = (Obj.magic eps : float) in
  let diff = ref ((actual -. expected)) in
  if (!diff < 0.0) then (
  diff := (-.(!diff));
  );
  if (!diff <= eps) then (
  print_endline ((name ^ " ok"));
  ) else (
  print_endline ((name ^ " fail"));
  );
    !__ret
  with Return -> !__ret)


let vx = ref ([1; 2; 3])
let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (assert_int ("component0") (Obj.repr (vector_component (!vx) (Obj.repr (0)))) (Obj.repr (1)));
  ignore (assert_int ("component2") (Obj.repr (vector_component (!vx) (Obj.repr (2)))) (Obj.repr (3)));
  let vs = ref ([0; 0; 0; 0; 0; 1]) in
  ignore (assert_str ("str_vector") (vector_str_int (!vs)) ("(0,0,0,0,0,1)"));
  let vsize = ref ([1; 2; 3; 4]) in
  ignore (assert_int ("size") (Obj.repr (List.length (!vsize))) (Obj.repr (4)));
  let va = ref ([1; 2; 3]) in
  let vb = ref ([1; 1; 1]) in
  let vsum = ref (vector_add (!va) (!vb)) in
  ignore (assert_int ("add0") (Obj.repr (vector_component (!vsum) (Obj.repr (0)))) (Obj.repr (2)));
  ignore (assert_int ("add1") (Obj.repr (vector_component (!vsum) (Obj.repr (1)))) (Obj.repr (3)));
  ignore (assert_int ("add2") (Obj.repr (vector_component (!vsum) (Obj.repr (2)))) (Obj.repr (4)));
  let vsub = ref (vector_sub (!va) (!vb)) in
  ignore (assert_int ("sub0") (Obj.repr (vector_component (!vsub) (Obj.repr (0)))) (Obj.repr (0)));
  ignore (assert_int ("sub1") (Obj.repr (vector_component (!vsub) (Obj.repr (1)))) (Obj.repr (1)));
  ignore (assert_int ("sub2") (Obj.repr (vector_component (!vsub) (Obj.repr (2)))) (Obj.repr (2)));
  let vmul = ref (vector_scalar_mul (!va) (Obj.repr (3.0))) in
  ignore (assert_str ("scalar_mul") (vector_str_float (!vmul) (Obj.repr (1))) ("(3.0,6.0,9.0)"));
  ignore (assert_int ("dot_product") (Obj.repr (vector_dot ([2; -(1); 4]) ([1; -(2); -(1)]))) (Obj.repr (0)));
  let zvec = ref (zero_vector (Obj.repr (10))) in
  let zstr = vector_str_int (!zvec) in
  let zcount = ref (0) in
  let zi = ref (0) in
  (try while (!zi < String.length (zstr)) do
    try
  if ((let __s = zstr in let __st = !zi in let __en = (!zi + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) = "0") then (
  zcount := (!zcount + 1);
  );
  zi := (!zi + 1);
    with Continue -> ()
  done with Break -> ());
  ignore (assert_int ("zero_vector") (Obj.repr (!zcount)) (Obj.repr (10)));
  ignore (assert_str ("unit_basis") (vector_str_int (unit_basis_vector (Obj.repr (3)) (Obj.repr (1)))) ("(0,1,0)"));
  ignore (assert_str ("axpy") (vector_str_int (axpy (Obj.repr (2)) ([1; 2; 3]) ([1; 0; 1]))) ("(3,4,7)"));
  let vcopy = ref (copy_vector ([1; 0; 0; 0; 0; 0])) in
  ignore (assert_str ("copy") (vector_str_int (!vcopy)) ("(1,0,0,0,0,0)"));
  let vchange = ref ([1; 0; 0]) in
  ignore (change_component (vchange) (Obj.repr (0)) (Obj.repr (0)));
  ignore (change_component (vchange) (Obj.repr (1)) (Obj.repr (1)));
  ignore (assert_str ("change_component") (vector_str_int (!vchange)) ("(0,1,0)"));
  let ma = ref ([[1; 2; 3]; [2; 4; 5]; [6; 7; 8]]) in
  ignore (assert_str ("matrix_str") (matrix_str (!ma)) ("|1,2,3|\n|2,4,5|\n|6,7,8|\n"));
  ignore (assert_int ("determinant") (Obj.repr (determinant (!ma))) (Obj.repr (-(5))));
  let mb = ref ([[1; 2; 3]; [4; 5; 6]; [7; 8; 9]]) in
  let mv = ref (matrix_mul_vector (!mb) ([1; 2; 3])) in
  ignore (assert_str ("matrix_vec_mul") (vector_str_int (!mv)) ("(14,32,50)"));
  let msc = ref (matrix_mul_scalar (!mb) (Obj.repr (2))) in
  ignore (assert_str ("matrix_scalar_mul") (matrix_str (!msc)) ("|2,4,6|\n|8,10,12|\n|14,16,18|\n"));
  let mc = ref ([[1; 2; 3]; [2; 4; 5]; [6; 7; 8]]) in
  ignore (matrix_change_component (mc) (Obj.repr (0)) (Obj.repr (2)) (Obj.repr (5)));
  ignore (assert_str ("change_component_matrix") (matrix_str (!mc)) ("|1,2,5|\n|2,4,5|\n|6,7,8|\n"));
  ignore (assert_int ("matrix_component") (Obj.repr (matrix_component (!mc) (Obj.repr (2)) (Obj.repr (1)))) (Obj.repr (7)));
  let madd = ref (matrix_add ([[1; 2; 3]; [2; 4; 5]; [6; 7; 8]]) ([[1; 2; 7]; [2; 4; 5]; [6; 7; 10]])) in
  ignore (assert_str ("matrix_add") (matrix_str (!madd)) ("|2,4,10|\n|4,8,10|\n|12,14,18|\n"));
  let msub = ref (matrix_sub ([[1; 2; 3]; [2; 4; 5]; [6; 7; 8]]) ([[1; 2; 7]; [2; 4; 5]; [6; 7; 10]])) in
  ignore (assert_str ("matrix_sub") (matrix_str (!msub)) ("|0,0,-4|\n|0,0,0|\n|0,0,-2|\n"));
  let mzero = ref (square_zero_matrix (Obj.repr (5))) in
  ignore (assert_str ("square_zero_matrix") (matrix_str (!mzero)) ("|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n"));
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
