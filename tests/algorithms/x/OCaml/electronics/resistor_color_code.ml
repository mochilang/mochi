(* Generated by Mochi transpiler v0.10.61 on 2025-08-09 10:14 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then false
  else
    match tag r with
    | 0 ->
        let t = field r 1 in
        if is_int t then (magic t : int) = 0
        else __is_list (magic t)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __show_list (Obj.magic v) else __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> if __is_list v then __str_list (Obj.magic v) else __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let valid_colors = ref (["Black"; "Brown"; "Red"; "Orange"; "Yellow"; "Green"; "Blue"; "Violet"; "Grey"; "White"; "Gold"; "Silver"])
let significant_figures_color_values = ref ([(__str ("Black"), 0); (__str ("Brown"), 1); (__str ("Red"), 2); (__str ("Orange"), 3); (__str ("Yellow"), 4); (__str ("Green"), 5); (__str ("Blue"), 6); (__str ("Violet"), 7); (__str ("Grey"), 8); (__str ("White"), 9)])
let multiplier_color_values = ref ([(__str ("Black"), 1.0); (__str ("Brown"), 10.0); (__str ("Red"), 100.0); (__str ("Orange"), 1000.0); (__str ("Yellow"), 10000.0); (__str ("Green"), 100000.0); (__str ("Blue"), 1000000.0); (__str ("Violet"), 10000000.0); (__str ("Grey"), 100000000.0); (__str ("White"), 1000000000.0); (__str ("Gold"), 0.1); (__str ("Silver"), 0.01)])
let tolerance_color_values = ref ([(__str ("Brown"), 1.0); (__str ("Red"), 2.0); (__str ("Orange"), 0.05); (__str ("Yellow"), 0.02); (__str ("Green"), 0.5); (__str ("Blue"), 0.25); (__str ("Violet"), 0.1); (__str ("Grey"), 0.01); (__str ("Gold"), 5.0); (__str ("Silver"), 10.0)])
let temperature_coeffecient_color_values = ref ([(__str ("Black"), 250); (__str ("Brown"), 100); (__str ("Red"), 50); (__str ("Orange"), 15); (__str ("Yellow"), 25); (__str ("Green"), 20); (__str ("Blue"), 10); (__str ("Violet"), 5); (__str ("Grey"), 1)])
let rec contains list value =
  let __ret = ref false in
  (try
  (try List.iter (fun c ->
    try
  if (c = value) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
    with Continue -> ()) (list) with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and get_significant_digits colors =
  let __ret = ref 0 in
  (try
  let digit = ref (0) in
  (try List.iter (fun color ->
    try
  if not ((List.mem_assoc color !significant_figures_color_values)) then (
  (failwith ((color ^ " is not a valid color for significant figure bands")));
  );
  digit := ((!digit * 10) + List.assoc (__str (color)) (!significant_figures_color_values));
    with Continue -> ()) (colors) with Break -> ());
  __ret := (Obj.magic (!digit) : int); raise Return
  with Return -> !__ret)

and get_multiplier color =
  let __ret = ref 0.0 in
  (try
  if not ((List.mem_assoc color !multiplier_color_values)) then (
  (failwith ((color ^ " is not a valid color for multiplier band")));
  );
  __ret := (Obj.magic (List.assoc (__str (color)) (!multiplier_color_values)) : float); raise Return
  with Return -> !__ret)

and get_tolerance color =
  let __ret = ref 0.0 in
  (try
  if not ((List.mem_assoc color !tolerance_color_values)) then (
  (failwith ((color ^ " is not a valid color for tolerance band")));
  );
  __ret := (Obj.magic (List.assoc (__str (color)) (!tolerance_color_values)) : float); raise Return
  with Return -> !__ret)

and get_temperature_coeffecient color =
  let __ret = ref 0 in
  (try
  if not ((List.mem_assoc color !temperature_coeffecient_color_values)) then (
  (failwith ((color ^ " is not a valid color for temperature coeffecient band")));
  );
  __ret := (Obj.magic (List.assoc (__str (color)) (!temperature_coeffecient_color_values)) : int); raise Return
  with Return -> !__ret)

and get_band_type_count total typ =
  let __ret = ref 0 in
  (try
  let total = (Obj.magic total : int) in
  if (total = 3) then (
  if (typ = "significant") then (
  __ret := (Obj.magic (2) : int); raise Return
  );
  if (typ = "multiplier") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  (failwith ((typ ^ " is not valid for a 3 band resistor")));
  ) else (
  if (total = 4) then (
  if (typ = "significant") then (
  __ret := (Obj.magic (2) : int); raise Return
  );
  if (typ = "multiplier") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  if (typ = "tolerance") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  (failwith ((typ ^ " is not valid for a 4 band resistor")));
  ) else (
  if (total = 5) then (
  if (typ = "significant") then (
  __ret := (Obj.magic (3) : int); raise Return
  );
  if (typ = "multiplier") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  if (typ = "tolerance") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  (failwith ((typ ^ " is not valid for a 5 band resistor")));
  ) else (
  if (total = 6) then (
  if (typ = "significant") then (
  __ret := (Obj.magic (3) : int); raise Return
  );
  if (typ = "multiplier") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  if (typ = "tolerance") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  if (typ = "temp_coeffecient") then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  (failwith ((typ ^ " is not valid for a 6 band resistor")));
  ) else (
  (failwith (((string_of_int (total)) ^ " is not a valid number of bands")));
  );
  );
  );
  );
    !__ret
  with Return -> !__ret)

and check_validity number_of_bands colors =
  let __ret = ref false in
  (try
  let number_of_bands = (Obj.magic number_of_bands : int) in
  if ((number_of_bands < 3) || (number_of_bands > 6)) then (
  (failwith ("Invalid number of bands. Resistor bands must be 3 to 6"));
  );
  if (number_of_bands <> List.length (colors)) then (
  (failwith ((((("Expecting " ^ (string_of_int (number_of_bands))) ^ " colors, provided ") ^ (string_of_int (List.length (colors)))) ^ " colors")));
  );
  (try List.iter (fun color ->
    try
  if not (contains (!valid_colors) (color)) then (
  (failwith ((color ^ " is not a valid color")));
  );
    with Continue -> ()) (colors) with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and calculate_resistance number_of_bands color_code_list =
  let __ret = ref "" in
  (try
  let number_of_bands = (Obj.magic number_of_bands : int) in
  ignore (check_validity (Obj.repr (number_of_bands)) (color_code_list));
  let sig_count = get_band_type_count (Obj.repr (number_of_bands)) ("significant") in
  let significant_colors = ref (List.of_seq (Seq.take (sig_count - 0) (Seq.drop 0 (List.to_seq (color_code_list))))) in
  let significant_digits = get_significant_digits (!significant_colors) in
  let multiplier_color = List.nth (color_code_list) (sig_count) in
  let multiplier = get_multiplier (multiplier_color) in
  let tolerance = ref (20.0) in
  if (number_of_bands >= 4) then (
  let tolerance_color = List.nth (color_code_list) ((sig_count + 1)) in
  tolerance := get_tolerance (tolerance_color);
  );
  let temp_coeff = ref (0) in
  if (number_of_bands = 6) then (
  let temp_color = List.nth (color_code_list) ((sig_count + 2)) in
  temp_coeff := get_temperature_coeffecient (temp_color);
  );
  let resistance_value = (multiplier *. float_of_int (significant_digits)) in
  let resistance_str = ref ((Printf.sprintf "%.16g" (resistance_value))) in
  if (resistance_value = float_of_int (int_of_float (resistance_value))) then (
  resistance_str := (string_of_int (int_of_float (resistance_value)));
  );
  let answer = ref ((((!resistance_str ^ "Ω ±") ^ (Printf.sprintf "%.16g" (!tolerance))) ^ "% ")) in
  if (!temp_coeff <> 0) then (
  answer := ((!answer ^ (string_of_int (!temp_coeff))) ^ " ppm/K");
  );
  __ret := (Obj.magic (!answer) : string); raise Return
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()
