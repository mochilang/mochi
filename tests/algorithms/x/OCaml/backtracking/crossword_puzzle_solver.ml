(* Generated by Mochi transpiler v0.10.59 on 2025-08-06 16:21 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "%S" (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat ", " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec is_valid puzzle word row col vertical =
  let __ret = ref false in
  (try
  let row = (Obj.magic row : int) in
  let col = (Obj.magic col : int) in
  (try for i = 0 to (String.length (word) - 1) do
    try
  if vertical then (
  if (((row + i) >= List.length (puzzle)) || (List.nth (List.nth (puzzle) ((row + i))) (col) <> "")) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  ) else (
  if (((col + i) >= List.length (List.nth (puzzle) (0))) || (List.nth (List.nth (puzzle) (row)) ((col + i)) <> "")) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and place_word puzzle word row col vertical =
  let __ret = ref (Obj.magic 0) in
  (try
  let row = (Obj.magic row : int) in
  let col = (Obj.magic col : int) in
  (try for i = 0 to (String.length (word) - 1) do
    try
  let ch = String.make 1 (String.get (word) i) in
  if vertical then (
  puzzle := (List.mapi (fun __i __x -> if __i = (row + i) then (List.mapi (fun __i __x -> if __i = col then ch else __x) (List.nth (!puzzle) ((row + i)))) else __x) (!puzzle));
  ) else (
  puzzle := (List.mapi (fun __i __x -> if __i = row then (List.mapi (fun __i __x -> if __i = (col + i) then ch else __x) (List.nth (!puzzle) (row))) else __x) (!puzzle));
  );
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and remove_word puzzle word row col vertical =
  let __ret = ref (Obj.magic 0) in
  (try
  let row = (Obj.magic row : int) in
  let col = (Obj.magic col : int) in
  (try for i = 0 to (String.length (word) - 1) do
    try
  if vertical then (
  puzzle := (List.mapi (fun __i __x -> if __i = (row + i) then (List.mapi (fun __i __x -> if __i = col then "" else __x) (List.nth (!puzzle) ((row + i)))) else __x) (!puzzle));
  ) else (
  puzzle := (List.mapi (fun __i __x -> if __i = row then (List.mapi (fun __i __x -> if __i = (col + i) then "" else __x) (List.nth (!puzzle) (row))) else __x) (!puzzle));
  );
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and solve_crossword puzzle words used =
  let __ret = ref false in
  (try
  (try for row = 0 to (List.length (puzzle) - 1) do
    try
  (try for col = 0 to (List.length (List.nth (puzzle) (0)) - 1) do
    try
  if (List.nth (List.nth (puzzle) (row)) (col) = "") then (
  (try for i = 0 to (List.length (words) - 1) do
    try
  if not (List.nth (!used) (i)) then (
  let word = List.nth (words) (i) in
  (try List.iter (fun vertical ->
    try
  if is_valid (puzzle) (word) (Obj.repr (row)) (Obj.repr (col)) (vertical) then (
  ignore (place_word (ref (puzzle)) (word) (Obj.repr (row)) (Obj.repr (col)) (vertical));
  used := (List.mapi (fun __i __x -> if __i = i then true else __x) (!used));
  if solve_crossword (puzzle) (words) (used) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  used := (List.mapi (fun __i __x -> if __i = i then false else __x) (!used));
  ignore (remove_word (ref (puzzle)) (word) (Obj.repr (row)) (Obj.repr (col)) (vertical));
  );
    with Continue -> ()) ([true; false]) with Break -> ());
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  );
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)


let puzzle = ref ([[""; ""; ""]; [""; ""; ""]; [""; ""; ""]])
let words = ref (["cat"; "dog"; "car"])
let used = ref ([false; false; false])
let () =
  let mem_start = _mem () in
  let start = _now () in
  if solve_crossword (!puzzle) (!words) (used) then (
  print_endline ("Solution found:");
  (try List.iter (fun row ->
    try
  print_endline (__show_list row);
    with Continue -> ()) (!puzzle) with Break -> ());
  ) else (
  print_endline ("No solution found:");
  );
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()