(* Generated by Mochi transpiler v0.10.59 on 2025-08-06 22:21 +0700 *)


let rec __show v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_list (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __str v =
  let open Obj in
  let r = repr v in
  if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_list (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _byte_size = 256
let rec pow_int base exp =
  let __ret = ref 0 in
  (try
  let base = (Obj.magic base : int) in
  let exp = (Obj.magic exp : int) in
  let result = ref (1) in
  let i = ref (0) in
  (try while (!i < exp) do
    try
  result := (!result * base);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : int); raise Return
  with Return -> !__ret)

and mod_pow base exponent modulus =
  let __ret = ref 0 in
  (try
  let base = (Obj.magic base : int) in
  let exponent = (Obj.magic exponent : int) in
  let modulus = (Obj.magic modulus : int) in
  let result = ref (1) in
  let b = ref ((base mod modulus)) in
  let e = ref (exponent) in
  (try while (!e > 0) do
    try
  if ((!e mod 2) = 1) then (
  result := ((!result * !b) mod modulus);
  );
  e := (!e / 2);
  b := ((!b * !b) mod modulus);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : int); raise Return
  with Return -> !__ret)

and ord ch =
  let __ret = ref 0 in
  (try
  if (ch = " ") then (
  __ret := (Obj.magic (32) : int); raise Return
  );
  if (ch = "a") then (
  __ret := (Obj.magic (97) : int); raise Return
  );
  if (ch = "b") then (
  __ret := (Obj.magic (98) : int); raise Return
  );
  if (ch = "c") then (
  __ret := (Obj.magic (99) : int); raise Return
  );
  if (ch = "d") then (
  __ret := (Obj.magic (100) : int); raise Return
  );
  if (ch = "e") then (
  __ret := (Obj.magic (101) : int); raise Return
  );
  if (ch = "f") then (
  __ret := (Obj.magic (102) : int); raise Return
  );
  if (ch = "g") then (
  __ret := (Obj.magic (103) : int); raise Return
  );
  if (ch = "h") then (
  __ret := (Obj.magic (104) : int); raise Return
  );
  if (ch = "i") then (
  __ret := (Obj.magic (105) : int); raise Return
  );
  if (ch = "j") then (
  __ret := (Obj.magic (106) : int); raise Return
  );
  if (ch = "k") then (
  __ret := (Obj.magic (107) : int); raise Return
  );
  if (ch = "l") then (
  __ret := (Obj.magic (108) : int); raise Return
  );
  if (ch = "m") then (
  __ret := (Obj.magic (109) : int); raise Return
  );
  if (ch = "n") then (
  __ret := (Obj.magic (110) : int); raise Return
  );
  if (ch = "o") then (
  __ret := (Obj.magic (111) : int); raise Return
  );
  if (ch = "p") then (
  __ret := (Obj.magic (112) : int); raise Return
  );
  if (ch = "q") then (
  __ret := (Obj.magic (113) : int); raise Return
  );
  if (ch = "r") then (
  __ret := (Obj.magic (114) : int); raise Return
  );
  if (ch = "s") then (
  __ret := (Obj.magic (115) : int); raise Return
  );
  if (ch = "t") then (
  __ret := (Obj.magic (116) : int); raise Return
  );
  if (ch = "u") then (
  __ret := (Obj.magic (117) : int); raise Return
  );
  if (ch = "v") then (
  __ret := (Obj.magic (118) : int); raise Return
  );
  if (ch = "w") then (
  __ret := (Obj.magic (119) : int); raise Return
  );
  if (ch = "x") then (
  __ret := (Obj.magic (120) : int); raise Return
  );
  if (ch = "y") then (
  __ret := (Obj.magic (121) : int); raise Return
  );
  if (ch = "z") then (
  __ret := (Obj.magic (122) : int); raise Return
  );
  __ret := (Obj.magic (0) : int); raise Return
  with Return -> !__ret)

and chr code =
  let __ret = ref "" in
  (try
  let code = (Obj.magic code : int) in
  if (code = 32) then (
  __ret := (Obj.magic (" ") : string); raise Return
  );
  if (code = 97) then (
  __ret := (Obj.magic ("a") : string); raise Return
  );
  if (code = 98) then (
  __ret := (Obj.magic ("b") : string); raise Return
  );
  if (code = 99) then (
  __ret := (Obj.magic ("c") : string); raise Return
  );
  if (code = 100) then (
  __ret := (Obj.magic ("d") : string); raise Return
  );
  if (code = 101) then (
  __ret := (Obj.magic ("e") : string); raise Return
  );
  if (code = 102) then (
  __ret := (Obj.magic ("f") : string); raise Return
  );
  if (code = 103) then (
  __ret := (Obj.magic ("g") : string); raise Return
  );
  if (code = 104) then (
  __ret := (Obj.magic ("h") : string); raise Return
  );
  if (code = 105) then (
  __ret := (Obj.magic ("i") : string); raise Return
  );
  if (code = 106) then (
  __ret := (Obj.magic ("j") : string); raise Return
  );
  if (code = 107) then (
  __ret := (Obj.magic ("k") : string); raise Return
  );
  if (code = 108) then (
  __ret := (Obj.magic ("l") : string); raise Return
  );
  if (code = 109) then (
  __ret := (Obj.magic ("m") : string); raise Return
  );
  if (code = 110) then (
  __ret := (Obj.magic ("n") : string); raise Return
  );
  if (code = 111) then (
  __ret := (Obj.magic ("o") : string); raise Return
  );
  if (code = 112) then (
  __ret := (Obj.magic ("p") : string); raise Return
  );
  if (code = 113) then (
  __ret := (Obj.magic ("q") : string); raise Return
  );
  if (code = 114) then (
  __ret := (Obj.magic ("r") : string); raise Return
  );
  if (code = 115) then (
  __ret := (Obj.magic ("s") : string); raise Return
  );
  if (code = 116) then (
  __ret := (Obj.magic ("t") : string); raise Return
  );
  if (code = 117) then (
  __ret := (Obj.magic ("u") : string); raise Return
  );
  if (code = 118) then (
  __ret := (Obj.magic ("v") : string); raise Return
  );
  if (code = 119) then (
  __ret := (Obj.magic ("w") : string); raise Return
  );
  if (code = 120) then (
  __ret := (Obj.magic ("x") : string); raise Return
  );
  if (code = 121) then (
  __ret := (Obj.magic ("y") : string); raise Return
  );
  if (code = 122) then (
  __ret := (Obj.magic ("z") : string); raise Return
  );
  __ret := (Obj.magic ("") : string); raise Return
  with Return -> !__ret)

and get_blocks_from_text message block_size =
  let __ret = ref ([] : (int) list) in
  (try
  let block_size = (Obj.magic block_size : int) in
  let block_ints = ref (([] : (int) list)) in
  let block_start = ref (0) in
  (try while (!block_start < String.length (message)) do
    try
  let block_int = ref (0) in
  let i = ref (!block_start) in
  (try while ((!i < (!block_start + block_size)) && (!i < String.length (message))) do
    try
  block_int := (!block_int + (ord (String.make 1 (String.get (message) !i)) * pow_int (Obj.repr (_byte_size)) (Obj.repr ((!i - !block_start)))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  block_ints := (List.append (!block_ints) [(Obj.magic (!block_int) : int)]);
  block_start := (!block_start + block_size);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!block_ints) : int list); raise Return
  with Return -> !__ret)

and get_text_from_blocks block_ints message_length block_size =
  let __ret = ref "" in
  (try
  let message_length = (Obj.magic message_length : int) in
  let block_size = (Obj.magic block_size : int) in
  let message = ref ("") in
  (try List.iter (fun block_int ->
    try
  let block = ref (block_int) in
  let i = ref ((block_size - 1)) in
  let block_message = ref ("") in
  (try while (!i >= 0) do
    try
  if ((String.length (!message) + !i) < message_length) then (
  let ascii_number = (!block / pow_int (Obj.repr (_byte_size)) (Obj.repr (!i))) in
  block := (!block mod pow_int (Obj.repr (_byte_size)) (Obj.repr (!i)));
  block_message := (chr (Obj.repr (ascii_number)) ^ !block_message);
  );
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  message := (!message ^ !block_message);
    with Continue -> ()) (block_ints) with Break -> ());
  __ret := (Obj.magic (!message) : string); raise Return
  with Return -> !__ret)

and encrypt_message message n e block_size =
  let __ret = ref ([] : (int) list) in
  (try
  let n = (Obj.magic n : int) in
  let e = (Obj.magic e : int) in
  let block_size = (Obj.magic block_size : int) in
  let encrypted = ref (([] : (int) list)) in
  let blocks = ref (get_blocks_from_text (message) (Obj.repr (block_size))) in
  (try List.iter (fun block ->
    try
  encrypted := (List.append (!encrypted) [(Obj.magic (mod_pow (Obj.repr (block)) (Obj.repr (e)) (Obj.repr (n))) : int)]);
    with Continue -> ()) (!blocks) with Break -> ());
  __ret := (Obj.magic (!encrypted) : int list); raise Return
  with Return -> !__ret)

and decrypt_message blocks message_length n d block_size =
  let __ret = ref "" in
  (try
  let message_length = (Obj.magic message_length : int) in
  let n = (Obj.magic n : int) in
  let d = (Obj.magic d : int) in
  let block_size = (Obj.magic block_size : int) in
  let decrypted_blocks = ref (([] : (int) list)) in
  (try List.iter (fun block ->
    try
  decrypted_blocks := (List.append (!decrypted_blocks) [(Obj.magic (mod_pow (Obj.repr (block)) (Obj.repr (d)) (Obj.repr (n))) : int)]);
    with Continue -> ()) (blocks) with Break -> ());
  let message = ref ("") in
  (try List.iter (fun num ->
    try
  message := (!message ^ chr (Obj.repr (num)));
    with Continue -> ()) (!decrypted_blocks) with Break -> ());
  __ret := (Obj.magic (!message) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let message = "hello world" in
  let n = 3233 in
  let e = 17 in
  let d = 2753 in
  let block_size = 1 in
  let encrypted = ref (encrypt_message (message) (Obj.repr (n)) (Obj.repr (e)) (Obj.repr (block_size))) in
  print_endline ((__str (!encrypted)));
  let decrypted = decrypt_message (!encrypted) (Obj.repr (String.length (message))) (Obj.repr (n)) (Obj.repr (d)) (Obj.repr (block_size)) in
  print_endline (decrypted);
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()