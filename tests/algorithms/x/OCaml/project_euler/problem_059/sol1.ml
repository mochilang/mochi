(* Generated by Mochi transpiler v0.10.70 on 2025-08-22 23:09 +0700 *)


let rec __is_list v =
  let open Obj in
  let r = repr v in
  if is_int r then (magic r : int) = 0
  else
    match tag r with
    | 0 -> __is_list (field r 1)
    | _ -> false

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())


let _ord s = Char.code s.[0]

exception Break
exception Continue

exception Return

let rec xor a b =
  let __ret = ref 0 in
  (try
  let a = (Obj.magic a : int) in
  let b = (Obj.magic b : int) in
  let res = ref (0) in
  let bit = ref (1) in
  let x = ref (a) in
  let y = ref (b) in
  (try while ((!x > 0) || (!y > 0)) do
    try
  let abit = ((!x mod 2 + 2) mod 2) in
  let bbit = ((!y mod 2 + 2) mod 2) in
  if (abit <> bbit) then (
  res := (!res + !bit);
  );
  x := (!x / 2);
  y := (!y / 2);
  bit := (!bit * 2);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int); raise Return
  with Return -> !__ret)


let ascii_chars = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
let rec chr code =
  let __ret = ref "" in
  (try
  let code = (Obj.magic code : int) in
  if (code = 10) then (
  __ret := (Obj.magic ("\n") : string); raise Return
  );
  if (code = 13) then (
  __ret := (Obj.magic ("\r") : string); raise Return
  );
  if (code = 9) then (
  __ret := (Obj.magic ("\t") : string); raise Return
  );
  if ((code >= 32) && (code < 127)) then (
  __ret := (Obj.magic ((let __s = ascii_chars in let __st = (code - 32) in let __len = ((code - 31) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")) : string); raise Return
  );
  __ret := (Obj.magic ("") : string); raise Return
  with Return -> !__ret)

and ord ch =
  let __ret = ref 0 in
  (try
  if (ch = "\n") then (
  __ret := (Obj.magic (10) : int); raise Return
  );
  if (ch = "\r") then (
  __ret := (Obj.magic (13) : int); raise Return
  );
  if (ch = "\t") then (
  __ret := (Obj.magic (9) : int); raise Return
  );
  let i = ref (0) in
  (try while (!i < String.length (ascii_chars)) do
    try
  if ((let __s = ascii_chars in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") = ch) then (
  __ret := (Obj.magic ((32 + !i)) : int); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (0) : int); raise Return
  with Return -> !__ret)

and is_valid_ascii code =
  let __ret = ref false in
  (try
  let code = (Obj.magic code : int) in
  if ((code >= 32) && (code <= 126)) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  if (((code = 9) || (code = 10)) || (code = 13)) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)


let _lowercase_ints = ref (([] : (int) list))
let i = ref (97)
let _common_words = ref (["the"; "be"; "to"; "of"; "and"; "in"; "that"; "have"])
let ciphertext = ref ([17; 6; 1; 69; 12; 1; 69; 26; 11; 69; 1; 2; 69; 15; 10; 1; 78; 13; 11; 78; 16; 13; 15; 16; 69; 6; 5; 19; 11])
let rec try_key ciphertext key =
  let __ret = ref "" in
  (try
  let ciphertext = (Obj.magic ciphertext : int list) in
  let key = (Obj.magic key : int list) in
  let decoded = ref ("") in
  let i = ref (0) in
  let klen = List.length (key) in
  (try while (!i < List.length (ciphertext)) do
    try
  let decodedchar = xor (Obj.repr ((let __l = ciphertext in let __i = !i in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0))) (Obj.repr ((let __l = key in let __i = ((!i mod klen + klen) mod klen) in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0))) in
  if not (is_valid_ascii (Obj.repr (decodedchar))) then (
  __ret := (Obj.magic (nil) : string); raise Return
  );
  decoded := (!decoded ^ chr (Obj.repr (decodedchar)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!decoded) : string); raise Return
  with Return -> !__ret)

and filter_valid_chars ciphertext =
  let __ret = ref ([] : (string) list) in
  (try
  let ciphertext = (Obj.magic ciphertext : int list) in
  let possibles = ref (([] : (string) list)) in
  let i = ref (0) in
  (try while (!i < List.length (!_lowercase_ints)) do
    try
  let j = ref (0) in
  (try while (!j < List.length (!_lowercase_ints)) do
    try
  let k = ref (0) in
  (try while (!k < List.length (!_lowercase_ints)) do
    try
  let key = ref ([(let __l = !_lowercase_ints in let __i = !i in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0); (let __l = !_lowercase_ints in let __i = !j in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0); (let __l = !_lowercase_ints in let __i = !k in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)]) in
  let decoded = try_key (ciphertext) (!key) in
  if ((Obj.repr (decoded)) <> nil) then (
  possibles := (Obj.magic ((List.append (!possibles) [(Obj.magic (decoded) : string)])) : string list);
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!possibles) : string list); raise Return
  with Return -> !__ret)

and contains s sub =
  let __ret = ref false in
  (try
  let n = String.length (s) in
  let m = String.length (sub) in
  if (m = 0) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  let i = ref (0) in
  (try while (!i <= (n - m)) do
    try
  let j = ref (0) in
  let is_match = ref (true) in
  (try while (!j < m) do
    try
  if ((let __s = s in let __i = (!i + !j) in let __len = String.length __s in String.make 1 (String.get __s (if __i >= 0 then __i else __len + __i))) <> (let __s = sub in let __i = !j in let __len = String.length __s in String.make 1 (String.get __s (if __i >= 0 then __i else __len + __i)))) then (
  is_match := false;
  raise Break;
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if !is_match then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and filter_common_word possibles common_word =
  let __ret = ref ([] : (string) list) in
  (try
  let possibles = (Obj.magic possibles : string list) in
  let res = ref (([] : (string) list)) in
  let i = ref (0) in
  (try while (!i < List.length (possibles)) do
    try
  let p = (let __l = possibles in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  if contains (String.lowercase_ascii (p)) (common_word) then (
  res := (Obj.magic ((List.append (!res) [(Obj.magic (p) : string)])) : string list);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string list); raise Return
  with Return -> !__ret)

and solution ciphertext =
  let __ret = ref 0 in
  (try
  let ciphertext = (Obj.magic ciphertext : int list) in
  let possibles = ref (filter_valid_chars (ciphertext)) in
  let i = ref (0) in
  (try while (!i < List.length (!_common_words)) do
    try
  let word = (let __l = !_common_words in let __i = !i in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  possibles := (Obj.magic (filter_common_word (!possibles) (word)) : string list);
  if (List.length (!possibles) = 1) then (
  raise Break;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let decoded_text = (let __l = !possibles in let __i = 0 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "") in
  let sum = ref (0) in
  let j = ref (0) in
  (try while (!j < String.length (decoded_text)) do
    try
  sum := (!sum + _ord ((let __s = decoded_text in let __st = !j in let __en = (!j + 1) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st))));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : int); raise Return
  with Return -> !__ret)


let () =
  let bench_mem_start = _mem () in
  let bench_start = _now () in
  (try while (!i <= 122) do
    try
  _lowercase_ints := (Obj.magic ((List.append (!_lowercase_ints) [(Obj.magic (!i) : int)])) : int list);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline ((string_of_int (Obj.magic (solution (!ciphertext)) : int)));
  let bench_finish = _now () in
  let bench_mem_end = _mem () in
  let bench_dur = (bench_finish - bench_start) / 1000 in
  let bench_mem_bytes = Stdlib.max 0 (bench_mem_end - bench_mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" bench_dur bench_mem_bytes "main";
  ()
