# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def make_knn(train_data, train_target, class_labels) do
    try do
      items = []
      i = 0
      while_fun_2 = fn while_fun_2, i, items ->
        if i < _len(train_data) do
          pl = %{point: Enum.at(train_data, i), label: Enum.at(train_target, i)}
          items = (items ++ [pl])
          i = i + 1
          while_fun_2.(while_fun_2, i, items)
        else
          {i, items}
        end
      end
      {i, items} = try do
          while_fun_2.(while_fun_2, i, items)
        catch
          {:break, {i, items}} -> {i, items}
        end

      throw {:return, %{data: items, labels: class_labels}}
    catch
      {:return, val} -> val
    end
  end
  def euclidean_distance(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, sum ->
        if i < _len(a) do
          diff = Enum.at(a, i) - Enum.at(b, i)
          sum = sum + diff * diff
          i = i + 1
          while_fun_3.(while_fun_3, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_3.(while_fun_3, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sqrtApprox(sum)}
    catch
      {:return, val} -> val
    end
  end
  def classify(knn, pred_point, k) do
    try do
      distances = []
      i = 0
      while_fun_4 = fn while_fun_4, distances, i ->
        if i < _len(Map.get(knn, :data, [])) do
          d = euclidean_distance(Enum.at(knn.data, i)["point"], pred_point)
          distances = (distances ++ [%{dist: d, label: Enum.at(knn.data, i)["label"]}])
          i = i + 1
          while_fun_4.(while_fun_4, distances, i)
        else
          {distances, i}
        end
      end
      {distances, i} = try do
          while_fun_4.(while_fun_4, distances, i)
        catch
          {:break, {distances, i}} -> {distances, i}
        end

      votes = []
      count = 0
      while_fun_5 = fn while_fun_5, count, distances, votes ->
        if count < k do
          min_index = 0
          j = 1
          while_fun_6 = fn while_fun_6, j, min_index ->
            if j < _len(distances) do
              {min_index} = if Enum.at(distances, j)["dist"] < Enum.at(distances, min_index)["dist"] do
                min_index = j
                {min_index}
              else
                {min_index}
              end
              j = j + 1
              while_fun_6.(while_fun_6, j, min_index)
            else
              {j, min_index}
            end
          end
          {j, min_index} = try do
              while_fun_6.(while_fun_6, j, min_index)
            catch
              {:break, {j, min_index}} -> {j, min_index}
            end

          votes = (votes ++ [Enum.at(distances, min_index)["label"]])
          distances = List.replace_at(distances, min_index, Map.put(Enum.at(distances, min_index), :dist, 1000000000000000000.0))
          count = count + 1
          while_fun_5.(while_fun_5, count, distances, votes)
        else
          {count, distances, votes}
        end
      end
      {count, distances, votes} = try do
          while_fun_5.(while_fun_5, count, distances, votes)
        catch
          {:break, {count, distances, votes}} -> {count, distances, votes}
        end

      tally = []
      t = 0
      while_fun_7 = fn while_fun_7, t, tally ->
        if t < _len(Map.get(knn, :labels, [])) do
          tally = (tally ++ [0])
          t = t + 1
          while_fun_7.(while_fun_7, t, tally)
        else
          {t, tally}
        end
      end
      {t, tally} = try do
          while_fun_7.(while_fun_7, t, tally)
        catch
          {:break, {t, tally}} -> {t, tally}
        end

      v = 0
      while_fun_8 = fn while_fun_8, tally, v ->
        if v < _len(votes) do
          lbl = Enum.at(votes, v)
          tally = List.replace_at(tally, lbl, Enum.at(tally, lbl) + 1)
          v = v + 1
          while_fun_8.(while_fun_8, tally, v)
        else
          {tally, v}
        end
      end
      {tally, v} = try do
          while_fun_8.(while_fun_8, tally, v)
        catch
          {:break, {tally, v}} -> {tally, v}
        end

      max_idx = 0
      m = 1
      while_fun_9 = fn while_fun_9, m, max_idx ->
        if m < _len(tally) do
          {max_idx} = if Enum.at(tally, m) > Enum.at(tally, max_idx) do
            max_idx = m
            {max_idx}
          else
            {max_idx}
          end
          m = m + 1
          while_fun_9.(while_fun_9, m, max_idx)
        else
          {m, max_idx}
        end
      end
      {m, max_idx} = try do
          while_fun_9.(while_fun_9, m, max_idx)
        catch
          {:break, {m, max_idx}} -> {m, max_idx}
        end

      throw {:return, Enum.at(knn.labels, max_idx)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:train_X, [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.5], [3.0, 3.0], [2.0, 3.0], [3.0, 2.0]])
  Process.put(:train_y, [0, 0, 0, 0, 1, 1, 1])
  Process.put(:classes, ["A", "B"])
  Process.put(:point, [1.2, 1.2])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:knn, make_knn(Process.get(:train_X), Process.get(:train_y), Process.get(:classes)))
    IO.puts(Kernel.inspect(classify(Process.get(:knn), Process.get(:point), 5)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
