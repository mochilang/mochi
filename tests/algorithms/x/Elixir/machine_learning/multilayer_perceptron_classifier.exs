# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def exp_taylor(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1.0
      while_fun = fn while_fun, i, sum, term ->
        if i < 20.0 do
          term = term * x / i
          sum = sum + term
          i = i + 1.0
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(x) do
    try do
      throw {:return, 1.0 / (1.0 + exp_taylor(-x))}
    catch
      {:return, val} -> val
    end
  end
  def train(epochs, lr) do
    try do
      e = 0
      while_fun_2 = fn while_fun_2, e ->
        if e < epochs do
          i = 0
          while_fun_3 = fn while_fun_3, i ->
            if i < _len(Process.get(:x)) do
              x0 = Enum.at(Enum.at(Process.get(:x), i), 0)
              x1 = Enum.at(Enum.at(Process.get(:x), i), 1)
              target = Enum.at(Process.get(:y), i)
              z1 = Enum.at(Enum.at(Process.get(:w1), 0), 0) * x0 + Enum.at(Enum.at(Process.get(:w1), 1), 0) * x1 + Enum.at(Process.get(:b1), 0)
              z2 = Enum.at(Enum.at(Process.get(:w1), 0), 1) * x0 + Enum.at(Enum.at(Process.get(:w1), 1), 1) * x1 + Enum.at(Process.get(:b1), 1)
              h1 = sigmoid(z1)
              h2 = sigmoid(z2)
              z3 = Enum.at(Process.get(:w2), 0) * h1 + Enum.at(Process.get(:w2), 1) * h2 + Process.get(:b2)
              out = sigmoid(z3)
              error = out - target
              d1 = h1 * (1.0 - h1) * Enum.at(Process.get(:w2), 0) * error
              d2 = h2 * (1.0 - h2) * Enum.at(Process.get(:w2), 1) * error
              Process.put(:w2, List.replace_at(Process.get(:w2), 0, Enum.at(Process.get(:w2), 0) - lr * error * h1))
              Process.put(:w2, List.replace_at(Process.get(:w2), 1, Enum.at(Process.get(:w2), 1) - lr * error * h2))
              Process.put(:b2, Process.get(:b2) - lr * error)
              Process.put(:w1, List.replace_at(Process.get(:w1), 0, List.replace_at(Enum.at(Process.get(:w1), 0), 0, Enum.at(Enum.at(Process.get(:w1), 0), 0) - lr * d1 * x0)))
              Process.put(:w1, List.replace_at(Process.get(:w1), 1, List.replace_at(Enum.at(Process.get(:w1), 1), 0, Enum.at(Enum.at(Process.get(:w1), 1), 0) - lr * d1 * x1)))
              Process.put(:b1, List.replace_at(Process.get(:b1), 0, Enum.at(Process.get(:b1), 0) - lr * d1))
              Process.put(:w1, List.replace_at(Process.get(:w1), 0, List.replace_at(Enum.at(Process.get(:w1), 0), 1, Enum.at(Enum.at(Process.get(:w1), 0), 1) - lr * d2 * x0)))
              Process.put(:w1, List.replace_at(Process.get(:w1), 1, List.replace_at(Enum.at(Process.get(:w1), 1), 1, Enum.at(Enum.at(Process.get(:w1), 1), 1) - lr * d2 * x1)))
              Process.put(:b1, List.replace_at(Process.get(:b1), 1, Enum.at(Process.get(:b1), 1) - lr * d2))
              i = i + 1
              while_fun_3.(while_fun_3, i)
            else
              i
            end
          end
          i = try do
              while_fun_3.(while_fun_3, i)
            catch
              {:break, {i}} -> i
            end

          e = e + 1
          while_fun_2.(while_fun_2, e)
        else
          e
        end
      end
      e = try do
          while_fun_2.(while_fun_2, e)
        catch
          {:break, {e}} -> e
        end

    catch
      {:return, val} -> val
    end
  end
  def predict(samples) do
    try do
      preds = []
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(samples) do
          x0 = Enum.at(Enum.at(samples, i), 0)
          x1 = Enum.at(Enum.at(samples, i), 1)
          z1 = Enum.at(Enum.at(Process.get(:w1), 0), 0) * x0 + Enum.at(Enum.at(Process.get(:w1), 1), 0) * x1 + Enum.at(Process.get(:b1), 0)
          z2 = Enum.at(Enum.at(Process.get(:w1), 0), 1) * x0 + Enum.at(Enum.at(Process.get(:w1), 1), 1) * x1 + Enum.at(Process.get(:b1), 1)
          h1 = sigmoid(z1)
          h2 = sigmoid(z2)
          z3 = Enum.at(Process.get(:w2), 0) * h1 + Enum.at(Process.get(:w2), 1) * h2 + Process.get(:b2)
          out = sigmoid(z3)
          label = 0
          {label} = if out >= 0.5 do
            label = 1
            {label}
          else
            {label}
          end
          preds = (preds ++ [label])
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, preds}
    catch
      {:return, val} -> val
    end
  end
  def wrapper(y) do
    try do
      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:x, [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]])
  Process.put(:y, [0.0, 1.0, 0.0, 0.0])
  Process.put(:test_data, [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]])
  Process.put(:b1, [0.0, 0.0])
  Process.put(:b2, 0.0)
  def main() do
    Process.put(:w1, [[0.5, -0.5], [0.5, 0.5]])
    Process.put(:w2, [0.5, -0.5])
    train(4000, 0.5)
    Process.put(:preds, wrapper(predict(Process.get(:test_data))))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:preds)])), ",", " "))
  end
end
Main.main()
