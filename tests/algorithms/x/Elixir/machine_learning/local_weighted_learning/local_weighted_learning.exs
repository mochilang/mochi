# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def expApprox(x) do
    try do
      if x < 0.0 do
        throw {:return, 1.0 / expApprox(-x)}
      end
      if x > 1.0 do
        half = expApprox(x / 2.0)
        throw {:return, half * half}
      end
      sum = 1.0
      term = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 20 do
          term = term * x / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def transpose(mat) do
    try do
      rows = _len(mat)
      cols = _len(Enum.at(mat, 0))
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < cols do
          row = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row ->
            if j < rows do
              row = (row ++ [Enum.at(Enum.at(mat, j), i)])
              j = j + 1
              while_fun_3.(while_fun_3, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_3.(while_fun_3, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matMul(a, b) do
    try do
      a_rows = _len(a)
      a_cols = _len(Enum.at(a, 0))
      b_cols = _len(Enum.at(b, 0))
      res = []
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < a_rows do
          row = []
          j = 0
          while_fun_5 = fn while_fun_5, j, row ->
            if j < b_cols do
              sum = 0.0
              k = 0
              while_fun_6 = fn while_fun_6, k, sum ->
                if k < a_cols do
                  sum = sum + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_6.(while_fun_6, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_6.(while_fun_6, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [sum])
              j = j + 1
              while_fun_5.(while_fun_5, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_5.(while_fun_5, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matInv(mat) do
    try do
      n = _len(mat)
      aug = []
      i = 0
      while_fun_7 = fn while_fun_7, aug, i ->
        if i < n do
          row = []
          j = 0
          while_fun_8 = fn while_fun_8, j, row ->
            if j < n do
              row = (row ++ [Enum.at(Enum.at(mat, i), j)])
              j = j + 1
              while_fun_8.(while_fun_8, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_8.(while_fun_8, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < n do
              row = (if i == j, do: (row ++ [1.0]), else: (row ++ [0.0]))
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          aug = (aug ++ [row])
          i = i + 1
          while_fun_7.(while_fun_7, aug, i)
        else
          {aug, i}
        end
      end
      {aug, i} = try do
          while_fun_7.(while_fun_7, aug, i)
        catch
          {:break, {aug, i}} -> {aug, i}
        end

      col = 0
      while_fun_10 = fn while_fun_10, aug, col ->
        if col < n do
          pivot = Enum.at(Enum.at(aug, col), col)
          if pivot == 0.0 do
            raise("Matrix is singular")
          end
          j = 0
          while_fun_11 = fn while_fun_11, aug, j ->
            if j < 2 * n do
              aug = List.replace_at(aug, col, List.replace_at(Enum.at(aug, col), j, Enum.at(Enum.at(aug, col), j) / pivot))
              j = j + 1
              while_fun_11.(while_fun_11, aug, j)
            else
              {aug, j}
            end
          end
          {aug, j} = try do
              while_fun_11.(while_fun_11, aug, j)
            catch
              {:break, {aug, j}} -> {aug, j}
            end

          r = 0
          while_fun_12 = fn while_fun_12, aug, j, r ->
            if r < n do
              {aug, j} = if r != col do
                factor = Enum.at(Enum.at(aug, r), col)
                j = 0
                while_fun_13 = fn while_fun_13, aug, j ->
                  if j < 2 * n do
                    aug = List.replace_at(aug, r, List.replace_at(Enum.at(aug, r), j, Enum.at(Enum.at(aug, r), j) - factor * Enum.at(Enum.at(aug, col), j)))
                    j = j + 1
                    while_fun_13.(while_fun_13, aug, j)
                  else
                    {aug, j}
                  end
                end
                {aug, j} = try do
                    while_fun_13.(while_fun_13, aug, j)
                  catch
                    {:break, {aug, j}} -> {aug, j}
                  end

                {aug, j}
              else
                {aug, j}
              end
              r = r + 1
              while_fun_12.(while_fun_12, aug, j, r)
            else
              {aug, j, r}
            end
          end
          {aug, j, r} = try do
              while_fun_12.(while_fun_12, aug, j, r)
            catch
              {:break, {aug, j, r}} -> {aug, j, r}
            end

          col = col + 1
          while_fun_10.(while_fun_10, aug, col)
        else
          {aug, col}
        end
      end
      {aug, col} = try do
          while_fun_10.(while_fun_10, aug, col)
        catch
          {:break, {aug, col}} -> {aug, col}
        end

      inv = []
      i = 0
      while_fun_14 = fn while_fun_14, i, inv ->
        if i < n do
          row = []
          j = 0
          while_fun_15 = fn while_fun_15, j, row ->
            if j < n do
              row = (row ++ [Enum.at(Enum.at(aug, i), j + n)])
              j = j + 1
              while_fun_15.(while_fun_15, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_15.(while_fun_15, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          inv = (inv ++ [row])
          i = i + 1
          while_fun_14.(while_fun_14, i, inv)
        else
          {i, inv}
        end
      end
      {i, inv} = try do
          while_fun_14.(while_fun_14, i, inv)
        catch
          {:break, {i, inv}} -> {i, inv}
        end

      throw {:return, inv}
    catch
      {:return, val} -> val
    end
  end
  def weight_matrix(point, x_train, tau) do
    try do
      m = _len(x_train)
      weights = []
      i = 0
      while_fun_16 = fn while_fun_16, i, weights ->
        if i < m do
          row = []
          j = 0
          while_fun_17 = fn while_fun_17, j, row ->
            if j < m do
              row = (if i == j, do: (row ++ [1.0]), else: (row ++ [0.0]))
              j = j + 1
              while_fun_17.(while_fun_17, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_17.(while_fun_17, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          weights = (weights ++ [row])
          i = i + 1
          while_fun_16.(while_fun_16, i, weights)
        else
          {i, weights}
        end
      end
      {i, weights} = try do
          while_fun_16.(while_fun_16, i, weights)
        catch
          {:break, {i, weights}} -> {i, weights}
        end

      j = 0
      while_fun_18 = fn while_fun_18, j, weights ->
        if j < m do
          diff_sq = 0.0
          k = 0
          while_fun_19 = fn while_fun_19, diff_sq, k ->
            if k < _len(point) do
              diff = Enum.at(point, k) - Enum.at(Enum.at(x_train, j), k)
              diff_sq = diff_sq + diff * diff
              k = k + 1
              while_fun_19.(while_fun_19, diff_sq, k)
            else
              {diff_sq, k}
            end
          end
          {diff_sq, k} = try do
              while_fun_19.(while_fun_19, diff_sq, k)
            catch
              {:break, {diff_sq, k}} -> {diff_sq, k}
            end

          weights = List.replace_at(weights, j, List.replace_at(Enum.at(weights, j), j, expApprox(-diff_sq / (2.0 * tau * tau))))
          j = j + 1
          while_fun_18.(while_fun_18, j, weights)
        else
          {j, weights}
        end
      end
      {j, weights} = try do
          while_fun_18.(while_fun_18, j, weights)
        catch
          {:break, {j, weights}} -> {j, weights}
        end

      throw {:return, weights}
    catch
      {:return, val} -> val
    end
  end
  def local_weight(point, x_train, y_train, tau) do
    try do
      w = weight_matrix(point, x_train, tau)
      x_t = transpose(x_train)
      x_t_w = matMul(x_t, w)
      x_t_w_x = matMul(x_t_w, x_train)
      inv_part = matInv(x_t_w_x)
      y_col = []
      i = 0
      while_fun_20 = fn while_fun_20, i, y_col ->
        if i < _len(y_train) do
          y_col = (y_col ++ [[Enum.at(y_train, i)]])
          i = i + 1
          while_fun_20.(while_fun_20, i, y_col)
        else
          {i, y_col}
        end
      end
      {i, y_col} = try do
          while_fun_20.(while_fun_20, i, y_col)
        catch
          {:break, {i, y_col}} -> {i, y_col}
        end

      x_t_w_y = matMul(x_t_w, y_col)
      throw {:return, matMul(inv_part, x_t_w_y)}
    catch
      {:return, val} -> val
    end
  end
  def local_weight_regression(x_train, y_train, tau) do
    try do
      m = _len(x_train)
      preds = []
      i = 0
      while_fun_21 = fn while_fun_21, i ->
        if i < m do
          theta = local_weight(Enum.at(x_train, i), x_train, y_train, tau)
          weights_vec = []
          k = 0
          while_fun_22 = fn while_fun_22, k, weights_vec ->
            if k < _len(theta) do
              weights_vec = (weights_vec ++ [Enum.at(Enum.at(theta, k), 0)])
              k = k + 1
              while_fun_22.(while_fun_22, k, weights_vec)
            else
              {k, weights_vec}
            end
          end
          {k, weights_vec} = try do
              while_fun_22.(while_fun_22, k, weights_vec)
            catch
              {:break, {k, weights_vec}} -> {k, weights_vec}
            end

          pred = 0.0
          j = 0
          while_fun_23 = fn while_fun_23, j, pred ->
            if j < _len(Enum.at(x_train, i)) do
              pred = pred + Enum.at(Enum.at(x_train, i), j) * Enum.at(weights_vec, j)
              j = j + 1
              while_fun_23.(while_fun_23, j, pred)
            else
              {j, pred}
            end
          end
          {j, pred} = try do
              while_fun_23.(while_fun_23, j, pred)
            catch
              {:break, {j, pred}} -> {j, pred}
            end

          preds = (preds ++ [pred])
          i = i + 1
          while_fun_21.(while_fun_21, i)
        else
          i
        end
      end
      i = try do
          while_fun_21.(while_fun_21, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, preds}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:x_train, [[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]])
  Process.put(:y_train, [1.01, 1.66, 3.5])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:preds, local_weight_regression(Process.get(:x_train), Process.get(:y_train), 0.6))
    IO.puts(Jason.encode!(Process.get(:preds)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
