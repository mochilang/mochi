# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrt(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def euclidean(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, sum ->
        if i < _len(a) do
          diff = Enum.at(a, i) - Enum.at(b, i)
          sum = sum + diff * diff
          i = i + 1
          while_fun_2.(while_fun_2, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_2.(while_fun_2, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      res = sqrt(sum)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def similarity_search(dataset, value_array) do
    try do
      dim = _len(Enum.at(dataset, 0))
      if dim != _len(Enum.at(value_array, 0)) do
        throw {:return, []}
      end
      result = []
      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(value_array) do
          value = Enum.at(value_array, i)
          dist = euclidean(value, Enum.at(dataset, 0))
          vec = Enum.at(dataset, 0)
          j = 1
          while_fun_4 = fn while_fun_4, dist, j, vec ->
            if j < _len(dataset) do
              d = euclidean(value, Enum.at(dataset, j))
              {dist, vec} = if d < dist do
                dist = d
                vec = Enum.at(dataset, j)
                {dist, vec}
              else
                {dist, vec}
              end
              j = j + 1
              while_fun_4.(while_fun_4, dist, j, vec)
            else
              {dist, j, vec}
            end
          end
          {dist, j, vec} = try do
              while_fun_4.(while_fun_4, dist, j, vec)
            catch
              {:break, {dist, j, vec}} -> {dist, j, vec}
            end

          nb = %{vector: vec, distance: dist}
          result = (result ++ [nb])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def cosine_similarity(a, b) do
    try do
      dot = 0.0
      norm_a = 0.0
      norm_b = 0.0
      i = 0
      while_fun_5 = fn while_fun_5, dot, i, norm_a, norm_b ->
        if i < _len(a) do
          dot = dot + Enum.at(a, i) * Enum.at(b, i)
          norm_a = norm_a + Enum.at(a, i) * Enum.at(a, i)
          norm_b = norm_b + Enum.at(b, i) * Enum.at(b, i)
          i = i + 1
          while_fun_5.(while_fun_5, dot, i, norm_a, norm_b)
        else
          {dot, i, norm_a, norm_b}
        end
      end
      {dot, i, norm_a, norm_b} = try do
          while_fun_5.(while_fun_5, dot, i, norm_a, norm_b)
        catch
          {:break, {dot, i, norm_a, norm_b}} -> {dot, i, norm_a, norm_b}
        end

      if norm_a == 0.0 || norm_b == 0.0 do
        throw {:return, 0.0}
      end
      throw {:return, dot / (sqrt(norm_a) * sqrt(norm_b))}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:dataset, [[0.0, 0.0, 0.0], [1.0, 1.0, 1.0], [2.0, 2.0, 2.0]])
  Process.put(:value_array, [[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])
  Process.put(:k, 0)
  def main() do
    Process.put(:neighbors, similarity_search(Process.get(:dataset), Process.get(:value_array)))
    while_fun_6 = fn while_fun_6 ->
      if Process.get(:k) < _len(Process.get(:neighbors)) do
        n = Enum.at(Process.get(:neighbors), Process.get(:k))
        IO.puts((((("[" <> Kernel.inspect(n.vector)) <> ", ") <> Kernel.to_string(n.distance)) <> "]"))
        Process.put(:k, Process.get(:k) + 1)
        while_fun_6.(while_fun_6)
      else
        nil
      end
    end
    try do
      while_fun_6.(while_fun_6)
    catch
      :break -> nil
    end

    IO.puts(Kernel.inspect(cosine_similarity([1.0, 2.0], [6.0, 32.0])))
  end
end
Main.main()
