# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_neighbours(p, x_limit, y_limit) do
    try do
      deltas = [%{x: (0 - 1), y: (0 - 1)}, %{x: (0 - 1), y: 0}, %{x: (0 - 1), y: 1}, %{x: 0, y: (0 - 1)}, %{x: 0, y: 1}, %{x: 1, y: (0 - 1)}, %{x: 1, y: 0}, %{x: 1, y: 1}]
      neighbours = []
      {neighbours} = Enum.reduce(deltas, {neighbours}, fn d, {neighbours} ->
        nx = p.x + d.x
        ny = p.y + d.y
        {neighbours} = if 0 <= nx && nx < x_limit && 0 <= ny && ny < y_limit do
          neighbours = (neighbours ++ [%{x: nx, y: ny}])
          {neighbours}
        else
          {neighbours}
        end
        {neighbours}
      end)
      throw {:return, neighbours}
    catch
      {:return, val} -> val
    end
  end
  def contains(nodes, p) do
    try do
      Enum.each(nodes, fn n ->
        if n.pos.x == p.x && n.pos.y == p.y do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def get_node(nodes, p) do
    try do
      Enum.each(nodes, fn n ->
        if n.pos.x == p.x && n.pos.y == p.y do
          throw {:return, n}
        end
      end)
      throw {:return, %{pos: p, parent: %{x: (0 - 1), y: (0 - 1)}, g: 0, h: 0, f: 0}}
    catch
      {:return, val} -> val
    end
  end
  def astar(x_limit, y_limit, start, goal) do
    try do
      open = []
      closed = []
      open = (open ++ [%{pos: start, parent: %{x: (0 - 1), y: (0 - 1)}, g: 0, h: 0, f: 0}])
      current = Enum.at(open, 0, [])
      while_fun = fn while_fun, closed, current, open ->
        if _len(open) > 0 do
          {closed, current, open} = try do
            min_index = 0
            i = 1
            while_fun_2 = fn while_fun_2, i, min_index ->
              if i < _len(open) do
                {min_index} = if Enum.at(open, i, [])["f"] < Enum.at(open, min_index, [])["f"] do
                  min_index = i
                  {min_index}
                else
                  {min_index}
                end
                i = i + 1
                while_fun_2.(while_fun_2, i, min_index)
              else
                {i, min_index}
              end
            end
            {i, min_index} = try do
                while_fun_2.(while_fun_2, i, min_index)
              catch
                {:break, {i, min_index}} -> {i, min_index}
              end

            current = Enum.at(open, min_index, [])
            new_open = []
            j = 0
            while_fun_3 = fn while_fun_3, j, new_open ->
              if j < _len(open) do
                {new_open} = if j != min_index do
                  new_open = (new_open ++ [Enum.at(open, j, [])])
                  {new_open}
                else
                  {new_open}
                end
                j = j + 1
                while_fun_3.(while_fun_3, j, new_open)
              else
                {j, new_open}
              end
            end
            {j, new_open} = try do
                while_fun_3.(while_fun_3, j, new_open)
              catch
                {:break, {j, new_open}} -> {j, new_open}
              end

            open = new_open
            closed = (closed ++ [current])
            if current.pos.x == goal.x && current.pos.y == goal.y do
              throw {:break, {closed, current, open}}
            end
            neighbours = get_neighbours(current.pos, x_limit, y_limit)
            {open} = Enum.reduce(neighbours, {open}, fn np, {open} ->
              try do
                if contains(closed, np) do
                  throw {:continue, {closed, current, open}}
                end
                g = current.g + 1
                dx = goal.x - np.x
                dy = goal.y - np.y
                h = dx * dx + dy * dy
                f = g + h
                skip = false
                {skip} = Enum.reduce(open, {skip}, fn node_, {skip} ->
                  {skip} = if node_.pos.x == np.x && node_.pos.y == np.y && node_.f < f do
                    skip = true
                    {skip}
                  else
                    {skip}
                  end
                  {skip}
                end)
                if skip do
                  throw {:continue, {closed, current, open}}
                end
                open = (open ++ [%{pos: np, parent: current.pos, g: g, h: h, f: f}])
              catch
                :continue -> {open}
              end
              {open}
            end)
            {closed, current, open}
          catch
            {:continue, {closed, current, open}} -> {closed, current, open}
          end
          while_fun.(while_fun, closed, current, open)
        else
          {closed, current, open}
        end
      end
      {closed, current, open} = try do
          while_fun.(while_fun, closed, current, open)
        catch
          {:break, {closed, current, open}} -> {closed, current, open}
        end

      path = []
      path = (path ++ [current.pos])
      while_fun_4 = fn while_fun_4, current ->
        if !(current.parent.x == (0 - 1) && current.parent.y == (0 - 1)) do
          current = get_node(closed, current.parent)
          path = (path ++ [current.pos])
          while_fun_4.(while_fun_4, current)
        else
          current
        end
      end
      current = try do
          while_fun_4.(while_fun_4, current)
        catch
          {:break, {current}} -> current
        end

      rev = []
      k = _len(path) - 1
      while_fun_5 = fn while_fun_5, k, rev ->
        if k >= 0 do
          rev = (rev ++ [Enum.at(path, k, [])])
          k = k - 1
          while_fun_5.(while_fun_5, k, rev)
        else
          {k, rev}
        end
      end
      {k, rev} = try do
          while_fun_5.(while_fun_5, k, rev)
        catch
          {:break, {k, rev}} -> {k, rev}
        end

      throw {:return, rev}
    catch
      {:return, val} -> val
    end
  end
  def create_world(x_limit, y_limit) do
    try do
      world = []
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < x_limit do
          row = []
          j = 0
          while_fun_7 = fn while_fun_7, j, row ->
            if j < y_limit do
              row = (row ++ [0])
              j = j + 1
              while_fun_7.(while_fun_7, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_7.(while_fun_7, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          world = (world ++ [row])
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, world}
    catch
      {:return, val} -> val
    end
  end
  def mark_path(world, path) do
    try do
      Enum.each(path, fn p ->
        world = List.replace_at(world, p.x, List.replace_at(Enum.at(world, p.x), p.y, 1))
      end)
    catch
      {:return, val} -> val
    end
  end
  def print_world(world) do
    try do
      Enum.each(world, fn row ->
        IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [row])), ",", " "))
      end)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:world_x, 5)
  Process.put(:world_y, 5)
  Process.put(:start, %{x: 0, y: 0})
  Process.put(:goal, %{x: 4, y: 4})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:path, astar(Process.get(:world_x), Process.get(:world_y), Process.get(:start), Process.get(:goal)))
    IO.puts((((((((("path from (" <> Kernel.to_string(Process.get(:start).x)) <> ", ") <> Kernel.to_string(Process.get(:start).y)) <> ") to (") <> Kernel.to_string(Process.get(:goal).x)) <> ", ") <> Kernel.to_string(Process.get(:goal).y)) <> ")"))
    Process.put(:world, create_world(Process.get(:world_x), Process.get(:world_y)))
    mark_path(Process.get(:world), Process.get(:path))
    print_world(Process.get(:world))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
