# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  def dual(v, d) do
    try do
      throw {:return, %{value: v, deriv: d}}
    catch
      {:return, val} -> val
    end
  end
  def pow_float(base, exp) do
    try do
      res = 1.0
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < exp do
          res = res * base
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def add(a, b) do
    try do
      throw {:return, %{value: a.value + b.value, deriv: a.deriv + b.deriv}}
    catch
      {:return, val} -> val
    end
  end
  def sub(a, b) do
    try do
      throw {:return, %{value: a.value - b.value, deriv: a.deriv - b.deriv}}
    catch
      {:return, val} -> val
    end
  end
  def mul(a, b) do
    try do
      throw {:return, %{value: a.value * b.value, deriv: a.deriv * b.value + b.deriv * a.value}}
    catch
      {:return, val} -> val
    end
  end
  def div_(a, b) do
    try do
      throw {:return, %{value: a.value / b.value, deriv: (a.deriv * b.value - b.deriv * a.value) / (b.value * b.value)}}
    catch
      {:return, val} -> val
    end
  end
  def power(a, p) do
    try do
      throw {:return, %{value: pow_float(a.value, p), deriv: (1.0 * p) * pow_float(a.value, p - 1) * a.deriv}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      a = dual(2.0, 1.0)
      b = dual(1.0, 0.0)
      c = add(a, b)
      d = mul(a, b)
      e = div_(c, d)
      IO.puts(Kernel.to_string(e.deriv))
      x = dual(2.0, 1.0)
      y = power(x, 3)
      IO.puts(Kernel.to_string(y.deriv))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
