# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_winner(weights, sample) do
    try do
      d0 = 0.0
      d1 = 0.0
      {d0, d1} = Enum.reduce((0..(_len(sample) - 1)//1), {d0, d1}, fn i, {d0, d1} ->
        diff0 = Enum.at(sample, i) - Enum.at(Enum.at(weights, 0), i)
        diff1 = Enum.at(sample, i) - Enum.at(Enum.at(weights, 1), i)
        d0 = d0 + diff0 * diff0
        d1 = d1 + diff1 * diff1
        throw {:return, ((if d0 > d1, do: 0, else: 1))}
        {d0, d1}
      end)
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def update(weights, sample, j, alpha) do
    try do
      {weights} = Enum.reduce((0..(_len(weights) - 1)//1), {weights}, fn i, {weights} ->
        weights = List.replace_at(weights, j, List.replace_at(Enum.at(weights, j), i, Enum.at(Enum.at(weights, j), i) + alpha * (Enum.at(sample, i) - Enum.at(Enum.at(weights, j), i))))
        {weights}
      end)
      throw {:return, weights}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(xs) do
    try do
      s = "["
      i = 0
      while_fun = fn while_fun, i, s ->
        if i < _len(xs) do
          s = (s <> Kernel.to_string(Enum.at(xs, i)))
          {s} = if i < _len(xs) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun.(while_fun, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun.(while_fun, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def matrix_to_string(m) do
    try do
      s = "["
      i = 0
      while_fun_2 = fn while_fun_2, i, s ->
        if i < _len(m) do
          s = (s <> list_to_string(Enum.at(m, i)))
          {s} = if i < _len(m) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_2.(while_fun_2, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      training_samples = [[1, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 0, 1, 1]]
      weights = [[0.2, 0.6, 0.5, 0.9], [0.8, 0.4, 0.7, 0.3]]
      epochs = 3
      alpha = 0.5
      {weights} = Enum.reduce((0..(epochs - 1)//1), {weights}, fn _, {weights} ->
        {weights} = Enum.reduce((0..(_len(training_samples) - 1)//1), {weights}, fn j, {weights} ->
          sample = Enum.at(training_samples, j)
          winner = get_winner(weights, sample)
          weights = update(weights, sample, winner, alpha)
          {weights}
        end)
        {weights}
      end)
      sample = [0, 0, 0, 1]
      winner = get_winner(weights, sample)
      IO.puts(("Clusters that the test sample belongs to : " <> Kernel.to_string(winner)))
      IO.puts(("Weights that have been trained : " <> matrix_to_string(weights)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
