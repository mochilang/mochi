# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def dot(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun = fn while_fun, i, sum ->
        if i < _len(a) do
          sum = sum + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun.(while_fun, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun.(while_fun, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def maxf(a, b) do
    try do
      throw {:return, ((if a > b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def minf(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x >= 0.0, do: x, else: 0.0 - x))}
    catch
      {:return, val} -> val
    end
  end
  def predict_raw(samples, labels, alphas, b, x) do
    try do
      res = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(samples) do
          res = res + Enum.at(alphas, i) * Enum.at(labels, i) * dot(Enum.at(samples, i), x)
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res + b}
    catch
      {:return, val} -> val
    end
  end
  def smo_train(samples, labels, c, tol, max_passes) do
    try do
      m = _len(samples)
      alphas = []
      i = 0
      while_fun_3 = fn while_fun_3, alphas, i ->
        if i < m do
          alphas = (alphas ++ [0.0])
          i = i + 1
          while_fun_3.(while_fun_3, alphas, i)
        else
          {alphas, i}
        end
      end
      {alphas, i} = try do
          while_fun_3.(while_fun_3, alphas, i)
        catch
          {:break, {alphas, i}} -> {alphas, i}
        end

      b = 0.0
      passes = 0
      while_fun_4 = fn while_fun_4, alphas, b, passes ->
        if passes < max_passes do
          {alphas, b, passes} = try do
            num_changed = 0
            i1 = 0
            while_fun_5 = fn while_fun_5, alphas, b, i1, num_changed ->
              if i1 < m do
                {alphas, b, i1, num_changed} = try do
                  ei = predict_raw(samples, labels, alphas, b, Enum.at(samples, i1)) - Enum.at(labels, i1)
                  {alphas, b, i1, num_changed} = if (Enum.at(labels, i1) * ei < 0.0 - tol && Enum.at(alphas, i1) < c) || (Enum.at(labels, i1) * ei > tol && Enum.at(alphas, i1) > 0.0) do
                    i2 = rem((i1 + 1), m)
                    ej = predict_raw(samples, labels, alphas, b, Enum.at(samples, i2)) - Enum.at(labels, i2)
                    alpha1_old = Enum.at(alphas, i1)
                    alpha2_old = Enum.at(alphas, i2)
                    l = 0.0
                    h = 0.0
                    {h, l} = if Enum.at(labels, i1) != Enum.at(labels, i2) do
                      l = maxf(0.0, alpha2_old - alpha1_old)
                      h = minf(c, c + alpha2_old - alpha1_old)
                      {h, l}
                    else
                      l = maxf(0.0, alpha2_old + alpha1_old - c)
                      h = minf(c, alpha2_old + alpha1_old)
                      {h, l}
                    end
                    {i1} = if l == h do
                      i1 = i1 + 1
                      throw {:continue, {alphas, b, i1, num_changed}}
                      {i1}
                    else
                      {i1}
                    end
                    eta = 2.0 * dot(Enum.at(samples, i1), Enum.at(samples, i2)) - dot(Enum.at(samples, i1), Enum.at(samples, i1)) - dot(Enum.at(samples, i2), Enum.at(samples, i2))
                    {i1} = if eta >= 0.0 do
                      i1 = i1 + 1
                      throw {:continue, {alphas, b, i1, num_changed}}
                      {i1}
                    else
                      {i1}
                    end
                    alphas = List.replace_at(alphas, i2, alpha2_old - Enum.at(labels, i2) * (ei - ej) / eta)
                    {alphas} = if Enum.at(alphas, i2) > h do
                      alphas = List.replace_at(alphas, i2, h)
                      {alphas}
                    else
                      {alphas}
                    end
                    {alphas} = if Enum.at(alphas, i2) < l do
                      alphas = List.replace_at(alphas, i2, l)
                      {alphas}
                    else
                      {alphas}
                    end
                    {i1} = if absf(Enum.at(alphas, i2) - alpha2_old) < 0.00001 do
                      i1 = i1 + 1
                      throw {:continue, {alphas, b, i1, num_changed}}
                      {i1}
                    else
                      {i1}
                    end
                    alphas = List.replace_at(alphas, i1, alpha1_old + Enum.at(labels, i1) * Enum.at(labels, i2) * (alpha2_old - Enum.at(alphas, i2)))
                    b1 = b - ei - Enum.at(labels, i1) * (Enum.at(alphas, i1) - alpha1_old) * dot(Enum.at(samples, i1), Enum.at(samples, i1)) - Enum.at(labels, i2) * (Enum.at(alphas, i2) - alpha2_old) * dot(Enum.at(samples, i1), Enum.at(samples, i2))
                    b2 = b - ej - Enum.at(labels, i1) * (Enum.at(alphas, i1) - alpha1_old) * dot(Enum.at(samples, i1), Enum.at(samples, i2)) - Enum.at(labels, i2) * (Enum.at(alphas, i2) - alpha2_old) * dot(Enum.at(samples, i2), Enum.at(samples, i2))
                    {b} = if Enum.at(alphas, i1) > 0.0 && Enum.at(alphas, i1) < c do
                      b = b1
                      {b}
                    else
                      {b} = if Enum.at(alphas, i2) > 0.0 && Enum.at(alphas, i2) < c do
                        b = b2
                        {b}
                      else
                        b = (b1 + b2) / 2.0
                        {b}
                      end
                      {b}
                    end
                    num_changed = num_changed + 1
                    {alphas, b, i1, num_changed}
                  else
                    {alphas, b, i1, num_changed}
                  end
                  i1 = i1 + 1
                  {alphas, b, i1, num_changed}
                catch
                  {:continue, {alphas, b, i1, num_changed}} -> {alphas, b, i1, num_changed}
                end
                while_fun_5.(while_fun_5, alphas, b, i1, num_changed)
              else
                {alphas, b, i1, num_changed}
              end
            end
            {alphas, b, i1, num_changed} = try do
                while_fun_5.(while_fun_5, alphas, b, i1, num_changed)
              catch
                {:break, {alphas, b, i1, num_changed}} -> {alphas, b, i1, num_changed}
              end

            passes = (if num_changed == 0, do: passes + 1, else: 0)
            {alphas, b, passes}
          catch
            {:continue, {alphas, b, passes}} -> {alphas, b, passes}
          end
          while_fun_4.(while_fun_4, alphas, b, passes)
        else
          {alphas, b, passes}
        end
      end
      {alphas, b, passes} = try do
          while_fun_4.(while_fun_4, alphas, b, passes)
        catch
          {:break, {alphas, b, passes}} -> {alphas, b, passes}
        end

      throw {:return, [alphas, [b]]}
    catch
      {:return, val} -> val
    end
  end
  def predict(samples, labels, model, x) do
    try do
      alphas = Enum.at(model, 0)
      b = Enum.at(Enum.at(model, 1), 0)
      val = predict_raw(samples, labels, alphas, b, x)
      if val >= 0.0 do
        throw {:return, 1.0}
      end
      throw {:return, -1.0}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:samples, [[2.0, 2.0], [1.5, 1.5], [0.0, 0.0], [0.5, 0.0]])
  def main() do
    Process.put(:labels, [1.0, 1.0, -1.0, -1.0])
    Process.put(:model, smo_train(Process.get(:samples), Process.get(:labels), 1.0, 0.001, 10))
    IO.puts(Kernel.inspect(predict(Process.get(:samples), Process.get(:labels), Process.get(:model), [1.5, 1.0])))
    IO.puts(Kernel.inspect(predict(Process.get(:samples), Process.get(:labels), Process.get(:model), [0.2, 0.1])))
  end
end
Main.main()
