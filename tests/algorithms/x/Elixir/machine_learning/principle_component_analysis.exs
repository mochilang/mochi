# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrt(x) do
    try do
      guess = (if x > 1.0, do: x / 2.0, else: 1.0)
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = 0.5 * (guess + x / guess)
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def mean(xs) do
    try do
      sum = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, sum ->
        if i < _len(xs) do
          sum = sum + Enum.at(xs, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_2.(while_fun_2, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, div(sum, _len(xs))}
    catch
      {:return, val} -> val
    end
  end
  def standardize(data) do
    try do
      n_samples = _len(data)
      n_features = _len(Enum.at(data, 0))
      means = []
      stds = []
      j = 0
      while_fun_3 = fn while_fun_3, j, means, stds ->
        if j < n_features do
          column = []
          i = 0
          while_fun_4 = fn while_fun_4, column, i ->
            if i < n_samples do
              column = (column ++ [Enum.at(Enum.at(data, i), j)])
              i = i + 1
              while_fun_4.(while_fun_4, column, i)
            else
              {column, i}
            end
          end
          {column, i} = try do
              while_fun_4.(while_fun_4, column, i)
            catch
              {:break, {column, i}} -> {column, i}
            end

          m = mean(column)
          means = (means ++ [m])
          variance = 0.0
          k = 0
          while_fun_5 = fn while_fun_5, k, variance ->
            if k < n_samples do
              diff = Enum.at(column, k) - m
              variance = variance + diff * diff
              k = k + 1
              while_fun_5.(while_fun_5, k, variance)
            else
              {k, variance}
            end
          end
          {k, variance} = try do
              while_fun_5.(while_fun_5, k, variance)
            catch
              {:break, {k, variance}} -> {k, variance}
            end

          stds = (stds ++ [sqrt(variance / (n_samples - 1))])
          j = j + 1
          while_fun_3.(while_fun_3, j, means, stds)
        else
          {j, means, stds}
        end
      end
      {j, means, stds} = try do
          while_fun_3.(while_fun_3, j, means, stds)
        catch
          {:break, {j, means, stds}} -> {j, means, stds}
        end

      standardized = []
      r = 0
      while_fun_6 = fn while_fun_6, r, standardized ->
        if r < n_samples do
          row = []
          c = 0
          while_fun_7 = fn while_fun_7, c, row ->
            if c < n_features do
              row = (row ++ [(Enum.at(Enum.at(data, r), c) - Enum.at(means, c)) / Enum.at(stds, c)])
              c = c + 1
              while_fun_7.(while_fun_7, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_7.(while_fun_7, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          standardized = (standardized ++ [row])
          r = r + 1
          while_fun_6.(while_fun_6, r, standardized)
        else
          {r, standardized}
        end
      end
      {r, standardized} = try do
          while_fun_6.(while_fun_6, r, standardized)
        catch
          {:break, {r, standardized}} -> {r, standardized}
        end

      throw {:return, standardized}
    catch
      {:return, val} -> val
    end
  end
  def covariance_matrix(data) do
    try do
      n_samples = _len(data)
      n_features = _len(Enum.at(data, 0))
      cov = []
      i = 0
      while_fun_8 = fn while_fun_8, cov, i ->
        if i < n_features do
          row = []
          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < n_features do
              sum = 0.0
              k = 0
              while_fun_10 = fn while_fun_10, k, sum ->
                if k < n_samples do
                  sum = sum + Enum.at(Enum.at(data, k), i) * Enum.at(Enum.at(data, k), j)
                  k = k + 1
                  while_fun_10.(while_fun_10, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_10.(while_fun_10, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [div(sum, (n_samples - 1))])
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          cov = (cov ++ [row])
          i = i + 1
          while_fun_8.(while_fun_8, cov, i)
        else
          {cov, i}
        end
      end
      {cov, i} = try do
          while_fun_8.(while_fun_8, cov, i)
        catch
          {:break, {cov, i}} -> {cov, i}
        end

      throw {:return, cov}
    catch
      {:return, val} -> val
    end
  end
  def normalize(vec) do
    try do
      sum = 0.0
      i = 0
      while_fun_11 = fn while_fun_11, i, sum ->
        if i < _len(vec) do
          sum = sum + Enum.at(vec, i) * Enum.at(vec, i)
          i = i + 1
          while_fun_11.(while_fun_11, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_11.(while_fun_11, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      n = sqrt(sum)
      res = []
      j = 0
      while_fun_12 = fn while_fun_12, j, res ->
        if j < _len(vec) do
          res = (res ++ [Enum.at(vec, j) / n])
          j = j + 1
          while_fun_12.(while_fun_12, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_12.(while_fun_12, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def eigen_decomposition_2x2(matrix) do
    try do
      a = Enum.at(Enum.at(matrix, 0), 0)
      b = Enum.at(Enum.at(matrix, 0), 1)
      c = Enum.at(Enum.at(matrix, 1), 1)
      diff = a - c
      discriminant = sqrt(diff * diff + 4.0 * b * b)
      lambda1 = (a + c + discriminant) / 2.0
      lambda2 = (a + c - discriminant) / 2.0
      v1 = nil
      v2 = nil
      {v1, v2} = if b != 0.0 do
        v1 = normalize([lambda1 - c, b])
        v2 = normalize([lambda2 - c, b])
        {v1, v2}
      else
        v1 = [1.0, 0.0]
        v2 = [0.0, 1.0]
        {v1, v2}
      end
      eigenvalues = [lambda1, lambda2]
      eigenvectors = [v1, v2]
      {eigenvalues, eigenvectors} = if Enum.at(eigenvalues, 0) < Enum.at(eigenvalues, 1) do
        tmp_val = Enum.at(eigenvalues, 0)
        eigenvalues = List.replace_at(eigenvalues, 0, Enum.at(eigenvalues, 1))
        eigenvalues = List.replace_at(eigenvalues, 1, tmp_val)
        tmp_vec = Enum.at(eigenvectors, 0)
        eigenvectors = List.replace_at(eigenvectors, 0, Enum.at(eigenvectors, 1))
        eigenvectors = List.replace_at(eigenvectors, 1, tmp_vec)
        {eigenvalues, eigenvectors}
      else
        {eigenvalues, eigenvectors}
      end
      throw {:return, %{values: eigenvalues, vectors: eigenvectors}}
    catch
      {:return, val} -> val
    end
  end
  def transpose(matrix) do
    try do
      rows = _len(matrix)
      cols = _len(Enum.at(matrix, 0))
      trans = []
      i = 0
      while_fun_13 = fn while_fun_13, i, trans ->
        if i < cols do
          row = []
          j = 0
          while_fun_14 = fn while_fun_14, j, row ->
            if j < rows do
              row = (row ++ [Enum.at(Enum.at(matrix, j), i)])
              j = j + 1
              while_fun_14.(while_fun_14, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_14.(while_fun_14, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          trans = (trans ++ [row])
          i = i + 1
          while_fun_13.(while_fun_13, i, trans)
        else
          {i, trans}
        end
      end
      {i, trans} = try do
          while_fun_13.(while_fun_13, i, trans)
        catch
          {:break, {i, trans}} -> {i, trans}
        end

      throw {:return, trans}
    catch
      {:return, val} -> val
    end
  end
  def matrix_multiply(a, b) do
    try do
      rows_a = _len(a)
      cols_a = _len(Enum.at(a, 0))
      rows_b = _len(b)
      cols_b = _len(Enum.at(b, 0))
      if cols_a != rows_b do
        raise("Incompatible matrices")
      end
      result = []
      i = 0
      while_fun_15 = fn while_fun_15, i ->
        if i < rows_a do
          row = []
          j = 0
          while_fun_16 = fn while_fun_16, j, row ->
            if j < cols_b do
              sum = 0.0
              k = 0
              while_fun_17 = fn while_fun_17, k, sum ->
                if k < cols_a do
                  sum = sum + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_17.(while_fun_17, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_17.(while_fun_17, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [sum])
              j = j + 1
              while_fun_16.(while_fun_16, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_16.(while_fun_16, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_15.(while_fun_15, i)
        else
          i
        end
      end
      i = try do
          while_fun_15.(while_fun_15, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def apply_pca(data, n_components) do
    try do
      standardized = standardize(data)
      cov = covariance_matrix(standardized)
      eig = eigen_decomposition_2x2(cov)
      eigenvalues = eig.values
      eigenvectors = eig.vectors
      components = transpose(eigenvectors)
      transformed = matrix_multiply(standardized, components)
      total = Enum.at(eigenvalues, 0) + Enum.at(eigenvalues, 1)
      ratios = []
      i = 0
      while_fun_18 = fn while_fun_18, i, ratios ->
        if i < n_components do
          ratios = (ratios ++ [Enum.at(eigenvalues, i) / total])
          i = i + 1
          while_fun_18.(while_fun_18, i, ratios)
        else
          {i, ratios}
        end
      end
      {i, ratios} = try do
          while_fun_18.(while_fun_18, i, ratios)
        catch
          {:break, {i, ratios}} -> {i, ratios}
        end

      throw {:return, %{transformed: transformed, variance_ratio: ratios}}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:data, [[2.5, 2.4], [0.5, 0.7], [2.2, 2.9], [1.9, 2.2], [3.1, 3.0], [2.3, 2.7], [2.0, 1.6], [1.0, 1.1], [1.5, 1.6], [1.1, 0.9]])
  Process.put(:idx, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:result, apply_pca(Process.get(:data), 2))
    IO.puts("Transformed Data (first 5 rows):")
    while_fun_19 = fn while_fun_19 ->
      if Process.get(:idx) < 5 do
        IO.puts(Kernel.inspect(Enum.at(Process.get(:result).transformed, Process.get(:idx))))
        Process.put(:idx, Process.get(:idx) + 1)
        while_fun_19.(while_fun_19)
      else
        nil
      end
    end
    try do
      while_fun_19.(while_fun_19)
    catch
      :break -> nil
    end

    IO.puts("Explained Variance Ratio:")
    IO.puts(Kernel.inspect(Process.get(:result).variance_ratio))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
