# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def to_lowercase(s) do
    try do
      res = ""
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(s) do
          c = String.at(s, i)
          j = 0
          found = false
          while_fun_2 = fn while_fun_2, found, j, res ->
            if j < _len(Process.get(:upper)) do
              {found, res} = if c == String.at(Process.get(:upper), j) do
                res = (res <> String.at(Process.get(:lower), j))
                found = true
                throw {:break, {found, j, res}}
                {found, res}
              else
                {found, res}
              end
              j = j + 1
              while_fun_2.(while_fun_2, found, j, res)
            else
              {found, j, res}
            end
          end
          {found, j, res} = try do
              while_fun_2.(while_fun_2, found, j, res)
            catch
              {:break, {found, j, res}} -> {found, j, res}
            end

          {res} = if !found do
            res = (res <> c)
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def is_punct(c) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(Process.get(:punct)) do
          if c == String.at(Process.get(:punct), i) do
            throw {:return, true}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def clean_text(text, keep_newlines) do
    try do
      lower = to_lowercase(text)
      res = ""
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(lower) do
          ch = Enum.at(lower, i)
          {res} = if is_punct(ch) do
            {res}
          else
            {res} = if ch == "\n" do
              {res} = if keep_newlines do
                res = (res <> "\n")
                {res}
              else
                {res}
              end
              {res}
            else
              res = (res <> ch)
              {res}
            end
            {res}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def split(s, sep) do
    try do
      res = []
      current = ""
      i = 0
      while_fun_5 = fn while_fun_5, current, i, res ->
        if i < _len(s) do
          ch = String.at(s, i)
          {current, res} = if ch == sep do
            res = (res ++ [current])
            current = ""
            {current, res}
          else
            current = (current <> ch)
            {current, res}
          end
          i = i + 1
          while_fun_5.(while_fun_5, current, i, res)
        else
          {current, i, res}
        end
      end
      {current, i, res} = try do
          while_fun_5.(while_fun_5, current, i, res)
        catch
          {:break, {current, i, res}} -> {current, i, res}
        end

      res = (res ++ [current])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def contains(s, sub) do
    try do
      n = _len(s)
      m = _len(sub)
      if m == 0 do
        throw {:return, true}
      end
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i <= n - m do
          j = 0
          is_match = true
          while_fun_7 = fn while_fun_7, is_match, j ->
            if j < m do
              {is_match} = if String.at(s, i + j) != String.at(sub, j) do
                is_match = false
                throw {:break, {is_match, j}}
                {is_match}
              else
                {is_match}
              end
              j = j + 1
              while_fun_7.(while_fun_7, is_match, j)
            else
              {is_match, j}
            end
          end
          {is_match, j} = try do
              while_fun_7.(while_fun_7, is_match, j)
            catch
              {:break, {is_match, j}} -> {is_match, j}
            end

          if is_match do
            throw {:return, true}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def round3(x) do
    try do
      throw {:return, floor(x * 1000.0 + 0.5) / 1000.0}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      t = (x - 1.0) / (x + 1.0)
      term = t
      sum = 0.0
      k = 1
      while_fun_8 = fn while_fun_8, k, sum, term ->
        if k <= 99 do
          sum = sum + term / (:erlang.float(k))
          term = term * t * t
          k = k + 2
          while_fun_8.(while_fun_8, k, sum, term)
        else
          {k, sum, term}
        end
      end
      {k, sum, term} = try do
          while_fun_8.(while_fun_8, k, sum, term)
        catch
          {:break, {k, sum, term}} -> {k, sum, term}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def log10(x) do
    try do
      throw {:return, ln(x) / ln(10.0)}
    catch
      {:return, val} -> val
    end
  end
  def term_frequency(term, document) do
    try do
      clean = clean_text(document, false)
      tokens = split(clean, " ")
      t = to_lowercase(term)
      count = 0
      i = 0
      while_fun_9 = fn while_fun_9, count, i ->
        if i < _len(tokens) do
          {count} = if Enum.at(tokens, i) != "" && Enum.at(tokens, i) == t do
            count = count + 1
            {count}
          else
            {count}
          end
          i = i + 1
          while_fun_9.(while_fun_9, count, i)
        else
          {count, i}
        end
      end
      {count, i} = try do
          while_fun_9.(while_fun_9, count, i)
        catch
          {:break, {count, i}} -> {count, i}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def document_frequency(term, corpus) do
    try do
      clean = clean_text(corpus, true)
      docs = split(clean, "\n")
      t = to_lowercase(term)
      matches = 0
      i = 0
      while_fun_10 = fn while_fun_10, i, matches ->
        if i < _len(docs) do
          {matches} = if contains(Enum.at(docs, i), t) do
            matches = matches + 1
            {matches}
          else
            {matches}
          end
          i = i + 1
          while_fun_10.(while_fun_10, i, matches)
        else
          {i, matches}
        end
      end
      {i, matches} = try do
          while_fun_10.(while_fun_10, i, matches)
        catch
          {:break, {i, matches}} -> {i, matches}
        end

      throw {:return, [matches, _len(docs)]}
    catch
      {:return, val} -> val
    end
  end
  def inverse_document_frequency(df, n, smoothing) do
    try do
      if smoothing do
        if n == 0 do
          raise("log10(0) is undefined.")
        end
        ratio = (:erlang.float(n)) / (1.0 + (:erlang.float(df)))
        l = log10(ratio)
        result = round3(1.0 + l)
        IO.puts(result)
        throw {:return, result}
      end
      if df == 0 do
        raise("df must be > 0")
      end
      if n == 0 do
        raise("log10(0) is undefined.")
      end
      ratio = (:erlang.float(n)) / (:erlang.float(df))
      l = log10(ratio)
      result = round3(l)
      IO.puts(result)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def tf_idf(tf, idf) do
    try do
      prod = (:erlang.float(tf)) * idf
      result = round3(prod)
      IO.puts(result)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:lower, "abcdefghijklmnopqrstuvwxyz")
  Process.put(:upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  Process.put(:punct, "!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~")
  Process.put(:corpus, "This is the first document in the corpus.\nThIs is the second document in the corpus.\nTHIS is the third document in the corpus.")
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(term_frequency("to", "To be, or not to be")))
    IO.puts(Kernel.inspect(document_frequency("first", Process.get(:corpus))))
    Process.put(:idf_val, inverse_document_frequency(1, 3, false))
    tf_idf(2, Process.get(:idf_val))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
