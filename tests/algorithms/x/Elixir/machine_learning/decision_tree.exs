# Code generated by Mochi transpiler 2025-08-14 17:45 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def _mod(x, m) do
    try do
      throw {:return, x - (:erlang.float(Kernel.trunc(x / m))) * m}
    catch
      {:return, val} -> val
    end
  end
  def sin(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y3 = y2 * y
      y5 = y3 * y2
      y7 = y5 * y2
      throw {:return, y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0}
    catch
      {:return, val} -> val
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((1103515245 * Process.get(:seed) + 12345), 2147483648))
      throw {:return, :erlang.float(Process.get(:seed)) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def mean(vals) do
    try do
      sum = 0.0
      i = 0
      while_fun = fn while_fun, i, sum ->
        if i < _len(vals) do
          sum = sum + Enum.at(vals, i, [])
          i = i + 1
          while_fun.(while_fun, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun.(while_fun, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum / _len(vals)}
    catch
      {:return, val} -> val
    end
  end
  def mean_squared_error(labels, prediction) do
    try do
      total = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, total ->
        if i < _len(labels) do
          diff = Enum.at(labels, i, []) - prediction
          total = total + diff * diff
          i = i + 1
          while_fun_2.(while_fun_2, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_2.(while_fun_2, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total / _len(labels)}
    catch
      {:return, val} -> val
    end
  end
  def train_tree(x, y, depth, min_leaf_size) do
    try do
      if _len(x) < 2 * min_leaf_size do
        throw {:return, %{prediction: mean(y)}}
      end
      if depth == 1 do
        throw {:return, %{prediction: mean(y)}}
      end
      best_split = 0
      min_error = mean_squared_error(x, mean(y)) * 2.0
      i = 0
      while_fun_3 = fn while_fun_3, best_split, i, min_error ->
        if i < _len(x) do
          {best_split, i, min_error} = if _len(_slice(x, 0, i - 0)) < min_leaf_size do
            i = i
            {best_split, i, min_error}
          else
            {best_split, i, min_error} = if _len(_slice(x, i, _len(x) - i)) < min_leaf_size do
              i = i
              {best_split, i, min_error}
            else
              err_left = mean_squared_error(_slice(x, 0, i - 0), mean(_slice(y, 0, i - 0)))
              err_right = mean_squared_error(_slice(x, i, _len(x) - i), mean(_slice(y, i, _len(y) - i)))
              err = err_left + err_right
              {best_split, min_error} = if err < min_error do
                best_split = i
                min_error = err
                {best_split, min_error}
              else
                {best_split, min_error}
              end
              {best_split, i, min_error}
            end
            {best_split, i, min_error}
          end
          i = i + 1
          while_fun_3.(while_fun_3, best_split, i, min_error)
        else
          {best_split, i, min_error}
        end
      end
      {best_split, i, min_error} = try do
          while_fun_3.(while_fun_3, best_split, i, min_error)
        catch
          {:break, {best_split, i, min_error}} -> {best_split, i, min_error}
        end

      if best_split != 0 do
        left_x = _slice(x, 0, best_split - 0)
        left_y = _slice(y, 0, best_split - 0)
        right_x = _slice(x, best_split, _len(x) - best_split)
        right_y = _slice(y, best_split, _len(y) - best_split)
        boundary = Enum.at(x, best_split, [])
        left_tree = train_tree(left_x, left_y, depth - 1, min_leaf_size)
        right_tree = train_tree(right_x, right_y, depth - 1, min_leaf_size)
        throw {:return, %{decision_boundary: boundary, left: left_tree, right: right_tree}}
      end
      throw {:return, %{prediction: mean(y)}}
    catch
      {:return, val} -> val
    end
  end
  def predict(tree, value) do
    try do
      throw {:return, case tree do
  %{prediction: p} -> p
  %{decision_boundary: b, left: l, right: r} -> (if value >= b, do: predict(r, value), else: predict(l, value))
end}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      x = []
      v = -1.0
      while_fun_4 = fn while_fun_4, v, x ->
        if v < 1.0 do
          x = (x ++ [v])
          v = v + 0.005
          while_fun_4.(while_fun_4, v, x)
        else
          {v, x}
        end
      end
      {v, x} = try do
          while_fun_4.(while_fun_4, v, x)
        catch
          {:break, {v, x}} -> {v, x}
        end

      y = []
      i = 0
      while_fun_5 = fn while_fun_5, i, y ->
        if i < _len(x) do
          y = (y ++ [sin(Enum.at(x, i, []))])
          i = i + 1
          while_fun_5.(while_fun_5, i, y)
        else
          {i, y}
        end
      end
      {i, y} = try do
          while_fun_5.(while_fun_5, i, y)
        catch
          {:break, {i, y}} -> {i, y}
        end

      tree = train_tree(x, y, 10, 10)
      test_cases = []
      i = 0
      while_fun_6 = fn while_fun_6, i, test_cases ->
        if i < 10 do
          test_cases = (test_cases ++ [rand() * 2.0 - 1.0])
          i = i + 1
          while_fun_6.(while_fun_6, i, test_cases)
        else
          {i, test_cases}
        end
      end
      {i, test_cases} = try do
          while_fun_6.(while_fun_6, i, test_cases)
        catch
          {:break, {i, test_cases}} -> {i, test_cases}
        end

      predictions = []
      i = 0
      while_fun_7 = fn while_fun_7, i, predictions ->
        if i < _len(test_cases) do
          predictions = (predictions ++ [predict(tree, Enum.at(test_cases, i, []))])
          i = i + 1
          while_fun_7.(while_fun_7, i, predictions)
        else
          {i, predictions}
        end
      end
      {i, predictions} = try do
          while_fun_7.(while_fun_7, i, predictions)
        catch
          {:break, {i, predictions}} -> {i, predictions}
        end

      sum_err = 0.0
      i = 0
      while_fun_8 = fn while_fun_8, i, sum_err ->
        if i < _len(test_cases) do
          diff = Enum.at(predictions, i, []) - Enum.at(test_cases, i, [])
          sum_err = sum_err + diff * diff
          i = i + 1
          while_fun_8.(while_fun_8, i, sum_err)
        else
          {i, sum_err}
        end
      end
      {i, sum_err} = try do
          while_fun_8.(while_fun_8, i, sum_err)
        catch
          {:break, {i, sum_err}} -> {i, sum_err}
        end

      avg_error = sum_err / _len(test_cases)
      IO.puts(("Test values: " <> Kernel.inspect(test_cases)))
      IO.puts(("Predictions: " <> Kernel.inspect(predictions)))
      IO.puts(("Average error: " <> Kernel.to_string(avg_error)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:two_pi, 6.283185307179586)
  Process.put(:seed, 123456789)
end
Main.main()
