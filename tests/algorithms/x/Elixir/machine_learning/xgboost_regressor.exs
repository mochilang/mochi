# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def data_handling(dataset) do
    try do
      throw {:return, dataset}
    catch
      {:return, val} -> val
    end
  end
  def xgboost(features, target, test_features) do
    try do
      learning_rate = 0.5
      n_estimators = 3
      trees = []
      predictions = []
      i = 0
      while_fun = fn while_fun, i, predictions ->
        if i < _len(target) do
          predictions = (predictions ++ [0.0])
          i = i + 1
          while_fun.(while_fun, i, predictions)
        else
          {i, predictions}
        end
      end
      {i, predictions} = try do
          while_fun.(while_fun, i, predictions)
        catch
          {:break, {i, predictions}} -> {i, predictions}
        end

      est = 0
      while_fun_2 = fn while_fun_2, est, predictions, trees ->
        if est < n_estimators do
          residuals = []
          j = 0
          while_fun_3 = fn while_fun_3, j, residuals ->
            if j < _len(target) do
              residuals = (residuals ++ [Enum.at(target, j) - Enum.at(predictions, j)])
              j = j + 1
              while_fun_3.(while_fun_3, j, residuals)
            else
              {j, residuals}
            end
          end
          {j, residuals} = try do
              while_fun_3.(while_fun_3, j, residuals)
            catch
              {:break, {j, residuals}} -> {j, residuals}
            end

          sum_feat = 0.0
          j = 0
          while_fun_4 = fn while_fun_4, j, sum_feat ->
            if j < _len(features) do
              sum_feat = sum_feat + Enum.at(Enum.at(features, j), 0)
              j = j + 1
              while_fun_4.(while_fun_4, j, sum_feat)
            else
              {j, sum_feat}
            end
          end
          {j, sum_feat} = try do
              while_fun_4.(while_fun_4, j, sum_feat)
            catch
              {:break, {j, sum_feat}} -> {j, sum_feat}
            end

          threshold = sum_feat / (:erlang.float(_len(features)))
          left_sum = 0.0
          left_count = 0
          right_sum = 0.0
          right_count = 0
          j = 0
          while_fun_5 = fn while_fun_5, j, left_count, left_sum, right_count, right_sum ->
            if j < _len(features) do
              {left_count, left_sum, right_count, right_sum} = if Enum.at(Enum.at(features, j), 0) <= threshold do
                left_sum = left_sum + Enum.at(residuals, j)
                left_count = left_count + 1
                {left_count, left_sum, right_count, right_sum}
              else
                right_sum = right_sum + Enum.at(residuals, j)
                right_count = right_count + 1
                {left_count, left_sum, right_count, right_sum}
              end
              j = j + 1
              while_fun_5.(while_fun_5, j, left_count, left_sum, right_count, right_sum)
            else
              {j, left_count, left_sum, right_count, right_sum}
            end
          end
          {j, left_count, left_sum, right_count, right_sum} = try do
              while_fun_5.(while_fun_5, j, left_count, left_sum, right_count, right_sum)
            catch
              {:break, {j, left_count, left_sum, right_count, right_sum}} -> {j, left_count, left_sum, right_count, right_sum}
            end

          left_value = 0.0
          {left_value} = if left_count > 0 do
            left_value = left_sum / (:erlang.float(left_count))
            {left_value}
          else
            {left_value}
          end
          right_value = 0.0
          {right_value} = if right_count > 0 do
            right_value = right_sum / (:erlang.float(right_count))
            {right_value}
          else
            {right_value}
          end
          j = 0
          while_fun_6 = fn while_fun_6, j, predictions ->
            if j < _len(features) do
              predictions = List.replace_at(predictions, j, ((if Enum.at(Enum.at(features, j), 0) <= threshold, do: Enum.at(predictions, j) + learning_rate * left_value, else: Enum.at(predictions, j) + learning_rate * right_value)))
              j = j + 1
              while_fun_6.(while_fun_6, j, predictions)
            else
              {j, predictions}
            end
          end
          {j, predictions} = try do
              while_fun_6.(while_fun_6, j, predictions)
            catch
              {:break, {j, predictions}} -> {j, predictions}
            end

          trees = (trees ++ [%{threshold: threshold, left_value: left_value, right_value: right_value}])
          est = est + 1
          while_fun_2.(while_fun_2, est, predictions, trees)
        else
          {est, predictions, trees}
        end
      end
      {est, predictions, trees} = try do
          while_fun_2.(while_fun_2, est, predictions, trees)
        catch
          {:break, {est, predictions, trees}} -> {est, predictions, trees}
        end

      preds = []
      t = 0
      while_fun_7 = fn while_fun_7, preds, t ->
        if t < _len(test_features) do
          pred = 0.0
          k = 0
          while_fun_8 = fn while_fun_8, k, pred ->
            if k < _len(trees) do
              pred = (if Enum.at(Enum.at(test_features, t), 0) <= Enum.at(trees, k)["threshold"], do: pred + learning_rate * Enum.at(trees, k)["left_value"], else: pred + learning_rate * Enum.at(trees, k)["right_value"])
              k = k + 1
              while_fun_8.(while_fun_8, k, pred)
            else
              {k, pred}
            end
          end
          {k, pred} = try do
              while_fun_8.(while_fun_8, k, pred)
            catch
              {:break, {k, pred}} -> {k, pred}
            end

          preds = (preds ++ [pred])
          t = t + 1
          while_fun_7.(while_fun_7, preds, t)
        else
          {preds, t}
        end
      end
      {preds, t} = try do
          while_fun_7.(while_fun_7, preds, t)
        catch
          {:break, {preds, t}} -> {preds, t}
        end

      throw {:return, preds}
    catch
      {:return, val} -> val
    end
  end
  def mean_absolute_error(y_true, y_pred) do
    try do
      sum = 0.0
      i = 0
      while_fun_9 = fn while_fun_9, i, sum ->
        if i < _len(y_true) do
          diff = Enum.at(y_true, i) - Enum.at(y_pred, i)
          {diff} = if diff < 0.0 do
            diff = -diff
            {diff}
          else
            {diff}
          end
          sum = sum + diff
          i = i + 1
          while_fun_9.(while_fun_9, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_9.(while_fun_9, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum / (:erlang.float(_len(y_true)))}
    catch
      {:return, val} -> val
    end
  end
  def mean_squared_error(y_true, y_pred) do
    try do
      sum = 0.0
      i = 0
      while_fun_10 = fn while_fun_10, i, sum ->
        if i < _len(y_true) do
          diff = Enum.at(y_true, i) - Enum.at(y_pred, i)
          sum = sum + diff * diff
          i = i + 1
          while_fun_10.(while_fun_10, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_10.(while_fun_10, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum / (:erlang.float(_len(y_true)))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      california = %{data: [[1.0], [2.0], [3.0], [4.0]], target: [2.0, 3.0, 4.0, 5.0]}
      ds = data_handling(california)
      x_train = ds.data
      y_train = ds.target
      x_test = [[1.5], [3.5]]
      y_test = [2.5, 4.5]
      predictions = xgboost(x_train, y_train, x_test)
      IO.puts("Predictions:")
      IO.puts(Kernel.inspect(predictions))
      IO.puts("Mean Absolute Error:")
      IO.puts(Kernel.inspect(mean_absolute_error(y_test, predictions)))
      IO.puts("Mean Square Error:")
      IO.puts(Kernel.inspect(mean_squared_error(y_test, predictions)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
