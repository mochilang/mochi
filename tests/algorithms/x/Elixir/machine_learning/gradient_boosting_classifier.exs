# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def exp_approx(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          term = term * x / (:erlang.float(i))
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def signf(x) do
    try do
      throw {:return, ((if x >= 0.0, do: 1.0, else: -1.0))}
    catch
      {:return, val} -> val
    end
  end
  def gradient(target, preds) do
    try do
      n = _len(target)
      residuals = []
      i = 0
      while_fun_2 = fn while_fun_2, i, residuals ->
        if i < n do
          t = Enum.at(target, i)
          y = Enum.at(preds, i)
          exp_val = exp_approx(t * y)
          res = -t / (1.0 + exp_val)
          residuals = (residuals ++ [res])
          i = i + 1
          while_fun_2.(while_fun_2, i, residuals)
        else
          {i, residuals}
        end
      end
      {i, residuals} = try do
          while_fun_2.(while_fun_2, i, residuals)
        catch
          {:break, {i, residuals}} -> {i, residuals}
        end

      throw {:return, residuals}
    catch
      {:return, val} -> val
    end
  end
  def predict_raw(models, features, learning_rate) do
    try do
      n = _len(features)
      preds = []
      i = 0
      while_fun_3 = fn while_fun_3, i, preds ->
        if i < n do
          preds = (preds ++ [0.0])
          i = i + 1
          while_fun_3.(while_fun_3, i, preds)
        else
          {i, preds}
        end
      end
      {i, preds} = try do
          while_fun_3.(while_fun_3, i, preds)
        catch
          {:break, {i, preds}} -> {i, preds}
        end

      m = 0
      while_fun_4 = fn while_fun_4, i, m, preds ->
        if m < _len(models) do
          stump = Enum.at(models, m)
          i = 0
          while_fun_5 = fn while_fun_5, i, preds ->
            if i < n do
              value = Enum.at(Enum.at(features, i), stump.feature)
              preds = List.replace_at(preds, i, ((if value <= stump.threshold, do: Enum.at(preds, i) + learning_rate * stump.left, else: Enum.at(preds, i) + learning_rate * stump.right)))
              i = i + 1
              while_fun_5.(while_fun_5, i, preds)
            else
              {i, preds}
            end
          end
          {i, preds} = try do
              while_fun_5.(while_fun_5, i, preds)
            catch
              {:break, {i, preds}} -> {i, preds}
            end

          m = m + 1
          while_fun_4.(while_fun_4, i, m, preds)
        else
          {i, m, preds}
        end
      end
      {i, m, preds} = try do
          while_fun_4.(while_fun_4, i, m, preds)
        catch
          {:break, {i, m, preds}} -> {i, m, preds}
        end

      throw {:return, preds}
    catch
      {:return, val} -> val
    end
  end
  def predict(models, features, learning_rate) do
    try do
      raw = predict_raw(models, features, learning_rate)
      result = []
      i = 0
      while_fun_6 = fn while_fun_6, i, result ->
        if i < _len(raw) do
          result = (result ++ [signf(Enum.at(raw, i))])
          i = i + 1
          while_fun_6.(while_fun_6, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_6.(while_fun_6, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def train_stump(features, residuals) do
    try do
      n_samples = _len(features)
      n_features = _len(Enum.at(features, 0))
      best_feature = 0
      best_threshold = 0.0
      best_error = 1000000000.0
      best_left = 0.0
      best_right = 0.0
      j = 0
      while_fun_7 = fn while_fun_7, best_error, best_feature, best_left, best_right, best_threshold, j ->
        if j < n_features do
          t_index = 0
          while_fun_8 = fn while_fun_8, best_error, best_feature, best_left, best_right, best_threshold, t_index ->
            if t_index < n_samples do
              t = Enum.at(Enum.at(features, t_index), j)
              sum_left = 0.0
              count_left = 0
              sum_right = 0.0
              count_right = 0
              i = 0
              while_fun_9 = fn while_fun_9, count_left, count_right, i, sum_left, sum_right ->
                if i < n_samples do
                  {count_left, count_right, sum_left, sum_right} = if Enum.at(Enum.at(features, i), j) <= t do
                    sum_left = sum_left + Enum.at(residuals, i)
                    count_left = count_left + 1
                    {count_left, count_right, sum_left, sum_right}
                  else
                    sum_right = sum_right + Enum.at(residuals, i)
                    count_right = count_right + 1
                    {count_left, count_right, sum_left, sum_right}
                  end
                  i = i + 1
                  while_fun_9.(while_fun_9, count_left, count_right, i, sum_left, sum_right)
                else
                  {count_left, count_right, i, sum_left, sum_right}
                end
              end
              {count_left, count_right, i, sum_left, sum_right} = try do
                  while_fun_9.(while_fun_9, count_left, count_right, i, sum_left, sum_right)
                catch
                  {:break, {count_left, count_right, i, sum_left, sum_right}} -> {count_left, count_right, i, sum_left, sum_right}
                end

              left_val = 0.0
              {left_val} = if count_left != 0 do
                left_val = sum_left / (:erlang.float(count_left))
                {left_val}
              else
                {left_val}
              end
              right_val = 0.0
              {right_val} = if count_right != 0 do
                right_val = sum_right / (:erlang.float(count_right))
                {right_val}
              else
                {right_val}
              end
              error = 0.0
              i = 0
              while_fun_10 = fn while_fun_10, error, i ->
                if i < n_samples do
                  pred = (if Enum.at(Enum.at(features, i), j) <= t, do: left_val, else: right_val)
                  diff = Enum.at(residuals, i) - pred
                  error = error + diff * diff
                  i = i + 1
                  while_fun_10.(while_fun_10, error, i)
                else
                  {error, i}
                end
              end
              {error, i} = try do
                  while_fun_10.(while_fun_10, error, i)
                catch
                  {:break, {error, i}} -> {error, i}
                end

              {best_error, best_feature, best_left, best_right, best_threshold} = if error < best_error do
                best_error = error
                best_feature = j
                best_threshold = t
                best_left = left_val
                best_right = right_val
                {best_error, best_feature, best_left, best_right, best_threshold}
              else
                {best_error, best_feature, best_left, best_right, best_threshold}
              end
              t_index = t_index + 1
              while_fun_8.(while_fun_8, best_error, best_feature, best_left, best_right, best_threshold, t_index)
            else
              {best_error, best_feature, best_left, best_right, best_threshold, t_index}
            end
          end
          {best_error, best_feature, best_left, best_right, best_threshold, t_index} = try do
              while_fun_8.(while_fun_8, best_error, best_feature, best_left, best_right, best_threshold, t_index)
            catch
              {:break, {best_error, best_feature, best_left, best_right, best_threshold, t_index}} -> {best_error, best_feature, best_left, best_right, best_threshold, t_index}
            end

          j = j + 1
          while_fun_7.(while_fun_7, best_error, best_feature, best_left, best_right, best_threshold, j)
        else
          {best_error, best_feature, best_left, best_right, best_threshold, j}
        end
      end
      {best_error, best_feature, best_left, best_right, best_threshold, j} = try do
          while_fun_7.(while_fun_7, best_error, best_feature, best_left, best_right, best_threshold, j)
        catch
          {:break, {best_error, best_feature, best_left, best_right, best_threshold, j}} -> {best_error, best_feature, best_left, best_right, best_threshold, j}
        end

      throw {:return, %{feature: best_feature, threshold: best_threshold, left: best_left, right: best_right}}
    catch
      {:return, val} -> val
    end
  end
  def fit(n_estimators, learning_rate, features, target) do
    try do
      models = []
      m = 0
      while_fun_11 = fn while_fun_11, m ->
        if m < n_estimators do
          preds = predict_raw(models, features, learning_rate)
          grad = gradient(target, preds)
          residuals = []
          i = 0
          while_fun_12 = fn while_fun_12, i, residuals ->
            if i < _len(grad) do
              residuals = (residuals ++ [-Enum.at(grad, i)])
              i = i + 1
              while_fun_12.(while_fun_12, i, residuals)
            else
              {i, residuals}
            end
          end
          {i, residuals} = try do
              while_fun_12.(while_fun_12, i, residuals)
            catch
              {:break, {i, residuals}} -> {i, residuals}
            end

          stump = train_stump(features, residuals)
          models = (models ++ [stump])
          m = m + 1
          while_fun_11.(while_fun_11, m)
        else
          m
        end
      end
      m = try do
          while_fun_11.(while_fun_11, m)
        catch
          {:break, {m}} -> m
        end

      throw {:return, models}
    catch
      {:return, val} -> val
    end
  end
  def accuracy(preds, target) do
    try do
      n = _len(target)
      correct = 0
      i = 0
      while_fun_13 = fn while_fun_13, correct, i ->
        if i < n do
          {correct} = if Enum.at(preds, i) == Enum.at(target, i) do
            correct = correct + 1
            {correct}
          else
            {correct}
          end
          i = i + 1
          while_fun_13.(while_fun_13, correct, i)
        else
          {correct, i}
        end
      end
      {correct, i} = try do
          while_fun_13.(while_fun_13, correct, i)
        catch
          {:break, {correct, i}} -> {correct, i}
        end

      throw {:return, (:erlang.float(correct)) / (:erlang.float(n))}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:features, [[1.0], [2.0], [3.0], [4.0]])
  def main() do
    Process.put(:target, [-1.0, -1.0, 1.0, 1.0])
    Process.put(:models, fit(5, 0.5, Process.get(:features), Process.get(:target)))
    Process.put(:predictions, predict(Process.get(:models), Process.get(:features), 0.5))
    Process.put(:acc, accuracy(Process.get(:predictions), Process.get(:target)))
    IO.puts(("Accuracy: " <> Kernel.to_string(Process.get(:acc))))
  end
end
Main.main()
