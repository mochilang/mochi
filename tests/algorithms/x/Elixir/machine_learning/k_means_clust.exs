# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def distance_sq(a, b) do
    try do
      sum = 0.0
      {sum} = Enum.reduce((0..(_len(a) - 1)//1), {sum}, fn i, {sum} ->
        diff = Enum.at(a, i) - Enum.at(b, i)
        sum = sum + diff * diff
        {sum}
      end)
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def assign_clusters(data, centroids) do
    try do
      assignments = []
      {assignments} = Enum.reduce((0..(_len(data) - 1)//1), {assignments}, fn i, {assignments} ->
        best_idx = 0
        best = distance_sq(Enum.at(data, i), Enum.at(centroids, 0))
        {best, best_idx} = Enum.reduce((1..(_len(centroids) - 1)//1), {best, best_idx}, fn j, {best, best_idx} ->
          dist = distance_sq(Enum.at(data, i), Enum.at(centroids, j))
          {best, best_idx} = if dist < best do
            best = dist
            best_idx = j
            {best, best_idx}
          else
            {best, best_idx}
          end
          {best, best_idx}
        end)
        assignments = (assignments ++ [best_idx])
        {assignments}
      end)
      throw {:return, assignments}
    catch
      {:return, val} -> val
    end
  end
  def revise_centroids(data, k, assignment) do
    try do
      dim = _len(Enum.at(data, 0))
      sums = []
      counts = []
      {counts, sums} = Enum.reduce((0..(k - 1)//1), {counts, sums}, fn i, {counts, sums} ->
        row = []
        {row} = Enum.reduce((0..(dim - 1)//1), {row}, fn j, {row} ->
          row = (row ++ [0.0])
          {row}
        end)
        sums = (sums ++ [row])
        counts = (counts ++ [0])
        {counts, sums}
      end)
      {counts, sums} = Enum.reduce((0..(_len(data) - 1)//1), {counts, sums}, fn i, {counts, sums} ->
        c = Enum.at(assignment, i)
        counts = List.replace_at(counts, c, Enum.at(counts, c) + 1)
        {sums} = Enum.reduce((0..(dim - 1)//1), {sums}, fn j, {sums} ->
          sums = List.replace_at(sums, c, List.replace_at(Enum.at(sums, c), j, Enum.at(Enum.at(sums, c), j) + Enum.at(Enum.at(data, i), j)))
          {sums}
        end)
        {counts, sums}
      end)
      centroids = []
      {centroids} = Enum.reduce((0..(k - 1)//1), {centroids}, fn i, {centroids} ->
        row = []
        {row} = if Enum.at(counts, i) > 0 do
          {row} = Enum.reduce((0..(dim - 1)//1), {row}, fn j, {row} ->
            row = (row ++ [Enum.at(Enum.at(sums, i), j) / (:erlang.float(Enum.at(counts, i)))])
            {row}
          end)
          {row}
        else
          {row} = Enum.reduce((0..(dim - 1)//1), {row}, fn j, {row} ->
            row = (row ++ [0.0])
            {row}
          end)
          {row}
        end
        centroids = (centroids ++ [row])
        {centroids}
      end)
      throw {:return, centroids}
    catch
      {:return, val} -> val
    end
  end
  def compute_heterogeneity(data, centroids, assignment) do
    try do
      total = 0.0
      {total} = Enum.reduce((0..(_len(data) - 1)//1), {total}, fn i, {total} ->
        c = Enum.at(assignment, i)
        total = total + distance_sq(Enum.at(data, i), Enum.at(centroids, c))
        {total}
      end)
      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def lists_equal(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      Enum.each((0..(_len(a) - 1)), fn i ->
        if Enum.at(a, i) != Enum.at(b, i) do
          throw {:return, false}
        end
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def kmeans(data, k, initial_centroids, max_iter) do
    try do
      centroids = initial_centroids
      assignment = []
      prev = []
      heterogeneity = []
      iter = 0
      while_fun = fn while_fun, assignment, centroids, heterogeneity, iter, prev ->
        if iter < max_iter do
          assignment = assign_clusters(data, centroids)
          centroids = revise_centroids(data, k, assignment)
          h = compute_heterogeneity(data, centroids, assignment)
          heterogeneity = (heterogeneity ++ [h])
          if iter > 0 && lists_equal(prev, assignment) do
            throw {:break, {assignment, centroids, heterogeneity, iter, prev}}
          end
          prev = assignment
          iter = iter + 1
          while_fun.(while_fun, assignment, centroids, heterogeneity, iter, prev)
        else
          {assignment, centroids, heterogeneity, iter, prev}
        end
      end
      {assignment, centroids, heterogeneity, iter, prev} = try do
          while_fun.(while_fun, assignment, centroids, heterogeneity, iter, prev)
        catch
          {:break, {assignment, centroids, heterogeneity, iter, prev}} -> {assignment, centroids, heterogeneity, iter, prev}
        end

      throw {:return, %{centroids: centroids, assignments: assignment, heterogeneity: heterogeneity}}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:data, [[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]])
  Process.put(:k, 3)
  def main() do
    Process.put(:initial_centroids, [Enum.at(Process.get(:data), 0), Enum.at(Process.get(:data), 2), Enum.at(Process.get(:data), 5)])
    Process.put(:result, kmeans(Process.get(:data), Process.get(:k), Process.get(:initial_centroids), 10))
    IO.puts(Kernel.inspect(Process.get(:result).centroids))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:result).assignments])), ",", " "))
    IO.puts(Kernel.inspect(Process.get(:result).heterogeneity))
  end
end
Main.main()
