# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def mean(xs) do
    try do
      sum = 0.0
      i = 0
      while_fun = fn while_fun, i, sum ->
        if i < _len(xs) do
          sum = sum + Enum.at(xs, i)
          i = i + 1
          while_fun.(while_fun, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun.(while_fun, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum / (_len(xs) * 1.0)}
    catch
      {:return, val} -> val
    end
  end
  def stump_predict(s, x) do
    try do
      throw {:return, ((if Enum.at(x, s.feature) < s.threshold, do: s.left, else: s.right))}
    catch
      {:return, val} -> val
    end
  end
  def train_stump(features, residuals) do
    try do
      best_feature = 0
      best_threshold = 0.0
      best_error = 1000000000.0
      best_left = 0.0
      best_right = 0.0
      num_features = _len(Enum.at(features, 0))
      f = 0
      while_fun_2 = fn while_fun_2, best_error, best_feature, best_left, best_right, best_threshold, f ->
        if f < num_features do
          i = 0
          while_fun_3 = fn while_fun_3, best_error, best_feature, best_left, best_right, best_threshold, i ->
            if i < _len(features) do
              threshold = Enum.at(Enum.at(features, i), f)
              left = []
              right = []
              j = 0
              while_fun_4 = fn while_fun_4, j, left, right ->
                if j < _len(features) do
                  {left, right} = if Enum.at(Enum.at(features, j), f) < threshold do
                    left = (left ++ [Enum.at(residuals, j)])
                    {left, right}
                  else
                    right = (right ++ [Enum.at(residuals, j)])
                    {left, right}
                  end
                  j = j + 1
                  while_fun_4.(while_fun_4, j, left, right)
                else
                  {j, left, right}
                end
              end
              {j, left, right} = try do
                  while_fun_4.(while_fun_4, j, left, right)
                catch
                  {:break, {j, left, right}} -> {j, left, right}
                end

              {best_error, best_feature, best_left, best_right, best_threshold, j} = if _len(left) != 0 && _len(right) != 0 do
                left_mean = mean(left)
                right_mean = mean(right)
                err = 0.0
                j = 0
                while_fun_5 = fn while_fun_5, err, j ->
                  if j < _len(features) do
                    pred = (if Enum.at(Enum.at(features, j), f) < threshold, do: left_mean, else: right_mean)
                    diff = Enum.at(residuals, j) - pred
                    err = err + diff * diff
                    j = j + 1
                    while_fun_5.(while_fun_5, err, j)
                  else
                    {err, j}
                  end
                end
                {err, j} = try do
                    while_fun_5.(while_fun_5, err, j)
                  catch
                    {:break, {err, j}} -> {err, j}
                  end

                {best_error, best_feature, best_left, best_right, best_threshold} = if err < best_error do
                  best_error = err
                  best_feature = f
                  best_threshold = threshold
                  best_left = left_mean
                  best_right = right_mean
                  {best_error, best_feature, best_left, best_right, best_threshold}
                else
                  {best_error, best_feature, best_left, best_right, best_threshold}
                end
                {best_error, best_feature, best_left, best_right, best_threshold, j}
              else
                {best_error, best_feature, best_left, best_right, best_threshold, j}
              end
              i = i + 1
              while_fun_3.(while_fun_3, best_error, best_feature, best_left, best_right, best_threshold, i)
            else
              {best_error, best_feature, best_left, best_right, best_threshold, i}
            end
          end
          {best_error, best_feature, best_left, best_right, best_threshold, i} = try do
              while_fun_3.(while_fun_3, best_error, best_feature, best_left, best_right, best_threshold, i)
            catch
              {:break, {best_error, best_feature, best_left, best_right, best_threshold, i}} -> {best_error, best_feature, best_left, best_right, best_threshold, i}
            end

          f = f + 1
          while_fun_2.(while_fun_2, best_error, best_feature, best_left, best_right, best_threshold, f)
        else
          {best_error, best_feature, best_left, best_right, best_threshold, f}
        end
      end
      {best_error, best_feature, best_left, best_right, best_threshold, f} = try do
          while_fun_2.(while_fun_2, best_error, best_feature, best_left, best_right, best_threshold, f)
        catch
          {:break, {best_error, best_feature, best_left, best_right, best_threshold, f}} -> {best_error, best_feature, best_left, best_right, best_threshold, f}
        end

      throw {:return, %{feature: best_feature, threshold: best_threshold, left: best_left, right: best_right}}
    catch
      {:return, val} -> val
    end
  end
  def boost(features, targets, rounds) do
    try do
      model = []
      preds = []
      i = 0
      while_fun_6 = fn while_fun_6, i, preds ->
        if i < _len(targets) do
          preds = (preds ++ [0.0])
          i = i + 1
          while_fun_6.(while_fun_6, i, preds)
        else
          {i, preds}
        end
      end
      {i, preds} = try do
          while_fun_6.(while_fun_6, i, preds)
        catch
          {:break, {i, preds}} -> {i, preds}
        end

      r = 0
      while_fun_7 = fn while_fun_7, model, preds, r ->
        if r < rounds do
          residuals = []
          j = 0
          while_fun_8 = fn while_fun_8, j, residuals ->
            if j < _len(targets) do
              residuals = (residuals ++ [Enum.at(targets, j) - Enum.at(preds, j)])
              j = j + 1
              while_fun_8.(while_fun_8, j, residuals)
            else
              {j, residuals}
            end
          end
          {j, residuals} = try do
              while_fun_8.(while_fun_8, j, residuals)
            catch
              {:break, {j, residuals}} -> {j, residuals}
            end

          stump = train_stump(features, residuals)
          model = (model ++ [stump])
          j = 0
          while_fun_9 = fn while_fun_9, j, preds ->
            if j < _len(preds) do
              preds = List.replace_at(preds, j, Enum.at(preds, j) + stump_predict(stump, Enum.at(features, j)))
              j = j + 1
              while_fun_9.(while_fun_9, j, preds)
            else
              {j, preds}
            end
          end
          {j, preds} = try do
              while_fun_9.(while_fun_9, j, preds)
            catch
              {:break, {j, preds}} -> {j, preds}
            end

          r = r + 1
          while_fun_7.(while_fun_7, model, preds, r)
        else
          {model, preds, r}
        end
      end
      {model, preds, r} = try do
          while_fun_7.(while_fun_7, model, preds, r)
        catch
          {:break, {model, preds, r}} -> {model, preds, r}
        end

      throw {:return, model}
    catch
      {:return, val} -> val
    end
  end
  def predict(model, x) do
    try do
      score = 0.0
      i = 0
      while_fun_10 = fn while_fun_10, i, score ->
        if i < _len(model) do
          s = Enum.at(model, i)
          score = (if Enum.at(x, s.feature) < s.threshold, do: score + s.left, else: score + s.right)
          i = i + 1
          while_fun_10.(while_fun_10, i, score)
        else
          {i, score}
        end
      end
      {i, score} = try do
          while_fun_10.(while_fun_10, i, score)
        catch
          {:break, {i, score}} -> {i, score}
        end

      throw {:return, score}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      features = [[5.1, 3.5], [4.9, 3.0], [6.2, 3.4], [5.9, 3.0]]
      targets = [0, 0, 1, 1]
      model = boost(features, targets, 3)
      out = ""
      i = 0
      while_fun_11 = fn while_fun_11, i, out ->
        if i < _len(features) do
          s = predict(model, Enum.at(features, i))
          label = (if s >= 0.5, do: 1, else: 0)
          out = (if i == 0, do: Kernel.to_string(label), else: ((out <> " ") <> Kernel.to_string(label)))
          i = i + 1
          while_fun_11.(while_fun_11, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_11.(while_fun_11, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      IO.puts(out)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
