# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def exp_approx(x) do
    try do
      sum = 1.0
      term = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 20 do
          term = term * x / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(x) do
    try do
      throw {:return, 1.0 / (1.0 + exp_approx(-x))}
    catch
      {:return, val} -> val
    end
  end
  def tanh_approx(x) do
    try do
      e = exp_approx(2.0 * x)
      throw {:return, (e - 1.0) / (e + 1.0)}
    catch
      {:return, val} -> val
    end
  end
  def forward(seq, w) do
    try do
      i_arr = []
      f_arr = []
      o_arr = []
      g_arr = []
      c_arr = [0.0]
      h_arr = [0.0]
      t = 0
      while_fun_2 = fn while_fun_2, c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t ->
        if t < _len(seq) do
          x = Enum.at(seq, t)
          h_prev = Enum.at(h_arr, t)
          c_prev = Enum.at(c_arr, t)
          i_t = sigmoid(w.w_i * x + w.u_i * h_prev + w.b_i)
          f_t = sigmoid(w.w_f * x + w.u_f * h_prev + w.b_f)
          o_t = sigmoid(w.w_o * x + w.u_o * h_prev + w.b_o)
          g_t = tanh_approx(w.w_c * x + w.u_c * h_prev + w.b_c)
          c_t = f_t * c_prev + i_t * g_t
          h_t = o_t * tanh_approx(c_t)
          i_arr = (i_arr ++ [i_t])
          f_arr = (f_arr ++ [f_t])
          o_arr = (o_arr ++ [o_t])
          g_arr = (g_arr ++ [g_t])
          c_arr = (c_arr ++ [c_t])
          h_arr = (h_arr ++ [h_t])
          t = t + 1
          while_fun_2.(while_fun_2, c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t)
        else
          {c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t}
        end
      end
      {c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t} = try do
          while_fun_2.(while_fun_2, c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t)
        catch
          {:break, {c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t}} -> {c_arr, f_arr, g_arr, h_arr, i_arr, o_arr, t}
        end

      throw {:return, %{i: i_arr, f: f_arr, o: o_arr, g: g_arr, c: c_arr, h: h_arr}}
    catch
      {:return, val} -> val
    end
  end
  def backward(seq, target, w, s, lr) do
    try do
      dw_i = 0.0
      du_i = 0.0
      db_i = 0.0
      dw_f = 0.0
      du_f = 0.0
      db_f = 0.0
      dw_o = 0.0
      du_o = 0.0
      db_o = 0.0
      dw_c = 0.0
      du_c = 0.0
      db_c = 0.0
      dw_y = 0.0
      db_y = 0.0
      t = _len(seq)
      h_last = Enum.at(s.h, t)
      y = w.w_y * h_last + w.b_y
      dy = y - target
      dw_y = dy * h_last
      db_y = dy
      dh_next = dy * w.w_y
      dc_next = 0.0
      t = t - 1
      while_fun_3 = fn while_fun_3, db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t ->
        if t >= 0 do
          i_t = Enum.at(s.i, t)
          f_t = Enum.at(s.f, t)
          o_t = Enum.at(s.o, t)
          g_t = Enum.at(s.g, t)
          c_t = Enum.at(s.c, t + 1)
          c_prev = Enum.at(s.c, t)
          h_prev = Enum.at(s.h, t)
          tanh_c = tanh_approx(c_t)
          do_t = dh_next * tanh_c
          da_o = do_t * o_t * (1.0 - o_t)
          dc = dh_next * o_t * (1.0 - tanh_c * tanh_c) + dc_next
          di_t = dc * g_t
          da_i = di_t * i_t * (1.0 - i_t)
          dg_t = dc * i_t
          da_g = dg_t * (1.0 - g_t * g_t)
          df_t = dc * c_prev
          da_f = df_t * f_t * (1.0 - f_t)
          dw_i = dw_i + da_i * Enum.at(seq, t)
          du_i = du_i + da_i * h_prev
          db_i = db_i + da_i
          dw_f = dw_f + da_f * Enum.at(seq, t)
          du_f = du_f + da_f * h_prev
          db_f = db_f + da_f
          dw_o = dw_o + da_o * Enum.at(seq, t)
          du_o = du_o + da_o * h_prev
          db_o = db_o + da_o
          dw_c = dw_c + da_g * Enum.at(seq, t)
          du_c = du_c + da_g * h_prev
          db_c = db_c + da_g
          dh_next = da_i * w.u_i + da_f * w.u_f + da_o * w.u_o + da_g * w.u_c
          dc_next = dc * f_t
          t = t - 1
          while_fun_3.(while_fun_3, db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t)
        else
          {db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t}
        end
      end
      {db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t} = try do
          while_fun_3.(while_fun_3, db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t)
        catch
          {:break, {db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t}} -> {db_c, db_f, db_i, db_o, dc_next, dh_next, du_c, du_f, du_i, du_o, dw_c, dw_f, dw_i, dw_o, t}
        end

      w = Map.put(w, :w_y, w.w_y - lr * dw_y)
      w = Map.put(w, :b_y, w.b_y - lr * db_y)
      w = Map.put(w, :w_i, w.w_i - lr * dw_i)
      w = Map.put(w, :u_i, w.u_i - lr * du_i)
      w = Map.put(w, :b_i, w.b_i - lr * db_i)
      w = Map.put(w, :w_f, w.w_f - lr * dw_f)
      w = Map.put(w, :u_f, w.u_f - lr * du_f)
      w = Map.put(w, :b_f, w.b_f - lr * db_f)
      w = Map.put(w, :w_o, w.w_o - lr * dw_o)
      w = Map.put(w, :u_o, w.u_o - lr * du_o)
      w = Map.put(w, :b_o, w.b_o - lr * db_o)
      w = Map.put(w, :w_c, w.w_c - lr * dw_c)
      w = Map.put(w, :u_c, w.u_c - lr * du_c)
      w = Map.put(w, :b_c, w.b_c - lr * db_c)
      throw {:return, w}
    catch
      {:return, val} -> val
    end
  end
  def make_samples(data, look_back) do
    try do
      x = []
      y = []
      i = 0
      while_fun_4 = fn while_fun_4, x, y, i ->
        if i + look_back < _len(data) do
          seq = _slice(data, i, i + look_back - (i))
          x = (x ++ [seq])
          y = (y ++ [Enum.at(data, i + look_back)])
          i = i + 1
          while_fun_4.(while_fun_4, x, y, i)
        else
          {x, y, i}
        end
      end
      {x, y, i} = try do
          while_fun_4.(while_fun_4, x, y, i)
        catch
          {:break, {x, y, i}} -> {x, y, i}
        end

      throw {:return, %{x: x, y: y}}
    catch
      {:return, val} -> val
    end
  end
  def init_weights() do
    try do
      throw {:return, %{w_i: 0.1, u_i: 0.2, b_i: 0.0, w_f: 0.1, u_f: 0.2, b_f: 0.0, w_o: 0.1, u_o: 0.2, b_o: 0.0, w_c: 0.1, u_c: 0.2, b_c: 0.0, w_y: 0.1, b_y: 0.0}}
    catch
      {:return, val} -> val
    end
  end
  def train(data, look_back, epochs, lr) do
    try do
      samples = make_samples(data, look_back)
      w = init_weights()
      ep = 0
      while_fun_5 = fn while_fun_5, ep ->
        if ep < epochs do
          j = 0
          while_fun_6 = fn while_fun_6, j ->
            if j < _len(Map.get(samples, :x, [])) do
              seq = Enum.at(samples.x, j)
              target = Enum.at(samples.y, j)
              state = forward(seq, w)
              w = backward(seq, target, w, state, lr)
              j = j + 1
              while_fun_6.(while_fun_6, j)
            else
              j
            end
          end
          j = try do
              while_fun_6.(while_fun_6, j)
            catch
              {:break, {j}} -> j
            end

          ep = ep + 1
          while_fun_5.(while_fun_5, ep)
        else
          ep
        end
      end
      ep = try do
          while_fun_5.(while_fun_5, ep)
        catch
          {:break, {ep}} -> ep
        end

      throw {:return, w}
    catch
      {:return, val} -> val
    end
  end
  def predict(seq, w) do
    try do
      state = forward(seq, w)
      h_last = Enum.at(state.h, _len(Map.get(state, :h, [])) - 1)
      throw {:return, w.w_y * h_last + w.b_y}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:data, [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8])
  Process.put(:look_back, 3)
  Process.put(:epochs, 200)
  Process.put(:lr, 0.1)
  Process.put(:test_seq, [0.6, 0.7, 0.8])
  def main() do
    Process.put(:w, train(Process.get(:data), Process.get(:look_back), Process.get(:epochs), Process.get(:lr)))
    Process.put(:pred, predict(Process.get(:test_seq), Process.get(:w)))
    IO.puts(("Predicted value: " <> Kernel.to_string(Process.get(:pred))))
  end
end
Main.main()
