# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def load_data() do
    try do
      throw {:return, [["milk"], ["milk", "butter"], ["milk", "bread"], ["milk", "bread", "chips"]]}
    catch
      {:return, val} -> val
    end
  end
  def contains_string(xs, s) do
    try do
      Enum.each(xs, fn v ->
        if v == s do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_subset(candidate, transaction) do
    try do
      Enum.each(candidate, fn it ->
        if !contains_string(transaction, it) do
          throw {:return, false}
        end
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def lists_equal(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(a) do
          if Enum.at(a, i, []) != Enum.at(b, i, []) do
            throw {:return, false}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def contains_list(itemset, item) do
    try do
      Enum.each(itemset, fn l ->
        if lists_equal(l, item) do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def count_list(itemset, item) do
    try do
      c = 0
      {c} = Enum.reduce(itemset, {c}, fn l, {c} ->
        {c} = if lists_equal(l, item) do
          c = c + 1
          {c}
        else
          {c}
        end
        {c}
      end)
      throw {:return, c}
    catch
      {:return, val} -> val
    end
  end
  def slice_list(xs, start) do
    try do
      res = []
      i = start
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(xs) do
          res = (res ++ [Enum.at(xs, i, [])])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def combinations_lists(xs, k) do
    try do
      result = []
      {result} = if k == 0 do
        result = (result ++ [[]])
        throw {:return, result}
        {result}
      else
        {result}
      end
      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(xs) do
          head = Enum.at(xs, i, [])
          tail = slice_list(xs, i + 1)
          tail_combos = combinations_lists(tail, k - 1)
          {result} = Enum.reduce(tail_combos, {result}, fn combo, {result} ->
            new_combo = []
            new_combo = (new_combo ++ [head])
            {new_combo} = Enum.reduce(combo, {new_combo}, fn c, {new_combo} ->
              new_combo = (new_combo ++ [c])
              {new_combo}
            end)
            result = (result ++ [new_combo])
            {result}
          end)
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def prune(itemset, candidates, length) do
    try do
      pruned = []
      {pruned} = Enum.reduce(candidates, {pruned}, fn candidate, {pruned} ->
        try do
          is_subsequence = true
          {is_subsequence} = Enum.reduce(candidate, {is_subsequence}, fn item, {is_subsequence} ->
            try do
              {is_subsequence} = if !contains_list(itemset, item) || count_list(itemset, item) < length - 1 do
                is_subsequence = false
                throw :break
                {is_subsequence}
              else
                {is_subsequence}
              end
            catch
              :continue -> {is_subsequence}
            end
            {is_subsequence}
          end)
          {pruned} = if is_subsequence do
            pruned = (pruned ++ [candidate])
            {pruned}
          else
            {pruned}
          end
        catch
          :continue -> {pruned}
        end
        {pruned}
      end)
      throw {:return, pruned}
    catch
      {:return, val} -> val
    end
  end
  def sort_strings(xs) do
    try do
      res = []
      {res} = Enum.reduce(xs, {res}, fn s, {res} ->
        res = (res ++ [s])
        {res}
      end)
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(res) do
          j = i + 1
          while_fun_5 = fn while_fun_5, j, res ->
            if j < _len(res) do
              {res} = if Enum.at(res, j, []) < Enum.at(res, i, []) do
                tmp = Enum.at(res, i, [])
                res = List.replace_at(res, i, Enum.at(res, j, []))
                res = List.replace_at(res, j, tmp)
                {res}
              else
                {res}
              end
              j = j + 1
              while_fun_5.(while_fun_5, j, res)
            else
              {j, res}
            end
          end
          {j, res} = try do
              while_fun_5.(while_fun_5, j, res)
            catch
              {:break, {j, res}} -> {j, res}
            end

          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def itemset_to_string(xs) do
    try do
      s = "["
      i = 0
      while_fun_6 = fn while_fun_6, i, s ->
        if i < _len(xs) do
          {s} = if i > 0 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          s = (((s <> "'") <> Enum.at(xs, i, [])) <> "'")
          i = i + 1
          while_fun_6.(while_fun_6, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_6.(while_fun_6, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def apriori(data, min_support) do
    try do
      itemset = []
      {itemset} = Enum.reduce(data, {itemset}, fn transaction, {itemset} ->
        t = []
        {t} = Enum.reduce(transaction, {t}, fn v, {t} ->
          t = (t ++ [v])
          {t}
        end)
        itemset = (itemset ++ [t])
        {itemset}
      end)
      frequent = []
      length = 1
      while_fun_7 = fn while_fun_7, frequent, itemset, length ->
        if _len(itemset) > 0 do
          counts = []
          idx = 0
          while_fun_8 = fn while_fun_8, counts, idx ->
            if idx < _len(itemset) do
              counts = (counts ++ [0])
              idx = idx + 1
              while_fun_8.(while_fun_8, counts, idx)
            else
              {counts, idx}
            end
          end
          {counts, idx} = try do
              while_fun_8.(while_fun_8, counts, idx)
            catch
              {:break, {counts, idx}} -> {counts, idx}
            end

          {counts} = Enum.reduce(data, {counts}, fn transaction, {counts} ->
            j = 0
            while_fun_9 = fn while_fun_9, counts, j ->
              if j < _len(itemset) do
                candidate = Enum.at(itemset, j, [])
                {counts} = if is_subset(candidate, transaction) do
                  counts = List.replace_at(counts, j, Enum.at(counts, j, []) + 1)
                  {counts}
                else
                  {counts}
                end
                j = j + 1
                while_fun_9.(while_fun_9, counts, j)
              else
                {counts, j}
              end
            end
            {counts, j} = try do
                while_fun_9.(while_fun_9, counts, j)
              catch
                {:break, {counts, j}} -> {counts, j}
              end

            {counts}
          end)
          new_itemset = []
          k = 0
          while_fun_10 = fn while_fun_10, k, new_itemset ->
            if k < _len(itemset) do
              {new_itemset} = if Enum.at(counts, k, []) >= min_support do
                new_itemset = (new_itemset ++ [Enum.at(itemset, k, [])])
                {new_itemset}
              else
                {new_itemset}
              end
              k = k + 1
              while_fun_10.(while_fun_10, k, new_itemset)
            else
              {k, new_itemset}
            end
          end
          {k, new_itemset} = try do
              while_fun_10.(while_fun_10, k, new_itemset)
            catch
              {:break, {k, new_itemset}} -> {k, new_itemset}
            end

          itemset = new_itemset
          m = 0
          while_fun_11 = fn while_fun_11, frequent, m ->
            if m < _len(itemset) do
              sorted_item = sort_strings(Enum.at(itemset, m, []))
              frequent = (frequent ++ [%{items: sorted_item, support: Enum.at(counts, m, [])}])
              m = m + 1
              while_fun_11.(while_fun_11, frequent, m)
            else
              {frequent, m}
            end
          end
          {frequent, m} = try do
              while_fun_11.(while_fun_11, frequent, m)
            catch
              {:break, {frequent, m}} -> {frequent, m}
            end

          length = length + 1
          combos = combinations_lists(itemset, length)
          itemset = prune(itemset, combos, length)
          while_fun_7.(while_fun_7, frequent, itemset, length)
        else
          {frequent, itemset, length}
        end
      end
      {frequent, itemset, length} = try do
          while_fun_7.(while_fun_7, frequent, itemset, length)
        catch
          {:break, {frequent, itemset, length}} -> {frequent, itemset, length}
        end

      throw {:return, frequent}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:frequent_itemsets, apriori(load_data(), 2))
    Enum.each(Process.get(:frequent_itemsets), fn fi ->
      IO.puts(Kernel.inspect(((itemset_to_string(fi.items) <> ": ") <> Kernel.to_string(fi.support))))
    end)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
