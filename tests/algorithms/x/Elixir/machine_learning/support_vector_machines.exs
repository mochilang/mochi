# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def dot(a, b) do
    try do
      s = 0.0
      i = 0
      while_fun = fn while_fun, i, s ->
        if i < _len(a) do
          s = s + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun.(while_fun, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun.(while_fun, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def new_svc(lr, lambda, epochs) do
    try do
      throw {:return, %{weights: [], bias: 0.0, lr: lr, lambda: lambda, epochs: epochs}}
    catch
      {:return, val} -> val
    end
  end
  def fit(model, xs, ys) do
    try do
      n_features = _len(Enum.at(xs, 0))
      w = []
      i = 0
      while_fun_2 = fn while_fun_2, i, w ->
        if i < n_features do
          w = (w ++ [0.0])
          i = i + 1
          while_fun_2.(while_fun_2, i, w)
        else
          {i, w}
        end
      end
      {i, w} = try do
          while_fun_2.(while_fun_2, i, w)
        catch
          {:break, {i, w}} -> {i, w}
        end

      b = 0.0
      epoch = 0
      while_fun_3 = fn while_fun_3, b, epoch, w ->
        if epoch < model.epochs do
          j = 0
          while_fun_4 = fn while_fun_4, b, j, w ->
            if j < _len(xs) do
              x = Enum.at(xs, j)
              y = :erlang.float(Enum.at(ys, j))
              prod = dot(w, x) + b
              {b, w} = if y * prod < 1.0 do
                k = 0
                while_fun_5 = fn while_fun_5, k, w ->
                  if k < _len(w) do
                    w = List.replace_at(w, k, Enum.at(w, k) + model.lr * (y * Enum.at(x, k) - 2.0 * model.lambda * Enum.at(w, k)))
                    k = k + 1
                    while_fun_5.(while_fun_5, k, w)
                  else
                    {k, w}
                  end
                end
                {k, w} = try do
                    while_fun_5.(while_fun_5, k, w)
                  catch
                    {:break, {k, w}} -> {k, w}
                  end

                b = b + model.lr * y
                {b, w}
              else
                k = 0
                while_fun_6 = fn while_fun_6, k, w ->
                  if k < _len(w) do
                    w = List.replace_at(w, k, Enum.at(w, k) - model.lr * (2.0 * model.lambda * Enum.at(w, k)))
                    k = k + 1
                    while_fun_6.(while_fun_6, k, w)
                  else
                    {k, w}
                  end
                end
                {k, w} = try do
                    while_fun_6.(while_fun_6, k, w)
                  catch
                    {:break, {k, w}} -> {k, w}
                  end

                {b, w}
              end
              j = j + 1
              while_fun_4.(while_fun_4, b, j, w)
            else
              {b, j, w}
            end
          end
          {b, j, w} = try do
              while_fun_4.(while_fun_4, b, j, w)
            catch
              {:break, {b, j, w}} -> {b, j, w}
            end

          epoch = epoch + 1
          while_fun_3.(while_fun_3, b, epoch, w)
        else
          {b, epoch, w}
        end
      end
      {b, epoch, w} = try do
          while_fun_3.(while_fun_3, b, epoch, w)
        catch
          {:break, {b, epoch, w}} -> {b, epoch, w}
        end

      throw {:return, %{weights: w, bias: b, lr: model.lr, lambda: model.lambda, epochs: model.epochs}}
    catch
      {:return, val} -> val
    end
  end
  def predict(model, x) do
    try do
      s = dot(model.weights, x) + model.bias
      if s >= 0.0 do
        throw {:return, 1}
      else
        throw {:return, -1}
      end
    catch
      {:return, val} -> val
    end
  end
  Process.put(:xs, [[0.0, 1.0], [0.0, 2.0], [1.0, 1.0], [1.0, 2.0]])
  def main() do
    Process.put(:ys, [1, 1, -1, -1])
    Process.put(:base, new_svc(0.01, 0.01, 1000))
    Process.put(:model, fit(Process.get(:base), Process.get(:xs), Process.get(:ys)))
    IO.puts(Kernel.inspect(predict(Process.get(:model), [0.0, 1.0])))
    IO.puts(Kernel.inspect(predict(Process.get(:model), [1.0, 1.0])))
    IO.puts(Kernel.inspect(predict(Process.get(:model), [2.0, 2.0])))
  end
end
Main.main()
