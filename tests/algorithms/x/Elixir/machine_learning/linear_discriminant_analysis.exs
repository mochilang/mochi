# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (:erlang.float(rand())) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def _mod(x, m) do
    try do
      throw {:return, x - (:erlang.float(Kernel.trunc(x / m))) * m}
    catch
      {:return, val} -> val
    end
  end
  def cos(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y4 = y2 * y2
      y6 = y4 * y2
      throw {:return, 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      t = (x - 1.0) / (x + 1.0)
      term = t
      sum = 0.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n <= 19 do
          sum = sum + term / (:erlang.float(n))
          term = term * t * t
          n = n + 2
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def gaussian_distribution(mean, std_dev, instance_count) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < instance_count do
          u1 = random()
          u2 = random()
          r = sqrtApprox(-2.0 * ln(u1))
          theta = Process.get(:two_pi) * u2
          z = r * cos(theta)
          res = (res ++ [mean + z * std_dev])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def y_generator(class_count, instance_count) do
    try do
      res = []
      k = 0
      while_fun_4 = fn while_fun_4, k, res ->
        if k < class_count do
          i = 0
          while_fun_5 = fn while_fun_5, i, res ->
            if i < Enum.at(instance_count, k) do
              res = (res ++ [k])
              i = i + 1
              while_fun_5.(while_fun_5, i, res)
            else
              {i, res}
            end
          end
          {i, res} = try do
              while_fun_5.(while_fun_5, i, res)
            catch
              {:break, {i, res}} -> {i, res}
            end

          k = k + 1
          while_fun_4.(while_fun_4, k, res)
        else
          {k, res}
        end
      end
      {k, res} = try do
          while_fun_4.(while_fun_4, k, res)
        catch
          {:break, {k, res}} -> {k, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def calculate_mean(instance_count, items) do
    try do
      total = 0.0
      i = 0
      while_fun_6 = fn while_fun_6, i, total ->
        if i < instance_count do
          total = total + Enum.at(items, i)
          i = i + 1
          while_fun_6.(while_fun_6, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_6.(while_fun_6, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total / (:erlang.float(instance_count))}
    catch
      {:return, val} -> val
    end
  end
  def calculate_probabilities(instance_count, total_count) do
    try do
      throw {:return, (:erlang.float(instance_count)) / (:erlang.float(total_count))}
    catch
      {:return, val} -> val
    end
  end
  def calculate_variance(items, means, total_count) do
    try do
      squared_diff = []
      i = 0
      while_fun_7 = fn while_fun_7, i, squared_diff ->
        if i < _len(items) do
          j = 0
          while_fun_8 = fn while_fun_8, j, squared_diff ->
            if j < _len(Enum.at(items, i)) do
              diff = Enum.at(Enum.at(items, i), j) - Enum.at(means, i)
              squared_diff = (squared_diff ++ [diff * diff])
              j = j + 1
              while_fun_8.(while_fun_8, j, squared_diff)
            else
              {j, squared_diff}
            end
          end
          {j, squared_diff} = try do
              while_fun_8.(while_fun_8, j, squared_diff)
            catch
              {:break, {j, squared_diff}} -> {j, squared_diff}
            end

          i = i + 1
          while_fun_7.(while_fun_7, i, squared_diff)
        else
          {i, squared_diff}
        end
      end
      {i, squared_diff} = try do
          while_fun_7.(while_fun_7, i, squared_diff)
        catch
          {:break, {i, squared_diff}} -> {i, squared_diff}
        end

      sum_sq = 0.0
      k = 0
      while_fun_9 = fn while_fun_9, k, sum_sq ->
        if k < _len(squared_diff) do
          sum_sq = sum_sq + Enum.at(squared_diff, k)
          k = k + 1
          while_fun_9.(while_fun_9, k, sum_sq)
        else
          {k, sum_sq}
        end
      end
      {k, sum_sq} = try do
          while_fun_9.(while_fun_9, k, sum_sq)
        catch
          {:break, {k, sum_sq}} -> {k, sum_sq}
        end

      n_classes = _len(means)
      throw {:return, (1.0 / (:erlang.float((total_count - n_classes)))) * sum_sq}
    catch
      {:return, val} -> val
    end
  end
  def predict_y_values(x_items, means, variance, probabilities) do
    try do
      results = []
      i = 0
      while_fun_10 = fn while_fun_10, i, results ->
        if i < _len(x_items) do
          j = 0
          while_fun_11 = fn while_fun_11, j, results ->
            if j < _len(Enum.at(x_items, i)) do
              temp = []
              k = 0
              while_fun_12 = fn while_fun_12, k, temp ->
                if k < _len(x_items) do
                  discr = Enum.at(Enum.at(x_items, i), j) * (Enum.at(means, k) / variance) - (Enum.at(means, k) * Enum.at(means, k)) / (2.0 * variance) + ln(Enum.at(probabilities, k))
                  temp = (temp ++ [discr])
                  k = k + 1
                  while_fun_12.(while_fun_12, k, temp)
                else
                  {k, temp}
                end
              end
              {k, temp} = try do
                  while_fun_12.(while_fun_12, k, temp)
                catch
                  {:break, {k, temp}} -> {k, temp}
                end

              max_idx = 0
              max_val = Enum.at(temp, 0)
              t = 1
              while_fun_13 = fn while_fun_13, max_idx, max_val, t ->
                if t < _len(temp) do
                  {max_idx, max_val} = if Enum.at(temp, t) > max_val do
                    max_val = Enum.at(temp, t)
                    max_idx = t
                    {max_idx, max_val}
                  else
                    {max_idx, max_val}
                  end
                  t = t + 1
                  while_fun_13.(while_fun_13, max_idx, max_val, t)
                else
                  {max_idx, max_val, t}
                end
              end
              {max_idx, max_val, t} = try do
                  while_fun_13.(while_fun_13, max_idx, max_val, t)
                catch
                  {:break, {max_idx, max_val, t}} -> {max_idx, max_val, t}
                end

              results = (results ++ [max_idx])
              j = j + 1
              while_fun_11.(while_fun_11, j, results)
            else
              {j, results}
            end
          end
          {j, results} = try do
              while_fun_11.(while_fun_11, j, results)
            catch
              {:break, {j, results}} -> {j, results}
            end

          i = i + 1
          while_fun_10.(while_fun_10, i, results)
        else
          {i, results}
        end
      end
      {i, results} = try do
          while_fun_10.(while_fun_10, i, results)
        catch
          {:break, {i, results}} -> {i, results}
        end

      throw {:return, results}
    catch
      {:return, val} -> val
    end
  end
  def accuracy(actual_y, predicted_y) do
    try do
      correct = 0
      i = 0
      while_fun_14 = fn while_fun_14, correct, i ->
        if i < _len(actual_y) do
          {correct} = if Enum.at(actual_y, i) == Enum.at(predicted_y, i) do
            correct = correct + 1
            {correct}
          else
            {correct}
          end
          i = i + 1
          while_fun_14.(while_fun_14, correct, i)
        else
          {correct, i}
        end
      end
      {correct, i} = try do
          while_fun_14.(while_fun_14, correct, i)
        catch
          {:break, {correct, i}} -> {correct, i}
        end

      throw {:return, (:erlang.float(correct)) / (:erlang.float(_len(actual_y))) * 100.0}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      Process.put(:seed, 1)
      counts = [20, 20, 20]
      means = [5.0, 10.0, 15.0]
      std_dev = 1.0
      x = []
      i = 0
      while_fun_15 = fn while_fun_15, i, x ->
        if i < _len(counts) do
          x = (x ++ [gaussian_distribution(Enum.at(means, i), std_dev, Enum.at(counts, i))])
          i = i + 1
          while_fun_15.(while_fun_15, i, x)
        else
          {i, x}
        end
      end
      {i, x} = try do
          while_fun_15.(while_fun_15, i, x)
        catch
          {:break, {i, x}} -> {i, x}
        end

      y = y_generator(_len(counts), counts)
      actual_means = []
      i = 0
      while_fun_16 = fn while_fun_16, actual_means, i ->
        if i < _len(counts) do
          actual_means = (actual_means ++ [calculate_mean(Enum.at(counts, i), Enum.at(x, i))])
          i = i + 1
          while_fun_16.(while_fun_16, actual_means, i)
        else
          {actual_means, i}
        end
      end
      {actual_means, i} = try do
          while_fun_16.(while_fun_16, actual_means, i)
        catch
          {:break, {actual_means, i}} -> {actual_means, i}
        end

      total_count = 0
      i = 0
      while_fun_17 = fn while_fun_17, i, total_count ->
        if i < _len(counts) do
          total_count = total_count + Enum.at(counts, i)
          i = i + 1
          while_fun_17.(while_fun_17, i, total_count)
        else
          {i, total_count}
        end
      end
      {i, total_count} = try do
          while_fun_17.(while_fun_17, i, total_count)
        catch
          {:break, {i, total_count}} -> {i, total_count}
        end

      probabilities = []
      i = 0
      while_fun_18 = fn while_fun_18, i, probabilities ->
        if i < _len(counts) do
          probabilities = (probabilities ++ [calculate_probabilities(Enum.at(counts, i), total_count)])
          i = i + 1
          while_fun_18.(while_fun_18, i, probabilities)
        else
          {i, probabilities}
        end
      end
      {i, probabilities} = try do
          while_fun_18.(while_fun_18, i, probabilities)
        catch
          {:break, {i, probabilities}} -> {i, probabilities}
        end

      variance = calculate_variance(x, actual_means, total_count)
      predicted = predict_y_values(x, actual_means, variance, probabilities)
      IO.puts(Kernel.inspect(predicted))
      IO.puts(Kernel.inspect(accuracy(y, predicted)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:two_pi, 6.283185307179586)
  Process.put(:seed, 1)
end
Main.main()
