# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: 0.0 - x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def ln_series(x) do
    try do
      t = (x - 1.0) / (x + 1.0)
      term = t
      sum = 0.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n <= 19 do
          sum = sum + term / (:erlang.float(n))
          term = term * t * t
          n = n + 2
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      y = x
      k = 0
      while_fun_3 = fn while_fun_3, k, y ->
        if y >= 10.0 do
          y = y / 10.0
          k = k + 1
          while_fun_3.(while_fun_3, k, y)
        else
          {k, y}
        end
      end
      {k, y} = try do
          while_fun_3.(while_fun_3, k, y)
        catch
          {:break, {k, y}} -> {k, y}
        end

      while_fun_4 = fn while_fun_4, k, y ->
        if y < 1.0 do
          y = y * 10.0
          k = k - 1
          while_fun_4.(while_fun_4, k, y)
        else
          {k, y}
        end
      end
      {k, y} = try do
          while_fun_4.(while_fun_4, k, y)
        catch
          {:break, {k, y}} -> {k, y}
        end

      throw {:return, ln_series(y) + (:erlang.float(k)) * ln_series(10.0)}
    catch
      {:return, val} -> val
    end
  end
  def mae(predict, actual) do
    try do
      sum = 0.0
      i = 0
      while_fun_5 = fn while_fun_5, i, sum ->
        if i < _len(predict) do
          diff = Enum.at(predict, i) - Enum.at(actual, i)
          sum = sum + absf(diff)
          i = i + 1
          while_fun_5.(while_fun_5, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_5.(while_fun_5, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum / (:erlang.float(_len(predict)))}
    catch
      {:return, val} -> val
    end
  end
  def mse(predict, actual) do
    try do
      sum = 0.0
      i = 0
      while_fun_6 = fn while_fun_6, i, sum ->
        if i < _len(predict) do
          diff = Enum.at(predict, i) - Enum.at(actual, i)
          sum = sum + diff * diff
          i = i + 1
          while_fun_6.(while_fun_6, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_6.(while_fun_6, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum / (:erlang.float(_len(predict)))}
    catch
      {:return, val} -> val
    end
  end
  def rmse(predict, actual) do
    try do
      throw {:return, sqrtApprox(mse(predict, actual))}
    catch
      {:return, val} -> val
    end
  end
  def rmsle(predict, actual) do
    try do
      sum = 0.0
      i = 0
      while_fun_7 = fn while_fun_7, i, sum ->
        if i < _len(predict) do
          lp = ln(Enum.at(predict, i) + 1.0)
          la = ln(Enum.at(actual, i) + 1.0)
          diff = lp - la
          sum = sum + diff * diff
          i = i + 1
          while_fun_7.(while_fun_7, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_7.(while_fun_7, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sqrtApprox(sum / (:erlang.float(_len(predict))))}
    catch
      {:return, val} -> val
    end
  end
  def mbd(predict, actual) do
    try do
      diff_sum = 0.0
      actual_sum = 0.0
      i = 0
      while_fun_8 = fn while_fun_8, actual_sum, diff_sum, i ->
        if i < _len(predict) do
          diff_sum = diff_sum + (Enum.at(predict, i) - Enum.at(actual, i))
          actual_sum = actual_sum + Enum.at(actual, i)
          i = i + 1
          while_fun_8.(while_fun_8, actual_sum, diff_sum, i)
        else
          {actual_sum, diff_sum, i}
        end
      end
      {actual_sum, diff_sum, i} = try do
          while_fun_8.(while_fun_8, actual_sum, diff_sum, i)
        catch
          {:break, {actual_sum, diff_sum, i}} -> {actual_sum, diff_sum, i}
        end

      n = :erlang.float(_len(predict))
      numerator = diff_sum / n
      denominator = actual_sum / n
      throw {:return, numerator / denominator * 100.0}
    catch
      {:return, val} -> val
    end
  end
  def manual_accuracy(predict, actual) do
    try do
      correct = 0
      i = 0
      while_fun_9 = fn while_fun_9, correct, i ->
        if i < _len(predict) do
          {correct} = if Enum.at(predict, i) == Enum.at(actual, i) do
            correct = correct + 1
            {correct}
          else
            {correct}
          end
          i = i + 1
          while_fun_9.(while_fun_9, correct, i)
        else
          {correct, i}
        end
      end
      {correct, i} = try do
          while_fun_9.(while_fun_9, correct, i)
        catch
          {:break, {correct, i}} -> {correct, i}
        end

      throw {:return, (:erlang.float(correct)) / (:erlang.float(_len(predict)))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      actual = [1.0, 2.0, 3.0]
      predict = [1.0, 4.0, 3.0]
      IO.puts(Kernel.inspect(mae(predict, actual)))
      IO.puts(Kernel.inspect(mse(predict, actual)))
      IO.puts(Kernel.inspect(rmse(predict, actual)))
      IO.puts(Kernel.inspect(rmsle([10.0, 2.0, 30.0], [10.0, 10.0, 30.0])))
      IO.puts(Kernel.inspect(mbd([2.0, 3.0, 4.0], [1.0, 2.0, 3.0])))
      IO.puts(Kernel.inspect(mbd([0.0, 1.0, 1.0], [1.0, 2.0, 3.0])))
      IO.puts(Kernel.inspect(manual_accuracy(predict, actual)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
