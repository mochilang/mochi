# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      result = 1.0
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < n do
          result = result * 10.0
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def round(x, n) do
    try do
      m = pow10(n)
      y = :erlang.float(floor(x * m + 0.5))
      throw {:return, y / m}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x
      i = 0
      while_fun_2 = fn while_fun_2, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_2.(while_fun_2, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_2.(while_fun_2, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def mean(data) do
    try do
      total = 0.0
      i = 0
      n = _len(data)
      while_fun_3 = fn while_fun_3, i, total ->
        if i < n do
          total = total + Enum.at(data, i)
          i = i + 1
          while_fun_3.(while_fun_3, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_3.(while_fun_3, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total / (:erlang.float(n))}
    catch
      {:return, val} -> val
    end
  end
  def stdev(data) do
    try do
      n = _len(data)
      if n <= 1 do
        raise("data length must be > 1")
      end
      m = mean(data)
      sum_sq = 0.0
      i = 0
      while_fun_4 = fn while_fun_4, i, sum_sq ->
        if i < n do
          diff = Enum.at(data, i) - m
          sum_sq = sum_sq + diff * diff
          i = i + 1
          while_fun_4.(while_fun_4, i, sum_sq)
        else
          {i, sum_sq}
        end
      end
      {i, sum_sq} = try do
          while_fun_4.(while_fun_4, i, sum_sq)
        catch
          {:break, {i, sum_sq}} -> {i, sum_sq}
        end

      throw {:return, sqrtApprox(sum_sq / (:erlang.float((n - 1))))}
    catch
      {:return, val} -> val
    end
  end
  def normalization(data, ndigits) do
    try do
      x_min = :erlang.float(Enum.min(data))
      x_max = :erlang.float(Enum.max(data))
      denom = x_max - x_min
      result = []
      i = 0
      n = _len(data)
      while_fun_5 = fn while_fun_5, i, result ->
        if i < n do
          norm = (Enum.at(data, i) - x_min) / denom
          result = (result ++ [round(norm, ndigits)])
          i = i + 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def standardization(data, ndigits) do
    try do
      mu = mean(data)
      sigma = stdev(data)
      result = []
      i = 0
      n = _len(data)
      while_fun_6 = fn while_fun_6, i, result ->
        if i < n do
          z = (Enum.at(data, i) - mu) / sigma
          result = (result ++ [round(z, ndigits)])
          i = i + 1
          while_fun_6.(while_fun_6, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_6.(while_fun_6, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(normalization([2.0, 7.0, 10.0, 20.0, 30.0, 50.0], 3)))
    IO.puts(Kernel.inspect(normalization([5.0, 10.0, 15.0, 20.0, 25.0], 3)))
    IO.puts(Kernel.inspect(standardization([2.0, 7.0, 10.0, 20.0, 30.0, 50.0], 3)))
    IO.puts(Kernel.inspect(standardization([5.0, 10.0, 15.0, 20.0, 25.0], 3)))
  end
end
Main.main()
