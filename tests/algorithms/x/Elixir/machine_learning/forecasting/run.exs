# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def int_to_float(x) do
    try do
      throw {:return, x * 1.0}
    catch
      {:return, val} -> val
    end
  end
  def abs_float(x) do
    try do
      throw {:return, ((if x < 0.0, do: 0.0 - x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def exp_approx(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          term = term * x / int_to_float(i)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def floor_int(x) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if int_to_float(i + 1) <= x do
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def dot(a, b) do
    try do
      s = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, s ->
        if i < _len(a) do
          s = s + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def transpose(m) do
    try do
      rows = _len(m)
      cols = _len(Enum.at(m, 0))
      res = []
      j = 0
      while_fun_4 = fn while_fun_4, j, res ->
        if j < cols do
          row = []
          i = 0
          while_fun_5 = fn while_fun_5, i, row ->
            if i < rows do
              row = (row ++ [Enum.at(Enum.at(m, i), j)])
              i = i + 1
              while_fun_5.(while_fun_5, i, row)
            else
              {i, row}
            end
          end
          {i, row} = try do
              while_fun_5.(while_fun_5, i, row)
            catch
              {:break, {i, row}} -> {i, row}
            end

          res = (res ++ [row])
          j = j + 1
          while_fun_4.(while_fun_4, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_4.(while_fun_4, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matmul(a, b) do
    try do
      n = _len(a)
      m = _len(Enum.at(b, 0))
      p = _len(b)
      res = []
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < n do
          row = []
          j = 0
          while_fun_7 = fn while_fun_7, j, row ->
            if j < m do
              s = 0.0
              k = 0
              while_fun_8 = fn while_fun_8, k, s ->
                if k < p do
                  s = s + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_8.(while_fun_8, k, s)
                else
                  {k, s}
                end
              end
              {k, s} = try do
                  while_fun_8.(while_fun_8, k, s)
                catch
                  {:break, {k, s}} -> {k, s}
                end

              row = (row ++ [s])
              j = j + 1
              while_fun_7.(while_fun_7, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_7.(while_fun_7, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matvec(a, b) do
    try do
      res = []
      i = 0
      while_fun_9 = fn while_fun_9, i, res ->
        if i < _len(a) do
          res = (res ++ [dot(Enum.at(a, i), b)])
          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def identity(n) do
    try do
      res = []
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < n do
          row = []
          j = 0
          while_fun_11 = fn while_fun_11, j, row ->
            if j < n do
              row = (row ++ [(if i == j, do: 1.0, else: 0.0)])
              j = j + 1
              while_fun_11.(while_fun_11, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_11.(while_fun_11, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def invert(mat) do
    try do
      n = _len(mat)
      a = mat
      inv = identity(n)
      i = 0
      while_fun_12 = fn while_fun_12, a, i, inv ->
        if i < n do
          pivot = Enum.at(Enum.at(a, i), i)
          j = 0
          while_fun_13 = fn while_fun_13, a, inv, j ->
            if j < n do
              a = List.replace_at(a, i, List.replace_at(Enum.at(a, i), j, Enum.at(Enum.at(a, i), j) / pivot))
              inv = List.replace_at(inv, i, List.replace_at(Enum.at(inv, i), j, Enum.at(Enum.at(inv, i), j) / pivot))
              j = j + 1
              while_fun_13.(while_fun_13, a, inv, j)
            else
              {a, inv, j}
            end
          end
          {a, inv, j} = try do
              while_fun_13.(while_fun_13, a, inv, j)
            catch
              {:break, {a, inv, j}} -> {a, inv, j}
            end

          k = 0
          while_fun_14 = fn while_fun_14, a, inv, j, k ->
            if k < n do
              {a, inv, j} = if k != i do
                factor = Enum.at(Enum.at(a, k), i)
                j = 0
                while_fun_15 = fn while_fun_15, a, inv, j ->
                  if j < n do
                    a = List.replace_at(a, k, List.replace_at(Enum.at(a, k), j, Enum.at(Enum.at(a, k), j) - factor * Enum.at(Enum.at(a, i), j)))
                    inv = List.replace_at(inv, k, List.replace_at(Enum.at(inv, k), j, Enum.at(Enum.at(inv, k), j) - factor * Enum.at(Enum.at(inv, i), j)))
                    j = j + 1
                    while_fun_15.(while_fun_15, a, inv, j)
                  else
                    {a, inv, j}
                  end
                end
                {a, inv, j} = try do
                    while_fun_15.(while_fun_15, a, inv, j)
                  catch
                    {:break, {a, inv, j}} -> {a, inv, j}
                  end

                {a, inv, j}
              else
                {a, inv, j}
              end
              k = k + 1
              while_fun_14.(while_fun_14, a, inv, j, k)
            else
              {a, inv, j, k}
            end
          end
          {a, inv, j, k} = try do
              while_fun_14.(while_fun_14, a, inv, j, k)
            catch
              {:break, {a, inv, j, k}} -> {a, inv, j, k}
            end

          i = i + 1
          while_fun_12.(while_fun_12, a, i, inv)
        else
          {a, i, inv}
        end
      end
      {a, i, inv} = try do
          while_fun_12.(while_fun_12, a, i, inv)
        catch
          {:break, {a, i, inv}} -> {a, i, inv}
        end

      throw {:return, inv}
    catch
      {:return, val} -> val
    end
  end
  def normal_equation(x, y) do
    try do
      xt = transpose(x)
      xtx = matmul(xt, x)
      xtx_inv = invert(xtx)
      xty = matvec(xt, y)
      throw {:return, matvec(xtx_inv, xty)}
    catch
      {:return, val} -> val
    end
  end
  def linear_regression_prediction(train_dt, train_usr, train_mtch, test_dt, test_mtch) do
    try do
      x = []
      i = 0
      while_fun_16 = fn while_fun_16, x, i ->
        if i < _len(train_dt) do
          x = (x ++ [[1.0, Enum.at(train_dt, i), Enum.at(train_mtch, i)]])
          i = i + 1
          while_fun_16.(while_fun_16, x, i)
        else
          {x, i}
        end
      end
      {x, i} = try do
          while_fun_16.(while_fun_16, x, i)
        catch
          {:break, {x, i}} -> {x, i}
        end

      beta = normal_equation(x, train_usr)
      throw {:return, abs_float(Enum.at(beta, 0) + Enum.at(test_dt, 0) * Enum.at(beta, 1) + Enum.at(test_mtch, 0) * Enum.at(beta, 2))}
    catch
      {:return, val} -> val
    end
  end
  def sarimax_predictor(train_user, train_match, test_match) do
    try do
      n = _len(train_user)
      x = []
      y = []
      i = 1
      while_fun_17 = fn while_fun_17, x, i, y ->
        if i < n do
          x = (x ++ [[1.0, Enum.at(train_user, i - 1), Enum.at(train_match, i)]])
          y = (y ++ [Enum.at(train_user, i)])
          i = i + 1
          while_fun_17.(while_fun_17, x, i, y)
        else
          {x, i, y}
        end
      end
      {x, i, y} = try do
          while_fun_17.(while_fun_17, x, i, y)
        catch
          {:break, {x, i, y}} -> {x, i, y}
        end

      beta = normal_equation(x, y)
      throw {:return, Enum.at(beta, 0) + Enum.at(beta, 1) * Enum.at(train_user, n - 1) + Enum.at(beta, 2) * Enum.at(test_match, 0)}
    catch
      {:return, val} -> val
    end
  end
  def rbf_kernel(a, b, gamma) do
    try do
      sum = 0.0
      i = 0
      while_fun_18 = fn while_fun_18, i, sum ->
        if i < _len(a) do
          diff = Enum.at(a, i) - Enum.at(b, i)
          sum = sum + diff * diff
          i = i + 1
          while_fun_18.(while_fun_18, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_18.(while_fun_18, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, exp_approx(-gamma * sum)}
    catch
      {:return, val} -> val
    end
  end
  def support_vector_regressor(x_train, x_test, train_user) do
    try do
      gamma = 0.1
      weights = []
      i = 0
      while_fun_19 = fn while_fun_19, i, weights ->
        if i < _len(x_train) do
          weights = (weights ++ [rbf_kernel(Enum.at(x_train, i), Enum.at(x_test, 0), gamma)])
          i = i + 1
          while_fun_19.(while_fun_19, i, weights)
        else
          {i, weights}
        end
      end
      {i, weights} = try do
          while_fun_19.(while_fun_19, i, weights)
        catch
          {:break, {i, weights}} -> {i, weights}
        end

      num = 0.0
      den = 0.0
      i = 0
      while_fun_20 = fn while_fun_20, den, i, num ->
        if i < _len(train_user) do
          num = num + Enum.at(weights, i) * Enum.at(train_user, i)
          den = den + Enum.at(weights, i)
          i = i + 1
          while_fun_20.(while_fun_20, den, i, num)
        else
          {den, i, num}
        end
      end
      {den, i, num} = try do
          while_fun_20.(while_fun_20, den, i, num)
        catch
          {:break, {den, i, num}} -> {den, i, num}
        end

      throw {:return, num / den}
    catch
      {:return, val} -> val
    end
  end
  def set_at_float(xs, idx, value) do
    try do
      i = 0
      res = []
      while_fun_21 = fn while_fun_21, i, res ->
        if i < _len(xs) do
          res = (if i == idx, do: (res ++ [value]), else: (res ++ [Enum.at(xs, i)]))
          i = i + 1
          while_fun_21.(while_fun_21, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_21.(while_fun_21, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def sort_float(xs) do
    try do
      res = xs
      i = 1
      while_fun_22 = fn while_fun_22, i, res ->
        if i < _len(res) do
          key = Enum.at(res, i)
          j = i - 1
          while_fun_23 = fn while_fun_23, j, res ->
            if j >= 0 && Enum.at(res, j) > key do
              res = set_at_float(res, j + 1, Enum.at(res, j))
              j = j - 1
              while_fun_23.(while_fun_23, j, res)
            else
              {j, res}
            end
          end
          {j, res} = try do
              while_fun_23.(while_fun_23, j, res)
            catch
              {:break, {j, res}} -> {j, res}
            end

          res = set_at_float(res, j + 1, key)
          i = i + 1
          while_fun_22.(while_fun_22, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_22.(while_fun_22, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def percentile(data, q) do
    try do
      sorted = sort_float(data)
      n = _len(sorted)
      pos = (q / 100.0) * int_to_float(n - 1)
      idx = floor_int(pos)
      frac = pos - int_to_float(idx)
      if idx + 1 < n do
        throw {:return, Enum.at(sorted, idx) * (1.0 - frac) + Enum.at(sorted, idx + 1) * frac}
      end
      throw {:return, Enum.at(sorted, idx)}
    catch
      {:return, val} -> val
    end
  end
  def interquartile_range_checker(train_user) do
    try do
      q1 = percentile(train_user, 25.0)
      q3 = percentile(train_user, 75.0)
      iqr = q3 - q1
      throw {:return, q1 - iqr * 0.1}
    catch
      {:return, val} -> val
    end
  end
  def data_safety_checker(list_vote, actual_result) do
    try do
      safe = 0
      not_safe = 0
      i = 0
      while_fun_24 = fn while_fun_24, i, not_safe, safe ->
        if i < _len(list_vote) do
          v = Enum.at(list_vote, i)
          {not_safe, safe} = if v > actual_result do
            safe = not_safe + 1
            {not_safe, safe}
          else
            {not_safe, safe} = if abs_float(abs_float(v) - abs_float(actual_result)) <= 0.1 do
              safe = safe + 1
              {not_safe, safe}
            else
              not_safe = not_safe + 1
              {not_safe, safe}
            end
            {not_safe, safe}
          end
          i = i + 1
          while_fun_24.(while_fun_24, i, not_safe, safe)
        else
          {i, not_safe, safe}
        end
      end
      {i, not_safe, safe} = try do
          while_fun_24.(while_fun_24, i, not_safe, safe)
        catch
          {:break, {i, not_safe, safe}} -> {i, not_safe, safe}
        end

      throw {:return, safe > not_safe}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      vote = [linear_regression_prediction([2.0, 3.0, 4.0, 5.0], [5.0, 3.0, 4.0, 6.0], [3.0, 1.0, 2.0, 4.0], [2.0], [2.0]), sarimax_predictor([4.0, 2.0, 6.0, 8.0], [3.0, 1.0, 2.0, 4.0], [2.0]), support_vector_regressor([[5.0, 2.0], [1.0, 5.0], [6.0, 2.0]], [[3.0, 2.0]], [2.0, 1.0, 4.0])]
      IO.puts(Enum.at(vote, 0))
      IO.puts(Enum.at(vote, 1))
      IO.puts(Enum.at(vote, 2))
      IO.puts(Kernel.inspect(data_safety_checker(vote, 5.0)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
