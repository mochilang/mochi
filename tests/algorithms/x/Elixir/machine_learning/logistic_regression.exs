# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def expApprox(x) do
    try do
      y = x
      is_neg = false
      {is_neg} = if x < 0.0 do
        is_neg = true
        y = -x
        {is_neg}
      else
        {is_neg}
      end
      term = 1.0
      sum = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 30 do
          term = term * y / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      if is_neg do
        throw {:return, 1.0 / sum}
      end
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(z) do
    try do
      throw {:return, 1.0 / (1.0 + expApprox(-z))}
    catch
      {:return, val} -> val
    end
  end
  def dot(a, b) do
    try do
      s = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, s ->
        if i < _len(a) do
          s = s + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_2.(while_fun_2, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def zeros(n) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < n do
          res = (res ++ [0.0])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def logistic_reg(alpha, x, y, iterations) do
    try do
      m = _len(x)
      n = _len(Enum.at(x, 0))
      theta = zeros(n)
      iter = 0
      while_fun_4 = fn while_fun_4, iter ->
        if iter < iterations do
          grad = zeros(n)
          i = 0
          while_fun_5 = fn while_fun_5, grad, i ->
            if i < m do
              z = dot(Enum.at(x, i), theta)
              h = sigmoid(z)
              k = 0
              while_fun_6 = fn while_fun_6, grad, k ->
                if k < n do
                  grad = List.replace_at(grad, k, Enum.at(grad, k) + (h - Enum.at(y, i)) * Enum.at(Enum.at(x, i), k))
                  k = k + 1
                  while_fun_6.(while_fun_6, grad, k)
                else
                  {grad, k}
                end
              end
              {grad, k} = try do
                  while_fun_6.(while_fun_6, grad, k)
                catch
                  {:break, {grad, k}} -> {grad, k}
                end

              i = i + 1
              while_fun_5.(while_fun_5, grad, i)
            else
              {grad, i}
            end
          end
          {grad, i} = try do
              while_fun_5.(while_fun_5, grad, i)
            catch
              {:break, {grad, i}} -> {grad, i}
            end

          k2 = 0
          while_fun_7 = fn while_fun_7, k2 ->
            if k2 < n do
              theta = List.replace_at(theta, k2, Enum.at(theta, k2) - alpha * Enum.at(grad, k2) / (:erlang.float(m)))
              k2 = k2 + 1
              while_fun_7.(while_fun_7, k2)
            else
              k2
            end
          end
          k2 = try do
              while_fun_7.(while_fun_7, k2)
            catch
              {:break, {k2}} -> k2
            end

          iter = iter + 1
          while_fun_4.(while_fun_4, iter)
        else
          iter
        end
      end
      iter = try do
          while_fun_4.(while_fun_4, iter)
        catch
          {:break, {iter}} -> iter
        end

      throw {:return, theta}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:x, [[0.5, 1.5], [1.0, 1.0], [1.5, 0.5], [3.0, 3.5], [3.5, 3.0], [4.0, 4.0]])
  Process.put(:y, [0.0, 0.0, 0.0, 1.0, 1.0, 1.0])
  Process.put(:alpha, 0.1)
  Process.put(:iterations, 1000)
  def main() do
    Process.put(:theta, logistic_reg(Process.get(:alpha), Process.get(:x), Process.get(:y), Process.get(:iterations)))
    Enum.each((0..(_len(Process.get(:theta)) - 1)), fn i ->
      IO.puts(Enum.at(Process.get(:theta), i))
    end)
  end
end
Main.main()
