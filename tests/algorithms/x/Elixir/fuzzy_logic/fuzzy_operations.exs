# Code generated by Mochi transpiler 2025-08-14 10:36 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def stringify(fs) do
    try do
      throw {:return, (((((((fs.name <> ": [") <> Kernel.to_string(fs.left_boundary)) <> ", ") <> Kernel.to_string(fs.peak)) <> ", ") <> Kernel.to_string(fs.right_boundary)) <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def max2(a, b) do
    try do
      throw {:return, ((if a > b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def min2(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def complement(fs) do
    try do
      throw {:return, %{name: ("¬" <> fs.name), left_boundary: 1.0 - fs.right_boundary, peak: 1.0 - fs.left_boundary, right_boundary: 1.0 - fs.peak}}
    catch
      {:return, val} -> val
    end
  end
  def intersection(a, b) do
    try do
      throw {:return, %{name: ((a.name <> " ∩ ") <> b.name), left_boundary: max2(a.left_boundary, b.left_boundary), peak: min2(a.right_boundary, b.right_boundary), right_boundary: (a.peak + b.peak) / 2.0}}
    catch
      {:return, val} -> val
    end
  end
  def union(a, b) do
    try do
      throw {:return, %{name: ((a.name <> " U ") <> b.name), left_boundary: min2(a.left_boundary, b.left_boundary), peak: max2(a.right_boundary, b.right_boundary), right_boundary: (a.peak + b.peak) / 2.0}}
    catch
      {:return, val} -> val
    end
  end
  def membership(fs, x) do
    try do
      if x <= fs.left_boundary || x >= fs.right_boundary do
        throw {:return, 0.0}
      end
      if fs.left_boundary < x && x <= fs.peak do
        throw {:return, (x - fs.left_boundary) / (fs.peak - fs.left_boundary)}
      end
      if fs.peak < x && x < fs.right_boundary do
        throw {:return, (fs.right_boundary - x) / (fs.right_boundary - fs.peak)}
      end
      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:sheru, %{name: "Sheru", left_boundary: 0.4, peak: 1.0, right_boundary: 0.6})
  Process.put(:siya, %{name: "Siya", left_boundary: 0.5, peak: 1.0, right_boundary: 0.7})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(stringify(Process.get(:sheru))))
    IO.puts(Kernel.inspect(stringify(Process.get(:siya))))
    Process.put(:sheru_comp, complement(Process.get(:sheru)))
    IO.puts(Kernel.inspect(stringify(Process.get(:sheru_comp))))
    Process.put(:inter, intersection(Process.get(:siya), Process.get(:sheru)))
    IO.puts(Kernel.inspect(stringify(Process.get(:inter))))
    IO.puts(("Sheru membership 0.5: " <> Kernel.inspect(membership(Process.get(:sheru), 0.5))))
    IO.puts(("Sheru membership 0.6: " <> Kernel.inspect(membership(Process.get(:sheru), 0.6))))
    Process.put(:uni, union(Process.get(:siya), Process.get(:sheru)))
    IO.puts(Kernel.inspect(stringify(Process.get(:uni))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
