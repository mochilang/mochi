# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def supported_values() do
    try do
      result = Enum.at(Process.get(:units), 0)
      i = 1
      while_fun = fn while_fun, i, result ->
        if i < _len(Process.get(:units)) do
          result = ((result <> ", ") <> Enum.at(Process.get(:units), i))
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def find_index(name) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(Process.get(:units)) do
          if Enum.at(Process.get(:units), i) == name do
            throw {:return, i}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def get_from_factor(name) do
    try do
      idx = find_index(name)
      if idx < 0 do
        raise(((("Invalid 'from_type' value: '" <> name) <> "' Supported values are: ") <> supported_values()))
      end
      throw {:return, Enum.at(Process.get(:from_factors), idx)}
    catch
      {:return, val} -> val
    end
  end
  def get_to_factor(name) do
    try do
      idx = find_index(name)
      if idx < 0 do
        raise(((("Invalid 'to_type' value: '" <> name) <> "' Supported values are: ") <> supported_values()))
      end
      throw {:return, Enum.at(Process.get(:to_factors), idx)}
    catch
      {:return, val} -> val
    end
  end
  def volume_conversion(value, from_type, to_type) do
    try do
      from_factor = get_from_factor(from_type)
      to_factor = get_to_factor(to_type)
      throw {:return, value * from_factor * to_factor}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:units, ["cubic meter", "litre", "kilolitre", "gallon", "cubic yard", "cubic foot", "cup"])
  Process.put(:from_factors, [1.0, 0.001, 1.0, 0.00454, 0.76455, 0.028, 0.000236588])
  Process.put(:to_factors, [1.0, 1000.0, 1.0, 264.172, 1.30795, 35.3147, 4226.75])
  def main() do
    IO.puts(Kernel.inspect(volume_conversion(4.0, "cubic meter", "litre")))
    IO.puts(Kernel.inspect(volume_conversion(1.0, "litre", "gallon")))
    IO.puts(Kernel.inspect(volume_conversion(1.0, "kilolitre", "cubic meter")))
    IO.puts(Kernel.inspect(volume_conversion(3.0, "gallon", "cubic yard")))
    IO.puts(Kernel.inspect(volume_conversion(2.0, "cubic yard", "litre")))
    IO.puts(Kernel.inspect(volume_conversion(4.0, "cubic foot", "cup")))
    IO.puts(Kernel.inspect(volume_conversion(1.0, "cup", "kilolitre")))
  end
end
Main.main()
