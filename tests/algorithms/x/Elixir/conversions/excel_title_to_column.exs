# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def excel_title_to_column(title) do
    try do
      result = 0
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < _len(title) do
          ch = _slice(title, i, (i + 1) - i)
          value = 0
          idx = 0
          found = false
          while_fun_2 = fn while_fun_2, found, idx, value ->
            if idx < _len(Process.get(:letters)) do
              {found, value} = if _slice(Process.get(:letters), idx, (idx + 1) - idx) == ch do
                value = idx + 1
                found = true
                throw {:break, {found, idx, value}}
                {found, value}
              else
                {found, value}
              end
              idx = idx + 1
              while_fun_2.(while_fun_2, found, idx, value)
            else
              {found, idx, value}
            end
          end
          {found, idx, value} = try do
              while_fun_2.(while_fun_2, found, idx, value)
            catch
              {:break, {found, idx, value}} -> {found, idx, value}
            end

          if !found do
            raise("title must contain only uppercase A-Z")
          end
          result = result * 26 + value
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(excel_title_to_column("A")))
      IO.puts(Kernel.inspect(excel_title_to_column("B")))
      IO.puts(Kernel.inspect(excel_title_to_column("AB")))
      IO.puts(Kernel.inspect(excel_title_to_column("Z")))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:letters, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
end
Main.main()
