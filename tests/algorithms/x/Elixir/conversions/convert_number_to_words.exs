# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow10(exp) do
    try do
      res = 1
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < exp do
          res = res * 10
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def max_value(system) do
    try do
      if system == "short" do
        throw {:return, pow10(18) - 1}
      end
      if system == "long" do
        throw {:return, pow10(21) - 1}
      end
      if system == "indian" do
        throw {:return, pow10(19) - 1}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def join_words(words) do
    try do
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(words) do
          {res} = if i > 0 do
            res = (res <> " ")
            {res}
          else
            {res}
          end
          res = (res <> Enum.at(words, i))
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def convert_small_number(num) do
    try do
      if num < 0 do
        throw {:return, ""}
      end
      if num >= 100 do
        throw {:return, ""}
      end
      tens_digit = div(num, 10)
      ones_digit = rem(num, 10)
      if tens_digit == 0 do
        throw {:return, Enum.at(Process.get(:ones), ones_digit)}
      end
      if tens_digit == 1 do
        throw {:return, Enum.at(Process.get(:teens), ones_digit)}
      end
      hyphen = (if ones_digit > 0, do: "-", else: "")
      tail = (if ones_digit > 0, do: Enum.at(Process.get(:ones), ones_digit), else: "")
      throw {:return, ((Enum.at(Process.get(:tens), tens_digit) <> hyphen) <> tail)}
    catch
      {:return, val} -> val
    end
  end
  def convert_number(num, system) do
    try do
      word_groups = []
      n = num
      {n, word_groups} = if n < 0 do
        word_groups = (word_groups ++ ["negative"])
        n = -n
        {n, word_groups}
      else
        {n, word_groups}
      end
      if n > max_value(system) do
        throw {:return, ""}
      end
      powers = []
      units = []
      {powers, units} = if system == "short" do
        powers = Process.get(:short_powers)
        units = Process.get(:short_units)
        {powers, units}
      else
        {powers, units} = if system == "long" do
          powers = Process.get(:long_powers)
          units = Process.get(:long_units)
          {powers, units}
        else
          {powers, units} = if system == "indian" do
            powers = Process.get(:indian_powers)
            units = Process.get(:indian_units)
            {powers, units}
          else
            throw {:return, ""}
            {powers, units}
          end
          {powers, units}
        end
        {powers, units}
      end
      i = 0
      while_fun_3 = fn while_fun_3, i, n, word_groups ->
        if i < _len(powers) do
          power = Enum.at(powers, i)
          unit = Enum.at(units, i)
          divisor = pow10(power)
          digit_group = div(n, divisor)
          n = rem(n, divisor)
          {word_groups} = if digit_group > 0 do
            word_group = (if digit_group >= 100, do: convert_number(digit_group, system), else: convert_small_number(digit_group))
            word_groups = (word_groups ++ [((word_group <> " ") <> unit)])
            {word_groups}
          else
            {word_groups}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, n, word_groups)
        else
          {i, n, word_groups}
        end
      end
      {i, n, word_groups} = try do
          while_fun_3.(while_fun_3, i, n, word_groups)
        catch
          {:break, {i, n, word_groups}} -> {i, n, word_groups}
        end

      {word_groups} = if n > 0 || _len(word_groups) == 0 do
        word_groups = (word_groups ++ [convert_small_number(n)])
        {word_groups}
      else
        {word_groups}
      end
      joined = join_words(word_groups)
      throw {:return, joined}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:ones, ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"])
  Process.put(:teens, ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"])
  Process.put(:tens, ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"])
  Process.put(:short_powers, [15, 12, 9, 6, 3, 2])
  Process.put(:short_units, ["quadrillion", "trillion", "billion", "million", "thousand", "hundred"])
  Process.put(:long_powers, [15, 9, 6, 3, 2])
  Process.put(:long_units, ["billiard", "milliard", "million", "thousand", "hundred"])
  Process.put(:indian_powers, [14, 12, 7, 5, 3, 2])
  Process.put(:indian_units, ["crore crore", "lakh crore", "crore", "lakh", "thousand", "hundred"])
  def main() do
    IO.puts(Kernel.inspect(convert_number(123456789012345, "short")))
    IO.puts(Kernel.inspect(convert_number(123456789012345, "long")))
    IO.puts(Kernel.inspect(convert_number(123456789012345, "indian")))
  end
end
Main.main()
