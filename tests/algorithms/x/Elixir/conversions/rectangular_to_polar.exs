# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def atanApprox(x) do
    try do
      if x > 1.0 do
        throw {:return, Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      if x < (-1.0) do
        throw {:return, -Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      throw {:return, x / (1.0 + 0.28 * x * x)}
    catch
      {:return, val} -> val
    end
  end
  def atan2Approx(y, x) do
    try do
      if x > 0.0 do
        r = atanApprox(y / x)
        throw {:return, r}
      end
      if x < 0.0 do
        if y >= 0.0 do
          throw {:return, atanApprox(y / x) + Process.get(:pi)}
        end
        throw {:return, atanApprox(y / x) - Process.get(:pi)}
      end
      if y > 0.0 do
        throw {:return, Process.get(:pi) / 2.0}
      end
      if y < 0.0 do
        throw {:return, -Process.get(:pi) / 2.0}
      end
      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  def deg(rad) do
    try do
      throw {:return, rad * 180.0 / Process.get(:pi)}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      i = 0
      while_fun_2 = fn while_fun_2, i, p ->
        if i < n do
          p = p * 10.0
          i = i + 1
          while_fun_2.(while_fun_2, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun_2.(while_fun_2, i, p)
        catch
          {:break, {i, p}} -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def round(x, n) do
    try do
      m = pow10(n)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def rectangular_to_polar(real, img) do
    try do
      mod = round(sqrtApprox(real * real + img * img), 2)
      ang = round(deg(atan2Approx(img, real)), 2)
      throw {:return, [mod, ang]}
    catch
      {:return, val} -> val
    end
  end
  def show(real, img) do
    try do
      r = rectangular_to_polar(real, img)
      IO.puts(Kernel.to_string(r))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  def main() do
    show(5.0, -5.0)
    show(-1.0, 1.0)
    show(-1.0, -1.0)
    show(0.0000000001, 0.0000000001)
    show(-0.0000000001, 0.0000000001)
    show(9.75, 5.93)
    show(10000.0, 99999.0)
  end
end
Main.main()
