# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def panic(msg) do
    try do
      IO.puts(msg)
    catch
      {:return, val} -> val
    end
  end
  def trim_spaces(s) do
    try do
      start = 0
      end_ = _len(s) - 1
      while_fun = fn while_fun, start ->
        if start <= end_ && _slice(s, start, start + 1 - (start)) == " " do
          start = start + 1
          while_fun.(while_fun, start)
        else
          start
        end
      end
      start = try do
          while_fun.(while_fun, start)
        catch
          {:break, {start}} -> start
        end

      while_fun_2 = fn while_fun_2, end_ ->
        if end_ >= start && _slice(s, end_, end_ + 1 - (end_)) == " " do
          end_ = end_ - 1
          while_fun_2.(while_fun_2, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_2.(while_fun_2, end_)
        catch
          {:break, {end_}} -> end_
        end

      if start > end_ do
        throw {:return, ""}
      end
      throw {:return, _slice(s, start, end_ + 1 - (start))}
    catch
      {:return, val} -> val
    end
  end
  def char_to_digit(ch) do
    try do
      if ch == "0" do
        throw {:return, 0}
      end
      if ch == "1" do
        throw {:return, 1}
      end
      if ch == "2" do
        throw {:return, 2}
      end
      if ch == "3" do
        throw {:return, 3}
      end
      if ch == "4" do
        throw {:return, 4}
      end
      if ch == "5" do
        throw {:return, 5}
      end
      if ch == "6" do
        throw {:return, 6}
      end
      if ch == "7" do
        throw {:return, 7}
      end
      panic("Non-octal value was passed to the function")
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def oct_to_decimal(oct_string) do
    try do
      s = trim_spaces(oct_string)
      if _len(s) == 0 do
        panic("Empty string was passed to the function")
        throw {:return, 0}
      end
      is_negative = false
      {is_negative, s} = if _slice(s, 0, 1 - (0)) == "-" do
        is_negative = true
        s = _slice(s, 1, _len(s) - (1))
        {is_negative, s}
      else
        {is_negative, s}
      end
      if _len(s) == 0 do
        panic("Non-octal value was passed to the function")
        throw {:return, 0}
      end
      decimal_number = 0
      i = 0
      while_fun_3 = fn while_fun_3, decimal_number, i ->
        if i < _len(s) do
          ch = _slice(s, i, i + 1 - (i))
          digit = char_to_digit(ch)
          decimal_number = 8 * decimal_number + digit
          i = i + 1
          while_fun_3.(while_fun_3, decimal_number, i)
        else
          {decimal_number, i}
        end
      end
      {decimal_number, i} = try do
          while_fun_3.(while_fun_3, decimal_number, i)
        catch
          {:break, {decimal_number, i}} -> {decimal_number, i}
        end

      {decimal_number} = if is_negative do
        decimal_number = -decimal_number
        {decimal_number}
      else
        {decimal_number}
      end
      throw {:return, decimal_number}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(oct_to_decimal("1")))
      IO.puts(Kernel.inspect(oct_to_decimal("-1")))
      IO.puts(Kernel.inspect(oct_to_decimal("12")))
      IO.puts(Kernel.inspect(oct_to_decimal(" 12   ")))
      IO.puts(Kernel.inspect(oct_to_decimal("-45")))
      IO.puts(Kernel.inspect(oct_to_decimal("0")))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
