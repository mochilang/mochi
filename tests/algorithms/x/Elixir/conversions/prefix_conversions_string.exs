# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow(base, exp) do
    try do
      result = 1.0
      e = exp
      {e, result} = if e < 0 do
        e = -e
        i = 0
        while_fun = fn while_fun, i, result ->
          if i < e do
            result = result * base
            i = i + 1
            while_fun.(while_fun, i, result)
          else
            {i, result}
          end
        end
        {i, result} = try do
            while_fun.(while_fun, i, result)
          catch
            {:break, {i, result}} -> {i, result}
          end

        throw {:return, 1.0 / result}
        {e, result}
      else
        {e, result}
      end
      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < e do
          result = result * base
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def add_si_prefix(value) do
    try do
      prefixes = nil
      prefixes = (if value > 0.0, do: Process.get(:si_positive), else: Process.get(:si_negative))
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(prefixes) do
          p = Enum.at(prefixes, i)
          num = value / pow(10.0, p.exp)
          if num > 1.0 do
            throw {:return, ((Kernel.inspect(num) <> " ") <> p.name)}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, Kernel.to_string(value)}
    catch
      {:return, val} -> val
    end
  end
  def add_binary_prefix(value) do
    try do
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(Process.get(:binary_prefixes)) do
          p = Enum.at(Process.get(:binary_prefixes), i)
          num = value / pow(2.0, p.exp)
          if num > 1.0 do
            throw {:return, ((Kernel.inspect(num) <> " ") <> p.name)}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, Kernel.to_string(value)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:si_positive, [%{name: "yotta", exp: 24}, %{name: "zetta", exp: 21}, %{name: "exa", exp: 18}, %{name: "peta", exp: 15}, %{name: "tera", exp: 12}, %{name: "giga", exp: 9}, %{name: "mega", exp: 6}, %{name: "kilo", exp: 3}, %{name: "hecto", exp: 2}, %{name: "deca", exp: 1}])
  Process.put(:binary_prefixes, [%{name: "yotta", exp: 80}, %{name: "zetta", exp: 70}, %{name: "exa", exp: 60}, %{name: "peta", exp: 50}, %{name: "tera", exp: 40}, %{name: "giga", exp: 30}, %{name: "mega", exp: 20}, %{name: "kilo", exp: 10}])
  def main() do
    Process.put(:si_negative, [%{name: "deci", exp: -1}, %{name: "centi", exp: -2}, %{name: "milli", exp: -3}, %{name: "micro", exp: -6}, %{name: "nano", exp: -9}, %{name: "pico", exp: -12}, %{name: "femto", exp: -15}, %{name: "atto", exp: -18}, %{name: "zepto", exp: -21}, %{name: "yocto", exp: -24}])
    IO.puts(Kernel.inspect(add_si_prefix(10000.0)))
    IO.puts(Kernel.inspect(add_si_prefix(0.005)))
    IO.puts(Kernel.inspect(add_binary_prefix(65536.0)))
    IO.puts(Kernel.inspect(add_binary_prefix(512.0)))
  end
end
Main.main()
