# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def fmod(a, b) do
    try do
      throw {:return, a - b * Kernel.trunc(a / b)}
    catch
      {:return, val} -> val
    end
  end
  def roundf(x) do
    try do
      throw {:return, ((if x >= 0.0, do: Kernel.trunc(x + 0.5), else: Kernel.trunc(x - 0.5)))}
    catch
      {:return, val} -> val
    end
  end
  def maxf(a, b, c) do
    try do
      m = a
      {m} = if b > m do
        m = b
        {m}
      else
        {m}
      end
      {m} = if c > m do
        m = c
        {m}
      else
        {m}
      end
      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def minf(a, b, c) do
    try do
      m = a
      {m} = if b < m do
        m = b
        {m}
      else
        {m}
      end
      {m} = if c < m do
        m = c
        {m}
      else
        {m}
      end
      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def hsv_to_rgb(hue, saturation, value) do
    try do
      if hue < 0.0 || hue > 360.0 do
        IO.puts("hue should be between 0 and 360")
        throw {:return, []}
      end
      if saturation < 0.0 || saturation > 1.0 do
        IO.puts("saturation should be between 0 and 1")
        throw {:return, []}
      end
      if value < 0.0 || value > 1.0 do
        IO.puts("value should be between 0 and 1")
        throw {:return, []}
      end
      chroma = value * saturation
      hue_section = hue / 60.0
      second_largest_component = chroma * (1.0 - absf(fmod(hue_section, 2.0) - 1.0))
      match_value = value - chroma
      red = 0
      green = 0
      blue = 0
      {blue, green, red} = if hue_section >= 0.0 && hue_section <= 1.0 do
        red = roundf(255.0 * (chroma + match_value))
        green = roundf(255.0 * (second_largest_component + match_value))
        blue = roundf(255.0 * match_value)
        {blue, green, red}
      else
        {blue, green, red} = if hue_section > 1.0 && hue_section <= 2.0 do
          red = roundf(255.0 * (second_largest_component + match_value))
          green = roundf(255.0 * (chroma + match_value))
          blue = roundf(255.0 * match_value)
          {blue, green, red}
        else
          {blue, green, red} = if hue_section > 2.0 && hue_section <= 3.0 do
            red = roundf(255.0 * match_value)
            green = roundf(255.0 * (chroma + match_value))
            blue = roundf(255.0 * (second_largest_component + match_value))
            {blue, green, red}
          else
            {blue, green, red} = if hue_section > 3.0 && hue_section <= 4.0 do
              red = roundf(255.0 * match_value)
              green = roundf(255.0 * (second_largest_component + match_value))
              blue = roundf(255.0 * (chroma + match_value))
              {blue, green, red}
            else
              {blue, green, red} = if hue_section > 4.0 && hue_section <= 5.0 do
                red = roundf(255.0 * (second_largest_component + match_value))
                green = roundf(255.0 * match_value)
                blue = roundf(255.0 * (chroma + match_value))
                {blue, green, red}
              else
                red = roundf(255.0 * (chroma + match_value))
                green = roundf(255.0 * match_value)
                blue = roundf(255.0 * (second_largest_component + match_value))
                {blue, green, red}
              end
              {blue, green, red}
            end
            {blue, green, red}
          end
          {blue, green, red}
        end
        {blue, green, red}
      end
      throw {:return, [red, green, blue]}
    catch
      {:return, val} -> val
    end
  end
  def rgb_to_hsv(red, green, blue) do
    try do
      if red < 0 || red > 255 do
        IO.puts("red should be between 0 and 255")
        throw {:return, []}
      end
      if green < 0 || green > 255 do
        IO.puts("green should be between 0 and 255")
        throw {:return, []}
      end
      if blue < 0 || blue > 255 do
        IO.puts("blue should be between 0 and 255")
        throw {:return, []}
      end
      float_red = red / 255.0
      float_green = green / 255.0
      float_blue = blue / 255.0
      value = maxf(float_red, float_green, float_blue)
      min_val = minf(float_red, float_green, float_blue)
      chroma = value - min_val
      saturation = (if value == 0.0, do: 0.0, else: chroma / value)
      hue = nil
      {hue} = if chroma == 0.0 do
        hue = 0.0
        {hue}
      else
        {hue} = if value == float_red do
          hue = 60.0 * (0.0 + (float_green - float_blue) / chroma)
          {hue}
        else
          {hue} = if value == float_green do
            hue = 60.0 * (2.0 + (float_blue - float_red) / chroma)
            {hue}
          else
            hue = 60.0 * (4.0 + (float_red - float_green) / chroma)
            {hue}
          end
          {hue}
        end
        {hue}
      end
      hue = fmod(hue + 360.0, 360.0)
      throw {:return, [hue, saturation, value]}
    catch
      {:return, val} -> val
    end
  end
  def approximately_equal_hsv(hsv1, hsv2) do
    try do
      check_hue = absf(Enum.at(hsv1, 0) - Enum.at(hsv2, 0)) < 0.2
      check_saturation = absf(Enum.at(hsv1, 1) - Enum.at(hsv2, 1)) < 0.002
      check_value = absf(Enum.at(hsv1, 2) - Enum.at(hsv2, 2)) < 0.002
      throw {:return, check_hue && check_saturation && check_value}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:rgb, hsv_to_rgb(180.0, 0.5, 0.5))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:rgb)])), ",", " "))
    Process.put(:hsv, rgb_to_hsv(64, 128, 128))
    IO.puts(Kernel.to_string(Process.get(:hsv)))
    IO.puts(Kernel.inspect(approximately_equal_hsv(Process.get(:hsv), [180.0, 0.5, 0.5])))
  end
end
Main.main()
