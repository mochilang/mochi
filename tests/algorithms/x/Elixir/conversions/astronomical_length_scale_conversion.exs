# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sanitize(unit) do
    try do
      res = String.downcase(unit)
      {res} = if _len(res) > 0 do
        last = _slice(res, _len(res) - 1, _len(res) - (_len(res) - 1))
        {res} = if last == "s" do
          res = _slice(res, 0, _len(res) - 1 - (0))
          {res}
        else
          {res}
        end
        {res}
      else
        {res}
      end
      if Map.has_key?(Process.get(:unit_symbol), res) do
        throw {:return, Map.get(Process.get(:unit_symbol), res, "")}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def pow10(exp) do
    try do
      if exp == 0 do
        throw {:return, 1.0}
      end
      e = exp
      res = 1.0
      {e} = if e < 0 do
        e = -e
        {e}
      else
        {e}
      end
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < e do
          res = res * 10.0
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      if exp < 0 do
        throw {:return, 1.0 / res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def length_conversion(value, from_type, to_type) do
    try do
      from_sanitized = sanitize(from_type)
      to_sanitized = sanitize(to_type)
      if !(Map.has_key?(Process.get(:metric_conversion), from_sanitized)) do
        raise(((("Invalid 'from_type' value: '" <> from_type) <> "'.\nConversion abbreviations are: ") <> Process.get(:abbreviations)))
      end
      if !(Map.has_key?(Process.get(:metric_conversion), to_sanitized)) do
        raise(((("Invalid 'to_type' value: '" <> to_type) <> "'.\nConversion abbreviations are: ") <> Process.get(:abbreviations)))
      end
      from_exp = Process.get(:metric_conversion)[from_sanitized]
      to_exp = Process.get(:metric_conversion)[to_sanitized]
      exponent = 0
      exponent = (if from_exp > to_exp, do: from_exp - to_exp, else: -(to_exp - from_exp))
      throw {:return, value * pow10(exponent)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:unit_symbol, %{"meter" => "m", "kilometer" => "km", "megametre" => "Mm", "gigametre" => "Gm", "terametre" => "Tm", "petametre" => "Pm", "exametre" => "Em", "zettametre" => "Zm", "yottametre" => "Ym"})
  Process.put(:metric_conversion, %{"m" => 0, "km" => 3, "Mm" => 6, "Gm" => 9, "Tm" => 12, "Pm" => 15, "Em" => 18, "Zm" => 21, "Ym" => 24})
  Process.put(:abbreviations, "m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym")
  def main() do
    IO.puts(Kernel.inspect(length_conversion(1.0, "meter", "kilometer")))
    IO.puts(Kernel.inspect(length_conversion(1.0, "meter", "megametre")))
    IO.puts(Kernel.inspect(length_conversion(1.0, "gigametre", "meter")))
    IO.puts(Kernel.inspect(length_conversion(1.0, "terametre", "zettametre")))
    IO.puts(Kernel.inspect(length_conversion(1.0, "yottametre", "zettametre")))
  end
end
Main.main()
