# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def strip(s) do
    try do
      start = 0
      end_ = _len(s)
      while_fun = fn while_fun, start ->
        if start < end_ && _slice(s, start, start + 1 - (start)) == " " do
          start = start + 1
          while_fun.(while_fun, start)
        else
          start
        end
      end
      start = try do
          while_fun.(while_fun, start)
        catch
          {:break, {start}} -> start
        end

      while_fun_2 = fn while_fun_2, end_ ->
        if end_ > start && _slice(s, end_ - 1, end_ - (end_ - 1)) == " " do
          end_ = end_ - 1
          while_fun_2.(while_fun_2, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_2.(while_fun_2, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - (start))}
    catch
      {:return, val} -> val
    end
  end
  def hex_digit_value(c) do
    try do
      if c == "0" do
        throw {:return, 0}
      end
      if c == "1" do
        throw {:return, 1}
      end
      if c == "2" do
        throw {:return, 2}
      end
      if c == "3" do
        throw {:return, 3}
      end
      if c == "4" do
        throw {:return, 4}
      end
      if c == "5" do
        throw {:return, 5}
      end
      if c == "6" do
        throw {:return, 6}
      end
      if c == "7" do
        throw {:return, 7}
      end
      if c == "8" do
        throw {:return, 8}
      end
      if c == "9" do
        throw {:return, 9}
      end
      if c == "a" || c == "A" do
        throw {:return, 10}
      end
      if c == "b" || c == "B" do
        throw {:return, 11}
      end
      if c == "c" || c == "C" do
        throw {:return, 12}
      end
      if c == "d" || c == "D" do
        throw {:return, 13}
      end
      if c == "e" || c == "E" do
        throw {:return, 14}
      end
      if c == "f" || c == "F" do
        throw {:return, 15}
      end
      IO.puts("Non-hexadecimal value was passed to the function")
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def hex_to_decimal(hex_string) do
    try do
      s = strip(hex_string)
      if _len(s) == 0 do
        IO.puts("Empty string was passed to the function")
        throw {:return, 0}
      end
      is_negative = false
      {is_negative, s} = if _slice(s, 0, 1 - (0)) == "-" do
        is_negative = true
        s = _slice(s, 1, _len(s) - (1))
        {is_negative, s}
      else
        {is_negative, s}
      end
      decimal_number = 0
      i = 0
      while_fun_3 = fn while_fun_3, decimal_number, i ->
        if i < _len(s) do
          c = _slice(s, i, i + 1 - (i))
          value = hex_digit_value(c)
          decimal_number = 16 * decimal_number + value
          i = i + 1
          while_fun_3.(while_fun_3, decimal_number, i)
        else
          {decimal_number, i}
        end
      end
      {decimal_number, i} = try do
          while_fun_3.(while_fun_3, decimal_number, i)
        catch
          {:break, {decimal_number, i}} -> {decimal_number, i}
        end

      if is_negative do
        throw {:return, -decimal_number}
      end
      throw {:return, decimal_number}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(hex_to_decimal("a")))
      IO.puts(Kernel.inspect(hex_to_decimal("12f")))
      IO.puts(Kernel.inspect(hex_to_decimal("   12f   ")))
      IO.puts(Kernel.inspect(hex_to_decimal("FfFf")))
      IO.puts(Kernel.inspect(hex_to_decimal("-Ff")))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
