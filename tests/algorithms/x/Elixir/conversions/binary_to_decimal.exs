# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def trim(s) do
    try do
      start = 0
      while_fun = fn while_fun, start ->
        if start < _len(s) do
          ch = _slice(s, start, (start + 1) - start)
          if ch != " " && ch != "\n" && ch != "\t" && ch != "\r" do
            throw {:break, {start}}
          end
          start = start + 1
          while_fun.(while_fun, start)
        else
          start
        end
      end
      start = try do
          while_fun.(while_fun, start)
        catch
          {:break, {start}} -> start
        end

      end_ = _len(s)
      while_fun_2 = fn while_fun_2, end_ ->
        if end_ > start do
          ch = _slice(s, end_ - 1, end_ - (end_ - 1))
          if ch != " " && ch != "\n" && ch != "\t" && ch != "\r" do
            throw {:break, {end_}}
          end
          end_ = end_ - 1
          while_fun_2.(while_fun_2, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_2.(while_fun_2, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - (start))}
    catch
      {:return, val} -> val
    end
  end
  def bin_to_decimal(bin_string) do
    try do
      trimmed = trim(bin_string)
      if trimmed == "" do
        raise("Empty string was passed to the function")
      end
      is_negative = false
      s = trimmed
      {is_negative, s} = if _slice(s, 0, 1 - 0) == "-" do
        is_negative = true
        s = _slice(s, 1, _len(s) - (1))
        {is_negative, s}
      else
        {is_negative, s}
      end
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(s) do
          c = _slice(s, i, (i + 1) - i)
          if c != "0" && c != "1" do
            raise("Non-binary value was passed to the function")
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      decimal_number = 0
      i = 0
      while_fun_4 = fn while_fun_4, decimal_number, i ->
        if i < _len(s) do
          c = _slice(s, i, (i + 1) - i)
          digit = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(c)
          decimal_number = 2 * decimal_number + digit
          i = i + 1
          while_fun_4.(while_fun_4, decimal_number, i)
        else
          {decimal_number, i}
        end
      end
      {decimal_number, i} = try do
          while_fun_4.(while_fun_4, decimal_number, i)
        catch
          {:break, {decimal_number, i}} -> {decimal_number, i}
        end

      if is_negative do
        throw {:return, -decimal_number}
      end
      throw {:return, decimal_number}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(bin_to_decimal("101")))
    IO.puts(Kernel.inspect(bin_to_decimal(" 1010   ")))
    IO.puts(Kernel.inspect(bin_to_decimal("-11101")))
    IO.puts(Kernel.inspect(bin_to_decimal("0")))
  end
end
Main.main()
