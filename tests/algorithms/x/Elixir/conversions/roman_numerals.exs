# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def char_value(c) do
    try do
      if c == "I" do
        throw {:return, 1}
      end
      if c == "V" do
        throw {:return, 5}
      end
      if c == "X" do
        throw {:return, 10}
      end
      if c == "L" do
        throw {:return, 50}
      end
      if c == "C" do
        throw {:return, 100}
      end
      if c == "D" do
        throw {:return, 500}
      end
      if c == "M" do
        throw {:return, 1000}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def roman_to_int(roman) do
    try do
      total = 0
      i = 0
      while_fun = fn while_fun, i, total ->
        if i < _len(roman) do
          {i, total} = if i + 1 < _len(roman) && char_value(String.at(roman, i)) < char_value(String.at(roman, i + 1)) do
            total = total + char_value(String.at(roman, i + 1)) - char_value(String.at(roman, i))
            i = i + 2
            {i, total}
          else
            total = total + char_value(String.at(roman, i))
            i = i + 1
            {i, total}
          end
          while_fun.(while_fun, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun.(while_fun, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def int_to_roman(number) do
    try do
      num = number
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, num, res ->
        if i < _len(Process.get(:roman_values)) do
          value = Enum.at(Process.get(:roman_values), i)
          symbol = Enum.at(Process.get(:roman_symbols), i)
          factor = div(num, value)
          num = rem(num, value)
          j = 0
          while_fun_3 = fn while_fun_3, j, res ->
            if j < factor do
              res = (res <> symbol)
              j = j + 1
              while_fun_3.(while_fun_3, j, res)
            else
              {j, res}
            end
          end
          {j, res} = try do
              while_fun_3.(while_fun_3, j, res)
            catch
              {:break, {j, res}} -> {j, res}
            end

          if num == 0 do
            throw {:break, {i, num, res}}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, num, res)
        else
          {i, num, res}
        end
      end
      {i, num, res} = try do
          while_fun_2.(while_fun_2, i, num, res)
        catch
          {:break, {i, num, res}} -> {i, num, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:roman_values, [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1])
  Process.put(:roman_symbols, ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"])
  def main() do
  end
end
Main.main()
