# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def panic(msg) do
    try do
      IO.puts(msg)
    catch
      {:return, val} -> val
    end
  end
  def trim_spaces(s) do
    try do
      start = 0
      end_ = _len(s)
      while_fun = fn while_fun, start ->
        if start < end_ && _slice(s, start, start + 1 - (start)) == " " do
          start = start + 1
          while_fun.(while_fun, start)
        else
          start
        end
      end
      start = try do
          while_fun.(while_fun, start)
        catch
          {:break, {start}} -> start
        end

      while_fun_2 = fn while_fun_2, end_ ->
        if end_ > start && _slice(s, end_ - 1, end_ - (end_ - 1)) == " " do
          end_ = end_ - 1
          while_fun_2.(while_fun_2, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_2.(while_fun_2, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - (start))}
    catch
      {:return, val} -> val
    end
  end
  def hex_digit_value(ch) do
    try do
      if ch == "0" do
        throw {:return, 0}
      end
      if ch == "1" do
        throw {:return, 1}
      end
      if ch == "2" do
        throw {:return, 2}
      end
      if ch == "3" do
        throw {:return, 3}
      end
      if ch == "4" do
        throw {:return, 4}
      end
      if ch == "5" do
        throw {:return, 5}
      end
      if ch == "6" do
        throw {:return, 6}
      end
      if ch == "7" do
        throw {:return, 7}
      end
      if ch == "8" do
        throw {:return, 8}
      end
      if ch == "9" do
        throw {:return, 9}
      end
      if ch == "a" || ch == "A" do
        throw {:return, 10}
      end
      if ch == "b" || ch == "B" do
        throw {:return, 11}
      end
      if ch == "c" || ch == "C" do
        throw {:return, 12}
      end
      if ch == "d" || ch == "D" do
        throw {:return, 13}
      end
      if ch == "e" || ch == "E" do
        throw {:return, 14}
      end
      if ch == "f" || ch == "F" do
        throw {:return, 15}
      end
      panic("Invalid value was passed to the function")
    catch
      {:return, val} -> val
    end
  end
  def hex_to_bin(hex_num) do
    try do
      trimmed = trim_spaces(hex_num)
      if _len(trimmed) == 0 do
        panic("No value was passed to the function")
      end
      s = trimmed
      is_negative = false
      {is_negative, s} = if _slice(s, 0, 1 - (0)) == "-" do
        is_negative = true
        s = _slice(s, 1, _len(s) - (1))
        {is_negative, s}
      else
        {is_negative, s}
      end
      int_num = 0
      i = 0
      while_fun_3 = fn while_fun_3, i, int_num ->
        if i < _len(s) do
          ch = _slice(s, i, i + 1 - (i))
          val = hex_digit_value(ch)
          int_num = int_num * 16 + val
          i = i + 1
          while_fun_3.(while_fun_3, i, int_num)
        else
          {i, int_num}
        end
      end
      {i, int_num} = try do
          while_fun_3.(while_fun_3, i, int_num)
        catch
          {:break, {i, int_num}} -> {i, int_num}
        end

      bin_str = ""
      n = int_num
      {bin_str} = if n == 0 do
        bin_str = "0"
        {bin_str}
      else
        {bin_str}
      end
      while_fun_4 = fn while_fun_4, bin_str, n ->
        if n > 0 do
          bin_str = (Kernel.to_string(rem(n, 2)) <> bin_str)
          n = div(n, 2)
          while_fun_4.(while_fun_4, bin_str, n)
        else
          {bin_str, n}
        end
      end
      {bin_str, n} = try do
          while_fun_4.(while_fun_4, bin_str, n)
        catch
          {:break, {bin_str, n}} -> {bin_str, n}
        end

      result = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(bin_str)
      {result} = if is_negative do
        result = -result
        {result}
      else
        {result}
      end
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(hex_to_bin("AC")))
    IO.puts(Kernel.inspect(hex_to_bin("9A4")))
    IO.puts(Kernel.inspect(hex_to_bin("   12f   ")))
    IO.puts(Kernel.inspect(hex_to_bin("FfFf")))
    IO.puts(Kernel.inspect(hex_to_bin("-fFfF")))
  end
end
Main.main()
