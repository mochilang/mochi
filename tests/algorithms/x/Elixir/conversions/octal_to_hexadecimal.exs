# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def octal_to_hex(octal) do
    try do
      s = octal
      {s} = if _len(s) >= 2 && String.at(s, 0) == "0" && String.at(s, 1) == "o" do
        s = _slice(s, 2, _len(s) - (2))
        {s}
      else
        {s}
      end
      if _len(s) == 0 do
        raise("Empty string was passed to the function")
      end
      j = 0
      while_fun = fn while_fun, j ->
        if j < _len(s) do
          c = String.at(s, j)
          if c != "0" && c != "1" && c != "2" && c != "3" && c != "4" && c != "5" && c != "6" && c != "7" do
            raise("Not a Valid Octal Number")
          end
          j = j + 1
          while_fun.(while_fun, j)
        else
          j
        end
      end
      j = try do
          while_fun.(while_fun, j)
        catch
          {:break, {j}} -> j
        end

      decimal = 0
      k = 0
      while_fun_2 = fn while_fun_2, decimal, k ->
        if k < _len(s) do
          d = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(String.at(s, k))
          decimal = decimal * 8 + d
          k = k + 1
          while_fun_2.(while_fun_2, decimal, k)
        else
          {decimal, k}
        end
      end
      {decimal, k} = try do
          while_fun_2.(while_fun_2, decimal, k)
        catch
          {:break, {decimal, k}} -> {decimal, k}
        end

      hex_chars = "0123456789ABCDEF"
      if decimal == 0 do
        throw {:return, "0x"}
      end
      hex = ""
      while_fun_3 = fn while_fun_3, decimal, hex ->
        if decimal > 0 do
          idx = rem(decimal, 16)
          hex = (String.at(hex_chars, idx) <> hex)
          decimal = div(decimal, 16)
          while_fun_3.(while_fun_3, decimal, hex)
        else
          {decimal, hex}
        end
      end
      {decimal, hex} = try do
          while_fun_3.(while_fun_3, decimal, hex)
        catch
          {:break, {decimal, hex}} -> {decimal, hex}
        end

      throw {:return, ("0x" <> hex)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:nums, ["030", "100", "247", "235", "007"])
  Process.put(:t, 0)
  def main() do
    while_fun_4 = fn while_fun_4 ->
      if Process.get(:t) < _len(Process.get(:nums)) do
        num = Enum.at(Process.get(:nums), Process.get(:t))
        IO.puts(Kernel.inspect(octal_to_hex(num)))
        Process.put(:t, Process.get(:t) + 1)
        while_fun_4.(while_fun_4)
      else
        nil
      end
    end
    try do
      while_fun_4.(while_fun_4)
    catch
      :break -> nil
    end

  end
end
Main.main()
