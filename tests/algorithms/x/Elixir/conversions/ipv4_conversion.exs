# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def split_by_dot(s) do
    try do
      res = []
      current = ""
      i = 0
      while_fun = fn while_fun, current, i, res ->
        if i < _len(s) do
          c = String.at(s, i)
          {current, res} = if c == "." do
            res = (res ++ [current])
            current = ""
            {current, res}
          else
            current = (current <> c)
            {current, res}
          end
          i = i + 1
          while_fun.(while_fun, current, i, res)
        else
          {current, i, res}
        end
      end
      {current, i, res} = try do
          while_fun.(while_fun, current, i, res)
        catch
          {:break, {current, i, res}} -> {current, i, res}
        end

      res = (res ++ [current])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def parse_decimal(s) do
    try do
      if _len(s) == 0 do
        raise("Invalid IPv4 address format")
      end
      value = 0
      i = 0
      while_fun_2 = fn while_fun_2, i, value ->
        if i < _len(s) do
          c = String.at(s, i)
          if c < "0" || c > "9" do
            raise("Invalid IPv4 address format")
          end
          value = value * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(c))
          i = i + 1
          while_fun_2.(while_fun_2, i, value)
        else
          {i, value}
        end
      end
      {i, value} = try do
          while_fun_2.(while_fun_2, i, value)
        catch
          {:break, {i, value}} -> {i, value}
        end

      throw {:return, value}
    catch
      {:return, val} -> val
    end
  end
  def to_hex2(n) do
    try do
      x = n
      res = ""
      while_fun_3 = fn while_fun_3, res, x ->
        if x > 0 do
          d = rem(x, 16)
          res = (String.at(Process.get(:hex_digits), d) <> res)
          x = div(x, 16)
          while_fun_3.(while_fun_3, res, x)
        else
          {res, x}
        end
      end
      {res, x} = try do
          while_fun_3.(while_fun_3, res, x)
        catch
          {:break, {res, x}} -> {res, x}
        end

      while_fun_4 = fn while_fun_4, res ->
        if _len(res) < 2 do
          res = ("0" <> res)
          while_fun_4.(while_fun_4, res)
        else
          res
        end
      end
      res = try do
          while_fun_4.(while_fun_4, res)
        catch
          {:break, {res}} -> res
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def ipv4_to_decimal(ipv4_address) do
    try do
      parts = split_by_dot(ipv4_address)
      if _len(parts) != 4 do
        raise("Invalid IPv4 address format")
      end
      result = 0
      i = 0
      while_fun_5 = fn while_fun_5, i, result ->
        if i < 4 do
          oct = parse_decimal(Enum.at(parts, i))
          if oct < 0 || oct > 255 do
            raise(("Invalid IPv4 octet " <> Kernel.to_string(oct)))
          end
          result = result * 256 + oct
          i = i + 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def alt_ipv4_to_decimal(ipv4_address) do
    try do
      parts = split_by_dot(ipv4_address)
      if _len(parts) != 4 do
        raise("Invalid IPv4 address format")
      end
      hex_str = ""
      i = 0
      while_fun_6 = fn while_fun_6, hex_str, i ->
        if i < 4 do
          oct = parse_decimal(Enum.at(parts, i))
          if oct < 0 || oct > 255 do
            raise(("Invalid IPv4 octet " <> Kernel.to_string(oct)))
          end
          hex_str = (hex_str <> to_hex2(oct))
          i = i + 1
          while_fun_6.(while_fun_6, hex_str, i)
        else
          {hex_str, i}
        end
      end
      {hex_str, i} = try do
          while_fun_6.(while_fun_6, hex_str, i)
        catch
          {:break, {hex_str, i}} -> {hex_str, i}
        end

      value = 0
      k = 0
      while_fun_7 = fn while_fun_7, k, value ->
        if k < _len(hex_str) do
          c = String.at(hex_str, k)
          digit = 0 - 1
          j = 0
          while_fun_8 = fn while_fun_8, digit, j ->
            if j < _len(Process.get(:hex_digits)) do
              {digit} = if String.at(Process.get(:hex_digits), j) == c do
                digit = j
                {digit}
              else
                {digit}
              end
              j = j + 1
              while_fun_8.(while_fun_8, digit, j)
            else
              {digit, j}
            end
          end
          {digit, j} = try do
              while_fun_8.(while_fun_8, digit, j)
            catch
              {:break, {digit, j}} -> {digit, j}
            end

          if digit < 0 do
            raise("Invalid hex digit")
          end
          value = value * 16 + digit
          k = k + 1
          while_fun_7.(while_fun_7, k, value)
        else
          {k, value}
        end
      end
      {k, value} = try do
          while_fun_7.(while_fun_7, k, value)
        catch
          {:break, {k, value}} -> {k, value}
        end

      throw {:return, value}
    catch
      {:return, val} -> val
    end
  end
  def decimal_to_ipv4(decimal_ipv4) do
    try do
      if decimal_ipv4 < 0 || decimal_ipv4 > 4294967295 do
        raise("Invalid decimal IPv4 address")
      end
      n = decimal_ipv4
      parts = []
      i = 0
      while_fun_9 = fn while_fun_9, i, n, parts ->
        if i < 4 do
          octet = rem(n, 256)
          parts = (parts ++ [Kernel.to_string(octet)])
          n = div(n, 256)
          i = i + 1
          while_fun_9.(while_fun_9, i, n, parts)
        else
          {i, n, parts}
        end
      end
      {i, n, parts} = try do
          while_fun_9.(while_fun_9, i, n, parts)
        catch
          {:break, {i, n, parts}} -> {i, n, parts}
        end

      res = ""
      j = _len(parts) - 1
      while_fun_10 = fn while_fun_10, j, res ->
        if j >= 0 do
          res = (res <> Enum.at(parts, j))
          {res} = if j > 0 do
            res = (res <> ".")
            {res}
          else
            {res}
          end
          j = j - 1
          while_fun_10.(while_fun_10, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_10.(while_fun_10, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:hex_digits, "0123456789abcdef")
  def main() do
    IO.puts(Kernel.inspect(ipv4_to_decimal("192.168.0.1")))
    IO.puts(Kernel.inspect(ipv4_to_decimal("10.0.0.255")))
    IO.puts(Kernel.inspect(alt_ipv4_to_decimal("192.168.0.1")))
    IO.puts(Kernel.inspect(alt_ipv4_to_decimal("10.0.0.255")))
    IO.puts(Kernel.inspect(decimal_to_ipv4(3232235521)))
    IO.puts(Kernel.inspect(decimal_to_ipv4(167772415)))
  end
end
Main.main()
