# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_graph(vertices, edges, directed) do
    try do
      g = %{directed: directed, vertex_to_index: %{}, adj_matrix: []}
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(vertices) do
          add_vertex(g, Enum.at(vertices, i))
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      j = 0
      while_fun_2 = fn while_fun_2, j ->
        if j < _len(edges) do
          e = Enum.at(edges, j)
          add_edge(g, Enum.at(e, 0), Enum.at(e, 1))
          j = j + 1
          while_fun_2.(while_fun_2, j)
        else
          j
        end
      end
      j = try do
          while_fun_2.(while_fun_2, j)
        catch
          {:break, {j}} -> j
        end

      throw {:return, g}
    catch
      {:return, val} -> val
    end
  end
  def contains_vertex(g, v) do
    try do
      throw {:return, Map.has_key?(g.vertex_to_index, v)}
    catch
      {:return, val} -> val
    end
  end
  def add_vertex(g, v) do
    try do
      if contains_vertex(g, v) do
        raise("vertex already exists")
      end
      matrix = g.adj_matrix
      i = 0
      while_fun_3 = fn while_fun_3, i, matrix ->
        if i < _len(matrix) do
          matrix = List.replace_at(matrix, i, (Enum.at(matrix, i) ++ [0]))
          i = i + 1
          while_fun_3.(while_fun_3, i, matrix)
        else
          {i, matrix}
        end
      end
      {i, matrix} = try do
          while_fun_3.(while_fun_3, i, matrix)
        catch
          {:break, {i, matrix}} -> {i, matrix}
        end

      row = []
      j = 0
      while_fun_4 = fn while_fun_4, j, row ->
        if j < _len(matrix) + 1 do
          row = (row ++ [0])
          j = j + 1
          while_fun_4.(while_fun_4, j, row)
        else
          {j, row}
        end
      end
      {j, row} = try do
          while_fun_4.(while_fun_4, j, row)
        catch
          {:break, {j, row}} -> {j, row}
        end

      matrix = (matrix ++ [row])
      g = Map.put(g, :adj_matrix, matrix)
      idx_map = g.vertex_to_index
      idx_map = Map.put(idx_map, v, _len(matrix) - 1)
      g = Map.put(g, :vertex_to_index, idx_map)
    catch
      {:return, val} -> val
    end
  end
  def remove_key(m, k) do
    try do
      out = %{}
      {out} = Enum.reduce(Map.keys(m), {out}, fn key, {out} ->
        {out} = if key != k do
          out = Map.put(out, key, m[key])
          {out}
        else
          {out}
        end
        {out}
      end)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def decrement_indices(m, start) do
    try do
      out = %{}
      {out} = Enum.reduce(Map.keys(m), {out}, fn key, {out} ->
        idx = m[key]
        out = Map.put(out, key, ((if idx > start, do: idx - 1, else: idx)))
        {out}
      end)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def remove_vertex(g, v) do
    try do
      if !contains_vertex(g, v) do
        raise("vertex does not exist")
      end
      idx = (g.vertex_to_index)[v]
      new_matrix = []
      i = 0
      while_fun_5 = fn while_fun_5, i, new_matrix ->
        if i < _len(Map.get(g, :adj_matrix, [])) do
          {new_matrix} = if i != idx do
            row = Enum.at(g.adj_matrix, i)
            new_row = []
            j = 0
            while_fun_6 = fn while_fun_6, j, new_row ->
              if j < _len(row) do
                {new_row} = if j != idx do
                  new_row = (new_row ++ [Enum.at(row, j)])
                  {new_row}
                else
                  {new_row}
                end
                j = j + 1
                while_fun_6.(while_fun_6, j, new_row)
              else
                {j, new_row}
              end
            end
            {j, new_row} = try do
                while_fun_6.(while_fun_6, j, new_row)
              catch
                {:break, {j, new_row}} -> {j, new_row}
              end

            new_matrix = (new_matrix ++ [new_row])
            {new_matrix}
          else
            {new_matrix}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, new_matrix)
        else
          {i, new_matrix}
        end
      end
      {i, new_matrix} = try do
          while_fun_5.(while_fun_5, i, new_matrix)
        catch
          {:break, {i, new_matrix}} -> {i, new_matrix}
        end

      g = Map.put(g, :adj_matrix, new_matrix)
      m = remove_key(g.vertex_to_index, v)
      g = Map.put(g, :vertex_to_index, decrement_indices(m, idx))
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, u, v) do
    try do
      if !(contains_vertex(g, u) && contains_vertex(g, v)) do
        raise("missing vertex")
      end
      i = (g.vertex_to_index)[u]
      j = (g.vertex_to_index)[v]
      matrix = g.adj_matrix
      matrix = List.replace_at(matrix, i, List.replace_at(Enum.at(matrix, i), j, 1))
      {matrix} = if !g.directed do
        matrix = List.replace_at(matrix, j, List.replace_at(Enum.at(matrix, j), i, 1))
        {matrix}
      else
        {matrix}
      end
      g = Map.put(g, :adj_matrix, matrix)
    catch
      {:return, val} -> val
    end
  end
  def remove_edge(g, u, v) do
    try do
      if !(contains_vertex(g, u) && contains_vertex(g, v)) do
        raise("missing vertex")
      end
      i = (g.vertex_to_index)[u]
      j = (g.vertex_to_index)[v]
      matrix = g.adj_matrix
      matrix = List.replace_at(matrix, i, List.replace_at(Enum.at(matrix, i), j, 0))
      {matrix} = if !g.directed do
        matrix = List.replace_at(matrix, j, List.replace_at(Enum.at(matrix, j), i, 0))
        {matrix}
      else
        {matrix}
      end
      g = Map.put(g, :adj_matrix, matrix)
    catch
      {:return, val} -> val
    end
  end
  def contains_edge(g, u, v) do
    try do
      if !(contains_vertex(g, u) && contains_vertex(g, v)) do
        raise("missing vertex")
      end
      i = (g.vertex_to_index)[u]
      j = (g.vertex_to_index)[v]
      matrix = g.adj_matrix
      throw {:return, Enum.at(Enum.at(matrix, i), j) == 1}
    catch
      {:return, val} -> val
    end
  end
  def clear_graph(g) do
    try do
      g = Map.put(g, :vertex_to_index, %{})
      g = Map.put(g, :adj_matrix, [])
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:g, make_graph([1, 2, 3], [[1, 2], [2, 3]], false))
    IO.puts(Kernel.to_string(Process.get(:g).adj_matrix))
    IO.puts(Kernel.inspect(contains_edge(Process.get(:g), 1, 2)))
    IO.puts(Kernel.inspect(contains_edge(Process.get(:g), 2, 1)))
    remove_edge(Process.get(:g), 1, 2)
    IO.puts(Kernel.inspect(contains_edge(Process.get(:g), 1, 2)))
    remove_vertex(Process.get(:g), 2)
    IO.puts(Kernel.to_string(Process.get(:g).adj_matrix))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
