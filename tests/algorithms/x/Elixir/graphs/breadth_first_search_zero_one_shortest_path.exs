# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_adjacency_list(size) do
    try do
      g = []
      i = 0
      while_fun = fn while_fun, i ->
        if i < size do
          g = (g ++ [[]])
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, %{graph: g, size: size}}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(al, from_vertex, to_vertex, weight) do
    try do
      if !(weight == 0 || weight == 1) do
        raise("Edge weight must be either 0 or 1.")
      end
      if to_vertex < 0 || to_vertex >= al.size do
        raise("Vertex indexes must be in [0; size).")
      end
      g = al.graph
      edges = Enum.at(g, from_vertex)
      g = Map.put(g, from_vertex, (edges ++ [%{destination_vertex: to_vertex, weight: weight}]))
      al = Map.put(al, :graph, g)
    catch
      {:return, val} -> val
    end
  end
  def push_front(q, v) do
    try do
      res = [v]
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(q) do
          res = (res ++ [Enum.at(q, i)])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def pop_front(q) do
    try do
      res = []
      i = 1
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(q) do
          res = (res ++ [Enum.at(q, i)])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def front(q) do
    try do
      throw {:return, Enum.at(q, 0)}
    catch
      {:return, val} -> val
    end
  end
  def get_shortest_path(al, start_vertex, finish_vertex) do
    try do
      queue = [start_vertex]
      distances = []
      i = 0
      while_fun_4 = fn while_fun_4, distances, i ->
        if i < al.size do
          distances = (distances ++ [-1])
          i = i + 1
          while_fun_4.(while_fun_4, distances, i)
        else
          {distances, i}
        end
      end
      {distances, i} = try do
          while_fun_4.(while_fun_4, distances, i)
        catch
          {:break, {distances, i}} -> {distances, i}
        end

      distances = List.replace_at(distances, start_vertex, 0)
      while_fun_5 = fn while_fun_5, distances, queue ->
        if _len(queue) > 0 do
          {distances, queue} = try do
            current_vertex = front(queue)
            queue = pop_front(queue)
            current_distance = Enum.at(distances, current_vertex)
            edges = Enum.at(al.graph, current_vertex)
            j = 0
            while_fun_6 = fn while_fun_6, distances, j, queue ->
              if j < _len(edges) do
                {distances, j, queue} = try do
                  edge = Enum.at(edges, j)
                  new_distance = current_distance + edge.weight
                  dest = edge.destination_vertex
                  dest_distance = Enum.at(distances, dest)
                  {j} = if dest_distance >= 0 && new_distance >= dest_distance do
                    j = j + 1
                    throw {:continue, {distances, j, queue}}
                    {j}
                  else
                    {j}
                  end
                  distances = List.replace_at(distances, dest, new_distance)
                  queue = (if edge.weight == 0, do: push_front(queue, dest), else: (queue ++ [dest]))
                  j = j + 1
                  {distances, j, queue}
                catch
                  {:continue, {distances, j, queue}} -> {distances, j, queue}
                end
                while_fun_6.(while_fun_6, distances, j, queue)
              else
                {distances, j, queue}
              end
            end
            {distances, j, queue} = try do
                while_fun_6.(while_fun_6, distances, j, queue)
              catch
                {:break, {distances, j, queue}} -> {distances, j, queue}
              end

            {distances, queue}
          catch
            {:continue, {distances, queue}} -> {distances, queue}
          end
          while_fun_5.(while_fun_5, distances, queue)
        else
          {distances, queue}
        end
      end
      {distances, queue} = try do
          while_fun_5.(while_fun_5, distances, queue)
        catch
          {:break, {distances, queue}} -> {distances, queue}
        end

      result = Enum.at(distances, finish_vertex)
      if result < 0 do
        raise("No path from start_vertex to finish_vertex.")
      end
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:g, new_adjacency_list(11))
    add_edge(Process.get(:g), 0, 1, 0)
    add_edge(Process.get(:g), 0, 3, 1)
    add_edge(Process.get(:g), 1, 2, 0)
    add_edge(Process.get(:g), 2, 3, 0)
    add_edge(Process.get(:g), 4, 2, 1)
    add_edge(Process.get(:g), 4, 5, 1)
    add_edge(Process.get(:g), 4, 6, 1)
    add_edge(Process.get(:g), 5, 9, 0)
    add_edge(Process.get(:g), 6, 7, 1)
    add_edge(Process.get(:g), 7, 8, 1)
    add_edge(Process.get(:g), 8, 10, 1)
    add_edge(Process.get(:g), 9, 7, 0)
    add_edge(Process.get(:g), 9, 10, 1)
    IO.puts(Kernel.inspect(get_shortest_path(Process.get(:g), 0, 3)))
    IO.puts(Kernel.inspect(get_shortest_path(Process.get(:g), 4, 10)))
    IO.puts(Kernel.inspect(get_shortest_path(Process.get(:g), 4, 8)))
    IO.puts(Kernel.inspect(get_shortest_path(Process.get(:g), 0, 1)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
