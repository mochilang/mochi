# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def make_graph(directed) do
    try do
      m = %{}
      throw {:return, %{adj_list: m, directed: directed}}
    catch
      {:return, val} -> val
    end
  end
  def contains_vertex(m, v) do
    try do
      throw {:return, Map.has_key?(m, v)}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, s, d) do
    try do
      adj = g.adj_list
      {adj} = if !g.directed do
        {adj} = if contains_vertex(adj, s) && contains_vertex(adj, d) do
          adj = Map.put(adj, s, (adj[s] ++ [d]))
          adj = Map.put(adj, d, (adj[d] ++ [s]))
          {adj}
        else
          {adj} = if contains_vertex(adj, s) do
            adj = Map.put(adj, s, (adj[s] ++ [d]))
            adj = Map.put(adj, d, [s])
            {adj}
          else
            {adj} = if contains_vertex(adj, d) do
              adj = Map.put(adj, d, (adj[d] ++ [s]))
              adj = Map.put(adj, s, [d])
              {adj}
            else
              adj = Map.put(adj, s, [d])
              adj = Map.put(adj, d, [s])
              {adj}
            end
            {adj}
          end
          {adj}
        end
        {adj}
      else
        {adj} = if contains_vertex(adj, s) && contains_vertex(adj, d) do
          adj = Map.put(adj, s, (adj[s] ++ [d]))
          {adj}
        else
          {adj} = if contains_vertex(adj, s) do
            adj = Map.put(adj, s, (adj[s] ++ [d]))
            adj = Map.put(adj, d, [])
            {adj}
          else
            {adj} = if contains_vertex(adj, d) do
              adj = Map.put(adj, s, [d])
              {adj}
            else
              adj = Map.put(adj, s, [d])
              adj = Map.put(adj, d, [])
              {adj}
            end
            {adj}
          end
          {adj}
        end
        {adj}
      end
      g = Map.put(g, :adj_list, adj)
      throw {:return, g}
    catch
      {:return, val} -> val
    end
  end
  def graph_to_string(g) do
    try do
      throw {:return, Kernel.inspect(Map.get(g, :adj_list, []))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:d_graph, make_graph(true))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(0), Kernel.to_string(1)))
    IO.puts(Kernel.inspect(graph_to_string(Process.get(:d_graph))))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(1), Kernel.to_string(2)))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(1), Kernel.to_string(4)))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(1), Kernel.to_string(5)))
    IO.puts(Kernel.inspect(graph_to_string(Process.get(:d_graph))))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(2), Kernel.to_string(0)))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(2), Kernel.to_string(6)))
    Process.put(:d_graph, add_edge(Process.get(:d_graph), Kernel.to_string(2), Kernel.to_string(7)))
    IO.puts(Kernel.inspect(graph_to_string(Process.get(:d_graph))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
