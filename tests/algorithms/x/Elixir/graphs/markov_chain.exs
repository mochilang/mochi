# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (1.0 * rand()) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def get_nodes(trans) do
    try do
      seen = %{}
      {seen} = Enum.reduce(trans, {seen}, fn t, {seen} ->
        seen = Map.put(seen, t.src, true)
        seen = Map.put(seen, t.dst, true)
        {seen}
      end)
      nodes = []
      {nodes} = Enum.reduce(Map.keys(seen), {nodes}, fn k, {nodes} ->
        nodes = (nodes ++ [k])
        {nodes}
      end)
      throw {:return, nodes}
    catch
      {:return, val} -> val
    end
  end
  def transition(current, trans) do
    try do
      current_probability = 0.0
      random_value = random()
      {current_probability} = Enum.reduce(trans, {current_probability}, fn t, {current_probability} ->
        {current_probability} = if t.src == current do
          current_probability = current_probability + t.prob
          if current_probability > random_value do
            throw {:return, t.dst}
          end
          {current_probability}
        else
          {current_probability}
        end
        {current_probability}
      end)
      throw {:return, ""}
    catch
      {:return, val} -> val
    end
  end
  def get_transitions(start, trans, steps) do
    try do
      visited = %{}
      {visited} = Enum.reduce(get_nodes(trans), {visited}, fn node_, {visited} ->
        one = 1
        visited = Map.put(visited, node_, one)
        {visited}
      end)
      node_ = start
      i = 0
      while_fun = fn while_fun, i, node_, visited ->
        if i < steps do
          node_ = transition(node_, trans)
          count = visited[node_]
          count = count + 1
          visited = Map.put(visited, node_, count)
          i = i + 1
          while_fun.(while_fun, i, node_, visited)
        else
          {i, node_, visited}
        end
      end
      {i, node_, visited} = try do
          while_fun.(while_fun, i, node_, visited)
        catch
          {:break, {i, node_, visited}} -> {i, node_, visited}
        end

      throw {:return, visited}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      transitions = [%{src: "a", dst: "a", prob: 0.9}, %{src: "a", dst: "b", prob: 0.075}, %{src: "a", dst: "c", prob: 0.025}, %{src: "b", dst: "a", prob: 0.15}, %{src: "b", dst: "b", prob: 0.8}, %{src: "b", dst: "c", prob: 0.05}, %{src: "c", dst: "a", prob: 0.25}, %{src: "c", dst: "b", prob: 0.25}, %{src: "c", dst: "c", prob: 0.5}]
      result = get_transitions("a", transitions, 5000)
      IO.puts(((((Kernel.to_string(result["a"]) <> " ") <> Kernel.to_string(result["b"])) <> " ") <> Kernel.to_string(result["c"])))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
end
Main.main()
