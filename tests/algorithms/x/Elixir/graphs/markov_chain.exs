# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (1.0 * rand()) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def get_nodes(trans) do
    try do
      seen = %{}
      {seen} = Enum.reduce(trans, {seen}, fn t, {seen} ->
        seen = Map.put(seen, t.src, true)
        seen = Map.put(seen, t.dst, true)
        {seen}
      end)
      nodes = []
      {nodes} = Enum.reduce(Map.keys(seen), {nodes}, fn k, {nodes} ->
        nodes = (nodes ++ [k])
        {nodes}
      end)
      throw {:return, nodes}
    catch
      {:return, val} -> val
    end
  end
  def transition(current, trans) do
    try do
      current_probability = 0.0
      random_value = random()
      {current_probability} = Enum.reduce(trans, {current_probability}, fn t, {current_probability} ->
        current_probability = if t.src == current do
          current_probability = current_probability + t.prob
          if current_probability > random_value do
            throw {:return, t.dst}
          end
          current_probability
        else
          current_probability
        end
        {current_probability}
      end)
      throw {:return, ""}
    catch
      {:return, val} -> val
    end
  end
  def get_transitions(start, trans, steps) do
    try do
      visited = %{}
      {visited} = Enum.reduce(get_nodes(trans), {visited}, fn node_, {visited} ->
        one = 1
        visited = Map.put(visited, node_, one)
        {visited}
      end)
      node_ = start
      i = 0
      while_fun = fn while_fun, i, node_, visited ->
        if i < steps do
          node_ = transition(node_, trans)
          count = visited[node_]
          count = count + 1
          visited = Map.put(visited, node_, count)
          i = i + 1
          while_fun.(while_fun, i, node_, visited)
        else
          {i, node_, visited}
        end
      end
      {i, node_, visited} = try do
          while_fun.(while_fun, i, node_, visited)
        catch
          {:break, {i, node_, visited}} -> {i, node_, visited}
        end

      throw {:return, visited}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      transitions = [%{src: "a", dst: "a", prob: 0.9}, %{src: "a", dst: "b", prob: 0.075}, %{src: "a", dst: "c", prob: 0.025}, %{src: "b", dst: "a", prob: 0.15}, %{src: "b", dst: "b", prob: 0.8}, %{src: "b", dst: "c", prob: 0.05}, %{src: "c", dst: "a", prob: 0.25}, %{src: "c", dst: "b", prob: 0.25}, %{src: "c", dst: "c", prob: 0.5}]
      result = get_transitions("a", transitions, 5000)
      IO.puts(((((Kernel.to_string(result["a"]) <> " ") <> Kernel.to_string(result["b"])) <> " ") <> Kernel.to_string(result["c"])))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
