# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def list_to_string(arr) do
    try do
      s = "["
      i = 0
      while_fun = fn while_fun, i, s ->
        if i < _len(arr) do
          s = (s <> Kernel.to_string(Enum.at(arr, i)))
          {s} = if i < _len(arr) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun.(while_fun, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun.(while_fun, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def check_negative_cycle(graph, distance, edge_count) do
    try do
      j = 0
      while_fun_2 = fn while_fun_2, j ->
        if j < edge_count do
          e = Enum.at(graph, j)
          u = e.src
          v = e.dst
          w = :erlang.float(e.weight)
          if Enum.at(distance, u) < Process.get(:inf) && Enum.at(distance, u) + w < Enum.at(distance, v) do
            throw {:return, true}
          end
          j = j + 1
          while_fun_2.(while_fun_2, j)
        else
          j
        end
      end
      j = try do
          while_fun_2.(while_fun_2, j)
        catch
          {:break, {j}} -> j
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def bellman_ford(graph, vertex_count, edge_count, src) do
    try do
      distance = []
      i = 0
      while_fun_3 = fn while_fun_3, distance, i ->
        if i < vertex_count do
          distance = (distance ++ [Process.get(:inf)])
          i = i + 1
          while_fun_3.(while_fun_3, distance, i)
        else
          {distance, i}
        end
      end
      {distance, i} = try do
          while_fun_3.(while_fun_3, distance, i)
        catch
          {:break, {distance, i}} -> {distance, i}
        end

      distance = List.replace_at(distance, src, 0.0)
      k = 0
      while_fun_4 = fn while_fun_4, distance, k ->
        if k < vertex_count - 1 do
          j = 0
          while_fun_5 = fn while_fun_5, distance, j ->
            if j < edge_count do
              e = Enum.at(graph, j)
              u = e.src
              v = e.dst
              w = :erlang.float(e.weight)
              {distance} = if Enum.at(distance, u) < Process.get(:inf) && Enum.at(distance, u) + w < Enum.at(distance, v) do
                distance = List.replace_at(distance, v, Enum.at(distance, u) + w)
                {distance}
              else
                {distance}
              end
              j = j + 1
              while_fun_5.(while_fun_5, distance, j)
            else
              {distance, j}
            end
          end
          {distance, j} = try do
              while_fun_5.(while_fun_5, distance, j)
            catch
              {:break, {distance, j}} -> {distance, j}
            end

          k = k + 1
          while_fun_4.(while_fun_4, distance, k)
        else
          {distance, k}
        end
      end
      {distance, k} = try do
          while_fun_4.(while_fun_4, distance, k)
        catch
          {:break, {distance, k}} -> {distance, k}
        end

      if check_negative_cycle(graph, distance, edge_count) do
        raise("Negative cycle found")
      end
      throw {:return, distance}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:inf, 1000000000.0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:edges, [%{src: 2, dst: 1, weight: -10}, %{src: 3, dst: 2, weight: 3}, %{src: 0, dst: 3, weight: 5}, %{src: 0, dst: 1, weight: 4}])
    Process.put(:distances, bellman_ford(Process.get(:edges), 4, _len(Process.get(:edges)), 0))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:distances))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
