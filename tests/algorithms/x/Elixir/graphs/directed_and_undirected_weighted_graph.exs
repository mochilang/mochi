# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def list_contains_int(xs, x) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(xs) do
          if Enum.at(xs, i) == x do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def edge_exists(edges, w, v) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(edges) do
          if Enum.at(Enum.at(edges, i), 0) == w && Enum.at(Enum.at(edges, i), 1) == v do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def first_key(m) do
    try do
      Enum.each(Map.keys(m), fn k ->
        throw {:return, k}
      end)
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def rand_range(low, high) do
    try do
      throw {:return, (rem(_now(), (high - low))) + low}
    catch
      {:return, val} -> val
    end
  end
  def dg_make_graph() do
    try do
      throw {:return, %{graph: %{}}}
    catch
      {:return, val} -> val
    end
  end
  def dg_add_pair(g, u, v, w) do
    try do
      {g} = if Map.has_key?(g.graph, u) do
        edges = g.graph[u]
        {edges, g} = if !edge_exists(edges, w, v) do
          edges = (edges ++ [[w, v]])
          m = g.graph
          m = Map.put(m, u, edges)
          g = Map.put(g, :graph, m)
          {edges, g}
        else
          {edges, g}
        end
        {g}
      else
        m0 = g.graph
        m0 = Map.put(m0, u, [[w, v]])
        g = Map.put(g, :graph, m0)
        {g}
      end
      {g} = if !(Map.has_key?(g.graph, v)) do
        m1 = g.graph
        m1 = Map.put(m1, v, [])
        g = Map.put(g, :graph, m1)
        {g}
      else
        {g}
      end
    catch
      {:return, val} -> val
    end
  end
  def dg_remove_pair(g, u, v) do
    try do
      {g} = if Map.has_key?(g.graph, u) do
        edges = g.graph[u]
        new_edges = []
        i = 0
        while_fun_3 = fn while_fun_3, i, new_edges ->
          if i < _len(edges) do
            {new_edges} = if Enum.at(Enum.at(edges, i), 1) != v do
              new_edges = (new_edges ++ [Enum.at(edges, i)])
              {new_edges}
            else
              {new_edges}
            end
            i = i + 1
            while_fun_3.(while_fun_3, i, new_edges)
          else
            {i, new_edges}
          end
        end
        {i, new_edges} = try do
            while_fun_3.(while_fun_3, i, new_edges)
          catch
            {:break, {i, new_edges}} -> {i, new_edges}
          end

        m = g.graph
        m = Map.put(m, u, new_edges)
        g = Map.put(g, :graph, m)
        {g}
      else
        {g}
      end
    catch
      {:return, val} -> val
    end
  end
  def dg_all_nodes(g) do
    try do
      res = []
      {res} = Enum.reduce(Map.keys(g.graph), {res}, fn k, {res} ->
        res = (res ++ [k])
        {res}
      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def dg_dfs_util(g, node_, visited, order, d) do
    try do
      visited = Map.put(visited, node_, true)
      order = (order ++ [node_])
      if d != (-1) && node_ == d do
        throw {:return, order}
      end
      edges = g.graph[node_]
      i = 0
      while_fun_4 = fn while_fun_4, i, order ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          {order} = if !(Map.has_key?(visited, neigh)) do
            order = dg_dfs_util(g, neigh, visited, order, d)
            if d != (-1) && Enum.at(order, _len(order) - 1) == d do
              throw {:return, order}
            end
            {order}
          else
            {order}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, order)
        else
          {i, order}
        end
      end
      {i, order} = try do
          while_fun_4.(while_fun_4, i, order)
        catch
          {:break, {i, order}} -> {i, order}
        end

      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def dg_dfs(g, s, d) do
    try do
      if s == d do
        throw {:return, []}
      end
      start = (if s == (-2), do: first_key(Map.get(g, :graph, [])), else: s)
      visited = %{}
      order = []
      order = dg_dfs_util(g, start, visited, order, d)
      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def dg_bfs(g, s) do
    try do
      queue = []
      visited = %{}
      order = []
      start = (if s == (-2), do: first_key(Map.get(g, :graph, [])), else: s)
      queue = (queue ++ [start])
      visited = Map.put(visited, start, true)
      while_fun_5 = fn while_fun_5, order, queue, visited ->
        if _len(queue) > 0 do
          node_ = Enum.at(queue, 0)
          queue = _slice(queue, 1, _len(queue) - 1)
          order = (order ++ [node_])
          edges = g.graph[node_]
          i = 0
          while_fun_6 = fn while_fun_6, i, queue, visited ->
            if i < _len(edges) do
              neigh = Enum.at(Enum.at(edges, i), 1)
              {queue, visited} = if !(Map.has_key?(visited, neigh)) do
                queue = (queue ++ [neigh])
                visited = Map.put(visited, neigh, true)
                {queue, visited}
              else
                {queue, visited}
              end
              i = i + 1
              while_fun_6.(while_fun_6, i, queue, visited)
            else
              {i, queue, visited}
            end
          end
          {i, queue, visited} = try do
              while_fun_6.(while_fun_6, i, queue, visited)
            catch
              {:break, {i, queue, visited}} -> {i, queue, visited}
            end

          while_fun_5.(while_fun_5, order, queue, visited)
        else
          {order, queue, visited}
        end
      end
      {order, queue, visited} = try do
          while_fun_5.(while_fun_5, order, queue, visited)
        catch
          {:break, {order, queue, visited}} -> {order, queue, visited}
        end

      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def dg_in_degree(g, u) do
    try do
      count = 0
      {count} = Enum.reduce(Map.keys(g.graph), {count}, fn k, {count} ->
        edges = g.graph[k]
        i = 0
        while_fun_7 = fn while_fun_7, count, i ->
          if i < _len(edges) do
            {count} = if Enum.at(Enum.at(edges, i), 1) == u do
              count = count + 1
              {count}
            else
              {count}
            end
            i = i + 1
            while_fun_7.(while_fun_7, count, i)
          else
            {count, i}
          end
        end
        {count, i} = try do
            while_fun_7.(while_fun_7, count, i)
          catch
            {:break, {count, i}} -> {count, i}
          end

        {count}
      end)
      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def dg_out_degree(g, u) do
    try do
      throw {:return, ((if Map.has_key?(g.graph, u), do: _len(Map.get(g.graph, u, [])), else: 0))}
    catch
      {:return, val} -> val
    end
  end
  def dg_topo_util(g, node_, visited, stack) do
    try do
      visited = Map.put(visited, node_, true)
      edges = g.graph[node_]
      i = 0
      while_fun_8 = fn while_fun_8, i, stack ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          {stack} = if !(Map.has_key?(visited, neigh)) do
            stack = dg_topo_util(g, neigh, visited, stack)
            {stack}
          else
            {stack}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i, stack)
        else
          {i, stack}
        end
      end
      {i, stack} = try do
          while_fun_8.(while_fun_8, i, stack)
        catch
          {:break, {i, stack}} -> {i, stack}
        end

      stack = (stack ++ [node_])
      throw {:return, stack}
    catch
      {:return, val} -> val
    end
  end
  def dg_topological_sort(g) do
    try do
      visited = %{}
      stack = []
      {stack} = Enum.reduce(Map.keys(g.graph), {stack}, fn k, {stack} ->
        {stack} = if !(Map.has_key?(visited, k)) do
          stack = dg_topo_util(g, k, visited, stack)
          {stack}
        else
          {stack}
        end
        {stack}
      end)
      res = []
      i = _len(stack) - 1
      while_fun_9 = fn while_fun_9, i, res ->
        if i >= 0 do
          res = (res ++ [Enum.at(stack, i)])
          i = i - 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def dg_cycle_util(g, node_, visited, rec, res) do
    try do
      visited = Map.put(visited, node_, true)
      rec = Map.put(rec, node_, true)
      edges = g.graph[node_]
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          {res} = if !(Map.has_key?(visited, neigh)) do
            res = dg_cycle_util(g, neigh, visited, rec, res)
            {res}
          else
            {res} = if rec[neigh] do
              {res} = if !list_contains_int(res, neigh) do
                res = (res ++ [neigh])
                {res}
              else
                {res}
              end
              {res} = if !list_contains_int(res, node_) do
                res = (res ++ [node_])
                {res}
              else
                {res}
              end
              {res}
            else
              {res}
            end
            {res}
          end
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      rec = Map.put(rec, node_, false)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def dg_cycle_nodes(g) do
    try do
      visited = %{}
      rec = %{}
      res = []
      {res} = Enum.reduce(Map.keys(g.graph), {res}, fn k, {res} ->
        {res} = if !(Map.has_key?(visited, k)) do
          res = dg_cycle_util(g, k, visited, rec, res)
          {res}
        else
          {res}
        end
        {res}
      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def dg_has_cycle_util(g, node_, visited, rec) do
    try do
      visited = Map.put(visited, node_, true)
      rec = Map.put(rec, node_, true)
      edges = g.graph[node_]
      i = 0
      while_fun_11 = fn while_fun_11, i ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          if !(Map.has_key?(visited, neigh)) do
            if dg_has_cycle_util(g, neigh, visited, rec) do
              throw {:return, true}
            end
          else
            if rec[neigh] do
              throw {:return, true}
            end
          end
          i = i + 1
          while_fun_11.(while_fun_11, i)
        else
          i
        end
      end
      i = try do
          while_fun_11.(while_fun_11, i)
        catch
          {:break, {i}} -> i
        end

      rec = Map.put(rec, node_, false)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def dg_has_cycle(g) do
    try do
      visited = %{}
      rec = %{}
      Enum.each(Map.keys(g.graph), fn k ->
        if !(Map.has_key?(visited, k)) do
          if dg_has_cycle_util(g, k, visited, rec) do
            throw {:return, true}
          end
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def dg_fill_graph_randomly(g, c) do
    try do
      count = c
      {count} = if count == (-1) do
        count = rand_range(10, 10010)
        {count}
      else
        {count}
      end
      i = 0
      while_fun_12 = fn while_fun_12, i ->
        if i < count do
          edge_count = rand_range(1, 103)
          j = 0
          while_fun_13 = fn while_fun_13, j ->
            if j < edge_count do
              n = rand_range(0, count)
              if n != i do
                dg_add_pair(g, i, n, 1)
              end
              j = j + 1
              while_fun_13.(while_fun_13, j)
            else
              j
            end
          end
          j = try do
              while_fun_13.(while_fun_13, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_12.(while_fun_12, i)
        else
          i
        end
      end
      i = try do
          while_fun_12.(while_fun_12, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def dg_dfs_time(g, s, e) do
    try do
      begin = _now()
      dg_dfs(g, s, e)
      end_ = _now()
      throw {:return, end_ - begin}
    catch
      {:return, val} -> val
    end
  end
  def dg_bfs_time(g, s) do
    try do
      begin = _now()
      dg_bfs(g, s)
      end_ = _now()
      throw {:return, end_ - begin}
    catch
      {:return, val} -> val
    end
  end
  def g_make_graph() do
    try do
      throw {:return, %{graph: %{}}}
    catch
      {:return, val} -> val
    end
  end
  def g_add_pair(g, u, v, w) do
    try do
      {g} = if Map.has_key?(g.graph, u) do
        edges = g.graph[u]
        {edges, g} = if !edge_exists(edges, w, v) do
          edges = (edges ++ [[w, v]])
          m = g.graph
          m = Map.put(m, u, edges)
          g = Map.put(g, :graph, m)
          {edges, g}
        else
          {edges, g}
        end
        {g}
      else
        m0 = g.graph
        m0 = Map.put(m0, u, [[w, v]])
        g = Map.put(g, :graph, m0)
        {g}
      end
      {g} = if Map.has_key?(g.graph, v) do
        edges2 = g.graph[v]
        {edges2, g} = if !edge_exists(edges2, w, u) do
          edges2 = (edges2 ++ [[w, u]])
          m2 = g.graph
          m2 = Map.put(m2, v, edges2)
          g = Map.put(g, :graph, m2)
          {edges2, g}
        else
          {edges2, g}
        end
        {g}
      else
        m3 = g.graph
        m3 = Map.put(m3, v, [[w, u]])
        g = Map.put(g, :graph, m3)
        {g}
      end
    catch
      {:return, val} -> val
    end
  end
  def g_remove_pair(g, u, v) do
    try do
      {g} = if Map.has_key?(g.graph, u) do
        edges = g.graph[u]
        new_edges = []
        i = 0
        while_fun_14 = fn while_fun_14, i, new_edges ->
          if i < _len(edges) do
            {new_edges} = if Enum.at(Enum.at(edges, i), 1) != v do
              new_edges = (new_edges ++ [Enum.at(edges, i)])
              {new_edges}
            else
              {new_edges}
            end
            i = i + 1
            while_fun_14.(while_fun_14, i, new_edges)
          else
            {i, new_edges}
          end
        end
        {i, new_edges} = try do
            while_fun_14.(while_fun_14, i, new_edges)
          catch
            {:break, {i, new_edges}} -> {i, new_edges}
          end

        m = g.graph
        m = Map.put(m, u, new_edges)
        g = Map.put(g, :graph, m)
        {g}
      else
        {g}
      end
      {g} = if Map.has_key?(g.graph, v) do
        edges2 = g.graph[v]
        new_edges2 = []
        j = 0
        while_fun_15 = fn while_fun_15, j, new_edges2 ->
          if j < _len(edges2) do
            {new_edges2} = if Enum.at(Enum.at(edges2, j), 1) != u do
              new_edges2 = (new_edges2 ++ [Enum.at(edges2, j)])
              {new_edges2}
            else
              {new_edges2}
            end
            j = j + 1
            while_fun_15.(while_fun_15, j, new_edges2)
          else
            {j, new_edges2}
          end
        end
        {j, new_edges2} = try do
            while_fun_15.(while_fun_15, j, new_edges2)
          catch
            {:break, {j, new_edges2}} -> {j, new_edges2}
          end

        m2 = g.graph
        m2 = Map.put(m2, v, new_edges2)
        g = Map.put(g, :graph, m2)
        {g}
      else
        {g}
      end
    catch
      {:return, val} -> val
    end
  end
  def g_all_nodes(g) do
    try do
      res = []
      {res} = Enum.reduce(Map.keys(g.graph), {res}, fn k, {res} ->
        res = (res ++ [k])
        {res}
      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def g_dfs_util(g, node_, visited, order, d) do
    try do
      visited = Map.put(visited, node_, true)
      order = (order ++ [node_])
      if d != (-1) && node_ == d do
        throw {:return, order}
      end
      edges = g.graph[node_]
      i = 0
      while_fun_16 = fn while_fun_16, i, order ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          {order} = if !(Map.has_key?(visited, neigh)) do
            order = g_dfs_util(g, neigh, visited, order, d)
            if d != (-1) && Enum.at(order, _len(order) - 1) == d do
              throw {:return, order}
            end
            {order}
          else
            {order}
          end
          i = i + 1
          while_fun_16.(while_fun_16, i, order)
        else
          {i, order}
        end
      end
      {i, order} = try do
          while_fun_16.(while_fun_16, i, order)
        catch
          {:break, {i, order}} -> {i, order}
        end

      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def g_dfs(g, s, d) do
    try do
      if s == d do
        throw {:return, []}
      end
      start = (if s == (-2), do: first_key(Map.get(g, :graph, [])), else: s)
      visited = %{}
      order = []
      order = g_dfs_util(g, start, visited, order, d)
      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def g_bfs(g, s) do
    try do
      queue = []
      visited = %{}
      order = []
      start = (if s == (-2), do: first_key(Map.get(g, :graph, [])), else: s)
      queue = (queue ++ [start])
      visited = Map.put(visited, start, true)
      while_fun_17 = fn while_fun_17, order, queue, visited ->
        if _len(queue) > 0 do
          node_ = Enum.at(queue, 0)
          queue = _slice(queue, 1, _len(queue) - 1)
          order = (order ++ [node_])
          edges = g.graph[node_]
          i = 0
          while_fun_18 = fn while_fun_18, i, queue, visited ->
            if i < _len(edges) do
              neigh = Enum.at(Enum.at(edges, i), 1)
              {queue, visited} = if !(Map.has_key?(visited, neigh)) do
                queue = (queue ++ [neigh])
                visited = Map.put(visited, neigh, true)
                {queue, visited}
              else
                {queue, visited}
              end
              i = i + 1
              while_fun_18.(while_fun_18, i, queue, visited)
            else
              {i, queue, visited}
            end
          end
          {i, queue, visited} = try do
              while_fun_18.(while_fun_18, i, queue, visited)
            catch
              {:break, {i, queue, visited}} -> {i, queue, visited}
            end

          while_fun_17.(while_fun_17, order, queue, visited)
        else
          {order, queue, visited}
        end
      end
      {order, queue, visited} = try do
          while_fun_17.(while_fun_17, order, queue, visited)
        catch
          {:break, {order, queue, visited}} -> {order, queue, visited}
        end

      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def g_degree(g, u) do
    try do
      throw {:return, ((if Map.has_key?(g.graph, u), do: _len(Map.get(g.graph, u, [])), else: 0))}
    catch
      {:return, val} -> val
    end
  end
  def g_cycle_util(g, node_, visited, parent, res) do
    try do
      visited = Map.put(visited, node_, true)
      edges = g.graph[node_]
      i = 0
      while_fun_19 = fn while_fun_19, i, res ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          {res} = if !(Map.has_key?(visited, neigh)) do
            res = g_cycle_util(g, neigh, visited, node_, res)
            {res}
          else
            {res} = if neigh != parent do
              {res} = if !list_contains_int(res, neigh) do
                res = (res ++ [neigh])
                {res}
              else
                {res}
              end
              {res} = if !list_contains_int(res, node_) do
                res = (res ++ [node_])
                {res}
              else
                {res}
              end
              {res}
            else
              {res}
            end
            {res}
          end
          i = i + 1
          while_fun_19.(while_fun_19, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_19.(while_fun_19, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def g_cycle_nodes(g) do
    try do
      visited = %{}
      res = []
      {res} = Enum.reduce(Map.keys(g.graph), {res}, fn k, {res} ->
        {res} = if !(Map.has_key?(visited, k)) do
          res = g_cycle_util(g, k, visited, -1, res)
          {res}
        else
          {res}
        end
        {res}
      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def g_has_cycle_util(g, node_, visited, parent) do
    try do
      visited = Map.put(visited, node_, true)
      edges = g.graph[node_]
      i = 0
      while_fun_20 = fn while_fun_20, i ->
        if i < _len(edges) do
          neigh = Enum.at(Enum.at(edges, i), 1)
          if !(Map.has_key?(visited, neigh)) do
            if g_has_cycle_util(g, neigh, visited, node_) do
              throw {:return, true}
            end
          else
            if neigh != parent do
              throw {:return, true}
            end
          end
          i = i + 1
          while_fun_20.(while_fun_20, i)
        else
          i
        end
      end
      i = try do
          while_fun_20.(while_fun_20, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def g_has_cycle(g) do
    try do
      visited = %{}
      Enum.each(Map.keys(g.graph), fn k ->
        if !(Map.has_key?(visited, k)) do
          if g_has_cycle_util(g, k, visited, -1) do
            throw {:return, true}
          end
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def g_fill_graph_randomly(g, c) do
    try do
      count = c
      {count} = if count == (-1) do
        count = rand_range(10, 10010)
        {count}
      else
        {count}
      end
      i = 0
      while_fun_21 = fn while_fun_21, i ->
        if i < count do
          edge_count = rand_range(1, 103)
          j = 0
          while_fun_22 = fn while_fun_22, j ->
            if j < edge_count do
              n = rand_range(0, count)
              if n != i do
                g_add_pair(g, i, n, 1)
              end
              j = j + 1
              while_fun_22.(while_fun_22, j)
            else
              j
            end
          end
          j = try do
              while_fun_22.(while_fun_22, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_21.(while_fun_21, i)
        else
          i
        end
      end
      i = try do
          while_fun_21.(while_fun_21, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def g_dfs_time(g, s, e) do
    try do
      begin = _now()
      g_dfs(g, s, e)
      end_ = _now()
      throw {:return, end_ - begin}
    catch
      {:return, val} -> val
    end
  end
  def g_bfs_time(g, s) do
    try do
      begin = _now()
      g_bfs(g, s)
      end_ = _now()
      throw {:return, end_ - begin}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      dg = dg_make_graph()
      dg_add_pair(dg, 0, 1, 5)
      dg_add_pair(dg, 0, 2, 3)
      dg_add_pair(dg, 1, 3, 2)
      dg_add_pair(dg, 2, 3, 4)
      IO.puts(Kernel.inspect(dg_dfs(dg, -2, -1)))
      IO.puts(Kernel.inspect(dg_bfs(dg, -2)))
      IO.puts(Kernel.inspect(dg_in_degree(dg, 3)))
      IO.puts(Kernel.inspect(dg_out_degree(dg, 0)))
      IO.puts(Kernel.inspect(dg_topological_sort(dg)))
      IO.puts(Kernel.inspect(dg_has_cycle(dg)))
      ug = g_make_graph()
      g_add_pair(ug, 0, 1, 1)
      g_add_pair(ug, 1, 2, 1)
      g_add_pair(ug, 2, 0, 1)
      IO.puts(Kernel.inspect(g_dfs(ug, -2, -1)))
      IO.puts(Kernel.inspect(g_bfs(ug, -2)))
      IO.puts(Kernel.inspect(g_degree(ug, 1)))
      IO.puts(Kernel.inspect(g_has_cycle(ug)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
