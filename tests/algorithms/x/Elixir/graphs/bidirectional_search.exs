# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def expand_search(graph, queue, head, parents, visited, opposite_visited) do
    try do
      if head >= _len(queue) do
        throw {:return, %{queue: queue, head: head, parents: parents, visited: visited, intersection: 0 - 1, found: false}}
      end
      current = Enum.at(queue, head)
      head = head + 1
      neighbors = graph[current]
      q = queue
      p = parents
      v = visited
      i = 0
      while_fun = fn while_fun, i, p, q, v ->
        if i < _len(neighbors) do
          {i, p, q, v} = try do
            neighbor = Enum.at(neighbors, i)
            {i} = if v[neighbor] do
              i = i + 1
              throw {:continue, {i, p, q, v}}
              {i}
            else
              {i}
            end
            v = Map.put(v, neighbor, true)
            p = Map.put(p, neighbor, current)
            q = (q ++ [neighbor])
            if opposite_visited[neighbor] do
              throw {:return, %{queue: q, head: head, parents: p, visited: v, intersection: neighbor, found: true}}
            end
            i = i + 1
            {i, p, q, v}
          catch
            {:continue, {i, p, q, v}} -> {i, p, q, v}
          end
          while_fun.(while_fun, i, p, q, v)
        else
          {i, p, q, v}
        end
      end
      {i, p, q, v} = try do
          while_fun.(while_fun, i, p, q, v)
        catch
          {:break, {i, p, q, v}} -> {i, p, q, v}
        end

      throw {:return, %{queue: q, head: head, parents: p, visited: v, intersection: 0 - 1, found: false}}
    catch
      {:return, val} -> val
    end
  end
  def construct_path(current, parents) do
    try do
      path = []
      node_ = current
      while_fun_2 = fn while_fun_2, node_, path ->
        if node_ != 0 - 1 do
          path = (path ++ [node_])
          node_ = parents[node_]
          while_fun_2.(while_fun_2, node_, path)
        else
          {node_, path}
        end
      end
      {node_, path} = try do
          while_fun_2.(while_fun_2, node_, path)
        catch
          {:break, {node_, path}} -> {node_, path}
        end

      throw {:return, path}
    catch
      {:return, val} -> val
    end
  end
  def reverse_list(xs) do
    try do
      res = []
      i = _len(xs)
      while_fun_3 = fn while_fun_3, i, res ->
        if i > 0 do
          i = i - 1
          res = (res ++ [Enum.at(xs, i)])
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bidirectional_search(g, start, goal) do
    try do
      if start == goal do
        throw {:return, %{path: [start], ok: true}}
      end
      forward_parents = %{}
      forward_parents = Map.put(forward_parents, start, 0 - 1)
      backward_parents = %{}
      backward_parents = Map.put(backward_parents, goal, 0 - 1)
      forward_visited = %{}
      forward_visited = Map.put(forward_visited, start, true)
      backward_visited = %{}
      backward_visited = Map.put(backward_visited, goal, true)
      forward_queue = [start]
      backward_queue = [goal]
      forward_head = 0
      backward_head = 0
      intersection = 0 - 1
      while_fun_4 = fn while_fun_4, backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection ->
        if forward_head < _len(forward_queue) && backward_head < _len(backward_queue) && intersection == 0 - 1 do
          res = expand_search(g, forward_queue, forward_head, forward_parents, forward_visited, backward_visited)
          forward_queue = res.queue
          forward_head = res.head
          forward_parents = res.parents
          forward_visited = res.visited
          {intersection} = if res.found do
            intersection = res.intersection
            throw {:break, {backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection}}
            {intersection}
          else
            {intersection}
          end
          res = expand_search(g, backward_queue, backward_head, backward_parents, backward_visited, forward_visited)
          backward_queue = res.queue
          backward_head = res.head
          backward_parents = res.parents
          backward_visited = res.visited
          {intersection} = if res.found do
            intersection = res.intersection
            throw {:break, {backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection}}
            {intersection}
          else
            {intersection}
          end
          while_fun_4.(while_fun_4, backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection)
        else
          {backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection}
        end
      end
      {backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection} = try do
          while_fun_4.(while_fun_4, backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection)
        catch
          {:break, {backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection}} -> {backward_head, backward_parents, backward_queue, backward_visited, forward_head, forward_parents, forward_queue, forward_visited, intersection}
        end

      if intersection == 0 - 1 do
        throw {:return, %{path: [], ok: false}}
      end
      forward_path = construct_path(intersection, forward_parents)
      forward_path = reverse_list(forward_path)
      back_start = backward_parents[intersection]
      backward_path = construct_path(back_start, backward_parents)
      result = forward_path
      j = 0
      while_fun_5 = fn while_fun_5, j, result ->
        if j < _len(backward_path) do
          result = (result ++ [Enum.at(backward_path, j)])
          j = j + 1
          while_fun_5.(while_fun_5, j, result)
        else
          {j, result}
        end
      end
      {j, result} = try do
          while_fun_5.(while_fun_5, j, result)
        catch
          {:break, {j, result}} -> {j, result}
        end

      throw {:return, %{path: result, ok: true}}
    catch
      {:return, val} -> val
    end
  end
  def is_edge(g, u, v) do
    try do
      neighbors = g[u]
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(neighbors) do
          if Enum.at(neighbors, i) == v do
            throw {:return, true}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def path_exists(g, path) do
    try do
      if _len(path) == 0 do
        throw {:return, false}
      end
      i = 0
      while_fun_7 = fn while_fun_7, i ->
        if i + 1 < _len(path) do
          if !is_edge(g, Enum.at(path, i), Enum.at(path, i + 1)) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      i = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def print_path(g, s, t) do
    try do
      res = bidirectional_search(g, s, t)
      if res.ok && path_exists(g, res.path) do
        IO.puts(((((("Path from " <> Kernel.to_string(s)) <> " to ") <> Kernel.to_string(t)) <> ": ") <> String.replace(IO.iodata_to_binary(:io_lib.format("~w", [res.path])), ",", " ")))
      else
        IO.puts((((("Path from " <> Kernel.to_string(s)) <> " to ") <> Kernel.to_string(t)) <> ": None"))
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      graph = %{0 => [1, 2], 1 => [0, 3, 4], 2 => [0, 5, 6], 3 => [1, 7], 4 => [1, 8], 5 => [2, 9], 6 => [2, 10], 7 => [3, 11], 8 => [4, 11], 9 => [5, 11], 10 => [6, 11], 11 => [7, 8, 9, 10]}
      print_path(graph, 0, 11)
      print_path(graph, 5, 5)
      disconnected = %{0 => [1, 2], 1 => [0], 2 => [0], 3 => [4], 4 => [3]}
      print_path(disconnected, 0, 3)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
