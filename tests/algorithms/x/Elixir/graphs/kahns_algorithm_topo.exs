# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def topological_sort(graph) do
    try do
      indegree = []
      i = 0
      while_fun = fn while_fun, i, indegree ->
        if i < map_size(graph) do
          indegree = (indegree ++ [0])
          i = i + 1
          while_fun.(while_fun, i, indegree)
        else
          {i, indegree}
        end
      end
      {i, indegree} = try do
          while_fun.(while_fun, i, indegree)
        catch
          {:break, {i, indegree}} -> {i, indegree}
        end

      {indegree} = Enum.reduce(Map.values(graph), {indegree}, fn edges, {indegree} ->
        j = 0
        while_fun_2 = fn while_fun_2, indegree, j ->
          if j < _len(edges) do
            v = Enum.at(edges, j)
            indegree = List.replace_at(indegree, v, Enum.at(indegree, v) + 1)
            j = j + 1
            while_fun_2.(while_fun_2, indegree, j)
          else
            {indegree, j}
          end
        end
        {indegree, j} = try do
            while_fun_2.(while_fun_2, indegree, j)
          catch
            {:break, {indegree, j}} -> {indegree, j}
          end

        {indegree}
      end)
      queue = []
      i = 0
      while_fun_3 = fn while_fun_3, i, queue ->
        if i < _len(indegree) do
          {queue} = if Enum.at(indegree, i) == 0 do
            queue = (queue ++ [i])
            {queue}
          else
            {queue}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, queue)
        else
          {i, queue}
        end
      end
      {i, queue} = try do
          while_fun_3.(while_fun_3, i, queue)
        catch
          {:break, {i, queue}} -> {i, queue}
        end

      order = []
      head = 0
      processed = 0
      while_fun_4 = fn while_fun_4, head, indegree, order, processed, queue ->
        if head < _len(queue) do
          v = Enum.at(queue, head)
          head = head + 1
          processed = processed + 1
          order = (order ++ [v])
          neighbors = graph[v]
          k = 0
          while_fun_5 = fn while_fun_5, indegree, k, queue ->
            if k < _len(neighbors) do
              nb = Enum.at(neighbors, k)
              indegree = List.replace_at(indegree, nb, Enum.at(indegree, nb) - 1)
              {queue} = if Enum.at(indegree, nb) == 0 do
                queue = (queue ++ [nb])
                {queue}
              else
                {queue}
              end
              k = k + 1
              while_fun_5.(while_fun_5, indegree, k, queue)
            else
              {indegree, k, queue}
            end
          end
          {indegree, k, queue} = try do
              while_fun_5.(while_fun_5, indegree, k, queue)
            catch
              {:break, {indegree, k, queue}} -> {indegree, k, queue}
            end

          while_fun_4.(while_fun_4, head, indegree, order, processed, queue)
        else
          {head, indegree, order, processed, queue}
        end
      end
      {head, indegree, order, processed, queue} = try do
          while_fun_4.(while_fun_4, head, indegree, order, processed, queue)
        catch
          {:break, {head, indegree, order, processed, queue}} -> {head, indegree, order, processed, queue}
        end

      if processed != map_size(graph) do
        throw {:return, nil}
      end
      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      graph = %{0 => [1, 2], 1 => [3], 2 => [3], 3 => [4, 5], 4 => [], 5 => []}
      IO.puts(Kernel.inspect(topological_sort(graph)))
      cyclic = %{0 => [1], 1 => [2], 2 => [0]}
      IO.puts(Kernel.inspect(topological_sort(cyclic)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
