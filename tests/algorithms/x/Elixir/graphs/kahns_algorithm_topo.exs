# Code generated by Mochi transpiler 2025-08-16 09:34 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def topological_sort(graph) do
    try do
      indegree = []
      i = 0
      while_fun = fn while_fun, i, indegree ->
        if i < map_size(graph) do
          indegree = (indegree ++ [0])
          i = i + 1
          while_fun.(while_fun, i, indegree)
        else
          {i, indegree}
        end
      end
      {_, indegree} = try do
          while_fun.(while_fun, i, indegree)
        catch
          {:break, {_, indegree}} -> {0, indegree}
        end

      {indegree} = Enum.reduce(Map.values(graph), {indegree}, fn edges, {indegree} ->
        j = 0
        while_fun_2 = fn while_fun_2, indegree, j ->
          if j < _len(edges) do
            v = Enum.at(edges, j, [])
            indegree = List.replace_at(indegree, v, Enum.at(indegree, v, []) + 1)
            j = j + 1
            while_fun_2.(while_fun_2, indegree, j)
          else
            {indegree, j}
          end
        end
        {indegree, _} = try do
            while_fun_2.(while_fun_2, indegree, j)
          catch
            {:break, {indegree, _}} -> {indegree, 0}
          end

        {indegree}
      end)
      queue = []
      i = 0
      while_fun_3 = fn while_fun_3, i, queue ->
        if i < _len(indegree) do
          queue = if Enum.at(indegree, i, []) == 0 do
            queue = (queue ++ [i])
            queue
          else
            queue
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, queue)
        else
          {i, queue}
        end
      end
      {_, queue} = try do
          while_fun_3.(while_fun_3, i, queue)
        catch
          {:break, {_, queue}} -> {0, queue}
        end

      order = []
      head = 0
      processed = 0
      while_fun_4 = fn while_fun_4, head, indegree, order, processed, queue ->
        if head < _len(queue) do
          v = Enum.at(queue, head, [])
          head = head + 1
          processed = processed + 1
          order = (order ++ [v])
          neighbors = graph[v]
          k = 0
          while_fun_5 = fn while_fun_5, indegree, k, queue ->
            if k < _len(neighbors) do
              nb = Enum.at(neighbors, k, [])
              indegree = List.replace_at(indegree, nb, Enum.at(indegree, nb, []) - 1)
              queue = if Enum.at(indegree, nb, []) == 0 do
                queue = (queue ++ [nb])
                queue
              else
                queue
              end
              k = k + 1
              while_fun_5.(while_fun_5, indegree, k, queue)
            else
              {indegree, k, queue}
            end
          end
          {indegree, _, queue} = try do
              while_fun_5.(while_fun_5, indegree, k, queue)
            catch
              {:break, {indegree, _, queue}} -> {indegree, 0, queue}
            end

          while_fun_4.(while_fun_4, head, indegree, order, processed, queue)
        else
          {head, indegree, order, processed, queue}
        end
      end
      {head, indegree, order, processed, queue} = try do
          while_fun_4.(while_fun_4, head, indegree, order, processed, queue)
        catch
          {:break, {head, indegree, order, processed, queue}} -> {head, indegree, order, processed, queue}
        end

      if processed != map_size(graph) do
        throw {:return, nil}
      end
      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      graph = %{0 => [1, 2], 1 => [3], 2 => [3], 3 => [4, 5], 4 => [], 5 => []}
      IO.puts(Kernel.inspect(topological_sort(graph)))
      cyclic = %{0 => [1], 1 => [2], 2 => [0]}
      IO.puts(Kernel.inspect(topological_sort(cyclic)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
