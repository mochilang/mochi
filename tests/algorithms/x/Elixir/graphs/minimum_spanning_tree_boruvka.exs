# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def uf_make(n) do
    try do
      p = []
      r = []
      i = 0
      while_fun = fn while_fun, i, p, r ->
        if i < n do
          p = (p ++ [i])
          r = (r ++ [0])
          i = i + 1
          while_fun.(while_fun, i, p, r)
        else
          {i, p, r}
        end
      end
      {i, p, r} = try do
          while_fun.(while_fun, i, p, r)
        catch
          {:break, {i, p, r}} -> {i, p, r}
        end

      throw {:return, %{parent: p, rank: r}}
    catch
      {:return, val} -> val
    end
  end
  def uf_find(uf, x) do
    try do
      p = uf.parent
      {p} = if Enum.at(p, x) != x do
        res = uf_find(%{parent: p, rank: uf.rank}, Enum.at(p, x))
        p = res.uf.parent
        p = List.replace_at(p, x, res.root)
        throw {:return, %{root: res.root, uf: %{parent: p, rank: res.uf.rank}}}
        {p}
      else
        {p}
      end
      throw {:return, %{root: x, uf: uf}}
    catch
      {:return, val} -> val
    end
  end
  def uf_union(uf, x, y) do
    try do
      fr1 = uf_find(uf, x)
      uf1 = fr1.uf
      root1 = fr1.root
      fr2 = uf_find(uf1, y)
      uf1 = fr2.uf
      root2 = fr2.root
      if root1 == root2 do
        throw {:return, uf1}
      end
      p = uf1.parent
      r = uf1.rank
      {p, r} = if Enum.at(r, root1) > Enum.at(r, root2) do
        p = List.replace_at(p, root2, root1)
        {p, r}
      else
        {p, r} = if Enum.at(r, root1) < Enum.at(r, root2) do
          p = List.replace_at(p, root1, root2)
          {p, r}
        else
          p = List.replace_at(p, root2, root1)
          r = List.replace_at(r, root1, Enum.at(r, root1) + 1)
          {p, r}
        end
        {p, r}
      end
      throw {:return, %{parent: p, rank: r}}
    catch
      {:return, val} -> val
    end
  end
  def boruvka(n, edges) do
    try do
      uf = uf_make(n)
      num_components = n
      mst = []
      while_fun_2 = fn while_fun_2, mst, num_components, uf ->
        if num_components > 1 do
          cheap = []
          i = 0
          while_fun_3 = fn while_fun_3, cheap, i ->
            if i < n do
              cheap = (cheap ++ [0 - 1])
              i = i + 1
              while_fun_3.(while_fun_3, cheap, i)
            else
              {cheap, i}
            end
          end
          {cheap, i} = try do
              while_fun_3.(while_fun_3, cheap, i)
            catch
              {:break, {cheap, i}} -> {cheap, i}
            end

          idx = 0
          while_fun_4 = fn while_fun_4, cheap, idx, uf ->
            if idx < _len(edges) do
              e = Enum.at(edges, idx)
              fr1 = uf_find(uf, e.u)
              uf = fr1.uf
              set1 = fr1.root
              fr2 = uf_find(uf, e.v)
              uf = fr2.uf
              set2 = fr2.root
              {cheap} = if set1 != set2 do
                {cheap} = if Enum.at(cheap, set1) == 0 - 1 || Enum.at(edges, Enum.at(cheap, set1))["w"] > e.w do
                  cheap = List.replace_at(cheap, set1, idx)
                  {cheap}
                else
                  {cheap}
                end
                {cheap} = if Enum.at(cheap, set2) == 0 - 1 || Enum.at(edges, Enum.at(cheap, set2))["w"] > e.w do
                  cheap = List.replace_at(cheap, set2, idx)
                  {cheap}
                else
                  {cheap}
                end
                {cheap}
              else
                {cheap}
              end
              idx = idx + 1
              while_fun_4.(while_fun_4, cheap, idx, uf)
            else
              {cheap, idx, uf}
            end
          end
          {cheap, idx, uf} = try do
              while_fun_4.(while_fun_4, cheap, idx, uf)
            catch
              {:break, {cheap, idx, uf}} -> {cheap, idx, uf}
            end

          v = 0
          while_fun_5 = fn while_fun_5, mst, num_components, uf, v ->
            if v < n do
              idxe = Enum.at(cheap, v)
              {mst, num_components, uf} = if idxe != 0 - 1 do
                e = Enum.at(edges, idxe)
                fr1 = uf_find(uf, e.u)
                uf = fr1.uf
                set1 = fr1.root
                fr2 = uf_find(uf, e.v)
                uf = fr2.uf
                set2 = fr2.root
                {mst, num_components, uf} = if set1 != set2 do
                  mst = (mst ++ [e])
                  uf = uf_union(uf, set1, set2)
                  num_components = num_components - 1
                  {mst, num_components, uf}
                else
                  {mst, num_components, uf}
                end
                {mst, num_components, uf}
              else
                {mst, num_components, uf}
              end
              v = v + 1
              while_fun_5.(while_fun_5, mst, num_components, uf, v)
            else
              {mst, num_components, uf, v}
            end
          end
          {mst, num_components, uf, v} = try do
              while_fun_5.(while_fun_5, mst, num_components, uf, v)
            catch
              {:break, {mst, num_components, uf, v}} -> {mst, num_components, uf, v}
            end

          while_fun_2.(while_fun_2, mst, num_components, uf)
        else
          {mst, num_components, uf}
        end
      end
      {mst, num_components, uf} = try do
          while_fun_2.(while_fun_2, mst, num_components, uf)
        catch
          {:break, {mst, num_components, uf}} -> {mst, num_components, uf}
        end

      throw {:return, mst}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      edges = [%{u: 0, v: 1, w: 1}, %{u: 0, v: 2, w: 2}, %{u: 2, v: 3, w: 3}]
      mst = boruvka(4, edges)
      Enum.each(mst, fn e ->
        IO.puts(((((Kernel.to_string(e.u) <> " - ") <> Kernel.to_string(e.v)) <> " : ") <> Kernel.to_string(e.w)))
      end)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
