# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def minimum_distance(distances, visited) do
    try do
      minimum = 10000000
      min_index = 0
      vertex = 0
      while_fun = fn while_fun, min_index, minimum, vertex ->
        if vertex < _len(distances) do
          {min_index, minimum} = if Enum.at(distances, vertex) < minimum && Enum.at(visited, vertex) == false do
            minimum = Enum.at(distances, vertex)
            min_index = vertex
            {min_index, minimum}
          else
            {min_index, minimum}
          end
          vertex = vertex + 1
          while_fun.(while_fun, min_index, minimum, vertex)
        else
          {min_index, minimum, vertex}
        end
      end
      {min_index, minimum, vertex} = try do
          while_fun.(while_fun, min_index, minimum, vertex)
        catch
          {:break, {min_index, minimum, vertex}} -> {min_index, minimum, vertex}
        end

      throw {:return, min_index}
    catch
      {:return, val} -> val
    end
  end
  def dijkstra(graph, source) do
    try do
      vertices = _len(graph)
      distances = nil
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < vertices do
          distances = (distances ++ [10000000])
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      distances = List.replace_at(distances, source, 0)
      visited = nil
      i = 0
      while_fun_3 = fn while_fun_3, i, visited ->
        if i < vertices do
          visited = (visited ++ [false])
          i = i + 1
          while_fun_3.(while_fun_3, i, visited)
        else
          {i, visited}
        end
      end
      {i, visited} = try do
          while_fun_3.(while_fun_3, i, visited)
        catch
          {:break, {i, visited}} -> {i, visited}
        end

      count = 0
      while_fun_4 = fn while_fun_4, count, visited ->
        if count < vertices do
          u = minimum_distance(distances, visited)
          visited = List.replace_at(visited, u, true)
          v = 0
          while_fun_5 = fn while_fun_5, v ->
            if v < vertices do
              if Enum.at(Enum.at(graph, u), v) > 0 && Enum.at(visited, v) == false && Enum.at(distances, v) > Enum.at(distances, u) + Enum.at(Enum.at(graph, u), v) do
                distances = List.replace_at(distances, v, Enum.at(distances, u) + Enum.at(Enum.at(graph, u), v))
              end
              v = v + 1
              while_fun_5.(while_fun_5, v)
            else
              v
            end
          end
          v = try do
              while_fun_5.(while_fun_5, v)
            catch
              {:break, {v}} -> v
            end

          count = count + 1
          while_fun_4.(while_fun_4, count, visited)
        else
          {count, visited}
        end
      end
      {count, visited} = try do
          while_fun_4.(while_fun_4, count, visited)
        catch
          {:break, {count, visited}} -> {count, visited}
        end

      throw {:return, distances}
    catch
      {:return, val} -> val
    end
  end
  def print_solution(distances) do
    try do
      IO.puts("Vertex \t Distance from Source")
      v = 0
      while_fun_6 = fn while_fun_6, v ->
        if v < _len(distances) do
          IO.puts(((Kernel.to_string(v) <> "\t\t") <> Kernel.to_string(Enum.at(distances, v))))
          v = v + 1
          while_fun_6.(while_fun_6, v)
        else
          v
        end
      end
      v = try do
          while_fun_6.(while_fun_6, v)
        catch
          {:break, {v}} -> v
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, [[0, 4, 0, 0, 0, 0, 0, 8, 0], [4, 0, 8, 0, 0, 0, 0, 11, 0], [0, 8, 0, 7, 0, 4, 0, 0, 2], [0, 0, 7, 0, 9, 14, 0, 0, 0], [0, 0, 0, 9, 0, 10, 0, 0, 0], [0, 0, 4, 14, 10, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 1, 6], [8, 11, 0, 0, 0, 0, 1, 0, 7], [0, 0, 2, 0, 0, 0, 6, 7, 0]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:distances, dijkstra(Process.get(:graph), 0))
    print_solution(Process.get(:distances))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
