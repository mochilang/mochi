# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def add_edge(g, from_vertex, to_vertex) do
    try do
      v = g.vertex
      {v} = if Map.has_key?(v, from_vertex) do
        lst = v[from_vertex]
        lst = (lst ++ [to_vertex])
        v = Map.put(v, from_vertex, lst)
        {v}
      else
        v = Map.put(v, from_vertex, [to_vertex])
        {v}
      end
      g = Map.put(g, :vertex, v)
      if from_vertex + 1 > g.size do
        g = Map.put(g, :size, from_vertex + 1)
      end
      if to_vertex + 1 > g.size do
        g = Map.put(g, :size, to_vertex + 1)
      end
      throw {:return, g}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(lst) do
    try do
      res = ""
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(lst) do
          res = (res <> Kernel.to_string(Enum.at(lst, i)))
          {res} = if i < _len(lst) - 1 do
            res = (res <> " ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def list_to_arrow(lst) do
    try do
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(lst) do
          res = (res <> Kernel.to_string(Enum.at(lst, i)))
          {res} = if i < _len(lst) - 1 do
            res = (res <> " -> ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def print_graph(g) do
    try do
      IO.puts(Kernel.inspect(Map.get(g, :vertex, [])))
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < g.size do
          edges = []
          {edges} = if Map.has_key?(g.vertex, i) do
            edges = g.vertex[i]
            {edges}
          else
            {edges}
          end
          line = ((Kernel.to_string(i) <> "  ->  ") <> list_to_arrow(edges))
          IO.puts(line)
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def dfs_recursive(g, start_vertex, visited, order) do
    try do
      visited = List.replace_at(visited, start_vertex, true)
      order = (order ++ [start_vertex])
      {order} = if Map.has_key?(g.vertex, start_vertex) do
        neighbors = g.vertex[start_vertex]
        i = 0
        while_fun_4 = fn while_fun_4, i, order ->
          if i < _len(neighbors) do
            nb = Enum.at(neighbors, i)
            {order} = if !Enum.at(visited, nb) do
              order = dfs_recursive(g, nb, visited, order)
              {order}
            else
              {order}
            end
            i = i + 1
            while_fun_4.(while_fun_4, i, order)
          else
            {i, order}
          end
        end
        {i, order} = try do
            while_fun_4.(while_fun_4, i, order)
          catch
            {:break, {i, order}} -> {i, order}
          end

        {order}
      else
        {order}
      end
      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def dfs(g) do
    try do
      n = g.size
      visited = []
      i = 0
      while_fun_5 = fn while_fun_5, i, visited ->
        if i < n do
          visited = (visited ++ [false])
          i = i + 1
          while_fun_5.(while_fun_5, i, visited)
        else
          {i, visited}
        end
      end
      {i, visited} = try do
          while_fun_5.(while_fun_5, i, visited)
        catch
          {:break, {i, visited}} -> {i, visited}
        end

      order = []
      i = 0
      while_fun_6 = fn while_fun_6, i, order ->
        if i < n do
          {order} = if !Enum.at(visited, i) do
            order = dfs_recursive(g, i, visited, order)
            {order}
          else
            {order}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, order)
        else
          {i, order}
        end
      end
      {i, order} = try do
          while_fun_6.(while_fun_6, i, order)
        catch
          {:break, {i, order}} -> {i, order}
        end

      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:g, %{vertex: %{}, size: 0})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:g, add_edge(Process.get(:g), 0, 1))
    Process.put(:g, add_edge(Process.get(:g), 0, 2))
    Process.put(:g, add_edge(Process.get(:g), 1, 2))
    Process.put(:g, add_edge(Process.get(:g), 2, 0))
    Process.put(:g, add_edge(Process.get(:g), 2, 3))
    Process.put(:g, add_edge(Process.get(:g), 3, 3))
    print_graph(Process.get(:g))
    IO.puts("DFS:")
    IO.puts(Kernel.inspect(list_to_string(dfs(Process.get(:g)))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
