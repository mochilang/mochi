# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_min_index(q) do
    try do
      idx = 0
      i = 1
      while_fun = fn while_fun, i, idx ->
        if i < _len(q) do
          {idx} = if Enum.at(q, i)["cost"] < Enum.at(q, idx)["cost"] do
            idx = i
            {idx}
          else
            {idx}
          end
          i = i + 1
          while_fun.(while_fun, i, idx)
        else
          {i, idx}
        end
      end
      {i, idx} = try do
          while_fun.(while_fun, i, idx)
        catch
          {:break, {i, idx}} -> {i, idx}
        end

      throw {:return, idx}
    catch
      {:return, val} -> val
    end
  end
  def remove_at(q, idx) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(q) do
          {res} = if i != idx do
            res = (res ++ [Enum.at(q, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def pass_and_relaxation(graph, v, visited_forward, visited_backward, cst_fwd, cst_bwd, queue, parent, shortest_distance) do
    try do
      q = queue
      sd = shortest_distance
      {cst_fwd, parent, q, sd} = Enum.reduce(graph[v], {cst_fwd, parent, q, sd}, fn e, {cst_fwd, parent, q, sd} ->
        try do
          nxt = e.to
          d = e.cost
          if Map.has_key?(visited_forward, nxt) do
            throw :continue
          end
          old_cost = (if Map.has_key?(cst_fwd, nxt), do: cst_fwd[nxt], else: 2147483647)
          new_cost = cst_fwd[v] + d
          {cst_fwd, parent, q} = if new_cost < old_cost do
            q = (q ++ [%{node: nxt, cost: new_cost}])
            cst_fwd = Map.put(cst_fwd, nxt, new_cost)
            parent = Map.put(parent, nxt, v)
            {cst_fwd, parent, q}
          else
            {cst_fwd, parent, q}
          end
          {sd} = if Map.has_key?(visited_backward, nxt) do
            alt = cst_fwd[v] + d + cst_bwd[nxt]
            {sd} = if alt < sd do
              sd = alt
              {sd}
            else
              {sd}
            end
            {sd}
          else
            {sd}
          end
        catch
          :continue -> {cst_fwd, parent, q, sd}
        end
        {cst_fwd, parent, q, sd}
      end)
      throw {:return, %{queue: q, dist: sd}}
    catch
      {:return, val} -> val
    end
  end
  def bidirectional_dij(source, destination, graph_forward, graph_backward) do
    try do
      shortest_path_distance = -1
      visited_forward = %{}
      visited_backward = %{}
      cst_fwd = %{}
      cst_fwd = Map.put(cst_fwd, source, 0)
      cst_bwd = %{}
      cst_bwd = Map.put(cst_bwd, destination, 0)
      parent_forward = %{}
      parent_forward = Map.put(parent_forward, source, "")
      parent_backward = %{}
      parent_backward = Map.put(parent_backward, destination, "")
      queue_forward = []
      queue_forward = (queue_forward ++ [%{node: source, cost: 0}])
      queue_backward = []
      queue_backward = (queue_backward ++ [%{node: destination, cost: 0}])
      shortest_distance = 2147483647
      if source == destination do
        throw {:return, 0}
      end
      while_fun_3 = fn while_fun_3, queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward ->
        if _len(queue_forward) > 0 && _len(queue_backward) > 0 do
          idx_f = get_min_index(queue_forward)
          item_f = Enum.at(queue_forward, idx_f)
          queue_forward = remove_at(queue_forward, idx_f)
          v_fwd = item_f.node
          visited_forward = Map.put(visited_forward, v_fwd, true)
          idx_b = get_min_index(queue_backward)
          item_b = Enum.at(queue_backward, idx_b)
          queue_backward = remove_at(queue_backward, idx_b)
          v_bwd = item_b.node
          visited_backward = Map.put(visited_backward, v_bwd, true)
          res_f = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, parent_forward, shortest_distance)
          queue_forward = res_f.queue
          shortest_distance = res_f.dist
          res_b = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, parent_backward, shortest_distance)
          queue_backward = res_b.queue
          shortest_distance = res_b.dist
          if cst_fwd[v_fwd] + cst_bwd[v_bwd] >= shortest_distance do
            throw {:break, {queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward}}
          end
          while_fun_3.(while_fun_3, queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward)
        else
          {queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward}
        end
      end
      {queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward} = try do
          while_fun_3.(while_fun_3, queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward)
        catch
          {:break, {queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward}} -> {queue_backward, queue_forward, shortest_distance, visited_backward, visited_forward}
        end

      {shortest_path_distance} = if shortest_distance != 2147483647 do
        shortest_path_distance = shortest_distance
        {shortest_path_distance}
      else
        {shortest_path_distance}
      end
      throw {:return, shortest_path_distance}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph_fwd, %{"B" => [%{to: "C", cost: 1}], "C" => [%{to: "D", cost: 1}], "D" => [%{to: "F", cost: 1}], "E" => [%{to: "B", cost: 1}, %{to: "G", cost: 2}], "F" => [], "G" => [%{to: "F", cost: 1}]})
  Process.put(:graph_bwd, %{"B" => [%{to: "E", cost: 1}], "C" => [%{to: "B", cost: 1}], "D" => [%{to: "C", cost: 1}], "F" => [%{to: "D", cost: 1}, %{to: "G", cost: 1}], "E" => [], "G" => [%{to: "E", cost: 2}]})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(bidirectional_dij("E", "F", Process.get(:graph_fwd), Process.get(:graph_bwd))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
