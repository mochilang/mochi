# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand_int(n) do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, rem(Process.get(:seed), n)}
    catch
      {:return, val} -> val
    end
  end
  def contains(list, value) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(list) do
          if Enum.at(list, i) == value do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def remove_all(list, value) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(list) do
          {res} = if Enum.at(list, i) != value do
            res = (res ++ [Enum.at(list, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def partition_graph(graph) do
    try do
      contracted = %{}
      {contracted} = Enum.reduce(Map.keys(graph), {contracted}, fn node_, {contracted} ->
        contracted = Map.put(contracted, node_, [node_])
        {contracted}
      end)
      graph_copy = %{}
      {graph_copy} = Enum.reduce(Map.keys(graph), {graph_copy}, fn node_, {graph_copy} ->
        lst = []
        neigh = graph[node_]
        i = 0
        while_fun_3 = fn while_fun_3, i, lst ->
          if i < _len(neigh) do
            lst = (lst ++ [Enum.at(neigh, i)])
            i = i + 1
            while_fun_3.(while_fun_3, i, lst)
          else
            {i, lst}
          end
        end
        {i, lst} = try do
            while_fun_3.(while_fun_3, i, lst)
          catch
            {:break, {i, lst}} -> {i, lst}
          end

        graph_copy = Map.put(graph_copy, node_, lst)
        {graph_copy}
      end)
      nodes = Map.keys(graph_copy)
      while_fun_4 = fn while_fun_4, contracted, graph_copy, nodes ->
        if _len(nodes) > 2 do
          u = Enum.at(nodes, rand_int(_len(nodes)))
          u_neighbors = graph_copy[u]
          v = Enum.at(u_neighbors, rand_int(_len(u_neighbors)))
          uv = (u <> v)
          uv_neighbors = []
          i = 0
          while_fun_5 = fn while_fun_5, i, uv_neighbors ->
            if i < _len(Map.get(graph_copy, u, [])) do
              n = Enum.at(graph_copy[u], i)
              {uv_neighbors} = if n != u && n != v && contains(uv_neighbors, n) == false do
                uv_neighbors = (uv_neighbors ++ [n])
                {uv_neighbors}
              else
                {uv_neighbors}
              end
              i = i + 1
              while_fun_5.(while_fun_5, i, uv_neighbors)
            else
              {i, uv_neighbors}
            end
          end
          {i, uv_neighbors} = try do
              while_fun_5.(while_fun_5, i, uv_neighbors)
            catch
              {:break, {i, uv_neighbors}} -> {i, uv_neighbors}
            end

          i = 0
          while_fun_6 = fn while_fun_6, i, uv_neighbors ->
            if i < _len(Map.get(graph_copy, v, [])) do
              n = Enum.at(graph_copy[v], i)
              {uv_neighbors} = if n != u && n != v && contains(uv_neighbors, n) == false do
                uv_neighbors = (uv_neighbors ++ [n])
                {uv_neighbors}
              else
                {uv_neighbors}
              end
              i = i + 1
              while_fun_6.(while_fun_6, i, uv_neighbors)
            else
              {i, uv_neighbors}
            end
          end
          {i, uv_neighbors} = try do
              while_fun_6.(while_fun_6, i, uv_neighbors)
            catch
              {:break, {i, uv_neighbors}} -> {i, uv_neighbors}
            end

          graph_copy = Map.put(graph_copy, uv, uv_neighbors)
          k = 0
          while_fun_7 = fn while_fun_7, graph_copy, k ->
            if k < _len(uv_neighbors) do
              nb = Enum.at(uv_neighbors, k)
              graph_copy = Map.put(graph_copy, nb, (graph_copy[nb] ++ [uv]))
              graph_copy = Map.put(graph_copy, nb, remove_all(graph_copy[nb], u))
              graph_copy = Map.put(graph_copy, nb, remove_all(graph_copy[nb], v))
              k = k + 1
              while_fun_7.(while_fun_7, graph_copy, k)
            else
              {graph_copy, k}
            end
          end
          {graph_copy, k} = try do
              while_fun_7.(while_fun_7, graph_copy, k)
            catch
              {:break, {graph_copy, k}} -> {graph_copy, k}
            end

          group = []
          i = 0
          while_fun_8 = fn while_fun_8, group, i ->
            if i < _len(Map.get(contracted, u, [])) do
              group = (group ++ [Enum.at(contracted[u], i)])
              i = i + 1
              while_fun_8.(while_fun_8, group, i)
            else
              {group, i}
            end
          end
          {group, i} = try do
              while_fun_8.(while_fun_8, group, i)
            catch
              {:break, {group, i}} -> {group, i}
            end

          i = 0
          while_fun_9 = fn while_fun_9, group, i ->
            if i < _len(Map.get(contracted, v, [])) do
              val = Enum.at(contracted[v], i)
              {group} = if contains(group, val) == false do
                group = (group ++ [val])
                {group}
              else
                {group}
              end
              i = i + 1
              while_fun_9.(while_fun_9, group, i)
            else
              {group, i}
            end
          end
          {group, i} = try do
              while_fun_9.(while_fun_9, group, i)
            catch
              {:break, {group, i}} -> {group, i}
            end

          contracted = Map.put(contracted, uv, group)
          nodes = remove_all(nodes, u)
          nodes = remove_all(nodes, v)
          nodes = (nodes ++ [uv])
          while_fun_4.(while_fun_4, contracted, graph_copy, nodes)
        else
          {contracted, graph_copy, nodes}
        end
      end
      {contracted, graph_copy, nodes} = try do
          while_fun_4.(while_fun_4, contracted, graph_copy, nodes)
        catch
          {:break, {contracted, graph_copy, nodes}} -> {contracted, graph_copy, nodes}
        end

      groups = []
      j = 0
      while_fun_10 = fn while_fun_10, groups, j ->
        if j < _len(nodes) do
          n = Enum.at(nodes, j)
          groups = (groups ++ [contracted[n]])
          j = j + 1
          while_fun_10.(while_fun_10, groups, j)
        else
          {groups, j}
        end
      end
      {groups, j} = try do
          while_fun_10.(while_fun_10, groups, j)
        catch
          {:break, {groups, j}} -> {groups, j}
        end

      groupA = Enum.at(groups, 0)
      groupB = Enum.at(groups, 1)
      cut = []
      j = 0
      while_fun_11 = fn while_fun_11, cut, j ->
        if j < _len(groupA) do
          node_ = Enum.at(groupA, j)
          neigh = graph[node_]
          l = 0
          while_fun_12 = fn while_fun_12, cut, l ->
            if l < _len(neigh) do
              nb = Enum.at(neigh, l)
              {cut} = if contains(groupB, nb) do
                cut = (cut ++ [%{a: node_, b: nb}])
                {cut}
              else
                {cut}
              end
              l = l + 1
              while_fun_12.(while_fun_12, cut, l)
            else
              {cut, l}
            end
          end
          {cut, l} = try do
              while_fun_12.(while_fun_12, cut, l)
            catch
              {:break, {cut, l}} -> {cut, l}
            end

          j = j + 1
          while_fun_11.(while_fun_11, cut, j)
        else
          {cut, j}
        end
      end
      {cut, j} = try do
          while_fun_11.(while_fun_11, cut, j)
        catch
          {:break, {cut, j}} -> {cut, j}
        end

      throw {:return, cut}
    catch
      {:return, val} -> val
    end
  end
  def cut_to_string(cut) do
    try do
      s = "{"
      i = 0
      while_fun_13 = fn while_fun_13, i, s ->
        if i < _len(cut) do
          p = Enum.at(cut, i)
          s = (((((s <> "(") <> p.a) <> ", ") <> p.b) <> ")")
          {s} = if i < _len(cut) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_13.(while_fun_13, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_13.(while_fun_13, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "}")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
  Process.put(:test_graph, %{"1" => ["2", "3", "4", "5"], "2" => ["1", "3", "4", "5"], "3" => ["1", "2", "4", "5", "10"], "4" => ["1", "2", "3", "5", "6"], "5" => ["1", "2", "3", "4", "7"], "6" => ["7", "8", "9", "10", "4"], "7" => ["6", "8", "9", "10", "5"], "8" => ["6", "7", "9", "10"], "9" => ["6", "7", "8", "10"], "10" => ["6", "7", "8", "9", "3"]})
  def main() do
    Process.put(:result, partition_graph(Process.get(:test_graph)))
    IO.puts(Kernel.inspect(cut_to_string(Process.get(:result))))
  end
end
Main.main()
