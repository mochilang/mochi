# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand_int(n) do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, rem(Process.get(:seed), n)}
    catch
      {:return, val} -> val
    end
  end
  def contains(list, value) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(list) do
          if Enum.at(list, i, []) == value do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def remove_all(list, value) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(list) do
          res = if Enum.at(list, i, []) != value do
            res = (res ++ [Enum.at(list, i, [])])
            res
          else
            res
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def partition_graph(graph) do
    try do
      contracted = %{}
      {contracted} = Enum.reduce(Map.keys(graph), {contracted}, fn node_, {contracted} ->
        contracted = Map.put(contracted, node_, [node_])
        {contracted}
      end)
      graph_copy = %{}
      {graph_copy} = Enum.reduce(Map.keys(graph), {graph_copy}, fn node_, {graph_copy} ->
        lst = []
        neigh = graph[node_]
        i = 0
        while_fun_3 = fn while_fun_3, i, lst ->
          if i < _len(neigh) do
            lst = (lst ++ [Enum.at(neigh, i, [])])
            i = i + 1
            while_fun_3.(while_fun_3, i, lst)
          else
            {i, lst}
          end
        end
        {i, lst} = try do
            while_fun_3.(while_fun_3, i, lst)
          catch
            {:break, {i, lst}} -> {i, lst}
          end

        graph_copy = Map.put(graph_copy, node_, lst)
        {graph_copy}
      end)
      nodes = Map.keys(graph_copy)
      while_fun_4 = fn while_fun_4, contracted, graph_copy, nodes ->
        if _len(nodes) > 2 do
          u = Enum.at(nodes, rand_int(_len(nodes)), [])
          u_neighbors = graph_copy[u]
          v = Enum.at(u_neighbors, rand_int(_len(u_neighbors)), [])
          uv = (u <> v)
          uv_neighbors = []
          i = 0
          while_fun_5 = fn while_fun_5, i, uv_neighbors ->
            if i < _len(Map.get(graph_copy, u, [])) do
              n = Enum.at(graph_copy[u], i, 0)
              uv_neighbors = if n != u && n != v && contains(uv_neighbors, n) == false do
                uv_neighbors = (uv_neighbors ++ [n])
                uv_neighbors
              else
                uv_neighbors
              end
              i = i + 1
              while_fun_5.(while_fun_5, i, uv_neighbors)
            else
              {i, uv_neighbors}
            end
          end
          {i, uv_neighbors} = try do
              while_fun_5.(while_fun_5, i, uv_neighbors)
            catch
              {:break, {i, uv_neighbors}} -> {i, uv_neighbors}
            end

          i = 0
          while_fun_6 = fn while_fun_6, i, uv_neighbors ->
            if i < _len(Map.get(graph_copy, v, [])) do
              n = Enum.at(graph_copy[v], i, 0)
              uv_neighbors = if n != u && n != v && contains(uv_neighbors, n) == false do
                uv_neighbors = (uv_neighbors ++ [n])
                uv_neighbors
              else
                uv_neighbors
              end
              i = i + 1
              while_fun_6.(while_fun_6, i, uv_neighbors)
            else
              {i, uv_neighbors}
            end
          end
          {i, uv_neighbors} = try do
              while_fun_6.(while_fun_6, i, uv_neighbors)
            catch
              {:break, {i, uv_neighbors}} -> {i, uv_neighbors}
            end

          graph_copy = Map.put(graph_copy, uv, uv_neighbors)
          k = 0
          while_fun_7 = fn while_fun_7, graph_copy, k ->
            if k < _len(uv_neighbors) do
              nb = Enum.at(uv_neighbors, k, [])
              graph_copy = Map.put(graph_copy, nb, (graph_copy[nb] ++ [uv]))
              graph_copy = Map.put(graph_copy, nb, remove_all(graph_copy[nb], u))
              graph_copy = Map.put(graph_copy, nb, remove_all(graph_copy[nb], v))
              k = k + 1
              while_fun_7.(while_fun_7, graph_copy, k)
            else
              {graph_copy, k}
            end
          end
          {graph_copy, k} = try do
              while_fun_7.(while_fun_7, graph_copy, k)
            catch
              {:break, {graph_copy, k}} -> {graph_copy, k}
            end

          group = []
          i = 0
          while_fun_8 = fn while_fun_8, group, i ->
            if i < _len(Map.get(contracted, u, [])) do
              group = (group ++ [Enum.at(contracted[u], i, 0)])
              i = i + 1
              while_fun_8.(while_fun_8, group, i)
            else
              {group, i}
            end
          end
          {group, i} = try do
              while_fun_8.(while_fun_8, group, i)
            catch
              {:break, {group, i}} -> {group, i}
            end

          i = 0
          while_fun_9 = fn while_fun_9, group, i ->
            if i < _len(Map.get(contracted, v, [])) do
              val = Enum.at(contracted[v], i, 0)
              group = if contains(group, val) == false do
                group = (group ++ [val])
                group
              else
                group
              end
              i = i + 1
              while_fun_9.(while_fun_9, group, i)
            else
              {group, i}
            end
          end
          {group, i} = try do
              while_fun_9.(while_fun_9, group, i)
            catch
              {:break, {group, i}} -> {group, i}
            end

          contracted = Map.put(contracted, uv, group)
          nodes = remove_all(nodes, u)
          nodes = remove_all(nodes, v)
          nodes = (nodes ++ [uv])
          while_fun_4.(while_fun_4, contracted, graph_copy, nodes)
        else
          {contracted, graph_copy, nodes}
        end
      end
      {contracted, graph_copy, nodes} = try do
          while_fun_4.(while_fun_4, contracted, graph_copy, nodes)
        catch
          {:break, {contracted, graph_copy, nodes}} -> {contracted, graph_copy, nodes}
        end

      groups = []
      j = 0
      while_fun_10 = fn while_fun_10, groups, j ->
        if j < _len(nodes) do
          n = Enum.at(nodes, j, [])
          groups = (groups ++ [contracted[n]])
          j = j + 1
          while_fun_10.(while_fun_10, groups, j)
        else
          {groups, j}
        end
      end
      {groups, j} = try do
          while_fun_10.(while_fun_10, groups, j)
        catch
          {:break, {groups, j}} -> {groups, j}
        end

      groupA = Enum.at(groups, 0, [])
      groupB = Enum.at(groups, 1, [])
      cut = []
      j = 0
      while_fun_11 = fn while_fun_11, cut, j ->
        if j < _len(groupA) do
          node_ = Enum.at(groupA, j, [])
          neigh = graph[node_]
          l = 0
          while_fun_12 = fn while_fun_12, cut, l ->
            if l < _len(neigh) do
              nb = Enum.at(neigh, l, [])
              cut = if contains(groupB, nb) do
                cut = (cut ++ [%{a: node_, b: nb}])
                cut
              else
                cut
              end
              l = l + 1
              while_fun_12.(while_fun_12, cut, l)
            else
              {cut, l}
            end
          end
          {cut, l} = try do
              while_fun_12.(while_fun_12, cut, l)
            catch
              {:break, {cut, l}} -> {cut, l}
            end

          j = j + 1
          while_fun_11.(while_fun_11, cut, j)
        else
          {cut, j}
        end
      end
      {cut, j} = try do
          while_fun_11.(while_fun_11, cut, j)
        catch
          {:break, {cut, j}} -> {cut, j}
        end

      throw {:return, cut}
    catch
      {:return, val} -> val
    end
  end
  def cut_to_string(cut) do
    try do
      s = "{"
      i = 0
      while_fun_13 = fn while_fun_13, i, s ->
        if i < _len(cut) do
          p = Enum.at(cut, i, [])
          s = (((((s <> "(") <> p.a) <> ", ") <> p.b) <> ")")
          s = if i < _len(cut) - 1 do
            s = (s <> ", ")
            s
          else
            s
          end
          i = i + 1
          while_fun_13.(while_fun_13, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_13.(while_fun_13, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "}")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
  Process.put(:test_graph, %{"1" => ["2", "3", "4", "5"], "2" => ["1", "3", "4", "5"], "3" => ["1", "2", "4", "5", "10"], "4" => ["1", "2", "3", "5", "6"], "5" => ["1", "2", "3", "4", "7"], "6" => ["7", "8", "9", "10", "4"], "7" => ["6", "8", "9", "10", "5"], "8" => ["6", "7", "9", "10"], "9" => ["6", "7", "8", "10"], "10" => ["6", "7", "8", "9", "3"]})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:result, partition_graph(Process.get(:test_graph)))
    IO.puts(Kernel.inspect(cut_to_string(Process.get(:result))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
