# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def key(p) do
    try do
      throw {:return, ((Kernel.to_string(p.x) <> ",") <> Kernel.to_string(p.y))}
    catch
      {:return, val} -> val
    end
  end
  def path_to_string(path) do
    try do
      s = "["
      i = 0
      while_fun = fn while_fun, i, s ->
        if i < _len(path) do
          pt = Enum.at(path, i, [])
          s = (((((s <> "(") <> Kernel.to_string(pt.x)) <> ", ") <> Kernel.to_string(pt.y)) <> ")")
          s = if i < _len(path) - 1 do
            s = (s <> ", ")
            s
          else
            s
          end
          i = i + 1
          while_fun.(while_fun, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun.(while_fun, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def dijkstra(grid, source, destination, allow_diagonal) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0, []))
      dx = [-1, 1, 0, 0]
      dy = [0, 0, -1, 1]
      {dx, dy} = if allow_diagonal do
        dx = (dx ++ [-1, -1, 1, 1])
        dy = (dy ++ [-1, 1, -1, 1])
        {dx, dy}
      else
        {dx, dy}
      end
      inf = 1000000000000.0
      queue = [source]
      front = 0
      dist_map = %{key(source) => 0.0}
      prev = %{}
      while_fun_2 = fn while_fun_2, dist_map, front, prev, queue ->
        if front < _len(queue) do
          current = Enum.at(queue, front, [])
          front = front + 1
          cur_key = key(current)
          if current.x == destination.x && current.y == destination.y do
            throw {:break, {dist_map, front, prev, queue}}
          end
          i = 0
          while_fun_3 = fn while_fun_3, dist_map, i, prev, queue ->
            if i < _len(dx) do
              nx = current.x + Enum.at(dx, i, [])
              ny = current.y + Enum.at(dy, i, [])
              {dist_map, prev, queue} = if nx >= 0 && nx < rows && ny >= 0 && ny < cols do
                {dist_map, prev, queue} = if Enum.at(Enum.at(grid, nx, []), ny, 0) == 1 do
                  n_key = ((Kernel.to_string(nx) <> ",") <> Kernel.to_string(ny))
                  {dist_map, prev, queue} = if !(Map.has_key?(dist_map, n_key)) do
                    dist_map = Map.put(dist_map, n_key, dist_map[cur_key] + 1.0)
                    prev = Map.put(prev, n_key, current)
                    queue = (queue ++ [%{x: nx, y: ny}])
                    {dist_map, prev, queue}
                  else
                    {dist_map, prev, queue}
                  end
                  {dist_map, prev, queue}
                else
                  {dist_map, prev, queue}
                end
                {dist_map, prev, queue}
              else
                {dist_map, prev, queue}
              end
              i = i + 1
              while_fun_3.(while_fun_3, dist_map, i, prev, queue)
            else
              {dist_map, i, prev, queue}
            end
          end
          {dist_map, i, prev, queue} = try do
              while_fun_3.(while_fun_3, dist_map, i, prev, queue)
            catch
              {:break, {dist_map, i, prev, queue}} -> {dist_map, i, prev, queue}
            end

          while_fun_2.(while_fun_2, dist_map, front, prev, queue)
        else
          {dist_map, front, prev, queue}
        end
      end
      {dist_map, front, prev, queue} = try do
          while_fun_2.(while_fun_2, dist_map, front, prev, queue)
        catch
          {:break, {dist_map, front, prev, queue}} -> {dist_map, front, prev, queue}
        end

      dest_key = key(destination)
      if Map.has_key?(dist_map, dest_key) do
        path_rev = [destination]
        step_key = dest_key
        step_pt = destination
        while_fun_4 = fn while_fun_4, path_rev, step_key, step_pt ->
          if step_key != key(source) do
            step_pt = prev[step_key]
            step_key = key(step_pt)
            path_rev = (path_rev ++ [step_pt])
            while_fun_4.(while_fun_4, path_rev, step_key, step_pt)
          else
            {path_rev, step_key, step_pt}
          end
        end
        {path_rev, step_key, step_pt} = try do
            while_fun_4.(while_fun_4, path_rev, step_key, step_pt)
          catch
            {:break, {path_rev, step_key, step_pt}} -> {path_rev, step_key, step_pt}
          end

        path = []
        k = _len(path_rev) - 1
        while_fun_5 = fn while_fun_5, k, path ->
          if k >= 0 do
            path = (path ++ [Enum.at(path_rev, k, [])])
            k = k - 1
            while_fun_5.(while_fun_5, k, path)
          else
            {k, path}
          end
        end
        {k, path} = try do
            while_fun_5.(while_fun_5, k, path)
          catch
            {:break, {k, path}} -> {k, path}
          end

        throw {:return, %{distance: dist_map[dest_key], path: path}}
      end
      throw {:return, %{distance: inf, path: []}}
    catch
      {:return, val} -> val
    end
  end
  def print_result(res) do
    try do
      IO.puts(((Kernel.to_string(res.distance) <> ", ") <> path_to_string(res.path)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:grid1, [[1, 1, 1], [0, 1, 0], [0, 1, 1]])
  Process.put(:grid2, [[1, 1, 1], [0, 0, 1], [0, 1, 1]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    print_result(dijkstra(Process.get(:grid1), %{x: 0, y: 0}, %{x: 2, y: 2}, false))
    print_result(dijkstra(Process.get(:grid1), %{x: 0, y: 0}, %{x: 2, y: 2}, true))
    print_result(dijkstra(Process.get(:grid2), %{x: 0, y: 0}, %{x: 2, y: 2}, false))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
