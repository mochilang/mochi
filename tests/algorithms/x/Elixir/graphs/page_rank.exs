# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def node_to_string(n) do
    try do
      throw {:return, (((((("<node=" <> n.name) <> " inbound=") ++ n.inbound) <> " outbound=") ++ n.outbound) <> ">")}
    catch
      {:return, val} -> val
    end
  end
  def page_rank(nodes, limit, d) do
    try do
      ranks = %{}
      {ranks} = Enum.reduce(nodes, {ranks}, fn n, {ranks} ->
        ranks = Map.put(ranks, n.name, 1.0)
        {ranks}
      end)
      outbounds = %{}
      {outbounds} = Enum.reduce(nodes, {outbounds}, fn n, {outbounds} ->
        outbounds = Map.put(outbounds, n.name, 1.0 * _len(Map.get(n, :outbound, [])))
        {outbounds}
      end)
      i = 0
      while_fun = fn while_fun, i, ranks ->
        if i < limit do
          IO.puts((("======= Iteration " <> Kernel.to_string(i + 1)) <> " ======="))
          {ranks} = Enum.reduce(nodes, {ranks}, fn n, {ranks} ->
            sum_val = 0.0
            {sum_val} = Enum.reduce(n.inbound, {sum_val}, fn ib, {sum_val} ->
              sum_val = sum_val + ranks[ib] / outbounds[ib]
              {sum_val}
            end)
            ranks = Map.put(ranks, n.name, (1.0 - d) + d * sum_val)
            {ranks}
          end)
          IO.puts(Kernel.inspect(ranks))
          i = i + 1
          while_fun.(while_fun, i, ranks)
        else
          {i, ranks}
        end
      end
      {i, ranks} = try do
          while_fun.(while_fun, i, ranks)
        catch
          {:break, {i, ranks}} -> {i, ranks}
        end

      throw {:return, ranks}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:names, ["A", "B", "C"])
  Process.put(:graph, [[0, 1, 1], [0, 0, 1], [1, 0, 0]])
  Process.put(:nodes, [])
  Process.put(:ri, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    {nodes} = Enum.reduce(Process.get(:names), {nodes}, fn name, {nodes} ->
      Process.put(:nodes, (Process.get(:nodes) ++ [%{name: name, inbound: [], outbound: []}]))
      {nodes}
    end)
    while_fun_2 = fn while_fun_2, nodes, ri ->
      if Process.get(:ri) < _len(Process.get(:graph)) do
        row = Enum.at(Process.get(:graph), Process.get(:ri), [])
        ci = 0
        while_fun_3 = fn while_fun_3, ci, nodes ->
          if ci < _len(row) do
            nodes = if Enum.at(row, ci, []) == 1 do
              n_in = Enum.at(Process.get(:nodes), ci, [])
              n_in = Map.put(n_in, :inbound, (n_in.inbound ++ [Enum.at(Process.get(:names), Process.get(:ri), [])]))
              Process.put(:nodes, List.replace_at(Process.get(:nodes), ci, n_in))
              n_out = Enum.at(Process.get(:nodes), Process.get(:ri), [])
              n_out = Map.put(n_out, :outbound, (n_out.outbound ++ [Enum.at(Process.get(:names), ci, [])]))
              Process.put(:nodes, List.replace_at(Process.get(:nodes), Process.get(:ri), n_out))
              nodes
            else
              nodes
            end
            ci = ci + 1
            while_fun_3.(while_fun_3, ci, nodes)
          else
            {ci, nodes}
          end
        end
        {ci, nodes} = try do
            while_fun_3.(while_fun_3, ci, nodes)
          catch
            {:break, {ci, nodes}} -> {ci, nodes}
          end

        Process.put(:ri, Process.get(:ri) + 1)
        while_fun_2.(while_fun_2, nodes, ri)
      else
        {nodes, ri}
      end
    end
    {nodes, ri} = try do
        while_fun_2.(while_fun_2, nodes, ri)
      catch
        {:break, {nodes, ri}} -> {nodes, ri}
      end

    IO.puts("======= Nodes =======")
    Enum.each(Process.get(:nodes), fn n ->
      IO.puts(Kernel.inspect(n))
    end)
    page_rank(Process.get(:nodes), 3, 0.85)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
