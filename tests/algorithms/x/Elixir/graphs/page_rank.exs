# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def node_to_string(n) do
    try do
      throw {:return, (((((("<node=" <> n.name) <> " inbound=") ++ n.inbound) <> " outbound=") ++ n.outbound) <> ">")}
    catch
      {:return, val} -> val
    end
  end
  def page_rank(nodes, limit, d) do
    try do
      ranks = %{}
      {ranks} = Enum.reduce(nodes, {ranks}, fn n, {ranks} ->
        ranks = Map.put(ranks, n.name, 1.0)
        {ranks}
      end)
      outbounds = %{}
      {outbounds} = Enum.reduce(nodes, {outbounds}, fn n, {outbounds} ->
        outbounds = Map.put(outbounds, n.name, 1.0 * _len(Map.get(n, :outbound, [])))
        {outbounds}
      end)
      i = 0
      while_fun = fn while_fun, i, ranks ->
        if i < limit do
          IO.puts((("======= Iteration " <> Kernel.to_string(i + 1)) <> " ======="))
          {ranks} = Enum.reduce(nodes, {ranks}, fn n, {ranks} ->
            sum_val = 0.0
            {sum_val} = Enum.reduce(n.inbound, {sum_val}, fn ib, {sum_val} ->
              sum_val = sum_val + ranks[ib] / outbounds[ib]
              {sum_val}
            end)
            ranks = Map.put(ranks, n.name, (1.0 - d) + d * sum_val)
            {ranks}
          end)
          IO.puts(Kernel.inspect(ranks))
          i = i + 1
          while_fun.(while_fun, i, ranks)
        else
          {i, ranks}
        end
      end
      {i, ranks} = try do
          while_fun.(while_fun, i, ranks)
        catch
          {:break, {i, ranks}} -> {i, ranks}
        end

      throw {:return, ranks}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:names, ["A", "B", "C"])
  Process.put(:graph, [[0, 1, 1], [0, 0, 1], [1, 0, 0]])
  Process.put(:nodes, [])
  Process.put(:ri, 0)
  def main() do
    Enum.each(Process.get(:names), fn name ->
      Process.put(:nodes, (Process.get(:nodes) ++ [%{name: name, inbound: [], outbound: []}]))
    end)
    while_fun_2 = fn while_fun_2 ->
      if Process.get(:ri) < _len(Process.get(:graph)) do
        row = Enum.at(Process.get(:graph), Process.get(:ri))
        ci = 0
        while_fun_3 = fn while_fun_3, ci ->
          if ci < _len(row) do
            if Enum.at(row, ci) == 1 do
              n_in = Enum.at(Process.get(:nodes), ci)
              n_in = Map.put(n_in, :inbound, (n_in.inbound ++ [Enum.at(Process.get(:names), Process.get(:ri))]))
              Process.put(:nodes, List.replace_at(Process.get(:nodes), ci, n_in))
              n_out = Enum.at(Process.get(:nodes), Process.get(:ri))
              n_out = Map.put(n_out, :outbound, (n_out.outbound ++ [Enum.at(Process.get(:names), ci)]))
              Process.put(:nodes, List.replace_at(Process.get(:nodes), Process.get(:ri), n_out))
            end
            ci = ci + 1
            while_fun_3.(while_fun_3, ci)
          else
            ci
          end
        end
        ci = try do
            while_fun_3.(while_fun_3, ci)
          catch
            {:break, {ci}} -> ci
          end

        Process.put(:ri, Process.get(:ri) + 1)
        while_fun_2.(while_fun_2)
      else
        nil
      end
    end
    try do
      while_fun_2.(while_fun_2)
    catch
      :break -> nil
    end

    IO.puts("======= Nodes =======")
    Enum.each(Process.get(:nodes), fn n ->
      IO.puts(Kernel.inspect(n))
    end)
    page_rank(Process.get(:nodes), 3, 0.85)
  end
end
Main.main()
