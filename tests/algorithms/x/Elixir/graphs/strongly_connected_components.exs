# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def topology_sort(graph, vert, visited) do
    try do
      visited = List.replace_at(visited, vert, true)
      order = []
      {order} = Enum.reduce(Enum.at(graph, vert), {order}, fn neighbour, {order} ->
        {order} = if !Enum.at(visited, neighbour) do
          order = (order ++ topology_sort(graph, neighbour, visited))
          {order}
        else
          {order}
        end
        {order}
      end)
      order = (order ++ [vert])
      throw {:return, order}
    catch
      {:return, val} -> val
    end
  end
  def find_component(graph, vert, visited) do
    try do
      visited = List.replace_at(visited, vert, true)
      comp = [vert]
      {comp} = Enum.reduce(Enum.at(graph, vert), {comp}, fn neighbour, {comp} ->
        {comp} = if !Enum.at(visited, neighbour) do
          comp = (comp ++ find_component(graph, neighbour, visited))
          {comp}
        else
          {comp}
        end
        {comp}
      end)
      throw {:return, comp}
    catch
      {:return, val} -> val
    end
  end
  def strongly_connected_components(graph) do
    try do
      n = _len(graph)
      visited = []
      {visited} = Enum.reduce((0..(n - 1)//1), {visited}, fn _, {visited} ->
        visited = (visited ++ [false])
        {visited}
      end)
      reversed = []
      {reversed} = Enum.reduce((0..(n - 1)//1), {reversed}, fn _, {reversed} ->
        reversed = (reversed ++ [[]])
        {reversed}
      end)
      {reversed} = Enum.reduce((0..(n - 1)//1), {reversed}, fn i, {reversed} ->
        {reversed} = Enum.reduce(Enum.at(graph, i), {reversed}, fn neighbour, {reversed} ->
          reversed = List.replace_at(reversed, neighbour, (Enum.at(reversed, neighbour) ++ [i]))
          {reversed}
        end)
        {reversed}
      end)
      order = []
      {order} = Enum.reduce((0..(n - 1)//1), {order}, fn i, {order} ->
        {order} = if !Enum.at(visited, i) do
          order = (order ++ topology_sort(graph, i, visited))
          {order}
        else
          {order}
        end
        {order}
      end)
      visited = []
      {visited} = Enum.reduce((0..(n - 1)//1), {visited}, fn _, {visited} ->
        visited = (visited ++ [false])
        {visited}
      end)
      components = []
      i = 0
      while_fun = fn while_fun, components, i ->
        if i < n do
          v = Enum.at(order, n - i - 1)
          {components} = if !Enum.at(visited, v) do
            comp = find_component(reversed, v, visited)
            components = (components ++ [comp])
            {components}
          else
            {components}
          end
          i = i + 1
          while_fun.(while_fun, components, i)
        else
          {components, i}
        end
      end
      {components, i} = try do
          while_fun.(while_fun, components, i)
        catch
          {:break, {components, i}} -> {components, i}
        end

      throw {:return, components}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_graph_1 = [[2, 3], [0], [1], [4], []]
      test_graph_2 = [[1, 2, 3], [2], [0], [4], [5], [3]]
      IO.puts(Kernel.inspect(strongly_connected_components(test_graph_1)))
      IO.puts(Kernel.inspect(strongly_connected_components(test_graph_2)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
