# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def remove_value(lst, val) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(lst) do
          {res} = if Enum.at(lst, i) != val do
            res = (res ++ [Enum.at(lst, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def greedy_min_vertex_cover(graph) do
    try do
      g = graph
      cover = []
      while_fun_2 = fn while_fun_2, cover, g ->
        if true do
          max_v = 0
          max_deg = 0
          {max_deg, max_v} = Enum.reduce(Map.keys(g), {max_deg, max_v}, fn v, {max_deg, max_v} ->
            key = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(v)
            deg = _len(Map.get(g, key, []))
            {max_deg, max_v} = if deg > max_deg do
              max_deg = deg
              max_v = key
              {max_deg, max_v}
            else
              {max_deg, max_v}
            end
            {max_deg, max_v}
          end)
          if max_deg == 0 do
            throw {:break, {cover, g}}
          end
          cover = (cover ++ [max_v])
          neighbors = g[max_v]
          i = 0
          while_fun_3 = fn while_fun_3, g, i ->
            if i < _len(neighbors) do
              n = Enum.at(neighbors, i)
              g = Map.put(g, n, remove_value(g[n], max_v))
              i = i + 1
              while_fun_3.(while_fun_3, g, i)
            else
              {g, i}
            end
          end
          {g, i} = try do
              while_fun_3.(while_fun_3, g, i)
            catch
              {:break, {g, i}} -> {g, i}
            end

          g = Map.put(g, max_v, [])
          while_fun_2.(while_fun_2, cover, g)
        else
          {cover, g}
        end
      end
      {cover, g} = try do
          while_fun_2.(while_fun_2, cover, g)
        catch
          {:break, {cover, g}} -> {cover, g}
        end

      throw {:return, cover}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, %{0 => [1, 3], 1 => [0, 3], 2 => [0, 3, 4], 3 => [0, 1, 2], 4 => [2, 3]})
  def main() do
    IO.puts(Kernel.inspect(greedy_min_vertex_cover(Process.get(:graph))))
  end
end
Main.main()
