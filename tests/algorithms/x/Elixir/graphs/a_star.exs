# Code generated by Mochi transpiler 2025-08-14 10:36 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def iabs(x) do
    try do
      throw {:return, ((if x < 0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def search(grid, init, goal, cost, heuristic) do
    try do
      closed = []
      r = 0
      while_fun = fn while_fun, closed, r ->
        if r < _len(grid) do
          row = []
          c = 0
          while_fun_2 = fn while_fun_2, c, row ->
            if c < _len(Enum.at(grid, 0, [])) do
              row = (row ++ [0])
              c = c + 1
              while_fun_2.(while_fun_2, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_2.(while_fun_2, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          closed = (closed ++ [row])
          r = r + 1
          while_fun.(while_fun, closed, r)
        else
          {closed, r}
        end
      end
      {closed, r} = try do
          while_fun.(while_fun, closed, r)
        catch
          {:break, {closed, r}} -> {closed, r}
        end

      closed = List.replace_at(closed, Enum.at(init, 0, []), List.replace_at(Enum.at(closed, Enum.at(init, 0, [])), Enum.at(init, 1, []), 1))
      action = []
      r = 0
      while_fun_3 = fn while_fun_3, action, r ->
        if r < _len(grid) do
          row = []
          c = 0
          while_fun_4 = fn while_fun_4, c, row ->
            if c < _len(Enum.at(grid, 0, [])) do
              row = (row ++ [0])
              c = c + 1
              while_fun_4.(while_fun_4, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_4.(while_fun_4, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          action = (action ++ [row])
          r = r + 1
          while_fun_3.(while_fun_3, action, r)
        else
          {action, r}
        end
      end
      {action, r} = try do
          while_fun_3.(while_fun_3, action, r)
        catch
          {:break, {action, r}} -> {action, r}
        end

      x = Enum.at(init, 0, [])
      y = Enum.at(init, 1, [])
      g = 0
      f = g + Enum.at(Enum.at(heuristic, x, []), y, 0)
      cell = [[f, g, x, y]]
      found = false
      resign = false
      while_fun_5 = fn while_fun_5, action, cell, closed, found, g, x, y ->
        if (!found) && (!resign) do
          {action, cell, closed, found, g, x, y} = if _len(cell) == 0 do
            raise("Algorithm is unable to find solution")
            {action, cell, closed, found, g, x, y}
          else
            best_i = 0
            best_f = Enum.at(Enum.at(cell, 0, []), 0, 0)
            i = 1
            while_fun_6 = fn while_fun_6, best_f, best_i, i ->
              if i < _len(cell) do
                {best_f, best_i} = if Enum.at(Enum.at(cell, i, []), 0, 0) < best_f do
                  best_f = Enum.at(Enum.at(cell, i, []), 0, 0)
                  best_i = i
                  {best_f, best_i}
                else
                  {best_f, best_i}
                end
                i = i + 1
                while_fun_6.(while_fun_6, best_f, best_i, i)
              else
                {best_f, best_i, i}
              end
            end
            {best_f, best_i, i} = try do
                while_fun_6.(while_fun_6, best_f, best_i, i)
              catch
                {:break, {best_f, best_i, i}} -> {best_f, best_i, i}
              end

            next_cell = Enum.at(cell, best_i, [])
            new_cell = []
            i = 0
            while_fun_7 = fn while_fun_7, i, new_cell ->
              if i < _len(cell) do
                new_cell = if i != best_i do
                  new_cell = (new_cell ++ [Enum.at(cell, i, [])])
                  new_cell
                else
                  new_cell
                end
                i = i + 1
                while_fun_7.(while_fun_7, i, new_cell)
              else
                {i, new_cell}
              end
            end
            {i, new_cell} = try do
                while_fun_7.(while_fun_7, i, new_cell)
              catch
                {:break, {i, new_cell}} -> {i, new_cell}
              end

            cell = new_cell
            x = Enum.at(next_cell, 2, [])
            y = Enum.at(next_cell, 3, [])
            g = Enum.at(next_cell, 1, [])
            {action, cell, closed, found} = if x == Enum.at(goal, 0, []) && y == Enum.at(goal, 1, []) do
              found = true
              {action, cell, closed, found}
            else
              d = 0
              while_fun_8 = fn while_fun_8, action, cell, closed, d ->
                if d < _len(Process.get(:directions)) do
                  x2 = x + Enum.at(Enum.at(Process.get(:directions), d, []), 0, 0)
                  y2 = y + Enum.at(Enum.at(Process.get(:directions), d, []), 1, 0)
                  {action, cell, closed} = if x2 >= 0 && x2 < _len(grid) && y2 >= 0 && y2 < _len(Enum.at(grid, 0, [])) && Enum.at(Enum.at(closed, x2, []), y2, 0) == 0 && Enum.at(Enum.at(grid, x2, []), y2, 0) == 0 do
                    g2 = g + cost
                    f2 = g2 + Enum.at(Enum.at(heuristic, x2, []), y2, 0)
                    cell = (cell ++ [[f2, g2, x2, y2]])
                    closed = List.replace_at(closed, x2, List.replace_at(Enum.at(closed, x2), y2, 1))
                    action = List.replace_at(action, x2, List.replace_at(Enum.at(action, x2), y2, d))
                    {action, cell, closed}
                  else
                    {action, cell, closed}
                  end
                  d = d + 1
                  while_fun_8.(while_fun_8, action, cell, closed, d)
                else
                  {action, cell, closed, d}
                end
              end
              {action, cell, closed, d} = try do
                  while_fun_8.(while_fun_8, action, cell, closed, d)
                catch
                  {:break, {action, cell, closed, d}} -> {action, cell, closed, d}
                end

              {action, cell, closed, found}
            end
            {action, cell, closed, found, g, x, y}
          end
          while_fun_5.(while_fun_5, action, cell, closed, found, g, x, y)
        else
          {action, cell, closed, found, g, x, y}
        end
      end
      {action, cell, closed, found, g, x, y} = try do
          while_fun_5.(while_fun_5, action, cell, closed, found, g, x, y)
        catch
          {:break, {action, cell, closed, found, g, x, y}} -> {action, cell, closed, found, g, x, y}
        end

      invpath = []
      x = Enum.at(goal, 0, [])
      y = Enum.at(goal, 1, [])
      invpath = (invpath ++ [[x, y]])
      while_fun_9 = fn while_fun_9, invpath, x, y ->
        if x != Enum.at(init, 0, []) || y != Enum.at(init, 1, []) do
          dir = Enum.at(Enum.at(action, x, []), y, 0)
          x2 = x - Enum.at(Enum.at(Process.get(:directions), dir, []), 0, 0)
          y2 = y - Enum.at(Enum.at(Process.get(:directions), dir, []), 1, 0)
          x = x2
          y = y2
          invpath = (invpath ++ [[x, y]])
          while_fun_9.(while_fun_9, invpath, x, y)
        else
          {invpath, x, y}
        end
      end
      {invpath, x, y} = try do
          while_fun_9.(while_fun_9, invpath, x, y)
        catch
          {:break, {invpath, x, y}} -> {invpath, x, y}
        end

      path = []
      idx = _len(invpath) - 1
      while_fun_10 = fn while_fun_10, idx, path ->
        if idx >= 0 do
          path = (path ++ [Enum.at(invpath, idx, [])])
          idx = idx - 1
          while_fun_10.(while_fun_10, idx, path)
        else
          {idx, path}
        end
      end
      {idx, path} = try do
          while_fun_10.(while_fun_10, idx, path)
        catch
          {:break, {idx, path}} -> {idx, path}
        end

      throw {:return, %{path: path, action: action}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      grid = [[0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0]]
      init = [0, 0]
      goal = [_len(grid) - 1, _len(Enum.at(grid, 0, [])) - 1]
      cost = 1
      heuristic = []
      i = 0
      while_fun_11 = fn while_fun_11, heuristic, i ->
        if i < _len(grid) do
          row = []
          j = 0
          while_fun_12 = fn while_fun_12, j, row ->
            if j < _len(Enum.at(grid, 0, [])) do
              h = iabs(i - Enum.at(goal, 0, [])) + iabs(j - Enum.at(goal, 1, []))
              row = (if Enum.at(Enum.at(grid, i, []), j, 0) == 1, do: (row ++ [99]), else: (row ++ [h]))
              j = j + 1
              while_fun_12.(while_fun_12, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_12.(while_fun_12, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          heuristic = (heuristic ++ [row])
          i = i + 1
          while_fun_11.(while_fun_11, heuristic, i)
        else
          {heuristic, i}
        end
      end
      {heuristic, i} = try do
          while_fun_11.(while_fun_11, heuristic, i)
        catch
          {:break, {heuristic, i}} -> {heuristic, i}
        end

      result = search(grid, init, goal, cost, heuristic)
      IO.puts("ACTION MAP")
      rr = 0
      while_fun_13 = fn while_fun_13, rr ->
        if rr < _len(Map.get(result, :action, [])) do
          IO.puts(Kernel.inspect(Enum.at(result.action, rr, 0)))
          rr = rr + 1
          while_fun_13.(while_fun_13, rr)
        else
          rr
        end
      end
      rr = try do
          while_fun_13.(while_fun_13, rr)
        catch
          {:break, {rr}} -> rr
        end

      p = 0
      while_fun_14 = fn while_fun_14, p ->
        if p < _len(Map.get(result, :path, [])) do
          IO.puts(Kernel.inspect(Enum.at(result.path, p, 0)))
          p = p + 1
          while_fun_14.(while_fun_14, p)
        else
          p
        end
      end
      p = try do
          while_fun_14.(while_fun_14, p)
        catch
          {:break, {p}} -> p
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:directions, [[-1, 0], [0, -1], [1, 0], [0, 1]])
Main.bench_main()
