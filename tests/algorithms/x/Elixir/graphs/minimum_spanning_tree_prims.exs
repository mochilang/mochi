# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pairs_to_string(edges) do
    try do
      s = "["
      i = 0
      while_fun = fn while_fun, i, s ->
        if i < _len(edges) do
          e = Enum.at(edges, i)
          s = (((((s <> "(") <> Kernel.to_string(e.u)) <> ", ") <> Kernel.to_string(e.v)) <> ")")
          {s} = if i < _len(edges) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun.(while_fun, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun.(while_fun, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def prim_mst(graph) do
    try do
      n = _len(graph)
      visited = []
      dist = []
      parent = []
      i = 0
      while_fun_2 = fn while_fun_2, dist, i, parent, visited ->
        if i < n do
          visited = (visited ++ [false])
          dist = (dist ++ [Process.get(:inf)])
          parent = (parent ++ [-1])
          i = i + 1
          while_fun_2.(while_fun_2, dist, i, parent, visited)
        else
          {dist, i, parent, visited}
        end
      end
      {dist, i, parent, visited} = try do
          while_fun_2.(while_fun_2, dist, i, parent, visited)
        catch
          {:break, {dist, i, parent, visited}} -> {dist, i, parent, visited}
        end

      dist = List.replace_at(dist, 0, 0)
      result = []
      count = 0
      while_fun_3 = fn while_fun_3, count, dist, parent, result, visited ->
        if count < n do
          min_val = Process.get(:inf)
          u = 0
          v = 0
          while_fun_4 = fn while_fun_4, min_val, u, v ->
            if v < n do
              {min_val, u} = if Enum.at(visited, v) == false && Enum.at(dist, v) < min_val do
                min_val = Enum.at(dist, v)
                u = v
                {min_val, u}
              else
                {min_val, u}
              end
              v = v + 1
              while_fun_4.(while_fun_4, min_val, u, v)
            else
              {min_val, u, v}
            end
          end
          {min_val, u, v} = try do
              while_fun_4.(while_fun_4, min_val, u, v)
            catch
              {:break, {min_val, u, v}} -> {min_val, u, v}
            end

          if min_val == Process.get(:inf) do
            throw {:break, {count, dist, parent, result, visited}}
          end
          visited = List.replace_at(visited, u, true)
          {result} = if u != 0 do
            result = (result ++ [%{u: Enum.at(parent, u), v: u}])
            {result}
          else
            {result}
          end
          {dist, parent} = Enum.reduce(Enum.at(graph, u), {dist, parent}, fn e, {dist, parent} ->
            {dist, parent} = if Enum.at(visited, e.to) == false && e.weight < Enum.at(dist, e.to) do
              dist = List.replace_at(dist, e.to, e.weight)
              parent = List.replace_at(parent, e.to, u)
              {dist, parent}
            else
              {dist, parent}
            end
            {dist, parent}
          end)
          count = count + 1
          while_fun_3.(while_fun_3, count, dist, parent, result, visited)
        else
          {count, dist, parent, result, visited}
        end
      end
      {count, dist, parent, result, visited} = try do
          while_fun_3.(while_fun_3, count, dist, parent, result, visited)
        catch
          {:break, {count, dist, parent, result, visited}} -> {count, dist, parent, result, visited}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:inf, 1000000000)
  Process.put(:adjacency_list, [[%{to: 1, weight: 1}, %{to: 3, weight: 3}], [%{to: 0, weight: 1}, %{to: 2, weight: 6}, %{to: 3, weight: 5}, %{to: 4, weight: 1}], [%{to: 1, weight: 6}, %{to: 4, weight: 5}, %{to: 5, weight: 2}], [%{to: 0, weight: 3}, %{to: 1, weight: 5}, %{to: 4, weight: 1}], [%{to: 1, weight: 1}, %{to: 2, weight: 5}, %{to: 3, weight: 1}, %{to: 5, weight: 4}], [%{to: 2, weight: 2}, %{to: 4, weight: 4}]])
  def main() do
    Process.put(:mst_edges, prim_mst(Process.get(:adjacency_list)))
    IO.puts(Kernel.inspect(pairs_to_string(Process.get(:mst_edges))))
  end
end
Main.main()
