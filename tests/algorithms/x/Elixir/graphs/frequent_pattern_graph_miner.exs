# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def contains(lst, item) do
    try do
      Enum.each(lst, fn v ->
        if v == item do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def get_distinct_edge(edge_array) do
    try do
      distinct = []
      {distinct} = Enum.reduce(edge_array, {distinct}, fn row, {distinct} ->
        {distinct} = Enum.reduce(row, {distinct}, fn item, {distinct} ->
          e = Enum.at(item, 0)
          {distinct} = if !contains(distinct, e) do
            distinct = (distinct ++ [e])
            {distinct}
          else
            {distinct}
          end
          {distinct}
        end)
        {distinct}
      end)
      throw {:return, distinct}
    catch
      {:return, val} -> val
    end
  end
  def get_bitcode(edge_array, de) do
    try do
      bitcode = ""
      i = 0
      while_fun = fn while_fun, bitcode, i ->
        if i < _len(edge_array) do
          found = false
          {found} = Enum.reduce(Enum.at(edge_array, i), {found}, fn item, {found} ->
            try do
              {found} = if Enum.at(item, 0) == de do
                found = true
                throw {:break, {bitcode, i}}
                {found}
              else
                {found}
              end
            catch
              :continue -> {found}
            end
            {found}
          end)
          bitcode = (if found, do: (bitcode <> "1"), else: (bitcode <> "0"))
          i = i + 1
          while_fun.(while_fun, bitcode, i)
        else
          {bitcode, i}
        end
      end
      {bitcode, i} = try do
          while_fun.(while_fun, bitcode, i)
        catch
          {:break, {bitcode, i}} -> {bitcode, i}
        end

      throw {:return, bitcode}
    catch
      {:return, val} -> val
    end
  end
  def count_ones(s) do
    try do
      c = 0
      i = 0
      while_fun_2 = fn while_fun_2, c, i ->
        if i < _len(s) do
          {c} = if _slice(s, i, i + 1 - (i)) == "1" do
            c = c + 1
            {c}
          else
            {c}
          end
          i = i + 1
          while_fun_2.(while_fun_2, c, i)
        else
          {c, i}
        end
      end
      {c, i} = try do
          while_fun_2.(while_fun_2, c, i)
        catch
          {:break, {c, i}} -> {c, i}
        end

      throw {:return, c}
    catch
      {:return, val} -> val
    end
  end
  def get_frequency_table(edge_array) do
    try do
      distinct = get_distinct_edge(edge_array)
      table = []
      {table} = Enum.reduce(distinct, {table}, fn e, {table} ->
        bit = get_bitcode(edge_array, e)
        cnt = count_ones(bit)
        entry = %{"edge" => e, "count" => Kernel.to_string(cnt), "bit" => bit}
        table = (table ++ [entry])
        {table}
      end)
      i = 0
      while_fun_3 = fn while_fun_3, i, table ->
        if i < _len(table) do
          max_i = i
          j = i + 1
          while_fun_4 = fn while_fun_4, j, max_i ->
            if j < _len(table) do
              {max_i} = if toi(Map.get(Enum.at(table, j), "count", "")) > toi(Map.get(Enum.at(table, max_i), "count", "")) do
                max_i = j
                {max_i}
              else
                {max_i}
              end
              j = j + 1
              while_fun_4.(while_fun_4, j, max_i)
            else
              {j, max_i}
            end
          end
          {j, max_i} = try do
              while_fun_4.(while_fun_4, j, max_i)
            catch
              {:break, {j, max_i}} -> {j, max_i}
            end

          tmp = Enum.at(table, i)
          table = List.replace_at(table, i, Enum.at(table, max_i))
          table = List.replace_at(table, max_i, tmp)
          i = i + 1
          while_fun_3.(while_fun_3, i, table)
        else
          {i, table}
        end
      end
      {i, table} = try do
          while_fun_3.(while_fun_3, i, table)
        catch
          {:break, {i, table}} -> {i, table}
        end

      throw {:return, table}
    catch
      {:return, val} -> val
    end
  end
  def get_nodes(freq_table) do
    try do
      nodes = %{}
      keys = []
      {keys, nodes} = Enum.reduce(freq_table, {keys, nodes}, fn f, {keys, nodes} ->
        code = Map.get(f, "bit", "")
        edge = Map.get(f, "edge", "")
        {keys, nodes} = if Map.has_key?(nodes, code) do
          nodes = Map.put(nodes, code, (nodes[code] ++ [edge]))
          {keys, nodes}
        else
          nodes = Map.put(nodes, code, [edge])
          keys = (keys ++ [code])
          {keys, nodes}
        end
        {keys, nodes}
      end)
      throw {:return, %{map: nodes, keys: keys}}
    catch
      {:return, val} -> val
    end
  end
  def get_cluster(nodes) do
    try do
      clusters = %{}
      weights = []
      i = 0
      while_fun_5 = fn while_fun_5, clusters, i, weights ->
        if i < _len(Map.get(nodes, :keys, [])) do
          code = Enum.at(nodes.keys, i)
          wt = count_ones(code)
          {clusters, weights} = if Map.has_key?(clusters, wt) do
            clusters = Map.put(clusters, wt, (clusters[wt] ++ [code]))
            {clusters, weights}
          else
            clusters = Map.put(clusters, wt, [code])
            weights = (weights ++ [wt])
            {clusters, weights}
          end
          i = i + 1
          while_fun_5.(while_fun_5, clusters, i, weights)
        else
          {clusters, i, weights}
        end
      end
      {clusters, i, weights} = try do
          while_fun_5.(while_fun_5, clusters, i, weights)
        catch
          {:break, {clusters, i, weights}} -> {clusters, i, weights}
        end

      throw {:return, %{clusters: clusters, weights: weights}}
    catch
      {:return, val} -> val
    end
  end
  def get_support(clusters) do
    try do
      sup = []
      i = 0
      while_fun_6 = fn while_fun_6, i, sup ->
        if i < _len(Map.get(clusters, :weights, [])) do
          w = Enum.at(clusters.weights, i)
          sup = (sup ++ [div(w * 100, _len(Map.get(clusters, :weights, [])))])
          i = i + 1
          while_fun_6.(while_fun_6, i, sup)
        else
          {i, sup}
        end
      end
      {i, sup} = try do
          while_fun_6.(while_fun_6, i, sup)
        catch
          {:break, {i, sup}} -> {i, sup}
        end

      throw {:return, sup}
    catch
      {:return, val} -> val
    end
  end
  def contains_bits(a, b) do
    try do
      i = 0
      while_fun_7 = fn while_fun_7, i ->
        if i < _len(a) do
          c1 = _slice(a, i, i + 1 - (i))
          c2 = _slice(b, i, i + 1 - (i))
          if c1 == "1" && c2 != "1" do
            throw {:return, false}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      i = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def max_cluster_key(clusters) do
    try do
      m = 0
      i = 0
      while_fun_8 = fn while_fun_8, i, m ->
        if i < _len(Map.get(clusters, :weights, [])) do
          w = Enum.at(clusters.weights, i)
          {m} = if w > m do
            m = w
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_8.(while_fun_8, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def get_cluster_codes(clusters, wt) do
    try do
      throw {:return, ((if Map.has_key?(clusters.clusters, wt), do: clusters.clusters[wt], else: []))}
    catch
      {:return, val} -> val
    end
  end
  def create_edge(nodes, graph, gkeys, clusters, c1, maxk) do
    try do
      keys = gkeys
      codes1 = get_cluster_codes(clusters, c1)
      idx1 = 0
      while_fun_9 = fn while_fun_9, graph, idx1, keys ->
        if idx1 < _len(codes1) do
          i_code = Enum.at(codes1, idx1)
          count = 0
          c2 = c1 + 1
          while_fun_10 = fn while_fun_10, c2, count, graph, keys ->
            if c2 <= maxk do
              codes2 = get_cluster_codes(clusters, c2)
              j = 0
              while_fun_11 = fn while_fun_11, count, graph, j, keys ->
                if j < _len(codes2) do
                  j_code = Enum.at(codes2, j)
                  {count, graph, keys} = if contains_bits(i_code, j_code) do
                    {graph, keys} = if Map.has_key?(graph, i_code) do
                      graph = Map.put(graph, i_code, (graph[i_code] ++ [j_code]))
                      {graph, keys}
                    else
                      graph = Map.put(graph, i_code, [j_code])
                      {keys} = if !contains(keys, i_code) do
                        keys = (keys ++ [i_code])
                        {keys}
                      else
                        {keys}
                      end
                      {graph, keys}
                    end
                    {keys} = if !contains(keys, j_code) do
                      keys = (keys ++ [j_code])
                      {keys}
                    else
                      {keys}
                    end
                    count = count + 1
                    {count, graph, keys}
                  else
                    {count, graph, keys}
                  end
                  j = j + 1
                  while_fun_11.(while_fun_11, count, graph, j, keys)
                else
                  {count, graph, j, keys}
                end
              end
              {count, graph, j, keys} = try do
                  while_fun_11.(while_fun_11, count, graph, j, keys)
                catch
                  {:break, {count, graph, j, keys}} -> {count, graph, j, keys}
                end

              {c2} = if count == 0 do
                c2 = c2 + 1
                {c2}
              else
                throw {:break, {c2, count, graph, keys}}
                {c2}
              end
              while_fun_10.(while_fun_10, c2, count, graph, keys)
            else
              {c2, count, graph, keys}
            end
          end
          {c2, count, graph, keys} = try do
              while_fun_10.(while_fun_10, c2, count, graph, keys)
            catch
              {:break, {c2, count, graph, keys}} -> {c2, count, graph, keys}
            end

          idx1 = idx1 + 1
          while_fun_9.(while_fun_9, graph, idx1, keys)
        else
          {graph, idx1, keys}
        end
      end
      {graph, idx1, keys} = try do
          while_fun_9.(while_fun_9, graph, idx1, keys)
        catch
          {:break, {graph, idx1, keys}} -> {graph, idx1, keys}
        end

      throw {:return, keys}
    catch
      {:return, val} -> val
    end
  end
  def construct_graph(clusters, nodes) do
    try do
      maxk = max_cluster_key(clusters)
      top_codes = get_cluster_codes(clusters, maxk)
      graph = %{}
      keys = ["Header"]
      graph = Map.put(graph, "Header", [])
      i = 0
      while_fun_12 = fn while_fun_12, graph, i, keys ->
        if i < _len(top_codes) do
          code = Enum.at(top_codes, i)
          graph = Map.put(graph, "Header", (graph["Header"] ++ [code]))
          graph = Map.put(graph, code, ["Header"])
          keys = (keys ++ [code])
          i = i + 1
          while_fun_12.(while_fun_12, graph, i, keys)
        else
          {graph, i, keys}
        end
      end
      {graph, i, keys} = try do
          while_fun_12.(while_fun_12, graph, i, keys)
        catch
          {:break, {graph, i, keys}} -> {graph, i, keys}
        end

      c = 1
      while_fun_13 = fn while_fun_13, c, keys ->
        if c < maxk do
          keys = create_edge(nodes, graph, keys, clusters, c, maxk)
          c = c + 1
          while_fun_13.(while_fun_13, c, keys)
        else
          {c, keys}
        end
      end
      {c, keys} = try do
          while_fun_13.(while_fun_13, c, keys)
        catch
          {:break, {c, keys}} -> {c, keys}
        end

      throw {:return, %{edges: graph, keys: keys}}
    catch
      {:return, val} -> val
    end
  end
  def copy_list(lst) do
    try do
      n = []
      {n} = Enum.reduce(lst, {n}, fn v, {n} ->
        n = (n ++ [v])
        {n}
      end)
      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def my_dfs(graph, start, end_, path) do
    try do
      new_path = copy_list(path)
      new_path = (new_path ++ [start])
      if start == end_ do
        Process.put(:paths, (Process.get(:paths) ++ [new_path]))
        throw {:return, nil}
      end
      Enum.each(graph[start], fn node_ ->
        seen = false
        {seen} = Enum.reduce(new_path, {seen}, fn p, {seen} ->
          {seen} = if p == node_ do
            seen = true
            {seen}
          else
            {seen}
          end
          {seen}
        end)
        if !seen do
          my_dfs(graph, node_, end_, new_path)
        end
      end)
    catch
      {:return, val} -> val
    end
  end
  def find_freq_subgraph_given_support(s, clusters, graph) do
    try do
      k = div(s * _len(Map.get(clusters, :weights, [])), 100)
      codes = get_cluster_codes(clusters, k)
      i = 0
      while_fun_14 = fn while_fun_14, i ->
        if i < _len(codes) do
          my_dfs(Map.get(graph, :edges, []), Enum.at(codes, i), "Header", [])
          i = i + 1
          while_fun_14.(while_fun_14, i)
        else
          i
        end
      end
      i = try do
          while_fun_14.(while_fun_14, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def node_edges(nodes, code) do
    try do
      throw {:return, nodes.map[code]}
    catch
      {:return, val} -> val
    end
  end
  def freq_subgraphs_edge_list(paths, nodes) do
    try do
      freq_sub_el = []
      {freq_sub_el} = Enum.reduce(paths, {freq_sub_el}, fn path, {freq_sub_el} ->
        el = []
        j = 0
        while_fun_15 = fn while_fun_15, el, j ->
          if j < _len(path) - 1 do
            code = Enum.at(path, j)
            edge_list = node_edges(nodes, code)
            e = 0
            while_fun_16 = fn while_fun_16, e, el ->
              if e < _len(edge_list) do
                edge = Enum.at(edge_list, e)
                a = _slice(edge, 0, 1 - (0))
                b = _slice(edge, 1, 2 - (1))
                el = (el ++ [[a, b]])
                e = e + 1
                while_fun_16.(while_fun_16, e, el)
              else
                {e, el}
              end
            end
            {e, el} = try do
                while_fun_16.(while_fun_16, e, el)
              catch
                {:break, {e, el}} -> {e, el}
              end

            j = j + 1
            while_fun_15.(while_fun_15, el, j)
          else
            {el, j}
          end
        end
        {el, j} = try do
            while_fun_15.(while_fun_15, el, j)
          catch
            {:break, {el, j}} -> {el, j}
          end

        freq_sub_el = (freq_sub_el ++ [el])
        {freq_sub_el}
      end)
      throw {:return, freq_sub_el}
    catch
      {:return, val} -> val
    end
  end
  def print_all(nodes, support, clusters, graph, freq_subgraph_edge_list) do
    try do
      IO.puts("\nNodes\n")
      i = 0
      while_fun_17 = fn while_fun_17, i ->
        if i < _len(Map.get(nodes, :keys, [])) do
          code = Enum.at(nodes.keys, i)
          IO.puts(code)
          IO.puts(Kernel.inspect(nodes.map[code]))
          i = i + 1
          while_fun_17.(while_fun_17, i)
        else
          i
        end
      end
      i = try do
          while_fun_17.(while_fun_17, i)
        catch
          {:break, {i}} -> i
        end

      IO.puts("\nSupport\n")
      IO.puts(Kernel.inspect(support))
      IO.puts("\nCluster\n")
      j = 0
      while_fun_18 = fn while_fun_18, j ->
        if j < _len(Map.get(clusters, :weights, [])) do
          w = Enum.at(clusters.weights, j)
          IO.puts(((Kernel.to_string(w) <> ":") <> Kernel.to_string(clusters.clusters[w])))
          j = j + 1
          while_fun_18.(while_fun_18, j)
        else
          j
        end
      end
      j = try do
          while_fun_18.(while_fun_18, j)
        catch
          {:break, {j}} -> j
        end

      IO.puts("\nGraph\n")
      k = 0
      while_fun_19 = fn while_fun_19, k ->
        if k < _len(Map.get(graph, :keys, [])) do
          key = Enum.at(graph.keys, k)
          IO.puts(key)
          IO.puts(Kernel.inspect(graph.edges[key]))
          k = k + 1
          while_fun_19.(while_fun_19, k)
        else
          k
        end
      end
      k = try do
          while_fun_19.(while_fun_19, k)
        catch
          {:break, {k}} -> k
        end

      IO.puts("\nEdge List of Frequent subgraphs\n")
      Enum.each(freq_subgraph_edge_list, fn el ->
        IO.puts(Kernel.inspect(el))
      end)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      frequency_table = get_frequency_table(Process.get(:edge_array))
      nodes = get_nodes(frequency_table)
      clusters = get_cluster(nodes)
      support = get_support(clusters)
      graph = construct_graph(clusters, nodes)
      find_freq_subgraph_given_support(60, clusters, graph)
      freq_subgraph_edge_list = freq_subgraphs_edge_list(Process.get(:paths), nodes)
      print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:edge_array, [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]])
  Process.put(:paths, [])
  def bench_main() do
    Process.put(:edge_array, [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]])
    Process.put(:paths, [])
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
