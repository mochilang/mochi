# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sort_edges(edges) do
    try do
      es = edges
      i = 0
      while_fun = fn while_fun, es, i ->
        if i < _len(es) do
          j = 0
          while_fun_2 = fn while_fun_2, es, j ->
            if j < _len(es) - i - 1 do
              {es} = if Enum.at(Enum.at(es, j), 2) > Enum.at(Enum.at(es, j + 1), 2) do
                temp = Enum.at(es, j)
                es = List.replace_at(es, j, Enum.at(es, j + 1))
                es = List.replace_at(es, j + 1, temp)
                {es}
              else
                {es}
              end
              j = j + 1
              while_fun_2.(while_fun_2, es, j)
            else
              {es, j}
            end
          end
          {es, j} = try do
              while_fun_2.(while_fun_2, es, j)
            catch
              {:break, {es, j}} -> {es, j}
            end

          i = i + 1
          while_fun.(while_fun, es, i)
        else
          {es, i}
        end
      end
      {es, i} = try do
          while_fun.(while_fun, es, i)
        catch
          {:break, {es, i}} -> {es, i}
        end

      throw {:return, es}
    catch
      {:return, val} -> val
    end
  end
  def find_parent(parent, i) do
    try do
      {parent} = if Enum.at(parent, i) != i do
        parent = List.replace_at(parent, i, find_parent(parent, Enum.at(parent, i)))
        {parent}
      else
        {parent}
      end
      throw {:return, Enum.at(parent, i)}
    catch
      {:return, val} -> val
    end
  end
  def kruskal(num_nodes, edges) do
    try do
      es = sort_edges(edges)
      parent = []
      i = 0
      while_fun_3 = fn while_fun_3, i, parent ->
        if i < num_nodes do
          parent = (parent ++ [i])
          i = i + 1
          while_fun_3.(while_fun_3, i, parent)
        else
          {i, parent}
        end
      end
      {i, parent} = try do
          while_fun_3.(while_fun_3, i, parent)
        catch
          {:break, {i, parent}} -> {i, parent}
        end

      mst = []
      idx = 0
      while_fun_4 = fn while_fun_4, idx, mst, parent ->
        if idx < _len(es) do
          e = Enum.at(es, idx)
          pa = find_parent(parent, Enum.at(e, 0))
          pb = find_parent(parent, Enum.at(e, 1))
          {mst, parent} = if pa != pb do
            mst = (mst ++ [e])
            parent = List.replace_at(parent, pa, pb)
            {mst, parent}
          else
            {mst, parent}
          end
          idx = idx + 1
          while_fun_4.(while_fun_4, idx, mst, parent)
        else
          {idx, mst, parent}
        end
      end
      {idx, mst, parent} = try do
          while_fun_4.(while_fun_4, idx, mst, parent)
        catch
          {:break, {idx, mst, parent}} -> {idx, mst, parent}
        end

      throw {:return, mst}
    catch
      {:return, val} -> val
    end
  end
  def edges_to_string(es) do
    try do
      s = "["
      i = 0
      while_fun_5 = fn while_fun_5, i, s ->
        if i < _len(es) do
          e = Enum.at(es, i)
          s = (((((((s <> "(") <> Kernel.to_string(Enum.at(e, 0))) <> ", ") <> Kernel.to_string(Enum.at(e, 1))) <> ", ") <> Kernel.to_string(Enum.at(e, 2))) <> ")")
          {s} = if i < _len(es) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_5.(while_fun_5, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:edges1, [[0, 1, 3], [1, 2, 5], [2, 3, 1]])
  Process.put(:edges2, [[0, 1, 3], [1, 2, 5], [2, 3, 1], [0, 2, 1], [0, 3, 2]])
  Process.put(:edges3, [[0, 1, 3], [1, 2, 5], [2, 3, 1], [0, 2, 1], [0, 3, 2], [2, 1, 1]])
  def main() do
    IO.puts(Kernel.inspect(edges_to_string(kruskal(4, Process.get(:edges1)))))
    IO.puts(Kernel.inspect(edges_to_string(kruskal(4, Process.get(:edges2)))))
    IO.puts(Kernel.inspect(edges_to_string(kruskal(4, Process.get(:edges3)))))
  end
end
Main.main()
