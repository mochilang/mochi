# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def key(y, x) do
    try do
      throw {:return, ((Kernel.to_string(y) <> ",") <> Kernel.to_string(x))}
    catch
      {:return, val} -> val
    end
  end
  def parse_int(s) do
    try do
      value = 0
      i = 0
      while_fun = fn while_fun, i, value ->
        if i < _len(s) do
          c = String.at(s, i)
          value = value * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(c))
          i = i + 1
          while_fun.(while_fun, i, value)
        else
          {i, value}
        end
      end
      {i, value} = try do
          while_fun.(while_fun, i, value)
        catch
          {:break, {i, value}} -> {i, value}
        end

      throw {:return, value}
    catch
      {:return, val} -> val
    end
  end
  def parse_key(k) do
    try do
      idx = 0
      while_fun_2 = fn while_fun_2, idx ->
        if idx < _len(k) && _slice(k, idx, idx + 1 - (idx)) != "," do
          idx = idx + 1
          while_fun_2.(while_fun_2, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_2.(while_fun_2, idx)
        catch
          {:break, {idx}} -> idx
        end

      y = parse_int(_slice(k, 0, idx - (0)))
      x = parse_int(_slice(k, idx + 1, _len(k) - (idx + 1)))
      throw {:return, [y, x]}
    catch
      {:return, val} -> val
    end
  end
  def neighbors(pos) do
    try do
      coords = parse_key(pos)
      y = Enum.at(coords, 0)
      x = Enum.at(coords, 1)
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(Process.get(:delta)) do
          ny = y + Enum.at(Enum.at(Process.get(:delta), i), 0)
          nx = x + Enum.at(Enum.at(Process.get(:delta), i), 1)
          {res} = if ny >= 0 && ny < _len(Process.get(:grid)) && nx >= 0 && nx < _len(Enum.at(Process.get(:grid), 0)) do
            {res} = if Enum.at(Enum.at(Process.get(:grid), ny), nx) == 0 do
              res = (res ++ [key(ny, nx)])
              {res}
            else
              {res}
            end
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def reverse_list(lst) do
    try do
      res = []
      i = _len(lst) - 1
      while_fun_4 = fn while_fun_4, i, res ->
        if i >= 0 do
          res = (res ++ [Enum.at(lst, i)])
          i = i - 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bfs(start, goal) do
    try do
      queue = []
      queue = (queue ++ [%{pos: start, path: [start]}])
      head = 0
      visited = %{start: true}
      while_fun_5 = fn while_fun_5, head, queue, visited ->
        if head < _len(queue) do
          node_ = Enum.at(queue, head)
          head = head + 1
          if node_.pos == goal do
            throw {:return, node_.path}
          end
          neigh = neighbors(node_.pos)
          i = 0
          while_fun_6 = fn while_fun_6, i, queue, visited ->
            if i < _len(neigh) do
              npos = Enum.at(neigh, i)
              {queue, visited} = if !(Map.has_key?(visited, npos)) do
                visited = Map.put(visited, npos, true)
                new_path = (node_.path ++ [npos])
                queue = (queue ++ [%{pos: npos, path: new_path}])
                {queue, visited}
              else
                {queue, visited}
              end
              i = i + 1
              while_fun_6.(while_fun_6, i, queue, visited)
            else
              {i, queue, visited}
            end
          end
          {i, queue, visited} = try do
              while_fun_6.(while_fun_6, i, queue, visited)
            catch
              {:break, {i, queue, visited}} -> {i, queue, visited}
            end

          while_fun_5.(while_fun_5, head, queue, visited)
        else
          {head, queue, visited}
        end
      end
      {head, queue, visited} = try do
          while_fun_5.(while_fun_5, head, queue, visited)
        catch
          {:break, {head, queue, visited}} -> {head, queue, visited}
        end

      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  def bidirectional_bfs(start, goal) do
    try do
      queue_f = []
      queue_b = []
      queue_f = (queue_f ++ [%{pos: start, path: [start]}])
      queue_b = (queue_b ++ [%{pos: goal, path: [goal]}])
      head_f = 0
      head_b = 0
      visited_f = %{start: [start]}
      visited_b = %{goal: [goal]}
      while_fun_7 = fn while_fun_7, head_b, head_f, queue_b, queue_f, visited_b, visited_f ->
        if head_f < _len(queue_f) && head_b < _len(queue_b) do
          node_f = Enum.at(queue_f, head_f)
          head_f = head_f + 1
          neigh_f = neighbors(node_f.pos)
          i = 0
          while_fun_8 = fn while_fun_8, i, queue_f, visited_f ->
            if i < _len(neigh_f) do
              npos = Enum.at(neigh_f, i)
              {queue_f, visited_f} = if !(Map.has_key?(visited_f, npos)) do
                new_path = (node_f.path ++ [npos])
                visited_f = Map.put(visited_f, npos, new_path)
                {new_path} = if Map.has_key?(visited_b, npos) do
                  rev = reverse_list(visited_b[npos])
                  j = 1
                  while_fun_9 = fn while_fun_9, j, new_path ->
                    if j < _len(rev) do
                      new_path = (new_path ++ [Enum.at(rev, j)])
                      j = j + 1
                      while_fun_9.(while_fun_9, j, new_path)
                    else
                      {j, new_path}
                    end
                  end
                  {j, new_path} = try do
                      while_fun_9.(while_fun_9, j, new_path)
                    catch
                      {:break, {j, new_path}} -> {j, new_path}
                    end

                  throw {:return, new_path}
                  {new_path}
                else
                  {new_path}
                end
                queue_f = (queue_f ++ [%{pos: npos, path: new_path}])
                {queue_f, visited_f}
              else
                {queue_f, visited_f}
              end
              i = i + 1
              while_fun_8.(while_fun_8, i, queue_f, visited_f)
            else
              {i, queue_f, visited_f}
            end
          end
          {i, queue_f, visited_f} = try do
              while_fun_8.(while_fun_8, i, queue_f, visited_f)
            catch
              {:break, {i, queue_f, visited_f}} -> {i, queue_f, visited_f}
            end

          node_b = Enum.at(queue_b, head_b)
          head_b = head_b + 1
          neigh_b = neighbors(node_b.pos)
          j = 0
          while_fun_10 = fn while_fun_10, j, queue_b, visited_b ->
            if j < _len(neigh_b) do
              nposb = Enum.at(neigh_b, j)
              {queue_b, visited_b} = if !(Map.has_key?(visited_b, nposb)) do
                new_path_b = (node_b.path ++ [nposb])
                visited_b = Map.put(visited_b, nposb, new_path_b)
                {new_path_b} = if Map.has_key?(visited_f, nposb) do
                  path_f = visited_f[nposb]
                  new_path_b = reverse_list(new_path_b)
                  t = 1
                  while_fun_11 = fn while_fun_11, path_f, t ->
                    if t < _len(new_path_b) do
                      path_f = (path_f ++ [Enum.at(new_path_b, t)])
                      t = t + 1
                      while_fun_11.(while_fun_11, path_f, t)
                    else
                      {path_f, t}
                    end
                  end
                  {path_f, t} = try do
                      while_fun_11.(while_fun_11, path_f, t)
                    catch
                      {:break, {path_f, t}} -> {path_f, t}
                    end

                  throw {:return, path_f}
                  {new_path_b}
                else
                  {new_path_b}
                end
                queue_b = (queue_b ++ [%{pos: nposb, path: new_path_b}])
                {queue_b, visited_b}
              else
                {queue_b, visited_b}
              end
              j = j + 1
              while_fun_10.(while_fun_10, j, queue_b, visited_b)
            else
              {j, queue_b, visited_b}
            end
          end
          {j, queue_b, visited_b} = try do
              while_fun_10.(while_fun_10, j, queue_b, visited_b)
            catch
              {:break, {j, queue_b, visited_b}} -> {j, queue_b, visited_b}
            end

          while_fun_7.(while_fun_7, head_b, head_f, queue_b, queue_f, visited_b, visited_f)
        else
          {head_b, head_f, queue_b, queue_f, visited_b, visited_f}
        end
      end
      {head_b, head_f, queue_b, queue_f, visited_b, visited_f} = try do
          while_fun_7.(while_fun_7, head_b, head_f, queue_b, queue_f, visited_b, visited_f)
        catch
          {:break, {head_b, head_f, queue_b, queue_f, visited_b, visited_f}} -> {head_b, head_f, queue_b, queue_f, visited_b, visited_f}
        end

      throw {:return, [start]}
    catch
      {:return, val} -> val
    end
  end
  def path_to_string(path) do
    try do
      if _len(path) == 0 do
        throw {:return, "[]"}
      end
      first = parse_key(Enum.at(path, 0))
      s = (((("[(" <> Kernel.inspect(Enum.at(first, 0))) <> ", ") <> Kernel.inspect(Enum.at(first, 1))) <> ")")
      i = 1
      while_fun_12 = fn while_fun_12, i, s ->
        if i < _len(path) do
          c = parse_key(Enum.at(path, i))
          s = (((((s <> ", (") <> Kernel.to_string(Enum.at(c, 0))) <> ", ") <> Kernel.to_string(Enum.at(c, 1))) <> ")")
          i = i + 1
          while_fun_12.(while_fun_12, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_12.(while_fun_12, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:grid, [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:delta, [[-1, 0], [0, -1], [1, 0], [0, 1]])
    Process.put(:start, key(0, 0))
    Process.put(:goal, key(_len(Process.get(:grid)) - 1, _len(Enum.at(Process.get(:grid), 0)) - 1))
    Process.put(:path1, bfs(Process.get(:start), Process.get(:goal)))
    IO.puts(Kernel.inspect(path_to_string(Process.get(:path1))))
    Process.put(:path2, bidirectional_bfs(Process.get(:start), Process.get(:goal)))
    IO.puts(Kernel.inspect(path_to_string(Process.get(:path2))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
