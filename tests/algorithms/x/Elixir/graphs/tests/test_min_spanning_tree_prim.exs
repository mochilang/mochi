# Code generated by Mochi transpiler 2025-08-16 09:34 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def prims_algorithm(adjacency) do
    try do
      visited = %{}
      visited = Map.put(visited, 0, true)
      mst = []
      count = 1
      total = 0
      {total} = Enum.reduce(Map.keys(adjacency), {total}, fn k, {total} ->
        total = total + 1
        {total}
      end)
      while_fun = fn while_fun, count, mst, visited ->
        if count < total do
          best_u = 0
          best_v = 0
          best_cost = 2147483647
          {best_cost, best_u, best_v} = Enum.reduce(Map.keys(adjacency), {best_cost, best_u, best_v}, fn u_str, {best_cost, best_u, best_v} ->
            u = Kernel.trunc(u_str)
            {best_cost, best_u, best_v} = if visited[u] do
              {best_cost, best_u, best_v} = Enum.reduce(adjacency[u], {best_cost, best_u, best_v}, fn n, {best_cost, best_u, best_v} ->
                {best_cost, best_u, best_v} = if !visited[n.node] && n.cost < best_cost do
                  best_cost = n.cost
                  best_u = u
                  best_v = n.node
                  {best_cost, best_u, best_v}
                else
                  {best_cost, best_u, best_v}
                end
                {best_cost, best_u, best_v}
              end)
              {best_cost, best_u, best_v}
            else
              {best_cost, best_u, best_v}
            end
            {best_cost, best_u, best_v}
          end)
          visited = Map.put(visited, best_v, true)
          mst = (mst ++ [%{u: best_u, v: best_v}])
          count = count + 1
          while_fun.(while_fun, count, mst, visited)
        else
          {count, mst, visited}
        end
      end
      {count, mst, visited} = try do
          while_fun.(while_fun, count, mst, visited)
        catch
          {:break, {count, mst, visited}} -> {count, mst, visited}
        end

      throw {:return, mst}
    catch
      {:return, val} -> val
    end
  end
  def test_prim_successful_result() do
    try do
      edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, 2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, 9], [5, 4, 10], [1, 7, 11]]
      adjacency = %{}
      {adjacency} = Enum.reduce(edges, {adjacency}, fn e, {adjacency} ->
        u = Enum.at(e, 0, [])
        v = Enum.at(e, 1, [])
        w = Enum.at(e, 2, [])
        adjacency = if !(Map.has_key?(adjacency, u)) do
          adjacency = Map.put(adjacency, u, [])
          adjacency
        else
          adjacency
        end
        adjacency = if !(Map.has_key?(adjacency, v)) do
          adjacency = Map.put(adjacency, v, [])
          adjacency
        else
          adjacency
        end
        adjacency = Map.put(adjacency, u, (adjacency[u] ++ [%{node: v, cost: w}]))
        adjacency = Map.put(adjacency, v, (adjacency[v] ++ [%{node: u, cost: w}]))
        {adjacency}
      end)
      result = prims_algorithm(adjacency)
      seen = %{}
      {seen} = Enum.reduce(result, {seen}, fn e, {seen} ->
        key1 = ((Kernel.to_string(e.u) <> ",") <> Kernel.to_string(e.v))
        key2 = ((Kernel.to_string(e.v) <> ",") <> Kernel.to_string(e.u))
        seen = Map.put(seen, key1, true)
        seen = Map.put(seen, key2, true)
        {seen}
      end)
      expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, 3, 7], [0, 7, 8], [3, 4, 9]]
      Enum.each(expected, fn ans ->
        key = ((Kernel.to_string(Enum.at(ans, 0, [])) <> ",") <> Kernel.to_string(Enum.at(ans, 1, [])))
        if !seen[key] do
          throw {:return, false}
        end
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(test_prim_successful_result()))
    IO.puts(true)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
