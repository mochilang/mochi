# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_matrix(n) do
    try do
      matrix = []
      i = 0
      while_fun = fn while_fun, i, matrix ->
        if i <= n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j <= n do
              row = (row ++ [false])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          matrix = (matrix ++ [row])
          i = i + 1
          while_fun.(while_fun, i, matrix)
        else
          {i, matrix}
        end
      end
      {i, matrix} = try do
          while_fun.(while_fun, i, matrix)
        catch
          {:break, {i, matrix}} -> {i, matrix}
        end

      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def dfs(u, graph, visited_edge, path) do
    try do
      path = (path ++ [u])
      {path, visited_edge} = if Map.has_key?(graph, u) do
        neighbors = graph[u]
        i = 0
        while_fun_3 = fn while_fun_3, i, path, visited_edge ->
          if i < _len(neighbors) do
            v = Enum.at(neighbors, i)
            {path, visited_edge} = if Enum.at(Enum.at(visited_edge, u), v) == false do
              visited_edge = List.replace_at(visited_edge, u, List.replace_at(Enum.at(visited_edge, u), v, true))
              visited_edge = List.replace_at(visited_edge, v, List.replace_at(Enum.at(visited_edge, v), u, true))
              path = dfs(v, graph, visited_edge, path)
              {path, visited_edge}
            else
              {path, visited_edge}
            end
            i = i + 1
            while_fun_3.(while_fun_3, i, path, visited_edge)
          else
            {i, path, visited_edge}
          end
        end
        {i, path, visited_edge} = try do
            while_fun_3.(while_fun_3, i, path, visited_edge)
          catch
            {:break, {i, path, visited_edge}} -> {i, path, visited_edge}
          end

        {path, visited_edge}
      else
        {path, visited_edge}
      end
      throw {:return, path}
    catch
      {:return, val} -> val
    end
  end
  def check_circuit_or_path(graph, max_node) do
    try do
      odd_degree_nodes = 0
      odd_node = -1
      i = 0
      while_fun_4 = fn while_fun_4, i, odd_degree_nodes, odd_node ->
        if i < max_node do
          {odd_degree_nodes, odd_node} = if Map.has_key?(graph, i) do
            {odd_degree_nodes, odd_node} = if rem(_len(Map.get(graph, i, [])), 2) == 1 do
              odd_degree_nodes = odd_degree_nodes + 1
              odd_node = i
              {odd_degree_nodes, odd_node}
            else
              {odd_degree_nodes, odd_node}
            end
            {odd_degree_nodes, odd_node}
          else
            {odd_degree_nodes, odd_node}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, odd_degree_nodes, odd_node)
        else
          {i, odd_degree_nodes, odd_node}
        end
      end
      {i, odd_degree_nodes, odd_node} = try do
          while_fun_4.(while_fun_4, i, odd_degree_nodes, odd_node)
        catch
          {:break, {i, odd_degree_nodes, odd_node}} -> {i, odd_degree_nodes, odd_node}
        end

      if odd_degree_nodes == 0 do
        throw {:return, %{status: 1, odd_node: odd_node}}
      end
      if odd_degree_nodes == 2 do
        throw {:return, %{status: 2, odd_node: odd_node}}
      end
      throw {:return, %{status: 3, odd_node: odd_node}}
    catch
      {:return, val} -> val
    end
  end
  def check_euler(graph, max_node) do
    try do
      visited_edge = make_matrix(max_node)
      res = check_circuit_or_path(graph, max_node)
      if res.status == 3 do
        IO.puts("graph is not Eulerian")
        IO.puts("no path")
        throw {:return, nil}
      end
      start_node = 1
      {start_node} = if res.status == 2 do
        start_node = res.odd_node
        IO.puts("graph has a Euler path")
        {start_node}
      else
        {start_node}
      end
      if res.status == 1 do
        IO.puts("graph has a Euler cycle")
      end
      path = dfs(start_node, graph, visited_edge, [])
      IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [path])), ",", " "))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:g1, %{1 => [2, 3, 4], 2 => [1, 3], 3 => [1, 2], 4 => [1, 5], 5 => [4]})
  Process.put(:g2, %{1 => [2, 3, 4, 5], 2 => [1, 3], 3 => [1, 2], 4 => [1, 5], 5 => [1, 4]})
  Process.put(:g3, %{1 => [2, 3, 4], 2 => [1, 3, 4], 3 => [1, 2], 4 => [1, 2, 5], 5 => [4]})
  Process.put(:g4, %{1 => [2, 3], 2 => [1, 3], 3 => [1, 2]})
  Process.put(:g5, %{1 => [], 2 => []})
  Process.put(:max_node, 10)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    check_euler(Process.get(:g1), Process.get(:max_node))
    check_euler(Process.get(:g2), Process.get(:max_node))
    check_euler(Process.get(:g3), Process.get(:max_node))
    check_euler(Process.get(:g4), Process.get(:max_node))
    check_euler(Process.get(:g5), Process.get(:max_node))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
