# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0, do: 0 - x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def manhattan(x1, y1, x2, y2) do
    try do
      throw {:return, abs_(x1 - x2) + abs_(y1 - y2)}
    catch
      {:return, val} -> val
    end
  end
  def clone_path(p) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(p) do
          res = (res ++ [Enum.at(p, i)])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def make_node(pos_x, pos_y, goal_x, goal_y, g_cost, path) do
    try do
      f = manhattan(pos_x, pos_y, goal_x, goal_y)
      throw {:return, %{pos_x: pos_x, pos_y: pos_y, goal_x: goal_x, goal_y: goal_y, g_cost: g_cost, f_cost: f, path: path}}
    catch
      {:return, val} -> val
    end
  end
  def node_equal(a, b) do
    try do
      throw {:return, a.pos_x == b.pos_x && a.pos_y == b.pos_y}
    catch
      {:return, val} -> val
    end
  end
  def contains(nodes, node_) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(nodes) do
          if node_equal(Enum.at(nodes, i), node_) do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def sort_nodes(nodes) do
    try do
      arr = nodes
      i = 1
      while_fun_3 = fn while_fun_3, arr, i ->
        if i < _len(arr) do
          key_node = Enum.at(arr, i)
          j = i - 1
          while_fun_4 = fn while_fun_4, arr, j ->
            if j >= 0 do
              temp = Enum.at(arr, j)
              {arr, j} = if temp.f_cost > key_node.f_cost do
                arr = List.replace_at(arr, j + 1, temp)
                j = j - 1
                {arr, j}
              else
                throw {:break, {arr, j}}
                {arr, j}
              end
              while_fun_4.(while_fun_4, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_4.(while_fun_4, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          arr = List.replace_at(arr, j + 1, key_node)
          i = i + 1
          while_fun_3.(while_fun_3, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_3.(while_fun_3, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def get_successors(grid, parent, target) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(Process.get(:delta)) do
          d = Enum.at(Process.get(:delta), i)
          pos_x = parent.pos_x + d.x
          pos_y = parent.pos_y + d.y
          {res} = if pos_x >= 0 && pos_x < _len(Enum.at(grid, 0)) && pos_y >= 0 && pos_y < _len(grid) && Enum.at(Enum.at(grid, pos_y), pos_x) == 0 do
            new_path = clone_path(parent.path)
            new_path = (new_path ++ [%{y: pos_y, x: pos_x}])
            res = (res ++ [make_node(pos_x, pos_y, target.x, target.y, parent.g_cost + 1, new_path)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def greedy_best_first(grid, init, goal) do
    try do
      start_path = [init]
      start = make_node(init.x, init.y, goal.x, goal.y, 0, start_path)
      open_nodes = [start]
      closed_nodes = []
      while_fun_6 = fn while_fun_6, closed_nodes, open_nodes ->
        if _len(open_nodes) > 0 do
          open_nodes = sort_nodes(open_nodes)
          current = Enum.at(open_nodes, 0)
          new_open = []
          idx = 1
          while_fun_7 = fn while_fun_7, idx, new_open ->
            if idx < _len(open_nodes) do
              new_open = (new_open ++ [Enum.at(open_nodes, idx)])
              idx = idx + 1
              while_fun_7.(while_fun_7, idx, new_open)
            else
              {idx, new_open}
            end
          end
          {idx, new_open} = try do
              while_fun_7.(while_fun_7, idx, new_open)
            catch
              {:break, {idx, new_open}} -> {idx, new_open}
            end

          open_nodes = new_open
          if current.pos_x == goal.x && current.pos_y == goal.y do
            throw {:return, current.path}
          end
          closed_nodes = (closed_nodes ++ [current])
          successors = get_successors(grid, current, goal)
          i = 0
          while_fun_8 = fn while_fun_8, i, open_nodes ->
            if i < _len(successors) do
              child = Enum.at(successors, i)
              {open_nodes} = if (!contains(closed_nodes, child)) && (!contains(open_nodes, child)) do
                open_nodes = (open_nodes ++ [child])
                {open_nodes}
              else
                {open_nodes}
              end
              i = i + 1
              while_fun_8.(while_fun_8, i, open_nodes)
            else
              {i, open_nodes}
            end
          end
          {i, open_nodes} = try do
              while_fun_8.(while_fun_8, i, open_nodes)
            catch
              {:break, {i, open_nodes}} -> {i, open_nodes}
            end

          while_fun_6.(while_fun_6, closed_nodes, open_nodes)
        else
          {closed_nodes, open_nodes}
        end
      end
      {closed_nodes, open_nodes} = try do
          while_fun_6.(while_fun_6, closed_nodes, open_nodes)
        catch
          {:break, {closed_nodes, open_nodes}} -> {closed_nodes, open_nodes}
        end

      r = [init]
      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def print_grid(grid) do
    try do
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < _len(grid) do
          IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Enum.at(grid, i)])), ",", " "))
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      idx = 0
      while_fun_10 = fn while_fun_10, idx ->
        if idx < _len(Process.get(:test_grids)) do
          IO.puts((("==grid-" <> Kernel.to_string(idx + 1)) <> "=="))
          grid = Enum.at(Process.get(:test_grids), idx)
          init = %{y: 0, x: 0}
          goal = %{y: _len(grid) - 1, x: _len(Enum.at(grid, 0)) - 1}
          print_grid(grid)
          IO.puts("------")
          path = greedy_best_first(grid, init, goal)
          j = 0
          while_fun_11 = fn while_fun_11, grid, j ->
            if j < _len(path) do
              p = Enum.at(path, j)
              grid = List.replace_at(grid, p.y, List.replace_at(Enum.at(grid, p.y), p.x, 2))
              j = j + 1
              while_fun_11.(while_fun_11, grid, j)
            else
              {grid, j}
            end
          end
          {grid, j} = try do
              while_fun_11.(while_fun_11, grid, j)
            catch
              {:break, {grid, j}} -> {grid, j}
            end

          print_grid(grid)
          idx = idx + 1
          while_fun_10.(while_fun_10, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_10.(while_fun_10, idx)
        catch
          {:break, {idx}} -> idx
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:test_grids, [[[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]], [[0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0]]])
end
Process.put(:delta, [%{y: -1, x: 0}, %{y: 0, x: -1}, %{y: 1, x: 0}, %{y: 0, x: 1}])
Main.main()
