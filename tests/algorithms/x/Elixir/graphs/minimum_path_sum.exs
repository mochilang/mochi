# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def fill_row(current_row, row_above) do
    try do
      current_row = List.replace_at(current_row, 0, Enum.at(current_row, 0) + Enum.at(row_above, 0))
      cell_n = 1
      while_fun = fn while_fun, cell_n, current_row ->
        if cell_n < _len(current_row) do
          left = Enum.at(current_row, cell_n - 1)
          up = Enum.at(row_above, cell_n)
          current_row = List.replace_at(current_row, cell_n, ((if left < up, do: Enum.at(current_row, cell_n) + left, else: Enum.at(current_row, cell_n) + up)))
          cell_n = cell_n + 1
          while_fun.(while_fun, cell_n, current_row)
        else
          {cell_n, current_row}
        end
      end
      {cell_n, current_row} = try do
          while_fun.(while_fun, cell_n, current_row)
        catch
          {:break, {cell_n, current_row}} -> {cell_n, current_row}
        end

      throw {:return, current_row}
    catch
      {:return, val} -> val
    end
  end
  def min_path_sum(grid) do
    try do
      if _len(grid) == 0 || _len(Enum.at(grid, 0)) == 0 do
        error("The grid does not contain the appropriate information")
      end
      cell_n = 1
      while_fun_2 = fn while_fun_2, cell_n, grid ->
        if cell_n < _len(Enum.at(grid, 0)) do
          grid = List.replace_at(grid, 0, List.replace_at(Enum.at(grid, 0), cell_n, Enum.at(Enum.at(grid, 0), cell_n) + Enum.at(Enum.at(grid, 0), cell_n - 1)))
          cell_n = cell_n + 1
          while_fun_2.(while_fun_2, cell_n, grid)
        else
          {cell_n, grid}
        end
      end
      {cell_n, grid} = try do
          while_fun_2.(while_fun_2, cell_n, grid)
        catch
          {:break, {cell_n, grid}} -> {cell_n, grid}
        end

      row_above = Enum.at(grid, 0)
      row_n = 1
      while_fun_3 = fn while_fun_3, grid, row_above, row_n ->
        if row_n < _len(grid) do
          current_row = Enum.at(grid, row_n)
          grid = List.replace_at(grid, row_n, fill_row(current_row, row_above))
          row_above = Enum.at(grid, row_n)
          row_n = row_n + 1
          while_fun_3.(while_fun_3, grid, row_above, row_n)
        else
          {grid, row_above, row_n}
        end
      end
      {grid, row_above, row_n} = try do
          while_fun_3.(while_fun_3, grid, row_above, row_n)
        catch
          {:break, {grid, row_above, row_n}} -> {grid, row_above, row_n}
        end

      throw {:return, Enum.at(Enum.at(grid, _len(grid) - 1), _len(Enum.at(grid, 0)) - 1)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:grid1, [[1, 3, 1], [1, 5, 1], [4, 2, 1]])
  Process.put(:grid2, [[1, 0, 5, 6, 7], [8, 9, 0, 4, 2], [4, 4, 4, 5, 1], [9, 6, 3, 1, 0], [8, 4, 3, 2, 7]])
  def main() do
    IO.puts(Kernel.inspect(min_path_sum(Process.get(:grid1))))
    IO.puts(Kernel.inspect(min_path_sum(Process.get(:grid2))))
  end
end
Main.main()
