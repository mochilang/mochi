# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def dfs(graph, at, parent, visited, ids, low, id, bridges) do
    try do
      visited = List.replace_at(visited, at, true)
      ids = List.replace_at(ids, at, id)
      low = List.replace_at(low, at, id)
      current_id = id + 1
      res_bridges = bridges
      {current_id, low, res_bridges} = Enum.reduce(graph[at], {current_id, low, res_bridges}, fn to, {current_id, low, res_bridges} ->
        try do
          {current_id, low, res_bridges} = if to == parent do
            throw :continue
            {current_id, low, res_bridges}
          else
            {current_id, low, res_bridges} = if !Enum.at(visited, to) do
              result = dfs(graph, to, at, visited, ids, low, current_id, res_bridges)
              current_id = result.id
              res_bridges = result.bridges
              {low} = if Enum.at(low, at) > Enum.at(low, to) do
                low = List.replace_at(low, at, Enum.at(low, to))
                {low}
              else
                {low}
              end
              {res_bridges} = if Enum.at(ids, at) < Enum.at(low, to) do
                edge = (if at < to, do: [at, to], else: [to, at])
                res_bridges = (res_bridges ++ [edge])
                {res_bridges}
              else
                {res_bridges}
              end
              {current_id, low, res_bridges}
            else
              {low} = if Enum.at(low, at) > Enum.at(ids, to) do
                low = List.replace_at(low, at, Enum.at(ids, to))
                {low}
              else
                {low}
              end
              {current_id, low, res_bridges}
            end
            {current_id, low, res_bridges}
          end
        catch
          :continue -> {current_id, low, res_bridges}
        end
        {current_id, low, res_bridges}
      end)
      throw {:return, %{id: current_id, bridges: res_bridges}}
    catch
      {:return, val} -> val
    end
  end
  def compute_bridges(graph) do
    try do
      n = map_size(graph)
      visited = []
      ids = []
      low = []
      i = 0
      while_fun = fn while_fun, i, ids, low, visited ->
        if i < n do
          visited = (visited ++ [false])
          ids = (ids ++ [0])
          low = (low ++ [0])
          i = i + 1
          while_fun.(while_fun, i, ids, low, visited)
        else
          {i, ids, low, visited}
        end
      end
      {i, ids, low, visited} = try do
          while_fun.(while_fun, i, ids, low, visited)
        catch
          {:break, {i, ids, low, visited}} -> {i, ids, low, visited}
        end

      bridges = []
      id = 0
      i = 0
      while_fun_2 = fn while_fun_2, bridges, i, id ->
        if i < n do
          {bridges, id} = if !Enum.at(visited, i) do
            result = dfs(graph, i, -1, visited, ids, low, id, bridges)
            id = result.id
            bridges = result.bridges
            {bridges, id}
          else
            {bridges, id}
          end
          i = i + 1
          while_fun_2.(while_fun_2, bridges, i, id)
        else
          {bridges, i, id}
        end
      end
      {bridges, i, id} = try do
          while_fun_2.(while_fun_2, bridges, i, id)
        catch
          {:break, {bridges, i, id}} -> {bridges, i, id}
        end

      throw {:return, bridges}
    catch
      {:return, val} -> val
    end
  end
  def get_demo_graph(index) do
    try do
      if index == 0 do
        throw {:return, %{0 => [1, 2], 1 => [0, 2], 2 => [0, 1, 3, 5], 3 => [2, 4], 4 => [3], 5 => [2, 6, 8], 6 => [5, 7], 7 => [6, 8], 8 => [5, 7]}}
      end
      if index == 1 do
        throw {:return, %{0 => [6], 1 => [9], 2 => [4, 5], 3 => [4], 4 => [2, 3], 5 => [2], 6 => [0, 7], 7 => [6], 8 => [], 9 => [1]}}
      end
      if index == 2 do
        throw {:return, %{0 => [4], 1 => [6], 2 => [], 3 => [5, 6, 7], 4 => [0, 6], 5 => [3, 8, 9], 6 => [1, 3, 4, 7], 7 => [3, 6, 8, 9], 8 => [5, 7], 9 => [5, 7]}}
      end
      throw {:return, %{0 => [1, 3], 1 => [0, 2, 4], 2 => [1, 3, 4], 3 => [0, 2, 4], 4 => [1, 2, 3]}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(compute_bridges(get_demo_graph(0))))
    IO.puts(Kernel.inspect(compute_bridges(get_demo_graph(1))))
    IO.puts(Kernel.inspect(compute_bridges(get_demo_graph(2))))
    IO.puts(Kernel.inspect(compute_bridges(get_demo_graph(3))))
    IO.puts(Kernel.inspect(compute_bridges(%{})))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
