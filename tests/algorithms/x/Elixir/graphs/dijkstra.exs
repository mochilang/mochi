# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    g = %{"A" => %{"B" => 2, "C" => 5}, "B" => %{"A" => 2, "D" => 3, "E" => 1, "F" => 1}, "C" => %{"A" => 5, "F" => 3}, "D" => %{"B" => 3}, "E" => %{"B" => 4, "F" => 3}, "F" => %{"C" => 3, "E" => 3}}
    heap = [%{node: "E", cost: 0}]
    visited = %{}
    result = -1
    while_fun = fn while_fun, heap, result, visited ->
      if _len(heap) > 0 do
        {heap, result, visited} = try do
          best_idx = 0
          i = 1
          while_fun_2 = fn while_fun_2, best_idx, i ->
            if i < _len(heap) do
              best_idx = if Enum.at(heap, i, []).cost < Enum.at(heap, best_idx, []).cost do
                best_idx = i
                best_idx
              else
                best_idx
              end
              i = i + 1
              while_fun_2.(while_fun_2, best_idx, i)
            else
              {best_idx, i}
            end
          end
          {best_idx, i} = try do
              while_fun_2.(while_fun_2, best_idx, i)
            catch
              {:break, {best_idx, i}} -> {best_idx, i}
            end

          best = Enum.at(heap, best_idx, [])
          new_heap = []
          j = 0
          while_fun_3 = fn while_fun_3, j, new_heap ->
            if j < _len(heap) do
              new_heap = if j != best_idx do
                new_heap = (new_heap ++ [Enum.at(heap, j, [])])
                new_heap
              else
                new_heap
              end
              j = j + 1
              while_fun_3.(while_fun_3, j, new_heap)
            else
              {j, new_heap}
            end
          end
          {j, new_heap} = try do
              while_fun_3.(while_fun_3, j, new_heap)
            catch
              {:break, {j, new_heap}} -> {j, new_heap}
            end

          heap = new_heap
          u = best.node
          cost = best.cost
          if Map.has_key?(visited, u) do
            throw {:continue, {heap, result, visited}}
          end
          visited = Map.put(visited, u, true)
          result = if u == "C" do
            result = cost
            throw {:break, {heap, result, visited}}
            result
          else
            result
          end
          {heap} = Enum.reduce(Map.keys(g[u]), {heap}, fn v, {heap} ->
            try do
              if Map.has_key?(visited, v) do
                throw {:continue, {heap, result, visited}}
              end
              next_cost = cost + g[u][v]
              heap = (heap ++ [%{node: v, cost: next_cost}])
            catch
              :continue -> {heap}
            end
            {heap}
          end)
          {heap, result, visited}
        catch
          {:continue, {heap, result, visited}} -> {heap, result, visited}
        end
        while_fun.(while_fun, heap, result, visited)
      else
        {heap, result, visited}
      end
    end
    {heap, result, visited} = try do
        while_fun.(while_fun, heap, result, visited)
      catch
        {:break, {heap, result, visited}} -> {heap, result, visited}
      end

    IO.puts(result)
    g2 = %{"B" => %{"C" => 1}, "C" => %{"D" => 1}, "D" => %{"F" => 1}, "E" => %{"B" => 1, "F" => 3}, "F" => %{}}
    heap2 = [%{node: "E", cost: 0}]
    visited2 = %{}
    result2 = -1
    while_fun_4 = fn while_fun_4, heap2, result2, visited2 ->
      if _len(heap2) > 0 do
        {heap2, result2, visited2} = try do
          best2_idx = 0
          i2 = 1
          while_fun_5 = fn while_fun_5, best2_idx, i2 ->
            if i2 < _len(heap2) do
              best2_idx = if Enum.at(heap2, i2, []).cost < Enum.at(heap2, best2_idx, []).cost do
                best2_idx = i2
                best2_idx
              else
                best2_idx
              end
              i2 = i2 + 1
              while_fun_5.(while_fun_5, best2_idx, i2)
            else
              {best2_idx, i2}
            end
          end
          {best2_idx, i2} = try do
              while_fun_5.(while_fun_5, best2_idx, i2)
            catch
              {:break, {best2_idx, i2}} -> {best2_idx, i2}
            end

          best2 = Enum.at(heap2, best2_idx, [])
          new_heap2 = []
          j2 = 0
          while_fun_6 = fn while_fun_6, j2, new_heap2 ->
            if j2 < _len(heap2) do
              new_heap2 = if j2 != best2_idx do
                new_heap2 = (new_heap2 ++ [Enum.at(heap2, j2, [])])
                new_heap2
              else
                new_heap2
              end
              j2 = j2 + 1
              while_fun_6.(while_fun_6, j2, new_heap2)
            else
              {j2, new_heap2}
            end
          end
          {j2, new_heap2} = try do
              while_fun_6.(while_fun_6, j2, new_heap2)
            catch
              {:break, {j2, new_heap2}} -> {j2, new_heap2}
            end

          heap2 = new_heap2
          u2 = best2.node
          cost2 = best2.cost
          if Map.has_key?(visited2, u2) do
            throw {:continue, {heap2, result2, visited2}}
          end
          visited2 = Map.put(visited2, u2, true)
          result2 = if u2 == "F" do
            result2 = cost2
            throw {:break, {heap2, result2, visited2}}
            result2
          else
            result2
          end
          {heap2} = Enum.reduce(Map.keys(g2[u2]), {heap2}, fn v2, {heap2} ->
            try do
              if Map.has_key?(visited2, v2) do
                throw {:continue, {heap2, result2, visited2}}
              end
              next_cost2 = cost2 + g2[u2][v2]
              heap2 = (heap2 ++ [%{node: v2, cost: next_cost2}])
            catch
              :continue -> {heap2}
            end
            {heap2}
          end)
          {heap2, result2, visited2}
        catch
          {:continue, {heap2, result2, visited2}} -> {heap2, result2, visited2}
        end
        while_fun_4.(while_fun_4, heap2, result2, visited2)
      else
        {heap2, result2, visited2}
      end
    end
    {heap2, result2, visited2} = try do
        while_fun_4.(while_fun_4, heap2, result2, visited2)
      catch
        {:break, {heap2, result2, visited2}} -> {heap2, result2, visited2}
      end

    IO.puts(result2)
    g3 = %{"B" => %{"C" => 1}, "C" => %{"D" => 1}, "D" => %{"F" => 1}, "E" => %{"B" => 1, "G" => 2}, "F" => %{}, "G" => %{"F" => 1}}
    heap3 = [%{node: "E", cost: 0}]
    visited3 = %{}
    result3 = -1
    while_fun_7 = fn while_fun_7, heap3, result3, visited3 ->
      if _len(heap3) > 0 do
        {heap3, result3, visited3} = try do
          best3_idx = 0
          i3 = 1
          while_fun_8 = fn while_fun_8, best3_idx, i3 ->
            if i3 < _len(heap3) do
              best3_idx = if Enum.at(heap3, i3, []).cost < Enum.at(heap3, best3_idx, []).cost do
                best3_idx = i3
                best3_idx
              else
                best3_idx
              end
              i3 = i3 + 1
              while_fun_8.(while_fun_8, best3_idx, i3)
            else
              {best3_idx, i3}
            end
          end
          {best3_idx, i3} = try do
              while_fun_8.(while_fun_8, best3_idx, i3)
            catch
              {:break, {best3_idx, i3}} -> {best3_idx, i3}
            end

          best3 = Enum.at(heap3, best3_idx, [])
          new_heap3 = []
          j3 = 0
          while_fun_9 = fn while_fun_9, j3, new_heap3 ->
            if j3 < _len(heap3) do
              new_heap3 = if j3 != best3_idx do
                new_heap3 = (new_heap3 ++ [Enum.at(heap3, j3, [])])
                new_heap3
              else
                new_heap3
              end
              j3 = j3 + 1
              while_fun_9.(while_fun_9, j3, new_heap3)
            else
              {j3, new_heap3}
            end
          end
          {j3, new_heap3} = try do
              while_fun_9.(while_fun_9, j3, new_heap3)
            catch
              {:break, {j3, new_heap3}} -> {j3, new_heap3}
            end

          heap3 = new_heap3
          u3 = best3.node
          cost3 = best3.cost
          if Map.has_key?(visited3, u3) do
            throw {:continue, {heap3, result3, visited3}}
          end
          visited3 = Map.put(visited3, u3, true)
          result3 = if u3 == "F" do
            result3 = cost3
            throw {:break, {heap3, result3, visited3}}
            result3
          else
            result3
          end
          {heap3} = Enum.reduce(Map.keys(g3[u3]), {heap3}, fn v3, {heap3} ->
            try do
              if Map.has_key?(visited3, v3) do
                throw {:continue, {heap3, result3, visited3}}
              end
              next_cost3 = cost3 + g3[u3][v3]
              heap3 = (heap3 ++ [%{node: v3, cost: next_cost3}])
            catch
              :continue -> {heap3}
            end
            {heap3}
          end)
          {heap3, result3, visited3}
        catch
          {:continue, {heap3, result3, visited3}} -> {heap3, result3, visited3}
        end
        while_fun_7.(while_fun_7, heap3, result3, visited3)
      else
        {heap3, result3, visited3}
      end
    end
    {heap3, result3, visited3} = try do
        while_fun_7.(while_fun_7, heap3, result3, visited3)
      catch
        {:break, {heap3, result3, visited3}} -> {heap3, result3, visited3}
      end

    IO.puts(result3)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
