# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def main() do
    g = %{"A" => %{"B" => 2, "C" => 5}, "B" => %{"A" => 2, "D" => 3, "E" => 1, "F" => 1}, "C" => %{"A" => 5, "F" => 3}, "D" => %{"B" => 3}, "E" => %{"B" => 4, "F" => 3}, "F" => %{"C" => 3, "E" => 3}}
    heap = [%{node: "E", cost: 0}]
    visited = %{}
    result = -1
    while_fun = fn while_fun ->
      if _len(heap) > 0 do
        try do
          best_idx = 0
          i = 1
          while_fun_2 = fn while_fun_2, best_idx, i ->
            if i < _len(heap) do
              {best_idx} = if Enum.at(heap, i)["cost"] < Enum.at(heap, best_idx)["cost"] do
                best_idx = i
                {best_idx}
              else
                {best_idx}
              end
              i = i + 1
              while_fun_2.(while_fun_2, best_idx, i)
            else
              {best_idx, i}
            end
          end
          {best_idx, i} = try do
              while_fun_2.(while_fun_2, best_idx, i)
            catch
              {:break, {best_idx, i}} -> {best_idx, i}
            end

          best = Enum.at(heap, best_idx)
          new_heap = []
          j = 0
          while_fun_3 = fn while_fun_3, j, new_heap ->
            if j < _len(heap) do
              {new_heap} = if j != best_idx do
                new_heap = (new_heap ++ [Enum.at(heap, j)])
                {new_heap}
              else
                {new_heap}
              end
              j = j + 1
              while_fun_3.(while_fun_3, j, new_heap)
            else
              {j, new_heap}
            end
          end
          {j, new_heap} = try do
              while_fun_3.(while_fun_3, j, new_heap)
            catch
              {:break, {j, new_heap}} -> {j, new_heap}
            end

          heap = new_heap
          u = best.node
          cost = best.cost
          if Map.has_key?(visited, u) do
            throw :continue
          end
          visited = Map.put(visited, u, true)
          if u == "C" do
            result = cost
            throw :break
          end
          try do
            for v <- Map.keys(g[u]) do
              try do
                if Map.has_key?(visited, v) do
                  throw :continue
                end
                next_cost = cost + g[u][v]
                heap = (heap ++ [%{node: v, cost: next_cost}])
              catch
                :continue -> nil
              end
            end
          catch
            :break -> nil
          end
        catch
          :continue -> nil
        end
        while_fun.(while_fun)
      else
        nil
      end
    end
    try do
      while_fun.(while_fun)
    catch
      :break -> nil
    end

    IO.puts(result)
    g2 = %{"B" => %{"C" => 1}, "C" => %{"D" => 1}, "D" => %{"F" => 1}, "E" => %{"B" => 1, "F" => 3}, "F" => %{}}
    heap2 = [%{node: "E", cost: 0}]
    visited2 = %{}
    result2 = -1
    while_fun_4 = fn while_fun_4 ->
      if _len(heap2) > 0 do
        try do
          best2_idx = 0
          i2 = 1
          while_fun_5 = fn while_fun_5, best2_idx, i2 ->
            if i2 < _len(heap2) do
              {best2_idx} = if Enum.at(heap2, i2)["cost"] < Enum.at(heap2, best2_idx)["cost"] do
                best2_idx = i2
                {best2_idx}
              else
                {best2_idx}
              end
              i2 = i2 + 1
              while_fun_5.(while_fun_5, best2_idx, i2)
            else
              {best2_idx, i2}
            end
          end
          {best2_idx, i2} = try do
              while_fun_5.(while_fun_5, best2_idx, i2)
            catch
              {:break, {best2_idx, i2}} -> {best2_idx, i2}
            end

          best2 = Enum.at(heap2, best2_idx)
          new_heap2 = []
          j2 = 0
          while_fun_6 = fn while_fun_6, j2, new_heap2 ->
            if j2 < _len(heap2) do
              {new_heap2} = if j2 != best2_idx do
                new_heap2 = (new_heap2 ++ [Enum.at(heap2, j2)])
                {new_heap2}
              else
                {new_heap2}
              end
              j2 = j2 + 1
              while_fun_6.(while_fun_6, j2, new_heap2)
            else
              {j2, new_heap2}
            end
          end
          {j2, new_heap2} = try do
              while_fun_6.(while_fun_6, j2, new_heap2)
            catch
              {:break, {j2, new_heap2}} -> {j2, new_heap2}
            end

          heap2 = new_heap2
          u2 = best2.node
          cost2 = best2.cost
          if Map.has_key?(visited2, u2) do
            throw :continue
          end
          visited2 = Map.put(visited2, u2, true)
          if u2 == "F" do
            result2 = cost2
            throw :break
          end
          try do
            for v2 <- Map.keys(g2[u2]) do
              try do
                if Map.has_key?(visited2, v2) do
                  throw :continue
                end
                next_cost2 = cost2 + g2[u2][v2]
                heap2 = (heap2 ++ [%{node: v2, cost: next_cost2}])
              catch
                :continue -> nil
              end
            end
          catch
            :break -> nil
          end
        catch
          :continue -> nil
        end
        while_fun_4.(while_fun_4)
      else
        nil
      end
    end
    try do
      while_fun_4.(while_fun_4)
    catch
      :break -> nil
    end

    IO.puts(result2)
    g3 = %{"B" => %{"C" => 1}, "C" => %{"D" => 1}, "D" => %{"F" => 1}, "E" => %{"B" => 1, "G" => 2}, "F" => %{}, "G" => %{"F" => 1}}
    heap3 = [%{node: "E", cost: 0}]
    visited3 = %{}
    result3 = -1
    while_fun_7 = fn while_fun_7 ->
      if _len(heap3) > 0 do
        try do
          best3_idx = 0
          i3 = 1
          while_fun_8 = fn while_fun_8, best3_idx, i3 ->
            if i3 < _len(heap3) do
              {best3_idx} = if Enum.at(heap3, i3)["cost"] < Enum.at(heap3, best3_idx)["cost"] do
                best3_idx = i3
                {best3_idx}
              else
                {best3_idx}
              end
              i3 = i3 + 1
              while_fun_8.(while_fun_8, best3_idx, i3)
            else
              {best3_idx, i3}
            end
          end
          {best3_idx, i3} = try do
              while_fun_8.(while_fun_8, best3_idx, i3)
            catch
              {:break, {best3_idx, i3}} -> {best3_idx, i3}
            end

          best3 = Enum.at(heap3, best3_idx)
          new_heap3 = []
          j3 = 0
          while_fun_9 = fn while_fun_9, j3, new_heap3 ->
            if j3 < _len(heap3) do
              {new_heap3} = if j3 != best3_idx do
                new_heap3 = (new_heap3 ++ [Enum.at(heap3, j3)])
                {new_heap3}
              else
                {new_heap3}
              end
              j3 = j3 + 1
              while_fun_9.(while_fun_9, j3, new_heap3)
            else
              {j3, new_heap3}
            end
          end
          {j3, new_heap3} = try do
              while_fun_9.(while_fun_9, j3, new_heap3)
            catch
              {:break, {j3, new_heap3}} -> {j3, new_heap3}
            end

          heap3 = new_heap3
          u3 = best3.node
          cost3 = best3.cost
          if Map.has_key?(visited3, u3) do
            throw :continue
          end
          visited3 = Map.put(visited3, u3, true)
          if u3 == "F" do
            result3 = cost3
            throw :break
          end
          try do
            for v3 <- Map.keys(g3[u3]) do
              try do
                if Map.has_key?(visited3, v3) do
                  throw :continue
                end
                next_cost3 = cost3 + g3[u3][v3]
                heap3 = (heap3 ++ [%{node: v3, cost: next_cost3}])
              catch
                :continue -> nil
              end
            end
          catch
            :break -> nil
          end
        catch
          :continue -> nil
        end
        while_fun_7.(while_fun_7)
      else
        nil
      end
    end
    try do
      while_fun_7.(while_fun_7)
    catch
      :break -> nil
    end

    IO.puts(result3)
  end
end
Main.main()
