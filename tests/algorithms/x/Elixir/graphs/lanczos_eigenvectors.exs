# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (1.0 * rand()) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def dot(a, b) do
    try do
      s = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, s ->
        if i < _len(a) do
          s = s + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_2.(while_fun_2, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def vector_scale(v, s) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(v) do
          res = (res ++ [Enum.at(v, i) * s])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vector_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) - Enum.at(b, i)])
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vector_add(a, b) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) + Enum.at(b, i)])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def zeros_matrix(r, c) do
    try do
      m = []
      i = 0
      while_fun_6 = fn while_fun_6, i, m ->
        if i < r do
          row = []
          j = 0
          while_fun_7 = fn while_fun_7, j, row ->
            if j < c do
              row = (row ++ [0.0])
              j = j + 1
              while_fun_7.(while_fun_7, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_7.(while_fun_7, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          m = (m ++ [row])
          i = i + 1
          while_fun_6.(while_fun_6, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_6.(while_fun_6, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def column(m, idx) do
    try do
      col = []
      i = 0
      while_fun_8 = fn while_fun_8, col, i ->
        if i < _len(m) do
          col = (col ++ [Enum.at(Enum.at(m, i), idx)])
          i = i + 1
          while_fun_8.(while_fun_8, col, i)
        else
          {col, i}
        end
      end
      {col, i} = try do
          while_fun_8.(while_fun_8, col, i)
        catch
          {:break, {col, i}} -> {col, i}
        end

      throw {:return, col}
    catch
      {:return, val} -> val
    end
  end
  def validate_adjacency_list(graph) do
    try do
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < _len(graph) do
          j = 0
          while_fun_10 = fn while_fun_10, j ->
            if j < _len(Enum.at(graph, i)) do
              v = Enum.at(Enum.at(graph, i), j)
              if v < 0 || v >= _len(graph) do
                raise("Invalid neighbor")
              end
              j = j + 1
              while_fun_10.(while_fun_10, j)
            else
              j
            end
          end
          j = try do
              while_fun_10.(while_fun_10, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def multiply_matrix_vector(graph, vector) do
    try do
      n = _len(graph)
      if _len(vector) != n do
        raise("Vector length must match number of nodes")
      end
      result = []
      i = 0
      while_fun_11 = fn while_fun_11, i ->
        if i < n do
          sum = 0.0
          j = 0
          while_fun_12 = fn while_fun_12, j, sum ->
            if j < _len(Enum.at(graph, i)) do
              nb = Enum.at(Enum.at(graph, i), j)
              sum = sum + Enum.at(vector, nb)
              j = j + 1
              while_fun_12.(while_fun_12, j, sum)
            else
              {j, sum}
            end
          end
          {j, sum} = try do
              while_fun_12.(while_fun_12, j, sum)
            catch
              {:break, {j, sum}} -> {j, sum}
            end

          result = (result ++ [sum])
          i = i + 1
          while_fun_11.(while_fun_11, i)
        else
          i
        end
      end
      i = try do
          while_fun_11.(while_fun_11, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def lanczos_iteration(graph, k) do
    try do
      n = _len(graph)
      if k < 1 || k > n do
        raise("invalid number of eigenvectors")
      end
      q = zeros_matrix(n, k)
      t = zeros_matrix(k, k)
      v = []
      i = 0
      while_fun_13 = fn while_fun_13, i, v ->
        if i < n do
          v = (v ++ [random()])
          i = i + 1
          while_fun_13.(while_fun_13, i, v)
        else
          {i, v}
        end
      end
      {i, v} = try do
          while_fun_13.(while_fun_13, i, v)
        catch
          {:break, {i, v}} -> {i, v}
        end

      ss = 0.0
      i = 0
      while_fun_14 = fn while_fun_14, i, ss ->
        if i < n do
          ss = ss + Enum.at(v, i) * Enum.at(v, i)
          i = i + 1
          while_fun_14.(while_fun_14, i, ss)
        else
          {i, ss}
        end
      end
      {i, ss} = try do
          while_fun_14.(while_fun_14, i, ss)
        catch
          {:break, {i, ss}} -> {i, ss}
        end

      vnorm = sqrtApprox(ss)
      i = 0
      while_fun_15 = fn while_fun_15, i, q ->
        if i < n do
          q = List.replace_at(q, i, List.replace_at(Enum.at(q, i), 0, Enum.at(v, i) / vnorm))
          i = i + 1
          while_fun_15.(while_fun_15, i, q)
        else
          {i, q}
        end
      end
      {i, q} = try do
          while_fun_15.(while_fun_15, i, q)
        catch
          {:break, {i, q}} -> {i, q}
        end

      beta = 0.0
      j = 0
      while_fun_16 = fn while_fun_16, beta, j, q, t ->
        if j < k do
          w = multiply_matrix_vector(graph, column(q, j))
          {w} = if j > 0 do
            w = vector_sub(w, vector_scale(column(q, j - 1), beta))
            {w}
          else
            {w}
          end
          alpha = dot(column(q, j), w)
          w = vector_sub(w, vector_scale(column(q, j), alpha))
          ss2 = 0.0
          p = 0
          while_fun_17 = fn while_fun_17, p, ss2 ->
            if p < n do
              ss2 = ss2 + Enum.at(w, p) * Enum.at(w, p)
              p = p + 1
              while_fun_17.(while_fun_17, p, ss2)
            else
              {p, ss2}
            end
          end
          {p, ss2} = try do
              while_fun_17.(while_fun_17, p, ss2)
            catch
              {:break, {p, ss2}} -> {p, ss2}
            end

          beta = sqrtApprox(ss2)
          t = List.replace_at(t, j, List.replace_at(Enum.at(t, j), j, alpha))
          {q, t} = if j < k - 1 do
            t = List.replace_at(t, j, List.replace_at(Enum.at(t, j), j + 1, beta))
            t = List.replace_at(t, j + 1, List.replace_at(Enum.at(t, j + 1), j, beta))
            {q} = if beta > 0.0000000001 do
              wnorm = vector_scale(w, 1.0 / beta)
              r = 0
              while_fun_18 = fn while_fun_18, q, r ->
                if r < n do
                  q = List.replace_at(q, r, List.replace_at(Enum.at(q, r), j + 1, Enum.at(wnorm, r)))
                  r = r + 1
                  while_fun_18.(while_fun_18, q, r)
                else
                  {q, r}
                end
              end
              {q, r} = try do
                  while_fun_18.(while_fun_18, q, r)
                catch
                  {:break, {q, r}} -> {q, r}
                end

              {q}
            else
              {q}
            end
            {q, t}
          else
            {q, t}
          end
          j = j + 1
          while_fun_16.(while_fun_16, beta, j, q, t)
        else
          {beta, j, q, t}
        end
      end
      {beta, j, q, t} = try do
          while_fun_16.(while_fun_16, beta, j, q, t)
        catch
          {:break, {beta, j, q, t}} -> {beta, j, q, t}
        end

      throw {:return, %{t: t, q: q}}
    catch
      {:return, val} -> val
    end
  end
  def jacobi_eigen(a_in, max_iter) do
    try do
      n = _len(a_in)
      a = a_in
      v = zeros_matrix(n, n)
      i = 0
      while_fun_19 = fn while_fun_19, i, v ->
        if i < n do
          v = List.replace_at(v, i, List.replace_at(Enum.at(v, i), i, 1.0))
          i = i + 1
          while_fun_19.(while_fun_19, i, v)
        else
          {i, v}
        end
      end
      {i, v} = try do
          while_fun_19.(while_fun_19, i, v)
        catch
          {:break, {i, v}} -> {i, v}
        end

      iter = 0
      while_fun_20 = fn while_fun_20, a, i, iter, v ->
        if iter < max_iter do
          p = 0
          q = 1
          max = absf(Enum.at(Enum.at(a, p), q))
          i = 0
          while_fun_21 = fn while_fun_21, i, max, p, q ->
            if i < n do
              j = i + 1
              while_fun_22 = fn while_fun_22, j, max, p, q ->
                if j < n do
                  val = absf(Enum.at(Enum.at(a, i), j))
                  {max, p, q} = if val > max do
                    max = val
                    p = i
                    q = j
                    {max, p, q}
                  else
                    {max, p, q}
                  end
                  j = j + 1
                  while_fun_22.(while_fun_22, j, max, p, q)
                else
                  {j, max, p, q}
                end
              end
              {j, max, p, q} = try do
                  while_fun_22.(while_fun_22, j, max, p, q)
                catch
                  {:break, {j, max, p, q}} -> {j, max, p, q}
                end

              i = i + 1
              while_fun_21.(while_fun_21, i, max, p, q)
            else
              {i, max, p, q}
            end
          end
          {i, max, p, q} = try do
              while_fun_21.(while_fun_21, i, max, p, q)
            catch
              {:break, {i, max, p, q}} -> {i, max, p, q}
            end

          if max < 0.00000001 do
            throw {:break, {a, i, iter, v}}
          end
          app = Enum.at(Enum.at(a, p), p)
          aqq = Enum.at(Enum.at(a, q), q)
          apq = Enum.at(Enum.at(a, p), q)
          theta = (aqq - app) / (2.0 * apq)
          t = 1.0 / (absf(theta) + sqrtApprox(theta * theta + 1.0))
          {t} = if theta < 0.0 do
            t = -t
            {t}
          else
            {t}
          end
          c = 1.0 / sqrtApprox(1.0 + t * t)
          s = t * c
          tau = s / (1.0 + c)
          a = List.replace_at(a, p, List.replace_at(Enum.at(a, p), p, app - t * apq))
          a = List.replace_at(a, q, List.replace_at(Enum.at(a, q), q, aqq + t * apq))
          a = List.replace_at(a, p, List.replace_at(Enum.at(a, p), q, 0.0))
          a = List.replace_at(a, q, List.replace_at(Enum.at(a, q), p, 0.0))
          k = 0
          while_fun_23 = fn while_fun_23, a, k ->
            if k < n do
              {a} = if k != p && k != q do
                akp = Enum.at(Enum.at(a, k), p)
                akq = Enum.at(Enum.at(a, k), q)
                a = List.replace_at(a, k, List.replace_at(Enum.at(a, k), p, akp - s * (akq + tau * akp)))
                a = List.replace_at(a, p, List.replace_at(Enum.at(a, p), k, Enum.at(Enum.at(a, k), p)))
                a = List.replace_at(a, k, List.replace_at(Enum.at(a, k), q, akq + s * (akp - tau * akq)))
                a = List.replace_at(a, q, List.replace_at(Enum.at(a, q), k, Enum.at(Enum.at(a, k), q)))
                {a}
              else
                {a}
              end
              k = k + 1
              while_fun_23.(while_fun_23, a, k)
            else
              {a, k}
            end
          end
          {a, k} = try do
              while_fun_23.(while_fun_23, a, k)
            catch
              {:break, {a, k}} -> {a, k}
            end

          k = 0
          while_fun_24 = fn while_fun_24, k, v ->
            if k < n do
              vkp = Enum.at(Enum.at(v, k), p)
              vkq = Enum.at(Enum.at(v, k), q)
              v = List.replace_at(v, k, List.replace_at(Enum.at(v, k), p, vkp - s * (vkq + tau * vkp)))
              v = List.replace_at(v, k, List.replace_at(Enum.at(v, k), q, vkq + s * (vkp - tau * vkq)))
              k = k + 1
              while_fun_24.(while_fun_24, k, v)
            else
              {k, v}
            end
          end
          {k, v} = try do
              while_fun_24.(while_fun_24, k, v)
            catch
              {:break, {k, v}} -> {k, v}
            end

          iter = iter + 1
          while_fun_20.(while_fun_20, a, i, iter, v)
        else
          {a, i, iter, v}
        end
      end
      {a, i, iter, v} = try do
          while_fun_20.(while_fun_20, a, i, iter, v)
        catch
          {:break, {a, i, iter, v}} -> {a, i, iter, v}
        end

      eigenvalues = []
      i = 0
      while_fun_25 = fn while_fun_25, eigenvalues, i ->
        if i < n do
          eigenvalues = (eigenvalues ++ [Enum.at(Enum.at(a, i), i)])
          i = i + 1
          while_fun_25.(while_fun_25, eigenvalues, i)
        else
          {eigenvalues, i}
        end
      end
      {eigenvalues, i} = try do
          while_fun_25.(while_fun_25, eigenvalues, i)
        catch
          {:break, {eigenvalues, i}} -> {eigenvalues, i}
        end

      throw {:return, %{values: eigenvalues, vectors: v}}
    catch
      {:return, val} -> val
    end
  end
  def matmul(a, b) do
    try do
      rows = _len(a)
      cols = _len(Enum.at(b, 0))
      inner = _len(b)
      m = zeros_matrix(rows, cols)
      i = 0
      while_fun_26 = fn while_fun_26, i, m ->
        if i < rows do
          j = 0
          while_fun_27 = fn while_fun_27, j, m ->
            if j < cols do
              s = 0.0
              k = 0
              while_fun_28 = fn while_fun_28, k, s ->
                if k < inner do
                  s = s + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_28.(while_fun_28, k, s)
                else
                  {k, s}
                end
              end
              {k, s} = try do
                  while_fun_28.(while_fun_28, k, s)
                catch
                  {:break, {k, s}} -> {k, s}
                end

              m = List.replace_at(m, i, List.replace_at(Enum.at(m, i), j, s))
              j = j + 1
              while_fun_27.(while_fun_27, j, m)
            else
              {j, m}
            end
          end
          {j, m} = try do
              while_fun_27.(while_fun_27, j, m)
            catch
              {:break, {j, m}} -> {j, m}
            end

          i = i + 1
          while_fun_26.(while_fun_26, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_26.(while_fun_26, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def sort_eigenpairs(vals, vecs) do
    try do
      n = _len(vals)
      values = vals
      vectors = vecs
      i = 0
      while_fun_29 = fn while_fun_29, i, values, vectors ->
        if i < n do
          j = 0
          while_fun_30 = fn while_fun_30, j, values, vectors ->
            if j < n - 1 do
              {values, vectors} = if Enum.at(values, j) < Enum.at(values, j + 1) do
                tmp = Enum.at(values, j)
                values = List.replace_at(values, j, Enum.at(values, j + 1))
                values = List.replace_at(values, j + 1, tmp)
                r = 0
                while_fun_31 = fn while_fun_31, r, vectors ->
                  if r < _len(vectors) do
                    tv = Enum.at(Enum.at(vectors, r), j)
                    vectors = List.replace_at(vectors, r, List.replace_at(Enum.at(vectors, r), j, Enum.at(Enum.at(vectors, r), j + 1)))
                    vectors = List.replace_at(vectors, r, List.replace_at(Enum.at(vectors, r), j + 1, tv))
                    r = r + 1
                    while_fun_31.(while_fun_31, r, vectors)
                  else
                    {r, vectors}
                  end
                end
                {r, vectors} = try do
                    while_fun_31.(while_fun_31, r, vectors)
                  catch
                    {:break, {r, vectors}} -> {r, vectors}
                  end

                {values, vectors}
              else
                {values, vectors}
              end
              j = j + 1
              while_fun_30.(while_fun_30, j, values, vectors)
            else
              {j, values, vectors}
            end
          end
          {j, values, vectors} = try do
              while_fun_30.(while_fun_30, j, values, vectors)
            catch
              {:break, {j, values, vectors}} -> {j, values, vectors}
            end

          i = i + 1
          while_fun_29.(while_fun_29, i, values, vectors)
        else
          {i, values, vectors}
        end
      end
      {i, values, vectors} = try do
          while_fun_29.(while_fun_29, i, values, vectors)
        catch
          {:break, {i, values, vectors}} -> {i, values, vectors}
        end

      throw {:return, %{values: values, vectors: vectors}}
    catch
      {:return, val} -> val
    end
  end
  def find_lanczos_eigenvectors(graph, k) do
    try do
      validate_adjacency_list(graph)
      res = lanczos_iteration(graph, k)
      eig = jacobi_eigen(res.t, 50)
      sorted = sort_eigenpairs(eig.values, eig.vectors)
      final_vectors = matmul(res.q, sorted.vectors)
      throw {:return, %{values: sorted.values, vectors: final_vectors}}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(arr) do
    try do
      s = "["
      i = 0
      while_fun_32 = fn while_fun_32, i, s ->
        if i < _len(arr) do
          s = (s <> Kernel.to_string(Enum.at(arr, i)))
          {s} = if i < _len(arr) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_32.(while_fun_32, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_32.(while_fun_32, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def matrix_to_string(m) do
    try do
      s = "["
      i = 0
      while_fun_33 = fn while_fun_33, i, s ->
        if i < _len(m) do
          s = (s <> list_to_string(Enum.at(m, i)))
          {s} = if i < _len(m) - 1 do
            s = (s <> "; ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_33.(while_fun_33, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_33.(while_fun_33, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 123456789)
  Process.put(:graph, [[1, 2], [0, 2], [0, 1]])
  def main() do
    Process.put(:result, find_lanczos_eigenvectors(Process.get(:graph), 2))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:result).values)))
    IO.puts(Kernel.inspect(matrix_to_string(Process.get(:result).vectors)))
  end
end
Main.main()
