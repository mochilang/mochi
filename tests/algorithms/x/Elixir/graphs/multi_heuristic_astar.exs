# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pos_equal(a, b) do
    try do
      throw {:return, a.x == b.x && a.y == b.y}
    catch
      {:return, val} -> val
    end
  end
  def pos_key(p) do
    try do
      throw {:return, ((Kernel.to_string(p.x) <> ",") <> Kernel.to_string(p.y))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def consistent_heuristic(p, goal) do
    try do
      dx = :erlang.float((p.x - goal.x))
      dy = :erlang.float((p.y - goal.y))
      throw {:return, sqrtApprox(dx * dx + dy * dy)}
    catch
      {:return, val} -> val
    end
  end
  def iabs(x) do
    try do
      throw {:return, ((if x < 0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def heuristic_1(p, goal) do
    try do
      throw {:return, :erlang.float((iabs(p.x - goal.x) + iabs(p.y - goal.y)))}
    catch
      {:return, val} -> val
    end
  end
  def heuristic_2(p, goal) do
    try do
      h = consistent_heuristic(p, goal)
      throw {:return, h / (:erlang.float(Process.get(:t)))}
    catch
      {:return, val} -> val
    end
  end
  def heuristic(i, p, goal) do
    try do
      if i == 0 do
        throw {:return, consistent_heuristic(p, goal)}
      end
      if i == 1 do
        throw {:return, heuristic_1(p, goal)}
      end
      throw {:return, heuristic_2(p, goal)}
    catch
      {:return, val} -> val
    end
  end
  def key_fn(start, i, goal, g_func) do
    try do
      g = g_func[pos_key(start)]
      throw {:return, g + Process.get(:w1) * heuristic(i, start, goal)}
    catch
      {:return, val} -> val
    end
  end
  def valid(p) do
    try do
      if p.x < 0 || p.x > Process.get(:n) - 1 do
        throw {:return, false}
      end
      if p.y < 0 || p.y > Process.get(:n) - 1 do
        throw {:return, false}
      end
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def in_blocks(p) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(Process.get(:blocks)) do
          if pos_equal(Enum.at(Process.get(:blocks), i), p) do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def pq_put(pq, node_, pri) do
    try do
      updated = false
      i = 0
      while_fun_3 = fn while_fun_3, i, pq, updated ->
        if i < _len(pq) do
          {pq, updated} = if pos_equal(Enum.at(pq, i)["pos"], node_) do
            {pq} = if pri < Enum.at(pq, i)["pri"] do
              pq = List.replace_at(pq, i, %{pos: node_, pri: pri})
              {pq}
            else
              {pq}
            end
            updated = true
            {pq, updated}
          else
            {pq, updated}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, pq, updated)
        else
          {i, pq, updated}
        end
      end
      {i, pq, updated} = try do
          while_fun_3.(while_fun_3, i, pq, updated)
        catch
          {:break, {i, pq, updated}} -> {i, pq, updated}
        end

      {pq} = if !updated do
        pq = (pq ++ [%{pos: node_, pri: pri}])
        {pq}
      else
        {pq}
      end
      throw {:return, pq}
    catch
      {:return, val} -> val
    end
  end
  def pq_minkey(pq) do
    try do
      if _len(pq) == 0 do
        throw {:return, Process.get(:inf)}
      end
      first = Enum.at(pq, 0)
      m = first.pri
      i = 1
      while_fun_4 = fn while_fun_4, i, m ->
        if i < _len(pq) do
          item = Enum.at(pq, i)
          {m} = if item.pri < m do
            m = item.pri
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_4.(while_fun_4, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def pq_pop_min(pq) do
    try do
      best = Enum.at(pq, 0)
      idx = 0
      i = 1
      while_fun_5 = fn while_fun_5, best, i, idx ->
        if i < _len(pq) do
          {best, idx} = if Enum.at(pq, i)["pri"] < best.pri do
            best = Enum.at(pq, i)
            idx = i
            {best, idx}
          else
            {best, idx}
          end
          i = i + 1
          while_fun_5.(while_fun_5, best, i, idx)
        else
          {best, i, idx}
        end
      end
      {best, i, idx} = try do
          while_fun_5.(while_fun_5, best, i, idx)
        catch
          {:break, {best, i, idx}} -> {best, i, idx}
        end

      new_pq = []
      i = 0
      while_fun_6 = fn while_fun_6, i, new_pq ->
        if i < _len(pq) do
          {new_pq} = if i != idx do
            new_pq = (new_pq ++ [Enum.at(pq, i)])
            {new_pq}
          else
            {new_pq}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, new_pq)
        else
          {i, new_pq}
        end
      end
      {i, new_pq} = try do
          while_fun_6.(while_fun_6, i, new_pq)
        catch
          {:break, {i, new_pq}} -> {i, new_pq}
        end

      throw {:return, %{pq: new_pq, node: best}}
    catch
      {:return, val} -> val
    end
  end
  def pq_remove(pq, node_) do
    try do
      new_pq = []
      i = 0
      while_fun_7 = fn while_fun_7, i, new_pq ->
        if i < _len(pq) do
          {new_pq} = if !pos_equal(Enum.at(pq, i)["pos"], node_) do
            new_pq = (new_pq ++ [Enum.at(pq, i)])
            {new_pq}
          else
            {new_pq}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, new_pq)
        else
          {i, new_pq}
        end
      end
      {i, new_pq} = try do
          while_fun_7.(while_fun_7, i, new_pq)
        catch
          {:break, {i, new_pq}} -> {i, new_pq}
        end

      throw {:return, new_pq}
    catch
      {:return, val} -> val
    end
  end
  def reconstruct(back_pointer, goal, start) do
    try do
      path = []
      current = goal
      key = pos_key(current)
      path = (path ++ [current])
      while_fun_8 = fn while_fun_8, current, key, path ->
        if !(pos_equal(current, start)) do
          current = back_pointer[key]
          key = pos_key(current)
          path = (path ++ [current])
          while_fun_8.(while_fun_8, current, key, path)
        else
          {current, key, path}
        end
      end
      {current, key, path} = try do
          while_fun_8.(while_fun_8, current, key, path)
        catch
          {:break, {current, key, path}} -> {current, key, path}
        end

      rev = []
      i = _len(path) - 1
      while_fun_9 = fn while_fun_9, i, rev ->
        if i >= 0 do
          rev = (rev ++ [Enum.at(path, i)])
          i = i - 1
          while_fun_9.(while_fun_9, i, rev)
        else
          {i, rev}
        end
      end
      {i, rev} = try do
          while_fun_9.(while_fun_9, i, rev)
        catch
          {:break, {i, rev}} -> {i, rev}
        end

      throw {:return, rev}
    catch
      {:return, val} -> val
    end
  end
  def neighbours(p) do
    try do
      left = %{x: p.x - 1, y: p.y}
      right = %{x: p.x + 1, y: p.y}
      up = %{x: p.x, y: p.y + 1}
      down = %{x: p.x, y: p.y - 1}
      throw {:return, [left, right, up, down]}
    catch
      {:return, val} -> val
    end
  end
  def multi_a_star(start, goal, n_heuristic) do
    try do
      g_function = %{}
      back_pointer = %{}
      visited = %{}
      open_list = []
      g_function = Map.put(g_function, pos_key(start), 0.0)
      g_function = Map.put(g_function, pos_key(goal), Process.get(:inf))
      back_pointer = Map.put(back_pointer, pos_key(start), %{x: -1, y: -1})
      back_pointer = Map.put(back_pointer, pos_key(goal), %{x: -1, y: -1})
      visited = Map.put(visited, pos_key(start), true)
      i = 0
      while_fun_10 = fn while_fun_10, i, open_list ->
        if i < n_heuristic do
          open_list = (open_list ++ [[]])
          pri = key_fn(start, i, goal, g_function)
          open_list = List.replace_at(open_list, i, pq_put(Enum.at(open_list, i), start, pri))
          i = i + 1
          while_fun_10.(while_fun_10, i, open_list)
        else
          {i, open_list}
        end
      end
      {i, open_list} = try do
          while_fun_10.(while_fun_10, i, open_list)
        catch
          {:break, {i, open_list}} -> {i, open_list}
        end

      while_fun_11 = fn while_fun_11, back_pointer, g_function, i, open_list, visited ->
        if pq_minkey(Enum.at(open_list, 0)) < Process.get(:inf) do
          {back_pointer, g_function, i, open_list, visited} = try do
            chosen = 0
            i = 1
            while_fun_12 = fn while_fun_12, chosen, i ->
              if i < n_heuristic do
                {chosen} = if pq_minkey(Enum.at(open_list, i)) <= Process.get(:w2) * pq_minkey(Enum.at(open_list, 0)) do
                  chosen = i
                  throw {:break, {chosen, i}}
                  {chosen}
                else
                  {chosen}
                end
                i = i + 1
                while_fun_12.(while_fun_12, chosen, i)
              else
                {chosen, i}
              end
            end
            {chosen, i} = try do
                while_fun_12.(while_fun_12, chosen, i)
              catch
                {:break, {chosen, i}} -> {chosen, i}
              end

            if chosen != 0 do
              Process.put(:t, Process.get(:t) + 1)
            end
            pair = pq_pop_min(Enum.at(open_list, chosen))
            open_list = List.replace_at(open_list, chosen, pair.pq)
            current = pair.node
            i = 0
            while_fun_13 = fn while_fun_13, i, open_list ->
              if i < n_heuristic do
                {open_list} = if i != chosen do
                  open_list = List.replace_at(open_list, i, pq_remove(Enum.at(open_list, i), current.pos))
                  {open_list}
                else
                  {open_list}
                end
                i = i + 1
                while_fun_13.(while_fun_13, i, open_list)
              else
                {i, open_list}
              end
            end
            {i, open_list} = try do
                while_fun_13.(while_fun_13, i, open_list)
              catch
                {:break, {i, open_list}} -> {i, open_list}
              end

            ckey = pos_key(current.pos)
            if Map.has_key?(visited, ckey) do
              throw {:continue, {back_pointer, g_function, i, open_list, visited}}
            end
            visited = Map.put(visited, ckey, true)
            if pos_equal(current.pos, goal) do
              path = reconstruct(back_pointer, goal, start)
              j = 0
              while_fun_14 = fn while_fun_14, j ->
                if j < _len(path) do
                  p = Enum.at(path, j)
                  IO.puts((((("(" <> Kernel.to_string(p.x)) <> ",") <> Kernel.to_string(p.y)) <> ")"))
                  j = j + 1
                  while_fun_14.(while_fun_14, j)
                else
                  j
                end
              end
              j = try do
                  while_fun_14.(while_fun_14, j)
                catch
                  {:break, {j}} -> j
                end

              throw {:return, nil}
            end
            neighs = neighbours(current.pos)
            k = 0
            while_fun_15 = fn while_fun_15, back_pointer, g_function, i, k, open_list ->
              if k < _len(neighs) do
                nb = Enum.at(neighs, k)
                {back_pointer, g_function, i, open_list} = if valid(nb) && (in_blocks(nb) == false) do
                  nkey = pos_key(nb)
                  tentative = g_function[ckey] + 1.0
                  {back_pointer, g_function, i, open_list} = if !(Map.has_key?(g_function, nkey)) || tentative < g_function[nkey] do
                    g_function = Map.put(g_function, nkey, tentative)
                    back_pointer = Map.put(back_pointer, nkey, current.pos)
                    i = 0
                    while_fun_16 = fn while_fun_16, i, open_list ->
                      if i < n_heuristic do
                        pri2 = tentative + Process.get(:w1) * heuristic(i, nb, goal)
                        open_list = List.replace_at(open_list, i, pq_put(Enum.at(open_list, i), nb, pri2))
                        i = i + 1
                        while_fun_16.(while_fun_16, i, open_list)
                      else
                        {i, open_list}
                      end
                    end
                    {i, open_list} = try do
                        while_fun_16.(while_fun_16, i, open_list)
                      catch
                        {:break, {i, open_list}} -> {i, open_list}
                      end

                    {back_pointer, g_function, i, open_list}
                  else
                    {back_pointer, g_function, i, open_list}
                  end
                  {back_pointer, g_function, i, open_list}
                else
                  {back_pointer, g_function, i, open_list}
                end
                k = k + 1
                while_fun_15.(while_fun_15, back_pointer, g_function, i, k, open_list)
              else
                {back_pointer, g_function, i, k, open_list}
              end
            end
            {back_pointer, g_function, i, k, open_list} = try do
                while_fun_15.(while_fun_15, back_pointer, g_function, i, k, open_list)
              catch
                {:break, {back_pointer, g_function, i, k, open_list}} -> {back_pointer, g_function, i, k, open_list}
              end

            {back_pointer, g_function, i, open_list, visited}
          catch
            {:continue, {back_pointer, g_function, i, open_list, visited}} -> {back_pointer, g_function, i, open_list, visited}
          end
          while_fun_11.(while_fun_11, back_pointer, g_function, i, open_list, visited)
        else
          {back_pointer, g_function, i, open_list, visited}
        end
      end
      {back_pointer, g_function, i, open_list, visited} = try do
          while_fun_11.(while_fun_11, back_pointer, g_function, i, open_list, visited)
        catch
          {:break, {back_pointer, g_function, i, open_list, visited}} -> {back_pointer, g_function, i, open_list, visited}
        end

      IO.puts("No path found to goal")
    catch
      {:return, val} -> val
    end
  end
  Process.put(:w1, 1.0)
  Process.put(:w2, 1.0)
  Process.put(:n, 20)
  Process.put(:n_heuristic, 3)
  Process.put(:inf, 1000000000.0)
  Process.put(:t, 1)
  Process.put(:blocks, [%{x: 0, y: 1}, %{x: 1, y: 1}, %{x: 2, y: 1}, %{x: 3, y: 1}, %{x: 4, y: 1}, %{x: 5, y: 1}, %{x: 6, y: 1}, %{x: 7, y: 1}, %{x: 8, y: 1}, %{x: 9, y: 1}, %{x: 10, y: 1}, %{x: 11, y: 1}, %{x: 12, y: 1}, %{x: 13, y: 1}, %{x: 14, y: 1}, %{x: 15, y: 1}, %{x: 16, y: 1}, %{x: 17, y: 1}, %{x: 18, y: 1}, %{x: 19, y: 1}])
  Process.put(:start, %{x: 0, y: 0})
  def main() do
    Process.put(:goal, %{x: Process.get(:n) - 1, y: Process.get(:n) - 1})
    multi_a_star(Process.get(:start), Process.get(:goal), Process.get(:n_heuristic))
  end
end
Main.main()
