# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_graph() do
    try do
      throw {:return, %{edges: [], num_nodes: 0}}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, u, v, w) do
    try do
      es = g.edges
      es = (es ++ [%{u: u, v: v, w: w}])
      n = g.num_nodes
      n = if u > n do
        n = u
        n
      else
        n
      end
      n = if v > n do
        n = v
        n
      else
        n
      end
      throw {:return, %{edges: es, num_nodes: n}}
    catch
      {:return, val} -> val
    end
  end
  def make_ds(n) do
    try do
      parent = []
      rank = []
      i = 0
      while_fun = fn while_fun, i, parent, rank ->
        if i <= n do
          parent = (parent ++ [i])
          rank = (rank ++ [0])
          i = i + 1
          while_fun.(while_fun, i, parent, rank)
        else
          {i, parent, rank}
        end
      end
      {i, parent, rank} = try do
          while_fun.(while_fun, i, parent, rank)
        catch
          {:break, {i, parent, rank}} -> {i, parent, rank}
        end

      throw {:return, %{parent: parent, rank: rank}}
    catch
      {:return, val} -> val
    end
  end
  def find_set(ds, x) do
    try do
      if Enum.at(ds.parent, x, 0) == x do
        throw {:return, %{ds: ds, root: x}}
      end
      res = find_set(ds, Enum.at(ds.parent, x, 0))
      p = res.ds.parent
      p = List.replace_at(p, x, res.root)
      throw {:return, %{ds: %{parent: p, rank: res.ds.rank}, root: res.root}}
    catch
      {:return, val} -> val
    end
  end
  def union_set(ds, x, y) do
    try do
      fx = find_set(ds, x)
      ds1 = fx.ds
      x_root = fx.root
      fy = find_set(ds1, y)
      ds2 = fy.ds
      y_root = fy.root
      if x_root == y_root do
        throw {:return, ds2}
      end
      p = ds2.parent
      r = ds2.rank
      {p, r} = if Enum.at(r, x_root, []) > Enum.at(r, y_root, []) do
        p = List.replace_at(p, y_root, x_root)
        {p, r}
      else
        p = List.replace_at(p, x_root, y_root)
        r = if Enum.at(r, x_root, []) == Enum.at(r, y_root, []) do
          r = List.replace_at(r, y_root, Enum.at(r, y_root, []) + 1)
          r
        else
          r
        end
        {p, r}
      end
      throw {:return, %{parent: p, rank: r}}
    catch
      {:return, val} -> val
    end
  end
  def sort_edges(edges) do
    try do
      arr = edges
      i = 1
      while_fun_2 = fn while_fun_2, arr, i ->
        if i < _len(arr) do
          key = Enum.at(arr, i, [])
          j = i - 1
          while_fun_3 = fn while_fun_3, arr, j ->
            if j >= 0 do
              temp = Enum.at(arr, j, [])
              {arr, j} = if temp.w > key.w || (temp.w == key.w && (temp.u > key.u || (temp.u == key.u && temp.v > key.v))) do
                arr = List.replace_at(arr, j + 1, temp)
                j = j - 1
                {arr, j}
              else
                throw {:break, {arr, j}}
                {arr, j}
              end
              while_fun_3.(while_fun_3, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_3.(while_fun_3, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          arr = List.replace_at(arr, j + 1, key)
          i = i + 1
          while_fun_2.(while_fun_2, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_2.(while_fun_2, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def kruskal(g) do
    try do
      edges = sort_edges(g.edges)
      ds = make_ds(g.num_nodes)
      mst_edges = []
      i = 0
      added = 0
      while_fun_4 = fn while_fun_4, added, ds, i, mst_edges ->
        if added < g.num_nodes - 1 && i < _len(edges) do
          e = Enum.at(edges, i, [])
          i = i + 1
          fu = find_set(ds, e.u)
          ds = fu.ds
          ru = fu.root
          fv = find_set(ds, e.v)
          ds = fv.ds
          rv = fv.root
          {added, ds, mst_edges} = if ru != rv do
            mst_edges = (mst_edges ++ [e])
            added = added + 1
            ds = union_set(ds, ru, rv)
            {added, ds, mst_edges}
          else
            {added, ds, mst_edges}
          end
          while_fun_4.(while_fun_4, added, ds, i, mst_edges)
        else
          {added, ds, i, mst_edges}
        end
      end
      {added, ds, i, mst_edges} = try do
          while_fun_4.(while_fun_4, added, ds, i, mst_edges)
        catch
          {:break, {added, ds, i, mst_edges}} -> {added, ds, i, mst_edges}
        end

      throw {:return, %{edges: mst_edges, num_nodes: g.num_nodes}}
    catch
      {:return, val} -> val
    end
  end
  def print_mst(g) do
    try do
      es = sort_edges(g.edges)
      Enum.each(es, fn e ->
        IO.puts(((((Kernel.to_string(e.u) <> "-") <> Kernel.to_string(e.v)) <> ":") <> Kernel.to_string(e.w)))
      end)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      g = new_graph()
      g = add_edge(g, 1, 2, 1)
      g = add_edge(g, 2, 3, 2)
      g = add_edge(g, 3, 4, 1)
      g = add_edge(g, 3, 5, 100)
      g = add_edge(g, 4, 5, 5)
      mst = kruskal(g)
      print_mst(mst)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
