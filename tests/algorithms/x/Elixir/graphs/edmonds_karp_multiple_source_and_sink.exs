# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def push_relabel_max_flow(graph, sources, sinks) do
    try do
      if _len(sources) == 0 || _len(sinks) == 0 do
        throw {:return, 0}
      end
      g = graph
      source_index = Enum.at(sources, 0, [])
      sink_index = Enum.at(sinks, 0, [])
      {g, sink_index, source_index} = if _len(sources) > 1 || _len(sinks) > 1 do
        max_input_flow = 0
        i = 0
        while_fun = fn while_fun, i, max_input_flow ->
          if i < _len(sources) do
            j = 0
            while_fun_2 = fn while_fun_2, j, max_input_flow ->
              if j < _len(Enum.at(g, Enum.at(sources, i, []), [])) do
                max_input_flow = max_input_flow + Enum.at(Enum.at(g, Enum.at(sources, i, []), []), j, 0)
                j = j + 1
                while_fun_2.(while_fun_2, j, max_input_flow)
              else
                {j, max_input_flow}
              end
            end
            {j, max_input_flow} = try do
                while_fun_2.(while_fun_2, j, max_input_flow)
              catch
                {:break, {j, max_input_flow}} -> {j, max_input_flow}
              end

            i = i + 1
            while_fun.(while_fun, i, max_input_flow)
          else
            {i, max_input_flow}
          end
        end
        {i, max_input_flow} = try do
            while_fun.(while_fun, i, max_input_flow)
          catch
            {:break, {i, max_input_flow}} -> {i, max_input_flow}
          end

        size = _len(g) + 1
        new_graph = []
        zero_row = []
        j = 0
        while_fun_3 = fn while_fun_3, j, zero_row ->
          if j < size do
            zero_row = (zero_row ++ [0])
            j = j + 1
            while_fun_3.(while_fun_3, j, zero_row)
          else
            {j, zero_row}
          end
        end
        {j, zero_row} = try do
            while_fun_3.(while_fun_3, j, zero_row)
          catch
            {:break, {j, zero_row}} -> {j, zero_row}
          end

        new_graph = (new_graph ++ [zero_row])
        r = 0
        while_fun_4 = fn while_fun_4, new_graph, r ->
          if r < _len(g) do
            row = [0]
            c = 0
            while_fun_5 = fn while_fun_5, c, row ->
              if c < _len(Enum.at(g, r, [])) do
                row = (row ++ [Enum.at(Enum.at(g, r, []), c, 0)])
                c = c + 1
                while_fun_5.(while_fun_5, c, row)
              else
                {c, row}
              end
            end
            {c, row} = try do
                while_fun_5.(while_fun_5, c, row)
              catch
                {:break, {c, row}} -> {c, row}
              end

            new_graph = (new_graph ++ [row])
            r = r + 1
            while_fun_4.(while_fun_4, new_graph, r)
          else
            {new_graph, r}
          end
        end
        {new_graph, r} = try do
            while_fun_4.(while_fun_4, new_graph, r)
          catch
            {:break, {new_graph, r}} -> {new_graph, r}
          end

        g = new_graph
        i = 0
        while_fun_6 = fn while_fun_6, g, i ->
          if i < _len(sources) do
            g = List.replace_at(g, 0, List.replace_at(Enum.at(g, 0), Enum.at(sources, i, []) + 1, max_input_flow))
            i = i + 1
            while_fun_6.(while_fun_6, g, i)
          else
            {g, i}
          end
        end
        {g, i} = try do
            while_fun_6.(while_fun_6, g, i)
          catch
            {:break, {g, i}} -> {g, i}
          end

        source_index = 0
        size = _len(g) + 1
        new_graph = []
        r = 0
        while_fun_7 = fn while_fun_7, new_graph, r ->
          if r < _len(g) do
            row2 = Enum.at(g, r, [])
            row2 = (row2 ++ [0])
            new_graph = (new_graph ++ [row2])
            r = r + 1
            while_fun_7.(while_fun_7, new_graph, r)
          else
            {new_graph, r}
          end
        end
        {new_graph, r} = try do
            while_fun_7.(while_fun_7, new_graph, r)
          catch
            {:break, {new_graph, r}} -> {new_graph, r}
          end

        last_row = []
        j = 0
        while_fun_8 = fn while_fun_8, j, last_row ->
          if j < size do
            last_row = (last_row ++ [0])
            j = j + 1
            while_fun_8.(while_fun_8, j, last_row)
          else
            {j, last_row}
          end
        end
        {j, last_row} = try do
            while_fun_8.(while_fun_8, j, last_row)
          catch
            {:break, {j, last_row}} -> {j, last_row}
          end

        new_graph = (new_graph ++ [last_row])
        g = new_graph
        i = 0
        while_fun_9 = fn while_fun_9, g, i ->
          if i < _len(sinks) do
            g = List.replace_at(g, Enum.at(sinks, i, []) + 1, List.replace_at(Enum.at(g, Enum.at(sinks, i, []) + 1), size - 1, max_input_flow))
            i = i + 1
            while_fun_9.(while_fun_9, g, i)
          else
            {g, i}
          end
        end
        {g, i} = try do
            while_fun_9.(while_fun_9, g, i)
          catch
            {:break, {g, i}} -> {g, i}
          end

        sink_index = size - 1
        {g, sink_index, source_index}
      else
        {g, sink_index, source_index}
      end
      n = _len(g)
      preflow = []
      i = 0
      while_fun_10 = fn while_fun_10, i, preflow ->
        if i < n do
          row = []
          j = 0
          while_fun_11 = fn while_fun_11, j, row ->
            if j < n do
              row = (row ++ [0])
              j = j + 1
              while_fun_11.(while_fun_11, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_11.(while_fun_11, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          preflow = (preflow ++ [row])
          i = i + 1
          while_fun_10.(while_fun_10, i, preflow)
        else
          {i, preflow}
        end
      end
      {i, preflow} = try do
          while_fun_10.(while_fun_10, i, preflow)
        catch
          {:break, {i, preflow}} -> {i, preflow}
        end

      heights = []
      i = 0
      while_fun_12 = fn while_fun_12, heights, i ->
        if i < n do
          heights = (heights ++ [0])
          i = i + 1
          while_fun_12.(while_fun_12, heights, i)
        else
          {heights, i}
        end
      end
      {heights, i} = try do
          while_fun_12.(while_fun_12, heights, i)
        catch
          {:break, {heights, i}} -> {heights, i}
        end

      excesses = []
      i = 0
      while_fun_13 = fn while_fun_13, excesses, i ->
        if i < n do
          excesses = (excesses ++ [0])
          i = i + 1
          while_fun_13.(while_fun_13, excesses, i)
        else
          {excesses, i}
        end
      end
      {excesses, i} = try do
          while_fun_13.(while_fun_13, excesses, i)
        catch
          {:break, {excesses, i}} -> {excesses, i}
        end

      heights = List.replace_at(heights, source_index, n)
      i = 0
      while_fun_14 = fn while_fun_14, excesses, i, preflow ->
        if i < n do
          bandwidth = Enum.at(Enum.at(g, source_index, []), i, 0)
          preflow = List.replace_at(preflow, source_index, List.replace_at(Enum.at(preflow, source_index), i, Enum.at(Enum.at(preflow, source_index, []), i, 0) + bandwidth))
          preflow = List.replace_at(preflow, i, List.replace_at(Enum.at(preflow, i), source_index, Enum.at(Enum.at(preflow, i, []), source_index, 0) - bandwidth))
          excesses = List.replace_at(excesses, i, Enum.at(excesses, i, []) + bandwidth)
          i = i + 1
          while_fun_14.(while_fun_14, excesses, i, preflow)
        else
          {excesses, i, preflow}
        end
      end
      {excesses, i, preflow} = try do
          while_fun_14.(while_fun_14, excesses, i, preflow)
        catch
          {:break, {excesses, i, preflow}} -> {excesses, i, preflow}
        end

      vertices_list = []
      i = 0
      while_fun_15 = fn while_fun_15, i, vertices_list ->
        if i < n do
          vertices_list = if i != source_index && i != sink_index do
            vertices_list = (vertices_list ++ [i])
            vertices_list
          else
            vertices_list
          end
          i = i + 1
          while_fun_15.(while_fun_15, i, vertices_list)
        else
          {i, vertices_list}
        end
      end
      {i, vertices_list} = try do
          while_fun_15.(while_fun_15, i, vertices_list)
        catch
          {:break, {i, vertices_list}} -> {i, vertices_list}
        end

      idx = 0
      while_fun_16 = fn while_fun_16, excesses, heights, idx, preflow, vertices_list ->
        if idx < _len(vertices_list) do
          v = Enum.at(vertices_list, idx, [])
          prev_height = Enum.at(heights, v, [])
          while_fun_17 = fn while_fun_17, excesses, heights, preflow ->
            if Enum.at(excesses, v, []) > 0 do
              nb = 0
              while_fun_18 = fn while_fun_18, excesses, nb, preflow ->
                if nb < n do
                  {excesses, preflow} = if Enum.at(Enum.at(g, v, []), nb, 0) - Enum.at(Enum.at(preflow, v, []), nb, 0) > 0 && Enum.at(heights, v, []) > Enum.at(heights, nb, []) do
                    delta = Enum.at(excesses, v, [])
                    capacity = Enum.at(Enum.at(g, v, []), nb, 0) - Enum.at(Enum.at(preflow, v, []), nb, 0)
                    delta = if delta > capacity do
                      delta = capacity
                      delta
                    else
                      delta
                    end
                    preflow = List.replace_at(preflow, v, List.replace_at(Enum.at(preflow, v), nb, Enum.at(Enum.at(preflow, v, []), nb, 0) + delta))
                    preflow = List.replace_at(preflow, nb, List.replace_at(Enum.at(preflow, nb), v, Enum.at(Enum.at(preflow, nb, []), v, 0) - delta))
                    excesses = List.replace_at(excesses, v, Enum.at(excesses, v, []) - delta)
                    excesses = List.replace_at(excesses, nb, Enum.at(excesses, nb, []) + delta)
                    {excesses, preflow}
                  else
                    {excesses, preflow}
                  end
                  nb = nb + 1
                  while_fun_18.(while_fun_18, excesses, nb, preflow)
                else
                  {excesses, nb, preflow}
                end
              end
              {excesses, nb, preflow} = try do
                  while_fun_18.(while_fun_18, excesses, nb, preflow)
                catch
                  {:break, {excesses, nb, preflow}} -> {excesses, nb, preflow}
                end

              min_height = -1
              nb = 0
              while_fun_19 = fn while_fun_19, min_height, nb ->
                if nb < n do
                  min_height = if Enum.at(Enum.at(g, v, []), nb, 0) - Enum.at(Enum.at(preflow, v, []), nb, 0) > 0 do
                    min_height = if min_height == (-1) || Enum.at(heights, nb, []) < min_height do
                      min_height = Enum.at(heights, nb, [])
                      min_height
                    else
                      min_height
                    end
                    min_height
                  else
                    min_height
                  end
                  nb = nb + 1
                  while_fun_19.(while_fun_19, min_height, nb)
                else
                  {min_height, nb}
                end
              end
              {min_height, nb} = try do
                  while_fun_19.(while_fun_19, min_height, nb)
                catch
                  {:break, {min_height, nb}} -> {min_height, nb}
                end

              heights = if min_height != (-1) do
                heights = List.replace_at(heights, v, min_height + 1)
                heights
              else
                throw {:break, {excesses, heights, preflow}}
                heights
              end
              while_fun_17.(while_fun_17, excesses, heights, preflow)
            else
              {excesses, heights, preflow}
            end
          end
          {excesses, heights, preflow} = try do
              while_fun_17.(while_fun_17, excesses, heights, preflow)
            catch
              {:break, {excesses, heights, preflow}} -> {excesses, heights, preflow}
            end

          {idx, vertices_list} = if Enum.at(heights, v, []) > prev_height do
            vertex = Enum.at(vertices_list, idx, [])
            j = idx
            while_fun_20 = fn while_fun_20, j, vertices_list ->
              if j > 0 do
                vertices_list = List.replace_at(vertices_list, j, Enum.at(vertices_list, j - 1, []))
                j = j - 1
                while_fun_20.(while_fun_20, j, vertices_list)
              else
                {j, vertices_list}
              end
            end
            {j, vertices_list} = try do
                while_fun_20.(while_fun_20, j, vertices_list)
              catch
                {:break, {j, vertices_list}} -> {j, vertices_list}
              end

            vertices_list = List.replace_at(vertices_list, 0, vertex)
            idx = 0
            {idx, vertices_list}
          else
            idx = idx + 1
            {idx, vertices_list}
          end
          while_fun_16.(while_fun_16, excesses, heights, idx, preflow, vertices_list)
        else
          {excesses, heights, idx, preflow, vertices_list}
        end
      end
      {excesses, heights, idx, preflow, vertices_list} = try do
          while_fun_16.(while_fun_16, excesses, heights, idx, preflow, vertices_list)
        catch
          {:break, {excesses, heights, idx, preflow, vertices_list}} -> {excesses, heights, idx, preflow, vertices_list}
        end

      flow = 0
      i = 0
      while_fun_21 = fn while_fun_21, flow, i ->
        if i < n do
          flow = flow + Enum.at(Enum.at(preflow, source_index, []), i, 0)
          i = i + 1
          while_fun_21.(while_fun_21, flow, i)
        else
          {flow, i}
        end
      end
      {flow, i} = try do
          while_fun_21.(while_fun_21, flow, i)
        catch
          {:break, {flow, i}} -> {flow, i}
        end

      flow = if flow < 0 do
        flow = -flow
        flow
      else
        flow
      end
      throw {:return, flow}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, [[0, 7, 0, 0], [0, 0, 6, 0], [0, 0, 0, 8], [9, 0, 0, 0]])
  Process.put(:sources, [0])
  Process.put(:sinks, [3])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:result, push_relabel_max_flow(Process.get(:graph), Process.get(:sources), Process.get(:sinks)))
    IO.puts(("maximum flow is " <> Kernel.to_string(Process.get(:result))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
