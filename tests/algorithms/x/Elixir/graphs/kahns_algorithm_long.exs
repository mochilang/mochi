# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def longest_distance(graph) do
    try do
      n = _len(graph)
      indegree = []
      i = 0
      while_fun = fn while_fun, i, indegree ->
        if i < n do
          indegree = (indegree ++ [0])
          i = i + 1
          while_fun.(while_fun, i, indegree)
        else
          {i, indegree}
        end
      end
      {i, indegree} = try do
          while_fun.(while_fun, i, indegree)
        catch
          {:break, {i, indegree}} -> {i, indegree}
        end

      long_dist = []
      j = 0
      while_fun_2 = fn while_fun_2, j, long_dist ->
        if j < n do
          long_dist = (long_dist ++ [1])
          j = j + 1
          while_fun_2.(while_fun_2, j, long_dist)
        else
          {j, long_dist}
        end
      end
      {j, long_dist} = try do
          while_fun_2.(while_fun_2, j, long_dist)
        catch
          {:break, {j, long_dist}} -> {j, long_dist}
        end

      u = 0
      while_fun_3 = fn while_fun_3, indegree, u ->
        if u < n do
          {indegree} = Enum.reduce(Enum.at(graph, u, []), {indegree}, fn v, {indegree} ->
            indegree = List.replace_at(indegree, v, Enum.at(indegree, v, []) + 1)
            {indegree}
          end)
          u = u + 1
          while_fun_3.(while_fun_3, indegree, u)
        else
          {indegree, u}
        end
      end
      {indegree, u} = try do
          while_fun_3.(while_fun_3, indegree, u)
        catch
          {:break, {indegree, u}} -> {indegree, u}
        end

      queue = []
      head = 0
      k = 0
      while_fun_4 = fn while_fun_4, k, queue ->
        if k < n do
          queue = if Enum.at(indegree, k, []) == 0 do
            queue = (queue ++ [k])
            queue
          else
            queue
          end
          k = k + 1
          while_fun_4.(while_fun_4, k, queue)
        else
          {k, queue}
        end
      end
      {k, queue} = try do
          while_fun_4.(while_fun_4, k, queue)
        catch
          {:break, {k, queue}} -> {k, queue}
        end

      while_fun_5 = fn while_fun_5, head, indegree, long_dist, queue ->
        if head < _len(queue) do
          vertex = Enum.at(queue, head, [])
          head = head + 1
          {indegree, long_dist, queue} = Enum.reduce(Enum.at(graph, vertex, []), {indegree, long_dist, queue}, fn x, {indegree, long_dist, queue} ->
            indegree = List.replace_at(indegree, x, Enum.at(indegree, x, []) - 1)
            new_dist = Enum.at(long_dist, vertex, []) + 1
            long_dist = if new_dist > Enum.at(long_dist, x, []) do
              long_dist = List.replace_at(long_dist, x, new_dist)
              long_dist
            else
              long_dist
            end
            queue = if Enum.at(indegree, x, []) == 0 do
              queue = (queue ++ [x])
              queue
            else
              queue
            end
            {indegree, long_dist, queue}
          end)
          while_fun_5.(while_fun_5, head, indegree, long_dist, queue)
        else
          {head, indegree, long_dist, queue}
        end
      end
      {head, indegree, long_dist, queue} = try do
          while_fun_5.(while_fun_5, head, indegree, long_dist, queue)
        catch
          {:break, {head, indegree, long_dist, queue}} -> {head, indegree, long_dist, queue}
        end

      max_len = Enum.at(long_dist, 0, [])
      m = 1
      while_fun_6 = fn while_fun_6, m, max_len ->
        if m < n do
          max_len = if Enum.at(long_dist, m, []) > max_len do
            max_len = Enum.at(long_dist, m, [])
            max_len
          else
            max_len
          end
          m = m + 1
          while_fun_6.(while_fun_6, m, max_len)
        else
          {m, max_len}
        end
      end
      {m, max_len} = try do
          while_fun_6.(while_fun_6, m, max_len)
        catch
          {:break, {m, max_len}} -> {m, max_len}
        end

      throw {:return, max_len}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, [[2, 3, 4], [2, 7], [5], [5, 7], [7], [6], [7], []])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(longest_distance(Process.get(:graph))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
