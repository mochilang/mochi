# Code generated by Mochi transpiler 2025-08-08 18:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def longest_distance(graph) do
    try do
      n = _len(graph)
      indegree = []
      i = 0
      while_fun = fn while_fun, i, indegree ->
        if i < n do
          indegree = (indegree ++ [0])
          i = i + 1
          while_fun.(while_fun, i, indegree)
        else
          {i, indegree}
        end
      end
      {i, indegree} = try do
          while_fun.(while_fun, i, indegree)
        catch
          {:break, {i, indegree}} -> {i, indegree}
        end

      long_dist = []
      j = 0
      while_fun_2 = fn while_fun_2, j, long_dist ->
        if j < n do
          long_dist = (long_dist ++ [1])
          j = j + 1
          while_fun_2.(while_fun_2, j, long_dist)
        else
          {j, long_dist}
        end
      end
      {j, long_dist} = try do
          while_fun_2.(while_fun_2, j, long_dist)
        catch
          {:break, {j, long_dist}} -> {j, long_dist}
        end

      u = 0
      while_fun_3 = fn while_fun_3, indegree, u ->
        if u < n do
          {indegree} = Enum.reduce(Enum.at(graph, u), {indegree}, fn v, {indegree} ->
            indegree = List.replace_at(indegree, v, Enum.at(indegree, v) + 1)
            {indegree}
          end)
          u = u + 1
          while_fun_3.(while_fun_3, indegree, u)
        else
          {indegree, u}
        end
      end
      {indegree, u} = try do
          while_fun_3.(while_fun_3, indegree, u)
        catch
          {:break, {indegree, u}} -> {indegree, u}
        end

      queue = []
      head = 0
      k = 0
      while_fun_4 = fn while_fun_4, k, queue ->
        if k < n do
          {queue} = if Enum.at(indegree, k) == 0 do
            queue = (queue ++ [k])
            {queue}
          else
            {queue}
          end
          k = k + 1
          while_fun_4.(while_fun_4, k, queue)
        else
          {k, queue}
        end
      end
      {k, queue} = try do
          while_fun_4.(while_fun_4, k, queue)
        catch
          {:break, {k, queue}} -> {k, queue}
        end

      while_fun_5 = fn while_fun_5, head, indegree, long_dist, queue ->
        if head < _len(queue) do
          vertex = Enum.at(queue, head)
          head = head + 1
          {indegree, long_dist, queue} = Enum.reduce(Enum.at(graph, vertex), {indegree, long_dist, queue}, fn x, {indegree, long_dist, queue} ->
            indegree = List.replace_at(indegree, x, Enum.at(indegree, x) - 1)
            new_dist = Enum.at(long_dist, vertex) + 1
            {long_dist} = if new_dist > Enum.at(long_dist, x) do
              long_dist = List.replace_at(long_dist, x, new_dist)
              {long_dist}
            else
              {long_dist}
            end
            {queue} = if Enum.at(indegree, x) == 0 do
              queue = (queue ++ [x])
              {queue}
            else
              {queue}
            end
            {indegree, long_dist, queue}
          end)
          while_fun_5.(while_fun_5, head, indegree, long_dist, queue)
        else
          {head, indegree, long_dist, queue}
        end
      end
      {head, indegree, long_dist, queue} = try do
          while_fun_5.(while_fun_5, head, indegree, long_dist, queue)
        catch
          {:break, {head, indegree, long_dist, queue}} -> {head, indegree, long_dist, queue}
        end

      max_len = Enum.at(long_dist, 0)
      m = 1
      while_fun_6 = fn while_fun_6, m, max_len ->
        if m < n do
          {max_len} = if Enum.at(long_dist, m) > max_len do
            max_len = Enum.at(long_dist, m)
            {max_len}
          else
            {max_len}
          end
          m = m + 1
          while_fun_6.(while_fun_6, m, max_len)
        else
          {m, max_len}
        end
      end
      {m, max_len} = try do
          while_fun_6.(while_fun_6, m, max_len)
        catch
          {:break, {m, max_len}} -> {m, max_len}
        end

      throw {:return, max_len}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, [[2, 3, 4], [2, 7], [5], [5, 7], [7], [6], [7], []])
  def main() do
    IO.puts(Kernel.inspect(longest_distance(Process.get(:graph))))
  end
end
Main.main()
