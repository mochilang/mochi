# Code generated by Mochi transpiler 2025-08-14 17:09 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_int_list(n, value) do
    try do
      lst = []
      i = 0
      while_fun = fn while_fun, i, lst ->
        if i < n do
          lst = (lst ++ [value])
          i = i + 1
          while_fun.(while_fun, i, lst)
        else
          {i, lst}
        end
      end
      {i, lst} = try do
          while_fun.(while_fun, i, lst)
        catch
          {:break, {i, lst}} -> {i, lst}
        end

      throw {:return, lst}
    catch
      {:return, val} -> val
    end
  end
  def make_bool_list(n) do
    try do
      lst = []
      i = 0
      while_fun_2 = fn while_fun_2, i, lst ->
        if i < n do
          lst = (lst ++ [false])
          i = i + 1
          while_fun_2.(while_fun_2, i, lst)
        else
          {i, lst}
        end
      end
      {i, lst} = try do
          while_fun_2.(while_fun_2, i, lst)
        catch
          {:break, {i, lst}} -> {i, lst}
        end

      throw {:return, lst}
    catch
      {:return, val} -> val
    end
  end
  def dijkstra(graph, src) do
    try do
      n = _len(graph)
      dist = make_int_list(n, 1000000000)
      visited = make_bool_list(n)
      dist = List.replace_at(dist, src, 0)
      count = 0
      while_fun_3 = fn while_fun_3, count, dist, visited ->
        if count < n do
          u = -1
          min_dist = 1000000000
          i = 0
          while_fun_4 = fn while_fun_4, i, min_dist, u ->
            if i < n do
              {min_dist, u} = if !Enum.at(visited, i, []) && Enum.at(dist, i, []) < min_dist do
                min_dist = Enum.at(dist, i, [])
                u = i
                {min_dist, u}
              else
                {min_dist, u}
              end
              i = i + 1
              while_fun_4.(while_fun_4, i, min_dist, u)
            else
              {i, min_dist, u}
            end
          end
          {i, min_dist, u} = try do
              while_fun_4.(while_fun_4, i, min_dist, u)
            catch
              {:break, {i, min_dist, u}} -> {i, min_dist, u}
            end

          if u < 0 do
            throw {:break, {count, dist, visited}}
          end
          visited = List.replace_at(visited, u, true)
          j = 0
          while_fun_5 = fn while_fun_5, dist, j ->
            if j < _len(Enum.at(graph, u, [])) do
              e = Enum.at(Enum.at(graph, u, []), j, 0)
              v = e.node
              w = e.weight
              dist = if !Enum.at(visited, v, []) do
                new_dist = Enum.at(dist, u, []) + w
                dist = if new_dist < Enum.at(dist, v, []) do
                  dist = List.replace_at(dist, v, new_dist)
                  dist
                else
                  dist
                end
                dist
              else
                dist
              end
              j = j + 1
              while_fun_5.(while_fun_5, dist, j)
            else
              {dist, j}
            end
          end
          {dist, j} = try do
              while_fun_5.(while_fun_5, dist, j)
            catch
              {:break, {dist, j}} -> {dist, j}
            end

          count = count + 1
          while_fun_3.(while_fun_3, count, dist, visited)
        else
          {count, dist, visited}
        end
      end
      {count, dist, visited} = try do
          while_fun_3.(while_fun_3, count, dist, visited)
        catch
          {:break, {count, dist, visited}} -> {count, dist, visited}
        end

      throw {:return, dist}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, [[%{node: 1, weight: 10}, %{node: 3, weight: 5}], [%{node: 2, weight: 1}, %{node: 3, weight: 2}], [%{node: 4, weight: 4}], [%{node: 1, weight: 3}, %{node: 2, weight: 9}, %{node: 4, weight: 2}], [%{node: 0, weight: 7}, %{node: 2, weight: 6}]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:dist, dijkstra(Process.get(:graph), 0))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:dist), 0, [])))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:dist), 1, [])))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:dist), 2, [])))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:dist), 3, [])))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:dist), 4, [])))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
