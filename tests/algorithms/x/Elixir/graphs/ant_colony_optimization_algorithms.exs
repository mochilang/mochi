# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def rand_float() do
    try do
      throw {:return, :erlang.float((rem(_now(), 1000000))) / 1000000.0}
    catch
      {:return, val} -> val
    end
  end
  def pow_float(base, exp) do
    try do
      result = 1.0
      i = 0
      e = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(exp)
      while_fun_2 = fn while_fun_2, i, result ->
        if i < e do
          result = result * base
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def distance(city1, city2) do
    try do
      dx = :erlang.float((Enum.at(city1, 0) - Enum.at(city2, 0)))
      dy = :erlang.float((Enum.at(city1, 1) - Enum.at(city2, 1)))
      throw {:return, sqrtApprox(dx * dx + dy * dy)}
    catch
      {:return, val} -> val
    end
  end
  def choose_weighted(options, weights) do
    try do
      total = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, total ->
        if i < _len(weights) do
          total = total + Enum.at(weights, i)
          i = i + 1
          while_fun_3.(while_fun_3, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_3.(while_fun_3, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      r = rand_float() * total
      accum = 0.0
      i = 0
      while_fun_4 = fn while_fun_4, accum, i ->
        if i < _len(weights) do
          accum = accum + Enum.at(weights, i)
          if r <= accum do
            throw {:return, Enum.at(options, i)}
          end
          i = i + 1
          while_fun_4.(while_fun_4, accum, i)
        else
          {accum, i}
        end
      end
      {accum, i} = try do
          while_fun_4.(while_fun_4, accum, i)
        catch
          {:break, {accum, i}} -> {accum, i}
        end

      throw {:return, Enum.at(options, _len(options) - 1)}
    catch
      {:return, val} -> val
    end
  end
  def city_select(pheromone, current, unvisited, alpha, beta, cities) do
    try do
      probs = []
      i = 0
      while_fun_5 = fn while_fun_5, i, probs ->
        if i < _len(unvisited) do
          city = Enum.at(unvisited, i)
          dist = distance(cities[city], cities[current])
          trail = Enum.at(Enum.at(pheromone, city), current)
          prob = pow_float(trail, alpha) * pow_float(1.0 / dist, beta)
          probs = (probs ++ [prob])
          i = i + 1
          while_fun_5.(while_fun_5, i, probs)
        else
          {i, probs}
        end
      end
      {i, probs} = try do
          while_fun_5.(while_fun_5, i, probs)
        catch
          {:break, {i, probs}} -> {i, probs}
        end

      throw {:return, choose_weighted(unvisited, probs)}
    catch
      {:return, val} -> val
    end
  end
  def pheromone_update(pheromone, cities, evaporation, ants_route, q) do
    try do
      n = _len(pheromone)
      i = 0
      while_fun_6 = fn while_fun_6, i, pheromone ->
        if i < n do
          j = 0
          while_fun_7 = fn while_fun_7, j, pheromone ->
            if j < n do
              pheromone = List.replace_at(pheromone, i, List.replace_at(Enum.at(pheromone, i), j, Enum.at(Enum.at(pheromone, i), j) * evaporation))
              j = j + 1
              while_fun_7.(while_fun_7, j, pheromone)
            else
              {j, pheromone}
            end
          end
          {j, pheromone} = try do
              while_fun_7.(while_fun_7, j, pheromone)
            catch
              {:break, {j, pheromone}} -> {j, pheromone}
            end

          i = i + 1
          while_fun_6.(while_fun_6, i, pheromone)
        else
          {i, pheromone}
        end
      end
      {i, pheromone} = try do
          while_fun_6.(while_fun_6, i, pheromone)
        catch
          {:break, {i, pheromone}} -> {i, pheromone}
        end

      a = 0
      while_fun_8 = fn while_fun_8, a, pheromone ->
        if a < _len(ants_route) do
          route = Enum.at(ants_route, a)
          total = 0.0
          r = 0
          while_fun_9 = fn while_fun_9, r, total ->
            if r < _len(route) - 1 do
              total = total + distance(cities[Enum.at(route, r)], cities[Enum.at(route, r + 1)])
              r = r + 1
              while_fun_9.(while_fun_9, r, total)
            else
              {r, total}
            end
          end
          {r, total} = try do
              while_fun_9.(while_fun_9, r, total)
            catch
              {:break, {r, total}} -> {r, total}
            end

          delta = q / total
          r = 0
          while_fun_10 = fn while_fun_10, pheromone, r ->
            if r < _len(route) - 1 do
              u = Enum.at(route, r)
              v = Enum.at(route, r + 1)
              pheromone = List.replace_at(pheromone, u, List.replace_at(Enum.at(pheromone, u), v, Enum.at(Enum.at(pheromone, u), v) + delta))
              pheromone = List.replace_at(pheromone, v, List.replace_at(Enum.at(pheromone, v), u, Enum.at(Enum.at(pheromone, u), v)))
              r = r + 1
              while_fun_10.(while_fun_10, pheromone, r)
            else
              {pheromone, r}
            end
          end
          {pheromone, r} = try do
              while_fun_10.(while_fun_10, pheromone, r)
            catch
              {:break, {pheromone, r}} -> {pheromone, r}
            end

          a = a + 1
          while_fun_8.(while_fun_8, a, pheromone)
        else
          {a, pheromone}
        end
      end
      {a, pheromone} = try do
          while_fun_8.(while_fun_8, a, pheromone)
        catch
          {:break, {a, pheromone}} -> {a, pheromone}
        end

      throw {:return, pheromone}
    catch
      {:return, val} -> val
    end
  end
  def remove_value(lst, val) do
    try do
      res = []
      i = 0
      while_fun_11 = fn while_fun_11, i, res ->
        if i < _len(lst) do
          {res} = if Enum.at(lst, i) != val do
            res = (res ++ [Enum.at(lst, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_11.(while_fun_11, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_11.(while_fun_11, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def ant_colony(cities, ants_num, iterations, evaporation, alpha, beta, q) do
    try do
      n = map_size(cities)
      pheromone = []
      i = 0
      while_fun_12 = fn while_fun_12, i, pheromone ->
        if i < n do
          row = []
          j = 0
          while_fun_13 = fn while_fun_13, j, row ->
            if j < n do
              row = (row ++ [1.0])
              j = j + 1
              while_fun_13.(while_fun_13, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_13.(while_fun_13, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          pheromone = (pheromone ++ [row])
          i = i + 1
          while_fun_12.(while_fun_12, i, pheromone)
        else
          {i, pheromone}
        end
      end
      {i, pheromone} = try do
          while_fun_12.(while_fun_12, i, pheromone)
        catch
          {:break, {i, pheromone}} -> {i, pheromone}
        end

      best_path = []
      best_distance = 1000000000.0
      iter = 0
      while_fun_14 = fn while_fun_14, best_distance, best_path, iter, pheromone ->
        if iter < iterations do
          ants_route = []
          k = 0
          while_fun_15 = fn while_fun_15, ants_route, k ->
            if k < ants_num do
              route = [0]
              unvisited = []
              {unvisited} = Enum.reduce(Map.keys(cities), {unvisited}, fn key, {unvisited} ->
                {unvisited} = if key != 0 do
                  unvisited = (unvisited ++ [key])
                  {unvisited}
                else
                  {unvisited}
                end
                {unvisited}
              end)
              current = 0
              while_fun_16 = fn while_fun_16, current, route, unvisited ->
                if _len(unvisited) > 0 do
                  next_city = city_select(pheromone, current, unvisited, alpha, beta, cities)
                  route = (route ++ [next_city])
                  unvisited = remove_value(unvisited, next_city)
                  current = next_city
                  while_fun_16.(while_fun_16, current, route, unvisited)
                else
                  {current, route, unvisited}
                end
              end
              {current, route, unvisited} = try do
                  while_fun_16.(while_fun_16, current, route, unvisited)
                catch
                  {:break, {current, route, unvisited}} -> {current, route, unvisited}
                end

              route = (route ++ [0])
              ants_route = (ants_route ++ [route])
              k = k + 1
              while_fun_15.(while_fun_15, ants_route, k)
            else
              {ants_route, k}
            end
          end
          {ants_route, k} = try do
              while_fun_15.(while_fun_15, ants_route, k)
            catch
              {:break, {ants_route, k}} -> {ants_route, k}
            end

          pheromone = pheromone_update(pheromone, cities, evaporation, ants_route, q)
          a = 0
          while_fun_17 = fn while_fun_17, a, best_distance, best_path ->
            if a < _len(ants_route) do
              route = Enum.at(ants_route, a)
              dist = 0.0
              r = 0
              while_fun_18 = fn while_fun_18, dist, r ->
                if r < _len(route) - 1 do
                  dist = dist + distance(cities[Enum.at(route, r)], cities[Enum.at(route, r + 1)])
                  r = r + 1
                  while_fun_18.(while_fun_18, dist, r)
                else
                  {dist, r}
                end
              end
              {dist, r} = try do
                  while_fun_18.(while_fun_18, dist, r)
                catch
                  {:break, {dist, r}} -> {dist, r}
                end

              {best_distance, best_path} = if dist < best_distance do
                best_distance = dist
                best_path = route
                {best_distance, best_path}
              else
                {best_distance, best_path}
              end
              a = a + 1
              while_fun_17.(while_fun_17, a, best_distance, best_path)
            else
              {a, best_distance, best_path}
            end
          end
          {a, best_distance, best_path} = try do
              while_fun_17.(while_fun_17, a, best_distance, best_path)
            catch
              {:break, {a, best_distance, best_path}} -> {a, best_distance, best_path}
            end

          iter = iter + 1
          while_fun_14.(while_fun_14, best_distance, best_path, iter, pheromone)
        else
          {best_distance, best_path, iter, pheromone}
        end
      end
      {best_distance, best_path, iter, pheromone} = try do
          while_fun_14.(while_fun_14, best_distance, best_path, iter, pheromone)
        catch
          {:break, {best_distance, best_path, iter, pheromone}} -> {best_distance, best_path, iter, pheromone}
        end

      IO.puts(("best_path = " <> String.replace(IO.iodata_to_binary(:io_lib.format("~w", [best_path])), ",", " ")))
      IO.puts(("best_distance = " <> Kernel.to_string(best_distance)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:cities, %{0 => [0, 0], 1 => [0, 5], 2 => [3, 8], 3 => [8, 10], 4 => [12, 8], 5 => [12, 4], 6 => [8, 0], 7 => [6, 2]})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    ant_colony(Process.get(:cities), 10, 20, 0.7, 1.0, 5.0, 10.0)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
