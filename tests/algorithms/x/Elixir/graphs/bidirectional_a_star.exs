# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def heuristic(a, b) do
    try do
      dy = a.y - b.y
      dx = a.x - b.x
      if Process.get(:heuristic) == 1 do
        throw {:return, :erlang.float((abs_(dy) + abs_(dx)))}
      end
      dyf = (:erlang.float(dy))
      dxf = (:erlang.float(dx))
      throw {:return, sqrtApprox(dyf * dyf + dxf * dxf)}
    catch
      {:return, val} -> val
    end
  end
  def pos_equal(a, b) do
    try do
      throw {:return, a.y == b.y && a.x == b.x}
    catch
      {:return, val} -> val
    end
  end
  def contains_pos(lst, p) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(lst) do
          if pos_equal(Enum.at(lst, i), p) do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def open_index_of_pos(open, p) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(open) do
          if pos_equal(Enum.at(open, i)["pos"], p) do
            throw {:return, i}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def remove_node_at(nodes, idx) do
    try do
      res = []
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(nodes) do
          {res} = if i != idx do
            res = (res ++ [Enum.at(nodes, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def append_pos_list(path, p) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(path) do
          res = (res ++ [Enum.at(path, i)])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res ++ [p])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def reverse_pos_list(lst) do
    try do
      res = []
      i = _len(lst) - 1
      while_fun_6 = fn while_fun_6, i, res ->
        if i >= 0 do
          res = (res ++ [Enum.at(lst, i)])
          i = i - 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def concat_pos_lists(a, b) do
    try do
      res = []
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i)])
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      j = 0
      while_fun_8 = fn while_fun_8, j, res ->
        if j < _len(b) do
          res = (res ++ [Enum.at(b, j)])
          j = j + 1
          while_fun_8.(while_fun_8, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_8.(while_fun_8, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def get_successors(p) do
    try do
      res = []
      i = 0
      while_fun_9 = fn while_fun_9, i, res ->
        if i < _len(Process.get(:delta)) do
          nx = p.x + Enum.at(Enum.at(Process.get(:delta), i), 1)
          ny = p.y + Enum.at(Enum.at(Process.get(:delta), i), 0)
          {res} = if nx >= 0 && ny >= 0 && nx < _len(Enum.at(Process.get(:grid), 0)) && ny < _len(Process.get(:grid)) do
            {res} = if Enum.at(Enum.at(Process.get(:grid), ny), nx) == 0 do
              res = (res ++ [%{y: ny, x: nx}])
              {res}
            else
              {res}
            end
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def find_lowest_f(open) do
    try do
      best = 0
      i = 1
      while_fun_10 = fn while_fun_10, best, i ->
        if i < _len(open) do
          {best} = if Enum.at(open, i)["f_cost"] < Enum.at(open, best)["f_cost"] do
            best = i
            {best}
          else
            {best}
          end
          i = i + 1
          while_fun_10.(while_fun_10, best, i)
        else
          {best, i}
        end
      end
      {best, i} = try do
          while_fun_10.(while_fun_10, best, i)
        catch
          {:break, {best, i}} -> {best, i}
        end

      throw {:return, best}
    catch
      {:return, val} -> val
    end
  end
  def astar(start, goal) do
    try do
      h0 = heuristic(start, goal)
      open = [%{pos: start, g_cost: 0, h_cost: h0, f_cost: h0, path: [start]}]
      closed = []
      while_fun_11 = fn while_fun_11, closed, open ->
        if _len(open) > 0 do
          {closed, open} = try do
            idx = find_lowest_f(open)
            current = Enum.at(open, idx)
            open = remove_node_at(open, idx)
            if pos_equal(current.pos, goal) do
              throw {:return, current.path}
            end
            closed = (closed ++ [current.pos])
            succ = get_successors(current.pos)
            i = 0
            while_fun_12 = fn while_fun_12, i, open ->
              if i < _len(succ) do
                {i, open} = try do
                  pos = Enum.at(succ, i)
                  {i} = if contains_pos(closed, pos) do
                    i = i + 1
                    throw {:continue, {i, open}}
                    {i}
                  else
                    {i}
                  end
                  tentative_g = current.g_cost + 1
                  idx_open = open_index_of_pos(open, pos)
                  {open} = if idx_open == 0 - 1 || tentative_g < Enum.at(open, idx_open)["g_cost"] do
                    new_path = append_pos_list(current.path, pos)
                    h = heuristic(pos, goal)
                    f = (:erlang.float(tentative_g)) + h
                    {open} = if idx_open != 0 - 1 do
                      open = remove_node_at(open, idx_open)
                      {open}
                    else
                      {open}
                    end
                    open = (open ++ [%{pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path}])
                    {open}
                  else
                    {open}
                  end
                  i = i + 1
                  {i, open}
                catch
                  {:continue, {i, open}} -> {i, open}
                end
                while_fun_12.(while_fun_12, i, open)
              else
                {i, open}
              end
            end
            {i, open} = try do
                while_fun_12.(while_fun_12, i, open)
              catch
                {:break, {i, open}} -> {i, open}
              end

            {closed, open}
          catch
            {:continue, {closed, open}} -> {closed, open}
          end
          while_fun_11.(while_fun_11, closed, open)
        else
          {closed, open}
        end
      end
      {closed, open} = try do
          while_fun_11.(while_fun_11, closed, open)
        catch
          {:break, {closed, open}} -> {closed, open}
        end

      throw {:return, [start]}
    catch
      {:return, val} -> val
    end
  end
  def combine_paths(fwd, bwd) do
    try do
      bwd_copy = []
      i = 0
      while_fun_13 = fn while_fun_13, bwd_copy, i ->
        if i < _len(Map.get(bwd, :path, [])) - 1 do
          bwd_copy = (bwd_copy ++ [Enum.at(bwd.path, i)])
          i = i + 1
          while_fun_13.(while_fun_13, bwd_copy, i)
        else
          {bwd_copy, i}
        end
      end
      {bwd_copy, i} = try do
          while_fun_13.(while_fun_13, bwd_copy, i)
        catch
          {:break, {bwd_copy, i}} -> {bwd_copy, i}
        end

      bwd_copy = reverse_pos_list(bwd_copy)
      throw {:return, concat_pos_lists(fwd.path, bwd_copy)}
    catch
      {:return, val} -> val
    end
  end
  def bidirectional_astar(start, goal) do
    try do
      hf = heuristic(start, goal)
      hb = heuristic(goal, start)
      open_f = [%{pos: start, g_cost: 0, h_cost: hf, f_cost: hf, path: [start]}]
      open_b = [%{pos: goal, g_cost: 0, h_cost: hb, f_cost: hb, path: [goal]}]
      closed_f = []
      closed_b = []
      while_fun_14 = fn while_fun_14, closed_b, closed_f, open_b, open_f ->
        if _len(open_f) > 0 && _len(open_b) > 0 do
          {closed_b, closed_f, open_b, open_f} = try do
            idx_f = find_lowest_f(open_f)
            current_f = Enum.at(open_f, idx_f)
            open_f = remove_node_at(open_f, idx_f)
            idx_b = find_lowest_f(open_b)
            current_b = Enum.at(open_b, idx_b)
            open_b = remove_node_at(open_b, idx_b)
            if pos_equal(current_f.pos, current_b.pos) do
              throw {:return, combine_paths(current_f, current_b)}
            end
            closed_f = (closed_f ++ [current_f.pos])
            closed_b = (closed_b ++ [current_b.pos])
            succ_f = get_successors(current_f.pos)
            i = 0
            while_fun_15 = fn while_fun_15, i, open_f ->
              if i < _len(succ_f) do
                {i, open_f} = try do
                  pos = Enum.at(succ_f, i)
                  {i} = if contains_pos(closed_f, pos) do
                    i = i + 1
                    throw {:continue, {i, open_f}}
                    {i}
                  else
                    {i}
                  end
                  tentative_g = current_f.g_cost + 1
                  h = heuristic(pos, current_b.pos)
                  f = (:erlang.float(tentative_g)) + h
                  idx_open = open_index_of_pos(open_f, pos)
                  {open_f} = if idx_open == 0 - 1 || tentative_g < Enum.at(open_f, idx_open)["g_cost"] do
                    new_path = append_pos_list(current_f.path, pos)
                    {open_f} = if idx_open != 0 - 1 do
                      open_f = remove_node_at(open_f, idx_open)
                      {open_f}
                    else
                      {open_f}
                    end
                    open_f = (open_f ++ [%{pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path}])
                    {open_f}
                  else
                    {open_f}
                  end
                  i = i + 1
                  {i, open_f}
                catch
                  {:continue, {i, open_f}} -> {i, open_f}
                end
                while_fun_15.(while_fun_15, i, open_f)
              else
                {i, open_f}
              end
            end
            {i, open_f} = try do
                while_fun_15.(while_fun_15, i, open_f)
              catch
                {:break, {i, open_f}} -> {i, open_f}
              end

            succ_b = get_successors(current_b.pos)
            i = 0
            while_fun_16 = fn while_fun_16, i, open_b ->
              if i < _len(succ_b) do
                {i, open_b} = try do
                  pos = Enum.at(succ_b, i)
                  {i} = if contains_pos(closed_b, pos) do
                    i = i + 1
                    throw {:continue, {i, open_b}}
                    {i}
                  else
                    {i}
                  end
                  tentative_g = current_b.g_cost + 1
                  h = heuristic(pos, current_f.pos)
                  f = (:erlang.float(tentative_g)) + h
                  idx_open = open_index_of_pos(open_b, pos)
                  {open_b} = if idx_open == 0 - 1 || tentative_g < Enum.at(open_b, idx_open)["g_cost"] do
                    new_path = append_pos_list(current_b.path, pos)
                    {open_b} = if idx_open != 0 - 1 do
                      open_b = remove_node_at(open_b, idx_open)
                      {open_b}
                    else
                      {open_b}
                    end
                    open_b = (open_b ++ [%{pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path}])
                    {open_b}
                  else
                    {open_b}
                  end
                  i = i + 1
                  {i, open_b}
                catch
                  {:continue, {i, open_b}} -> {i, open_b}
                end
                while_fun_16.(while_fun_16, i, open_b)
              else
                {i, open_b}
              end
            end
            {i, open_b} = try do
                while_fun_16.(while_fun_16, i, open_b)
              catch
                {:break, {i, open_b}} -> {i, open_b}
              end

            {closed_b, closed_f, open_b, open_f}
          catch
            {:continue, {closed_b, closed_f, open_b, open_f}} -> {closed_b, closed_f, open_b, open_f}
          end
          while_fun_14.(while_fun_14, closed_b, closed_f, open_b, open_f)
        else
          {closed_b, closed_f, open_b, open_f}
        end
      end
      {closed_b, closed_f, open_b, open_f} = try do
          while_fun_14.(while_fun_14, closed_b, closed_f, open_b, open_f)
        catch
          {:break, {closed_b, closed_f, open_b, open_f}} -> {closed_b, closed_f, open_b, open_f}
        end

      throw {:return, [start]}
    catch
      {:return, val} -> val
    end
  end
  def path_to_string(path) do
    try do
      if _len(path) == 0 do
        throw {:return, "[]"}
      end
      s = (((("[(" <> Kernel.to_string(Enum.at(path, 0)["y"])) <> ", ") <> Kernel.to_string(Enum.at(path, 0)["x"])) <> ")")
      i = 1
      while_fun_17 = fn while_fun_17, i, s ->
        if i < _len(path) do
          s = (((((s <> ", (") <> Kernel.to_string(Enum.at(path, i)["y"])) <> ", ") <> Kernel.to_string(Enum.at(path, i)["x"])) <> ")")
          i = i + 1
          while_fun_17.(while_fun_17, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_17.(while_fun_17, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:heuristic, 0)
  Process.put(:grid, [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]])
  Process.put(:start, %{y: 0, x: 0})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:delta, [[-1, 0], [0, -1], [1, 0], [0, 1]])
    Process.put(:goal, %{y: _len(Process.get(:grid)) - 1, x: _len(Enum.at(Process.get(:grid), 0)) - 1})
    Process.put(:path1, astar(Process.get(:start), Process.get(:goal)))
    IO.puts(Kernel.inspect(path_to_string(Process.get(:path1))))
    Process.put(:path2, bidirectional_astar(Process.get(:start), Process.get(:goal)))
    IO.puts(Kernel.inspect(path_to_string(Process.get(:path2))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
