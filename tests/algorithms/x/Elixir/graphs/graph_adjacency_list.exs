# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def create_graph(vertices, edges, directed) do
    try do
      adj = %{}
      {adj} = Enum.reduce(vertices, {adj}, fn v, {adj} ->
        adj = Map.put(adj, v, [])
        {adj}
      end)
      {adj} = Enum.reduce(edges, {adj}, fn e, {adj} ->
        s = Enum.at(e, 0)
        d = Enum.at(e, 1)
        {adj} = if !(Map.has_key?(adj, s)) do
          adj = Map.put(adj, s, [])
          {adj}
        else
          {adj}
        end
        {adj} = if !(Map.has_key?(adj, d)) do
          adj = Map.put(adj, d, [])
          {adj}
        else
          {adj}
        end
        adj = Map.put(adj, s, (adj[s] ++ [d]))
        {adj} = if !directed do
          adj = Map.put(adj, d, (adj[d] ++ [s]))
          {adj}
        else
          {adj}
        end
        {adj}
      end)
      throw {:return, %{adj: adj, directed: directed}}
    catch
      {:return, val} -> val
    end
  end
  def add_vertex(graph, v) do
    try do
      if Map.has_key?(graph.adj, v) do
        raise("vertex exists")
      end
      adj = %{}
      {adj} = Enum.reduce(Map.keys(graph.adj), {adj}, fn k, {adj} ->
        adj = Map.put(adj, k, graph.adj[k])
        {adj}
      end)
      adj = Map.put(adj, v, [])
      throw {:return, %{adj: adj, directed: graph.directed}}
    catch
      {:return, val} -> val
    end
  end
  def remove_from_list(lst, value) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(lst) do
          {res} = if Enum.at(lst, i) != value do
            res = (res ++ [Enum.at(lst, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def remove_key(m, key) do
    try do
      res = %{}
      {res} = Enum.reduce(Map.keys(m), {res}, fn k, {res} ->
        {res} = if k != key do
          res = Map.put(res, k, m[k])
          {res}
        else
          {res}
        end
        {res}
      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(graph, s, d) do
    try do
      if ((!(Map.has_key?(graph.adj, s))) || (!(Map.has_key?(graph.adj, d)))) do
        raise("vertex missing")
      end
      if contains_edge(graph, s, d) do
        raise("edge exists")
      end
      adj = %{}
      {adj} = Enum.reduce(Map.keys(graph.adj), {adj}, fn k, {adj} ->
        adj = Map.put(adj, k, graph.adj[k])
        {adj}
      end)
      list_s = adj[s]
      list_s = (list_s ++ [d])
      adj = Map.put(adj, s, list_s)
      {adj} = if !graph.directed do
        list_d = adj[d]
        list_d = (list_d ++ [s])
        adj = Map.put(adj, d, list_d)
        {adj}
      else
        {adj}
      end
      throw {:return, %{adj: adj, directed: graph.directed}}
    catch
      {:return, val} -> val
    end
  end
  def remove_edge(graph, s, d) do
    try do
      if ((!(Map.has_key?(graph.adj, s))) || (!(Map.has_key?(graph.adj, d)))) do
        raise("vertex missing")
      end
      if !contains_edge(graph, s, d) do
        raise("edge missing")
      end
      adj = %{}
      {adj} = Enum.reduce(Map.keys(graph.adj), {adj}, fn k, {adj} ->
        adj = Map.put(adj, k, graph.adj[k])
        {adj}
      end)
      adj = Map.put(adj, s, remove_from_list(adj[s], d))
      {adj} = if !graph.directed do
        adj = Map.put(adj, d, remove_from_list(adj[d], s))
        {adj}
      else
        {adj}
      end
      throw {:return, %{adj: adj, directed: graph.directed}}
    catch
      {:return, val} -> val
    end
  end
  def remove_vertex(graph, v) do
    try do
      if !(Map.has_key?(graph.adj, v)) do
        raise("vertex missing")
      end
      adj = %{}
      {adj} = Enum.reduce(Map.keys(graph.adj), {adj}, fn k, {adj} ->
        {adj} = if k != v do
          adj = Map.put(adj, k, remove_from_list(graph.adj[k], v))
          {adj}
        else
          {adj}
        end
        {adj}
      end)
      throw {:return, %{adj: adj, directed: graph.directed}}
    catch
      {:return, val} -> val
    end
  end
  def contains_vertex(graph, v) do
    try do
      throw {:return, Map.has_key?(graph.adj, v)}
    catch
      {:return, val} -> val
    end
  end
  def contains_edge(graph, s, d) do
    try do
      if ((!(Map.has_key?(graph.adj, s))) || (!(Map.has_key?(graph.adj, d)))) do
        raise("vertex missing")
      end
      Enum.each(graph.adj[s], fn x ->
        if x == d do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def clear_graph(graph) do
    try do
      throw {:return, %{adj: %{}, directed: graph.directed}}
    catch
      {:return, val} -> val
    end
  end
  def to_string(graph) do
    try do
      throw {:return, Kernel.inspect(Map.get(graph, :adj, []))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      vertices = ["1", "2", "3", "4"]
      edges = [["1", "2"], ["2", "3"], ["3", "4"]]
      g = create_graph(vertices, edges, false)
      IO.puts(to_string(g))
      g = add_vertex(g, "5")
      g = add_edge(g, "4", "5")
      IO.puts(Kernel.inspect(contains_edge(g, "4", "5")))
      g = remove_edge(g, "1", "2")
      g = remove_vertex(g, "3")
      IO.puts(to_string(g))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
