# Code generated by Mochi transpiler 2025-08-14 16:00 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def new_graph(num_nodes) do
    try do
      throw {:return, %{num_nodes: num_nodes, edges: [], component: %{}}}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, u, v, w) do
    try do
      es = g.edges
      es = (es ++ [%{u: u, v: v, w: w}])
      throw {:return, %{num_nodes: g.num_nodes, edges: es, component: g.component}}
    catch
      {:return, val} -> val
    end
  end
  def find_component(g, node_) do
    try do
      throw {:return, ((if g.component[node_] == node_, do: node_, else: find_component(g, g.component[node_])))}
    catch
      {:return, val} -> val
    end
  end
  def set_component(g, node_) do
    try do
      g = if g.component[node_] != node_ do
        comp = g.component
        k = 0
        while_fun = fn while_fun, comp, k ->
          if k < g.num_nodes do
            comp = Map.put(comp, k, find_component(g, k))
            k = k + 1
            while_fun.(while_fun, comp, k)
          else
            {comp, k}
          end
        end
        {comp, k} = try do
            while_fun.(while_fun, comp, k)
          catch
            {:break, {comp, k}} -> {comp, k}
          end

        g = %{num_nodes: g.num_nodes, edges: g.edges, component: comp}
        g
      else
        g
      end
      throw {:return, g}
    catch
      {:return, val} -> val
    end
  end
  def union(g, component_size, u, v) do
    try do
      comp_size = component_size
      comp = g.component
      {comp, comp_size, g} = if Enum.at(comp_size, u, []) <= Enum.at(comp_size, v, []) do
        comp = Map.put(comp, u, v)
        comp_size = List.replace_at(comp_size, v, Enum.at(comp_size, v, []) + Enum.at(comp_size, u, []))
        g = %{num_nodes: g.num_nodes, edges: g.edges, component: comp}
        g = set_component(g, u)
        {comp, comp_size, g}
      else
        comp = Map.put(comp, v, u)
        comp_size = List.replace_at(comp_size, u, Enum.at(comp_size, u, []) + Enum.at(comp_size, v, []))
        g = %{num_nodes: g.num_nodes, edges: g.edges, component: comp}
        g = set_component(g, v)
        {comp, comp_size, g}
      end
      throw {:return, %{graph: g, component_size: comp_size}}
    catch
      {:return, val} -> val
    end
  end
  def create_empty_edges(n) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < n do
          res = (res ++ [%{u: 0 - 1, v: 0 - 1, w: 0 - 1}])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def boruvka(g) do
    try do
      component_size = []
      i = 0
      while_fun_3 = fn while_fun_3, component_size, g, i ->
        if i < g.num_nodes do
          component_size = (component_size ++ [1])
          comp = g.component
          comp = Map.put(comp, i, i)
          g = %{num_nodes: g.num_nodes, edges: g.edges, component: comp}
          i = i + 1
          while_fun_3.(while_fun_3, component_size, g, i)
        else
          {component_size, g, i}
        end
      end
      {component_size, g, i} = try do
          while_fun_3.(while_fun_3, component_size, g, i)
        catch
          {:break, {component_size, g, i}} -> {component_size, g, i}
        end

      mst_weight = 0
      num_components = g.num_nodes
      minimum_weight_edge = create_empty_edges(g.num_nodes)
      while_fun_4 = fn while_fun_4, component_size, g, minimum_weight_edge, mst_weight, num_components ->
        if num_components > 1 do
          {minimum_weight_edge} = Enum.reduce(g.edges, {minimum_weight_edge}, fn e, {minimum_weight_edge} ->
            u = e.u
            v = e.v
            w = e.w
            u_comp = g.component[u]
            v_comp = g.component[v]
            minimum_weight_edge = if u_comp != v_comp do
              current_u = Enum.at(minimum_weight_edge, u_comp, [])
              minimum_weight_edge = if current_u.u == 0 - 1 || current_u.w > w do
                minimum_weight_edge = List.replace_at(minimum_weight_edge, u_comp, %{u: u, v: v, w: w})
                minimum_weight_edge
              else
                minimum_weight_edge
              end
              current_v = Enum.at(minimum_weight_edge, v_comp, [])
              minimum_weight_edge = if current_v.u == 0 - 1 || current_v.w > w do
                minimum_weight_edge = List.replace_at(minimum_weight_edge, v_comp, %{u: u, v: v, w: w})
                minimum_weight_edge
              else
                minimum_weight_edge
              end
              minimum_weight_edge
            else
              minimum_weight_edge
            end
            {minimum_weight_edge}
          end)
          {component_size, g, mst_weight, num_components} = Enum.reduce(minimum_weight_edge, {component_size, g, mst_weight, num_components}, fn e, {component_size, g, mst_weight, num_components} ->
            {component_size, g, mst_weight, num_components} = if e.u != 0 - 1 do
              u = e.u
              v = e.v
              w = e.w
              u_comp = g.component[u]
              v_comp = g.component[v]
              {component_size, g, mst_weight, num_components} = if u_comp != v_comp do
                mst_weight = mst_weight + w
                res = union(g, component_size, u_comp, v_comp)
                g = res.graph
                component_size = res.component_size
                IO.puts((((("Added edge [" <> Kernel.to_string(u)) <> " - ") <> Kernel.to_string(v)) <> "]"))
                IO.puts(("Added weight: " <> Kernel.to_string(w)))
                IO.puts("")
                num_components = num_components - 1
                {component_size, g, mst_weight, num_components}
              else
                {component_size, g, mst_weight, num_components}
              end
              {component_size, g, mst_weight, num_components}
            else
              {component_size, g, mst_weight, num_components}
            end
            {component_size, g, mst_weight, num_components}
          end)
          minimum_weight_edge = create_empty_edges(g.num_nodes)
          while_fun_4.(while_fun_4, component_size, g, minimum_weight_edge, mst_weight, num_components)
        else
          {component_size, g, minimum_weight_edge, mst_weight, num_components}
        end
      end
      {component_size, g, minimum_weight_edge, mst_weight, num_components} = try do
          while_fun_4.(while_fun_4, component_size, g, minimum_weight_edge, mst_weight, num_components)
        catch
          {:break, {component_size, g, minimum_weight_edge, mst_weight, num_components}} -> {component_size, g, minimum_weight_edge, mst_weight, num_components}
        end

      IO.puts(("The total weight of the minimal spanning tree is: " <> Kernel.to_string(mst_weight)))
      throw {:return, mst_weight}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      g = new_graph(8)
      edges = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4], [3, 4, 8], [4, 5, 10], [4, 6, 6], [4, 7, 5], [5, 7, 15], [6, 7, 4]]
      {g} = Enum.reduce(edges, {g}, fn e, {g} ->
        g = add_edge(g, Enum.at(e, 0, []), Enum.at(e, 1, []), Enum.at(e, 2, []))
        {g}
      end)
      boruvka(g)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
