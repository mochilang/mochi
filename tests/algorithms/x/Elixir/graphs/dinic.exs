# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow2(k) do
    try do
      res = 1
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < k do
          res = res * 2
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def min2(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def new_dinic(n) do
    try do
      lvl = []
      ptr = []
      q = []
      adj = []
      i = 0
      while_fun_2 = fn while_fun_2, adj, i, lvl, ptr, q ->
        if i < n do
          lvl = (lvl ++ [0])
          ptr = (ptr ++ [0])
          q = (q ++ [0])
          edges = []
          adj = (adj ++ [edges])
          i = i + 1
          while_fun_2.(while_fun_2, adj, i, lvl, ptr, q)
        else
          {adj, i, lvl, ptr, q}
        end
      end
      {adj, i, lvl, ptr, q} = try do
          while_fun_2.(while_fun_2, adj, i, lvl, ptr, q)
        catch
          {:break, {adj, i, lvl, ptr, q}} -> {adj, i, lvl, ptr, q}
        end

      throw {:return, %{n: n, lvl: lvl, ptr: ptr, q: q, adj: adj}}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, a, b, c, rcap) do
    try do
      adj = g.adj
      list_a = Enum.at(adj, a)
      list_b = Enum.at(adj, b)
      e1 = [b, _len(list_b), c, 0]
      e2 = [a, _len(list_a), rcap, 0]
      list_a = (list_a ++ [e1])
      list_b = (list_b ++ [e2])
      adj = List.replace_at(adj, a, list_a)
      adj = List.replace_at(adj, b, list_b)
      g = Map.put(g, :adj, adj)
    catch
      {:return, val} -> val
    end
  end
  def dfs(g, v, sink, flow) do
    try do
      if v == sink || flow == 0 do
        throw {:return, flow}
      end
      ptr = g.ptr
      i = Enum.at(ptr, v)
      adj_all = g.adj
      adj_v = Enum.at(adj_all, v)
      while_fun_3 = fn while_fun_3, adj_all, adj_v, g, i, ptr ->
        if i < _len(adj_v) do
          e = Enum.at(adj_v, i)
          to = Enum.at(e, 0)
          {adj_all, adj_v, e, g} = if Enum.at(g.lvl, to) == Enum.at(g.lvl, v) + 1 do
            avail = Enum.at(e, 2) - Enum.at(e, 3)
            pushed = dfs(g, to, sink, min2(flow, avail))
            {adj_all, adj_v, e, g} = if pushed > 0 do
              e = List.replace_at(e, 3, Enum.at(e, 3) + pushed)
              adj_v = List.replace_at(adj_v, i, e)
              adj_to = Enum.at(adj_all, to)
              back = Enum.at(adj_to, Enum.at(e, 1))
              back = List.replace_at(back, 3, Enum.at(back, 3) - pushed)
              adj_to = List.replace_at(adj_to, Enum.at(e, 1), back)
              adj_all = List.replace_at(adj_all, to, adj_to)
              adj_all = List.replace_at(adj_all, v, adj_v)
              g = Map.put(g, :adj, adj_all)
              throw {:return, pushed}
              {adj_all, adj_v, e, g}
            else
              {adj_all, adj_v, e, g}
            end
            {adj_all, adj_v, e, g}
          else
            {adj_all, adj_v, e, g}
          end
          i = i + 1
          ptr = List.replace_at(ptr, v, i)
          while_fun_3.(while_fun_3, adj_all, adj_v, g, i, ptr)
        else
          {adj_all, adj_v, g, i, ptr}
        end
      end
      {adj_all, adj_v, g, i, ptr} = try do
          while_fun_3.(while_fun_3, adj_all, adj_v, g, i, ptr)
        catch
          {:break, {adj_all, adj_v, g, i, ptr}} -> {adj_all, adj_v, g, i, ptr}
        end

      g = Map.put(g, :ptr, ptr)
      adj_all = List.replace_at(adj_all, v, adj_v)
      g = Map.put(g, :adj, adj_all)
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def max_flow(g, source, sink) do
    try do
      flow = 0
      l = 0
      while_fun_4 = fn while_fun_4, flow, g, l ->
        if l < 31 do
          threshold = pow2(30 - l)
          while_fun_5 = fn while_fun_5, flow, g ->
            if true do
              lvl = []
              ptr = []
              i = 0
              while_fun_6 = fn while_fun_6, i, lvl, ptr ->
                if i < g.n do
                  lvl = (lvl ++ [0])
                  ptr = (ptr ++ [0])
                  i = i + 1
                  while_fun_6.(while_fun_6, i, lvl, ptr)
                else
                  {i, lvl, ptr}
                end
              end
              {i, lvl, ptr} = try do
                  while_fun_6.(while_fun_6, i, lvl, ptr)
                catch
                  {:break, {i, lvl, ptr}} -> {i, lvl, ptr}
                end

              g = Map.put(g, :lvl, lvl)
              g = Map.put(g, :ptr, ptr)
              qi = 0
              qe = 1
              lvl = List.replace_at(lvl, source, 1)
              g = Map.put(g, :lvl, lvl)
              q = g.q
              q = List.replace_at(q, 0, source)
              while_fun_7 = fn while_fun_7, g, q, qe, qi ->
                if qi < qe && Enum.at(g.lvl, sink) == 0 do
                  v = Enum.at(q, qi)
                  qi = qi + 1
                  edges = Enum.at(g.adj, Process.get(:v))
                  j = 0
                  while_fun_8 = fn while_fun_8, g, j, q, qe ->
                    if j < _len(edges) do
                      e = Enum.at(edges, j)
                      to = Enum.at(e, 0)
                      residual = Enum.at(e, 2) - Enum.at(e, 3)
                      lvl_inner = g.lvl
                      {g, lvl_inner, q, qe} = if Enum.at(lvl_inner, to) == 0 && residual >= threshold do
                        q = List.replace_at(q, qe, to)
                        qe = qe + 1
                        lvl_inner = List.replace_at(lvl_inner, to, Enum.at(lvl_inner, Process.get(:v)) + 1)
                        g = Map.put(g, :lvl, lvl_inner)
                        {g, lvl_inner, q, qe}
                      else
                        {g, lvl_inner, q, qe}
                      end
                      j = j + 1
                      while_fun_8.(while_fun_8, g, j, q, qe)
                    else
                      {g, j, q, qe}
                    end
                  end
                  {g, j, q, qe} = try do
                      while_fun_8.(while_fun_8, g, j, q, qe)
                    catch
                      {:break, {g, j, q, qe}} -> {g, j, q, qe}
                    end

                  while_fun_7.(while_fun_7, g, q, qe, qi)
                else
                  {g, q, qe, qi}
                end
              end
              {g, q, qe, qi} = try do
                  while_fun_7.(while_fun_7, g, q, qe, qi)
                catch
                  {:break, {g, q, qe, qi}} -> {g, q, qe, qi}
                end

              p = dfs(g, source, sink, Process.get(:inf))
              while_fun_9 = fn while_fun_9, flow, p ->
                if p > 0 do
                  flow = flow + p
                  p = dfs(g, source, sink, Process.get(:inf))
                  while_fun_9.(while_fun_9, flow, p)
                else
                  {flow, p}
                end
              end
              {flow, p} = try do
                  while_fun_9.(while_fun_9, flow, p)
                catch
                  {:break, {flow, p}} -> {flow, p}
                end

              if Enum.at(g.lvl, sink) == 0 do
                throw {:break, {flow, g}}
              end
              while_fun_5.(while_fun_5, flow, g)
            else
              {flow, g}
            end
          end
          {flow, g} = try do
              while_fun_5.(while_fun_5, flow, g)
            catch
              {:break, {flow, g}} -> {flow, g}
            end

          l = l + 1
          while_fun_4.(while_fun_4, flow, g, l)
        else
          {flow, g, l}
        end
      end
      {flow, g, l} = try do
          while_fun_4.(while_fun_4, flow, g, l)
        catch
          {:break, {flow, g, l}} -> {flow, g, l}
        end

      throw {:return, flow}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:inf, 1000000000)
  Process.put(:source, 0)
  Process.put(:sink, 9)
  Process.put(:v, 1)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:graph, new_dinic(10))
    while_fun_10 = fn while_fun_10 ->
      if Process.get(:v) < 5 do
        add_edge(Process.get(:graph), Process.get(:source), Process.get(:v), 1, 0)
        Process.put(:v, Process.get(:v) + 1)
        while_fun_10.(while_fun_10)
      else
        nil
      end
    end
    try do
      while_fun_10.(while_fun_10)
    catch
      :break -> nil
    end

    Process.put(:v, 5)
    while_fun_11 = fn while_fun_11 ->
      if Process.get(:v) < 9 do
        add_edge(Process.get(:graph), Process.get(:v), Process.get(:sink), 1, 0)
        Process.put(:v, Process.get(:v) + 1)
        while_fun_11.(while_fun_11)
      else
        nil
      end
    end
    try do
      while_fun_11.(while_fun_11)
    catch
      :break -> nil
    end

    Process.put(:v, 1)
    while_fun_12 = fn while_fun_12 ->
      if Process.get(:v) < 5 do
        add_edge(Process.get(:graph), Process.get(:v), Process.get(:v) + 4, 1, 0)
        Process.put(:v, Process.get(:v) + 1)
        while_fun_12.(while_fun_12)
      else
        nil
      end
    end
    try do
      while_fun_12.(while_fun_12)
    catch
      :break -> nil
    end

    IO.puts(Kernel.inspect(max_flow(Process.get(:graph), Process.get(:source), Process.get(:sink))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
