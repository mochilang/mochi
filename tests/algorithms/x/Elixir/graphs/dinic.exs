# Code generated by Mochi transpiler 2025-08-15 10:15 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow2(k) do
    try do
      res = 1
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < k do
          res = res * 2
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def min2(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def new_dinic(n) do
    try do
      lvl = []
      ptr = []
      q = []
      adj = []
      i = 0
      while_fun_2 = fn while_fun_2, adj, i, lvl, ptr, q ->
        if i < n do
          lvl = (lvl ++ [0])
          ptr = (ptr ++ [0])
          q = (q ++ [0])
          edges = []
          adj = (adj ++ [edges])
          i = i + 1
          while_fun_2.(while_fun_2, adj, i, lvl, ptr, q)
        else
          {adj, i, lvl, ptr, q}
        end
      end
      {adj, _, lvl, ptr, q} = try do
          while_fun_2.(while_fun_2, adj, i, lvl, ptr, q)
        catch
          {:break, {adj, _, lvl, ptr, q}} -> {adj, 0, lvl, ptr, q}
        end

      throw {:return, %{n: n, lvl: lvl, ptr: ptr, q: q, adj: adj}}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, a, b, c, rcap) do
    try do
      adj = g.adj
      list_a = Enum.at(adj, a, [])
      list_b = Enum.at(adj, b, [])
      e1 = [b, _len(list_b), c, 0]
      e2 = [a, _len(list_a), rcap, 0]
      list_a = (list_a ++ [e1])
      list_b = (list_b ++ [e2])
      adj = List.replace_at(adj, a, list_a)
      adj = List.replace_at(adj, b, list_b)
      g = Map.put(g, :adj, adj)
    catch
      {:return, val} -> val
    end
  end
  def dfs(g, v, sink, flow) do
    try do
      if v == sink || flow == 0 do
        throw {:return, flow}
      end
      ptr = g.ptr
      i = Enum.at(ptr, v, [])
      adj_all = g.adj
      adj_v = Enum.at(adj_all, v, [])
      while_fun_3 = fn while_fun_3, adj_all, adj_v, g, i, ptr ->
        if i < _len(adj_v) do
          e = Enum.at(adj_v, i, [])
          to = Enum.at(e, 0, [])
          {adj_all, adj_v, e, g} = if Enum.at(g.lvl, to, 0) == Enum.at(g.lvl, v, 0) + 1 do
            avail = Enum.at(e, 2, []) - Enum.at(e, 3, [])
            pushed = dfs(g, to, sink, min2(flow, avail))
            {adj_all, adj_v, e, g} = if pushed > 0 do
              e = List.replace_at(e, 3, Enum.at(e, 3, []) + pushed)
              adj_v = List.replace_at(adj_v, i, e)
              adj_to = Enum.at(adj_all, to, [])
              back = Enum.at(adj_to, Enum.at(e, 1, []), [])
              back = List.replace_at(back, 3, Enum.at(back, 3, []) - pushed)
              adj_to = List.replace_at(adj_to, Enum.at(e, 1, []), back)
              adj_all = List.replace_at(adj_all, to, adj_to)
              adj_all = List.replace_at(adj_all, v, adj_v)
              g = Map.put(g, :adj, adj_all)
              throw {:return, pushed}
              {adj_all, adj_v, e, g}
            else
              {adj_all, adj_v, e, g}
            end
            {adj_all, adj_v, e, g}
          else
            {adj_all, adj_v, e, g}
          end
          i = i + 1
          ptr = List.replace_at(ptr, v, i)
          while_fun_3.(while_fun_3, adj_all, adj_v, g, i, ptr)
        else
          {adj_all, adj_v, g, i, ptr}
        end
      end
      {adj_all, adj_v, g, _, ptr} = try do
          while_fun_3.(while_fun_3, adj_all, adj_v, g, i, ptr)
        catch
          {:break, {adj_all, adj_v, g, _, ptr}} -> {adj_all, adj_v, g, 0, ptr}
        end

      g = Map.put(g, :ptr, ptr)
      adj_all = List.replace_at(adj_all, v, adj_v)
      g = Map.put(g, :adj, adj_all)
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def max_flow(g, source, sink) do
    try do
      flow = 0
      l = 0
      while_fun_4 = fn while_fun_4, flow, g, l ->
        if l < 31 do
          threshold = pow2(30 - l)
          while_fun_5 = fn while_fun_5, flow, g ->
            if true do
              lvl = []
              ptr = []
              i = 0
              while_fun_6 = fn while_fun_6, i, lvl, ptr ->
                if i < g.n do
                  lvl = (lvl ++ [0])
                  ptr = (ptr ++ [0])
                  i = i + 1
                  while_fun_6.(while_fun_6, i, lvl, ptr)
                else
                  {i, lvl, ptr}
                end
              end
              {_, lvl, ptr} = try do
                  while_fun_6.(while_fun_6, i, lvl, ptr)
                catch
                  {:break, {_, lvl, ptr}} -> {0, lvl, ptr}
                end

              g = Map.put(g, :lvl, lvl)
              g = Map.put(g, :ptr, ptr)
              qi = 0
              qe = 1
              lvl = List.replace_at(lvl, source, 1)
              g = Map.put(g, :lvl, lvl)
              q = g.q
              q = List.replace_at(q, 0, source)
              while_fun_7 = fn while_fun_7, g, q, qe, qi ->
                if qi < qe && Enum.at(g.lvl, sink, 0) == 0 do
                  v = Enum.at(q, qi, [])
                  qi = qi + 1
                  edges = Enum.at(g.adj, Process.get(:v), 0)
                  j = 0
                  while_fun_8 = fn while_fun_8, g, j, q, qe ->
                    if j < _len(edges) do
                      e = Enum.at(edges, j, [])
                      to = Enum.at(e, 0, [])
                      residual = Enum.at(e, 2, []) - Enum.at(e, 3, [])
                      lvl_inner = g.lvl
                      {g, lvl_inner, q, qe} = if Enum.at(lvl_inner, to, []) == 0 && residual >= threshold do
                        q = List.replace_at(q, qe, to)
                        qe = qe + 1
                        lvl_inner = List.replace_at(lvl_inner, to, Enum.at(lvl_inner, Process.get(:v), []) + 1)
                        g = Map.put(g, :lvl, lvl_inner)
                        {g, lvl_inner, q, qe}
                      else
                        {g, lvl_inner, q, qe}
                      end
                      j = j + 1
                      while_fun_8.(while_fun_8, g, j, q, qe)
                    else
                      {g, j, q, qe}
                    end
                  end
                  {g, _, q, qe} = try do
                      while_fun_8.(while_fun_8, g, j, q, qe)
                    catch
                      {:break, {g, _, q, qe}} -> {g, 0, q, qe}
                    end

                  while_fun_7.(while_fun_7, g, q, qe, qi)
                else
                  {g, q, qe, qi}
                end
              end
              {g, q, qe, qi} = try do
                  while_fun_7.(while_fun_7, g, q, qe, qi)
                catch
                  {:break, {g, q, qe, qi}} -> {g, q, qe, qi}
                end

              p = dfs(g, source, sink, Process.get(:inf))
              while_fun_9 = fn while_fun_9, flow, p ->
                if p > 0 do
                  flow = flow + p
                  p = dfs(g, source, sink, Process.get(:inf))
                  while_fun_9.(while_fun_9, flow, p)
                else
                  {flow, p}
                end
              end
              {flow, p} = try do
                  while_fun_9.(while_fun_9, flow, p)
                catch
                  {:break, {flow, p}} -> {flow, p}
                end

              if Enum.at(g.lvl, sink, 0) == 0 do
                throw {:break, {flow, g}}
              end
              while_fun_5.(while_fun_5, flow, g)
            else
              {flow, g}
            end
          end
          {flow, g} = try do
              while_fun_5.(while_fun_5, flow, g)
            catch
              {:break, {flow, g}} -> {flow, g}
            end

          l = l + 1
          while_fun_4.(while_fun_4, flow, g, l)
        else
          {flow, g, l}
        end
      end
      {flow, g, l} = try do
          while_fun_4.(while_fun_4, flow, g, l)
        catch
          {:break, {flow, g, l}} -> {flow, g, l}
        end

      throw {:return, flow}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:inf, 1000000000)
  Process.put(:source, 0)
  Process.put(:sink, 9)
  Process.put(:v, 1)
  def main() do
    Process.put(:graph, new_dinic(10))
    while_fun_10 = fn while_fun_10, v ->
      if Process.get(:v) < 5 do
        add_edge(Process.get(:graph), Process.get(:source), Process.get(:v), 1, 0)
        Process.put(:v, Process.get(:v) + 1)
        while_fun_10.(while_fun_10, Process.get(:v))
      else
        v
      end
    end
    v = try do
        while_fun_10.(while_fun_10, Process.get(:v))
      catch
        {:break, {v}} -> v
      end

    Process.put(:v, 5)
    while_fun_11 = fn while_fun_11, v ->
      if Process.get(:v) < 9 do
        add_edge(Process.get(:graph), Process.get(:v), Process.get(:sink), 1, 0)
        Process.put(:v, Process.get(:v) + 1)
        while_fun_11.(while_fun_11, Process.get(:v))
      else
        v
      end
    end
    v = try do
        while_fun_11.(while_fun_11, Process.get(:v))
      catch
        {:break, {v}} -> v
      end

    Process.put(:v, 1)
    while_fun_12 = fn while_fun_12, v ->
      if Process.get(:v) < 5 do
        add_edge(Process.get(:graph), Process.get(:v), Process.get(:v) + 4, 1, 0)
        Process.put(:v, Process.get(:v) + 1)
        while_fun_12.(while_fun_12, Process.get(:v))
      else
        v
      end
    end
    v = try do
        while_fun_12.(while_fun_12, Process.get(:v))
      catch
        {:break, {v}} -> v
      end

    IO.puts(Kernel.inspect(max_flow(Process.get(:graph), Process.get(:source), Process.get(:sink))))
  end
end
Main.main()
