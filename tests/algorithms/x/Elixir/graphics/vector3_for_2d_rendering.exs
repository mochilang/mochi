# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def modf(x, m) do
    try do
      throw {:return, x - floor(x / m) * m}
    catch
      {:return, val} -> val
    end
  end
  def sin_taylor(x) do
    try do
      term = x
      sum = x
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i))
          k2 = k1 + 1.0
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def cos_taylor(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun_2 = fn while_fun_2, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i)) - 1.0
          k2 = 2.0 * (:erlang.float(i))
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun_2.(while_fun_2, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun_2.(while_fun_2, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def convert_to_2d(x, y, z, scale, distance) do
    try do
      projected_x = ((x * distance) / (z + distance)) * scale
      projected_y = ((y * distance) / (z + distance)) * scale
      throw {:return, [projected_x, projected_y]}
    catch
      {:return, val} -> val
    end
  end
  def rotate(x, y, z, axis, angle) do
    try do
      angle = modf(angle, 360.0) / 450.0 * 180.0 / Process.get(:pi)
      angle = modf(angle, 2.0 * Process.get(:pi))
      {angle} = if angle > Process.get(:pi) do
        angle = angle - 2.0 * Process.get(:pi)
        {angle}
      else
        {angle}
      end
      if axis == "z" do
        new_x = x * cos_taylor(angle) - y * sin_taylor(angle)
        new_y = y * cos_taylor(angle) + x * sin_taylor(angle)
        new_z = z
        throw {:return, [new_x, new_y, new_z]}
      end
      if axis == "x" do
        new_y = y * cos_taylor(angle) - z * sin_taylor(angle)
        new_z = z * cos_taylor(angle) + y * sin_taylor(angle)
        new_x = x
        throw {:return, [new_x, new_y, new_z]}
      end
      if axis == "y" do
        new_x = x * cos_taylor(angle) - z * sin_taylor(angle)
        new_z = z * cos_taylor(angle) + x * sin_taylor(angle)
        new_y = y
        throw {:return, [new_x, new_y, new_z]}
      end
      IO.puts("not a valid axis, choose one of 'x', 'y', 'z'")
      throw {:return, [0.0, 0.0, 0.0]}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)))
    IO.puts(Kernel.inspect(rotate(1.0, 2.0, 3.0, "y", 90.0)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
