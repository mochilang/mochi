# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def build_set(words) do
    try do
      m = %{}
      {m} = Enum.reduce(words, {m}, fn w, {m} ->
        m = Map.put(m, w, true)
        {m}
      end)
      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def word_break(s, words) do
    try do
      n = _len(s)
      dict = build_set(words)
      dp = []
      i = 0
      while_fun = fn while_fun, dp, i ->
        if i <= n do
          dp = (dp ++ [false])
          i = i + 1
          while_fun.(while_fun, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun.(while_fun, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      dp = List.replace_at(dp, 0, true)
      i = 1
      while_fun_2 = fn while_fun_2, dp, i ->
        if i <= n do
          j = 0
          while_fun_3 = fn while_fun_3, dp, j ->
            if j < i do
              {dp, j} = if Enum.at(dp, j) do
                sub = _slice(s, j, i - j)
                {dp, j} = if Map.has_key?(dict, sub) do
                  dp = List.replace_at(dp, i, true)
                  j = i
                  {dp, j}
                else
                  {dp, j}
                end
                {dp, j}
              else
                {dp, j}
              end
              j = j + 1
              while_fun_3.(while_fun_3, dp, j)
            else
              {dp, j}
            end
          end
          {dp, j} = try do
              while_fun_3.(while_fun_3, dp, j)
            catch
              {:break, {dp, j}} -> {dp, j}
            end

          i = i + 1
          while_fun_2.(while_fun_2, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_2.(while_fun_2, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      throw {:return, Enum.at(dp, n)}
    catch
      {:return, val} -> val
    end
  end
  def print_bool(b) do
    try do
      if b do
        IO.puts(true)
      else
        IO.puts(false)
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    print_bool(word_break("applepenapple", ["apple", "pen"]))
    print_bool(word_break("catsandog", ["cats", "dog", "sand", "and", "cat"]))
    print_bool(word_break("cars", ["car", "ca", "rs"]))
  end
end
Main.main()
