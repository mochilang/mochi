# Code generated by Mochi transpiler 2025-08-13 07:12 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def max_int(a, b) do
    try do
      if a > b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def init_f(n, w) do
    try do
      table = []
      i = 0
      while_fun = fn while_fun, i, table ->
        if i <= n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j <= w do
              row = (if i == 0 || j == 0, do: (row ++ [0]), else: (row ++ [-1]))
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          table = (table ++ [row])
          i = i + 1
          while_fun.(while_fun, i, table)
        else
          {i, table}
        end
      end
      {i, table} = try do
          while_fun.(while_fun, i, table)
        catch
          {:break, {i, table}} -> {i, table}
        end

      throw {:return, table}
    catch
      {:return, val} -> val
    end
  end
  def mf_knapsack(i, wt, val, j) do
    try do
      if Enum.at(Enum.at(Process.get(:f), i, []), j, 0) < 0 do
        if j < Enum.at(wt, i - 1, []) do
          Process.put(:f, List.replace_at(Process.get(:f), i, List.replace_at(Enum.at(Process.get(:f), i), j, mf_knapsack(i - 1, wt, val, j))))
        else
          without_item = mf_knapsack(i - 1, wt, val, j)
          with_item = mf_knapsack(i - 1, wt, val, j - Enum.at(wt, i - 1, [])) + Enum.at(val, i - 1, [])
          Process.put(:f, List.replace_at(Process.get(:f), i, List.replace_at(Enum.at(Process.get(:f), i), j, max_int(without_item, with_item))))
        end
      end
      throw {:return, Enum.at(Enum.at(Process.get(:f), i, []), j, 0)}
    catch
      {:return, val} -> val
    end
  end
  def create_matrix(rows, cols) do
    try do
      matrix = []
      i = 0
      while_fun_3 = fn while_fun_3, i, matrix ->
        if i <= rows do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j <= cols do
              row = (row ++ [0])
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          matrix = (matrix ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, i, matrix)
        else
          {i, matrix}
        end
      end
      {i, matrix} = try do
          while_fun_3.(while_fun_3, i, matrix)
        catch
          {:break, {i, matrix}} -> {i, matrix}
        end

      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def knapsack(w, wt, val, n) do
    try do
      dp = create_matrix(n, w)
      i = 1
      while_fun_5 = fn while_fun_5, dp, i ->
        if i <= n do
          w_ = 1
          while_fun_6 = fn while_fun_6, dp, w_ ->
            if w_ <= w do
              {dp} = if Enum.at(wt, i - 1, []) <= w_ do
                include = Enum.at(val, i - 1, []) + Enum.at(Enum.at(dp, i - 1, []), w_ - Enum.at(wt, i - 1, []), 0)
                exclude = Enum.at(Enum.at(dp, i - 1, []), w_, 0)
                dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), w_, max_int(include, exclude)))
                {dp}
              else
                dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), w_, Enum.at(Enum.at(dp, i - 1, []), w_, 0)))
                {dp}
              end
              w_ = w_ + 1
              while_fun_6.(while_fun_6, dp, w_)
            else
              {dp, w_}
            end
          end
          {dp, w_} = try do
              while_fun_6.(while_fun_6, dp, w_)
            catch
              {:break, {dp, w_}} -> {dp, w_}
            end

          i = i + 1
          while_fun_5.(while_fun_5, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_5.(while_fun_5, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      throw {:return, dp}
    catch
      {:return, val} -> val
    end
  end
  def construct_solution(dp, wt, i, j, optimal_set) do
    try do
      if i > 0 && j > 0 do
        if Enum.at(Enum.at(dp, i - 1, []), j, 0) == Enum.at(Enum.at(dp, i, []), j, 0) do
          throw {:return, construct_solution(dp, wt, i - 1, j, optimal_set)}
        else
          with_prev = construct_solution(dp, wt, i - 1, j - Enum.at(wt, i - 1, []), optimal_set)
          throw {:return, (with_prev ++ [i])}
        end
      end
      throw {:return, optimal_set}
    catch
      {:return, val} -> val
    end
  end
  def knapsack_with_example_solution(w, wt, val) do
    try do
      num_items = _len(wt)
      dp_table = knapsack(w, wt, val, num_items)
      optimal_val = Enum.at(Enum.at(dp_table, num_items, []), w, 0)
      subset = construct_solution(dp_table, wt, num_items, w, [])
      throw {:return, %{value: optimal_val, subset: subset}}
    catch
      {:return, val} -> val
    end
  end
  def format_set(xs) do
    try do
      res = "{"
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < _len(xs) do
          res = (res <> Kernel.to_string(Enum.at(xs, i, [])))
          {res} = if i + 1 < _len(xs) do
            res = (res <> ", ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res <> "}")
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:f, [])
  Process.put(:val_list, [3, 2, 4, 4])
  Process.put(:wt_list, [4, 3, 2, 3])
  Process.put(:n, 4)
  Process.put(:w_cap, 6)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:f, init_f(Process.get(:n), Process.get(:w_cap)))
    Process.put(:dp_table, knapsack(Process.get(:w_cap), Process.get(:wt_list), Process.get(:val_list), Process.get(:n)))
    Process.put(:optimal_solution, Enum.at(Enum.at(Process.get(:dp_table), Process.get(:n), []), Process.get(:w_cap), 0))
    IO.puts(Process.get(:optimal_solution))
    IO.puts(Kernel.inspect(mf_knapsack(Process.get(:n), Process.get(:wt_list), Process.get(:val_list), Process.get(:w_cap))))
    Process.put(:example, knapsack_with_example_solution(Process.get(:w_cap), Process.get(:wt_list), Process.get(:val_list)))
    IO.puts(("optimal_value = " <> Kernel.to_string(Process.get(:example).value)))
    IO.puts(("An optimal subset corresponding to the optimal value " <> format_set(Process.get(:example).subset)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
