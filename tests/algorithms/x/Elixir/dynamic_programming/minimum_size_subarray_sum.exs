# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def minimum_subarray_sum(target, numbers) do
    try do
      n = _len(numbers)
      if n == 0 do
        throw {:return, 0}
      end
      if target == 0 do
        i = 0
        while_fun = fn while_fun, i ->
          if i < n do
            if Enum.at(numbers, i) == 0 do
              throw {:return, 0}
            end
            i = i + 1
            while_fun.(while_fun, i)
          else
            i
          end
        end
        i = try do
            while_fun.(while_fun, i)
          catch
            {:break, {i}} -> i
          end

      end
      left = 0
      right = 0
      curr_sum = 0
      min_len = n + 1
      while_fun_2 = fn while_fun_2, curr_sum, left, min_len, right ->
        if right < n do
          curr_sum = curr_sum + Enum.at(numbers, right)
          while_fun_3 = fn while_fun_3, curr_sum, left, min_len ->
            if curr_sum >= target && left <= right do
              current_len = right - left + 1
              {min_len} = if current_len < min_len do
                min_len = current_len
                {min_len}
              else
                {min_len}
              end
              curr_sum = curr_sum - Enum.at(numbers, left)
              left = left + 1
              while_fun_3.(while_fun_3, curr_sum, left, min_len)
            else
              {curr_sum, left, min_len}
            end
          end
          {curr_sum, left, min_len} = try do
              while_fun_3.(while_fun_3, curr_sum, left, min_len)
            catch
              {:break, {curr_sum, left, min_len}} -> {curr_sum, left, min_len}
            end

          right = right + 1
          while_fun_2.(while_fun_2, curr_sum, left, min_len, right)
        else
          {curr_sum, left, min_len, right}
        end
      end
      {curr_sum, left, min_len, right} = try do
          while_fun_2.(while_fun_2, curr_sum, left, min_len, right)
        catch
          {:break, {curr_sum, left, min_len, right}} -> {curr_sum, left, min_len, right}
        end

      if min_len == n + 1 do
        throw {:return, 0}
      end
      throw {:return, min_len}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3])))
    IO.puts(Kernel.inspect(minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3])))
    IO.puts(Kernel.inspect(minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1])))
    IO.puts(Kernel.inspect(minimum_subarray_sum(0, [1, 2, 3])))
  end
end
Main.main()
