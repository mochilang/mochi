# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_list(len, value) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < len do
          arr = (arr ++ [value])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def max_int(a, b) do
    try do
      if a > b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def min_int(a, b) do
    try do
      if a < b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def min3(a, b, c) do
    try do
      throw {:return, min_int(min_int(a, b), c)}
    catch
      {:return, val} -> val
    end
  end
  def minimum_tickets_cost(days, costs) do
    try do
      if _len(days) == 0 do
        throw {:return, 0}
      end
      last_day = Enum.at(days, _len(days) - 1)
      dp = make_list(last_day + 1, 0)
      day_index = 0
      d = 1
      while_fun_2 = fn while_fun_2, d, day_index, dp ->
        if d <= last_day do
          {day_index, dp} = if day_index < _len(days) && d == Enum.at(days, day_index) do
            cost1 = Enum.at(dp, d - 1) + Enum.at(costs, 0)
            cost7 = Enum.at(dp, max_int(0, d - 7)) + Enum.at(costs, 1)
            cost30 = Enum.at(dp, max_int(0, d - 30)) + Enum.at(costs, 2)
            dp = List.replace_at(dp, d, min3(cost1, cost7, cost30))
            day_index = day_index + 1
            {day_index, dp}
          else
            dp = List.replace_at(dp, d, Enum.at(dp, d - 1))
            {day_index, dp}
          end
          d = d + 1
          while_fun_2.(while_fun_2, d, day_index, dp)
        else
          {d, day_index, dp}
        end
      end
      {d, day_index, dp} = try do
          while_fun_2.(while_fun_2, d, day_index, dp)
        catch
          {:break, {d, day_index, dp}} -> {d, day_index, dp}
        end

      throw {:return, Enum.at(dp, last_day)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(minimum_tickets_cost([1, 4, 6, 7, 8, 20], [2, 7, 15])))
    IO.puts(Kernel.inspect(minimum_tickets_cost([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 7, 15])))
    IO.puts(Kernel.inspect(minimum_tickets_cost([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])))
  end
end
Main.main()
