# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_list(len, value) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < len do
          arr = (arr ++ [value])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def trapped_rainwater(heights) do
    try do
      if _len(heights) == 0 do
        throw {:return, 0}
      end
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(heights) do
          if Enum.at(heights, i) < 0 do
            raise("No height can be negative")
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      length = _len(heights)
      left_max = make_list(length, 0)
      left_max = List.replace_at(left_max, 0, Enum.at(heights, 0))
      i = 1
      while_fun_3 = fn while_fun_3, i, left_max ->
        if i < length do
          left_max = List.replace_at(left_max, i, ((if Enum.at(heights, i) > Enum.at(left_max, i - 1), do: Enum.at(heights, i), else: Enum.at(left_max, i - 1))))
          i = i + 1
          while_fun_3.(while_fun_3, i, left_max)
        else
          {i, left_max}
        end
      end
      {i, left_max} = try do
          while_fun_3.(while_fun_3, i, left_max)
        catch
          {:break, {i, left_max}} -> {i, left_max}
        end

      right_max = make_list(length, 0)
      last = length - 1
      right_max = List.replace_at(right_max, last, Enum.at(heights, last))
      i = last - 1
      while_fun_4 = fn while_fun_4, i, right_max ->
        if i >= 0 do
          right_max = List.replace_at(right_max, i, ((if Enum.at(heights, i) > Enum.at(right_max, i + 1), do: Enum.at(heights, i), else: Enum.at(right_max, i + 1))))
          i = i - 1
          while_fun_4.(while_fun_4, i, right_max)
        else
          {i, right_max}
        end
      end
      {i, right_max} = try do
          while_fun_4.(while_fun_4, i, right_max)
        catch
          {:break, {i, right_max}} -> {i, right_max}
        end

      total = 0
      i = 0
      while_fun_5 = fn while_fun_5, i, total ->
        if i < length do
          left = Enum.at(left_max, i)
          right = Enum.at(right_max, i)
          smaller = (if left < right, do: left, else: right)
          total = total + (smaller - Enum.at(heights, i))
          i = i + 1
          while_fun_5.(while_fun_5, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_5.(while_fun_5, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(trapped_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])))
    IO.puts(Kernel.inspect(trapped_rainwater([7, 1, 5, 3, 6, 4])))
  end
end
Main.main()
