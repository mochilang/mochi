# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def new_graph(n) do
    try do
      dp = []
      i = 0
      while_fun = fn while_fun, dp, i ->
        if i < n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < n do
              row = (if i == j, do: (row ++ [0]), else: (row ++ [Process.get(:inf)]))
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          dp = (dp ++ [row])
          i = i + 1
          while_fun.(while_fun, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun.(while_fun, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      throw {:return, %{n: n, dp: dp}}
    catch
      {:return, val} -> val
    end
  end
  def add_edge(g, u, v, w) do
    try do
      dp = g.dp
      row = Enum.at(dp, u)
      row = List.replace_at(row, v, w)
      dp = List.replace_at(dp, u, row)
      g = Map.put(g, :dp, dp)
    catch
      {:return, val} -> val
    end
  end
  def floyd_warshall(g) do
    try do
      dp = g.dp
      k = 0
      while_fun_3 = fn while_fun_3, dp, k ->
        if k < g.n do
          i = 0
          while_fun_4 = fn while_fun_4, dp, i ->
            if i < g.n do
              j = 0
              while_fun_5 = fn while_fun_5, dp, j ->
                if j < g.n do
                  alt = Enum.at(Enum.at(dp, i), k) + Enum.at(Enum.at(dp, k), j)
                  row = Enum.at(dp, i)
                  {dp, row} = if alt < Enum.at(row, j) do
                    row = List.replace_at(row, j, alt)
                    dp = List.replace_at(dp, i, row)
                    {dp, row}
                  else
                    {dp, row}
                  end
                  j = j + 1
                  while_fun_5.(while_fun_5, dp, j)
                else
                  {dp, j}
                end
              end
              {dp, j} = try do
                  while_fun_5.(while_fun_5, dp, j)
                catch
                  {:break, {dp, j}} -> {dp, j}
                end

              i = i + 1
              while_fun_4.(while_fun_4, dp, i)
            else
              {dp, i}
            end
          end
          {dp, i} = try do
              while_fun_4.(while_fun_4, dp, i)
            catch
              {:break, {dp, i}} -> {dp, i}
            end

          k = k + 1
          while_fun_3.(while_fun_3, dp, k)
        else
          {dp, k}
        end
      end
      {dp, k} = try do
          while_fun_3.(while_fun_3, dp, k)
        catch
          {:break, {dp, k}} -> {dp, k}
        end

      g = Map.put(g, :dp, dp)
    catch
      {:return, val} -> val
    end
  end
  def show_min(g, u, v) do
    try do
      throw {:return, Enum.at(Enum.at(g.dp, u), v)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:inf, 1000000000)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:graph, new_graph(5))
    add_edge(Process.get(:graph), 0, 2, 9)
    add_edge(Process.get(:graph), 0, 4, 10)
    add_edge(Process.get(:graph), 1, 3, 5)
    add_edge(Process.get(:graph), 2, 3, 7)
    add_edge(Process.get(:graph), 3, 0, 10)
    add_edge(Process.get(:graph), 3, 1, 2)
    add_edge(Process.get(:graph), 3, 2, 1)
    add_edge(Process.get(:graph), 3, 4, 6)
    add_edge(Process.get(:graph), 4, 1, 3)
    add_edge(Process.get(:graph), 4, 2, 4)
    add_edge(Process.get(:graph), 4, 3, 9)
    floyd_warshall(Process.get(:graph))
    IO.puts(Kernel.inspect(show_min(Process.get(:graph), 1, 4)))
    IO.puts(Kernel.inspect(show_min(Process.get(:graph), 0, 3)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
