# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sort_nodes(nodes) do
    try do
      arr = nodes
      i = 1
      while_fun = fn while_fun, arr, i ->
        if i < _len(arr) do
          key_node = Enum.at(arr, i)
          j = i - 1
          while_fun_2 = fn while_fun_2, arr, j ->
            if j >= 0 do
              temp = Enum.at(arr, j)
              {arr, j} = if temp.key > key_node.key do
                arr = List.replace_at(arr, j + 1, temp)
                j = j - 1
                {arr, j}
              else
                throw {:break, {arr, j}}
                {arr, j}
              end
              while_fun_2.(while_fun_2, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_2.(while_fun_2, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          arr = List.replace_at(arr, j + 1, key_node)
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def print_node(n) do
    try do
      IO.puts((((("Node(key=" <> Kernel.to_string(n.key)) <> ", freq=") <> Kernel.to_string(n.freq)) <> ")"))
    catch
      {:return, val} -> val
    end
  end
  def print_binary_search_tree(root, keys, i, j, parent, is_left) do
    try do
      if i > j || i < 0 || j > _len(root) - 1 do
        throw {:return, nil}
      end
      node_ = Enum.at(Enum.at(root, i), j)
      if parent == (-1) do
        IO.puts((Kernel.to_string(Enum.at(keys, node_)) <> " is the root of the binary search tree."))
      else
        if is_left do
          IO.puts((((Kernel.to_string(Enum.at(keys, node_)) <> " is the left child of key ") <> Kernel.to_string(parent)) <> "."))
        else
          IO.puts((((Kernel.to_string(Enum.at(keys, node_)) <> " is the right child of key ") <> Kernel.to_string(parent)) <> "."))
        end
      end
      print_binary_search_tree(root, keys, i, node_ - 1, Enum.at(keys, node_), true)
      print_binary_search_tree(root, keys, node_ + 1, j, Enum.at(keys, node_), false)
    catch
      {:return, val} -> val
    end
  end
  def find_optimal_binary_search_tree(original_nodes) do
    try do
      nodes = sort_nodes(original_nodes)
      n = _len(nodes)
      keys = []
      freqs = []
      i = 0
      while_fun_3 = fn while_fun_3, freqs, i, keys ->
        if i < n do
          node_ = Enum.at(nodes, i)
          keys = (keys ++ [node_.key])
          freqs = (freqs ++ [node_.freq])
          i = i + 1
          while_fun_3.(while_fun_3, freqs, i, keys)
        else
          {freqs, i, keys}
        end
      end
      {freqs, i, keys} = try do
          while_fun_3.(while_fun_3, freqs, i, keys)
        catch
          {:break, {freqs, i, keys}} -> {freqs, i, keys}
        end

      dp = []
      total = []
      root = []
      i = 0
      while_fun_4 = fn while_fun_4, dp, i, root, total ->
        if i < n do
          dp_row = []
          total_row = []
          root_row = []
          j = 0
          while_fun_5 = fn while_fun_5, dp_row, j, root_row, total_row ->
            if j < n do
              {dp_row, root_row, total_row} = if i == j do
                dp_row = (dp_row ++ [Enum.at(freqs, i)])
                total_row = (total_row ++ [Enum.at(freqs, i)])
                root_row = (root_row ++ [i])
                {dp_row, root_row, total_row}
              else
                dp_row = (dp_row ++ [0])
                total_row = (total_row ++ [0])
                root_row = (root_row ++ [0])
                {dp_row, root_row, total_row}
              end
              j = j + 1
              while_fun_5.(while_fun_5, dp_row, j, root_row, total_row)
            else
              {dp_row, j, root_row, total_row}
            end
          end
          {dp_row, j, root_row, total_row} = try do
              while_fun_5.(while_fun_5, dp_row, j, root_row, total_row)
            catch
              {:break, {dp_row, j, root_row, total_row}} -> {dp_row, j, root_row, total_row}
            end

          dp = (dp ++ [dp_row])
          total = (total ++ [total_row])
          root = (root ++ [root_row])
          i = i + 1
          while_fun_4.(while_fun_4, dp, i, root, total)
        else
          {dp, i, root, total}
        end
      end
      {dp, i, root, total} = try do
          while_fun_4.(while_fun_4, dp, i, root, total)
        catch
          {:break, {dp, i, root, total}} -> {dp, i, root, total}
        end

      interval_length = 2
      inf = 2147483647
      while_fun_6 = fn while_fun_6, dp, i, interval_length, root, total ->
        if interval_length <= n do
          i = 0
          while_fun_7 = fn while_fun_7, dp, i, root, total ->
            if i < n - interval_length + 1 do
              j = i + interval_length - 1
              dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, inf))
              total = List.replace_at(total, i, List.replace_at(Enum.at(total, i), j, Enum.at(Enum.at(total, i), j - 1) + Enum.at(freqs, j)))
              r = Enum.at(Enum.at(root, i), j - 1)
              while_fun_8 = fn while_fun_8, dp, r, root ->
                if r <= Enum.at(Enum.at(root, i + 1), j) do
                  left = (if r != i, do: Enum.at(Enum.at(dp, i), r - 1), else: 0)
                  right = (if r != j, do: Enum.at(Enum.at(dp, r + 1), j), else: 0)
                  cost = left + Enum.at(Enum.at(total, i), j) + right
                  {dp, root} = if Enum.at(Enum.at(dp, i), j) > cost do
                    dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, cost))
                    root = List.replace_at(root, i, List.replace_at(Enum.at(root, i), j, r))
                    {dp, root}
                  else
                    {dp, root}
                  end
                  r = r + 1
                  while_fun_8.(while_fun_8, dp, r, root)
                else
                  {dp, r, root}
                end
              end
              {dp, r, root} = try do
                  while_fun_8.(while_fun_8, dp, r, root)
                catch
                  {:break, {dp, r, root}} -> {dp, r, root}
                end

              i = i + 1
              while_fun_7.(while_fun_7, dp, i, root, total)
            else
              {dp, i, root, total}
            end
          end
          {dp, i, root, total} = try do
              while_fun_7.(while_fun_7, dp, i, root, total)
            catch
              {:break, {dp, i, root, total}} -> {dp, i, root, total}
            end

          interval_length = interval_length + 1
          while_fun_6.(while_fun_6, dp, i, interval_length, root, total)
        else
          {dp, i, interval_length, root, total}
        end
      end
      {dp, i, interval_length, root, total} = try do
          while_fun_6.(while_fun_6, dp, i, interval_length, root, total)
        catch
          {:break, {dp, i, interval_length, root, total}} -> {dp, i, interval_length, root, total}
        end

      IO.puts("Binary search tree nodes:")
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < n do
          print_node(Enum.at(nodes, i))
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {i}} -> i
        end

      IO.puts((("\nThe cost of optimal BST for given tree nodes is " <> Kernel.to_string(Enum.at(Enum.at(dp, 0), n - 1))) <> "."))
      print_binary_search_tree(root, keys, 0, n - 1, (-1), false)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      nodes = [%{key: 12, freq: 8}, %{key: 10, freq: 34}, %{key: 20, freq: 50}, %{key: 42, freq: 3}, %{key: 25, freq: 40}, %{key: 37, freq: 30}]
      find_optimal_binary_search_tree(nodes)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
