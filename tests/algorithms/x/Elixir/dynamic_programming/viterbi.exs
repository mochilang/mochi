# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def key(state, obs) do
    try do
      throw {:return, ((state <> "|") <> obs)}
    catch
      {:return, val} -> val
    end
  end
  def viterbi(observations, states, start_p, trans_p, emit_p) do
    try do
      if _len(observations) == 0 || _len(states) == 0 do
        raise("empty parameters")
      end
      probs = %{}
      ptrs = %{}
      first_obs = Enum.at(observations, 0)
      i = 0
      while_fun = fn while_fun, i, probs, ptrs ->
        if i < _len(states) do
          state = Enum.at(states, i)
          probs = Map.put(probs, key(state, first_obs), start_p[state] * emit_p[state][first_obs])
          ptrs = Map.put(ptrs, key(state, first_obs), "")
          i = i + 1
          while_fun.(while_fun, i, probs, ptrs)
        else
          {i, probs, ptrs}
        end
      end
      {i, probs, ptrs} = try do
          while_fun.(while_fun, i, probs, ptrs)
        catch
          {:break, {i, probs, ptrs}} -> {i, probs, ptrs}
        end

      t = 1
      while_fun_2 = fn while_fun_2, probs, ptrs, t ->
        if t < _len(observations) do
          obs = Enum.at(observations, t)
          j = 0
          while_fun_3 = fn while_fun_3, j, probs, ptrs ->
            if j < _len(states) do
              state = Enum.at(states, j)
              max_prob = -1.0
              prev_state = ""
              k = 0
              while_fun_4 = fn while_fun_4, k, max_prob, prev_state ->
                if k < _len(states) do
                  state0 = Enum.at(states, k)
                  obs0 = Enum.at(observations, t - 1)
                  prob_prev = probs[key(state0, obs0)]
                  prob = prob_prev * trans_p[state0][state] * emit_p[state][obs]
                  {max_prob, prev_state} = if prob > max_prob do
                    max_prob = prob
                    prev_state = state0
                    {max_prob, prev_state}
                  else
                    {max_prob, prev_state}
                  end
                  k = k + 1
                  while_fun_4.(while_fun_4, k, max_prob, prev_state)
                else
                  {k, max_prob, prev_state}
                end
              end
              {k, max_prob, prev_state} = try do
                  while_fun_4.(while_fun_4, k, max_prob, prev_state)
                catch
                  {:break, {k, max_prob, prev_state}} -> {k, max_prob, prev_state}
                end

              probs = Map.put(probs, key(state, obs), max_prob)
              ptrs = Map.put(ptrs, key(state, obs), prev_state)
              j = j + 1
              while_fun_3.(while_fun_3, j, probs, ptrs)
            else
              {j, probs, ptrs}
            end
          end
          {j, probs, ptrs} = try do
              while_fun_3.(while_fun_3, j, probs, ptrs)
            catch
              {:break, {j, probs, ptrs}} -> {j, probs, ptrs}
            end

          t = t + 1
          while_fun_2.(while_fun_2, probs, ptrs, t)
        else
          {probs, ptrs, t}
        end
      end
      {probs, ptrs, t} = try do
          while_fun_2.(while_fun_2, probs, ptrs, t)
        catch
          {:break, {probs, ptrs, t}} -> {probs, ptrs, t}
        end

      path = []
      n = 0
      while_fun_5 = fn while_fun_5, n, path ->
        if n < _len(observations) do
          path = (path ++ [""])
          n = n + 1
          while_fun_5.(while_fun_5, n, path)
        else
          {n, path}
        end
      end
      {n, path} = try do
          while_fun_5.(while_fun_5, n, path)
        catch
          {:break, {n, path}} -> {n, path}
        end

      last_obs = Enum.at(observations, _len(observations) - 1)
      max_final = -1.0
      last_state = ""
      m = 0
      while_fun_6 = fn while_fun_6, last_state, m, max_final ->
        if m < _len(states) do
          state = Enum.at(states, m)
          prob = probs[key(state, last_obs)]
          {last_state, max_final} = if prob > max_final do
            max_final = prob
            last_state = state
            {last_state, max_final}
          else
            {last_state, max_final}
          end
          m = m + 1
          while_fun_6.(while_fun_6, last_state, m, max_final)
        else
          {last_state, m, max_final}
        end
      end
      {last_state, m, max_final} = try do
          while_fun_6.(while_fun_6, last_state, m, max_final)
        catch
          {:break, {last_state, m, max_final}} -> {last_state, m, max_final}
        end

      last_index = _len(observations) - 1
      path = List.replace_at(path, last_index, last_state)
      idx = last_index
      while_fun_7 = fn while_fun_7, idx, path ->
        if idx > 0 do
          obs = Enum.at(observations, idx)
          prev = Map.get(ptrs, key(Enum.at(path, idx), obs), "")
          path = List.replace_at(path, idx - 1, prev)
          idx = idx - 1
          while_fun_7.(while_fun_7, idx, path)
        else
          {idx, path}
        end
      end
      {idx, path} = try do
          while_fun_7.(while_fun_7, idx, path)
        catch
          {:break, {idx, path}} -> {idx, path}
        end

      throw {:return, path}
    catch
      {:return, val} -> val
    end
  end
  def join_words(words) do
    try do
      res = ""
      i = 0
      while_fun_8 = fn while_fun_8, i, res ->
        if i < _len(words) do
          {res} = if i > 0 do
            res = (res <> " ")
            {res}
          else
            {res}
          end
          res = (res <> Enum.at(words, i))
          i = i + 1
          while_fun_8.(while_fun_8, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_8.(while_fun_8, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:observations, ["normal", "cold", "dizzy"])
  Process.put(:states, ["Healthy", "Fever"])
  Process.put(:start_p, %{"Healthy" => 0.6, "Fever" => 0.4})
  Process.put(:trans_p, %{"Healthy" => %{"Healthy" => 0.7, "Fever" => 0.3}, "Fever" => %{"Healthy" => 0.4, "Fever" => 0.6}})
  Process.put(:emit_p, %{"Healthy" => %{"normal" => 0.5, "cold" => 0.4, "dizzy" => 0.1}, "Fever" => %{"normal" => 0.1, "cold" => 0.3, "dizzy" => 0.6}})
  def main() do
    Process.put(:result, viterbi(Process.get(:observations), Process.get(:states), Process.get(:start_p), Process.get(:trans_p), Process.get(:emit_p)))
    IO.puts(Kernel.inspect(join_words(Process.get(:result))))
  end
end
Main.main()
