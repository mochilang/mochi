# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def find_min(numbers) do
    try do
      n = _len(numbers)
      s = 0
      idx = 0
      while_fun = fn while_fun, idx, s ->
        if idx < n do
          s = s + Enum.at(numbers, idx)
          idx = idx + 1
          while_fun.(while_fun, idx, s)
        else
          {idx, s}
        end
      end
      {idx, s} = try do
          while_fun.(while_fun, idx, s)
        catch
          {:break, {idx, s}} -> {idx, s}
        end

      dp = []
      i = 0
      while_fun_2 = fn while_fun_2, dp, i ->
        if i <= n do
          row = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row ->
            if j <= s do
              row = (row ++ [false])
              j = j + 1
              while_fun_3.(while_fun_3, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_3.(while_fun_3, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          dp = (dp ++ [row])
          i = i + 1
          while_fun_2.(while_fun_2, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_2.(while_fun_2, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      i = 0
      while_fun_4 = fn while_fun_4, dp, i ->
        if i <= n do
          dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), 0, true))
          i = i + 1
          while_fun_4.(while_fun_4, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_4.(while_fun_4, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      j = 1
      while_fun_5 = fn while_fun_5, dp, j ->
        if j <= s do
          dp = List.replace_at(dp, 0, List.replace_at(Enum.at(dp, 0), j, false))
          j = j + 1
          while_fun_5.(while_fun_5, dp, j)
        else
          {dp, j}
        end
      end
      {dp, j} = try do
          while_fun_5.(while_fun_5, dp, j)
        catch
          {:break, {dp, j}} -> {dp, j}
        end

      i = 1
      while_fun_6 = fn while_fun_6, dp, i, j ->
        if i <= n do
          j = 1
          while_fun_7 = fn while_fun_7, dp, j ->
            if j <= s do
              dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, Enum.at(Enum.at(dp, i - 1), j)))
              {dp} = if Enum.at(numbers, i - 1) <= j do
                {dp} = if Enum.at(Enum.at(dp, i - 1), j - Enum.at(numbers, i - 1)) do
                  dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, true))
                  {dp}
                else
                  {dp}
                end
                {dp}
              else
                {dp}
              end
              j = j + 1
              while_fun_7.(while_fun_7, dp, j)
            else
              {dp, j}
            end
          end
          {dp, j} = try do
              while_fun_7.(while_fun_7, dp, j)
            catch
              {:break, {dp, j}} -> {dp, j}
            end

          i = i + 1
          while_fun_6.(while_fun_6, dp, i, j)
        else
          {dp, i, j}
        end
      end
      {dp, i, j} = try do
          while_fun_6.(while_fun_6, dp, i, j)
        catch
          {:break, {dp, i, j}} -> {dp, i, j}
        end

      diff = 0
      j = div(s, 2)
      while_fun_8 = fn while_fun_8, diff, j ->
        if j >= 0 do
          {diff} = if Enum.at(Enum.at(dp, n), j) do
            diff = s - 2 * j
            throw {:break, {diff, j}}
            {diff}
          else
            {diff}
          end
          j = j - 1
          while_fun_8.(while_fun_8, diff, j)
        else
          {diff, j}
        end
      end
      {diff, j} = try do
          while_fun_8.(while_fun_8, diff, j)
        catch
          {:break, {diff, j}} -> {diff, j}
        end

      throw {:return, diff}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(find_min([1, 2, 3, 4, 5])))
    IO.puts(Kernel.inspect(find_min([5, 5, 5, 5, 5])))
    IO.puts(Kernel.inspect(find_min([5, 5, 5, 5])))
    IO.puts(Kernel.inspect(find_min([3])))
    IO.puts(Kernel.inspect(find_min([])))
    IO.puts(Kernel.inspect(find_min([1, 2, 3, 4])))
    IO.puts(Kernel.inspect(find_min([0, 0, 0, 0])))
    IO.puts(Kernel.inspect(find_min([-1, -5, 5, 1])))
    IO.puts(Kernel.inspect(find_min([9, 9, 9, 9, 9])))
    IO.puts(Kernel.inspect(find_min([1, 5, 10, 3])))
    IO.puts(Kernel.inspect(find_min([-1, 0, 1])))
    IO.puts(Kernel.inspect(find_min([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])))
  end
end
Main.main()
