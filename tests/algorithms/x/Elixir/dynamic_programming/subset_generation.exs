# Code generated by Mochi transpiler 2025-08-13 12:32 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def copy_list(src) do
    try do
      result = []
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < _len(src) do
          result = (result ++ [Enum.at(src, i, [])])
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def subset_combinations(elements, n) do
    try do
      r = _len(elements)
      if n > r do
        throw {:return, []}
      end
      dp = []
      i = 0
      while_fun_2 = fn while_fun_2, dp, i ->
        if i <= r do
          dp = (dp ++ [[]])
          i = i + 1
          while_fun_2.(while_fun_2, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_2.(while_fun_2, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      dp = List.replace_at(dp, 0, (Enum.at(dp, 0, []) ++ [[]]))
      i = 1
      while_fun_3 = fn while_fun_3, dp, i ->
        if i <= r do
          j = i
          while_fun_4 = fn while_fun_4, dp, j ->
            if j > 0 do
              prevs = Enum.at(dp, j - 1, [])
              k = 0
              while_fun_5 = fn while_fun_5, dp, k ->
                if k < _len(prevs) do
                  prev = Enum.at(prevs, k, [])
                  comb = copy_list(prev)
                  comb = (comb ++ [Enum.at(elements, i - 1, [])])
                  dp = List.replace_at(dp, j, (Enum.at(dp, j, []) ++ [comb]))
                  k = k + 1
                  while_fun_5.(while_fun_5, dp, k)
                else
                  {dp, k}
                end
              end
              {dp, k} = try do
                  while_fun_5.(while_fun_5, dp, k)
                catch
                  {:break, {dp, k}} -> {dp, k}
                end

              j = j - 1
              while_fun_4.(while_fun_4, dp, j)
            else
              {dp, j}
            end
          end
          {dp, j} = try do
              while_fun_4.(while_fun_4, dp, j)
            catch
              {:break, {dp, j}} -> {dp, j}
            end

          i = i + 1
          while_fun_3.(while_fun_3, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_3.(while_fun_3, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      throw {:return, Enum.at(dp, n, [])}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(subset_combinations([10, 20, 30, 40], 2)))
  end
end
Main.main()
