# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_2d(n) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < n do
              row = (row ++ [0])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matrix_chain_order(arr) do
    try do
      n = _len(arr)
      m = make_2d(n)
      s = make_2d(n)
      chain_length = 2
      while_fun_3 = fn while_fun_3, chain_length, m, s ->
        if chain_length < n do
          a = 1
          while_fun_4 = fn while_fun_4, a, m, s ->
            if a < n - chain_length + 1 do
              b = a + chain_length - 1
              m = List.replace_at(m, a, List.replace_at(Enum.at(m, a), b, 1000000000))
              c = a
              while_fun_5 = fn while_fun_5, c, m, s ->
                if c < b do
                  cost = Enum.at(Enum.at(m, a), c) + Enum.at(Enum.at(m, c + 1), b) + Enum.at(arr, a - 1) * Enum.at(arr, c) * Enum.at(arr, b)
                  {m, s} = if cost < Enum.at(Enum.at(m, a), b) do
                    m = List.replace_at(m, a, List.replace_at(Enum.at(m, a), b, cost))
                    s = List.replace_at(s, a, List.replace_at(Enum.at(s, a), b, c))
                    {m, s}
                  else
                    {m, s}
                  end
                  c = c + 1
                  while_fun_5.(while_fun_5, c, m, s)
                else
                  {c, m, s}
                end
              end
              {c, m, s} = try do
                  while_fun_5.(while_fun_5, c, m, s)
                catch
                  {:break, {c, m, s}} -> {c, m, s}
                end

              a = a + 1
              while_fun_4.(while_fun_4, a, m, s)
            else
              {a, m, s}
            end
          end
          {a, m, s} = try do
              while_fun_4.(while_fun_4, a, m, s)
            catch
              {:break, {a, m, s}} -> {a, m, s}
            end

          chain_length = chain_length + 1
          while_fun_3.(while_fun_3, chain_length, m, s)
        else
          {chain_length, m, s}
        end
      end
      {chain_length, m, s} = try do
          while_fun_3.(while_fun_3, chain_length, m, s)
        catch
          {:break, {chain_length, m, s}} -> {chain_length, m, s}
        end

      throw {:return, %{matrix: m, solution: s}}
    catch
      {:return, val} -> val
    end
  end
  def optimal_parenthesization(s, i, j) do
    try do
      if i == j do
        throw {:return, ("A" <> Kernel.to_string(i))}
      else
        left = optimal_parenthesization(s, i, Enum.at(Enum.at(s, i), j))
        right = optimal_parenthesization(s, Enum.at(Enum.at(s, i), j) + 1, j)
        throw {:return, (((("( " <> left) <> " ") <> right) <> " )")}
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      arr = [30, 35, 15, 5, 10, 20, 25]
      n = _len(arr)
      res = matrix_chain_order(arr)
      m = res.matrix
      s = res.solution
      IO.puts(("No. of Operation required: " <> Kernel.to_string(Enum.at(Enum.at(m, 1), n - 1))))
      seq = optimal_parenthesization(s, 1, n - 1)
      IO.puts(seq)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
