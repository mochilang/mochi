# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def distance_sq(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun = fn while_fun, i, sum ->
        if i < _len(a) do
          diff = Enum.at(a, i) - Enum.at(b, i)
          sum = sum + diff * diff
          i = i + 1
          while_fun.(while_fun, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun.(while_fun, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def mean(vectors) do
    try do
      dim = _len(Enum.at(vectors, 0))
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < dim do
          total = 0.0
          j = 0
          while_fun_3 = fn while_fun_3, j, total ->
            if j < _len(vectors) do
              total = total + Enum.at(Enum.at(vectors, j), i)
              j = j + 1
              while_fun_3.(while_fun_3, j, total)
            else
              {j, total}
            end
          end
          {j, total} = try do
              while_fun_3.(while_fun_3, j, total)
            catch
              {:break, {j, total}} -> {j, total}
            end

          res = (res ++ [total / _len(vectors)])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def k_means(vectors, k, iterations) do
    try do
      centroids = []
      i = 0
      while_fun_4 = fn while_fun_4, centroids, i ->
        if i < k do
          centroids = (centroids ++ [Enum.at(vectors, i)])
          i = i + 1
          while_fun_4.(while_fun_4, centroids, i)
        else
          {centroids, i}
        end
      end
      {centroids, i} = try do
          while_fun_4.(while_fun_4, centroids, i)
        catch
          {:break, {centroids, i}} -> {centroids, i}
        end

      assignments = []
      n = _len(vectors)
      i = 0
      while_fun_5 = fn while_fun_5, assignments, i ->
        if i < n do
          assignments = (assignments ++ [0])
          i = i + 1
          while_fun_5.(while_fun_5, assignments, i)
        else
          {assignments, i}
        end
      end
      {assignments, i} = try do
          while_fun_5.(while_fun_5, assignments, i)
        catch
          {:break, {assignments, i}} -> {assignments, i}
        end

      it = 0
      while_fun_6 = fn while_fun_6, assignments, centroids, it ->
        if it < iterations do
          v = 0
          while_fun_7 = fn while_fun_7, assignments, v ->
            if v < n do
              best = 0
              bestDist = distance_sq(Enum.at(vectors, v), Enum.at(centroids, 0))
              c = 1
              while_fun_8 = fn while_fun_8, best, bestDist, c ->
                if c < k do
                  d = distance_sq(Enum.at(vectors, v), Enum.at(centroids, c))
                  {best, bestDist} = if d < bestDist do
                    bestDist = d
                    best = c
                    {best, bestDist}
                  else
                    {best, bestDist}
                  end
                  c = c + 1
                  while_fun_8.(while_fun_8, best, bestDist, c)
                else
                  {best, bestDist, c}
                end
              end
              {best, bestDist, c} = try do
                  while_fun_8.(while_fun_8, best, bestDist, c)
                catch
                  {:break, {best, bestDist, c}} -> {best, bestDist, c}
                end

              assignments = List.replace_at(assignments, v, best)
              v = v + 1
              while_fun_7.(while_fun_7, assignments, v)
            else
              {assignments, v}
            end
          end
          {assignments, v} = try do
              while_fun_7.(while_fun_7, assignments, v)
            catch
              {:break, {assignments, v}} -> {assignments, v}
            end

          cIdx = 0
          while_fun_9 = fn while_fun_9, cIdx, centroids ->
            if cIdx < k do
              cluster = []
              v2 = 0
              while_fun_10 = fn while_fun_10, cluster, v2 ->
                if v2 < n do
                  {cluster} = if Enum.at(assignments, v2) == cIdx do
                    cluster = (cluster ++ [Enum.at(vectors, v2)])
                    {cluster}
                  else
                    {cluster}
                  end
                  v2 = v2 + 1
                  while_fun_10.(while_fun_10, cluster, v2)
                else
                  {cluster, v2}
                end
              end
              {cluster, v2} = try do
                  while_fun_10.(while_fun_10, cluster, v2)
                catch
                  {:break, {cluster, v2}} -> {cluster, v2}
                end

              {centroids} = if _len(cluster) > 0 do
                centroids = List.replace_at(centroids, cIdx, mean(cluster))
                {centroids}
              else
                {centroids}
              end
              cIdx = cIdx + 1
              while_fun_9.(while_fun_9, cIdx, centroids)
            else
              {cIdx, centroids}
            end
          end
          {cIdx, centroids} = try do
              while_fun_9.(while_fun_9, cIdx, centroids)
            catch
              {:break, {cIdx, centroids}} -> {cIdx, centroids}
            end

          it = it + 1
          while_fun_6.(while_fun_6, assignments, centroids, it)
        else
          {assignments, centroids, it}
        end
      end
      {assignments, centroids, it} = try do
          while_fun_6.(while_fun_6, assignments, centroids, it)
        catch
          {:break, {assignments, centroids, it}} -> {assignments, centroids, it}
        end

      throw {:return, %{centroids: centroids, assignments: assignments}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      vectors = [[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]]
      result = k_means(vectors, 2, 5)
      IO.puts(Kernel.to_string(result.centroids))
      IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [result.assignments])), ",", " "))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
