# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def zeros_matrix(rows, cols) do
    try do
      matrix = []
      i = 0
      while_fun = fn while_fun, i, matrix ->
        if i <= rows do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j <= cols do
              row = (row ++ [0])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          matrix = (matrix ++ [row])
          i = i + 1
          while_fun.(while_fun, i, matrix)
        else
          {i, matrix}
        end
      end
      {i, matrix} = try do
          while_fun.(while_fun, i, matrix)
        catch
          {:break, {i, matrix}} -> {i, matrix}
        end

      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def longest_common_subsequence(x, y) do
    try do
      m = _len(x)
      n = _len(y)
      dp = zeros_matrix(m, n)
      i = 1
      while_fun_3 = fn while_fun_3, dp, i ->
        if i <= m do
          j = 1
          while_fun_4 = fn while_fun_4, dp, j ->
            if j <= n do
              {dp} = if String.at(x, i - 1) == String.at(y, j - 1) do
                dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, Enum.at(Enum.at(dp, i - 1), j - 1) + 1))
                {dp}
              else
                {dp} = if Enum.at(Enum.at(dp, i - 1), j) > Enum.at(Enum.at(dp, i), j - 1) do
                  dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, Enum.at(Enum.at(dp, i - 1), j)))
                  {dp}
                else
                  dp = List.replace_at(dp, i, List.replace_at(Enum.at(dp, i), j, Enum.at(Enum.at(dp, i), j - 1)))
                  {dp}
                end
                {dp}
              end
              j = j + 1
              while_fun_4.(while_fun_4, dp, j)
            else
              {dp, j}
            end
          end
          {dp, j} = try do
              while_fun_4.(while_fun_4, dp, j)
            catch
              {:break, {dp, j}} -> {dp, j}
            end

          i = i + 1
          while_fun_3.(while_fun_3, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_3.(while_fun_3, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      seq = ""
      i2 = m
      j2 = n
      while_fun_5 = fn while_fun_5, i2, j2, seq ->
        if i2 > 0 && j2 > 0 do
          {i2, j2, seq} = if String.at(x, i2 - 1) == String.at(y, j2 - 1) do
            seq = (String.at(x, i2 - 1) <> seq)
            i2 = i2 - 1
            j2 = j2 - 1
            {i2, j2, seq}
          else
            {i2, j2} = if Enum.at(Enum.at(dp, i2 - 1), j2) >= Enum.at(Enum.at(dp, i2), j2 - 1) do
              i2 = i2 - 1
              {i2, j2}
            else
              j2 = j2 - 1
              {i2, j2}
            end
            {i2, j2, seq}
          end
          while_fun_5.(while_fun_5, i2, j2, seq)
        else
          {i2, j2, seq}
        end
      end
      {i2, j2, seq} = try do
          while_fun_5.(while_fun_5, i2, j2, seq)
        catch
          {:break, {i2, j2, seq}} -> {i2, j2, seq}
        end

      throw {:return, %{length: Enum.at(Enum.at(dp, m), n), sequence: seq}}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:a, "AGGTAB")
  Process.put(:b, "GXTXAYB")
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:res, longest_common_subsequence(Process.get(:a), Process.get(:b)))
    IO.puts(((("len = " <> Kernel.to_string(Process.get(:res).length)) <> ", sub-sequence = ") <> Process.get(:res).sequence))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
