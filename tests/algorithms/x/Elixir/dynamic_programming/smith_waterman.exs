# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def score_function(source_char, target_char, match_score, mismatch_score, gap_score) do
    try do
      if source_char == "-" || target_char == "-" do
        throw {:return, gap_score}
      end
      if source_char == target_char do
        throw {:return, match_score}
      end
      throw {:return, mismatch_score}
    catch
      {:return, val} -> val
    end
  end
  def smith_waterman(query, subject, match_score, mismatch_score, gap_score) do
    try do
      q = String.upcase(query)
      s = String.upcase(subject)
      m = _len(q)
      n = _len(s)
      score = []
      Enum.each((0..((m + 1) - 1)), fn _ ->
        row = []
        {row} = Enum.reduce((0..((n + 1) - 1)//1), {row}, fn _2, {row} ->
          row = (row ++ [0])
          {row}
        end)
        score = (score ++ [row])
      end)
      Enum.each((1..((m + 1) - 1)), fn i ->
        Enum.each((1..((n + 1) - 1)), fn j ->
          qc = _slice(q, i - 1, i - (i - 1))
          sc = _slice(s, j - 1, j - (j - 1))
          diag = Enum.at(Enum.at(score, i - 1), j - 1) + score_function(qc, sc, match_score, mismatch_score, gap_score)
          delete = Enum.at(Enum.at(score, i - 1), j) + gap_score
          insert = Enum.at(Enum.at(score, i), j - 1) + gap_score
          max_val = 0
          {max_val} = if diag > max_val do
            max_val = diag
            {max_val}
          else
            {max_val}
          end
          {max_val} = if delete > max_val do
            max_val = delete
            {max_val}
          else
            {max_val}
          end
          {max_val} = if insert > max_val do
            max_val = insert
            {max_val}
          else
            {max_val}
          end
          score = List.replace_at(score, i, List.replace_at(Enum.at(score, i), j, max_val))
        end)
      end)
      throw {:return, score}
    catch
      {:return, val} -> val
    end
  end
  def traceback(score, query, subject, match_score, mismatch_score, gap_score) do
    try do
      q = String.upcase(query)
      s = String.upcase(subject)
      max_value = 0
      i_max = 0
      j_max = 0
      {i_max, j_max, max_value} = Enum.reduce((0..(_len(score) - 1)//1), {i_max, j_max, max_value}, fn i, {i_max, j_max, max_value} ->
        {i_max, j_max, max_value} = Enum.reduce((0..(_len(Enum.at(score, i)) - 1)//1), {i_max, j_max, max_value}, fn j, {i_max, j_max, max_value} ->
          {i_max, j_max, max_value} = if Enum.at(Enum.at(score, i), j) > max_value do
            max_value = Enum.at(Enum.at(score, i), j)
            i_max = i
            j_max = j
            {i_max, j_max, max_value}
          else
            {i_max, j_max, max_value}
          end
          {i_max, j_max, max_value}
        end)
        {i_max, j_max, max_value}
      end)
      i = i_max
      j = j_max
      align1 = ""
      align2 = ""
      gap_penalty = score_function("-", "-", match_score, mismatch_score, gap_score)
      if i == 0 || j == 0 do
        throw {:return, ""}
      end
      while_fun = fn while_fun, align1, align2, i, j ->
        if i > 0 && j > 0 do
          qc = _slice(q, i - 1, i - (i - 1))
          sc = _slice(s, j - 1, j - (j - 1))
          {align1, align2, i, j} = if Enum.at(Enum.at(score, i), j) == Enum.at(Enum.at(score, i - 1), j - 1) + score_function(qc, sc, match_score, mismatch_score, gap_score) do
            align1 = (qc <> align1)
            align2 = (sc <> align2)
            i = i - 1
            j = j - 1
            {align1, align2, i, j}
          else
            {align1, align2, i, j} = if Enum.at(Enum.at(score, i), j) == Enum.at(Enum.at(score, i - 1), j) + gap_penalty do
              align1 = (qc <> align1)
              align2 = ("-" <> align2)
              i = i - 1
              {align1, align2, i, j}
            else
              align1 = ("-" <> align1)
              align2 = (sc <> align2)
              j = j - 1
              {align1, align2, i, j}
            end
            {align1, align2, i, j}
          end
          while_fun.(while_fun, align1, align2, i, j)
        else
          {align1, align2, i, j}
        end
      end
      {align1, align2, i, j} = try do
          while_fun.(while_fun, align1, align2, i, j)
        catch
          {:break, {align1, align2, i, j}} -> {align1, align2, i, j}
        end

      throw {:return, ((align1 <> "\n") <> align2)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:query, "HEAGAWGHEE")
  Process.put(:subject, "PAWHEAE")
  def main() do
    Process.put(:score, smith_waterman(Process.get(:query), Process.get(:subject), 1, -1, -2))
    IO.puts(Kernel.inspect(traceback(Process.get(:score), Process.get(:query), Process.get(:subject), 1, -1, -2)))
  end
end
Main.main()
