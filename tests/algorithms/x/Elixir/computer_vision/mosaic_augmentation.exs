# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale) do
    try do
      height = Enum.at(output_size, 0)
      width = Enum.at(output_size, 1)
      output_img = nil
      r = 0
      while_fun = fn while_fun, output_img, r ->
        if r < height do
          row = nil
          c = 0
          while_fun_2 = fn while_fun_2, c, row ->
            if c < width do
              row = (row ++ [0])
              c = c + 1
              while_fun_2.(while_fun_2, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_2.(while_fun_2, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          output_img = (output_img ++ [row])
          r = r + 1
          while_fun.(while_fun, output_img, r)
        else
          {output_img, r}
        end
      end
      {output_img, r} = try do
          while_fun.(while_fun, output_img, r)
        catch
          {:break, {output_img, r}} -> {output_img, r}
        end

      scale_x = (Enum.at(scale_range, 0) + Enum.at(scale_range, 1)) / 2.0
      scale_y = (Enum.at(scale_range, 0) + Enum.at(scale_range, 1)) / 2.0
      divid_point_x = ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((scale_x * (:erlang.float(width)))))
      divid_point_y = ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((scale_y * (:erlang.float(height)))))
      new_anno = nil
      path_list = nil
      i = 0
      while_fun_3 = fn while_fun_3, i, new_anno, output_img, path_list ->
        if i < _len(idxs) do
          index = Enum.at(idxs, i)
          path = Enum.at(all_img_list, index)
          path_list = (path_list ++ [path])
          img_annos = Enum.at(all_annos, index)
          {new_anno, output_img} = if i == 0 do
            y0 = 0
            while_fun_4 = fn while_fun_4, output_img, y0 ->
              if y0 < divid_point_y do
                x0 = 0
                while_fun_5 = fn while_fun_5, output_img, x0 ->
                  if x0 < divid_point_x do
                    output_img = List.replace_at(output_img, y0, List.replace_at(Enum.at(output_img, y0), x0, i + 1))
                    x0 = x0 + 1
                    while_fun_5.(while_fun_5, output_img, x0)
                  else
                    {output_img, x0}
                  end
                end
                {output_img, x0} = try do
                    while_fun_5.(while_fun_5, output_img, x0)
                  catch
                    {:break, {output_img, x0}} -> {output_img, x0}
                  end

                y0 = y0 + 1
                while_fun_4.(while_fun_4, output_img, y0)
              else
                {output_img, y0}
              end
            end
            {output_img, y0} = try do
                while_fun_4.(while_fun_4, output_img, y0)
              catch
                {:break, {output_img, y0}} -> {output_img, y0}
              end

            j0 = 0
            while_fun_6 = fn while_fun_6, j0, new_anno ->
              if j0 < _len(img_annos) do
                bbox = Enum.at(img_annos, j0)
                xmin = Enum.at(bbox, 1) * scale_x
                ymin = Enum.at(bbox, 2) * scale_y
                xmax = Enum.at(bbox, 3) * scale_x
                ymax = Enum.at(bbox, 4) * scale_y
                new_anno = (new_anno ++ [[Enum.at(bbox, 0), xmin, ymin, xmax, ymax]])
                j0 = j0 + 1
                while_fun_6.(while_fun_6, j0, new_anno)
              else
                {j0, new_anno}
              end
            end
            {j0, new_anno} = try do
                while_fun_6.(while_fun_6, j0, new_anno)
              catch
                {:break, {j0, new_anno}} -> {j0, new_anno}
              end

            {new_anno, output_img}
          else
            {new_anno, output_img} = if i == 1 do
              y1 = 0
              while_fun_7 = fn while_fun_7, output_img, y1 ->
                if y1 < divid_point_y do
                  x1 = divid_point_x
                  while_fun_8 = fn while_fun_8, output_img, x1 ->
                    if x1 < width do
                      output_img = List.replace_at(output_img, y1, List.replace_at(Enum.at(output_img, y1), x1, i + 1))
                      x1 = x1 + 1
                      while_fun_8.(while_fun_8, output_img, x1)
                    else
                      {output_img, x1}
                    end
                  end
                  {output_img, x1} = try do
                      while_fun_8.(while_fun_8, output_img, x1)
                    catch
                      {:break, {output_img, x1}} -> {output_img, x1}
                    end

                  y1 = y1 + 1
                  while_fun_7.(while_fun_7, output_img, y1)
                else
                  {output_img, y1}
                end
              end
              {output_img, y1} = try do
                  while_fun_7.(while_fun_7, output_img, y1)
                catch
                  {:break, {output_img, y1}} -> {output_img, y1}
                end

              j1 = 0
              while_fun_9 = fn while_fun_9, j1, new_anno ->
                if j1 < _len(img_annos) do
                  bbox1 = Enum.at(img_annos, j1)
                  xmin1 = scale_x + Enum.at(bbox1, 1) * (1.0 - scale_x)
                  ymin1 = Enum.at(bbox1, 2) * scale_y
                  xmax1 = scale_x + Enum.at(bbox1, 3) * (1.0 - scale_x)
                  ymax1 = Enum.at(bbox1, 4) * scale_y
                  new_anno = (new_anno ++ [[Enum.at(bbox1, 0), xmin1, ymin1, xmax1, ymax1]])
                  j1 = j1 + 1
                  while_fun_9.(while_fun_9, j1, new_anno)
                else
                  {j1, new_anno}
                end
              end
              {j1, new_anno} = try do
                  while_fun_9.(while_fun_9, j1, new_anno)
                catch
                  {:break, {j1, new_anno}} -> {j1, new_anno}
                end

              {new_anno, output_img}
            else
              {new_anno, output_img} = if i == 2 do
                y2 = divid_point_y
                while_fun_10 = fn while_fun_10, output_img, y2 ->
                  if y2 < height do
                    x2 = 0
                    while_fun_11 = fn while_fun_11, output_img, x2 ->
                      if x2 < divid_point_x do
                        output_img = List.replace_at(output_img, y2, List.replace_at(Enum.at(output_img, y2), x2, i + 1))
                        x2 = x2 + 1
                        while_fun_11.(while_fun_11, output_img, x2)
                      else
                        {output_img, x2}
                      end
                    end
                    {output_img, x2} = try do
                        while_fun_11.(while_fun_11, output_img, x2)
                      catch
                        {:break, {output_img, x2}} -> {output_img, x2}
                      end

                    y2 = y2 + 1
                    while_fun_10.(while_fun_10, output_img, y2)
                  else
                    {output_img, y2}
                  end
                end
                {output_img, y2} = try do
                    while_fun_10.(while_fun_10, output_img, y2)
                  catch
                    {:break, {output_img, y2}} -> {output_img, y2}
                  end

                j2 = 0
                while_fun_12 = fn while_fun_12, j2, new_anno ->
                  if j2 < _len(img_annos) do
                    bbox2 = Enum.at(img_annos, j2)
                    xmin2 = Enum.at(bbox2, 1) * scale_x
                    ymin2 = scale_y + Enum.at(bbox2, 2) * (1.0 - scale_y)
                    xmax2 = Enum.at(bbox2, 3) * scale_x
                    ymax2 = scale_y + Enum.at(bbox2, 4) * (1.0 - scale_y)
                    new_anno = (new_anno ++ [[Enum.at(bbox2, 0), xmin2, ymin2, xmax2, ymax2]])
                    j2 = j2 + 1
                    while_fun_12.(while_fun_12, j2, new_anno)
                  else
                    {j2, new_anno}
                  end
                end
                {j2, new_anno} = try do
                    while_fun_12.(while_fun_12, j2, new_anno)
                  catch
                    {:break, {j2, new_anno}} -> {j2, new_anno}
                  end

                {new_anno, output_img}
              else
                y3 = divid_point_y
                while_fun_13 = fn while_fun_13, output_img, y3 ->
                  if y3 < height do
                    x3 = divid_point_x
                    while_fun_14 = fn while_fun_14, output_img, x3 ->
                      if x3 < width do
                        output_img = List.replace_at(output_img, y3, List.replace_at(Enum.at(output_img, y3), x3, i + 1))
                        x3 = x3 + 1
                        while_fun_14.(while_fun_14, output_img, x3)
                      else
                        {output_img, x3}
                      end
                    end
                    {output_img, x3} = try do
                        while_fun_14.(while_fun_14, output_img, x3)
                      catch
                        {:break, {output_img, x3}} -> {output_img, x3}
                      end

                    y3 = y3 + 1
                    while_fun_13.(while_fun_13, output_img, y3)
                  else
                    {output_img, y3}
                  end
                end
                {output_img, y3} = try do
                    while_fun_13.(while_fun_13, output_img, y3)
                  catch
                    {:break, {output_img, y3}} -> {output_img, y3}
                  end

                j3 = 0
                while_fun_15 = fn while_fun_15, j3, new_anno ->
                  if j3 < _len(img_annos) do
                    bbox3 = Enum.at(img_annos, j3)
                    xmin3 = scale_x + Enum.at(bbox3, 1) * (1.0 - scale_x)
                    ymin3 = scale_y + Enum.at(bbox3, 2) * (1.0 - scale_y)
                    xmax3 = scale_x + Enum.at(bbox3, 3) * (1.0 - scale_x)
                    ymax3 = scale_y + Enum.at(bbox3, 4) * (1.0 - scale_y)
                    new_anno = (new_anno ++ [[Enum.at(bbox3, 0), xmin3, ymin3, xmax3, ymax3]])
                    j3 = j3 + 1
                    while_fun_15.(while_fun_15, j3, new_anno)
                  else
                    {j3, new_anno}
                  end
                end
                {j3, new_anno} = try do
                    while_fun_15.(while_fun_15, j3, new_anno)
                  catch
                    {:break, {j3, new_anno}} -> {j3, new_anno}
                  end

                {new_anno, output_img}
              end
              {new_anno, output_img}
            end
            {new_anno, output_img}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, new_anno, output_img, path_list)
        else
          {i, new_anno, output_img, path_list}
        end
      end
      {i, new_anno, output_img, path_list} = try do
          while_fun_3.(while_fun_3, i, new_anno, output_img, path_list)
        catch
          {:break, {i, new_anno, output_img, path_list}} -> {i, new_anno, output_img, path_list}
        end

      {new_anno} = if filter_scale > 0.0 do
        filtered = nil
        k = 0
        while_fun_16 = fn while_fun_16, filtered, k ->
          if k < _len(new_anno) do
            anno = Enum.at(new_anno, k)
            w = Enum.at(anno, 3) - Enum.at(anno, 1)
            h = Enum.at(anno, 4) - Enum.at(anno, 2)
            {filtered} = if filter_scale < w && filter_scale < h do
              filtered = (filtered ++ [anno])
              {filtered}
            else
              {filtered}
            end
            k = k + 1
            while_fun_16.(while_fun_16, filtered, k)
          else
            {filtered, k}
          end
        end
        {filtered, k} = try do
            while_fun_16.(while_fun_16, filtered, k)
          catch
            {:break, {filtered, k}} -> {filtered, k}
          end

        new_anno = filtered
        {new_anno}
      else
        {new_anno}
      end
      throw {:return, %{img: output_img, annos: new_anno, path: Enum.at(path_list, 0)}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      all_img_list = ["img0.jpg", "img1.jpg", "img2.jpg", "img3.jpg"]
      all_annos = [[[0.0, 0.1, 0.1, 0.4, 0.4]], [[1.0, 0.2, 0.3, 0.5, 0.7]], [[2.0, 0.6, 0.2, 0.9, 0.5]], [[3.0, 0.5, 0.5, 0.8, 0.8]]]
      idxs = [0, 1, 2, 3]
      output_size = [100, 100]
      scale_range = [0.4, 0.6]
      filter_scale = 0.05
      res = update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale)
      new_annos = res.annos
      path = res.path
      IO.puts(("Base image: " <> path))
      IO.puts(("Mosaic annotation count: " <> Kernel.inspect(_len(new_annos))))
      i = 0
      while_fun_17 = fn while_fun_17, i ->
        if i < _len(new_annos) do
          a = Enum.at(new_annos, i)
          IO.puts(((((((((Kernel.to_string(Enum.at(a, 0)) <> " ") <> Kernel.to_string(Enum.at(a, 1))) <> " ") <> Kernel.to_string(Enum.at(a, 2))) <> " ") <> Kernel.to_string(Enum.at(a, 3))) <> " ") <> Kernel.to_string(Enum.at(a, 4))))
          i = i + 1
          while_fun_17.(while_fun_17, i)
        else
          i
        end
      end
      i = try do
          while_fun_17.(while_fun_17, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
end
Main.main()
