# Code generated by Mochi transpiler 2025-08-06 22:25 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def zeros(h, w) do
    try do
      m = []
      y = 0
      while_fun = fn while_fun, m, y ->
        if y < h do
          row = []
          x = 0
          while_fun_2 = fn while_fun_2, row, x ->
            if x < w do
              row = (row ++ [0.0])
              x = x + 1
              while_fun_2.(while_fun_2, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_2.(while_fun_2, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          m = (m ++ [row])
          y = y + 1
          while_fun.(while_fun, m, y)
        else
          {m, y}
        end
      end
      {m, y} = try do
          while_fun.(while_fun, m, y)
        catch
          {:break, {m, y}} -> {m, y}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def gradient(img) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      dx = zeros(h, w)
      dy = zeros(h, w)
      y = 1
      while_fun_3 = fn while_fun_3, dx, dy, y ->
        if y < h - 1 do
          x = 1
          while_fun_4 = fn while_fun_4, dx, dy, x ->
            if x < w - 1 do
              dx = List.replace_at(dx, y, List.replace_at(Enum.at(dx, y), x, (:erlang.float(Enum.at(Enum.at(img, y), x + 1))) - (:erlang.float(Enum.at(Enum.at(img, y), x - 1)))))
              dy = List.replace_at(dy, y, List.replace_at(Enum.at(dy, y), x, (:erlang.float(Enum.at(Enum.at(img, y + 1), x))) - (:erlang.float(Enum.at(Enum.at(img, y - 1), x)))))
              x = x + 1
              while_fun_4.(while_fun_4, dx, dy, x)
            else
              {dx, dy, x}
            end
          end
          {dx, dy, x} = try do
              while_fun_4.(while_fun_4, dx, dy, x)
            catch
              {:break, {dx, dy, x}} -> {dx, dy, x}
            end

          y = y + 1
          while_fun_3.(while_fun_3, dx, dy, y)
        else
          {dx, dy, y}
        end
      end
      {dx, dy, y} = try do
          while_fun_3.(while_fun_3, dx, dy, y)
        catch
          {:break, {dx, dy, y}} -> {dx, dy, y}
        end

      throw {:return, [dx, dy]}
    catch
      {:return, val} -> val
    end
  end
  def harris(img, k, window, thresh) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      grads = gradient(img)
      dx = Enum.at(grads, 0)
      dy = Enum.at(grads, 1)
      ixx = zeros(h, w)
      iyy = zeros(h, w)
      ixy = zeros(h, w)
      y = 0
      while_fun_5 = fn while_fun_5, ixx, ixy, iyy, y ->
        if y < h do
          x = 0
          while_fun_6 = fn while_fun_6, ixx, ixy, iyy, x ->
            if x < w do
              gx = Enum.at(Enum.at(dx, y), x)
              gy = Enum.at(Enum.at(dy, y), x)
              ixx = List.replace_at(ixx, y, List.replace_at(Enum.at(ixx, y), x, gx * gx))
              iyy = List.replace_at(iyy, y, List.replace_at(Enum.at(iyy, y), x, gy * gy))
              ixy = List.replace_at(ixy, y, List.replace_at(Enum.at(ixy, y), x, gx * gy))
              x = x + 1
              while_fun_6.(while_fun_6, ixx, ixy, iyy, x)
            else
              {ixx, ixy, iyy, x}
            end
          end
          {ixx, ixy, iyy, x} = try do
              while_fun_6.(while_fun_6, ixx, ixy, iyy, x)
            catch
              {:break, {ixx, ixy, iyy, x}} -> {ixx, ixy, iyy, x}
            end

          y = y + 1
          while_fun_5.(while_fun_5, ixx, ixy, iyy, y)
        else
          {ixx, ixy, iyy, y}
        end
      end
      {ixx, ixy, iyy, y} = try do
          while_fun_5.(while_fun_5, ixx, ixy, iyy, y)
        catch
          {:break, {ixx, ixy, iyy, y}} -> {ixx, ixy, iyy, y}
        end

      offset = div(window, 2)
      corners = []
      y = offset
      while_fun_7 = fn while_fun_7, y ->
        if y < h - offset do
          x = offset
          while_fun_8 = fn while_fun_8, x ->
            if x < w - offset do
              wxx = 0.0
              wyy = 0.0
              wxy = 0.0
              yy = y - offset
              while_fun_9 = fn while_fun_9, wxx, wxy, wyy, yy ->
                if yy <= y + offset do
                  xx = x - offset
                  while_fun_10 = fn while_fun_10, wxx, wxy, wyy, xx ->
                    if xx <= x + offset do
                      wxx = wxx + Enum.at(Enum.at(ixx, yy), xx)
                      wyy = wyy + Enum.at(Enum.at(iyy, yy), xx)
                      wxy = wxy + Enum.at(Enum.at(ixy, yy), xx)
                      xx = xx + 1
                      while_fun_10.(while_fun_10, wxx, wxy, wyy, xx)
                    else
                      {wxx, wxy, wyy, xx}
                    end
                  end
                  {wxx, wxy, wyy, xx} = try do
                      while_fun_10.(while_fun_10, wxx, wxy, wyy, xx)
                    catch
                      {:break, {wxx, wxy, wyy, xx}} -> {wxx, wxy, wyy, xx}
                    end

                  yy = yy + 1
                  while_fun_9.(while_fun_9, wxx, wxy, wyy, yy)
                else
                  {wxx, wxy, wyy, yy}
                end
              end
              {wxx, wxy, wyy, yy} = try do
                  while_fun_9.(while_fun_9, wxx, wxy, wyy, yy)
                catch
                  {:break, {wxx, wxy, wyy, yy}} -> {wxx, wxy, wyy, yy}
                end

              det = wxx * wyy - (wxy * wxy)
              trace = wxx + wyy
              r = det - k * (trace * trace)
              if r > thresh do
                corners = (corners ++ [[x, y]])
              end
              x = x + 1
              while_fun_8.(while_fun_8, x)
            else
              x
            end
          end
          x = try do
              while_fun_8.(while_fun_8, x)
            catch
              {:break, {x}} -> x
            end

          y = y + 1
          while_fun_7.(while_fun_7, y)
        else
          y
        end
      end
      y = try do
          while_fun_7.(while_fun_7, y)
        catch
          {:break, {y}} -> y
        end

      throw {:return, corners}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:img, [[1, 1, 1, 1, 1], [1, 255, 255, 255, 1], [1, 255, 0, 255, 1], [1, 255, 255, 255, 1], [1, 1, 1, 1, 1]])
  def main() do
    Process.put(:corners, harris(Process.get(:img), 0.04, 3, 10000000000.0))
    IO.puts(Kernel.inspect(Process.get(:corners)))
  end
end
Main.main()
