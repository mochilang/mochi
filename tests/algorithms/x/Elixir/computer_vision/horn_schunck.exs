# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def round_int(x) do
    try do
      throw {:return, ((if x >= 0.0, do: Kernel.trunc(x + 0.5), else: Kernel.trunc(x - 0.5)))}
    catch
      {:return, val} -> val
    end
  end
  def zeros(rows, cols) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < rows do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < cols do
              row = (row ++ [0.0])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def warp(image, h_flow, v_flow) do
    try do
      h = _len(image)
      w = _len(Enum.at(image, 0))
      out = []
      y = 0
      while_fun_3 = fn while_fun_3, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_4 = fn while_fun_4, row, x ->
            if x < w do
              sx = x - round_int(Enum.at(Enum.at(h_flow, y), x))
              sy = y - round_int(Enum.at(Enum.at(v_flow, y), x))
              row = (if sx >= 0 && sx < w && sy >= 0 && sy < h, do: (row ++ [Enum.at(Enum.at(image, sy), sx)]), else: (row ++ [0.0]))
              x = x + 1
              while_fun_4.(while_fun_4, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_4.(while_fun_4, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_3.(while_fun_3, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_3.(while_fun_3, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def convolve(img, ker) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      kh = _len(ker)
      kw = _len(Enum.at(ker, 0))
      py = div(kh, 2)
      px = div(kw, 2)
      out = []
      y = 0
      while_fun_5 = fn while_fun_5, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_6 = fn while_fun_6, row, x ->
            if x < w do
              s = 0.0
              ky = 0
              while_fun_7 = fn while_fun_7, ky, s ->
                if ky < kh do
                  kx = 0
                  while_fun_8 = fn while_fun_8, kx, s ->
                    if kx < kw do
                      iy = y + ky - py
                      ix = x + kx - px
                      {s} = if iy >= 0 && iy < h && ix >= 0 && ix < w do
                        s = s + Enum.at(Enum.at(img, iy), ix) * Enum.at(Enum.at(ker, ky), kx)
                        {s}
                      else
                        {s}
                      end
                      kx = kx + 1
                      while_fun_8.(while_fun_8, kx, s)
                    else
                      {kx, s}
                    end
                  end
                  {kx, s} = try do
                      while_fun_8.(while_fun_8, kx, s)
                    catch
                      {:break, {kx, s}} -> {kx, s}
                    end

                  ky = ky + 1
                  while_fun_7.(while_fun_7, ky, s)
                else
                  {ky, s}
                end
              end
              {ky, s} = try do
                  while_fun_7.(while_fun_7, ky, s)
                catch
                  {:break, {ky, s}} -> {ky, s}
                end

              row = (row ++ [s])
              x = x + 1
              while_fun_6.(while_fun_6, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_6.(while_fun_6, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_5.(while_fun_5, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_5.(while_fun_5, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def horn_schunck(image0, image1, num_iter, alpha) do
    try do
      h = _len(image0)
      w = _len(Enum.at(image0, 0))
      u = zeros(h, w)
      v = zeros(h, w)
      kernel_x = [[-0.25, 0.25], [-0.25, 0.25]]
      kernel_y = [[-0.25, -0.25], [0.25, 0.25]]
      kernel_t = [[0.25, 0.25], [0.25, 0.25]]
      laplacian = [[0.0833333333333, 0.166666666667, 0.0833333333333], [0.166666666667, 0.0, 0.166666666667], [0.0833333333333, 0.166666666667, 0.0833333333333]]
      it = 0
      while_fun_9 = fn while_fun_9, it, u, v ->
        if it < num_iter do
          warped = warp(image0, u, v)
          dx1 = convolve(warped, kernel_x)
          dx2 = convolve(image1, kernel_x)
          dy1 = convolve(warped, kernel_y)
          dy2 = convolve(image1, kernel_y)
          dt1 = convolve(warped, kernel_t)
          dt2 = convolve(image1, kernel_t)
          avg_u = convolve(u, laplacian)
          avg_v = convolve(v, laplacian)
          y = 0
          while_fun_10 = fn while_fun_10, u, v, y ->
            if y < h do
              x = 0
              while_fun_11 = fn while_fun_11, u, v, x ->
                if x < w do
                  dx = Enum.at(Enum.at(dx1, y), x) + Enum.at(Enum.at(dx2, y), x)
                  dy = Enum.at(Enum.at(dy1, y), x) + Enum.at(Enum.at(dy2, y), x)
                  dt = Enum.at(Enum.at(dt1, y), x) - Enum.at(Enum.at(dt2, y), x)
                  au = Enum.at(Enum.at(avg_u, y), x)
                  av = Enum.at(Enum.at(avg_v, y), x)
                  numer = dx * au + dy * av + dt
                  denom = alpha * alpha + dx * dx + dy * dy
                  upd = numer / denom
                  u = List.replace_at(u, y, List.replace_at(Enum.at(u, y), x, au - dx * upd))
                  v = List.replace_at(v, y, List.replace_at(Enum.at(v, y), x, av - dy * upd))
                  x = x + 1
                  while_fun_11.(while_fun_11, u, v, x)
                else
                  {u, v, x}
                end
              end
              {u, v, x} = try do
                  while_fun_11.(while_fun_11, u, v, x)
                catch
                  {:break, {u, v, x}} -> {u, v, x}
                end

              y = y + 1
              while_fun_10.(while_fun_10, u, v, y)
            else
              {u, v, y}
            end
          end
          {u, v, y} = try do
              while_fun_10.(while_fun_10, u, v, y)
            catch
              {:break, {u, v, y}} -> {u, v, y}
            end

          it = it + 1
          while_fun_9.(while_fun_9, it, u, v)
        else
          {it, u, v}
        end
      end
      {it, u, v} = try do
          while_fun_9.(while_fun_9, it, u, v)
        catch
          {:break, {it, u, v}} -> {it, u, v}
        end

      throw {:return, [u, v]}
    catch
      {:return, val} -> val
    end
  end
  def print_matrix(mat) do
    try do
      y = 0
      while_fun_12 = fn while_fun_12, y ->
        if y < _len(mat) do
          row = Enum.at(mat, y)
          x = 0
          line = ""
          while_fun_13 = fn while_fun_13, line, x ->
            if x < _len(row) do
              line = (line <> Kernel.inspect(round_int(Enum.at(row, x))))
              {line} = if x + 1 < _len(row) do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              x = x + 1
              while_fun_13.(while_fun_13, line, x)
            else
              {line, x}
            end
          end
          {line, x} = try do
              while_fun_13.(while_fun_13, line, x)
            catch
              {:break, {line, x}} -> {line, x}
            end

          IO.puts(line)
          y = y + 1
          while_fun_12.(while_fun_12, y)
        else
          y
        end
      end
      y = try do
          while_fun_12.(while_fun_12, y)
        catch
          {:break, {y}} -> y
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      image0 = [[0.0, 0.0, 2.0], [0.0, 0.0, 2.0]]
      image1 = [[0.0, 2.0, 0.0], [0.0, 2.0, 0.0]]
      flows = horn_schunck(image0, image1, 20, 0.1)
      u = Enum.at(flows, 0)
      v = Enum.at(flows, 1)
      print_matrix(u)
      IO.puts("---")
      print_matrix(v)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
