# Code generated by Mochi transpiler 2025-08-06 22:25 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_int(n) do
    try do
      throw {:return, ((if n < 0, do: -n, else: n))}
    catch
      {:return, val} -> val
    end
  end
  def sqrt(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      e = 2.718281828
      n = 0
      y = x
      while_fun_2 = fn while_fun_2, n, y ->
        if y >= e do
          y = y / e
          n = n + 1
          while_fun_2.(while_fun_2, n, y)
        else
          {n, y}
        end
      end
      {n, y} = try do
          while_fun_2.(while_fun_2, n, y)
        catch
          {:break, {n, y}} -> {n, y}
        end

      while_fun_3 = fn while_fun_3, n, y ->
        if y <= 1.0 / e do
          y = y * e
          n = n - 1
          while_fun_3.(while_fun_3, n, y)
        else
          {n, y}
        end
      end
      {n, y} = try do
          while_fun_3.(while_fun_3, n, y)
        catch
          {:break, {n, y}} -> {n, y}
        end

      y = y - 1.0
      term = y
      result = 0.0
      k = 1
      while_fun_4 = fn while_fun_4, k, result, term ->
        if k <= 20 do
          result = (if rem(k, 2) == 1, do: result + term / (1.0 * k), else: result - term / (1.0 * k))
          term = term * y
          k = k + 1
          while_fun_4.(while_fun_4, k, result, term)
        else
          {k, result, term}
        end
      end
      {k, result, term} = try do
          while_fun_4.(while_fun_4, k, result, term)
        catch
          {:break, {k, result, term}} -> {k, result, term}
        end

      throw {:return, result + (1.0 * n)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_concurrency(image, coord) do
    try do
      offset_x = Enum.at(coord, 0)
      offset_y = Enum.at(coord, 1)
      max_val = 0
      {max_val} = Enum.reduce((0..(_len(image) - 1)), {max_val}, fn r, {max_val} ->
        {max_val} = Enum.reduce((0..(_len(Enum.at(image, r)) - 1)), {max_val}, fn c, {max_val} ->
          {max_val} = if Enum.at(Enum.at(image, r), c) > max_val do
            max_val = Enum.at(Enum.at(image, r), c)
            {max_val}
          else
            {max_val}
          end
          {max_val}
        end)
        {max_val}
      end)
      size = max_val + 1
      matrix = []
      {matrix} = Enum.reduce((0..(size - 1)), {matrix}, fn i, {matrix} ->
        row = []
        {row} = Enum.reduce((0..(size - 1)), {row}, fn j, {row} ->
          row = (row ++ [0.0])
          {row}
        end)
        matrix = (matrix ++ [row])
        {matrix}
      end)
      {matrix} = Enum.reduce((1..(_len(image) - 1 - 1)), {matrix}, fn x, {matrix} ->
        {matrix} = Enum.reduce((1..(_len(Enum.at(image, x)) - 1 - 1)), {matrix}, fn y, {matrix} ->
          base = Enum.at(Enum.at(image, x), y)
          offset = Enum.at(Enum.at(image, x + offset_x), y + offset_y)
          matrix = List.replace_at(matrix, base, List.replace_at(Enum.at(matrix, base), offset, Enum.at(Enum.at(matrix, base), offset) + 1.0))
          {matrix}
        end)
        {matrix}
      end)
      total = 0.0
      {total} = Enum.reduce((0..(size - 1)), {total}, fn i, {total} ->
        {total} = Enum.reduce((0..(size - 1)), {total}, fn j, {total} ->
          total = total + Enum.at(Enum.at(matrix, i), j)
          {total}
        end)
        {total}
      end)
      if total == 0.0 do
        throw {:return, matrix}
      end
      {matrix} = Enum.reduce((0..(size - 1)), {matrix}, fn i, {matrix} ->
        {matrix} = Enum.reduce((0..(size - 1)), {matrix}, fn j, {matrix} ->
          matrix = List.replace_at(matrix, i, List.replace_at(Enum.at(matrix, i), j, Enum.at(Enum.at(matrix, i), j) / total))
          {matrix}
        end)
        {matrix}
      end)
      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def haralick_descriptors(matrix) do
    try do
      rows = _len(matrix)
      cols = _len(Enum.at(matrix, 0))
      maximum_prob = 0.0
      correlation = 0.0
      energy = 0.0
      contrast = 0.0
      dissimilarity = 0.0
      inverse_difference = 0.0
      homogeneity = 0.0
      entropy = 0.0
      i = 0
      while_fun_5 = fn while_fun_5, contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob ->
        if i < rows do
          j = 0
          while_fun_6 = fn while_fun_6, contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob ->
            if j < cols do
              val = Enum.at(Enum.at(matrix, i), j)
              {maximum_prob} = if val > maximum_prob do
                maximum_prob = val
                {maximum_prob}
              else
                {maximum_prob}
              end
              correlation = correlation + (1.0 * i * j) * val
              energy = energy + val * val
              diff = i - j
              adiff = abs_int(diff)
              contrast = contrast + val * (1.0 * diff * diff)
              dissimilarity = dissimilarity + val * (1.0 * adiff)
              inverse_difference = inverse_difference + val / (1.0 + (1.0 * adiff))
              homogeneity = homogeneity + val / (1.0 + (1.0 * diff * diff))
              {entropy} = if val > 0.0 do
                entropy = entropy - (val * ln(val))
                {entropy}
              else
                {entropy}
              end
              j = j + 1
              while_fun_6.(while_fun_6, contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob)
            else
              {contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob}
            end
          end
          {contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob} = try do
              while_fun_6.(while_fun_6, contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob)
            catch
              {:break, {contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob}} -> {contrast, correlation, dissimilarity, energy, entropy, homogeneity, inverse_difference, j, maximum_prob}
            end

          i = i + 1
          while_fun_5.(while_fun_5, contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob)
        else
          {contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob}
        end
      end
      {contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob} = try do
          while_fun_5.(while_fun_5, contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob)
        catch
          {:break, {contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob}} -> {contrast, correlation, dissimilarity, energy, entropy, homogeneity, i, inverse_difference, maximum_prob}
        end

      throw {:return, [maximum_prob, correlation, energy, contrast, dissimilarity, inverse_difference, homogeneity, entropy]}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:image, [[0, 1, 0], [1, 0, 1], [0, 1, 0]])
  Process.put(:idx, 0)
  def main() do
    Process.put(:glcm, matrix_concurrency(Process.get(:image), [0, 1]))
    Process.put(:descriptors, haralick_descriptors(Process.get(:glcm)))
    while_fun_7 = fn while_fun_7 ->
      if Process.get(:idx) < _len(Process.get(:descriptors)) do
        IO.puts(Kernel.to_string(Enum.at(Process.get(:descriptors), Process.get(:idx))))
        Process.put(:idx, Process.get(:idx) + 1)
        while_fun_7.(while_fun_7)
      else
        nil
      end
    end
    try do
      while_fun_7.(while_fun_7)
    catch
      :break -> nil
    end

  end
end
Main.main()
