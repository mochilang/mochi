# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def token_to_string(t) do
    try do
      throw {:return, (((((("(" <> Kernel.to_string(t.offset)) <> ", ") <> Kernel.to_string(t.length)) <> ", ") <> t.indicator) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def tokens_to_string(ts) do
    try do
      res = "["
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(ts) do
          res = (res <> token_to_string(Enum.at(ts, i)))
          {res} = if i < _len(ts) - 1 do
            res = (res <> ", ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, (res <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def match_length_from_index(text, window, text_index, window_index) do
    try do
      if text_index >= _len(text) || window_index >= _len(window) do
        throw {:return, 0}
      end
      tc = _slice(text, text_index, text_index + 1 - (text_index))
      wc = _slice(window, window_index, window_index + 1 - (window_index))
      if tc != wc do
        throw {:return, 0}
      end
      throw {:return, 1 + match_length_from_index(text, (window <> tc), text_index + 1, window_index + 1)}
    catch
      {:return, val} -> val
    end
  end
  def find_encoding_token(text, search_buffer) do
    try do
      if _len(text) == 0 do
        raise("We need some text to work with.")
      end
      length = 0
      offset = 0
      if _len(search_buffer) == 0 do
        throw {:return, %{offset: offset, length: length, indicator: _slice(text, 0, 1 - (0))}}
      end
      i = 0
      while_fun_2 = fn while_fun_2, i, length, offset ->
        if i < _len(search_buffer) do
          ch = _slice(search_buffer, i, i + 1 - (i))
          found_offset = _len(search_buffer) - i
          {length, offset} = if ch == _slice(text, 0, 1 - (0)) do
            found_length = match_length_from_index(text, search_buffer, 0, i)
            {length, offset} = if found_length >= length do
              offset = found_offset
              length = found_length
              {length, offset}
            else
              {length, offset}
            end
            {length, offset}
          else
            {length, offset}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, length, offset)
        else
          {i, length, offset}
        end
      end
      {i, length, offset} = try do
          while_fun_2.(while_fun_2, i, length, offset)
        catch
          {:break, {i, length, offset}} -> {i, length, offset}
        end

      throw {:return, %{offset: offset, length: length, indicator: _slice(text, length, length + 1 - (length))}}
    catch
      {:return, val} -> val
    end
  end
  def lz77_compress(text, window_size, lookahead) do
    try do
      search_buffer_size = window_size - lookahead
      output = []
      search_buffer = ""
      remaining = text
      while_fun_3 = fn while_fun_3, output, remaining, search_buffer ->
        if _len(remaining) > 0 do
          token = find_encoding_token(remaining, search_buffer)
          add_len = token.length + 1
          search_buffer = (search_buffer <> _slice(remaining, 0, add_len - (0)))
          {search_buffer} = if _len(search_buffer) > search_buffer_size do
            search_buffer = _slice(search_buffer, _len(search_buffer) - search_buffer_size, _len(search_buffer) - (_len(search_buffer) - search_buffer_size))
            {search_buffer}
          else
            {search_buffer}
          end
          remaining = _slice(remaining, add_len, _len(remaining) - (add_len))
          output = (output ++ [token])
          while_fun_3.(while_fun_3, output, remaining, search_buffer)
        else
          {output, remaining, search_buffer}
        end
      end
      {output, remaining, search_buffer} = try do
          while_fun_3.(while_fun_3, output, remaining, search_buffer)
        catch
          {:break, {output, remaining, search_buffer}} -> {output, remaining, search_buffer}
        end

      throw {:return, output}
    catch
      {:return, val} -> val
    end
  end
  def lz77_decompress(tokens) do
    try do
      output = ""
      {output} = Enum.reduce(tokens, {output}, fn t, {output} ->
        i = 0
        while_fun_4 = fn while_fun_4, i, output ->
          if i < t.length do
            output = (output <> _slice(output, _len(output) - t.offset, _len(output) - t.offset + 1 - (_len(output) - t.offset)))
            i = i + 1
            while_fun_4.(while_fun_4, i, output)
          else
            {i, output}
          end
        end
        {i, output} = try do
            while_fun_4.(while_fun_4, i, output)
          catch
            {:break, {i, output}} -> {i, output}
          end

        output = (output <> t.indicator)
        {output}
      end)
      throw {:return, output}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:tokens_example, [%{offset: 0, length: 0, indicator: "c"}, %{offset: 0, length: 0, indicator: "a"}, %{offset: 0, length: 0, indicator: "b"}, %{offset: 0, length: 0, indicator: "r"}, %{offset: 3, length: 1, indicator: "c"}, %{offset: 2, length: 1, indicator: "d"}, %{offset: 7, length: 4, indicator: "r"}, %{offset: 3, length: 5, indicator: "d"}])
  def main() do
    Process.put(:c1, lz77_compress("ababcbababaa", 13, 6))
    IO.puts(Kernel.inspect(tokens_to_string(Process.get(:c1))))
    Process.put(:c2, lz77_compress("aacaacabcabaaac", 13, 6))
    IO.puts(Kernel.inspect(tokens_to_string(Process.get(:c2))))
    IO.puts(Kernel.inspect(lz77_decompress(Process.get(:tokens_example))))
  end
end
Main.main()
