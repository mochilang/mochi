# Code generated by Mochi transpiler 2025-08-24 15:35 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def run_length_encode(text) do
    try do
      if _len(text) == 0 do
        throw {:return, ""}
      end
      encoded = ""
      count = 1
      i = 0
      while_fun = fn while_fun, count, encoded, i ->
        if i < _len(text) do
          {count, encoded} = if i + 1 < _len(text) && String.at(text, i) == String.at(text, i + 1) do
            count = count + 1
            {count, encoded}
          else
            encoded = ((encoded <> String.at(text, i)) <> Kernel.inspect(count))
            count = 1
            {count, encoded}
          end
          i = i + 1
          while_fun.(while_fun, count, encoded, i)
        else
          {count, encoded, i}
        end
      end
      {count, encoded, _} = try do
          while_fun.(while_fun, count, encoded, i)
        catch
          {:break, {count, encoded, _}} -> {count, encoded, 0}
        end

      throw {:return, encoded}
    catch
      {:return, val} -> val
    end
  end
  def run_length_decode(encoded) do
    try do
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(encoded) do
          ch = String.at(encoded, i)
          i = i + 1
          num_str = ""
          while_fun_3 = fn while_fun_3, i, num_str ->
            if i < _len(encoded) && String.at(encoded, i) >= "0" && String.at(encoded, i) <= "9" do
              num_str = (num_str <> String.at(encoded, i))
              i = i + 1
              while_fun_3.(while_fun_3, i, num_str)
            else
              {i, num_str}
            end
          end
          {_, num_str} = try do
              while_fun_3.(while_fun_3, i, num_str)
            catch
              {:break, {_, num_str}} -> {0, num_str}
            end

          count = String.to_integer(num_str)
          j = 0
          while_fun_4 = fn while_fun_4, j, res ->
            if j < count do
              res = (res <> ch)
              j = j + 1
              while_fun_4.(while_fun_4, j, res)
            else
              {j, res}
            end
          end
          {_, res} = try do
              while_fun_4.(while_fun_4, j, res)
            catch
              {:break, {_, res}} -> {0, res}
            end

          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:example1, "AAAABBBCCDAA")
  Process.put(:example2, "A")
  Process.put(:example3, "AAADDDDDDFFFCCCAAVVVV")
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:encoded1, run_length_encode(Process.get(:example1)))
    Process.put(:encoded1, IO.puts(Process.get(:encoded1)))
    IO.puts(Kernel.inspect(run_length_decode(Process.get(:encoded1))))
    Process.put(:encoded2, run_length_encode(Process.get(:example2)))
    Process.put(:encoded2, IO.puts(Process.get(:encoded2)))
    IO.puts(Kernel.inspect(run_length_decode(Process.get(:encoded2))))
    Process.put(:encoded3, run_length_encode(Process.get(:example3)))
    Process.put(:encoded3, IO.puts(Process.get(:encoded3)))
    IO.puts(Kernel.inspect(run_length_decode(Process.get(:encoded3))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
