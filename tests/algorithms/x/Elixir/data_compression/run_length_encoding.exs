# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def run_length_encode(text) do
    try do
      if _len(text) == 0 do
        throw {:return, ""}
      end
      encoded = ""
      count = 1
      i = 0
      while_fun = fn while_fun, count, encoded, i ->
        if i < _len(text) do
          {count, encoded} = if i + 1 < _len(text) && String.at(text, i) == String.at(text, i + 1) do
            count = count + 1
            {count, encoded}
          else
            encoded = ((encoded <> String.at(text, i)) <> Kernel.inspect(count))
            count = 1
            {count, encoded}
          end
          i = i + 1
          while_fun.(while_fun, count, encoded, i)
        else
          {count, encoded, i}
        end
      end
      {count, encoded, i} = try do
          while_fun.(while_fun, count, encoded, i)
        catch
          {:break, {count, encoded, i}} -> {count, encoded, i}
        end

      throw {:return, encoded}
    catch
      {:return, val} -> val
    end
  end
  def run_length_decode(encoded) do
    try do
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(encoded) do
          ch = String.at(encoded, i)
          i = i + 1
          num_str = ""
          while_fun_3 = fn while_fun_3, i, num_str ->
            if i < _len(encoded) && String.at(encoded, i) >= "0" && String.at(encoded, i) <= "9" do
              num_str = (num_str <> String.at(encoded, i))
              i = i + 1
              while_fun_3.(while_fun_3, i, num_str)
            else
              {i, num_str}
            end
          end
          {i, num_str} = try do
              while_fun_3.(while_fun_3, i, num_str)
            catch
              {:break, {i, num_str}} -> {i, num_str}
            end

          count = String.to_integer(num_str)
          j = 0
          while_fun_4 = fn while_fun_4, j, res ->
            if j < count do
              res = (res <> ch)
              j = j + 1
              while_fun_4.(while_fun_4, j, res)
            else
              {j, res}
            end
          end
          {j, res} = try do
              while_fun_4.(while_fun_4, j, res)
            catch
              {:break, {j, res}} -> {j, res}
            end

          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:example1, "AAAABBBCCDAA")
  Process.put(:example2, "A")
  Process.put(:example3, "AAADDDDDDFFFCCCAAVVVV")
  def main() do
    Process.put(:encoded1, run_length_encode(Process.get(:example1)))
    IO.puts(Process.get(:encoded1))
    IO.puts(Kernel.inspect(run_length_decode(Process.get(:encoded1))))
    Process.put(:encoded2, run_length_encode(Process.get(:example2)))
    IO.puts(Process.get(:encoded2))
    IO.puts(Kernel.inspect(run_length_decode(Process.get(:encoded2))))
    Process.put(:encoded3, run_length_encode(Process.get(:example3)))
    IO.puts(Process.get(:encoded3))
    IO.puts(Kernel.inspect(run_length_decode(Process.get(:encoded3))))
  end
end
Main.main()
