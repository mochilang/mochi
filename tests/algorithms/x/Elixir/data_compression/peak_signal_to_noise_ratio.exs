# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      t = (x - 1.0) / (x + 1.0)
      term = t
      sum = 0.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n <= 19 do
          sum = sum + term / (:erlang.float(n))
          term = term * t * t
          n = n + 2
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def log10(x) do
    try do
      throw {:return, ln(x) / ln(10.0)}
    catch
      {:return, val} -> val
    end
  end
  def peak_signal_to_noise_ratio(original, contrast) do
    try do
      mse = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, mse ->
        if i < _len(original) do
          j = 0
          while_fun_4 = fn while_fun_4, j, mse ->
            if j < _len(Enum.at(original, i)) do
              diff = :erlang.float((Enum.at(Enum.at(original, i), j) - Enum.at(Enum.at(contrast, i), j)))
              mse = mse + diff * diff
              j = j + 1
              while_fun_4.(while_fun_4, j, mse)
            else
              {j, mse}
            end
          end
          {j, mse} = try do
              while_fun_4.(while_fun_4, j, mse)
            catch
              {:break, {j, mse}} -> {j, mse}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, mse)
        else
          {i, mse}
        end
      end
      {i, mse} = try do
          while_fun_3.(while_fun_3, i, mse)
        catch
          {:break, {i, mse}} -> {i, mse}
        end

      size = :erlang.float((_len(original) * _len(Enum.at(original, 0))))
      mse = mse / size
      if mse == 0.0 do
        throw {:return, 100.0}
      end
      pixel_max = 255.0
      throw {:return, 20.0 * log10(pixel_max / sqrtApprox(mse))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
  end
end
Main.main()
