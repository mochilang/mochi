# Code generated by Mochi transpiler 2025-08-24 15:35 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, _} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, _}} -> {guess, 0}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      t = (x - 1.0) / (x + 1.0)
      term = t
      sum = 0.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n <= 19 do
          sum = sum + term / (:erlang.float(n))
          term = term * t * t
          n = n + 2
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {_, sum, _} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {_, sum, _}} -> {0, sum, 0}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def log10(x) do
    try do
      throw {:return, ln(x) / ln(10.0)}
    catch
      {:return, val} -> val
    end
  end
  def peak_signal_to_noise_ratio(original, contrast) do
    try do
      mse = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, mse ->
        if i < _len(original) do
          j = 0
          while_fun_4 = fn while_fun_4, j, mse ->
            if j < _len(Enum.at(original, i, [])) do
              diff = :erlang.float((Enum.at(Enum.at(original, i, []), j, 0) - Enum.at(Enum.at(contrast, i, []), j, 0)))
              mse = mse + diff * diff
              j = j + 1
              while_fun_4.(while_fun_4, j, mse)
            else
              {j, mse}
            end
          end
          {_, mse} = try do
              while_fun_4.(while_fun_4, j, mse)
            catch
              {:break, {_, mse}} -> {0, mse}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, mse)
        else
          {i, mse}
        end
      end
      {_, mse} = try do
          while_fun_3.(while_fun_3, i, mse)
        catch
          {:break, {_, mse}} -> {0, mse}
        end

      size = :erlang.float((_len(original) * _len(Enum.at(original, 0, []))))
      mse = mse / size
      if mse == 0.0 do
        throw {:return, 100.0}
      end
      pixel_max = 255.0
      throw {:return, 20.0 * log10(pixel_max / sqrtApprox(mse))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
