# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def to_binary(n) do
    try do
      if n == 0 do
        throw {:return, "0"}
      end
      num = n
      res = ""
      while_fun = fn while_fun, num, res ->
        if num > 0 do
          bit = rem(num, 2)
          res = (Kernel.inspect(bit) <> res)
          num = div(num, 2)
          while_fun.(while_fun, num, res)
        else
          {num, res}
        end
      end
      {num, res} = try do
          while_fun.(while_fun, num, res)
        catch
          {:break, {num, res}} -> {num, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def contains_key_int(m, key) do
    try do
      Enum.each(Map.keys(m), fn k ->
        if k == key do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def lzw_compress(bits) do
    try do
      dict = %{"0" => 0, "1" => 1}
      current = ""
      result = ""
      index = 2
      i = 0
      while_fun_2 = fn while_fun_2, current, dict, i, index, result ->
        if i < _len(bits) do
          ch = String.at(bits, i)
          candidate = (current <> ch)
          {current, dict, index, result} = if contains_key_int(dict, candidate) do
            current = candidate
            {current, dict, index, result}
          else
            result = (result <> to_binary(dict[current]))
            dict = Map.put(dict, candidate, index)
            index = index + 1
            current = ch
            {current, dict, index, result}
          end
          i = i + 1
          while_fun_2.(while_fun_2, current, dict, i, index, result)
        else
          {current, dict, i, index, result}
        end
      end
      {current, dict, i, index, result} = try do
          while_fun_2.(while_fun_2, current, dict, i, index, result)
        catch
          {:break, {current, dict, i, index, result}} -> {current, dict, i, index, result}
        end

      {result} = if current != "" do
        result = (result <> to_binary(dict[current]))
        {result}
      else
        {result}
      end
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:data, "01001100100111")
  def main() do
    IO.puts(Kernel.inspect(lzw_compress(Process.get(:data))))
  end
end
Main.main()
