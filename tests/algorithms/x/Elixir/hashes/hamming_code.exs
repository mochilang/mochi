# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def index_of(s, ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(s) do
          if String.at(s, i) == ch do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def ord(ch) do
    try do
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      lower = "abcdefghijklmnopqrstuvwxyz"
      idx = index_of(upper, ch)
      if idx >= 0 do
        throw {:return, 65 + idx}
      end
      idx = index_of(lower, ch)
      if idx >= 0 do
        throw {:return, 97 + idx}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def chr(n) do
    try do
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      lower = "abcdefghijklmnopqrstuvwxyz"
      if n >= 65 && n < 91 do
        throw {:return, _slice(upper, n - 65, (n - 64) - (n - 65))}
      end
      if n >= 97 && n < 123 do
        throw {:return, _slice(lower, n - 97, (n - 96) - (n - 97))}
      end
      throw {:return, "?"}
    catch
      {:return, val} -> val
    end
  end
  def text_to_bits(text) do
    try do
      bits = ""
      i = 0
      while_fun_2 = fn while_fun_2, bits, i ->
        if i < _len(text) do
          code = ord(String.at(text, i))
          j = 7
          while_fun_3 = fn while_fun_3, bits, j ->
            if j >= 0 do
              p = pow2(j)
              bits = (if (rem((div(code, p)), 2)) == 1, do: (bits <> "1"), else: (bits <> "0"))
              j = j - 1
              while_fun_3.(while_fun_3, bits, j)
            else
              {bits, j}
            end
          end
          {bits, j} = try do
              while_fun_3.(while_fun_3, bits, j)
            catch
              {:break, {bits, j}} -> {bits, j}
            end

          i = i + 1
          while_fun_2.(while_fun_2, bits, i)
        else
          {bits, i}
        end
      end
      {bits, i} = try do
          while_fun_2.(while_fun_2, bits, i)
        catch
          {:break, {bits, i}} -> {bits, i}
        end

      throw {:return, bits}
    catch
      {:return, val} -> val
    end
  end
  def text_from_bits(bits) do
    try do
      text = ""
      i = 0
      while_fun_4 = fn while_fun_4, i, text ->
        if i < _len(bits) do
          code = 0
          j = 0
          while_fun_5 = fn while_fun_5, code, j ->
            if j < 8 && i + j < _len(bits) do
              code = code * 2
              {code} = if String.at(bits, i + j) == "1" do
                code = code + 1
                {code}
              else
                {code}
              end
              j = j + 1
              while_fun_5.(while_fun_5, code, j)
            else
              {code, j}
            end
          end
          {code, j} = try do
              while_fun_5.(while_fun_5, code, j)
            catch
              {:break, {code, j}} -> {code, j}
            end

          text = (text <> chr(code))
          i = i + 8
          while_fun_4.(while_fun_4, i, text)
        else
          {i, text}
        end
      end
      {i, text} = try do
          while_fun_4.(while_fun_4, i, text)
        catch
          {:break, {i, text}} -> {i, text}
        end

      throw {:return, text}
    catch
      {:return, val} -> val
    end
  end
  def bool_to_string(b) do
    try do
      throw {:return, ((if b, do: "True", else: "False"))}
    catch
      {:return, val} -> val
    end
  end
  def string_to_bitlist(s) do
    try do
      res = []
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(s) do
          res = (if String.at(s, i) == "1", do: (res ++ [1]), else: (res ++ [0]))
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bitlist_to_string(bits) do
    try do
      s = ""
      i = 0
      while_fun_7 = fn while_fun_7, i, s ->
        if i < _len(bits) do
          s = (if Enum.at(bits, i, []) == 1, do: (s <> "1"), else: (s <> "0"))
          i = i + 1
          while_fun_7.(while_fun_7, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_7.(while_fun_7, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def is_power_of_two(x) do
    try do
      if x < 1 do
        throw {:return, false}
      end
      p = 1
      while_fun_8 = fn while_fun_8, p ->
        if p < x do
          p = p * 2
          while_fun_8.(while_fun_8, p)
        else
          p
        end
      end
      p = try do
          while_fun_8.(while_fun_8, p)
        catch
          {:break, {p}} -> p
        end

      throw {:return, p == x}
    catch
      {:return, val} -> val
    end
  end
  def list_eq(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < _len(a) do
          if Enum.at(a, i, []) != Enum.at(b, i, []) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def pow2(e) do
    try do
      res = 1
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < e do
          res = res * 2
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def has_bit(n, b) do
    try do
      p = pow2(b)
      if (rem((div(n, p)), 2)) == 1 do
        throw {:return, true}
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def hamming_encode(r, data_bits) do
    try do
      total = r + _len(data_bits)
      data_ord = []
      cont_data = 0
      x = 1
      while_fun_11 = fn while_fun_11, cont_data, data_ord, x ->
        if x <= total do
          {cont_data, data_ord} = if is_power_of_two(x) do
            data_ord = (data_ord ++ [-1])
            {cont_data, data_ord}
          else
            data_ord = (data_ord ++ [Enum.at(data_bits, cont_data, [])])
            cont_data = cont_data + 1
            {cont_data, data_ord}
          end
          x = x + 1
          while_fun_11.(while_fun_11, cont_data, data_ord, x)
        else
          {cont_data, data_ord, x}
        end
      end
      {cont_data, data_ord, x} = try do
          while_fun_11.(while_fun_11, cont_data, data_ord, x)
        catch
          {:break, {cont_data, data_ord, x}} -> {cont_data, data_ord, x}
        end

      parity = []
      bp = 0
      while_fun_12 = fn while_fun_12, bp, parity ->
        if bp < r do
          cont_bo = 0
          j = 0
          while_fun_13 = fn while_fun_13, cont_bo, j ->
            if j < _len(data_ord) do
              bit = Enum.at(data_ord, j, [])
              {cont_bo} = if bit >= 0 do
                pos = j + 1
                {cont_bo} = if has_bit(pos, bp) && bit == 1 do
                  cont_bo = cont_bo + 1
                  {cont_bo}
                else
                  {cont_bo}
                end
                {cont_bo}
              else
                {cont_bo}
              end
              j = j + 1
              while_fun_13.(while_fun_13, cont_bo, j)
            else
              {cont_bo, j}
            end
          end
          {cont_bo, j} = try do
              while_fun_13.(while_fun_13, cont_bo, j)
            catch
              {:break, {cont_bo, j}} -> {cont_bo, j}
            end

          parity = (parity ++ [rem(cont_bo, 2)])
          bp = bp + 1
          while_fun_12.(while_fun_12, bp, parity)
        else
          {bp, parity}
        end
      end
      {bp, parity} = try do
          while_fun_12.(while_fun_12, bp, parity)
        catch
          {:break, {bp, parity}} -> {bp, parity}
        end

      result = []
      cont_bp = 0
      i = 0
      while_fun_14 = fn while_fun_14, cont_bp, i, result ->
        if i < _len(data_ord) do
          {cont_bp, result} = if Enum.at(data_ord, i, []) < 0 do
            result = (result ++ [Enum.at(parity, cont_bp, [])])
            cont_bp = cont_bp + 1
            {cont_bp, result}
          else
            result = (result ++ [Enum.at(data_ord, i, [])])
            {cont_bp, result}
          end
          i = i + 1
          while_fun_14.(while_fun_14, cont_bp, i, result)
        else
          {cont_bp, i, result}
        end
      end
      {cont_bp, i, result} = try do
          while_fun_14.(while_fun_14, cont_bp, i, result)
        catch
          {:break, {cont_bp, i, result}} -> {cont_bp, i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def hamming_decode(r, code) do
    try do
      data_output = []
      parity_received = []
      i = 1
      idx = 0
      while_fun_15 = fn while_fun_15, data_output, i, idx, parity_received ->
        if i <= _len(code) do
          {data_output, parity_received} = if is_power_of_two(i) do
            parity_received = (parity_received ++ [Enum.at(code, idx, [])])
            {data_output, parity_received}
          else
            data_output = (data_output ++ [Enum.at(code, idx, [])])
            {data_output, parity_received}
          end
          idx = idx + 1
          i = i + 1
          while_fun_15.(while_fun_15, data_output, i, idx, parity_received)
        else
          {data_output, i, idx, parity_received}
        end
      end
      {data_output, i, idx, parity_received} = try do
          while_fun_15.(while_fun_15, data_output, i, idx, parity_received)
        catch
          {:break, {data_output, i, idx, parity_received}} -> {data_output, i, idx, parity_received}
        end

      recomputed = hamming_encode(r, data_output)
      parity_calc = []
      j = 0
      while_fun_16 = fn while_fun_16, j, parity_calc ->
        if j < _len(recomputed) do
          {parity_calc} = if is_power_of_two(j + 1) do
            parity_calc = (parity_calc ++ [Enum.at(recomputed, j, [])])
            {parity_calc}
          else
            {parity_calc}
          end
          j = j + 1
          while_fun_16.(while_fun_16, j, parity_calc)
        else
          {j, parity_calc}
        end
      end
      {j, parity_calc} = try do
          while_fun_16.(while_fun_16, j, parity_calc)
        catch
          {:break, {j, parity_calc}} -> {j, parity_calc}
        end

      ack = list_eq(parity_received, parity_calc)
      throw {:return, %{data: data_output, ack: ack}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      sizePari = 4
      be = 2
      text = "Message01"
      binary = text_to_bits(text)
      IO.puts((("Text input in binary is '" <> binary) <> "'"))
      data_bits = string_to_bitlist(binary)
      encoded = hamming_encode(sizePari, data_bits)
      IO.puts(("Data converted ----------> " <> bitlist_to_string(encoded)))
      decoded = hamming_decode(sizePari, encoded)
      IO.puts(((("Data receive ------------> " <> bitlist_to_string(decoded.data)) <> " -- Data integrity: ") <> bool_to_string(decoded.ack)))
      corrupted = []
      i = 0
      while_fun_17 = fn while_fun_17, corrupted, i ->
        if i < _len(encoded) do
          corrupted = (corrupted ++ [Enum.at(encoded, i, [])])
          i = i + 1
          while_fun_17.(while_fun_17, corrupted, i)
        else
          {corrupted, i}
        end
      end
      {corrupted, i} = try do
          while_fun_17.(while_fun_17, corrupted, i)
        catch
          {:break, {corrupted, i}} -> {corrupted, i}
        end

      pos = be - 1
      corrupted = List.replace_at(corrupted, pos, ((if Enum.at(corrupted, pos, []) == 0, do: 1, else: 0)))
      decoded_err = hamming_decode(sizePari, corrupted)
      IO.puts(((("Data receive (error) ----> " <> bitlist_to_string(decoded_err.data)) <> " -- Data integrity: ") <> bool_to_string(decoded_err.ack)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
