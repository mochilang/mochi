# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def ord(ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(Process.get(:ascii)) do
          if _slice(Process.get(:ascii), i, (i + 1) - i) == ch do
            throw {:return, 32 + i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def to_little_endian(s) do
    try do
      if _len(s) != 32 do
        raise("Input must be of length 32")
      end
      throw {:return, (((_slice(s, 24, 32 - 24) <> _slice(s, 16, 24 - 16)) <> _slice(s, 8, 16 - 8)) <> _slice(s, 0, 8 - 0))}
    catch
      {:return, val} -> val
    end
  end
  def int_to_bits(n, width) do
    try do
      bits = ""
      num = n
      while_fun_2 = fn while_fun_2, bits, num ->
        if num > 0 do
          bits = (Kernel.inspect(rem(num, 2)) <> bits)
          num = div(num, 2)
          while_fun_2.(while_fun_2, bits, num)
        else
          {bits, num}
        end
      end
      {bits, num} = try do
          while_fun_2.(while_fun_2, bits, num)
        catch
          {:break, {bits, num}} -> {bits, num}
        end

      while_fun_3 = fn while_fun_3, bits ->
        if _len(bits) < width do
          bits = ("0" <> bits)
          while_fun_3.(while_fun_3, bits)
        else
          bits
        end
      end
      bits = try do
          while_fun_3.(while_fun_3, bits)
        catch
          {:break, {bits}} -> bits
        end

      {bits} = if _len(bits) > width do
        bits = _slice(bits, _len(bits) - width, _len(bits) - (_len(bits) - width))
        {bits}
      else
        {bits}
      end
      throw {:return, bits}
    catch
      {:return, val} -> val
    end
  end
  def bits_to_int(bits) do
    try do
      num = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, num ->
        if i < _len(bits) do
          num = (if _slice(bits, i, (i + 1) - i) == "1", do: num * 2 + 1, else: num * 2)
          i = i + 1
          while_fun_4.(while_fun_4, i, num)
        else
          {i, num}
        end
      end
      {i, num} = try do
          while_fun_4.(while_fun_4, i, num)
        catch
          {:break, {i, num}} -> {i, num}
        end

      throw {:return, num}
    catch
      {:return, val} -> val
    end
  end
  def to_hex(n) do
    try do
      digits = "0123456789abcdef"
      if n == 0 do
        throw {:return, "0"}
      end
      num = n
      s = ""
      while_fun_5 = fn while_fun_5, num, s ->
        if num > 0 do
          d = rem(num, 16)
          s = (_slice(digits, d, (d + 1) - d) <> s)
          num = div(num, 16)
          while_fun_5.(while_fun_5, num, s)
        else
          {num, s}
        end
      end
      {num, s} = try do
          while_fun_5.(while_fun_5, num, s)
        catch
          {:break, {num, s}} -> {num, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def reformat_hex(i) do
    try do
      if i < 0 do
        raise("Input must be non-negative")
      end
      hex = to_hex(i)
      while_fun_6 = fn while_fun_6, hex ->
        if _len(hex) < 8 do
          hex = ("0" <> hex)
          while_fun_6.(while_fun_6, hex)
        else
          hex
        end
      end
      hex = try do
          while_fun_6.(while_fun_6, hex)
        catch
          {:break, {hex}} -> hex
        end

      {hex} = if _len(hex) > 8 do
        hex = _slice(hex, _len(hex) - 8, _len(hex) - (_len(hex) - 8))
        {hex}
      else
        {hex}
      end
      le = ""
      j = _len(hex) - 2
      while_fun_7 = fn while_fun_7, j, le ->
        if j >= 0 do
          le = (le <> _slice(hex, j, (j + 2) - j))
          j = j - 2
          while_fun_7.(while_fun_7, j, le)
        else
          {j, le}
        end
      end
      {j, le} = try do
          while_fun_7.(while_fun_7, j, le)
        catch
          {:break, {j, le}} -> {j, le}
        end

      throw {:return, le}
    catch
      {:return, val} -> val
    end
  end
  def preprocess(message) do
    try do
      bit_string = ""
      i = 0
      while_fun_8 = fn while_fun_8, bit_string, i ->
        if i < _len(message) do
          ch = _slice(message, i, (i + 1) - i)
          bit_string = (bit_string <> int_to_bits(ord(ch), 8))
          i = i + 1
          while_fun_8.(while_fun_8, bit_string, i)
        else
          {bit_string, i}
        end
      end
      {bit_string, i} = try do
          while_fun_8.(while_fun_8, bit_string, i)
        catch
          {:break, {bit_string, i}} -> {bit_string, i}
        end

      start_len = int_to_bits(_len(bit_string), 64)
      bit_string = (bit_string <> "1")
      while_fun_9 = fn while_fun_9, bit_string ->
        if rem(_len(bit_string), 512) != 448 do
          bit_string = (bit_string <> "0")
          while_fun_9.(while_fun_9, bit_string)
        else
          bit_string
        end
      end
      bit_string = try do
          while_fun_9.(while_fun_9, bit_string)
        catch
          {:break, {bit_string}} -> bit_string
        end

      bit_string = ((bit_string <> to_little_endian(_slice(start_len, 32, 64 - 32))) <> to_little_endian(_slice(start_len, 0, 32 - 0)))
      throw {:return, bit_string}
    catch
      {:return, val} -> val
    end
  end
  def get_block_words(bit_string) do
    try do
      if rem(_len(bit_string), 512) != 0 do
        raise("Input must have length that's a multiple of 512")
      end
      blocks = []
      pos = 0
      while_fun_10 = fn while_fun_10, blocks, pos ->
        if pos < _len(bit_string) do
          block = []
          i = 0
          while_fun_11 = fn while_fun_11, block, i ->
            if i < 512 do
              part = _slice(bit_string, pos + i, (pos + i + 32) - (pos + i))
              word = bits_to_int(to_little_endian(part))
              block = (block ++ [word])
              i = i + 32
              while_fun_11.(while_fun_11, block, i)
            else
              {block, i}
            end
          end
          {block, i} = try do
              while_fun_11.(while_fun_11, block, i)
            catch
              {:break, {block, i}} -> {block, i}
            end

          blocks = (blocks ++ [block])
          pos = pos + 512
          while_fun_10.(while_fun_10, blocks, pos)
        else
          {blocks, pos}
        end
      end
      {blocks, pos} = try do
          while_fun_10.(while_fun_10, blocks, pos)
        catch
          {:break, {blocks, pos}} -> {blocks, pos}
        end

      throw {:return, blocks}
    catch
      {:return, val} -> val
    end
  end
  def bit_and(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_12 = fn while_fun_12, bit, i, res, x, y ->
        if i < 32 do
          {res} = if (rem(x, 2) == 1) && (rem(y, 2) == 1) do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_12.(while_fun_12, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_12.(while_fun_12, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_or(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_13 = fn while_fun_13, bit, i, res, x, y ->
        if i < 32 do
          abit = rem(x, 2)
          bbit = rem(y, 2)
          {res} = if abit == 1 || bbit == 1 do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_13.(while_fun_13, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_13.(while_fun_13, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_xor(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_14 = fn while_fun_14, bit, i, res, x, y ->
        if i < 32 do
          abit = rem(x, 2)
          bbit = rem(y, 2)
          {res} = if rem((abit + bbit), 2) == 1 do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_14.(while_fun_14, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_14.(while_fun_14, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def not_32(i) do
    try do
      if i < 0 do
        raise("Input must be non-negative")
      end
      throw {:return, 4294967295 - i}
    catch
      {:return, val} -> val
    end
  end
  def sum_32(a, b) do
    try do
      throw {:return, rem((a + b), Process.get(:mod))}
    catch
      {:return, val} -> val
    end
  end
  def lshift(num, k) do
    try do
      result = rem(num, Process.get(:mod))
      i = 0
      while_fun_15 = fn while_fun_15, i, result ->
        if i < k do
          result = rem((result * 2), Process.get(:mod))
          i = i + 1
          while_fun_15.(while_fun_15, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_15.(while_fun_15, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def rshift(num, k) do
    try do
      result = num
      i = 0
      while_fun_16 = fn while_fun_16, i, result ->
        if i < k do
          result = div(result, 2)
          i = i + 1
          while_fun_16.(while_fun_16, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_16.(while_fun_16, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def left_rotate_32(i, shift) do
    try do
      if i < 0 do
        raise("Input must be non-negative")
      end
      if shift < 0 do
        raise("Shift must be non-negative")
      end
      left = lshift(i, shift)
      right = rshift(i, 32 - shift)
      throw {:return, rem((left + right), Process.get(:mod))}
    catch
      {:return, val} -> val
    end
  end
  def md5_me(message) do
    try do
      bit_string = preprocess(message)
      added_consts = [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]
      shift_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
      a0 = 1732584193
      b0 = 4023233417
      c0 = 2562383102
      d0 = 271733878
      blocks = get_block_words(bit_string)
      bi = 0
      while_fun_17 = fn while_fun_17, a0, b0, bi, c0, d0 ->
        if bi < _len(blocks) do
          block = Enum.at(blocks, bi, [])
          a = a0
          b = b0
          c = c0
          d = d0
          i = 0
          while_fun_18 = fn while_fun_18, a, b, c, d, i ->
            if i < 64 do
              f = 0
              g = 0
              {f, g} = if i <= 15 do
                f = bit_xor(d, bit_and(b, bit_xor(c, d)))
                g = i
                {f, g}
              else
                {f, g} = if i <= 31 do
                  f = bit_xor(c, bit_and(d, bit_xor(b, c)))
                  g = rem((5 * i + 1), 16)
                  {f, g}
                else
                  {f, g} = if i <= 47 do
                    f = bit_xor(bit_xor(b, c), d)
                    g = rem((3 * i + 5), 16)
                    {f, g}
                  else
                    f = bit_xor(c, bit_or(b, not_32(d)))
                    g = rem((7 * i), 16)
                    {f, g}
                  end
                  {f, g}
                end
                {f, g}
              end
              f = sum_32(f, a)
              f = sum_32(f, Enum.at(added_consts, i, []))
              f = sum_32(f, Enum.at(block, g, []))
              rotated = left_rotate_32(f, Enum.at(shift_amounts, i, []))
              new_b = sum_32(b, rotated)
              a = d
              d = c
              c = b
              b = new_b
              i = i + 1
              while_fun_18.(while_fun_18, a, b, c, d, i)
            else
              {a, b, c, d, i}
            end
          end
          {a, b, c, d, i} = try do
              while_fun_18.(while_fun_18, a, b, c, d, i)
            catch
              {:break, {a, b, c, d, i}} -> {a, b, c, d, i}
            end

          a0 = sum_32(a0, a)
          b0 = sum_32(b0, b)
          c0 = sum_32(c0, c)
          d0 = sum_32(d0, d)
          bi = bi + 1
          while_fun_17.(while_fun_17, a0, b0, bi, c0, d0)
        else
          {a0, b0, bi, c0, d0}
        end
      end
      {a0, b0, bi, c0, d0} = try do
          while_fun_17.(while_fun_17, a0, b0, bi, c0, d0)
        catch
          {:break, {a0, b0, bi, c0, d0}} -> {a0, b0, bi, c0, d0}
        end

      digest = (((reformat_hex(a0) <> reformat_hex(b0)) <> reformat_hex(c0)) <> reformat_hex(d0))
      throw {:return, digest}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:mod, 4294967296)
  Process.put(:ascii, " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
