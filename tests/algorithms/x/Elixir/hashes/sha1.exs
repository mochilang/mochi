# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def ord(ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(Process.get(:ascii)) do
          if _slice(Process.get(:ascii), i, (i + 1) - i) == ch do
            throw {:return, 32 + i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def pow2(n) do
    try do
      res = 1
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < n do
          res = res * 2
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_and(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_3 = fn while_fun_3, bit, i, res, x, y ->
        if i < 32 do
          {res} = if (rem(x, 2) == 1) && (rem(y, 2) == 1) do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_3.(while_fun_3, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_3.(while_fun_3, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_or(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_4 = fn while_fun_4, bit, i, res, x, y ->
        if i < 32 do
          abit = rem(x, 2)
          bbit = rem(y, 2)
          {res} = if abit == 1 || bbit == 1 do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_4.(while_fun_4, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_4.(while_fun_4, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_xor(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_5 = fn while_fun_5, bit, i, res, x, y ->
        if i < 32 do
          abit = rem(x, 2)
          bbit = rem(y, 2)
          {res} = if (abit == 1 && bbit == 0) || (abit == 0 && bbit == 1) do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_5.(while_fun_5, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_5.(while_fun_5, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_not(a) do
    try do
      throw {:return, (Process.get(:mod) - 1) - a}
    catch
      {:return, val} -> val
    end
  end
  def rotate_left(n, b) do
    try do
      left = rem((n * pow2(b)), Process.get(:mod))
      right = div(n, pow2(32 - b))
      throw {:return, rem((left + right), Process.get(:mod))}
    catch
      {:return, val} -> val
    end
  end
  def to_hex32(n) do
    try do
      digits = "0123456789abcdef"
      num = n
      s = ""
      {s} = if num == 0 do
        s = "0"
        {s}
      else
        {s}
      end
      while_fun_6 = fn while_fun_6, num, s ->
        if num > 0 do
          d = rem(num, 16)
          s = (_slice(digits, d, (d + 1) - d) <> s)
          num = div(num, 16)
          while_fun_6.(while_fun_6, num, s)
        else
          {num, s}
        end
      end
      {num, s} = try do
          while_fun_6.(while_fun_6, num, s)
        catch
          {:break, {num, s}} -> {num, s}
        end

      while_fun_7 = fn while_fun_7, s ->
        if _len(s) < 8 do
          s = ("0" <> s)
          while_fun_7.(while_fun_7, s)
        else
          s
        end
      end
      s = try do
          while_fun_7.(while_fun_7, s)
        catch
          {:break, {s}} -> s
        end

      {s} = if _len(s) > 8 do
        s = _slice(s, _len(s) - 8, _len(s) - (_len(s) - 8))
        {s}
      else
        {s}
      end
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def sha1(message) do
    try do
      bytes = []
      i = 0
      while_fun_8 = fn while_fun_8, bytes, i ->
        if i < _len(message) do
          bytes = (bytes ++ [ord(_slice(message, i, (i + 1) - i))])
          i = i + 1
          while_fun_8.(while_fun_8, bytes, i)
        else
          {bytes, i}
        end
      end
      {bytes, i} = try do
          while_fun_8.(while_fun_8, bytes, i)
        catch
          {:break, {bytes, i}} -> {bytes, i}
        end

      bytes = (bytes ++ [128])
      while_fun_9 = fn while_fun_9, bytes ->
        if rem((_len(bytes) + 8), 64) != 0 do
          bytes = (bytes ++ [0])
          while_fun_9.(while_fun_9, bytes)
        else
          bytes
        end
      end
      bytes = try do
          while_fun_9.(while_fun_9, bytes)
        catch
          {:break, {bytes}} -> bytes
        end

      bit_len = _len(message) * 8
      len_bytes = [0, 0, 0, 0, 0, 0, 0, 0]
      bl = bit_len
      k = 7
      while_fun_10 = fn while_fun_10, bl, k, len_bytes ->
        if k >= 0 do
          len_bytes = List.replace_at(len_bytes, k, rem(bl, 256))
          bl = div(bl, 256)
          k = k - 1
          while_fun_10.(while_fun_10, bl, k, len_bytes)
        else
          {bl, k, len_bytes}
        end
      end
      {bl, k, len_bytes} = try do
          while_fun_10.(while_fun_10, bl, k, len_bytes)
        catch
          {:break, {bl, k, len_bytes}} -> {bl, k, len_bytes}
        end

      j = 0
      while_fun_11 = fn while_fun_11, bytes, j ->
        if j < 8 do
          bytes = (bytes ++ [Enum.at(len_bytes, j, [])])
          j = j + 1
          while_fun_11.(while_fun_11, bytes, j)
        else
          {bytes, j}
        end
      end
      {bytes, j} = try do
          while_fun_11.(while_fun_11, bytes, j)
        catch
          {:break, {bytes, j}} -> {bytes, j}
        end

      blocks = []
      pos = 0
      while_fun_12 = fn while_fun_12, blocks, pos ->
        if pos < _len(bytes) do
          block = []
          j2 = 0
          while_fun_13 = fn while_fun_13, block, j2 ->
            if j2 < 64 do
              block = (block ++ [Enum.at(bytes, pos + j2, [])])
              j2 = j2 + 1
              while_fun_13.(while_fun_13, block, j2)
            else
              {block, j2}
            end
          end
          {block, j2} = try do
              while_fun_13.(while_fun_13, block, j2)
            catch
              {:break, {block, j2}} -> {block, j2}
            end

          blocks = (blocks ++ [block])
          pos = pos + 64
          while_fun_12.(while_fun_12, blocks, pos)
        else
          {blocks, pos}
        end
      end
      {blocks, pos} = try do
          while_fun_12.(while_fun_12, blocks, pos)
        catch
          {:break, {blocks, pos}} -> {blocks, pos}
        end

      h0 = 1732584193
      h1 = 4023233417
      h2 = 2562383102
      h3 = 271733878
      h4 = 3285377520
      bindex = 0
      while_fun_14 = fn while_fun_14, bindex, h0, h1, h2, h3, h4 ->
        if bindex < _len(blocks) do
          block = Enum.at(blocks, bindex, [])
          w = []
          t = 0
          while_fun_15 = fn while_fun_15, t, w ->
            if t < 16 do
              j3 = t * 4
              word = (((Enum.at(block, j3, []) * 256 + Enum.at(block, j3 + 1, [])) * 256 + Enum.at(block, j3 + 2, [])) * 256 + Enum.at(block, j3 + 3, []))
              w = (w ++ [word])
              t = t + 1
              while_fun_15.(while_fun_15, t, w)
            else
              {t, w}
            end
          end
          {t, w} = try do
              while_fun_15.(while_fun_15, t, w)
            catch
              {:break, {t, w}} -> {t, w}
            end

          while_fun_16 = fn while_fun_16, t, w ->
            if t < 80 do
              tmp = bit_xor(bit_xor(bit_xor(Enum.at(w, t - 3, []), Enum.at(w, t - 8, [])), Enum.at(w, t - 14, [])), Enum.at(w, t - 16, []))
              w = (w ++ [rotate_left(tmp, 1)])
              t = t + 1
              while_fun_16.(while_fun_16, t, w)
            else
              {t, w}
            end
          end
          {t, w} = try do
              while_fun_16.(while_fun_16, t, w)
            catch
              {:break, {t, w}} -> {t, w}
            end

          a = h0
          b = h1
          c = h2
          d = h3
          e = h4
          i2 = 0
          while_fun_17 = fn while_fun_17, a, b, c, d, e, i2 ->
            if i2 < 80 do
              f = 0
              kconst = 0
              {f, kconst} = if i2 < 20 do
                f = bit_or(bit_and(b, c), bit_and(bit_not(b), d))
                kconst = 1518500249
                {f, kconst}
              else
                {f, kconst} = if i2 < 40 do
                  f = bit_xor(bit_xor(b, c), d)
                  kconst = 1859775393
                  {f, kconst}
                else
                  {f, kconst} = if i2 < 60 do
                    f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d))
                    kconst = 2400959708
                    {f, kconst}
                  else
                    f = bit_xor(bit_xor(b, c), d)
                    kconst = 3395469782
                    {f, kconst}
                  end
                  {f, kconst}
                end
                {f, kconst}
              end
              temp = rem((rotate_left(a, 5) + f + e + kconst + Enum.at(w, i2, [])), Process.get(:mod))
              e = d
              d = c
              c = rotate_left(b, 30)
              b = a
              a = temp
              i2 = i2 + 1
              while_fun_17.(while_fun_17, a, b, c, d, e, i2)
            else
              {a, b, c, d, e, i2}
            end
          end
          {a, b, c, d, e, i2} = try do
              while_fun_17.(while_fun_17, a, b, c, d, e, i2)
            catch
              {:break, {a, b, c, d, e, i2}} -> {a, b, c, d, e, i2}
            end

          h0 = rem((h0 + a), Process.get(:mod))
          h1 = rem((h1 + b), Process.get(:mod))
          h2 = rem((h2 + c), Process.get(:mod))
          h3 = rem((h3 + d), Process.get(:mod))
          h4 = rem((h4 + e), Process.get(:mod))
          bindex = bindex + 1
          while_fun_14.(while_fun_14, bindex, h0, h1, h2, h3, h4)
        else
          {bindex, h0, h1, h2, h3, h4}
        end
      end
      {bindex, h0, h1, h2, h3, h4} = try do
          while_fun_14.(while_fun_14, bindex, h0, h1, h2, h3, h4)
        catch
          {:break, {bindex, h0, h1, h2, h3, h4}} -> {bindex, h0, h1, h2, h3, h4}
        end

      throw {:return, ((((to_hex32(h0) <> to_hex32(h1)) <> to_hex32(h2)) <> to_hex32(h3)) <> to_hex32(h4))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(sha1("Test String")))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:mod, 4294967296)
  Process.put(:ascii, " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
  def bench_main() do
    Process.put(:mod, 4294967296)
    Process.put(:ascii, " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
