# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def round_dec(x, n) do
    try do
      m10 = 1.0
      i = 0
      while_fun = fn while_fun, m10 ->
        if i < n do
          m10 = m10 * 10.0
          i = i + 1
          while_fun.(while_fun, m10)
        else
          m10
        end
      end
      m10 = try do
          while_fun.(while_fun, m10)
        catch
          {:break, {m10}} -> m10
        end

      y = x * m10 + 0.5
      throw {:return, (1.0 * Kernel.trunc(y)) / m10}
    catch
      {:return, val} -> val
    end
  end
  def reset() do
    try do
      throw {:return, %{buffer: Process.get(:k), params: [0.0, 0.0, 0.0, 0.0, 0.0], time: 0}}
    catch
      {:return, val} -> val
    end
  end
  def push(m, seed) do
    try do
      buf = m.buffer
      par = m.params
      i = 0
      while_fun_2 = fn while_fun_2, buf, par ->
        if i < _len(buf) do
          value = Enum.at(buf, i, [])
          e = (1.0 * seed) / value
          next_value = Enum.at(buf, rem((i + 1), Process.get(:size)), []) + e
          next_value = next_value - (1.0 * Kernel.trunc(next_value))
          r = Enum.at(par, i, []) + e
          r = r - (1.0 * Kernel.trunc(r))
          r = r + 3.0
          buf = List.replace_at(buf, i, round_dec(r * next_value * (1.0 - next_value), 10))
          par = List.replace_at(par, i, r)
          i = i + 1
          while_fun_2.(while_fun_2, buf, par)
        else
          {buf, par}
        end
      end
      {buf, par} = try do
          while_fun_2.(while_fun_2, buf, par)
        catch
          {:break, {buf, par}} -> {buf, par}
        end

      throw {:return, %{buffer: buf, params: par, time: m.time + 1}}
    catch
      {:return, val} -> val
    end
  end
  def xor(a, b) do
    try do
      aa = a
      bb = b
      res = 0
      bit = 1
      while_fun_3 = fn while_fun_3, aa, bb, bit ->
        if aa > 0 || bb > 0 do
          abit = rem(aa, 2)
          bbit = rem(bb, 2)
          if abit != bbit do
            res = res + bit
          end
          aa = div(aa, 2)
          bb = div(bb, 2)
          bit = bit * 2
          while_fun_3.(while_fun_3, aa, bb, bit)
        else
          {aa, bb, bit}
        end
      end
      {aa, bb, bit} = try do
          while_fun_3.(while_fun_3, aa, bb, bit)
        catch
          {:break, {aa, bb, bit}} -> {aa, bb, bit}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def xorshift(x, y) do
    try do
      xv = x
      yv = y
      xv = xor(xv, div(yv, 8192))
      yv = xor(yv, xv * 131072)
      xv = xor(xv, div(yv, 32))
      throw {:return, xv}
    catch
      {:return, val} -> val
    end
  end
  def pull(m) do
    try do
      buf = m.buffer
      par = m.params
      key = rem(m.time, Process.get(:size))
      i = 0
      while_fun_4 = fn while_fun_4, buf, par ->
        if i < Process.get(:t) do
          r = Enum.at(par, key, [])
          value = Enum.at(buf, key, [])
          buf = List.replace_at(buf, key, round_dec(r * value * (1.0 - value), 10))
          new_r = (1.0 * m.time) * 0.01 + r * 1.01
          new_r = new_r - (1.0 * Kernel.trunc(new_r))
          par = List.replace_at(par, key, new_r + 3.0)
          i = i + 1
          while_fun_4.(while_fun_4, buf, par)
        else
          {buf, par}
        end
      end
      {buf, par} = try do
          while_fun_4.(while_fun_4, buf, par)
        catch
          {:break, {buf, par}} -> {buf, par}
        end

      x = Kernel.trunc(Enum.at(buf, rem((key + 2), Process.get(:size)), []) * 10000000000.0)
      y = Kernel.trunc(Enum.at(buf, rem((key + Process.get(:size) - 2), Process.get(:size)), []) * 10000000000.0)
      new_machine = %{buffer: buf, params: par, time: m.time + 1}
      value = rem(xorshift(x, y), 4294967295)
      throw {:return, %{value: value, machine: new_machine}}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:k, [0.33, 0.44, 0.55, 0.44, 0.33])
  Process.put(:t, 3)
  Process.put(:size, 5)
  Process.put(:i, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:machine, reset())
    while_fun_5 = fn while_fun_5 ->
      if Process.get(:i) < 100 do
        Process.put(:machine, push(Process.get(:machine), Process.get(:i)))
        Process.put(:i, Process.get(:i) + 1)
        while_fun_5.(while_fun_5)
      else
        nil
      end
    end
    try do
      while_fun_5.(while_fun_5)
    catch
      :break -> nil
    end

    Process.put(:res, pull(Process.get(:machine)))
    IO.puts(Process.get(:res).value)
    IO.puts(Kernel.inspect(Process.get(:res).machine.buffer))
    IO.puts(Kernel.inspect(Process.get(:res).machine.params))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
