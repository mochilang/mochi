# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      i = 0
      while_fun = fn while_fun, i, p ->
        if i < n do
          p = p * 10.0
          i = i + 1
          while_fun.(while_fun, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun.(while_fun, i, p)
        catch
          {:break, {i, p}} -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def roundn(x, n) do
    try do
      m = pow10(n)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def pad(signal, target) do
    try do
      s = signal
      while_fun_2 = fn while_fun_2, s ->
        if _len(s) < target do
          s = (s ++ [0.0])
          while_fun_2.(while_fun_2, s)
        else
          s
        end
      end
      s = try do
          while_fun_2.(while_fun_2, s)
        catch
          {:break, {s}} -> s
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def circular_convolution(a, b) do
    try do
      n1 = _len(a)
      n2 = _len(b)
      n = (if n1 > n2, do: n1, else: n2)
      x = pad(a, n)
      y = pad(b, n)
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < n do
          sum = 0.0
          k = 0
          while_fun_4 = fn while_fun_4, k, sum ->
            if k < n do
              j = rem((i - k), n)
              idx = (if j < 0, do: j + n, else: j)
              sum = sum + Enum.at(x, k) * Enum.at(y, idx)
              k = k + 1
              while_fun_4.(while_fun_4, k, sum)
            else
              {k, sum}
            end
          end
          {k, sum} = try do
              while_fun_4.(while_fun_4, k, sum)
            catch
              {:break, {k, sum}} -> {k, sum}
            end

          res = (res ++ [roundn(sum, 2)])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:example1, circular_convolution([2.0, 1.0, 2.0, -1.0], [1.0, 2.0, 3.0, 4.0]))
    IO.puts(Kernel.to_string(Process.get(:example1)))
    Process.put(:example2, circular_convolution([0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6], [0.1, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5]))
    IO.puts(Kernel.to_string(Process.get(:example2)))
    Process.put(:example3, circular_convolution([-1.0, 1.0, 2.0, -2.0], [0.5, 1.0, -1.0, 2.0, 0.75]))
    IO.puts(Kernel.to_string(Process.get(:example3)))
    Process.put(:example4, circular_convolution([1.0, -1.0, 2.0, 3.0, -1.0], [1.0, 2.0, 3.0]))
    IO.puts(Kernel.to_string(Process.get(:example4)))
  end
end
Main.main()
