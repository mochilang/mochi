# Code generated by Mochi transpiler 2025-08-13 12:32 +0700
defmodule Main do
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def to_radians(deg) do
    try do
      throw {:return, deg * Process.get(:pi) / 180.0}
    catch
      {:return, val} -> val
    end
  end
  def sin_taylor(x) do
    try do
      term = x
      sum = x
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i))
          k2 = k1 + 1.0
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def cos_taylor(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun_2 = fn while_fun_2, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i)) - 1.0
          k2 = 2.0 * (:erlang.float(i))
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun_2.(while_fun_2, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun_2.(while_fun_2, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def rect(mag, angle) do
    try do
      c = cos_taylor(angle)
      s = sin_taylor(angle)
      throw {:return, [mag * c, mag * s]}
    catch
      {:return, val} -> val
    end
  end
  def multiply(a, b) do
    try do
      throw {:return, [Enum.at(a, 0, []) * Enum.at(b, 0, []) - Enum.at(a, 1, []) * Enum.at(b, 1, []), Enum.at(a, 0, []) * Enum.at(b, 1, []) + Enum.at(a, 1, []) * Enum.at(b, 0, [])]}
    catch
      {:return, val} -> val
    end
  end
  def apparent_power(voltage, current, voltage_angle, current_angle) do
    try do
      vrad = to_radians(voltage_angle)
      irad = to_radians(current_angle)
      vrect = rect(voltage, vrad)
      irect = rect(current, irad)
      result = multiply(vrect, irect)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def approx_equal(a, b, eps) do
    try do
      throw {:return, abs_(Enum.at(a, 0, []) - Enum.at(b, 0, [])) < eps && abs_(Enum.at(a, 1, []) - Enum.at(b, 1, [])) < eps}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  def main() do
  end
end
Main.main()
