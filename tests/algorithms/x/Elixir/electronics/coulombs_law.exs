# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def coulombs_law(force, charge1, charge2, distance) do
    try do
      charge_product = abs_(charge1 * charge2)
      zero_count = 0
      {zero_count} = if force == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if charge1 == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if charge2 == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if distance == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      if zero_count != 1 do
        raise("One and only one argument must be 0")
      end
      if distance < 0.0 do
        raise("Distance cannot be negative")
      end
      if force == 0.0 do
        f = Process.get(:coulombs_constant) * charge_product / (distance * distance)
        throw {:return, %{"force" => f}}
      end
      if charge1 == 0.0 do
        c1 = abs_(force) * (distance * distance) / (Process.get(:coulombs_constant) * charge2)
        throw {:return, %{"charge1" => c1}}
      end
      if charge2 == 0.0 do
        c2 = abs_(force) * (distance * distance) / (Process.get(:coulombs_constant) * charge1)
        throw {:return, %{"charge2" => c2}}
      end
      d = sqrtApprox(Process.get(:coulombs_constant) * charge_product / abs_(force))
      throw {:return, %{"distance" => d}}
    catch
      {:return, val} -> val
    end
  end
  def print_map(m) do
    try do
      Enum.each(Map.keys(m), fn k ->
        IO.puts((((("{\"" <> k) <> "\": ") <> Kernel.to_string(m[k])) <> "}"))
      end)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:coulombs_constant, 8988000000.0)
  def main() do
    print_map(coulombs_law(0.0, 3.0, 5.0, 2000.0))
    print_map(coulombs_law(10.0, 3.0, 5.0, 0.0))
    print_map(coulombs_law(10.0, 0.0, 5.0, 2000.0))
  end
end
Main.main()
