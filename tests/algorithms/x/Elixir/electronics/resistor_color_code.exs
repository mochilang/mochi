# Code generated by Mochi transpiler 2025-08-13 12:32 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def contains(list, value) do
    try do
      Enum.each(list, fn c ->
        if c == value do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def get_significant_digits(colors) do
    try do
      digit = 0
      {digit} = Enum.reduce(colors, {digit}, fn color, {digit} ->
        if !(Map.has_key?(Process.get(:significant_figures_color_values), color)) do
          raise((color <> " is not a valid color for significant figure bands"))
        end
        digit = digit * 10 + Process.get(:significant_figures_color_values)[color]
        {digit}
      end)
      throw {:return, digit}
    catch
      {:return, val} -> val
    end
  end
  def get_multiplier(color) do
    try do
      if !(Map.has_key?(Process.get(:multiplier_color_values), color)) do
        raise((color <> " is not a valid color for multiplier band"))
      end
      throw {:return, Process.get(:multiplier_color_values)[color]}
    catch
      {:return, val} -> val
    end
  end
  def get_tolerance(color) do
    try do
      if !(Map.has_key?(Process.get(:tolerance_color_values), color)) do
        raise((color <> " is not a valid color for tolerance band"))
      end
      throw {:return, Process.get(:tolerance_color_values)[color]}
    catch
      {:return, val} -> val
    end
  end
  def get_temperature_coeffecient(color) do
    try do
      if !(Map.has_key?(Process.get(:temperature_coeffecient_color_values), color)) do
        raise((color <> " is not a valid color for temperature coeffecient band"))
      end
      throw {:return, Process.get(:temperature_coeffecient_color_values)[color]}
    catch
      {:return, val} -> val
    end
  end
  def get_band_type_count(total, typ) do
    try do
      if total == 3 do
        if typ == "significant" do
          throw {:return, 2}
        end
        if typ == "multiplier" do
          throw {:return, 1}
        end
        raise((typ <> " is not valid for a 3 band resistor"))
      else
        if total == 4 do
          if typ == "significant" do
            throw {:return, 2}
          end
          if typ == "multiplier" do
            throw {:return, 1}
          end
          if typ == "tolerance" do
            throw {:return, 1}
          end
          raise((typ <> " is not valid for a 4 band resistor"))
        else
          if total == 5 do
            if typ == "significant" do
              throw {:return, 3}
            end
            if typ == "multiplier" do
              throw {:return, 1}
            end
            if typ == "tolerance" do
              throw {:return, 1}
            end
            raise((typ <> " is not valid for a 5 band resistor"))
          else
            if total == 6 do
              if typ == "significant" do
                throw {:return, 3}
              end
              if typ == "multiplier" do
                throw {:return, 1}
              end
              if typ == "tolerance" do
                throw {:return, 1}
              end
              if typ == "temp_coeffecient" do
                throw {:return, 1}
              end
              raise((typ <> " is not valid for a 6 band resistor"))
            else
              raise((Kernel.to_string(total) <> " is not a valid number of bands"))
            end
          end
        end
      end
    catch
      {:return, val} -> val
    end
  end
  def check_validity(number_of_bands, colors) do
    try do
      if number_of_bands < 3 || number_of_bands > 6 do
        raise("Invalid number of bands. Resistor bands must be 3 to 6")
      end
      if number_of_bands != _len(colors) do
        raise((((("Expecting " <> Kernel.to_string(number_of_bands)) <> " colors, provided ") <> Kernel.inspect(_len(colors))) <> " colors"))
      end
      Enum.each(colors, fn color ->
        if !contains(Process.get(:valid_colors), color) do
          raise((color <> " is not a valid color"))
        end
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def calculate_resistance(number_of_bands, color_code_list) do
    try do
      check_validity(number_of_bands, color_code_list)
      sig_count = get_band_type_count(number_of_bands, "significant")
      significant_colors = _slice(color_code_list, 0, sig_count - 0)
      significant_digits = get_significant_digits(significant_colors)
      multiplier_color = Enum.at(color_code_list, sig_count, [])
      multiplier = get_multiplier(multiplier_color)
      tolerance = 20.0
      {tolerance} = if number_of_bands >= 4 do
        tolerance_color = Enum.at(color_code_list, sig_count + 1, [])
        tolerance = get_tolerance(tolerance_color)
        {tolerance}
      else
        {tolerance}
      end
      temp_coeff = 0
      {temp_coeff} = if number_of_bands == 6 do
        temp_color = Enum.at(color_code_list, sig_count + 2, [])
        temp_coeff = get_temperature_coeffecient(temp_color)
        {temp_coeff}
      else
        {temp_coeff}
      end
      resistance_value = multiplier * significant_digits
      resistance_str = Kernel.to_string(resistance_value)
      {resistance_str} = if resistance_value == Kernel.trunc(resistance_value) do
        resistance_str = Kernel.inspect(Kernel.trunc(resistance_value))
        {resistance_str}
      else
        {resistance_str}
      end
      answer = (((resistance_str <> "Ω ±") <> Kernel.to_string(tolerance)) <> "% ")
      {answer} = if temp_coeff != 0 do
        answer = ((answer <> Kernel.to_string(temp_coeff)) <> " ppm/K")
        {answer}
      else
        {answer}
      end
      throw {:return, answer}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:valid_colors, ["Black", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey", "White", "Gold", "Silver"])
  Process.put(:significant_figures_color_values, %{"Black" => 0, "Brown" => 1, "Red" => 2, "Orange" => 3, "Yellow" => 4, "Green" => 5, "Blue" => 6, "Violet" => 7, "Grey" => 8, "White" => 9})
  Process.put(:multiplier_color_values, %{"Black" => 1.0, "Brown" => 10.0, "Red" => 100.0, "Orange" => 1000.0, "Yellow" => 10000.0, "Green" => 100000.0, "Blue" => 1000000.0, "Violet" => 10000000.0, "Grey" => 100000000.0, "White" => 1000000000.0, "Gold" => 0.1, "Silver" => 0.01})
  Process.put(:tolerance_color_values, %{"Brown" => 1.0, "Red" => 2.0, "Orange" => 0.05, "Yellow" => 0.02, "Green" => 0.5, "Blue" => 0.25, "Violet" => 0.1, "Grey" => 0.01, "Gold" => 5.0, "Silver" => 10.0})
  Process.put(:temperature_coeffecient_color_values, %{"Black" => 250, "Brown" => 100, "Red" => 50, "Orange" => 15, "Yellow" => 25, "Green" => 20, "Blue" => 10, "Violet" => 5, "Grey" => 1})
  def main() do
  end
end
Main.main()
