# Code generated by Mochi transpiler 2025-08-08 15:59 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  def expApprox(x) do
    try do
      if x < 0.0 do
        throw {:return, 1.0 / expApprox(-x)}
      end
      if x > 1.0 do
        half = expApprox(x / 2.0)
        throw {:return, half * half}
      end
      sum = 1.0
      term = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 20 do
          term = term * x / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      result = 1.0
      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < n do
          result = result * 10.0
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def round(x, n) do
    try do
      m = pow10(n)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def charging_inductor(source_voltage, resistance, inductance, time) do
    try do
      if source_voltage <= 0.0 do
        raise("Source voltage must be positive.")
      end
      if resistance <= 0.0 do
        raise("Resistance must be positive.")
      end
      if inductance <= 0.0 do
        raise("Inductance must be positive.")
      end
      exponent = (-time * resistance) / inductance
      current = source_voltage / resistance * (1.0 - expApprox(exponent))
      throw {:return, round(current, 3)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(charging_inductor(5.8, 1.5, 2.3, 2.0)))
    IO.puts(Kernel.inspect(charging_inductor(8.0, 5.0, 3.0, 2.0)))
    IO.puts(Kernel.inspect(charging_inductor(8.0, 5.0 * pow10(2), 3.0, 2.0)))
  end
end
Main.main()
