# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def odd_sieve(num) do
    try do
      if num <= 2 do
        throw {:return, []}
      end
      if num == 3 do
        throw {:return, [2]}
      end
      size = div(num, 2) - 1
      sieve = []
      idx = 0
      while_fun = fn while_fun, idx, sieve ->
        if idx < size do
          sieve = (sieve ++ [true])
          idx = idx + 1
          while_fun.(while_fun, idx, sieve)
        else
          {idx, sieve}
        end
      end
      {idx, sieve} = try do
          while_fun.(while_fun, idx, sieve)
        catch
          {:break, {idx, sieve}} -> {idx, sieve}
        end

      i = 3
      while_fun_2 = fn while_fun_2, i, sieve ->
        if i * i <= num do
          s_idx = div(i, 2) - 1
          {sieve} = if Enum.at(sieve, s_idx) do
            j = i * i
            while_fun_3 = fn while_fun_3, j, sieve ->
              if j < num do
                j_idx = div(j, 2) - 1
                sieve = List.replace_at(sieve, j_idx, false)
                j = j + 2 * i
                while_fun_3.(while_fun_3, j, sieve)
              else
                {j, sieve}
              end
            end
            {j, sieve} = try do
                while_fun_3.(while_fun_3, j, sieve)
              catch
                {:break, {j, sieve}} -> {j, sieve}
              end

            {sieve}
          else
            {sieve}
          end
          i = i + 2
          while_fun_2.(while_fun_2, i, sieve)
        else
          {i, sieve}
        end
      end
      {i, sieve} = try do
          while_fun_2.(while_fun_2, i, sieve)
        catch
          {:break, {i, sieve}} -> {i, sieve}
        end

      primes = [2]
      n = 3
      k = 0
      while_fun_4 = fn while_fun_4, k, n, primes ->
        if n < num do
          {primes} = if Enum.at(sieve, k) do
            primes = (primes ++ [n])
            {primes}
          else
            {primes}
          end
          n = n + 2
          k = k + 1
          while_fun_4.(while_fun_4, k, n, primes)
        else
          {k, n, primes}
        end
      end
      {k, n, primes} = try do
          while_fun_4.(while_fun_4, k, n, primes)
        catch
          {:break, {k, n, primes}} -> {k, n, primes}
        end

      throw {:return, primes}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(odd_sieve(2)))
    IO.puts(Kernel.inspect(odd_sieve(3)))
    IO.puts(Kernel.inspect(odd_sieve(10)))
    IO.puts(Kernel.inspect(odd_sieve(20)))
  end
end
Main.main()
