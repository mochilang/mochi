# Code generated by Mochi transpiler 2025-08-09 10:14 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def pow_int(base, exp) do
    try do
      result = 1.0
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < exp do
          result = result * base
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def nth_root(x, n) do
    try do
      if x == 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun_2 = fn while_fun_2, guess, i ->
        if i < 10 do
          denom = pow_int(guess, n - 1)
          guess = (:erlang.float((n - 1)) * guess + x / denom) / (:erlang.float(n))
          i = i + 1
          while_fun_2.(while_fun_2, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_2.(while_fun_2, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def round_nearest(x) do
    try do
      if x >= 0.0 do
        n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((x + 0.5))
        throw {:return, :erlang.float(n)}
      end
      n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((x - 0.5))
      throw {:return, :erlang.float(n)}
    catch
      {:return, val} -> val
    end
  end
  def compute_geometric_mean(nums) do
    try do
      if _len(nums) == 0 do
        raise("no numbers")
      end
      product = 1.0
      i = 0
      while_fun_3 = fn while_fun_3, i, product ->
        if i < _len(nums) do
          product = product * Enum.at(nums, i)
          i = i + 1
          while_fun_3.(while_fun_3, i, product)
        else
          {i, product}
        end
      end
      {i, product} = try do
          while_fun_3.(while_fun_3, i, product)
        catch
          {:break, {i, product}} -> {i, product}
        end

      if product < 0.0 && rem(_len(nums), 2) == 0 do
        raise("Cannot Compute Geometric Mean for these numbers.")
      end
      mean = nth_root(abs_(product), _len(nums))
      {mean} = if product < 0.0 do
        mean = -mean
        {mean}
      else
        {mean}
      end
      possible = round_nearest(mean)
      {mean} = if pow_int(possible, _len(nums)) == product do
        mean = possible
        {mean}
      else
        {mean}
      end
      throw {:return, mean}
    catch
      {:return, val} -> val
    end
  end
  def test_compute_geometric_mean() do
    try do
      eps = 0.0001
      m1 = compute_geometric_mean([2.0, 8.0])
      if abs_(m1 - 4.0) > eps do
        raise("test1 failed")
      end
      m2 = compute_geometric_mean([5.0, 125.0])
      if abs_(m2 - 25.0) > eps do
        raise("test2 failed")
      end
      m3 = compute_geometric_mean([1.0, 0.0])
      if abs_(m3 - 0.0) > eps do
        raise("test3 failed")
      end
      m4 = compute_geometric_mean([1.0, 5.0, 25.0, 5.0])
      if abs_(m4 - 5.0) > eps do
        raise("test4 failed")
      end
      m5 = compute_geometric_mean([-5.0, 25.0, 1.0])
      if abs_(m5 + 5.0) > eps do
        raise("test5 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_compute_geometric_mean()
      IO.puts(Kernel.inspect(compute_geometric_mean([-3.0, -27.0])))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
