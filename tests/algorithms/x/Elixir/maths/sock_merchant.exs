# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sock_merchant(colors) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < _len(colors) do
          arr = (arr ++ [Enum.at(colors, i)])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      a = 0
      while_fun_2 = fn while_fun_2, a, arr ->
        if a < n do
          min_idx = a
          b = a + 1
          while_fun_3 = fn while_fun_3, b, min_idx ->
            if b < n do
              {min_idx} = if Enum.at(arr, b) < Enum.at(arr, min_idx) do
                min_idx = b
                {min_idx}
              else
                {min_idx}
              end
              b = b + 1
              while_fun_3.(while_fun_3, b, min_idx)
            else
              {b, min_idx}
            end
          end
          {b, min_idx} = try do
              while_fun_3.(while_fun_3, b, min_idx)
            catch
              {:break, {b, min_idx}} -> {b, min_idx}
            end

          temp = Enum.at(arr, a)
          arr = List.replace_at(arr, a, Enum.at(arr, min_idx))
          arr = List.replace_at(arr, min_idx, temp)
          a = a + 1
          while_fun_2.(while_fun_2, a, arr)
        else
          {a, arr}
        end
      end
      {a, arr} = try do
          while_fun_2.(while_fun_2, a, arr)
        catch
          {:break, {a, arr}} -> {a, arr}
        end

      pairs = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, pairs ->
        if i < n do
          count = 1
          while_fun_5 = fn while_fun_5, count, i ->
            if i + 1 < n && Enum.at(arr, i) == Enum.at(arr, i + 1) do
              count = count + 1
              i = i + 1
              while_fun_5.(while_fun_5, count, i)
            else
              {count, i}
            end
          end
          {count, i} = try do
              while_fun_5.(while_fun_5, count, i)
            catch
              {:break, {count, i}} -> {count, i}
            end

          pairs = pairs + div(count, 2)
          i = i + 1
          while_fun_4.(while_fun_4, i, pairs)
        else
          {i, pairs}
        end
      end
      {i, pairs} = try do
          while_fun_4.(while_fun_4, i, pairs)
        catch
          {:break, {i, pairs}} -> {i, pairs}
        end

      throw {:return, pairs}
    catch
      {:return, val} -> val
    end
  end
  def test_sock_merchant() do
    try do
      example1 = [10, 20, 20, 10, 10, 30, 50, 10, 20]
      if sock_merchant(example1) != 3 do
        raise("example1 failed")
      end
      example2 = [1, 1, 3, 3]
      if sock_merchant(example2) != 2 do
        raise("example2 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_sock_merchant()
      example1 = [10, 20, 20, 10, 10, 30, 50, 10, 20]
      IO.puts(Kernel.inspect(sock_merchant(example1)))
      example2 = [1, 1, 3, 3]
      IO.puts(Kernel.inspect(sock_merchant(example2)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
