# Code generated by Mochi transpiler 2025-08-17 13:17 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sock_merchant(colors) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < _len(colors) do
          arr = (arr ++ [Enum.at(colors, i, [])])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      a = 0
      while_fun_2 = fn while_fun_2, a, arr ->
        if a < n do
          min_idx = a
          b = a + 1
          while_fun_3 = fn while_fun_3, b, min_idx ->
            if b < n do
              min_idx = if Enum.at(arr, b, []) < Enum.at(arr, min_idx, []) do
                min_idx = b
                min_idx
              else
                min_idx
              end
              b = b + 1
              while_fun_3.(while_fun_3, b, min_idx)
            else
              {b, min_idx}
            end
          end
          {b, min_idx} = try do
              while_fun_3.(while_fun_3, b, min_idx)
            catch
              {:break, {b, min_idx}} -> {b, min_idx}
            end

          temp = Enum.at(arr, a, [])
          arr = List.replace_at(arr, a, Enum.at(arr, min_idx, []))
          arr = List.replace_at(arr, min_idx, temp)
          a = a + 1
          while_fun_2.(while_fun_2, a, arr)
        else
          {a, arr}
        end
      end
      {a, arr} = try do
          while_fun_2.(while_fun_2, a, arr)
        catch
          {:break, {a, arr}} -> {a, arr}
        end

      pairs = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, pairs ->
        if i < n do
          count = 1
          while_fun_5 = fn while_fun_5, count, i ->
            if i + 1 < n && Enum.at(arr, i, []) == Enum.at(arr, i + 1, []) do
              count = count + 1
              i = i + 1
              while_fun_5.(while_fun_5, count, i)
            else
              {count, i}
            end
          end
          {count, i} = try do
              while_fun_5.(while_fun_5, count, i)
            catch
              {:break, {count, i}} -> {count, i}
            end

          pairs = pairs + div(count, 2)
          i = i + 1
          while_fun_4.(while_fun_4, i, pairs)
        else
          {i, pairs}
        end
      end
      {i, pairs} = try do
          while_fun_4.(while_fun_4, i, pairs)
        catch
          {:break, {i, pairs}} -> {i, pairs}
        end

      throw {:return, pairs}
    catch
      {:return, val} -> val
    end
  end
  def test_sock_merchant() do
    try do
      example1 = [10, 20, 20, 10, 10, 30, 50, 10, 20]
      if sock_merchant(example1) != 3 do
        raise("example1 failed")
      end
      example2 = [1, 1, 3, 3]
      if sock_merchant(example2) != 2 do
        raise("example2 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_sock_merchant()
      example1 = [10, 20, 20, 10, 10, 30, 50, 10, 20]
      IO.puts(Kernel.inspect(sock_merchant(example1)))
      example2 = [1, 1, 3, 3]
      IO.puts(Kernel.inspect(sock_merchant(example2)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
