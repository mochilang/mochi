# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  def binary_exp_recursive(base, exponent) do
    try do
      if exponent < 0 do
        raise("exponent must be non-negative")
      end
      if exponent == 0 do
        throw {:return, 1.0}
      end
      if rem(exponent, 2) == 1 do
        throw {:return, binary_exp_recursive(base, exponent - 1) * base}
      end
      half = binary_exp_recursive(base, div(exponent, 2))
      throw {:return, half * half}
    catch
      {:return, val} -> val
    end
  end
  def binary_exp_iterative(base, exponent) do
    try do
      if exponent < 0 do
        raise("exponent must be non-negative")
      end
      result = 1.0
      b = base
      e = exponent
      while_fun = fn while_fun, b, e, result ->
        if e > 0 do
          {result} = if rem(e, 2) == 1 do
            result = result * b
            {result}
          else
            {result}
          end
          b = b * b
          e = div(e, 2)
          while_fun.(while_fun, b, e, result)
        else
          {b, e, result}
        end
      end
      {b, e, result} = try do
          while_fun.(while_fun, b, e, result)
        catch
          {:break, {b, e, result}} -> {b, e, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def binary_exp_mod_recursive(base, exponent, modulus) do
    try do
      if exponent < 0 do
        raise("exponent must be non-negative")
      end
      if modulus <= 0 do
        raise("modulus must be positive")
      end
      if exponent == 0 do
        throw {:return, rem(1, modulus)}
      end
      if rem(exponent, 2) == 1 do
        throw {:return, rem((binary_exp_mod_recursive(base, exponent - 1, modulus) * (rem(base, modulus))), modulus)}
      end
      r = binary_exp_mod_recursive(base, div(exponent, 2), modulus)
      throw {:return, rem((r * r), modulus)}
    catch
      {:return, val} -> val
    end
  end
  def binary_exp_mod_iterative(base, exponent, modulus) do
    try do
      if exponent < 0 do
        raise("exponent must be non-negative")
      end
      if modulus <= 0 do
        raise("modulus must be positive")
      end
      result = rem(1, modulus)
      b = rem(base, modulus)
      e = exponent
      while_fun_2 = fn while_fun_2, b, e, result ->
        if e > 0 do
          {result} = if rem(e, 2) == 1 do
            result = rem((result * b), modulus)
            {result}
          else
            {result}
          end
          b = rem((b * b), modulus)
          e = div(e, 2)
          while_fun_2.(while_fun_2, b, e, result)
        else
          {b, e, result}
        end
      end
      {b, e, result} = try do
          while_fun_2.(while_fun_2, b, e, result)
        catch
          {:break, {b, e, result}} -> {b, e, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(binary_exp_recursive(3.0, 5)))
    IO.puts(Kernel.inspect(binary_exp_iterative(1.5, 4)))
    IO.puts(Kernel.inspect(binary_exp_mod_recursive(3, 4, 5)))
    IO.puts(Kernel.inspect(binary_exp_mod_iterative(11, 13, 7)))
  end
end
Main.main()
