# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      i = 0
      while_fun = fn while_fun, i, p ->
        if i < n do
          p = p * 10.0
          i = i + 1
          while_fun.(while_fun, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun.(while_fun, i, p)
        catch
          {:break, {i, p}} -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def round(x, n) do
    try do
      m = pow10(n)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def clone_matrix(mat) do
    try do
      new_mat = []
      i = 0
      while_fun_2 = fn while_fun_2, i, new_mat ->
        if i < _len(mat) do
          row = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row ->
            if j < _len(Enum.at(mat, i)) do
              row = (row ++ [Enum.at(Enum.at(mat, i), j)])
              j = j + 1
              while_fun_3.(while_fun_3, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_3.(while_fun_3, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          new_mat = (new_mat ++ [row])
          i = i + 1
          while_fun_2.(while_fun_2, i, new_mat)
        else
          {i, new_mat}
        end
      end
      {i, new_mat} = try do
          while_fun_2.(while_fun_2, i, new_mat)
        catch
          {:break, {i, new_mat}} -> {i, new_mat}
        end

      throw {:return, new_mat}
    catch
      {:return, val} -> val
    end
  end
  def solve_simultaneous(equations) do
    try do
      n = _len(equations)
      if n == 0 do
        raise("solve_simultaneous() requires n lists of length n+1")
      end
      m = n + 1
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < n do
          if _len(Enum.at(equations, i)) != m do
            raise("solve_simultaneous() requires n lists of length n+1")
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      a = clone_matrix(equations)
      row = 0
      while_fun_5 = fn while_fun_5, a, row ->
        if row < n do
          pivot = row
          while_fun_6 = fn while_fun_6, pivot ->
            if pivot < n && Enum.at(Enum.at(a, pivot), row) == 0.0 do
              pivot = pivot + 1
              while_fun_6.(while_fun_6, pivot)
            else
              pivot
            end
          end
          pivot = try do
              while_fun_6.(while_fun_6, pivot)
            catch
              {:break, {pivot}} -> pivot
            end

          if pivot == n do
            raise("solve_simultaneous() requires at least 1 full equation")
          end
          {a} = if pivot != row do
            temp = Enum.at(a, row)
            a = List.replace_at(a, row, Enum.at(a, pivot))
            a = List.replace_at(a, pivot, temp)
            {a}
          else
            {a}
          end
          pivot_val = Enum.at(Enum.at(a, row), row)
          col = 0
          while_fun_7 = fn while_fun_7, a, col ->
            if col < m do
              a = List.replace_at(a, row, List.replace_at(Enum.at(a, row), col, Enum.at(Enum.at(a, row), col) / pivot_val))
              col = col + 1
              while_fun_7.(while_fun_7, a, col)
            else
              {a, col}
            end
          end
          {a, col} = try do
              while_fun_7.(while_fun_7, a, col)
            catch
              {:break, {a, col}} -> {a, col}
            end

          r = 0
          while_fun_8 = fn while_fun_8, a, r ->
            if r < n do
              {a} = if r != row do
                factor = Enum.at(Enum.at(a, r), row)
                c = 0
                while_fun_9 = fn while_fun_9, a, c ->
                  if c < m do
                    a = List.replace_at(a, r, List.replace_at(Enum.at(a, r), c, Enum.at(Enum.at(a, r), c) - factor * Enum.at(Enum.at(a, row), c)))
                    c = c + 1
                    while_fun_9.(while_fun_9, a, c)
                  else
                    {a, c}
                  end
                end
                {a, c} = try do
                    while_fun_9.(while_fun_9, a, c)
                  catch
                    {:break, {a, c}} -> {a, c}
                  end

                {a}
              else
                {a}
              end
              r = r + 1
              while_fun_8.(while_fun_8, a, r)
            else
              {a, r}
            end
          end
          {a, r} = try do
              while_fun_8.(while_fun_8, a, r)
            catch
              {:break, {a, r}} -> {a, r}
            end

          row = row + 1
          while_fun_5.(while_fun_5, a, row)
        else
          {a, row}
        end
      end
      {a, row} = try do
          while_fun_5.(while_fun_5, a, row)
        catch
          {:break, {a, row}} -> {a, row}
        end

      res = []
      k = 0
      while_fun_10 = fn while_fun_10, k, res ->
        if k < n do
          res = (res ++ [round(Enum.at(Enum.at(a, k), m - 1), 5)])
          k = k + 1
          while_fun_10.(while_fun_10, k, res)
        else
          {k, res}
        end
      end
      {k, res} = try do
          while_fun_10.(while_fun_10, k, res)
        catch
          {:break, {k, res}} -> {k, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def test_solver() do
    try do
      a = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
      r1 = solve_simultaneous(a)
      if !(_len(r1) == 2 && Enum.at(r1, 0) == (0.0 - 1.0) && Enum.at(r1, 1) == 2.0) do
        raise("test1 failed")
      end
      b = [[0.0, (0.0 - 3.0), 1.0, 7.0], [3.0, 2.0, (0.0 - 1.0), 11.0], [5.0, 1.0, (0.0 - 2.0), 12.0]]
      r2 = solve_simultaneous(b)
      if !(_len(r2) == 3 && Enum.at(r2, 0) == 6.4 && Enum.at(r2, 1) == 1.2 && Enum.at(r2, 2) == 10.6) do
        raise("test2 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_solver()
      eq = [[2.0, 1.0, 1.0, 1.0, 1.0, 4.0], [1.0, 2.0, 1.0, 1.0, 1.0, 5.0], [1.0, 1.0, 2.0, 1.0, 1.0, 6.0], [1.0, 1.0, 1.0, 2.0, 1.0, 7.0], [1.0, 1.0, 1.0, 1.0, 2.0, 8.0]]
      IO.puts(Kernel.inspect(solve_simultaneous(eq)))
      IO.puts(Kernel.inspect(solve_simultaneous([[4.0, 2.0]])))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
