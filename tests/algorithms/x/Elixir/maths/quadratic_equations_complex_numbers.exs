# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def add(a, b) do
    try do
      throw {:return, %{re: a.re + b.re, im: a.im + b.im}}
    catch
      {:return, val} -> val
    end
  end
  def sub(a, b) do
    try do
      throw {:return, %{re: a.re - b.re, im: a.im - b.im}}
    catch
      {:return, val} -> val
    end
  end
  def div_real(a, r) do
    try do
      throw {:return, %{re: a.re / r, im: a.im / r}}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_newton(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_to_complex(d) do
    try do
      throw {:return, ((if d >= 0.0, do: %{re: sqrt_newton(d), im: 0.0}, else: %{re: 0.0, im: sqrt_newton(-d)}))}
    catch
      {:return, val} -> val
    end
  end
  def quadratic_roots(a, b, c) do
    try do
      if a == 0.0 do
        IO.puts("ValueError: coefficient 'a' must not be zero")
        throw {:return, []}
      end
      delta = b * b - 4.0 * a * c
      sqrt_d = sqrt_to_complex(delta)
      minus_b = %{re: -b, im: 0.0}
      two_a = 2.0 * a
      root1 = div_real(add(minus_b, sqrt_d), two_a)
      root2 = div_real(sub(minus_b, sqrt_d), two_a)
      throw {:return, [root1, root2]}
    catch
      {:return, val} -> val
    end
  end
  def root_str(r) do
    try do
      if r.im == 0.0 do
        throw {:return, Kernel.to_string(r.re)}
      end
      s = Kernel.to_string(r.re)
      s = (if r.im >= 0.0, do: (((s <> "+") <> Kernel.to_string(r.im)) <> "i"), else: ((s <> Kernel.to_string(r.im)) <> "i"))
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      roots = quadratic_roots(5.0, 6.0, 1.0)
      if _len(roots) == 2 do
        IO.puts(((("The solutions are: " <> root_str(Enum.at(roots, 0))) <> " and ") <> root_str(Enum.at(roots, 1))))
      end
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
