# Code generated by Mochi transpiler 2025-08-12 07:47 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def contains(xs, value) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == value do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def jaccard_similarity(set_a, set_b, alternative_union) do
    try do
      intersection_len = 0
      i = 0
      while_fun_2 = fn while_fun_2, i, intersection_len ->
        if i < _len(set_a) do
          {intersection_len} = if contains(set_b, Enum.at(set_a, i, [])) do
            intersection_len = intersection_len + 1
            {intersection_len}
          else
            {intersection_len}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, intersection_len)
        else
          {i, intersection_len}
        end
      end
      {i, intersection_len} = try do
          while_fun_2.(while_fun_2, i, intersection_len)
        catch
          {:break, {i, intersection_len}} -> {i, intersection_len}
        end

      union_len = 0
      {i, union_len} = if alternative_union do
        union_len = _len(set_a) + _len(set_b)
        {i, union_len}
      else
        union_list = []
        i = 0
        while_fun_3 = fn while_fun_3, i, union_list ->
          if i < _len(set_a) do
            val_a = Enum.at(set_a, i, [])
            {union_list} = if !contains(union_list, val_a) do
              union_list = (union_list ++ [val_a])
              {union_list}
            else
              {union_list}
            end
            i = i + 1
            while_fun_3.(while_fun_3, i, union_list)
          else
            {i, union_list}
          end
        end
        {i, union_list} = try do
            while_fun_3.(while_fun_3, i, union_list)
          catch
            {:break, {i, union_list}} -> {i, union_list}
          end

        i = 0
        while_fun_4 = fn while_fun_4, i, union_list ->
          if i < _len(set_b) do
            val_b = Enum.at(set_b, i, [])
            {union_list} = if !contains(union_list, val_b) do
              union_list = (union_list ++ [val_b])
              {union_list}
            else
              {union_list}
            end
            i = i + 1
            while_fun_4.(while_fun_4, i, union_list)
          else
            {i, union_list}
          end
        end
        {i, union_list} = try do
            while_fun_4.(while_fun_4, i, union_list)
          catch
            {:break, {i, union_list}} -> {i, union_list}
          end

        union_len = _len(union_list)
        {i, union_len}
      end
      throw {:return, 1.0 * intersection_len / union_len}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      set_a = ["a", "b", "c", "d", "e"]
      set_b = ["c", "d", "e", "f", "h", "i"]
      IO.puts(Kernel.inspect(jaccard_similarity(set_a, set_b, false)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
