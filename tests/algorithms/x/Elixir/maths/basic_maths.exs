# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow_int(base, exp) do
    try do
      result = 1
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < exp do
          result = result * base
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def prime_factors(n) do
    try do
      if n <= 0 do
        raise("Only positive integers have prime factors")
      end
      num = n
      pf = []
      while_fun_2 = fn while_fun_2, num, pf ->
        if rem(num, 2) == 0 do
          pf = (pf ++ [2])
          num = div(num, 2)
          while_fun_2.(while_fun_2, num, pf)
        else
          {num, pf}
        end
      end
      {num, pf} = try do
          while_fun_2.(while_fun_2, num, pf)
        catch
          {:break, {num, pf}} -> {num, pf}
        end

      i = 3
      while_fun_3 = fn while_fun_3, i, num, pf ->
        if i * i <= num do
          while_fun_4 = fn while_fun_4, num, pf ->
            if rem(num, i) == 0 do
              pf = (pf ++ [i])
              num = div(num, i)
              while_fun_4.(while_fun_4, num, pf)
            else
              {num, pf}
            end
          end
          {num, pf} = try do
              while_fun_4.(while_fun_4, num, pf)
            catch
              {:break, {num, pf}} -> {num, pf}
            end

          i = i + 2
          while_fun_3.(while_fun_3, i, num, pf)
        else
          {i, num, pf}
        end
      end
      {i, num, pf} = try do
          while_fun_3.(while_fun_3, i, num, pf)
        catch
          {:break, {i, num, pf}} -> {i, num, pf}
        end

      {pf} = if num > 2 do
        pf = (pf ++ [num])
        {pf}
      else
        {pf}
      end
      throw {:return, pf}
    catch
      {:return, val} -> val
    end
  end
  def number_of_divisors(n) do
    try do
      if n <= 0 do
        raise("Only positive numbers are accepted")
      end
      num = n
      div_ = 1
      temp = 1
      while_fun_5 = fn while_fun_5, num, temp ->
        if rem(num, 2) == 0 do
          temp = temp + 1
          num = div(num, 2)
          while_fun_5.(while_fun_5, num, temp)
        else
          {num, temp}
        end
      end
      {num, temp} = try do
          while_fun_5.(while_fun_5, num, temp)
        catch
          {:break, {num, temp}} -> {num, temp}
        end

      div_ = div_ * temp
      i = 3
      while_fun_6 = fn while_fun_6, div_, i, num, temp ->
        if i * i <= num do
          temp = 1
          while_fun_7 = fn while_fun_7, num, temp ->
            if rem(num, i) == 0 do
              temp = temp + 1
              num = div(num, i)
              while_fun_7.(while_fun_7, num, temp)
            else
              {num, temp}
            end
          end
          {num, temp} = try do
              while_fun_7.(while_fun_7, num, temp)
            catch
              {:break, {num, temp}} -> {num, temp}
            end

          div_ = div_ * temp
          i = i + 2
          while_fun_6.(while_fun_6, div_, i, num, temp)
        else
          {div_, i, num, temp}
        end
      end
      {div_, i, num, temp} = try do
          while_fun_6.(while_fun_6, div_, i, num, temp)
        catch
          {:break, {div_, i, num, temp}} -> {div_, i, num, temp}
        end

      {div_} = if num > 1 do
        div_ = div_ * 2
        {div_}
      else
        {div_}
      end
      throw {:return, div_}
    catch
      {:return, val} -> val
    end
  end
  def sum_of_divisors(n) do
    try do
      if n <= 0 do
        raise("Only positive numbers are accepted")
      end
      num = n
      s = 1
      temp = 1
      while_fun_8 = fn while_fun_8, num, temp ->
        if rem(num, 2) == 0 do
          temp = temp + 1
          num = div(num, 2)
          while_fun_8.(while_fun_8, num, temp)
        else
          {num, temp}
        end
      end
      {num, temp} = try do
          while_fun_8.(while_fun_8, num, temp)
        catch
          {:break, {num, temp}} -> {num, temp}
        end

      {s} = if temp > 1 do
        s = s * (div((pow_int(2, temp) - 1), (2 - 1)))
        {s}
      else
        {s}
      end
      i = 3
      while_fun_9 = fn while_fun_9, i, num, s, temp ->
        if i * i <= num do
          temp = 1
          while_fun_10 = fn while_fun_10, num, temp ->
            if rem(num, i) == 0 do
              temp = temp + 1
              num = div(num, i)
              while_fun_10.(while_fun_10, num, temp)
            else
              {num, temp}
            end
          end
          {num, temp} = try do
              while_fun_10.(while_fun_10, num, temp)
            catch
              {:break, {num, temp}} -> {num, temp}
            end

          {s} = if temp > 1 do
            s = s * (div((pow_int(i, temp) - 1), (i - 1)))
            {s}
          else
            {s}
          end
          i = i + 2
          while_fun_9.(while_fun_9, i, num, s, temp)
        else
          {i, num, s, temp}
        end
      end
      {i, num, s, temp} = try do
          while_fun_9.(while_fun_9, i, num, s, temp)
        catch
          {:break, {i, num, s, temp}} -> {i, num, s, temp}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def contains(arr, x) do
    try do
      idx = 0
      while_fun_11 = fn while_fun_11, idx ->
        if idx < _len(arr) do
          if Enum.at(arr, idx) == x do
            throw {:return, true}
          end
          idx = idx + 1
          while_fun_11.(while_fun_11, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_11.(while_fun_11, idx)
        catch
          {:break, {idx}} -> idx
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def unique(arr) do
    try do
      result = []
      idx = 0
      while_fun_12 = fn while_fun_12, idx, result ->
        if idx < _len(arr) do
          v = Enum.at(arr, idx)
          {result} = if !contains(result, v) do
            result = (result ++ [v])
            {result}
          else
            {result}
          end
          idx = idx + 1
          while_fun_12.(while_fun_12, idx, result)
        else
          {idx, result}
        end
      end
      {idx, result} = try do
          while_fun_12.(while_fun_12, idx, result)
        catch
          {:break, {idx, result}} -> {idx, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def euler_phi(n) do
    try do
      if n <= 0 do
        raise("Only positive numbers are accepted")
      end
      s = n
      factors = unique(prime_factors(n))
      idx = 0
      while_fun_13 = fn while_fun_13, idx, s ->
        if idx < _len(factors) do
          x = Enum.at(factors, idx)
          s = (div(s, x)) * (x - 1)
          idx = idx + 1
          while_fun_13.(while_fun_13, idx, s)
        else
          {idx, s}
        end
      end
      {idx, s} = try do
          while_fun_13.(while_fun_13, idx, s)
        catch
          {:break, {idx, s}} -> {idx, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(prime_factors(100)))
    IO.puts(Kernel.inspect(number_of_divisors(100)))
    IO.puts(Kernel.inspect(sum_of_divisors(100)))
    IO.puts(Kernel.inspect(euler_phi(100)))
  end
end
Main.main()
