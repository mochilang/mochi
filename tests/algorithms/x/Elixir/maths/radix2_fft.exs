# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def c_add(a, b) do
    try do
      throw {:return, %{re: a.re + b.re, im: a.im + b.im}}
    catch
      {:return, val} -> val
    end
  end
  def c_sub(a, b) do
    try do
      throw {:return, %{re: a.re - b.re, im: a.im - b.im}}
    catch
      {:return, val} -> val
    end
  end
  def c_mul(a, b) do
    try do
      throw {:return, %{re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re}}
    catch
      {:return, val} -> val
    end
  end
  def c_mul_scalar(a, s) do
    try do
      throw {:return, %{re: a.re * s, im: a.im * s}}
    catch
      {:return, val} -> val
    end
  end
  def c_div_scalar(a, s) do
    try do
      throw {:return, %{re: a.re / s, im: a.im / s}}
    catch
      {:return, val} -> val
    end
  end
  def sin_taylor(x) do
    try do
      term = x
      sum = x
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i))
          k2 = k1 + 1.0
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def cos_taylor(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun_2 = fn while_fun_2, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i)) - 1.0
          k2 = 2.0 * (:erlang.float(i))
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun_2.(while_fun_2, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun_2.(while_fun_2, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def exp_i(theta) do
    try do
      throw {:return, %{re: cos_taylor(theta), im: sin_taylor(theta)}}
    catch
      {:return, val} -> val
    end
  end
  def make_complex_list(n, value) do
    try do
      arr = []
      i = 0
      while_fun_3 = fn while_fun_3, arr, i ->
        if i < n do
          arr = (arr ++ [value])
          i = i + 1
          while_fun_3.(while_fun_3, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_3.(while_fun_3, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def fft(a, invert) do
    try do
      n = _len(a)
      if n == 1 do
        throw {:return, [Enum.at(a, 0)]}
      end
      a0 = []
      a1 = []
      i = 0
      while_fun_4 = fn while_fun_4, a0, a1, i ->
        if i < div(n, 2) do
          a0 = (a0 ++ [Enum.at(a, 2 * i)])
          a1 = (a1 ++ [Enum.at(a, 2 * i + 1)])
          i = i + 1
          while_fun_4.(while_fun_4, a0, a1, i)
        else
          {a0, a1, i}
        end
      end
      {a0, a1, i} = try do
          while_fun_4.(while_fun_4, a0, a1, i)
        catch
          {:break, {a0, a1, i}} -> {a0, a1, i}
        end

      y0 = fft(a0, invert)
      y1 = fft(a1, invert)
      angle = 2.0 * Process.get(:pi) / (:erlang.float(n)) * ((if invert, do: -1.0, else: 1.0))
      w = %{re: 1.0, im: 0.0}
      wn = exp_i(angle)
      y = make_complex_list(n, %{re: 0.0, im: 0.0})
      i = 0
      while_fun_5 = fn while_fun_5, i, w, y ->
        if i < div(n, 2) do
          t = c_mul(w, Enum.at(y1, i))
          u = Enum.at(y0, i)
          even = c_add(u, t)
          odd = c_sub(u, t)
          {even, odd} = if invert do
            even = c_div_scalar(even, 2.0)
            odd = c_div_scalar(odd, 2.0)
            {even, odd}
          else
            {even, odd}
          end
          y = List.replace_at(y, i, even)
          y = List.replace_at(y, i + div(n, 2), odd)
          w = c_mul(w, wn)
          i = i + 1
          while_fun_5.(while_fun_5, i, w, y)
        else
          {i, w, y}
        end
      end
      {i, w, y} = try do
          while_fun_5.(while_fun_5, i, w, y)
        catch
          {:break, {i, w, y}} -> {i, w, y}
        end

      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      i = 0
      while_fun_6 = fn while_fun_6, i, p ->
        if i < n do
          p = p * 10.0
          i = i + 1
          while_fun_6.(while_fun_6, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun_6.(while_fun_6, i, p)
        catch
          {:break, {i, p}} -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def round_to(x, ndigits) do
    try do
      m = pow10(ndigits)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(l) do
    try do
      s = "["
      i = 0
      while_fun_7 = fn while_fun_7, i, s ->
        if i < _len(l) do
          s = (s <> Kernel.to_string(Enum.at(l, i)))
          {s} = if i + 1 < _len(l) do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_7.(while_fun_7, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def multiply_poly(a, b) do
    try do
      n = 1
      while_fun_8 = fn while_fun_8, n ->
        if n < _len(a) + _len(b) - 1 do
          n = n * 2
          while_fun_8.(while_fun_8, n)
        else
          n
        end
      end
      n = try do
          while_fun_8.(while_fun_8, n)
        catch
          {:break, {n}} -> n
        end

      fa = make_complex_list(n, %{re: 0.0, im: 0.0})
      fb = make_complex_list(n, %{re: 0.0, im: 0.0})
      i = 0
      while_fun_9 = fn while_fun_9, fa, i ->
        if i < _len(a) do
          fa = List.replace_at(fa, i, %{re: Enum.at(a, i), im: 0.0})
          i = i + 1
          while_fun_9.(while_fun_9, fa, i)
        else
          {fa, i}
        end
      end
      {fa, i} = try do
          while_fun_9.(while_fun_9, fa, i)
        catch
          {:break, {fa, i}} -> {fa, i}
        end

      i = 0
      while_fun_10 = fn while_fun_10, fb, i ->
        if i < _len(b) do
          fb = List.replace_at(fb, i, %{re: Enum.at(b, i), im: 0.0})
          i = i + 1
          while_fun_10.(while_fun_10, fb, i)
        else
          {fb, i}
        end
      end
      {fb, i} = try do
          while_fun_10.(while_fun_10, fb, i)
        catch
          {:break, {fb, i}} -> {fb, i}
        end

      fa = fft(fa, false)
      fb = fft(fb, false)
      i = 0
      while_fun_11 = fn while_fun_11, fa, i ->
        if i < n do
          fa = List.replace_at(fa, i, c_mul(Enum.at(fa, i), Enum.at(fb, i)))
          i = i + 1
          while_fun_11.(while_fun_11, fa, i)
        else
          {fa, i}
        end
      end
      {fa, i} = try do
          while_fun_11.(while_fun_11, fa, i)
        catch
          {:break, {fa, i}} -> {fa, i}
        end

      fa = fft(fa, true)
      res = []
      i = 0
      while_fun_12 = fn while_fun_12, i, res ->
        if i < _len(a) + _len(b) - 1 do
          val = Enum.at(fa, i)
          res = (res ++ [round_to(val.re, 8)])
          i = i + 1
          while_fun_12.(while_fun_12, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_12.(while_fun_12, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      while_fun_13 = fn while_fun_13, res ->
        if _len(res) > 0 && Enum.at(res, _len(res) - 1) == 0.0 do
          res = _slice(res, 0, (_len(res) - 1) - 0)
          while_fun_13.(while_fun_13, res)
        else
          res
        end
      end
      res = try do
          while_fun_13.(while_fun_13, res)
        catch
          {:break, {res}} -> res
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:a, [0.0, 1.0, 0.0, 2.0])
  Process.put(:b, [2.0, 3.0, 4.0, 0.0])
  def main() do
    Process.put(:product, multiply_poly(Process.get(:a), Process.get(:b)))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:product))))
  end
end
Main.main()
