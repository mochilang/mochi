# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_int(x) do
    try do
      throw {:return, ((if x < 0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def gcd_iter(a, b) do
    try do
      x = abs_int(a)
      y = abs_int(b)
      while_fun = fn while_fun, x, y ->
        if y != 0 do
          t = y
          y = rem(x, y)
          x = t
          while_fun.(while_fun, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun.(while_fun, x, y)
        catch
          {:break, {x, y}} -> {x, y}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def is_prime(n) do
    try do
      if n <= 1 do
        throw {:return, false}
      end
      d = 2
      while_fun_2 = fn while_fun_2, d ->
        if d * d <= n do
          if rem(n, d) == 0 do
            throw {:return, false}
          end
          d = d + 1
          while_fun_2.(while_fun_2, d)
        else
          d
        end
      end
      d = try do
          while_fun_2.(while_fun_2, d)
        catch
          {:break, {d}} -> d
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def sieve_er(n) do
    try do
      nums = []
      i = 2
      while_fun_3 = fn while_fun_3, i, nums ->
        if i <= n do
          nums = (nums ++ [i])
          i = i + 1
          while_fun_3.(while_fun_3, i, nums)
        else
          {i, nums}
        end
      end
      {i, nums} = try do
          while_fun_3.(while_fun_3, i, nums)
        catch
          {:break, {i, nums}} -> {i, nums}
        end

      idx = 0
      while_fun_4 = fn while_fun_4, idx, nums ->
        if idx < _len(nums) do
          j = idx + 1
          while_fun_5 = fn while_fun_5, j, nums ->
            if j < _len(nums) do
              {nums} = if Enum.at(nums, idx) != 0 do
                {nums} = if rem(Enum.at(nums, j), Enum.at(nums, idx)) == 0 do
                  nums = List.replace_at(nums, j, 0)
                  {nums}
                else
                  {nums}
                end
                {nums}
              else
                {nums}
              end
              j = j + 1
              while_fun_5.(while_fun_5, j, nums)
            else
              {j, nums}
            end
          end
          {j, nums} = try do
              while_fun_5.(while_fun_5, j, nums)
            catch
              {:break, {j, nums}} -> {j, nums}
            end

          idx = idx + 1
          while_fun_4.(while_fun_4, idx, nums)
        else
          {idx, nums}
        end
      end
      {idx, nums} = try do
          while_fun_4.(while_fun_4, idx, nums)
        catch
          {:break, {idx, nums}} -> {idx, nums}
        end

      res = []
      k = 0
      while_fun_6 = fn while_fun_6, k, res ->
        if k < _len(nums) do
          v = Enum.at(nums, k)
          {res} = if v != 0 do
            res = (res ++ [v])
            {res}
          else
            {res}
          end
          k = k + 1
          while_fun_6.(while_fun_6, k, res)
        else
          {k, res}
        end
      end
      {k, res} = try do
          while_fun_6.(while_fun_6, k, res)
        catch
          {:break, {k, res}} -> {k, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def get_prime_numbers(n) do
    try do
      ans = []
      num = 2
      while_fun_7 = fn while_fun_7, ans, num ->
        if num <= n do
          {ans} = if is_prime(num) do
            ans = (ans ++ [num])
            {ans}
          else
            {ans}
          end
          num = num + 1
          while_fun_7.(while_fun_7, ans, num)
        else
          {ans, num}
        end
      end
      {ans, num} = try do
          while_fun_7.(while_fun_7, ans, num)
        catch
          {:break, {ans, num}} -> {ans, num}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def prime_factorization(number) do
    try do
      if number == 0 do
        throw {:return, [0]}
      end
      if number == 1 do
        throw {:return, [1]}
      end
      ans = []
      {ans} = if is_prime(number) do
        ans = (ans ++ [number])
        throw {:return, ans}
        {ans}
      else
        {ans}
      end
      quotient = number
      factor = 2
      while_fun_8 = fn while_fun_8, ans, factor, quotient ->
        if quotient != 1 do
          {ans, factor, quotient} = if is_prime(factor) && rem(quotient, factor) == 0 do
            ans = (ans ++ [factor])
            quotient = div(quotient, factor)
            {ans, factor, quotient}
          else
            factor = factor + 1
            {ans, factor, quotient}
          end
          while_fun_8.(while_fun_8, ans, factor, quotient)
        else
          {ans, factor, quotient}
        end
      end
      {ans, factor, quotient} = try do
          while_fun_8.(while_fun_8, ans, factor, quotient)
        catch
          {:break, {ans, factor, quotient}} -> {ans, factor, quotient}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def greatest_prime_factor(number) do
    try do
      factors = prime_factorization(number)
      m = Enum.at(factors, 0)
      i = 1
      while_fun_9 = fn while_fun_9, i, m ->
        if i < _len(factors) do
          {m} = if Enum.at(factors, i) > m do
            m = Enum.at(factors, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_9.(while_fun_9, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_9.(while_fun_9, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def smallest_prime_factor(number) do
    try do
      factors = prime_factorization(number)
      m = Enum.at(factors, 0)
      i = 1
      while_fun_10 = fn while_fun_10, i, m ->
        if i < _len(factors) do
          {m} = if Enum.at(factors, i) < m do
            m = Enum.at(factors, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_10.(while_fun_10, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_10.(while_fun_10, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def kg_v(number1, number2) do
    try do
      if number1 < 1 || number2 < 1 do
        raise("numbers must be positive")
      end
      g = gcd_iter(number1, number2)
      throw {:return, (div(number1, g)) * number2}
    catch
      {:return, val} -> val
    end
  end
  def is_even(number) do
    try do
      throw {:return, rem(number, 2) == 0}
    catch
      {:return, val} -> val
    end
  end
  def is_odd(number) do
    try do
      throw {:return, rem(number, 2) != 0}
    catch
      {:return, val} -> val
    end
  end
  def goldbach(number) do
    try do
      if !is_even(number) || number <= 2 do
        raise("number must be even and > 2")
      end
      primes = get_prime_numbers(number)
      i = 0
      while_fun_11 = fn while_fun_11, i ->
        if i < _len(primes) do
          j = i + 1
          while_fun_12 = fn while_fun_12, j ->
            if j < _len(primes) do
              if Enum.at(primes, i) + Enum.at(primes, j) == number do
                throw {:return, [Enum.at(primes, i), Enum.at(primes, j)]}
              end
              j = j + 1
              while_fun_12.(while_fun_12, j)
            else
              j
            end
          end
          j = try do
              while_fun_12.(while_fun_12, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_11.(while_fun_11, i)
        else
          i
        end
      end
      i = try do
          while_fun_11.(while_fun_11, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  def get_prime(n) do
    try do
      if n < 0 do
        raise("n must be non-negative")
      end
      index = 0
      ans = 2
      while_fun_13 = fn while_fun_13, ans, index ->
        if index < n do
          index = index + 1
          ans = ans + 1
          while_fun_14 = fn while_fun_14, ans ->
            if !is_prime(ans) do
              ans = ans + 1
              while_fun_14.(while_fun_14, ans)
            else
              ans
            end
          end
          ans = try do
              while_fun_14.(while_fun_14, ans)
            catch
              {:break, {ans}} -> ans
            end

          while_fun_13.(while_fun_13, ans, index)
        else
          {ans, index}
        end
      end
      {ans, index} = try do
          while_fun_13.(while_fun_13, ans, index)
        catch
          {:break, {ans, index}} -> {ans, index}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def get_primes_between(p1, p2) do
    try do
      bad1 = !is_prime(p1)
      bad2 = !is_prime(p2)
      if bad1 || bad2 || p1 >= p2 do
        raise("arguments must be prime and p1 < p2")
      end
      num = p1 + 1
      while_fun_15 = fn while_fun_15, num ->
        if num < p2 do
          if is_prime(num) do
            throw {:break, {num}}
          end
          num = num + 1
          while_fun_15.(while_fun_15, num)
        else
          num
        end
      end
      num = try do
          while_fun_15.(while_fun_15, num)
        catch
          {:break, {num}} -> num
        end

      ans = []
      while_fun_16 = fn while_fun_16, ans, num ->
        if num < p2 do
          ans = (ans ++ [num])
          num = num + 1
          while_fun_17 = fn while_fun_17, num ->
            if num < p2 do
              if is_prime(num) do
                throw {:break, {num}}
              end
              num = num + 1
              while_fun_17.(while_fun_17, num)
            else
              num
            end
          end
          num = try do
              while_fun_17.(while_fun_17, num)
            catch
              {:break, {num}} -> num
            end

          while_fun_16.(while_fun_16, ans, num)
        else
          {ans, num}
        end
      end
      {ans, num} = try do
          while_fun_16.(while_fun_16, ans, num)
        catch
          {:break, {ans, num}} -> {ans, num}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def get_divisors(n) do
    try do
      if n < 1 do
        raise("n must be >= 1")
      end
      ans = []
      d = 1
      while_fun_18 = fn while_fun_18, ans, d ->
        if d <= n do
          {ans} = if rem(n, d) == 0 do
            ans = (ans ++ [d])
            {ans}
          else
            {ans}
          end
          d = d + 1
          while_fun_18.(while_fun_18, ans, d)
        else
          {ans, d}
        end
      end
      {ans, d} = try do
          while_fun_18.(while_fun_18, ans, d)
        catch
          {:break, {ans, d}} -> {ans, d}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def is_perfect_number(number) do
    try do
      if number <= 1 do
        raise("number must be > 1")
      end
      divisors = get_divisors(number)
      sum = 0
      i = 0
      while_fun_19 = fn while_fun_19, i, sum ->
        if i < _len(divisors) - 1 do
          sum = sum + Enum.at(divisors, i)
          i = i + 1
          while_fun_19.(while_fun_19, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_19.(while_fun_19, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum == number}
    catch
      {:return, val} -> val
    end
  end
  def simplify_fraction(numerator, denominator) do
    try do
      if denominator == 0 do
        raise("denominator cannot be zero")
      end
      g = gcd_iter(abs_int(numerator), abs_int(denominator))
      throw {:return, [div(numerator, g), div(denominator, g)]}
    catch
      {:return, val} -> val
    end
  end
  def factorial(n) do
    try do
      if n < 0 do
        raise("n must be >= 0")
      end
      ans = 1
      i = 1
      while_fun_20 = fn while_fun_20, ans, i ->
        if i <= n do
          ans = ans * i
          i = i + 1
          while_fun_20.(while_fun_20, ans, i)
        else
          {ans, i}
        end
      end
      {ans, i} = try do
          while_fun_20.(while_fun_20, ans, i)
        catch
          {:break, {ans, i}} -> {ans, i}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def fib(n) do
    try do
      if n < 0 do
        raise("n must be >= 0")
      end
      if n <= 1 do
        throw {:return, 1}
      end
      tmp = 0
      fib1 = 1
      ans = 1
      i = 0
      while_fun_21 = fn while_fun_21, ans, fib1, i, tmp ->
        if i < n - 1 do
          tmp = ans
          ans = ans + fib1
          fib1 = tmp
          i = i + 1
          while_fun_21.(while_fun_21, ans, fib1, i, tmp)
        else
          {ans, fib1, i, tmp}
        end
      end
      {ans, fib1, i, tmp} = try do
          while_fun_21.(while_fun_21, ans, fib1, i, tmp)
        catch
          {:break, {ans, fib1, i, tmp}} -> {ans, fib1, i, tmp}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(is_prime(97)))
    IO.puts(Kernel.inspect(sieve_er(20)))
    IO.puts(Kernel.inspect(get_prime_numbers(20)))
    IO.puts(Kernel.inspect(prime_factorization(287)))
    IO.puts(Kernel.inspect(greatest_prime_factor(287)))
    IO.puts(Kernel.inspect(smallest_prime_factor(287)))
    IO.puts(Kernel.inspect(kg_v(8, 10)))
    IO.puts(Kernel.inspect(goldbach(28)))
    IO.puts(Kernel.inspect(get_prime(8)))
    IO.puts(Kernel.inspect(get_primes_between(3, 20)))
    IO.puts(Kernel.inspect(get_divisors(28)))
    IO.puts(Kernel.inspect(is_perfect_number(28)))
    IO.puts(Kernel.inspect(simplify_fraction(10, 20)))
    IO.puts(Kernel.inspect(factorial(5)))
    IO.puts(Kernel.inspect(fib(10)))
  end
end
Main.main()
