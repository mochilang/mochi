# Code generated by Mochi transpiler 2025-08-12 07:47 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def key(x, y) do
    try do
      throw {:return, ((Kernel.to_string(x) <> ",") <> Kernel.to_string(y))}
    catch
      {:return, val} -> val
    end
  end
  def joint_probability_distribution(x_values, y_values, x_probabilities, y_probabilities) do
    try do
      result = %{}
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < _len(x_values) do
          j = 0
          while_fun_2 = fn while_fun_2, j, result ->
            if j < _len(y_values) do
              k = key(Enum.at(x_values, i, []), Enum.at(y_values, j, []))
              result = Map.put(result, k, Enum.at(x_probabilities, i, []) * Enum.at(y_probabilities, j, []))
              j = j + 1
              while_fun_2.(while_fun_2, j, result)
            else
              {j, result}
            end
          end
          {j, result} = try do
              while_fun_2.(while_fun_2, j, result)
            catch
              {:break, {j, result}} -> {j, result}
            end

          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def expectation(values, probabilities) do
    try do
      total = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, total ->
        if i < _len(values) do
          total = total + (:erlang.float(Enum.at(values, i, []))) * Enum.at(probabilities, i, [])
          i = i + 1
          while_fun_3.(while_fun_3, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_3.(while_fun_3, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def variance(values, probabilities) do
    try do
      mean = expectation(values, probabilities)
      total = 0.0
      i = 0
      while_fun_4 = fn while_fun_4, i, total ->
        if i < _len(values) do
          diff = (:erlang.float(Enum.at(values, i, []))) - mean
          total = total + diff * diff * Enum.at(probabilities, i, [])
          i = i + 1
          while_fun_4.(while_fun_4, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_4.(while_fun_4, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def covariance(x_values, y_values, x_probabilities, y_probabilities) do
    try do
      mean_x = expectation(x_values, x_probabilities)
      mean_y = expectation(y_values, y_probabilities)
      total = 0.0
      i = 0
      while_fun_5 = fn while_fun_5, i, total ->
        if i < _len(x_values) do
          j = 0
          while_fun_6 = fn while_fun_6, j, total ->
            if j < _len(y_values) do
              diff_x = (:erlang.float(Enum.at(x_values, i, []))) - mean_x
              diff_y = (:erlang.float(Enum.at(y_values, j, []))) - mean_y
              total = total + diff_x * diff_y * Enum.at(x_probabilities, i, []) * Enum.at(y_probabilities, j, [])
              j = j + 1
              while_fun_6.(while_fun_6, j, total)
            else
              {j, total}
            end
          end
          {j, total} = try do
              while_fun_6.(while_fun_6, j, total)
            catch
              {:break, {j, total}} -> {j, total}
            end

          i = i + 1
          while_fun_5.(while_fun_5, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_5.(while_fun_5, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun_7 = fn while_fun_7, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_7.(while_fun_7, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_7.(while_fun_7, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def standard_deviation(v) do
    try do
      throw {:return, sqrtApprox(v)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      x_values = [1, 2]
      y_values = [-2, 5, 8]
      x_probabilities = [0.7, 0.3]
      y_probabilities = [0.3, 0.5, 0.2]
      jpd = joint_probability_distribution(x_values, y_values, x_probabilities, y_probabilities)
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < _len(x_values) do
          j = 0
          while_fun_9 = fn while_fun_9, j ->
            if j < _len(y_values) do
              k = key(Enum.at(x_values, i, []), Enum.at(y_values, j, []))
              prob = jpd[k]
              IO.puts(((k <> "=") <> Kernel.to_string(prob)))
              j = j + 1
              while_fun_9.(while_fun_9, j)
            else
              j
            end
          end
          j = try do
              while_fun_9.(while_fun_9, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      i = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {i}} -> i
        end

      ex = expectation(x_values, x_probabilities)
      ey = expectation(y_values, y_probabilities)
      vx = variance(x_values, x_probabilities)
      vy = variance(y_values, y_probabilities)
      cov = covariance(x_values, y_values, x_probabilities, y_probabilities)
      IO.puts(("Ex=" <> Kernel.to_string(ex)))
      IO.puts(("Ey=" <> Kernel.to_string(ey)))
      IO.puts(("Vx=" <> Kernel.to_string(vx)))
      IO.puts(("Vy=" <> Kernel.to_string(vy)))
      IO.puts(("Cov=" <> Kernel.to_string(cov)))
      IO.puts(("Sx=" <> Kernel.inspect(standard_deviation(vx))))
      IO.puts(("Sy=" <> Kernel.inspect(standard_deviation(vy))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
