# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def bubble_sort(nums) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < _len(nums) do
          arr = (arr ++ [Enum.at(nums, i)])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      a = 0
      while_fun_2 = fn while_fun_2, a, arr ->
        if a < n do
          b = 0
          while_fun_3 = fn while_fun_3, arr, b ->
            if b < n - a - 1 do
              {arr} = if Enum.at(arr, b) > Enum.at(arr, b + 1) do
                tmp = Enum.at(arr, b)
                arr = List.replace_at(arr, b, Enum.at(arr, b + 1))
                arr = List.replace_at(arr, b + 1, tmp)
                {arr}
              else
                {arr}
              end
              b = b + 1
              while_fun_3.(while_fun_3, arr, b)
            else
              {arr, b}
            end
          end
          {arr, b} = try do
              while_fun_3.(while_fun_3, arr, b)
            catch
              {:break, {arr, b}} -> {arr, b}
            end

          a = a + 1
          while_fun_2.(while_fun_2, a, arr)
        else
          {a, arr}
        end
      end
      {a, arr} = try do
          while_fun_2.(while_fun_2, a, arr)
        catch
          {:break, {a, arr}} -> {a, arr}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def sort3(xs) do
    try do
      arr = []
      i = 0
      while_fun_4 = fn while_fun_4, arr, i ->
        if i < _len(xs) do
          arr = (arr ++ [Enum.at(xs, i)])
          i = i + 1
          while_fun_4.(while_fun_4, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_4.(while_fun_4, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      a = 0
      while_fun_5 = fn while_fun_5, a, arr ->
        if a < n do
          b = 0
          while_fun_6 = fn while_fun_6, arr, b ->
            if b < n - a - 1 do
              {arr} = if Enum.at(arr, b) > Enum.at(arr, b + 1) do
                tmp = Enum.at(arr, b)
                arr = List.replace_at(arr, b, Enum.at(arr, b + 1))
                arr = List.replace_at(arr, b + 1, tmp)
                {arr}
              else
                {arr}
              end
              b = b + 1
              while_fun_6.(while_fun_6, arr, b)
            else
              {arr, b}
            end
          end
          {arr, b} = try do
              while_fun_6.(while_fun_6, arr, b)
            catch
              {:break, {arr, b}} -> {arr, b}
            end

          a = a + 1
          while_fun_5.(while_fun_5, a, arr)
        else
          {a, arr}
        end
      end
      {a, arr} = try do
          while_fun_5.(while_fun_5, a, arr)
        catch
          {:break, {a, arr}} -> {a, arr}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def triplet_sum1(arr, target) do
    try do
      i = 0
      while_fun_7 = fn while_fun_7, i ->
        if i < _len(arr) - 2 do
          j = i + 1
          while_fun_8 = fn while_fun_8, j ->
            if j < _len(arr) - 1 do
              k = j + 1
              while_fun_9 = fn while_fun_9, k ->
                if k < _len(arr) do
                  if Enum.at(arr, i) + Enum.at(arr, j) + Enum.at(arr, k) == target do
                    throw {:return, sort3([Enum.at(arr, i), Enum.at(arr, j), Enum.at(arr, k)])}
                  end
                  k = k + 1
                  while_fun_9.(while_fun_9, k)
                else
                  k
                end
              end
              k = try do
                  while_fun_9.(while_fun_9, k)
                catch
                  {:break, {k}} -> k
                end

              j = j + 1
              while_fun_8.(while_fun_8, j)
            else
              j
            end
          end
          j = try do
              while_fun_8.(while_fun_8, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      i = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, [0, 0, 0]}
    catch
      {:return, val} -> val
    end
  end
  def triplet_sum2(arr, target) do
    try do
      sorted = bubble_sort(arr)
      n = _len(sorted)
      i = 0
      while_fun_10 = fn while_fun_10, i ->
        if i < n - 2 do
          left = i + 1
          right = n - 1
          while_fun_11 = fn while_fun_11, left, right ->
            if left < right do
              s = Enum.at(sorted, i) + Enum.at(sorted, left) + Enum.at(sorted, right)
              if s == target do
                throw {:return, [Enum.at(sorted, i), Enum.at(sorted, left), Enum.at(sorted, right)]}
              end
              {left, right} = if s < target do
                left = left + 1
                {left, right}
              else
                right = right - 1
                {left, right}
              end
              while_fun_11.(while_fun_11, left, right)
            else
              {left, right}
            end
          end
          {left, right} = try do
              while_fun_11.(while_fun_11, left, right)
            catch
              {:break, {left, right}} -> {left, right}
            end

          i = i + 1
          while_fun_10.(while_fun_10, i)
        else
          i
        end
      end
      i = try do
          while_fun_10.(while_fun_10, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, [0, 0, 0]}
    catch
      {:return, val} -> val
    end
  end
  def list_equal(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      i = 0
      while_fun_12 = fn while_fun_12, i ->
        if i < _len(a) do
          if Enum.at(a, i) != Enum.at(b, i) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_12.(while_fun_12, i)
        else
          i
        end
      end
      i = try do
          while_fun_12.(while_fun_12, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def test_triplet_sum() do
    try do
      arr1 = [13, 29, 7, 23, 5]
      if !list_equal(triplet_sum1(arr1, 35), [5, 7, 23]) do
        raise("ts1 case1 failed")
      end
      if !list_equal(triplet_sum2(arr1, 35), [5, 7, 23]) do
        raise("ts2 case1 failed")
      end
      arr2 = [37, 9, 19, 50, 44]
      if !list_equal(triplet_sum1(arr2, 65), [9, 19, 37]) do
        raise("ts1 case2 failed")
      end
      if !list_equal(triplet_sum2(arr2, 65), [9, 19, 37]) do
        raise("ts2 case2 failed")
      end
      arr3 = [6, 47, 27, 1, 15]
      if !list_equal(triplet_sum1(arr3, 11), [0, 0, 0]) do
        raise("ts1 case3 failed")
      end
      if !list_equal(triplet_sum2(arr3, 11), [0, 0, 0]) do
        raise("ts2 case3 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_triplet_sum()
      sample = [13, 29, 7, 23, 5]
      res = triplet_sum2(sample, 35)
      IO.puts(((((Kernel.to_string(Enum.at(res, 0)) <> " ") <> Kernel.to_string(Enum.at(res, 1))) <> " ") <> Kernel.to_string(Enum.at(res, 2))))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
