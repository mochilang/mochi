# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def rand_float() do
    try do
      Process.put(:rand_seed, rem((1103515245 * Process.get(:rand_seed) + 12345), 2147483648))
      throw {:return, (:erlang.float(Process.get(:rand_seed))) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def rand_range(min_val, max_val) do
    try do
      throw {:return, rand_float() * (max_val - min_val) + min_val}
    catch
      {:return, val} -> val
    end
  end
  def abs_float(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x == 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def pi_estimator(iterations) do
    try do
      inside = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, inside ->
        if i < iterations do
          x = rand_range(-1.0, 1.0)
          y = rand_range(-1.0, 1.0)
          {inside} = if x * x + y * y <= 1.0 do
            inside = inside + 1.0
            {inside}
          else
            {inside}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, inside)
        else
          {i, inside}
        end
      end
      {i, inside} = try do
          while_fun_2.(while_fun_2, i, inside)
        catch
          {:break, {i, inside}} -> {i, inside}
        end

      proportion = inside / (:erlang.float(iterations))
      pi_estimate = proportion * 4.0
      IO.puts("The estimated value of pi is #{pi_estimate}")
      IO.puts("The numpy value of pi is #{Process.get(:pi)}")
      IO.puts("The total error is #{Kernel.inspect(abs_float(Process.get(:pi) - pi_estimate))}")
    catch
      {:return, val} -> val
    end
  end
  def area_under_curve_estimator(iterations, f, min_value, max_value) do
    try do
      sum = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, sum ->
        if i < iterations do
          x = rand_range(min_value, max_value)
          sum = sum + f.(x)
          i = i + 1
          while_fun_3.(while_fun_3, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_3.(while_fun_3, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      expected = sum / (:erlang.float(iterations))
      throw {:return, expected * (max_value - min_value)}
    catch
      {:return, val} -> val
    end
  end
  def area_under_line_estimator_check(iterations, min_value, max_value) do
    try do
      identity_function = fn x ->
  throw {:return, x}
end
      estimated_value = area_under_curve_estimator(iterations, identity_function, min_value, max_value)
      expected_value = (max_value * max_value - min_value * min_value) / 2.0
      IO.puts("******************")
      IO.puts("Estimating area under y=x where x varies from #{min_value}")
      IO.puts("Estimated value is #{estimated_value}")
      IO.puts("Expected value is #{expected_value}")
      IO.puts("Total error is #{Kernel.inspect(abs_float(estimated_value - expected_value))}")
      IO.puts("******************")
    catch
      {:return, val} -> val
    end
  end
  def pi_estimator_using_area_under_curve(iterations) do
    try do
      semi_circle = fn x ->
  y = 4.0 - x * x
  s = sqrtApprox(y)
  throw {:return, s}
end
      estimated_value = area_under_curve_estimator(iterations, semi_circle, 0.0, 2.0)
      IO.puts("******************")
      IO.puts("Estimating pi using area_under_curve_estimator")
      IO.puts("Estimated value is #{estimated_value}")
      IO.puts("Expected value is #{Process.get(:pi)}")
      IO.puts("Total error is #{Kernel.inspect(abs_float(estimated_value - Process.get(:pi)))}")
      IO.puts("******************")
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      pi_estimator(1000)
      area_under_line_estimator_check(1000, 0.0, 1.0)
      pi_estimator_using_area_under_curve(1000)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:rand_seed, 123456789)
end
Main.main()
