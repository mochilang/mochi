# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  def _mod(x, m) do
    try do
      throw {:return, x - (:erlang.float(Kernel.trunc(x / m))) * m}
    catch
      {:return, val} -> val
    end
  end
  def sin_approx(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y3 = y2 * y
      y5 = y3 * y2
      y7 = y5 * y2
      throw {:return, y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0}
    catch
      {:return, val} -> val
    end
  end
  def cos_approx(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y4 = y2 * y2
      y6 = y4 * y2
      throw {:return, 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0}
    catch
      {:return, val} -> val
    end
  end
  def tan_approx(x) do
    try do
      throw {:return, sin_approx(x) / cos_approx(x)}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_approx(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_cube(side_length) do
    try do
      if side_length < 0.0 do
        IO.puts("ValueError: surface_area_cube() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 6.0 * side_length * side_length}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_cuboid(length, breadth, height) do
    try do
      if length < 0.0 || breadth < 0.0 || height < 0.0 do
        IO.puts("ValueError: surface_area_cuboid() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 2.0 * ((length * breadth) + (breadth * height) + (length * height))}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_sphere(radius) do
    try do
      if radius < 0.0 do
        IO.puts("ValueError: surface_area_sphere() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 4.0 * Process.get(:pi) * radius * radius}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_hemisphere(radius) do
    try do
      if radius < 0.0 do
        IO.puts("ValueError: surface_area_hemisphere() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 3.0 * Process.get(:pi) * radius * radius}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_cone(radius, height) do
    try do
      if radius < 0.0 || height < 0.0 do
        IO.puts("ValueError: surface_area_cone() only accepts non-negative values")
        throw {:return, 0.0}
      end
      slant = sqrt_approx(height * height + radius * radius)
      throw {:return, Process.get(:pi) * radius * (radius + slant)}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_conical_frustum(radius1, radius2, height) do
    try do
      if radius1 < 0.0 || radius2 < 0.0 || height < 0.0 do
        IO.puts("ValueError: surface_area_conical_frustum() only accepts non-negative values")
        throw {:return, 0.0}
      end
      slant = sqrt_approx(height * height + (radius1 - radius2) * (radius1 - radius2))
      throw {:return, Process.get(:pi) * (slant * (radius1 + radius2) + radius1 * radius1 + radius2 * radius2)}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_cylinder(radius, height) do
    try do
      if radius < 0.0 || height < 0.0 do
        IO.puts("ValueError: surface_area_cylinder() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 2.0 * Process.get(:pi) * radius * (height + radius)}
    catch
      {:return, val} -> val
    end
  end
  def surface_area_torus(torus_radius, tube_radius) do
    try do
      if torus_radius < 0.0 || tube_radius < 0.0 do
        IO.puts("ValueError: surface_area_torus() only accepts non-negative values")
        throw {:return, 0.0}
      end
      if torus_radius < tube_radius do
        IO.puts("ValueError: surface_area_torus() does not support spindle or self intersecting tori")
        throw {:return, 0.0}
      end
      throw {:return, 4.0 * Process.get(:pi) * Process.get(:pi) * torus_radius * tube_radius}
    catch
      {:return, val} -> val
    end
  end
  def area_rectangle(length, width) do
    try do
      if length < 0.0 || width < 0.0 do
        IO.puts("ValueError: area_rectangle() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, length * width}
    catch
      {:return, val} -> val
    end
  end
  def area_square(side_length) do
    try do
      if side_length < 0.0 do
        IO.puts("ValueError: area_square() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, side_length * side_length}
    catch
      {:return, val} -> val
    end
  end
  def area_triangle(base, height) do
    try do
      if base < 0.0 || height < 0.0 do
        IO.puts("ValueError: area_triangle() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, (base * height) / 2.0}
    catch
      {:return, val} -> val
    end
  end
  def area_triangle_three_sides(side1, side2, side3) do
    try do
      if side1 < 0.0 || side2 < 0.0 || side3 < 0.0 do
        IO.puts("ValueError: area_triangle_three_sides() only accepts non-negative values")
        throw {:return, 0.0}
      end
      if side1 + side2 < side3 || side1 + side3 < side2 || side2 + side3 < side1 do
        IO.puts("ValueError: Given three sides do not form a triangle")
        throw {:return, 0.0}
      end
      s = (side1 + side2 + side3) / 2.0
      prod = s * (s - side1) * (s - side2) * (s - side3)
      res = sqrt_approx(prod)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def area_parallelogram(base, height) do
    try do
      if base < 0.0 || height < 0.0 do
        IO.puts("ValueError: area_parallelogram() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, base * height}
    catch
      {:return, val} -> val
    end
  end
  def area_trapezium(base1, base2, height) do
    try do
      if base1 < 0.0 || base2 < 0.0 || height < 0.0 do
        IO.puts("ValueError: area_trapezium() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 0.5 * (base1 + base2) * height}
    catch
      {:return, val} -> val
    end
  end
  def area_circle(radius) do
    try do
      if radius < 0.0 do
        IO.puts("ValueError: area_circle() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, Process.get(:pi) * radius * radius}
    catch
      {:return, val} -> val
    end
  end
  def area_ellipse(radius_x, radius_y) do
    try do
      if radius_x < 0.0 || radius_y < 0.0 do
        IO.puts("ValueError: area_ellipse() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, Process.get(:pi) * radius_x * radius_y}
    catch
      {:return, val} -> val
    end
  end
  def area_rhombus(diagonal1, diagonal2) do
    try do
      if diagonal1 < 0.0 || diagonal2 < 0.0 do
        IO.puts("ValueError: area_rhombus() only accepts non-negative values")
        throw {:return, 0.0}
      end
      throw {:return, 0.5 * diagonal1 * diagonal2}
    catch
      {:return, val} -> val
    end
  end
  def area_reg_polygon(sides, length) do
    try do
      if sides < 3 do
        IO.puts("ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides")
        throw {:return, 0.0}
      end
      if length < 0.0 do
        IO.puts("ValueError: area_reg_polygon() only accepts non-negative values as length of a side")
        throw {:return, 0.0}
      end
      n = :erlang.float(sides)
      throw {:return, (n * length * length) / (4.0 * tan_approx(Process.get(:pi) / n))}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:two_pi, 6.283185307179586)
  def main() do
    IO.puts("[DEMO] Areas of various geometric shapes:")
    IO.puts(("Rectangle: " <> Kernel.inspect(area_rectangle(10.0, 20.0))))
    IO.puts(("Square: " <> Kernel.inspect(area_square(10.0))))
    IO.puts(("Triangle: " <> Kernel.inspect(area_triangle(10.0, 10.0))))
    Process.put(:tri_three_sides, area_triangle_three_sides(5.0, 12.0, 13.0))
    IO.puts(("Triangle Three Sides: " <> Kernel.to_string(Process.get(:tri_three_sides))))
    IO.puts(("Parallelogram: " <> Kernel.inspect(area_parallelogram(10.0, 20.0))))
    IO.puts(("Rhombus: " <> Kernel.inspect(area_rhombus(10.0, 20.0))))
    IO.puts(("Trapezium: " <> Kernel.inspect(area_trapezium(10.0, 20.0, 30.0))))
    IO.puts(("Circle: " <> Kernel.inspect(area_circle(20.0))))
    IO.puts(("Ellipse: " <> Kernel.inspect(area_ellipse(10.0, 20.0))))
    IO.puts("")
    IO.puts("Surface Areas of various geometric shapes:")
    IO.puts(("Cube: " <> Kernel.inspect(surface_area_cube(20.0))))
    IO.puts(("Cuboid: " <> Kernel.inspect(surface_area_cuboid(10.0, 20.0, 30.0))))
    IO.puts(("Sphere: " <> Kernel.inspect(surface_area_sphere(20.0))))
    IO.puts(("Hemisphere: " <> Kernel.inspect(surface_area_hemisphere(20.0))))
    IO.puts(("Cone: " <> Kernel.inspect(surface_area_cone(10.0, 20.0))))
    IO.puts(("Conical Frustum: " <> Kernel.inspect(surface_area_conical_frustum(10.0, 20.0, 30.0))))
    IO.puts(("Cylinder: " <> Kernel.inspect(surface_area_cylinder(10.0, 20.0))))
    IO.puts(("Torus: " <> Kernel.inspect(surface_area_torus(20.0, 10.0))))
    IO.puts(("Equilateral Triangle: " <> Kernel.inspect(area_reg_polygon(3, 10.0))))
    IO.puts(("Square: " <> Kernel.inspect(area_reg_polygon(4, 10.0))))
    IO.puts(("Regular Pentagon: " <> Kernel.inspect(area_reg_polygon(5, 10.0))))
  end
end
Main.main()
