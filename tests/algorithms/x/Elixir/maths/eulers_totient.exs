# Code generated by Mochi transpiler 2025-08-12 08:15 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def totient(n) do
    try do
      is_prime = []
      totients = []
      primes = []
      i = 0
      while_fun = fn while_fun, i, is_prime, totients ->
        if i <= n do
          is_prime = (is_prime ++ [true])
          totients = (totients ++ [i - 1])
          i = i + 1
          while_fun.(while_fun, i, is_prime, totients)
        else
          {i, is_prime, totients}
        end
      end
      {i, is_prime, totients} = try do
          while_fun.(while_fun, i, is_prime, totients)
        catch
          {:break, {i, is_prime, totients}} -> {i, is_prime, totients}
        end

      i = 2
      while_fun_2 = fn while_fun_2, i, is_prime, primes, totients ->
        if i <= n do
          {primes} = if Enum.at(is_prime, i, []) do
            primes = (primes ++ [i])
            {primes}
          else
            {primes}
          end
          j = 0
          while_fun_3 = fn while_fun_3, is_prime, j, totients ->
            if j < _len(primes) do
              p = Enum.at(primes, j, [])
              if i * p >= n do
                throw {:break, {is_prime, j, totients}}
              end
              is_prime = List.replace_at(is_prime, i * p, false)
              {totients} = if rem(i, p) == 0 do
                totients = List.replace_at(totients, i * p, Enum.at(totients, i, []) * p)
                throw {:break, {is_prime, j, totients}}
                {totients}
              else
                {totients}
              end
              totients = List.replace_at(totients, i * p, Enum.at(totients, i, []) * (p - 1))
              j = j + 1
              while_fun_3.(while_fun_3, is_prime, j, totients)
            else
              {is_prime, j, totients}
            end
          end
          {is_prime, j, totients} = try do
              while_fun_3.(while_fun_3, is_prime, j, totients)
            catch
              {:break, {is_prime, j, totients}} -> {is_prime, j, totients}
            end

          i = i + 1
          while_fun_2.(while_fun_2, i, is_prime, primes, totients)
        else
          {i, is_prime, primes, totients}
        end
      end
      {i, is_prime, primes, totients} = try do
          while_fun_2.(while_fun_2, i, is_prime, primes, totients)
        catch
          {:break, {i, is_prime, primes, totients}} -> {i, is_prime, primes, totients}
        end

      throw {:return, totients}
    catch
      {:return, val} -> val
    end
  end
  def test_totient() do
    try do
      expected = [-1, 0, 1, 2, 2, 4, 2, 6, 4, 6, 9]
      res = totient(10)
      idx = 0
      while_fun_4 = fn while_fun_4, idx ->
        if idx < _len(expected) do
          if Enum.at(res, idx, []) != Enum.at(expected, idx, []) do
            raise(("totient mismatch at " <> Kernel.to_string(idx)))
          end
          idx = idx + 1
          while_fun_4.(while_fun_4, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_4.(while_fun_4, idx)
        catch
          {:break, {idx}} -> idx
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_totient()
      n = 10
      res = totient(n)
      i = 1
      while_fun_5 = fn while_fun_5, i ->
        if i < n do
          IO.puts((((Kernel.to_string(i) <> " has ") <> Kernel.to_string(Enum.at(res, i, []))) <> " relative primes."))
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
