# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def assign_ranks(data) do
    try do
      ranks = []
      n = _len(data)
      i = 0
      while_fun = fn while_fun, i, ranks ->
        if i < n do
          rank = 1
          j = 0
          while_fun_2 = fn while_fun_2, j, rank ->
            if j < n do
              {rank} = if Enum.at(data, j) < Enum.at(data, i) || (Enum.at(data, j) == Enum.at(data, i) && j < i) do
                rank = rank + 1
                {rank}
              else
                {rank}
              end
              j = j + 1
              while_fun_2.(while_fun_2, j, rank)
            else
              {j, rank}
            end
          end
          {j, rank} = try do
              while_fun_2.(while_fun_2, j, rank)
            catch
              {:break, {j, rank}} -> {j, rank}
            end

          ranks = (ranks ++ [rank])
          i = i + 1
          while_fun.(while_fun, i, ranks)
        else
          {i, ranks}
        end
      end
      {i, ranks} = try do
          while_fun.(while_fun, i, ranks)
        catch
          {:break, {i, ranks}} -> {i, ranks}
        end

      throw {:return, ranks}
    catch
      {:return, val} -> val
    end
  end
  def calculate_spearman_rank_correlation(var1, var2) do
    try do
      if _len(var1) != _len(var2) do
        raise("Lists must have equal length")
      end
      n = _len(var1)
      rank1 = assign_ranks(var1)
      rank2 = assign_ranks(var2)
      i = 0
      d_sq = 0.0
      while_fun_3 = fn while_fun_3, d_sq, i ->
        if i < n do
          diff = (:erlang.float((Enum.at(rank1, i) - Enum.at(rank2, i))))
          d_sq = d_sq + diff * diff
          i = i + 1
          while_fun_3.(while_fun_3, d_sq, i)
        else
          {d_sq, i}
        end
      end
      {d_sq, i} = try do
          while_fun_3.(while_fun_3, d_sq, i)
        catch
          {:break, {d_sq, i}} -> {d_sq, i}
        end

      n_f = (:erlang.float(n))
      throw {:return, 1.0 - (6.0 * d_sq) / (n_f * (n_f * n_f - 1.0))}
    catch
      {:return, val} -> val
    end
  end
  def test_spearman() do
    try do
      x = [1.0, 2.0, 3.0, 4.0, 5.0]
      y_inc = [2.0, 4.0, 6.0, 8.0, 10.0]
      if calculate_spearman_rank_correlation(x, y_inc) != 1.0 do
        raise("case1")
      end
      y_dec = [5.0, 4.0, 3.0, 2.0, 1.0]
      if calculate_spearman_rank_correlation(x, y_dec) != (-1.0) do
        raise("case2")
      end
      y_mix = [5.0, 1.0, 2.0, 9.0, 5.0]
      if calculate_spearman_rank_correlation(x, y_mix) != 0.6 do
        raise("case3")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_spearman()
      IO.puts(Kernel.inspect(calculate_spearman_rank_correlation([1.0, 2.0, 3.0, 4.0, 5.0], [2.0, 4.0, 6.0, 8.0, 10.0])))
      IO.puts(Kernel.inspect(calculate_spearman_rank_correlation([1.0, 2.0, 3.0, 4.0, 5.0], [5.0, 4.0, 3.0, 2.0, 1.0])))
      IO.puts(Kernel.inspect(calculate_spearman_rank_correlation([1.0, 2.0, 3.0, 4.0, 5.0], [5.0, 1.0, 2.0, 9.0, 5.0])))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
