# Code generated by Mochi transpiler 2025-08-17 13:17 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def assign_ranks(data) do
    try do
      ranks = []
      n = _len(data)
      i = 0
      while_fun = fn while_fun, i, ranks ->
        if i < n do
          rank = 1
          j = 0
          while_fun_2 = fn while_fun_2, j, rank ->
            if j < n do
              rank = if Enum.at(data, j, []) < Enum.at(data, i, []) || (Enum.at(data, j, []) == Enum.at(data, i, []) && j < i) do
                rank = rank + 1
                rank
              else
                rank
              end
              j = j + 1
              while_fun_2.(while_fun_2, j, rank)
            else
              {j, rank}
            end
          end
          {_, rank} = try do
              while_fun_2.(while_fun_2, j, rank)
            catch
              {:break, {_, rank}} -> {0, rank}
            end

          ranks = (ranks ++ [rank])
          i = i + 1
          while_fun.(while_fun, i, ranks)
        else
          {i, ranks}
        end
      end
      {i, ranks} = try do
          while_fun.(while_fun, i, ranks)
        catch
          {:break, {i, ranks}} -> {i, ranks}
        end

      throw {:return, ranks}
    catch
      {:return, val} -> val
    end
  end
  def calculate_spearman_rank_correlation(var1, var2) do
    try do
      if _len(var1) != _len(var2) do
        raise("Lists must have equal length")
      end
      n = _len(var1)
      rank1 = assign_ranks(var1)
      rank2 = assign_ranks(var2)
      i = 0
      d_sq = 0.0
      while_fun_3 = fn while_fun_3, d_sq, i ->
        if i < n do
          diff = (:erlang.float((Enum.at(rank1, i, []) - Enum.at(rank2, i, []))))
          d_sq = d_sq + diff * diff
          i = i + 1
          while_fun_3.(while_fun_3, d_sq, i)
        else
          {d_sq, i}
        end
      end
      {d_sq, i} = try do
          while_fun_3.(while_fun_3, d_sq, i)
        catch
          {:break, {d_sq, i}} -> {d_sq, i}
        end

      n_f = (:erlang.float(n))
      throw {:return, 1.0 - (6.0 * d_sq) / (n_f * (n_f * n_f - 1.0))}
    catch
      {:return, val} -> val
    end
  end
  def test_spearman() do
    try do
      x = [1.0, 2.0, 3.0, 4.0, 5.0]
      y_inc = [2.0, 4.0, 6.0, 8.0, 10.0]
      if calculate_spearman_rank_correlation(x, y_inc) != 1.0 do
        raise("case1")
      end
      y_dec = [5.0, 4.0, 3.0, 2.0, 1.0]
      if calculate_spearman_rank_correlation(x, y_dec) != (-1.0) do
        raise("case2")
      end
      y_mix = [5.0, 1.0, 2.0, 9.0, 5.0]
      if calculate_spearman_rank_correlation(x, y_mix) != 0.6 do
        raise("case3")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_spearman()
      IO.puts(Kernel.inspect(calculate_spearman_rank_correlation([1.0, 2.0, 3.0, 4.0, 5.0], [2.0, 4.0, 6.0, 8.0, 10.0])))
      IO.puts(Kernel.inspect(calculate_spearman_rank_correlation([1.0, 2.0, 3.0, 4.0, 5.0], [5.0, 4.0, 3.0, 2.0, 1.0])))
      IO.puts(Kernel.inspect(calculate_spearman_rank_correlation([1.0, 2.0, 3.0, 4.0, 5.0], [5.0, 1.0, 2.0, 9.0, 5.0])))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
