# Code generated by Mochi transpiler 2025-08-12 08:15 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrt(x) do
    try do
      if x < 0.0 do
        raise("sqrt domain error")
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      if x <= 0.0 do
        raise("ln domain error")
      end
      y = (x - 1.0) / (x + 1.0)
      y2 = y * y
      term = y
      sum = 0.0
      k = 0
      while_fun_2 = fn while_fun_2, k, sum, term ->
        if k < 10 do
          denom = :erlang.float((2 * k + 1))
          sum = sum + term / denom
          term = term * y2
          k = k + 1
          while_fun_2.(while_fun_2, k, sum, term)
        else
          {k, sum, term}
        end
      end
      {k, sum, term} = try do
          while_fun_2.(while_fun_2, k, sum, term)
        catch
          {:break, {k, sum, term}} -> {k, sum, term}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def exp_series(x) do
    try do
      term = 1.0
      sum = 1.0
      n = 1
      while_fun_3 = fn while_fun_3, n, sum, term ->
        if n < 20 do
          term = term * x / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun_3.(while_fun_3, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_3.(while_fun_3, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def powf(base, exponent) do
    try do
      throw {:return, ((if base <= 0.0, do: 0.0, else: exp_series(exponent * ln(base))))}
    catch
      {:return, val} -> val
    end
  end
  def integrand(x, z) do
    try do
      throw {:return, powf(x, z - 1.0) * exp_series(-x)}
    catch
      {:return, val} -> val
    end
  end
  def gamma_iterative(num) do
    try do
      if num <= 0.0 do
        raise("math domain error")
      end
      step = 0.001
      limit = 100.0
      x = step
      total = 0.0
      while_fun_4 = fn while_fun_4, total, x ->
        if x < limit do
          total = total + integrand(x, num) * step
          x = x + step
          while_fun_4.(while_fun_4, total, x)
        else
          {total, x}
        end
      end
      {total, x} = try do
          while_fun_4.(while_fun_4, total, x)
        catch
          {:break, {total, x}} -> {total, x}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def gamma_recursive(num) do
    try do
      if num <= 0.0 do
        raise("math domain error")
      end
      if num > 171.5 do
        raise("math range error")
      end
      int_part = Kernel.trunc(num)
      frac = num - (:erlang.float(int_part))
      if !(absf(frac) < 0.000001 || absf(frac - 0.5) < 0.000001) do
        raise("num must be an integer or a half-integer")
      end
      if absf(num - 0.5) < 0.000001 do
        throw {:return, sqrt(Process.get(:pi))}
      end
      if absf(num - 1.0) < 0.000001 do
        throw {:return, 1.0}
      end
      throw {:return, (num - 1.0) * gamma_recursive(num - 1.0)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(gamma_iterative(5.0)))
      IO.puts(Kernel.inspect(gamma_recursive(5.0)))
      IO.puts(Kernel.inspect(gamma_recursive(0.5)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  def bench_main() do
    Process.put(:pi, 3.141592653589793)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
