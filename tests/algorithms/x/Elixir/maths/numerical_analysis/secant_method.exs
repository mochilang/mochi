# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def exp_approx(x) do
    try do
      sum = 1.0
      term = 1.0
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i <= 20 do
          term = term * x / i
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def f(x) do
    try do
      throw {:return, 8.0 * x - 2.0 * exp_approx(-x)}
    catch
      {:return, val} -> val
    end
  end
  def secant_method(lower_bound, upper_bound, repeats) do
    try do
      x0 = lower_bound
      x1 = upper_bound
      i = 0
      while_fun_2 = fn while_fun_2, i, x0, x1 ->
        if i < repeats do
          fx1 = f(x1)
          fx0 = f(x0)
          new_x = x1 - (fx1 * (x1 - x0)) / (fx1 - fx0)
          x0 = x1
          x1 = new_x
          i = i + 1
          while_fun_2.(while_fun_2, i, x0, x1)
        else
          {i, x0, x1}
        end
      end
      {i, x0, x1} = try do
          while_fun_2.(while_fun_2, i, x0, x1)
        catch
          {:break, {i, x0, x1}} -> {i, x0, x1}
        end

      throw {:return, x1}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(secant_method(1.0, 3.0, 2)))
  end
end
Main.main()
