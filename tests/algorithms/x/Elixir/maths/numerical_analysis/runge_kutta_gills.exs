# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrt(x) do
    try do
      guess = (if x > 1.0, do: x / 2.0, else: 1.0)
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = 0.5 * (guess + x / guess)
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def runge_kutta_gills(func, x_initial, y_initial, step_size, x_final) do
    try do
      if x_initial >= x_final do
        raise("The final value of x must be greater than initial value of x.")
      end
      if step_size <= 0.0 do
        raise("Step size must be positive.")
      end
      n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(((x_final - x_initial) / step_size))
      y = []
      i = 0
      while_fun_2 = fn while_fun_2, i, y ->
        if i <= n do
          y = (y ++ [0.0])
          i = i + 1
          while_fun_2.(while_fun_2, i, y)
        else
          {i, y}
        end
      end
      {i, y} = try do
          while_fun_2.(while_fun_2, i, y)
        catch
          {:break, {i, y}} -> {i, y}
        end

      y = List.replace_at(y, 0, y_initial)
      xi = x_initial
      idx = 0
      root2 = sqrt(2.0)
      while_fun_3 = fn while_fun_3, idx, xi, y ->
        if idx < n do
          k1 = step_size * func.(xi, Enum.at(y, idx))
          k2 = step_size * func.(xi + step_size / 2.0, Enum.at(y, idx) + k1 / 2.0)
          k3 = step_size * func.(xi + step_size / 2.0, Enum.at(y, idx) + (-0.5 + 1.0 / root2) * k1 + (1.0 - 1.0 / root2) * k2)
          k4 = step_size * func.(xi + step_size, Enum.at(y, idx) - (1.0 / root2) * k2 + (1.0 + 1.0 / root2) * k3)
          y = List.replace_at(y, idx + 1, Enum.at(y, idx) + (k1 + (2.0 - root2) * k2 + (2.0 + root2) * k3 + k4) / 6.0)
          xi = xi + step_size
          idx = idx + 1
          while_fun_3.(while_fun_3, idx, xi, y)
        else
          {idx, xi, y}
        end
      end
      {idx, xi, y} = try do
          while_fun_3.(while_fun_3, idx, xi, y)
        catch
          {:break, {idx, xi, y}} -> {idx, xi, y}
        end

      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def f1(x, y) do
    try do
      throw {:return, (x - y) / 2.0}
    catch
      {:return, val} -> val
    end
  end
  def f2(x, y) do
    try do
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:y1, runge_kutta_gills(&f1/2, 0.0, 3.0, 0.2, 5.0))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:y1), _len(Process.get(:y1)) - 1)))
    Process.put(:y2, runge_kutta_gills(&f2/2, -1.0, 0.0, 0.2, 0.0))
    IO.puts(Kernel.inspect(Process.get(:y2)))
  end
end
Main.main()
