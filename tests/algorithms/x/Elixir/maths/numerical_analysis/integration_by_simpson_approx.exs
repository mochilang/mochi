# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      {i} = if (:erlang.float(i)) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, :erlang.float(i)}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      i = 0
      while_fun = fn while_fun, i, p ->
        if i < n do
          p = p * 10.0
          i = i + 1
          while_fun.(while_fun, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun.(while_fun, i, p)
        catch
          {:break, {i, p}} -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def round(x, n) do
    try do
      m = pow10(n)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def simpson_integration(f, a, b, precision) do
    try do
      if precision <= 0 do
        raise("precision should be positive")
      end
      h = (b - a) / (:erlang.float(Process.get(:n_steps)))
      result = f.(a) + f.(b)
      i = 1
      while_fun_2 = fn while_fun_2, i, result ->
        if i < Process.get(:n_steps) do
          x = a + h * (:erlang.float(i))
          result = (if rem(i, 2) == 1, do: result + 4.0 * f.(x), else: result + 2.0 * f.(x))
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      result = result * (h / 3.0)
      r = round(result, precision)
      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def square(x) do
    try do
      throw {:return, x * x}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:n_steps, 1000)
  def main() do
    IO.puts(Kernel.inspect(simpson_integration(&square/1, 1.0, 2.0, 3)))
    IO.puts(Kernel.inspect(simpson_integration(&square/1, 3.45, 3.2, 1)))
  end
end
Main.main()
