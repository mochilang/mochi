# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def abs_float(x) do
    try do
      if x < 0.0 do
        throw {:return, -x}
      else
        throw {:return, x}
      end
    catch
      {:return, val} -> val
    end
  end
  def fail(msg) do
    try do
      IO.puts(("error: " <> msg))
    catch
      {:return, val} -> val
    end
  end
  def calc_derivative(f, x, delta_x) do
    try do
      throw {:return, (f.(x + delta_x / 2.0) - f.(x - delta_x / 2.0)) / delta_x}
    catch
      {:return, val} -> val
    end
  end
  def newton_raphson(f, x0, max_iter, step, max_error, log_steps) do
    try do
      a = x0
      steps = []
      i = 0
      while_fun = fn while_fun, a, i, steps ->
        if i < max_iter do
          {steps} = if log_steps do
            steps = (steps ++ [a])
            {steps}
          else
            {steps}
          end
          err = abs_float(f.(a))
          if err < max_error do
            throw {:return, %{root: a, error: err, steps: steps}}
          end
          der = calc_derivative(f, a, step)
          if der == 0.0 do
            fail("No converging solution found, zero derivative")
            throw {:return, %{root: a, error: err, steps: steps}}
          end
          a = a - f.(a) / der
          i = i + 1
          while_fun.(while_fun, a, i, steps)
        else
          {a, i, steps}
        end
      end
      {a, i, steps} = try do
          while_fun.(while_fun, a, i, steps)
        catch
          {:break, {a, i, steps}} -> {a, i, steps}
        end

      fail("No converging solution found, iteration limit reached")
      throw {:return, %{root: a, error: abs_float(f.(a)), steps: steps}}
    catch
      {:return, val} -> val
    end
  end
  def poly(x) do
    try do
      throw {:return, x * x - 5.0 * x + 2.0}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:result, newton_raphson(&poly/1, 0.4, 20, 0.000001, 0.000001, false))
    IO.puts(((("root = " <> Kernel.to_string(Process.get(:result).root)) <> ", error = ") <> Kernel.to_string(Process.get(:result).error)))
  end
end
Main.main()
