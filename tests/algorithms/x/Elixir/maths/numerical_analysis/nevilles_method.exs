# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def neville_interpolate(x_points, y_points, x0) do
    try do
      n = _len(x_points)
      q = []
      i = 0
      while_fun = fn while_fun, i, q ->
        if i < n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < n do
              row = (row ++ [0.0])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          q = (q ++ [row])
          i = i + 1
          while_fun.(while_fun, i, q)
        else
          {i, q}
        end
      end
      {i, q} = try do
          while_fun.(while_fun, i, q)
        catch
          {:break, {i, q}} -> {i, q}
        end

      i = 0
      while_fun_3 = fn while_fun_3, i, q ->
        if i < n do
          q = List.replace_at(q, i, List.replace_at(Enum.at(q, i), 1, Enum.at(y_points, i)))
          i = i + 1
          while_fun_3.(while_fun_3, i, q)
        else
          {i, q}
        end
      end
      {i, q} = try do
          while_fun_3.(while_fun_3, i, q)
        catch
          {:break, {i, q}} -> {i, q}
        end

      col = 2
      while_fun_4 = fn while_fun_4, col, q ->
        if col < n do
          row_idx = col
          while_fun_5 = fn while_fun_5, q, row_idx ->
            if row_idx < n do
              q = List.replace_at(q, row_idx, List.replace_at(Enum.at(q, row_idx), col, ((x0 - Enum.at(x_points, row_idx - col + 1)) * Enum.at(Enum.at(q, row_idx), col - 1) - (x0 - Enum.at(x_points, row_idx)) * Enum.at(Enum.at(q, row_idx - 1), col - 1)) / (Enum.at(x_points, row_idx) - Enum.at(x_points, row_idx - col + 1))))
              row_idx = row_idx + 1
              while_fun_5.(while_fun_5, q, row_idx)
            else
              {q, row_idx}
            end
          end
          {q, row_idx} = try do
              while_fun_5.(while_fun_5, q, row_idx)
            catch
              {:break, {q, row_idx}} -> {q, row_idx}
            end

          col = col + 1
          while_fun_4.(while_fun_4, col, q)
        else
          {col, q}
        end
      end
      {col, q} = try do
          while_fun_4.(while_fun_4, col, q)
        catch
          {:break, {col, q}} -> {col, q}
        end

      throw {:return, %{value: Enum.at(Enum.at(q, n - 1), n - 1), table: q}}
    catch
      {:return, val} -> val
    end
  end
  def test_neville() do
    try do
      xs = [1.0, 2.0, 3.0, 4.0, 6.0]
      ys = [6.0, 7.0, 8.0, 9.0, 11.0]
      r1 = neville_interpolate(xs, ys, 5.0)
      if r1.value != 10.0 do
        raise("neville_interpolate at 5 failed")
      end
      r2 = neville_interpolate(xs, ys, 99.0)
      if r2.value != 104.0 do
        raise("neville_interpolate at 99 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_neville()
      xs = [1.0, 2.0, 3.0, 4.0, 6.0]
      ys = [6.0, 7.0, 8.0, 9.0, 11.0]
      r = neville_interpolate(xs, ys, 5.0)
      IO.puts(r.value)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
