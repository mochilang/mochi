# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_float(x) do
    try do
      if x < 0.0 do
        throw {:return, -x}
      else
        throw {:return, x}
      end
    catch
      {:return, val} -> val
    end
  end
  def validate_inputs(x_initials, step_size, x_final) do
    try do
      if Enum.at(x_initials, _len(x_initials) - 1) >= x_final do
        raise("The final value of x must be greater than the initial values of x.")
      end
      if step_size <= 0.0 do
        raise("Step size must be positive.")
      end
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(x_initials) - 1 do
          diff = Enum.at(x_initials, i + 1) - Enum.at(x_initials, i)
          if abs_float(diff - step_size) > 0.0000000001 do
            raise("x-values must be equally spaced according to step size.")
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def list_to_string(xs) do
    try do
      s = "["
      i = 0
      while_fun_2 = fn while_fun_2, i, s ->
        if i < _len(xs) do
          s = (s <> Kernel.to_string(Enum.at(xs, i)))
          {s} = if i + 1 < _len(xs) do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_2.(while_fun_2, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def adams_bashforth_step2(f, x_initials, y_initials, step_size, x_final) do
    try do
      validate_inputs(x_initials, step_size, x_final)
      if _len(x_initials) != 2 || _len(y_initials) != 2 do
        raise("Insufficient initial points information.")
      end
      x0 = Enum.at(x_initials, 0)
      x1 = Enum.at(x_initials, 1)
      y = []
      y = (y ++ [Enum.at(y_initials, 0)])
      y = (y ++ [Enum.at(y_initials, 1)])
      n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(((x_final - x1) / step_size))
      i = 0
      while_fun_3 = fn while_fun_3, i, x0, x1, y ->
        if i < n do
          term = 3.0 * f.(x1, Enum.at(y, i + 1)) - f.(x0, Enum.at(y, i))
          y_next = Enum.at(y, i + 1) + (step_size / 2.0) * term
          y = (y ++ [y_next])
          x0 = x1
          x1 = x1 + step_size
          i = i + 1
          while_fun_3.(while_fun_3, i, x0, x1, y)
        else
          {i, x0, x1, y}
        end
      end
      {i, x0, x1, y} = try do
          while_fun_3.(while_fun_3, i, x0, x1, y)
        catch
          {:break, {i, x0, x1, y}} -> {i, x0, x1, y}
        end

      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def adams_bashforth_step3(f, x_initials, y_initials, step_size, x_final) do
    try do
      validate_inputs(x_initials, step_size, x_final)
      if _len(x_initials) != 3 || _len(y_initials) != 3 do
        raise("Insufficient initial points information.")
      end
      x0 = Enum.at(x_initials, 0)
      x1 = Enum.at(x_initials, 1)
      x2 = Enum.at(x_initials, 2)
      y = []
      y = (y ++ [Enum.at(y_initials, 0)])
      y = (y ++ [Enum.at(y_initials, 1)])
      y = (y ++ [Enum.at(y_initials, 2)])
      n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(((x_final - x2) / step_size))
      i = 0
      while_fun_4 = fn while_fun_4, i, x0, x1, x2, y ->
        if i <= n do
          term = 23.0 * f.(x2, Enum.at(y, i + 2)) - 16.0 * f.(x1, Enum.at(y, i + 1)) + 5.0 * f.(x0, Enum.at(y, i))
          y_next = Enum.at(y, i + 2) + (step_size / 12.0) * term
          y = (y ++ [y_next])
          x0 = x1
          x1 = x2
          x2 = x2 + step_size
          i = i + 1
          while_fun_4.(while_fun_4, i, x0, x1, x2, y)
        else
          {i, x0, x1, x2, y}
        end
      end
      {i, x0, x1, x2, y} = try do
          while_fun_4.(while_fun_4, i, x0, x1, x2, y)
        catch
          {:break, {i, x0, x1, x2, y}} -> {i, x0, x1, x2, y}
        end

      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def adams_bashforth_step4(f, x_initials, y_initials, step_size, x_final) do
    try do
      validate_inputs(x_initials, step_size, x_final)
      if _len(x_initials) != 4 || _len(y_initials) != 4 do
        raise("Insufficient initial points information.")
      end
      x0 = Enum.at(x_initials, 0)
      x1 = Enum.at(x_initials, 1)
      x2 = Enum.at(x_initials, 2)
      x3 = Enum.at(x_initials, 3)
      y = []
      y = (y ++ [Enum.at(y_initials, 0)])
      y = (y ++ [Enum.at(y_initials, 1)])
      y = (y ++ [Enum.at(y_initials, 2)])
      y = (y ++ [Enum.at(y_initials, 3)])
      n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(((x_final - x3) / step_size))
      i = 0
      while_fun_5 = fn while_fun_5, i, x0, x1, x2, x3, y ->
        if i < n do
          term = 55.0 * f.(x3, Enum.at(y, i + 3)) - 59.0 * f.(x2, Enum.at(y, i + 2)) + 37.0 * f.(x1, Enum.at(y, i + 1)) - 9.0 * f.(x0, Enum.at(y, i))
          y_next = Enum.at(y, i + 3) + (step_size / 24.0) * term
          y = (y ++ [y_next])
          x0 = x1
          x1 = x2
          x2 = x3
          x3 = x3 + step_size
          i = i + 1
          while_fun_5.(while_fun_5, i, x0, x1, x2, x3, y)
        else
          {i, x0, x1, x2, x3, y}
        end
      end
      {i, x0, x1, x2, x3, y} = try do
          while_fun_5.(while_fun_5, i, x0, x1, x2, x3, y)
        catch
          {:break, {i, x0, x1, x2, x3, y}} -> {i, x0, x1, x2, x3, y}
        end

      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def adams_bashforth_step5(f, x_initials, y_initials, step_size, x_final) do
    try do
      validate_inputs(x_initials, step_size, x_final)
      if _len(x_initials) != 5 || _len(y_initials) != 5 do
        raise("Insufficient initial points information.")
      end
      x0 = Enum.at(x_initials, 0)
      x1 = Enum.at(x_initials, 1)
      x2 = Enum.at(x_initials, 2)
      x3 = Enum.at(x_initials, 3)
      x4 = Enum.at(x_initials, 4)
      y = []
      y = (y ++ [Enum.at(y_initials, 0)])
      y = (y ++ [Enum.at(y_initials, 1)])
      y = (y ++ [Enum.at(y_initials, 2)])
      y = (y ++ [Enum.at(y_initials, 3)])
      y = (y ++ [Enum.at(y_initials, 4)])
      n = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(((x_final - x4) / step_size))
      i = 0
      while_fun_6 = fn while_fun_6, i, x0, x1, x2, x3, x4, y ->
        if i <= n do
          term = 1901.0 * f.(x4, Enum.at(y, i + 4)) - 2774.0 * f.(x3, Enum.at(y, i + 3)) - 2616.0 * f.(x2, Enum.at(y, i + 2)) - 1274.0 * f.(x1, Enum.at(y, i + 1)) + 251.0 * f.(x0, Enum.at(y, i))
          y_next = Enum.at(y, i + 4) + (step_size / 720.0) * term
          y = (y ++ [y_next])
          x0 = x1
          x1 = x2
          x2 = x3
          x3 = x4
          x4 = x4 + step_size
          i = i + 1
          while_fun_6.(while_fun_6, i, x0, x1, x2, x3, x4, y)
        else
          {i, x0, x1, x2, x3, x4, y}
        end
      end
      {i, x0, x1, x2, x3, x4, y} = try do
          while_fun_6.(while_fun_6, i, x0, x1, x2, x3, x4, y)
        catch
          {:break, {i, x0, x1, x2, x3, x4, y}} -> {i, x0, x1, x2, x3, x4, y}
        end

      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def f_x(x, y) do
    try do
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def f_xy(x, y) do
    try do
      throw {:return, x + y}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:y2, adams_bashforth_step2(&f_x/2, [0.0, 0.2], [0.0, 0.0], 0.2, 1.0))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:y2))))
    Process.put(:y3, adams_bashforth_step3(&f_xy/2, [0.0, 0.2, 0.4], [0.0, 0.0, 0.04], 0.2, 1.0))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:y3), 3)))
    Process.put(:y4, adams_bashforth_step4(&f_xy/2, [0.0, 0.2, 0.4, 0.6], [0.0, 0.0, 0.04, 0.128], 0.2, 1.0))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:y4), 4)))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:y4), 5)))
    Process.put(:y5, adams_bashforth_step5(&f_xy/2, [0.0, 0.2, 0.4, 0.6, 0.8], [0.0, 0.0214, 0.0214, 0.22211, 0.42536], 0.2, 1.0))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:y5), _len(Process.get(:y5)) - 1)))
  end
end
Main.main()
