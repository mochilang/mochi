# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def parse_decimal(s) do
    try do
      value = 0
      i = 0
      while_fun = fn while_fun, i, value ->
        if i < _len(s) do
          c = String.at(s, i)
          if c < "0" || c > "9" do
            raise("invalid literal")
          end
          value = value * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(c))
          i = i + 1
          while_fun.(while_fun, i, value)
        else
          {i, value}
        end
      end
      {i, value} = try do
          while_fun.(while_fun, i, value)
        catch
          {:break, {i, value}} -> {i, value}
        end

      throw {:return, value}
    catch
      {:return, val} -> val
    end
  end
  def zeller_day(date_input) do
    try do
      days = %{0 => "Sunday", 1 => "Monday", 2 => "Tuesday", 3 => "Wednesday", 4 => "Thursday", 5 => "Friday", 6 => "Saturday"}
      if _len(date_input) != 10 do
        raise("Must be 10 characters long")
      end
      m = parse_decimal(_slice(date_input, 0, 2 - 0))
      if m <= 0 || m >= 13 do
        raise("Month must be between 1 - 12")
      end
      sep1 = String.at(date_input, 2)
      if sep1 != "-" && sep1 != "/" do
        raise("Date separator must be '-' or '/'")
      end
      d = parse_decimal(_slice(date_input, 3, 5 - 3))
      if d <= 0 || d >= 32 do
        raise("Date must be between 1 - 31")
      end
      sep2 = String.at(date_input, 5)
      if sep2 != "-" && sep2 != "/" do
        raise("Date separator must be '-' or '/'")
      end
      y = parse_decimal(_slice(date_input, 6, 10 - 6))
      if y <= 45 || y >= 8500 do
        raise("Year out of range. There has to be some sort of limit...right?")
      end
      year = y
      month = m
      {month, year} = if month <= 2 do
        year = year - 1
        month = month + 12
        {month, year}
      else
        {month, year}
      end
      c = div(year, 100)
      k = rem(year, 100)
      t = Kernel.trunc(2.6 * (:erlang.float(month)) - 5.39)
      u = div(c, 4)
      v = div(k, 4)
      x = d + k
      z = t + u + v + x
      w = z - (2 * c)
      f = rem(w, 7)
      {f} = if f < 0 do
        f = f + 7
        {f}
      else
        {f}
      end
      throw {:return, Map.get(days, f, "")}
    catch
      {:return, val} -> val
    end
  end
  def zeller(date_input) do
    try do
      day = zeller_day(date_input)
      throw {:return, (((("Your date " <> date_input) <> ", is a ") <> day) <> "!")}
    catch
      {:return, val} -> val
    end
  end
  def test_zeller() do
    try do
      inputs = ["01-31-2010", "02-01-2010", "11-26-2024", "07-04-1776"]
      expected = ["Sunday", "Monday", "Tuesday", "Thursday"]
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(inputs) do
          res = zeller_day(Enum.at(inputs, i))
          if res != Enum.at(expected, i) do
            raise("zeller test failed")
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_zeller()
      IO.puts(Kernel.inspect(zeller("01-31-2010")))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
