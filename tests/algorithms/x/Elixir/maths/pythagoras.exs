# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_approx(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def distance(a, b) do
    try do
      dx = b.x - a.x
      dy = b.y - a.y
      dz = b.z - a.z
      throw {:return, sqrt_approx(absf(dx * dx + dy * dy + dz * dz))}
    catch
      {:return, val} -> val
    end
  end
  def point_to_string(p) do
    try do
      throw {:return, (((((("Point(" <> Kernel.to_string(p.x)) <> ", ") <> Kernel.to_string(p.y)) <> ", ") <> Kernel.to_string(p.z)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def test_distance() do
    try do
      p1 = %{x: 2.0, y: -1.0, z: 7.0}
      p2 = %{x: 1.0, y: -3.0, z: 5.0}
      d = distance(p1, p2)
      if absf(d - 3.0) > 0.0001 do
        raise("distance test failed")
      end
      IO.puts(((((("Distance from " <> point_to_string(p1)) <> " to ") <> point_to_string(p2)) <> " is ") <> Kernel.to_string(d)))
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_distance()
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
