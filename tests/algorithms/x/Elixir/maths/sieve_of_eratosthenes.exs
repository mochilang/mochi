# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  def isqrt(n) do
    try do
      r = 0
      while_fun = fn while_fun, r ->
        if (r + 1) * (r + 1) <= n do
          r = r + 1
          while_fun.(while_fun, r)
        else
          r
        end
      end
      r = try do
          while_fun.(while_fun, r)
        catch
          {:break, {r}} -> r
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def prime_sieve(num) do
    try do
      if num <= 0 do
        raise("Invalid input, please enter a positive integer.")
      end
      sieve = []
      i = 0
      while_fun_2 = fn while_fun_2, i, sieve ->
        if i <= num do
          sieve = (sieve ++ [true])
          i = i + 1
          while_fun_2.(while_fun_2, i, sieve)
        else
          {i, sieve}
        end
      end
      {i, sieve} = try do
          while_fun_2.(while_fun_2, i, sieve)
        catch
          {:break, {i, sieve}} -> {i, sieve}
        end

      prime = []
      start = 2
      end_ = isqrt(num)
      while_fun_3 = fn while_fun_3, prime, sieve, start ->
        if start <= end_ do
          {prime, sieve} = if Enum.at(sieve, start) do
            prime = (prime ++ [start])
            j = start * start
            while_fun_4 = fn while_fun_4, j, sieve ->
              if j <= num do
                {sieve} = if Enum.at(sieve, j) do
                  sieve = List.replace_at(sieve, j, false)
                  {sieve}
                else
                  {sieve}
                end
                j = j + start
                while_fun_4.(while_fun_4, j, sieve)
              else
                {j, sieve}
              end
            end
            {j, sieve} = try do
                while_fun_4.(while_fun_4, j, sieve)
              catch
                {:break, {j, sieve}} -> {j, sieve}
              end

            {prime, sieve}
          else
            {prime, sieve}
          end
          start = start + 1
          while_fun_3.(while_fun_3, prime, sieve, start)
        else
          {prime, sieve, start}
        end
      end
      {prime, sieve, start} = try do
          while_fun_3.(while_fun_3, prime, sieve, start)
        catch
          {:break, {prime, sieve, start}} -> {prime, sieve, start}
        end

      k = end_ + 1
      while_fun_5 = fn while_fun_5, k, prime ->
        if k <= num do
          {prime} = if Enum.at(sieve, k) do
            prime = (prime ++ [k])
            {prime}
          else
            {prime}
          end
          k = k + 1
          while_fun_5.(while_fun_5, k, prime)
        else
          {k, prime}
        end
      end
      {k, prime} = try do
          while_fun_5.(while_fun_5, k, prime)
        catch
          {:break, {k, prime}} -> {k, prime}
        end

      throw {:return, prime}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(prime_sieve(50)))
    IO.puts(Kernel.inspect(prime_sieve(25)))
    IO.puts(Kernel.inspect(prime_sieve(10)))
    IO.puts(Kernel.inspect(prime_sieve(9)))
    IO.puts(Kernel.inspect(prime_sieve(2)))
    IO.puts(Kernel.inspect(prime_sieve(1)))
  end
end
Main.main()
