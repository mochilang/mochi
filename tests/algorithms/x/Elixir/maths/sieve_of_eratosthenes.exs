# Code generated by Mochi transpiler 2025-08-17 13:17 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def isqrt(n) do
    try do
      r = 0
      while_fun = fn while_fun, r ->
        if (r + 1) * (r + 1) <= n do
          r = r + 1
          while_fun.(while_fun, r)
        else
          r
        end
      end
      r = try do
          while_fun.(while_fun, r)
        catch
          {:break, {r}} -> r
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def prime_sieve(num) do
    try do
      if num <= 0 do
        raise("Invalid input, please enter a positive integer.")
      end
      sieve = []
      i = 0
      while_fun_2 = fn while_fun_2, i, sieve ->
        if i <= num do
          sieve = (sieve ++ [true])
          i = i + 1
          while_fun_2.(while_fun_2, i, sieve)
        else
          {i, sieve}
        end
      end
      {i, sieve} = try do
          while_fun_2.(while_fun_2, i, sieve)
        catch
          {:break, {i, sieve}} -> {i, sieve}
        end

      prime = []
      start = 2
      end_ = isqrt(num)
      while_fun_3 = fn while_fun_3, prime, sieve, start ->
        if start <= end_ do
          {prime, sieve} = if Enum.at(sieve, start, []) do
            prime = (prime ++ [start])
            j = start * start
            while_fun_4 = fn while_fun_4, j, sieve ->
              if j <= num do
                sieve = if Enum.at(sieve, j, []) do
                  sieve = List.replace_at(sieve, j, false)
                  sieve
                else
                  sieve
                end
                j = j + start
                while_fun_4.(while_fun_4, j, sieve)
              else
                {j, sieve}
              end
            end
            {_, sieve} = try do
                while_fun_4.(while_fun_4, j, sieve)
              catch
                {:break, {_, sieve}} -> {0, sieve}
              end

            {prime, sieve}
          else
            {prime, sieve}
          end
          start = start + 1
          while_fun_3.(while_fun_3, prime, sieve, start)
        else
          {prime, sieve, start}
        end
      end
      {prime, sieve, start} = try do
          while_fun_3.(while_fun_3, prime, sieve, start)
        catch
          {:break, {prime, sieve, start}} -> {prime, sieve, start}
        end

      k = end_ + 1
      while_fun_5 = fn while_fun_5, k, prime ->
        if k <= num do
          prime = if Enum.at(sieve, k, []) do
            prime = (prime ++ [k])
            prime
          else
            prime
          end
          k = k + 1
          while_fun_5.(while_fun_5, k, prime)
        else
          {k, prime}
        end
      end
      {k, prime} = try do
          while_fun_5.(while_fun_5, k, prime)
        catch
          {:break, {k, prime}} -> {k, prime}
        end

      throw {:return, prime}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(prime_sieve(50)))
    IO.puts(Kernel.inspect(prime_sieve(25)))
    IO.puts(Kernel.inspect(prime_sieve(10)))
    IO.puts(Kernel.inspect(prime_sieve(9)))
    IO.puts(Kernel.inspect(prime_sieve(2)))
    IO.puts(Kernel.inspect(prime_sieve(1)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
