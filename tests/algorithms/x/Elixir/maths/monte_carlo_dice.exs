# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def lcg_rand() do
    try do
      Process.put(:lcg_seed, rem((Process.get(:lcg_seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:lcg_seed)}
    catch
      {:return, val} -> val
    end
  end
  def roll() do
    try do
      rv = :erlang.float(lcg_rand())
      r = rv * 6.0 / 2147483648.0
      throw {:return, 1 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(r))}
    catch
      {:return, val} -> val
    end
  end
  def round2(x) do
    try do
      y = x * 100.0 + 0.5
      z = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(y)
      throw {:return, (:erlang.float(z)) / 100.0}
    catch
      {:return, val} -> val
    end
  end
  def throw_dice(num_throws, num_dice) do
    try do
      count_of_sum = []
      max_sum = num_dice * 6 + 1
      i = 0
      while_fun = fn while_fun, count_of_sum, i ->
        if i < max_sum do
          count_of_sum = (count_of_sum ++ [0])
          i = i + 1
          while_fun.(while_fun, count_of_sum, i)
        else
          {count_of_sum, i}
        end
      end
      {count_of_sum, i} = try do
          while_fun.(while_fun, count_of_sum, i)
        catch
          {:break, {count_of_sum, i}} -> {count_of_sum, i}
        end

      t = 0
      while_fun_2 = fn while_fun_2, count_of_sum, t ->
        if t < num_throws do
          s = 0
          d = 0
          while_fun_3 = fn while_fun_3, d, s ->
            if d < num_dice do
              s = s + roll()
              d = d + 1
              while_fun_3.(while_fun_3, d, s)
            else
              {d, s}
            end
          end
          {d, s} = try do
              while_fun_3.(while_fun_3, d, s)
            catch
              {:break, {d, s}} -> {d, s}
            end

          count_of_sum = List.replace_at(count_of_sum, s, Enum.at(count_of_sum, s) + 1)
          t = t + 1
          while_fun_2.(while_fun_2, count_of_sum, t)
        else
          {count_of_sum, t}
        end
      end
      {count_of_sum, t} = try do
          while_fun_2.(while_fun_2, count_of_sum, t)
        catch
          {:break, {count_of_sum, t}} -> {count_of_sum, t}
        end

      probability = []
      i = num_dice
      while_fun_4 = fn while_fun_4, i, probability ->
        if i < max_sum do
          p = (:erlang.float(Enum.at(count_of_sum, i))) * 100.0 / (:erlang.float(num_throws))
          probability = (probability ++ [round2(p)])
          i = i + 1
          while_fun_4.(while_fun_4, i, probability)
        else
          {i, probability}
        end
      end
      {i, probability} = try do
          while_fun_4.(while_fun_4, i, probability)
        catch
          {:break, {i, probability}} -> {i, probability}
        end

      throw {:return, probability}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      Process.put(:lcg_seed, 1)
      result = throw_dice(10000, 2)
      IO.puts(Kernel.inspect(result))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:lcg_seed, 1)
end
Main.main()
