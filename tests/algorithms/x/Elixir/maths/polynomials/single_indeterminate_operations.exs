# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def copy_list(xs) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) do
          res = (res ++ [Enum.at(xs, i)])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def polynomial_new(degree, coeffs) do
    try do
      if _len(coeffs) != degree + 1 do
        raise("The number of coefficients should be equal to the degree + 1.")
      end
      throw {:return, %{degree: degree, coefficients: copy_list(coeffs)}}
    catch
      {:return, val} -> val
    end
  end
  def add(p, q) do
    try do
      if p.degree > q.degree do
        coeffs = copy_list(p.coefficients)
        i = 0
        while_fun_2 = fn while_fun_2, coeffs, i ->
          if i <= q.degree do
            coeffs = List.replace_at(coeffs, i, Enum.at(coeffs, i) + Enum.at(q.coefficients, i))
            i = i + 1
            while_fun_2.(while_fun_2, coeffs, i)
          else
            {coeffs, i}
          end
        end
        {coeffs, i} = try do
            while_fun_2.(while_fun_2, coeffs, i)
          catch
            {:break, {coeffs, i}} -> {coeffs, i}
          end

        throw {:return, %{degree: p.degree, coefficients: coeffs}}
      else
        coeffs = copy_list(q.coefficients)
        i = 0
        while_fun_3 = fn while_fun_3, coeffs, i ->
          if i <= p.degree do
            coeffs = List.replace_at(coeffs, i, Enum.at(coeffs, i) + Enum.at(p.coefficients, i))
            i = i + 1
            while_fun_3.(while_fun_3, coeffs, i)
          else
            {coeffs, i}
          end
        end
        {coeffs, i} = try do
            while_fun_3.(while_fun_3, coeffs, i)
          catch
            {:break, {coeffs, i}} -> {coeffs, i}
          end

        throw {:return, %{degree: q.degree, coefficients: coeffs}}
      end
    catch
      {:return, val} -> val
    end
  end
  def neg(p) do
    try do
      coeffs = []
      i = 0
      while_fun_4 = fn while_fun_4, coeffs, i ->
        if i <= p.degree do
          coeffs = (coeffs ++ [-Enum.at(p.coefficients, i)])
          i = i + 1
          while_fun_4.(while_fun_4, coeffs, i)
        else
          {coeffs, i}
        end
      end
      {coeffs, i} = try do
          while_fun_4.(while_fun_4, coeffs, i)
        catch
          {:break, {coeffs, i}} -> {coeffs, i}
        end

      throw {:return, %{degree: p.degree, coefficients: coeffs}}
    catch
      {:return, val} -> val
    end
  end
  def sub(p, q) do
    try do
      throw {:return, add(p, neg(q))}
    catch
      {:return, val} -> val
    end
  end
  def mul(p, q) do
    try do
      size = p.degree + q.degree + 1
      coeffs = []
      i = 0
      while_fun_5 = fn while_fun_5, coeffs, i ->
        if i < size do
          coeffs = (coeffs ++ [0.0])
          i = i + 1
          while_fun_5.(while_fun_5, coeffs, i)
        else
          {coeffs, i}
        end
      end
      {coeffs, i} = try do
          while_fun_5.(while_fun_5, coeffs, i)
        catch
          {:break, {coeffs, i}} -> {coeffs, i}
        end

      i = 0
      while_fun_6 = fn while_fun_6, coeffs, i ->
        if i <= p.degree do
          j = 0
          while_fun_7 = fn while_fun_7, coeffs, j ->
            if j <= q.degree do
              coeffs = List.replace_at(coeffs, i + j, Enum.at(coeffs, i + j) + Enum.at(p.coefficients, i) * Enum.at(q.coefficients, j))
              j = j + 1
              while_fun_7.(while_fun_7, coeffs, j)
            else
              {coeffs, j}
            end
          end
          {coeffs, j} = try do
              while_fun_7.(while_fun_7, coeffs, j)
            catch
              {:break, {coeffs, j}} -> {coeffs, j}
            end

          i = i + 1
          while_fun_6.(while_fun_6, coeffs, i)
        else
          {coeffs, i}
        end
      end
      {coeffs, i} = try do
          while_fun_6.(while_fun_6, coeffs, i)
        catch
          {:break, {coeffs, i}} -> {coeffs, i}
        end

      throw {:return, %{degree: p.degree + q.degree, coefficients: coeffs}}
    catch
      {:return, val} -> val
    end
  end
  def power(base, exp) do
    try do
      result = 1.0
      i = 0
      while_fun_8 = fn while_fun_8, i, result ->
        if i < exp do
          result = result * base
          i = i + 1
          while_fun_8.(while_fun_8, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_8.(while_fun_8, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def evaluate(p, x) do
    try do
      result = 0.0
      i = 0
      while_fun_9 = fn while_fun_9, i, result ->
        if i <= p.degree do
          result = result + Enum.at(p.coefficients, i) * power(x, i)
          i = i + 1
          while_fun_9.(while_fun_9, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_9.(while_fun_9, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def poly_to_string(p) do
    try do
      s = ""
      i = p.degree
      while_fun_10 = fn while_fun_10, i, s ->
        if i >= 0 do
          coeff = Enum.at(p.coefficients, i)
          {s} = if coeff != 0.0 do
            {s} = if _len(s) > 0 do
              s = (if coeff > 0.0, do: (s <> " + "), else: (s <> " - "))
              {s}
            else
              {s} = if coeff < 0.0 do
                s = (s <> "-")
                {s}
              else
                {s}
              end
              {s}
            end
            abs_coeff = (if coeff < 0.0, do: -coeff, else: coeff)
            {s} = if i == 0 do
              s = (s <> Kernel.to_string(abs_coeff))
              {s}
            else
              {s} = if i == 1 do
                s = ((s <> Kernel.to_string(abs_coeff)) <> "x")
                {s}
              else
                s = (((s <> Kernel.to_string(abs_coeff)) <> "x^") <> Kernel.to_string(i))
                {s}
              end
              {s}
            end
            {s}
          else
            {s}
          end
          i = i - 1
          while_fun_10.(while_fun_10, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_10.(while_fun_10, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      {s} = if s == "" do
        s = "0"
        {s}
      else
        {s}
      end
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def derivative(p) do
    try do
      if p.degree == 0 do
        throw {:return, %{degree: 0, coefficients: [0.0]}}
      end
      coeffs = []
      i = 0
      while_fun_11 = fn while_fun_11, coeffs, i ->
        if i < p.degree do
          coeffs = (coeffs ++ [Enum.at(p.coefficients, i + 1) * :erlang.float(i + 1)])
          i = i + 1
          while_fun_11.(while_fun_11, coeffs, i)
        else
          {coeffs, i}
        end
      end
      {coeffs, i} = try do
          while_fun_11.(while_fun_11, coeffs, i)
        catch
          {:break, {coeffs, i}} -> {coeffs, i}
        end

      throw {:return, %{degree: p.degree - 1, coefficients: coeffs}}
    catch
      {:return, val} -> val
    end
  end
  def integral(p, constant) do
    try do
      coeffs = [constant]
      i = 0
      while_fun_12 = fn while_fun_12, coeffs, i ->
        if i <= p.degree do
          coeffs = (coeffs ++ [Enum.at(p.coefficients, i) / :erlang.float(i + 1)])
          i = i + 1
          while_fun_12.(while_fun_12, coeffs, i)
        else
          {coeffs, i}
        end
      end
      {coeffs, i} = try do
          while_fun_12.(while_fun_12, coeffs, i)
        catch
          {:break, {coeffs, i}} -> {coeffs, i}
        end

      throw {:return, %{degree: p.degree + 1, coefficients: coeffs}}
    catch
      {:return, val} -> val
    end
  end
  def equals(p, q) do
    try do
      if p.degree != q.degree do
        throw {:return, false}
      end
      i = 0
      while_fun_13 = fn while_fun_13, i ->
        if i <= p.degree do
          if Enum.at(p.coefficients, i) != Enum.at(q.coefficients, i) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_13.(while_fun_13, i)
        else
          i
        end
      end
      i = try do
          while_fun_13.(while_fun_13, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def not_equals(p, q) do
    try do
      throw {:return, !equals(p, q)}
    catch
      {:return, val} -> val
    end
  end
  def test_polynomial() do
    try do
      p = polynomial_new(2, [1.0, 2.0, 3.0])
      q = polynomial_new(2, [1.0, 2.0, 3.0])
      if poly_to_string(add(p, q)) != "6x^2 + 4x + 2" do
        raise("add failed")
      end
      if poly_to_string(sub(p, q)) != "0" do
        raise("sub failed")
      end
      if evaluate(p, 2.0) != 17.0 do
        raise("evaluate failed")
      end
      if poly_to_string(derivative(p)) != "6x + 2" do
        raise("derivative failed")
      end
      integ = poly_to_string(integral(p, 0.0))
      if integ != "1x^3 + 1x^2 + 1x" do
        raise("integral failed")
      end
      if !equals(p, q) do
        raise("equals failed")
      end
      if not_equals(p, q) do
        raise("not_equals failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_polynomial()
      p = polynomial_new(2, [1.0, 2.0, 3.0])
      d = derivative(p)
      IO.puts(Kernel.inspect(poly_to_string(d)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
