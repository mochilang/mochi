# Code generated by Mochi transpiler 2025-08-12 08:15 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def bubble_sort(nums) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < _len(nums) do
          arr = (arr ++ [Enum.at(nums, i, [])])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      a = 0
      while_fun_2 = fn while_fun_2, a, arr ->
        if a < n do
          b = 0
          while_fun_3 = fn while_fun_3, arr, b ->
            if b < n - a - 1 do
              {arr} = if Enum.at(arr, b, []) > Enum.at(arr, b + 1, []) do
                temp = Enum.at(arr, b, [])
                arr = List.replace_at(arr, b, Enum.at(arr, b + 1, []))
                arr = List.replace_at(arr, b + 1, temp)
                {arr}
              else
                {arr}
              end
              b = b + 1
              while_fun_3.(while_fun_3, arr, b)
            else
              {arr, b}
            end
          end
          {arr, b} = try do
              while_fun_3.(while_fun_3, arr, b)
            catch
              {:break, {arr, b}} -> {arr, b}
            end

          a = a + 1
          while_fun_2.(while_fun_2, a, arr)
        else
          {a, arr}
        end
      end
      {a, arr} = try do
          while_fun_2.(while_fun_2, a, arr)
        catch
          {:break, {a, arr}} -> {a, arr}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def find_median(nums) do
    try do
      length = _len(nums)
      div_ = div(length, 2)
      mod = rem(length, 2)
      if mod != 0 do
        throw {:return, Enum.at(nums, div_, [])}
      end
      throw {:return, (Enum.at(nums, div_, []) + Enum.at(nums, div_ - 1, [])) / 2.0}
    catch
      {:return, val} -> val
    end
  end
  def interquartile_range(nums) do
    try do
      if _len(nums) == 0 do
        raise("The list is empty. Provide a non-empty list.")
      end
      sorted = bubble_sort(nums)
      length = _len(sorted)
      div_ = div(length, 2)
      mod = rem(length, 2)
      lower = []
      i = 0
      while_fun_4 = fn while_fun_4, i, lower ->
        if i < div_ do
          lower = (lower ++ [Enum.at(sorted, i, [])])
          i = i + 1
          while_fun_4.(while_fun_4, i, lower)
        else
          {i, lower}
        end
      end
      {i, lower} = try do
          while_fun_4.(while_fun_4, i, lower)
        catch
          {:break, {i, lower}} -> {i, lower}
        end

      upper = []
      j = div_ + mod
      while_fun_5 = fn while_fun_5, j, upper ->
        if j < length do
          upper = (upper ++ [Enum.at(sorted, j, [])])
          j = j + 1
          while_fun_5.(while_fun_5, j, upper)
        else
          {j, upper}
        end
      end
      {j, upper} = try do
          while_fun_5.(while_fun_5, j, upper)
        catch
          {:break, {j, upper}} -> {j, upper}
        end

      q1 = find_median(lower)
      q3 = find_median(upper)
      throw {:return, q3 - q1}
    catch
      {:return, val} -> val
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def float_equal(a, b) do
    try do
      diff = absf(a - b)
      throw {:return, diff < 0.0000001}
    catch
      {:return, val} -> val
    end
  end
  def test_interquartile_range() do
    try do
      if !float_equal(interquartile_range([4.0, 1.0, 2.0, 3.0, 2.0]), 2.0) do
        raise("interquartile_range case1 failed")
      end
      if !float_equal(interquartile_range([-2.0, -7.0, -10.0, 9.0, 8.0, 4.0, -67.0, 45.0]), 17.0) do
        raise("interquartile_range case2 failed")
      end
      if !float_equal(interquartile_range([-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1]), 17.2) do
        raise("interquartile_range case3 failed")
      end
      if !float_equal(interquartile_range([0.0, 0.0, 0.0, 0.0, 0.0]), 0.0) do
        raise("interquartile_range case4 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_interquartile_range()
      IO.puts(Kernel.inspect(interquartile_range([4.0, 1.0, 2.0, 3.0, 2.0])))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
