# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_val(num) do
    try do
      throw {:return, ((if num < 0.0, do: -num, else: num))}
    catch
      {:return, val} -> val
    end
  end
  def abs_min(x) do
    try do
      if _len(x) == 0 do
        raise("abs_min() arg is an empty sequence")
      end
      j = Enum.at(x, 0)
      idx = 0
      while_fun = fn while_fun, idx, j ->
        if idx < _len(x) do
          i = Enum.at(x, idx)
          {j} = if abs_val(:erlang.float(i)) < abs_val(:erlang.float(j)) do
            j = i
            {j}
          else
            {j}
          end
          idx = idx + 1
          while_fun.(while_fun, idx, j)
        else
          {idx, j}
        end
      end
      {idx, j} = try do
          while_fun.(while_fun, idx, j)
        catch
          {:break, {idx, j}} -> {idx, j}
        end

      throw {:return, j}
    catch
      {:return, val} -> val
    end
  end
  def abs_max(x) do
    try do
      if _len(x) == 0 do
        raise("abs_max() arg is an empty sequence")
      end
      j = Enum.at(x, 0)
      idx = 0
      while_fun_2 = fn while_fun_2, idx, j ->
        if idx < _len(x) do
          i = Enum.at(x, idx)
          {j} = if abs_val(:erlang.float(i)) > abs_val(:erlang.float(j)) do
            j = i
            {j}
          else
            {j}
          end
          idx = idx + 1
          while_fun_2.(while_fun_2, idx, j)
        else
          {idx, j}
        end
      end
      {idx, j} = try do
          while_fun_2.(while_fun_2, idx, j)
        catch
          {:break, {idx, j}} -> {idx, j}
        end

      throw {:return, j}
    catch
      {:return, val} -> val
    end
  end
  def abs_max_sort(x) do
    try do
      if _len(x) == 0 do
        raise("abs_max_sort() arg is an empty sequence")
      end
      arr = []
      i = 0
      while_fun_3 = fn while_fun_3, arr, i ->
        if i < _len(x) do
          arr = (arr ++ [Enum.at(x, i)])
          i = i + 1
          while_fun_3.(while_fun_3, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_3.(while_fun_3, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      a = 0
      while_fun_4 = fn while_fun_4, a, arr ->
        if a < n do
          b = 0
          while_fun_5 = fn while_fun_5, arr, b ->
            if b < n - a - 1 do
              {arr} = if abs_val(:erlang.float(Enum.at(arr, b))) > abs_val(:erlang.float(Enum.at(arr, b + 1))) do
                temp = Enum.at(arr, b)
                arr = List.replace_at(arr, b, Enum.at(arr, b + 1))
                arr = List.replace_at(arr, b + 1, temp)
                {arr}
              else
                {arr}
              end
              b = b + 1
              while_fun_5.(while_fun_5, arr, b)
            else
              {arr, b}
            end
          end
          {arr, b} = try do
              while_fun_5.(while_fun_5, arr, b)
            catch
              {:break, {arr, b}} -> {arr, b}
            end

          a = a + 1
          while_fun_4.(while_fun_4, a, arr)
        else
          {a, arr}
        end
      end
      {a, arr} = try do
          while_fun_4.(while_fun_4, a, arr)
        catch
          {:break, {a, arr}} -> {a, arr}
        end

      throw {:return, Enum.at(arr, n - 1)}
    catch
      {:return, val} -> val
    end
  end
  def test_abs_val() do
    try do
      if abs_val(0.0) != 0.0 do
        raise("abs_val(0) failed")
      end
      if abs_val(34.0) != 34.0 do
        raise("abs_val(34) failed")
      end
      if abs_val(-100000000000.0) != 100000000000.0 do
        raise("abs_val large failed")
      end
      a = [-3, -1, 2, -11]
      if abs_max(a) != (-11) do
        raise("abs_max failed")
      end
      if abs_max_sort(a) != (-11) do
        raise("abs_max_sort failed")
      end
      if abs_min(a) != (-1) do
        raise("abs_min failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_abs_val()
      IO.puts(Kernel.inspect(abs_val(-34.0)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
