# Code generated by Mochi transpiler 2025-08-12 07:47 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def pow2_int(n) do
    try do
      result = 1
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < n do
          result = result * 2
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def pow2_float(n) do
    try do
      result = 1.0
      {result} = if n >= 0 do
        i = 0
        while_fun_2 = fn while_fun_2, i, result ->
          if i < n do
            result = result * 2.0
            i = i + 1
            while_fun_2.(while_fun_2, i, result)
          else
            {i, result}
          end
        end
        {i, result} = try do
            while_fun_2.(while_fun_2, i, result)
          catch
            {:break, {i, result}} -> {i, result}
          end

        {result}
      else
        i = 0
        m = 0 - n
        while_fun_3 = fn while_fun_3, i, result ->
          if i < m do
            result = result / 2.0
            i = i + 1
            while_fun_3.(while_fun_3, i, result)
          else
            {i, result}
          end
        end
        {i, result} = try do
            while_fun_3.(while_fun_3, i, result)
          catch
            {:break, {i, result}} -> {i, result}
          end

        {result}
      end
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def lshift(num, k) do
    try do
      result = num
      i = 0
      while_fun_4 = fn while_fun_4, i, result ->
        if i < k do
          result = result * 2
          i = i + 1
          while_fun_4.(while_fun_4, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_4.(while_fun_4, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def rshift(num, k) do
    try do
      result = num
      i = 0
      while_fun_5 = fn while_fun_5, i, result ->
        if i < k do
          result = div((result - (rem(result, 2))), 2)
          i = i + 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def log2_floor(x) do
    try do
      n = x
      e = 0
      while_fun_6 = fn while_fun_6, e, n ->
        if n >= 2.0 do
          n = n / 2.0
          e = e + 1
          while_fun_6.(while_fun_6, e, n)
        else
          {e, n}
        end
      end
      {e, n} = try do
          while_fun_6.(while_fun_6, e, n)
        catch
          {:break, {e, n}} -> {e, n}
        end

      while_fun_7 = fn while_fun_7, e, n ->
        if n < 1.0 do
          n = n * 2.0
          e = e - 1
          while_fun_7.(while_fun_7, e, n)
        else
          {e, n}
        end
      end
      {e, n} = try do
          while_fun_7.(while_fun_7, e, n)
        catch
          {:break, {e, n}} -> {e, n}
        end

      throw {:return, e}
    catch
      {:return, val} -> val
    end
  end
  def float_to_bits(x) do
    try do
      num = x
      sign = 0
      {num, sign} = if num < 0.0 do
        sign = 1
        num = -num
        {num, sign}
      else
        {num, sign}
      end
      exp = log2_floor(num)
      pow = pow2_float(exp)
      normalized = num / pow
      frac = normalized - 1.0
      mantissa = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((frac * pow2_float(23)))
      exp_bits = exp + 127
      throw {:return, lshift(sign, 31) + lshift(exp_bits, 23) + mantissa}
    catch
      {:return, val} -> val
    end
  end
  def bits_to_float(bits) do
    try do
      sign_bit = rem(rshift(bits, 31), 2)
      sign = 1.0
      {sign} = if sign_bit == 1 do
        sign = -1.0
        {sign}
      else
        {sign}
      end
      exp_bits = rem(rshift(bits, 23), 256)
      exp = exp_bits - 127
      mantissa_bits = rem(bits, pow2_int(23))
      mantissa = 1.0 + (:erlang.float(mantissa_bits)) / pow2_float(23)
      throw {:return, sign * mantissa * pow2_float(exp)}
    catch
      {:return, val} -> val
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun_8 = fn while_fun_8, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_8.(while_fun_8, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_8.(while_fun_8, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def is_close(a, b, rel_tol) do
    try do
      throw {:return, absf(a - b) <= rel_tol * absf(b)}
    catch
      {:return, val} -> val
    end
  end
  def fast_inverse_sqrt(number) do
    try do
      if number <= 0.0 do
        raise("Input must be a positive number.")
      end
      i = float_to_bits(number)
      magic = 1597463007
      y_bits = magic - rshift(i, 1)
      y = bits_to_float(y_bits)
      y = y * (1.5 - 0.5 * number * y * y)
      throw {:return, y}
    catch
      {:return, val} -> val
    end
  end
  def test_fast_inverse_sqrt() do
    try do
      if absf(fast_inverse_sqrt(10.0) - 0.3156857923527257) > 0.0001 do
        raise("fast_inverse_sqrt(10) failed")
      end
      if absf(fast_inverse_sqrt(4.0) - 0.49915357479239103) > 0.0001 do
        raise("fast_inverse_sqrt(4) failed")
      end
      if absf(fast_inverse_sqrt(4.1) - 0.4932849504615651) > 0.0001 do
        raise("fast_inverse_sqrt(4.1) failed")
      end
      i = 50
      while_fun_9 = fn while_fun_9, i ->
        if i < 60 do
          y = fast_inverse_sqrt(:erlang.float(i))
          actual = 1.0 / sqrtApprox(:erlang.float(i))
          if !is_close(y, actual, 0.00132) do
            raise("relative error too high")
          end
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_fast_inverse_sqrt()
      i = 5
      while_fun_10 = fn while_fun_10, i ->
        if i <= 100 do
          diff = (1.0 / sqrtApprox(:erlang.float(i))) - fast_inverse_sqrt(:erlang.float(i))
          IO.puts(((Kernel.to_string(i) <> ": ") <> Kernel.to_string(diff)))
          i = i + 5
          while_fun_10.(while_fun_10, i)
        else
          i
        end
      end
      i = try do
          while_fun_10.(while_fun_10, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
