# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def gcd(a, b) do
    try do
      x = (if a < 0, do: -a, else: a)
      y = (if b < 0, do: -b, else: b)
      while_fun = fn while_fun, x, y ->
        if y != 0 do
          t = rem(x, y)
          x = y
          y = t
          while_fun.(while_fun, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun.(while_fun, x, y)
        catch
          {:break, {x, y}} -> {x, y}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def rand_fn(value, step, modulus) do
    try do
      throw {:return, rem((value * value + step), modulus)}
    catch
      {:return, val} -> val
    end
  end
  def pollard_rho(num, seed, step, attempts) do
    try do
      if num < 2 do
        raise("The input value cannot be less than 2")
      end
      if num > 2 && rem(num, 2) == 0 do
        throw {:return, %{factor: 2, ok: true}}
      end
      s = seed
      st = step
      i = 0
      while_fun_2 = fn while_fun_2, i, s, st ->
        if i < attempts do
          {i, s, st} = try do
            tortoise = s
            hare = s
            while_fun_3 = fn while_fun_3, hare, tortoise ->
              if true do
                {hare, tortoise} = try do
                  tortoise = rand_fn(tortoise, st, num)
                  hare = rand_fn(hare, st, num)
                  hare = rand_fn(hare, st, num)
                  divisor = gcd(hare - tortoise, num)
                  if divisor == 1 do
                    throw {:continue, {hare, tortoise}}
                  else
                    if divisor == num do
                      throw {:break, {hare, tortoise}}
                    else
                      throw {:return, %{factor: divisor, ok: true}}
                    end
                  end
                  {hare, tortoise}
                catch
                  {:continue, {hare, tortoise}} -> {hare, tortoise}
                end
                while_fun_3.(while_fun_3, hare, tortoise)
              else
                {hare, tortoise}
              end
            end
            {hare, tortoise} = try do
                while_fun_3.(while_fun_3, hare, tortoise)
              catch
                {:break, {hare, tortoise}} -> {hare, tortoise}
              end

            s = hare
            st = st + 1
            i = i + 1
            {i, s, st}
          catch
            {:continue, {i, s, st}} -> {i, s, st}
          end
          while_fun_2.(while_fun_2, i, s, st)
        else
          {i, s, st}
        end
      end
      {i, s, st} = try do
          while_fun_2.(while_fun_2, i, s, st)
        catch
          {:break, {i, s, st}} -> {i, s, st}
        end

      throw {:return, %{factor: 0, ok: false}}
    catch
      {:return, val} -> val
    end
  end
  def test_pollard_rho() do
    try do
      r1 = pollard_rho(8051, 2, 1, 5)
      if !r1.ok || (r1.factor != 83 && r1.factor != 97) do
        raise("test1 failed")
      end
      r2 = pollard_rho(10403, 2, 1, 5)
      if !r2.ok || (r2.factor != 101 && r2.factor != 103) do
        raise("test2 failed")
      end
      r3 = pollard_rho(100, 2, 1, 3)
      if !r3.ok || r3.factor != 2 do
        raise("test3 failed")
      end
      r4 = pollard_rho(17, 2, 1, 3)
      if r4.ok do
        raise("test4 failed")
      end
      r5 = pollard_rho(17 * 17 * 17, 2, 1, 3)
      if !r5.ok || r5.factor != 17 do
        raise("test5 failed")
      end
      r6 = pollard_rho(17 * 17 * 17, 2, 1, 1)
      if r6.ok do
        raise("test6 failed")
      end
      r7 = pollard_rho(3 * 5 * 7, 2, 1, 3)
      if !r7.ok || r7.factor != 21 do
        raise("test7 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_pollard_rho()
      a = pollard_rho(100, 2, 1, 3)
      if a.ok do
        IO.puts(Kernel.to_string(a.factor))
      else
        IO.puts("None")
      end
      b = pollard_rho(17, 2, 1, 3)
      if b.ok do
        IO.puts(Kernel.to_string(b.factor))
      else
        IO.puts("None")
      end
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
