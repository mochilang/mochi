# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def prime_sieve_eratosthenes(num) do
    try do
      if num <= 0 do
        raise("Input must be a positive integer")
      end
      primes = []
      i = 0
      while_fun = fn while_fun, i, primes ->
        if i <= num do
          primes = (primes ++ [true])
          i = i + 1
          while_fun.(while_fun, i, primes)
        else
          {i, primes}
        end
      end
      {i, primes} = try do
          while_fun.(while_fun, i, primes)
        catch
          {:break, {i, primes}} -> {i, primes}
        end

      p = 2
      while_fun_2 = fn while_fun_2, p, primes ->
        if p * p <= num do
          {primes} = if Enum.at(primes, p) do
            j = p * p
            while_fun_3 = fn while_fun_3, j, primes ->
              if j <= num do
                primes = List.replace_at(primes, j, false)
                j = j + p
                while_fun_3.(while_fun_3, j, primes)
              else
                {j, primes}
              end
            end
            {j, primes} = try do
                while_fun_3.(while_fun_3, j, primes)
              catch
                {:break, {j, primes}} -> {j, primes}
              end

            {primes}
          else
            {primes}
          end
          p = p + 1
          while_fun_2.(while_fun_2, p, primes)
        else
          {p, primes}
        end
      end
      {p, primes} = try do
          while_fun_2.(while_fun_2, p, primes)
        catch
          {:break, {p, primes}} -> {p, primes}
        end

      result = []
      k = 2
      while_fun_4 = fn while_fun_4, k, result ->
        if k <= num do
          {result} = if Enum.at(primes, k) do
            result = (result ++ [k])
            {result}
          else
            {result}
          end
          k = k + 1
          while_fun_4.(while_fun_4, k, result)
        else
          {k, result}
        end
      end
      {k, result} = try do
          while_fun_4.(while_fun_4, k, result)
        catch
          {:break, {k, result}} -> {k, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def list_eq(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i < _len(a) do
          if Enum.at(a, i) != Enum.at(b, i) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def test_prime_sieve_eratosthenes() do
    try do
      if !list_eq(prime_sieve_eratosthenes(10), [2, 3, 5, 7]) do
        raise("test 10 failed")
      end
      if !list_eq(prime_sieve_eratosthenes(20), [2, 3, 5, 7, 11, 13, 17, 19]) do
        raise("test 20 failed")
      end
      if !list_eq(prime_sieve_eratosthenes(2), [2]) do
        raise("test 2 failed")
      end
      if _len(prime_sieve_eratosthenes(1)) != 0 do
        raise("test 1 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_prime_sieve_eratosthenes()
      IO.puts(Kernel.inspect(prime_sieve_eratosthenes(20)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
