# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def contains_int(xs, x) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(xs) do
          if Enum.at(xs, i) == x do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def contains_string(xs, x) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(xs) do
          if Enum.at(xs, i) == x do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def count_int(xs, x) do
    try do
      cnt = 0
      i = 0
      while_fun_3 = fn while_fun_3, cnt, i ->
        if i < _len(xs) do
          {cnt} = if Enum.at(xs, i) == x do
            cnt = cnt + 1
            {cnt}
          else
            {cnt}
          end
          i = i + 1
          while_fun_3.(while_fun_3, cnt, i)
        else
          {cnt, i}
        end
      end
      {cnt, i} = try do
          while_fun_3.(while_fun_3, cnt, i)
        catch
          {:break, {cnt, i}} -> {cnt, i}
        end

      throw {:return, cnt}
    catch
      {:return, val} -> val
    end
  end
  def count_string(xs, x) do
    try do
      cnt = 0
      i = 0
      while_fun_4 = fn while_fun_4, cnt, i ->
        if i < _len(xs) do
          {cnt} = if Enum.at(xs, i) == x do
            cnt = cnt + 1
            {cnt}
          else
            {cnt}
          end
          i = i + 1
          while_fun_4.(while_fun_4, cnt, i)
        else
          {cnt, i}
        end
      end
      {cnt, i} = try do
          while_fun_4.(while_fun_4, cnt, i)
        catch
          {:break, {cnt, i}} -> {cnt, i}
        end

      throw {:return, cnt}
    catch
      {:return, val} -> val
    end
  end
  def sort_int(xs) do
    try do
      arr = xs
      i = 0
      while_fun_5 = fn while_fun_5, arr, i ->
        if i < _len(arr) do
          j = i + 1
          while_fun_6 = fn while_fun_6, arr, j ->
            if j < _len(arr) do
              {arr} = if Enum.at(arr, j) < Enum.at(arr, i) do
                tmp = Enum.at(arr, i)
                arr = List.replace_at(arr, i, Enum.at(arr, j))
                arr = List.replace_at(arr, j, tmp)
                {arr}
              else
                {arr}
              end
              j = j + 1
              while_fun_6.(while_fun_6, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_6.(while_fun_6, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun_5.(while_fun_5, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_5.(while_fun_5, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def sort_string(xs) do
    try do
      arr = xs
      i = 0
      while_fun_7 = fn while_fun_7, arr, i ->
        if i < _len(arr) do
          j = i + 1
          while_fun_8 = fn while_fun_8, arr, j ->
            if j < _len(arr) do
              {arr} = if Enum.at(arr, j) < Enum.at(arr, i) do
                tmp = Enum.at(arr, i)
                arr = List.replace_at(arr, i, Enum.at(arr, j))
                arr = List.replace_at(arr, j, tmp)
                {arr}
              else
                {arr}
              end
              j = j + 1
              while_fun_8.(while_fun_8, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_8.(while_fun_8, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun_7.(while_fun_7, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_7.(while_fun_7, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def mode_int(lst) do
    try do
      if _len(lst) == 0 do
        throw {:return, []}
      end
      counts = []
      i = 0
      while_fun_9 = fn while_fun_9, counts, i ->
        if i < _len(lst) do
          counts = (counts ++ [count_int(lst, Enum.at(lst, i))])
          i = i + 1
          while_fun_9.(while_fun_9, counts, i)
        else
          {counts, i}
        end
      end
      {counts, i} = try do
          while_fun_9.(while_fun_9, counts, i)
        catch
          {:break, {counts, i}} -> {counts, i}
        end

      max_count = 0
      i = 0
      while_fun_10 = fn while_fun_10, i, max_count ->
        if i < _len(counts) do
          {max_count} = if Enum.at(counts, i) > max_count do
            max_count = Enum.at(counts, i)
            {max_count}
          else
            {max_count}
          end
          i = i + 1
          while_fun_10.(while_fun_10, i, max_count)
        else
          {i, max_count}
        end
      end
      {i, max_count} = try do
          while_fun_10.(while_fun_10, i, max_count)
        catch
          {:break, {i, max_count}} -> {i, max_count}
        end

      modes = []
      i = 0
      while_fun_11 = fn while_fun_11, i, modes ->
        if i < _len(lst) do
          {modes} = if Enum.at(counts, i) == max_count do
            v = Enum.at(lst, i)
            {modes} = if !contains_int(modes, v) do
              modes = (modes ++ [v])
              {modes}
            else
              {modes}
            end
            {modes}
          else
            {modes}
          end
          i = i + 1
          while_fun_11.(while_fun_11, i, modes)
        else
          {i, modes}
        end
      end
      {i, modes} = try do
          while_fun_11.(while_fun_11, i, modes)
        catch
          {:break, {i, modes}} -> {i, modes}
        end

      throw {:return, sort_int(modes)}
    catch
      {:return, val} -> val
    end
  end
  def mode_string(lst) do
    try do
      if _len(lst) == 0 do
        throw {:return, []}
      end
      counts = []
      i = 0
      while_fun_12 = fn while_fun_12, counts, i ->
        if i < _len(lst) do
          counts = (counts ++ [count_string(lst, Enum.at(lst, i))])
          i = i + 1
          while_fun_12.(while_fun_12, counts, i)
        else
          {counts, i}
        end
      end
      {counts, i} = try do
          while_fun_12.(while_fun_12, counts, i)
        catch
          {:break, {counts, i}} -> {counts, i}
        end

      max_count = 0
      i = 0
      while_fun_13 = fn while_fun_13, i, max_count ->
        if i < _len(counts) do
          {max_count} = if Enum.at(counts, i) > max_count do
            max_count = Enum.at(counts, i)
            {max_count}
          else
            {max_count}
          end
          i = i + 1
          while_fun_13.(while_fun_13, i, max_count)
        else
          {i, max_count}
        end
      end
      {i, max_count} = try do
          while_fun_13.(while_fun_13, i, max_count)
        catch
          {:break, {i, max_count}} -> {i, max_count}
        end

      modes = []
      i = 0
      while_fun_14 = fn while_fun_14, i, modes ->
        if i < _len(lst) do
          {modes} = if Enum.at(counts, i) == max_count do
            v = Enum.at(lst, i)
            {modes} = if !contains_string(modes, v) do
              modes = (modes ++ [v])
              {modes}
            else
              {modes}
            end
            {modes}
          else
            {modes}
          end
          i = i + 1
          while_fun_14.(while_fun_14, i, modes)
        else
          {i, modes}
        end
      end
      {i, modes} = try do
          while_fun_14.(while_fun_14, i, modes)
        catch
          {:break, {i, modes}} -> {i, modes}
        end

      throw {:return, sort_string(modes)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(mode_int([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])))
    IO.puts(Kernel.inspect(mode_int([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])))
    IO.puts(Kernel.inspect(mode_int([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])))
    IO.puts(Kernel.inspect(mode_string(["x", "y", "y", "z"])))
    IO.puts(Kernel.inspect(mode_string(["x", "x", "y", "y", "z"])))
  end
end
Main.main()
