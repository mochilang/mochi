# Code generated by Mochi transpiler 2025-08-17 13:17 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def ugly_numbers(n) do
    try do
      if n <= 0 do
        throw {:return, 1}
      end
      ugly_nums = []
      ugly_nums = (ugly_nums ++ [1])
      i2 = 0
      i3 = 0
      i5 = 0
      next_2 = 2
      next_3 = 3
      next_5 = 5
      count = 1
      while_fun = fn while_fun, count, i2, i3, i5, next_2, next_3, next_5, ugly_nums ->
        if count < n do
          next_num = (if next_2 < next_3, do: (if next_2 < next_5, do: next_2, else: next_5), else: (if next_3 < next_5, do: next_3, else: next_5))
          ugly_nums = (ugly_nums ++ [next_num])
          {i2, next_2} = if next_num == next_2 do
            i2 = i2 + 1
            next_2 = Enum.at(ugly_nums, i2, []) * 2
            {i2, next_2}
          else
            {i2, next_2}
          end
          {i3, next_3} = if next_num == next_3 do
            i3 = i3 + 1
            next_3 = Enum.at(ugly_nums, i3, []) * 3
            {i3, next_3}
          else
            {i3, next_3}
          end
          {i5, next_5} = if next_num == next_5 do
            i5 = i5 + 1
            next_5 = Enum.at(ugly_nums, i5, []) * 5
            {i5, next_5}
          else
            {i5, next_5}
          end
          count = count + 1
          while_fun.(while_fun, count, i2, i3, i5, next_2, next_3, next_5, ugly_nums)
        else
          {count, i2, i3, i5, next_2, next_3, next_5, ugly_nums}
        end
      end
      {count, i2, i3, i5, next_2, next_3, next_5, ugly_nums} = try do
          while_fun.(while_fun, count, i2, i3, i5, next_2, next_3, next_5, ugly_nums)
        catch
          {:break, {count, i2, i3, i5, next_2, next_3, next_5, ugly_nums}} -> {count, i2, i3, i5, next_2, next_3, next_5, ugly_nums}
        end

      throw {:return, Enum.at(ugly_nums, _len(ugly_nums) - 1, [])}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(ugly_numbers(100)))
    IO.puts(Kernel.inspect(ugly_numbers(0)))
    IO.puts(Kernel.inspect(ugly_numbers(20)))
    IO.puts(Kernel.inspect(ugly_numbers(-5)))
    IO.puts(Kernel.inspect(ugly_numbers(200)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
