# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  def pow_int(base, exp) do
    try do
      result = 1
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < exp do
          result = result * base
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def armstrong_number(n) do
    try do
      if n < 1 do
        throw {:return, false}
      end
      digits = 0
      temp = n
      while_fun_2 = fn while_fun_2, digits, temp ->
        if temp > 0 do
          temp = div(temp, 10)
          digits = digits + 1
          while_fun_2.(while_fun_2, digits, temp)
        else
          {digits, temp}
        end
      end
      {digits, temp} = try do
          while_fun_2.(while_fun_2, digits, temp)
        catch
          {:break, {digits, temp}} -> {digits, temp}
        end

      total = 0
      temp = n
      while_fun_3 = fn while_fun_3, temp, total ->
        if temp > 0 do
          rem_ = rem(temp, 10)
          total = total + pow_int(rem_, digits)
          temp = div(temp, 10)
          while_fun_3.(while_fun_3, temp, total)
        else
          {temp, total}
        end
      end
      {temp, total} = try do
          while_fun_3.(while_fun_3, temp, total)
        catch
          {:break, {temp, total}} -> {temp, total}
        end

      throw {:return, total == n}
    catch
      {:return, val} -> val
    end
  end
  def pluperfect_number(n) do
    try do
      if n < 1 do
        throw {:return, false}
      end
      digit_histogram = []
      i = 0
      while_fun_4 = fn while_fun_4, digit_histogram, i ->
        if i < 10 do
          digit_histogram = (digit_histogram ++ [0])
          i = i + 1
          while_fun_4.(while_fun_4, digit_histogram, i)
        else
          {digit_histogram, i}
        end
      end
      {digit_histogram, i} = try do
          while_fun_4.(while_fun_4, digit_histogram, i)
        catch
          {:break, {digit_histogram, i}} -> {digit_histogram, i}
        end

      digit_total = 0
      temp = n
      while_fun_5 = fn while_fun_5, digit_histogram, digit_total, temp ->
        if temp > 0 do
          rem_ = rem(temp, 10)
          digit_histogram = List.replace_at(digit_histogram, rem_, Enum.at(digit_histogram, rem_) + 1)
          digit_total = digit_total + 1
          temp = div(temp, 10)
          while_fun_5.(while_fun_5, digit_histogram, digit_total, temp)
        else
          {digit_histogram, digit_total, temp}
        end
      end
      {digit_histogram, digit_total, temp} = try do
          while_fun_5.(while_fun_5, digit_histogram, digit_total, temp)
        catch
          {:break, {digit_histogram, digit_total, temp}} -> {digit_histogram, digit_total, temp}
        end

      total = 0
      i = 0
      while_fun_6 = fn while_fun_6, i, total ->
        if i < 10 do
          {total} = if Enum.at(digit_histogram, i) > 0 do
            total = total + Enum.at(digit_histogram, i) * pow_int(i, digit_total)
            {total}
          else
            {total}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_6.(while_fun_6, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total == n}
    catch
      {:return, val} -> val
    end
  end
  def narcissistic_number(n) do
    try do
      if n < 1 do
        throw {:return, false}
      end
      digits = 0
      temp = n
      while_fun_7 = fn while_fun_7, digits, temp ->
        if temp > 0 do
          temp = div(temp, 10)
          digits = digits + 1
          while_fun_7.(while_fun_7, digits, temp)
        else
          {digits, temp}
        end
      end
      {digits, temp} = try do
          while_fun_7.(while_fun_7, digits, temp)
        catch
          {:break, {digits, temp}} -> {digits, temp}
        end

      temp = n
      total = 0
      while_fun_8 = fn while_fun_8, temp, total ->
        if temp > 0 do
          rem_ = rem(temp, 10)
          total = total + pow_int(rem_, digits)
          temp = div(temp, 10)
          while_fun_8.(while_fun_8, temp, total)
        else
          {temp, total}
        end
      end
      {temp, total} = try do
          while_fun_8.(while_fun_8, temp, total)
        catch
          {:break, {temp, total}} -> {temp, total}
        end

      throw {:return, total == n}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(armstrong_number(371)))
    IO.puts(Kernel.inspect(armstrong_number(200)))
    IO.puts(Kernel.inspect(pluperfect_number(371)))
    IO.puts(Kernel.inspect(pluperfect_number(200)))
    IO.puts(Kernel.inspect(narcissistic_number(371)))
    IO.puts(Kernel.inspect(narcissistic_number(200)))
  end
end
Main.main()
