# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def bubble_sort(xs) do
    try do
      arr = xs
      n = _len(arr)
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < n do
          j = 0
          while_fun_2 = fn while_fun_2, arr, j ->
            if j < n - i - 1 do
              {arr} = if Enum.at(arr, j) > Enum.at(arr, j + 1) do
                tmp = Enum.at(arr, j)
                arr = List.replace_at(arr, j, Enum.at(arr, j + 1))
                arr = List.replace_at(arr, j + 1, tmp)
                {arr}
              else
                {arr}
              end
              j = j + 1
              while_fun_2.(while_fun_2, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_2.(while_fun_2, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def factors(num) do
    try do
      values = [1]
      i = 2
      while_fun_3 = fn while_fun_3, i, values ->
        if i * i <= num do
          {values} = if rem(num, i) == 0 do
            values = (values ++ [i])
            d = div(num, i)
            {values} = if d != i do
              values = (values ++ [d])
              {values}
            else
              {values}
            end
            {values}
          else
            {values}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, values)
        else
          {i, values}
        end
      end
      {i, values} = try do
          while_fun_3.(while_fun_3, i, values)
        catch
          {:break, {i, values}} -> {i, values}
        end

      throw {:return, bubble_sort(values)}
    catch
      {:return, val} -> val
    end
  end
  def sum_list(xs) do
    try do
      total = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, total ->
        if i < _len(xs) do
          total = total + Enum.at(xs, i)
          i = i + 1
          while_fun_4.(while_fun_4, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_4.(while_fun_4, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def abundant(n) do
    try do
      throw {:return, sum_list(factors(n)) > n}
    catch
      {:return, val} -> val
    end
  end
  def semi_perfect(number) do
    try do
      if number <= 0 do
        throw {:return, true}
      end
      values = factors(number)
      possible = []
      j = 0
      while_fun_5 = fn while_fun_5, j, possible ->
        if j <= number do
          possible = (possible ++ [j == 0])
          j = j + 1
          while_fun_5.(while_fun_5, j, possible)
        else
          {j, possible}
        end
      end
      {j, possible} = try do
          while_fun_5.(while_fun_5, j, possible)
        catch
          {:break, {j, possible}} -> {j, possible}
        end

      idx = 0
      while_fun_6 = fn while_fun_6, idx, possible ->
        if idx < _len(values) do
          v = Enum.at(values, idx)
          s = number
          while_fun_7 = fn while_fun_7, possible, s ->
            if s >= v do
              {possible} = if Enum.at(possible, s - v) do
                possible = List.replace_at(possible, s, true)
                {possible}
              else
                {possible}
              end
              s = s - 1
              while_fun_7.(while_fun_7, possible, s)
            else
              {possible, s}
            end
          end
          {possible, s} = try do
              while_fun_7.(while_fun_7, possible, s)
            catch
              {:break, {possible, s}} -> {possible, s}
            end

          idx = idx + 1
          while_fun_6.(while_fun_6, idx, possible)
        else
          {idx, possible}
        end
      end
      {idx, possible} = try do
          while_fun_6.(while_fun_6, idx, possible)
        catch
          {:break, {idx, possible}} -> {idx, possible}
        end

      throw {:return, Enum.at(possible, number)}
    catch
      {:return, val} -> val
    end
  end
  def weird(number) do
    try do
      throw {:return, abundant(number) && semi_perfect(number) == false}
    catch
      {:return, val} -> val
    end
  end
  def run_tests() do
    try do
      if factors(12) != [1, 2, 3, 4, 6] do
        raise("factors 12 failed")
      end
      if factors(1) != [1] do
        raise("factors 1 failed")
      end
      if factors(100) != [1, 2, 4, 5, 10, 20, 25, 50] do
        raise("factors 100 failed")
      end
      if abundant(0) != true do
        raise("abundant 0 failed")
      end
      if abundant(1) != false do
        raise("abundant 1 failed")
      end
      if abundant(12) != true do
        raise("abundant 12 failed")
      end
      if abundant(13) != false do
        raise("abundant 13 failed")
      end
      if abundant(20) != true do
        raise("abundant 20 failed")
      end
      if semi_perfect(0) != true do
        raise("semi_perfect 0 failed")
      end
      if semi_perfect(1) != true do
        raise("semi_perfect 1 failed")
      end
      if semi_perfect(12) != true do
        raise("semi_perfect 12 failed")
      end
      if semi_perfect(13) != false do
        raise("semi_perfect 13 failed")
      end
      if weird(0) != false do
        raise("weird 0 failed")
      end
      if weird(70) != true do
        raise("weird 70 failed")
      end
      if weird(77) != false do
        raise("weird 77 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      run_tests()
      nums = [69, 70, 71]
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < _len(nums) do
          n = Enum.at(nums, i)
          if weird(n) do
            IO.puts((Kernel.to_string(n) <> " is weird."))
          else
            IO.puts((Kernel.to_string(n) <> " is not weird."))
          end
          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      i = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
end
Main.main()
