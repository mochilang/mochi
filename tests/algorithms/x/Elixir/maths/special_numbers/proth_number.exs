# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  def pow2(exp) do
    try do
      result = 1
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < exp do
          result = result * 2
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def proth(number) do
    try do
      if number < 1 do
        raise("Input value must be > 0")
      end
      if number == 1 do
        throw {:return, 3}
      end
      if number == 2 do
        throw {:return, 5}
      end
      temp = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(number, 3)))
      pow = 1
      block_index = 1
      while_fun_2 = fn while_fun_2, block_index, pow ->
        if pow <= temp do
          pow = pow * 2
          block_index = block_index + 1
          while_fun_2.(while_fun_2, block_index, pow)
        else
          {block_index, pow}
        end
      end
      {block_index, pow} = try do
          while_fun_2.(while_fun_2, block_index, pow)
        catch
          {:break, {block_index, pow}} -> {block_index, pow}
        end

      proth_list = [3, 5]
      proth_index = 2
      increment = 3
      block = 1
      while_fun_3 = fn while_fun_3, block, increment, proth_index, proth_list ->
        if block < block_index do
          i = 0
          while_fun_4 = fn while_fun_4, i, proth_index, proth_list ->
            if i < increment do
              next_val = pow2(block + 1) + Enum.at(proth_list, proth_index - 1)
              proth_list = (proth_list ++ [next_val])
              proth_index = proth_index + 1
              i = i + 1
              while_fun_4.(while_fun_4, i, proth_index, proth_list)
            else
              {i, proth_index, proth_list}
            end
          end
          {i, proth_index, proth_list} = try do
              while_fun_4.(while_fun_4, i, proth_index, proth_list)
            catch
              {:break, {i, proth_index, proth_list}} -> {i, proth_index, proth_list}
            end

          increment = increment * 2
          block = block + 1
          while_fun_3.(while_fun_3, block, increment, proth_index, proth_list)
        else
          {block, increment, proth_index, proth_list}
        end
      end
      {block, increment, proth_index, proth_list} = try do
          while_fun_3.(while_fun_3, block, increment, proth_index, proth_list)
        catch
          {:break, {block, increment, proth_index, proth_list}} -> {block, increment, proth_index, proth_list}
        end

      throw {:return, Enum.at(proth_list, number - 1)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      n = 1
      while_fun_5 = fn while_fun_5, n ->
        if n <= 10 do
          value = proth(n)
          IO.puts(((("The " <> Kernel.to_string(n)) <> "th Proth number: ") <> Kernel.to_string(value)))
          n = n + 1
          while_fun_5.(while_fun_5, n)
        else
          n
        end
      end
      n = try do
          while_fun_5.(while_fun_5, n)
        catch
          {:break, {n}} -> n
        end

    catch
      {:return, val} -> val
    end
  end
end
Main.main()
