# Code generated by Mochi transpiler 2025-08-12 08:15 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def log2(x) do
    try do
      k = 0.0
      v = x
      while_fun = fn while_fun, k, v ->
        if v >= 2.0 do
          v = v / 2.0
          k = k + 1.0
          while_fun.(while_fun, k, v)
        else
          {k, v}
        end
      end
      {k, v} = try do
          while_fun.(while_fun, k, v)
        catch
          {:break, {k, v}} -> {k, v}
        end

      while_fun_2 = fn while_fun_2, k, v ->
        if v < 1.0 do
          v = v * 2.0
          k = k - 1.0
          while_fun_2.(while_fun_2, k, v)
        else
          {k, v}
        end
      end
      {k, v} = try do
          while_fun_2.(while_fun_2, k, v)
        catch
          {:break, {k, v}} -> {k, v}
        end

      z = (v - 1.0) / (v + 1.0)
      zpow = z
      sum = z
      i = 3
      while_fun_3 = fn while_fun_3, i, sum, zpow ->
        if i <= 9 do
          zpow = zpow * z * z
          sum = sum + zpow / (:erlang.float(i))
          i = i + 2
          while_fun_3.(while_fun_3, i, sum, zpow)
        else
          {i, sum, zpow}
        end
      end
      {i, sum, zpow} = try do
          while_fun_3.(while_fun_3, i, sum, zpow)
        catch
          {:break, {i, sum, zpow}} -> {i, sum, zpow}
        end

      ln2 = 0.6931471805599453
      throw {:return, k + 2.0 * sum / ln2}
    catch
      {:return, val} -> val
    end
  end
  def analyze_text(text) do
    try do
      single = %{}
      double = %{}
      n = _len(text)
      if n == 0 do
        throw {:return, %{single: single, double: double}}
      end
      last = _slice(text, n - 1, n - (n - 1))
      single = Map.put(single, last, ((if Map.has_key?(single, last), do: single[last] + 1, else: 1)))
      first = _slice(text, 0, 1 - (0))
      pair0 = (" " <> first)
      double = Map.put(double, pair0, 1)
      i = 0
      while_fun_4 = fn while_fun_4, double, i, single ->
        if i < n - 1 do
          ch = _slice(text, i, i + 1 - (i))
          single = Map.put(single, ch, ((if Map.has_key?(single, ch), do: single[ch] + 1, else: 1)))
          seq = _slice(text, i, i + 2 - (i))
          double = Map.put(double, seq, ((if Map.has_key?(double, seq), do: double[seq] + 1, else: 1)))
          i = i + 1
          while_fun_4.(while_fun_4, double, i, single)
        else
          {double, i, single}
        end
      end
      {double, i, single} = try do
          while_fun_4.(while_fun_4, double, i, single)
        catch
          {:break, {double, i, single}} -> {double, i, single}
        end

      throw {:return, %{single: single, double: double}}
    catch
      {:return, val} -> val
    end
  end
  def round_to_int(x) do
    try do
      throw {:return, ((if x < 0.0, do: (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((x - 0.5)), else: (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((x + 0.5))))}
    catch
      {:return, val} -> val
    end
  end
  def calculate_entropy(text) do
    try do
      counts = analyze_text(text)
      alphas = " abcdefghijklmnopqrstuvwxyz"
      total1 = 0
      {total1} = Enum.reduce(Map.keys(counts.single), {total1}, fn ch, {total1} ->
        total1 = total1 + counts.single[ch]
        {total1}
      end)
      h1 = 0.0
      i = 0
      while_fun_5 = fn while_fun_5, h1, i ->
        if i < _len(alphas) do
          ch = _slice(alphas, i, i + 1 - (i))
          {h1} = if Map.has_key?(counts.single, ch) do
            prob = (:erlang.float(counts.single[ch])) / (:erlang.float(total1))
            h1 = h1 + prob * log2(prob)
            {h1}
          else
            {h1}
          end
          i = i + 1
          while_fun_5.(while_fun_5, h1, i)
        else
          {h1, i}
        end
      end
      {h1, i} = try do
          while_fun_5.(while_fun_5, h1, i)
        catch
          {:break, {h1, i}} -> {h1, i}
        end

      first_entropy = -h1
      IO.puts((Kernel.inspect(round_to_int(first_entropy)) <> ".0"))
      total2 = 0
      {total2} = Enum.reduce(Map.keys(counts.double), {total2}, fn seq, {total2} ->
        total2 = total2 + counts.double[seq]
        {total2}
      end)
      h2 = 0.0
      a0 = 0
      while_fun_6 = fn while_fun_6, a0, h2 ->
        if a0 < _len(alphas) do
          ch0 = _slice(alphas, a0, a0 + 1 - (a0))
          a1 = 0
          while_fun_7 = fn while_fun_7, a1, h2 ->
            if a1 < _len(alphas) do
              ch1 = _slice(alphas, a1, a1 + 1 - (a1))
              seq = (ch0 <> ch1)
              {h2} = if Map.has_key?(counts.double, seq) do
                prob = (:erlang.float(counts.double[seq])) / (:erlang.float(total2))
                h2 = h2 + prob * log2(prob)
                {h2}
              else
                {h2}
              end
              a1 = a1 + 1
              while_fun_7.(while_fun_7, a1, h2)
            else
              {a1, h2}
            end
          end
          {a1, h2} = try do
              while_fun_7.(while_fun_7, a1, h2)
            catch
              {:break, {a1, h2}} -> {a1, h2}
            end

          a0 = a0 + 1
          while_fun_6.(while_fun_6, a0, h2)
        else
          {a0, h2}
        end
      end
      {a0, h2} = try do
          while_fun_6.(while_fun_6, a0, h2)
        catch
          {:break, {a0, h2}} -> {a0, h2}
        end

      second_entropy = -h2
      IO.puts((Kernel.inspect(round_to_int(second_entropy)) <> ".0"))
      diff = second_entropy - first_entropy
      IO.puts((Kernel.inspect(round_to_int(diff)) <> ".0"))
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:text1, (("Behind Winston's back the voice " <> "from the telescreen was still ") <> "babbling and the overfulfilment"))
    calculate_entropy(Process.get(:text1))
    Process.put(:text3, (((((((((("Had repulsive dashwoods suspicion sincerity but advantage now him. " <> "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. ") <> "You greatest jointure saw horrible. He private he on be imagine ") <> "suppose. Fertile beloved evident through no service elderly is. Blind ") <> "there if every no so at. Own neglected you preferred way sincerity ") <> "delivered his attempted. To of message cottage windows do besides ") <> "against uncivil.  Delightful unreserved impossible few estimating ") <> "men favourable see entreaties. She propriety immediate was improving. ") <> "He or entrance humoured likewise moderate. Much nor game son say ") <> "feel. Fat make met can must form into gate. Me we offending prevailed ") <> "discovery."))
    calculate_entropy(Process.get(:text3))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
