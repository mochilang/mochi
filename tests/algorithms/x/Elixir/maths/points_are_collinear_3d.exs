# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def create_vector(p1, p2) do
    try do
      vx = p2.x - p1.x
      vy = p2.y - p1.y
      vz = p2.z - p1.z
      throw {:return, %{x: vx, y: vy, z: vz}}
    catch
      {:return, val} -> val
    end
  end
  def get_3d_vectors_cross(ab, ac) do
    try do
      cx = ab.y * ac.z - ab.z * ac.y
      cy = ab.z * ac.x - ab.x * ac.z
      cz = ab.x * ac.y - ab.y * ac.x
      throw {:return, %{x: cx, y: cy, z: cz}}
    catch
      {:return, val} -> val
    end
  end
  def pow10(exp) do
    try do
      result = 1.0
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < exp do
          result = result * 10.0
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def round_float(x, digits) do
    try do
      factor = pow10(digits)
      v = x * factor
      v = (if v >= 0.0, do: v + 0.5, else: v - 0.5)
      t = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(v)
      throw {:return, (:erlang.float(t)) / factor}
    catch
      {:return, val} -> val
    end
  end
  def is_zero_vector(v, accuracy) do
    try do
      throw {:return, round_float(v.x, accuracy) == 0.0 && round_float(v.y, accuracy) == 0.0 && round_float(v.z, accuracy) == 0.0}
    catch
      {:return, val} -> val
    end
  end
  def are_collinear(a, b, c, accuracy) do
    try do
      ab = create_vector(a, b)
      ac = create_vector(a, c)
      cross = get_3d_vectors_cross(ab, ac)
      throw {:return, is_zero_vector(cross, accuracy)}
    catch
      {:return, val} -> val
    end
  end
  def test_are_collinear() do
    try do
      p1 = %{x: 0.0, y: 0.0, z: 0.0}
      p2 = %{x: 1.0, y: 1.0, z: 1.0}
      p3 = %{x: 2.0, y: 2.0, z: 2.0}
      if !are_collinear(p1, p2, p3, 10) do
        raise("collinear test failed")
      end
      q3 = %{x: 1.0, y: 2.0, z: 3.0}
      if are_collinear(p1, p2, q3, 10) do
        raise("non-collinear test failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_are_collinear()
      a = %{x: 4.802293498137402, y: 3.536233125455244, z: 0.0}
      b = %{x: -2.186788107953106, y: -9.24561398001649, z: 7.141509524846482}
      c = %{x: 1.530169574640268, y: -2.447927606600034, z: 3.343487096469054}
      IO.puts(Kernel.inspect(are_collinear(a, b, c, 10)))
      d = %{x: 2.399001826862445, y: -2.452009976680793, z: 4.464656666157666}
      e = %{x: -3.682816335934376, y: 5.753788986533145, z: 9.490993909044244}
      f = %{x: 1.962903518985307, y: 3.741415730125627, z: 7.0}
      IO.puts(Kernel.inspect(are_collinear(d, e, f, 10)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
