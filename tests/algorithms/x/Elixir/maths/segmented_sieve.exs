# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def min_int(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def int_sqrt(n) do
    try do
      r = 0
      while_fun = fn while_fun, r ->
        if (r + 1) * (r + 1) <= n do
          r = r + 1
          while_fun.(while_fun, r)
        else
          r
        end
      end
      r = try do
          while_fun.(while_fun, r)
        catch
          {:break, {r}} -> r
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def sieve(n) do
    try do
      if n <= 0 do
        raise("Number must instead be a positive integer")
      end
      in_prime = []
      start = 2
      end_ = int_sqrt(n)
      temp = []
      i = 0
      while_fun_2 = fn while_fun_2, i, temp ->
        if i < end_ + 1 do
          temp = (temp ++ [1])
          i = i + 1
          while_fun_2.(while_fun_2, i, temp)
        else
          {i, temp}
        end
      end
      {i, temp} = try do
          while_fun_2.(while_fun_2, i, temp)
        catch
          {:break, {i, temp}} -> {i, temp}
        end

      prime = []
      while_fun_3 = fn while_fun_3, in_prime, start, temp ->
        if start <= end_ do
          {in_prime, temp} = if Enum.at(temp, start) == 1 do
            in_prime = (in_prime ++ [start])
            j = start * start
            while_fun_4 = fn while_fun_4, j, temp ->
              if j <= end_ do
                temp = List.replace_at(temp, j, 0)
                j = j + start
                while_fun_4.(while_fun_4, j, temp)
              else
                {j, temp}
              end
            end
            {j, temp} = try do
                while_fun_4.(while_fun_4, j, temp)
              catch
                {:break, {j, temp}} -> {j, temp}
              end

            {in_prime, temp}
          else
            {in_prime, temp}
          end
          start = start + 1
          while_fun_3.(while_fun_3, in_prime, start, temp)
        else
          {in_prime, start, temp}
        end
      end
      {in_prime, start, temp} = try do
          while_fun_3.(while_fun_3, in_prime, start, temp)
        catch
          {:break, {in_prime, start, temp}} -> {in_prime, start, temp}
        end

      i = 0
      while_fun_5 = fn while_fun_5, i, prime ->
        if i < _len(in_prime) do
          prime = (prime ++ [Enum.at(in_prime, i)])
          i = i + 1
          while_fun_5.(while_fun_5, i, prime)
        else
          {i, prime}
        end
      end
      {i, prime} = try do
          while_fun_5.(while_fun_5, i, prime)
        catch
          {:break, {i, prime}} -> {i, prime}
        end

      low = end_ + 1
      high = min_int(2 * end_, n)
      while_fun_6 = fn while_fun_6, high, low, prime ->
        if low <= n do
          tempSeg = []
          size = high - low + 1
          k = 0
          while_fun_7 = fn while_fun_7, k, tempSeg ->
            if k < size do
              tempSeg = (tempSeg ++ [1])
              k = k + 1
              while_fun_7.(while_fun_7, k, tempSeg)
            else
              {k, tempSeg}
            end
          end
          {k, tempSeg} = try do
              while_fun_7.(while_fun_7, k, tempSeg)
            catch
              {:break, {k, tempSeg}} -> {k, tempSeg}
            end

          idx = 0
          while_fun_8 = fn while_fun_8, idx, tempSeg ->
            if idx < _len(in_prime) do
              each = Enum.at(in_prime, idx)
              t = (div(low, each)) * each
              {t} = if t < low do
                t = t + each
                {t}
              else
                {t}
              end
              j2 = t
              while_fun_9 = fn while_fun_9, j2, tempSeg ->
                if j2 <= high do
                  tempSeg = List.replace_at(tempSeg, j2 - low, 0)
                  j2 = j2 + each
                  while_fun_9.(while_fun_9, j2, tempSeg)
                else
                  {j2, tempSeg}
                end
              end
              {j2, tempSeg} = try do
                  while_fun_9.(while_fun_9, j2, tempSeg)
                catch
                  {:break, {j2, tempSeg}} -> {j2, tempSeg}
                end

              idx = idx + 1
              while_fun_8.(while_fun_8, idx, tempSeg)
            else
              {idx, tempSeg}
            end
          end
          {idx, tempSeg} = try do
              while_fun_8.(while_fun_8, idx, tempSeg)
            catch
              {:break, {idx, tempSeg}} -> {idx, tempSeg}
            end

          j3 = 0
          while_fun_10 = fn while_fun_10, j3, prime ->
            if j3 < _len(tempSeg) do
              {prime} = if Enum.at(tempSeg, j3) == 1 do
                prime = (prime ++ [j3 + low])
                {prime}
              else
                {prime}
              end
              j3 = j3 + 1
              while_fun_10.(while_fun_10, j3, prime)
            else
              {j3, prime}
            end
          end
          {j3, prime} = try do
              while_fun_10.(while_fun_10, j3, prime)
            catch
              {:break, {j3, prime}} -> {j3, prime}
            end

          low = high + 1
          high = min_int(high + end_, n)
          while_fun_6.(while_fun_6, high, low, prime)
        else
          {high, low, prime}
        end
      end
      {high, low, prime} = try do
          while_fun_6.(while_fun_6, high, low, prime)
        catch
          {:break, {high, low, prime}} -> {high, low, prime}
        end

      throw {:return, prime}
    catch
      {:return, val} -> val
    end
  end
  def lists_equal(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      m = 0
      while_fun_11 = fn while_fun_11, m ->
        if m < _len(a) do
          if Enum.at(a, m) != Enum.at(b, m) do
            throw {:return, false}
          end
          m = m + 1
          while_fun_11.(while_fun_11, m)
        else
          m
        end
      end
      m = try do
          while_fun_11.(while_fun_11, m)
        catch
          {:break, {m}} -> m
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def test_sieve() do
    try do
      e1 = sieve(8)
      if !lists_equal(e1, [2, 3, 5, 7]) do
        raise("sieve(8) failed")
      end
      e2 = sieve(27)
      if !lists_equal(e2, [2, 3, 5, 7, 11, 13, 17, 19, 23]) do
        raise("sieve(27) failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_sieve()
      IO.puts(Kernel.inspect(sieve(30)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
