# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  def mod(a, n) do
    try do
      r = rem(a, n)
      if r < 0 do
        throw {:return, r + n}
      end
      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def greatest_common_divisor(a, b) do
    try do
      x = (if a < 0, do: -a, else: a)
      y = (if b < 0, do: -b, else: b)
      while_fun = fn while_fun, x, y ->
        if y != 0 do
          t = rem(x, y)
          x = y
          y = t
          while_fun.(while_fun, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun.(while_fun, x, y)
        catch
          {:break, {x, y}} -> {x, y}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def extended_gcd(a, b) do
    try do
      if b == 0 do
        throw {:return, [a, 1, 0]}
      end
      res = extended_gcd(b, rem(a, b))
      d = Enum.at(res, 0)
      p = Enum.at(res, 1)
      q = Enum.at(res, 2)
      x = q
      y = p - q * (div(a, b))
      throw {:return, [d, x, y]}
    catch
      {:return, val} -> val
    end
  end
  def extended_euclid(a, b) do
    try do
      if b == 0 do
        throw {:return, [1, 0]}
      end
      res = extended_euclid(b, rem(a, b))
      x = Enum.at(res, 1)
      y = Enum.at(res, 0) - (div(a, b)) * Enum.at(res, 1)
      throw {:return, [x, y]}
    catch
      {:return, val} -> val
    end
  end
  def invert_modulo(a, n) do
    try do
      res = extended_euclid(a, n)
      inv = Enum.at(res, 0)
      throw {:return, mod(inv, n)}
    catch
      {:return, val} -> val
    end
  end
  def modular_division(a, b, n) do
    try do
      if n <= 1 do
        raise("n must be > 1")
      end
      if a <= 0 do
        raise("a must be > 0")
      end
      if greatest_common_divisor(a, n) != 1 do
        raise("gcd(a,n) != 1")
      end
      eg = extended_gcd(n, a)
      s = Enum.at(eg, 2)
      throw {:return, mod(b * s, n)}
    catch
      {:return, val} -> val
    end
  end
  def modular_division2(a, b, n) do
    try do
      s = invert_modulo(a, n)
      throw {:return, mod(b * s, n)}
    catch
      {:return, val} -> val
    end
  end
  def tests() do
    try do
      if modular_division(4, 8, 5) != 2 do
        raise("md1")
      end
      if modular_division(3, 8, 5) != 1 do
        raise("md2")
      end
      if modular_division(4, 11, 5) != 4 do
        raise("md3")
      end
      if modular_division2(4, 8, 5) != 2 do
        raise("md21")
      end
      if modular_division2(3, 8, 5) != 1 do
        raise("md22")
      end
      if modular_division2(4, 11, 5) != 4 do
        raise("md23")
      end
      if invert_modulo(2, 5) != 3 do
        raise("inv")
      end
      eg = extended_gcd(10, 6)
      if Enum.at(eg, 0) != 2 || Enum.at(eg, 1) != (-1) || Enum.at(eg, 2) != 2 do
        raise("eg")
      end
      eu = extended_euclid(10, 6)
      if Enum.at(eu, 0) != (-1) || Enum.at(eu, 1) != 2 do
        raise("eu")
      end
      if greatest_common_divisor(121, 11) != 11 do
        raise("gcd")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tests()
      IO.puts(Kernel.inspect(modular_division(4, 8, 5)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
