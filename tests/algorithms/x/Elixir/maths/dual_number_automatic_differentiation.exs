# Code generated by Mochi transpiler 2025-08-12 08:15 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_dual(real, rank) do
    try do
      ds = []
      i = 0
      while_fun = fn while_fun, ds, i ->
        if i < rank do
          ds = (ds ++ [1.0])
          i = i + 1
          while_fun.(while_fun, ds, i)
        else
          {ds, i}
        end
      end
      {ds, i} = try do
          while_fun.(while_fun, ds, i)
        catch
          {:break, {ds, i}} -> {ds, i}
        end

      throw {:return, %{real: real, duals: ds}}
    catch
      {:return, val} -> val
    end
  end
  def dual_from_list(real, ds) do
    try do
      throw {:return, %{real: real, duals: ds}}
    catch
      {:return, val} -> val
    end
  end
  def dual_add(a, b) do
    try do
      s_dual = []
      i = 0
      while_fun_2 = fn while_fun_2, i, s_dual ->
        if i < _len(Map.get(a, :duals, [])) do
          s_dual = (s_dual ++ [Enum.at(a.duals, i, 0)])
          i = i + 1
          while_fun_2.(while_fun_2, i, s_dual)
        else
          {i, s_dual}
        end
      end
      {i, s_dual} = try do
          while_fun_2.(while_fun_2, i, s_dual)
        catch
          {:break, {i, s_dual}} -> {i, s_dual}
        end

      o_dual = []
      j = 0
      while_fun_3 = fn while_fun_3, j, o_dual ->
        if j < _len(Map.get(b, :duals, [])) do
          o_dual = (o_dual ++ [Enum.at(b.duals, j, 0)])
          j = j + 1
          while_fun_3.(while_fun_3, j, o_dual)
        else
          {j, o_dual}
        end
      end
      {j, o_dual} = try do
          while_fun_3.(while_fun_3, j, o_dual)
        catch
          {:break, {j, o_dual}} -> {j, o_dual}
        end

      {o_dual, s_dual} = if _len(s_dual) > _len(o_dual) do
        diff = _len(s_dual) - _len(o_dual)
        k = 0
        while_fun_4 = fn while_fun_4, k, o_dual ->
          if k < diff do
            o_dual = (o_dual ++ [1.0])
            k = k + 1
            while_fun_4.(while_fun_4, k, o_dual)
          else
            {k, o_dual}
          end
        end
        {k, o_dual} = try do
            while_fun_4.(while_fun_4, k, o_dual)
          catch
            {:break, {k, o_dual}} -> {k, o_dual}
          end

        {o_dual, s_dual}
      else
        {s_dual} = if _len(s_dual) < _len(o_dual) do
          diff2 = _len(o_dual) - _len(s_dual)
          k2 = 0
          while_fun_5 = fn while_fun_5, k2, s_dual ->
            if k2 < diff2 do
              s_dual = (s_dual ++ [1.0])
              k2 = k2 + 1
              while_fun_5.(while_fun_5, k2, s_dual)
            else
              {k2, s_dual}
            end
          end
          {k2, s_dual} = try do
              while_fun_5.(while_fun_5, k2, s_dual)
            catch
              {:break, {k2, s_dual}} -> {k2, s_dual}
            end

          {s_dual}
        else
          {s_dual}
        end
        {o_dual, s_dual}
      end
      new_duals = []
      idx = 0
      while_fun_6 = fn while_fun_6, idx, new_duals ->
        if idx < _len(s_dual) do
          new_duals = (new_duals ++ [Enum.at(s_dual, idx, []) + Enum.at(o_dual, idx, [])])
          idx = idx + 1
          while_fun_6.(while_fun_6, idx, new_duals)
        else
          {idx, new_duals}
        end
      end
      {idx, new_duals} = try do
          while_fun_6.(while_fun_6, idx, new_duals)
        catch
          {:break, {idx, new_duals}} -> {idx, new_duals}
        end

      throw {:return, %{real: a.real + b.real, duals: new_duals}}
    catch
      {:return, val} -> val
    end
  end
  def dual_add_real(a, b) do
    try do
      ds = []
      i = 0
      while_fun_7 = fn while_fun_7, ds, i ->
        if i < _len(Map.get(a, :duals, [])) do
          ds = (ds ++ [Enum.at(a.duals, i, 0)])
          i = i + 1
          while_fun_7.(while_fun_7, ds, i)
        else
          {ds, i}
        end
      end
      {ds, i} = try do
          while_fun_7.(while_fun_7, ds, i)
        catch
          {:break, {ds, i}} -> {ds, i}
        end

      throw {:return, %{real: a.real + b, duals: ds}}
    catch
      {:return, val} -> val
    end
  end
  def dual_mul(a, b) do
    try do
      new_len = _len(Map.get(a, :duals, [])) + _len(Map.get(b, :duals, [])) + 1
      new_duals = []
      idx = 0
      while_fun_8 = fn while_fun_8, idx, new_duals ->
        if idx < new_len do
          new_duals = (new_duals ++ [0.0])
          idx = idx + 1
          while_fun_8.(while_fun_8, idx, new_duals)
        else
          {idx, new_duals}
        end
      end
      {idx, new_duals} = try do
          while_fun_8.(while_fun_8, idx, new_duals)
        catch
          {:break, {idx, new_duals}} -> {idx, new_duals}
        end

      i = 0
      while_fun_9 = fn while_fun_9, i, new_duals ->
        if i < _len(Map.get(a, :duals, [])) do
          j = 0
          while_fun_10 = fn while_fun_10, j, new_duals ->
            if j < _len(Map.get(b, :duals, [])) do
              pos = i + j + 1
              val = Enum.at(new_duals, pos, []) + Enum.at(a.duals, i, 0) * Enum.at(b.duals, j, 0)
              new_duals = List.replace_at(new_duals, pos, val)
              j = j + 1
              while_fun_10.(while_fun_10, j, new_duals)
            else
              {j, new_duals}
            end
          end
          {j, new_duals} = try do
              while_fun_10.(while_fun_10, j, new_duals)
            catch
              {:break, {j, new_duals}} -> {j, new_duals}
            end

          i = i + 1
          while_fun_9.(while_fun_9, i, new_duals)
        else
          {i, new_duals}
        end
      end
      {i, new_duals} = try do
          while_fun_9.(while_fun_9, i, new_duals)
        catch
          {:break, {i, new_duals}} -> {i, new_duals}
        end

      k = 0
      while_fun_11 = fn while_fun_11, k, new_duals ->
        if k < _len(Map.get(a, :duals, [])) do
          val = Enum.at(new_duals, k, []) + Enum.at(a.duals, k, 0) * b.real
          new_duals = List.replace_at(new_duals, k, val)
          k = k + 1
          while_fun_11.(while_fun_11, k, new_duals)
        else
          {k, new_duals}
        end
      end
      {k, new_duals} = try do
          while_fun_11.(while_fun_11, k, new_duals)
        catch
          {:break, {k, new_duals}} -> {k, new_duals}
        end

      l = 0
      while_fun_12 = fn while_fun_12, l, new_duals ->
        if l < _len(Map.get(b, :duals, [])) do
          val = Enum.at(new_duals, l, []) + Enum.at(b.duals, l, 0) * a.real
          new_duals = List.replace_at(new_duals, l, val)
          l = l + 1
          while_fun_12.(while_fun_12, l, new_duals)
        else
          {l, new_duals}
        end
      end
      {l, new_duals} = try do
          while_fun_12.(while_fun_12, l, new_duals)
        catch
          {:break, {l, new_duals}} -> {l, new_duals}
        end

      throw {:return, %{real: a.real * b.real, duals: new_duals}}
    catch
      {:return, val} -> val
    end
  end
  def dual_mul_real(a, b) do
    try do
      ds = []
      i = 0
      while_fun_13 = fn while_fun_13, ds, i ->
        if i < _len(Map.get(a, :duals, [])) do
          ds = (ds ++ [Enum.at(a.duals, i, 0) * b])
          i = i + 1
          while_fun_13.(while_fun_13, ds, i)
        else
          {ds, i}
        end
      end
      {ds, i} = try do
          while_fun_13.(while_fun_13, ds, i)
        catch
          {:break, {ds, i}} -> {ds, i}
        end

      throw {:return, %{real: a.real * b, duals: ds}}
    catch
      {:return, val} -> val
    end
  end
  def dual_pow(x, n) do
    try do
      if n < 0 do
        raise("power must be a positive integer")
      end
      if n == 0 do
        throw {:return, %{real: 1.0, duals: []}}
      end
      res = x
      i = 1
      while_fun_14 = fn while_fun_14, i, res ->
        if i < n do
          res = dual_mul(res, x)
          i = i + 1
          while_fun_14.(while_fun_14, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_14.(while_fun_14, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def factorial(n) do
    try do
      res = 1.0
      i = 2
      while_fun_15 = fn while_fun_15, i, res ->
        if i <= n do
          res = res * (:erlang.float(i))
          i = i + 1
          while_fun_15.(while_fun_15, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_15.(while_fun_15, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def differentiate(func, position, order) do
    try do
      d = make_dual(position, 1)
      result = func.(d)
      if order == 0 do
        throw {:return, result.real}
      end
      throw {:return, Enum.at(result.duals, order - 1, 0) * factorial(order)}
    catch
      {:return, val} -> val
    end
  end
  def test_differentiate() do
    try do
      f1 = fn x ->
  try do
    throw {:return, dual_pow(x, 2)}
  catch
    {:return, val} -> val
  end
end
      if differentiate(f1, 2.0, 2) != 2.0 do
        raise("f1 failed")
      end
      f2 = fn x ->
  try do
    throw {:return, dual_mul(dual_pow(x, 2), dual_pow(x, 4))}
  catch
    {:return, val} -> val
  end
end
      if differentiate(f2, 9.0, 2) != 196830.0 do
        raise("f2 failed")
      end
      f3 = fn y ->
  try do
    throw {:return, dual_mul_real(dual_pow(dual_add_real(y, 3.0), 6), 0.5)}
  catch
    {:return, val} -> val
  end
end
      if differentiate(f3, 3.5, 4) != 7605.0 do
        raise("f3 failed")
      end
      f4 = fn y ->
  try do
    throw {:return, dual_pow(y, 2)}
  catch
    {:return, val} -> val
  end
end
      if differentiate(f4, 4.0, 3) != 0.0 do
        raise("f4 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_differentiate()
      f = fn y ->
  try do
    throw {:return, dual_mul(dual_pow(y, 2), dual_pow(y, 4))}
  catch
    {:return, val} -> val
  end
end
      res = differentiate(f, 9.0, 2)
      IO.puts(res)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
