# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  def to_unsigned(n) do
    try do
      throw {:return, ((if n < 0, do: Process.get(:max) + n, else: n))}
    catch
      {:return, val} -> val
    end
  end
  def from_unsigned(n) do
    try do
      throw {:return, ((if n >= Process.get(:half), do: n - Process.get(:max), else: n))}
    catch
      {:return, val} -> val
    end
  end
  def bit_and(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun = fn while_fun, bit, i, res, x, y ->
        if i < 32 do
          {res} = if (rem(x, 2) == 1) && (rem(y, 2) == 1) do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun.(while_fun, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun.(while_fun, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bit_xor(a, b) do
    try do
      x = a
      y = b
      res = 0
      bit = 1
      i = 0
      while_fun_2 = fn while_fun_2, bit, i, res, x, y ->
        if i < 32 do
          abit = rem(x, 2)
          bbit = rem(y, 2)
          {res} = if rem((abit + bbit), 2) == 1 do
            res = res + bit
            {res}
          else
            {res}
          end
          x = div(x, 2)
          y = div(y, 2)
          bit = bit * 2
          i = i + 1
          while_fun_2.(while_fun_2, bit, i, res, x, y)
        else
          {bit, i, res, x, y}
        end
      end
      {bit, i, res, x, y} = try do
          while_fun_2.(while_fun_2, bit, i, res, x, y)
        catch
          {:break, {bit, i, res, x, y}} -> {bit, i, res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def lshift1(num) do
    try do
      throw {:return, rem((num * 2), Process.get(:max))}
    catch
      {:return, val} -> val
    end
  end
  def add(a, b) do
    try do
      first = to_unsigned(a)
      second = to_unsigned(b)
      while_fun_3 = fn while_fun_3, first, second ->
        if second != 0 do
          carry = bit_and(first, second)
          first = bit_xor(first, second)
          second = lshift1(carry)
          while_fun_3.(while_fun_3, first, second)
        else
          {first, second}
        end
      end
      {first, second} = try do
          while_fun_3.(while_fun_3, first, second)
        catch
          {:break, {first, second}} -> {first, second}
        end

      result = from_unsigned(first)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:max, 4294967296)
  Process.put(:half, 2147483648)
  def main() do
    IO.puts(Kernel.inspect(add(3, 5)))
    IO.puts(Kernel.inspect(add(13, 5)))
    IO.puts(Kernel.inspect(add(-7, 2)))
    IO.puts(Kernel.inspect(add(0, -7)))
    IO.puts(Kernel.inspect(add(-321, 0)))
  end
end
Main.main()
