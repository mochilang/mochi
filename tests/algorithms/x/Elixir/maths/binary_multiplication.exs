# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  def binary_multiply(a, b) do
    try do
      x = a
      y = b
      res = 0
      while_fun = fn while_fun, res, x, y ->
        if y > 0 do
          {res} = if rem(y, 2) == 1 do
            res = res + x
            {res}
          else
            {res}
          end
          x = x + x
          y = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(y, 2)))
          while_fun.(while_fun, res, x, y)
        else
          {res, x, y}
        end
      end
      {res, x, y} = try do
          while_fun.(while_fun, res, x, y)
        catch
          {:break, {res, x, y}} -> {res, x, y}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def binary_mod_multiply(a, b, modulus) do
    try do
      x = a
      y = b
      res = 0
      while_fun_2 = fn while_fun_2, res, x, y ->
        if y > 0 do
          {res} = if rem(y, 2) == 1 do
            res = rem(((rem(res, modulus)) + (rem(x, modulus))), modulus)
            {res}
          else
            {res}
          end
          x = x + x
          y = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(y, 2)))
          while_fun_2.(while_fun_2, res, x, y)
        else
          {res, x, y}
        end
      end
      {res, x, y} = try do
          while_fun_2.(while_fun_2, res, x, y)
        catch
          {:break, {res, x, y}} -> {res, x, y}
        end

      throw {:return, rem(res, modulus)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(binary_multiply(2, 3)))
      IO.puts(Kernel.inspect(binary_multiply(5, 0)))
      IO.puts(Kernel.inspect(binary_mod_multiply(2, 3, 5)))
      IO.puts(Kernel.inspect(binary_mod_multiply(10, 5, 13)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
