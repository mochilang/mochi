# Code generated by Mochi transpiler 2025-08-09 10:14 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def abs_val(n) do
    try do
      throw {:return, ((if n < 0, do: -n, else: n))}
    catch
      {:return, val} -> val
    end
  end
  def extended_euclidean_algorithm(a, b) do
    try do
      if abs_val(a) == 1 do
        throw {:return, %{x: a, y: 0}}
      end
      if abs_val(b) == 1 do
        throw {:return, %{x: 0, y: b}}
      end
      old_remainder = a
      remainder = b
      old_coeff_a = 1
      coeff_a = 0
      old_coeff_b = 0
      coeff_b = 1
      while_fun = fn while_fun, coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder ->
        if remainder != 0 do
          quotient = div(old_remainder, remainder)
          temp_remainder = old_remainder - quotient * remainder
          old_remainder = remainder
          remainder = temp_remainder
          temp_a = old_coeff_a - quotient * coeff_a
          old_coeff_a = coeff_a
          coeff_a = temp_a
          temp_b = old_coeff_b - quotient * coeff_b
          old_coeff_b = coeff_b
          coeff_b = temp_b
          while_fun.(while_fun, coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder)
        else
          {coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder}
        end
      end
      {coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder} = try do
          while_fun.(while_fun, coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder)
        catch
          {:break, {coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder}} -> {coeff_a, coeff_b, old_coeff_a, old_coeff_b, old_remainder, remainder}
        end

      {old_coeff_a} = if a < 0 do
        old_coeff_a = -old_coeff_a
        {old_coeff_a}
      else
        {old_coeff_a}
      end
      {old_coeff_b} = if b < 0 do
        old_coeff_b = -old_coeff_b
        {old_coeff_b}
      else
        {old_coeff_b}
      end
      throw {:return, %{x: old_coeff_a, y: old_coeff_b}}
    catch
      {:return, val} -> val
    end
  end
  def test_extended_euclidean_algorithm() do
    try do
      r1 = extended_euclidean_algorithm(1, 24)
      if (r1.x != 1) || (r1.y != 0) do
        raise("test1 failed")
      end
      r2 = extended_euclidean_algorithm(8, 14)
      if (r2.x != 2) || (r2.y != (-1)) do
        raise("test2 failed")
      end
      r3 = extended_euclidean_algorithm(240, 46)
      if (r3.x != (-9)) || (r3.y != 47) do
        raise("test3 failed")
      end
      r4 = extended_euclidean_algorithm(1, -4)
      if (r4.x != 1) || (r4.y != 0) do
        raise("test4 failed")
      end
      r5 = extended_euclidean_algorithm(-2, -4)
      if (r5.x != (-1)) || (r5.y != 0) do
        raise("test5 failed")
      end
      r6 = extended_euclidean_algorithm(0, -4)
      if (r6.x != 0) || (r6.y != (-1)) do
        raise("test6 failed")
      end
      r7 = extended_euclidean_algorithm(2, 0)
      if (r7.x != 1) || (r7.y != 0) do
        raise("test7 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_extended_euclidean_algorithm()
      res = extended_euclidean_algorithm(240, 46)
      IO.puts((((("(" <> Kernel.to_string(res.x)) <> ", ") <> Kernel.to_string(res.y)) <> ")"))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
