# Code generated by Mochi transpiler 2025-08-09 16:15 +0700
defmodule Main do
  def set_seed(s) do
    try do
      Process.put(:seed, s)
    catch
      {:return, val} -> val
    end
  end
  def randint(a, b) do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, (rem(Process.get(:seed), (b - a + 1))) + a}
    catch
      {:return, val} -> val
    end
  end
  def jacobi_symbol(random_a, number) do
    try do
      if random_a == 0 || random_a == 1 do
        throw {:return, random_a}
      end
      random_a = rem(random_a, number)
      t = 1
      while_fun = fn while_fun, number, random_a, t ->
        if random_a != 0 do
          while_fun_2 = fn while_fun_2, random_a, t ->
            if rem(random_a, 2) == 0 do
              random_a = div(random_a, 2)
              r = rem(number, 8)
              {t} = if r == 3 || r == 5 do
                t = -t
                {t}
              else
                {t}
              end
              while_fun_2.(while_fun_2, random_a, t)
            else
              {random_a, t}
            end
          end
          {random_a, t} = try do
              while_fun_2.(while_fun_2, random_a, t)
            catch
              {:break, {random_a, t}} -> {random_a, t}
            end

          temp = random_a
          random_a = number
          number = temp
          {t} = if rem(random_a, 4) == 3 && rem(number, 4) == 3 do
            t = -t
            {t}
          else
            {t}
          end
          random_a = rem(random_a, number)
          while_fun.(while_fun, number, random_a, t)
        else
          {number, random_a, t}
        end
      end
      {number, random_a, t} = try do
          while_fun.(while_fun, number, random_a, t)
        catch
          {:break, {number, random_a, t}} -> {number, random_a, t}
        end

      if number == 1 do
        throw {:return, t}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def pow_mod(base, exp, mod) do
    try do
      result = 1
      b = rem(base, mod)
      e = exp
      while_fun_3 = fn while_fun_3, b, e, result ->
        if e > 0 do
          {result} = if rem(e, 2) == 1 do
            result = rem((result * b), mod)
            {result}
          else
            {result}
          end
          b = rem((b * b), mod)
          e = div(e, 2)
          while_fun_3.(while_fun_3, b, e, result)
        else
          {b, e, result}
        end
      end
      {b, e, result} = try do
          while_fun_3.(while_fun_3, b, e, result)
        catch
          {:break, {b, e, result}} -> {b, e, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def solovay_strassen(number, iterations) do
    try do
      if number <= 1 do
        throw {:return, false}
      end
      if number <= 3 do
        throw {:return, true}
      end
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < iterations do
          a = randint(2, number - 2)
          x = jacobi_symbol(a, number)
          y = pow_mod(a, div((number - 1), 2), number)
          mod_x = rem(x, number)
          {mod_x} = if mod_x < 0 do
            mod_x = mod_x + number
            {mod_x}
          else
            {mod_x}
          end
          if x == 0 || y != mod_x do
            throw {:return, false}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      set_seed(10)
      IO.puts(Kernel.inspect(solovay_strassen(13, 5)))
      IO.puts(Kernel.inspect(solovay_strassen(9, 10)))
      IO.puts(Kernel.inspect(solovay_strassen(17, 15)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
end
Main.main()
