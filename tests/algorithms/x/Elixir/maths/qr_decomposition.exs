# Code generated by Mochi transpiler 2025-08-09 10:54 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrt_approx(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def sign(x) do
    try do
      if x >= 0.0 do
        throw {:return, 1.0}
      else
        throw {:return, -1.0}
      end
    catch
      {:return, val} -> val
    end
  end
  def vector_norm(v) do
    try do
      sum = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, sum ->
        if i < _len(v) do
          sum = sum + Enum.at(v, i) * Enum.at(v, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_2.(while_fun_2, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      n = sqrt_approx(sum)
      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def identity_matrix(n) do
    try do
      mat = []
      i = 0
      while_fun_3 = fn while_fun_3, i, mat ->
        if i < n do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j < n do
              row = (if i == j, do: (row ++ [1.0]), else: (row ++ [0.0]))
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_3.(while_fun_3, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, mat}
    catch
      {:return, val} -> val
    end
  end
  def copy_matrix(a) do
    try do
      mat = []
      i = 0
      while_fun_5 = fn while_fun_5, i, mat ->
        if i < _len(a) do
          row = []
          j = 0
          while_fun_6 = fn while_fun_6, j, row ->
            if j < _len(Enum.at(a, i)) do
              row = (row ++ [Enum.at(Enum.at(a, i), j)])
              j = j + 1
              while_fun_6.(while_fun_6, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_6.(while_fun_6, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_5.(while_fun_5, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_5.(while_fun_5, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, mat}
    catch
      {:return, val} -> val
    end
  end
  def matmul(a, b) do
    try do
      m = _len(a)
      n = _len(Enum.at(a, 0))
      p = _len(Enum.at(b, 0))
      res = []
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < m do
          row = []
          j = 0
          while_fun_8 = fn while_fun_8, j, row ->
            if j < p do
              sum = 0.0
              k = 0
              while_fun_9 = fn while_fun_9, k, sum ->
                if k < n do
                  sum = sum + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_9.(while_fun_9, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_9.(while_fun_9, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [sum])
              j = j + 1
              while_fun_8.(while_fun_8, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_8.(while_fun_8, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def qr_decomposition(a) do
    try do
      m = _len(a)
      n = _len(Enum.at(a, 0))
      t = (if m < n, do: m, else: n)
      q = identity_matrix(m)
      r = copy_matrix(a)
      k = 0
      while_fun_10 = fn while_fun_10, k, q, r ->
        if k < t - 1 do
          x = []
          i = k
          while_fun_11 = fn while_fun_11, i, x ->
            if i < m do
              x = (x ++ [Enum.at(Enum.at(r, i), k)])
              i = i + 1
              while_fun_11.(while_fun_11, i, x)
            else
              {i, x}
            end
          end
          {i, x} = try do
              while_fun_11.(while_fun_11, i, x)
            catch
              {:break, {i, x}} -> {i, x}
            end

          e1 = []
          i = 0
          while_fun_12 = fn while_fun_12, e1, i ->
            if i < _len(x) do
              e1 = (if i == 0, do: (e1 ++ [1.0]), else: (e1 ++ [0.0]))
              i = i + 1
              while_fun_12.(while_fun_12, e1, i)
            else
              {e1, i}
            end
          end
          {e1, i} = try do
              while_fun_12.(while_fun_12, e1, i)
            catch
              {:break, {e1, i}} -> {e1, i}
            end

          alpha = vector_norm(x)
          s = sign(Enum.at(x, 0)) * alpha
          v = []
          i = 0
          while_fun_13 = fn while_fun_13, i, v ->
            if i < _len(x) do
              v = (v ++ [Enum.at(x, i) + s * Enum.at(e1, i)])
              i = i + 1
              while_fun_13.(while_fun_13, i, v)
            else
              {i, v}
            end
          end
          {i, v} = try do
              while_fun_13.(while_fun_13, i, v)
            catch
              {:break, {i, v}} -> {i, v}
            end

          vnorm = vector_norm(v)
          i = 0
          while_fun_14 = fn while_fun_14, i, v ->
            if i < _len(v) do
              v = List.replace_at(v, i, Enum.at(v, i) / vnorm)
              i = i + 1
              while_fun_14.(while_fun_14, i, v)
            else
              {i, v}
            end
          end
          {i, v} = try do
              while_fun_14.(while_fun_14, i, v)
            catch
              {:break, {i, v}} -> {i, v}
            end

          size = _len(v)
          qk_small = []
          i = 0
          while_fun_15 = fn while_fun_15, i, qk_small ->
            if i < size do
              row = []
              j = 0
              while_fun_16 = fn while_fun_16, j, row ->
                if j < size do
                  delta = (if i == j, do: 1.0, else: 0.0)
                  row = (row ++ [delta - 2.0 * Enum.at(v, i) * Enum.at(v, j)])
                  j = j + 1
                  while_fun_16.(while_fun_16, j, row)
                else
                  {j, row}
                end
              end
              {j, row} = try do
                  while_fun_16.(while_fun_16, j, row)
                catch
                  {:break, {j, row}} -> {j, row}
                end

              qk_small = (qk_small ++ [row])
              i = i + 1
              while_fun_15.(while_fun_15, i, qk_small)
            else
              {i, qk_small}
            end
          end
          {i, qk_small} = try do
              while_fun_15.(while_fun_15, i, qk_small)
            catch
              {:break, {i, qk_small}} -> {i, qk_small}
            end

          qk = identity_matrix(m)
          i = 0
          while_fun_17 = fn while_fun_17, i, qk ->
            if i < size do
              j = 0
              while_fun_18 = fn while_fun_18, j, qk ->
                if j < size do
                  qk = List.replace_at(qk, k + i, List.replace_at(Enum.at(qk, k + i), k + j, Enum.at(Enum.at(qk_small, i), j)))
                  j = j + 1
                  while_fun_18.(while_fun_18, j, qk)
                else
                  {j, qk}
                end
              end
              {j, qk} = try do
                  while_fun_18.(while_fun_18, j, qk)
                catch
                  {:break, {j, qk}} -> {j, qk}
                end

              i = i + 1
              while_fun_17.(while_fun_17, i, qk)
            else
              {i, qk}
            end
          end
          {i, qk} = try do
              while_fun_17.(while_fun_17, i, qk)
            catch
              {:break, {i, qk}} -> {i, qk}
            end

          q = matmul(q, qk)
          r = matmul(qk, r)
          k = k + 1
          while_fun_10.(while_fun_10, k, q, r)
        else
          {k, q, r}
        end
      end
      {k, q, r} = try do
          while_fun_10.(while_fun_10, k, q, r)
        catch
          {:break, {k, q, r}} -> {k, q, r}
        end

      throw {:return, %{q: q, r: r}}
    catch
      {:return, val} -> val
    end
  end
  def print_matrix(mat) do
    try do
      i = 0
      while_fun_19 = fn while_fun_19, i ->
        if i < _len(mat) do
          line = ""
          j = 0
          while_fun_20 = fn while_fun_20, j, line ->
            if j < _len(Enum.at(mat, i)) do
              line = (line <> Kernel.to_string(Enum.at(Enum.at(mat, i), j)))
              {line} = if j + 1 < _len(Enum.at(mat, i)) do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              j = j + 1
              while_fun_20.(while_fun_20, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_20.(while_fun_20, j, line)
            catch
              {:break, {j, line}} -> {j, line}
            end

          IO.puts(line)
          i = i + 1
          while_fun_19.(while_fun_19, i)
        else
          i
        end
      end
      i = try do
          while_fun_19.(while_fun_19, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:a, [[12.0, -51.0, 4.0], [6.0, 167.0, -68.0], [-4.0, 24.0, -41.0]])
    Process.put(:result, qr_decomposition(Process.get(:a)))
    print_matrix(Process.get(:result).q)
    print_matrix(Process.get(:result).r)
  end
end
Main.main()
