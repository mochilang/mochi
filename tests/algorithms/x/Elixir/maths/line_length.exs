# Code generated by Mochi transpiler 2025-08-09 10:14 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def sqrt_newton(n) do
    try do
      if n == 0.0 do
        throw {:return, 0.0}
      end
      x = n
      i = 0
      while_fun = fn while_fun, i, x ->
        if i < 20 do
          x = (x + n / x) / 2.0
          i = i + 1
          while_fun.(while_fun, i, x)
        else
          {i, x}
        end
      end
      {i, x} = try do
          while_fun.(while_fun, i, x)
        catch
          {:break, {i, x}} -> {i, x}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def hypot(a, b) do
    try do
      throw {:return, sqrt_newton(a * a + b * b)}
    catch
      {:return, val} -> val
    end
  end
  def line_length(fnc, x_start, x_end, steps) do
    try do
      x1 = x_start
      fx1 = fnc.(x_start)
      length = 0.0
      i = 0
      step = (x_end - x_start) / (1.0 * steps)
      while_fun_2 = fn while_fun_2, fx1, i, length, x1 ->
        if i < steps do
          x2 = step + x1
          fx2 = fnc.(x2)
          length = length + hypot(x2 - x1, fx2 - fx1)
          x1 = x2
          fx1 = fx2
          i = i + 1
          while_fun_2.(while_fun_2, fx1, i, length, x1)
        else
          {fx1, i, length, x1}
        end
      end
      {fx1, i, length, x1} = try do
          while_fun_2.(while_fun_2, fx1, i, length, x1)
        catch
          {:break, {fx1, i, length, x1}} -> {fx1, i, length, x1}
        end

      throw {:return, length}
    catch
      {:return, val} -> val
    end
  end
  def f1(x) do
    try do
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def f2(x) do
    try do
      throw {:return, 1.0}
    catch
      {:return, val} -> val
    end
  end
  def f3(x) do
    try do
      throw {:return, (x * x) / 10.0}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(line_length(&f1/1, 0.0, 1.0, 10)))
    IO.puts(Kernel.inspect(line_length(&f2/1, -5.5, 4.5, 100)))
    IO.puts(Kernel.inspect(line_length(&f3/1, 0.0, 10.0, 1000)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
