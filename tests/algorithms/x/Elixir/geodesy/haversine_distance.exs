# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def to_radians(deg) do
    try do
      throw {:return, deg * Process.get(:pi) / 180.0}
    catch
      {:return, val} -> val
    end
  end
  def sin_taylor(x) do
    try do
      term = x
      sum = x
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i))
          k2 = k1 + 1.0
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def cos_taylor(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun_2 = fn while_fun_2, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i)) - 1.0
          k2 = 2.0 * (:erlang.float(i))
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun_2.(while_fun_2, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun_2.(while_fun_2, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def tan_approx(x) do
    try do
      throw {:return, sin_taylor(x) / cos_taylor(x)}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun_3 = fn while_fun_3, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_3.(while_fun_3, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_3.(while_fun_3, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def atanApprox(x) do
    try do
      if x > 1.0 do
        throw {:return, Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      if x < (-1.0) do
        throw {:return, -Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      throw {:return, x / (1.0 + 0.28 * x * x)}
    catch
      {:return, val} -> val
    end
  end
  def atan2Approx(y, x) do
    try do
      if x > 0.0 do
        val = atanApprox(y / x)
        throw {:return, val}
      end
      if x < 0.0 do
        if y >= 0.0 do
          throw {:return, atanApprox(y / x) + Process.get(:pi)}
        end
        throw {:return, atanApprox(y / x) - Process.get(:pi)}
      end
      if y > 0.0 do
        throw {:return, Process.get(:pi) / 2.0}
      end
      if y < 0.0 do
        throw {:return, -Process.get(:pi) / 2.0}
      end
      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  def asinApprox(x) do
    try do
      denom = sqrtApprox(1.0 - x * x)
      res = atan2Approx(x, denom)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def haversine_distance(lat1, lon1, lat2, lon2) do
    try do
      flattening = (Process.get(:axis_a) - Process.get(:axis_b)) / Process.get(:axis_a)
      phi_1 = atanApprox((1.0 - flattening) * tan_approx(to_radians(lat1)))
      phi_2 = atanApprox((1.0 - flattening) * tan_approx(to_radians(lat2)))
      lambda_1 = to_radians(lon1)
      lambda_2 = to_radians(lon2)
      sin_sq_phi = sin_taylor((phi_2 - phi_1) / 2.0)
      sin_sq_lambda = sin_taylor((lambda_2 - lambda_1) / 2.0)
      sin_sq_phi = sin_sq_phi * sin_sq_phi
      sin_sq_lambda = sin_sq_lambda * sin_sq_lambda
      h_value = sqrtApprox(sin_sq_phi + cos_taylor(phi_1) * cos_taylor(phi_2) * sin_sq_lambda)
      throw {:return, 2.0 * Process.get(:radius) * asinApprox(h_value)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:axis_a, 6378137.0)
  Process.put(:axis_b, 6356752.314245)
  Process.put(:radius, 6378137.0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:san_francisco, [37.774856, -122.424227])
    Process.put(:yosemite, [37.864742, -119.537521])
    IO.puts(Kernel.inspect(haversine_distance(Enum.at(Process.get(:san_francisco), 0), Enum.at(Process.get(:san_francisco), 1), Enum.at(Process.get(:yosemite), 0), Enum.at(Process.get(:yosemite), 1))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
