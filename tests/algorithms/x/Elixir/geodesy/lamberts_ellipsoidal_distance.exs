# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def to_radians(deg) do
    try do
      throw {:return, deg * Process.get(:pi) / 180.0}
    catch
      {:return, val} -> val
    end
  end
  def sin_approx(x) do
    try do
      term = x
      sum = x
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i))
          k2 = k1 + 1.0
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def cos_approx(x) do
    try do
      term = 1.0
      sum = 1.0
      i = 1
      while_fun_2 = fn while_fun_2, i, sum, term ->
        if i < 10 do
          k1 = 2.0 * (:erlang.float(i)) - 1.0
          k2 = 2.0 * (:erlang.float(i))
          term = -term * x * x / (k1 * k2)
          sum = sum + term
          i = i + 1
          while_fun_2.(while_fun_2, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun_2.(while_fun_2, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_approx(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun_3 = fn while_fun_3, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_3.(while_fun_3, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_3.(while_fun_3, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def lamberts_ellipsoidal_distance(lat1, lon1, lat2, lon2) do
    try do
      phi1 = to_radians(lat1)
      phi2 = to_radians(lat2)
      lambda1 = to_radians(lon1)
      lambda2 = to_radians(lon2)
      x = (lambda2 - lambda1) * cos_approx((phi1 + phi2) / 2.0)
      y = phi2 - phi1
      throw {:return, Process.get(:equatorial_radius) * sqrt_approx(x * x + y * y)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:equatorial_radius, 6378137.0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(lamberts_ellipsoidal_distance(37.774856, -122.424227, 37.864742, -119.537521)))
    IO.puts(Kernel.inspect(lamberts_ellipsoidal_distance(37.774856, -122.424227, 40.713019, -74.012647)))
    IO.puts(Kernel.inspect(lamberts_ellipsoidal_distance(37.774856, -122.424227, 45.443012, 12.313071)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
