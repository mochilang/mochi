# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def split(s, sep) do
    try do
      parts = []
      cur = ""
      i = 0
      while_fun = fn while_fun, cur, i, parts ->
        if i < _len(s) do
          {cur, i, parts} = if _len(sep) > 0 && i + _len(sep) <= _len(s) && _slice(s, i, i + _len(sep) - (i)) == sep do
            parts = (parts ++ [cur])
            cur = ""
            i = i + _len(sep)
            {cur, i, parts}
          else
            cur = (cur <> _slice(s, i, i + 1 - (i)))
            i = i + 1
            {cur, i, parts}
          end
          while_fun.(while_fun, cur, i, parts)
        else
          {cur, i, parts}
        end
      end
      {cur, _, parts} = try do
          while_fun.(while_fun, cur, i, parts)
        catch
          {:break, {cur, _, parts}} -> {cur, 0, parts}
        end

      parts = (parts ++ [cur])
      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def join(xs, sep) do
    try do
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(xs) do
          res = if i > 0 do
            res = (res <> sep)
            res
          else
            res
          end
          res = (res <> Enum.at(xs, i, []))
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def repeat(s, n) do
    try do
      out = ""
      i = 0
      while_fun_3 = fn while_fun_3, i, out ->
        if i < n do
          out = (out <> s)
          i = i + 1
          while_fun_3.(while_fun_3, i, out)
        else
          {i, out}
        end
      end
      {_, out} = try do
          while_fun_3.(while_fun_3, i, out)
        catch
          {:break, {_, out}} -> {0, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def replace_char(s, old, new) do
    try do
      out = ""
      i = 0
      while_fun_4 = fn while_fun_4, i, out ->
        if i < _len(s) do
          c = _slice(s, i, i + 1 - (i))
          out = (if c == old, do: (out <> new), else: (out <> c))
          i = i + 1
          while_fun_4.(while_fun_4, i, out)
        else
          {i, out}
        end
      end
      {_, out} = try do
          while_fun_4.(while_fun_4, i, out)
        catch
          {:break, {_, out}} -> {0, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def contains(s, sub) do
    try do
      if _len(sub) == 0 do
        throw {:return, true}
      end
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i + _len(sub) <= _len(s) do
          if _slice(s, i, i + _len(sub) - (i)) == sub do
            throw {:return, true}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      _ = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def file_extension(name) do
    try do
      i = _len(name) - 1
      while_fun_6 = fn while_fun_6, i ->
        if i >= 0 do
          if _slice(name, i, i + 1 - (i)) == "." do
            throw {:return, _slice(name, i, _len(name) - i)}
          end
          i = i - 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      _ = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, ""}
    catch
      {:return, val} -> val
    end
  end
  def remove_extension(name) do
    try do
      i = _len(name) - 1
      while_fun_7 = fn while_fun_7, i ->
        if i >= 0 do
          if _slice(name, i, i + 1 - (i)) == "." do
            throw {:return, _slice(name, 0, i - 0)}
          end
          i = i - 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      _ = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, name}
    catch
      {:return, val} -> val
    end
  end
  def title_case(s) do
    try do
      out = ""
      cap = true
      i = 0
      while_fun_8 = fn while_fun_8, cap, i, out ->
        if i < _len(s) do
          c = _slice(s, i, i + 1 - (i))
          {cap, out} = if c == " " do
            out = (out <> c)
            cap = true
            {cap, out}
          else
            {cap, out} = if cap do
              out = (out <> String.upcase(c))
              cap = false
              {cap, out}
            else
              out = (out <> String.downcase(c))
              {cap, out}
            end
            {cap, out}
          end
          i = i + 1
          while_fun_8.(while_fun_8, cap, i, out)
        else
          {cap, i, out}
        end
      end
      {cap, _, out} = try do
          while_fun_8.(while_fun_8, cap, i, out)
        catch
          {:break, {cap, _, out}} -> {cap, 0, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def count_char(s, ch) do
    try do
      cnt = 0
      i = 0
      while_fun_9 = fn while_fun_9, cnt, i ->
        if i < _len(s) do
          cnt = if _slice(s, i, i + 1 - (i)) == ch do
            cnt = cnt + 1
            cnt
          else
            cnt
          end
          i = i + 1
          while_fun_9.(while_fun_9, cnt, i)
        else
          {cnt, i}
        end
      end
      {cnt, _} = try do
          while_fun_9.(while_fun_9, cnt, i)
        catch
          {:break, {cnt, _}} -> {cnt, 0}
        end

      throw {:return, cnt}
    catch
      {:return, val} -> val
    end
  end
  def md_prefix(level) do
    try do
      throw {:return, ((if level == 0, do: "\n##", else: (repeat("  ", level) <> "*")))}
    catch
      {:return, val} -> val
    end
  end
  def print_path(old_path, new_path) do
    try do
      old_parts = split(old_path, "/")
      new_parts = split(new_path, "/")
      i = 0
      while_fun_10 = fn while_fun_10, i ->
        if i < _len(new_parts) do
          if (i >= _len(old_parts) || Enum.at(old_parts, i, []) != Enum.at(new_parts, i, [])) && Enum.at(new_parts, i, []) != "" do
            title = title_case(replace_char(Enum.at(new_parts, i, []), "_", " "))
            IO.puts(Kernel.inspect(((md_prefix(i) <> " ") <> title)))
          end
          i = i + 1
          while_fun_10.(while_fun_10, i)
        else
          i
        end
      end
      _ = try do
          while_fun_10.(while_fun_10, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, new_path}
    catch
      {:return, val} -> val
    end
  end
  def sort_strings(xs) do
    try do
      arr = xs
      i = 0
      while_fun_11 = fn while_fun_11, arr, i ->
        if i < _len(arr) do
          min_idx = i
          j = i + 1
          while_fun_12 = fn while_fun_12, j, min_idx ->
            if j < _len(arr) do
              min_idx = if Enum.at(arr, j, []) < Enum.at(arr, min_idx, []) do
                min_idx = j
                min_idx
              else
                min_idx
              end
              j = j + 1
              while_fun_12.(while_fun_12, j, min_idx)
            else
              {j, min_idx}
            end
          end
          {_, min_idx} = try do
              while_fun_12.(while_fun_12, j, min_idx)
            catch
              {:break, {_, min_idx}} -> {0, min_idx}
            end

          tmp = Enum.at(arr, i, [])
          arr = List.replace_at(arr, i, Enum.at(arr, min_idx, []))
          arr = List.replace_at(arr, min_idx, tmp)
          i = i + 1
          while_fun_11.(while_fun_11, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun_11.(while_fun_11, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def good_file_paths(paths) do
    try do
      res = []
      {res} = Enum.reduce(paths, {res}, fn p, {res} ->
        try do
          parts = split(p, "/")
          skip = false
          k = 0
          while_fun_13 = fn while_fun_13, k, skip ->
            if k < _len(parts) - 1 do
              part = Enum.at(parts, k, [])
              skip = if part == "scripts" || _slice(part, 0, 1 - 0) == "." || _slice(part, 0, 1 - 0) == "_" || contains(part, "venv") do
                skip = true
                skip
              else
                skip
              end
              k = k + 1
              while_fun_13.(while_fun_13, k, skip)
            else
              {k, skip}
            end
          end
          {_, skip} = try do
              while_fun_13.(while_fun_13, k, skip)
            catch
              {:break, {_, skip}} -> {0, skip}
            end

          if skip do
            throw :continue
          end
          filename = Enum.at(parts, _len(parts) - 1, [])
          if filename == "__init__.py" do
            throw :continue
          end
          ext = file_extension(filename)
          res = if ext == ".py" || ext == ".ipynb" do
            res = (res ++ [p])
            res
          else
            res
          end
        catch
          :continue -> {res}
        end
        {res}
      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def print_directory_md(paths) do
    try do
      files = sort_strings(good_file_paths(paths))
      old_path = ""
      i = 0
      while_fun_14 = fn while_fun_14, i, old_path ->
        if i < _len(files) do
          fp = Enum.at(files, i, [])
          parts = split(fp, "/")
          filename = Enum.at(parts, _len(parts) - 1, [])
          filepath = ""
          filepath = if _len(parts) > 1 do
            filepath = join(_slice(parts, 0, (_len(parts) - 1) - 0), "/")
            filepath
          else
            filepath
          end
          old_path = if filepath != old_path do
            old_path = print_path(old_path, filepath)
            old_path
          else
            old_path
          end
          indent = 0
          indent = if _len(filepath) > 0 do
            indent = count_char(filepath, "/") + 1
            indent
          else
            indent
          end
          url = replace_char(fp, " ", "%20")
          name = title_case(replace_char(remove_extension(filename), "_", " "))
          IO.puts(Kernel.inspect((((((md_prefix(indent) <> " [") <> name) <> "](") <> url) <> ")")))
          i = i + 1
          while_fun_14.(while_fun_14, i, old_path)
        else
          {i, old_path}
        end
      end
      {_, old_path} = try do
          while_fun_14.(while_fun_14, i, old_path)
        catch
          {:break, {_, old_path}} -> {0, old_path}
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:sample, ["data_structures/linked_list.py", "data_structures/binary_tree.py", "math/number_theory/prime_check.py", "math/number_theory/greatest_common_divisor.ipynb"])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    print_directory_md(Process.get(:sample))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
