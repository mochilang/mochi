# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_trie() do
    try do
      throw {:return, %{nodes: [%{children: %{}, is_leaf: false}]}}
    catch
      {:return, val} -> val
    end
  end
  def remove_key(m, k) do
    try do
      out = %{}
      {out} = Enum.reduce(Map.keys(m), {out}, fn key, {out} ->
        {out} = if key != k do
          out = Map.put(out, key, m[key])
          {out}
        else
          {out}
        end
        {out}
      end)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def insert(trie, word) do
    try do
      nodes = trie.nodes
      curr = 0
      i = 0
      while_fun = fn while_fun, curr, i, nodes ->
        if i < _len(word) do
          ch = String.at(word, i)
          child_idx = -1
          children = Enum.at(nodes, curr)["children"]
          {child_idx, nodes} = if ch in children do
            child_idx = children[ch]
            {child_idx, nodes}
          else
            new_node = %{children: %{}, is_leaf: false}
            nodes = (nodes ++ [new_node])
            child_idx = _len(nodes) - 1
            new_children = children
            new_children = Map.put(new_children, ch, child_idx)
            node_ = Enum.at(nodes, curr)
            node_ = Map.put(node_, :children, new_children)
            nodes = List.replace_at(nodes, curr, node_)
            {child_idx, nodes}
          end
          curr = child_idx
          i = i + 1
          while_fun.(while_fun, curr, i, nodes)
        else
          {curr, i, nodes}
        end
      end
      {curr, i, nodes} = try do
          while_fun.(while_fun, curr, i, nodes)
        catch
          {:break, {curr, i, nodes}} -> {curr, i, nodes}
        end

      node_ = Enum.at(nodes, curr)
      node_ = Map.put(node_, :is_leaf, true)
      nodes = List.replace_at(nodes, curr, node_)
      trie = Map.put(trie, :nodes, nodes)
    catch
      {:return, val} -> val
    end
  end
  def insert_many(trie, words) do
    try do
      Enum.each(words, fn w ->
        insert(trie, w)
      end)
    catch
      {:return, val} -> val
    end
  end
  def find(trie, word) do
    try do
      nodes = trie.nodes
      curr = 0
      i = 0
      while_fun_2 = fn while_fun_2, curr, i ->
        if i < _len(word) do
          ch = String.at(word, i)
          children = Enum.at(nodes, curr)["children"]
          if !(ch in children) do
            throw {:return, false}
          end
          curr = children[ch]
          i = i + 1
          while_fun_2.(while_fun_2, curr, i)
        else
          {curr, i}
        end
      end
      {curr, i} = try do
          while_fun_2.(while_fun_2, curr, i)
        catch
          {:break, {curr, i}} -> {curr, i}
        end

      node_ = Enum.at(nodes, curr)
      throw {:return, node_.is_leaf}
    catch
      {:return, val} -> val
    end
  end
  def delete(trie, word) do
    try do
      nodes = trie.nodes
      _delete = fn idx, pos ->
  {nodes} = if pos == _len(word) do
    node_ = Enum.at(nodes, idx)
    if node_.is_leaf == false do
      throw {:return, false}
    end
    node_ = Map.put(node_, :is_leaf, false)
    nodes = List.replace_at(nodes, idx, node_)
    throw {:return, map_size(Map.get(node_, :children, [])) == 0}
    {nodes}
  else
    {nodes}
  end
  node_ = Enum.at(nodes, idx)
  children = node_.children
  ch = String.at(word, pos)
  if !(Map.has_key?(children, ch)) do
    throw {:return, false}
  end
  child_idx = children[ch]
  should_delete = _delete(child_idx, pos + 1)
  node_ = Enum.at(nodes, idx)
  {node_, nodes} = if should_delete do
    new_children = remove_key(node_.children, ch)
    node_ = Map.put(node_, :children, new_children)
    nodes = List.replace_at(nodes, idx, node_)
    throw {:return, map_size(new_children) == 0 && node_.is_leaf == false}
    {node_, nodes}
  else
    {node_, nodes}
  end
  nodes = List.replace_at(nodes, idx, node_)
  throw {:return, false}
end
      _delete.(0, 0)
      trie = Map.put(trie, :nodes, nodes)
    catch
      {:return, val} -> val
    end
  end
  def print_words(trie) do
    try do
      dfs = fn idx, word ->
  node_ = Enum.at(trie.nodes, idx)
  if node_.is_leaf do
    IO.puts(word)
  end
  Enum.each(Map.keys(node_.children), fn key ->
    dfs(node_.children[key], (word <> key))
  end)
end
      dfs.(0, "")
    catch
      {:return, val} -> val
    end
  end
  def test_trie() do
    try do
      words = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"]
      trie = new_trie()
      insert_many(trie, words)
      ok = true
      {ok} = Enum.reduce(words, {ok}, fn w, {ok} ->
        ok = ok && find(trie, w)
        {ok}
      end)
      ok = ok && find(trie, "banana")
      t = find(trie, "bandanas")
      ok = ok && (t == false)
      t2 = find(trie, "apps")
      ok = ok && (t2 == false)
      ok = ok && find(trie, "apple")
      ok = ok && find(trie, "all")
      delete(trie, "all")
      t3 = find(trie, "all")
      ok = ok && (t3 == false)
      delete(trie, "banana")
      t4 = find(trie, "banana")
      ok = ok && (t4 == false)
      ok = ok && find(trie, "bananas")
      throw {:return, ok}
    catch
      {:return, val} -> val
    end
  end
  def print_results(msg, passes) do
    try do
      if passes do
        IO.puts((msg <> " works!"))
      else
        IO.puts((msg <> " doesn't work :("))
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:trie, new_trie())
    print_results("Testing trie functionality", test_trie())
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
