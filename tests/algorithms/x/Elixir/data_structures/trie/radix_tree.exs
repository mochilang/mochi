# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_node(prefix, is_leaf) do
    try do
      throw {:return, %{prefix: prefix, is_leaf: is_leaf, children: %{}}}
    catch
      {:return, val} -> val
    end
  end
  def new_tree() do
    try do
      nodes = [new_node("", false)]
      throw {:return, %{nodes: nodes}}
    catch
      {:return, val} -> val
    end
  end
  def match_prefix(node_, word) do
    try do
      x = 0
      p = node_.prefix
      w = word
      min_len = _len(p)
      {min_len} = if _len(w) < min_len do
        min_len = _len(w)
        {min_len}
      else
        {min_len}
      end
      while_fun = fn while_fun, x ->
        if x < min_len do
          if _slice(p, x, x + 1 - (x)) != _slice(w, x, x + 1 - (x)) do
            throw {:break, {x}}
          end
          x = x + 1
          while_fun.(while_fun, x)
        else
          x
        end
      end
      x = try do
          while_fun.(while_fun, x)
        catch
          {:break, {x}} -> x
        end

      common = _slice(p, 0, x - (0))
      rem_prefix = _slice(p, x, _len(p) - (x))
      rem_word = _slice(w, x, _len(w) - (x))
      throw {:return, %{common: common, rem_prefix: rem_prefix, rem_word: rem_word}}
    catch
      {:return, val} -> val
    end
  end
  def insert_many(tree, words) do
    try do
      Enum.each(words, fn w ->
        insert(tree, 0, w)
      end)
    catch
      {:return, val} -> val
    end
  end
  def insert(tree, idx, word) do
    try do
      nodes = tree.nodes
      node_ = Enum.at(nodes, idx)
      {node_, nodes, tree} = if (node_.prefix == word) && (!node_.is_leaf) do
        node_ = Map.put(node_, :is_leaf, true)
        nodes = List.replace_at(nodes, idx, node_)
        tree = Map.put(tree, :nodes, nodes)
        throw {:return, nil}
        {node_, nodes, tree}
      else
        {node_, nodes, tree}
      end
      first = _slice(word, 0, 1 - (0))
      children = node_.children
      {children, node_, nodes, tree} = if !has_key(children, first) do
        new_idx = _len(nodes)
        nodes = (nodes ++ [new_node(word, true)])
        children = Map.put(children, first, new_idx)
        node_ = Map.put(node_, :children, children)
        nodes = List.replace_at(nodes, idx, node_)
        tree = Map.put(tree, :nodes, nodes)
        throw {:return, nil}
        {children, node_, nodes, tree}
      else
        {children, node_, nodes, tree}
      end
      child_idx = children[first]
      child = Enum.at(nodes, child_idx)
      res = match_prefix(child, word)
      if res.rem_prefix == "" do
        insert(tree, child_idx, res.rem_word)
        throw {:return, nil}
      end
      child = Map.put(child, :prefix, res.rem_prefix)
      nodes = List.replace_at(nodes, child_idx, child)
      new_children = %{}
      new_children = Map.put(new_children, _slice(res.rem_prefix, 0, 1 - (0)), child_idx)
      new_idx = _len(nodes)
      nodes = (nodes ++ [new_node(res.common, false)])
      nodes = List.replace_at(nodes, new_idx, Map.put(Enum.at(nodes, new_idx), :children, new_children))
      {nodes} = if res.rem_word == "" do
        nodes = List.replace_at(nodes, new_idx, Map.put(Enum.at(nodes, new_idx), :is_leaf, true))
        {nodes}
      else
        insert(tree, new_idx, res.rem_word)
        {nodes}
      end
      children = Map.put(children, first, new_idx)
      node_ = Map.put(node_, :children, children)
      nodes = List.replace_at(nodes, idx, node_)
      tree = Map.put(tree, :nodes, nodes)
    catch
      {:return, val} -> val
    end
  end
  def find(tree, idx, word) do
    try do
      nodes = tree.nodes
      node_ = Enum.at(nodes, idx)
      first = _slice(word, 0, 1 - (0))
      children = node_.children
      if !has_key(children, first) do
        throw {:return, false}
      end
      child_idx = children[first]
      child = Enum.at(nodes, child_idx)
      res = match_prefix(child, word)
      if res.rem_prefix != "" do
        throw {:return, false}
      end
      if res.rem_word == "" do
        throw {:return, child.is_leaf}
      end
      throw {:return, find(tree, child_idx, res.rem_word)}
    catch
      {:return, val} -> val
    end
  end
  def remove_key(m, k) do
    try do
      out = %{}
      {out} = Enum.reduce(Map.keys(m), {out}, fn key, {out} ->
        {out} = if key != k do
          out = Map.put(out, key, m[key])
          {out}
        else
          {out}
        end
        {out}
      end)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def has_key(m, k) do
    try do
      Enum.each(Map.keys(m), fn key ->
        if key == k do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def delete(tree, idx, word) do
    try do
      nodes = tree.nodes
      node_ = Enum.at(nodes, idx)
      first = _slice(word, 0, 1 - (0))
      children = node_.children
      if !has_key(children, first) do
        throw {:return, false}
      end
      child_idx = children[first]
      child = Enum.at(nodes, child_idx)
      res = match_prefix(child, word)
      if res.rem_prefix != "" do
        throw {:return, false}
      end
      {node_, nodes} = if res.rem_word != "" do
        deleted = delete(tree, child_idx, res.rem_word)
        {node_, nodes} = if deleted do
          nodes = tree.nodes
          node_ = Enum.at(nodes, idx)
          {node_, nodes}
        else
          {node_, nodes}
        end
        throw {:return, deleted}
        {node_, nodes}
      else
        {node_, nodes}
      end
      if !child.is_leaf do
        throw {:return, false}
      end
      {child, children, node_, nodes, tree} = if map_size(Map.get(child, :children, [])) == 0 do
        children = remove_key(children, first)
        node_ = Map.put(node_, :children, children)
        nodes = List.replace_at(nodes, idx, node_)
        tree = Map.put(tree, :nodes, nodes)
        {node_, nodes, tree} = if (map_size(children) == 1) && (!node_.is_leaf) do
          only_key = ""
          {only_key} = Enum.reduce(Map.keys(children), {only_key}, fn k, {only_key} ->
            only_key = k
            {only_key}
          end)
          merge_idx = children[only_key]
          merge_node = Enum.at(nodes, merge_idx)
          node_ = Map.put(node_, :is_leaf, merge_node.is_leaf)
          node_ = Map.put(node_, :prefix, (node_.prefix <> merge_node.prefix))
          node_ = Map.put(node_, :children, merge_node.children)
          nodes = List.replace_at(nodes, idx, node_)
          tree = Map.put(tree, :nodes, nodes)
          {node_, nodes, tree}
        else
          {node_, nodes, tree}
        end
        {child, children, node_, nodes, tree}
      else
        {child, nodes, tree} = if map_size(Map.get(child, :children, [])) > 1 do
          child = Map.put(child, :is_leaf, false)
          nodes = List.replace_at(nodes, child_idx, child)
          tree = Map.put(tree, :nodes, nodes)
          {child, nodes, tree}
        else
          only_key = ""
          {only_key} = Enum.reduce(Map.keys(child.children), {only_key}, fn k, {only_key} ->
            only_key = k
            {only_key}
          end)
          merge_idx = child.children[only_key]
          merge_node = Enum.at(nodes, merge_idx)
          child = Map.put(child, :is_leaf, merge_node.is_leaf)
          child = Map.put(child, :prefix, (child.prefix <> merge_node.prefix))
          child = Map.put(child, :children, merge_node.children)
          nodes = List.replace_at(nodes, child_idx, child)
          tree = Map.put(tree, :nodes, nodes)
          {child, nodes, tree}
        end
        {child, children, node_, nodes, tree}
      end
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def print_tree(tree, idx, height) do
    try do
      nodes = tree.nodes
      node_ = Enum.at(nodes, idx)
      if node_.prefix != "" do
        line = ""
        i = 0
        while_fun_2 = fn while_fun_2, i, line ->
          if i < height do
            line = (line <> "-")
            i = i + 1
            while_fun_2.(while_fun_2, i, line)
          else
            {i, line}
          end
        end
        {i, line} = try do
            while_fun_2.(while_fun_2, i, line)
          catch
            {:break, {i, line}} -> {i, line}
          end

        line = ((line <> " ") <> node_.prefix)
        {line} = if node_.is_leaf do
          line = (line <> "  (leaf)")
          {line}
        else
          {line}
        end
        IO.puts(line)
      end
      children = node_.children
      Enum.each(Map.keys(children), fn k ->
        child_idx = children[k]
        print_tree(tree, child_idx, height + 1)
      end)
    catch
      {:return, val} -> val
    end
  end
  def test_trie() do
    try do
      words = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"]
      tree = new_tree()
      insert_many(tree, words)
      ok = true
      {ok} = Enum.reduce(words, {ok}, fn w, {ok} ->
        {ok} = if !find(tree, 0, w) do
          ok = false
          {ok}
        else
          {ok}
        end
        {ok}
      end)
      {ok} = if find(tree, 0, "bandanas") do
        ok = false
        {ok}
      else
        {ok}
      end
      {ok} = if find(tree, 0, "apps") do
        ok = false
        {ok}
      else
        {ok}
      end
      delete(tree, 0, "all")
      {ok} = if find(tree, 0, "all") do
        ok = false
        {ok}
      else
        {ok}
      end
      delete(tree, 0, "banana")
      {ok} = if find(tree, 0, "banana") do
        ok = false
        {ok}
      else
        {ok}
      end
      {ok} = if !find(tree, 0, "bananas") do
        ok = false
        {ok}
      else
        {ok}
      end
      throw {:return, ok}
    catch
      {:return, val} -> val
    end
  end
  def pytests() do
    try do
      if !test_trie() do
        raise("test failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tree = new_tree()
      words = ["banana", "bananas", "bandanas", "bandana", "band", "apple", "all", "beast"]
      insert_many(tree, words)
      IO.puts(("Words: " <> Kernel.to_string(words)))
      IO.puts("Tree:")
      print_tree(tree, 0, 0)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
