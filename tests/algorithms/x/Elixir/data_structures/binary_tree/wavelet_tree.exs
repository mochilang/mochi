# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_list(length, value) do
    try do
      lst = []
      i = 0
      while_fun = fn while_fun, i, lst ->
        if i < length do
          lst = (lst ++ [value])
          i = i + 1
          while_fun.(while_fun, i, lst)
        else
          {i, lst}
        end
      end
      {i, lst} = try do
          while_fun.(while_fun, i, lst)
        catch
          {:break, {i, lst}} -> {i, lst}
        end

      throw {:return, lst}
    catch
      {:return, val} -> val
    end
  end
  def min_list(arr) do
    try do
      m = Enum.at(arr, 0)
      i = 1
      while_fun_2 = fn while_fun_2, i, m ->
        if i < _len(arr) do
          {m} = if Enum.at(arr, i) < m do
            m = Enum.at(arr, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_2.(while_fun_2, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def max_list(arr) do
    try do
      m = Enum.at(arr, 0)
      i = 1
      while_fun_3 = fn while_fun_3, i, m ->
        if i < _len(arr) do
          {m} = if Enum.at(arr, i) > m do
            m = Enum.at(arr, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_3.(while_fun_3, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def build_tree(arr) do
    try do
      n = %{minn: min_list(arr), maxx: max_list(arr), map_left: make_list(_len(arr), 0), left: -1, right: -1}
      if n.minn == n.maxx do
        Process.put(:nodes, (Process.get(:nodes) ++ [n]))
        throw {:return, _len(Process.get(:nodes)) - 1}
      end
      pivot = div((n.minn + n.maxx), 2)
      left_arr = []
      right_arr = []
      i = 0
      while_fun_4 = fn while_fun_4, i, left_arr, n, right_arr ->
        if i < _len(arr) do
          num = Enum.at(arr, i)
          {left_arr, right_arr} = if num <= pivot do
            left_arr = (left_arr ++ [num])
            {left_arr, right_arr}
          else
            right_arr = (right_arr ++ [num])
            {left_arr, right_arr}
          end
          ml = n.map_left
          ml = List.replace_at(ml, i, _len(left_arr))
          n = Map.put(n, :map_left, ml)
          i = i + 1
          while_fun_4.(while_fun_4, i, left_arr, n, right_arr)
        else
          {i, left_arr, n, right_arr}
        end
      end
      {i, left_arr, n, right_arr} = try do
          while_fun_4.(while_fun_4, i, left_arr, n, right_arr)
        catch
          {:break, {i, left_arr, n, right_arr}} -> {i, left_arr, n, right_arr}
        end

      {n} = if _len(left_arr) > 0 do
        n = Map.put(n, :left, build_tree(left_arr))
        {n}
      else
        {n}
      end
      {n} = if _len(right_arr) > 0 do
        n = Map.put(n, :right, build_tree(right_arr))
        {n}
      else
        {n}
      end
      Process.put(:nodes, (Process.get(:nodes) ++ [n]))
      throw {:return, _len(Process.get(:nodes)) - 1}
    catch
      {:return, val} -> val
    end
  end
  def rank_till_index(node_idx, num, index) do
    try do
      if index < 0 || node_idx < 0 do
        throw {:return, 0}
      end
      node_ = Enum.at(Process.get(:nodes), node_idx)
      if node_.minn == node_.maxx do
        if node_.minn == num do
          throw {:return, index + 1}
        else
          throw {:return, 0}
        end
      end
      pivot = div((node_.minn + node_.maxx), 2)
      if num <= pivot do
        throw {:return, rank_till_index(node_.left, num, Enum.at(node_.map_left, index) - 1)}
      else
        throw {:return, rank_till_index(node_.right, num, index - Enum.at(node_.map_left, index))}
      end
    catch
      {:return, val} -> val
    end
  end
  def rank(node_idx, num, start, end_) do
    try do
      if start > end_ do
        throw {:return, 0}
      end
      rank_till_end = rank_till_index(node_idx, num, end_)
      rank_before_start = rank_till_index(node_idx, num, start - 1)
      throw {:return, rank_till_end - rank_before_start}
    catch
      {:return, val} -> val
    end
  end
  def quantile(node_idx, index, start, end_) do
    try do
      if index > (end_ - start) || start > end_ || node_idx < 0 do
        throw {:return, -1}
      end
      node_ = Enum.at(Process.get(:nodes), node_idx)
      if node_.minn == node_.maxx do
        throw {:return, node_.minn}
      end
      left_start = (if start == 0, do: 0, else: Enum.at(node_.map_left, start - 1))
      num_left = Enum.at(node_.map_left, end_) - left_start
      if num_left > index do
        throw {:return, quantile(node_.left, index, left_start, Enum.at(node_.map_left, end_) - 1)}
      else
        throw {:return, quantile(node_.right, index - num_left, start - left_start, end_ - Enum.at(node_.map_left, end_))}
      end
    catch
      {:return, val} -> val
    end
  end
  def range_counting(node_idx, start, end_, start_num, end_num) do
    try do
      if start > end_ || node_idx < 0 || start_num > end_num do
        throw {:return, 0}
      end
      node_ = Enum.at(Process.get(:nodes), node_idx)
      if node_.minn > end_num || node_.maxx < start_num do
        throw {:return, 0}
      end
      if start_num <= node_.minn && node_.maxx <= end_num do
        throw {:return, end_ - start + 1}
      end
      left = range_counting(node_.left, ((if start == 0, do: 0, else: Enum.at(node_.map_left, start - 1))), Enum.at(node_.map_left, end_) - 1, start_num, end_num)
      right = range_counting(node_.right, start - ((if start == 0, do: 0, else: Enum.at(node_.map_left, start - 1))), end_ - Enum.at(node_.map_left, end_), start_num, end_num)
      throw {:return, left + right}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:nodes, [])
  Process.put(:test_array, [2, 1, 4, 5, 6, 0, 8, 9, 1, 2, 0, 6, 4, 2, 0, 6, 5, 3, 2, 7])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:root, build_tree(Process.get(:test_array)))
    IO.puts(("rank_till_index 6 at 6 -> " <> Kernel.inspect(rank_till_index(Process.get(:root), 6, 6))))
    IO.puts(("rank 6 in [3,13] -> " <> Kernel.inspect(rank(Process.get(:root), 6, 3, 13))))
    IO.puts(("quantile index 2 in [2,5] -> " <> Kernel.inspect(quantile(Process.get(:root), 2, 2, 5))))
    IO.puts(("range_counting [3,7] in [1,10] -> " <> Kernel.inspect(range_counting(Process.get(:root), 1, 10, 3, 7))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
