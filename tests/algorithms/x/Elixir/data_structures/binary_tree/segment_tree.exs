# Code generated by Mochi transpiler 2025-08-07 14:57 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def left_child(idx) do
    try do
      throw {:return, idx * 2}
    catch
      {:return, val} -> val
    end
  end
  def right_child(idx) do
    try do
      throw {:return, idx * 2 + 1}
    catch
      {:return, val} -> val
    end
  end
  def build(idx, left, right) do
    try do
      if left == right do
        Process.put(:st, List.replace_at(Process.get(:st), idx, Enum.at(Process.get(:a), left)))
      else
        mid = div((left + right), 2)
        build(left_child(idx), left, mid)
        build(right_child(idx), mid + 1, right)
        left_val = Enum.at(Process.get(:st), left_child(idx))
        right_val = Enum.at(Process.get(:st), right_child(idx))
        Process.put(:st, List.replace_at(Process.get(:st), idx, ((if left_val > right_val, do: left_val, else: right_val))))
      end
    catch
      {:return, val} -> val
    end
  end
  def update_recursive(idx, left, right, a, b, val) do
    try do
      if right < a || left > b do
        throw {:return, true}
      end
      if left == right do
        Process.put(:st, List.replace_at(Process.get(:st), idx, val))
        throw {:return, true}
      end
      mid = div((left + right), 2)
      update_recursive(left_child(idx), left, mid, a, b, val)
      update_recursive(right_child(idx), mid + 1, right, a, b, val)
      left_val = Enum.at(Process.get(:st), left_child(idx))
      right_val = Enum.at(Process.get(:st), right_child(idx))
      Process.put(:st, List.replace_at(Process.get(:st), idx, ((if left_val > right_val, do: left_val, else: right_val))))
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def update(a, b, val) do
    try do
      throw {:return, update_recursive(1, 0, Process.get(:n) - 1, a - 1, b - 1, val)}
    catch
      {:return, val} -> val
    end
  end
  def query_recursive(idx, left, right, a, b) do
    try do
      if right < a || left > b do
        throw {:return, Process.get(:neg_inf)}
      end
      if left >= a && right <= b do
        throw {:return, Enum.at(Process.get(:st), idx)}
      end
      mid = div((left + right), 2)
      q1 = query_recursive(left_child(idx), left, mid, a, b)
      q2 = query_recursive(right_child(idx), mid + 1, right, a, b)
      throw {:return, ((if q1 > q2, do: q1, else: q2))}
    catch
      {:return, val} -> val
    end
  end
  def query(a, b) do
    try do
      throw {:return, query_recursive(1, 0, Process.get(:n) - 1, a - 1, b - 1)}
    catch
      {:return, val} -> val
    end
  end
  def show_data() do
    try do
      i = 0
      show_list = []
      while_fun = fn while_fun, i, show_list ->
        if i < Process.get(:n) do
          show_list = (show_list ++ [query(i + 1, i + 1)])
          i = i + 1
          while_fun.(while_fun, i, show_list)
        else
          {i, show_list}
        end
      end
      {i, show_list} = try do
          while_fun.(while_fun, i, show_list)
        catch
          {:break, {i, show_list}} -> {i, show_list}
        end

      IO.puts(Kernel.inspect(show_list))
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      Process.put(:a, [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8])
      Process.put(:n, _len(Process.get(:a)))
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < 4 * Process.get(:n) do
          Process.put(:st, (Process.get(:st) ++ [0]))
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      if Process.get(:n) > 0 do
        build(1, 0, Process.get(:n) - 1)
      end
      IO.puts(Kernel.inspect(query(4, 6)))
      IO.puts(Kernel.inspect(query(7, 11)))
      IO.puts(Kernel.inspect(query(7, 12)))
      update(1, 3, 111)
      IO.puts(Kernel.inspect(query(1, 15)))
      update(7, 8, 235)
      show_data()
    catch
      {:return, val} -> val
    end
  end
  Process.put(:a, [])
  Process.put(:n, 0)
  Process.put(:st, [])
end
Process.put(:neg_inf, -1000000000)
Main.main()
