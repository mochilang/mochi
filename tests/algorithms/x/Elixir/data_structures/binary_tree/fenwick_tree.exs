# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def fenwick_from_list(arr) do
    try do
      size = _len(arr)
      tree = []
      i = 0
      while_fun = fn while_fun, i, tree ->
        if i < size do
          tree = (tree ++ [Enum.at(arr, i)])
          i = i + 1
          while_fun.(while_fun, i, tree)
        else
          {i, tree}
        end
      end
      {i, tree} = try do
          while_fun.(while_fun, i, tree)
        catch
          {:break, {i, tree}} -> {i, tree}
        end

      i = 1
      while_fun_2 = fn while_fun_2, i, tree ->
        if i < size do
          j = fenwick_next(i)
          {tree} = if j < size do
            tree = List.replace_at(tree, j, Enum.at(tree, j) + Enum.at(tree, i))
            {tree}
          else
            {tree}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, tree)
        else
          {i, tree}
        end
      end
      {i, tree} = try do
          while_fun_2.(while_fun_2, i, tree)
        catch
          {:break, {i, tree}} -> {i, tree}
        end

      throw {:return, %{size: size, tree: tree}}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_empty(size) do
    try do
      tree = []
      i = 0
      while_fun_3 = fn while_fun_3, i, tree ->
        if i < size do
          tree = (tree ++ [0])
          i = i + 1
          while_fun_3.(while_fun_3, i, tree)
        else
          {i, tree}
        end
      end
      {i, tree} = try do
          while_fun_3.(while_fun_3, i, tree)
        catch
          {:break, {i, tree}} -> {i, tree}
        end

      throw {:return, %{size: size, tree: tree}}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_get_array(f) do
    try do
      arr = []
      i = 0
      while_fun_4 = fn while_fun_4, arr, i ->
        if i < f.size do
          arr = (arr ++ [Enum.at(f.tree, i)])
          i = i + 1
          while_fun_4.(while_fun_4, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_4.(while_fun_4, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      i = f.size - 1
      while_fun_5 = fn while_fun_5, arr, i ->
        if i > 0 do
          j = fenwick_next(i)
          {arr} = if j < f.size do
            arr = List.replace_at(arr, j, Enum.at(arr, j) - Enum.at(arr, i))
            {arr}
          else
            {arr}
          end
          i = i - 1
          while_fun_5.(while_fun_5, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_5.(while_fun_5, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def bit_and(a, b) do
    try do
      ua = a
      ub = b
      res = 0
      bit = 1
      while_fun_6 = fn while_fun_6, bit, res, ua, ub ->
        if ua != 0 || ub != 0 do
          {res} = if rem(ua, 2) == 1 && rem(ub, 2) == 1 do
            res = res + bit
            {res}
          else
            {res}
          end
          ua = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(ua, 2)))
          ub = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(ub, 2)))
          bit = bit * 2
          while_fun_6.(while_fun_6, bit, res, ua, ub)
        else
          {bit, res, ua, ub}
        end
      end
      {bit, res, ua, ub} = try do
          while_fun_6.(while_fun_6, bit, res, ua, ub)
        catch
          {:break, {bit, res, ua, ub}} -> {bit, res, ua, ub}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def low_bit(x) do
    try do
      throw {:return, ((if x == 0, do: 0, else: x - bit_and(x, x - 1)))}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_next(index) do
    try do
      throw {:return, index + low_bit(index)}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_prev(index) do
    try do
      throw {:return, index - low_bit(index)}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_add(f, index, value) do
    try do
      tree = f.tree
      {tree} = if index == 0 do
        tree = List.replace_at(tree, 0, Enum.at(tree, 0) + value)
        throw {:return, %{size: f.size, tree: tree}}
        {tree}
      else
        {tree}
      end
      i = index
      while_fun_7 = fn while_fun_7, i, tree ->
        if i < f.size do
          tree = List.replace_at(tree, i, Enum.at(tree, i) + value)
          i = fenwick_next(i)
          while_fun_7.(while_fun_7, i, tree)
        else
          {i, tree}
        end
      end
      {i, tree} = try do
          while_fun_7.(while_fun_7, i, tree)
        catch
          {:break, {i, tree}} -> {i, tree}
        end

      throw {:return, %{size: f.size, tree: tree}}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_update(f, index, value) do
    try do
      current = fenwick_get(f, index)
      throw {:return, fenwick_add(f, index, value - current)}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_prefix(f, right) do
    try do
      if right == 0 do
        throw {:return, 0}
      end
      result = Enum.at(f.tree, 0)
      r = right - 1
      while_fun_8 = fn while_fun_8, r, result ->
        if r > 0 do
          result = result + Enum.at(f.tree, r)
          r = fenwick_prev(r)
          while_fun_8.(while_fun_8, r, result)
        else
          {r, result}
        end
      end
      {r, result} = try do
          while_fun_8.(while_fun_8, r, result)
        catch
          {:break, {r, result}} -> {r, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_query(f, left, right) do
    try do
      throw {:return, fenwick_prefix(f, right) - fenwick_prefix(f, left)}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_get(f, index) do
    try do
      throw {:return, fenwick_query(f, index, index + 1)}
    catch
      {:return, val} -> val
    end
  end
  def fenwick_rank_query(f, value) do
    try do
      v = value - Enum.at(f.tree, 0)
      if v < 0 do
        throw {:return, -1}
      end
      j = 1
      while_fun_9 = fn while_fun_9, j ->
        if j * 2 < f.size do
          j = j * 2
          while_fun_9.(while_fun_9, j)
        else
          j
        end
      end
      j = try do
          while_fun_9.(while_fun_9, j)
        catch
          {:break, {j}} -> j
        end

      i = 0
      jj = j
      while_fun_10 = fn while_fun_10, i, jj, v ->
        if jj > 0 do
          {i, v} = if i + jj < f.size && Enum.at(f.tree, i + jj) <= v do
            v = v - Enum.at(f.tree, i + jj)
            i = i + jj
            {i, v}
          else
            {i, v}
          end
          jj = div(jj, 2)
          while_fun_10.(while_fun_10, i, jj, v)
        else
          {i, jj, v}
        end
      end
      {i, jj, v} = try do
          while_fun_10.(while_fun_10, i, jj, v)
        catch
          {:break, {i, jj, v}} -> {i, jj, v}
        end

      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:f_base, fenwick_from_list([1, 2, 3, 4, 5]))
    IO.puts(Kernel.inspect(fenwick_get_array(Process.get(:f_base))))
    Process.put(:f, fenwick_from_list([1, 2, 3, 4, 5]))
    Process.put(:f, fenwick_add(Process.get(:f), 0, 1))
    Process.put(:f, fenwick_add(Process.get(:f), 1, 2))
    Process.put(:f, fenwick_add(Process.get(:f), 2, 3))
    Process.put(:f, fenwick_add(Process.get(:f), 3, 4))
    Process.put(:f, fenwick_add(Process.get(:f), 4, 5))
    IO.puts(Kernel.inspect(fenwick_get_array(Process.get(:f))))
    Process.put(:f2, fenwick_from_list([1, 2, 3, 4, 5]))
    IO.puts(Kernel.inspect(fenwick_prefix(Process.get(:f2), 3)))
    IO.puts(Kernel.inspect(fenwick_query(Process.get(:f2), 1, 4)))
    Process.put(:f3, fenwick_from_list([1, 2, 0, 3, 0, 5]))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 0)))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 2)))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 1)))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 3)))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 5)))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 6)))
    IO.puts(Kernel.inspect(fenwick_rank_query(Process.get(:f3), 11)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
