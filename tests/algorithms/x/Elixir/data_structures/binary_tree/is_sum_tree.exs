# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def tree_sum(nodes, idx) do
    try do
      if idx == (-1) do
        throw {:return, 0}
      end
      node_ = Enum.at(nodes, idx)
      throw {:return, node_.value + tree_sum(nodes, node_.left) + tree_sum(nodes, node_.right)}
    catch
      {:return, val} -> val
    end
  end
  def is_sum_node(nodes, idx) do
    try do
      node_ = Enum.at(nodes, idx)
      if node_.left == (-1) && node_.right == (-1) do
        throw {:return, true}
      end
      left_sum = tree_sum(nodes, node_.left)
      right_sum = tree_sum(nodes, node_.right)
      if node_.value != left_sum + right_sum do
        throw {:return, false}
      end
      left_ok = true
      {left_ok} = if node_.left != (-1) do
        left_ok = is_sum_node(nodes, node_.left)
        {left_ok}
      else
        {left_ok}
      end
      right_ok = true
      {right_ok} = if node_.right != (-1) do
        right_ok = is_sum_node(nodes, node_.right)
        {right_ok}
      else
        {right_ok}
      end
      throw {:return, left_ok && right_ok}
    catch
      {:return, val} -> val
    end
  end
  def build_a_tree() do
    try do
      throw {:return, [%{value: 11, left: 1, right: 2}, %{value: 2, left: 3, right: 4}, %{value: 29, left: 5, right: 6}, %{value: 1, left: (-1), right: (-1)}, %{value: 7, left: (-1), right: (-1)}, %{value: 15, left: (-1), right: (-1)}, %{value: 40, left: 7, right: (-1)}, %{value: 35, left: (-1), right: (-1)}]}
    catch
      {:return, val} -> val
    end
  end
  def build_a_sum_tree() do
    try do
      throw {:return, [%{value: 26, left: 1, right: 2}, %{value: 10, left: 3, right: 4}, %{value: 3, left: (-1), right: 5}, %{value: 4, left: (-1), right: (-1)}, %{value: 6, left: (-1), right: (-1)}, %{value: 3, left: (-1), right: (-1)}]}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
