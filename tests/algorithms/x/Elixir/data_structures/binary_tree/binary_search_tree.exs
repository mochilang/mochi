# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def create_node(value) do
    try do
      throw {:return, [value, nil, nil]}
    catch
      {:return, val} -> val
    end
  end
  def insert(node_, value) do
    try do
      if node_ == nil do
        throw {:return, create_node(value)}
      end
      {node_} = if value < Enum.at(node_, 0) do
        node_ = List.replace_at(node_, 1, insert(Enum.at(node_, 1), value))
        {node_}
      else
        {node_} = if value > Enum.at(node_, 0) do
          node_ = List.replace_at(node_, 2, insert(Enum.at(node_, 2), value))
          {node_}
        else
          {node_}
        end
        {node_}
      end
      throw {:return, node_}
    catch
      {:return, val} -> val
    end
  end
  def search(node_, value) do
    try do
      if node_ == nil do
        throw {:return, false}
      end
      if value == Enum.at(node_, 0) do
        throw {:return, true}
      end
      if value < Enum.at(node_, 0) do
        throw {:return, search(Enum.at(node_, 1), value)}
      end
      throw {:return, search(Enum.at(node_, 2), value)}
    catch
      {:return, val} -> val
    end
  end
  def inorder(node_, acc) do
    try do
      if node_ == nil do
        throw {:return, acc}
      end
      left_acc = inorder(Enum.at(node_, 1), acc)
      with_node = (left_acc ++ [Enum.at(node_, 0)])
      throw {:return, inorder(Enum.at(node_, 2), with_node)}
    catch
      {:return, val} -> val
    end
  end
  def find_min(node_) do
    try do
      current = node_
      while_fun = fn while_fun, current ->
        if Enum.at(current, 1) != nil do
          current = Enum.at(current, 1)
          while_fun.(while_fun, current)
        else
          current
        end
      end
      current = try do
          while_fun.(while_fun, current)
        catch
          {:break, {current}} -> current
        end

      throw {:return, Enum.at(current, 0)}
    catch
      {:return, val} -> val
    end
  end
  def find_max(node_) do
    try do
      current = node_
      while_fun_2 = fn while_fun_2, current ->
        if Enum.at(current, 2) != nil do
          current = Enum.at(current, 2)
          while_fun_2.(while_fun_2, current)
        else
          current
        end
      end
      current = try do
          while_fun_2.(while_fun_2, current)
        catch
          {:break, {current}} -> current
        end

      throw {:return, Enum.at(current, 0)}
    catch
      {:return, val} -> val
    end
  end
  def delete(node_, value) do
    try do
      if node_ == nil do
        throw {:return, nil}
      end
      {node_} = if value < Enum.at(node_, 0) do
        node_ = List.replace_at(node_, 1, delete(Enum.at(node_, 1), value))
        {node_}
      else
        {node_} = if value > Enum.at(node_, 0) do
          node_ = List.replace_at(node_, 2, delete(Enum.at(node_, 2), value))
          {node_}
        else
          if Enum.at(node_, 1) == nil do
            throw {:return, Enum.at(node_, 2)}
          end
          if Enum.at(node_, 2) == nil do
            throw {:return, Enum.at(node_, 1)}
          end
          min_val = find_min(Enum.at(node_, 2))
          node_ = List.replace_at(node_, 0, min_val)
          node_ = List.replace_at(node_, 2, delete(Enum.at(node_, 2), min_val))
          {node_}
        end
        {node_}
      end
      throw {:return, node_}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      root = nil
      nums = [8, 3, 6, 1, 10, 14, 13, 4, 7]
      {root} = Enum.reduce(nums, {root}, fn v, {root} ->
        root = insert(root, v)
        {root}
      end)
      IO.puts(Kernel.inspect(inorder(root, [])))
      IO.puts(Kernel.inspect(search(root, 6)))
      IO.puts(Kernel.inspect(search(root, 20)))
      IO.puts(Kernel.inspect(find_min(root)))
      IO.puts(Kernel.inspect(find_max(root)))
      root = delete(root, 6)
      IO.puts(Kernel.inspect(inorder(root, [])))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
