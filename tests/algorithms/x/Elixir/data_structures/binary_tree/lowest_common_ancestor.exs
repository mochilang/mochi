# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow2(exp) do
    try do
      res = 1
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < exp do
          res = res * 2
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def create_sparse(max_node, parent) do
    try do
      j = 1
      while_fun_2 = fn while_fun_2, j, parent ->
        if pow2(j) < max_node do
          i = 1
          while_fun_3 = fn while_fun_3, i, parent ->
            if i <= max_node do
              parent = List.replace_at(parent, j, List.replace_at(Enum.at(parent, j), i, Enum.at(Enum.at(parent, j - 1), Enum.at(Enum.at(parent, j - 1), i))))
              i = i + 1
              while_fun_3.(while_fun_3, i, parent)
            else
              {i, parent}
            end
          end
          {i, parent} = try do
              while_fun_3.(while_fun_3, i, parent)
            catch
              {:break, {i, parent}} -> {i, parent}
            end

          j = j + 1
          while_fun_2.(while_fun_2, j, parent)
        else
          {j, parent}
        end
      end
      {j, parent} = try do
          while_fun_2.(while_fun_2, j, parent)
        catch
          {:break, {j, parent}} -> {j, parent}
        end

      throw {:return, parent}
    catch
      {:return, val} -> val
    end
  end
  def lowest_common_ancestor(u, v, level, parent) do
    try do
      {u, v} = if Enum.at(level, u) < Enum.at(level, v) do
        temp = u
        u = v
        v = temp
        {u, v}
      else
        {u, v}
      end
      i = 18
      while_fun_4 = fn while_fun_4, i, u ->
        if i >= 0 do
          {u} = if Enum.at(level, u) - pow2(i) >= Enum.at(level, v) do
            u = Enum.at(Enum.at(parent, i), u)
            {u}
          else
            {u}
          end
          i = i - 1
          while_fun_4.(while_fun_4, i, u)
        else
          {i, u}
        end
      end
      {i, u} = try do
          while_fun_4.(while_fun_4, i, u)
        catch
          {:break, {i, u}} -> {i, u}
        end

      if u == v do
        throw {:return, u}
      end
      i = 18
      while_fun_5 = fn while_fun_5, i, u, v ->
        if i >= 0 do
          pu = Enum.at(Enum.at(parent, i), u)
          pv = Enum.at(Enum.at(parent, i), v)
          {u, v} = if pu != 0 && pu != pv do
            u = pu
            v = pv
            {u, v}
          else
            {u, v}
          end
          i = i - 1
          while_fun_5.(while_fun_5, i, u, v)
        else
          {i, u, v}
        end
      end
      {i, u, v} = try do
          while_fun_5.(while_fun_5, i, u, v)
        catch
          {:break, {i, u, v}} -> {i, u, v}
        end

      throw {:return, Enum.at(Enum.at(parent, 0), u)}
    catch
      {:return, val} -> val
    end
  end
  def breadth_first_search(level, parent, max_node, graph, root) do
    try do
      level = List.replace_at(level, root, 0)
      q = []
      q = (q ++ [root])
      head = 0
      while_fun_6 = fn while_fun_6, head, level, parent, q ->
        if head < _len(q) do
          u = Enum.at(q, head)
          head = head + 1
          adj = graph[u]
          j = 0
          while_fun_7 = fn while_fun_7, j, level, parent, q ->
            if j < _len(adj) do
              v = Enum.at(adj, j)
              {level, parent, q} = if Enum.at(level, v) == 0 - 1 do
                level = List.replace_at(level, v, Enum.at(level, u) + 1)
                parent = List.replace_at(parent, 0, List.replace_at(Enum.at(parent, 0), v, u))
                q = (q ++ [v])
                {level, parent, q}
              else
                {level, parent, q}
              end
              j = j + 1
              while_fun_7.(while_fun_7, j, level, parent, q)
            else
              {j, level, parent, q}
            end
          end
          {j, level, parent, q} = try do
              while_fun_7.(while_fun_7, j, level, parent, q)
            catch
              {:break, {j, level, parent, q}} -> {j, level, parent, q}
            end

          while_fun_6.(while_fun_6, head, level, parent, q)
        else
          {head, level, parent, q}
        end
      end
      {head, level, parent, q} = try do
          while_fun_6.(while_fun_6, head, level, parent, q)
        catch
          {:break, {head, level, parent, q}} -> {head, level, parent, q}
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      max_node = 13
      parent = []
      i = 0
      while_fun_8 = fn while_fun_8, i, parent ->
        if i < 20 do
          row = []
          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < max_node + 10 do
              row = (row ++ [0])
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          parent = (parent ++ [row])
          i = i + 1
          while_fun_8.(while_fun_8, i, parent)
        else
          {i, parent}
        end
      end
      {i, parent} = try do
          while_fun_8.(while_fun_8, i, parent)
        catch
          {:break, {i, parent}} -> {i, parent}
        end

      level = []
      i = 0
      while_fun_10 = fn while_fun_10, i, level ->
        if i < max_node + 10 do
          level = (level ++ [0 - 1])
          i = i + 1
          while_fun_10.(while_fun_10, i, level)
        else
          {i, level}
        end
      end
      {i, level} = try do
          while_fun_10.(while_fun_10, i, level)
        catch
          {:break, {i, level}} -> {i, level}
        end

      graph = %{}
      graph = Map.put(graph, 1, [2, 3, 4])
      graph = Map.put(graph, 2, [5])
      graph = Map.put(graph, 3, [6, 7])
      graph = Map.put(graph, 4, [8])
      graph = Map.put(graph, 5, [9, 10])
      graph = Map.put(graph, 6, [11])
      graph = Map.put(graph, 7, [])
      graph = Map.put(graph, 8, [12, 13])
      graph = Map.put(graph, 9, [])
      graph = Map.put(graph, 10, [])
      graph = Map.put(graph, 11, [])
      graph = Map.put(graph, 12, [])
      graph = Map.put(graph, 13, [])
      breadth_first_search(level, parent, max_node, graph, 1)
      parent = create_sparse(max_node, parent)
      IO.puts(("LCA of node 1 and 3 is: " <> Kernel.inspect(lowest_common_ancestor(1, 3, level, parent))))
      IO.puts(("LCA of node 5 and 6 is: " <> Kernel.inspect(lowest_common_ancestor(5, 6, level, parent))))
      IO.puts(("LCA of node 7 and 11 is: " <> Kernel.inspect(lowest_common_ancestor(7, 11, level, parent))))
      IO.puts(("LCA of node 6 and 7 is: " <> Kernel.inspect(lowest_common_ancestor(6, 7, level, parent))))
      IO.puts(("LCA of node 4 and 12 is: " <> Kernel.inspect(lowest_common_ancestor(4, 12, level, parent))))
      IO.puts(("LCA of node 8 and 8 is: " <> Kernel.inspect(lowest_common_ancestor(8, 8, level, parent))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
