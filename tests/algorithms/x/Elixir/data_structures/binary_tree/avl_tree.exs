# Code generated by Mochi transpiler 2025-08-24 15:35 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_node(value) do
    try do
      node_ = %{"data" => value, "left" => Process.get(:nil), "right" => Process.get(:nil), "height" => 1}
      Process.put(:nodes, (Process.get(:nodes) ++ [node_]))
      throw {:return, _len(Process.get(:nodes)) - 1}
    catch
      {:return, val} -> val
    end
  end
  def get_height(i) do
    try do
      throw {:return, ((if i == Process.get(:nil), do: 0, else: Enum.at(Process.get(:nodes), i, [])["height"]))}
    catch
      {:return, val} -> val
    end
  end
  def my_max(a, b) do
    try do
      throw {:return, ((if a > b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def update_height(i) do
    try do
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "height", my_max(get_height(Enum.at(Process.get(:nodes), i, [])["left"]), get_height(Enum.at(Process.get(:nodes), i, [])["right"])) + 1)))
    catch
      {:return, val} -> val
    end
  end
  def right_rotation(i) do
    try do
      left = Enum.at(Process.get(:nodes), i, [])["left"]
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", Enum.at(Process.get(:nodes), left, [])["right"])))
      Process.put(:nodes, List.replace_at(Process.get(:nodes), left, Map.put(Enum.at(Process.get(:nodes), left), "right", i)))
      i = update_height(i)
      left = update_height(left)
      throw {:return, left}
    catch
      {:return, val} -> val
    end
  end
  def left_rotation(i) do
    try do
      right = Enum.at(Process.get(:nodes), i, [])["right"]
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", Enum.at(Process.get(:nodes), right, [])["left"])))
      Process.put(:nodes, List.replace_at(Process.get(:nodes), right, Map.put(Enum.at(Process.get(:nodes), right), "left", i)))
      i = update_height(i)
      right = update_height(right)
      throw {:return, right}
    catch
      {:return, val} -> val
    end
  end
  def lr_rotation(i) do
    try do
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", left_rotation(Enum.at(Process.get(:nodes), i, [])["left"]))))
      throw {:return, right_rotation(i)}
    catch
      {:return, val} -> val
    end
  end
  def rl_rotation(i) do
    try do
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", right_rotation(Enum.at(Process.get(:nodes), i, [])["right"]))))
      throw {:return, left_rotation(i)}
    catch
      {:return, val} -> val
    end
  end
  def insert_node(i, value) do
    try do
      if i == Process.get(:nil) do
        throw {:return, new_node(value)}
      end
      i = if value < Enum.at(Process.get(:nodes), i, [])["data"] do
        Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", insert_node(Enum.at(Process.get(:nodes), i, [])["left"], value))))
        i = if get_height(Enum.at(Process.get(:nodes), i, [])["left"]) - get_height(Enum.at(Process.get(:nodes), i, [])["right"]) == 2 do
          i = (if value < Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i, [])["left"], [])["data"], do: right_rotation(i), else: lr_rotation(i))
          i
        else
          i
        end
        i
      else
        Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", insert_node(Enum.at(Process.get(:nodes), i, [])["right"], value))))
        i = if get_height(Enum.at(Process.get(:nodes), i, [])["right"]) - get_height(Enum.at(Process.get(:nodes), i, [])["left"]) == 2 do
          i = (if value < Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i, [])["right"], [])["data"], do: rl_rotation(i), else: left_rotation(i))
          i
        else
          i
        end
        i
      end
      i = update_height(i)
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def get_left_most(i) do
    try do
      cur = i
      while_fun = fn while_fun, cur ->
        if Enum.at(Process.get(:nodes), cur, [])["left"] != Process.get(:nil) do
          cur = Enum.at(Process.get(:nodes), cur, [])["left"]
          while_fun.(while_fun, cur)
        else
          cur
        end
      end
      cur = try do
          while_fun.(while_fun, cur)
        catch
          {:break, {cur}} -> cur
        end

      throw {:return, Enum.at(Process.get(:nodes), cur, [])["data"]}
    catch
      {:return, val} -> val
    end
  end
  def del_node(i, value) do
    try do
      if i == Process.get(:nil) do
        throw {:return, Process.get(:nil)}
      end
      i = if value < Enum.at(Process.get(:nodes), i, [])["data"] do
        Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", del_node(Enum.at(Process.get(:nodes), i, [])["left"], value))))
        i
      else
        i = if value > Enum.at(Process.get(:nodes), i, [])["data"] do
          Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", del_node(Enum.at(Process.get(:nodes), i, [])["right"], value))))
          i
        else
          i = if Enum.at(Process.get(:nodes), i, [])["left"] != Process.get(:nil) && Enum.at(Process.get(:nodes), i, [])["right"] != Process.get(:nil) do
            temp = get_left_most(Enum.at(Process.get(:nodes), i, [])["right"])
            Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "data", temp)))
            Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", del_node(Enum.at(Process.get(:nodes), i, [])["right"], temp))))
            i
          else
            i = if Enum.at(Process.get(:nodes), i, [])["left"] != Process.get(:nil) do
              i = Enum.at(Process.get(:nodes), i, [])["left"]
              i
            else
              i = Enum.at(Process.get(:nodes), i, [])["right"]
              i
            end
            i
          end
          i
        end
        i
      end
      if i == Process.get(:nil) do
        throw {:return, Process.get(:nil)}
      end
      lh = get_height(Enum.at(Process.get(:nodes), i, [])["left"])
      rh = get_height(Enum.at(Process.get(:nodes), i, [])["right"])
      i = if rh - lh == 2 do
        i = (if get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i, [])["right"], [])["right"]) > get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i, [])["right"], [])["left"]), do: left_rotation(i), else: rl_rotation(i))
        i
      else
        i = if lh - rh == 2 do
          i = (if get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i, [])["left"], [])["left"]) > get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i, [])["left"], [])["right"]), do: right_rotation(i), else: lr_rotation(i))
          i
        else
          i
        end
        i
      end
      i = update_height(i)
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def inorder(i) do
    try do
      if i == Process.get(:nil) do
        throw {:return, ""}
      end
      left = inorder(Enum.at(Process.get(:nodes), i, [])["left"])
      right = inorder(Enum.at(Process.get(:nodes), i, [])["right"])
      res = Kernel.to_string(Enum.at(Process.get(:nodes), i, [])["data"])
      res = if left != "" do
        res = ((left <> " ") <> res)
        res
      else
        res
      end
      res = if right != "" do
        res = ((res <> " ") <> right)
        res
      else
        res
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      Process.put(:nodes, [])
      root = Process.get(:nil)
      root = insert_node(root, 4)
      root = insert_node(root, 2)
      root = insert_node(root, 3)
      IO.puts(Kernel.inspect(inorder(root)))
      IO.puts(Kernel.inspect(get_height(root)))
      root = del_node(root, 3)
      IO.puts(Kernel.inspect(inorder(root)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:nodes, [])
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:nil, 0 - 1)
Main.bench_main()
