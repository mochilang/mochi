# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_node(value) do
    try do
      node_ = %{"data" => value, "left" => Process.get(:nil), "right" => Process.get(:nil), "height" => 1}
      Process.put(:nodes, (Process.get(:nodes) ++ [node_]))
      throw {:return, _len(Process.get(:nodes)) - 1}
    catch
      {:return, val} -> val
    end
  end
  def get_height(i) do
    try do
      throw {:return, ((if i == Process.get(:nil), do: 0, else: Enum.at(Process.get(:nodes), i)["height"]))}
    catch
      {:return, val} -> val
    end
  end
  def my_max(a, b) do
    try do
      throw {:return, ((if a > b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def update_height(i) do
    try do
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "height", my_max(get_height(Enum.at(Process.get(:nodes), i)["left"]), get_height(Enum.at(Process.get(:nodes), i)["right"])) + 1)))
    catch
      {:return, val} -> val
    end
  end
  def right_rotation(i) do
    try do
      left = Enum.at(Process.get(:nodes), i)["left"]
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", Enum.at(Process.get(:nodes), left)["right"])))
      Process.put(:nodes, List.replace_at(Process.get(:nodes), left, Map.put(Enum.at(Process.get(:nodes), left), "right", i)))
      update_height(i)
      update_height(left)
      throw {:return, left}
    catch
      {:return, val} -> val
    end
  end
  def left_rotation(i) do
    try do
      right = Enum.at(Process.get(:nodes), i)["right"]
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", Enum.at(Process.get(:nodes), right)["left"])))
      Process.put(:nodes, List.replace_at(Process.get(:nodes), right, Map.put(Enum.at(Process.get(:nodes), right), "left", i)))
      update_height(i)
      update_height(right)
      throw {:return, right}
    catch
      {:return, val} -> val
    end
  end
  def lr_rotation(i) do
    try do
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", left_rotation(Enum.at(Process.get(:nodes), i)["left"]))))
      throw {:return, right_rotation(i)}
    catch
      {:return, val} -> val
    end
  end
  def rl_rotation(i) do
    try do
      Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", right_rotation(Enum.at(Process.get(:nodes), i)["right"]))))
      throw {:return, left_rotation(i)}
    catch
      {:return, val} -> val
    end
  end
  def insert_node(i, value) do
    try do
      if i == Process.get(:nil) do
        throw {:return, new_node(value)}
      end
      {i, nodes} = if value < Enum.at(Process.get(:nodes), i)["data"] do
        Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", insert_node(Enum.at(Process.get(:nodes), i)["left"], value))))
        {i} = if get_height(Enum.at(Process.get(:nodes), i)["left"]) - get_height(Enum.at(Process.get(:nodes), i)["right"]) == 2 do
          i = (if value < Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i)["left"])["data"], do: right_rotation(i), else: lr_rotation(i))
          {i}
        else
          {i}
        end
        {i, nodes}
      else
        Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", insert_node(Enum.at(Process.get(:nodes), i)["right"], value))))
        {i} = if get_height(Enum.at(Process.get(:nodes), i)["right"]) - get_height(Enum.at(Process.get(:nodes), i)["left"]) == 2 do
          i = (if value < Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i)["right"])["data"], do: rl_rotation(i), else: left_rotation(i))
          {i}
        else
          {i}
        end
        {i, nodes}
      end
      update_height(i)
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def get_left_most(i) do
    try do
      cur = i
      while_fun = fn while_fun, cur ->
        if Enum.at(Process.get(:nodes), cur)["left"] != Process.get(:nil) do
          cur = Enum.at(Process.get(:nodes), cur)["left"]
          while_fun.(while_fun, cur)
        else
          cur
        end
      end
      cur = try do
          while_fun.(while_fun, cur)
        catch
          {:break, {cur}} -> cur
        end

      throw {:return, Enum.at(Process.get(:nodes), cur)["data"]}
    catch
      {:return, val} -> val
    end
  end
  def del_node(i, value) do
    try do
      if i == Process.get(:nil) do
        throw {:return, Process.get(:nil)}
      end
      {i, nodes} = if value < Enum.at(Process.get(:nodes), i)["data"] do
        Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "left", del_node(Enum.at(Process.get(:nodes), i)["left"], value))))
        {i, nodes}
      else
        {i, nodes} = if value > Enum.at(Process.get(:nodes), i)["data"] do
          Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", del_node(Enum.at(Process.get(:nodes), i)["right"], value))))
          {i, nodes}
        else
          {i, nodes} = if Enum.at(Process.get(:nodes), i)["left"] != Process.get(:nil) && Enum.at(Process.get(:nodes), i)["right"] != Process.get(:nil) do
            temp = get_left_most(Enum.at(Process.get(:nodes), i)["right"])
            Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "data", temp)))
            Process.put(:nodes, List.replace_at(Process.get(:nodes), i, Map.put(Enum.at(Process.get(:nodes), i), "right", del_node(Enum.at(Process.get(:nodes), i)["right"], temp))))
            {i, nodes}
          else
            {i} = if Enum.at(Process.get(:nodes), i)["left"] != Process.get(:nil) do
              i = Enum.at(Process.get(:nodes), i)["left"]
              {i}
            else
              i = Enum.at(Process.get(:nodes), i)["right"]
              {i}
            end
            {i, nodes}
          end
          {i, nodes}
        end
        {i, nodes}
      end
      if i == Process.get(:nil) do
        throw {:return, Process.get(:nil)}
      end
      lh = get_height(Enum.at(Process.get(:nodes), i)["left"])
      rh = get_height(Enum.at(Process.get(:nodes), i)["right"])
      {i} = if rh - lh == 2 do
        i = (if get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i)["right"])["right"]) > get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i)["right"])["left"]), do: left_rotation(i), else: rl_rotation(i))
        {i}
      else
        {i} = if lh - rh == 2 do
          i = (if get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i)["left"])["left"]) > get_height(Enum.at(Process.get(:nodes), Enum.at(Process.get(:nodes), i)["left"])["right"]), do: right_rotation(i), else: lr_rotation(i))
          {i}
        else
          {i}
        end
        {i}
      end
      update_height(i)
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def inorder(i) do
    try do
      if i == Process.get(:nil) do
        throw {:return, ""}
      end
      left = inorder(Enum.at(Process.get(:nodes), i)["left"])
      right = inorder(Enum.at(Process.get(:nodes), i)["right"])
      res = Kernel.to_string(Enum.at(Process.get(:nodes), i)["data"])
      {res} = if left != "" do
        res = ((left <> " ") <> res)
        {res}
      else
        {res}
      end
      {res} = if right != "" do
        res = ((res <> " ") <> right)
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      Process.put(:nodes, [])
      root = Process.get(:nil)
      root = insert_node(root, 4)
      root = insert_node(root, 2)
      root = insert_node(root, 3)
      IO.puts(Kernel.inspect(inorder(root)))
      IO.puts(Kernel.inspect(get_height(root)))
      root = del_node(root, 3)
      IO.puts(Kernel.inspect(inorder(root)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:nodes, [])
end
Process.put(:nil, 0 - 1)
Main.main()
