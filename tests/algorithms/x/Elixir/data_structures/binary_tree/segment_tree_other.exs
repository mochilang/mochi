# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def combine(a, b, op) do
    try do
      if op == 0 do
        throw {:return, a + b}
      end
      if op == 1 do
        if a > b do
          throw {:return, a}
        end
        throw {:return, b}
      end
      if a < b do
        throw {:return, a}
      end
      throw {:return, b}
    catch
      {:return, val} -> val
    end
  end
  def build_tree(nodes, arr, start, end_, op) do
    try do
      if start == end_ do
        node_ = %{start: start, end: end_, val: Enum.at(arr, start), mid: start, left: -1, right: -1}
        new_nodes = (nodes ++ [node_])
        throw {:return, %{nodes: new_nodes, idx: _len(new_nodes) - 1}}
      end
      mid = div((start + end_), 2)
      left_res = build_tree(nodes, arr, start, mid, op)
      right_res = build_tree(left_res.nodes, arr, mid + 1, end_, op)
      left_node = Enum.at(right_res.nodes, left_res.idx)
      right_node = Enum.at(right_res.nodes, right_res.idx)
      val = combine(left_node.val, right_node.val, op)
      parent = %{start: start, end: end_, val: val, mid: mid, left: left_res.idx, right: right_res.idx}
      new_nodes = (right_res.nodes ++ [parent])
      throw {:return, %{nodes: new_nodes, idx: _len(new_nodes) - 1}}
    catch
      {:return, val} -> val
    end
  end
  def new_segment_tree(collection, op) do
    try do
      throw {:return, %{arr: collection, op: op}}
    catch
      {:return, val} -> val
    end
  end
  def update(tree, i, val) do
    try do
      new_arr = []
      idx = 0
      while_fun = fn while_fun, idx, new_arr ->
        if idx < _len(Map.get(tree, :arr, [])) do
          new_arr = (if idx == i, do: (new_arr ++ [val]), else: (new_arr ++ [Enum.at(tree.arr, idx)]))
          idx = idx + 1
          while_fun.(while_fun, idx, new_arr)
        else
          {idx, new_arr}
        end
      end
      {idx, new_arr} = try do
          while_fun.(while_fun, idx, new_arr)
        catch
          {:break, {idx, new_arr}} -> {idx, new_arr}
        end

      throw {:return, %{arr: new_arr, op: tree.op}}
    catch
      {:return, val} -> val
    end
  end
  def query_range(tree, i, j) do
    try do
      result = Enum.at(tree.arr, i)
      idx = i + 1
      while_fun_2 = fn while_fun_2, idx, result ->
        if idx <= j do
          result = combine(result, Enum.at(tree.arr, idx), tree.op)
          idx = idx + 1
          while_fun_2.(while_fun_2, idx, result)
        else
          {idx, result}
        end
      end
      {idx, result} = try do
          while_fun_2.(while_fun_2, idx, result)
        catch
          {:break, {idx, result}} -> {idx, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def traverse(tree) do
    try do
      if _len(Map.get(tree, :arr, [])) == 0 do
        throw {:return, []}
      end
      res = build_tree([], tree.arr, 0, _len(Map.get(tree, :arr, [])) - 1, tree.op)
      throw {:return, res.nodes}
    catch
      {:return, val} -> val
    end
  end
  def node_to_string(node_) do
    try do
      throw {:return, (((((("SegmentTreeNode(start=" <> Kernel.to_string(node_.start)) <> ", end=") <> Kernel.to_string(node_.end)) <> ", val=") <> Kernel.to_string(node_.val)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def print_traverse(tree) do
    try do
      nodes = traverse(tree)
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(nodes) do
          IO.puts(Kernel.inspect(node_to_string(Enum.at(nodes, i))))
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      IO.puts("")
    catch
      {:return, val} -> val
    end
  end
  Process.put(:arr, [2, 1, 5, 3, 4])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Enum.each([0, 1, 2], fn op ->
      IO.puts("**************************************************")
      tree = new_segment_tree(Process.get(:arr), op)
      print_traverse(tree)
      tree = update(tree, 1, 5)
      print_traverse(tree)
      IO.puts(Kernel.inspect(query_range(tree, 3, 4)))
      IO.puts(Kernel.inspect(query_range(tree, 2, 2)))
      IO.puts(Kernel.inspect(query_range(tree, 1, 3)))
      IO.puts("")
    end)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
