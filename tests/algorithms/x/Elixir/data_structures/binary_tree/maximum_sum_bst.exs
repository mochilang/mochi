# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def min_int(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def max_int(a, b) do
    try do
      throw {:return, ((if a > b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def solver(nodes, idx) do
    try do
      if idx == 0 - 1 do
        throw {:return, %{is_bst: true, min_val: 2147483647, max_val: -2147483648, total: 0, best: 0}}
      end
      node_ = Enum.at(nodes, idx)
      left_info = solver(nodes, node_.left)
      right_info = solver(nodes, node_.right)
      current_best = max_int(left_info.best, right_info.best)
      {current_best} = if left_info.is_bst && right_info.is_bst && left_info.max_val < node_.val && node_.val < right_info.min_val do
        sum_val = left_info.total + right_info.total + node_.val
        current_best = max_int(current_best, sum_val)
        throw {:return, %{is_bst: true, min_val: min_int(left_info.min_val, node_.val), max_val: max_int(right_info.max_val, node_.val), total: sum_val, best: current_best}}
        {current_best}
      else
        {current_best}
      end
      throw {:return, %{is_bst: false, min_val: 0, max_val: 0, total: 0, best: current_best}}
    catch
      {:return, val} -> val
    end
  end
  def max_sum_bst(nodes, root) do
    try do
      info = solver(nodes, root)
      throw {:return, info.best}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      t1_nodes = [%{val: 4, left: 1, right: 0 - 1}, %{val: 3, left: 2, right: 3}, %{val: 1, left: 0 - 1, right: 0 - 1}, %{val: 2, left: 0 - 1, right: 0 - 1}]
      IO.puts(Kernel.inspect(max_sum_bst(t1_nodes, 0)))
      t2_nodes = [%{val: -4, left: 1, right: 2}, %{val: -2, left: 0 - 1, right: 0 - 1}, %{val: -5, left: 0 - 1, right: 0 - 1}]
      IO.puts(Kernel.inspect(max_sum_bst(t2_nodes, 0)))
      t3_nodes = [%{val: 1, left: 1, right: 2}, %{val: 4, left: 3, right: 4}, %{val: 3, left: 5, right: 6}, %{val: 2, left: 0 - 1, right: 0 - 1}, %{val: 4, left: 0 - 1, right: 0 - 1}, %{val: 2, left: 0 - 1, right: 0 - 1}, %{val: 5, left: 7, right: 8}, %{val: 4, left: 0 - 1, right: 0 - 1}, %{val: 6, left: 0 - 1, right: 0 - 1}]
      IO.puts(Kernel.inspect(max_sum_bst(t3_nodes, 0)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
