# Code generated by Mochi transpiler 2025-08-07 08:34 +0700
defmodule Main do
  def min_int(a, b) do
    try do
      throw {:return, ((if a < b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def max_int(a, b) do
    try do
      throw {:return, ((if a > b, do: a, else: b))}
    catch
      {:return, val} -> val
    end
  end
  def solver(nodes, idx) do
    try do
      if idx == 0 - 1 do
        throw {:return, %{is_bst: true, min_val: 2147483647, max_val: -2147483648, total: 0, best: 0}}
      end
      node_ = Enum.at(nodes, idx)
      left_info = solver(nodes, node_.left)
      right_info = solver(nodes, node_.right)
      current_best = max_int(left_info.best, right_info.best)
      {current_best} = if left_info.is_bst && right_info.is_bst && left_info.max_val < node_.val && node_.val < right_info.min_val do
        sum_val = left_info.total + right_info.total + node_.val
        current_best = max_int(current_best, sum_val)
        throw {:return, %{is_bst: true, min_val: min_int(left_info.min_val, node_.val), max_val: max_int(right_info.max_val, node_.val), total: sum_val, best: current_best}}
        {current_best}
      else
        {current_best}
      end
      throw {:return, %{is_bst: false, min_val: 0, max_val: 0, total: 0, best: current_best}}
    catch
      {:return, val} -> val
    end
  end
  def max_sum_bst(nodes, root) do
    try do
      info = solver(nodes, root)
      throw {:return, info.best}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      t1_nodes = [%{val: 4, left: 1, right: 0 - 1}, %{val: 3, left: 2, right: 3}, %{val: 1, left: 0 - 1, right: 0 - 1}, %{val: 2, left: 0 - 1, right: 0 - 1}]
      IO.puts(Kernel.inspect(max_sum_bst(t1_nodes, 0)))
      t2_nodes = [%{val: -4, left: 1, right: 2}, %{val: -2, left: 0 - 1, right: 0 - 1}, %{val: -5, left: 0 - 1, right: 0 - 1}]
      IO.puts(Kernel.inspect(max_sum_bst(t2_nodes, 0)))
      t3_nodes = [%{val: 1, left: 1, right: 2}, %{val: 4, left: 3, right: 4}, %{val: 3, left: 5, right: 6}, %{val: 2, left: 0 - 1, right: 0 - 1}, %{val: 4, left: 0 - 1, right: 0 - 1}, %{val: 2, left: 0 - 1, right: 0 - 1}, %{val: 5, left: 7, right: 8}, %{val: 4, left: 0 - 1, right: 0 - 1}, %{val: 6, left: 0 - 1, right: 0 - 1}]
      IO.puts(Kernel.inspect(max_sum_bst(t3_nodes, 0)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
