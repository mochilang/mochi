# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def init_int_array(n) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < 4 * n + 5 do
          arr = (arr ++ [0])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def init_bool_array(n) do
    try do
      arr = []
      i = 0
      while_fun_2 = fn while_fun_2, arr, i ->
        if i < 4 * n + 5 do
          arr = (arr ++ [false])
          i = i + 1
          while_fun_2.(while_fun_2, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_2.(while_fun_2, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def left(idx) do
    try do
      throw {:return, idx * 2}
    catch
      {:return, val} -> val
    end
  end
  def right(idx) do
    try do
      throw {:return, idx * 2 + 1}
    catch
      {:return, val} -> val
    end
  end
  def build(segment_tree, idx, l, r, a) do
    try do
      if l == r do
        segment_tree = List.replace_at(segment_tree, idx, Enum.at(a, l - 1))
      else
        mid = div((l + r), 2)
        build(segment_tree, left(idx), l, mid, a)
        build(segment_tree, right(idx), mid + 1, r, a)
        lv = Enum.at(segment_tree, left(idx))
        rv = Enum.at(segment_tree, right(idx))
        segment_tree = List.replace_at(segment_tree, idx, ((if lv > rv, do: lv, else: rv)))
      end
    catch
      {:return, val} -> val
    end
  end
  def update(segment_tree, lazy, flag, idx, l, r, a, b, val) do
    try do
      if Enum.at(flag, idx) do
        segment_tree = List.replace_at(segment_tree, idx, Enum.at(lazy, idx))
        flag = List.replace_at(flag, idx, false)
        if l != r do
          lazy = List.replace_at(lazy, left(idx), Enum.at(lazy, idx))
          lazy = List.replace_at(lazy, right(idx), Enum.at(lazy, idx))
          flag = List.replace_at(flag, left(idx), true)
          flag = List.replace_at(flag, right(idx), true)
        end
      end
      if r < a || l > b do
        throw {:return, nil}
      end
      if l >= a && r <= b do
        segment_tree = List.replace_at(segment_tree, idx, val)
        if l != r do
          lazy = List.replace_at(lazy, left(idx), val)
          lazy = List.replace_at(lazy, right(idx), val)
          flag = List.replace_at(flag, left(idx), true)
          flag = List.replace_at(flag, right(idx), true)
        end
        throw {:return, nil}
      end
      mid = div((l + r), 2)
      update(segment_tree, lazy, flag, left(idx), l, mid, a, b, val)
      update(segment_tree, lazy, flag, right(idx), mid + 1, r, a, b, val)
      lv = Enum.at(segment_tree, left(idx))
      rv = Enum.at(segment_tree, right(idx))
      segment_tree = List.replace_at(segment_tree, idx, ((if lv > rv, do: lv, else: rv)))
    catch
      {:return, val} -> val
    end
  end
  def query(segment_tree, lazy, flag, idx, l, r, a, b) do
    try do
      if Enum.at(flag, idx) do
        segment_tree = List.replace_at(segment_tree, idx, Enum.at(lazy, idx))
        flag = List.replace_at(flag, idx, false)
        if l != r do
          lazy = List.replace_at(lazy, left(idx), Enum.at(lazy, idx))
          lazy = List.replace_at(lazy, right(idx), Enum.at(lazy, idx))
          flag = List.replace_at(flag, left(idx), true)
          flag = List.replace_at(flag, right(idx), true)
        end
      end
      if r < a || l > b do
        throw {:return, Process.get(:neg_inf)}
      end
      if l >= a && r <= b do
        throw {:return, Enum.at(segment_tree, idx)}
      end
      mid = div((l + r), 2)
      q1 = query(segment_tree, lazy, flag, left(idx), l, mid, a, b)
      q2 = query(segment_tree, lazy, flag, right(idx), mid + 1, r, a, b)
      if q1 > q2 do
        throw {:return, q1}
      else
        throw {:return, q2}
      end
    catch
      {:return, val} -> val
    end
  end
  def segtree_to_string(segment_tree, lazy, flag, n) do
    try do
      res = "["
      i = 1
      while_fun_3 = fn while_fun_3, i, res ->
        if i <= n do
          v = query(segment_tree, lazy, flag, 1, 1, n, i, i)
          res = (res <> Kernel.to_string(v))
          {res} = if i < n do
            res = (res <> ", ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res <> "]")
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:n, 15)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:neg_inf, -1000000000)
    Process.put(:a, [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8])
    Process.put(:segment_tree, init_int_array(Process.get(:n)))
    Process.put(:lazy, init_int_array(Process.get(:n)))
    Process.put(:flag, init_bool_array(Process.get(:n)))
    build(Process.get(:segment_tree), 1, 1, Process.get(:n), Process.get(:a))
    IO.puts(Kernel.inspect(query(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), 1, 1, Process.get(:n), 4, 6)))
    IO.puts(Kernel.inspect(query(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), 1, 1, Process.get(:n), 7, 11)))
    IO.puts(Kernel.inspect(query(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), 1, 1, Process.get(:n), 7, 12)))
    update(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), 1, 1, Process.get(:n), 1, 3, 111)
    IO.puts(Kernel.inspect(query(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), 1, 1, Process.get(:n), 1, 15)))
    update(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), 1, 1, Process.get(:n), 7, 8, 235)
    IO.puts(Kernel.inspect(segtree_to_string(Process.get(:segment_tree), Process.get(:lazy), Process.get(:flag), Process.get(:n))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
