# Code generated by Mochi transpiler 2025-08-07 09:56 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def build(arr, combine) do
    try do
      n = _len(arr)
      st = []
      i = 0
      while_fun = fn while_fun, i, st ->
        if i < 2 * n do
          st = (st ++ [0])
          i = i + 1
          while_fun.(while_fun, i, st)
        else
          {i, st}
        end
      end
      {i, st} = try do
          while_fun.(while_fun, i, st)
        catch
          {:break, {i, st}} -> {i, st}
        end

      i = 0
      while_fun_2 = fn while_fun_2, i, st ->
        if i < n do
          st = List.replace_at(st, n + i, Enum.at(arr, i))
          i = i + 1
          while_fun_2.(while_fun_2, i, st)
        else
          {i, st}
        end
      end
      {i, st} = try do
          while_fun_2.(while_fun_2, i, st)
        catch
          {:break, {i, st}} -> {i, st}
        end

      i = n - 1
      while_fun_3 = fn while_fun_3, i, st ->
        if i > 0 do
          st = List.replace_at(st, i, combine.(Enum.at(st, i * 2), Enum.at(st, i * 2 + 1)))
          i = i - 1
          while_fun_3.(while_fun_3, i, st)
        else
          {i, st}
        end
      end
      {i, st} = try do
          while_fun_3.(while_fun_3, i, st)
        catch
          {:break, {i, st}} -> {i, st}
        end

      throw {:return, st}
    catch
      {:return, val} -> val
    end
  end
  def update(st, n, combine, p, v) do
    try do
      idx = p + n
      st = List.replace_at(st, idx, v)
      while_fun_4 = fn while_fun_4, idx, st ->
        if idx > 1 do
          idx = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(idx, 2)))
          st = List.replace_at(st, idx, combine.(Enum.at(st, idx * 2), Enum.at(st, idx * 2 + 1)))
          while_fun_4.(while_fun_4, idx, st)
        else
          {idx, st}
        end
      end
      {idx, st} = try do
          while_fun_4.(while_fun_4, idx, st)
        catch
          {:break, {idx, st}} -> {idx, st}
        end

    catch
      {:return, val} -> val
    end
  end
  def query(st, n, combine, left, right) do
    try do
      l = left + n
      r = right + n
      res = 0
      has = false
      while_fun_5 = fn while_fun_5, has, l, r, res ->
        if l <= r do
          {has, l, res} = if rem(l, 2) == 1 do
            {has, res} = if !has do
              res = Enum.at(st, l)
              has = true
              {has, res}
            else
              res = combine.(res, Enum.at(st, l))
              {has, res}
            end
            l = l + 1
            {has, l, res}
          else
            {has, l, res}
          end
          {has, r, res} = if rem(r, 2) == 0 do
            {has, res} = if !has do
              res = Enum.at(st, r)
              has = true
              {has, res}
            else
              res = combine.(res, Enum.at(st, r))
              {has, res}
            end
            r = r - 1
            {has, r, res}
          else
            {has, r, res}
          end
          l = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(l, 2)))
          r = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(r, 2)))
          while_fun_5.(while_fun_5, has, l, r, res)
        else
          {has, l, r, res}
        end
      end
      {has, l, r, res} = try do
          while_fun_5.(while_fun_5, has, l, r, res)
        catch
          {:break, {has, l, r, res}} -> {has, l, r, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def add(a, b) do
    try do
      throw {:return, a + b}
    catch
      {:return, val} -> val
    end
  end
  def min_int(a, b) do
    try do
      if a < b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def max_int(a, b) do
    try do
      if a > b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  Process.put(:arr1, [1, 2, 3])
  Process.put(:arr2, [3, 1, 2])
  Process.put(:arr3, [2, 3, 1])
  def main() do
    Process.put(:st1, build(Process.get(:arr1), &add/2))
    IO.puts(Kernel.inspect(query(Process.get(:st1), _len(Process.get(:arr1)), &add/2, 0, 2)))
    Process.put(:st2, build(Process.get(:arr2), &min_int/2))
    IO.puts(Kernel.inspect(query(Process.get(:st2), _len(Process.get(:arr2)), &min_int/2, 0, 2)))
    Process.put(:st3, build(Process.get(:arr3), &max_int/2))
    IO.puts(Kernel.inspect(query(Process.get(:st3), _len(Process.get(:arr3)), &max_int/2, 0, 2)))
    Process.put(:arr4, [1, 5, 7, -1, 6])
    Process.put(:n4, _len(Process.get(:arr4)))
    Process.put(:st4, build(Process.get(:arr4), &add/2))
    update(Process.get(:st4), Process.get(:n4), &add/2, 1, -1)
    update(Process.get(:st4), Process.get(:n4), &add/2, 2, 3)
    IO.puts(Kernel.inspect(query(Process.get(:st4), Process.get(:n4), &add/2, 1, 2)))
    IO.puts(Kernel.inspect(query(Process.get(:st4), Process.get(:n4), &add/2, 1, 1)))
    update(Process.get(:st4), Process.get(:n4), &add/2, 4, 1)
    IO.puts(Kernel.inspect(query(Process.get(:st4), Process.get(:n4), &add/2, 3, 4)))
  end
end
Main.main()
