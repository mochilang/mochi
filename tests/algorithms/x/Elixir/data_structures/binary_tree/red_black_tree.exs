# Code generated by Mochi transpiler 2025-08-07 08:34 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_tree() do
    try do
      throw {:return, %{nodes: [], root: -1}}
    catch
      {:return, val} -> val
    end
  end
  def rotate_left(t, x) do
    try do
      nodes = t.nodes
      y = Enum.at(Enum.at(nodes, x), Process.get(:right))
      yLeft = Enum.at(Enum.at(nodes, y), Process.get(:left))
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:right), yLeft))
      {nodes} = if yLeft != Process.get(:neg_one) do
        nodes = List.replace_at(nodes, yLeft, List.replace_at(Enum.at(nodes, yLeft), Process.get(:parent), x))
        {nodes}
      else
        {nodes}
      end
      xParent = Enum.at(Enum.at(nodes, x), Process.get(:parent))
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:parent), xParent))
      {nodes, t} = if xParent == Process.get(:neg_one) do
        t = Map.put(t, :root, y)
        {nodes, t}
      else
        {nodes} = if x == Enum.at(Enum.at(nodes, xParent), Process.get(:left)) do
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:left), y))
          {nodes}
        else
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:right), y))
          {nodes}
        end
        {nodes, t}
      end
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:left), x))
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:parent), y))
      t = Map.put(t, :nodes, nodes)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def rotate_right(t, x) do
    try do
      nodes = t.nodes
      y = Enum.at(Enum.at(nodes, x), Process.get(:left))
      yRight = Enum.at(Enum.at(nodes, y), Process.get(:right))
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:left), yRight))
      {nodes} = if yRight != Process.get(:neg_one) do
        nodes = List.replace_at(nodes, yRight, List.replace_at(Enum.at(nodes, yRight), Process.get(:parent), x))
        {nodes}
      else
        {nodes}
      end
      xParent = Enum.at(Enum.at(nodes, x), Process.get(:parent))
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:parent), xParent))
      {nodes, t} = if xParent == Process.get(:neg_one) do
        t = Map.put(t, :root, y)
        {nodes, t}
      else
        {nodes} = if x == Enum.at(Enum.at(nodes, xParent), Process.get(:right)) do
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:right), y))
          {nodes}
        else
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:left), y))
          {nodes}
        end
        {nodes, t}
      end
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:right), x))
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:parent), y))
      t = Map.put(t, :nodes, nodes)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def insert_fix(t, z) do
    try do
      nodes = t.nodes
      while_fun = fn while_fun, nodes, t, z ->
        if z != t.root && Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:color)) == 1 do
          {nodes, t, z} = if Enum.at(Enum.at(nodes, z), Process.get(:parent)) == Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))), Process.get(:left)) do
            y = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))), Process.get(:right))
            {nodes, t, z} = if y != Process.get(:neg_one) && Enum.at(Enum.at(nodes, y), Process.get(:color)) == 1 do
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent)), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:color), 0))
              nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              z = gp
              {nodes, t, z}
            else
              {nodes, t, z} = if z == Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:right)) do
                z = Enum.at(Enum.at(nodes, z), Process.get(:parent))
                t = Map.put(t, :nodes, nodes)
                t = rotate_left(t, z)
                nodes = t.nodes
                {nodes, t, z}
              else
                {nodes, t, z}
              end
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent)), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              t = Map.put(t, :nodes, nodes)
              t = rotate_right(t, gp)
              nodes = t.nodes
              {nodes, t, z}
            end
            {nodes, t, z}
          else
            y = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))), Process.get(:left))
            {nodes, t, z} = if y != Process.get(:neg_one) && Enum.at(Enum.at(nodes, y), Process.get(:color)) == 1 do
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent)), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:color), 0))
              nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              z = gp
              {nodes, t, z}
            else
              {nodes, t, z} = if z == Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:left)) do
                z = Enum.at(Enum.at(nodes, z), Process.get(:parent))
                t = Map.put(t, :nodes, nodes)
                t = rotate_right(t, z)
                nodes = t.nodes
                {nodes, t, z}
              else
                {nodes, t, z}
              end
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent)), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z), Process.get(:parent))), Process.get(:parent))
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              t = Map.put(t, :nodes, nodes)
              t = rotate_left(t, gp)
              nodes = t.nodes
              {nodes, t, z}
            end
            {nodes, t, z}
          end
          while_fun.(while_fun, nodes, t, z)
        else
          {nodes, t, z}
        end
      end
      {nodes, t, z} = try do
          while_fun.(while_fun, nodes, t, z)
        catch
          {:break, {nodes, t, z}} -> {nodes, t, z}
        end

      nodes = t.nodes
      nodes = List.replace_at(nodes, t.root, List.replace_at(Enum.at(nodes, t.root), Process.get(:color), 0))
      t = Map.put(t, :nodes, nodes)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def tree_insert(t, v) do
    try do
      nodes = t.nodes
      node_ = [v, 1, -1, -1, -1]
      nodes = (nodes ++ [node_])
      idx = _len(nodes) - 1
      y = Process.get(:neg_one)
      x = t.root
      while_fun_2 = fn while_fun_2, x, y ->
        if x != Process.get(:neg_one) do
          y = x
          x = (if v < Enum.at(Enum.at(nodes, x), Process.get(:label)), do: Enum.at(Enum.at(nodes, x), Process.get(:left)), else: Enum.at(Enum.at(nodes, x), Process.get(:right)))
          while_fun_2.(while_fun_2, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun_2.(while_fun_2, x, y)
        catch
          {:break, {x, y}} -> {x, y}
        end

      nodes = List.replace_at(nodes, idx, List.replace_at(Enum.at(nodes, idx), Process.get(:parent), y))
      {nodes, t} = if y == Process.get(:neg_one) do
        t = Map.put(t, :root, idx)
        {nodes, t}
      else
        {nodes} = if v < Enum.at(Enum.at(nodes, y), Process.get(:label)) do
          nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:left), idx))
          {nodes}
        else
          nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:right), idx))
          {nodes}
        end
        {nodes, t}
      end
      t = Map.put(t, :nodes, nodes)
      t = insert_fix(t, idx)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def inorder(t, x, acc) do
    try do
      if x == Process.get(:neg_one) do
        throw {:return, acc}
      end
      acc = inorder(t, Enum.at(Enum.at(t.nodes, x), Process.get(:left)), acc)
      acc = (acc ++ [Enum.at(Enum.at(t.nodes, x), Process.get(:label))])
      acc = inorder(t, Enum.at(Enum.at(t.nodes, x), Process.get(:right)), acc)
      throw {:return, acc}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      t = make_tree()
      values = [10, 20, 30, 15, 25, 5, 1]
      i = 0
      while_fun_3 = fn while_fun_3, i, t ->
        if i < _len(values) do
          t = tree_insert(t, Enum.at(values, i))
          i = i + 1
          while_fun_3.(while_fun_3, i, t)
        else
          {i, t}
        end
      end
      {i, t} = try do
          while_fun_3.(while_fun_3, i, t)
        catch
          {:break, {i, t}} -> {i, t}
        end

      res = []
      res = inorder(t, t.root, res)
      IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [res])), ",", " "))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:label, 0)
  Process.put(:color, 1)
  Process.put(:parent, 2)
  Process.put(:left, 3)
  Process.put(:right, 4)
end
Process.put(:neg_one, -1)
Main.main()
