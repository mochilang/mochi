# Code generated by Mochi transpiler 2025-08-24 15:35 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_tree() do
    try do
      throw {:return, %{nodes: [], root: -1}}
    catch
      {:return, val} -> val
    end
  end
  def rotate_left(t, x) do
    try do
      nodes = t.nodes
      y = Enum.at(Enum.at(nodes, x, []), Process.get(:right), 0)
      yLeft = Enum.at(Enum.at(nodes, y, []), Process.get(:left), 0)
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:right), yLeft))
      nodes = if yLeft != Process.get(:neg_one) do
        nodes = List.replace_at(nodes, yLeft, List.replace_at(Enum.at(nodes, yLeft), Process.get(:parent), x))
        nodes
      else
        nodes
      end
      xParent = Enum.at(Enum.at(nodes, x, []), Process.get(:parent), 0)
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:parent), xParent))
      {nodes, t} = if xParent == Process.get(:neg_one) do
        t = Map.put(t, :root, y)
        {nodes, t}
      else
        nodes = if x == Enum.at(Enum.at(nodes, xParent, []), Process.get(:left), 0) do
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:left), y))
          nodes
        else
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:right), y))
          nodes
        end
        {nodes, t}
      end
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:left), x))
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:parent), y))
      t = Map.put(t, :nodes, nodes)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def rotate_right(t, x) do
    try do
      nodes = t.nodes
      y = Enum.at(Enum.at(nodes, x, []), Process.get(:left), 0)
      yRight = Enum.at(Enum.at(nodes, y, []), Process.get(:right), 0)
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:left), yRight))
      nodes = if yRight != Process.get(:neg_one) do
        nodes = List.replace_at(nodes, yRight, List.replace_at(Enum.at(nodes, yRight), Process.get(:parent), x))
        nodes
      else
        nodes
      end
      xParent = Enum.at(Enum.at(nodes, x, []), Process.get(:parent), 0)
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:parent), xParent))
      {nodes, t} = if xParent == Process.get(:neg_one) do
        t = Map.put(t, :root, y)
        {nodes, t}
      else
        nodes = if x == Enum.at(Enum.at(nodes, xParent, []), Process.get(:right), 0) do
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:right), y))
          nodes
        else
          nodes = List.replace_at(nodes, xParent, List.replace_at(Enum.at(nodes, xParent), Process.get(:left), y))
          nodes
        end
        {nodes, t}
      end
      nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:right), x))
      nodes = List.replace_at(nodes, x, List.replace_at(Enum.at(nodes, x), Process.get(:parent), y))
      t = Map.put(t, :nodes, nodes)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def insert_fix(t, z) do
    try do
      nodes = t.nodes
      while_fun = fn while_fun, nodes, t, z ->
        if z != t.root && Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:color), 0) == 1 do
          {nodes, t, z} = if Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0) == Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0), []), Process.get(:left), 0) do
            y = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0), []), Process.get(:right), 0)
            {nodes, t, z} = if y != Process.get(:neg_one) && Enum.at(Enum.at(nodes, y, []), Process.get(:color), 0) == 1 do
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0)), Process.get(:color), 0))
              nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0)
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              z = gp
              {nodes, t, z}
            else
              {nodes, t, z} = if z == Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:right), 0) do
                z = Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0)
                t = Map.put(t, :nodes, nodes)
                t = rotate_left(t, z)
                nodes = t.nodes
                {nodes, t, z}
              else
                {nodes, t, z}
              end
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0)), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0)
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              t = Map.put(t, :nodes, nodes)
              t = rotate_right(t, gp)
              nodes = t.nodes
              {nodes, t, z}
            end
            {nodes, t, z}
          else
            y = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0), []), Process.get(:left), 0)
            {nodes, t, z} = if y != Process.get(:neg_one) && Enum.at(Enum.at(nodes, y, []), Process.get(:color), 0) == 1 do
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0)), Process.get(:color), 0))
              nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0)
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              z = gp
              {nodes, t, z}
            else
              {nodes, t, z} = if z == Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:left), 0) do
                z = Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0)
                t = Map.put(t, :nodes, nodes)
                t = rotate_right(t, z)
                nodes = t.nodes
                {nodes, t, z}
              else
                {nodes, t, z}
              end
              nodes = List.replace_at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), List.replace_at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0)), Process.get(:color), 0))
              gp = Enum.at(Enum.at(nodes, Enum.at(Enum.at(nodes, z, []), Process.get(:parent), 0), []), Process.get(:parent), 0)
              nodes = List.replace_at(nodes, gp, List.replace_at(Enum.at(nodes, gp), Process.get(:color), 1))
              t = Map.put(t, :nodes, nodes)
              t = rotate_left(t, gp)
              nodes = t.nodes
              {nodes, t, z}
            end
            {nodes, t, z}
          end
          while_fun.(while_fun, nodes, t, z)
        else
          {nodes, t, z}
        end
      end
      {nodes, t, z} = try do
          while_fun.(while_fun, nodes, t, z)
        catch
          {:break, {nodes, t, z}} -> {nodes, t, z}
        end

      nodes = t.nodes
      nodes = List.replace_at(nodes, t.root, List.replace_at(Enum.at(nodes, t.root), Process.get(:color), 0))
      t = Map.put(t, :nodes, nodes)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def tree_insert(t, v) do
    try do
      nodes = t.nodes
      node_ = [v, 1, -1, -1, -1]
      nodes = (nodes ++ [node_])
      idx = _len(nodes) - 1
      y = Process.get(:neg_one)
      x = t.root
      while_fun_2 = fn while_fun_2, x, y ->
        if x != Process.get(:neg_one) do
          y = x
          x = (if v < Enum.at(Enum.at(nodes, x, []), Process.get(:label), 0), do: Enum.at(Enum.at(nodes, x, []), Process.get(:left), 0), else: Enum.at(Enum.at(nodes, x, []), Process.get(:right), 0))
          while_fun_2.(while_fun_2, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun_2.(while_fun_2, x, y)
        catch
          {:break, {x, y}} -> {x, y}
        end

      nodes = List.replace_at(nodes, idx, List.replace_at(Enum.at(nodes, idx), Process.get(:parent), y))
      {nodes, t} = if y == Process.get(:neg_one) do
        t = Map.put(t, :root, idx)
        {nodes, t}
      else
        nodes = if v < Enum.at(Enum.at(nodes, y, []), Process.get(:label), 0) do
          nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:left), idx))
          nodes
        else
          nodes = List.replace_at(nodes, y, List.replace_at(Enum.at(nodes, y), Process.get(:right), idx))
          nodes
        end
        {nodes, t}
      end
      t = Map.put(t, :nodes, nodes)
      t = insert_fix(t, idx)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def inorder(t, x, acc) do
    try do
      if x == Process.get(:neg_one) do
        throw {:return, acc}
      end
      acc = inorder(t, Enum.at(Enum.at(t.nodes, x, 0), Process.get(:left), 0), acc)
      acc = (acc ++ [Enum.at(Enum.at(t.nodes, x, 0), Process.get(:label), 0)])
      acc = inorder(t, Enum.at(Enum.at(t.nodes, x, 0), Process.get(:right), 0), acc)
      throw {:return, acc}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      t = make_tree()
      values = [10, 20, 30, 15, 25, 5, 1]
      i = 0
      while_fun_3 = fn while_fun_3, i, t ->
        if i < _len(values) do
          t = tree_insert(t, Enum.at(values, i, []))
          i = i + 1
          while_fun_3.(while_fun_3, i, t)
        else
          {i, t}
        end
      end
      {_, t} = try do
          while_fun_3.(while_fun_3, i, t)
        catch
          {:break, {_, t}} -> {0, t}
        end

      res = []
      res = inorder(t, t.root, res)
      IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [res])), ",", " "))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:label, 0)
    Process.put(:color, 1)
    Process.put(:parent, 2)
    Process.put(:left, 3)
    Process.put(:right, 4)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:neg_one, -1)
Main.bench_main()
