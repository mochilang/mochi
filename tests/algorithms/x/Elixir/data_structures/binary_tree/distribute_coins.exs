# Code generated by Mochi transpiler 2025-08-07 08:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def count_nodes(nodes, idx) do
    try do
      if idx == 0 do
        throw {:return, 0}
      end
      node_ = Enum.at(nodes, idx)
      throw {:return, count_nodes(nodes, node_.left) + count_nodes(nodes, node_.right) + 1}
    catch
      {:return, val} -> val
    end
  end
  def count_coins(nodes, idx) do
    try do
      if idx == 0 do
        throw {:return, 0}
      end
      node_ = Enum.at(nodes, idx)
      throw {:return, count_coins(nodes, node_.left) + count_coins(nodes, node_.right) + node_.data}
    catch
      {:return, val} -> val
    end
  end
  def iabs(x) do
    try do
      throw {:return, ((if x < 0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def dfs(nodes, idx) do
    try do
      if idx == 0 do
        throw {:return, 0}
      end
      node_ = Enum.at(nodes, idx)
      left_excess = dfs(nodes, node_.left)
      right_excess = dfs(nodes, node_.right)
      abs_left = iabs(left_excess)
      abs_right = iabs(right_excess)
      Process.put(:total_moves, Process.get(:total_moves) + abs_left + abs_right)
      throw {:return, node_.data + left_excess + right_excess - 1}
    catch
      {:return, val} -> val
    end
  end
  def distribute_coins(nodes, root) do
    try do
      if root == 0 do
        throw {:return, 0}
      end
      if count_nodes(nodes, root) != count_coins(nodes, root) do
        raise("The nodes number should be same as the number of coins")
      end
      Process.put(:total_moves, 0)
      dfs(nodes, root)
      throw {:return, Process.get(:total_moves)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      example1 = [%{data: 0, left: 0, right: 0}, %{data: 3, left: 2, right: 3}, %{data: 0, left: 0, right: 0}, %{data: 0, left: 0, right: 0}]
      example2 = [%{data: 0, left: 0, right: 0}, %{data: 0, left: 2, right: 3}, %{data: 3, left: 0, right: 0}, %{data: 0, left: 0, right: 0}]
      example3 = [%{data: 0, left: 0, right: 0}, %{data: 0, left: 2, right: 3}, %{data: 0, left: 0, right: 0}, %{data: 3, left: 0, right: 0}]
      IO.puts(Kernel.inspect(distribute_coins(example1, 1)))
      IO.puts(Kernel.inspect(distribute_coins(example2, 1)))
      IO.puts(Kernel.inspect(distribute_coins(example3, 1)))
      IO.puts(Kernel.inspect(distribute_coins([%{data: 0, left: 0, right: 0}], 0)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:total_moves, 0)
  def bench_main() do
    Process.put(:total_moves, 0)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
