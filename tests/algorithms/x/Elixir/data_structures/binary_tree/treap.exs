# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def random() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 13 + 7), 100))
      throw {:return, (:erlang.float(Process.get(:seed))) / 100.0}
    catch
      {:return, val} -> val
    end
  end
  def new_node(value) do
    try do
      Process.put(:node_values, (Process.get(:node_values) ++ [value]))
      Process.put(:node_priors, (Process.get(:node_priors) ++ [random()]))
      Process.put(:node_lefts, (Process.get(:node_lefts) ++ [Process.get(:nil)]))
      Process.put(:node_rights, (Process.get(:node_rights) ++ [Process.get(:nil)]))
      throw {:return, _len(Process.get(:node_values)) - 1}
    catch
      {:return, val} -> val
    end
  end
  def split(root, value) do
    try do
      if root == Process.get(:nil) do
        throw {:return, %{left: Process.get(:nil), right: Process.get(:nil)}}
      end
      if value < Enum.at(Process.get(:node_values), root) do
        res = split(Enum.at(Process.get(:node_lefts), root), value)
        Process.put(:node_lefts, List.replace_at(Process.get(:node_lefts), root, res.right))
        throw {:return, %{left: res.left, right: root}}
      end
      res = split(Enum.at(Process.get(:node_rights), root), value)
      Process.put(:node_rights, List.replace_at(Process.get(:node_rights), root, res.left))
      throw {:return, %{left: root, right: res.right}}
    catch
      {:return, val} -> val
    end
  end
  def merge(left, right) do
    try do
      if left == Process.get(:nil) do
        throw {:return, right}
      end
      if right == Process.get(:nil) do
        throw {:return, left}
      end
      if Enum.at(Process.get(:node_priors), left) < Enum.at(Process.get(:node_priors), right) do
        Process.put(:node_rights, List.replace_at(Process.get(:node_rights), left, merge(Enum.at(Process.get(:node_rights), left), right)))
        throw {:return, left}
      end
      Process.put(:node_lefts, List.replace_at(Process.get(:node_lefts), right, merge(left, Enum.at(Process.get(:node_lefts), right))))
      throw {:return, right}
    catch
      {:return, val} -> val
    end
  end
  def insert(root, value) do
    try do
      node_ = new_node(value)
      res = split(root, value)
      throw {:return, merge(merge(res.left, node_), res.right)}
    catch
      {:return, val} -> val
    end
  end
  def erase(root, value) do
    try do
      res1 = split(root, value - 1)
      res2 = split(res1.right, value)
      throw {:return, merge(res1.left, res2.right)}
    catch
      {:return, val} -> val
    end
  end
  def inorder(i, acc) do
    try do
      if i == Process.get(:nil) do
        throw {:return, acc}
      end
      left_acc = inorder(Enum.at(Process.get(:node_lefts), i), acc)
      with_node = (left_acc ++ [Enum.at(Process.get(:node_values), i)])
      throw {:return, inorder(Enum.at(Process.get(:node_rights), i), with_node)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      root = Process.get(:nil)
      root = insert(root, 1)
      IO.puts(Kernel.inspect(inorder(root, [])))
      root = insert(root, 3)
      root = insert(root, 5)
      root = insert(root, 17)
      root = insert(root, 19)
      root = insert(root, 2)
      root = insert(root, 16)
      root = insert(root, 4)
      root = insert(root, 0)
      IO.puts(Kernel.inspect(inorder(root, [])))
      root = insert(root, 4)
      root = insert(root, 4)
      root = insert(root, 4)
      IO.puts(Kernel.inspect(inorder(root, [])))
      root = erase(root, 0)
      IO.puts(Kernel.inspect(inorder(root, [])))
      root = erase(root, 4)
      IO.puts(Kernel.inspect(inorder(root, [])))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:node_values, [])
  Process.put(:node_priors, [])
  Process.put(:node_lefts, [])
  Process.put(:node_rights, [])
  Process.put(:seed, 1)
  def bench_main() do
    Process.put(:node_values, [])
    Process.put(:node_priors, [])
    Process.put(:node_lefts, [])
    Process.put(:node_rights, [])
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:nil, 0 - 1)
Main.bench_main()
