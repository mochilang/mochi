# Code generated by Mochi transpiler 2025-08-24 16:59 +0700
defmodule Main do
  @data_dir nil
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def binary_tree_mirror_dict(tree, root) do
    try do
      if (root == 0) || (!(Map.has_key?(tree, root))) do
        throw {:return, tree}
      end
      children = tree[root]
      left = Enum.at(children, 0, [])
      right = Enum.at(children, 1, [])
      tree = Map.put(tree, root, [right, left])
      tree = binary_tree_mirror_dict(tree, left)
      tree = binary_tree_mirror_dict(tree, right)
    catch
      {:return, val} -> val
    end
  end
  def binary_tree_mirror(binary_tree, root) do
    try do
      if map_size(binary_tree) == 0 do
        raise("binary tree cannot be empty")
      end
      if !(Map.has_key?(binary_tree, root)) do
        raise((("root " <> Kernel.to_string(root)) <> " is not present in the binary_tree"))
      end
      tree_copy = %{}
      {tree_copy} = Enum.reduce(Map.keys(binary_tree), {tree_copy}, fn k, {tree_copy} ->
        tree_copy = Map.put(tree_copy, k, binary_tree[k])
        {tree_copy}
      end)
      tree_copy = binary_tree_mirror_dict(tree_copy, root)
      throw {:return, tree_copy}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      binary_tree = %{1 => [2, 3], 2 => [4, 5], 3 => [6, 7], 7 => [8, 9]}
      IO.puts(("Binary tree: " <> Kernel.inspect(binary_tree)))
      mirrored = binary_tree_mirror(binary_tree, 1)
      IO.puts(("Binary tree mirror: " <> Kernel.inspect(mirrored)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
