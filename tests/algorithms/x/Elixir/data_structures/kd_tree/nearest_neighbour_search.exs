# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def square_distance(a, b) do
    try do
      i = 0
      total = 0.0
      while_fun = fn while_fun, i, total ->
        if i < _len(a) do
          diff = Enum.at(a, i) - Enum.at(b, i)
          total = total + diff * diff
          i = i + 1
          while_fun.(while_fun, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun.(while_fun, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def search(nodes, index, query_point, depth, best) do
    try do
      if index == (-1) do
        throw {:return, best}
      end
      result = best
      result = Map.put(result, :nodes_visited, result.nodes_visited + 1)
      node_ = Enum.at(nodes, index)
      current_point = node_.point
      current_dist = square_distance(query_point, current_point)
      {result} = if _len(Map.get(result, :point, [])) == 0 || current_dist < result.distance do
        result = Map.put(result, :point, current_point)
        result = Map.put(result, :distance, current_dist)
        {result}
      else
        {result}
      end
      k = _len(query_point)
      axis = rem(depth, k)
      nearer = node_.left
      further = node_.right
      {further, nearer} = if Enum.at(query_point, axis) > Enum.at(current_point, axis) do
        nearer = node_.right
        further = node_.left
        {further, nearer}
      else
        {further, nearer}
      end
      result = search(nodes, nearer, query_point, depth + 1, result)
      diff = Enum.at(query_point, axis) - Enum.at(current_point, axis)
      {result} = if diff * diff < result.distance do
        result = search(nodes, further, query_point, depth + 1, result)
        {result}
      else
        {result}
      end
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def nearest_neighbour_search(nodes, root, query_point) do
    try do
      initial = %{point: [], distance: 1000000000000000000000000000000.0, nodes_visited: 0}
      throw {:return, search(nodes, root, query_point, 0, initial)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:queries, [[9.0, 2.0], [12.0, 15.0], [1.0, 3.0]])
  Process.put(:q, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:nodes, [%{point: [9.0, 1.0], left: 1, right: 4}, %{point: [2.0, 7.0], left: 2, right: 3}, %{point: [3.0, 6.0], left: -1, right: -1}, %{point: [6.0, 12.0], left: -1, right: -1}, %{point: [17.0, 15.0], left: 5, right: 6}, %{point: [13.0, 15.0], left: -1, right: -1}, %{point: [10.0, 19.0], left: -1, right: -1}])
    while_fun_2 = fn while_fun_2 ->
      if Process.get(:q) < _len(Process.get(:queries)) do
        res = nearest_neighbour_search(Process.get(:nodes), 0, Enum.at(Process.get(:queries), Process.get(:q)))
        IO.puts((((((Kernel.to_string(res.point) <> " ") <> Kernel.to_string(res.distance)) <> " ") <> Kernel.to_string(res.nodes_visited)) <> "\n"))
        Process.put(:q, Process.get(:q) + 1)
        while_fun_2.(while_fun_2)
      else
        nil
      end
    end
    try do
      while_fun_2.(while_fun_2)
    catch
      :break -> nil
    end

    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
