# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand_float() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, (:erlang.float(Process.get(:seed))) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def hypercube_points(num_points, cube_size, num_dimensions) do
    try do
      pts = []
      i = 0
      while_fun = fn while_fun, i, pts ->
        if i < num_points do
          p = []
          j = 0
          while_fun_2 = fn while_fun_2, j, p ->
            if j < num_dimensions do
              v = cube_size * rand_float()
              p = (p ++ [v])
              j = j + 1
              while_fun_2.(while_fun_2, j, p)
            else
              {j, p}
            end
          end
          {j, p} = try do
              while_fun_2.(while_fun_2, j, p)
            catch
              {:break, {j, p}} -> {j, p}
            end

          pts = (pts ++ [p])
          i = i + 1
          while_fun.(while_fun, i, pts)
        else
          {i, pts}
        end
      end
      {i, pts} = try do
          while_fun.(while_fun, i, pts)
        catch
          {:break, {i, pts}} -> {i, pts}
        end

      throw {:return, pts}
    catch
      {:return, val} -> val
    end
  end
  def build_kdtree(points, depth) do
    try do
      throw {:return, points}
    catch
      {:return, val} -> val
    end
  end
  def distance_sq(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, sum ->
        if i < _len(a) do
          d = Enum.at(a, i) - Enum.at(b, i)
          sum = sum + d * d
          i = i + 1
          while_fun_3.(while_fun_3, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_3.(while_fun_3, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def nearest_neighbour_search(points, query) do
    try do
      if _len(points) == 0 do
        throw {:return, %{"index" => -1.0, "dist" => Process.get(:inf), "visited" => 0.0}}
      end
      nearest_idx = 0
      nearest_dist = Process.get(:inf)
      visited = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, nearest_dist, nearest_idx, visited ->
        if i < _len(points) do
          d = distance_sq(query, Enum.at(points, i))
          visited = visited + 1
          {nearest_dist, nearest_idx} = if d < nearest_dist do
            nearest_dist = d
            nearest_idx = i
            {nearest_dist, nearest_idx}
          else
            {nearest_dist, nearest_idx}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, nearest_dist, nearest_idx, visited)
        else
          {i, nearest_dist, nearest_idx, visited}
        end
      end
      {i, nearest_dist, nearest_idx, visited} = try do
          while_fun_4.(while_fun_4, i, nearest_dist, nearest_idx, visited)
        catch
          {:break, {i, nearest_dist, nearest_idx, visited}} -> {i, nearest_dist, nearest_idx, visited}
        end

      throw {:return, %{"index" => :erlang.float(nearest_idx), "dist" => nearest_dist, "visited" => :erlang.float(visited)}}
    catch
      {:return, val} -> val
    end
  end
  def test_build_cases() do
    try do
      empty_pts = []
      tree0 = build_kdtree(empty_pts, 0)
      if _len(tree0) == 0 do
        IO.puts("case1 true")
      else
        IO.puts("case1 false")
      end
      pts1 = hypercube_points(10, 10.0, 2)
      tree1 = build_kdtree(pts1, 2)
      if _len(tree1) > 0 && _len(Enum.at(tree1, 0)) == 2 do
        IO.puts("case2 true")
      else
        IO.puts("case2 false")
      end
      pts2 = hypercube_points(10, 10.0, 3)
      tree2 = build_kdtree(pts2, -2)
      if _len(tree2) > 0 && _len(Enum.at(tree2, 0)) == 3 do
        IO.puts("case3 true")
      else
        IO.puts("case3 false")
      end
    catch
      {:return, val} -> val
    end
  end
  def test_search() do
    try do
      pts = hypercube_points(10, 10.0, 2)
      tree = build_kdtree(pts, 0)
      qp = Enum.at(hypercube_points(1, 10.0, 2), 0)
      res = nearest_neighbour_search(tree, qp)
      if res["index"] != (-1.0) && res["dist"] >= 0.0 && res["visited"] > 0.0 do
        IO.puts("search true")
      else
        IO.puts("search false")
      end
    catch
      {:return, val} -> val
    end
  end
  def test_edge() do
    try do
      empty_pts = []
      tree = build_kdtree(empty_pts, 0)
      query = [0.0, 0.0]
      res = nearest_neighbour_search(tree, query)
      if res["index"] == (-1.0) && res["dist"] > 100000000.0 && res["visited"] == 0.0 do
        IO.puts("edge true")
      else
        IO.puts("edge false")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      Process.put(:seed, 1)
      test_build_cases()
      test_search()
      test_edge()
    catch
      {:return, val} -> val
    end
  end
  Process.put(:inf, 1000000000.0)
  Process.put(:seed, 1)
  def bench_main() do
    Process.put(:inf, 1000000000.0)
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
