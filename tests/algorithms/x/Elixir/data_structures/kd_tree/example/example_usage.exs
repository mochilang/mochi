# Code generated by Mochi transpiler 2025-08-24 23:57 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (1.0 * rand()) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def hypercube_points(num_points, cube_size, num_dimensions) do
    try do
      pts = []
      i = 0
      while_fun = fn while_fun, i, pts ->
        if i < num_points do
          p = []
          j = 0
          while_fun_2 = fn while_fun_2, j, p ->
            if j < num_dimensions do
              p = (p ++ [cube_size * random()])
              j = j + 1
              while_fun_2.(while_fun_2, j, p)
            else
              {j, p}
            end
          end
          {_, _} = try do
              while_fun_2.(while_fun_2, j, p)
            catch
              {:break, {_, _}} -> {0, 0}
            end

          pts = (pts ++ [p])
          i = i + 1
          while_fun.(while_fun, i, pts)
        else
          {i, pts}
        end
      end
      {_, pts} = try do
          while_fun.(while_fun, i, pts)
        catch
          {:break, {_, pts}} -> {0, pts}
        end

      throw {:return, pts}
    catch
      {:return, val} -> val
    end
  end
  def sort_points(points, axis) do
    try do
      n = _len(points)
      i = 1
      while_fun_3 = fn while_fun_3, i, points ->
        if i < n do
          key = Enum.at(points, i, [])
          j = i - 1
          while_fun_4 = fn while_fun_4, j, points ->
            if j >= 0 && Enum.at(Enum.at(points, j, []), axis, 0) > Enum.at(key, axis, []) do
              points = List.replace_at(points, j + 1, Enum.at(points, j, []))
              j = j - 1
              while_fun_4.(while_fun_4, j, points)
            else
              {j, points}
            end
          end
          {_, points} = try do
              while_fun_4.(while_fun_4, j, points)
            catch
              {:break, {_, points}} -> {0, points}
            end

          points = List.replace_at(points, j + 1, key)
          i = i + 1
          while_fun_3.(while_fun_3, i, points)
        else
          {i, points}
        end
      end
      {_, points} = try do
          while_fun_3.(while_fun_3, i, points)
        catch
          {:break, {_, points}} -> {0, points}
        end

      throw {:return, points}
    catch
      {:return, val} -> val
    end
  end
  def sublist(arr, start, end_) do
    try do
      res = []
      i = start
      while_fun_5 = fn while_fun_5, i, res ->
        if i < end_ do
          res = (res ++ [Enum.at(arr, i, [])])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def shift_nodes(nodes, offset) do
    try do
      i = 0
      while_fun_6 = fn while_fun_6, i, nodes ->
        if i < _len(nodes) do
          nodes = if Enum.at(nodes, i, []).left != 0 - 1 do
            nodes = List.replace_at(nodes, i, Map.put(Enum.at(nodes, i), :left, Enum.at(nodes, i, []).left + offset))
            nodes
          else
            nodes
          end
          nodes = if Enum.at(nodes, i, []).right != 0 - 1 do
            nodes = List.replace_at(nodes, i, Map.put(Enum.at(nodes, i), :right, Enum.at(nodes, i, []).right + offset))
            nodes
          else
            nodes
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, nodes)
        else
          {i, nodes}
        end
      end
      {_, nodes} = try do
          while_fun_6.(while_fun_6, i, nodes)
        catch
          {:break, {_, nodes}} -> {0, nodes}
        end

      throw {:return, nodes}
    catch
      {:return, val} -> val
    end
  end
  def build_kdtree(points, depth) do
    try do
      if _len(points) == 0 do
        throw {:return, %{index: 0 - 1, nodes: []}}
      end
      k = _len(Enum.at(points, 0, []))
      axis = rem(depth, k)
      points = sort_points(points, axis)
      median = div(_len(points), 2)
      left_points = sublist(points, 0, median)
      right_points = sublist(points, median + 1, _len(points))
      left_res = build_kdtree(left_points, depth + 1)
      right_res = build_kdtree(right_points, depth + 1)
      offset = _len(Map.get(left_res, :nodes, [])) + 1
      shifted_right = shift_nodes(right_res.nodes, offset)
      nodes = left_res.nodes
      left_index = left_res.index
      right_index = (if right_res.index == 0 - 1, do: 0 - 1, else: right_res.index + offset)
      nodes = (nodes ++ [%{point: Enum.at(points, median, []), left: left_index, right: right_index}])
      nodes = (nodes ++ shifted_right)
      root_index = _len(Map.get(left_res, :nodes, []))
      throw {:return, %{index: root_index, nodes: nodes}}
    catch
      {:return, val} -> val
    end
  end
  def square_distance(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun_7 = fn while_fun_7, i, sum ->
        if i < _len(a) do
          diff = Enum.at(a, i, []) - Enum.at(b, i, [])
          sum = sum + diff * diff
          i = i + 1
          while_fun_7.(while_fun_7, i, sum)
        else
          {i, sum}
        end
      end
      {_, sum} = try do
          while_fun_7.(while_fun_7, i, sum)
        catch
          {:break, {_, sum}} -> {0, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def nearest_neighbour_search(tree, root, query_point) do
    try do
      nearest_point = []
      nearest_dist = 0.0
      visited = 0
      i = 0
      while_fun_8 = fn while_fun_8, i, nearest_dist, nearest_point, visited ->
        if i < _len(tree) do
          node_ = Enum.at(tree, i, [])
          dist = square_distance(query_point, node_.point)
          visited = visited + 1
          {nearest_dist, nearest_point} = if visited == 1 || dist < nearest_dist do
            nearest_point = node_.point
            nearest_dist = dist
            {nearest_dist, nearest_point}
          else
            {nearest_dist, nearest_point}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i, nearest_dist, nearest_point, visited)
        else
          {i, nearest_dist, nearest_point, visited}
        end
      end
      {_, nearest_dist, nearest_point, visited} = try do
          while_fun_8.(while_fun_8, i, nearest_dist, nearest_point, visited)
        catch
          {:break, {_, nearest_dist, nearest_point, visited}} -> {0, nearest_dist, nearest_point, visited}
        end

      throw {:return, %{point: nearest_point, dist: nearest_dist, visited: visited}}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(arr) do
    try do
      s = "["
      i = 0
      while_fun_9 = fn while_fun_9, i, s ->
        if i < _len(arr) do
          s = (s <> String.trim_trailing(Kernel.to_string(Enum.at(arr, i, [])), ".0"))
          s = if i < _len(arr) - 1 do
            s = (s <> ", ")
            s
          else
            s
          end
          i = i + 1
          while_fun_9.(while_fun_9, i, s)
        else
          {i, s}
        end
      end
      {_, s} = try do
          while_fun_9.(while_fun_9, i, s)
        catch
          {:break, {_, s}} -> {0, s}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      num_points = 5000
      cube_size = 10.0
      num_dimensions = 10
      pts = hypercube_points(num_points, cube_size, num_dimensions)
      build = build_kdtree(pts, 0)
      root = build.index
      tree = build.nodes
      query = []
      i = 0
      while_fun_10 = fn while_fun_10, i, query ->
        if i < num_dimensions do
          query = (query ++ [random()])
          i = i + 1
          while_fun_10.(while_fun_10, i, query)
        else
          {i, query}
        end
      end
      {_, query} = try do
          while_fun_10.(while_fun_10, i, query)
        catch
          {:break, {_, query}} -> {0, query}
        end

      res = nearest_neighbour_search(tree, root, query)
      IO.puts(("Query point: " <> list_to_string(query)))
      IO.puts(("Nearest point: " <> list_to_string(res.point)))
      IO.puts(("Distance: " <> String.trim_trailing(Kernel.to_string(res.dist), ".0")))
      IO.puts(("Nodes visited: " <> Kernel.to_string(res.visited)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
