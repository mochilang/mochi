# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def has_loop(nodes, head) do
    try do
      slow = head
      fast = head
      while_fun = fn while_fun, fast, slow ->
        if fast != 0 - 1 do
          fast_node1 = Enum.at(nodes, fast)
          if fast_node1.next == 0 - 1 do
            throw {:return, false}
          end
          fast_node2 = Enum.at(nodes, fast_node1.next)
          if fast_node2.next == 0 - 1 do
            throw {:return, false}
          end
          slow_node = Enum.at(nodes, slow)
          slow = slow_node.next
          fast = fast_node2.next
          if slow == fast do
            throw {:return, true}
          end
          while_fun.(while_fun, fast, slow)
        else
          {fast, slow}
        end
      end
      {fast, slow} = try do
          while_fun.(while_fun, fast, slow)
        catch
          {:break, {fast, slow}} -> {fast, slow}
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def make_nodes(values) do
    try do
      nodes = []
      i = 0
      while_fun_2 = fn while_fun_2, i, nodes ->
        if i < _len(values) do
          next_idx = (if i == _len(values) - 1, do: 0 - 1, else: i + 1)
          nodes = (nodes ++ [%{data: Enum.at(values, i), next: next_idx}])
          i = i + 1
          while_fun_2.(while_fun_2, i, nodes)
        else
          {i, nodes}
        end
      end
      {i, nodes} = try do
          while_fun_2.(while_fun_2, i, nodes)
        catch
          {:break, {i, nodes}} -> {i, nodes}
        end

      throw {:return, nodes}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      list1 = make_nodes([1, 2, 3, 4])
      IO.puts(Kernel.inspect(has_loop(list1, 0)))
      list1 = List.replace_at(list1, 3, Map.put(Enum.at(list1, 3), :next, 1))
      IO.puts(Kernel.inspect(has_loop(list1, 0)))
      list2 = make_nodes([5, 6, 5, 6])
      IO.puts(Kernel.inspect(has_loop(list2, 0)))
      list3 = make_nodes([1])
      IO.puts(Kernel.inspect(has_loop(list3, 0)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
