# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_deque() do
    try do
      nodes = []
      nodes = (nodes ++ [%{data: "", prev: -1, next: 1}])
      nodes = (nodes ++ [%{data: "", prev: 0, next: -1}])
      throw {:return, %{nodes: nodes, header: 0, trailer: 1, size: 0}}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(d) do
    try do
      throw {:return, d.size == 0}
    catch
      {:return, val} -> val
    end
  end
  def front(d) do
    try do
      if is_empty(d) do
        raise("List is empty")
      end
      head = Enum.at(d.nodes, d.header)
      idx = head.next
      node_ = Enum.at(d.nodes, idx)
      throw {:return, node_.data}
    catch
      {:return, val} -> val
    end
  end
  def back(d) do
    try do
      if is_empty(d) do
        raise("List is empty")
      end
      tail = Enum.at(d.nodes, d.trailer)
      idx = tail.prev
      node_ = Enum.at(d.nodes, idx)
      throw {:return, node_.data}
    catch
      {:return, val} -> val
    end
  end
  def insert(d, pred, value, succ) do
    try do
      nodes = d.nodes
      new_idx = _len(nodes)
      nodes = (nodes ++ [%{data: value, prev: pred, next: succ}])
      pred_node = Enum.at(nodes, pred)
      pred_node = Map.put(pred_node, :next, new_idx)
      nodes = List.replace_at(nodes, pred, pred_node)
      succ_node = Enum.at(nodes, succ)
      succ_node = Map.put(succ_node, :prev, new_idx)
      nodes = List.replace_at(nodes, succ, succ_node)
      d = Map.put(d, :nodes, nodes)
      d = Map.put(d, :size, d.size + 1)
      throw {:return, d}
    catch
      {:return, val} -> val
    end
  end
  def delete(d, idx) do
    try do
      nodes = d.nodes
      node_ = Enum.at(nodes, idx)
      pred = node_.prev
      succ = node_.next
      pred_node = Enum.at(nodes, pred)
      pred_node = Map.put(pred_node, :next, succ)
      nodes = List.replace_at(nodes, pred, pred_node)
      succ_node = Enum.at(nodes, succ)
      succ_node = Map.put(succ_node, :prev, pred)
      nodes = List.replace_at(nodes, succ, succ_node)
      val = node_.data
      d = Map.put(d, :nodes, nodes)
      d = Map.put(d, :size, d.size - 1)
      throw {:return, %{deque: d, value: val}}
    catch
      {:return, val} -> val
    end
  end
  def add_first(d, value) do
    try do
      head = Enum.at(d.nodes, d.header)
      succ = head.next
      throw {:return, insert(d, d.header, value, succ)}
    catch
      {:return, val} -> val
    end
  end
  def add_last(d, value) do
    try do
      tail = Enum.at(d.nodes, d.trailer)
      pred = tail.prev
      throw {:return, insert(d, pred, value, d.trailer)}
    catch
      {:return, val} -> val
    end
  end
  def remove_first(d) do
    try do
      if is_empty(d) do
        raise("remove_first from empty list")
      end
      head = Enum.at(d.nodes, d.header)
      idx = head.next
      throw {:return, delete(d, idx)}
    catch
      {:return, val} -> val
    end
  end
  def remove_last(d) do
    try do
      if is_empty(d) do
        raise("remove_first from empty list")
      end
      tail = Enum.at(d.nodes, d.trailer)
      idx = tail.prev
      throw {:return, delete(d, idx)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      d = new_deque()
      d = add_first(d, "A")
      IO.puts(Kernel.inspect(front(d)))
      d = add_last(d, "B")
      IO.puts(Kernel.inspect(back(d)))
      r = remove_first(d)
      d = r.deque
      IO.puts(r.value)
      r = remove_last(d)
      d = r.deque
      IO.puts(r.value)
      IO.puts(Kernel.inspect(is_empty(d)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
