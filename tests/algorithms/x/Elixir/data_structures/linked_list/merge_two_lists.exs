# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sort_list(nums) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < _len(nums) do
          arr = (arr ++ [Enum.at(nums, i)])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      j = 0
      while_fun_2 = fn while_fun_2, arr, j ->
        if j < _len(arr) do
          k = j + 1
          while_fun_3 = fn while_fun_3, arr, k ->
            if k < _len(arr) do
              {arr} = if Enum.at(arr, k) < Enum.at(arr, j) do
                tmp = Enum.at(arr, j)
                arr = List.replace_at(arr, j, Enum.at(arr, k))
                arr = List.replace_at(arr, k, tmp)
                {arr}
              else
                {arr}
              end
              k = k + 1
              while_fun_3.(while_fun_3, arr, k)
            else
              {arr, k}
            end
          end
          {arr, k} = try do
              while_fun_3.(while_fun_3, arr, k)
            catch
              {:break, {arr, k}} -> {arr, k}
            end

          j = j + 1
          while_fun_2.(while_fun_2, arr, j)
        else
          {arr, j}
        end
      end
      {arr, j} = try do
          while_fun_2.(while_fun_2, arr, j)
        catch
          {:break, {arr, j}} -> {arr, j}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def make_sorted_linked_list(ints) do
    try do
      throw {:return, %{values: sort_list(ints)}}
    catch
      {:return, val} -> val
    end
  end
  def len_sll(sll) do
    try do
      throw {:return, _len(Map.get(sll, :values, []))}
    catch
      {:return, val} -> val
    end
  end
  def str_sll(sll) do
    try do
      res = ""
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(Map.get(sll, :values, [])) do
          res = (res <> Kernel.to_string(Enum.at(sll.values, i)))
          {res} = if i + 1 < _len(Map.get(sll, :values, [])) do
            res = (res <> " -> ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def merge_lists(a, b) do
    try do
      combined = []
      i = 0
      while_fun_5 = fn while_fun_5, combined, i ->
        if i < _len(Map.get(a, :values, [])) do
          combined = (combined ++ [Enum.at(a.values, i)])
          i = i + 1
          while_fun_5.(while_fun_5, combined, i)
        else
          {combined, i}
        end
      end
      {combined, i} = try do
          while_fun_5.(while_fun_5, combined, i)
        catch
          {:break, {combined, i}} -> {combined, i}
        end

      i = 0
      while_fun_6 = fn while_fun_6, combined, i ->
        if i < _len(Map.get(b, :values, [])) do
          combined = (combined ++ [Enum.at(b.values, i)])
          i = i + 1
          while_fun_6.(while_fun_6, combined, i)
        else
          {combined, i}
        end
      end
      {combined, i} = try do
          while_fun_6.(while_fun_6, combined, i)
        catch
          {:break, {combined, i}} -> {combined, i}
        end

      throw {:return, make_sorted_linked_list(combined)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_data_odd = [3, 9, -11, 0, 7, 5, 1, -1]
      test_data_even = [4, 6, 2, 0, 8, 10, 3, -2]
      sll_one = make_sorted_linked_list(test_data_odd)
      sll_two = make_sorted_linked_list(test_data_even)
      merged = merge_lists(sll_one, sll_two)
      IO.puts(Kernel.inspect(len_sll(merged)))
      IO.puts(Kernel.inspect(str_sll(merged)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
