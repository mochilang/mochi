# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def empty_list() do
    try do
      throw {:return, %{nodes: [], head_idx: -1, tail_idx: -1}}
    catch
      {:return, val} -> val
    end
  end
  def get_head_data(ll) do
    try do
      if ll.head_idx == (-1) do
        throw {:return, -1}
      end
      node_ = Enum.at(ll.nodes, ll.head_idx)
      throw {:return, node_.data}
    catch
      {:return, val} -> val
    end
  end
  def get_tail_data(ll) do
    try do
      if ll.tail_idx == (-1) do
        throw {:return, -1}
      end
      node_ = Enum.at(ll.nodes, ll.tail_idx)
      throw {:return, node_.data}
    catch
      {:return, val} -> val
    end
  end
  def insert_before_node(ll, idx, new_idx) do
    try do
      nodes = ll.nodes
      new_node = Enum.at(nodes, new_idx)
      new_node = Map.put(new_node, :next_index, idx)
      node_ = Enum.at(nodes, idx)
      p = node_.prev_index
      new_node = Map.put(new_node, :prev_index, p)
      nodes = List.replace_at(nodes, new_idx, new_node)
      {ll, nodes} = if p == (-1) do
        ll = Map.put(ll, :head_idx, new_idx)
        {ll, nodes}
      else
        prev_node = Enum.at(nodes, p)
        prev_node = Map.put(prev_node, :next_index, new_idx)
        nodes = List.replace_at(nodes, p, prev_node)
        {ll, nodes}
      end
      node_ = Map.put(node_, :prev_index, new_idx)
      nodes = List.replace_at(nodes, idx, node_)
      ll = Map.put(ll, :nodes, nodes)
    catch
      {:return, val} -> val
    end
  end
  def insert_after_node(ll, idx, new_idx) do
    try do
      nodes = ll.nodes
      new_node = Enum.at(nodes, new_idx)
      new_node = Map.put(new_node, :prev_index, idx)
      node_ = Enum.at(nodes, idx)
      nxt = node_.next_index
      new_node = Map.put(new_node, :next_index, nxt)
      nodes = List.replace_at(nodes, new_idx, new_node)
      {ll, nodes} = if nxt == (-1) do
        ll = Map.put(ll, :tail_idx, new_idx)
        {ll, nodes}
      else
        next_node = Enum.at(nodes, nxt)
        next_node = Map.put(next_node, :prev_index, new_idx)
        nodes = List.replace_at(nodes, nxt, next_node)
        {ll, nodes}
      end
      node_ = Map.put(node_, :next_index, new_idx)
      nodes = List.replace_at(nodes, idx, node_)
      ll = Map.put(ll, :nodes, nodes)
    catch
      {:return, val} -> val
    end
  end
  def set_head(ll, idx) do
    try do
      {ll} = if ll.head_idx == (-1) do
        ll = Map.put(ll, :head_idx, idx)
        ll = Map.put(ll, :tail_idx, idx)
        {ll}
      else
        insert_before_node(ll, ll.head_idx, idx)
        {ll}
      end
    catch
      {:return, val} -> val
    end
  end
  def set_tail(ll, idx) do
    try do
      {ll} = if ll.tail_idx == (-1) do
        ll = Map.put(ll, :head_idx, idx)
        ll = Map.put(ll, :tail_idx, idx)
        {ll}
      else
        insert_after_node(ll, ll.tail_idx, idx)
        {ll}
      end
    catch
      {:return, val} -> val
    end
  end
  def insert(ll, value) do
    try do
      nodes = ll.nodes
      nodes = (nodes ++ [%{data: value, prev_index: -1, next_index: -1}])
      idx = _len(nodes) - 1
      ll = Map.put(ll, :nodes, nodes)
      {ll} = if ll.head_idx == (-1) do
        ll = Map.put(ll, :head_idx, idx)
        ll = Map.put(ll, :tail_idx, idx)
        {ll}
      else
        insert_after_node(ll, ll.tail_idx, idx)
        {ll}
      end
    catch
      {:return, val} -> val
    end
  end
  def insert_at_position(ll, position, value) do
    try do
      current = ll.head_idx
      current_pos = 1
      while_fun = fn while_fun, current, current_pos, ll ->
        if current != (-1) do
          {ll} = if current_pos == position do
            nodes = ll.nodes
            nodes = (nodes ++ [%{data: value, prev_index: -1, next_index: -1}])
            new_idx = _len(nodes) - 1
            ll = Map.put(ll, :nodes, nodes)
            insert_before_node(ll, current, new_idx)
            throw {:return, nil}
            {ll}
          else
            {ll}
          end
          node_ = Enum.at(ll.nodes, current)
          current = node_.next_index
          current_pos = current_pos + 1
          while_fun.(while_fun, current, current_pos, ll)
        else
          {current, current_pos, ll}
        end
      end
      {current, current_pos, ll} = try do
          while_fun.(while_fun, current, current_pos, ll)
        catch
          {:break, {current, current_pos, ll}} -> {current, current_pos, ll}
        end

      insert(ll, value)
    catch
      {:return, val} -> val
    end
  end
  def get_node(ll, item) do
    try do
      current = ll.head_idx
      while_fun_2 = fn while_fun_2, current ->
        if current != (-1) do
          node_ = Enum.at(ll.nodes, current)
          if node_.data == item do
            throw {:return, current}
          end
          current = node_.next_index
          while_fun_2.(while_fun_2, current)
        else
          current
        end
      end
      current = try do
          while_fun_2.(while_fun_2, current)
        catch
          {:break, {current}} -> current
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def remove_node_pointers(ll, idx) do
    try do
      nodes = ll.nodes
      node_ = Enum.at(nodes, idx)
      nxt = node_.next_index
      p = node_.prev_index
      {nodes} = if nxt != (-1) do
        nxt_node = Enum.at(nodes, nxt)
        nxt_node = Map.put(nxt_node, :prev_index, p)
        nodes = List.replace_at(nodes, nxt, nxt_node)
        {nodes}
      else
        {nodes}
      end
      {nodes} = if p != (-1) do
        prev_node = Enum.at(nodes, p)
        prev_node = Map.put(prev_node, :next_index, nxt)
        nodes = List.replace_at(nodes, p, prev_node)
        {nodes}
      else
        {nodes}
      end
      node_ = Map.put(node_, :next_index, -1)
      node_ = Map.put(node_, :prev_index, -1)
      nodes = List.replace_at(nodes, idx, node_)
      ll = Map.put(ll, :nodes, nodes)
    catch
      {:return, val} -> val
    end
  end
  def delete_value(ll, value) do
    try do
      idx = get_node(ll, value)
      if idx == (-1) do
        throw {:return, nil}
      end
      {ll} = if idx == ll.head_idx do
        node_ = Enum.at(ll.nodes, idx)
        ll = Map.put(ll, :head_idx, node_.next_index)
        {ll}
      else
        {ll}
      end
      {ll} = if idx == ll.tail_idx do
        node_ = Enum.at(ll.nodes, idx)
        ll = Map.put(ll, :tail_idx, node_.prev_index)
        {ll}
      else
        {ll}
      end
      remove_node_pointers(ll, idx)
    catch
      {:return, val} -> val
    end
  end
  def contains(ll, value) do
    try do
      throw {:return, get_node(ll, value) != (-1)}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(ll) do
    try do
      throw {:return, ll.head_idx == (-1)}
    catch
      {:return, val} -> val
    end
  end
  def to_string(ll) do
    try do
      res = ""
      first = true
      current = ll.head_idx
      while_fun_3 = fn while_fun_3, current, first, res ->
        if current != (-1) do
          node_ = Enum.at(ll.nodes, current)
          val = Kernel.to_string(node_.data)
          {first, res} = if first do
            res = val
            first = false
            {first, res}
          else
            res = ((res <> " ") <> val)
            {first, res}
          end
          current = node_.next_index
          while_fun_3.(while_fun_3, current, first, res)
        else
          {current, first, res}
        end
      end
      {current, first, res} = try do
          while_fun_3.(while_fun_3, current, first, res)
        catch
          {:break, {current, first, res}} -> {current, first, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def print_list(ll) do
    try do
      current = ll.head_idx
      while_fun_4 = fn while_fun_4, current ->
        if current != (-1) do
          node_ = Enum.at(ll.nodes, current)
          IO.puts(Kernel.to_string(node_.data))
          current = node_.next_index
          while_fun_4.(while_fun_4, current)
        else
          current
        end
      end
      current = try do
          while_fun_4.(while_fun_4, current)
        catch
          {:break, {current}} -> current
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      ll = empty_list()
      IO.puts(Kernel.inspect(get_head_data(ll)))
      IO.puts(Kernel.inspect(get_tail_data(ll)))
      IO.puts(Kernel.inspect(is_empty(ll)))
      insert(ll, 10)
      IO.puts(Kernel.inspect(get_head_data(ll)))
      IO.puts(Kernel.inspect(get_tail_data(ll)))
      insert_at_position(ll, 3, 20)
      IO.puts(Kernel.inspect(get_head_data(ll)))
      IO.puts(Kernel.inspect(get_tail_data(ll)))
      nodes = ll.nodes
      nodes = (nodes ++ [%{data: 1000, prev_index: -1, next_index: -1}])
      idx_head = _len(nodes) - 1
      ll = Map.put(ll, :nodes, nodes)
      set_head(ll, idx_head)
      nodes = ll.nodes
      nodes = (nodes ++ [%{data: 2000, prev_index: -1, next_index: -1}])
      idx_tail = _len(nodes) - 1
      ll = Map.put(ll, :nodes, nodes)
      set_tail(ll, idx_tail)
      print_list(ll)
      IO.puts(Kernel.inspect(is_empty(ll)))
      print_list(ll)
      IO.puts(Kernel.inspect(contains(ll, 10)))
      delete_value(ll, 10)
      IO.puts(Kernel.inspect(contains(ll, 10)))
      delete_value(ll, 2000)
      IO.puts(Kernel.inspect(get_tail_data(ll)))
      delete_value(ll, 1000)
      IO.puts(Kernel.inspect(get_tail_data(ll)))
      IO.puts(Kernel.inspect(get_head_data(ll)))
      print_list(ll)
      delete_value(ll, 20)
      print_list(ll)
      i = 1
      while_fun_5 = fn while_fun_5, i ->
        if i < 10 do
          insert(ll, i)
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

      print_list(ll)
      ll2 = empty_list()
      insert_at_position(ll2, 1, 10)
      IO.puts(to_string(ll2))
      insert_at_position(ll2, 2, 20)
      IO.puts(to_string(ll2))
      insert_at_position(ll2, 1, 30)
      IO.puts(to_string(ll2))
      insert_at_position(ll2, 3, 40)
      IO.puts(to_string(ll2))
      insert_at_position(ll2, 5, 50)
      IO.puts(to_string(ll2))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
