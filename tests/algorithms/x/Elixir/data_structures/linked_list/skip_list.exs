# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def random() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 13 + 7), 100))
      throw {:return, (:erlang.float(Process.get(:seed))) / 100.0}
    catch
      {:return, val} -> val
    end
  end
  def random_level() do
    try do
      lvl = 1
      while_fun = fn while_fun, lvl ->
        if random() < Process.get(:p) && lvl < Process.get(:max_level) do
          lvl = lvl + 1
          while_fun.(while_fun, lvl)
        else
          lvl
        end
      end
      lvl = try do
          while_fun.(while_fun, lvl)
        catch
          {:break, {lvl}} -> lvl
        end

      throw {:return, lvl}
    catch
      {:return, val} -> val
    end
  end
  def empty_forward() do
    try do
      f = []
      i = 0
      while_fun_2 = fn while_fun_2, f, i ->
        if i < Process.get(:max_level) do
          f = (f ++ [Process.get(:nil)])
          i = i + 1
          while_fun_2.(while_fun_2, f, i)
        else
          {f, i}
        end
      end
      {f, i} = try do
          while_fun_2.(while_fun_2, f, i)
        catch
          {:break, {f, i}} -> {f, i}
        end

      throw {:return, f}
    catch
      {:return, val} -> val
    end
  end
  def init() do
    try do
      Process.put(:node_keys, [-1])
      Process.put(:node_vals, [0])
      Process.put(:node_forwards, [empty_forward()])
      Process.put(:level, 1)
    catch
      {:return, val} -> val
    end
  end
  def insert(key, value) do
    try do
      update = []
      i = 0
      while_fun_3 = fn while_fun_3, i, update ->
        if i < Process.get(:max_level) do
          update = (update ++ [0])
          i = i + 1
          while_fun_3.(while_fun_3, i, update)
        else
          {i, update}
        end
      end
      {i, update} = try do
          while_fun_3.(while_fun_3, i, update)
        catch
          {:break, {i, update}} -> {i, update}
        end

      x = 0
      i = Process.get(:level) - 1
      while_fun_4 = fn while_fun_4, i, update, x ->
        if i >= 0 do
          while_fun_5 = fn while_fun_5, x ->
            if Enum.at(Enum.at(Process.get(:node_forwards), x), i) != Process.get(:nil) && Enum.at(Process.get(:node_keys), Enum.at(Enum.at(Process.get(:node_forwards), x), i)) < key do
              x = Enum.at(Enum.at(Process.get(:node_forwards), x), i)
              while_fun_5.(while_fun_5, x)
            else
              x
            end
          end
          x = try do
              while_fun_5.(while_fun_5, x)
            catch
              {:break, {x}} -> x
            end

          update = List.replace_at(update, i, x)
          i = i - 1
          while_fun_4.(while_fun_4, i, update, x)
        else
          {i, update, x}
        end
      end
      {i, update, x} = try do
          while_fun_4.(while_fun_4, i, update, x)
        catch
          {:break, {i, update, x}} -> {i, update, x}
        end

      x = Enum.at(Enum.at(Process.get(:node_forwards), x), 0)
      if x != Process.get(:nil) && Enum.at(Process.get(:node_keys), x) == key do
        Process.put(:node_vals, List.replace_at(Process.get(:node_vals), x, value))
        throw {:return, nil}
      end
      lvl = random_level()
      {update} = if lvl > Process.get(:level) do
        j = Process.get(:level)
        while_fun_6 = fn while_fun_6, j, update ->
          if j < lvl do
            update = List.replace_at(update, j, 0)
            j = j + 1
            while_fun_6.(while_fun_6, j, update)
          else
            {j, update}
          end
        end
        {j, update} = try do
            while_fun_6.(while_fun_6, j, update)
          catch
            {:break, {j, update}} -> {j, update}
          end

        Process.put(:level, lvl)
        {update}
      else
        {update}
      end
      Process.put(:node_keys, (Process.get(:node_keys) ++ [key]))
      Process.put(:node_vals, (Process.get(:node_vals) ++ [value]))
      forwards = empty_forward()
      idx = _len(Process.get(:node_keys)) - 1
      i = 0
      while_fun_7 = fn while_fun_7, forwards, i ->
        if i < lvl do
          forwards = List.replace_at(forwards, i, Enum.at(Enum.at(Process.get(:node_forwards), Enum.at(update, i)), i))
          Process.put(:node_forwards, List.replace_at(Process.get(:node_forwards), Enum.at(update, i), List.replace_at(Enum.at(Process.get(:node_forwards), Enum.at(update, i)), i, idx)))
          i = i + 1
          while_fun_7.(while_fun_7, forwards, i)
        else
          {forwards, i}
        end
      end
      {forwards, i} = try do
          while_fun_7.(while_fun_7, forwards, i)
        catch
          {:break, {forwards, i}} -> {forwards, i}
        end

      Process.put(:node_forwards, (Process.get(:node_forwards) ++ [forwards]))
    catch
      {:return, val} -> val
    end
  end
  def find(key) do
    try do
      x = 0
      i = Process.get(:level) - 1
      while_fun_8 = fn while_fun_8, i, x ->
        if i >= 0 do
          while_fun_9 = fn while_fun_9, x ->
            if Enum.at(Enum.at(Process.get(:node_forwards), x), i) != Process.get(:nil) && Enum.at(Process.get(:node_keys), Enum.at(Enum.at(Process.get(:node_forwards), x), i)) < key do
              x = Enum.at(Enum.at(Process.get(:node_forwards), x), i)
              while_fun_9.(while_fun_9, x)
            else
              x
            end
          end
          x = try do
              while_fun_9.(while_fun_9, x)
            catch
              {:break, {x}} -> x
            end

          i = i - 1
          while_fun_8.(while_fun_8, i, x)
        else
          {i, x}
        end
      end
      {i, x} = try do
          while_fun_8.(while_fun_8, i, x)
        catch
          {:break, {i, x}} -> {i, x}
        end

      x = Enum.at(Enum.at(Process.get(:node_forwards), x), 0)
      if x != Process.get(:nil) && Enum.at(Process.get(:node_keys), x) == key do
        throw {:return, Enum.at(Process.get(:node_vals), x)}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def delete(key) do
    try do
      update = []
      i = 0
      while_fun_10 = fn while_fun_10, i, update ->
        if i < Process.get(:max_level) do
          update = (update ++ [0])
          i = i + 1
          while_fun_10.(while_fun_10, i, update)
        else
          {i, update}
        end
      end
      {i, update} = try do
          while_fun_10.(while_fun_10, i, update)
        catch
          {:break, {i, update}} -> {i, update}
        end

      x = 0
      i = Process.get(:level) - 1
      while_fun_11 = fn while_fun_11, i, update, x ->
        if i >= 0 do
          while_fun_12 = fn while_fun_12, x ->
            if Enum.at(Enum.at(Process.get(:node_forwards), x), i) != Process.get(:nil) && Enum.at(Process.get(:node_keys), Enum.at(Enum.at(Process.get(:node_forwards), x), i)) < key do
              x = Enum.at(Enum.at(Process.get(:node_forwards), x), i)
              while_fun_12.(while_fun_12, x)
            else
              x
            end
          end
          x = try do
              while_fun_12.(while_fun_12, x)
            catch
              {:break, {x}} -> x
            end

          update = List.replace_at(update, i, x)
          i = i - 1
          while_fun_11.(while_fun_11, i, update, x)
        else
          {i, update, x}
        end
      end
      {i, update, x} = try do
          while_fun_11.(while_fun_11, i, update, x)
        catch
          {:break, {i, update, x}} -> {i, update, x}
        end

      x = Enum.at(Enum.at(Process.get(:node_forwards), x), 0)
      if x == Process.get(:nil) || Enum.at(Process.get(:node_keys), x) != key do
        throw {:return, nil}
      end
      i = 0
      while_fun_13 = fn while_fun_13, i ->
        if i < Process.get(:level) do
          if Enum.at(Enum.at(Process.get(:node_forwards), Enum.at(update, i)), i) == x do
            Process.put(:node_forwards, List.replace_at(Process.get(:node_forwards), Enum.at(update, i), List.replace_at(Enum.at(Process.get(:node_forwards), Enum.at(update, i)), i, Enum.at(Enum.at(Process.get(:node_forwards), x), i))))
          end
          i = i + 1
          while_fun_13.(while_fun_13, i)
        else
          i
        end
      end
      i = try do
          while_fun_13.(while_fun_13, i)
        catch
          {:break, {i}} -> i
        end

      while_fun_14 = fn while_fun_14 ->
        if Process.get(:level) > 1 && Enum.at(Enum.at(Process.get(:node_forwards), 0), Process.get(:level) - 1) == Process.get(:nil) do
          Process.put(:level, Process.get(:level) - 1)
          while_fun_14.(while_fun_14)
        else
          nil
        end
      end
      try do
        while_fun_14.(while_fun_14)
      catch
        :break -> nil
      end

    catch
      {:return, val} -> val
    end
  end
  def to_string() do
    try do
      s = ""
      x = Enum.at(Enum.at(Process.get(:node_forwards), 0), 0)
      while_fun_15 = fn while_fun_15, s, x ->
        if x != Process.get(:nil) do
          {s} = if s != "" do
            s = (s <> " -> ")
            {s}
          else
            {s}
          end
          s = (((s <> Kernel.to_string(Enum.at(Process.get(:node_keys), x))) <> ":") <> Kernel.to_string(Enum.at(Process.get(:node_vals), x)))
          x = Enum.at(Enum.at(Process.get(:node_forwards), x), 0)
          while_fun_15.(while_fun_15, s, x)
        else
          {s, x}
        end
      end
      {s, x} = try do
          while_fun_15.(while_fun_15, s, x)
        catch
          {:break, {s, x}} -> {s, x}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      init()
      insert(2, 2)
      insert(4, 4)
      insert(6, 4)
      insert(4, 5)
      insert(8, 4)
      insert(9, 4)
      delete(4)
      IO.puts(to_string())
    catch
      {:return, val} -> val
    end
  end
  Process.put(:max_level, 6)
  Process.put(:p, 0.5)
  Process.put(:seed, 1)
  Process.put(:node_keys, [])
  Process.put(:node_vals, [])
  Process.put(:node_forwards, [])
  Process.put(:level, 1)
  def bench_main() do
    Process.put(:max_level, 6)
    Process.put(:p, 0.5)
    Process.put(:seed, 1)
    Process.put(:node_keys, [])
    Process.put(:node_vals, [])
    Process.put(:node_forwards, [])
    Process.put(:level, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:nil, 0 - 1)
Main.bench_main()
