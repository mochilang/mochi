# Code generated by Mochi transpiler 2025-08-06 23:01 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def tail(xs) do
    try do
      res = []
      i = 1
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) do
          res = (res ++ [Enum.at(xs, i)])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def rotate_left(xs) do
    try do
      if _len(xs) == 0 do
        throw {:return, xs}
      end
      res = []
      i = 1
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(xs) do
          res = (res ++ [Enum.at(xs, i)])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res ++ [Enum.at(xs, 0)])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def permute_recursive(nums) do
    try do
      if _len(nums) == 0 do
        base = []
        throw {:return, (base ++ [[]])}
      end
      result = []
      current = nums
      count = 0
      while_fun_3 = fn while_fun_3, count, current, result ->
        if count < _len(nums) do
          n = Enum.at(current, 0)
          rest = tail(current)
          perms = permute_recursive(rest)
          j = 0
          while_fun_4 = fn while_fun_4, j, result ->
            if j < _len(perms) do
              perm = (Enum.at(perms, j) ++ [n])
              result = (result ++ [perm])
              j = j + 1
              while_fun_4.(while_fun_4, j, result)
            else
              {j, result}
            end
          end
          {j, result} = try do
              while_fun_4.(while_fun_4, j, result)
            catch
              {:break, {j, result}} -> {j, result}
            end

          current = rotate_left(current)
          count = count + 1
          while_fun_3.(while_fun_3, count, current, result)
        else
          {count, current, result}
        end
      end
      {count, current, result} = try do
          while_fun_3.(while_fun_3, count, current, result)
        catch
          {:break, {count, current, result}} -> {count, current, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def swap(xs, i, j) do
    try do
      res = []
      k = 0
      while_fun_5 = fn while_fun_5, k, res ->
        if k < _len(xs) do
          {res} = if k == i do
            res = (res ++ [Enum.at(xs, j)])
            {res}
          else
            {res} = if k == j do
              res = (res ++ [Enum.at(xs, i)])
              {res}
            else
              res = (res ++ [Enum.at(xs, k)])
              {res}
            end
            {res}
          end
          k = k + 1
          while_fun_5.(while_fun_5, k, res)
        else
          {k, res}
        end
      end
      {k, res} = try do
          while_fun_5.(while_fun_5, k, res)
        catch
          {:break, {k, res}} -> {k, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def permute_backtrack_helper(nums, start, output) do
    try do
      if start == _len(nums) - 1 do
        throw {:return, (output ++ [nums])}
      end
      i = start
      res = output
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(nums) do
          swapped = swap(nums, start, i)
          res = permute_backtrack_helper(swapped, start + 1, res)
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def permute_backtrack(nums) do
    try do
      output = []
      throw {:return, permute_backtrack_helper(nums, 0, output)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(permute_recursive([1, 2, 3])))
    IO.puts(Kernel.inspect(permute_backtrack([1, 2, 3])))
  end
end
Main.main()
