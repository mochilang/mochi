# Code generated by Mochi transpiler 2025-08-24 15:35 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow2(n) do
    try do
      result = 1
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < n do
          result = result * 2
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {_, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {_, result}} -> {0, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def int_log2(n) do
    try do
      v = n
      res = 0
      while_fun_2 = fn while_fun_2, res, v ->
        if v > 1 do
          v = div(v, 2)
          res = res + 1
          while_fun_2.(while_fun_2, res, v)
        else
          {res, v}
        end
      end
      {res, v} = try do
          while_fun_2.(while_fun_2, res, v)
        catch
          {:break, {res, v}} -> {res, v}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def build_sparse_table(number_list) do
    try do
      if _len(number_list) == 0 do
        raise("empty number list not allowed")
      end
      length = _len(number_list)
      row = int_log2(length) + 1
      sparse_table = []
      j = 0
      while_fun_3 = fn while_fun_3, j, sparse_table ->
        if j < row do
          inner = []
          i = 0
          while_fun_4 = fn while_fun_4, i, inner ->
            if i < length do
              inner = (inner ++ [0])
              i = i + 1
              while_fun_4.(while_fun_4, i, inner)
            else
              {i, inner}
            end
          end
          {_, inner} = try do
              while_fun_4.(while_fun_4, i, inner)
            catch
              {:break, {_, inner}} -> {0, inner}
            end

          sparse_table = (sparse_table ++ [inner])
          j = j + 1
          while_fun_3.(while_fun_3, j, sparse_table)
        else
          {j, sparse_table}
        end
      end
      {_, sparse_table} = try do
          while_fun_3.(while_fun_3, j, sparse_table)
        catch
          {:break, {_, sparse_table}} -> {0, sparse_table}
        end

      i = 0
      while_fun_5 = fn while_fun_5, i, sparse_table ->
        if i < length do
          sparse_table = List.replace_at(sparse_table, 0, List.replace_at(Enum.at(sparse_table, 0), i, Enum.at(number_list, i, [])))
          i = i + 1
          while_fun_5.(while_fun_5, i, sparse_table)
        else
          {i, sparse_table}
        end
      end
      {_, sparse_table} = try do
          while_fun_5.(while_fun_5, i, sparse_table)
        catch
          {:break, {_, sparse_table}} -> {0, sparse_table}
        end

      j = 1
      while_fun_6 = fn while_fun_6, i, j, sparse_table ->
        if pow2(j) <= length do
          i = 0
          while_fun_7 = fn while_fun_7, i, sparse_table ->
            if i + pow2(j) - 1 < length do
              left = Enum.at(Enum.at(sparse_table, j - 1, []), i + pow2(j - 1), 0)
              right = Enum.at(Enum.at(sparse_table, j - 1, []), i, 0)
              sparse_table = if left < right do
                sparse_table = List.replace_at(sparse_table, j, List.replace_at(Enum.at(sparse_table, j), i, left))
                sparse_table
              else
                sparse_table = List.replace_at(sparse_table, j, List.replace_at(Enum.at(sparse_table, j), i, right))
                sparse_table
              end
              i = i + 1
              while_fun_7.(while_fun_7, i, sparse_table)
            else
              {i, sparse_table}
            end
          end
          {_, sparse_table} = try do
              while_fun_7.(while_fun_7, i, sparse_table)
            catch
              {:break, {_, sparse_table}} -> {0, sparse_table}
            end

          j = j + 1
          while_fun_6.(while_fun_6, i, j, sparse_table)
        else
          {i, j, sparse_table}
        end
      end
      {_, _, sparse_table} = try do
          while_fun_6.(while_fun_6, i, j, sparse_table)
        catch
          {:break, {_, _, sparse_table}} -> {0, 0, sparse_table}
        end

      throw {:return, sparse_table}
    catch
      {:return, val} -> val
    end
  end
  def query(sparse_table, left_bound, right_bound) do
    try do
      if left_bound < 0 || right_bound >= _len(Enum.at(sparse_table, 0, [])) do
        raise("list index out of range")
      end
      interval = right_bound - left_bound + 1
      j = int_log2(interval)
      val1 = Enum.at(Enum.at(sparse_table, j, []), right_bound - pow2(j) + 1, 0)
      val2 = Enum.at(Enum.at(sparse_table, j, []), left_bound, 0)
      if val1 < val2 do
        throw {:return, val1}
      end
      throw {:return, val2}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:st1, build_sparse_table([8, 1, 0, 3, 4, 9, 3]))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:st1)])), ",", " "))
    Process.put(:st2, build_sparse_table([3, 1, 9]))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:st2)])), ",", " "))
    IO.puts(Kernel.inspect(query(Process.get(:st1), 0, 4)))
    IO.puts(Kernel.inspect(query(Process.get(:st1), 4, 6)))
    IO.puts(Kernel.inspect(query(Process.get(:st2), 2, 2)))
    IO.puts(Kernel.inspect(query(Process.get(:st2), 0, 1)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
