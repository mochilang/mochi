# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_parent_idx(idx) do
    try do
      throw {:return, div((idx - 1), 2)}
    catch
      {:return, val} -> val
    end
  end
  def get_left_child_idx(idx) do
    try do
      throw {:return, idx * 2 + 1}
    catch
      {:return, val} -> val
    end
  end
  def get_right_child_idx(idx) do
    try do
      throw {:return, idx * 2 + 2}
    catch
      {:return, val} -> val
    end
  end
  def remove_key(m, k) do
    try do
      out = %{}
      {out} = Enum.reduce(Map.keys(m), {out}, fn key, {out} ->
        {out} = if key != k do
          out = Map.put(out, key, m[key])
          {out}
        else
          {out}
        end
        {out}
      end)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def slice_without_last(xs) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) - 1 do
          res = (res ++ [Enum.at(xs, i)])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def sift_down(mh, idx) do
    try do
      heap = mh.heap
      idx_map = mh.idx_of_element
      i = idx
      while_fun_2 = fn while_fun_2, heap, i, idx_map ->
        if true do
          left = get_left_child_idx(i)
          right = get_right_child_idx(i)
          smallest = i
          {smallest} = if left < _len(heap) && Enum.at(heap, left)["val"] < Enum.at(heap, smallest)["val"] do
            smallest = left
            {smallest}
          else
            {smallest}
          end
          {smallest} = if right < _len(heap) && Enum.at(heap, right)["val"] < Enum.at(heap, smallest)["val"] do
            smallest = right
            {smallest}
          else
            {smallest}
          end
          {heap, i, idx_map} = if smallest != i do
            tmp = Enum.at(heap, i)
            heap = List.replace_at(heap, i, Enum.at(heap, smallest))
            heap = List.replace_at(heap, smallest, tmp)
            idx_map = Map.put(idx_map, Enum.at(heap, i)["name"], i)
            idx_map = Map.put(idx_map, Enum.at(heap, smallest)["name"], smallest)
            i = smallest
            {heap, i, idx_map}
          else
            throw {:break, {heap, i, idx_map}}
            {heap, i, idx_map}
          end
          while_fun_2.(while_fun_2, heap, i, idx_map)
        else
          {heap, i, idx_map}
        end
      end
      {heap, i, idx_map} = try do
          while_fun_2.(while_fun_2, heap, i, idx_map)
        catch
          {:break, {heap, i, idx_map}} -> {heap, i, idx_map}
        end

      mh = Map.put(mh, :heap, heap)
      mh = Map.put(mh, :idx_of_element, idx_map)
    catch
      {:return, val} -> val
    end
  end
  def sift_up(mh, idx) do
    try do
      heap = mh.heap
      idx_map = mh.idx_of_element
      i = idx
      p = get_parent_idx(i)
      while_fun_3 = fn while_fun_3, heap, i, idx_map, p ->
        if p >= 0 && Enum.at(heap, p)["val"] > Enum.at(heap, i)["val"] do
          tmp = Enum.at(heap, p)
          heap = List.replace_at(heap, p, Enum.at(heap, i))
          heap = List.replace_at(heap, i, tmp)
          idx_map = Map.put(idx_map, Enum.at(heap, p)["name"], p)
          idx_map = Map.put(idx_map, Enum.at(heap, i)["name"], i)
          i = p
          p = get_parent_idx(i)
          while_fun_3.(while_fun_3, heap, i, idx_map, p)
        else
          {heap, i, idx_map, p}
        end
      end
      {heap, i, idx_map, p} = try do
          while_fun_3.(while_fun_3, heap, i, idx_map, p)
        catch
          {:break, {heap, i, idx_map, p}} -> {heap, i, idx_map, p}
        end

      mh = Map.put(mh, :heap, heap)
      mh = Map.put(mh, :idx_of_element, idx_map)
    catch
      {:return, val} -> val
    end
  end
  def new_min_heap(array) do
    try do
      idx_map = %{}
      val_map = %{}
      heap = array
      i = 0
      while_fun_4 = fn while_fun_4, i, idx_map, val_map ->
        if i < _len(array) do
          n = Enum.at(array, i)
          idx_map = Map.put(idx_map, n.name, i)
          val_map = Map.put(val_map, n.name, n.val)
          i = i + 1
          while_fun_4.(while_fun_4, i, idx_map, val_map)
        else
          {i, idx_map, val_map}
        end
      end
      {i, idx_map, val_map} = try do
          while_fun_4.(while_fun_4, i, idx_map, val_map)
        catch
          {:break, {i, idx_map, val_map}} -> {i, idx_map, val_map}
        end

      mh = %{heap: heap, idx_of_element: idx_map, heap_dict: val_map}
      start = get_parent_idx(_len(array) - 1)
      while_fun_5 = fn while_fun_5, start ->
        if start >= 0 do
          sift_down(mh, start)
          start = start - 1
          while_fun_5.(while_fun_5, start)
        else
          start
        end
      end
      start = try do
          while_fun_5.(while_fun_5, start)
        catch
          {:break, {start}} -> start
        end

      throw {:return, mh}
    catch
      {:return, val} -> val
    end
  end
  def peek(mh) do
    try do
      throw {:return, Enum.at(mh.heap, 0)}
    catch
      {:return, val} -> val
    end
  end
  def remove_min(mh) do
    try do
      heap = mh.heap
      idx_map = mh.idx_of_element
      val_map = mh.heap_dict
      last_idx = _len(heap) - 1
      top = Enum.at(heap, 0)
      last = Enum.at(heap, last_idx)
      heap = List.replace_at(heap, 0, last)
      idx_map = Map.put(idx_map, last.name, 0)
      heap = slice_without_last(heap)
      idx_map = remove_key(idx_map, top.name)
      val_map = remove_key(val_map, top.name)
      mh = Map.put(mh, :heap, heap)
      mh = Map.put(mh, :idx_of_element, idx_map)
      mh = Map.put(mh, :heap_dict, val_map)
      if _len(heap) > 0 do
        sift_down(mh, 0)
      end
      throw {:return, top}
    catch
      {:return, val} -> val
    end
  end
  def insert(mh, node_) do
    try do
      heap = mh.heap
      idx_map = mh.idx_of_element
      val_map = mh.heap_dict
      heap = (heap ++ [node_])
      idx = _len(heap) - 1
      idx_map = Map.put(idx_map, node_.name, idx)
      val_map = Map.put(val_map, node_.name, node_.val)
      mh = Map.put(mh, :heap, heap)
      mh = Map.put(mh, :idx_of_element, idx_map)
      mh = Map.put(mh, :heap_dict, val_map)
      sift_up(mh, idx)
    catch
      {:return, val} -> val
    end
  end
  def is_empty(mh) do
    try do
      throw {:return, _len(Map.get(mh, :heap, [])) == 0}
    catch
      {:return, val} -> val
    end
  end
  def get_value(mh, key) do
    try do
      throw {:return, mh.heap_dict[key]}
    catch
      {:return, val} -> val
    end
  end
  def decrease_key(mh, node_, new_value) do
    try do
      heap = mh.heap
      val_map = mh.heap_dict
      idx_map = mh.idx_of_element
      idx = idx_map[node_.name]
      if !(Enum.at(heap, idx)["val"] > new_value) do
        raise("newValue must be less than current value")
      end
      node_ = Map.put(node_, :val, new_value)
      heap = List.replace_at(heap, idx, Map.put(Enum.at(heap, idx), :val, new_value))
      val_map = Map.put(val_map, node_.name, new_value)
      mh = Map.put(mh, :heap, heap)
      mh = Map.put(mh, :heap_dict, val_map)
      sift_up(mh, idx)
    catch
      {:return, val} -> val
    end
  end
  def node_to_string(n) do
    try do
      throw {:return, (((("Node(" <> n.name) <> ", ") <> Kernel.to_string(n.val)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:b, %{name: "B", val: 6})
  Process.put(:a, %{name: "A", val: 3})
  Process.put(:x, %{name: "X", val: 1})
  Process.put(:e, %{name: "E", val: 4})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:r, %{name: "R", val: -1})
    Process.put(:my_min_heap, new_min_heap([Process.get(:r), Process.get(:b), Process.get(:a), Process.get(:x), Process.get(:e)]))
    IO.puts("Min Heap - before decrease key")
    Enum.each(Process.get(:my_min_heap).heap, fn n ->
      IO.puts(Kernel.inspect(node_to_string(n)))
    end)
    IO.puts("Min Heap - After decrease key of node [B -> -17]")
    decrease_key(Process.get(:my_min_heap), Process.get(:b), -17)
    Enum.each(Process.get(:my_min_heap).heap, fn n ->
      IO.puts(Kernel.inspect(node_to_string(n)))
    end)
    IO.puts(Kernel.inspect(get_value(Process.get(:my_min_heap), "B")))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
