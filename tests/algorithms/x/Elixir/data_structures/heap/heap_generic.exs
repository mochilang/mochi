# Code generated by Mochi transpiler 2025-08-24 23:57 +0700
defmodule Main do
  @data_dir nil
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def new_heap(key) do
    try do
      throw {:return, %{arr: [], pos_map: %{}, size: 0, key: key}}
    catch
      {:return, val} -> val
    end
  end
  def parent(i) do
    try do
      throw {:return, ((if i > 0, do: div((i - 1), 2), else: -1))}
    catch
      {:return, val} -> val
    end
  end
  def left(i, size) do
    try do
      l = 2 * i + 1
      if l < size do
        throw {:return, l}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def right(i, size) do
    try do
      r = 2 * i + 2
      if r < size do
        throw {:return, r}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def swap(h, i, j) do
    try do
      arr = h.arr
      item_i = Enum.at(Enum.at(arr, i, []), 0, 0)
      item_j = Enum.at(Enum.at(arr, j, []), 0, 0)
      pm = h.pos_map
      pm = Map.put(pm, item_i, j + 1)
      pm = Map.put(pm, item_j, i + 1)
      h = Map.put(h, :pos_map, pm)
      tmp = Enum.at(arr, i, [])
      arr = List.replace_at(arr, i, Enum.at(arr, j, []))
      arr = List.replace_at(arr, j, tmp)
      h = Map.put(h, :arr, arr)
    catch
      {:return, val} -> val
    end
  end
  def cmp(h, i, j) do
    try do
      arr = h.arr
      throw {:return, Enum.at(Enum.at(arr, i, []), 1, 0) < Enum.at(Enum.at(arr, j, []), 1, 0)}
    catch
      {:return, val} -> val
    end
  end
  def get_valid_parent(h, i) do
    try do
      vp = i
      l = left(i, h.size)
      vp = if l != 0 - 1 && cmp(h, l, vp) == false do
        vp = l
        vp
      else
        vp
      end
      r = right(i, h.size)
      vp = if r != 0 - 1 && cmp(h, r, vp) == false do
        vp = r
        vp
      else
        vp
      end
      throw {:return, vp}
    catch
      {:return, val} -> val
    end
  end
  def heapify_up(h, index) do
    try do
      idx = index
      p = parent(idx)
      while_fun = fn while_fun, idx, p ->
        if p != 0 - 1 && cmp(h, idx, p) == false do
          h = swap(h, idx, p)
          idx = p
          p = parent(p)
          while_fun.(while_fun, idx, p)
        else
          {idx, p}
        end
      end
      {_, _} = try do
          while_fun.(while_fun, idx, p)
        catch
          {:break, {_, _}} -> {0, 0}
        end

    catch
      {:return, val} -> val
    end
  end
  def heapify_down(h, index) do
    try do
      idx = index
      vp = get_valid_parent(h, idx)
      while_fun_2 = fn while_fun_2, idx, vp ->
        if vp != idx do
          h = swap(h, idx, vp)
          idx = vp
          vp = get_valid_parent(h, idx)
          while_fun_2.(while_fun_2, idx, vp)
        else
          {idx, vp}
        end
      end
      {_, vp} = try do
          while_fun_2.(while_fun_2, idx, vp)
        catch
          {:break, {_, vp}} -> {0, vp}
        end

    catch
      {:return, val} -> val
    end
  end
  def update_item(h, item, item_value) do
    try do
      pm = h.pos_map
      if pm[item] == 0 do
        throw {:return, h}
      end
      index = pm[item] - 1
      arr = h.arr
      arr = List.replace_at(arr, index, [item, h.key.(item_value)])
      h = Map.put(h, :arr, arr)
      h = Map.put(h, :pos_map, pm)
      h = heapify_up(h, index)
      h = heapify_down(h, index)
    catch
      {:return, val} -> val
    end
  end
  def delete_item(h, item) do
    try do
      pm = h.pos_map
      if pm[item] == 0 do
        throw {:return, h}
      end
      index = pm[item] - 1
      pm = Map.put(pm, item, 0)
      arr = h.arr
      last_index = h.size - 1
      {arr, pm} = if index != last_index do
        arr = List.replace_at(arr, index, Enum.at(arr, last_index, []))
        moved = Enum.at(Enum.at(arr, index, []), 0, 0)
        pm = Map.put(pm, moved, index + 1)
        {arr, pm}
      else
        {arr, pm}
      end
      h = Map.put(h, :size, h.size - 1)
      h = Map.put(h, :arr, arr)
      h = Map.put(h, :pos_map, pm)
      if h.size > index do
        h = heapify_up(h, index)
        h = heapify_down(h, index)
      end
    catch
      {:return, val} -> val
    end
  end
  def insert_item(h, item, item_value) do
    try do
      arr = h.arr
      arr_len = _len(arr)
      arr = if arr_len == h.size do
        arr = (arr ++ [[item, h.key.(item_value)]])
        arr
      else
        arr = List.replace_at(arr, h.size, [item, h.key.(item_value)])
        arr
      end
      pm = h.pos_map
      pm = Map.put(pm, item, h.size + 1)
      h = Map.put(h, :size, h.size + 1)
      h = Map.put(h, :arr, arr)
      h = Map.put(h, :pos_map, pm)
      h = heapify_up(h, h.size - 1)
    catch
      {:return, val} -> val
    end
  end
  def get_top(h) do
    try do
      arr = h.arr
      if h.size > 0 do
        throw {:return, Enum.at(arr, 0, [])}
      end
      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  def extract_top(h) do
    try do
      top = get_top(h)
      if _len(top) > 0 do
        h = delete_item(h, Enum.at(top, 0, []))
      end
      throw {:return, top}
    catch
      {:return, val} -> val
    end
  end
  def identity(x) do
    try do
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def negate(x) do
    try do
      throw {:return, 0 - x}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:h, new_heap(&identity/1))
    Process.put(:h, insert_item(Process.get(:h), 5, 34))
    Process.put(:h, insert_item(Process.get(:h), 6, 31))
    Process.put(:h, insert_item(Process.get(:h), 7, 37))
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    Process.put(:h, new_heap(&negate/1))
    Process.put(:h, insert_item(Process.get(:h), 5, 34))
    Process.put(:h, insert_item(Process.get(:h), 6, 31))
    Process.put(:h, insert_item(Process.get(:h), 7, 37))
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    Process.put(:h, insert_item(Process.get(:h), 8, 45))
    Process.put(:h, insert_item(Process.get(:h), 9, 40))
    Process.put(:h, insert_item(Process.get(:h), 10, 50))
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    Process.put(:h, update_item(Process.get(:h), 10, 30))
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    Process.put(:h, delete_item(Process.get(:h), 10))
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
  end
end
Main.main()
