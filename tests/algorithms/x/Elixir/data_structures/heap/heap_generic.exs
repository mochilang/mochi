# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_heap(key) do
    try do
      throw {:return, %{arr: [], pos_map: %{}, size: 0, key: key}}
    catch
      {:return, val} -> val
    end
  end
  def parent(i) do
    try do
      throw {:return, ((if i > 0, do: div((i - 1), 2), else: -1))}
    catch
      {:return, val} -> val
    end
  end
  def left(i, size) do
    try do
      l = 2 * i + 1
      if l < size do
        throw {:return, l}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def right(i, size) do
    try do
      r = 2 * i + 2
      if r < size do
        throw {:return, r}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def swap(h, i, j) do
    try do
      arr = h.arr
      item_i = Enum.at(Enum.at(arr, i), 0)
      item_j = Enum.at(Enum.at(arr, j), 0)
      pm = h.pos_map
      pm = Map.put(pm, item_i, j + 1)
      pm = Map.put(pm, item_j, i + 1)
      h = Map.put(h, :pos_map, pm)
      tmp = Enum.at(arr, i)
      arr = List.replace_at(arr, i, Enum.at(arr, j))
      arr = List.replace_at(arr, j, tmp)
      h = Map.put(h, :arr, arr)
    catch
      {:return, val} -> val
    end
  end
  def cmp(h, i, j) do
    try do
      arr = h.arr
      throw {:return, Enum.at(Enum.at(arr, i), 1) < Enum.at(Enum.at(arr, j), 1)}
    catch
      {:return, val} -> val
    end
  end
  def get_valid_parent(h, i) do
    try do
      vp = i
      l = left(i, h.size)
      {vp} = if l != 0 - 1 && cmp(h, l, vp) == false do
        vp = l
        {vp}
      else
        {vp}
      end
      r = right(i, h.size)
      {vp} = if r != 0 - 1 && cmp(h, r, vp) == false do
        vp = r
        {vp}
      else
        {vp}
      end
      throw {:return, vp}
    catch
      {:return, val} -> val
    end
  end
  def heapify_up(h, index) do
    try do
      idx = index
      p = parent(idx)
      while_fun = fn while_fun, idx, p ->
        if p != 0 - 1 && cmp(h, idx, p) == false do
          swap(h, idx, p)
          idx = p
          p = parent(p)
          while_fun.(while_fun, idx, p)
        else
          {idx, p}
        end
      end
      {idx, p} = try do
          while_fun.(while_fun, idx, p)
        catch
          {:break, {idx, p}} -> {idx, p}
        end

    catch
      {:return, val} -> val
    end
  end
  def heapify_down(h, index) do
    try do
      idx = index
      vp = get_valid_parent(h, idx)
      while_fun_2 = fn while_fun_2, idx, vp ->
        if vp != idx do
          swap(h, idx, vp)
          idx = vp
          vp = get_valid_parent(h, idx)
          while_fun_2.(while_fun_2, idx, vp)
        else
          {idx, vp}
        end
      end
      {idx, vp} = try do
          while_fun_2.(while_fun_2, idx, vp)
        catch
          {:break, {idx, vp}} -> {idx, vp}
        end

    catch
      {:return, val} -> val
    end
  end
  def update_item(h, item, item_value) do
    try do
      pm = h.pos_map
      if pm[item] == 0 do
        throw {:return, nil}
      end
      index = pm[item] - 1
      arr = h.arr
      arr = List.replace_at(arr, index, [item, h.key.(item_value)])
      h = Map.put(h, :arr, arr)
      h = Map.put(h, :pos_map, pm)
      heapify_up(h, index)
      heapify_down(h, index)
    catch
      {:return, val} -> val
    end
  end
  def delete_item(h, item) do
    try do
      pm = h.pos_map
      if pm[item] == 0 do
        throw {:return, nil}
      end
      index = pm[item] - 1
      pm = Map.put(pm, item, 0)
      arr = h.arr
      last_index = h.size - 1
      {arr, pm} = if index != last_index do
        arr = List.replace_at(arr, index, Enum.at(arr, last_index))
        moved = Enum.at(Enum.at(arr, index), 0)
        pm = Map.put(pm, moved, index + 1)
        {arr, pm}
      else
        {arr, pm}
      end
      h = Map.put(h, :size, h.size - 1)
      h = Map.put(h, :arr, arr)
      h = Map.put(h, :pos_map, pm)
      if h.size > index do
        heapify_up(h, index)
        heapify_down(h, index)
      end
    catch
      {:return, val} -> val
    end
  end
  def insert_item(h, item, item_value) do
    try do
      arr = h.arr
      arr_len = _len(arr)
      {arr} = if arr_len == h.size do
        arr = (arr ++ [[item, h.key.(item_value)]])
        {arr}
      else
        arr = List.replace_at(arr, h.size, [item, h.key.(item_value)])
        {arr}
      end
      pm = h.pos_map
      pm = Map.put(pm, item, h.size + 1)
      h = Map.put(h, :size, h.size + 1)
      h = Map.put(h, :arr, arr)
      h = Map.put(h, :pos_map, pm)
      heapify_up(h, h.size - 1)
    catch
      {:return, val} -> val
    end
  end
  def get_top(h) do
    try do
      arr = h.arr
      if h.size > 0 do
        throw {:return, Enum.at(arr, 0)}
      end
      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  def extract_top(h) do
    try do
      top = get_top(h)
      if _len(top) > 0 do
        delete_item(h, Enum.at(top, 0))
      end
      throw {:return, top}
    catch
      {:return, val} -> val
    end
  end
  def identity(x) do
    try do
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def negate(x) do
    try do
      throw {:return, 0 - x}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:h, new_heap(&identity/1))
    insert_item(Process.get(:h), 5, 34)
    insert_item(Process.get(:h), 6, 31)
    insert_item(Process.get(:h), 7, 37)
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    Process.put(:h, new_heap(&negate/1))
    insert_item(Process.get(:h), 5, 34)
    insert_item(Process.get(:h), 6, 31)
    insert_item(Process.get(:h), 7, 37)
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    IO.puts(Kernel.inspect(extract_top(Process.get(:h))))
    insert_item(Process.get(:h), 8, 45)
    insert_item(Process.get(:h), 9, 40)
    insert_item(Process.get(:h), 10, 50)
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    update_item(Process.get(:h), 10, 30)
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    delete_item(Process.get(:h), 10)
    IO.puts(Kernel.inspect(get_top(Process.get(:h))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
