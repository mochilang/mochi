# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def swap_up(i) do
    try do
      temp = Enum.at(Process.get(:heap), i)
      idx = i
      while_fun = fn while_fun, idx ->
        if div(idx, 2) > 0 do
          if Enum.at(Process.get(:heap), idx) > Enum.at(Process.get(:heap), div(idx, 2)) do
            Process.put(:heap, List.replace_at(Process.get(:heap), idx, Enum.at(Process.get(:heap), div(idx, 2))))
            Process.put(:heap, List.replace_at(Process.get(:heap), div(idx, 2), temp))
          end
          idx = div(idx, 2)
          while_fun.(while_fun, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun.(while_fun, idx)
        catch
          {:break, {idx}} -> idx
        end

    catch
      {:return, val} -> val
    end
  end
  def insert(value) do
    try do
      Process.put(:heap, (Process.get(:heap) ++ [value]))
      Process.put(:size, Process.get(:size) + 1)
      swap_up(Process.get(:size))
    catch
      {:return, val} -> val
    end
  end
  def swap_down(i) do
    try do
      idx = i
      while_fun_2 = fn while_fun_2, idx ->
        if Process.get(:size) >= 2 * idx do
          bigger_child = (if 2 * idx + 1 > Process.get(:size), do: 2 * idx, else: (if Enum.at(Process.get(:heap), 2 * idx) > Enum.at(Process.get(:heap), 2 * idx + 1), do: 2 * idx, else: 2 * idx + 1))
          temp = Enum.at(Process.get(:heap), idx)
          if Enum.at(Process.get(:heap), idx) < Enum.at(Process.get(:heap), bigger_child) do
            Process.put(:heap, List.replace_at(Process.get(:heap), idx, Enum.at(Process.get(:heap), bigger_child)))
            Process.put(:heap, List.replace_at(Process.get(:heap), bigger_child, temp))
          end
          idx = bigger_child
          while_fun_2.(while_fun_2, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_2.(while_fun_2, idx)
        catch
          {:break, {idx}} -> idx
        end

    catch
      {:return, val} -> val
    end
  end
  def shrink() do
    try do
      new_heap = []
      i = 0
      while_fun_3 = fn while_fun_3, i, new_heap ->
        if i <= Process.get(:size) do
          new_heap = (new_heap ++ [Enum.at(Process.get(:heap), i)])
          i = i + 1
          while_fun_3.(while_fun_3, i, new_heap)
        else
          {i, new_heap}
        end
      end
      {i, new_heap} = try do
          while_fun_3.(while_fun_3, i, new_heap)
        catch
          {:break, {i, new_heap}} -> {i, new_heap}
        end

      Process.put(:heap, new_heap)
    catch
      {:return, val} -> val
    end
  end
  def pop() do
    try do
      max_value = Enum.at(Process.get(:heap), 1)
      Process.put(:heap, List.replace_at(Process.get(:heap), 1, Enum.at(Process.get(:heap), Process.get(:size))))
      Process.put(:size, Process.get(:size) - 1)
      shrink()
      swap_down(1)
      throw {:return, max_value}
    catch
      {:return, val} -> val
    end
  end
  def get_list() do
    try do
      out = []
      i = 1
      while_fun_4 = fn while_fun_4, i, out ->
        if i <= Process.get(:size) do
          out = (out ++ [Enum.at(Process.get(:heap), i)])
          i = i + 1
          while_fun_4.(while_fun_4, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_4.(while_fun_4, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def len() do
    try do
      throw {:return, Process.get(:size)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:heap, [0])
  Process.put(:size, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    insert(6)
    insert(10)
    insert(15)
    insert(12)
    IO.puts(Kernel.inspect(pop()))
    IO.puts(Kernel.inspect(pop()))
    IO.puts(Kernel.inspect(get_list()))
    IO.puts(Kernel.inspect(len()))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
