# Code generated by Mochi transpiler 2025-08-07 08:34 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_table(size_table, charge_factor) do
    try do
      vals = []
      i = 0
      while_fun = fn while_fun, i, vals ->
        if i < size_table do
          vals = (vals ++ [[]])
          i = i + 1
          while_fun.(while_fun, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun.(while_fun, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{size_table: size_table, charge_factor: charge_factor, values: vals, keys: %{}}}
    catch
      {:return, val} -> val
    end
  end
  def hash_function(ht, key) do
    try do
      res = rem(key, ht.size_table)
      {res} = if res < 0 do
        res = res + ht.size_table
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def prepend(lst, value) do
    try do
      result = [value]
      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < _len(lst) do
          result = (result ++ [Enum.at(lst, i)])
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def set_value(ht, key, data) do
    try do
      current = Enum.at(ht.values, key)
      updated = prepend(current, data)
      vals = ht.values
      vals = List.replace_at(vals, key, updated)
      ht = Map.put(ht, :values, vals)
      ks = ht.keys
      ks = Map.put(ks, key, updated)
      ht = Map.put(ht, :keys, ks)
    catch
      {:return, val} -> val
    end
  end
  def count_empty(ht) do
    try do
      count = 0
      i = 0
      while_fun_3 = fn while_fun_3, count, i ->
        if i < _len(Map.get(ht, :values, [])) do
          {count} = if _len(Enum.at(ht.values, i)) == 0 do
            count = count + 1
            {count}
          else
            {count}
          end
          i = i + 1
          while_fun_3.(while_fun_3, count, i)
        else
          {count, i}
        end
      end
      {count, i} = try do
          while_fun_3.(while_fun_3, count, i)
        catch
          {:break, {count, i}} -> {count, i}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def balanced_factor(ht) do
    try do
      total = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, total ->
        if i < _len(Map.get(ht, :values, [])) do
          total = total + (ht.charge_factor - _len(Enum.at(ht.values, i)))
          i = i + 1
          while_fun_4.(while_fun_4, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_4.(while_fun_4, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, (:erlang.float(total)) / (:erlang.float(ht.size_table)) * (:erlang.float(ht.charge_factor))}
    catch
      {:return, val} -> val
    end
  end
  def collision_resolution(ht, key) do
    try do
      if !(_len(Enum.at(ht.values, key)) == ht.charge_factor && count_empty(ht) == 0) do
        throw {:return, key}
      end
      new_key = rem((key + 1), ht.size_table)
      steps = 0
      while_fun_5 = fn while_fun_5, new_key, steps ->
        if _len(Enum.at(ht.values, new_key)) == ht.charge_factor && steps < ht.size_table - 1 do
          new_key = rem((new_key + 1), ht.size_table)
          steps = steps + 1
          while_fun_5.(while_fun_5, new_key, steps)
        else
          {new_key, steps}
        end
      end
      {new_key, steps} = try do
          while_fun_5.(while_fun_5, new_key, steps)
        catch
          {:break, {new_key, steps}} -> {new_key, steps}
        end

      if _len(Enum.at(ht.values, new_key)) < ht.charge_factor do
        throw {:return, new_key}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def insert(ht, data) do
    try do
      key = hash_function(ht, data)
      if _len(Enum.at(ht.values, key)) == 0 || _len(Enum.at(ht.values, key)) < ht.charge_factor do
        set_value(ht, key, data)
        throw {:return, nil}
      end
      dest = collision_resolution(ht, key)
      if dest >= 0 do
        set_value(ht, dest, data)
      else
        IO.puts("table full")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      ht = make_table(3, 2)
      insert(ht, 10)
      insert(ht, 20)
      insert(ht, 30)
      insert(ht, 40)
      insert(ht, 50)
      IO.puts(Kernel.to_string(ht.values))
      IO.puts(Kernel.inspect(balanced_factor(ht)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
