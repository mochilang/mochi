# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def ord(ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(Process.get(:ascii)) do
          if _slice(Process.get(:ascii), i, (i + 1) - i) == ch do
            throw {:return, 32 + i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def new_bloom(size) do
    try do
      bits = []
      i = 0
      while_fun_2 = fn while_fun_2, bits, i ->
        if i < size do
          bits = (bits ++ [0])
          i = i + 1
          while_fun_2.(while_fun_2, bits, i)
        else
          {bits, i}
        end
      end
      {bits, i} = try do
          while_fun_2.(while_fun_2, bits, i)
        catch
          {:break, {bits, i}} -> {bits, i}
        end

      throw {:return, %{size: size, bits: bits}}
    catch
      {:return, val} -> val
    end
  end
  def hash1(value, size) do
    try do
      h = 0
      i = 0
      while_fun_3 = fn while_fun_3, h, i ->
        if i < _len(value) do
          h = rem((h * 31 + ord(_slice(value, i, (i + 1) - i))), size)
          i = i + 1
          while_fun_3.(while_fun_3, h, i)
        else
          {h, i}
        end
      end
      {h, i} = try do
          while_fun_3.(while_fun_3, h, i)
        catch
          {:break, {h, i}} -> {h, i}
        end

      throw {:return, h}
    catch
      {:return, val} -> val
    end
  end
  def hash2(value, size) do
    try do
      h = 0
      i = 0
      while_fun_4 = fn while_fun_4, h, i ->
        if i < _len(value) do
          h = rem((h * 131 + ord(_slice(value, i, (i + 1) - i))), size)
          i = i + 1
          while_fun_4.(while_fun_4, h, i)
        else
          {h, i}
        end
      end
      {h, i} = try do
          while_fun_4.(while_fun_4, h, i)
        catch
          {:break, {h, i}} -> {h, i}
        end

      throw {:return, h}
    catch
      {:return, val} -> val
    end
  end
  def hash_positions(value, size) do
    try do
      h1 = hash1(value, size)
      h2 = hash2(value, size)
      res = []
      res = (res ++ [h1])
      res = (res ++ [h2])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def bloom_add(b, value) do
    try do
      pos = hash_positions(value, b.size)
      bits = b.bits
      i = 0
      while_fun_5 = fn while_fun_5, bits, i ->
        if i < _len(pos) do
          idx = b.size - 1 - Enum.at(pos, i)
          bits = List.replace_at(bits, idx, 1)
          i = i + 1
          while_fun_5.(while_fun_5, bits, i)
        else
          {bits, i}
        end
      end
      {bits, i} = try do
          while_fun_5.(while_fun_5, bits, i)
        catch
          {:break, {bits, i}} -> {bits, i}
        end

      throw {:return, %{size: b.size, bits: bits}}
    catch
      {:return, val} -> val
    end
  end
  def bloom_exists(b, value) do
    try do
      pos = hash_positions(value, b.size)
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(pos) do
          idx = b.size - 1 - Enum.at(pos, i)
          if Enum.at(b.bits, idx) != 1 do
            throw {:return, false}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def bitstring(b) do
    try do
      res = ""
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < b.size do
          res = (res <> Kernel.to_string(Enum.at(b.bits, i)))
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def format_hash(b, value) do
    try do
      pos = hash_positions(value, b.size)
      bits = []
      i = 0
      while_fun_8 = fn while_fun_8, bits, i ->
        if i < b.size do
          bits = (bits ++ [0])
          i = i + 1
          while_fun_8.(while_fun_8, bits, i)
        else
          {bits, i}
        end
      end
      {bits, i} = try do
          while_fun_8.(while_fun_8, bits, i)
        catch
          {:break, {bits, i}} -> {bits, i}
        end

      i = 0
      while_fun_9 = fn while_fun_9, bits, i ->
        if i < _len(pos) do
          idx = b.size - 1 - Enum.at(pos, i)
          bits = List.replace_at(bits, idx, 1)
          i = i + 1
          while_fun_9.(while_fun_9, bits, i)
        else
          {bits, i}
        end
      end
      {bits, i} = try do
          while_fun_9.(while_fun_9, bits, i)
        catch
          {:break, {bits, i}} -> {bits, i}
        end

      res = ""
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < b.size do
          res = (res <> Kernel.to_string(Enum.at(bits, i)))
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def estimated_error_rate(b) do
    try do
      ones = 0
      i = 0
      while_fun_11 = fn while_fun_11, i, ones ->
        if i < b.size do
          {ones} = if Enum.at(b.bits, i) == 1 do
            ones = ones + 1
            {ones}
          else
            {ones}
          end
          i = i + 1
          while_fun_11.(while_fun_11, i, ones)
        else
          {i, ones}
        end
      end
      {i, ones} = try do
          while_fun_11.(while_fun_11, i, ones)
        catch
          {:break, {i, ones}} -> {i, ones}
        end

      frac = (:erlang.float(ones)) / (:erlang.float(b.size))
      throw {:return, frac * frac}
    catch
      {:return, val} -> val
    end
  end
  def any_in(b, items) do
    try do
      i = 0
      while_fun_12 = fn while_fun_12, i ->
        if i < _len(items) do
          if bloom_exists(b, Enum.at(items, i)) do
            throw {:return, true}
          end
          i = i + 1
          while_fun_12.(while_fun_12, i)
        else
          i
        end
      end
      i = try do
          while_fun_12.(while_fun_12, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      bloom = new_bloom(8)
      IO.puts(Kernel.inspect(bitstring(bloom)))
      IO.puts(Kernel.inspect(bloom_exists(bloom, "Titanic")))
      bloom = bloom_add(bloom, "Titanic")
      IO.puts(Kernel.inspect(bitstring(bloom)))
      IO.puts(Kernel.inspect(bloom_exists(bloom, "Titanic")))
      bloom = bloom_add(bloom, "Avatar")
      IO.puts(Kernel.inspect(bloom_exists(bloom, "Avatar")))
      IO.puts(Kernel.inspect(format_hash(bloom, "Avatar")))
      IO.puts(Kernel.inspect(bitstring(bloom)))
      not_present = ["The Godfather", "Interstellar", "Parasite", "Pulp Fiction"]
      i = 0
      while_fun_13 = fn while_fun_13, i ->
        if i < _len(not_present) do
          film = Enum.at(not_present, i)
          IO.puts(((film <> ":") <> format_hash(bloom, film)))
          i = i + 1
          while_fun_13.(while_fun_13, i)
        else
          i
        end
      end
      i = try do
          while_fun_13.(while_fun_13, i)
        catch
          {:break, {i}} -> i
        end

      IO.puts(Kernel.inspect(any_in(bloom, not_present)))
      IO.puts(Kernel.inspect(bloom_exists(bloom, "Ratatouille")))
      IO.puts(Kernel.inspect(format_hash(bloom, "Ratatouille")))
      IO.puts(Kernel.inspect(estimated_error_rate(bloom)))
      bloom = bloom_add(bloom, "The Godfather")
      IO.puts(Kernel.inspect(estimated_error_rate(bloom)))
      IO.puts(Kernel.inspect(bitstring(bloom)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:ascii, " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
  def bench_main() do
    Process.put(:ascii, " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
