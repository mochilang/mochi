# Code generated by Mochi transpiler 2025-08-07 08:34 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def repeat_int(n, val) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < n do
          res = (res ++ [val])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def repeat_bool(n, val) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < n do
          res = (res ++ [val])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def set_int(xs, idx, value) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(xs) do
          res = (if i == idx, do: (res ++ [value]), else: (res ++ [Enum.at(xs, i)]))
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def set_bool(xs, idx, value) do
    try do
      res = []
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(xs) do
          res = (if i == idx, do: (res ++ [value]), else: (res ++ [Enum.at(xs, i)]))
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def create_table(size_table, charge_factor, lim_charge) do
    try do
      throw {:return, %{size_table: size_table, values: repeat_int(size_table, 0), filled: repeat_bool(size_table, false), charge_factor: charge_factor, lim_charge: lim_charge}}
    catch
      {:return, val} -> val
    end
  end
  def hash_function(ht, key) do
    try do
      k = rem(key, ht.size_table)
      {k} = if k < 0 do
        k = k + ht.size_table
        {k}
      else
        {k}
      end
      throw {:return, k}
    catch
      {:return, val} -> val
    end
  end
  def is_prime(n) do
    try do
      if n < 2 do
        throw {:return, false}
      end
      if rem(n, 2) == 0 do
        throw {:return, n == 2}
      end
      i = 3
      while_fun_5 = fn while_fun_5, i ->
        if i * i <= n do
          if rem(n, i) == 0 do
            throw {:return, false}
          end
          i = i + 2
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def next_prime(value, factor) do
    try do
      candidate = value * factor + 1
      while_fun_6 = fn while_fun_6, candidate ->
        if !is_prime(candidate) do
          candidate = candidate + 1
          while_fun_6.(while_fun_6, candidate)
        else
          candidate
        end
      end
      candidate = try do
          while_fun_6.(while_fun_6, candidate)
        catch
          {:break, {candidate}} -> candidate
        end

      throw {:return, candidate}
    catch
      {:return, val} -> val
    end
  end
  def set_value(ht, key, data) do
    try do
      new_values = set_int(ht.values, key, data)
      new_filled = set_bool(ht.filled, key, true)
      throw {:return, %{size_table: ht.size_table, values: new_values, filled: new_filled, charge_factor: ht.charge_factor, lim_charge: ht.lim_charge}}
    catch
      {:return, val} -> val
    end
  end
  def collision_resolution(ht, key) do
    try do
      new_key = hash_function(ht, key + 1)
      steps = 0
      while_fun_7 = fn while_fun_7, new_key, steps ->
        if Enum.at(ht.filled, new_key) do
          new_key = hash_function(ht, new_key + 1)
          steps = steps + 1
          if steps >= ht.size_table do
            throw {:return, -1}
          end
          while_fun_7.(while_fun_7, new_key, steps)
        else
          {new_key, steps}
        end
      end
      {new_key, steps} = try do
          while_fun_7.(while_fun_7, new_key, steps)
        catch
          {:break, {new_key, steps}} -> {new_key, steps}
        end

      throw {:return, new_key}
    catch
      {:return, val} -> val
    end
  end
  def rehashing(ht) do
    try do
      survivors = []
      i = 0
      while_fun_8 = fn while_fun_8, i, survivors ->
        if i < _len(Map.get(ht, :values, [])) do
          {survivors} = if Enum.at(ht.filled, i) do
            survivors = (survivors ++ [Enum.at(ht.values, i)])
            {survivors}
          else
            {survivors}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i, survivors)
        else
          {i, survivors}
        end
      end
      {i, survivors} = try do
          while_fun_8.(while_fun_8, i, survivors)
        catch
          {:break, {i, survivors}} -> {i, survivors}
        end

      new_size = next_prime(ht.size_table, 2)
      new_ht = create_table(new_size, ht.charge_factor, ht.lim_charge)
      i = 0
      while_fun_9 = fn while_fun_9, i, new_ht ->
        if i < _len(survivors) do
          new_ht = insert_data(new_ht, Enum.at(survivors, i))
          i = i + 1
          while_fun_9.(while_fun_9, i, new_ht)
        else
          {i, new_ht}
        end
      end
      {i, new_ht} = try do
          while_fun_9.(while_fun_9, i, new_ht)
        catch
          {:break, {i, new_ht}} -> {i, new_ht}
        end

      throw {:return, new_ht}
    catch
      {:return, val} -> val
    end
  end
  def insert_data(ht, data) do
    try do
      key = hash_function(ht, data)
      if !Enum.at(ht.filled, key) do
        throw {:return, set_value(ht, key, data)}
      end
      if Enum.at(ht.values, key) == data do
        throw {:return, ht}
      end
      new_key = collision_resolution(ht, key)
      if new_key >= 0 do
        throw {:return, set_value(ht, new_key, data)}
      end
      resized = rehashing(ht)
      throw {:return, insert_data(resized, data)}
    catch
      {:return, val} -> val
    end
  end
  def keys(ht) do
    try do
      res = []
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < _len(Map.get(ht, :values, [])) do
          {res} = if Enum.at(ht.filled, i) do
            res = (res ++ [[i, Enum.at(ht.values, i)]])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      ht = create_table(3, 1, 0.75)
      ht = insert_data(ht, 17)
      ht = insert_data(ht, 18)
      ht = insert_data(ht, 99)
      IO.puts(Kernel.inspect(keys(ht)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
