# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_hash_map() do
    try do
      throw {:return, %{entries: []}}
    catch
      {:return, val} -> val
    end
  end
  def hm_len(m) do
    try do
      throw {:return, _len(Map.get(m, :entries, []))}
    catch
      {:return, val} -> val
    end
  end
  def hm_set(m, key, value) do
    try do
      entries = m.entries
      updated = false
      new_entries = []
      i = 0
      while_fun = fn while_fun, i, new_entries, updated ->
        if i < _len(entries) do
          e = Enum.at(entries, i)
          {new_entries, updated} = if e.key == key do
            new_entries = (new_entries ++ [%{key: key, value: value}])
            updated = true
            {new_entries, updated}
          else
            new_entries = (new_entries ++ [e])
            {new_entries, updated}
          end
          i = i + 1
          while_fun.(while_fun, i, new_entries, updated)
        else
          {i, new_entries, updated}
        end
      end
      {i, new_entries, updated} = try do
          while_fun.(while_fun, i, new_entries, updated)
        catch
          {:break, {i, new_entries, updated}} -> {i, new_entries, updated}
        end

      {new_entries} = if !updated do
        new_entries = (new_entries ++ [%{key: key, value: value}])
        {new_entries}
      else
        {new_entries}
      end
      throw {:return, %{entries: new_entries}}
    catch
      {:return, val} -> val
    end
  end
  def hm_get(m, key) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(Map.get(m, :entries, [])) do
          e = Enum.at(m.entries, i)
          if e.key == key do
            throw {:return, %{found: true, value: e.value}}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, %{found: false, value: ""}}
    catch
      {:return, val} -> val
    end
  end
  def hm_del(m, key) do
    try do
      entries = m.entries
      new_entries = []
      removed = false
      i = 0
      while_fun_3 = fn while_fun_3, i, new_entries, removed ->
        if i < _len(entries) do
          e = Enum.at(entries, i)
          {new_entries, removed} = if e.key == key do
            removed = true
            {new_entries, removed}
          else
            new_entries = (new_entries ++ [e])
            {new_entries, removed}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, new_entries, removed)
        else
          {i, new_entries, removed}
        end
      end
      {i, new_entries, removed} = try do
          while_fun_3.(while_fun_3, i, new_entries, removed)
        catch
          {:break, {i, new_entries, removed}} -> {i, new_entries, removed}
        end

      if removed do
        throw {:return, %{map: %{entries: new_entries}, ok: true}}
      end
      throw {:return, %{map: m, ok: false}}
    catch
      {:return, val} -> val
    end
  end
  def test_add_items() do
    try do
      h = make_hash_map()
      h = hm_set(h, "key_a", "val_a")
      h = hm_set(h, "key_b", "val_b")
      a = hm_get(h, "key_a")
      b = hm_get(h, "key_b")
      throw {:return, hm_len(h) == 2 && a.found && b.found && a.value == "val_a" && b.value == "val_b"}
    catch
      {:return, val} -> val
    end
  end
  def test_overwrite_items() do
    try do
      h = make_hash_map()
      h = hm_set(h, "key_a", "val_a")
      h = hm_set(h, "key_a", "val_b")
      a = hm_get(h, "key_a")
      throw {:return, hm_len(h) == 1 && a.found && a.value == "val_b"}
    catch
      {:return, val} -> val
    end
  end
  def test_delete_items() do
    try do
      h = make_hash_map()
      h = hm_set(h, "key_a", "val_a")
      h = hm_set(h, "key_b", "val_b")
      d1 = hm_del(h, "key_a")
      h = d1.map
      d2 = hm_del(h, "key_b")
      h = d2.map
      h = hm_set(h, "key_a", "val_a")
      d3 = hm_del(h, "key_a")
      h = d3.map
      throw {:return, hm_len(h) == 0}
    catch
      {:return, val} -> val
    end
  end
  def test_access_absent_items() do
    try do
      h = make_hash_map()
      g1 = hm_get(h, "key_a")
      d1 = hm_del(h, "key_a")
      h = d1.map
      h = hm_set(h, "key_a", "val_a")
      d2 = hm_del(h, "key_a")
      h = d2.map
      d3 = hm_del(h, "key_a")
      h = d3.map
      g2 = hm_get(h, "key_a")
      throw {:return, g1.found == false && d1.ok == false && d2.ok && d3.ok == false && g2.found == false && hm_len(h) == 0}
    catch
      {:return, val} -> val
    end
  end
  def test_add_with_resize_up() do
    try do
      h = make_hash_map()
      i = 0
      while_fun_4 = fn while_fun_4, h, i ->
        if i < 5 do
          s = Kernel.to_string(i)
          h = hm_set(h, s, s)
          i = i + 1
          while_fun_4.(while_fun_4, h, i)
        else
          {h, i}
        end
      end
      {h, i} = try do
          while_fun_4.(while_fun_4, h, i)
        catch
          {:break, {h, i}} -> {h, i}
        end

      throw {:return, hm_len(h) == 5}
    catch
      {:return, val} -> val
    end
  end
  def test_add_with_resize_down() do
    try do
      h = make_hash_map()
      i = 0
      while_fun_5 = fn while_fun_5, h, i ->
        if i < 5 do
          s = Kernel.to_string(i)
          h = hm_set(h, s, s)
          i = i + 1
          while_fun_5.(while_fun_5, h, i)
        else
          {h, i}
        end
      end
      {h, i} = try do
          while_fun_5.(while_fun_5, h, i)
        catch
          {:break, {h, i}} -> {h, i}
        end

      j = 0
      while_fun_6 = fn while_fun_6, h, j ->
        if j < 5 do
          s = Kernel.to_string(j)
          d = hm_del(h, s)
          h = d.map
          j = j + 1
          while_fun_6.(while_fun_6, h, j)
        else
          {h, j}
        end
      end
      {h, j} = try do
          while_fun_6.(while_fun_6, h, j)
        catch
          {:break, {h, j}} -> {h, j}
        end

      h = hm_set(h, "key_a", "val_b")
      a = hm_get(h, "key_a")
      throw {:return, hm_len(h) == 1 && a.found && a.value == "val_b"}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(test_add_items()))
    IO.puts(Kernel.inspect(test_overwrite_items()))
    IO.puts(Kernel.inspect(test_delete_items()))
    IO.puts(Kernel.inspect(test_access_absent_items()))
    IO.puts(Kernel.inspect(test_add_with_resize_up()))
    IO.puts(Kernel.inspect(test_add_with_resize_down()))
    IO.puts(true)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
