# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def create_hash_table(size) do
    try do
      vals = []
      i = 0
      while_fun = fn while_fun, i, vals ->
        if i < size do
          vals = (vals ++ [nil])
          i = i + 1
          while_fun.(while_fun, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun.(while_fun, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{size_table: size, values: vals, lim_charge: 0.75}}
    catch
      {:return, val} -> val
    end
  end
  def hash_function(table, key) do
    try do
      throw {:return, rem(key, table.size_table)}
    catch
      {:return, val} -> val
    end
  end
  def balanced_factor(table) do
    try do
      count = 0
      i = 0
      while_fun_2 = fn while_fun_2, count, i ->
        if i < _len(Map.get(table, :values, [])) do
          {count} = if Enum.at(table.values, i) != nil do
            count = count + 1
            {count}
          else
            {count}
          end
          i = i + 1
          while_fun_2.(while_fun_2, count, i)
        else
          {count, i}
        end
      end
      {count, i} = try do
          while_fun_2.(while_fun_2, count, i)
        catch
          {:break, {count, i}} -> {count, i}
        end

      throw {:return, (:erlang.float(count)) / (:erlang.float(table.size_table))}
    catch
      {:return, val} -> val
    end
  end
  def collision_resolution(table, key) do
    try do
      i = 1
      new_key = hash_function(table, key + i * i)
      while_fun_3 = fn while_fun_3, i, new_key ->
        if Enum.at(table.values, new_key) != nil && Enum.at(table.values, new_key) != key do
          i = i + 1
          if balanced_factor(table) >= table.lim_charge do
            throw {:return, table.size_table}
          end
          new_key = hash_function(table, key + i * i)
          while_fun_3.(while_fun_3, i, new_key)
        else
          {i, new_key}
        end
      end
      {i, new_key} = try do
          while_fun_3.(while_fun_3, i, new_key)
        catch
          {:break, {i, new_key}} -> {i, new_key}
        end

      throw {:return, new_key}
    catch
      {:return, val} -> val
    end
  end
  def insert_data(table, data) do
    try do
      key = hash_function(table, data)
      vals = table.values
      {table, vals} = if Enum.at(vals, key) == nil do
        vals = List.replace_at(vals, key, data)
        {table, vals}
      else
        {table, vals} = if Enum.at(vals, key) == data do
          table = Map.put(table, :values, vals)
          throw {:return, nil}
          {table, vals}
        else
          new_key = collision_resolution(table, key)
          {vals} = if new_key < _len(vals) && Enum.at(vals, new_key) == nil do
            vals = List.replace_at(vals, new_key, data)
            {vals}
          else
            {vals}
          end
          {table, vals}
        end
        {table, vals}
      end
      table = Map.put(table, :values, vals)
    catch
      {:return, val} -> val
    end
  end
  def int_to_string(n) do
    try do
      if n == 0 do
        throw {:return, "0"}
      end
      num = n
      neg = false
      {neg, num} = if num < 0 do
        neg = true
        num = -num
        {neg, num}
      else
        {neg, num}
      end
      res = ""
      while_fun_4 = fn while_fun_4, num, res ->
        if num > 0 do
          digit = rem(num, 10)
          ch = _slice("0123456789", digit, digit + 1 - (digit))
          res = (ch <> res)
          num = div(num, 10)
          while_fun_4.(while_fun_4, num, res)
        else
          {num, res}
        end
      end
      {num, res} = try do
          while_fun_4.(while_fun_4, num, res)
        catch
          {:break, {num, res}} -> {num, res}
        end

      {res} = if neg do
        res = ("-" <> res)
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def keys_to_string(table) do
    try do
      result = "{"
      first = true
      i = 0
      while_fun_5 = fn while_fun_5, first, i, result ->
        if i < _len(Map.get(table, :values, [])) do
          v = Enum.at(table.values, i)
          {first, result} = if v != nil do
            {result} = if !first do
              result = (result <> ", ")
              {result}
            else
              {result}
            end
            result = (((result <> int_to_string(i)) <> ": ") <> int_to_string(v))
            first = false
            {first, result}
          else
            {first, result}
          end
          i = i + 1
          while_fun_5.(while_fun_5, first, i, result)
        else
          {first, i, result}
        end
      end
      {first, i, result} = try do
          while_fun_5.(while_fun_5, first, i, result)
        catch
          {:break, {first, i, result}} -> {first, i, result}
        end

      result = (result <> "}")
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:qp, create_hash_table(8))
    insert_data(Process.get(:qp), 0)
    insert_data(Process.get(:qp), 999)
    insert_data(Process.get(:qp), 111)
    IO.puts(Kernel.inspect(keys_to_string(Process.get(:qp))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
