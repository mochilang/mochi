# Code generated by Mochi transpiler 2025-08-07 08:34 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_buckets(n) do
    try do
      buckets = []
      i = 0
      while_fun = fn while_fun, buckets, i ->
        if i < n do
          buckets = (buckets ++ [%{state: 0, key: 0, val: 0}])
          i = i + 1
          while_fun.(while_fun, buckets, i)
        else
          {buckets, i}
        end
      end
      {buckets, i} = try do
          while_fun.(while_fun, buckets, i)
        catch
          {:break, {buckets, i}} -> {buckets, i}
        end

      throw {:return, buckets}
    catch
      {:return, val} -> val
    end
  end
  def hashmap_new(initial_size) do
    try do
      throw {:return, %{buckets: make_buckets(initial_size), len: 0, cap_num: 3, cap_den: 4, initial_size: initial_size}}
    catch
      {:return, val} -> val
    end
  end
  def bucket_index(hm, key) do
    try do
      ind = rem(key, _len(Map.get(hm, :buckets, [])))
      {ind} = if ind < 0 do
        ind = ind + _len(Map.get(hm, :buckets, []))
        {ind}
      else
        {ind}
      end
      throw {:return, ind}
    catch
      {:return, val} -> val
    end
  end
  def next_index(hm, ind) do
    try do
      throw {:return, rem((ind + 1), _len(Map.get(hm, :buckets, [])))}
    catch
      {:return, val} -> val
    end
  end
  def try_set(hm, ind, key, val) do
    try do
      buckets = hm.buckets
      b = Enum.at(buckets, ind)
      {buckets} = if b.state == 0 || b.state == 2 do
        buckets = List.replace_at(buckets, ind, %{state: 1, key: key, val: val})
        hm = Map.put(hm, :buckets, buckets)
        hm = Map.put(hm, :len, hm.len + 1)
        throw {:return, true}
        {buckets}
      else
        {buckets}
      end
      {buckets} = if b.key == key do
        buckets = List.replace_at(buckets, ind, %{state: 1, key: key, val: val})
        hm = Map.put(hm, :buckets, buckets)
        throw {:return, true}
        {buckets}
      else
        {buckets}
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_full(hm) do
    try do
      limit = div(_len(Map.get(hm, :buckets, [])) * hm.cap_num, hm.cap_den)
      throw {:return, hm.len >= limit}
    catch
      {:return, val} -> val
    end
  end
  def is_sparse(hm) do
    try do
      if _len(Map.get(hm, :buckets, [])) <= hm.initial_size do
        throw {:return, false}
      end
      limit = div(_len(Map.get(hm, :buckets, [])) * hm.cap_num, (2 * hm.cap_den))
      throw {:return, hm.len < limit}
    catch
      {:return, val} -> val
    end
  end
  def resize(hm, new_size) do
    try do
      old = hm.buckets
      hm = Map.put(hm, :buckets, make_buckets(new_size))
      hm = Map.put(hm, :len, 0)
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(old) do
          it = Enum.at(old, i)
          if it.state == 1 do
            add_item(hm, it.key, it.val)
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def size_up(hm) do
    try do
      resize(hm, _len(Map.get(hm, :buckets, [])) * 2)
    catch
      {:return, val} -> val
    end
  end
  def size_down(hm) do
    try do
      resize(hm, div(_len(Map.get(hm, :buckets, [])), 2))
    catch
      {:return, val} -> val
    end
  end
  def add_item(hm, key, val) do
    try do
      ind = bucket_index(hm, key)
      i = 0
      while_fun_3 = fn while_fun_3, i, ind ->
        if i < _len(Map.get(hm, :buckets, [])) do
          if try_set(hm, ind, key, val) do
            throw {:break, {i, ind}}
          end
          ind = next_index(hm, ind)
          i = i + 1
          while_fun_3.(while_fun_3, i, ind)
        else
          {i, ind}
        end
      end
      {i, ind} = try do
          while_fun_3.(while_fun_3, i, ind)
        catch
          {:break, {i, ind}} -> {i, ind}
        end

    catch
      {:return, val} -> val
    end
  end
  def hashmap_set(hm, key, val) do
    try do
      if is_full(hm) do
        size_up(hm)
      end
      add_item(hm, key, val)
    catch
      {:return, val} -> val
    end
  end
  def hashmap_get(hm, key) do
    try do
      buckets = hm.buckets
      ind = bucket_index(hm, key)
      i = 0
      while_fun_4 = fn while_fun_4, i, ind ->
        if i < _len(buckets) do
          it = Enum.at(buckets, ind)
          if it.state == 0 do
            throw {:break, {i, ind}}
          end
          if it.state == 1 && it.key == key do
            throw {:return, it.val}
          end
          ind = next_index(hm, ind)
          i = i + 1
          while_fun_4.(while_fun_4, i, ind)
        else
          {i, ind}
        end
      end
      {i, ind} = try do
          while_fun_4.(while_fun_4, i, ind)
        catch
          {:break, {i, ind}} -> {i, ind}
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def hashmap_del(hm, key) do
    try do
      buckets = hm.buckets
      ind = bucket_index(hm, key)
      i = 0
      while_fun_5 = fn while_fun_5, buckets, i, ind ->
        if i < _len(buckets) do
          it = Enum.at(buckets, ind)
          if it.state == 0 do
            IO.puts(("KeyError: " <> Kernel.to_string(key)))
            throw {:return, nil}
          end
          {buckets} = if it.state == 1 && it.key == key do
            buckets = List.replace_at(buckets, ind, %{state: 2, key: 0, val: 0})
            hm = Map.put(hm, :buckets, buckets)
            hm = Map.put(hm, :len, hm.len - 1)
            throw {:break, {buckets, i, ind}}
            {buckets}
          else
            {buckets}
          end
          ind = next_index(hm, ind)
          i = i + 1
          while_fun_5.(while_fun_5, buckets, i, ind)
        else
          {buckets, i, ind}
        end
      end
      {buckets, i, ind} = try do
          while_fun_5.(while_fun_5, buckets, i, ind)
        catch
          {:break, {buckets, i, ind}} -> {buckets, i, ind}
        end

      if is_sparse(hm) do
        size_down(hm)
      end
    catch
      {:return, val} -> val
    end
  end
  def hashmap_len(hm) do
    try do
      throw {:return, hm.len}
    catch
      {:return, val} -> val
    end
  end
  def hashmap_repr(hm) do
    try do
      out = "HashMap("
      first = true
      i = 0
      while_fun_6 = fn while_fun_6, first, i, out ->
        if i < _len(Map.get(hm, :buckets, [])) do
          b = Enum.at(hm.buckets, i)
          {first, out} = if b.state == 1 do
            {first, out} = if !first do
              out = (out <> ", ")
              {first, out}
            else
              first = false
              {first, out}
            end
            out = (((out <> Kernel.to_string(b.key)) <> ": ") <> Kernel.to_string(b.val))
            {first, out}
          else
            {first, out}
          end
          i = i + 1
          while_fun_6.(while_fun_6, first, i, out)
        else
          {first, i, out}
        end
      end
      {first, i, out} = try do
          while_fun_6.(while_fun_6, first, i, out)
        catch
          {:break, {first, i, out}} -> {first, i, out}
        end

      out = (out <> ")")
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:hm, hashmap_new(5))
    hashmap_set(Process.get(:hm), 1, 10)
    hashmap_set(Process.get(:hm), 2, 20)
    hashmap_set(Process.get(:hm), 3, 30)
    IO.puts(Kernel.inspect(hashmap_repr(Process.get(:hm))))
    IO.puts(Kernel.inspect(hashmap_get(Process.get(:hm), 2)))
    hashmap_del(Process.get(:hm), 1)
    IO.puts(Kernel.inspect(hashmap_repr(Process.get(:hm))))
    IO.puts(Kernel.inspect(hashmap_len(Process.get(:hm))))
  end
end
Main.main()
