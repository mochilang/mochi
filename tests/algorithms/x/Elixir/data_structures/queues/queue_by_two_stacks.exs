# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_queue(items) do
    try do
      throw {:return, %{stack1: items, stack2: []}}
    catch
      {:return, val} -> val
    end
  end
  def len_queue(q) do
    try do
      throw {:return, _len(Map.get(q, :stack1, [])) + _len(Map.get(q, :stack2, []))}
    catch
      {:return, val} -> val
    end
  end
  def str_queue(q) do
    try do
      items = []
      i = _len(Map.get(q, :stack2, [])) - 1
      while_fun = fn while_fun, i, items ->
        if i >= 0 do
          items = (items ++ [Enum.at(q.stack2, i)])
          i = i - 1
          while_fun.(while_fun, i, items)
        else
          {i, items}
        end
      end
      {i, items} = try do
          while_fun.(while_fun, i, items)
        catch
          {:break, {i, items}} -> {i, items}
        end

      j = 0
      while_fun_2 = fn while_fun_2, items, j ->
        if j < _len(Map.get(q, :stack1, [])) do
          items = (items ++ [Enum.at(q.stack1, j)])
          j = j + 1
          while_fun_2.(while_fun_2, items, j)
        else
          {items, j}
        end
      end
      {items, j} = try do
          while_fun_2.(while_fun_2, items, j)
        catch
          {:break, {items, j}} -> {items, j}
        end

      s = "Queue(("
      k = 0
      while_fun_3 = fn while_fun_3, k, s ->
        if k < _len(items) do
          s = (s <> Kernel.to_string(Enum.at(items, k)))
          {s} = if k < _len(items) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          k = k + 1
          while_fun_3.(while_fun_3, k, s)
        else
          {k, s}
        end
      end
      {k, s} = try do
          while_fun_3.(while_fun_3, k, s)
        catch
          {:break, {k, s}} -> {k, s}
        end

      s = (s <> "))")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def put(q, item) do
    try do
      s1 = q.stack1
      s1 = (s1 ++ [item])
      throw {:return, %{stack1: s1, stack2: q.stack2}}
    catch
      {:return, val} -> val
    end
  end
  def get(q) do
    try do
      s1 = q.stack1
      s2 = q.stack2
      {s1, s2} = if _len(s2) == 0 do
        while_fun_4 = fn while_fun_4, s1, s2 ->
          if _len(s1) > 0 do
            idx = _len(s1) - 1
            v = Enum.at(s1, idx)
            new_s1 = []
            i = 0
            while_fun_5 = fn while_fun_5, i, new_s1 ->
              if i < idx do
                new_s1 = (new_s1 ++ [Enum.at(s1, i)])
                i = i + 1
                while_fun_5.(while_fun_5, i, new_s1)
              else
                {i, new_s1}
              end
            end
            {i, new_s1} = try do
                while_fun_5.(while_fun_5, i, new_s1)
              catch
                {:break, {i, new_s1}} -> {i, new_s1}
              end

            s1 = new_s1
            s2 = (s2 ++ [v])
            while_fun_4.(while_fun_4, s1, s2)
          else
            {s1, s2}
          end
        end
        {s1, s2} = try do
            while_fun_4.(while_fun_4, s1, s2)
          catch
            {:break, {s1, s2}} -> {s1, s2}
          end

        {s1, s2}
      else
        {s1, s2}
      end
      if _len(s2) == 0 do
        raise("Queue is empty")
      end
      idx2 = _len(s2) - 1
      value = Enum.at(s2, idx2)
      new_s2 = []
      j = 0
      while_fun_6 = fn while_fun_6, j, new_s2 ->
        if j < idx2 do
          new_s2 = (new_s2 ++ [Enum.at(s2, j)])
          j = j + 1
          while_fun_6.(while_fun_6, j, new_s2)
        else
          {j, new_s2}
        end
      end
      {j, new_s2} = try do
          while_fun_6.(while_fun_6, j, new_s2)
        catch
          {:break, {j, new_s2}} -> {j, new_s2}
        end

      s2 = new_s2
      throw {:return, %{queue: %{stack1: s1, stack2: s2}, value: value}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:q, new_queue([10, 20, 30]))
    Process.put(:r1, get(Process.get(:q)))
    Process.put(:q, Process.get(:r1).queue)
    IO.puts(Process.get(:r1).value)
    Process.put(:q, put(Process.get(:q), 40))
    Process.put(:r2, get(Process.get(:q)))
    Process.put(:q, Process.get(:r2).queue)
    IO.puts(Process.get(:r2).value)
    Process.put(:r3, get(Process.get(:q)))
    Process.put(:q, Process.get(:r3).queue)
    IO.puts(Process.get(:r3).value)
    IO.puts(Kernel.inspect(len_queue(Process.get(:q))))
    Process.put(:r4, get(Process.get(:q)))
    Process.put(:q, Process.get(:r4).queue)
    IO.puts(Process.get(:r4).value)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
