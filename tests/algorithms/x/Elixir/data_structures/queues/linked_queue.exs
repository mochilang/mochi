# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_queue() do
    try do
      throw {:return, %{nodes: [], front: 0 - 1, rear: 0 - 1}}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(q) do
    try do
      throw {:return, q.front == 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def put(q, item) do
    try do
      node_ = %{data: item, next: 0 - 1}
      q = Map.put(q, :nodes, (q.nodes ++ [node_]))
      idx = _len(Map.get(q, :nodes, [])) - 1
      {q} = if q.front == 0 - 1 do
        q = Map.put(q, :front, idx)
        q = Map.put(q, :rear, idx)
        {q}
      else
        nodes = q.nodes
        nodes = List.replace_at(nodes, q.rear, Map.put(Enum.at(nodes, q.rear), :next, idx))
        q = Map.put(q, :nodes, nodes)
        q = Map.put(q, :rear, idx)
        {q}
      end
    catch
      {:return, val} -> val
    end
  end
  def get(q) do
    try do
      if is_empty(q) do
        raise("dequeue from empty queue")
      end
      idx = q.front
      node_ = Enum.at(q.nodes, idx)
      q = Map.put(q, :front, node_.next)
      {q} = if q.front == 0 - 1 do
        q = Map.put(q, :rear, 0 - 1)
        {q}
      else
        {q}
      end
      throw {:return, node_.data}
    catch
      {:return, val} -> val
    end
  end
  def length(q) do
    try do
      count = 0
      idx = q.front
      while_fun = fn while_fun, count, idx ->
        if idx != 0 - 1 do
          count = count + 1
          idx = Enum.at(q.nodes, idx)["next"]
          while_fun.(while_fun, count, idx)
        else
          {count, idx}
        end
      end
      {count, idx} = try do
          while_fun.(while_fun, count, idx)
        catch
          {:break, {count, idx}} -> {count, idx}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def to_string(q) do
    try do
      res = ""
      idx = q.front
      first = true
      while_fun_2 = fn while_fun_2, first, idx, res ->
        if idx != 0 - 1 do
          node_ = Enum.at(q.nodes, idx)
          {first, res} = if first do
            res = node_.data
            first = false
            {first, res}
          else
            res = ((res <> " <- ") <> node_.data)
            {first, res}
          end
          idx = node_.next
          while_fun_2.(while_fun_2, first, idx, res)
        else
          {first, idx, res}
        end
      end
      {first, idx, res} = try do
          while_fun_2.(while_fun_2, first, idx, res)
        catch
          {:break, {first, idx, res}} -> {first, idx, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def clear(q) do
    try do
      q = Map.put(q, :nodes, [])
      q = Map.put(q, :front, 0 - 1)
      q = Map.put(q, :rear, 0 - 1)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:queue, new_queue())
    IO.puts(Kernel.inspect(is_empty(Process.get(:queue))))
    put(Process.get(:queue), "5")
    put(Process.get(:queue), "9")
    put(Process.get(:queue), "python")
    IO.puts(Kernel.inspect(is_empty(Process.get(:queue))))
    IO.puts(Kernel.inspect(get(Process.get(:queue))))
    put(Process.get(:queue), "algorithms")
    IO.puts(Kernel.inspect(get(Process.get(:queue))))
    IO.puts(Kernel.inspect(get(Process.get(:queue))))
    IO.puts(Kernel.inspect(get(Process.get(:queue))))
    IO.puts(Kernel.inspect(is_empty(Process.get(:queue))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
