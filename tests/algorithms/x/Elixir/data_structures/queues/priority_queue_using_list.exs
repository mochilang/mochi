# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def panic(msg) do
    try do
      IO.puts(msg)
    catch
      {:return, val} -> val
    end
  end
  def fpq_new() do
    try do
      throw {:return, %{queues: [[], [], []]}}
    catch
      {:return, val} -> val
    end
  end
  def fpq_enqueue(fpq, priority, data) do
    try do
      if priority < 0 || priority >= _len(Map.get(fpq, :queues, [])) do
        panic("Valid priorities are 0, 1, and 2")
        throw {:return, fpq}
      end
      if _len(Enum.at(fpq.queues, priority)) >= 100 do
        panic("Maximum queue size is 100")
        throw {:return, fpq}
      end
      qs = fpq.queues
      qs = List.replace_at(qs, priority, (Enum.at(qs, priority) ++ [data]))
      fpq = Map.put(fpq, :queues, qs)
      throw {:return, fpq}
    catch
      {:return, val} -> val
    end
  end
  def fpq_dequeue(fpq) do
    try do
      qs = fpq.queues
      i = 0
      while_fun = fn while_fun, fpq, i, qs ->
        if i < _len(qs) do
          q = Enum.at(qs, i)
          {fpq, qs} = if _len(q) > 0 do
            val = Enum.at(q, 0)
            new_q = []
            j = 1
            while_fun_2 = fn while_fun_2, j, new_q ->
              if j < _len(q) do
                new_q = (new_q ++ [Enum.at(q, j)])
                j = j + 1
                while_fun_2.(while_fun_2, j, new_q)
              else
                {j, new_q}
              end
            end
            {j, new_q} = try do
                while_fun_2.(while_fun_2, j, new_q)
              catch
                {:break, {j, new_q}} -> {j, new_q}
              end

            qs = List.replace_at(qs, i, new_q)
            fpq = Map.put(fpq, :queues, qs)
            throw {:return, %{queue: fpq, value: val}}
            {fpq, qs}
          else
            {fpq, qs}
          end
          i = i + 1
          while_fun.(while_fun, fpq, i, qs)
        else
          {fpq, i, qs}
        end
      end
      {fpq, i, qs} = try do
          while_fun.(while_fun, fpq, i, qs)
        catch
          {:break, {fpq, i, qs}} -> {fpq, i, qs}
        end

      panic("All queues are empty")
      throw {:return, %{queue: fpq, value: 0}}
    catch
      {:return, val} -> val
    end
  end
  def fpq_to_string(fpq) do
    try do
      lines = []
      i = 0
      while_fun_3 = fn while_fun_3, i, lines ->
        if i < _len(Map.get(fpq, :queues, [])) do
          q_str = "["
          q = Enum.at(fpq.queues, i)
          j = 0
          while_fun_4 = fn while_fun_4, j, q_str ->
            if j < _len(q) do
              {q_str} = if j > 0 do
                q_str = (q_str <> ", ")
                {q_str}
              else
                {q_str}
              end
              q_str = (q_str <> Kernel.to_string(Enum.at(q, j)))
              j = j + 1
              while_fun_4.(while_fun_4, j, q_str)
            else
              {j, q_str}
            end
          end
          {j, q_str} = try do
              while_fun_4.(while_fun_4, j, q_str)
            catch
              {:break, {j, q_str}} -> {j, q_str}
            end

          q_str = (q_str <> "]")
          lines = (lines ++ [((("Priority " <> Kernel.to_string(i)) <> ": ") <> q_str)])
          i = i + 1
          while_fun_3.(while_fun_3, i, lines)
        else
          {i, lines}
        end
      end
      {i, lines} = try do
          while_fun_3.(while_fun_3, i, lines)
        catch
          {:break, {i, lines}} -> {i, lines}
        end

      res = ""
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(lines) do
          {res} = if i > 0 do
            res = (res <> "\n")
            {res}
          else
            {res}
          end
          res = (res <> Enum.at(lines, i))
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def epq_new() do
    try do
      throw {:return, %{queue: []}}
    catch
      {:return, val} -> val
    end
  end
  def epq_enqueue(epq, data) do
    try do
      if _len(Map.get(epq, :queue, [])) >= 100 do
        panic("Maximum queue size is 100")
        throw {:return, epq}
      end
      epq = Map.put(epq, :queue, (epq.queue ++ [data]))
      throw {:return, epq}
    catch
      {:return, val} -> val
    end
  end
  def epq_dequeue(epq) do
    try do
      if _len(Map.get(epq, :queue, [])) == 0 do
        panic("The queue is empty")
        throw {:return, %{queue: epq, value: 0}}
      end
      min_val = Enum.at(epq.queue, 0)
      idx = 0
      i = 1
      while_fun_6 = fn while_fun_6, i, idx, min_val ->
        if i < _len(Map.get(epq, :queue, [])) do
          v = Enum.at(epq.queue, i)
          {idx, min_val} = if v < min_val do
            min_val = v
            idx = i
            {idx, min_val}
          else
            {idx, min_val}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, idx, min_val)
        else
          {i, idx, min_val}
        end
      end
      {i, idx, min_val} = try do
          while_fun_6.(while_fun_6, i, idx, min_val)
        catch
          {:break, {i, idx, min_val}} -> {i, idx, min_val}
        end

      new_q = []
      i = 0
      while_fun_7 = fn while_fun_7, i, new_q ->
        if i < _len(Map.get(epq, :queue, [])) do
          {new_q} = if i != idx do
            new_q = (new_q ++ [Enum.at(epq.queue, i)])
            {new_q}
          else
            {new_q}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, new_q)
        else
          {i, new_q}
        end
      end
      {i, new_q} = try do
          while_fun_7.(while_fun_7, i, new_q)
        catch
          {:break, {i, new_q}} -> {i, new_q}
        end

      epq = Map.put(epq, :queue, new_q)
      throw {:return, %{queue: epq, value: min_val}}
    catch
      {:return, val} -> val
    end
  end
  def epq_to_string(epq) do
    try do
      throw {:return, String.replace(IO.iodata_to_binary(:io_lib.format("~w", [epq.queue])), ",", " ")}
    catch
      {:return, val} -> val
    end
  end
  def fixed_priority_queue() do
    try do
      fpq = fpq_new()
      fpq = fpq_enqueue(fpq, 0, 10)
      fpq = fpq_enqueue(fpq, 1, 70)
      fpq = fpq_enqueue(fpq, 0, 100)
      fpq = fpq_enqueue(fpq, 2, 1)
      fpq = fpq_enqueue(fpq, 2, 5)
      fpq = fpq_enqueue(fpq, 1, 7)
      fpq = fpq_enqueue(fpq, 2, 4)
      fpq = fpq_enqueue(fpq, 1, 64)
      fpq = fpq_enqueue(fpq, 0, 128)
      IO.puts(Kernel.inspect(fpq_to_string(fpq)))
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      IO.puts(Kernel.inspect(fpq_to_string(fpq)))
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
      res = fpq_dequeue(fpq)
      fpq = res.queue
      IO.puts(res.value)
    catch
      {:return, val} -> val
    end
  end
  def element_priority_queue() do
    try do
      epq = epq_new()
      epq = epq_enqueue(epq, 10)
      epq = epq_enqueue(epq, 70)
      epq = epq_enqueue(epq, 100)
      epq = epq_enqueue(epq, 1)
      epq = epq_enqueue(epq, 5)
      epq = epq_enqueue(epq, 7)
      epq = epq_enqueue(epq, 4)
      epq = epq_enqueue(epq, 64)
      epq = epq_enqueue(epq, 128)
      IO.puts(Kernel.inspect(epq_to_string(epq)))
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      IO.puts(Kernel.inspect(epq_to_string(epq)))
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
      res = epq_dequeue(epq)
      epq = res.queue
      IO.puts(res.value)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      fixed_priority_queue()
      element_priority_queue()
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
