# Code generated by Mochi transpiler 2025-08-07 08:34 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def max_list(xs) do
    try do
      m = Enum.at(xs, 0)
      i = 1
      while_fun = fn while_fun, i, m ->
        if i < _len(xs) do
          {m} = if Enum.at(xs, i) > m do
            m = Enum.at(xs, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun.(while_fun, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun.(while_fun, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def disjoint_set_new(set_counts) do
    try do
      max_set = max_list(set_counts)
      num_sets = _len(set_counts)
      ranks = []
      parents = []
      i = 0
      while_fun_2 = fn while_fun_2, i, parents, ranks ->
        if i < num_sets do
          ranks = (ranks ++ [1])
          parents = (parents ++ [i])
          i = i + 1
          while_fun_2.(while_fun_2, i, parents, ranks)
        else
          {i, parents, ranks}
        end
      end
      {i, parents, ranks} = try do
          while_fun_2.(while_fun_2, i, parents, ranks)
        catch
          {:break, {i, parents, ranks}} -> {i, parents, ranks}
        end

      throw {:return, %{set_counts: set_counts, max_set: max_set, ranks: ranks, parents: parents}}
    catch
      {:return, val} -> val
    end
  end
  def get_parent(ds, idx) do
    try do
      if Enum.at(ds.parents, idx) == idx do
        throw {:return, idx}
      end
      parents = ds.parents
      parents = List.replace_at(parents, idx, get_parent(ds, Enum.at(parents, idx)))
      ds = Map.put(ds, :parents, parents)
      throw {:return, Enum.at(ds.parents, idx)}
    catch
      {:return, val} -> val
    end
  end
  def merge(ds, src, dst) do
    try do
      src_parent = get_parent(ds, src)
      dst_parent = get_parent(ds, dst)
      if src_parent == dst_parent do
        throw {:return, false}
      end
      if Enum.at(ds.ranks, dst_parent) >= Enum.at(ds.ranks, src_parent) do
        counts = ds.set_counts
        counts = List.replace_at(counts, dst_parent, Enum.at(counts, dst_parent) + Enum.at(counts, src_parent))
        counts = List.replace_at(counts, src_parent, 0)
        ds = Map.put(ds, :set_counts, counts)
        parents = ds.parents
        parents = List.replace_at(parents, src_parent, dst_parent)
        ds = Map.put(ds, :parents, parents)
        if Enum.at(ds.ranks, dst_parent) == Enum.at(ds.ranks, src_parent) do
          ranks = ds.ranks
          ranks = List.replace_at(ranks, dst_parent, Enum.at(ranks, dst_parent) + 1)
          ds = Map.put(ds, :ranks, ranks)
        end
        joined = Enum.at(ds.set_counts, dst_parent)
        if joined > ds.max_set do
          ds = Map.put(ds, :max_set, joined)
        end
      else
        counts = ds.set_counts
        counts = List.replace_at(counts, src_parent, Enum.at(counts, src_parent) + Enum.at(counts, dst_parent))
        counts = List.replace_at(counts, dst_parent, 0)
        ds = Map.put(ds, :set_counts, counts)
        parents = ds.parents
        parents = List.replace_at(parents, dst_parent, src_parent)
        ds = Map.put(ds, :parents, parents)
        joined = Enum.at(ds.set_counts, src_parent)
        if joined > ds.max_set do
          ds = Map.put(ds, :max_set, joined)
        end
      end
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:ds, disjoint_set_new([1, 1, 1]))
    IO.puts(Kernel.inspect(merge(Process.get(:ds), 1, 2)))
    IO.puts(Kernel.inspect(merge(Process.get(:ds), 0, 2)))
    IO.puts(Kernel.inspect(merge(Process.get(:ds), 0, 1)))
    IO.puts(Kernel.inspect(get_parent(Process.get(:ds), 0)))
    IO.puts(Kernel.inspect(get_parent(Process.get(:ds), 1)))
    IO.puts(Process.get(:ds).max_set)
  end
end
Main.main()
