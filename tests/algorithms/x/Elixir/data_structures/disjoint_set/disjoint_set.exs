# Code generated by Mochi transpiler 2025-08-07 16:23 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def make_set(ds, x) do
    try do
      p = ds.parent
      r = ds.rank
      p = List.replace_at(p, x, x)
      r = List.replace_at(r, x, 0)
      throw {:return, %{parent: p, rank: r}}
    catch
      {:return, val} -> val
    end
  end
  def find_set(ds, x) do
    try do
      if Enum.at(ds.parent, x) == x do
        throw {:return, %{ds: ds, root: x}}
      end
      res = find_set(ds, Enum.at(ds.parent, x))
      p = res.ds.parent
      p = List.replace_at(p, x, res.root)
      throw {:return, %{ds: %{parent: p, rank: res.ds.rank}, root: res.root}}
    catch
      {:return, val} -> val
    end
  end
  def union_set(ds, x, y) do
    try do
      fx = find_set(ds, x)
      ds1 = fx.ds
      x_root = fx.root
      fy = find_set(ds1, y)
      ds2 = fy.ds
      y_root = fy.root
      if x_root == y_root do
        throw {:return, ds2}
      end
      p = ds2.parent
      r = ds2.rank
      {p, r} = if Enum.at(r, x_root) > Enum.at(r, y_root) do
        p = List.replace_at(p, y_root, x_root)
        {p, r}
      else
        p = List.replace_at(p, x_root, y_root)
        {r} = if Enum.at(r, x_root) == Enum.at(r, y_root) do
          r = List.replace_at(r, y_root, Enum.at(r, y_root) + 1)
          {r}
        else
          {r}
        end
        {p, r}
      end
      throw {:return, %{parent: p, rank: r}}
    catch
      {:return, val} -> val
    end
  end
  def same_python_set(a, b) do
    try do
      if a < 3 && b < 3 do
        throw {:return, true}
      end
      if a >= 3 && a < 6 && b >= 3 && b < 6 do
        throw {:return, true}
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:ds, %{parent: [], rank: []})
  Process.put(:i, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    while_fun = fn while_fun ->
      if Process.get(:i) < 6 do
        Process.put(:ds, Map.put(Process.get(:ds), :parent, (Process.get(:ds).parent ++ [0])))
        Process.put(:ds, Map.put(Process.get(:ds), :rank, (Process.get(:ds).rank ++ [0])))
        Process.put(:ds, make_set(Process.get(:ds), Process.get(:i)))
        Process.put(:i, Process.get(:i) + 1)
        while_fun.(while_fun)
      else
        nil
      end
    end
    try do
      while_fun.(while_fun)
    catch
      :break -> nil
    end

    Process.put(:ds, union_set(Process.get(:ds), 0, 1))
    Process.put(:ds, union_set(Process.get(:ds), 1, 2))
    Process.put(:ds, union_set(Process.get(:ds), 3, 4))
    Process.put(:ds, union_set(Process.get(:ds), 3, 5))
    Process.put(:i, 0)
    while_fun_2 = fn while_fun_2 ->
      if Process.get(:i) < 6 do
        j = 0
        while_fun_3 = fn while_fun_3, j ->
          if j < 6 do
            res_i = find_set(Process.get(:ds), Process.get(:i))
            Process.put(:ds, res_i.ds)
            root_i = res_i.root
            res_j = find_set(Process.get(:ds), j)
            Process.put(:ds, res_j.ds)
            root_j = res_j.root
            same = same_python_set(Process.get(:i), j)
            root_same = root_i == root_j
            if same do
              if !root_same do
                raise("nodes should be in same set")
              end
            else
              if root_same do
                raise("nodes should be in different sets")
              end
            end
            j = j + 1
            while_fun_3.(while_fun_3, j)
          else
            j
          end
        end
        j = try do
            while_fun_3.(while_fun_3, j)
          catch
            {:break, {j}} -> j
          end

        Process.put(:i, Process.get(:i) + 1)
        while_fun_2.(while_fun_2)
      else
        nil
      end
    end
    try do
      while_fun_2.(while_fun_2)
    catch
      :break -> nil
    end

    Process.put(:i, 0)
    while_fun_4 = fn while_fun_4 ->
      if Process.get(:i) < 6 do
        res = find_set(Process.get(:ds), Process.get(:i))
        Process.put(:ds, res.ds)
        IO.puts(Kernel.to_string(res.root))
        Process.put(:i, Process.get(:i) + 1)
        while_fun_4.(while_fun_4)
      else
        nil
      end
    end
    try do
      while_fun_4.(while_fun_4)
    catch
      :break -> nil
    end

    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
