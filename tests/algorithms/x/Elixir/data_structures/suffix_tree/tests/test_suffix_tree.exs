# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def suffix_tree_new(text) do
    try do
      throw {:return, %{text: text}}
    catch
      {:return, val} -> val
    end
  end
  def suffix_tree_search(st, pattern) do
    try do
      if _len(pattern) == 0 do
        throw {:return, true}
      end
      i = 0
      n = _len(Map.get(st, :text, ""))
      m = _len(pattern)
      while_fun = fn while_fun ->
        if i <= n - m do
          j = 0
          found = true
          while_fun_2 = fn while_fun_2, found, j ->
            if j < m do
              {found} = if String.at(st.text, i + j) != String.at(pattern, j) do
                found = false
                throw {:break, {found, j}}
                {found}
              else
                {found}
              end
              j = j + 1
              while_fun_2.(while_fun_2, found, j)
            else
              {found, j}
            end
          end
          {found, j} = try do
              while_fun_2.(while_fun_2, found, j)
            catch
              {:break, {found, j}} -> {found, j}
            end

          if found do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun)
        else
          nil
        end
      end
      try do
        while_fun.(while_fun)
      catch
        :break -> nil
      end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:text, "banana")
  Process.put(:patterns_exist, ["ana", "ban", "na"])
  Process.put(:i, 0)
  Process.put(:patterns_none, ["xyz", "apple", "cat"])
  Process.put(:substrings, ["ban", "ana", "a", "na"])
  def main() do
    Process.put(:st, suffix_tree_new(Process.get(:text)))
    while_fun_3 = fn while_fun_3 ->
      if Process.get(:i) < _len(Process.get(:patterns_exist)) do
        IO.puts(Kernel.inspect(suffix_tree_search(Process.get(:st), Enum.at(Process.get(:patterns_exist), Process.get(:i)))))
        Process.put(:i, Process.get(:i) + 1)
        while_fun_3.(while_fun_3)
      else
        nil
      end
    end
    try do
      while_fun_3.(while_fun_3)
    catch
      :break -> nil
    end

    Process.put(:i, 0)
    while_fun_4 = fn while_fun_4 ->
      if Process.get(:i) < _len(Process.get(:patterns_none)) do
        IO.puts(Kernel.inspect(suffix_tree_search(Process.get(:st), Enum.at(Process.get(:patterns_none), Process.get(:i)))))
        Process.put(:i, Process.get(:i) + 1)
        while_fun_4.(while_fun_4)
      else
        nil
      end
    end
    try do
      while_fun_4.(while_fun_4)
    catch
      :break -> nil
    end

    IO.puts(Kernel.inspect(suffix_tree_search(Process.get(:st), "")))
    IO.puts(Kernel.inspect(suffix_tree_search(Process.get(:st), Process.get(:text))))
    Process.put(:i, 0)
    while_fun_5 = fn while_fun_5 ->
      if Process.get(:i) < _len(Process.get(:substrings)) do
        IO.puts(Kernel.inspect(suffix_tree_search(Process.get(:st), Enum.at(Process.get(:substrings), Process.get(:i)))))
        Process.put(:i, Process.get(:i) + 1)
        while_fun_5.(while_fun_5)
      else
        nil
      end
    end
    try do
      while_fun_5.(while_fun_5)
    catch
      :break -> nil
    end

  end
end
Main.main()
