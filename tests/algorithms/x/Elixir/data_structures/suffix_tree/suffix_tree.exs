# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_node() do
    try do
      throw {:return, %{children: %{}, is_end_of_string: false, start: -1, end: -1}}
    catch
      {:return, val} -> val
    end
  end
  def has_key(m, k) do
    try do
      Enum.each(Map.keys(m), fn key ->
        if key == k do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def add_suffix(tree, suffix, index) do
    try do
      nodes = tree.nodes
      node_idx = 0
      j = 0
      while_fun = fn while_fun, j, node_idx, nodes ->
        if j < _len(suffix) do
          ch = _slice(suffix, j, j + 1 - (j))
          node_ = Enum.at(nodes, node_idx)
          children = node_.children
          {children, nodes} = if !has_key(children, ch) do
            nodes = (nodes ++ [new_node()])
            new_idx = _len(nodes) - 1
            children = Map.put(children, ch, new_idx)
            {children, nodes}
          else
            {children, nodes}
          end
          node_ = Map.put(node_, :children, children)
          nodes = List.replace_at(nodes, node_idx, node_)
          node_idx = children[ch]
          j = j + 1
          while_fun.(while_fun, j, node_idx, nodes)
        else
          {j, node_idx, nodes}
        end
      end
      {j, node_idx, nodes} = try do
          while_fun.(while_fun, j, node_idx, nodes)
        catch
          {:break, {j, node_idx, nodes}} -> {j, node_idx, nodes}
        end

      node_ = Enum.at(nodes, node_idx)
      node_ = Map.put(node_, :is_end_of_string, true)
      node_ = Map.put(node_, :start, index)
      node_ = Map.put(node_, :end, index + _len(suffix) - 1)
      nodes = List.replace_at(nodes, node_idx, node_)
      tree = Map.put(tree, :nodes, nodes)
      throw {:return, tree}
    catch
      {:return, val} -> val
    end
  end
  def build_suffix_tree(tree) do
    try do
      text = tree.text
      n = _len(text)
      i = 0
      t = tree
      while_fun_2 = fn while_fun_2, i, t ->
        if i < n do
          suffix = ""
          k = i
          while_fun_3 = fn while_fun_3, k, suffix ->
            if k < n do
              suffix = (suffix <> _slice(text, k, k + 1 - (k)))
              k = k + 1
              while_fun_3.(while_fun_3, k, suffix)
            else
              {k, suffix}
            end
          end
          {k, suffix} = try do
              while_fun_3.(while_fun_3, k, suffix)
            catch
              {:break, {k, suffix}} -> {k, suffix}
            end

          t = add_suffix(t, suffix, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, t)
        else
          {i, t}
        end
      end
      {i, t} = try do
          while_fun_2.(while_fun_2, i, t)
        catch
          {:break, {i, t}} -> {i, t}
        end

      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def new_suffix_tree(text) do
    try do
      tree = %{text: text, nodes: []}
      tree = Map.put(tree, :nodes, (tree.nodes ++ [new_node()]))
      tree = build_suffix_tree(tree)
      throw {:return, tree}
    catch
      {:return, val} -> val
    end
  end
  def search(tree, pattern) do
    try do
      node_idx = 0
      i = 0
      nodes = tree.nodes
      while_fun_4 = fn while_fun_4, i, node_idx ->
        if i < _len(pattern) do
          ch = _slice(pattern, i, i + 1 - (i))
          node_ = Enum.at(nodes, node_idx)
          children = node_.children
          if !has_key(children, ch) do
            throw {:return, false}
          end
          node_idx = children[ch]
          i = i + 1
          while_fun_4.(while_fun_4, i, node_idx)
        else
          {i, node_idx}
        end
      end
      {i, node_idx} = try do
          while_fun_4.(while_fun_4, i, node_idx)
        catch
          {:break, {i, node_idx}} -> {i, node_idx}
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:st, new_suffix_tree("bananas"))
    IO.puts(Kernel.inspect(search(Process.get(:st), "ana")))
    IO.puts(Kernel.inspect(search(Process.get(:st), "apple")))
  end
end
Main.main()
