# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def slice_without_last(xs) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) - 1 do
          res = (res ++ [Enum.at(xs, i)])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def parse_float(token) do
    try do
      sign = 1.0
      idx = 0
      {idx, sign} = if _len(token) > 0 do
        first = _slice(token, 0, 1 - (0))
        {idx, sign} = if first == "-" do
          sign = -1.0
          idx = 1
          {idx, sign}
        else
          {idx} = if first == "+" do
            idx = 1
            {idx}
          else
            {idx}
          end
          {idx, sign}
        end
        {idx, sign}
      else
        {idx, sign}
      end
      int_part = 0
      while_fun_2 = fn while_fun_2, idx, int_part ->
        if idx < _len(token) && _slice(token, idx, idx + 1 - (idx)) != "." do
          int_part = int_part * 10 + Kernel.trunc(_slice(token, idx, idx + 1 - (idx)))
          idx = idx + 1
          while_fun_2.(while_fun_2, idx, int_part)
        else
          {idx, int_part}
        end
      end
      {idx, int_part} = try do
          while_fun_2.(while_fun_2, idx, int_part)
        catch
          {:break, {idx, int_part}} -> {idx, int_part}
        end

      result = 1.0 * int_part
      {idx, result} = if idx < _len(token) && _slice(token, idx, idx + 1 - (idx)) == "." do
        idx = idx + 1
        place = 0.1
        while_fun_3 = fn while_fun_3, idx, place, result ->
          if idx < _len(token) do
            digit = Kernel.trunc(_slice(token, idx, idx + 1 - (idx)))
            result = result + place * (1.0 * digit)
            place = place / 10.0
            idx = idx + 1
            while_fun_3.(while_fun_3, idx, place, result)
          else
            {idx, place, result}
          end
        end
        {idx, place, result} = try do
            while_fun_3.(while_fun_3, idx, place, result)
          catch
            {:break, {idx, place, result}} -> {idx, place, result}
          end

        {idx, result}
      else
        {idx, result}
      end
      throw {:return, sign * result}
    catch
      {:return, val} -> val
    end
  end
  def pow_float(base, exp) do
    try do
      result = 1.0
      i = 0
      e = Kernel.trunc(exp)
      while_fun_4 = fn while_fun_4, i, result ->
        if i < e do
          result = result * base
          i = i + 1
          while_fun_4.(while_fun_4, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_4.(while_fun_4, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def apply_op(a, b, op) do
    try do
      if op == "+" do
        throw {:return, a + b}
      end
      if op == "-" do
        throw {:return, a - b}
      end
      if op == "*" do
        throw {:return, a * b}
      end
      if op == "/" do
        throw {:return, a / b}
      end
      if op == "^" do
        throw {:return, pow_float(a, b)}
      end
      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  def evaluate(tokens) do
    try do
      if _len(tokens) == 0 do
        throw {:return, 0.0}
      end
      stack = []
      {stack} = Enum.reduce(tokens, {stack}, fn token, {stack} ->
        {stack} = if token == "+" || token == "-" || token == "*" || token == "/" || token == "^" do
          {stack} = if (token == "+" || token == "-") && _len(stack) < 2 do
            b = Enum.at(stack, _len(stack) - 1)
            stack = slice_without_last(stack)
            stack = (if token == "-", do: (stack ++ [0.0 - b]), else: (stack ++ [b]))
            {stack}
          else
            b = Enum.at(stack, _len(stack) - 1)
            stack = slice_without_last(stack)
            a = Enum.at(stack, _len(stack) - 1)
            stack = slice_without_last(stack)
            result = apply_op(a, b, token)
            stack = (stack ++ [result])
            {stack}
          end
          {stack}
        else
          stack = (stack ++ [parse_float(token)])
          {stack}
        end
        {stack}
      end)
      if _len(stack) != 1 do
        raise("Invalid postfix expression")
      end
      throw {:return, Enum.at(stack, 0)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(evaluate(["2", "1", "+", "3", "*"])))
    IO.puts(Kernel.inspect(evaluate(["4", "13", "5", "/", "+"])))
    IO.puts(Kernel.inspect(evaluate(["5", "6", "9", "*", "+"])))
    IO.puts(Kernel.inspect(evaluate(["2", "-", "3", "+"])))
    IO.puts(Kernel.inspect(evaluate([])))
  end
end
Main.main()
