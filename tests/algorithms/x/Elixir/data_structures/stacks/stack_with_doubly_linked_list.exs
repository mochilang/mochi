# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def empty_stack() do
    try do
      throw {:return, %{nodes: [], head: 0 - 1}}
    catch
      {:return, val} -> val
    end
  end
  def push(stack, value) do
    try do
      nodes = stack.nodes
      idx = _len(nodes)
      new_node = %{data: value, next: stack.head, prev: 0 - 1}
      nodes = (nodes ++ [new_node])
      {nodes} = if stack.head != 0 - 1 do
        head_node = Enum.at(nodes, stack.head)
        head_node = Map.put(head_node, :prev, idx)
        nodes = List.replace_at(nodes, stack.head, head_node)
        {nodes}
      else
        {nodes}
      end
      throw {:return, %{nodes: nodes, head: idx}}
    catch
      {:return, val} -> val
    end
  end
  def pop(stack) do
    try do
      if stack.head == 0 - 1 do
        throw {:return, %{stack: stack, value: 0, ok: false}}
      end
      nodes = stack.nodes
      head_node = Enum.at(nodes, stack.head)
      value = head_node.data
      next_idx = head_node.next
      {nodes} = if next_idx != 0 - 1 do
        next_node = Enum.at(nodes, next_idx)
        next_node = Map.put(next_node, :prev, 0 - 1)
        nodes = List.replace_at(nodes, next_idx, next_node)
        {nodes}
      else
        {nodes}
      end
      new_stack = %{nodes: nodes, head: next_idx}
      throw {:return, %{stack: new_stack, value: value, ok: true}}
    catch
      {:return, val} -> val
    end
  end
  def top(stack) do
    try do
      if stack.head == 0 - 1 do
        throw {:return, %{value: 0, ok: false}}
      end
      node_ = Enum.at(stack.nodes, stack.head)
      throw {:return, %{value: node_.data, ok: true}}
    catch
      {:return, val} -> val
    end
  end
  def size(stack) do
    try do
      count = 0
      idx = stack.head
      while_fun = fn while_fun, count, idx ->
        if idx != 0 - 1 do
          count = count + 1
          node_ = Enum.at(stack.nodes, idx)
          idx = node_.next
          while_fun.(while_fun, count, idx)
        else
          {count, idx}
        end
      end
      {count, idx} = try do
          while_fun.(while_fun, count, idx)
        catch
          {:break, {count, idx}} -> {count, idx}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(stack) do
    try do
      throw {:return, stack.head == 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def print_stack(stack) do
    try do
      IO.puts("stack elements are:")
      idx = stack.head
      s = ""
      while_fun_2 = fn while_fun_2, idx, s ->
        if idx != 0 - 1 do
          node_ = Enum.at(stack.nodes, idx)
          s = ((s <> Kernel.to_string(node_.data)) <> "->")
          idx = node_.next
          while_fun_2.(while_fun_2, idx, s)
        else
          {idx, s}
        end
      end
      {idx, s} = try do
          while_fun_2.(while_fun_2, idx, s)
        catch
          {:break, {idx, s}} -> {idx, s}
        end

      if _len(s) > 0 do
        IO.puts(s)
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      stack = empty_stack()
      IO.puts("Stack operations using Doubly LinkedList")
      stack = push(stack, 4)
      stack = push(stack, 5)
      stack = push(stack, 6)
      stack = push(stack, 7)
      print_stack(stack)
      t = top(stack)
      if t.ok do
        IO.puts(("Top element is " <> Kernel.to_string(t.value)))
      else
        IO.puts("Top element is None")
      end
      IO.puts(("Size of the stack is " <> Kernel.inspect(size(stack))))
      p = pop(stack)
      stack = p.stack
      p = pop(stack)
      stack = p.stack
      print_stack(stack)
      IO.puts(("stack is empty: " <> Kernel.inspect(is_empty(stack))))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
