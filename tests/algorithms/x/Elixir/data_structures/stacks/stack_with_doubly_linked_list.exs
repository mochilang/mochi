# Code generated by Mochi transpiler 2025-08-24 23:57 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def empty_stack() do
    try do
      throw {:return, %{nodes: [], head: 0 - 1}}
    catch
      {:return, val} -> val
    end
  end
  def push(stack, value) do
    try do
      nodes = stack.nodes
      idx = _len(nodes)
      new_node = %{data: value, next: stack.head, prev: 0 - 1}
      nodes = (nodes ++ [new_node])
      nodes = if stack.head != 0 - 1 do
        head_node = Enum.at(nodes, stack.head, [])
        head_node = Map.put(head_node, :prev, idx)
        nodes = List.replace_at(nodes, stack.head, head_node)
        nodes
      else
        nodes
      end
      throw {:return, %{nodes: nodes, head: idx}}
    catch
      {:return, val} -> val
    end
  end
  def pop(stack) do
    try do
      if stack.head == 0 - 1 do
        throw {:return, %{stack: stack, value: 0, ok: false}}
      end
      nodes = stack.nodes
      head_node = Enum.at(nodes, stack.head, [])
      value = head_node.data
      next_idx = head_node.next
      nodes = if next_idx != 0 - 1 do
        next_node = Enum.at(nodes, next_idx, [])
        next_node = Map.put(next_node, :prev, 0 - 1)
        nodes = List.replace_at(nodes, next_idx, next_node)
        nodes
      else
        nodes
      end
      new_stack = %{nodes: nodes, head: next_idx}
      throw {:return, %{stack: new_stack, value: value, ok: true}}
    catch
      {:return, val} -> val
    end
  end
  def top(stack) do
    try do
      if stack.head == 0 - 1 do
        throw {:return, %{value: 0, ok: false}}
      end
      node_ = Enum.at(stack.nodes, stack.head, 0)
      throw {:return, %{value: node_.data, ok: true}}
    catch
      {:return, val} -> val
    end
  end
  def size(stack) do
    try do
      count = 0
      idx = stack.head
      while_fun = fn while_fun, count, idx ->
        if idx != 0 - 1 do
          count = count + 1
          node_ = Enum.at(stack.nodes, idx, 0)
          idx = node_.next
          while_fun.(while_fun, count, idx)
        else
          {count, idx}
        end
      end
      {count, _} = try do
          while_fun.(while_fun, count, idx)
        catch
          {:break, {count, _}} -> {count, 0}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(stack) do
    try do
      throw {:return, stack.head == 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def print_stack(stack) do
    try do
      IO.puts("stack elements are:")
      idx = stack.head
      s = ""
      while_fun_2 = fn while_fun_2, idx, s ->
        if idx != 0 - 1 do
          node_ = Enum.at(stack.nodes, idx, 0)
          s = ((s <> Kernel.to_string(node_.data)) <> "->")
          idx = node_.next
          while_fun_2.(while_fun_2, idx, s)
        else
          {idx, s}
        end
      end
      {_, s} = try do
          while_fun_2.(while_fun_2, idx, s)
        catch
          {:break, {_, s}} -> {0, s}
        end

      s = if _len(s) > 0 do
        s = IO.puts(s)
        s
      else
        s
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      stack = empty_stack()
      IO.puts("Stack operations using Doubly LinkedList")
      stack = push(stack, 4)
      stack = push(stack, 5)
      stack = push(stack, 6)
      stack = push(stack, 7)
      stack = print_stack(stack)
      t = top(stack)
      if t.ok do
        IO.puts(("Top element is " <> Kernel.to_string(t.value)))
      else
        IO.puts("Top element is None")
      end
      IO.puts(("Size of the stack is " <> Kernel.inspect(size(stack))))
      p = pop(stack)
      stack = p.stack
      p = pop(stack)
      stack = p.stack
      stack = print_stack(stack)
      IO.puts(("stack is empty: " <> Kernel.inspect(is_empty(stack))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
