# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def empty_stack() do
    try do
      throw {:return, %{nodes: [], top: (-1)}}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(stack) do
    try do
      throw {:return, stack.top == (-1)}
    catch
      {:return, val} -> val
    end
  end
  def push(stack, item) do
    try do
      new_node = %{value: item, next: stack.top}
      new_nodes = stack.nodes
      new_nodes = (new_nodes ++ [new_node])
      new_top = _len(new_nodes) - 1
      throw {:return, %{nodes: new_nodes, top: new_top}}
    catch
      {:return, val} -> val
    end
  end
  def pop(stack) do
    try do
      if stack.top == (-1) do
        raise("pop from empty stack")
      end
      node_ = (Enum.at(stack.nodes, stack.top))
      new_top = node_.next
      new_stack = %{nodes: stack.nodes, top: new_top}
      throw {:return, %{stack: new_stack, value: node_.value}}
    catch
      {:return, val} -> val
    end
  end
  def peek(stack) do
    try do
      if stack.top == (-1) do
        raise("peek from empty stack")
      end
      node_ = (Enum.at(stack.nodes, stack.top))
      throw {:return, node_.value}
    catch
      {:return, val} -> val
    end
  end
  def clear(stack) do
    try do
      throw {:return, %{nodes: [], top: (-1)}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      stack = empty_stack()
      IO.puts(Kernel.inspect(is_empty(stack)))
      stack = push(stack, "5")
      stack = push(stack, "9")
      stack = push(stack, "python")
      IO.puts(Kernel.inspect(is_empty(stack)))
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      stack = push(stack, "algorithms")
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      IO.puts(Kernel.inspect(is_empty(stack)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
