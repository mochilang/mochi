# Code generated by Mochi transpiler 2025-08-24 23:57 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def empty_stack() do
    try do
      throw {:return, %{nodes: [], top: (-1)}}
    catch
      {:return, val} -> val
    end
  end
  def is_empty(stack) do
    try do
      throw {:return, stack.top == (-1)}
    catch
      {:return, val} -> val
    end
  end
  def push(stack, item) do
    try do
      new_node = %{value: item, next: stack.top}
      new_nodes = stack.nodes
      new_nodes = (new_nodes ++ [new_node])
      new_top = _len(new_nodes) - 1
      throw {:return, %{nodes: new_nodes, top: new_top}}
    catch
      {:return, val} -> val
    end
  end
  def pop(stack) do
    try do
      if stack.top == (-1) do
        raise("pop from empty stack")
      end
      node_ = (Enum.at(stack.nodes, stack.top, 0))
      new_top = node_.next
      new_stack = %{nodes: stack.nodes, top: new_top}
      throw {:return, %{stack: new_stack, value: node_.value}}
    catch
      {:return, val} -> val
    end
  end
  def peek(stack) do
    try do
      if stack.top == (-1) do
        raise("peek from empty stack")
      end
      node_ = (Enum.at(stack.nodes, stack.top, 0))
      throw {:return, node_.value}
    catch
      {:return, val} -> val
    end
  end
  def clear(stack) do
    try do
      throw {:return, %{nodes: [], top: (-1)}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      stack = empty_stack()
      IO.puts(Kernel.inspect(is_empty(stack)))
      stack = push(stack, "5")
      stack = push(stack, "9")
      stack = push(stack, "python")
      IO.puts(Kernel.inspect(is_empty(stack)))
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      stack = push(stack, "algorithms")
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      res = pop(stack)
      stack = res.stack
      IO.puts(res.value)
      IO.puts(Kernel.inspect(is_empty(stack)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
