# Code generated by Mochi transpiler 2025-08-08 10:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def precedence(ch) do
    try do
      throw {:return, ((if Map.has_key?(Process.get(:precedences), ch), do: Process.get(:precedences)[ch], else: -1))}
    catch
      {:return, val} -> val
    end
  end
  def associativity(ch) do
    try do
      throw {:return, ((if Map.has_key?(Process.get(:associativities), ch), do: Map.get(Process.get(:associativities), ch, ""), else: ""))}
    catch
      {:return, val} -> val
    end
  end
  def balanced_parentheses(expr) do
    try do
      count = 0
      i = 0
      while_fun = fn while_fun, count, i ->
        if i < _len(expr) do
          ch = _slice(expr, i, i + 1 - (i))
          {count} = if ch == "(" do
            count = count + 1
            {count}
          else
            {count}
          end
          {count} = if ch == ")" do
            count = count - 1
            if count < 0 do
              throw {:return, false}
            end
            {count}
          else
            {count}
          end
          i = i + 1
          while_fun.(while_fun, count, i)
        else
          {count, i}
        end
      end
      {count, i} = try do
          while_fun.(while_fun, count, i)
        catch
          {:break, {count, i}} -> {count, i}
        end

      throw {:return, count == 0}
    catch
      {:return, val} -> val
    end
  end
  def is_letter(ch) do
    try do
      throw {:return, ("a" <= ch && ch <= "z") || ("A" <= ch && ch <= "Z")}
    catch
      {:return, val} -> val
    end
  end
  def is_digit(ch) do
    try do
      throw {:return, "0" <= ch && ch <= "9"}
    catch
      {:return, val} -> val
    end
  end
  def is_alnum(ch) do
    try do
      throw {:return, is_letter(ch) || is_digit(ch)}
    catch
      {:return, val} -> val
    end
  end
  def infix_to_postfix(expression) do
    try do
      if balanced_parentheses(expression) == false do
        raise("Mismatched parentheses")
      end
      stack = []
      postfix = []
      i = 0
      while_fun_2 = fn while_fun_2, i, postfix, stack ->
        if i < _len(expression) do
          {i, postfix, stack} = try do
            ch = _slice(expression, i, i + 1 - (i))
            {postfix, stack} = if is_alnum(ch) do
              postfix = (postfix ++ [ch])
              {postfix, stack}
            else
              {postfix, stack} = if ch == "(" do
                stack = (stack ++ [ch])
                {postfix, stack}
              else
                {postfix, stack} = if ch == ")" do
                  while_fun_3 = fn while_fun_3, postfix, stack ->
                    if _len(stack) > 0 && Enum.at(stack, _len(stack) - 1) != "(" do
                      postfix = (postfix ++ [Enum.at(stack, _len(stack) - 1)])
                      stack = _slice(stack, 0, _len(stack) - 1 - (0))
                      while_fun_3.(while_fun_3, postfix, stack)
                    else
                      {postfix, stack}
                    end
                  end
                  {postfix, stack} = try do
                      while_fun_3.(while_fun_3, postfix, stack)
                    catch
                      {:break, {postfix, stack}} -> {postfix, stack}
                    end

                  {stack} = if _len(stack) > 0 do
                    stack = _slice(stack, 0, _len(stack) - 1 - (0))
                    {stack}
                  else
                    {stack}
                  end
                  {postfix, stack}
                else
                  {postfix, stack} = if ch == " " do
                    {postfix, stack}
                  else
                    while_fun_4 = fn while_fun_4, postfix, stack ->
                      if true do
                        {postfix, stack} = try do
                          {stack} = if _len(stack) == 0 do
                            stack = (stack ++ [ch])
                            throw {:break, {postfix, stack}}
                            {stack}
                          else
                            {stack}
                          end
                          cp = precedence(ch)
                          tp = precedence(Enum.at(stack, _len(stack) - 1))
                          {stack} = if cp > tp do
                            stack = (stack ++ [ch])
                            throw {:break, {postfix, stack}}
                            {stack}
                          else
                            {stack}
                          end
                          {postfix, stack} = if cp < tp do
                            postfix = (postfix ++ [Enum.at(stack, _len(stack) - 1)])
                            stack = _slice(stack, 0, _len(stack) - 1 - (0))
                            throw {:continue, {postfix, stack}}
                            {postfix, stack}
                          else
                            {postfix, stack}
                          end
                          {stack} = if associativity(ch) == "RL" do
                            stack = (stack ++ [ch])
                            throw {:break, {postfix, stack}}
                            {stack}
                          else
                            {stack}
                          end
                          postfix = (postfix ++ [Enum.at(stack, _len(stack) - 1)])
                          stack = _slice(stack, 0, _len(stack) - 1 - (0))
                          {postfix, stack}
                        catch
                          {:continue, {postfix, stack}} -> {postfix, stack}
                        end
                        while_fun_4.(while_fun_4, postfix, stack)
                      else
                        {postfix, stack}
                      end
                    end
                    {postfix, stack} = try do
                        while_fun_4.(while_fun_4, postfix, stack)
                      catch
                        {:break, {postfix, stack}} -> {postfix, stack}
                      end

                    {postfix, stack}
                  end
                  {postfix, stack}
                end
                {postfix, stack}
              end
              {postfix, stack}
            end
            i = i + 1
            {i, postfix, stack}
          catch
            {:continue, {i, postfix, stack}} -> {i, postfix, stack}
          end
          while_fun_2.(while_fun_2, i, postfix, stack)
        else
          {i, postfix, stack}
        end
      end
      {i, postfix, stack} = try do
          while_fun_2.(while_fun_2, i, postfix, stack)
        catch
          {:break, {i, postfix, stack}} -> {i, postfix, stack}
        end

      while_fun_5 = fn while_fun_5, postfix, stack ->
        if _len(stack) > 0 do
          postfix = (postfix ++ [Enum.at(stack, _len(stack) - 1)])
          stack = _slice(stack, 0, _len(stack) - 1 - (0))
          while_fun_5.(while_fun_5, postfix, stack)
        else
          {postfix, stack}
        end
      end
      {postfix, stack} = try do
          while_fun_5.(while_fun_5, postfix, stack)
        catch
          {:break, {postfix, stack}} -> {postfix, stack}
        end

      res = ""
      j = 0
      while_fun_6 = fn while_fun_6, j, res ->
        if j < _len(postfix) do
          {res} = if j > 0 do
            res = (res <> " ")
            {res}
          else
            {res}
          end
          res = (res <> Enum.at(postfix, j))
          j = j + 1
          while_fun_6.(while_fun_6, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_6.(while_fun_6, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      expression = "a+b*(c^d-e)^(f+g*h)-i"
      IO.puts(expression)
      IO.puts(Kernel.inspect(infix_to_postfix(expression)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:precedences, %{"+" => 1, "-" => 1, "*" => 2, "/" => 2, "^" => 3})
  Process.put(:associativities, %{"+" => "LR", "-" => "LR", "*" => "LR", "/" => "LR", "^" => "RL"})
  def bench_main() do
    Process.put(:precedences, %{"+" => 1, "-" => 1, "*" => 2, "/" => 2, "^" => 3})
    Process.put(:associativities, %{"+" => "LR", "-" => "LR", "*" => "LR", "/" => "LR", "^" => "RL"})
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
