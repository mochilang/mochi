# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_body(px, py, vx, vy, mass) do
    try do
      throw {:return, %{position_x: px, position_y: py, velocity_x: vx, velocity_y: vy, mass: mass}}
    catch
      {:return, val} -> val
    end
  end
  def update_velocity(body, force_x, force_y, delta_time) do
    try do
      body = Map.put(body, :velocity_x, body.velocity_x + force_x * delta_time)
      body = Map.put(body, :velocity_y, body.velocity_y + force_y * delta_time)
      throw {:return, body}
    catch
      {:return, val} -> val
    end
  end
  def update_position(body, delta_time) do
    try do
      body = Map.put(body, :position_x, body.position_x + body.velocity_x * delta_time)
      body = Map.put(body, :position_y, body.position_y + body.velocity_y * delta_time)
      throw {:return, body}
    catch
      {:return, val} -> val
    end
  end
  def make_body_system(bodies, g, tf, sf) do
    try do
      throw {:return, %{bodies: bodies, gravitation_constant: g, time_factor: tf, softening_factor: sf}}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def update_system(system, delta_time) do
    try do
      bodies = system.bodies
      i = 0
      while_fun_2 = fn while_fun_2, bodies, i ->
        if i < _len(bodies) do
          body1 = Enum.at(bodies, i, [])
          force_x = 0.0
          force_y = 0.0
          j = 0
          while_fun_3 = fn while_fun_3, force_x, force_y, j ->
            if j < _len(bodies) do
              {force_x, force_y} = if i != j do
                body2 = Enum.at(bodies, j, [])
                dif_x = body2.position_x - body1.position_x
                dif_y = body2.position_y - body1.position_y
                distance_sq = dif_x * dif_x + dif_y * dif_y + system.softening_factor
                distance = sqrtApprox(distance_sq)
                denom = distance * distance * distance
                force_x = force_x + system.gravitation_constant * body2.mass * dif_x / denom
                force_y = force_y + system.gravitation_constant * body2.mass * dif_y / denom
                {force_x, force_y}
              else
                {force_x, force_y}
              end
              j = j + 1
              while_fun_3.(while_fun_3, force_x, force_y, j)
            else
              {force_x, force_y, j}
            end
          end
          {force_x, force_y, j} = try do
              while_fun_3.(while_fun_3, force_x, force_y, j)
            catch
              {:break, {force_x, force_y, j}} -> {force_x, force_y, j}
            end

          body1 = update_velocity(body1, force_x, force_y, delta_time * system.time_factor)
          bodies = List.replace_at(bodies, i, body1)
          i = i + 1
          while_fun_2.(while_fun_2, bodies, i)
        else
          {bodies, i}
        end
      end
      {bodies, i} = try do
          while_fun_2.(while_fun_2, bodies, i)
        catch
          {:break, {bodies, i}} -> {bodies, i}
        end

      i = 0
      while_fun_4 = fn while_fun_4, bodies, i ->
        if i < _len(bodies) do
          body = Enum.at(bodies, i, [])
          body = update_position(body, delta_time * system.time_factor)
          bodies = List.replace_at(bodies, i, body)
          i = i + 1
          while_fun_4.(while_fun_4, bodies, i)
        else
          {bodies, i}
        end
      end
      {bodies, i} = try do
          while_fun_4.(while_fun_4, bodies, i)
        catch
          {:break, {bodies, i}} -> {bodies, i}
        end

      system = Map.put(system, :bodies, bodies)
      throw {:return, system}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      b1 = make_body(0.0, 0.0, 0.0, 0.0, 1.0)
      b2 = make_body(10.0, 0.0, 0.0, 0.0, 1.0)
      sys1 = make_body_system([b1, b2], 1.0, 1.0, 0.0)
      sys1 = update_system(sys1, 1.0)
      b1_after = Enum.at(sys1.bodies, 0, 0)
      pos1x = b1_after.position_x
      pos1y = b1_after.position_y
      IO.puts(Kernel.inspect(%{"x" => pos1x, "y" => pos1y}))
      vel1x = b1_after.velocity_x
      vel1y = b1_after.velocity_y
      IO.puts(Kernel.inspect(%{"vx" => vel1x, "vy" => vel1y}))
      b3 = make_body(-10.0, 0.0, 0.0, 0.0, 1.0)
      b4 = make_body(10.0, 0.0, 0.0, 0.0, 4.0)
      sys2 = make_body_system([b3, b4], 1.0, 10.0, 0.0)
      sys2 = update_system(sys2, 1.0)
      b2_after = Enum.at(sys2.bodies, 0, 0)
      pos2x = b2_after.position_x
      pos2y = b2_after.position_y
      IO.puts(Kernel.inspect(%{"x" => pos2x, "y" => pos2y}))
      vel2x = b2_after.velocity_x
      vel2y = b2_after.velocity_y
      IO.puts(Kernel.inspect(%{"vx" => vel2x, "vy" => vel2y}))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
