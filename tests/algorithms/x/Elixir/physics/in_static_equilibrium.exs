# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def _mod(x, m) do
    try do
      throw {:return, x - (:erlang.float(Kernel.trunc(x / m))) * m}
    catch
      {:return, val} -> val
    end
  end
  def sin_approx(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y3 = y2 * y
      y5 = y3 * y2
      y7 = y5 * y2
      throw {:return, y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0}
    catch
      {:return, val} -> val
    end
  end
  def cos_approx(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y4 = y2 * y2
      y6 = y4 * y2
      throw {:return, 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0}
    catch
      {:return, val} -> val
    end
  end
  def polar_force(magnitude, angle, radian_mode) do
    try do
      theta = (if radian_mode, do: angle, else: angle * Process.get(:pi) / 180.0)
      throw {:return, [magnitude * cos_approx(theta), magnitude * sin_approx(theta)]}
    catch
      {:return, val} -> val
    end
  end
  def abs_float(x) do
    try do
      if x < 0.0 do
        throw {:return, -x}
      else
        throw {:return, x}
      end
    catch
      {:return, val} -> val
    end
  end
  def in_static_equilibrium(forces, location, eps) do
    try do
      sum_moments = 0.0
      i = 0
      n = _len(forces)
      while_fun = fn while_fun, i, sum_moments ->
        if i < n do
          r = Enum.at(location, i, [])
          f = Enum.at(forces, i, [])
          moment = Enum.at(r, 0, []) * Enum.at(f, 1, []) - Enum.at(r, 1, []) * Enum.at(f, 0, [])
          sum_moments = sum_moments + moment
          i = i + 1
          while_fun.(while_fun, i, sum_moments)
        else
          {i, sum_moments}
        end
      end
      {i, sum_moments} = try do
          while_fun.(while_fun, i, sum_moments)
        catch
          {:break, {i, sum_moments}} -> {i, sum_moments}
        end

      throw {:return, abs_float(sum_moments) < eps}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:two_pi, 6.283185307179586)
  Process.put(:location1, [[1.0, 0.0], [10.0, 0.0]])
  Process.put(:location2, [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])
  Process.put(:location3, [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])
  Process.put(:location4, [[0.0, 0.0], [6.0, 0.0], [10.0, 0.0], [12.0, 0.0]])
  def main() do
    Process.put(:forces1, [[1.0, 1.0], [-1.0, 2.0]])
    IO.puts(Kernel.inspect(in_static_equilibrium(Process.get(:forces1), Process.get(:location1), 0.1)))
    Process.put(:forces2, [polar_force(718.4, 150.0, false), polar_force(879.54, 45.0, false), polar_force(100.0, -90.0, false)])
    IO.puts(Kernel.inspect(in_static_equilibrium(Process.get(:forces2), Process.get(:location2), 0.1)))
    Process.put(:forces3, [polar_force(30.0 * 9.81, 15.0, false), polar_force(215.0, 135.0, false), polar_force(264.0, 60.0, false)])
    IO.puts(Kernel.inspect(in_static_equilibrium(Process.get(:forces3), Process.get(:location3), 0.1)))
    Process.put(:forces4, [[0.0, -2000.0], [0.0, -1200.0], [0.0, 15600.0], [0.0, -12400.0]])
    IO.puts(Kernel.inspect(in_static_equilibrium(Process.get(:forces4), Process.get(:location4), 0.1)))
  end
end
Main.main()
