# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  def pow10(n) do
    try do
      p = 1.0
      k = 0
      {k, p} = if n >= 0 do
        while_fun = fn while_fun, k, p ->
          if k < n do
            p = p * 10.0
            k = k + 1
            while_fun.(while_fun, k, p)
          else
            {k, p}
          end
        end
        {k, p} = try do
            while_fun.(while_fun, k, p)
          catch
            {:break, {k, p}} -> {k, p}
          end

        {k, p}
      else
        m = -n
        while_fun_2 = fn while_fun_2, k, p ->
          if k < m do
            p = p / 10.0
            k = k + 1
            while_fun_2.(while_fun_2, k, p)
          else
            {k, p}
          end
        end
        {k, p} = try do
            while_fun_2.(while_fun_2, k, p)
          catch
            {:break, {k, p}} -> {k, p}
          end

        {k, p}
      end
      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_newton(n) do
    try do
      if n == 0.0 do
        throw {:return, 0.0}
      end
      x = n
      j = 0
      while_fun_3 = fn while_fun_3, j, x ->
        if j < 20 do
          x = (x + n / x) / 2.0
          j = j + 1
          while_fun_3.(while_fun_3, j, x)
        else
          {j, x}
        end
      end
      {j, x} = try do
          while_fun_3.(while_fun_3, j, x)
        catch
          {:break, {j, x}} -> {j, x}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def round3(x) do
    try do
      y = x * 1000.0 + 0.5
      yi = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(y)
      {yi} = if (:erlang.float(yi)) > y do
        yi = yi - 1
        {yi}
      else
        {yi}
      end
      throw {:return, (:erlang.float(yi)) / 1000.0}
    catch
      {:return, val} -> val
    end
  end
  def escape_velocity(mass, radius) do
    try do
      if radius == 0.0 do
        raise("Radius cannot be zero.")
      end
      g = 6.6743 * pow10(-11)
      velocity = sqrt_newton(2.0 * g * mass / radius)
      throw {:return, round3(velocity)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(escape_velocity(5.972 * pow10(24), 6.371 * pow10(6))))
    IO.puts(Kernel.inspect(escape_velocity(7.348 * pow10(22), 1.737 * pow10(6))))
    IO.puts(Kernel.inspect(escape_velocity(1.898 * pow10(27), 6.9911 * pow10(7))))
  end
end
Main.main()
