# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def beta(velocity) do
    try do
      if velocity > Process.get(:c) do
        raise("Speed must not exceed light speed 299,792,458 [m/s]!")
      end
      if velocity < 1.0 do
        raise("Speed must be greater than or equal to 1!")
      end
      throw {:return, velocity / Process.get(:c)}
    catch
      {:return, val} -> val
    end
  end
  def gamma(velocity) do
    try do
      b = beta(velocity)
      throw {:return, 1.0 / sqrtApprox(1.0 - b * b)}
    catch
      {:return, val} -> val
    end
  end
  def transformation_matrix(velocity) do
    try do
      g = gamma(velocity)
      b = beta(velocity)
      throw {:return, [[g, -g * b, 0.0, 0.0], [-g * b, g, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]]}
    catch
      {:return, val} -> val
    end
  end
  def mat_vec_mul(mat, vec) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < 4 do
          row = Enum.at(mat, i, [])
          value = Enum.at(row, 0, []) * Enum.at(vec, 0, []) + Enum.at(row, 1, []) * Enum.at(vec, 1, []) + Enum.at(row, 2, []) * Enum.at(vec, 2, []) + Enum.at(row, 3, []) * Enum.at(vec, 3, [])
          res = (res ++ [value])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def transform(velocity, event) do
    try do
      g = gamma(velocity)
      b = beta(velocity)
      ct = Enum.at(event, 0, []) * Process.get(:c)
      x = Enum.at(event, 1, [])
      throw {:return, [g * ct - g * b * x, -g * b * ct + g * x, Enum.at(event, 2, []), Enum.at(event, 3, [])]}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:c, 299792458.0)
  def main() do
    IO.puts(Kernel.inspect(beta(Process.get(:c))))
    IO.puts(Kernel.inspect(beta(199792458.0)))
    IO.puts(Kernel.inspect(beta(100000.0)))
    IO.puts(Kernel.inspect(gamma(4.0)))
    IO.puts(Kernel.inspect(gamma(100000.0)))
    IO.puts(Kernel.inspect(gamma(30000000.0)))
    IO.puts(Kernel.inspect(transformation_matrix(29979245.0)))
    Process.put(:v, transform(29979245.0, [1.0, 2.0, 3.0, 4.0]))
    IO.puts(Kernel.inspect(Process.get(:v)))
  end
end
Main.main()
