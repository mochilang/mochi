# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def gravitational_law(force, mass_1, mass_2, distance) do
    try do
      zero_count = 0
      {zero_count} = if force == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if mass_1 == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if mass_2 == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if distance == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      if zero_count != 1 do
        raise("One and only one argument must be 0")
      end
      if force < 0.0 do
        raise("Gravitational force can not be negative")
      end
      if distance < 0.0 do
        raise("Distance can not be negative")
      end
      if mass_1 < 0.0 do
        raise("Mass can not be negative")
      end
      if mass_2 < 0.0 do
        raise("Mass can not be negative")
      end
      product_of_mass = mass_1 * mass_2
      if force == 0.0 do
        f = Process.get(:gravitational_constant) * product_of_mass / (distance * distance)
        throw {:return, %{kind: "force", value: f}}
      end
      if mass_1 == 0.0 do
        m1 = force * (distance * distance) / (Process.get(:gravitational_constant) * mass_2)
        throw {:return, %{kind: "mass_1", value: m1}}
      end
      if mass_2 == 0.0 do
        m2 = force * (distance * distance) / (Process.get(:gravitational_constant) * mass_1)
        throw {:return, %{kind: "mass_2", value: m2}}
      end
      d = sqrtApprox(Process.get(:gravitational_constant) * product_of_mass / force)
      throw {:return, %{kind: "distance", value: d}}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:gravitational_constant, 0.000000000066743)
  def main() do
    Process.put(:r1, gravitational_law(0.0, 5.0, 10.0, 20.0))
    Process.put(:r2, gravitational_law(7367.382, 0.0, 74.0, 3048.0))
    Process.put(:r3, gravitational_law(100.0, 5.0, 0.0, 3.0))
    Process.put(:r4, gravitational_law(100.0, 5.0, 10.0, 0.0))
    IO.puts(((Process.get(:r1).kind <> " ") <> Kernel.to_string(Process.get(:r1).value)))
    IO.puts(((Process.get(:r2).kind <> " ") <> Kernel.to_string(Process.get(:r2).value)))
    IO.puts(((Process.get(:r3).kind <> " ") <> Kernel.to_string(Process.get(:r3).value)))
    IO.puts(((Process.get(:r4).kind <> " ") <> Kernel.to_string(Process.get(:r4).value)))
  end
end
Main.main()
