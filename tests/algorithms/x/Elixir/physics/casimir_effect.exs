# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 100 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def casimir_force(force, area, distance) do
    try do
      zero_count = 0
      {zero_count} = if force == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if area == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      {zero_count} = if distance == 0.0 do
        zero_count = zero_count + 1
        {zero_count}
      else
        {zero_count}
      end
      if zero_count != 1 do
        raise("One and only one argument must be 0")
      end
      if force < 0.0 do
        raise("Magnitude of force can not be negative")
      end
      if distance < 0.0 do
        raise("Distance can not be negative")
      end
      if area < 0.0 do
        raise("Area can not be negative")
      end
      if force == 0.0 do
        num = Process.get(:reduced_planck_constant) * Process.get(:speed_of_light) * Process.get(:pi) * Process.get(:pi) * area
        den = 240.0 * distance * distance * distance * distance
        f = num / den
        throw {:return, %{"force" => f}}
      end
      if area == 0.0 do
        num = 240.0 * force * distance * distance * distance * distance
        den = Process.get(:reduced_planck_constant) * Process.get(:speed_of_light) * Process.get(:pi) * Process.get(:pi)
        a = num / den
        throw {:return, %{"area" => a}}
      end
      num = Process.get(:reduced_planck_constant) * Process.get(:speed_of_light) * Process.get(:pi) * Process.get(:pi) * area
      den = 240.0 * force
      inner = num / den
      d = sqrtApprox(sqrtApprox(inner))
      throw {:return, %{"distance" => d}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(casimir_force(0.0, 4.0, 0.03)))
      IO.puts(Kernel.inspect(casimir_force(0.0000000002635, 0.0023, 0.0)))
      IO.puts(Kernel.inspect(casimir_force(0.000000000000000002737, 0.0, 0.0023746)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:reduced_planck_constant, 0.0000000000000000000000000000000001054571817)
  Process.put(:speed_of_light, 300000000.0)
end
Main.main()
