# Code generated by Mochi transpiler 2025-08-22 14:19 +0700
defmodule Main do
  import Kernel, except: [floor: 1]
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      p = if n >= 0 do
        i = 0
        while_fun = fn while_fun, i, p ->
          if i < n do
            p = p * 10.0
            i = i + 1
            while_fun.(while_fun, i, p)
          else
            {i, p}
          end
        end
        {_, p} = try do
            while_fun.(while_fun, i, p)
          catch
            {:break, {_, p}} -> {0, p}
          end

        p
      else
        i = 0
        while_fun_2 = fn while_fun_2, i, p ->
          if i > n do
            p = p / 10.0
            i = i - 1
            while_fun_2.(while_fun_2, i, p)
          else
            {i, p}
          end
        end
        {_, p} = try do
            while_fun_2.(while_fun_2, i, p)
          catch
            {:break, {_, p}} -> {0, p}
          end

        p
      end
      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x)
      f = :erlang.float(i)
      if f > x do
        throw {:return, :erlang.float((i - 1))}
      end
      throw {:return, f}
    catch
      {:return, val} -> val
    end
  end
  def format_scientific_3(x) do
    try do
      if x == 0.0 do
        throw {:return, "0.000e+00"}
      end
      sign = ""
      num = x
      {num, sign} = if num < 0.0 do
        sign = "-"
        num = -num
        {num, sign}
      else
        {num, sign}
      end
      exp = 0
      while_fun_3 = fn while_fun_3, exp, num ->
        if num >= 10.0 do
          num = num / 10.0
          exp = exp + 1
          while_fun_3.(while_fun_3, exp, num)
        else
          {exp, num}
        end
      end
      {exp, num} = try do
          while_fun_3.(while_fun_3, exp, num)
        catch
          {:break, {exp, num}} -> {exp, num}
        end

      while_fun_4 = fn while_fun_4, exp, num ->
        if num < 1.0 do
          num = num * 10.0
          exp = exp - 1
          while_fun_4.(while_fun_4, exp, num)
        else
          {exp, num}
        end
      end
      {exp, num} = try do
          while_fun_4.(while_fun_4, exp, num)
        catch
          {:break, {exp, num}} -> {exp, num}
        end

      temp = floor(num * 1000.0 + 0.5)
      scaled = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(temp)
      {exp, scaled} = if scaled == 10000 do
        scaled = 1000
        exp = exp + 1
        {exp, scaled}
      else
        {exp, scaled}
      end
      int_part = div(scaled, 1000)
      frac_part = rem(scaled, 1000)
      frac_str = Kernel.to_string(frac_part)
      while_fun_5 = fn while_fun_5, frac_str ->
        if _len(frac_str) < 3 do
          frac_str = ("0" <> frac_str)
          while_fun_5.(while_fun_5, frac_str)
        else
          frac_str
        end
      end
      frac_str = try do
          while_fun_5.(while_fun_5, frac_str)
        catch
          {:break, {frac_str}} -> frac_str
        end

      mantissa = ((Kernel.to_string(int_part) <> ".") <> frac_str)
      exp_sign = "+"
      exp_abs = exp
      {exp_abs, exp_sign} = if exp < 0 do
        exp_sign = "-"
        exp_abs = -exp
        {exp_abs, exp_sign}
      else
        {exp_abs, exp_sign}
      end
      exp_str = Kernel.to_string(exp_abs)
      exp_str = if exp_abs < 10 do
        exp_str = ("0" <> exp_str)
        exp_str
      else
        exp_str
      end
      throw {:return, ((((sign <> mantissa) <> "e") <> exp_sign) <> exp_str)}
    catch
      {:return, val} -> val
    end
  end
  def orbital_transfer_work(mass_central, mass_object, r_initial, r_final) do
    try do
      g = 6.6743 * pow10(-11)
      if r_initial <= 0.0 || r_final <= 0.0 do
        raise("Orbital radii must be greater than zero.")
      end
      work = (g * mass_central * mass_object / 2.0) * (1.0 / r_initial - 1.0 / r_final)
      throw {:return, format_scientific_3(work)}
    catch
      {:return, val} -> val
    end
  end
  def test_orbital_transfer_work() do
    try do
      if orbital_transfer_work(5.972 * pow10(24), 1000.0, 6.371 * pow10(6), 7.0 * pow10(6)) != "2.811e+09" do
        raise("case1 failed")
      end
      if orbital_transfer_work(5.972 * pow10(24), 500.0, 7.0 * pow10(6), 6.371 * pow10(6)) != "-1.405e+09" do
        raise("case2 failed")
      end
      if orbital_transfer_work(1.989 * pow10(30), 1000.0, 1.5 * pow10(11), 2.28 * pow10(11)) != "1.514e+11" do
        raise("case3 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_orbital_transfer_work()
      IO.puts(Kernel.inspect(orbital_transfer_work(5.972 * pow10(24), 1000.0, 6.371 * pow10(6), 7.0 * pow10(6))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
