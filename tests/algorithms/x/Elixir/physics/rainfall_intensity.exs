# Code generated by Mochi transpiler 2025-08-12 12:29 +0700
defmodule Main do
  def exp_approx(x) do
    try do
      y = x
      is_neg = false
      {is_neg, y} = if x < 0.0 do
        is_neg = true
        y = -x
        {is_neg, y}
      else
        {is_neg, y}
      end
      term = 1.0
      sum = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 30 do
          term = term * y / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      if is_neg do
        throw {:return, 1.0 / sum}
      end
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def ln_series(x) do
    try do
      t = (x - 1.0) / (x + 1.0)
      term = t
      sum = 0.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n <= 19 do
          sum = sum + term / (:erlang.float(n))
          term = term * t * t
          n = n + 2
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, 2.0 * sum}
    catch
      {:return, val} -> val
    end
  end
  def ln(x) do
    try do
      y = x
      k = 0
      while_fun_3 = fn while_fun_3, k, y ->
        if y >= 10.0 do
          y = y / 10.0
          k = k + 1
          while_fun_3.(while_fun_3, k, y)
        else
          {k, y}
        end
      end
      {k, y} = try do
          while_fun_3.(while_fun_3, k, y)
        catch
          {:break, {k, y}} -> {k, y}
        end

      while_fun_4 = fn while_fun_4, k, y ->
        if y < 1.0 do
          y = y * 10.0
          k = k - 1
          while_fun_4.(while_fun_4, k, y)
        else
          {k, y}
        end
      end
      {k, y} = try do
          while_fun_4.(while_fun_4, k, y)
        catch
          {:break, {k, y}} -> {k, y}
        end

      throw {:return, ln_series(y) + (:erlang.float(k)) * ln_series(10.0)}
    catch
      {:return, val} -> val
    end
  end
  def powf(base, exponent) do
    try do
      throw {:return, exp_approx(exponent * ln(base))}
    catch
      {:return, val} -> val
    end
  end
  def rainfall_intensity(coefficient_k, coefficient_a, coefficient_b, coefficient_c, return_period, duration) do
    try do
      if coefficient_k <= 0.0 do
        raise("All parameters must be positive.")
      end
      if coefficient_a <= 0.0 do
        raise("All parameters must be positive.")
      end
      if coefficient_b <= 0.0 do
        raise("All parameters must be positive.")
      end
      if coefficient_c <= 0.0 do
        raise("All parameters must be positive.")
      end
      if return_period <= 0.0 do
        raise("All parameters must be positive.")
      end
      if duration <= 0.0 do
        raise("All parameters must be positive.")
      end
      numerator = coefficient_k * powf(return_period, coefficient_a)
      denominator = powf(duration + coefficient_b, coefficient_c)
      throw {:return, numerator / denominator}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:r1, rainfall_intensity(1000.0, 0.2, 11.6, 0.81, 10.0, 60.0))
    IO.puts(Kernel.to_string(Process.get(:r1)))
    Process.put(:r2, rainfall_intensity(1000.0, 0.2, 11.6, 0.81, 10.0, 30.0))
    IO.puts(Kernel.to_string(Process.get(:r2)))
    Process.put(:r3, rainfall_intensity(1000.0, 0.2, 11.6, 0.81, 5.0, 60.0))
    IO.puts(Kernel.to_string(Process.get(:r3)))
  end
end
Main.main()
