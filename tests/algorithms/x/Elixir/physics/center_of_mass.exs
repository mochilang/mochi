# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def round2(x) do
    try do
      scaled = x * 100.0
      rounded = :erlang.float(((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((scaled + 0.5))))
      throw {:return, rounded / 100.0}
    catch
      {:return, val} -> val
    end
  end
  def center_of_mass(ps) do
    try do
      if _len(ps) == 0 do
        raise("No particles provided")
      end
      i = 0
      total_mass = 0.0
      while_fun = fn while_fun, i, total_mass ->
        if i < _len(ps) do
          p = Enum.at(ps, i)
          if p.mass <= 0.0 do
            raise("Mass of all particles must be greater than 0")
          end
          total_mass = total_mass + p.mass
          i = i + 1
          while_fun.(while_fun, i, total_mass)
        else
          {i, total_mass}
        end
      end
      {i, total_mass} = try do
          while_fun.(while_fun, i, total_mass)
        catch
          {:break, {i, total_mass}} -> {i, total_mass}
        end

      sum_x = 0.0
      sum_y = 0.0
      sum_z = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, sum_x, sum_y, sum_z ->
        if i < _len(ps) do
          p = Enum.at(ps, i)
          sum_x = sum_x + p.x * p.mass
          sum_y = sum_y + p.y * p.mass
          sum_z = sum_z + p.z * p.mass
          i = i + 1
          while_fun_2.(while_fun_2, i, sum_x, sum_y, sum_z)
        else
          {i, sum_x, sum_y, sum_z}
        end
      end
      {i, sum_x, sum_y, sum_z} = try do
          while_fun_2.(while_fun_2, i, sum_x, sum_y, sum_z)
        catch
          {:break, {i, sum_x, sum_y, sum_z}} -> {i, sum_x, sum_y, sum_z}
        end

      cm_x = round2(sum_x / total_mass)
      cm_y = round2(sum_y / total_mass)
      cm_z = round2(sum_z / total_mass)
      throw {:return, %{x: cm_x, y: cm_y, z: cm_z}}
    catch
      {:return, val} -> val
    end
  end
  def coord_to_string(c) do
    try do
      throw {:return, (((((("Coord3D(x=" <> Kernel.to_string(c.x)) <> ", y=") <> Kernel.to_string(c.y)) <> ", z=") <> Kernel.to_string(c.z)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:r1, center_of_mass([%{x: 1.5, y: 4.0, z: 3.4, mass: 4.0}, %{x: 5.0, y: 6.8, z: 7.0, mass: 8.1}, %{x: 9.4, y: 10.1, z: 11.6, mass: 12.0}]))
    IO.puts(Kernel.inspect(coord_to_string(Process.get(:r1))))
    Process.put(:r2, center_of_mass([%{x: 1.0, y: 2.0, z: 3.0, mass: 4.0}, %{x: 5.0, y: 6.0, z: 7.0, mass: 8.0}, %{x: 9.0, y: 10.0, z: 11.0, mass: 12.0}]))
    IO.puts(Kernel.inspect(coord_to_string(Process.get(:r2))))
  end
end
Main.main()
