# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def to_float(x) do
    try do
      throw {:return, x * 1.0}
    catch
      {:return, val} -> val
    end
  end
  def round6(x) do
    try do
      factor = 1000000.0
      throw {:return, to_float(Kernel.trunc(x * factor + 0.5)) / factor}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def validate(values) do
    try do
      if _len(values) == 0 do
        throw {:return, false}
      end
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(values) do
          if Enum.at(values, i) <= 0.0 do
            throw {:return, false}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def effusion_ratio(m1, m2) do
    try do
      if !validate([m1, m2]) do
        IO.puts("ValueError: Molar mass values must greater than 0.")
        throw {:return, 0.0}
      end
      throw {:return, round6(sqrtApprox(m2 / m1))}
    catch
      {:return, val} -> val
    end
  end
  def first_effusion_rate(rate, m1, m2) do
    try do
      if !validate([rate, m1, m2]) do
        IO.puts("ValueError: Molar mass and effusion rate values must greater than 0.")
        throw {:return, 0.0}
      end
      throw {:return, round6(rate * sqrtApprox(m2 / m1))}
    catch
      {:return, val} -> val
    end
  end
  def second_effusion_rate(rate, m1, m2) do
    try do
      if !validate([rate, m1, m2]) do
        IO.puts("ValueError: Molar mass and effusion rate values must greater than 0.")
        throw {:return, 0.0}
      end
      throw {:return, round6(rate / sqrtApprox(m2 / m1))}
    catch
      {:return, val} -> val
    end
  end
  def first_molar_mass(mass, r1, r2) do
    try do
      if !validate([mass, r1, r2]) do
        IO.puts("ValueError: Molar mass and effusion rate values must greater than 0.")
        throw {:return, 0.0}
      end
      ratio = r1 / r2
      throw {:return, round6(mass / (ratio * ratio))}
    catch
      {:return, val} -> val
    end
  end
  def second_molar_mass(mass, r1, r2) do
    try do
      if !validate([mass, r1, r2]) do
        IO.puts("ValueError: Molar mass and effusion rate values must greater than 0.")
        throw {:return, 0.0}
      end
      ratio = r1 / r2
      throw {:return, round6((ratio * ratio) / mass)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(effusion_ratio(2.016, 4.002)))
    IO.puts(Kernel.inspect(first_effusion_rate(1.0, 2.016, 4.002)))
    IO.puts(Kernel.inspect(second_effusion_rate(1.0, 2.016, 4.002)))
    IO.puts(Kernel.inspect(first_molar_mass(2.0, 1.408943, 0.709752)))
    IO.puts(Kernel.inspect(second_molar_mass(2.0, 1.408943, 0.709752)))
  end
end
Main.main()
