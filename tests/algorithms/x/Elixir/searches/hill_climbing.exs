# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def score(sp) do
    try do
      throw {:return, sp.f.(sp.x, sp.y)}
    catch
      {:return, val} -> val
    end
  end
  def neighbors(sp) do
    try do
      s = sp.step
      throw {:return, [%{x: sp.x - s, y: sp.y - s, step: s, f: sp.f}, %{x: sp.x - s, y: sp.y, step: s, f: sp.f}, %{x: sp.x - s, y: sp.y + s, step: s, f: sp.f}, %{x: sp.x, y: sp.y - s, step: s, f: sp.f}, %{x: sp.x, y: sp.y + s, step: s, f: sp.f}, %{x: sp.x + s, y: sp.y - s, step: s, f: sp.f}, %{x: sp.x + s, y: sp.y, step: s, f: sp.f}, %{x: sp.x + s, y: sp.y + s, step: s, f: sp.f}]}
    catch
      {:return, val} -> val
    end
  end
  def equal_state(a, b) do
    try do
      throw {:return, a.x == b.x && a.y == b.y}
    catch
      {:return, val} -> val
    end
  end
  def contains_state(lst, sp) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(lst) do
          if equal_state(Enum.at(lst, i, []), sp) do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      _ = try do
          while_fun.(while_fun, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def hill_climbing(sp, find_max, max_x, min_x, max_y, min_y, max_iter) do
    try do
      current = sp
      visited = []
      iterations = 0
      solution_found = false
      while_fun_2 = fn while_fun_2, current, iterations, solution_found, visited ->
        if solution_found == false && iterations < max_iter do
          {current, iterations, solution_found, visited} = try do
            visited = (visited ++ [current])
            iterations = iterations + 1
            current_score = score(current)
            neighs = neighbors(current)
            max_change = -1000000000000000000.0
            min_change = 1000000000000000000.0
            next = current
            improved = false
            i = 0
            while_fun_3 = fn while_fun_3, i, improved, max_change, min_change, next ->
              if i < _len(neighs) do
                {_, improved, max_change, min_change, next} = try do
                  n = Enum.at(neighs, i, [])
                  i = i + 1
                  if contains_state(visited, n) do
                    throw {:continue, {i, improved, max_change, min_change, next}}
                  end
                  if n.x > max_x || n.x < min_x || n.y > max_y || n.y < min_y do
                    throw {:continue, {i, improved, max_change, min_change, next}}
                  end
                  change = score(n) - current_score
                  {improved, max_change, min_change, next} = if find_max do
                    {improved, max_change, next} = if change > max_change && change > 0.0 do
                      max_change = change
                      next = n
                      improved = true
                      {improved, max_change, next}
                    else
                      {improved, max_change, next}
                    end
                    {improved, max_change, min_change, next}
                  else
                    {improved, min_change, next} = if change < min_change && change < 0.0 do
                      min_change = change
                      next = n
                      improved = true
                      {improved, min_change, next}
                    else
                      {improved, min_change, next}
                    end
                    {improved, max_change, min_change, next}
                  end
                  {_, improved, max_change, min_change, next}
                catch
                  {:continue, {_, improved, max_change, min_change, next}} -> {0, improved, max_change, min_change, next}
                end
                while_fun_3.(while_fun_3, i, improved, max_change, min_change, next)
              else
                {i, improved, max_change, min_change, next}
              end
            end
            {_, improved, max_change, min_change, next} = try do
                while_fun_3.(while_fun_3, i, improved, max_change, min_change, next)
              catch
                {:break, {_, improved, max_change, min_change, next}} -> {0, improved, max_change, min_change, next}
              end

            {current, solution_found} = if improved do
              current = next
              {current, solution_found}
            else
              solution_found = true
              {current, solution_found}
            end
            {current, iterations, solution_found, visited}
          catch
            {:continue, {current, iterations, solution_found, visited}} -> {current, iterations, solution_found, visited}
          end
          while_fun_2.(while_fun_2, current, iterations, solution_found, visited)
        else
          {current, iterations, solution_found, visited}
        end
      end
      {current, iterations, solution_found, visited} = try do
          while_fun_2.(while_fun_2, current, iterations, solution_found, visited)
        catch
          {:break, {current, iterations, solution_found, visited}} -> {current, iterations, solution_found, visited}
        end

      throw {:return, current}
    catch
      {:return, val} -> val
    end
  end
  def test_f1(x, y) do
    try do
      throw {:return, x * x + y * y}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      prob1 = %{x: 3.0, y: 4.0, step: 1.0, f: &test_f1/2}
      local_min1 = hill_climbing(prob1, false, 1000000000.0, -1000000000.0, 1000000000.0, -1000000000.0, 10000)
      IO.puts(Kernel.inspect(Kernel.trunc(score(local_min1))))
      prob2 = %{x: 12.0, y: 47.0, step: 1.0, f: &test_f1/2}
      local_min2 = hill_climbing(prob2, false, 100.0, 5.0, 50.0, -5.0, 10000)
      IO.puts(Kernel.inspect(Kernel.trunc(score(local_min2))))
      prob3 = %{x: 3.0, y: 4.0, step: 1.0, f: &test_f1/2}
      local_max = hill_climbing(prob3, true, 1000000000.0, -1000000000.0, 1000000000.0, -1000000000.0, 1000)
      IO.puts(Kernel.inspect(Kernel.trunc(score(local_max))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
