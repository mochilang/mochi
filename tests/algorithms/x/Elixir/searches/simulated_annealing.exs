# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def score(p, f) do
    try do
      throw {:return, f.(p.x, p.y)}
    catch
      {:return, val} -> val
    end
  end
  def get_neighbors(p) do
    try do
      s = p.step
      ns = []
      ns = (ns ++ [%{x: p.x - s, y: p.y - s, step: s}])
      ns = (ns ++ [%{x: p.x - s, y: p.y, step: s}])
      ns = (ns ++ [%{x: p.x - s, y: p.y + s, step: s}])
      ns = (ns ++ [%{x: p.x, y: p.y - s, step: s}])
      ns = (ns ++ [%{x: p.x, y: p.y + s, step: s}])
      ns = (ns ++ [%{x: p.x + s, y: p.y - s, step: s}])
      ns = (ns ++ [%{x: p.x + s, y: p.y, step: s}])
      ns = (ns ++ [%{x: p.x + s, y: p.y + s, step: s}])
      throw {:return, ns}
    catch
      {:return, val} -> val
    end
  end
  def remove_at(lst, idx) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(lst) do
          res = if i != idx do
            res = (res ++ [Enum.at(lst, i, [])])
            res
          else
            res
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def rand() do
    try do
      _t = _now()
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random_float() do
    try do
      throw {:return, (:erlang.float(rand())) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def randint(low, high) do
    try do
      throw {:return, (rem(rand(), (high - low + 1))) + low}
    catch
      {:return, val} -> val
    end
  end
  def expApprox(x) do
    try do
      y = x
      is_neg = false
      {is_neg, y} = if x < 0.0 do
        is_neg = true
        y = -x
        {is_neg, y}
      else
        {is_neg, y}
      end
      term = 1.0
      sum = 1.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n < 30 do
          term = term * y / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {_, sum, _} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {_, sum, _}} -> {0, sum, 0}
        end

      if is_neg do
        throw {:return, 1.0 / sum}
      end
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def simulated_annealing(search_prob, f, find_max, max_x, min_x, max_y, min_y, start_temp, rate_of_decrease, threshold_temp) do
    try do
      search_end = false
      current_state = search_prob
      current_temp = start_temp
      best_state = current_state
      while_fun_3 = fn while_fun_3, best_state, current_state, current_temp, search_end ->
        if !search_end do
          {best_state, current_state, current_temp, search_end} = try do
            current_score = score(current_state, f)
            best_state = if score(best_state, f) < current_score do
              best_state = current_state
              best_state
            else
              best_state
            end
            next_state = current_state
            found_next = false
            neighbors = get_neighbors(current_state)
            while_fun_4 = fn while_fun_4, found_next, neighbors, next_state ->
              if !found_next && _len(neighbors) > 0 do
                {found_next, neighbors, next_state} = try do
                  idx = randint(0, _len(neighbors) - 1)
                  picked_neighbor = Enum.at(neighbors, idx, [])
                  neighbors = remove_at(neighbors, idx)
                  if picked_neighbor.x > max_x || picked_neighbor.x < min_x || picked_neighbor.y > max_y || picked_neighbor.y < min_y do
                    throw {:continue, {found_next, neighbors, next_state}}
                  end
                  change = score(picked_neighbor, f) - current_score
                  change = if !find_max do
                    change = -change
                    change
                  else
                    change
                  end
                  {found_next, next_state} = if change > 0.0 do
                    next_state = picked_neighbor
                    found_next = true
                    {found_next, next_state}
                  else
                    probability = expApprox(change / current_temp)
                    {found_next, next_state} = if random_float() < probability do
                      next_state = picked_neighbor
                      found_next = true
                      {found_next, next_state}
                    else
                      {found_next, next_state}
                    end
                    {found_next, next_state}
                  end
                  {found_next, neighbors, next_state}
                catch
                  {:continue, {found_next, neighbors, next_state}} -> {found_next, neighbors, next_state}
                end
                while_fun_4.(while_fun_4, found_next, neighbors, next_state)
              else
                {found_next, neighbors, next_state}
              end
            end
            {found_next, neighbors, next_state} = try do
                while_fun_4.(while_fun_4, found_next, neighbors, next_state)
              catch
                {:break, {found_next, neighbors, next_state}} -> {found_next, neighbors, next_state}
              end

            current_temp = current_temp - (current_temp * rate_of_decrease)
            {current_state, search_end} = if current_temp < threshold_temp || (!found_next) do
              search_end = true
              {current_state, search_end}
            else
              current_state = next_state
              {current_state, search_end}
            end
            {best_state, current_state, current_temp, search_end}
          catch
            {:continue, {best_state, current_state, current_temp, search_end}} -> {best_state, current_state, current_temp, search_end}
          end
          while_fun_3.(while_fun_3, best_state, current_state, current_temp, search_end)
        else
          {best_state, current_state, current_temp, search_end}
        end
      end
      {best_state, current_state, current_temp, search_end} = try do
          while_fun_3.(while_fun_3, best_state, current_state, current_temp, search_end)
        catch
          {:break, {best_state, current_state, current_temp, search_end}} -> {best_state, current_state, current_temp, search_end}
        end

      throw {:return, best_state}
    catch
      {:return, val} -> val
    end
  end
  def test_f1(x, y) do
    try do
      throw {:return, x * x + y * y}
    catch
      {:return, val} -> val
    end
  end
  def test_f2(x, y) do
    try do
      throw {:return, (3.0 * x * x) - (6.0 * y)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      prob1 = %{x: 12.0, y: 47.0, step: 1.0}
      min_state = simulated_annealing(prob1, &test_f1/2, false, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0)
      IO.puts("min1 #{Kernel.inspect(test_f1(min_state.x, min_state.y))}")
      prob2 = %{x: 12.0, y: 47.0, step: 1.0}
      max_state = simulated_annealing(prob2, &test_f1/2, true, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0)
      IO.puts("max1 #{Kernel.inspect(test_f1(max_state.x, max_state.y))}")
      prob3 = %{x: 3.0, y: 4.0, step: 1.0}
      min_state2 = simulated_annealing(prob3, &test_f2/2, false, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0)
      IO.puts("min2 #{Kernel.inspect(test_f2(min_state2.x, min_state2.y))}")
      prob4 = %{x: 3.0, y: 4.0, step: 1.0}
      max_state2 = simulated_annealing(prob4, &test_f2/2, true, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0)
      IO.puts("max2 #{Kernel.inspect(test_f2(max_state2.x, max_state2.y))}")
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
