# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def path_cost(path, graph) do
    try do
      total = 0
      i = 0
      while_fun = fn while_fun, i, total ->
        if i < _len(path) - 1 do
          u = Enum.at(path, i, [])
          v = Enum.at(path, i + 1, [])
          total = total + graph[u][v]
          i = i + 1
          while_fun.(while_fun, i, total)
        else
          {i, total}
        end
      end
      {_, total} = try do
          while_fun.(while_fun, i, total)
        catch
          {:break, {_, total}} -> {0, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def generate_first_solution(graph, start) do
    try do
      path = []
      visiting = start
      total = 0
      while_fun_2 = fn while_fun_2, path, total, visiting ->
        if _len(path) < map_size(graph) do
          path = (path ++ [visiting])
          best_node = ""
          best_cost = 1000000
          {best_cost, best_node} = Enum.reduce(Map.keys(graph[visiting]), {best_cost, best_node}, fn n, {best_cost, best_node} ->
            {best_cost, best_node} = if !(n in path) && graph[visiting][n] < best_cost do
              best_cost = graph[visiting][n]
              best_node = n
              {best_cost, best_node}
            else
              {best_cost, best_node}
            end
            {best_cost, best_node}
          end)
          if best_node == "" do
            throw {:break, {path, total, visiting}}
          end
          total = total + best_cost
          visiting = best_node
          while_fun_2.(while_fun_2, path, total, visiting)
        else
          {path, total, visiting}
        end
      end
      {path, total, visiting} = try do
          while_fun_2.(while_fun_2, path, total, visiting)
        catch
          {:break, {path, total, visiting}} -> {path, total, visiting}
        end

      path = (path ++ [start])
      total = total + graph[visiting][start]
      throw {:return, %{path: path, cost: total}}
    catch
      {:return, val} -> val
    end
  end
  def copy_path(path) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(path) do
          res = (res ++ [Enum.at(path, i, [])])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def find_neighborhood(sol, graph) do
    try do
      neighbors = []
      i = 1
      while_fun_4 = fn while_fun_4, i, neighbors ->
        if i < _len(Map.get(sol, :path, [])) - 1 do
          j = 1
          while_fun_5 = fn while_fun_5, j, neighbors ->
            if j < _len(Map.get(sol, :path, [])) - 1 do
              neighbors = if i != j do
                new_path = copy_path(sol.path)
                tmp = Enum.at(new_path, i, [])
                new_path = List.replace_at(new_path, i, Enum.at(new_path, j, []))
                new_path = List.replace_at(new_path, j, tmp)
                cost = path_cost(new_path, graph)
                neighbors = (neighbors ++ [%{path: new_path, cost: cost}])
                neighbors
              else
                neighbors
              end
              j = j + 1
              while_fun_5.(while_fun_5, j, neighbors)
            else
              {j, neighbors}
            end
          end
          {_, neighbors} = try do
              while_fun_5.(while_fun_5, j, neighbors)
            catch
              {:break, {_, neighbors}} -> {0, neighbors}
            end

          i = i + 1
          while_fun_4.(while_fun_4, i, neighbors)
        else
          {i, neighbors}
        end
      end
      {_, neighbors} = try do
          while_fun_4.(while_fun_4, i, neighbors)
        catch
          {:break, {_, neighbors}} -> {0, neighbors}
        end

      throw {:return, neighbors}
    catch
      {:return, val} -> val
    end
  end
  def find_swap(a, b) do
    try do
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(a) do
          if Enum.at(a, i, []) != Enum.at(b, i, []) do
            throw {:return, %{a: Enum.at(a, i, []), b: Enum.at(b, i, [])}}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      _ = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, %{a: "", b: ""}}
    catch
      {:return, val} -> val
    end
  end
  def tabu_search(first, graph, iters, size) do
    try do
      solution = first
      best = first
      tabu = []
      count = 0
      while_fun_7 = fn while_fun_7, count, solution, tabu ->
        if count < iters do
          neighborhood = find_neighborhood(solution, graph)
          if _len(neighborhood) == 0 do
            throw {:break, {count, solution, tabu}}
          end
          best_neighbor = Enum.at(neighborhood, 0, [])
          best_move = find_swap(solution.path, best_neighbor.path)
          i = 1
          while_fun_8 = fn while_fun_8, best_move, best_neighbor, i ->
            if i < _len(neighborhood) do
              cand = Enum.at(neighborhood, i, [])
              move = find_swap(solution.path, cand.path)
              forbidden = false
              t = 0
              while_fun_9 = fn while_fun_9, forbidden, t ->
                if t < _len(tabu) do
                  forbidden = if (Enum.at(tabu, t, []).a == move.a && Enum.at(tabu, t, []).b == move.b) || (Enum.at(tabu, t, []).a == move.b && Enum.at(tabu, t, []).b == move.a) do
                    forbidden = true
                    forbidden
                  else
                    forbidden
                  end
                  t = t + 1
                  while_fun_9.(while_fun_9, forbidden, t)
                else
                  {forbidden, t}
                end
              end
              {forbidden, t} = try do
                  while_fun_9.(while_fun_9, forbidden, t)
                catch
                  {:break, {forbidden, t}} -> {forbidden, t}
                end

              {best_move, best_neighbor} = if forbidden == false && cand.cost < best_neighbor.cost do
                best_neighbor = cand
                best_move = move
                {best_move, best_neighbor}
              else
                {best_move, best_neighbor}
              end
              i = i + 1
              while_fun_8.(while_fun_8, best_move, best_neighbor, i)
            else
              {best_move, best_neighbor, i}
            end
          end
          {best_move, best_neighbor, _} = try do
              while_fun_8.(while_fun_8, best_move, best_neighbor, i)
            catch
              {:break, {best_move, best_neighbor, _}} -> {best_move, best_neighbor, 0}
            end

          solution = best_neighbor
          tabu = (tabu ++ [best_move])
          tabu = if _len(tabu) > size do
            new_tab = []
            j = 1
            while_fun_10 = fn while_fun_10, j, new_tab ->
              if j < _len(tabu) do
                new_tab = (new_tab ++ [Enum.at(tabu, j, [])])
                j = j + 1
                while_fun_10.(while_fun_10, j, new_tab)
              else
                {j, new_tab}
              end
            end
            {_, new_tab} = try do
                while_fun_10.(while_fun_10, j, new_tab)
              catch
                {:break, {_, new_tab}} -> {0, new_tab}
              end

            tabu = new_tab
            tabu
          else
            tabu
          end
          if solution.cost < best.cost do
            best = solution
          end
          count = count + 1
          while_fun_7.(while_fun_7, count, solution, tabu)
        else
          {count, solution, tabu}
        end
      end
      {count, solution, tabu} = try do
          while_fun_7.(while_fun_7, count, solution, tabu)
        catch
          {:break, {count, solution, tabu}} -> {count, solution, tabu}
        end

      throw {:return, best}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:graph, %{"a" => %{"b" => 20, "c" => 18, "d" => 22, "e" => 26}, "b" => %{"a" => 20, "c" => 10, "d" => 11, "e" => 12}, "c" => %{"a" => 18, "b" => 10, "d" => 23, "e" => 24}, "d" => %{"a" => 22, "b" => 11, "c" => 23, "e" => 40}, "e" => %{"a" => 26, "b" => 12, "c" => 24, "d" => 40}})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:first, generate_first_solution(Process.get(:graph), "a"))
    Process.put(:best, tabu_search(Process.get(:first), Process.get(:graph), 4, 3))
    IO.puts(Kernel.inspect(Process.get(:best).path))
    IO.puts(Kernel.to_string(Process.get(:best).cost))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
