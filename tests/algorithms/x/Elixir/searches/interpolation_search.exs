# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def interpolation_search(arr, item) do
    try do
      left = 0
      right = _len(arr) - 1
      while_fun = fn while_fun, left, right ->
        if left <= right do
          if Enum.at(arr, left, []) == Enum.at(arr, right, []) do
            if Enum.at(arr, left, []) == item do
              throw {:return, left}
            end
            throw {:return, -1}
          end
          point = left + div(((item - Enum.at(arr, left, [])) * (right - left)), (Enum.at(arr, right, []) - Enum.at(arr, left, [])))
          if point < 0 || point >= _len(arr) do
            throw {:return, -1}
          end
          current = Enum.at(arr, point, [])
          if current == item do
            throw {:return, point}
          end
          {left, right} = if point < left do
            right = left
            left = point
            {left, right}
          else
            {left, right} = if point > right do
              left = right
              right = point
              {left, right}
            else
              {left, right} = if item < current do
                right = point - 1
                {left, right}
              else
                left = point + 1
                {left, right}
              end
              {left, right}
            end
            {left, right}
          end
          while_fun.(while_fun, left, right)
        else
          {left, right}
        end
      end
      {left, right} = try do
          while_fun.(while_fun, left, right)
        catch
          {:break, {left, right}} -> {left, right}
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def interpolation_search_recursive(arr, item, left, right) do
    try do
      if left > right do
        throw {:return, -1}
      end
      if Enum.at(arr, left, []) == Enum.at(arr, right, []) do
        if Enum.at(arr, left, []) == item do
          throw {:return, left}
        end
        throw {:return, -1}
      end
      point = left + div(((item - Enum.at(arr, left, [])) * (right - left)), (Enum.at(arr, right, []) - Enum.at(arr, left, [])))
      if point < 0 || point >= _len(arr) do
        throw {:return, -1}
      end
      if Enum.at(arr, point, []) == item do
        throw {:return, point}
      end
      if point < left do
        throw {:return, interpolation_search_recursive(arr, item, point, left)}
      end
      if point > right do
        throw {:return, interpolation_search_recursive(arr, item, right, left)}
      end
      if Enum.at(arr, point, []) > item do
        throw {:return, interpolation_search_recursive(arr, item, left, point - 1)}
      end
      throw {:return, interpolation_search_recursive(arr, item, point + 1, right)}
    catch
      {:return, val} -> val
    end
  end
  def interpolation_search_by_recursion(arr, item) do
    try do
      throw {:return, interpolation_search_recursive(arr, item, 0, _len(arr) - 1)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(interpolation_search([1, 2, 3, 4, 5], 2)))
    IO.puts(Kernel.inspect(interpolation_search([1, 2, 3, 4, 5], 6)))
    IO.puts(Kernel.inspect(interpolation_search_by_recursion([0, 5, 7, 10, 15], 5)))
    IO.puts(Kernel.inspect(interpolation_search_by_recursion([0, 5, 7, 10, 15], 100)))
    IO.puts(Kernel.inspect(interpolation_search_by_recursion([5, 5, 5, 5, 5], 3)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
