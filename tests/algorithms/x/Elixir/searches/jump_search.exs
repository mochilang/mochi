# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def int_sqrt(n) do
    try do
      x = 0
      while_fun = fn while_fun, x ->
        if (x + 1) * (x + 1) <= n do
          x = x + 1
          while_fun.(while_fun, x)
        else
          x
        end
      end
      x = try do
          while_fun.(while_fun, x)
        catch
          {:break, {x}} -> x
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def jump_search(arr, item) do
    try do
      arr_size = _len(arr)
      block_size = int_sqrt(arr_size)
      prev = 0
      step = block_size
      while_fun_2 = fn while_fun_2, prev, step ->
        if step < arr_size && Enum.at(arr, step - 1, []) < item do
          prev = step
          step = step + block_size
          if prev >= arr_size do
            throw {:return, -1}
          end
          while_fun_2.(while_fun_2, prev, step)
        else
          {prev, step}
        end
      end
      {prev, step} = try do
          while_fun_2.(while_fun_2, prev, step)
        catch
          {:break, {prev, step}} -> {prev, step}
        end

      while_fun_3 = fn while_fun_3, prev ->
        if prev < arr_size && Enum.at(arr, prev, []) < item do
          prev = prev + 1
          if prev == step do
            throw {:return, -1}
          end
          while_fun_3.(while_fun_3, prev)
        else
          prev
        end
      end
      prev = try do
          while_fun_3.(while_fun_3, prev)
        catch
          {:break, {prev}} -> prev
        end

      if prev < arr_size && Enum.at(arr, prev, []) == item do
        throw {:return, prev}
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(jump_search([0, 1, 2, 3, 4, 5], 3)))
      IO.puts(Kernel.inspect(jump_search([-5, -2, -1], -1)))
      IO.puts(Kernel.inspect(jump_search([0, 5, 10, 20], 8)))
      IO.puts(Kernel.inspect(jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
