# Code generated by Mochi transpiler 2025-08-06 21:32 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  defp _getoutput(cmd) do
    {out, 0} = System.cmd("sh", ["-c", cmd])
    String.trim(out)
  end
  defp _fetch(url) do
    {out, 0} = System.cmd("curl", ["-fsSL", url])
    s = String.trim(out)
    case String.split(s, "\"title\":\"") do
      [_, rest] ->
        case String.split(rest, "\"") do
          [title | _] -> title
          _ -> ""
        end
      _ -> ""
    end
  end
  defp _md5_hex(s) do
    :crypto.hash(:md5, s) |> Base.encode16(case: :lower)
  end
  def encodeToMorse(plaintext) do
    try do
      morse = ""
      i = 0
      while_fun = fn while_fun, i, morse ->
        if i < _len(plaintext) do
          ch = String.upcase(_slice(plaintext, i, (i + 1) - i))
          code = ""
          {code} = if Map.has_key?(Process.get(:morse_code_dict), ch) do
            code = Map.get(Process.get(:morse_code_dict), ch, "")
            {code}
          else
            {code}
          end
          {morse} = if i > 0 do
            morse = (morse <> "x")
            {morse}
          else
            {morse}
          end
          morse = (morse <> code)
          i = i + 1
          while_fun.(while_fun, i, morse)
        else
          {i, morse}
        end
      end
      {i, morse} = try do
          while_fun.(while_fun, i, morse)
        catch
          {:break, {i, morse}} -> {i, morse}
        end

      throw {:return, morse}
    catch
      {:return, val} -> val
    end
  end
  def encryptFractionatedMorse(plaintext, key) do
    try do
      morseCode = encodeToMorse(plaintext)
      combinedKey = (String.upcase(key) <> "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
      dedupKey = ""
      i = 0
      while_fun_2 = fn while_fun_2, dedupKey, i ->
        if i < _len(combinedKey) do
          ch = _slice(combinedKey, i, (i + 1) - i)
          {dedupKey} = if !(ch in dedupKey) do
            dedupKey = (dedupKey <> ch)
            {dedupKey}
          else
            {dedupKey}
          end
          i = i + 1
          while_fun_2.(while_fun_2, dedupKey, i)
        else
          {dedupKey, i}
        end
      end
      {dedupKey, i} = try do
          while_fun_2.(while_fun_2, dedupKey, i)
        catch
          {:break, {dedupKey, i}} -> {dedupKey, i}
        end

      paddingLength = 3 - (rem(_len(morseCode), 3))
      p = 0
      while_fun_3 = fn while_fun_3, morseCode, p ->
        if p < paddingLength do
          morseCode = (morseCode <> "x")
          p = p + 1
          while_fun_3.(while_fun_3, morseCode, p)
        else
          {morseCode, p}
        end
      end
      {morseCode, p} = try do
          while_fun_3.(while_fun_3, morseCode, p)
        catch
          {:break, {morseCode, p}} -> {morseCode, p}
        end

      dict = %{}
      j = 0
      while_fun_4 = fn while_fun_4, dict, j ->
        if j < 26 do
          combo = Enum.at(Process.get(:morse_combinations), j)
          letter = _slice(dedupKey, j, (j + 1) - j)
          dict = Map.put(dict, combo, letter)
          j = j + 1
          while_fun_4.(while_fun_4, dict, j)
        else
          {dict, j}
        end
      end
      {dict, j} = try do
          while_fun_4.(while_fun_4, dict, j)
        catch
          {:break, {dict, j}} -> {dict, j}
        end

      dict = Map.put(dict, "xxx", "")
      encrypted = ""
      k = 0
      while_fun_5 = fn while_fun_5, encrypted, k ->
        if k < _len(morseCode) do
          group = _slice(morseCode, k, (k + 3) - k)
          encrypted = (encrypted <> Map.get(dict, group, ""))
          k = k + 3
          while_fun_5.(while_fun_5, encrypted, k)
        else
          {encrypted, k}
        end
      end
      {encrypted, k} = try do
          while_fun_5.(while_fun_5, encrypted, k)
        catch
          {:break, {encrypted, k}} -> {encrypted, k}
        end

      throw {:return, encrypted}
    catch
      {:return, val} -> val
    end
  end
  def decryptFractionatedMorse(ciphertext, key) do
    try do
      combinedKey = (String.upcase(key) <> "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
      dedupKey = ""
      i = 0
      while_fun_6 = fn while_fun_6, dedupKey, i ->
        if i < _len(combinedKey) do
          ch = _slice(combinedKey, i, (i + 1) - i)
          {dedupKey} = if !(ch in dedupKey) do
            dedupKey = (dedupKey <> ch)
            {dedupKey}
          else
            {dedupKey}
          end
          i = i + 1
          while_fun_6.(while_fun_6, dedupKey, i)
        else
          {dedupKey, i}
        end
      end
      {dedupKey, i} = try do
          while_fun_6.(while_fun_6, dedupKey, i)
        catch
          {:break, {dedupKey, i}} -> {dedupKey, i}
        end

      inv = %{}
      j = 0
      while_fun_7 = fn while_fun_7, inv, j ->
        if j < 26 do
          letter = _slice(dedupKey, j, (j + 1) - j)
          inv = Map.put(inv, letter, Enum.at(Process.get(:morse_combinations), j))
          j = j + 1
          while_fun_7.(while_fun_7, inv, j)
        else
          {inv, j}
        end
      end
      {inv, j} = try do
          while_fun_7.(while_fun_7, inv, j)
        catch
          {:break, {inv, j}} -> {inv, j}
        end

      morse = ""
      k = 0
      while_fun_8 = fn while_fun_8, k, morse ->
        if k < _len(ciphertext) do
          ch = _slice(ciphertext, k, (k + 1) - k)
          {morse} = if Map.has_key?(inv, ch) do
            morse = (morse <> Map.get(inv, ch, ""))
            {morse}
          else
            {morse}
          end
          k = k + 1
          while_fun_8.(while_fun_8, k, morse)
        else
          {k, morse}
        end
      end
      {k, morse} = try do
          while_fun_8.(while_fun_8, k, morse)
        catch
          {:break, {k, morse}} -> {k, morse}
        end

      codes = []
      current = ""
      m = 0
      while_fun_9 = fn while_fun_9, codes, current, m ->
        if m < _len(morse) do
          ch = _slice(morse, m, (m + 1) - m)
          {codes, current} = if ch == "x" do
            codes = (codes ++ [current])
            current = ""
            {codes, current}
          else
            current = (current <> ch)
            {codes, current}
          end
          m = m + 1
          while_fun_9.(while_fun_9, codes, current, m)
        else
          {codes, current, m}
        end
      end
      {codes, current, m} = try do
          while_fun_9.(while_fun_9, codes, current, m)
        catch
          {:break, {codes, current, m}} -> {codes, current, m}
        end

      codes = (codes ++ [current])
      decrypted = ""
      idx = 0
      while_fun_10 = fn while_fun_10, idx ->
        if idx < _len(codes) do
          code = Enum.at(codes, idx)
          decrypted = (decrypted <> Map.get(Process.get(:reverse_dict), code, ""))
          idx = idx + 1
          while_fun_10.(while_fun_10, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_10.(while_fun_10, idx)
        catch
          {:break, {idx}} -> idx
        end

      start = 0
      while_fun_11 = fn while_fun_11, start ->
        if true do
          try do
            {start} = if start < _len(decrypted) do
              {start} = if _slice(decrypted, start, (start + 1) - start) == " " do
                start = start + 1
                throw :continue
                {start}
              else
                {start}
              end
              {start}
            else
              {start}
            end
            throw {:break, {start}}
          catch
            :continue -> nil
          end
          while_fun_11.(while_fun_11, start)
        else
          start
        end
      end
      start = try do
          while_fun_11.(while_fun_11, start)
        catch
          {:break, {start}} -> start
        end

      end_ = _len(decrypted)
      while_fun_12 = fn while_fun_12, end_ ->
        if true do
          try do
            {end_} = if end_ > start do
              {end_} = if _slice(decrypted, end_ - 1, end_ - (end_ - 1)) == " " do
                end_ = end_ - 1
                throw :continue
                {end_}
              else
                {end_}
              end
              {end_}
            else
              {end_}
            end
            throw {:break, {end_}}
          catch
            :continue -> nil
          end
          while_fun_12.(while_fun_12, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_12.(while_fun_12, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(decrypted, start, end_ - start)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:morse_code_dict, %{"A" => ".-", "B" => "-...", "C" => "-.-.", "D" => "-..", "E" => ".", "F" => "..-.", "G" => "--.", "H" => "....", "I" => "..", "J" => ".---", "K" => "-.-", "L" => ".-..", "M" => "--", "N" => "-.", "O" => "---", "P" => ".--.", "Q" => "--.-", "R" => ".-.", "S" => "...", "T" => "-", "U" => "..-", "V" => "...-", "W" => ".--", "X" => "-..-", "Y" => "-.--", "Z" => "--..", " " => ""})
  Process.put(:morse_combinations, ["...", "..-", "..x", ".-.", ".--", ".-x", ".x.", ".x-", ".xx", "-..", "-.-", "-.x", "--.", "---", "--x", "-x.", "-x-", "-xx", "x..", "x.-", "x.x", "x-.", "x--", "x-x", "xx.", "xx-", "xxx"])
  Process.put(:reverse_dict, %{".-" => "A", "-..." => "B", "-.-." => "C", "-.." => "D", "." => "E", "..-." => "F", "--." => "G", "...." => "H", ".." => "I", ".---" => "J", "-.-" => "K", ".-.." => "L", "--" => "M", "-." => "N", "---" => "O", ".--." => "P", "--.-" => "Q", ".-." => "R", "..." => "S", "-" => "T", "..-" => "U", "...-" => "V", ".--" => "W", "-..-" => "X", "-.--" => "Y", "--.." => "Z", "" => " "})
  Process.put(:plaintext, "defend the east")
  Process.put(:key, "ROUNDTABLE")
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts("Plain Text: #{Process.get(:plaintext)}")
    Process.put(:ciphertext, encryptFractionatedMorse(Process.get(:plaintext), Process.get(:key)))
    IO.puts("Encrypted: #{Process.get(:ciphertext)}")
    Process.put(:decrypted, decryptFractionatedMorse(Process.get(:ciphertext), Process.get(:key)))
    IO.puts("Decrypted: #{Process.get(:decrypted)}")
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
