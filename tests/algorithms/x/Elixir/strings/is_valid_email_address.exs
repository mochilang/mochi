# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def count_char(s, target) do
    try do
      cnt = 0
      i = 0
      while_fun = fn while_fun, cnt, i ->
        if i < _len(s) do
          {cnt} = if _slice(s, i, i + 1 - (i)) == target do
            cnt = cnt + 1
            {cnt}
          else
            {cnt}
          end
          i = i + 1
          while_fun.(while_fun, cnt, i)
        else
          {cnt, i}
        end
      end
      {cnt, i} = try do
          while_fun.(while_fun, cnt, i)
        catch
          {:break, {cnt, i}} -> {cnt, i}
        end

      throw {:return, cnt}
    catch
      {:return, val} -> val
    end
  end
  def char_in(c, allowed) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(allowed) do
          if _slice(allowed, i, i + 1 - (i)) == c do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def starts_with_char(s, c) do
    try do
      throw {:return, _len(s) > 0 && _slice(s, 0, 1 - (0)) == c}
    catch
      {:return, val} -> val
    end
  end
  def ends_with_char(s, c) do
    try do
      throw {:return, _len(s) > 0 && _slice(s, _len(s) - 1, _len(s) - (_len(s) - 1)) == c}
    catch
      {:return, val} -> val
    end
  end
  def contains_double_dot(s) do
    try do
      if _len(s) < 2 do
        throw {:return, false}
      end
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(s) - 1 do
          if _slice(s, i, i + 2 - (i)) == ".." do
            throw {:return, true}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_valid_email_address(email) do
    try do
      if count_char(email, "@") != 1 do
        throw {:return, false}
      end
      at_idx = 0
      i = 0
      while_fun_4 = fn while_fun_4, at_idx, i ->
        if i < _len(email) do
          {at_idx} = if _slice(email, i, i + 1 - (i)) == "@" do
            at_idx = i
            throw {:break, {at_idx, i}}
            {at_idx}
          else
            {at_idx}
          end
          i = i + 1
          while_fun_4.(while_fun_4, at_idx, i)
        else
          {at_idx, i}
        end
      end
      {at_idx, i} = try do
          while_fun_4.(while_fun_4, at_idx, i)
        catch
          {:break, {at_idx, i}} -> {at_idx, i}
        end

      local_part = _slice(email, 0, at_idx - (0))
      domain = _slice(email, at_idx + 1, _len(email) - (at_idx + 1))
      if _len(local_part) > Process.get(:max_local_part_octets) || _len(domain) > Process.get(:max_domain_octets) do
        throw {:return, false}
      end
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i < _len(local_part) do
          ch = _slice(local_part, i, i + 1 - (i))
          if !char_in(ch, ((Process.get(:ascii_letters) <> Process.get(:digits)) <> Process.get(:local_extra))) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

      if starts_with_char(local_part, ".") || ends_with_char(local_part, ".") || contains_double_dot(local_part) do
        throw {:return, false}
      end
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(domain) do
          ch = _slice(domain, i, i + 1 - (i))
          if !char_in(ch, ((Process.get(:ascii_letters) <> Process.get(:digits)) <> Process.get(:domain_extra))) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      if starts_with_char(domain, "-") || ends_with_char(domain, ".") do
        throw {:return, false}
      end
      if starts_with_char(domain, ".") || ends_with_char(domain, ".") || contains_double_dot(domain) do
        throw {:return, false}
      end
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:max_local_part_octets, 64)
  Process.put(:max_domain_octets, 255)
  Process.put(:ascii_letters, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
  Process.put(:digits, "0123456789")
  Process.put(:local_extra, ".(!#$%&'*+-/=?^_`{|}~)")
  Process.put(:domain_extra, ".-")
  Process.put(:email_tests, ["simple@example.com", "very.common@example.com", "disposable.style.email.with+symbol@example.com", "other-email-with-hyphen@and.subdomains.example.com", "fully-qualified-domain@example.com", "user.name+tag+sorting@example.com", "x@example.com", "example-indeed@strange-example.com", "test/test@test.com", "123456789012345678901234567890123456789012345678901234567890123@example.com", "admin@mailserver1", "example@s.example", "Abc.example.com", "A@b@c@example.com", "abc@example..com", "a(c)d,e:f;g<h>i[j\\k]l@example.com", "12345678901234567890123456789012345678901234567890123456789012345@example.com", "i.like.underscores@but_its_not_allowed_in_this_part", ""])
  Process.put(:idx, 0)
  def main() do
    while_fun_7 = fn while_fun_7 ->
      if Process.get(:idx) < _len(Process.get(:email_tests)) do
        email = Enum.at(Process.get(:email_tests), Process.get(:idx), [])
        IO.puts(Kernel.inspect(is_valid_email_address(email)))
        Process.put(:idx, Process.get(:idx) + 1)
        while_fun_7.(while_fun_7)
      else
        nil
      end
    end
    try do
      while_fun_7.(while_fun_7)
    catch
      :break -> nil
    end

  end
end
Main.main()
