# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def to_upper(s) do
    try do
      res = ""
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(s) do
          c = _slice(s, i, (i + 1) - i)
          j = 0
          up = c
          while_fun_2 = fn while_fun_2, j, up ->
            if j < _len(Process.get(:lower)) do
              {up} = if c == _slice(Process.get(:lower), j, (j + 1) - j) do
                up = _slice(Process.get(:upper), j, (j + 1) - j)
                throw {:break, {j, up}}
                {up}
              else
                {up}
              end
              j = j + 1
              while_fun_2.(while_fun_2, j, up)
            else
              {j, up}
            end
          end
          {j, up} = try do
              while_fun_2.(while_fun_2, j, up)
            catch
              {:break, {j, up}} -> {j, up}
            end

          res = (res <> up)
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def char_in(chars, c) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(chars) do
          if _slice(chars, i, (i + 1) - i) == c do
            throw {:return, true}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def remove_non_letters(message) do
    try do
      res = ""
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(message) do
          ch = _slice(message, i, (i + 1) - i)
          {res} = if char_in(Process.get(:letters_and_space), ch) do
            res = (res <> ch)
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def split_spaces(text) do
    try do
      res = []
      current = ""
      i = 0
      while_fun_5 = fn while_fun_5, current, i, res ->
        if i < _len(text) do
          ch = _slice(text, i, (i + 1) - i)
          {current, res} = if ch == " " do
            res = (res ++ [current])
            current = ""
            {current, res}
          else
            current = (current <> ch)
            {current, res}
          end
          i = i + 1
          while_fun_5.(while_fun_5, current, i, res)
        else
          {current, i, res}
        end
      end
      {current, i, res} = try do
          while_fun_5.(while_fun_5, current, i, res)
        catch
          {:break, {current, i, res}} -> {current, i, res}
        end

      res = (res ++ [current])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def load_dictionary() do
    try do
      words = ["HELLO", "WORLD", "HOW", "ARE", "YOU", "THE", "QUICK", "BROWN", "FOX", "JUMPS", "OVER", "LAZY", "DOG"]
      dict = %{}
      {dict} = Enum.reduce(words, {dict}, fn w, {dict} ->
        dict = Map.put(dict, w, true)
        {dict}
      end)
      throw {:return, dict}
    catch
      {:return, val} -> val
    end
  end
  def get_english_count(message) do
    try do
      upper = to_upper(message)
      cleaned = remove_non_letters(upper)
      possible = split_spaces(cleaned)
      matches = 0
      total = 0
      {matches, total} = Enum.reduce(possible, {matches, total}, fn w, {matches, total} ->
        {matches, total} = if w != "" do
          total = total + 1
          {matches} = if Map.has_key?(Process.get(:english_words), w) do
            matches = matches + 1
            {matches}
          else
            {matches}
          end
          {matches, total}
        else
          {matches, total}
        end
        {matches, total}
      end)
      if total == 0 do
        throw {:return, 0.0}
      end
      throw {:return, (:erlang.float(matches)) / (:erlang.float(total))}
    catch
      {:return, val} -> val
    end
  end
  def is_english(message, word_percentage, letter_percentage) do
    try do
      words_match = get_english_count(message) * 100.0 >= (:erlang.float(word_percentage))
      num_letters = _len(remove_non_letters(message))
      letters_pct = (if _len(message) == 0, do: 0.0, else: (:erlang.float(num_letters)) / (:erlang.float(_len(message))) * 100.0)
      letters_match = letters_pct >= (:erlang.float(letter_percentage))
      throw {:return, words_match && letters_match}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:letters_and_space, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz \t\n")
  Process.put(:lower, "abcdefghijklmnopqrstuvwxyz")
  Process.put(:upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  def main() do
    Process.put(:english_words, load_dictionary())
    IO.puts(Kernel.inspect(is_english("Hello World", 20, 85)))
    IO.puts(Kernel.inspect(is_english("llold HorWd", 20, 85)))
  end
end
Main.main()
