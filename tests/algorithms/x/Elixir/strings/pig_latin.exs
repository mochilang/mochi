# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def strip(s) do
    try do
      start = 0
      end_ = _len(s)
      while_fun = fn while_fun, start ->
        if start < end_ && _slice(s, start, start + 1 - (start)) == " " do
          start = start + 1
          while_fun.(while_fun, start)
        else
          start
        end
      end
      start = try do
          while_fun.(while_fun, start)
        catch
          {:break, {start}} -> start
        end

      while_fun_2 = fn while_fun_2, end_ ->
        if end_ > start && _slice(s, end_ - 1, end_ - (end_ - 1)) == " " do
          end_ = end_ - 1
          while_fun_2.(while_fun_2, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_2.(while_fun_2, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - (start))}
    catch
      {:return, val} -> val
    end
  end
  def is_vowel(c) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(Process.get(:vowels)) do
          if c == _slice(Process.get(:vowels), i, i + 1 - (i)) do
            throw {:return, true}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def pig_latin(word) do
    try do
      trimmed = strip(word)
      if _len(trimmed) == 0 do
        throw {:return, ""}
      end
      w = String.downcase(trimmed)
      first = _slice(w, 0, 1 - (0))
      if is_vowel(first) do
        throw {:return, (w <> "way")}
      end
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(w) do
          ch = _slice(w, i, i + 1 - (i))
          if is_vowel(ch) do
            throw {:break, {i}}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, ((_slice(w, i, _len(w) - (i)) <> _slice(w, 0, i - (0))) <> "ay")}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:vowels, "aeiou")
  def main() do
    IO.puts(("pig_latin('friends') = " <> pig_latin("friends")))
    IO.puts(("pig_latin('smile') = " <> pig_latin("smile")))
    IO.puts(("pig_latin('eat') = " <> pig_latin("eat")))
  end
end
Main.main()
