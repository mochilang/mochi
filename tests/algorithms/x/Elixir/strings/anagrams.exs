# Code generated by Mochi transpiler 2025-08-24 08:57 +0700
defmodule Main do
  @data_dir "/workspace/mochi/tests/github/TheAlgorithms/Mochi/strings"
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _read_file(path) do
    p = if @data_dir != nil and @data_dir != "" and not File.exists?(path) do
      Path.join(@data_dir, path)
    else
      path
    end
    case File.read(p) do
      {:ok, data} -> data
      _ -> ""
    end
  end
  def split(s, sep) do
    try do
      res = []
      current = ""
      i = 0
      while_fun = fn while_fun, current, i, res ->
        if i < _len(s) do
          ch = _slice(s, i, (i + 1) - i)
          {current, res} = if ch == sep do
            res = (res ++ [current])
            current = ""
            {current, res}
          else
            current = (current <> ch)
            {current, res}
          end
          i = i + 1
          while_fun.(while_fun, current, i, res)
        else
          {current, i, res}
        end
      end
      {current, _, res} = try do
          while_fun.(while_fun, current, i, res)
        catch
          {:break, {current, _, res}} -> {current, 0, res}
        end

      res = (res ++ [current])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def insertion_sort(arr) do
    try do
      a = arr
      i = 1
      while_fun_2 = fn while_fun_2, a, i ->
        if i < _len(a) do
          key = Enum.at(a, i, [])
          j = i - 1
          while_fun_3 = fn while_fun_3, a, j ->
            if j >= 0 && Enum.at(a, j, []) > key do
              a = List.replace_at(a, j + 1, Enum.at(a, j, []))
              j = j - 1
              while_fun_3.(while_fun_3, a, j)
            else
              {a, j}
            end
          end
          {a, _} = try do
              while_fun_3.(while_fun_3, a, j)
            catch
              {:break, {a, _}} -> {a, 0}
            end

          a = List.replace_at(a, j + 1, key)
          i = i + 1
          while_fun_2.(while_fun_2, a, i)
        else
          {a, i}
        end
      end
      {a, _} = try do
          while_fun_2.(while_fun_2, a, i)
        catch
          {:break, {a, _}} -> {a, 0}
        end

      throw {:return, a}
    catch
      {:return, val} -> val
    end
  end
  def sort_chars(word) do
    try do
      chars = []
      i = 0
      while_fun_4 = fn while_fun_4, chars, i ->
        if i < _len(word) do
          chars = (chars ++ [_slice(word, i, (i + 1) - i)])
          i = i + 1
          while_fun_4.(while_fun_4, chars, i)
        else
          {chars, i}
        end
      end
      {chars, _} = try do
          while_fun_4.(while_fun_4, chars, i)
        catch
          {:break, {chars, _}} -> {chars, 0}
        end

      chars = insertion_sort(chars)
      res = ""
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(chars) do
          res = (res <> Enum.at(chars, i, []))
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def unique_sorted(words) do
    try do
      seen = %{}
      res = []
      {res, seen} = Enum.reduce(words, {res, seen}, fn w, {res, seen} ->
        {res, seen} = if w != "" && not_(Map.has_key?(seen, w)) do
          res = (res ++ [w])
          seen = Map.put(seen, w, true)
          {res, seen}
        else
          {res, seen}
        end
        {res, seen}
      end)
      res = insertion_sort(res)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def build_map(words) do
    try do
      Enum.each(words, fn w ->
        sig = sort_chars(w)
        arr = []
        arr = if Map.has_key?(Process.get(:word_by_signature), sig) do
          arr = Process.get(:word_by_signature)[sig]
          arr
        else
          arr
        end
        arr = (arr ++ [w])
        Process.put(:word_by_signature, Map.put(Process.get(:word_by_signature), sig, arr))
      end)
    catch
      {:return, val} -> val
    end
  end
  def anagram(my_word) do
    try do
      sig = sort_chars(my_word)
      if Map.has_key?(Process.get(:word_by_signature), sig) do
        throw {:return, Process.get(:word_by_signature)[sig]}
      end
      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      text = _read_file("words.txt")
      lines = split(text, "\n")
      words = unique_sorted(lines)
      words = build_map(words)
      Enum.each(words, fn w ->
        anas = anagram(w)
        if _len(anas) > 1 do
          line = (w <> ":")
          i = 0
          while_fun_6 = fn while_fun_6, i, line ->
            if i < _len(anas) do
              line = if i > 0 do
                line = (line <> ",")
                line
              else
                line
              end
              line = (line <> Enum.at(anas, i, []))
              i = i + 1
              while_fun_6.(while_fun_6, i, line)
            else
              {i, line}
            end
          end
          {_, line} = try do
              while_fun_6.(while_fun_6, i, line)
            catch
              {:break, {_, line}} -> {0, line}
            end

          line = IO.puts(line)
        end
      end)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:word_by_signature, %{})
end
Main.main()
