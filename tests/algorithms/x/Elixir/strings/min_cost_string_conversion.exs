# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def string_to_chars(s) do
    try do
      chars = []
      i = 0
      while_fun = fn while_fun, chars, i ->
        if i < _len(s) do
          chars = (chars ++ [_slice(s, i, i + 1 - (i))])
          i = i + 1
          while_fun.(while_fun, chars, i)
        else
          {chars, i}
        end
      end
      {chars, i} = try do
          while_fun.(while_fun, chars, i)
        catch
          {:break, {chars, i}} -> {chars, i}
        end

      throw {:return, chars}
    catch
      {:return, val} -> val
    end
  end
  def join_chars(chars) do
    try do
      res = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(chars) do
          res = (res <> Enum.at(chars, i, []))
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def insert_at(chars, index, ch) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < index do
          res = (res ++ [Enum.at(chars, i, [])])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res ++ [ch])
      while_fun_4 = fn while_fun_4, i, res ->
        if i < _len(chars) do
          res = (res ++ [Enum.at(chars, i, [])])
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def remove_at(chars, index) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(chars) do
          {res} = if i != index do
            res = (res ++ [Enum.at(chars, i, [])])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def make_matrix_int(rows, cols, init) do
    try do
      matrix = []
      {matrix} = Enum.reduce((0..(rows - 1)//1), {matrix}, fn _, {matrix} ->
        row = []
        {row} = Enum.reduce((0..(cols - 1)//1), {row}, fn _2, {row} ->
          row = (row ++ [init])
          {row}
        end)
        matrix = (matrix ++ [row])
        {matrix}
      end)
      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def make_matrix_string(rows, cols, init) do
    try do
      matrix = []
      {matrix} = Enum.reduce((0..(rows - 1)//1), {matrix}, fn _, {matrix} ->
        row = []
        {row} = Enum.reduce((0..(cols - 1)//1), {row}, fn _2, {row} ->
          row = (row ++ [init])
          {row}
        end)
        matrix = (matrix ++ [row])
        {matrix}
      end)
      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def compute_transform_tables(source_string, destination_string, copy_cost, replace_cost, delete_cost, insert_cost) do
    try do
      source_seq = string_to_chars(source_string)
      dest_seq = string_to_chars(destination_string)
      m = _len(source_seq)
      n = _len(dest_seq)
      costs = make_matrix_int(m + 1, n + 1, 0)
      ops = make_matrix_string(m + 1, n + 1, "0")
      i = 1
      while_fun_6 = fn while_fun_6, costs, i, ops ->
        if i <= m do
          costs = List.replace_at(costs, i, List.replace_at(Enum.at(costs, i), 0, i * delete_cost))
          ops = List.replace_at(ops, i, List.replace_at(Enum.at(ops, i), 0, ("D" <> Enum.at(source_seq, i - 1, []))))
          i = i + 1
          while_fun_6.(while_fun_6, costs, i, ops)
        else
          {costs, i, ops}
        end
      end
      {costs, i, ops} = try do
          while_fun_6.(while_fun_6, costs, i, ops)
        catch
          {:break, {costs, i, ops}} -> {costs, i, ops}
        end

      j = 1
      while_fun_7 = fn while_fun_7, costs, j, ops ->
        if j <= n do
          costs = List.replace_at(costs, 0, List.replace_at(Enum.at(costs, 0), j, j * insert_cost))
          ops = List.replace_at(ops, 0, List.replace_at(Enum.at(ops, 0), j, ("I" <> Enum.at(dest_seq, j - 1, []))))
          j = j + 1
          while_fun_7.(while_fun_7, costs, j, ops)
        else
          {costs, j, ops}
        end
      end
      {costs, j, ops} = try do
          while_fun_7.(while_fun_7, costs, j, ops)
        catch
          {:break, {costs, j, ops}} -> {costs, j, ops}
        end

      i = 1
      while_fun_8 = fn while_fun_8, costs, i, j, ops ->
        if i <= m do
          j = 1
          while_fun_9 = fn while_fun_9, costs, j, ops ->
            if j <= n do
              {costs, ops} = if Enum.at(source_seq, i - 1, []) == Enum.at(dest_seq, j - 1, []) do
                costs = List.replace_at(costs, i, List.replace_at(Enum.at(costs, i), j, Enum.at(Enum.at(costs, i - 1, []), j - 1, 0) + copy_cost))
                ops = List.replace_at(ops, i, List.replace_at(Enum.at(ops, i), j, ("C" <> Enum.at(source_seq, i - 1, []))))
                {costs, ops}
              else
                costs = List.replace_at(costs, i, List.replace_at(Enum.at(costs, i), j, Enum.at(Enum.at(costs, i - 1, []), j - 1, 0) + replace_cost))
                ops = List.replace_at(ops, i, List.replace_at(Enum.at(ops, i), j, (("R" <> Enum.at(source_seq, i - 1, [])) <> Enum.at(dest_seq, j - 1, []))))
                {costs, ops}
              end
              {costs, ops} = if Enum.at(Enum.at(costs, i - 1, []), j, 0) + delete_cost < Enum.at(Enum.at(costs, i, []), j, 0) do
                costs = List.replace_at(costs, i, List.replace_at(Enum.at(costs, i), j, Enum.at(Enum.at(costs, i - 1, []), j, 0) + delete_cost))
                ops = List.replace_at(ops, i, List.replace_at(Enum.at(ops, i), j, ("D" <> Enum.at(source_seq, i - 1, []))))
                {costs, ops}
              else
                {costs, ops}
              end
              {costs, ops} = if Enum.at(Enum.at(costs, i, []), j - 1, 0) + insert_cost < Enum.at(Enum.at(costs, i, []), j, 0) do
                costs = List.replace_at(costs, i, List.replace_at(Enum.at(costs, i), j, Enum.at(Enum.at(costs, i, []), j - 1, 0) + insert_cost))
                ops = List.replace_at(ops, i, List.replace_at(Enum.at(ops, i), j, ("I" <> Enum.at(dest_seq, j - 1, []))))
                {costs, ops}
              else
                {costs, ops}
              end
              j = j + 1
              while_fun_9.(while_fun_9, costs, j, ops)
            else
              {costs, j, ops}
            end
          end
          {costs, j, ops} = try do
              while_fun_9.(while_fun_9, costs, j, ops)
            catch
              {:break, {costs, j, ops}} -> {costs, j, ops}
            end

          i = i + 1
          while_fun_8.(while_fun_8, costs, i, j, ops)
        else
          {costs, i, j, ops}
        end
      end
      {costs, i, j, ops} = try do
          while_fun_8.(while_fun_8, costs, i, j, ops)
        catch
          {:break, {costs, i, j, ops}} -> {costs, i, j, ops}
        end

      throw {:return, %{costs: costs, ops: ops}}
    catch
      {:return, val} -> val
    end
  end
  def assemble_transformation(ops, i, j) do
    try do
      if i == 0 && j == 0 do
        throw {:return, []}
      end
      op = Enum.at(Enum.at(ops, i, []), j, 0)
      kind = _slice(op, 0, 1 - (0))
      if kind == "C" || kind == "R" do
        seq = assemble_transformation(ops, i - 1, j - 1)
        seq = (seq ++ [op])
        throw {:return, seq}
      else
        if kind == "D" do
          seq = assemble_transformation(ops, i - 1, j)
          seq = (seq ++ [op])
          throw {:return, seq}
        else
          seq = assemble_transformation(ops, i, j - 1)
          seq = (seq ++ [op])
          throw {:return, seq}
        end
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      copy_cost = -1
      replace_cost = 1
      delete_cost = 2
      insert_cost = 2
      src = "Python"
      dst = "Algorithms"
      tables = compute_transform_tables(src, dst, copy_cost, replace_cost, delete_cost, insert_cost)
      operations = tables.ops
      m = _len(operations)
      n = _len(Enum.at(operations, 0, []))
      sequence = assemble_transformation(operations, m - 1, n - 1)
      string_list = string_to_chars(src)
      idx = 0
      cost = 0
      k = 0
      while_fun_10 = fn while_fun_10, cost, idx, k, string_list ->
        if k < _len(sequence) do
          IO.puts(Kernel.inspect(join_chars(string_list)))
          op = Enum.at(sequence, k, [])
          kind = _slice(op, 0, 1 - (0))
          {cost, string_list} = if kind == "C" do
            cost = cost + copy_cost
            {cost, string_list}
          else
            {cost, string_list} = if kind == "R" do
              string_list = List.replace_at(string_list, idx, _slice(op, 2, 3 - (2)))
              cost = cost + replace_cost
              {cost, string_list}
            else
              {cost, string_list} = if kind == "D" do
                string_list = remove_at(string_list, idx)
                cost = cost + delete_cost
                {cost, string_list}
              else
                string_list = insert_at(string_list, idx, _slice(op, 1, 2 - (1)))
                cost = cost + insert_cost
                {cost, string_list}
              end
              {cost, string_list}
            end
            {cost, string_list}
          end
          idx = idx + 1
          k = k + 1
          while_fun_10.(while_fun_10, cost, idx, k, string_list)
        else
          {cost, idx, k, string_list}
        end
      end
      {cost, idx, k, string_list} = try do
          while_fun_10.(while_fun_10, cost, idx, k, string_list)
        catch
          {:break, {cost, idx, k, string_list}} -> {cost, idx, k, string_list}
        end

      IO.puts(Kernel.inspect(join_chars(string_list)))
      IO.puts(("Cost: " <> Kernel.to_string(cost)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
