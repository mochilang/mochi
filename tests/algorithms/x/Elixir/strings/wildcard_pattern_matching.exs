# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_matrix_bool(rows, cols, init) do
    try do
      matrix = []
      {matrix} = Enum.reduce((0..(rows - 1)//1), {matrix}, fn _, {matrix} ->
        row = []
        {row} = Enum.reduce((0..(cols - 1)//1), {row}, fn _2, {row} ->
          row = (row ++ [init])
          {row}
        end)
        matrix = (matrix ++ [row])
        {matrix}
      end)
      throw {:return, matrix}
    catch
      {:return, val} -> val
    end
  end
  def match_pattern(input_string, pattern) do
    try do
      len_string = _len(input_string) + 1
      len_pattern = _len(pattern) + 1
      dp = make_matrix_bool(len_string, len_pattern, false)
      row0 = Enum.at(dp, 0, [])
      row0 = List.replace_at(row0, 0, true)
      dp = List.replace_at(dp, 0, row0)
      j = 1
      while_fun = fn while_fun, dp, j, row0 ->
        if j < len_pattern do
          row0 = Enum.at(dp, 0, [])
          row0 = List.replace_at(row0, j, ((if _slice(pattern, j - 1, j - (j - 1)) == "*", do: Enum.at(row0, j - 2, []), else: false)))
          dp = List.replace_at(dp, 0, row0)
          j = j + 1
          while_fun.(while_fun, dp, j, row0)
        else
          {dp, j, row0}
        end
      end
      {dp, j, row0} = try do
          while_fun.(while_fun, dp, j, row0)
        catch
          {:break, {dp, j, row0}} -> {dp, j, row0}
        end

      i = 1
      while_fun_2 = fn while_fun_2, dp, i ->
        if i < len_string do
          row = Enum.at(dp, i, [])
          j2 = 1
          while_fun_3 = fn while_fun_3, j2, row ->
            if j2 < len_pattern do
              s_char = _slice(input_string, i - 1, i - (i - 1))
              p_char = _slice(pattern, j2 - 1, j2 - (j2 - 1))
              {row} = if s_char == p_char || p_char == "." do
                row = List.replace_at(row, j2, Enum.at(Enum.at(dp, i - 1, []), j2 - 1, 0))
                {row}
              else
                {row} = if p_char == "*" do
                  val = Enum.at(Enum.at(dp, i, []), j2 - 2, 0)
                  prev_p = _slice(pattern, j2 - 2, j2 - 1 - (j2 - 2))
                  {val} = if !val && (prev_p == s_char || prev_p == ".") do
                    val = Enum.at(Enum.at(dp, i - 1, []), j2, 0)
                    {val}
                  else
                    {val}
                  end
                  row = List.replace_at(row, j2, val)
                  {row}
                else
                  row = List.replace_at(row, j2, false)
                  {row}
                end
                {row}
              end
              j2 = j2 + 1
              while_fun_3.(while_fun_3, j2, row)
            else
              {j2, row}
            end
          end
          {j2, row} = try do
              while_fun_3.(while_fun_3, j2, row)
            catch
              {:break, {j2, row}} -> {j2, row}
            end

          dp = List.replace_at(dp, i, row)
          i = i + 1
          while_fun_2.(while_fun_2, dp, i)
        else
          {dp, i}
        end
      end
      {dp, i} = try do
          while_fun_2.(while_fun_2, dp, i)
        catch
          {:break, {dp, i}} -> {dp, i}
        end

      throw {:return, Enum.at(Enum.at(dp, len_string - 1, []), len_pattern - 1, 0)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      if !match_pattern("aab", "c*a*b") do
        raise("case1 failed")
      end
      if match_pattern("dabc", "*abc") do
        raise("case2 failed")
      end
      if match_pattern("aaa", "aa") do
        raise("case3 failed")
      end
      if !match_pattern("aaa", "a.a") do
        raise("case4 failed")
      end
      if match_pattern("aaab", "aa*") do
        raise("case5 failed")
      end
      if !match_pattern("aaab", ".*") do
        raise("case6 failed")
      end
      if match_pattern("a", "bbbb") do
        raise("case7 failed")
      end
      if match_pattern("", "bbbb") do
        raise("case8 failed")
      end
      if match_pattern("a", "") do
        raise("case9 failed")
      end
      if !match_pattern("", "") do
        raise("case10 failed")
      end
      IO.puts(Kernel.inspect(match_pattern("aab", "c*a*b")))
      IO.puts(Kernel.inspect(match_pattern("dabc", "*abc")))
      IO.puts(Kernel.inspect(match_pattern("aaa", "aa")))
      IO.puts(Kernel.inspect(match_pattern("aaa", "a.a")))
      IO.puts(Kernel.inspect(match_pattern("aaab", "aa*")))
      IO.puts(Kernel.inspect(match_pattern("aaab", ".*")))
      IO.puts(Kernel.inspect(match_pattern("a", "bbbb")))
      IO.puts(Kernel.inspect(match_pattern("", "bbbb")))
      IO.puts(Kernel.inspect(match_pattern("a", "")))
      IO.puts(Kernel.inspect(match_pattern("", "")))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
