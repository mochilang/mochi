# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def index_of_char(s, ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(s) do
          if String.at(s, i) == ch do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def ord(ch) do
    try do
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      lower = "abcdefghijklmnopqrstuvwxyz"
      digits = "0123456789"
      idx = index_of_char(upper, ch)
      if idx >= 0 do
        throw {:return, 65 + idx}
      end
      idx = index_of_char(lower, ch)
      if idx >= 0 do
        throw {:return, 97 + idx}
      end
      idx = index_of_char(digits, ch)
      if idx >= 0 do
        throw {:return, 48 + idx}
      end
      if ch == "ü" do
        throw {:return, 252}
      end
      if ch == "Ü" do
        throw {:return, 220}
      end
      if ch == " " do
        throw {:return, 32}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def rabin_karp(pattern, text) do
    try do
      p_len = _len(pattern)
      t_len = _len(text)
      if p_len > t_len do
        throw {:return, false}
      end
      p_hash = 0
      t_hash = 0
      modulus_power = 1
      i = 0
      while_fun_2 = fn while_fun_2, i, modulus_power, p_hash, t_hash ->
        if i < p_len do
          p_hash = rem((ord(String.at(pattern, i)) + p_hash * Process.get(:alphabet_size)), Process.get(:modulus))
          t_hash = rem((ord(String.at(text, i)) + t_hash * Process.get(:alphabet_size)), Process.get(:modulus))
          {modulus_power} = if i != p_len - 1 do
            modulus_power = rem((modulus_power * Process.get(:alphabet_size)), Process.get(:modulus))
            {modulus_power}
          else
            {modulus_power}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, modulus_power, p_hash, t_hash)
        else
          {i, modulus_power, p_hash, t_hash}
        end
      end
      {i, modulus_power, p_hash, t_hash} = try do
          while_fun_2.(while_fun_2, i, modulus_power, p_hash, t_hash)
        catch
          {:break, {i, modulus_power, p_hash, t_hash}} -> {i, modulus_power, p_hash, t_hash}
        end

      j = 0
      while_fun_3 = fn while_fun_3, j, t_hash ->
        if j <= t_len - p_len do
          {j, t_hash} = try do
            if t_hash == p_hash && _slice(text, j, j + p_len - (j)) == pattern do
              throw {:return, true}
            end
            {j} = if j == t_len - p_len do
              j = j + 1
              throw {:continue, {j, t_hash}}
              {j}
            else
              {j}
            end
            t_hash = rem(((t_hash - ord(String.at(text, j)) * modulus_power) * Process.get(:alphabet_size) + ord(String.at(text, j + p_len))), Process.get(:modulus))
            {t_hash} = if t_hash < 0 do
              t_hash = t_hash + Process.get(:modulus)
              {t_hash}
            else
              {t_hash}
            end
            j = j + 1
            {j, t_hash}
          catch
            {:continue, {j, t_hash}} -> {j, t_hash}
          end
          while_fun_3.(while_fun_3, j, t_hash)
        else
          {j, t_hash}
        end
      end
      {j, t_hash} = try do
          while_fun_3.(while_fun_3, j, t_hash)
        catch
          {:break, {j, t_hash}} -> {j, t_hash}
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def test_rabin_karp() do
    try do
      pattern1 = "abc1abc12"
      text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
      text2 = "alskfjaldsk23adsfabcabc"
      if !rabin_karp(pattern1, text1) || rabin_karp(pattern1, text2) do
        IO.puts("Failure")
        throw {:return, nil}
      end
      pattern2 = "ABABX"
      text3 = "ABABZABABYABABX"
      if !rabin_karp(pattern2, text3) do
        IO.puts("Failure")
        throw {:return, nil}
      end
      pattern3 = "AAAB"
      text4 = "ABAAAAAB"
      if !rabin_karp(pattern3, text4) do
        IO.puts("Failure")
        throw {:return, nil}
      end
      pattern4 = "abcdabcy"
      text5 = "abcxabcdabxabcdabcdabcy"
      if !rabin_karp(pattern4, text5) do
        IO.puts("Failure")
        throw {:return, nil}
      end
      pattern5 = "Lü"
      text6 = "Lüsai"
      if !rabin_karp(pattern5, text6) do
        IO.puts("Failure")
        throw {:return, nil}
      end
      pattern6 = "Lue"
      if rabin_karp(pattern6, text6) do
        IO.puts("Failure")
        throw {:return, nil}
      end
      IO.puts("Success.")
    catch
      {:return, val} -> val
    end
  end
  Process.put(:alphabet_size, 256)
  Process.put(:modulus, 1000003)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    test_rabin_karp()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
