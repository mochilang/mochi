# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def etaoin_index(letter) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(Process.get(:etaoin)) do
          if _slice(Process.get(:etaoin), i, i + 1 - (i)) == letter do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, _len(Process.get(:etaoin))}
    catch
      {:return, val} -> val
    end
  end
  def get_letter_count(message) do
    try do
      letter_count = %{}
      i = 0
      while_fun_2 = fn while_fun_2, i, letter_count ->
        if i < _len(Process.get(:letters)) do
          c = _slice(Process.get(:letters), i, i + 1 - (i))
          letter_count = Map.put(letter_count, c, 0)
          i = i + 1
          while_fun_2.(while_fun_2, i, letter_count)
        else
          {i, letter_count}
        end
      end
      {i, letter_count} = try do
          while_fun_2.(while_fun_2, i, letter_count)
        catch
          {:break, {i, letter_count}} -> {i, letter_count}
        end

      msg = String.upcase(message)
      j = 0
      while_fun_3 = fn while_fun_3, j, letter_count ->
        if j < _len(msg) do
          ch = _slice(msg, j, j + 1 - (j))
          {letter_count} = if ch in Process.get(:letters) do
            letter_count = Map.put(letter_count, ch, letter_count[ch] + 1)
            {letter_count}
          else
            {letter_count}
          end
          j = j + 1
          while_fun_3.(while_fun_3, j, letter_count)
        else
          {j, letter_count}
        end
      end
      {j, letter_count} = try do
          while_fun_3.(while_fun_3, j, letter_count)
        catch
          {:break, {j, letter_count}} -> {j, letter_count}
        end

      throw {:return, letter_count}
    catch
      {:return, val} -> val
    end
  end
  def get_frequency_order(message) do
    try do
      letter_to_freq = get_letter_count(message)
      max_freq = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, max_freq ->
        if i < _len(Process.get(:letters)) do
          letter = _slice(Process.get(:letters), i, i + 1 - (i))
          f = letter_to_freq[letter]
          {max_freq} = if f > max_freq do
            max_freq = f
            {max_freq}
          else
            {max_freq}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, max_freq)
        else
          {i, max_freq}
        end
      end
      {i, max_freq} = try do
          while_fun_4.(while_fun_4, i, max_freq)
        catch
          {:break, {i, max_freq}} -> {i, max_freq}
        end

      result = ""
      freq = max_freq
      while_fun_5 = fn while_fun_5, freq, result ->
        if freq >= 0 do
          group = []
          j = 0
          while_fun_6 = fn while_fun_6, group, j ->
            if j < _len(Process.get(:letters)) do
              letter = _slice(Process.get(:letters), j, j + 1 - (j))
              {group} = if letter_to_freq[letter] == freq do
                group = (group ++ [letter])
                {group}
              else
                {group}
              end
              j = j + 1
              while_fun_6.(while_fun_6, group, j)
            else
              {group, j}
            end
          end
          {group, j} = try do
              while_fun_6.(while_fun_6, group, j)
            catch
              {:break, {group, j}} -> {group, j}
            end

          g_len = _len(group)
          a = 0
          while_fun_7 = fn while_fun_7, a, group ->
            if a < g_len do
              b = 0
              while_fun_8 = fn while_fun_8, b, group ->
                if b < g_len - a - 1 do
                  g1 = Enum.at(group, b, [])
                  g2 = Enum.at(group, b + 1, [])
                  idx1 = etaoin_index(g1)
                  idx2 = etaoin_index(g2)
                  {group} = if idx1 < idx2 do
                    tmp = Enum.at(group, b, [])
                    group = List.replace_at(group, b, Enum.at(group, b + 1, []))
                    group = List.replace_at(group, b + 1, tmp)
                    {group}
                  else
                    {group}
                  end
                  b = b + 1
                  while_fun_8.(while_fun_8, b, group)
                else
                  {b, group}
                end
              end
              {b, group} = try do
                  while_fun_8.(while_fun_8, b, group)
                catch
                  {:break, {b, group}} -> {b, group}
                end

              a = a + 1
              while_fun_7.(while_fun_7, a, group)
            else
              {a, group}
            end
          end
          {a, group} = try do
              while_fun_7.(while_fun_7, a, group)
            catch
              {:break, {a, group}} -> {a, group}
            end

          g = 0
          while_fun_9 = fn while_fun_9, g, result ->
            if g < _len(group) do
              result = (result <> Enum.at(group, g, []))
              g = g + 1
              while_fun_9.(while_fun_9, g, result)
            else
              {g, result}
            end
          end
          {g, result} = try do
              while_fun_9.(while_fun_9, g, result)
            catch
              {:break, {g, result}} -> {g, result}
            end

          freq = freq - 1
          while_fun_5.(while_fun_5, freq, result)
        else
          {freq, result}
        end
      end
      {freq, result} = try do
          while_fun_5.(while_fun_5, freq, result)
        catch
          {:break, {freq, result}} -> {freq, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def english_freq_match_score(message) do
    try do
      freq_order = get_frequency_order(message)
      top = _slice(freq_order, 0, 6 - (0))
      bottom = _slice(freq_order, _len(freq_order) - 6, _len(freq_order) - (_len(freq_order) - 6))
      score = 0
      i = 0
      while_fun_10 = fn while_fun_10, i, score ->
        if i < 6 do
          c = _slice(Process.get(:etaoin), i, i + 1 - (i))
          {score} = if c in top do
            score = score + 1
            {score}
          else
            {score}
          end
          i = i + 1
          while_fun_10.(while_fun_10, i, score)
        else
          {i, score}
        end
      end
      {i, score} = try do
          while_fun_10.(while_fun_10, i, score)
        catch
          {:break, {i, score}} -> {i, score}
        end

      j = _len(Process.get(:etaoin)) - 6
      while_fun_11 = fn while_fun_11, j, score ->
        if j < _len(Process.get(:etaoin)) do
          c = _slice(Process.get(:etaoin), j, j + 1 - (j))
          {score} = if c in bottom do
            score = score + 1
            {score}
          else
            {score}
          end
          j = j + 1
          while_fun_11.(while_fun_11, j, score)
        else
          {j, score}
        end
      end
      {j, score} = try do
          while_fun_11.(while_fun_11, j, score)
        catch
          {:break, {j, score}} -> {j, score}
        end

      throw {:return, score}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(get_frequency_order("Hello World")))
      IO.puts(Kernel.inspect(english_freq_match_score("Hello World")))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:etaoin, "ETAOINSHRDLCUMWFGYPBVKJXQZ")
  Process.put(:letters, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
end
Main.main()
