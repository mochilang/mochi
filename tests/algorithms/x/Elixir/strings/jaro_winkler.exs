# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def min_int(a, b) do
    try do
      if a < b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def max_int(a, b) do
    try do
      if a > b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def repeat_bool(n, value) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < n do
          res = (res ++ [value])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def set_bool(xs, idx, value) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(xs) do
          res = (if i == idx, do: (res ++ [value]), else: (res ++ [Enum.at(xs, i, [])]))
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def jaro_winkler(s1, s2) do
    try do
      len1 = _len(s1)
      len2 = _len(s2)
      limit = div(min_int(len1, len2), 2)
      match1 = repeat_bool(len1, false)
      match2 = repeat_bool(len2, false)
      matches = 0
      i = 0
      while_fun_3 = fn while_fun_3, i, match1, match2, matches ->
        if i < len1 do
          start = max_int(0, i - limit)
          end_ = min_int(i + limit + 1, len2)
          j = start
          while_fun_4 = fn while_fun_4, j, match1, match2, matches ->
            if j < end_ do
              {match1, match2, matches} = if !Enum.at(match2, j, []) && _slice(s1, i, i + 1 - (i)) == _slice(s2, j, j + 1 - (j)) do
                match1 = set_bool(match1, i, true)
                match2 = set_bool(match2, j, true)
                matches = matches + 1
                throw {:break, {j, match1, match2, matches}}
                {match1, match2, matches}
              else
                {match1, match2, matches}
              end
              j = j + 1
              while_fun_4.(while_fun_4, j, match1, match2, matches)
            else
              {j, match1, match2, matches}
            end
          end
          {j, match1, match2, matches} = try do
              while_fun_4.(while_fun_4, j, match1, match2, matches)
            catch
              {:break, {j, match1, match2, matches}} -> {j, match1, match2, matches}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, match1, match2, matches)
        else
          {i, match1, match2, matches}
        end
      end
      {i, match1, match2, matches} = try do
          while_fun_3.(while_fun_3, i, match1, match2, matches)
        catch
          {:break, {i, match1, match2, matches}} -> {i, match1, match2, matches}
        end

      if matches == 0 do
        throw {:return, 0.0}
      end
      transpositions = 0
      k = 0
      i = 0
      while_fun_5 = fn while_fun_5, i, k, transpositions ->
        if i < len1 do
          {k, transpositions} = if Enum.at(match1, i, []) do
            while_fun_6 = fn while_fun_6, k ->
              if !Enum.at(match2, k, []) do
                k = k + 1
                while_fun_6.(while_fun_6, k)
              else
                k
              end
            end
            k = try do
                while_fun_6.(while_fun_6, k)
              catch
                {:break, {k}} -> k
              end

            {transpositions} = if _slice(s1, i, i + 1 - (i)) != _slice(s2, k, k + 1 - (k)) do
              transpositions = transpositions + 1
              {transpositions}
            else
              {transpositions}
            end
            k = k + 1
            {k, transpositions}
          else
            {k, transpositions}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, k, transpositions)
        else
          {i, k, transpositions}
        end
      end
      {i, k, transpositions} = try do
          while_fun_5.(while_fun_5, i, k, transpositions)
        catch
          {:break, {i, k, transpositions}} -> {i, k, transpositions}
        end

      m = :erlang.float(matches)
      jaro = ((m / (:erlang.float(len1))) + (m / (:erlang.float(len2))) + ((m - (:erlang.float(transpositions)) / 2.0) / m)) / 3.0
      prefix_len = 0
      i = 0
      while_fun_7 = fn while_fun_7, i, prefix_len ->
        if i < 4 && i < len1 && i < len2 do
          {prefix_len} = if _slice(s1, i, i + 1 - (i)) == _slice(s2, i, i + 1 - (i)) do
            prefix_len = prefix_len + 1
            {prefix_len}
          else
            throw {:break, {i, prefix_len}}
            {prefix_len}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, prefix_len)
        else
          {i, prefix_len}
        end
      end
      {i, prefix_len} = try do
          while_fun_7.(while_fun_7, i, prefix_len)
        catch
          {:break, {i, prefix_len}} -> {i, prefix_len}
        end

      throw {:return, jaro + 0.1 * (:erlang.float(prefix_len)) * (1.0 - jaro)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(jaro_winkler("hello", "world")))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
