# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def range_list(n) do
    try do
      lst = []
      i = 0
      while_fun = fn while_fun, i, lst ->
        if i < n do
          lst = (lst ++ [i])
          i = i + 1
          while_fun.(while_fun, i, lst)
        else
          {i, lst}
        end
      end
      {i, lst} = try do
          while_fun.(while_fun, i, lst)
        catch
          {:break, {i, lst}} -> {i, lst}
        end

      throw {:return, lst}
    catch
      {:return, val} -> val
    end
  end
  def min3(a, b, c) do
    try do
      m = a
      {m} = if b < m do
        m = b
        {m}
      else
        {m}
      end
      {m} = if c < m do
        m = c
        {m}
      else
        {m}
      end
      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def levenshtein_distance(first_word, second_word) do
    try do
      if _len(first_word) < _len(second_word) do
        throw {:return, levenshtein_distance(second_word, first_word)}
      end
      if _len(second_word) == 0 do
        throw {:return, _len(first_word)}
      end
      previous_row = range_list(_len(second_word) + 1)
      i = 0
      while_fun_2 = fn while_fun_2, i, previous_row ->
        if i < _len(first_word) do
          c1 = String.at(first_word, i)
          current_row = []
          current_row = (current_row ++ [i + 1])
          j = 0
          while_fun_3 = fn while_fun_3, current_row, j ->
            if j < _len(second_word) do
              c2 = String.at(second_word, j)
              insertions = Enum.at(previous_row, j + 1, []) + 1
              deletions = Enum.at(current_row, j, []) + 1
              substitutions = Enum.at(previous_row, j, []) + ((if c1 == c2, do: 0, else: 1))
              min_val = min3(insertions, deletions, substitutions)
              current_row = (current_row ++ [min_val])
              j = j + 1
              while_fun_3.(while_fun_3, current_row, j)
            else
              {current_row, j}
            end
          end
          {current_row, j} = try do
              while_fun_3.(while_fun_3, current_row, j)
            catch
              {:break, {current_row, j}} -> {current_row, j}
            end

          previous_row = current_row
          i = i + 1
          while_fun_2.(while_fun_2, i, previous_row)
        else
          {i, previous_row}
        end
      end
      {i, previous_row} = try do
          while_fun_2.(while_fun_2, i, previous_row)
        catch
          {:break, {i, previous_row}} -> {i, previous_row}
        end

      throw {:return, Enum.at(previous_row, _len(previous_row) - 1, [])}
    catch
      {:return, val} -> val
    end
  end
  def levenshtein_distance_optimized(first_word, second_word) do
    try do
      if _len(first_word) < _len(second_word) do
        throw {:return, levenshtein_distance_optimized(second_word, first_word)}
      end
      if _len(second_word) == 0 do
        throw {:return, _len(first_word)}
      end
      previous_row = range_list(_len(second_word) + 1)
      i = 0
      while_fun_4 = fn while_fun_4, i, previous_row ->
        if i < _len(first_word) do
          c1 = String.at(first_word, i)
          current_row = []
          current_row = (current_row ++ [i + 1])
          k = 0
          while_fun_5 = fn while_fun_5, current_row, k ->
            if k < _len(second_word) do
              current_row = (current_row ++ [0])
              k = k + 1
              while_fun_5.(while_fun_5, current_row, k)
            else
              {current_row, k}
            end
          end
          {current_row, k} = try do
              while_fun_5.(while_fun_5, current_row, k)
            catch
              {:break, {current_row, k}} -> {current_row, k}
            end

          j = 0
          while_fun_6 = fn while_fun_6, current_row, j ->
            if j < _len(second_word) do
              c2 = String.at(second_word, j)
              insertions = Enum.at(previous_row, j + 1, []) + 1
              deletions = Enum.at(current_row, j, []) + 1
              substitutions = Enum.at(previous_row, j, []) + ((if c1 == c2, do: 0, else: 1))
              min_val = min3(insertions, deletions, substitutions)
              current_row = List.replace_at(current_row, j + 1, min_val)
              j = j + 1
              while_fun_6.(while_fun_6, current_row, j)
            else
              {current_row, j}
            end
          end
          {current_row, j} = try do
              while_fun_6.(while_fun_6, current_row, j)
            catch
              {:break, {current_row, j}} -> {current_row, j}
            end

          previous_row = current_row
          i = i + 1
          while_fun_4.(while_fun_4, i, previous_row)
        else
          {i, previous_row}
        end
      end
      {i, previous_row} = try do
          while_fun_4.(while_fun_4, i, previous_row)
        catch
          {:break, {i, previous_row}} -> {i, previous_row}
        end

      throw {:return, Enum.at(previous_row, _len(previous_row) - 1, [])}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      a = "kitten"
      b = "sitting"
      IO.puts(Kernel.inspect(levenshtein_distance(a, b)))
      IO.puts(Kernel.inspect(levenshtein_distance_optimized(a, b)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
