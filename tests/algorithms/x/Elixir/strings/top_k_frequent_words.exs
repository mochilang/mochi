# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def heapify(arr, index, heap_size) do
    try do
      largest = index
      left = 2 * index + 1
      right = 2 * index + 2
      {largest} = if left < heap_size do
        left_item = Enum.at(arr, left, [])
        largest_item = Enum.at(arr, largest, [])
        {largest} = if left_item.count > largest_item.count do
          largest = left
          {largest}
        else
          {largest}
        end
        {largest}
      else
        {largest}
      end
      {largest} = if right < heap_size do
        right_item = Enum.at(arr, right, [])
        largest_item2 = Enum.at(arr, largest, [])
        {largest} = if right_item.count > largest_item2.count do
          largest = right
          {largest}
        else
          {largest}
        end
        {largest}
      else
        {largest}
      end
      {arr} = if largest != index do
        temp = Enum.at(arr, largest, [])
        arr = List.replace_at(arr, largest, Enum.at(arr, index, []))
        arr = List.replace_at(arr, index, temp)
        heapify(arr, largest, heap_size)
        {arr}
      else
        {arr}
      end
    catch
      {:return, val} -> val
    end
  end
  def build_max_heap(arr) do
    try do
      i = div(_len(arr), 2) - 1
      while_fun = fn while_fun, i ->
        if i >= 0 do
          heapify(arr, i, _len(arr))
          i = i - 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def top_k_frequent_words(words, k_value) do
    try do
      Process.put(:freq_map, %{})
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(words) do
          w = Enum.at(words, i, [])
          Process.put(:freq_map, Map.put(Process.get(:freq_map), w, ((if Map.has_key?(Process.get(:freq_map), w), do: Process.get(:freq_map)[w] + 1, else: 1))))
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      heap = []
      {heap} = Enum.reduce(Map.keys(Process.get(:freq_map)), {heap}, fn w, {heap} ->
        heap = (heap ++ [%{word: w, count: Process.get(:freq_map)[w]}])
        {heap}
      end)
      build_max_heap(heap)
      result = []
      heap_size = _len(heap)
      limit = k_value
      {limit} = if limit > heap_size do
        limit = heap_size
        {limit}
      else
        {limit}
      end
      j = 0
      while_fun_3 = fn while_fun_3, heap, heap_size, j, result ->
        if j < limit do
          item = Enum.at(heap, 0, [])
          result = (result ++ [item.word])
          heap = List.replace_at(heap, 0, Enum.at(heap, heap_size - 1, []))
          heap = List.replace_at(heap, heap_size - 1, item)
          heap_size = heap_size - 1
          heapify(heap, 0, heap_size)
          j = j + 1
          while_fun_3.(while_fun_3, heap, heap_size, j, result)
        else
          {heap, heap_size, j, result}
        end
      end
      {heap, heap_size, j, result} = try do
          while_fun_3.(while_fun_3, heap, heap_size, j, result)
        catch
          {:break, {heap, heap_size, j, result}} -> {heap, heap_size, j, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      sample = ["a", "b", "c", "a", "c", "c"]
      IO.puts(Kernel.inspect(top_k_frequent_words(sample, 3)))
      IO.puts(Kernel.inspect(top_k_frequent_words(sample, 2)))
      IO.puts(Kernel.inspect(top_k_frequent_words(sample, 1)))
      IO.puts(Kernel.inspect(top_k_frequent_words(sample, 0)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:freq_map, %{})
  def bench_main() do
    Process.put(:freq_map, %{})
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
