# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def is_lower(ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(Process.get(:lower)) do
          if String.at(Process.get(:lower), i) == ch do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_upper(ch) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(Process.get(:upper)) do
          if String.at(Process.get(:upper), i) == ch do
            throw {:return, true}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_digit(ch) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(Process.get(:digits)) do
          if String.at(Process.get(:digits), i) == ch do
            throw {:return, true}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_alpha(ch) do
    try do
      if is_lower(ch) do
        throw {:return, true}
      end
      if is_upper(ch) do
        throw {:return, true}
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def is_alnum(ch) do
    try do
      if is_alpha(ch) do
        throw {:return, true}
      end
      if is_digit(ch) do
        throw {:return, true}
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def to_lower(ch) do
    try do
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(Process.get(:upper)) do
          if String.at(Process.get(:upper), i) == ch do
            throw {:return, String.at(Process.get(:lower), i)}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, ch}
    catch
      {:return, val} -> val
    end
  end
  def camel_to_snake_case(input_str) do
    try do
      snake_str = ""
      i = 0
      prev_is_digit = false
      prev_is_alpha = false
      while_fun_5 = fn while_fun_5, i, prev_is_alpha, prev_is_digit, snake_str ->
        if i < _len(input_str) do
          ch = String.at(input_str, i)
          {snake_str} = if is_upper(ch) do
            snake_str = ((snake_str <> "_") <> to_lower(ch))
            {snake_str}
          else
            {snake_str} = if prev_is_digit && is_lower(ch) do
              snake_str = ((snake_str <> "_") <> ch)
              {snake_str}
            else
              {snake_str} = if prev_is_alpha && is_digit(ch) do
                snake_str = ((snake_str <> "_") <> ch)
                {snake_str}
              else
                {snake_str} = if !is_alnum(ch) do
                  snake_str = (snake_str <> "_")
                  {snake_str}
                else
                  snake_str = (snake_str <> ch)
                  {snake_str}
                end
                {snake_str}
              end
              {snake_str}
            end
            {snake_str}
          end
          prev_is_digit = is_digit(ch)
          prev_is_alpha = is_alpha(ch)
          i = i + 1
          while_fun_5.(while_fun_5, i, prev_is_alpha, prev_is_digit, snake_str)
        else
          {i, prev_is_alpha, prev_is_digit, snake_str}
        end
      end
      {i, prev_is_alpha, prev_is_digit, snake_str} = try do
          while_fun_5.(while_fun_5, i, prev_is_alpha, prev_is_digit, snake_str)
        catch
          {:break, {i, prev_is_alpha, prev_is_digit, snake_str}} -> {i, prev_is_alpha, prev_is_digit, snake_str}
        end

      {snake_str} = if _len(snake_str) > 0 && String.at(snake_str, 0) == "_" do
        snake_str = _slice(snake_str, 1, _len(snake_str) - 1)
        {snake_str}
      else
        {snake_str}
      end
      throw {:return, snake_str}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(camel_to_snake_case("someRandomString")))
      IO.puts(Kernel.inspect(camel_to_snake_case("SomeRandomStr#ng")))
      IO.puts(Kernel.inspect(camel_to_snake_case("123SomeRandom123String123")))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:lower, "abcdefghijklmnopqrstuvwxyz")
  Process.put(:upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  Process.put(:digits, "0123456789")
end
Main.main()
