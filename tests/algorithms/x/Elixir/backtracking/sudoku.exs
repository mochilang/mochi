# Code generated by Mochi transpiler 2025-08-13 16:40 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def is_safe(grid, row, column, n) do
    try do
      Enum.each((0..(9 - 1)), fn i ->
        if Enum.at(Enum.at(grid, row, []), i, 0) == n || Enum.at(Enum.at(grid, i, []), column, 0) == n do
          throw {:return, false}
        end
      end)
      Enum.each((0..(3 - 1)), fn i ->
        Enum.each((0..(3 - 1)), fn j ->
          if Enum.at(Enum.at(grid, (row - rem(row, 3)) + i, []), (column - rem(column, 3)) + j, 0) == n do
            throw {:return, false}
          end
        end)
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def find_empty_location(grid) do
    try do
      Enum.each((0..(9 - 1)), fn i ->
        Enum.each((0..(9 - 1)), fn j ->
          if Enum.at(Enum.at(grid, i, []), j, 0) == 0 do
            throw {:return, [i, j]}
          end
        end)
      end)
      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  def sudoku(grid) do
    try do
      loc = find_empty_location(grid)
      if _len(loc) == 0 do
        throw {:return, true}
      end
      row = Enum.at(loc, 0, [])
      column = Enum.at(loc, 1, [])
      {grid} = Enum.reduce((1..(10 - 1)//1), {grid}, fn digit, {grid} ->
        grid = if is_safe(grid, row, column, digit) do
          grid = List.replace_at(grid, row, List.replace_at(Enum.at(grid, row), column, digit))
          if sudoku(grid) do
            throw {:return, true}
          end
          grid = List.replace_at(grid, row, List.replace_at(Enum.at(grid, row), column, 0))
          grid
        else
          grid
        end
        {grid}
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def print_solution(grid) do
    try do
      Enum.each((0..(_len(grid) - 1)), fn r ->
        line = ""
        {line} = Enum.reduce((0..(_len(Enum.at(grid, r, [])) - 1)//1), {line}, fn c, {line} ->
          line = (line <> Kernel.to_string(Enum.at(Enum.at(grid, r, []), c, 0)))
          line = if c < _len(Enum.at(grid, r, [])) - 1 do
            line = (line <> " ")
            line
          else
            line
          end
          {line}
        end)
        IO.puts(line)
      end)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:initial_grid, [[3, 0, 6, 5, 0, 8, 4, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]])
  Process.put(:no_solution, [[5, 0, 6, 5, 0, 8, 4, 0, 3], [5, 2, 0, 0, 0, 0, 0, 0, 2], [1, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]])
  Process.put(:idx, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:examples, [Process.get(:initial_grid), Process.get(:no_solution)])
    while_fun = fn while_fun ->
      if Process.get(:idx) < _len(Process.get(:examples)) do
        IO.puts("\nExample grid:\n====================")
        print_solution(Enum.at(Process.get(:examples), Process.get(:idx), []))
        IO.puts("\nExample grid solution:")
        if sudoku(Enum.at(Process.get(:examples), Process.get(:idx), [])) do
          print_solution(Enum.at(Process.get(:examples), Process.get(:idx), []))
        else
          IO.puts("Cannot find a solution.")
        end
        Process.put(:idx, Process.get(:idx) + 1)
        while_fun.(while_fun)
      else
        nil
      end
    end
    try do
      while_fun.(while_fun)
    catch
      :break -> nil
    end

    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
