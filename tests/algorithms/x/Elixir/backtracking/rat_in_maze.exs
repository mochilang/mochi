# Code generated by Mochi transpiler 2025-08-13 16:40 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def run_maze(maze, i, j, dr, dc, sol) do
    try do
      size = _len(maze)
      sol = if i == dr && j == dc && Enum.at(Enum.at(maze, i, []), j, 0) == 0 do
        sol = List.replace_at(sol, i, List.replace_at(Enum.at(sol, i), j, 0))
        throw {:return, true}
        sol
      else
        sol
      end
      lower_flag = (i >= 0) && (j >= 0)
      upper_flag = (i < size) && (j < size)
      sol = if lower_flag && upper_flag do
        block_flag = (Enum.at(Enum.at(sol, i, []), j, 0) == 1) && (Enum.at(Enum.at(maze, i, []), j, 0) == 0)
        sol = if block_flag do
          sol = List.replace_at(sol, i, List.replace_at(Enum.at(sol, i), j, 0))
          if run_maze(maze, i + 1, j, dr, dc, sol) || run_maze(maze, i, j + 1, dr, dc, sol) || run_maze(maze, i - 1, j, dr, dc, sol) || run_maze(maze, i, j - 1, dr, dc, sol) do
            throw {:return, true}
          end
          sol = List.replace_at(sol, i, List.replace_at(Enum.at(sol, i), j, 1))
          throw {:return, false}
          sol
        else
          sol
        end
        sol
      else
        sol
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def solve_maze(maze, sr, sc, dr, dc) do
    try do
      size = _len(maze)
      if !(0 <= sr && sr < size && 0 <= sc && sc < size && 0 <= dr && dr < size && 0 <= dc && dc < size) do
        raise("Invalid source or destination coordinates")
      end
      sol = []
      i = 0
      while_fun = fn while_fun, i, sol ->
        if i < size do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < size do
              row = (row ++ [1])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          sol = (sol ++ [row])
          i = i + 1
          while_fun.(while_fun, i, sol)
        else
          {i, sol}
        end
      end
      {i, sol} = try do
          while_fun.(while_fun, i, sol)
        catch
          {:break, {i, sol}} -> {i, sol}
        end

      solved = run_maze(maze, sr, sc, dr, dc, sol)
      if solved do
        throw {:return, sol}
      else
        raise("No solution exists!")
      end
    catch
      {:return, val} -> val
    end
  end
  Process.put(:maze, [[0, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 0, 1, 0, 0], [1, 0, 0, 1, 0]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:n, _len(Process.get(:maze)) - 1)
    IO.puts(Kernel.inspect(solve_maze(Process.get(:maze), 0, 0, Process.get(:n), Process.get(:n))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
