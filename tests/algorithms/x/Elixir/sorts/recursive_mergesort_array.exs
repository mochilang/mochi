# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def subarray(xs, start, end_) do
    try do
      result = []
      k = start
      while_fun = fn while_fun, k, result ->
        if k < end_ do
          result = (result ++ [Enum.at(xs, k, [])])
          k = k + 1
          while_fun.(while_fun, k, result)
        else
          {k, result}
        end
      end
      {k, result} = try do
          while_fun.(while_fun, k, result)
        catch
          {:break, {k, result}} -> {k, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def merge(arr) do
    try do
      {arr} = if _len(arr) > 1 do
        middle_length = div(_len(arr), 2)
        left_array = subarray(arr, 0, middle_length)
        right_array = subarray(arr, middle_length, _len(arr))
        left_size = _len(left_array)
        right_size = _len(right_array)
        merge(left_array)
        merge(right_array)
        left_index = 0
        right_index = 0
        index = 0
        while_fun_2 = fn while_fun_2, arr, index, left_index, right_index ->
          if left_index < left_size && right_index < right_size do
            {arr, left_index, right_index} = if Enum.at(left_array, left_index, []) < Enum.at(right_array, right_index, []) do
              arr = List.replace_at(arr, index, Enum.at(left_array, left_index, []))
              left_index = left_index + 1
              {arr, left_index, right_index}
            else
              arr = List.replace_at(arr, index, Enum.at(right_array, right_index, []))
              right_index = right_index + 1
              {arr, left_index, right_index}
            end
            index = index + 1
            while_fun_2.(while_fun_2, arr, index, left_index, right_index)
          else
            {arr, index, left_index, right_index}
          end
        end
        {arr, index, left_index, right_index} = try do
            while_fun_2.(while_fun_2, arr, index, left_index, right_index)
          catch
            {:break, {arr, index, left_index, right_index}} -> {arr, index, left_index, right_index}
          end

        while_fun_3 = fn while_fun_3, arr, index, left_index ->
          if left_index < left_size do
            arr = List.replace_at(arr, index, Enum.at(left_array, left_index, []))
            left_index = left_index + 1
            index = index + 1
            while_fun_3.(while_fun_3, arr, index, left_index)
          else
            {arr, index, left_index}
          end
        end
        {arr, index, left_index} = try do
            while_fun_3.(while_fun_3, arr, index, left_index)
          catch
            {:break, {arr, index, left_index}} -> {arr, index, left_index}
          end

        while_fun_4 = fn while_fun_4, arr, index, right_index ->
          if right_index < right_size do
            arr = List.replace_at(arr, index, Enum.at(right_array, right_index, []))
            right_index = right_index + 1
            index = index + 1
            while_fun_4.(while_fun_4, arr, index, right_index)
          else
            {arr, index, right_index}
          end
        end
        {arr, index, right_index} = try do
            while_fun_4.(while_fun_4, arr, index, right_index)
          catch
            {:break, {arr, index, right_index}} -> {arr, index, right_index}
          end

        {arr}
      else
        {arr}
      end
      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(merge([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])))
    IO.puts(Kernel.inspect(merge([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])))
    IO.puts(Kernel.inspect(merge([10, 22, 1, 2, 3, 9, 15, 23])))
    IO.puts(Kernel.inspect(merge([100])))
    IO.puts(Kernel.inspect(merge([])))
  end
end
Main.main()
