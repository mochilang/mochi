# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def binary_search_insertion_from(sorted_list, item, start) do
    try do
      left = start
      right = _len(sorted_list) - 1
      while_fun = fn while_fun, left, right ->
        if left <= right do
          middle = div((left + right), 2)
          {left, right} = if left == right do
            {left} = if Enum.at(sorted_list, middle, []) < item do
              left = middle + 1
              {left}
            else
              {left}
            end
            throw {:break, {left, right}}
            {left, right}
          else
            {left, right} = if Enum.at(sorted_list, middle, []) < item do
              left = middle + 1
              {left, right}
            else
              right = middle - 1
              {left, right}
            end
            {left, right}
          end
          while_fun.(while_fun, left, right)
        else
          {left, right}
        end
      end
      {left, right} = try do
          while_fun.(while_fun, left, right)
        catch
          {:break, {left, right}} -> {left, right}
        end

      result = []
      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < left do
          result = (result ++ [Enum.at(sorted_list, i, [])])
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      result = (result ++ [item])
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(sorted_list) do
          result = (result ++ [Enum.at(sorted_list, i, [])])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def binary_search_insertion(sorted_list, item) do
    try do
      throw {:return, binary_search_insertion_from(sorted_list, item, 0)}
    catch
      {:return, val} -> val
    end
  end
  def merge(left, right) do
    try do
      result = []
      i = 0
      j = 0
      while_fun_4 = fn while_fun_4, i, j, result ->
        if i < _len(left) && j < _len(right) do
          {i, j, result} = if Enum.at(Enum.at(left, i, []), 0, 0) < Enum.at(Enum.at(right, j, []), 0, 0) do
            result = (result ++ [Enum.at(left, i, [])])
            i = i + 1
            {i, j, result}
          else
            result = (result ++ [Enum.at(right, j, [])])
            j = j + 1
            {i, j, result}
          end
          while_fun_4.(while_fun_4, i, j, result)
        else
          {i, j, result}
        end
      end
      {i, j, result} = try do
          while_fun_4.(while_fun_4, i, j, result)
        catch
          {:break, {i, j, result}} -> {i, j, result}
        end

      while_fun_5 = fn while_fun_5, i, result ->
        if i < _len(left) do
          result = (result ++ [Enum.at(left, i, [])])
          i = i + 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      while_fun_6 = fn while_fun_6, j, result ->
        if j < _len(right) do
          result = (result ++ [Enum.at(right, j, [])])
          j = j + 1
          while_fun_6.(while_fun_6, j, result)
        else
          {j, result}
        end
      end
      {j, result} = try do
          while_fun_6.(while_fun_6, j, result)
        catch
          {:break, {j, result}} -> {j, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def sortlist_2d(list_2d) do
    try do
      length = _len(list_2d)
      if length <= 1 do
        throw {:return, list_2d}
      end
      middle = div(length, 2)
      left = []
      i = 0
      while_fun_7 = fn while_fun_7, i, left ->
        if i < middle do
          left = (left ++ [Enum.at(list_2d, i, [])])
          i = i + 1
          while_fun_7.(while_fun_7, i, left)
        else
          {i, left}
        end
      end
      {i, left} = try do
          while_fun_7.(while_fun_7, i, left)
        catch
          {:break, {i, left}} -> {i, left}
        end

      right = []
      j = middle
      while_fun_8 = fn while_fun_8, j, right ->
        if j < length do
          right = (right ++ [Enum.at(list_2d, j, [])])
          j = j + 1
          while_fun_8.(while_fun_8, j, right)
        else
          {j, right}
        end
      end
      {j, right} = try do
          while_fun_8.(while_fun_8, j, right)
        catch
          {:break, {j, right}} -> {j, right}
        end

      throw {:return, merge(sortlist_2d(left), sortlist_2d(right))}
    catch
      {:return, val} -> val
    end
  end
  def merge_insertion_sort(collection) do
    try do
      if _len(collection) <= 1 do
        throw {:return, collection}
      end
      two_paired_list = []
      has_last_odd_item = false
      i = 0
      while_fun_9 = fn while_fun_9, has_last_odd_item, i, two_paired_list ->
        if i < _len(collection) do
          {has_last_odd_item, two_paired_list} = if i == _len(collection) - 1 do
            has_last_odd_item = true
            {has_last_odd_item, two_paired_list}
          else
            a = Enum.at(collection, i, [])
            b = Enum.at(collection, i + 1, [])
            two_paired_list = (if a < b, do: (two_paired_list ++ [[a, b]]), else: (two_paired_list ++ [[b, a]]))
            {has_last_odd_item, two_paired_list}
          end
          i = i + 2
          while_fun_9.(while_fun_9, has_last_odd_item, i, two_paired_list)
        else
          {has_last_odd_item, i, two_paired_list}
        end
      end
      {has_last_odd_item, i, two_paired_list} = try do
          while_fun_9.(while_fun_9, has_last_odd_item, i, two_paired_list)
        catch
          {:break, {has_last_odd_item, i, two_paired_list}} -> {has_last_odd_item, i, two_paired_list}
        end

      sorted_list_2d = sortlist_2d(two_paired_list)
      result = []
      i = 0
      while_fun_10 = fn while_fun_10, i, result ->
        if i < _len(sorted_list_2d) do
          result = (result ++ [Enum.at(Enum.at(sorted_list_2d, i, []), 0, 0)])
          i = i + 1
          while_fun_10.(while_fun_10, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_10.(while_fun_10, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      result = (result ++ [Enum.at(Enum.at(sorted_list_2d, _len(sorted_list_2d) - 1, []), 1, 0)])
      {result} = if has_last_odd_item do
        result = binary_search_insertion(result, Enum.at(collection, _len(collection) - 1, []))
        {result}
      else
        {result}
      end
      inserted_before = false
      idx = 0
      while_fun_11 = fn while_fun_11, idx, inserted_before, result ->
        if idx < _len(sorted_list_2d) - 1 do
          {inserted_before} = if has_last_odd_item && Enum.at(result, idx, []) == Enum.at(collection, _len(collection) - 1, []) do
            inserted_before = true
            {inserted_before}
          else
            {inserted_before}
          end
          pivot = Enum.at(Enum.at(sorted_list_2d, idx, []), 1, 0)
          result = (if inserted_before, do: binary_search_insertion_from(result, pivot, idx + 2), else: binary_search_insertion_from(result, pivot, idx + 1))
          idx = idx + 1
          while_fun_11.(while_fun_11, idx, inserted_before, result)
        else
          {idx, inserted_before, result}
        end
      end
      {idx, inserted_before, result} = try do
          while_fun_11.(while_fun_11, idx, inserted_before, result)
        catch
          {:break, {idx, inserted_before, result}} -> {idx, inserted_before, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      example1 = [0, 5, 3, 2, 2]
      example2 = [99]
      example3 = [-2, -5, -45]
      IO.puts(Kernel.inspect(merge_insertion_sort(example1)))
      IO.puts(Kernel.inspect(merge_insertion_sort(example2)))
      IO.puts(Kernel.inspect(merge_insertion_sort(example3)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
