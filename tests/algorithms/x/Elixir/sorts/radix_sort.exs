# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_buckets() do
    try do
      buckets = []
      i = 0
      while_fun = fn while_fun, buckets, i ->
        if i < Process.get(:radix) do
          buckets = (buckets ++ [[]])
          i = i + 1
          while_fun.(while_fun, buckets, i)
        else
          {buckets, i}
        end
      end
      {buckets, i} = try do
          while_fun.(while_fun, buckets, i)
        catch
          {:break, {buckets, i}} -> {buckets, i}
        end

      throw {:return, buckets}
    catch
      {:return, val} -> val
    end
  end
  def max_value(xs) do
    try do
      max_val = Enum.at(xs, 0, [])
      i = 1
      while_fun_2 = fn while_fun_2, i, max_val ->
        if i < _len(xs) do
          {max_val} = if Enum.at(xs, i, []) > max_val do
            max_val = Enum.at(xs, i, [])
            {max_val}
          else
            {max_val}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, max_val)
        else
          {i, max_val}
        end
      end
      {i, max_val} = try do
          while_fun_2.(while_fun_2, i, max_val)
        catch
          {:break, {i, max_val}} -> {i, max_val}
        end

      throw {:return, max_val}
    catch
      {:return, val} -> val
    end
  end
  def radix_sort(list_of_ints) do
    try do
      placement = 1
      max_digit = max_value(list_of_ints)
      while_fun_3 = fn while_fun_3, list_of_ints, placement ->
        if placement <= max_digit do
          buckets = make_buckets()
          i = 0
          while_fun_4 = fn while_fun_4, buckets, i ->
            if i < _len(list_of_ints) do
              value = Enum.at(list_of_ints, i, [])
              tmp = rem((div(value, placement)), Process.get(:radix))
              buckets = List.replace_at(buckets, tmp, (Enum.at(buckets, tmp, []) ++ [value]))
              i = i + 1
              while_fun_4.(while_fun_4, buckets, i)
            else
              {buckets, i}
            end
          end
          {buckets, i} = try do
              while_fun_4.(while_fun_4, buckets, i)
            catch
              {:break, {buckets, i}} -> {buckets, i}
            end

          a = 0
          b = 0
          while_fun_5 = fn while_fun_5, a, b, list_of_ints ->
            if b < Process.get(:radix) do
              bucket = Enum.at(buckets, b, [])
              j = 0
              while_fun_6 = fn while_fun_6, a, j, list_of_ints ->
                if j < _len(bucket) do
                  list_of_ints = List.replace_at(list_of_ints, a, Enum.at(bucket, j, []))
                  a = a + 1
                  j = j + 1
                  while_fun_6.(while_fun_6, a, j, list_of_ints)
                else
                  {a, j, list_of_ints}
                end
              end
              {a, j, list_of_ints} = try do
                  while_fun_6.(while_fun_6, a, j, list_of_ints)
                catch
                  {:break, {a, j, list_of_ints}} -> {a, j, list_of_ints}
                end

              b = b + 1
              while_fun_5.(while_fun_5, a, b, list_of_ints)
            else
              {a, b, list_of_ints}
            end
          end
          {a, b, list_of_ints} = try do
              while_fun_5.(while_fun_5, a, b, list_of_ints)
            catch
              {:break, {a, b, list_of_ints}} -> {a, b, list_of_ints}
            end

          placement = placement * Process.get(:radix)
          while_fun_3.(while_fun_3, list_of_ints, placement)
        else
          {list_of_ints, placement}
        end
      end
      {list_of_ints, placement} = try do
          while_fun_3.(while_fun_3, list_of_ints, placement)
        catch
          {:break, {list_of_ints, placement}} -> {list_of_ints, placement}
        end

      throw {:return, list_of_ints}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:radix, 10)
  def main() do
    IO.puts(Kernel.inspect(radix_sort([0, 5, 3, 2, 2])))
    IO.puts(Kernel.inspect(radix_sort([1, 100, 10, 1000])))
    IO.puts(Kernel.inspect(radix_sort([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])))
  end
end
Main.main()
