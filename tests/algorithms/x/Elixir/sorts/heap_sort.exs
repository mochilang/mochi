# Code generated by Mochi transpiler 2025-08-24 08:57 +0700
defmodule Main do
  @data_dir nil
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def heapify(arr, index, heap_size) do
    try do
      largest = index
      left_index = 2 * index + 1
      right_index = 2 * index + 2
      largest = if left_index < heap_size && Enum.at(arr, left_index, []) > Enum.at(arr, largest, []) do
        largest = left_index
        largest
      else
        largest
      end
      largest = if right_index < heap_size && Enum.at(arr, right_index, []) > Enum.at(arr, largest, []) do
        largest = right_index
        largest
      else
        largest
      end
      arr = if largest != index do
        temp = Enum.at(arr, largest, [])
        arr = List.replace_at(arr, largest, Enum.at(arr, index, []))
        arr = List.replace_at(arr, index, temp)
        arr = heapify(arr, largest, heap_size)
        arr
      else
        arr
      end
    catch
      {:return, val} -> val
    end
  end
  def heap_sort(arr) do
    try do
      n = _len(arr)
      i = div(n, 2) - 1
      while_fun = fn while_fun, arr, i ->
        if i >= 0 do
          arr = heapify(arr, i, n)
          i = i - 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      i = n - 1
      while_fun_2 = fn while_fun_2, arr, i ->
        if i > 0 do
          temp = Enum.at(arr, 0, [])
          arr = List.replace_at(arr, 0, Enum.at(arr, i, []))
          arr = List.replace_at(arr, i, temp)
          arr = heapify(arr, 0, i)
          i = i - 1
          while_fun_2.(while_fun_2, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun_2.(while_fun_2, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:data, [3, 7, 9, 28, 123, -5, 8, -30, -200, 0, 4])
    Process.put(:result, heap_sort(Process.get(:data)))
    IO.puts(Kernel.inspect(Process.get(:result)))
    if String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:result)])), ",", " ") != String.replace(IO.iodata_to_binary(:io_lib.format("~w", [[-200, -30, -5, 0, 3, 4, 7, 8, 9, 28, 123]])), ",", " ") do
      raise("Assertion error")
    end
  end
end
Main.main()
