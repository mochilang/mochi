# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def odd_even_sort(xs) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < _len(xs) do
          arr = (arr ++ [Enum.at(xs, i, [])])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      n = _len(arr)
      sorted = false
      while_fun_2 = fn while_fun_2, arr, sorted ->
        if sorted == false do
          sorted = true
          j = 0
          while_fun_3 = fn while_fun_3, arr, j, sorted ->
            if j < n - 1 do
              {arr, sorted} = if Enum.at(arr, j, []) > Enum.at(arr, j + 1, []) do
                tmp = Enum.at(arr, j, [])
                arr = List.replace_at(arr, j, Enum.at(arr, j + 1, []))
                arr = List.replace_at(arr, j + 1, tmp)
                sorted = false
                {arr, sorted}
              else
                {arr, sorted}
              end
              j = j + 2
              while_fun_3.(while_fun_3, arr, j, sorted)
            else
              {arr, j, sorted}
            end
          end
          {arr, j, sorted} = try do
              while_fun_3.(while_fun_3, arr, j, sorted)
            catch
              {:break, {arr, j, sorted}} -> {arr, j, sorted}
            end

          j = 1
          while_fun_4 = fn while_fun_4, arr, j, sorted ->
            if j < n - 1 do
              {arr, sorted} = if Enum.at(arr, j, []) > Enum.at(arr, j + 1, []) do
                tmp = Enum.at(arr, j, [])
                arr = List.replace_at(arr, j, Enum.at(arr, j + 1, []))
                arr = List.replace_at(arr, j + 1, tmp)
                sorted = false
                {arr, sorted}
              else
                {arr, sorted}
              end
              j = j + 2
              while_fun_4.(while_fun_4, arr, j, sorted)
            else
              {arr, j, sorted}
            end
          end
          {arr, j, sorted} = try do
              while_fun_4.(while_fun_4, arr, j, sorted)
            catch
              {:break, {arr, j, sorted}} -> {arr, j, sorted}
            end

          while_fun_2.(while_fun_2, arr, sorted)
        else
          {arr, sorted}
        end
      end
      {arr, sorted} = try do
          while_fun_2.(while_fun_2, arr, sorted)
        catch
          {:break, {arr, sorted}} -> {arr, sorted}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def print_list(xs) do
    try do
      i = 0
      out = ""
      while_fun_5 = fn while_fun_5, i, out ->
        if i < _len(xs) do
          {out} = if i > 0 do
            out = (out <> " ")
            {out}
          else
            {out}
          end
          out = (out <> Kernel.to_string(Enum.at(xs, i, [])))
          i = i + 1
          while_fun_5.(while_fun_5, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_5.(while_fun_5, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      IO.puts(out)
    catch
      {:return, val} -> val
    end
  end
  def test_odd_even_sort() do
    try do
      a = [5, 4, 3, 2, 1]
      r1 = odd_even_sort(a)
      if Enum.at(r1, 0, []) != 1 || Enum.at(r1, 1, []) != 2 || Enum.at(r1, 2, []) != 3 || Enum.at(r1, 3, []) != 4 || Enum.at(r1, 4, []) != 5 do
        raise("case1 failed")
      end
      b = []
      r2 = odd_even_sort(b)
      if _len(r2) != 0 do
        raise("case2 failed")
      end
      c = [-10, -1, 10, 2]
      r3 = odd_even_sort(c)
      if Enum.at(r3, 0, []) != (-10) || Enum.at(r3, 1, []) != (-1) || Enum.at(r3, 2, []) != 2 || Enum.at(r3, 3, []) != 10 do
        raise("case3 failed")
      end
      d = [1, 2, 3, 4]
      r4 = odd_even_sort(d)
      if Enum.at(r4, 0, []) != 1 || Enum.at(r4, 1, []) != 2 || Enum.at(r4, 2, []) != 3 || Enum.at(r4, 3, []) != 4 do
        raise("case4 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_odd_even_sort()
      sample = [5, 4, 3, 2, 1]
      sorted = odd_even_sort(sample)
      print_list(sorted)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
