# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_node(state, value) do
    try do
      state = Map.put(state, :nodes, (state.nodes ++ [%{value: value, left: (-1), right: (-1)}]))
      throw {:return, _len(Map.get(state, :nodes, [])) - 1}
    catch
      {:return, val} -> val
    end
  end
  def insert(state, value) do
    try do
      {state} = if state.root == (-1) do
        state = Map.put(state, :root, new_node(state, value))
        throw {:return, nil}
        {state}
      else
        {state}
      end
      current = state.root
      nodes = state.nodes
      while_fun = fn while_fun, current, nodes, state ->
        if true do
          node_ = Enum.at(nodes, current, [])
          {current, node_, nodes, state} = if value < node_.value do
            {node_, nodes, state} = if node_.left == (-1) do
              idx = new_node(state, value)
              nodes = state.nodes
              node_ = Map.put(node_, :left, idx)
              nodes = List.replace_at(nodes, current, node_)
              state = Map.put(state, :nodes, nodes)
              throw {:return, nil}
              {node_, nodes, state}
            else
              {node_, nodes, state}
            end
            current = node_.left
            {current, node_, nodes, state}
          else
            {current, node_, nodes, state} = if value > node_.value do
              {node_, nodes, state} = if node_.right == (-1) do
                idx = new_node(state, value)
                nodes = state.nodes
                node_ = Map.put(node_, :right, idx)
                nodes = List.replace_at(nodes, current, node_)
                state = Map.put(state, :nodes, nodes)
                throw {:return, nil}
                {node_, nodes, state}
              else
                {node_, nodes, state}
              end
              current = node_.right
              {current, node_, nodes, state}
            else
              throw {:return, nil}
              {current, node_, nodes, state}
            end
            {current, node_, nodes, state}
          end
          while_fun.(while_fun, current, nodes, state)
        else
          {current, nodes, state}
        end
      end
      {current, nodes, state} = try do
          while_fun.(while_fun, current, nodes, state)
        catch
          {:break, {current, nodes, state}} -> {current, nodes, state}
        end

    catch
      {:return, val} -> val
    end
  end
  def inorder(state, idx) do
    try do
      if idx == (-1) do
        throw {:return, []}
      end
      node_ = Enum.at(state.nodes, idx, 0)
      result = inorder(state, node_.left)
      result = (result ++ [node_.value])
      right_part = inorder(state, node_.right)
      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < _len(right_part) do
          result = (result ++ [Enum.at(right_part, i, [])])
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def tree_sort(arr) do
    try do
      state = %{nodes: [], root: (-1)}
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(arr) do
          insert(state, Enum.at(arr, i, []))
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      if state.root == (-1) do
        throw {:return, []}
      end
      throw {:return, inorder(state, state.root)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(tree_sort([])))
    IO.puts(Kernel.inspect(tree_sort([1])))
    IO.puts(Kernel.inspect(tree_sort([1, 2])))
    IO.puts(Kernel.inspect(tree_sort([5, 2, 7])))
    IO.puts(Kernel.inspect(tree_sort([5, -4, 9, 2, 7])))
    IO.puts(Kernel.inspect(tree_sort([5, 6, 1, -1, 4, 37, 2, 7])))
  end
end
Main.main()
