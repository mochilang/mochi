# Code generated by Mochi transpiler 2025-08-24 08:57 +0700
defmodule Main do
  @data_dir nil
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def merge(a, low, mid, high) do
    try do
      left = _slice(a, low, mid - low)
      right = _slice(a, mid, (high + 1) - mid)
      result = []
      while_fun = fn while_fun, left, result, right ->
        if _len(left) > 0 && _len(right) > 0 do
          {left, result, right} = if Enum.at(left, 0, []) <= Enum.at(right, 0, []) do
            result = (result ++ [Enum.at(left, 0, [])])
            left = _slice(left, 1, _len(left) - 1)
            {left, result, right}
          else
            result = (result ++ [Enum.at(right, 0, [])])
            right = _slice(right, 1, _len(right) - 1)
            {left, result, right}
          end
          while_fun.(while_fun, left, result, right)
        else
          {left, result, right}
        end
      end
      {left, result, right} = try do
          while_fun.(while_fun, left, result, right)
        catch
          {:break, {left, result, right}} -> {left, result, right}
        end

      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < _len(left) do
          result = (result ++ [Enum.at(left, i, [])])
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {_, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {_, result}} -> {0, result}
        end

      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(right) do
          result = (result ++ [Enum.at(right, i, [])])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {_, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {_, result}} -> {0, result}
        end

      i = 0
      while_fun_4 = fn while_fun_4, a, i ->
        if i < _len(result) do
          a = List.replace_at(a, low + i, Enum.at(result, i, []))
          i = i + 1
          while_fun_4.(while_fun_4, a, i)
        else
          {a, i}
        end
      end
      {a, _} = try do
          while_fun_4.(while_fun_4, a, i)
        catch
          {:break, {a, _}} -> {a, 0}
        end

      throw {:return, a}
    catch
      {:return, val} -> val
    end
  end
  def iter_merge_sort(items) do
    try do
      n = _len(items)
      if n <= 1 do
        throw {:return, items}
      end
      arr = _slice(items, 0, _len(items) - 0)
      p = 2
      while_fun_5 = fn while_fun_5, arr, p ->
        if p <= n do
          i = 0
          while_fun_6 = fn while_fun_6, arr, i ->
            if i < n do
              high = i + p - 1
              high = if high >= n do
                high = n - 1
                high
              else
                high
              end
              low = i
              mid = div((low + high + 1), 2)
              arr = merge(arr, low, mid, high)
              i = i + p
              while_fun_6.(while_fun_6, arr, i)
            else
              {arr, i}
            end
          end
          {arr, _} = try do
              while_fun_6.(while_fun_6, arr, i)
            catch
              {:break, {arr, _}} -> {arr, 0}
            end

          arr = if p * 2 >= n do
            mid2 = i - p
            arr = merge(arr, 0, mid2, n - 1)
            throw {:break, {arr, p}}
            arr
          else
            arr
          end
          p = p * 2
          while_fun_5.(while_fun_5, arr, p)
        else
          {arr, p}
        end
      end
      {arr, _} = try do
          while_fun_5.(while_fun_5, arr, p)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(arr) do
    try do
      s = "["
      i = 0
      while_fun_7 = fn while_fun_7, i, s ->
        if i < _len(arr) do
          s = (s <> Kernel.to_string(Enum.at(arr, i, [])))
          s = if i < _len(arr) - 1 do
            s = (s <> ", ")
            s
          else
            s
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, s)
        else
          {i, s}
        end
      end
      {_, _} = try do
          while_fun_7.(while_fun_7, i, s)
        catch
          {:break, {_, _}} -> {0, 0}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([5, 9, 8, 7, 1, 2, 7]))))
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([1]))))
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([2, 1]))))
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([4, 3, 2, 1]))))
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([5, 4, 3, 2, 1]))))
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([-2, -9, -1, -4]))))
    IO.puts(Kernel.inspect(list_to_string(iter_merge_sort([]))))
  end
end
Main.main()
