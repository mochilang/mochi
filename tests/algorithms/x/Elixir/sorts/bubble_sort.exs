# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def bubble_sort_iterative(collection) do
    try do
      n = _len(collection)
      while_fun = fn while_fun, collection, n ->
        if n > 0 do
          swapped = false
          j = 0
          while_fun_2 = fn while_fun_2, collection, j, swapped ->
            if j < n - 1 do
              {collection, swapped} = if Enum.at(collection, j, []) > Enum.at(collection, j + 1, []) do
                temp = Enum.at(collection, j, [])
                collection = List.replace_at(collection, j, Enum.at(collection, j + 1, []))
                collection = List.replace_at(collection, j + 1, temp)
                swapped = true
                {collection, swapped}
              else
                {collection, swapped}
              end
              j = j + 1
              while_fun_2.(while_fun_2, collection, j, swapped)
            else
              {collection, j, swapped}
            end
          end
          {collection, _, swapped} = try do
              while_fun_2.(while_fun_2, collection, j, swapped)
            catch
              {:break, {collection, _, swapped}} -> {collection, 0, swapped}
            end

          if !swapped do
            throw {:break, {collection, n}}
          end
          n = n - 1
          while_fun.(while_fun, collection, n)
        else
          {collection, n}
        end
      end
      {collection, _} = try do
          while_fun.(while_fun, collection, n)
        catch
          {:break, {collection, _}} -> {collection, 0}
        end

      throw {:return, collection}
    catch
      {:return, val} -> val
    end
  end
  def bubble_sort_recursive(collection) do
    try do
      n = _len(collection)
      swapped = false
      i = 0
      while_fun_3 = fn while_fun_3, collection, i, swapped ->
        if i < n - 1 do
          {collection, swapped} = if Enum.at(collection, i, []) > Enum.at(collection, i + 1, []) do
            temp = Enum.at(collection, i, [])
            collection = List.replace_at(collection, i, Enum.at(collection, i + 1, []))
            collection = List.replace_at(collection, i + 1, temp)
            swapped = true
            {collection, swapped}
          else
            {collection, swapped}
          end
          i = i + 1
          while_fun_3.(while_fun_3, collection, i, swapped)
        else
          {collection, i, swapped}
        end
      end
      {collection, _, swapped} = try do
          while_fun_3.(while_fun_3, collection, i, swapped)
        catch
          {:break, {collection, _, swapped}} -> {collection, 0, swapped}
        end

      if swapped do
        throw {:return, bubble_sort_recursive(collection)}
      end
      throw {:return, collection}
    catch
      {:return, val} -> val
    end
  end
  def copy_list(xs) do
    try do
      out = []
      i = 0
      while_fun_4 = fn while_fun_4, i, out ->
        if i < _len(xs) do
          out = (out ++ [Enum.at(xs, i, [])])
          i = i + 1
          while_fun_4.(while_fun_4, i, out)
        else
          {i, out}
        end
      end
      {_, out} = try do
          while_fun_4.(while_fun_4, i, out)
        catch
          {:break, {_, out}} -> {0, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def list_eq(a, b) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      k = 0
      while_fun_5 = fn while_fun_5, k ->
        if k < _len(a) do
          if Enum.at(a, k, []) != Enum.at(b, k, []) do
            throw {:return, false}
          end
          k = k + 1
          while_fun_5.(while_fun_5, k)
        else
          k
        end
      end
      _ = try do
          while_fun_5.(while_fun_5, k)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def test_bubble_sort() do
    try do
      example = [0, 5, 2, 3, 2]
      expected = [0, 2, 2, 3, 5]
      if !list_eq(bubble_sort_iterative(copy_list(example)), expected) do
        raise("iterative failed")
      end
      if !list_eq(bubble_sort_recursive(copy_list(example)), expected) do
        raise("recursive failed")
      end
      empty = []
      if _len(bubble_sort_iterative(copy_list(empty))) != 0 do
        raise("empty iterative failed")
      end
      if _len(bubble_sort_recursive(copy_list(empty))) != 0 do
        raise("empty recursive failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_bubble_sort()
      arr = [5, 1, 4, 2, 8]
      IO.puts(Kernel.inspect(bubble_sort_iterative(copy_list(arr))))
      IO.puts(Kernel.inspect(bubble_sort_recursive(copy_list(arr))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
