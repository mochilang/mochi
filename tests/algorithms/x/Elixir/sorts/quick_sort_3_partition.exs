# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def quick_sort_3partition(arr, left, right) do
    try do
      if right <= left do
        throw {:return, arr}
      end
      a = left
      i = left
      b = right
      pivot = Enum.at(arr, left, [])
      while_fun = fn while_fun, a, arr, b, i ->
        if i <= b do
          {a, arr, b, i} = if Enum.at(arr, i, []) < pivot do
            temp = Enum.at(arr, a, [])
            arr = List.replace_at(arr, a, Enum.at(arr, i, []))
            arr = List.replace_at(arr, i, temp)
            a = a + 1
            i = i + 1
            {a, arr, b, i}
          else
            {arr, b, i} = if Enum.at(arr, i, []) > pivot do
              temp = Enum.at(arr, b, [])
              arr = List.replace_at(arr, b, Enum.at(arr, i, []))
              arr = List.replace_at(arr, i, temp)
              b = b - 1
              {arr, b, i}
            else
              i = i + 1
              {arr, b, i}
            end
            {a, arr, b, i}
          end
          while_fun.(while_fun, a, arr, b, i)
        else
          {a, arr, b, i}
        end
      end
      {a, arr, b, i} = try do
          while_fun.(while_fun, a, arr, b, i)
        catch
          {:break, {a, arr, b, i}} -> {a, arr, b, i}
        end

      arr = quick_sort_3partition(arr, left, a - 1)
      arr = quick_sort_3partition(arr, b + 1, right)
      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def quick_sort_lomuto_partition(arr, left, right) do
    try do
      {arr} = if left < right do
        pivot_index = lomuto_partition(arr, left, right)
        arr = quick_sort_lomuto_partition(arr, left, pivot_index - 1)
        arr = quick_sort_lomuto_partition(arr, pivot_index + 1, right)
        {arr}
      else
        {arr}
      end
      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def lomuto_partition(arr, left, right) do
    try do
      pivot = Enum.at(arr, right, [])
      store_index = left
      i = left
      while_fun_2 = fn while_fun_2, arr, i, store_index ->
        if i < right do
          {arr, store_index} = if Enum.at(arr, i, []) < pivot do
            temp = Enum.at(arr, store_index, [])
            arr = List.replace_at(arr, store_index, Enum.at(arr, i, []))
            arr = List.replace_at(arr, i, temp)
            store_index = store_index + 1
            {arr, store_index}
          else
            {arr, store_index}
          end
          i = i + 1
          while_fun_2.(while_fun_2, arr, i, store_index)
        else
          {arr, i, store_index}
        end
      end
      {arr, i, store_index} = try do
          while_fun_2.(while_fun_2, arr, i, store_index)
        catch
          {:break, {arr, i, store_index}} -> {arr, i, store_index}
        end

      temp = Enum.at(arr, right, [])
      arr = List.replace_at(arr, right, Enum.at(arr, store_index, []))
      arr = List.replace_at(arr, store_index, temp)
      throw {:return, store_index}
    catch
      {:return, val} -> val
    end
  end
  def three_way_radix_quicksort(arr) do
    try do
      if _len(arr) <= 1 do
        throw {:return, arr}
      end
      pivot = Enum.at(arr, 0, [])
      less = []
      equal = []
      greater = []
      i = 0
      while_fun_3 = fn while_fun_3, equal, greater, i, less ->
        if i < _len(arr) do
          val = Enum.at(arr, i, [])
          {equal, greater, less} = if val < pivot do
            less = (less ++ [val])
            {equal, greater, less}
          else
            {equal, greater} = if val > pivot do
              greater = (greater ++ [val])
              {equal, greater}
            else
              equal = (equal ++ [val])
              {equal, greater}
            end
            {equal, greater, less}
          end
          i = i + 1
          while_fun_3.(while_fun_3, equal, greater, i, less)
        else
          {equal, greater, i, less}
        end
      end
      {equal, greater, i, less} = try do
          while_fun_3.(while_fun_3, equal, greater, i, less)
        catch
          {:break, {equal, greater, i, less}} -> {equal, greater, i, less}
        end

      sorted_less = three_way_radix_quicksort(less)
      sorted_greater = three_way_radix_quicksort(greater)
      result = (sorted_less ++ equal)
      result = (result ++ sorted_greater)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:array2, [9, 0, 2, 6])
  Process.put(:array3, [])
  Process.put(:nums1, [0, 5, 3, 1, 2])
  Process.put(:nums2, [])
  def main() do
    Process.put(:array1, [5, -1, -1, 5, 5, 24, 0])
    Process.put(:array1, quick_sort_3partition(Process.get(:array1), 0, _len(Process.get(:array1)) - 1))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:array1)])), ",", " "))
    Process.put(:array2, quick_sort_3partition(Process.get(:array2), 0, _len(Process.get(:array2)) - 1))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:array2)])), ",", " "))
    Process.put(:array3, quick_sort_3partition(Process.get(:array3), 0, _len(Process.get(:array3)) - 1))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:array3)])), ",", " "))
    Process.put(:nums1, quick_sort_lomuto_partition(Process.get(:nums1), 0, _len(Process.get(:nums1)) - 1))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:nums1)])), ",", " "))
    Process.put(:nums2, quick_sort_lomuto_partition(Process.get(:nums2), 0, _len(Process.get(:nums2)) - 1))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:nums2)])), ",", " "))
    Process.put(:nums3, [-2, 5, 0, -4])
    Process.put(:nums3, quick_sort_lomuto_partition(Process.get(:nums3), 0, _len(Process.get(:nums3)) - 1))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:nums3)])), ",", " "))
    IO.puts(Kernel.inspect(three_way_radix_quicksort([])))
    IO.puts(Kernel.inspect(three_way_radix_quicksort([1])))
    IO.puts(Kernel.inspect(three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])))
    IO.puts(Kernel.inspect(three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])))
  end
end
Main.main()
