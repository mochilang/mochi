# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def flip(arr, k) do
    try do
      start = 0
      end_ = k
      while_fun = fn while_fun, arr, end_, start ->
        if start < end_ do
          temp = Enum.at(arr, start, [])
          arr = List.replace_at(arr, start, Enum.at(arr, end_, []))
          arr = List.replace_at(arr, end_, temp)
          start = start + 1
          end_ = end_ - 1
          while_fun.(while_fun, arr, end_, start)
        else
          {arr, end_, start}
        end
      end
      {arr, end_, start} = try do
          while_fun.(while_fun, arr, end_, start)
        catch
          {:break, {arr, end_, start}} -> {arr, end_, start}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def find_max_index(arr, n) do
    try do
      mi = 0
      i = 1
      while_fun_2 = fn while_fun_2, i, mi ->
        if i < n do
          {mi} = if Enum.at(arr, i, []) > Enum.at(arr, mi, []) do
            mi = i
            {mi}
          else
            {mi}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, mi)
        else
          {i, mi}
        end
      end
      {i, mi} = try do
          while_fun_2.(while_fun_2, i, mi)
        catch
          {:break, {i, mi}} -> {i, mi}
        end

      throw {:return, mi}
    catch
      {:return, val} -> val
    end
  end
  def pancake_sort(arr) do
    try do
      cur = _len(arr)
      while_fun_3 = fn while_fun_3, arr, cur ->
        if cur > 1 do
          mi = find_max_index(arr, cur)
          arr = flip(arr, mi)
          arr = flip(arr, cur - 1)
          cur = cur - 1
          while_fun_3.(while_fun_3, arr, cur)
        else
          {arr, cur}
        end
      end
      {arr, cur} = try do
          while_fun_3.(while_fun_3, arr, cur)
        catch
          {:break, {arr, cur}} -> {arr, cur}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      data = [3, 6, 1, 10, 2]
      sorted = pancake_sort(data)
      IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [sorted])), ",", " "))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
