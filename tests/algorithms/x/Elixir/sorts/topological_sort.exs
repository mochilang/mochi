# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def topological_sort(start, visited, sort) do
    try do
      visited = Map.put(visited, start, true)
      neighbors = Process.get(:edges)[start]
      i = 0
      while_fun = fn while_fun, i, sort ->
        if i < _len(neighbors) do
          neighbor = Enum.at(neighbors, i, [])
          {sort} = if !(Map.has_key?(visited, neighbor)) do
            sort = topological_sort(neighbor, visited, sort)
            {sort}
          else
            {sort}
          end
          i = i + 1
          while_fun.(while_fun, i, sort)
        else
          {i, sort}
        end
      end
      {i, sort} = try do
          while_fun.(while_fun, i, sort)
        catch
          {:break, {i, sort}} -> {i, sort}
        end

      sort = (sort ++ [start])
      {sort} = if map_size(visited) != _len(Process.get(:vertices)) do
        j = 0
        while_fun_2 = fn while_fun_2, j, sort ->
          if j < _len(Process.get(:vertices)) do
            v = Enum.at(Process.get(:vertices), j, [])
            {sort} = if !(Map.has_key?(visited, v)) do
              sort = topological_sort(v, visited, sort)
              {sort}
            else
              {sort}
            end
            j = j + 1
            while_fun_2.(while_fun_2, j, sort)
          else
            {j, sort}
          end
        end
        {j, sort} = try do
            while_fun_2.(while_fun_2, j, sort)
          catch
            {:break, {j, sort}} -> {j, sort}
          end

        {sort}
      else
        {sort}
      end
      throw {:return, sort}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      result = topological_sort("a", %{}, [])
      IO.puts(Kernel.inspect(result))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:edges, %{"a" => ["c", "b"], "b" => ["d", "e"], "c" => [], "d" => [], "e" => []})
  Process.put(:vertices, ["a", "b", "c", "d", "e"])
end
Main.main()
