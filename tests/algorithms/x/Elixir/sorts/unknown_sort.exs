# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def list_min(xs) do
    try do
      i = 1
      m = Enum.at(xs, 0, [])
      while_fun = fn while_fun, i, m ->
        if i < _len(xs) do
          {m} = if Enum.at(xs, i, []) < m do
            m = Enum.at(xs, i, [])
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun.(while_fun, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun.(while_fun, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def list_max(xs) do
    try do
      i = 1
      m = Enum.at(xs, 0, [])
      while_fun_2 = fn while_fun_2, i, m ->
        if i < _len(xs) do
          {m} = if Enum.at(xs, i, []) > m do
            m = Enum.at(xs, i, [])
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_2.(while_fun_2, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def remove_once(xs, value) do
    try do
      res = []
      removed = false
      i = 0
      while_fun_3 = fn while_fun_3, i, removed, res ->
        if i < _len(xs) do
          {removed, res} = if !removed && Enum.at(xs, i, []) == value do
            removed = true
            {removed, res}
          else
            res = (res ++ [Enum.at(xs, i, [])])
            {removed, res}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, removed, res)
        else
          {i, removed, res}
        end
      end
      {i, removed, res} = try do
          while_fun_3.(while_fun_3, i, removed, res)
        catch
          {:break, {i, removed, res}} -> {i, removed, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def reverse_list(xs) do
    try do
      res = []
      i = _len(xs) - 1
      while_fun_4 = fn while_fun_4, i, res ->
        if i >= 0 do
          res = (res ++ [Enum.at(xs, i, [])])
          i = i - 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def merge_sort(collection) do
    try do
      start = []
      end_ = []
      coll = collection
      while_fun_5 = fn while_fun_5, coll, end_, start ->
        if _len(coll) > 1 do
          mn = list_min(coll)
          mx = list_max(coll)
          start = (start ++ [mn])
          end_ = (end_ ++ [mx])
          coll = remove_once(coll, mn)
          coll = remove_once(coll, mx)
          while_fun_5.(while_fun_5, coll, end_, start)
        else
          {coll, end_, start}
        end
      end
      {coll, end_, start} = try do
          while_fun_5.(while_fun_5, coll, end_, start)
        catch
          {:break, {coll, end_, start}} -> {coll, end_, start}
        end

      end_ = reverse_list(end_)
      throw {:return, ((start ++ coll) ++ end_)}
    catch
      {:return, val} -> val
    end
  end
  def test_merge_sort() do
    try do
      if merge_sort([0, 5, 3, 2, 2]) != [0, 2, 2, 3, 5] do
        raise("case1 failed")
      end
      if merge_sort([]) != [] do
        raise("case2 failed")
      end
      if merge_sort([-2, -5, -45]) != [-45, -5, -2] do
        raise("case3 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_merge_sort()
      IO.puts(Kernel.inspect(merge_sort([0, 5, 3, 2, 2])))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
