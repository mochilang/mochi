# Code generated by Mochi transpiler 2025-08-24 08:57 +0700
defmodule Main do
  @data_dir nil
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def insertion_sort(a, start, end_) do
    try do
      arr = a
      i = start
      while_fun = fn while_fun, arr, i ->
        if i < end_ do
          key = Enum.at(arr, i, [])
          j = i
          while_fun_2 = fn while_fun_2, arr, j ->
            if j > start && Enum.at(arr, j - 1, []) > key do
              arr = List.replace_at(arr, j, Enum.at(arr, j - 1, []))
              j = j - 1
              while_fun_2.(while_fun_2, arr, j)
            else
              {arr, j}
            end
          end
          {arr, _} = try do
              while_fun_2.(while_fun_2, arr, j)
            catch
              {:break, {arr, _}} -> {arr, 0}
            end

          arr = List.replace_at(arr, j, key)
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def heapify(a, index, heap_size) do
    try do
      arr = a
      largest = index
      left = 2 * index + 1
      right = 2 * index + 2
      largest = if left < heap_size && Enum.at(arr, left, []) > Enum.at(arr, largest, []) do
        largest = left
        largest
      else
        largest
      end
      largest = if right < heap_size && Enum.at(arr, right, []) > Enum.at(arr, largest, []) do
        largest = right
        largest
      else
        largest
      end
      arr = if largest != index do
        temp = Enum.at(arr, index, [])
        arr = List.replace_at(arr, index, Enum.at(arr, largest, []))
        arr = List.replace_at(arr, largest, temp)
        arr = heapify(arr, largest, heap_size)
        arr
      else
        arr
      end
      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def heap_sort(a) do
    try do
      arr = a
      n = _len(arr)
      if n <= 1 do
        throw {:return, arr}
      end
      i = div(n, 2)
      while_fun_3 = fn while_fun_3, arr, i ->
        if true do
          arr = heapify(arr, i, n)
          if i == 0 do
            throw {:break, {arr, i}}
          end
          i = i - 1
          while_fun_3.(while_fun_3, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun_3.(while_fun_3, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      i = n - 1
      while_fun_4 = fn while_fun_4, arr, i ->
        if i > 0 do
          temp = Enum.at(arr, 0, [])
          arr = List.replace_at(arr, 0, Enum.at(arr, i, []))
          arr = List.replace_at(arr, i, temp)
          arr = heapify(arr, 0, i)
          i = i - 1
          while_fun_4.(while_fun_4, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun_4.(while_fun_4, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def median_of_3(arr, first, middle, last) do
    try do
      a = Enum.at(arr, first, [])
      b = Enum.at(arr, middle, [])
      c = Enum.at(arr, last, [])
      if (a > b && a < c) || (a < b && a > c) do
        throw {:return, a}
      else
        if (b > a && b < c) || (b < a && b > c) do
          throw {:return, b}
        else
          throw {:return, c}
        end
      end
    catch
      {:return, val} -> val
    end
  end
  def partition(arr, low, high, pivot) do
    try do
      i = low
      j = high
      while_fun_5 = fn while_fun_5, arr, i, j ->
        if true do
          while_fun_6 = fn while_fun_6, i ->
            if Enum.at(arr, i, []) < pivot do
              i = i + 1
              while_fun_6.(while_fun_6, i)
            else
              i
            end
          end
          _ = try do
              while_fun_6.(while_fun_6, i)
            catch
              {:break, {_}} -> 0
            end

          j = j - 1
          while_fun_7 = fn while_fun_7, j ->
            if pivot < Enum.at(arr, j, []) do
              j = j - 1
              while_fun_7.(while_fun_7, j)
            else
              j
            end
          end
          _ = try do
              while_fun_7.(while_fun_7, j)
            catch
              {:break, {_}} -> 0
            end

          if i >= j do
            throw {:return, i}
          end
          temp = Enum.at(arr, i, [])
          arr = List.replace_at(arr, i, Enum.at(arr, j, []))
          arr = List.replace_at(arr, j, temp)
          i = i + 1
          while_fun_5.(while_fun_5, arr, i, j)
        else
          {arr, i, j}
        end
      end
      {arr, _, _} = try do
          while_fun_5.(while_fun_5, arr, i, j)
        catch
          {:break, {arr, _, _}} -> {arr, 0, 0}
        end

    catch
      {:return, val} -> val
    end
  end
  def int_log2(n) do
    try do
      v = n
      r = 0
      while_fun_8 = fn while_fun_8, r, v ->
        if v > 1 do
          v = div(v, 2)
          r = r + 1
          while_fun_8.(while_fun_8, r, v)
        else
          {r, v}
        end
      end
      {_, v} = try do
          while_fun_8.(while_fun_8, r, v)
        catch
          {:break, {_, v}} -> {0, v}
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def intro_sort(arr, start, end_, size_threshold, max_depth) do
    try do
      array = arr
      s = start
      e = end_
      depth = max_depth
      while_fun_9 = fn while_fun_9, array, depth, e ->
        if e - s > size_threshold do
          if depth == 0 do
            throw {:return, heap_sort(array)}
          end
          depth = depth - 1
          pivot = median_of_3(array, s, s + (div((e - s), 2)) + 1, e - 1)
          p = partition(array, s, e, pivot)
          array = intro_sort(array, p, e, size_threshold, depth)
          e = p
          while_fun_9.(while_fun_9, array, depth, e)
        else
          {array, depth, e}
        end
      end
      {array, depth, e} = try do
          while_fun_9.(while_fun_9, array, depth, e)
        catch
          {:break, {array, depth, e}} -> {array, depth, e}
        end

      res = insertion_sort(array, s, e)
      _ = _len(res)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def intro_sort_main(arr) do
    try do
      if _len(arr) == 0 do
        IO.puts(Kernel.inspect(arr))
        throw {:return, nil}
      end
      max_depth = 2 * int_log2(_len(arr))
      sorted = intro_sort(arr, 0, _len(arr), 16, max_depth)
      IO.puts(Kernel.inspect(sorted))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:example1, [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])
  def main() do
    Process.put(:example1, intro_sort_main(Process.get(:example1)))
    Process.put(:example2, [21, 15, 11, 45, -2, -11, 46])
    Process.put(:example2, intro_sort_main(Process.get(:example2)))
  end
end
Main.main()
