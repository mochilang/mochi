# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_bit_length(n) do
    try do
      if n == 0 do
        throw {:return, 1}
      end
      length = 0
      num = n
      while_fun = fn while_fun, length, num ->
        if num > 0 do
          length = length + 1
          num = div(num, 2)
          while_fun.(while_fun, length, num)
        else
          {length, num}
        end
      end
      {length, num} = try do
          while_fun.(while_fun, length, num)
        catch
          {:break, {length, num}} -> {length, num}
        end

      throw {:return, length}
    catch
      {:return, val} -> val
    end
  end
  def max_bit_length(nums) do
    try do
      i = 0
      max_len = 0
      while_fun_2 = fn while_fun_2, i, max_len ->
        if i < _len(nums) do
          l = get_bit_length(Enum.at(nums, i, []))
          {max_len} = if l > max_len do
            max_len = l
            {max_len}
          else
            {max_len}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, max_len)
        else
          {i, max_len}
        end
      end
      {i, max_len} = try do
          while_fun_2.(while_fun_2, i, max_len)
        catch
          {:break, {i, max_len}} -> {i, max_len}
        end

      throw {:return, max_len}
    catch
      {:return, val} -> val
    end
  end
  def get_bit(num, pos) do
    try do
      n = num
      i = 0
      while_fun_3 = fn while_fun_3, i, n ->
        if i < pos do
          n = div(n, 2)
          i = i + 1
          while_fun_3.(while_fun_3, i, n)
        else
          {i, n}
        end
      end
      {i, n} = try do
          while_fun_3.(while_fun_3, i, n)
        catch
          {:break, {i, n}} -> {i, n}
        end

      throw {:return, rem(n, 2)}
    catch
      {:return, val} -> val
    end
  end
  def _msd_radix_sort(nums, bit_position) do
    try do
      if bit_position == 0 || _len(nums) <= 1 do
        throw {:return, nums}
      end
      zeros = []
      ones = []
      i = 0
      while_fun_4 = fn while_fun_4, i, ones, zeros ->
        if i < _len(nums) do
          num = Enum.at(nums, i, [])
          {ones, zeros} = if get_bit(num, bit_position - 1) == 1 do
            ones = (ones ++ [num])
            {ones, zeros}
          else
            zeros = (zeros ++ [num])
            {ones, zeros}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, ones, zeros)
        else
          {i, ones, zeros}
        end
      end
      {i, ones, zeros} = try do
          while_fun_4.(while_fun_4, i, ones, zeros)
        catch
          {:break, {i, ones, zeros}} -> {i, ones, zeros}
        end

      zeros = _msd_radix_sort(zeros, bit_position - 1)
      ones = _msd_radix_sort(ones, bit_position - 1)
      res = zeros
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(ones) do
          res = (res ++ [Enum.at(ones, i, [])])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def msd_radix_sort(nums) do
    try do
      if _len(nums) == 0 do
        throw {:return, []}
      end
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(nums) do
          if Enum.at(nums, i, []) < 0 do
            raise("All numbers must be positive")
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      bits = max_bit_length(nums)
      result = _msd_radix_sort(nums, bits)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def msd_radix_sort_inplace(nums) do
    try do
      throw {:return, msd_radix_sort(nums)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:ex1, [40, 12, 1, 100, 4])
  Process.put(:ex2, [])
  Process.put(:ex3, [123, 345, 123, 80])
  Process.put(:ex4, [1209, 834598, 1, 540402, 45])
  def main() do
    Process.put(:sorted1, msd_radix_sort(Process.get(:ex1)))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:sorted1)])), ",", " "))
    Process.put(:sorted2, msd_radix_sort(Process.get(:ex2)))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:sorted2)])), ",", " "))
    Process.put(:sorted3, msd_radix_sort(Process.get(:ex3)))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:sorted3)])), ",", " "))
    Process.put(:sorted4, msd_radix_sort(Process.get(:ex4)))
    IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [Process.get(:sorted4)])), ",", " "))
  end
end
Main.main()
