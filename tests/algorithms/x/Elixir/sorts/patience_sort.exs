# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def bisect_left(stacks, value) do
    try do
      low = 0
      high = _len(stacks)
      while_fun = fn while_fun, high, low ->
        if low < high do
          mid = div((low + high), 2)
          stack = Enum.at(stacks, mid, [])
          top_idx = _len(stack) - 1
          top = Enum.at(stack, top_idx, [])
          {high, low} = if top < value do
            low = mid + 1
            {high, low}
          else
            high = mid
            {high, low}
          end
          while_fun.(while_fun, high, low)
        else
          {high, low}
        end
      end
      {high, low} = try do
          while_fun.(while_fun, high, low)
        catch
          {:break, {high, low}} -> {high, low}
        end

      throw {:return, low}
    catch
      {:return, val} -> val
    end
  end
  def reverse_list(src) do
    try do
      res = []
      i = _len(src) - 1
      while_fun_2 = fn while_fun_2, i, res ->
        if i >= 0 do
          res = (res ++ [Enum.at(src, i, [])])
          i = i - 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def patience_sort(collection) do
    try do
      stacks = []
      i = 0
      while_fun_3 = fn while_fun_3, i, stacks ->
        if i < _len(collection) do
          element = Enum.at(collection, i, [])
          idx = bisect_left(stacks, element)
          {stacks} = if idx != _len(stacks) do
            stack = Enum.at(stacks, idx, [])
            stacks = List.replace_at(stacks, idx, (stack ++ [element]))
            {stacks}
          else
            new_stack = [element]
            stacks = (stacks ++ [new_stack])
            {stacks}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, stacks)
        else
          {i, stacks}
        end
      end
      {i, stacks} = try do
          while_fun_3.(while_fun_3, i, stacks)
        catch
          {:break, {i, stacks}} -> {i, stacks}
        end

      i = 0
      while_fun_4 = fn while_fun_4, i, stacks ->
        if i < _len(stacks) do
          stacks = List.replace_at(stacks, i, reverse_list(Enum.at(stacks, i, [])))
          i = i + 1
          while_fun_4.(while_fun_4, i, stacks)
        else
          {i, stacks}
        end
      end
      {i, stacks} = try do
          while_fun_4.(while_fun_4, i, stacks)
        catch
          {:break, {i, stacks}} -> {i, stacks}
        end

      indices = []
      i = 0
      while_fun_5 = fn while_fun_5, i, indices ->
        if i < _len(stacks) do
          indices = (indices ++ [0])
          i = i + 1
          while_fun_5.(while_fun_5, i, indices)
        else
          {i, indices}
        end
      end
      {i, indices} = try do
          while_fun_5.(while_fun_5, i, indices)
        catch
          {:break, {i, indices}} -> {i, indices}
        end

      total = 0
      i = 0
      while_fun_6 = fn while_fun_6, i, total ->
        if i < _len(stacks) do
          total = total + _len(Enum.at(stacks, i, []))
          i = i + 1
          while_fun_6.(while_fun_6, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_6.(while_fun_6, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      result = []
      count = 0
      while_fun_7 = fn while_fun_7, count, indices, result ->
        if count < total do
          min_val = 0
          min_stack = -1
          j = 0
          while_fun_8 = fn while_fun_8, j, min_stack, min_val ->
            if j < _len(stacks) do
              idx = Enum.at(indices, j, [])
              {min_stack, min_val} = if idx < _len(Enum.at(stacks, j, [])) do
                val = Enum.at(Enum.at(stacks, j, []), idx, 0)
                {min_stack, min_val} = if min_stack < 0 do
                  min_val = val
                  min_stack = j
                  {min_stack, min_val}
                else
                  {min_stack, min_val} = if val < min_val do
                    min_val = val
                    min_stack = j
                    {min_stack, min_val}
                  else
                    {min_stack, min_val}
                  end
                  {min_stack, min_val}
                end
                {min_stack, min_val}
              else
                {min_stack, min_val}
              end
              j = j + 1
              while_fun_8.(while_fun_8, j, min_stack, min_val)
            else
              {j, min_stack, min_val}
            end
          end
          {j, min_stack, min_val} = try do
              while_fun_8.(while_fun_8, j, min_stack, min_val)
            catch
              {:break, {j, min_stack, min_val}} -> {j, min_stack, min_val}
            end

          result = (result ++ [min_val])
          indices = List.replace_at(indices, min_stack, Enum.at(indices, min_stack, []) + 1)
          count = count + 1
          while_fun_7.(while_fun_7, count, indices, result)
        else
          {count, indices, result}
        end
      end
      {count, indices, result} = try do
          while_fun_7.(while_fun_7, count, indices, result)
        catch
          {:break, {count, indices, result}} -> {count, indices, result}
        end

      i = 0
      while_fun_9 = fn while_fun_9, collection, i ->
        if i < _len(result) do
          collection = List.replace_at(collection, i, Enum.at(result, i, []))
          i = i + 1
          while_fun_9.(while_fun_9, collection, i)
        else
          {collection, i}
        end
      end
      {collection, i} = try do
          while_fun_9.(while_fun_9, collection, i)
        catch
          {:break, {collection, i}} -> {collection, i}
        end

      throw {:return, collection}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(patience_sort([1, 9, 5, 21, 17, 6])))
    IO.puts(Kernel.inspect(patience_sort([])))
    IO.puts(Kernel.inspect(patience_sort([-3, -17, -48])))
  end
end
Main.main()
