# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def copy_list(xs) do
    try do
      res = []
      k = 0
      while_fun = fn while_fun, k, res ->
        if k < _len(xs) do
          res = (res ++ [Enum.at(xs, k, [])])
          k = k + 1
          while_fun.(while_fun, k, res)
        else
          {k, res}
        end
      end
      {k, res} = try do
          while_fun.(while_fun, k, res)
        catch
          {:break, {k, res}} -> {k, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def insertion_sort(xs) do
    try do
      arr = copy_list(xs)
      idx = 1
      while_fun_2 = fn while_fun_2, arr, idx ->
        if idx < _len(arr) do
          value = Enum.at(arr, idx, [])
          jdx = idx - 1
          while_fun_3 = fn while_fun_3, arr, jdx ->
            if jdx >= 0 && Enum.at(arr, jdx, []) > value do
              arr = List.replace_at(arr, jdx + 1, Enum.at(arr, jdx, []))
              jdx = jdx - 1
              while_fun_3.(while_fun_3, arr, jdx)
            else
              {arr, jdx}
            end
          end
          {arr, jdx} = try do
              while_fun_3.(while_fun_3, arr, jdx)
            catch
              {:break, {arr, jdx}} -> {arr, jdx}
            end

          arr = List.replace_at(arr, jdx + 1, value)
          idx = idx + 1
          while_fun_2.(while_fun_2, arr, idx)
        else
          {arr, idx}
        end
      end
      {arr, idx} = try do
          while_fun_2.(while_fun_2, arr, idx)
        catch
          {:break, {arr, idx}} -> {arr, idx}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def merge(left, right) do
    try do
      result = []
      i = 0
      j = 0
      while_fun_4 = fn while_fun_4, i, j, result ->
        if i < _len(left) && j < _len(right) do
          {i, j, result} = if Enum.at(left, i, []) < Enum.at(right, j, []) do
            result = (result ++ [Enum.at(left, i, [])])
            i = i + 1
            {i, j, result}
          else
            result = (result ++ [Enum.at(right, j, [])])
            j = j + 1
            {i, j, result}
          end
          while_fun_4.(while_fun_4, i, j, result)
        else
          {i, j, result}
        end
      end
      {i, j, result} = try do
          while_fun_4.(while_fun_4, i, j, result)
        catch
          {:break, {i, j, result}} -> {i, j, result}
        end

      while_fun_5 = fn while_fun_5, i, result ->
        if i < _len(left) do
          result = (result ++ [Enum.at(left, i, [])])
          i = i + 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      while_fun_6 = fn while_fun_6, j, result ->
        if j < _len(right) do
          result = (result ++ [Enum.at(right, j, [])])
          j = j + 1
          while_fun_6.(while_fun_6, j, result)
        else
          {j, result}
        end
      end
      {j, result} = try do
          while_fun_6.(while_fun_6, j, result)
        catch
          {:break, {j, result}} -> {j, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def tim_sort(xs) do
    try do
      n = _len(xs)
      runs = []
      sorted_runs = []
      current = []
      current = (current ++ [Enum.at(xs, 0, [])])
      i = 1
      while_fun_7 = fn while_fun_7, current, i, runs ->
        if i < n do
          {current, runs} = if Enum.at(xs, i, []) < Enum.at(xs, i - 1, []) do
            runs = (runs ++ [copy_list(current)])
            current = []
            current = (current ++ [Enum.at(xs, i, [])])
            {current, runs}
          else
            current = (current ++ [Enum.at(xs, i, [])])
            {current, runs}
          end
          i = i + 1
          while_fun_7.(while_fun_7, current, i, runs)
        else
          {current, i, runs}
        end
      end
      {current, i, runs} = try do
          while_fun_7.(while_fun_7, current, i, runs)
        catch
          {:break, {current, i, runs}} -> {current, i, runs}
        end

      runs = (runs ++ [copy_list(current)])
      r = 0
      while_fun_8 = fn while_fun_8, r, sorted_runs ->
        if r < _len(runs) do
          sorted_runs = (sorted_runs ++ [insertion_sort(Enum.at(runs, r, []))])
          r = r + 1
          while_fun_8.(while_fun_8, r, sorted_runs)
        else
          {r, sorted_runs}
        end
      end
      {r, sorted_runs} = try do
          while_fun_8.(while_fun_8, r, sorted_runs)
        catch
          {:break, {r, sorted_runs}} -> {r, sorted_runs}
        end

      result = []
      r = 0
      while_fun_9 = fn while_fun_9, r, result ->
        if r < _len(sorted_runs) do
          result = merge(result, Enum.at(sorted_runs, r, []))
          r = r + 1
          while_fun_9.(while_fun_9, r, result)
        else
          {r, result}
        end
      end
      {r, result} = try do
          while_fun_9.(while_fun_9, r, result)
        catch
          {:break, {r, result}} -> {r, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(xs) do
    try do
      s = "["
      k = 0
      while_fun_10 = fn while_fun_10, k, s ->
        if k < _len(xs) do
          s = (s <> Kernel.to_string(Enum.at(xs, k, [])))
          {s} = if k < _len(xs) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          k = k + 1
          while_fun_10.(while_fun_10, k, s)
        else
          {k, s}
        end
      end
      {k, s} = try do
          while_fun_10.(while_fun_10, k, s)
        catch
          {:break, {k, s}} -> {k, s}
        end

      throw {:return, (s <> "]")}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:sample2, [3, 2, 1])
  def main() do
    Process.put(:sample, [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7])
    Process.put(:sorted_sample, tim_sort(Process.get(:sample)))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:sorted_sample))))
    Process.put(:sorted_sample2, tim_sort(Process.get(:sample2)))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:sorted_sample2))))
  end
end
Main.main()
