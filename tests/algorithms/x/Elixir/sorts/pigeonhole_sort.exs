# Code generated by Mochi transpiler 2025-08-11 17:23 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pigeonhole_sort(arr) do
    try do
      if _len(arr) == 0 do
        throw {:return, arr}
      end
      min_val = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.min(arr))
      max_val = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.max(arr))
      size = max_val - min_val + 1
      holes = []
      i = 0
      while_fun = fn while_fun, holes, i ->
        if i < size do
          holes = (holes ++ [0])
          i = i + 1
          while_fun.(while_fun, holes, i)
        else
          {holes, i}
        end
      end
      {holes, i} = try do
          while_fun.(while_fun, holes, i)
        catch
          {:break, {holes, i}} -> {holes, i}
        end

      i = 0
      while_fun_2 = fn while_fun_2, holes, i ->
        if i < _len(arr) do
          x = Enum.at(arr, i, [])
          index = x - min_val
          holes = List.replace_at(holes, index, Enum.at(holes, index, []) + 1)
          i = i + 1
          while_fun_2.(while_fun_2, holes, i)
        else
          {holes, i}
        end
      end
      {holes, i} = try do
          while_fun_2.(while_fun_2, holes, i)
        catch
          {:break, {holes, i}} -> {holes, i}
        end

      sorted_index = 0
      count = 0
      while_fun_3 = fn while_fun_3, arr, count, holes, sorted_index ->
        if count < size do
          while_fun_4 = fn while_fun_4, arr, holes, sorted_index ->
            if Enum.at(holes, count, []) > 0 do
              arr = List.replace_at(arr, sorted_index, count + min_val)
              holes = List.replace_at(holes, count, Enum.at(holes, count, []) - 1)
              sorted_index = sorted_index + 1
              while_fun_4.(while_fun_4, arr, holes, sorted_index)
            else
              {arr, holes, sorted_index}
            end
          end
          {arr, holes, sorted_index} = try do
              while_fun_4.(while_fun_4, arr, holes, sorted_index)
            catch
              {:break, {arr, holes, sorted_index}} -> {arr, holes, sorted_index}
            end

          count = count + 1
          while_fun_3.(while_fun_3, arr, count, holes, sorted_index)
        else
          {arr, count, holes, sorted_index}
        end
      end
      {arr, count, holes, sorted_index} = try do
          while_fun_3.(while_fun_3, arr, count, holes, sorted_index)
        catch
          {:break, {arr, count, holes, sorted_index}} -> {arr, count, holes, sorted_index}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:example, [8, 3, 2, 7, 4, 6, 8])
  Process.put(:output, "Sorted order is:")
  Process.put(:j, 0)
  def main() do
    Process.put(:result, pigeonhole_sort(Process.get(:example)))
    while_fun_5 = fn while_fun_5 ->
      if Process.get(:j) < _len(Process.get(:result)) do
        Process.put(:output, ((Process.get(:output) <> " ") <> Kernel.to_string(Enum.at(Process.get(:result), Process.get(:j), []))))
        Process.put(:j, Process.get(:j) + 1)
        while_fun_5.(while_fun_5)
      else
        nil
      end
    end
    try do
      while_fun_5.(while_fun_5)
    catch
      :break -> nil
    end

    IO.puts(Process.get(:output))
  end
end
Main.main()
