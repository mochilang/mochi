# Code generated by Mochi transpiler 2025-08-06 21:32 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  defp _getoutput(cmd) do
    {out, 0} = System.cmd("sh", ["-c", cmd])
    String.trim(out)
  end
  defp _fetch(url) do
    {out, 0} = System.cmd("curl", ["-fsSL", url])
    s = String.trim(out)
    case String.split(s, "\"title\":\"") do
      [_, rest] ->
        case String.split(rest, "\"") do
          [title | _] -> title
          _ -> ""
        end
      _ -> ""
    end
  end
  defp _md5_hex(s) do
    :crypto.hash(:md5, s) |> Base.encode16(case: :lower)
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def randint(a, b) do
    try do
      r = rand()
      throw {:return, a + rem(r, (b - a + 1))}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (1.0 * rand()) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def construct_highway(number_of_cells, frequency, initial_speed, random_frequency, random_speed, max_speed) do
    try do
      row = []
      i = 0
      while_fun = fn while_fun, i, row ->
        if i < number_of_cells do
          row = (row ++ [-1])
          i = i + 1
          while_fun.(while_fun, i, row)
        else
          {i, row}
        end
      end
      {i, row} = try do
          while_fun.(while_fun, i, row)
        catch
          {:break, {i, row}} -> {i, row}
        end

      highway = []
      highway = (highway ++ [row])
      i = 0
      {initial_speed} = if initial_speed < 0 do
        initial_speed = 0
        {initial_speed}
      else
        {initial_speed}
      end
      while_fun_2 = fn while_fun_2, highway, i ->
        if i < number_of_cells do
          speed = initial_speed
          {speed} = if random_speed do
            speed = randint(0, max_speed)
            {speed}
          else
            {speed}
          end
          highway = List.replace_at(highway, 0, List.replace_at(Enum.at(highway, 0), i, speed))
          step = frequency
          {step} = if random_frequency do
            step = randint(1, max_speed * 2)
            {step}
          else
            {step}
          end
          i = i + step
          while_fun_2.(while_fun_2, highway, i)
        else
          {highway, i}
        end
      end
      {highway, i} = try do
          while_fun_2.(while_fun_2, highway, i)
        catch
          {:break, {highway, i}} -> {highway, i}
        end

      throw {:return, highway}
    catch
      {:return, val} -> val
    end
  end
  def get_distance(highway_now, car_index) do
    try do
      distance = 0
      i = car_index + 1
      while_fun_3 = fn while_fun_3, distance, i ->
        if i < _len(highway_now) do
          if Enum.at(highway_now, i) > Process.get(:neg_one) do
            throw {:return, distance}
          end
          distance = distance + 1
          i = i + 1
          while_fun_3.(while_fun_3, distance, i)
        else
          {distance, i}
        end
      end
      {distance, i} = try do
          while_fun_3.(while_fun_3, distance, i)
        catch
          {:break, {distance, i}} -> {distance, i}
        end

      throw {:return, distance + get_distance(highway_now, -1)}
    catch
      {:return, val} -> val
    end
  end
  def update(highway_now, probability, max_speed) do
    try do
      number_of_cells = _len(highway_now)
      next_highway = []
      i = 0
      while_fun_4 = fn while_fun_4, i, next_highway ->
        if i < number_of_cells do
          next_highway = (next_highway ++ [-1])
          i = i + 1
          while_fun_4.(while_fun_4, i, next_highway)
        else
          {i, next_highway}
        end
      end
      {i, next_highway} = try do
          while_fun_4.(while_fun_4, i, next_highway)
        catch
          {:break, {i, next_highway}} -> {i, next_highway}
        end

      car_index = 0
      while_fun_5 = fn while_fun_5, car_index, next_highway ->
        if car_index < number_of_cells do
          speed = Enum.at(highway_now, car_index)
          {next_highway} = if speed > Process.get(:neg_one) do
            new_speed = speed + 1
            {new_speed} = if new_speed > max_speed do
              new_speed = max_speed
              {new_speed}
            else
              {new_speed}
            end
            dn = get_distance(highway_now, car_index) - 1
            {new_speed} = if new_speed > dn do
              new_speed = dn
              {new_speed}
            else
              {new_speed}
            end
            {new_speed} = if random() < probability do
              new_speed = new_speed - 1
              {new_speed} = if new_speed < 0 do
                new_speed = 0
                {new_speed}
              else
                {new_speed}
              end
              {new_speed}
            else
              {new_speed}
            end
            next_highway = List.replace_at(next_highway, car_index, new_speed)
            {next_highway}
          else
            {next_highway}
          end
          car_index = car_index + 1
          while_fun_5.(while_fun_5, car_index, next_highway)
        else
          {car_index, next_highway}
        end
      end
      {car_index, next_highway} = try do
          while_fun_5.(while_fun_5, car_index, next_highway)
        catch
          {:break, {car_index, next_highway}} -> {car_index, next_highway}
        end

      throw {:return, next_highway}
    catch
      {:return, val} -> val
    end
  end
  def simulate(highway, number_of_update, probability, max_speed) do
    try do
      number_of_cells = _len(Enum.at(highway, 0))
      i = 0
      while_fun_6 = fn while_fun_6, highway, i ->
        if i < number_of_update do
          next_speeds = update(Enum.at(highway, i), probability, max_speed)
          real_next = []
          j = 0
          while_fun_7 = fn while_fun_7, j, real_next ->
            if j < number_of_cells do
              real_next = (real_next ++ [-1])
              j = j + 1
              while_fun_7.(while_fun_7, j, real_next)
            else
              {j, real_next}
            end
          end
          {j, real_next} = try do
              while_fun_7.(while_fun_7, j, real_next)
            catch
              {:break, {j, real_next}} -> {j, real_next}
            end

          k = 0
          while_fun_8 = fn while_fun_8, k, real_next ->
            if k < number_of_cells do
              speed = Enum.at(next_speeds, k)
              {real_next} = if speed > Process.get(:neg_one) do
                index = rem((k + speed), number_of_cells)
                real_next = List.replace_at(real_next, index, speed)
                {real_next}
              else
                {real_next}
              end
              k = k + 1
              while_fun_8.(while_fun_8, k, real_next)
            else
              {k, real_next}
            end
          end
          {k, real_next} = try do
              while_fun_8.(while_fun_8, k, real_next)
            catch
              {:break, {k, real_next}} -> {k, real_next}
            end

          highway = (highway ++ [real_next])
          i = i + 1
          while_fun_6.(while_fun_6, highway, i)
        else
          {highway, i}
        end
      end
      {highway, i} = try do
          while_fun_6.(while_fun_6, highway, i)
        catch
          {:break, {highway, i}} -> {highway, i}
        end

      throw {:return, highway}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      ex1 = simulate(construct_highway(6, 3, 0, false, false, 2), 2, 0.0, 2)
      IO.puts(Kernel.to_string(ex1))
      ex2 = simulate(construct_highway(5, 2, -2, false, false, 2), 3, 0.0, 2)
      IO.puts(Kernel.to_string(ex2))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
  def bench_main() do
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:neg_one, -1)
Main.bench_main()
