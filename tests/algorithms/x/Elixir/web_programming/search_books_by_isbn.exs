# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _fetch(url) do
    {out, 0} = System.cmd("curl", ["-fsSL", url])
    s = String.trim(out)
    case String.split(s, "\"title\":\"") do
      [_, rest] ->
        case String.split(rest, "\"") do
          [title | _] -> title
          _ -> ""
        end
      _ -> ""
    end
  end
  def join(xs, sep) do
    try do
      res = ""
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) do
          {res} = if i > 0 do
            res = (res <> sep)
            {res}
          else
            {res}
          end
          res = (res <> Enum.at(xs, i, []))
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def count_char(s, ch) do
    try do
      cnt = 0
      i = 0
      while_fun_2 = fn while_fun_2, cnt, i ->
        if i < _len(s) do
          {cnt} = if _slice(s, i, i + 1 - (i)) == ch do
            cnt = cnt + 1
            {cnt}
          else
            {cnt}
          end
          i = i + 1
          while_fun_2.(while_fun_2, cnt, i)
        else
          {cnt, i}
        end
      end
      {cnt, i} = try do
          while_fun_2.(while_fun_2, cnt, i)
        catch
          {:break, {cnt, i}} -> {cnt, i}
        end

      throw {:return, cnt}
    catch
      {:return, val} -> val
    end
  end
  def strip(s) do
    try do
      start = 0
      end_ = _len(s)
      while_fun_3 = fn while_fun_3, start ->
        if start < end_ && _slice(s, start, start + 1 - (start)) == " " do
          start = start + 1
          while_fun_3.(while_fun_3, start)
        else
          start
        end
      end
      start = try do
          while_fun_3.(while_fun_3, start)
        catch
          {:break, {start}} -> start
        end

      while_fun_4 = fn while_fun_4, end_ ->
        if end_ > start && _slice(s, end_ - 1, end_ - (end_ - 1)) == " " do
          end_ = end_ - 1
          while_fun_4.(while_fun_4, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_4.(while_fun_4, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - start)}
    catch
      {:return, val} -> val
    end
  end
  def trim_slashes(s) do
    try do
      start = 0
      end_ = _len(s)
      while_fun_5 = fn while_fun_5, start ->
        if start < end_ && _slice(s, start, start + 1 - (start)) == "/" do
          start = start + 1
          while_fun_5.(while_fun_5, start)
        else
          start
        end
      end
      start = try do
          while_fun_5.(while_fun_5, start)
        catch
          {:break, {start}} -> start
        end

      while_fun_6 = fn while_fun_6, end_ ->
        if end_ > start && _slice(s, end_ - 1, end_ - (end_ - 1)) == "/" do
          end_ = end_ - 1
          while_fun_6.(while_fun_6, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_6.(while_fun_6, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - start)}
    catch
      {:return, val} -> val
    end
  end
  def normalize_olid(olid) do
    try do
      stripped = strip(olid)
      cleaned = trim_slashes(stripped)
      if count_char(cleaned, "/") != 1 do
        raise((olid <> " is not a valid Open Library olid"))
      end
      throw {:return, cleaned}
    catch
      {:return, val} -> val
    end
  end
  def get_book_data(olid) do
    try do
      norm = normalize_olid(olid)
      url = (("https://openlibrary.org/" <> norm) <> ".json")
      data = %{authors: 0, isbn_10: 0, isbn_13: 0, number_of_pages: 0, publish_date: "", title: _fetch(url)}
      throw {:return, data}
    catch
      {:return, val} -> val
    end
  end
  def get_author_data(olid) do
    try do
      norm = normalize_olid(olid)
      url = (("https://openlibrary.org/" <> norm) <> ".json")
      data = %{name: ""}
      throw {:return, data}
    catch
      {:return, val} -> val
    end
  end
  def summarize_book(book) do
    try do
      names = []
      i = 0
      while_fun_7 = fn while_fun_7, i, names ->
        if i < _len(Map.get(book, :authors, [])) do
          ref = Enum.at(book.authors, i, 0)
          auth = get_author_data(ref.key)
          names = (names ++ [auth.name])
          i = i + 1
          while_fun_7.(while_fun_7, i, names)
        else
          {i, names}
        end
      end
      {i, names} = try do
          while_fun_7.(while_fun_7, i, names)
        catch
          {:break, {i, names}} -> {i, names}
        end

      throw {:return, %{title: book.title, publish_date: book.publish_date, authors: join(names, ", "), number_of_pages: book.number_of_pages, isbn_10: join(book.isbn_10, ", "), isbn_13: join(book.isbn_13, ", ")}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      book = get_book_data("isbn/0140328726")
      summary = summarize_book(book)
      IO.puts(("Title: " <> summary.title))
      IO.puts(("Publish date: " <> summary.publish_date))
      IO.puts(("Authors: " <> summary.authors))
      IO.puts(("Number of pages: " <> Kernel.to_string(summary.number_of_pages)))
      IO.puts(("ISBN (10): " <> summary.isbn_10))
      IO.puts(("ISBN (13): " <> summary.isbn_13))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
