# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def contains(xs, x) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == x do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def join_with_comma(xs) do
    try do
      s = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, s ->
        if i < _len(xs) do
          {s} = if i > 0 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          s = (s <> Enum.at(xs, i, []))
          i = i + 1
          while_fun_2.(while_fun_2, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_2.(while_fun_2, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def get_subreddit_data(subreddit, limit, age, wanted_data) do
    try do
      invalid = []
      i = 0
      while_fun_3 = fn while_fun_3, i, invalid ->
        if i < _len(wanted_data) do
          term = Enum.at(wanted_data, i, [])
          {invalid} = if !contains(Process.get(:valid_terms), term) do
            invalid = (invalid ++ [term])
            {invalid}
          else
            {invalid}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, invalid)
        else
          {i, invalid}
        end
      end
      {i, invalid} = try do
          while_fun_3.(while_fun_3, i, invalid)
        catch
          {:break, {i, invalid}} -> {i, invalid}
        end

      if _len(invalid) > 0 do
        msg = ("Invalid search term: " <> join_with_comma(invalid))
        raise(msg)
      end
      resp = %{data: 0}
      result = %{}
      idx = 0
      while_fun_4 = fn while_fun_4, idx, result ->
        if idx < limit do
          post = Enum.at(resp.data.children, idx, 0)["data"]
          post_map = %{}
          {post_map} = if _len(wanted_data) == 0 do
            post_map = Map.put(post_map, "title", post.title)
            post_map = Map.put(post_map, "url", post.url)
            post_map = Map.put(post_map, "selftext", post.selftext)
            {post_map}
          else
            j = 0
            while_fun_5 = fn while_fun_5, j, post_map ->
              if j < _len(wanted_data) do
                field = Enum.at(wanted_data, j, [])
                {post_map} = if field == "title" do
                  post_map = Map.put(post_map, "title", post.title)
                  {post_map}
                else
                  {post_map} = if field == "url" do
                    post_map = Map.put(post_map, "url", post.url)
                    {post_map}
                  else
                    {post_map} = if field == "selftext" do
                      post_map = Map.put(post_map, "selftext", post.selftext)
                      {post_map}
                    else
                      {post_map}
                    end
                    {post_map}
                  end
                  {post_map}
                end
                j = j + 1
                while_fun_5.(while_fun_5, j, post_map)
              else
                {j, post_map}
              end
            end
            {j, post_map} = try do
                while_fun_5.(while_fun_5, j, post_map)
              catch
                {:break, {j, post_map}} -> {j, post_map}
              end

            {post_map}
          end
          result = Map.put(result, idx, post_map)
          idx = idx + 1
          while_fun_4.(while_fun_4, idx, result)
        else
          {idx, result}
        end
      end
      {idx, result} = try do
          while_fun_4.(while_fun_4, idx, result)
        catch
          {:break, {idx, result}} -> {idx, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:valid_terms, ["approved_at_utc", "approved_by", "author_flair_background_color", "author_flair_css_class", "author_flair_richtext", "author_flair_template_id", "author_fullname", "author_premium", "can_mod_post", "category", "clicked", "content_categories", "created_utc", "downs", "edited", "gilded", "gildings", "hidden", "hide_score", "is_created_from_ads_ui", "is_meta", "is_original_content", "is_reddit_media_domain", "is_video", "link_flair_css_class", "link_flair_richtext", "link_flair_text", "link_flair_text_color", "media_embed", "mod_reason_title", "name", "permalink", "pwls", "quarantine", "saved", "score", "secure_media", "secure_media_embed", "selftext", "subreddit", "subreddit_name_prefixed", "subreddit_type", "thumbnail", "title", "top_awarded_type", "total_awards_received", "ups", "upvote_ratio", "url", "user_reports"])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(get_subreddit_data("learnpython", 1, "new", ["title", "url", "selftext"])))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
