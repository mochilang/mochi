# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def indexOf(s, sub, start) do
    try do
      n = _len(s)
      m = _len(sub)
      i = start
      while_fun = fn while_fun, i ->
        if i <= n - m do
          j = 0
          ok = true
          while_fun_2 = fn while_fun_2, j, ok ->
            if j < m do
              {ok} = if _slice(s, i + j, i + j + 1 - (i + j)) != _slice(sub, j, j + 1 - (j)) do
                ok = false
                throw {:break, {j, ok}}
                {ok}
              else
                {ok}
              end
              j = j + 1
              while_fun_2.(while_fun_2, j, ok)
            else
              {j, ok}
            end
          end
          {j, ok} = try do
              while_fun_2.(while_fun_2, j, ok)
            catch
              {:break, {j, ok}} -> {j, ok}
            end

          if ok do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, (0 - 1)}
    catch
      {:return, val} -> val
    end
  end
  def splitBy(s, sep) do
    try do
      res = []
      start = 0
      sepLen = _len(sep)
      idx = indexOf(s, sep, 0)
      while_fun_3 = fn while_fun_3, idx, res, start ->
        if idx != (0 - 1) do
          res = (res ++ [_slice(s, start, idx - (start))])
          start = idx + sepLen
          idx = indexOf(s, sep, start)
          while_fun_3.(while_fun_3, idx, res, start)
        else
          {idx, res, start}
        end
      end
      {idx, res, start} = try do
          while_fun_3.(while_fun_3, idx, res, start)
        catch
          {:break, {idx, res, start}} -> {idx, res, start}
        end

      res = (res ++ [_slice(s, start, _len(s) - (start))])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def between(s, startTag, endTag) do
    try do
      startIdx = indexOf(s, startTag, 0)
      if startIdx == (0 - 1) do
        throw {:return, ""}
      end
      startIdx = startIdx + _len(startTag)
      endIdx = indexOf(s, endTag, startIdx)
      if endIdx == (0 - 1) do
        throw {:return, ""}
      end
      throw {:return, _slice(s, startIdx, endIdx - (startIdx))}
    catch
      {:return, val} -> val
    end
  end
  def intToString(n) do
    try do
      if n == 0 do
        throw {:return, "0"}
      end
      num = n
      digits = ""
      while_fun_4 = fn while_fun_4, digits, num ->
        if num > 0 do
          d = rem(num, 10)
          digits = (_slice("0123456789", d, d + 1 - (d)) <> digits)
          num = div(num, 10)
          while_fun_4.(while_fun_4, digits, num)
        else
          {digits, num}
        end
      end
      {digits, num} = try do
          while_fun_4.(while_fun_4, digits, num)
        catch
          {:break, {digits, num}} -> {digits, num}
        end

      throw {:return, digits}
    catch
      {:return, val} -> val
    end
  end
  def fetch_jobs(location) do
    try do
      blocks = splitBy(Process.get(:sample_html), "data-tn-component=\"organicJob\"")
      jobs = []
      i = 1
      while_fun_5 = fn while_fun_5, i, jobs ->
        if i < _len(blocks) do
          block = Enum.at(blocks, i, [])
          title = between(block, "data-tn-element=\"jobTitle\">", "</a>")
          company = between(block, "class=\"company\">", "</span>")
          jobs = (jobs ++ [%{title: title, company: company}])
          i = i + 1
          while_fun_5.(while_fun_5, i, jobs)
        else
          {i, jobs}
        end
      end
      {i, jobs} = try do
          while_fun_5.(while_fun_5, i, jobs)
        catch
          {:break, {i, jobs}} -> {i, jobs}
        end

      throw {:return, jobs}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      jobs = fetch_jobs("Bangalore")
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(jobs) do
          j = Enum.at(jobs, i, [])
          idx = i + 1
          IO.puts(((((("Job " <> intToString(idx)) <> " is ") <> j.title) <> " at ") <> j.company))
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:sample_html, "<div data-tn-component=\"organicJob\"><a data-tn-element=\"jobTitle\">Android Developer</a><span class=\"company\">ABC Corp</span></div><div data-tn-component=\"organicJob\"><a data-tn-element=\"jobTitle\">iOS Engineer</a><span class=\"company\">XYZ Ltd</span></div>")
  def bench_main() do
    Process.put(:sample_html, "<div data-tn-component=\"organicJob\"><a data-tn-element=\"jobTitle\">Android Developer</a><span class=\"company\">ABC Corp</span></div><div data-tn-component=\"organicJob\"><a data-tn-element=\"jobTitle\">iOS Engineer</a><span class=\"company\">XYZ Ltd</span></div>")
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
