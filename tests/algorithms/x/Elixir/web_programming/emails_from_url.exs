# Code generated by Mochi transpiler 2025-08-11 15:32 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def index_of(s, ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(s) do
          if String.at(s, i) == ch do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def index_of_substring(s, sub) do
    try do
      n = _len(s)
      m = _len(sub)
      if m == 0 do
        throw {:return, 0}
      end
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i <= n - m do
          j = 0
          is_match = true
          while_fun_3 = fn while_fun_3, is_match, j ->
            if j < m do
              {is_match} = if String.at(s, i + j) != String.at(sub, j) do
                is_match = false
                throw {:break, {is_match, j}}
                {is_match}
              else
                {is_match}
              end
              j = j + 1
              while_fun_3.(while_fun_3, is_match, j)
            else
              {is_match, j}
            end
          end
          {is_match, j} = try do
              while_fun_3.(while_fun_3, is_match, j)
            catch
              {:break, {is_match, j}} -> {is_match, j}
            end

          if is_match do
            throw {:return, i}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def split(s, sep) do
    try do
      parts = []
      last = 0
      i = 0
      while_fun_4 = fn while_fun_4, i, last, parts ->
        if i < _len(s) do
          ch = String.at(s, i)
          {last, parts} = if ch == sep do
            parts = (parts ++ [_slice(s, last, i - (last))])
            last = i + 1
            {last, parts}
          else
            {last, parts}
          end
          {parts} = if i + 1 == _len(s) do
            parts = (parts ++ [_slice(s, last, i + 1 - (last))])
            {parts}
          else
            {parts}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, last, parts)
        else
          {i, last, parts}
        end
      end
      {i, last, parts} = try do
          while_fun_4.(while_fun_4, i, last, parts)
        catch
          {:break, {i, last, parts}} -> {i, last, parts}
        end

      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def get_sub_domain_name(url) do
    try do
      proto_pos = index_of_substring(url, "://")
      start = 0
      {start} = if proto_pos >= 0 do
        start = proto_pos + 3
        {start}
      else
        {start}
      end
      i = start
      while_fun_5 = fn while_fun_5, i ->
        if i < _len(url) do
          if String.at(url, i) == "/" do
            throw {:break, {i}}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, _slice(url, start, i - (start))}
    catch
      {:return, val} -> val
    end
  end
  def get_domain_name(url) do
    try do
      sub = get_sub_domain_name(url)
      parts = split(sub, ".")
      if _len(parts) >= 2 do
        throw {:return, ((Enum.at(parts, _len(parts) - 2, []) <> ".") <> Enum.at(parts, _len(parts) - 1, []))}
      end
      throw {:return, sub}
    catch
      {:return, val} -> val
    end
  end
  def is_alnum(ch) do
    try do
      chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
      throw {:return, index_of(chars, ch) >= 0}
    catch
      {:return, val} -> val
    end
  end
  def contains(xs, x) do
    try do
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == x do
            throw {:return, true}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def bubble_sort(xs) do
    try do
      arr = xs
      n = _len(arr)
      i = 0
      while_fun_7 = fn while_fun_7, arr, i ->
        if i < n do
          j = 0
          while_fun_8 = fn while_fun_8, arr, j ->
            if j + 1 < n - i do
              {arr} = if Enum.at(arr, j, []) > Enum.at(arr, j + 1, []) do
                tmp = Enum.at(arr, j, [])
                arr = List.replace_at(arr, j, Enum.at(arr, j + 1, []))
                arr = List.replace_at(arr, j + 1, tmp)
                {arr}
              else
                {arr}
              end
              j = j + 1
              while_fun_8.(while_fun_8, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_8.(while_fun_8, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun_7.(while_fun_7, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_7.(while_fun_7, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def extract_links(domain, html) do
    try do
      links = []
      pos = index_of_substring(html, "href=")
      while_fun_9 = fn while_fun_9, links, pos ->
        if pos >= 0 do
          start_quote = index_of(_slice(html, pos + 5, _len(html) - (pos + 5)), "\"")
          if start_quote < 0 do
            throw {:break, {links, pos}}
          end
          rest = pos + 5 + start_quote + 1
          end_quote = index_of(_slice(html, rest, _len(html) - (rest)), "\"")
          if end_quote < 0 do
            throw {:break, {links, pos}}
          end
          link = _slice(html, rest, rest + end_quote - (rest))
          {links} = if !contains(links, link) do
            absolute = link
            {absolute} = if !(index_of_substring(link, "http://") == 0 || index_of_substring(link, "https://") == 0) do
              absolute = (if index_of_substring(link, "/") == 0, do: (("https://" <> domain) <> link), else: ((("https://" <> domain) <> "/") <> link))
              {absolute}
            else
              {absolute}
            end
            links = (links ++ [absolute])
            {links}
          else
            {links}
          end
          pos = index_of_substring(_slice(html, rest + end_quote, _len(html) - (rest + end_quote)), "href=")
          {pos} = if pos >= 0 do
            pos = pos + rest + end_quote
            {pos}
          else
            {pos}
          end
          while_fun_9.(while_fun_9, links, pos)
        else
          {links, pos}
        end
      end
      {links, pos} = try do
          while_fun_9.(while_fun_9, links, pos)
        catch
          {:break, {links, pos}} -> {links, pos}
        end

      throw {:return, links}
    catch
      {:return, val} -> val
    end
  end
  def extract_emails(domain, text) do
    try do
      emails = []
      i = 0
      while_fun_10 = fn while_fun_10, i ->
        if i < _len(text) do
          if String.at(text, i) == "@" do
            if _slice(text, i + 1, i + 1 + _len(domain) - (i + 1)) == domain do
              j = i - 1
              while_fun_11 = fn while_fun_11, j ->
                if j >= 0 && is_alnum(String.at(text, j)) do
                  j = j - 1
                  while_fun_11.(while_fun_11, j)
                else
                  j
                end
              end
              j = try do
                  while_fun_11.(while_fun_11, j)
                catch
                  {:break, {j}} -> j
                end

              local = _slice(text, j + 1, i - (j + 1))
              if _len(local) > 0 do
                email = ((local <> "@") <> domain)
                if !contains(emails, email) do
                  emails = (emails ++ [email])
                end
              end
            end
          end
          i = i + 1
          while_fun_10.(while_fun_10, i)
        else
          i
        end
      end
      i = try do
          while_fun_10.(while_fun_10, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, emails}
    catch
      {:return, val} -> val
    end
  end
  def find_page(pages, url) do
    try do
      i = 0
      while_fun_12 = fn while_fun_12, i ->
        if i < _len(pages) do
          p = Enum.at(pages, i, [])
          if p.url == url do
            throw {:return, p.html}
          end
          i = i + 1
          while_fun_12.(while_fun_12, i)
        else
          i
        end
      end
      i = try do
          while_fun_12.(while_fun_12, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, ""}
    catch
      {:return, val} -> val
    end
  end
  def emails_from_url(url, pages) do
    try do
      domain = get_domain_name(url)
      base_html = find_page(pages, url)
      links = extract_links(domain, base_html)
      found = []
      i = 0
      while_fun_13 = fn while_fun_13, found, i ->
        if i < _len(links) do
          html = find_page(pages, Enum.at(links, i, []))
          emails = extract_emails(domain, html)
          j = 0
          while_fun_14 = fn while_fun_14, found, j ->
            if j < _len(Process.get(:emails)) do
              {found} = if !contains(found, Enum.at(Process.get(:emails), j, [])) do
                found = (found ++ [Enum.at(Process.get(:emails), j, [])])
                {found}
              else
                {found}
              end
              j = j + 1
              while_fun_14.(while_fun_14, found, j)
            else
              {found, j}
            end
          end
          {found, j} = try do
              while_fun_14.(while_fun_14, found, j)
            catch
              {:break, {found, j}} -> {found, j}
            end

          i = i + 1
          while_fun_13.(while_fun_13, found, i)
        else
          {found, i}
        end
      end
      {found, i} = try do
          while_fun_13.(while_fun_13, found, i)
        catch
          {:break, {found, i}} -> {found, i}
        end

      sorted = bubble_sort(found)
      throw {:return, sorted}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pages, [%{url: "https://example.com", html: "<html><body><a href=\"/contact\">Contact</a></body></html>"}, %{url: "https://example.com/contact", html: "<html>Contact us at info@example.com or support@example.com</html>"}])
  Process.put(:k, 0)
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:emails, emails_from_url("https://example.com", Process.get(:pages)))
    IO.puts((Kernel.inspect(_len(Process.get(:emails))) <> " emails found:"))
    while_fun_15 = fn while_fun_15 ->
      if Process.get(:k) < _len(Process.get(:emails)) do
        IO.puts(Enum.at(Process.get(:emails), Process.get(:k), []))
        Process.put(:k, Process.get(:k) + 1)
        while_fun_15.(while_fun_15)
      else
        nil
      end
    end
    try do
      while_fun_15.(while_fun_15)
    catch
      :break -> nil
    end

    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
