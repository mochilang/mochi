# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def index_of_min(xs) do
    try do
      min_idx = 0
      i = 1
      while_fun = fn while_fun, i, min_idx ->
        if i < _len(xs) do
          {min_idx} = if Enum.at(xs, i, []) < Enum.at(xs, min_idx, []) do
            min_idx = i
            {min_idx}
          else
            {min_idx}
          end
          i = i + 1
          while_fun.(while_fun, i, min_idx)
        else
          {i, min_idx}
        end
      end
      {i, min_idx} = try do
          while_fun.(while_fun, i, min_idx)
        catch
          {:break, {i, min_idx}} -> {i, min_idx}
        end

      throw {:return, min_idx}
    catch
      {:return, val} -> val
    end
  end
  def remove_at(xs, idx) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(xs) do
          {res} = if i != idx do
            res = (res ++ [Enum.at(xs, i, [])])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def optimal_merge_pattern(files) do
    try do
      arr = files
      optimal_merge_cost = 0
      while_fun_3 = fn while_fun_3, arr, optimal_merge_cost ->
        if _len(arr) > 1 do
          temp = 0
          k = 0
          while_fun_4 = fn while_fun_4, arr, k, temp ->
            if k < 2 do
              min_idx = index_of_min(arr)
              temp = temp + Enum.at(arr, min_idx, [])
              arr = remove_at(arr, min_idx)
              k = k + 1
              while_fun_4.(while_fun_4, arr, k, temp)
            else
              {arr, k, temp}
            end
          end
          {arr, k, temp} = try do
              while_fun_4.(while_fun_4, arr, k, temp)
            catch
              {:break, {arr, k, temp}} -> {arr, k, temp}
            end

          arr = (arr ++ [temp])
          optimal_merge_cost = optimal_merge_cost + temp
          while_fun_3.(while_fun_3, arr, optimal_merge_cost)
        else
          {arr, optimal_merge_cost}
        end
      end
      {arr, optimal_merge_cost} = try do
          while_fun_3.(while_fun_3, arr, optimal_merge_cost)
        catch
          {:break, {arr, optimal_merge_cost}} -> {arr, optimal_merge_cost}
        end

      throw {:return, optimal_merge_cost}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(optimal_merge_pattern([2, 3, 4])))
    IO.puts(Kernel.inspect(optimal_merge_pattern([5, 10, 20, 30, 30])))
    IO.puts(Kernel.inspect(optimal_merge_pattern([8, 8, 8, 8, 8])))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
