# Code generated by Mochi transpiler 2025-08-16 09:34 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def ratio(item) do
    try do
      throw {:return, (:erlang.float(item.value)) / (:erlang.float(item.weight))}
    catch
      {:return, val} -> val
    end
  end
  def fractional_cover(items, capacity) do
    try do
      if capacity < 0 do
        raise("Capacity cannot be negative")
      end
      total = 0.0
      remaining = capacity
      sorted = Enum.map(Enum.sort_by(for it <- items do
  %{
    k: -ratio(it),
    v: it
  }
end, fn x ->
  try do
    throw {:return, x.k}
  catch
    {:return, val} -> val
  end
end), fn x ->
  try do
    throw {:return, x.v}
  catch
    {:return, val} -> val
  end
end)
      idx = 0
      while_fun = fn while_fun, idx, remaining, total ->
        if idx < _len(sorted) && remaining > 0 do
          item = Enum.at(sorted, idx, [])
          take = (if item.weight < remaining, do: item.weight, else: remaining)
          total = total + (:erlang.float(take)) * ratio(item)
          remaining = remaining - take
          idx = idx + 1
          while_fun.(while_fun, idx, remaining, total)
        else
          {idx, remaining, total}
        end
      end
      {idx, remaining, total} = try do
          while_fun.(while_fun, idx, remaining, total)
        catch
          {:break, {idx, remaining, total}} -> {idx, remaining, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:items1, [%{weight: 10, value: 60}, %{weight: 20, value: 100}, %{weight: 30, value: 120}])
  Process.put(:items2, [%{weight: 20, value: 100}, %{weight: 30, value: 120}, %{weight: 10, value: 60}])
  Process.put(:items3, [])
  Process.put(:items4, [%{weight: 10, value: 60}])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(fractional_cover(Process.get(:items1), 50)))
    IO.puts(Kernel.inspect(fractional_cover(Process.get(:items2), 25)))
    IO.puts(Kernel.inspect(fractional_cover(Process.get(:items3), 50)))
    IO.puts(Kernel.inspect(fractional_cover(Process.get(:items4), 5)))
    IO.puts(Kernel.inspect(fractional_cover(Process.get(:items4), 1)))
    IO.puts(Kernel.inspect(fractional_cover(Process.get(:items4), 0)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
