# Code generated by Mochi transpiler 2025-08-16 09:34 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sort_by_ratio_desc(arr) do
    try do
      i = 1
      while_fun = fn while_fun, arr, i ->
        if i < _len(arr) do
          key = Enum.at(arr, i, [])
          j = i - 1
          while_fun_2 = fn while_fun_2, arr, j ->
            if j >= 0 do
              current = Enum.at(arr, j, [])
              {arr, j} = if current.value / current.weight < key.value / key.weight do
                arr = List.replace_at(arr, j + 1, current)
                j = j - 1
                {arr, j}
              else
                throw {:break, {arr, j}}
                {arr, j}
              end
              while_fun_2.(while_fun_2, arr, j)
            else
              {arr, j}
            end
          end
          {arr, _} = try do
              while_fun_2.(while_fun_2, arr, j)
            catch
              {:break, {arr, _}} -> {arr, 0}
            end

          arr = List.replace_at(arr, j + 1, key)
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def sum_first(arr, k) do
    try do
      s = 0.0
      i = 0
      while_fun_3 = fn while_fun_3, i, s ->
        if i < k && i < _len(arr) do
          s = s + Enum.at(arr, i, [])
          i = i + 1
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {_, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          {:break, {_, s}} -> {0, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def frac_knapsack(vl, wt, w, n) do
    try do
      items = []
      i = 0
      while_fun_4 = fn while_fun_4, i, items ->
        if i < _len(vl) && i < _len(wt) do
          items = (items ++ [%{value: Enum.at(vl, i, []), weight: Enum.at(wt, i, [])}])
          i = i + 1
          while_fun_4.(while_fun_4, i, items)
        else
          {i, items}
        end
      end
      {_, items} = try do
          while_fun_4.(while_fun_4, i, items)
        catch
          {:break, {_, items}} -> {0, items}
        end

      items = sort_by_ratio_desc(items)
      values = []
      weights = []
      i = 0
      while_fun_5 = fn while_fun_5, i, values, weights ->
        if i < _len(items) do
          itm = Enum.at(items, i, [])
          values = (values ++ [itm.value])
          weights = (weights ++ [itm.weight])
          i = i + 1
          while_fun_5.(while_fun_5, i, values, weights)
        else
          {i, values, weights}
        end
      end
      {_, values, weights} = try do
          while_fun_5.(while_fun_5, i, values, weights)
        catch
          {:break, {_, values, weights}} -> {0, values, weights}
        end

      acc = []
      total = 0.0
      i = 0
      while_fun_6 = fn while_fun_6, acc, i, total ->
        if i < _len(weights) do
          total = total + Enum.at(weights, i, [])
          acc = (acc ++ [total])
          i = i + 1
          while_fun_6.(while_fun_6, acc, i, total)
        else
          {acc, i, total}
        end
      end
      {acc, _, total} = try do
          while_fun_6.(while_fun_6, acc, i, total)
        catch
          {:break, {acc, _, total}} -> {acc, 0, total}
        end

      k = 0
      while_fun_7 = fn while_fun_7, k ->
        if k < _len(acc) && w >= Enum.at(acc, k, []) do
          k = k + 1
          while_fun_7.(while_fun_7, k)
        else
          k
        end
      end
      _ = try do
          while_fun_7.(while_fun_7, k)
        catch
          {:break, {_}} -> 0
        end

      if k == 0 do
        throw {:return, 0.0}
      end
      if k >= _len(values) do
        throw {:return, sum_first(values, _len(values))}
      end
      if k != n do
        throw {:return, sum_first(values, k) + (w - Enum.at(acc, k - 1, [])) * Enum.at(values, k, []) / Enum.at(weights, k, [])}
      end
      throw {:return, sum_first(values, k)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:vl, [60.0, 100.0, 120.0])
  Process.put(:wt, [10.0, 20.0, 30.0])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:result, frac_knapsack(Process.get(:vl), Process.get(:wt), 50.0, 3))
    IO.puts(Kernel.to_string(Process.get(:result)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
