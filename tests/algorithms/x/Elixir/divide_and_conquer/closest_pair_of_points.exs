# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: 0.0 - x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def euclidean_distance_sqr(p1, p2) do
    try do
      dx = Enum.at(p1, 0) - Enum.at(p2, 0)
      dy = Enum.at(p1, 1) - Enum.at(p2, 1)
      throw {:return, dx * dx + dy * dy}
    catch
      {:return, val} -> val
    end
  end
  def column_based_sort(arr, column) do
    try do
      points = arr
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < _len(points) do
          j = 0
          while_fun_3 = fn while_fun_3, j ->
            if j < _len(points) - 1 do
              if Enum.at(Enum.at(points, j), column) > Enum.at(Enum.at(points, j + 1), column) do
                tmp = Enum.at(points, j)
                points = List.replace_at(points, j, Enum.at(points, j + 1))
                points = List.replace_at(points, j + 1, tmp)
              end
              j = j + 1
              while_fun_3.(while_fun_3, j)
            else
              j
            end
          end
          j = try do
              while_fun_3.(while_fun_3, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, points}
    catch
      {:return, val} -> val
    end
  end
  def dis_between_closest_pair(points, count, min_dis) do
    try do
      i = 0
      while_fun_4 = fn while_fun_4, i, min_dis ->
        if i < count - 1 do
          j = i + 1
          while_fun_5 = fn while_fun_5, j, min_dis ->
            if j < count do
              current = euclidean_distance_sqr(Enum.at(points, i), Enum.at(points, j))
              {min_dis} = if current < min_dis do
                min_dis = current
                {min_dis}
              else
                {min_dis}
              end
              j = j + 1
              while_fun_5.(while_fun_5, j, min_dis)
            else
              {j, min_dis}
            end
          end
          {j, min_dis} = try do
              while_fun_5.(while_fun_5, j, min_dis)
            catch
              {:break, {j, min_dis}} -> {j, min_dis}
            end

          i = i + 1
          while_fun_4.(while_fun_4, i, min_dis)
        else
          {i, min_dis}
        end
      end
      {i, min_dis} = try do
          while_fun_4.(while_fun_4, i, min_dis)
        catch
          {:break, {i, min_dis}} -> {i, min_dis}
        end

      throw {:return, min_dis}
    catch
      {:return, val} -> val
    end
  end
  def dis_between_closest_in_strip(points, count, min_dis) do
    try do
      i_start = 0
      i_start = (if 6 < count - 1, do: 6, else: count - 1)
      i = i_start
      while_fun_6 = fn while_fun_6, i, min_dis ->
        if i < count do
          j_start = 0
          {j_start} = if i - 6 > 0 do
            j_start = i - 6
            {j_start}
          else
            {j_start}
          end
          j = j_start
          while_fun_7 = fn while_fun_7, j, min_dis ->
            if j < i do
              current = euclidean_distance_sqr(Enum.at(points, i), Enum.at(points, j))
              {min_dis} = if current < min_dis do
                min_dis = current
                {min_dis}
              else
                {min_dis}
              end
              j = j + 1
              while_fun_7.(while_fun_7, j, min_dis)
            else
              {j, min_dis}
            end
          end
          {j, min_dis} = try do
              while_fun_7.(while_fun_7, j, min_dis)
            catch
              {:break, {j, min_dis}} -> {j, min_dis}
            end

          i = i + 1
          while_fun_6.(while_fun_6, i, min_dis)
        else
          {i, min_dis}
        end
      end
      {i, min_dis} = try do
          while_fun_6.(while_fun_6, i, min_dis)
        catch
          {:break, {i, min_dis}} -> {i, min_dis}
        end

      throw {:return, min_dis}
    catch
      {:return, val} -> val
    end
  end
  def closest_pair_of_points_sqr(px, py, count) do
    try do
      if count <= 3 do
        throw {:return, dis_between_closest_pair(px, count, 1000000000000000000.0)}
      end
      mid = div(count, 2)
      left = closest_pair_of_points_sqr(px, _slice(py, 0, mid - 0), mid)
      right = closest_pair_of_points_sqr(py, _slice(py, mid, count - mid), count - mid)
      best = left
      {best} = if right < best do
        best = right
        {best}
      else
        {best}
      end
      strip = []
      i = 0
      while_fun_8 = fn while_fun_8, i, strip ->
        if i < _len(px) do
          {strip} = if abs_(Enum.at(Enum.at(px, i), 0) - Enum.at(Enum.at(px, mid), 0)) < best do
            strip = (strip ++ [Enum.at(px, i)])
            {strip}
          else
            {strip}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i, strip)
        else
          {i, strip}
        end
      end
      {i, strip} = try do
          while_fun_8.(while_fun_8, i, strip)
        catch
          {:break, {i, strip}} -> {i, strip}
        end

      strip_best = dis_between_closest_in_strip(strip, _len(strip), best)
      {best} = if strip_best < best do
        best = strip_best
        {best}
      else
        {best}
      end
      throw {:return, best}
    catch
      {:return, val} -> val
    end
  end
  def closest_pair_of_points(points, count) do
    try do
      points_sorted_on_x = column_based_sort(points, 0)
      points_sorted_on_y = column_based_sort(points, 1)
      dist_sqr = closest_pair_of_points_sqr(points_sorted_on_x, points_sorted_on_y, count)
      throw {:return, sqrtApprox(dist_sqr)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:points, [[2.0, 3.0], [12.0, 30.0], [40.0, 50.0], [5.0, 1.0], [12.0, 10.0], [3.0, 4.0]])
  def main() do
    IO.puts(("Distance: " <> Kernel.inspect(closest_pair_of_points(Process.get(:points), _len(Process.get(:points))))))
  end
end
Main.main()
