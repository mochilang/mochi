# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def min_slice(a, start, end_) do
    try do
      m = Enum.at(a, start)
      i = start + 1
      while_fun = fn while_fun, i, m ->
        if i < end_ do
          {m} = if Enum.at(a, i) < m do
            m = Enum.at(a, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun.(while_fun, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun.(while_fun, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def max_slice(a, start, end_) do
    try do
      m = Enum.at(a, start)
      i = start + 1
      while_fun_2 = fn while_fun_2, i, m ->
        if i < end_ do
          {m} = if Enum.at(a, i) > m do
            m = Enum.at(a, i)
            {m}
          else
            {m}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_2.(while_fun_2, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def max_diff_range(a, start, end_) do
    try do
      if end_ - start == 1 do
        v = Enum.at(a, start)
        throw {:return, [v, v]}
      end
      mid = div((start + end_), 2)
      left = max_diff_range(a, start, mid)
      right = max_diff_range(a, mid, end_)
      small1 = Enum.at(left, 0)
      big1 = Enum.at(left, 1)
      small2 = Enum.at(right, 0)
      big2 = Enum.at(right, 1)
      min_left = min_slice(a, start, mid)
      max_right = max_slice(a, mid, end_)
      cross_diff = max_right - min_left
      left_diff = big1 - small1
      right_diff = big2 - small2
      if right_diff > cross_diff && right_diff > left_diff do
        throw {:return, [small2, big2]}
      else
        if left_diff > cross_diff do
          throw {:return, [small1, big1]}
        else
          throw {:return, [min_left, max_right]}
        end
      end
    catch
      {:return, val} -> val
    end
  end
  def max_difference(a) do
    try do
      throw {:return, max_diff_range(a, 0, _len(a))}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      result = max_difference([5, 11, 2, 1, 7, 9, 0, 7])
      IO.puts(String.replace(IO.iodata_to_binary(:io_lib.format("~w", [result])), ",", " "))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
