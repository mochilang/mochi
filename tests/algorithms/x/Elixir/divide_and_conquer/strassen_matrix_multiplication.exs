# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def default_matrix_multiplication(a, b) do
    try do
      throw {:return, [[Enum.at(Enum.at(a, 0), 0) * Enum.at(Enum.at(b, 0), 0) + Enum.at(Enum.at(a, 0), 1) * Enum.at(Enum.at(b, 1), 0), Enum.at(Enum.at(a, 0), 0) * Enum.at(Enum.at(b, 0), 1) + Enum.at(Enum.at(a, 0), 1) * Enum.at(Enum.at(b, 1), 1)], [Enum.at(Enum.at(a, 1), 0) * Enum.at(Enum.at(b, 0), 0) + Enum.at(Enum.at(a, 1), 1) * Enum.at(Enum.at(b, 1), 0), Enum.at(Enum.at(a, 1), 0) * Enum.at(Enum.at(b, 0), 1) + Enum.at(Enum.at(a, 1), 1) * Enum.at(Enum.at(b, 1), 1)]]}
    catch
      {:return, val} -> val
    end
  end
  def matrix_addition(matrix_a, matrix_b) do
    try do
      result = []
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < _len(matrix_a) do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < _len(Enum.at(matrix_a, i)) do
              row = (row ++ [Enum.at(Enum.at(matrix_a, i), j) + Enum.at(Enum.at(matrix_b, i), j)])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def matrix_subtraction(matrix_a, matrix_b) do
    try do
      result = []
      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(matrix_a) do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j < _len(Enum.at(matrix_a, i)) do
              row = (row ++ [Enum.at(Enum.at(matrix_a, i), j) - Enum.at(Enum.at(matrix_b, i), j)])
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def split_matrix(a) do
    try do
      n = _len(a)
      mid = div(n, 2)
      top_left = []
      top_right = []
      bot_left = []
      bot_right = []
      i = 0
      while_fun_5 = fn while_fun_5, i, top_left, top_right ->
        if i < mid do
          left_row = []
          right_row = []
          j = 0
          while_fun_6 = fn while_fun_6, j, left_row, right_row ->
            if j < mid do
              left_row = (left_row ++ [Enum.at(Enum.at(a, i), j)])
              right_row = (right_row ++ [Enum.at(Enum.at(a, i), j + mid)])
              j = j + 1
              while_fun_6.(while_fun_6, j, left_row, right_row)
            else
              {j, left_row, right_row}
            end
          end
          {j, left_row, right_row} = try do
              while_fun_6.(while_fun_6, j, left_row, right_row)
            catch
              {:break, {j, left_row, right_row}} -> {j, left_row, right_row}
            end

          top_left = (top_left ++ [left_row])
          top_right = (top_right ++ [right_row])
          i = i + 1
          while_fun_5.(while_fun_5, i, top_left, top_right)
        else
          {i, top_left, top_right}
        end
      end
      {i, top_left, top_right} = try do
          while_fun_5.(while_fun_5, i, top_left, top_right)
        catch
          {:break, {i, top_left, top_right}} -> {i, top_left, top_right}
        end

      i = mid
      while_fun_7 = fn while_fun_7, bot_left, bot_right, i ->
        if i < n do
          left_row = []
          right_row = []
          j = 0
          while_fun_8 = fn while_fun_8, j, left_row, right_row ->
            if j < mid do
              left_row = (left_row ++ [Enum.at(Enum.at(a, i), j)])
              right_row = (right_row ++ [Enum.at(Enum.at(a, i), j + mid)])
              j = j + 1
              while_fun_8.(while_fun_8, j, left_row, right_row)
            else
              {j, left_row, right_row}
            end
          end
          {j, left_row, right_row} = try do
              while_fun_8.(while_fun_8, j, left_row, right_row)
            catch
              {:break, {j, left_row, right_row}} -> {j, left_row, right_row}
            end

          bot_left = (bot_left ++ [left_row])
          bot_right = (bot_right ++ [right_row])
          i = i + 1
          while_fun_7.(while_fun_7, bot_left, bot_right, i)
        else
          {bot_left, bot_right, i}
        end
      end
      {bot_left, bot_right, i} = try do
          while_fun_7.(while_fun_7, bot_left, bot_right, i)
        catch
          {:break, {bot_left, bot_right, i}} -> {bot_left, bot_right, i}
        end

      throw {:return, [top_left, top_right, bot_left, bot_right]}
    catch
      {:return, val} -> val
    end
  end
  def matrix_dimensions(matrix) do
    try do
      throw {:return, [_len(matrix), _len(Enum.at(matrix, 0))]}
    catch
      {:return, val} -> val
    end
  end
  def next_power_of_two(n) do
    try do
      p = 1
      while_fun_9 = fn while_fun_9, p ->
        if p < n do
          p = p * 2
          while_fun_9.(while_fun_9, p)
        else
          p
        end
      end
      p = try do
          while_fun_9.(while_fun_9, p)
        catch
          {:break, {p}} -> p
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def pad_matrix(mat, rows, cols) do
    try do
      res = []
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < rows do
          row = []
          j = 0
          while_fun_11 = fn while_fun_11, j, row ->
            if j < cols do
              v = 0
              {v} = if i < _len(mat) && j < _len(Enum.at(mat, 0)) do
                v = Enum.at(Enum.at(mat, i), j)
                {v}
              else
                {v}
              end
              row = (row ++ [v])
              j = j + 1
              while_fun_11.(while_fun_11, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_11.(while_fun_11, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def actual_strassen(matrix_a, matrix_b) do
    try do
      if Enum.at(matrix_dimensions(matrix_a), 0) == 2 do
        throw {:return, default_matrix_multiplication(matrix_a, matrix_b)}
      end
      parts_a = split_matrix(matrix_a)
      a = Enum.at(parts_a, 0)
      b = Enum.at(parts_a, 1)
      c = Enum.at(parts_a, 2)
      d = Enum.at(parts_a, 3)
      parts_b = split_matrix(matrix_b)
      e = Enum.at(parts_b, 0)
      f = Enum.at(parts_b, 1)
      g = Enum.at(parts_b, 2)
      h = Enum.at(parts_b, 3)
      t1 = actual_strassen(a, matrix_subtraction(f, h))
      t2 = actual_strassen(matrix_addition(a, b), h)
      t3 = actual_strassen(matrix_addition(c, d), e)
      t4 = actual_strassen(d, matrix_subtraction(g, e))
      t5 = actual_strassen(matrix_addition(a, d), matrix_addition(e, h))
      t6 = actual_strassen(matrix_subtraction(b, d), matrix_addition(g, h))
      t7 = actual_strassen(matrix_subtraction(a, c), matrix_addition(e, f))
      top_left = matrix_addition(matrix_subtraction(matrix_addition(t5, t4), t2), t6)
      top_right = matrix_addition(t1, t2)
      bot_left = matrix_addition(t3, t4)
      bot_right = matrix_subtraction(matrix_subtraction(matrix_addition(t1, t5), t3), t7)
      new_matrix = []
      i = 0
      while_fun_12 = fn while_fun_12, i, new_matrix ->
        if i < _len(top_right) do
          new_matrix = (new_matrix ++ [(Enum.at(top_left, i) ++ Enum.at(top_right, i))])
          i = i + 1
          while_fun_12.(while_fun_12, i, new_matrix)
        else
          {i, new_matrix}
        end
      end
      {i, new_matrix} = try do
          while_fun_12.(while_fun_12, i, new_matrix)
        catch
          {:break, {i, new_matrix}} -> {i, new_matrix}
        end

      i = 0
      while_fun_13 = fn while_fun_13, i, new_matrix ->
        if i < _len(bot_right) do
          new_matrix = (new_matrix ++ [(Enum.at(bot_left, i) ++ Enum.at(bot_right, i))])
          i = i + 1
          while_fun_13.(while_fun_13, i, new_matrix)
        else
          {i, new_matrix}
        end
      end
      {i, new_matrix} = try do
          while_fun_13.(while_fun_13, i, new_matrix)
        catch
          {:break, {i, new_matrix}} -> {i, new_matrix}
        end

      throw {:return, new_matrix}
    catch
      {:return, val} -> val
    end
  end
  def strassen(matrix1, matrix2) do
    try do
      dims1 = matrix_dimensions(matrix1)
      dims2 = matrix_dimensions(matrix2)
      if Enum.at(dims1, 1) != Enum.at(dims2, 0) do
        throw {:return, []}
      end
      maximum = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.max([Enum.at(dims1, 0), Enum.at(dims1, 1), Enum.at(dims2, 0), Enum.at(dims2, 1)]))
      size = next_power_of_two(maximum)
      new_matrix1 = pad_matrix(matrix1, size, size)
      new_matrix2 = pad_matrix(matrix2, size, size)
      result_padded = actual_strassen(new_matrix1, new_matrix2)
      final_matrix = []
      i = 0
      while_fun_14 = fn while_fun_14, final_matrix, i ->
        if i < Enum.at(dims1, 0) do
          row = []
          j = 0
          while_fun_15 = fn while_fun_15, j, row ->
            if j < Enum.at(dims2, 1) do
              row = (row ++ [Enum.at(Enum.at(result_padded, i), j)])
              j = j + 1
              while_fun_15.(while_fun_15, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_15.(while_fun_15, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          final_matrix = (final_matrix ++ [row])
          i = i + 1
          while_fun_14.(while_fun_14, final_matrix, i)
        else
          {final_matrix, i}
        end
      end
      {final_matrix, i} = try do
          while_fun_14.(while_fun_14, final_matrix, i)
        catch
          {:break, {final_matrix, i}} -> {final_matrix, i}
        end

      throw {:return, final_matrix}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      matrix1 = [[2, 3, 4, 5], [6, 4, 3, 1], [2, 3, 6, 7], [3, 1, 2, 4], [2, 3, 4, 5], [6, 4, 3, 1], [2, 3, 6, 7], [3, 1, 2, 4], [2, 3, 4, 5], [6, 2, 3, 1]]
      matrix2 = [[0, 2, 1, 1], [16, 2, 3, 3], [2, 2, 7, 7], [13, 11, 22, 4]]
      res = strassen(matrix1, matrix2)
      IO.puts(Kernel.inspect(res))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
