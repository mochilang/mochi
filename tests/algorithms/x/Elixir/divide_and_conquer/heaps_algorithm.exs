# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def permute(k, arr, res) do
    try do
      if k == 1 do
        copy = _slice(arr, 0, _len(arr) - 0)
        throw {:return, (res ++ [copy])}
      end
      res = permute(k - 1, arr, res)
      i = 0
      while_fun = fn while_fun, arr, i, res ->
        if i < k - 1 do
          {arr} = if rem(k, 2) == 0 do
            temp = Enum.at(arr, i)
            arr = List.replace_at(arr, i, Enum.at(arr, k - 1))
            arr = List.replace_at(arr, k - 1, temp)
            {arr}
          else
            temp = Enum.at(arr, 0)
            arr = List.replace_at(arr, 0, Enum.at(arr, k - 1))
            arr = List.replace_at(arr, k - 1, temp)
            {arr}
          end
          res = permute(k - 1, arr, res)
          i = i + 1
          while_fun.(while_fun, arr, i, res)
        else
          {arr, i, res}
        end
      end
      {arr, i, res} = try do
          while_fun.(while_fun, arr, i, res)
        catch
          {:break, {arr, i, res}} -> {arr, i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def heaps(arr) do
    try do
      if _len(arr) <= 1 do
        throw {:return, [_slice(arr, 0, _len(arr) - 0)]}
      end
      res = []
      res = permute(_len(arr), arr, res)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      perms = heaps([1, 2, 3])
      IO.puts(Kernel.inspect(perms))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
