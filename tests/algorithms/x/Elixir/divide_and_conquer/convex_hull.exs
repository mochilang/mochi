# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def cross(o, a, b) do
    try do
      throw {:return, (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)}
    catch
      {:return, val} -> val
    end
  end
  def sortPoints(ps) do
    try do
      arr = ps
      n = _len(arr)
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < n do
          j = 0
          while_fun_2 = fn while_fun_2, arr, j ->
            if j < n - 1 do
              p = Enum.at(arr, j)
              q = Enum.at(arr, j + 1)
              {arr} = if p.x > q.x || (p.x == q.x && p.y > q.y) do
                arr = List.replace_at(arr, j, q)
                arr = List.replace_at(arr, j + 1, p)
                {arr}
              else
                {arr}
              end
              j = j + 1
              while_fun_2.(while_fun_2, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_2.(while_fun_2, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def convex_hull(ps) do
    try do
      ps = sortPoints(ps)
      lower = []
      {lower} = Enum.reduce(ps, {lower}, fn p, {lower} ->
        while_fun_3 = fn while_fun_3, lower ->
          if _len(lower) >= 2 && cross(Enum.at(lower, _len(lower) - 2), Enum.at(lower, _len(lower) - 1), p) <= 0 do
            lower = _slice(lower, 0, (_len(lower) - 1) - 0)
            while_fun_3.(while_fun_3, lower)
          else
            lower
          end
        end
        lower = try do
            while_fun_3.(while_fun_3, lower)
          catch
            {:break, {lower}} -> lower
          end

        lower = (lower ++ [p])
        {lower}
      end)
      upper = []
      i = _len(ps) - 1
      while_fun_4 = fn while_fun_4, i, upper ->
        if i >= 0 do
          p = Enum.at(ps, i)
          while_fun_5 = fn while_fun_5, upper ->
            if _len(upper) >= 2 && cross(Enum.at(upper, _len(upper) - 2), Enum.at(upper, _len(upper) - 1), p) <= 0 do
              upper = _slice(upper, 0, (_len(upper) - 1) - 0)
              while_fun_5.(while_fun_5, upper)
            else
              upper
            end
          end
          upper = try do
              while_fun_5.(while_fun_5, upper)
            catch
              {:break, {upper}} -> upper
            end

          upper = (upper ++ [p])
          i = i - 1
          while_fun_4.(while_fun_4, i, upper)
        else
          {i, upper}
        end
      end
      {i, upper} = try do
          while_fun_4.(while_fun_4, i, upper)
        catch
          {:break, {i, upper}} -> {i, upper}
        end

      hull = _slice(lower, 0, (_len(lower) - 1) - 0)
      j = 0
      while_fun_6 = fn while_fun_6, hull, j ->
        if j < _len(upper) - 1 do
          hull = (hull ++ [Enum.at(upper, j)])
          j = j + 1
          while_fun_6.(while_fun_6, hull, j)
        else
          {hull, j}
        end
      end
      {hull, j} = try do
          while_fun_6.(while_fun_6, hull, j)
        catch
          {:break, {hull, j}} -> {hull, j}
        end

      throw {:return, hull}
    catch
      {:return, val} -> val
    end
  end
  def main() do
  end
end
Main.main()
