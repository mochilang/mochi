# Code generated by Mochi transpiler 2025-08-11 15:06 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def binary_search(arr, lower_bound, upper_bound, value) do
    try do
      r = div((lower_bound + upper_bound), 2)
      if Enum.at(arr, r, 0) == value do
        throw {:return, r}
      end
      if lower_bound >= upper_bound do
        throw {:return, -1}
      end
      if Enum.at(arr, r, 0) < value do
        throw {:return, binary_search(arr, r + 1, upper_bound, value)}
      end
      throw {:return, binary_search(arr, lower_bound, r - 1, value)}
    catch
      {:return, val} -> val
    end
  end
  def mat_bin_search(value, matrix) do
    try do
      index = 0
      if Enum.at(Enum.at(matrix, index, []), 0, 0) == value do
        throw {:return, [index, 0]}
      end
      while_fun = fn while_fun, index ->
        if index < _len(matrix) && Enum.at(Enum.at(matrix, index, []), 0, 0) < value do
          r = binary_search(Enum.at(matrix, index, []), 0, _len(Enum.at(matrix, index, [])) - 1, value)
          if r != (-1) do
            throw {:return, [index, r]}
          end
          index = index + 1
          while_fun.(while_fun, index)
        else
          index
        end
      end
      index = try do
          while_fun.(while_fun, index)
        catch
          {:break, {index}} -> index
        end

      throw {:return, [-1, -1]}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      row = [1, 4, 7, 11, 15]
      IO.puts(Kernel.inspect(binary_search(row, 0, _len(row) - 1, 1)))
      IO.puts(Kernel.inspect(binary_search(row, 0, _len(row) - 1, 23)))
      matrix = [[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]
      IO.puts(Kernel.inspect(mat_bin_search(1, matrix)))
      IO.puts(Kernel.inspect(mat_bin_search(34, matrix)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
