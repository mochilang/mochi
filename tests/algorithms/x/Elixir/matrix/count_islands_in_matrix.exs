# Code generated by Mochi transpiler 2025-08-25 22:27 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def is_safe(grid, visited, row, col) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0, []))
      within_bounds = row >= 0 && row < rows && col >= 0 && col < cols
      if !within_bounds do
        throw {:return, false}
      end
      visited_cell = Enum.at(Enum.at(visited, row, []), col, 0)
      not_visited = visited_cell == false
      throw {:return, not_visited && Enum.at(Enum.at(grid, row, []), col, 0) == 1}
    catch
      {:return, val} -> val
    end
  end
  def dfs(grid, visited, row, col) do
    try do
      row_nbr = [-1, -1, -1, 0, 0, 1, 1, 1]
      col_nbr = [-1, 0, 1, -1, 1, -1, 0, 1]
      visited = List.replace_at(visited, row, List.replace_at(Enum.at(visited, row), col, true))
      k = 0
      while_fun = fn while_fun, k ->
        if k < 8 do
          new_row = row + Enum.at(row_nbr, k, [])
          new_col = col + Enum.at(col_nbr, k, [])
          if is_safe(grid, visited, new_row, new_col) do
            grid = dfs(grid, visited, new_row, new_col)
          end
          k = k + 1
          while_fun.(while_fun, k)
        else
          k
        end
      end
      _ = try do
          while_fun.(while_fun, k)
        catch
          {:break, {_}} -> 0
        end

    catch
      {:return, val} -> val
    end
  end
  def count_islands(grid) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0, []))
      visited = []
      i = 0
      while_fun_2 = fn while_fun_2, i, visited ->
        if i < rows do
          row_list = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row_list ->
            if j < cols do
              row_list = (row_list ++ [false])
              j = j + 1
              while_fun_3.(while_fun_3, j, row_list)
            else
              {j, row_list}
            end
          end
          {_, row_list} = try do
              while_fun_3.(while_fun_3, j, row_list)
            catch
              {:break, {_, row_list}} -> {0, row_list}
            end

          visited = (visited ++ [row_list])
          i = i + 1
          while_fun_2.(while_fun_2, i, visited)
        else
          {i, visited}
        end
      end
      {_, visited} = try do
          while_fun_2.(while_fun_2, i, visited)
        catch
          {:break, {_, visited}} -> {0, visited}
        end

      count = 0
      i = 0
      while_fun_4 = fn while_fun_4, count, i ->
        if i < rows do
          j = 0
          while_fun_5 = fn while_fun_5, count, j ->
            if j < cols do
              count = if !Enum.at(Enum.at(visited, i, []), j, 0) && Enum.at(Enum.at(grid, i, []), j, 0) == 1 do
                grid = dfs(grid, visited, i, j)
                count = count + 1
                count
              else
                count
              end
              j = j + 1
              while_fun_5.(while_fun_5, count, j)
            else
              {count, j}
            end
          end
          {count, _} = try do
              while_fun_5.(while_fun_5, count, j)
            catch
              {:break, {count, _}} -> {count, 0}
            end

          i = i + 1
          while_fun_4.(while_fun_4, count, i)
        else
          {count, i}
        end
      end
      {count, _} = try do
          while_fun_4.(while_fun_4, count, i)
        catch
          {:break, {count, _}} -> {count, 0}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:grid, [[1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(count_islands(Process.get(:grid))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
