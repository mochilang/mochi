# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def is_safe(grid, visited, row, col) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0))
      visited_cell = Enum.at(Enum.at(visited, row), col)
      within_bounds = row >= 0 && row < rows && col >= 0 && col < cols
      not_visited = visited_cell == false
      throw {:return, within_bounds && not_visited && Enum.at(Enum.at(grid, row), col) == 1}
    catch
      {:return, val} -> val
    end
  end
  def dfs(grid, visited, row, col) do
    try do
      row_nbr = [-1, -1, -1, 0, 0, 1, 1, 1]
      col_nbr = [-1, 0, 1, -1, 1, -1, 0, 1]
      visited = List.replace_at(visited, row, List.replace_at(Enum.at(visited, row), col, true))
      k = 0
      while_fun = fn while_fun, k ->
        if k < 8 do
          new_row = row + Enum.at(row_nbr, k)
          new_col = col + Enum.at(col_nbr, k)
          if is_safe(grid, visited, new_row, new_col) do
            dfs(grid, visited, new_row, new_col)
          end
          k = k + 1
          while_fun.(while_fun, k)
        else
          k
        end
      end
      k = try do
          while_fun.(while_fun, k)
        catch
          {:break, {k}} -> k
        end

    catch
      {:return, val} -> val
    end
  end
  def count_islands(grid) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0))
      visited = []
      i = 0
      while_fun_2 = fn while_fun_2, i, visited ->
        if i < rows do
          row_list = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row_list ->
            if j < cols do
              row_list = (row_list ++ [false])
              j = j + 1
              while_fun_3.(while_fun_3, j, row_list)
            else
              {j, row_list}
            end
          end
          {j, row_list} = try do
              while_fun_3.(while_fun_3, j, row_list)
            catch
              {:break, {j, row_list}} -> {j, row_list}
            end

          visited = (visited ++ [row_list])
          i = i + 1
          while_fun_2.(while_fun_2, i, visited)
        else
          {i, visited}
        end
      end
      {i, visited} = try do
          while_fun_2.(while_fun_2, i, visited)
        catch
          {:break, {i, visited}} -> {i, visited}
        end

      count = 0
      i = 0
      while_fun_4 = fn while_fun_4, count, i ->
        if i < rows do
          j = 0
          while_fun_5 = fn while_fun_5, count, j ->
            if j < cols do
              {count} = if !Enum.at(Enum.at(visited, i), j) && Enum.at(Enum.at(grid, i), j) == 1 do
                dfs(grid, visited, i, j)
                count = count + 1
                {count}
              else
                {count}
              end
              j = j + 1
              while_fun_5.(while_fun_5, count, j)
            else
              {count, j}
            end
          end
          {count, j} = try do
              while_fun_5.(while_fun_5, count, j)
            catch
              {:break, {count, j}} -> {count, j}
            end

          i = i + 1
          while_fun_4.(while_fun_4, count, i)
        else
          {count, i}
        end
      end
      {count, i} = try do
          while_fun_4.(while_fun_4, count, i)
        catch
          {:break, {count, i}} -> {count, i}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:grid, [[1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1]])
  def main() do
    IO.puts(Kernel.inspect(count_islands(Process.get(:grid))))
  end
end
Main.main()
