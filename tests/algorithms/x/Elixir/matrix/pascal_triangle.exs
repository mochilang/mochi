# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  def populate_current_row(triangle, current_row_idx) do
    try do
      row = []
      i = 0
      while_fun = fn while_fun, i, row ->
        if i <= current_row_idx do
          {row} = if i == 0 || i == current_row_idx do
            row = (row ++ [1])
            {row}
          else
            left = Enum.at(Enum.at(triangle, current_row_idx - 1), i - 1)
            right = Enum.at(Enum.at(triangle, current_row_idx - 1), i)
            row = (row ++ [left + right])
            {row}
          end
          i = i + 1
          while_fun.(while_fun, i, row)
        else
          {i, row}
        end
      end
      {i, row} = try do
          while_fun.(while_fun, i, row)
        catch
          {:break, {i, row}} -> {i, row}
        end

      throw {:return, row}
    catch
      {:return, val} -> val
    end
  end
  def generate_pascal_triangle(num_rows) do
    try do
      if num_rows <= 0 do
        throw {:return, []}
      end
      triangle = []
      row_idx = 0
      while_fun_2 = fn while_fun_2, row_idx, triangle ->
        if row_idx < num_rows do
          row = populate_current_row(triangle, row_idx)
          triangle = (triangle ++ [row])
          row_idx = row_idx + 1
          while_fun_2.(while_fun_2, row_idx, triangle)
        else
          {row_idx, triangle}
        end
      end
      {row_idx, triangle} = try do
          while_fun_2.(while_fun_2, row_idx, triangle)
        catch
          {:break, {row_idx, triangle}} -> {row_idx, triangle}
        end

      throw {:return, triangle}
    catch
      {:return, val} -> val
    end
  end
  def row_to_string(row, total_rows, row_idx) do
    try do
      line = ""
      spaces = total_rows - row_idx - 1
      s = 0
      while_fun_3 = fn while_fun_3, line, s ->
        if s < spaces do
          line = (line <> " ")
          s = s + 1
          while_fun_3.(while_fun_3, line, s)
        else
          {line, s}
        end
      end
      {line, s} = try do
          while_fun_3.(while_fun_3, line, s)
        catch
          {:break, {line, s}} -> {line, s}
        end

      c = 0
      while_fun_4 = fn while_fun_4, c, line ->
        if c <= row_idx do
          line = (line <> Kernel.to_string(Enum.at(row, c)))
          {line} = if c != row_idx do
            line = (line <> " ")
            {line}
          else
            {line}
          end
          c = c + 1
          while_fun_4.(while_fun_4, c, line)
        else
          {c, line}
        end
      end
      {c, line} = try do
          while_fun_4.(while_fun_4, c, line)
        catch
          {:break, {c, line}} -> {c, line}
        end

      throw {:return, line}
    catch
      {:return, val} -> val
    end
  end
  def print_pascal_triangle(num_rows) do
    try do
      triangle = generate_pascal_triangle(num_rows)
      r = 0
      while_fun_5 = fn while_fun_5, r ->
        if r < num_rows do
          line = row_to_string(Enum.at(triangle, r), num_rows, r)
          IO.puts(line)
          r = r + 1
          while_fun_5.(while_fun_5, r)
        else
          r
        end
      end
      r = try do
          while_fun_5.(while_fun_5, r)
        catch
          {:break, {r}} -> r
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      print_pascal_triangle(5)
      IO.puts(Kernel.inspect(generate_pascal_triangle(5)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
