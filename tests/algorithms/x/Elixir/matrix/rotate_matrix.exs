# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_int(n) do
    try do
      throw {:return, ((if n < 0, do: -n, else: n))}
    catch
      {:return, val} -> val
    end
  end
  def make_matrix(row_size) do
    try do
      size = abs_int(row_size)
      {size} = if size == 0 do
        size = 4
        {size}
      else
        {size}
      end
      mat = []
      y = 0
      while_fun = fn while_fun, y ->
        if y < size do
          row = []
          x = 0
          while_fun_2 = fn while_fun_2, row, x ->
            if x < size do
              row = (row ++ [1 + x + y * size])
              x = x + 1
              while_fun_2.(while_fun_2, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_2.(while_fun_2, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          mat = (mat ++ [row])
          y = y + 1
          while_fun.(while_fun, y)
        else
          y
        end
      end
      y = try do
          while_fun.(while_fun, y)
        catch
          {:break, {y}} -> y
        end

      throw {:return, mat}
    catch
      {:return, val} -> val
    end
  end
  def transpose(mat) do
    try do
      n = _len(mat)
      result = []
      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < n do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j < n do
              row = (row ++ [Enum.at(Enum.at(mat, j), i)])
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def reverse_row(mat) do
    try do
      result = []
      i = _len(mat) - 1
      while_fun_5 = fn while_fun_5, i, result ->
        if i >= 0 do
          result = (result ++ [Enum.at(mat, i)])
          i = i - 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def reverse_column(mat) do
    try do
      result = []
      i = 0
      while_fun_6 = fn while_fun_6, i, result ->
        if i < _len(mat) do
          row = []
          j = _len(Enum.at(mat, i)) - 1
          while_fun_7 = fn while_fun_7, j, row ->
            if j >= 0 do
              row = (row ++ [Enum.at(Enum.at(mat, i), j)])
              j = j - 1
              while_fun_7.(while_fun_7, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_7.(while_fun_7, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_6.(while_fun_6, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_6.(while_fun_6, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def rotate_90(mat) do
    try do
      t = transpose(mat)
      rr = reverse_row(t)
      throw {:return, rr}
    catch
      {:return, val} -> val
    end
  end
  def rotate_180(mat) do
    try do
      rc = reverse_column(mat)
      rr = reverse_row(rc)
      throw {:return, rr}
    catch
      {:return, val} -> val
    end
  end
  def rotate_270(mat) do
    try do
      t = transpose(mat)
      rc = reverse_column(t)
      throw {:return, rc}
    catch
      {:return, val} -> val
    end
  end
  def row_to_string(row) do
    try do
      line = ""
      i = 0
      while_fun_8 = fn while_fun_8, i, line ->
        if i < _len(row) do
          line = (if i == 0, do: Kernel.to_string(Enum.at(row, i)), else: ((line <> " ") <> Kernel.to_string(Enum.at(row, i))))
          i = i + 1
          while_fun_8.(while_fun_8, i, line)
        else
          {i, line}
        end
      end
      {i, line} = try do
          while_fun_8.(while_fun_8, i, line)
        catch
          {:break, {i, line}} -> {i, line}
        end

      throw {:return, line}
    catch
      {:return, val} -> val
    end
  end
  def print_matrix(mat) do
    try do
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < _len(mat) do
          IO.puts(Kernel.inspect(row_to_string(Enum.at(mat, i))))
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:mat, make_matrix(4))
    IO.puts("\norigin:\n")
    print_matrix(Process.get(:mat))
    IO.puts("\nrotate 90 counterclockwise:\n")
    Process.put(:r90, rotate_90(Process.get(:mat)))
    print_matrix(Process.get(:r90))
    Process.put(:mat, make_matrix(4))
    IO.puts("\norigin:\n")
    print_matrix(Process.get(:mat))
    IO.puts("\nrotate 180:\n")
    Process.put(:r180, rotate_180(Process.get(:mat)))
    print_matrix(Process.get(:r180))
    Process.put(:mat, make_matrix(4))
    IO.puts("\norigin:\n")
    print_matrix(Process.get(:mat))
    IO.puts("\nrotate 270 counterclockwise:\n")
    Process.put(:r270, rotate_270(Process.get(:mat)))
    print_matrix(Process.get(:r270))
  end
end
Main.main()
