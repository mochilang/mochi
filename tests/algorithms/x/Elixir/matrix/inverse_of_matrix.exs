# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def inverse_of_matrix(matrix) do
    try do
      if _len(matrix) == 2 && _len(Enum.at(matrix, 0)) == 2 && _len(Enum.at(matrix, 1)) == 2 do
        det = Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 1), 1) - Enum.at(Enum.at(matrix, 1), 0) * Enum.at(Enum.at(matrix, 0), 1)
        if det == 0.0 do
          IO.puts("This matrix has no inverse.")
          throw {:return, []}
        end
        throw {:return, [[Enum.at(Enum.at(matrix, 1), 1) / det, -Enum.at(Enum.at(matrix, 0), 1) / det], [-Enum.at(Enum.at(matrix, 1), 0) / det, Enum.at(Enum.at(matrix, 0), 0) / det]]}
      else
        if _len(matrix) == 3 && _len(Enum.at(matrix, 0)) == 3 && _len(Enum.at(matrix, 1)) == 3 && _len(Enum.at(matrix, 2)) == 3 do
          det = Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 1), 1) * Enum.at(Enum.at(matrix, 2), 2) + Enum.at(Enum.at(matrix, 0), 1) * Enum.at(Enum.at(matrix, 1), 2) * Enum.at(Enum.at(matrix, 2), 0) + Enum.at(Enum.at(matrix, 0), 2) * Enum.at(Enum.at(matrix, 1), 0) * Enum.at(Enum.at(matrix, 2), 1) - (Enum.at(Enum.at(matrix, 0), 2) * Enum.at(Enum.at(matrix, 1), 1) * Enum.at(Enum.at(matrix, 2), 0) + Enum.at(Enum.at(matrix, 0), 1) * Enum.at(Enum.at(matrix, 1), 0) * Enum.at(Enum.at(matrix, 2), 2) + Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 1), 2) * Enum.at(Enum.at(matrix, 2), 1))
          if det == 0.0 do
            IO.puts("This matrix has no inverse.")
            throw {:return, []}
          end
          cof = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
          cof = List.replace_at(cof, 0, List.replace_at(Enum.at(cof, 0), 0, Enum.at(Enum.at(matrix, 1), 1) * Enum.at(Enum.at(matrix, 2), 2) - Enum.at(Enum.at(matrix, 1), 2) * Enum.at(Enum.at(matrix, 2), 1)))
          cof = List.replace_at(cof, 0, List.replace_at(Enum.at(cof, 0), 1, -(Enum.at(Enum.at(matrix, 1), 0) * Enum.at(Enum.at(matrix, 2), 2) - Enum.at(Enum.at(matrix, 1), 2) * Enum.at(Enum.at(matrix, 2), 0))))
          cof = List.replace_at(cof, 0, List.replace_at(Enum.at(cof, 0), 2, Enum.at(Enum.at(matrix, 1), 0) * Enum.at(Enum.at(matrix, 2), 1) - Enum.at(Enum.at(matrix, 1), 1) * Enum.at(Enum.at(matrix, 2), 0)))
          cof = List.replace_at(cof, 1, List.replace_at(Enum.at(cof, 1), 0, -(Enum.at(Enum.at(matrix, 0), 1) * Enum.at(Enum.at(matrix, 2), 2) - Enum.at(Enum.at(matrix, 0), 2) * Enum.at(Enum.at(matrix, 2), 1))))
          cof = List.replace_at(cof, 1, List.replace_at(Enum.at(cof, 1), 1, Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 2), 2) - Enum.at(Enum.at(matrix, 0), 2) * Enum.at(Enum.at(matrix, 2), 0)))
          cof = List.replace_at(cof, 1, List.replace_at(Enum.at(cof, 1), 2, -(Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 2), 1) - Enum.at(Enum.at(matrix, 0), 1) * Enum.at(Enum.at(matrix, 2), 0))))
          cof = List.replace_at(cof, 2, List.replace_at(Enum.at(cof, 2), 0, Enum.at(Enum.at(matrix, 0), 1) * Enum.at(Enum.at(matrix, 1), 2) - Enum.at(Enum.at(matrix, 0), 2) * Enum.at(Enum.at(matrix, 1), 1)))
          cof = List.replace_at(cof, 2, List.replace_at(Enum.at(cof, 2), 1, -(Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 1), 2) - Enum.at(Enum.at(matrix, 0), 2) * Enum.at(Enum.at(matrix, 1), 0))))
          cof = List.replace_at(cof, 2, List.replace_at(Enum.at(cof, 2), 2, Enum.at(Enum.at(matrix, 0), 0) * Enum.at(Enum.at(matrix, 1), 1) - Enum.at(Enum.at(matrix, 0), 1) * Enum.at(Enum.at(matrix, 1), 0)))
          inv = [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
          i = 0
          while_fun = fn while_fun, i, inv ->
            if i < 3 do
              j = 0
              while_fun_2 = fn while_fun_2, inv, j ->
                if j < 3 do
                  inv = List.replace_at(inv, i, List.replace_at(Enum.at(inv, i), j, Enum.at(Enum.at(cof, j), i) / det))
                  j = j + 1
                  while_fun_2.(while_fun_2, inv, j)
                else
                  {inv, j}
                end
              end
              {inv, j} = try do
                  while_fun_2.(while_fun_2, inv, j)
                catch
                  {:break, {inv, j}} -> {inv, j}
                end

              i = i + 1
              while_fun.(while_fun, i, inv)
            else
              {i, inv}
            end
          end
          {i, inv} = try do
              while_fun.(while_fun, i, inv)
            catch
              {:break, {i, inv}} -> {i, inv}
            end

          throw {:return, inv}
        end
      end
      IO.puts("Please provide a matrix of size 2x2 or 3x3.")
      throw {:return, []}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:m2, [[2.0, 5.0], [2.0, 0.0]])
  Process.put(:m3, [[2.0, 5.0, 7.0], [2.0, 0.0, 1.0], [1.0, 2.0, 3.0]])
  def main() do
    IO.puts(Kernel.inspect(inverse_of_matrix(Process.get(:m2))))
    IO.puts(Kernel.inspect(inverse_of_matrix(Process.get(:m3))))
  end
end
Main.main()
