# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_matrix(rows, cols, value) do
    try do
      arr = []
      r = 0
      while_fun = fn while_fun, arr, r ->
        if r < rows do
          row = []
          c = 0
          while_fun_2 = fn while_fun_2, c, row ->
            if c < cols do
              row = (row ++ [value])
              c = c + 1
              while_fun_2.(while_fun_2, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_2.(while_fun_2, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          arr = (arr ++ [row])
          r = r + 1
          while_fun.(while_fun, arr, r)
        else
          {arr, r}
        end
      end
      {arr, r} = try do
          while_fun.(while_fun, arr, r)
        catch
          {:break, {arr, r}} -> {arr, r}
        end

      throw {:return, %{data: arr, rows: rows, cols: cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_from_lists(vals) do
    try do
      r = _len(vals)
      c = (if r == 0, do: 0, else: _len(Enum.at(vals, 0)))
      throw {:return, %{data: vals, rows: r, cols: c}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_to_string(m) do
    try do
      s = ""
      i = 0
      while_fun_3 = fn while_fun_3, i, s ->
        if i < m.rows do
          s = (s <> "[")
          j = 0
          while_fun_4 = fn while_fun_4, j, s ->
            if j < m.cols do
              s = (s <> Kernel.to_string(Enum.at(Enum.at(m.data, i), j)))
              {s} = if j < m.cols - 1 do
                s = (s <> ", ")
                {s}
              else
                {s}
              end
              j = j + 1
              while_fun_4.(while_fun_4, j, s)
            else
              {j, s}
            end
          end
          {j, s} = try do
              while_fun_4.(while_fun_4, j, s)
            catch
              {:break, {j, s}} -> {j, s}
            end

          s = (s <> "]")
          {s} = if i < m.rows - 1 do
            s = (s <> "\n")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add(a, b) do
    try do
      if a.rows != b.rows || a.cols != b.cols do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_6 = fn while_fun_6, j, row ->
            if j < a.cols do
              row = (row ++ [Enum.at(Enum.at(a.data, i), j) + Enum.at(Enum.at(b.data, i), j)])
              j = j + 1
              while_fun_6.(while_fun_6, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_6.(while_fun_6, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{data: res, rows: a.rows, cols: a.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_sub(a, b) do
    try do
      if a.rows != b.rows || a.cols != b.cols do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      res = []
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_8 = fn while_fun_8, j, row ->
            if j < a.cols do
              row = (row ++ [Enum.at(Enum.at(a.data, i), j) - Enum.at(Enum.at(b.data, i), j)])
              j = j + 1
              while_fun_8.(while_fun_8, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_8.(while_fun_8, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{data: res, rows: a.rows, cols: a.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_scalar(m, k) do
    try do
      res = []
      i = 0
      while_fun_9 = fn while_fun_9, i, res ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_10 = fn while_fun_10, j, row ->
            if j < m.cols do
              row = (row ++ [Enum.at(Enum.at(m.data, i), j) * k])
              j = j + 1
              while_fun_10.(while_fun_10, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_10.(while_fun_10, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{data: res, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul(a, b) do
    try do
      if a.cols != b.rows do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      res = []
      i = 0
      while_fun_11 = fn while_fun_11, i, res ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_12 = fn while_fun_12, j, row ->
            if j < b.cols do
              sum = 0.0
              k = 0
              while_fun_13 = fn while_fun_13, k, sum ->
                if k < a.cols do
                  sum = sum + Enum.at(Enum.at(a.data, i), k) * Enum.at(Enum.at(b.data, k), j)
                  k = k + 1
                  while_fun_13.(while_fun_13, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_13.(while_fun_13, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [sum])
              j = j + 1
              while_fun_12.(while_fun_12, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_12.(while_fun_12, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_11.(while_fun_11, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_11.(while_fun_11, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{data: res, rows: a.rows, cols: b.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_transpose(m) do
    try do
      res = []
      c = 0
      while_fun_14 = fn while_fun_14, c, res ->
        if c < m.cols do
          row = []
          r = 0
          while_fun_15 = fn while_fun_15, r, row ->
            if r < m.rows do
              row = (row ++ [Enum.at(Enum.at(m.data, r), c)])
              r = r + 1
              while_fun_15.(while_fun_15, r, row)
            else
              {r, row}
            end
          end
          {r, row} = try do
              while_fun_15.(while_fun_15, r, row)
            catch
              {:break, {r, row}} -> {r, row}
            end

          res = (res ++ [row])
          c = c + 1
          while_fun_14.(while_fun_14, c, res)
        else
          {c, res}
        end
      end
      {c, res} = try do
          while_fun_14.(while_fun_14, c, res)
        catch
          {:break, {c, res}} -> {c, res}
        end

      throw {:return, %{data: res, rows: m.cols, cols: m.rows}}
    catch
      {:return, val} -> val
    end
  end
  def sherman_morrison(ainv, u, v) do
    try do
      vt = matrix_transpose(v)
      vu = matrix_mul(matrix_mul(vt, ainv), u)
      factor = Enum.at(Enum.at(vu.data, 0), 0) + 1.0
      if factor == 0.0 do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      term1 = matrix_mul(ainv, u)
      term2 = matrix_mul(vt, ainv)
      numerator = matrix_mul(term1, term2)
      scaled = matrix_mul_scalar(numerator, 1.0 / factor)
      throw {:return, matrix_sub(ainv, scaled)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      ainv = matrix_from_lists([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])
      u = matrix_from_lists([[1.0], [2.0], [-3.0]])
      v = matrix_from_lists([[4.0], [-2.0], [5.0]])
      result = sherman_morrison(ainv, u, v)
      IO.puts(Kernel.inspect(matrix_to_string(result)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
