# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def unique(nums) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(nums) do
          v = Enum.at(nums, i)
          found = false
          j = 0
          while_fun_2 = fn while_fun_2, found, j ->
            if j < _len(res) do
              {found} = if Enum.at(res, j) == v do
                found = true
                throw {:break, {found, j}}
                {found}
              else
                {found}
              end
              j = j + 1
              while_fun_2.(while_fun_2, found, j)
            else
              {found, j}
            end
          end
          {found, j} = try do
              while_fun_2.(while_fun_2, found, j)
            catch
              {:break, {found, j}} -> {found, j}
            end

          {res} = if !found do
            res = (res ++ [v])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def array_equalization(vector, step_size) do
    try do
      if step_size <= 0 do
        raise("Step size must be positive and non-zero.")
      end
      elems = unique(vector)
      min_updates = _len(vector)
      i = 0
      while_fun_3 = fn while_fun_3, i, min_updates ->
        if i < _len(elems) do
          target = Enum.at(elems, i)
          idx = 0
          updates = 0
          while_fun_4 = fn while_fun_4, idx, updates ->
            if idx < _len(vector) do
              {idx, updates} = if Enum.at(vector, idx) != target do
                updates = updates + 1
                idx = idx + step_size
                {idx, updates}
              else
                idx = idx + 1
                {idx, updates}
              end
              while_fun_4.(while_fun_4, idx, updates)
            else
              {idx, updates}
            end
          end
          {idx, updates} = try do
              while_fun_4.(while_fun_4, idx, updates)
            catch
              {:break, {idx, updates}} -> {idx, updates}
            end

          {min_updates} = if updates < min_updates do
            min_updates = updates
            {min_updates}
          else
            {min_updates}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, min_updates)
        else
          {i, min_updates}
        end
      end
      {i, min_updates} = try do
          while_fun_3.(while_fun_3, i, min_updates)
        catch
          {:break, {i, min_updates}} -> {i, min_updates}
        end

      throw {:return, min_updates}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4)))
    IO.puts(Kernel.inspect(array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2)))
    IO.puts(Kernel.inspect(array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5)))
    IO.puts(Kernel.inspect(array_equalization([22, 22, 22, 33, 33, 33], 2)))
    IO.puts(Kernel.inspect(array_equalization([1, 2, 3], 2147483647)))
  end
end
Main.main()
