# Code generated by Mochi transpiler 2025-08-12 13:41 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def depth_first_search(grid, row, col, visit) do
    try do
      row_length = _len(grid)
      col_length = _len(Enum.at(grid, 0, []))
      if row < 0 || col < 0 || row == row_length || col == col_length do
        throw {:return, 0}
      end
      if Enum.at(Enum.at(visit, row, []), col, 0) do
        throw {:return, 0}
      end
      if Enum.at(Enum.at(grid, row, []), col, 0) == 1 do
        throw {:return, 0}
      end
      if row == row_length - 1 && col == col_length - 1 do
        throw {:return, 1}
      end
      visit = List.replace_at(visit, row, List.replace_at(Enum.at(visit, row), col, true))
      count = 0
      count = count + depth_first_search(grid, row + 1, col, visit)
      count = count + depth_first_search(grid, row - 1, col, visit)
      count = count + depth_first_search(grid, row, col + 1, visit)
      count = count + depth_first_search(grid, row, col - 1, visit)
      visit = List.replace_at(visit, row, List.replace_at(Enum.at(visit, row), col, false))
      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def count_paths(grid) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0, []))
      visit = []
      i = 0
      while_fun = fn while_fun, i, visit ->
        if i < rows do
          row_visit = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row_visit ->
            if j < cols do
              row_visit = (row_visit ++ [false])
              j = j + 1
              while_fun_2.(while_fun_2, j, row_visit)
            else
              {j, row_visit}
            end
          end
          {j, row_visit} = try do
              while_fun_2.(while_fun_2, j, row_visit)
            catch
              {:break, {j, row_visit}} -> {j, row_visit}
            end

          visit = (visit ++ [row_visit])
          i = i + 1
          while_fun.(while_fun, i, visit)
        else
          {i, visit}
        end
      end
      {i, visit} = try do
          while_fun.(while_fun, i, visit)
        catch
          {:break, {i, visit}} -> {i, visit}
        end

      throw {:return, depth_first_search(grid, 0, 0, visit)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      grid1 = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]
      IO.puts(Kernel.inspect(count_paths(grid1)))
      grid2 = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]
      IO.puts(Kernel.inspect(count_paths(grid2)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
