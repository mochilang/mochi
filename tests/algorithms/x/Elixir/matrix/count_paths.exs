# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def depth_first_search(grid, row, col, visit) do
    try do
      row_length = _len(grid)
      col_length = _len(Enum.at(grid, 0))
      if row < 0 || col < 0 || row == row_length || col == col_length do
        throw {:return, 0}
      end
      if Enum.at(Enum.at(visit, row), col) do
        throw {:return, 0}
      end
      if Enum.at(Enum.at(grid, row), col) == 1 do
        throw {:return, 0}
      end
      if row == row_length - 1 && col == col_length - 1 do
        throw {:return, 1}
      end
      visit = List.replace_at(visit, row, List.replace_at(Enum.at(visit, row), col, true))
      count = 0
      count = count + depth_first_search(grid, row + 1, col, visit)
      count = count + depth_first_search(grid, row - 1, col, visit)
      count = count + depth_first_search(grid, row, col + 1, visit)
      count = count + depth_first_search(grid, row, col - 1, visit)
      visit = List.replace_at(visit, row, List.replace_at(Enum.at(visit, row), col, false))
      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def count_paths(grid) do
    try do
      rows = _len(grid)
      cols = _len(Enum.at(grid, 0))
      visit = []
      i = 0
      while_fun = fn while_fun, i, visit ->
        if i < rows do
          row_visit = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row_visit ->
            if j < cols do
              row_visit = (row_visit ++ [false])
              j = j + 1
              while_fun_2.(while_fun_2, j, row_visit)
            else
              {j, row_visit}
            end
          end
          {j, row_visit} = try do
              while_fun_2.(while_fun_2, j, row_visit)
            catch
              {:break, {j, row_visit}} -> {j, row_visit}
            end

          visit = (visit ++ [row_visit])
          i = i + 1
          while_fun.(while_fun, i, visit)
        else
          {i, visit}
        end
      end
      {i, visit} = try do
          while_fun.(while_fun, i, visit)
        catch
          {:break, {i, visit}} -> {i, visit}
        end

      throw {:return, depth_first_search(grid, 0, 0, visit)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      grid1 = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]
      IO.puts(Kernel.inspect(count_paths(grid1)))
      grid2 = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]
      IO.puts(Kernel.inspect(count_paths(grid2)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
