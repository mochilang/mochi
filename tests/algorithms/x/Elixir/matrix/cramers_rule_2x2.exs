# Code generated by Mochi transpiler 2025-08-12 09:13 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def cramers_rule_2x2(eq1, eq2) do
    try do
      if _len(eq1) != 3 || _len(eq2) != 3 do
        raise("Please enter a valid equation.")
      end
      if Enum.at(eq1, 0, []) == 0.0 && Enum.at(eq1, 1, []) == 0.0 && Enum.at(eq2, 0, []) == 0.0 && Enum.at(eq2, 1, []) == 0.0 do
        raise("Both a & b of two equations can't be zero.")
      end
      a1 = Enum.at(eq1, 0, [])
      b1 = Enum.at(eq1, 1, [])
      c1 = Enum.at(eq1, 2, [])
      a2 = Enum.at(eq2, 0, [])
      b2 = Enum.at(eq2, 1, [])
      c2 = Enum.at(eq2, 2, [])
      determinant = a1 * b2 - a2 * b1
      determinant_x = c1 * b2 - c2 * b1
      determinant_y = a1 * c2 - a2 * c1
      if determinant == 0.0 do
        if determinant_x == 0.0 && determinant_y == 0.0 do
          raise("Infinite solutions. (Consistent system)")
        end
        raise("No solution. (Inconsistent system)")
      end
      if determinant_x == 0.0 && determinant_y == 0.0 do
        throw {:return, [0.0, 0.0]}
      end
      x = determinant_x / determinant
      y = determinant_y / determinant
      throw {:return, [x, y]}
    catch
      {:return, val} -> val
    end
  end
  def test_cramers_rule_2x2() do
    try do
      r1 = cramers_rule_2x2([2.0, 3.0, 0.0], [5.0, 1.0, 0.0])
      if Enum.at(r1, 0, []) != 0.0 || Enum.at(r1, 1, []) != 0.0 do
        raise("Test1 failed")
      end
      r2 = cramers_rule_2x2([0.0, 4.0, 50.0], [2.0, 0.0, 26.0])
      if Enum.at(r2, 0, []) != 13.0 || Enum.at(r2, 1, []) != 12.5 do
        raise("Test2 failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_cramers_rule_2x2()
      IO.puts(Kernel.inspect(cramers_rule_2x2([11.0, 2.0, 30.0], [1.0, 0.0, 4.0])))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
