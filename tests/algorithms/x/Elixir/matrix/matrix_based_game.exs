# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def is_alnum(ch) do
    try do
      throw {:return, (ch >= "0" && ch <= "9") || (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z")}
    catch
      {:return, val} -> val
    end
  end
  def to_int(token) do
    try do
      res = 0
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(token) do
          res = res * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(_slice(token, i, i + 1 - (i))))
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def split(s, sep) do
    try do
      res = []
      current = ""
      i = 0
      while_fun_2 = fn while_fun_2, current, i, res ->
        if i < _len(s) do
          ch = _slice(s, i, i + 1 - (i))
          {current, res} = if ch == sep do
            res = (res ++ [current])
            current = ""
            {current, res}
          else
            current = (current <> ch)
            {current, res}
          end
          i = i + 1
          while_fun_2.(while_fun_2, current, i, res)
        else
          {current, i, res}
        end
      end
      {current, i, res} = try do
          while_fun_2.(while_fun_2, current, i, res)
        catch
          {:break, {current, i, res}} -> {current, i, res}
        end

      res = (res ++ [current])
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def parse_moves(input_str) do
    try do
      pairs = split(input_str, ",")
      moves = []
      i = 0
      while_fun_3 = fn while_fun_3, i, moves ->
        if i < _len(pairs) do
          pair = Enum.at(pairs, i)
          numbers = []
          num = ""
          j = 0
          while_fun_4 = fn while_fun_4, j, num, numbers ->
            if j < _len(pair) do
              ch = _slice(pair, j, j + 1 - (j))
              {num, numbers} = if ch == " " do
                {num, numbers} = if num != "" do
                  numbers = (numbers ++ [num])
                  num = ""
                  {num, numbers}
                else
                  {num, numbers}
                end
                {num, numbers}
              else
                num = (num <> ch)
                {num, numbers}
              end
              j = j + 1
              while_fun_4.(while_fun_4, j, num, numbers)
            else
              {j, num, numbers}
            end
          end
          {j, num, numbers} = try do
              while_fun_4.(while_fun_4, j, num, numbers)
            catch
              {:break, {j, num, numbers}} -> {j, num, numbers}
            end

          {numbers} = if num != "" do
            numbers = (numbers ++ [num])
            {numbers}
          else
            {numbers}
          end
          if _len(numbers) != 2 do
            raise("Each move must have exactly two numbers.")
          end
          x = to_int(Enum.at(numbers, 0))
          y = to_int(Enum.at(numbers, 1))
          moves = (moves ++ [%{x: x, y: y}])
          i = i + 1
          while_fun_3.(while_fun_3, i, moves)
        else
          {i, moves}
        end
      end
      {i, moves} = try do
          while_fun_3.(while_fun_3, i, moves)
        catch
          {:break, {i, moves}} -> {i, moves}
        end

      throw {:return, moves}
    catch
      {:return, val} -> val
    end
  end
  def validate_matrix_size(size) do
    try do
      if size <= 0 do
        raise("Matrix size must be a positive integer.")
      end
    catch
      {:return, val} -> val
    end
  end
  def validate_matrix_content(matrix, size) do
    try do
      if _len(matrix) != size do
        raise("The matrix dont match with size.")
      end
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i < size do
          row = Enum.at(matrix, i)
          if _len(row) != size do
            raise((("Each row in the matrix must have exactly " <> Kernel.to_string(size)) <> " characters."))
          end
          j = 0
          while_fun_6 = fn while_fun_6, j ->
            if j < size do
              ch = _slice(row, j, j + 1 - (j))
              if !is_alnum(ch) do
                raise("Matrix rows can only contain letters and numbers.")
              end
              j = j + 1
              while_fun_6.(while_fun_6, j)
            else
              j
            end
          end
          j = try do
              while_fun_6.(while_fun_6, j)
            catch
              {:break, {j}} -> j
            end

          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def validate_moves(moves, size) do
    try do
      i = 0
      while_fun_7 = fn while_fun_7, i ->
        if i < _len(moves) do
          mv = Enum.at(moves, i)
          if mv.x < 0 || mv.x >= size || mv.y < 0 || mv.y >= size do
            raise("Move is out of bounds for a matrix.")
          end
          i = i + 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      i = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def contains(pos, r, c) do
    try do
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < _len(pos) do
          p = Enum.at(pos, i)
          if p.x == r && p.y == c do
            throw {:return, true}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      i = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def find_repeat(matrix_g, row, column, size) do
    try do
      column = size - 1 - column
      visited = []
      repeated = []
      color = Enum.at(Enum.at(matrix_g, column), row)
      if color == "-" do
        throw {:return, repeated}
      end
      stack = [%{x: column, y: row}]
      while_fun_9 = fn while_fun_9, repeated, stack, visited ->
        if _len(stack) > 0 do
          {repeated, stack, visited} = try do
            idx = _len(stack) - 1
            pos = Enum.at(stack, idx)
            stack = _slice(stack, 0, idx - 0)
            if pos.x < 0 || pos.x >= size || pos.y < 0 || pos.y >= size do
              throw {:continue, {repeated, stack, visited}}
            end
            if contains(visited, pos.x, pos.y) do
              throw {:continue, {repeated, stack, visited}}
            end
            visited = (visited ++ [pos])
            {repeated, stack} = if Enum.at(Enum.at(matrix_g, pos.x), pos.y) == color do
              repeated = (repeated ++ [pos])
              stack = (stack ++ [%{x: pos.x - 1, y: pos.y}])
              stack = (stack ++ [%{x: pos.x + 1, y: pos.y}])
              stack = (stack ++ [%{x: pos.x, y: pos.y - 1}])
              stack = (stack ++ [%{x: pos.x, y: pos.y + 1}])
              {repeated, stack}
            else
              {repeated, stack}
            end
            {repeated, stack, visited}
          catch
            {:continue, {repeated, stack, visited}} -> {repeated, stack, visited}
          end
          while_fun_9.(while_fun_9, repeated, stack, visited)
        else
          {repeated, stack, visited}
        end
      end
      {repeated, stack, visited} = try do
          while_fun_9.(while_fun_9, repeated, stack, visited)
        catch
          {:break, {repeated, stack, visited}} -> {repeated, stack, visited}
        end

      throw {:return, repeated}
    catch
      {:return, val} -> val
    end
  end
  def increment_score(count) do
    try do
      throw {:return, div(count * (count + 1), 2)}
    catch
      {:return, val} -> val
    end
  end
  def move_x(matrix_g, column, size) do
    try do
      new_list = []
      row = 0
      while_fun_10 = fn while_fun_10, new_list, row ->
        if row < size do
          val = Enum.at(Enum.at(matrix_g, row), column)
          new_list = (if val != "-", do: (new_list ++ [val]), else: ([val] ++ new_list))
          row = row + 1
          while_fun_10.(while_fun_10, new_list, row)
        else
          {new_list, row}
        end
      end
      {new_list, row} = try do
          while_fun_10.(while_fun_10, new_list, row)
        catch
          {:break, {new_list, row}} -> {new_list, row}
        end

      row = 0
      while_fun_11 = fn while_fun_11, matrix_g, row ->
        if row < size do
          matrix_g = List.replace_at(matrix_g, row, List.replace_at(Enum.at(matrix_g, row), column, Enum.at(new_list, row)))
          row = row + 1
          while_fun_11.(while_fun_11, matrix_g, row)
        else
          {matrix_g, row}
        end
      end
      {matrix_g, row} = try do
          while_fun_11.(while_fun_11, matrix_g, row)
        catch
          {:break, {matrix_g, row}} -> {matrix_g, row}
        end

      throw {:return, matrix_g}
    catch
      {:return, val} -> val
    end
  end
  def move_y(matrix_g, size) do
    try do
      empty_cols = []
      column = size - 1
      while_fun_12 = fn while_fun_12, column, empty_cols ->
        if column >= 0 do
          row = 0
          all_empty = true
          while_fun_13 = fn while_fun_13, all_empty, row ->
            if row < size do
              {all_empty} = if Enum.at(Enum.at(matrix_g, row), column) != "-" do
                all_empty = false
                throw {:break, {all_empty, row}}
                {all_empty}
              else
                {all_empty}
              end
              row = row + 1
              while_fun_13.(while_fun_13, all_empty, row)
            else
              {all_empty, row}
            end
          end
          {all_empty, row} = try do
              while_fun_13.(while_fun_13, all_empty, row)
            catch
              {:break, {all_empty, row}} -> {all_empty, row}
            end

          {empty_cols} = if all_empty do
            empty_cols = (empty_cols ++ [column])
            {empty_cols}
          else
            {empty_cols}
          end
          column = column - 1
          while_fun_12.(while_fun_12, column, empty_cols)
        else
          {column, empty_cols}
        end
      end
      {column, empty_cols} = try do
          while_fun_12.(while_fun_12, column, empty_cols)
        catch
          {:break, {column, empty_cols}} -> {column, empty_cols}
        end

      i = 0
      while_fun_14 = fn while_fun_14, i, matrix_g ->
        if i < _len(empty_cols) do
          col = Enum.at(empty_cols, i)
          c = col + 1
          while_fun_15 = fn while_fun_15, c, matrix_g ->
            if c < size do
              r = 0
              while_fun_16 = fn while_fun_16, matrix_g, r ->
                if r < size do
                  matrix_g = List.replace_at(matrix_g, r, List.replace_at(Enum.at(matrix_g, r), c - 1, Enum.at(Enum.at(matrix_g, r), c)))
                  r = r + 1
                  while_fun_16.(while_fun_16, matrix_g, r)
                else
                  {matrix_g, r}
                end
              end
              {matrix_g, r} = try do
                  while_fun_16.(while_fun_16, matrix_g, r)
                catch
                  {:break, {matrix_g, r}} -> {matrix_g, r}
                end

              c = c + 1
              while_fun_15.(while_fun_15, c, matrix_g)
            else
              {c, matrix_g}
            end
          end
          {c, matrix_g} = try do
              while_fun_15.(while_fun_15, c, matrix_g)
            catch
              {:break, {c, matrix_g}} -> {c, matrix_g}
            end

          r = 0
          while_fun_17 = fn while_fun_17, matrix_g, r ->
            if r < size do
              matrix_g = List.replace_at(matrix_g, r, List.replace_at(Enum.at(matrix_g, r), size - 1, "-"))
              r = r + 1
              while_fun_17.(while_fun_17, matrix_g, r)
            else
              {matrix_g, r}
            end
          end
          {matrix_g, r} = try do
              while_fun_17.(while_fun_17, matrix_g, r)
            catch
              {:break, {matrix_g, r}} -> {matrix_g, r}
            end

          i = i + 1
          while_fun_14.(while_fun_14, i, matrix_g)
        else
          {i, matrix_g}
        end
      end
      {i, matrix_g} = try do
          while_fun_14.(while_fun_14, i, matrix_g)
        catch
          {:break, {i, matrix_g}} -> {i, matrix_g}
        end

      throw {:return, matrix_g}
    catch
      {:return, val} -> val
    end
  end
  def play(matrix_g, pos_x, pos_y, size) do
    try do
      same_colors = find_repeat(matrix_g, pos_x, pos_y, size)
      {matrix_g} = if _len(same_colors) != 0 do
        i = 0
        while_fun_18 = fn while_fun_18, i, matrix_g ->
          if i < _len(same_colors) do
            p = Enum.at(same_colors, i)
            matrix_g = List.replace_at(matrix_g, p.x, List.replace_at(Enum.at(matrix_g, p.x), p.y, "-"))
            i = i + 1
            while_fun_18.(while_fun_18, i, matrix_g)
          else
            {i, matrix_g}
          end
        end
        {i, matrix_g} = try do
            while_fun_18.(while_fun_18, i, matrix_g)
          catch
            {:break, {i, matrix_g}} -> {i, matrix_g}
          end

        column = 0
        while_fun_19 = fn while_fun_19, column, matrix_g ->
          if column < size do
            matrix_g = move_x(matrix_g, column, size)
            column = column + 1
            while_fun_19.(while_fun_19, column, matrix_g)
          else
            {column, matrix_g}
          end
        end
        {column, matrix_g} = try do
            while_fun_19.(while_fun_19, column, matrix_g)
          catch
            {:break, {column, matrix_g}} -> {column, matrix_g}
          end

        matrix_g = move_y(matrix_g, size)
        {matrix_g}
      else
        {matrix_g}
      end
      sc = increment_score(_len(same_colors))
      throw {:return, %{matrix: matrix_g, score: sc}}
    catch
      {:return, val} -> val
    end
  end
  def build_matrix(matrix) do
    try do
      res = []
      i = 0
      while_fun_20 = fn while_fun_20, i, res ->
        if i < _len(matrix) do
          row = Enum.at(matrix, i)
          row_list = []
          j = 0
          while_fun_21 = fn while_fun_21, j, row_list ->
            if j < _len(row) do
              row_list = (row_list ++ [_slice(row, j, j + 1 - (j))])
              j = j + 1
              while_fun_21.(while_fun_21, j, row_list)
            else
              {j, row_list}
            end
          end
          {j, row_list} = try do
              while_fun_21.(while_fun_21, j, row_list)
            catch
              {:break, {j, row_list}} -> {j, row_list}
            end

          res = (res ++ [row_list])
          i = i + 1
          while_fun_20.(while_fun_20, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_20.(while_fun_20, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def process_game(size, matrix, moves) do
    try do
      game_matrix = build_matrix(matrix)
      total = 0
      i = 0
      while_fun_22 = fn while_fun_22, game_matrix, i, total ->
        if i < _len(moves) do
          mv = Enum.at(moves, i)
          res = play(game_matrix, mv.x, mv.y, size)
          game_matrix = res.matrix
          total = total + res.score
          i = i + 1
          while_fun_22.(while_fun_22, game_matrix, i, total)
        else
          {game_matrix, i, total}
        end
      end
      {game_matrix, i, total} = try do
          while_fun_22.(while_fun_22, game_matrix, i, total)
        catch
          {:break, {game_matrix, i, total}} -> {game_matrix, i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      size = 4
      matrix = ["RRBG", "RBBG", "YYGG", "XYGG"]
      moves = parse_moves("0 1,1 1")
      validate_matrix_size(size)
      validate_matrix_content(matrix, size)
      validate_moves(moves, size)
      score = process_game(size, matrix, moves)
      IO.puts(Kernel.to_string(score))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
