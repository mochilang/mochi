# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  def update_area_of_max_square(row, col, rows, cols, mat, largest_square_area) do
    try do
      if row >= rows || col >= cols do
        throw {:return, 0}
      end
      right = update_area_of_max_square(row, col + 1, rows, cols, mat, largest_square_area)
      diagonal = update_area_of_max_square(row + 1, col + 1, rows, cols, mat, largest_square_area)
      down = update_area_of_max_square(row + 1, col, rows, cols, mat, largest_square_area)
      {largest_square_area} = if Enum.at(Enum.at(mat, row), col) == 1 do
        sub = 1 + Enum.min([right, diagonal, down])
        {largest_square_area} = if sub > Enum.at(largest_square_area, 0) do
          largest_square_area = List.replace_at(largest_square_area, 0, sub)
          {largest_square_area}
        else
          {largest_square_area}
        end
        throw {:return, sub}
        {largest_square_area}
      else
        throw {:return, 0}
        {largest_square_area}
      end
    catch
      {:return, val} -> val
    end
  end
  def largest_square_area_in_matrix_top_down(rows, cols, mat) do
    try do
      largest = [0]
      update_area_of_max_square(0, 0, rows, cols, mat, largest)
      throw {:return, Enum.at(largest, 0)}
    catch
      {:return, val} -> val
    end
  end
  def update_area_of_max_square_with_dp(row, col, rows, cols, mat, dp_array, largest_square_area) do
    try do
      if row >= rows || col >= cols do
        throw {:return, 0}
      end
      if Enum.at(Enum.at(dp_array, row), col) != (-1) do
        throw {:return, Enum.at(Enum.at(dp_array, row), col)}
      end
      right = update_area_of_max_square_with_dp(row, col + 1, rows, cols, mat, dp_array, largest_square_area)
      diagonal = update_area_of_max_square_with_dp(row + 1, col + 1, rows, cols, mat, dp_array, largest_square_area)
      down = update_area_of_max_square_with_dp(row + 1, col, rows, cols, mat, dp_array, largest_square_area)
      {dp_array, largest_square_area} = if Enum.at(Enum.at(mat, row), col) == 1 do
        sub = 1 + Enum.min([right, diagonal, down])
        {largest_square_area} = if sub > Enum.at(largest_square_area, 0) do
          largest_square_area = List.replace_at(largest_square_area, 0, sub)
          {largest_square_area}
        else
          {largest_square_area}
        end
        dp_array = List.replace_at(dp_array, row, List.replace_at(Enum.at(dp_array, row), col, sub))
        throw {:return, sub}
        {dp_array, largest_square_area}
      else
        dp_array = List.replace_at(dp_array, row, List.replace_at(Enum.at(dp_array, row), col, 0))
        throw {:return, 0}
        {dp_array, largest_square_area}
      end
    catch
      {:return, val} -> val
    end
  end
  def largest_square_area_in_matrix_top_down_with_dp(rows, cols, mat) do
    try do
      largest = [0]
      dp_array = []
      r = 0
      while_fun = fn while_fun, dp_array, r ->
        if r < rows do
          row_list = []
          c = 0
          while_fun_2 = fn while_fun_2, c, row_list ->
            if c < cols do
              row_list = (row_list ++ [-1])
              c = c + 1
              while_fun_2.(while_fun_2, c, row_list)
            else
              {c, row_list}
            end
          end
          {c, row_list} = try do
              while_fun_2.(while_fun_2, c, row_list)
            catch
              {:break, {c, row_list}} -> {c, row_list}
            end

          dp_array = (dp_array ++ [row_list])
          r = r + 1
          while_fun.(while_fun, dp_array, r)
        else
          {dp_array, r}
        end
      end
      {dp_array, r} = try do
          while_fun.(while_fun, dp_array, r)
        catch
          {:break, {dp_array, r}} -> {dp_array, r}
        end

      update_area_of_max_square_with_dp(0, 0, rows, cols, mat, dp_array, largest)
      throw {:return, Enum.at(largest, 0)}
    catch
      {:return, val} -> val
    end
  end
  def largest_square_area_in_matrix_bottom_up(rows, cols, mat) do
    try do
      dp_array = []
      r = 0
      while_fun_3 = fn while_fun_3, dp_array, r ->
        if r <= rows do
          row_list = []
          c = 0
          while_fun_4 = fn while_fun_4, c, row_list ->
            if c <= cols do
              row_list = (row_list ++ [0])
              c = c + 1
              while_fun_4.(while_fun_4, c, row_list)
            else
              {c, row_list}
            end
          end
          {c, row_list} = try do
              while_fun_4.(while_fun_4, c, row_list)
            catch
              {:break, {c, row_list}} -> {c, row_list}
            end

          dp_array = (dp_array ++ [row_list])
          r = r + 1
          while_fun_3.(while_fun_3, dp_array, r)
        else
          {dp_array, r}
        end
      end
      {dp_array, r} = try do
          while_fun_3.(while_fun_3, dp_array, r)
        catch
          {:break, {dp_array, r}} -> {dp_array, r}
        end

      largest = 0
      row = rows - 1
      while_fun_5 = fn while_fun_5, dp_array, largest, row ->
        if row >= 0 do
          col = cols - 1
          while_fun_6 = fn while_fun_6, col, dp_array, largest ->
            if col >= 0 do
              right = Enum.at(Enum.at(dp_array, row), col + 1)
              diagonal = Enum.at(Enum.at(dp_array, row + 1), col + 1)
              bottom = Enum.at(Enum.at(dp_array, row + 1), col)
              {dp_array, largest} = if Enum.at(Enum.at(mat, row), col) == 1 do
                value = 1 + Enum.min([right, diagonal, bottom])
                dp_array = List.replace_at(dp_array, row, List.replace_at(Enum.at(dp_array, row), col, value))
                {largest} = if value > largest do
                  largest = value
                  {largest}
                else
                  {largest}
                end
                {dp_array, largest}
              else
                dp_array = List.replace_at(dp_array, row, List.replace_at(Enum.at(dp_array, row), col, 0))
                {dp_array, largest}
              end
              col = col - 1
              while_fun_6.(while_fun_6, col, dp_array, largest)
            else
              {col, dp_array, largest}
            end
          end
          {col, dp_array, largest} = try do
              while_fun_6.(while_fun_6, col, dp_array, largest)
            catch
              {:break, {col, dp_array, largest}} -> {col, dp_array, largest}
            end

          row = row - 1
          while_fun_5.(while_fun_5, dp_array, largest, row)
        else
          {dp_array, largest, row}
        end
      end
      {dp_array, largest, row} = try do
          while_fun_5.(while_fun_5, dp_array, largest, row)
        catch
          {:break, {dp_array, largest, row}} -> {dp_array, largest, row}
        end

      throw {:return, largest}
    catch
      {:return, val} -> val
    end
  end
  def largest_square_area_in_matrix_bottom_up_space_optimization(rows, cols, mat) do
    try do
      current_row = []
      i = 0
      while_fun_7 = fn while_fun_7, current_row, i ->
        if i <= cols do
          current_row = (current_row ++ [0])
          i = i + 1
          while_fun_7.(while_fun_7, current_row, i)
        else
          {current_row, i}
        end
      end
      {current_row, i} = try do
          while_fun_7.(while_fun_7, current_row, i)
        catch
          {:break, {current_row, i}} -> {current_row, i}
        end

      next_row = []
      j = 0
      while_fun_8 = fn while_fun_8, j, next_row ->
        if j <= cols do
          next_row = (next_row ++ [0])
          j = j + 1
          while_fun_8.(while_fun_8, j, next_row)
        else
          {j, next_row}
        end
      end
      {j, next_row} = try do
          while_fun_8.(while_fun_8, j, next_row)
        catch
          {:break, {j, next_row}} -> {j, next_row}
        end

      largest = 0
      row = rows - 1
      while_fun_9 = fn while_fun_9, current_row, largest, next_row, row ->
        if row >= 0 do
          col = cols - 1
          while_fun_10 = fn while_fun_10, col, current_row, largest ->
            if col >= 0 do
              right = Enum.at(current_row, col + 1)
              diagonal = Enum.at(next_row, col + 1)
              bottom = Enum.at(next_row, col)
              {current_row, largest} = if Enum.at(Enum.at(mat, row), col) == 1 do
                value = 1 + Enum.min([right, diagonal, bottom])
                current_row = List.replace_at(current_row, col, value)
                {largest} = if value > largest do
                  largest = value
                  {largest}
                else
                  {largest}
                end
                {current_row, largest}
              else
                current_row = List.replace_at(current_row, col, 0)
                {current_row, largest}
              end
              col = col - 1
              while_fun_10.(while_fun_10, col, current_row, largest)
            else
              {col, current_row, largest}
            end
          end
          {col, current_row, largest} = try do
              while_fun_10.(while_fun_10, col, current_row, largest)
            catch
              {:break, {col, current_row, largest}} -> {col, current_row, largest}
            end

          next_row = current_row
          current_row = []
          t = 0
          while_fun_11 = fn while_fun_11, current_row, t ->
            if t <= cols do
              current_row = (current_row ++ [0])
              t = t + 1
              while_fun_11.(while_fun_11, current_row, t)
            else
              {current_row, t}
            end
          end
          {current_row, t} = try do
              while_fun_11.(while_fun_11, current_row, t)
            catch
              {:break, {current_row, t}} -> {current_row, t}
            end

          row = row - 1
          while_fun_9.(while_fun_9, current_row, largest, next_row, row)
        else
          {current_row, largest, next_row, row}
        end
      end
      {current_row, largest, next_row, row} = try do
          while_fun_9.(while_fun_9, current_row, largest, next_row, row)
        catch
          {:break, {current_row, largest, next_row, row}} -> {current_row, largest, next_row, row}
        end

      throw {:return, largest}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:sample, [[1, 1], [1, 1]])
  def main() do
    IO.puts(Kernel.inspect(largest_square_area_in_matrix_top_down(2, 2, Process.get(:sample))))
    IO.puts(Kernel.inspect(largest_square_area_in_matrix_top_down_with_dp(2, 2, Process.get(:sample))))
    IO.puts(Kernel.inspect(largest_square_area_in_matrix_bottom_up(2, 2, Process.get(:sample))))
    IO.puts(Kernel.inspect(largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, Process.get(:sample))))
  end
end
Main.main()
