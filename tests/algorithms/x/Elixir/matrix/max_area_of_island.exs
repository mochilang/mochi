# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def encode(row, col) do
    try do
      throw {:return, ((Kernel.to_string(row) <> ",") <> Kernel.to_string(col))}
    catch
      {:return, val} -> val
    end
  end
  def is_safe(row, col, rows, cols) do
    try do
      throw {:return, row >= 0 && row < rows && col >= 0 && col < cols}
    catch
      {:return, val} -> val
    end
  end
  def has(seen, key) do
    try do
      throw {:return, Map.has_key?(seen, key)}
    catch
      {:return, val} -> val
    end
  end
  def depth_first_search(row, col, seen, mat) do
    try do
      rows = _len(mat)
      cols = _len(Enum.at(mat, 0))
      key = encode(row, col)
      {seen} = if is_safe(row, col, rows, cols) && (!has(seen, key)) && Enum.at(Enum.at(mat, row), col) == 1 do
        seen = Map.put(seen, key, true)
        throw {:return, 1 + depth_first_search(row + 1, col, seen, mat) + depth_first_search(row - 1, col, seen, mat) + depth_first_search(row, col + 1, seen, mat) + depth_first_search(row, col - 1, seen, mat)}
        {seen}
      else
        throw {:return, 0}
        {seen}
      end
    catch
      {:return, val} -> val
    end
  end
  def find_max_area(mat) do
    try do
      seen = %{}
      rows = _len(mat)
      max_area = 0
      r = 0
      while_fun = fn while_fun, max_area, r ->
        if r < rows do
          line = Enum.at(mat, r)
          cols = _len(line)
          c = 0
          while_fun_2 = fn while_fun_2, c, max_area ->
            if c < cols do
              {max_area} = if Enum.at(line, c) == 1 do
                key = encode(r, c)
                {max_area} = if !(Map.has_key?(seen, key)) do
                  area = depth_first_search(r, c, seen, mat)
                  {max_area} = if area > max_area do
                    max_area = area
                    {max_area}
                  else
                    {max_area}
                  end
                  {max_area}
                else
                  {max_area}
                end
                {max_area}
              else
                {max_area}
              end
              c = c + 1
              while_fun_2.(while_fun_2, c, max_area)
            else
              {c, max_area}
            end
          end
          {c, max_area} = try do
              while_fun_2.(while_fun_2, c, max_area)
            catch
              {:break, {c, max_area}} -> {c, max_area}
            end

          r = r + 1
          while_fun.(while_fun, max_area, r)
        else
          {max_area, r}
        end
      end
      {max_area, r} = try do
          while_fun.(while_fun, max_area, r)
        catch
          {:break, {max_area, r}} -> {max_area, r}
        end

      throw {:return, max_area}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:matrix, [[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]])
  def main() do
    IO.puts(Kernel.inspect(find_max_area(Process.get(:matrix))))
  end
end
Main.main()
