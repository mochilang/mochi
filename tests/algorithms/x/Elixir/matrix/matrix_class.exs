# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_matrix(values) do
    try do
      r = _len(values)
      if r == 0 do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      c = _len(Enum.at(values, 0))
      i = 0
      while_fun = fn while_fun, i ->
        if i < r do
          if _len(Enum.at(values, i)) != c do
            throw {:return, %{data: [], rows: 0, cols: 0}}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, %{data: values, rows: r, cols: c}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_columns(m) do
    try do
      cols = []
      j = 0
      while_fun_2 = fn while_fun_2, cols, j ->
        if j < m.cols do
          col = []
          i = 0
          while_fun_3 = fn while_fun_3, col, i ->
            if i < m.rows do
              col = (col ++ [Enum.at(Enum.at(m.data, i), j)])
              i = i + 1
              while_fun_3.(while_fun_3, col, i)
            else
              {col, i}
            end
          end
          {col, i} = try do
              while_fun_3.(while_fun_3, col, i)
            catch
              {:break, {col, i}} -> {col, i}
            end

          cols = (cols ++ [col])
          j = j + 1
          while_fun_2.(while_fun_2, cols, j)
        else
          {cols, j}
        end
      end
      {cols, j} = try do
          while_fun_2.(while_fun_2, cols, j)
        catch
          {:break, {cols, j}} -> {cols, j}
        end

      throw {:return, cols}
    catch
      {:return, val} -> val
    end
  end
  def matrix_identity(m) do
    try do
      vals = []
      i = 0
      while_fun_4 = fn while_fun_4, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_5 = fn while_fun_5, j, row ->
            if j < m.cols do
              v = (if i == j, do: 1.0, else: 0.0)
              row = (row ++ [v])
              j = j + 1
              while_fun_5.(while_fun_5, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_5.(while_fun_5, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_4.(while_fun_4, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_4.(while_fun_4, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_minor(m, r, c) do
    try do
      vals = []
      i = 0
      while_fun_6 = fn while_fun_6, i, vals ->
        if i < m.rows do
          {vals} = if i != r do
            row = []
            j = 0
            while_fun_7 = fn while_fun_7, j, row ->
              if j < m.cols do
                {row} = if j != c do
                  row = (row ++ [Enum.at(Enum.at(m.data, i), j)])
                  {row}
                else
                  {row}
                end
                j = j + 1
                while_fun_7.(while_fun_7, j, row)
              else
                {j, row}
              end
            end
            {j, row} = try do
                while_fun_7.(while_fun_7, j, row)
              catch
                {:break, {j, row}} -> {j, row}
              end

            vals = (vals ++ [row])
            {vals}
          else
            {vals}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_6.(while_fun_6, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      sub = %{data: vals, rows: m.rows - 1, cols: m.cols - 1}
      throw {:return, matrix_determinant(sub)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_cofactor(m, r, c) do
    try do
      minor = matrix_minor(m, r, c)
      if rem((r + c), 2) == 0 do
        throw {:return, minor}
      end
      throw {:return, -1.0 * minor}
    catch
      {:return, val} -> val
    end
  end
  def matrix_minors(m) do
    try do
      vals = []
      i = 0
      while_fun_8 = fn while_fun_8, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < m.cols do
              row = (row ++ [matrix_minor(m, i, j)])
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_8.(while_fun_8, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_8.(while_fun_8, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_cofactors(m) do
    try do
      vals = []
      i = 0
      while_fun_10 = fn while_fun_10, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_11 = fn while_fun_11, j, row ->
            if j < m.cols do
              row = (row ++ [matrix_cofactor(m, i, j)])
              j = j + 1
              while_fun_11.(while_fun_11, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_11.(while_fun_11, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_10.(while_fun_10, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_10.(while_fun_10, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_determinant(m) do
    try do
      if m.rows != m.cols do
        throw {:return, 0.0}
      end
      if m.rows == 0 do
        throw {:return, 0.0}
      end
      if m.rows == 1 do
        throw {:return, Enum.at(Enum.at(m.data, 0), 0)}
      end
      if m.rows == 2 do
        throw {:return, Enum.at(Enum.at(m.data, 0), 0) * Enum.at(Enum.at(m.data, 1), 1) - Enum.at(Enum.at(m.data, 0), 1) * Enum.at(Enum.at(m.data, 1), 0)}
      end
      sum = 0.0
      j = 0
      while_fun_12 = fn while_fun_12, j, sum ->
        if j < m.cols do
          sum = sum + Enum.at(Enum.at(m.data, 0), j) * matrix_cofactor(m, 0, j)
          j = j + 1
          while_fun_12.(while_fun_12, j, sum)
        else
          {j, sum}
        end
      end
      {j, sum} = try do
          while_fun_12.(while_fun_12, j, sum)
        catch
          {:break, {j, sum}} -> {j, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def matrix_is_invertible(m) do
    try do
      throw {:return, matrix_determinant(m) != 0.0}
    catch
      {:return, val} -> val
    end
  end
  def matrix_adjugate(m) do
    try do
      cof = matrix_cofactors(m)
      vals = []
      i = 0
      while_fun_13 = fn while_fun_13, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_14 = fn while_fun_14, j, row ->
            if j < m.cols do
              row = (row ++ [Enum.at(Enum.at(cof.data, j), i)])
              j = j + 1
              while_fun_14.(while_fun_14, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_14.(while_fun_14, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_13.(while_fun_13, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_13.(while_fun_13, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_inverse(m) do
    try do
      det = matrix_determinant(m)
      if det == 0.0 do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      adj = matrix_adjugate(m)
      throw {:return, matrix_mul_scalar(adj, 1.0 / det)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add_row(m, row) do
    try do
      newData = m.data
      newData = (newData ++ [row])
      throw {:return, %{data: newData, rows: m.rows + 1, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add_column(m, col) do
    try do
      newData = []
      i = 0
      while_fun_15 = fn while_fun_15, i, newData ->
        if i < m.rows do
          newData = (newData ++ [(Enum.at(m.data, i) ++ [Enum.at(col, i)])])
          i = i + 1
          while_fun_15.(while_fun_15, i, newData)
        else
          {i, newData}
        end
      end
      {i, newData} = try do
          while_fun_15.(while_fun_15, i, newData)
        catch
          {:break, {i, newData}} -> {i, newData}
        end

      throw {:return, %{data: newData, rows: m.rows, cols: m.cols + 1}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_scalar(m, s) do
    try do
      vals = []
      i = 0
      while_fun_16 = fn while_fun_16, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_17 = fn while_fun_17, j, row ->
            if j < m.cols do
              row = (row ++ [Enum.at(Enum.at(m.data, i), j) * s])
              j = j + 1
              while_fun_17.(while_fun_17, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_17.(while_fun_17, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_16.(while_fun_16, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_16.(while_fun_16, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_neg(m) do
    try do
      throw {:return, matrix_mul_scalar(m, -1.0)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add(a, b) do
    try do
      if a.rows != b.rows || a.cols != b.cols do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      vals = []
      i = 0
      while_fun_18 = fn while_fun_18, i, vals ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_19 = fn while_fun_19, j, row ->
            if j < a.cols do
              row = (row ++ [Enum.at(Enum.at(a.data, i), j) + Enum.at(Enum.at(b.data, i), j)])
              j = j + 1
              while_fun_19.(while_fun_19, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_19.(while_fun_19, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_18.(while_fun_18, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_18.(while_fun_18, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: a.rows, cols: a.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_sub(a, b) do
    try do
      if a.rows != b.rows || a.cols != b.cols do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      vals = []
      i = 0
      while_fun_20 = fn while_fun_20, i, vals ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_21 = fn while_fun_21, j, row ->
            if j < a.cols do
              row = (row ++ [Enum.at(Enum.at(a.data, i), j) - Enum.at(Enum.at(b.data, i), j)])
              j = j + 1
              while_fun_21.(while_fun_21, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_21.(while_fun_21, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_20.(while_fun_20, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_20.(while_fun_20, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: a.rows, cols: a.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_dot(row, col) do
    try do
      sum = 0.0
      i = 0
      while_fun_22 = fn while_fun_22, i, sum ->
        if i < _len(row) do
          sum = sum + Enum.at(row, i) * Enum.at(col, i)
          i = i + 1
          while_fun_22.(while_fun_22, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_22.(while_fun_22, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul(a, b) do
    try do
      if a.cols != b.rows do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      bcols = matrix_columns(b)
      vals = []
      i = 0
      while_fun_23 = fn while_fun_23, i, vals ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_24 = fn while_fun_24, j, row ->
            if j < b.cols do
              row = (row ++ [matrix_dot(Enum.at(a.data, i), Enum.at(bcols, j))])
              j = j + 1
              while_fun_24.(while_fun_24, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_24.(while_fun_24, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_23.(while_fun_23, i, vals)
        else
          {i, vals}
        end
      end
      {i, vals} = try do
          while_fun_23.(while_fun_23, i, vals)
        catch
          {:break, {i, vals}} -> {i, vals}
        end

      throw {:return, %{data: vals, rows: a.rows, cols: b.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_pow(m, p) do
    try do
      if p == 0 do
        throw {:return, matrix_identity(m)}
      end
      if p < 0 do
        if matrix_is_invertible(m) do
          throw {:return, matrix_pow(matrix_inverse(m), -p)}
        end
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      result = m
      i = 1
      while_fun_25 = fn while_fun_25, i, result ->
        if i < p do
          result = matrix_mul(result, m)
          i = i + 1
          while_fun_25.(while_fun_25, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_25.(while_fun_25, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def matrix_to_string(m) do
    try do
      if m.rows == 0 do
        throw {:return, "[]"}
      end
      s = "["
      i = 0
      while_fun_26 = fn while_fun_26, i, s ->
        if i < m.rows do
          s = (s <> "[")
          j = 0
          while_fun_27 = fn while_fun_27, j, s ->
            if j < m.cols do
              s = (s <> Kernel.to_string(Enum.at(Enum.at(m.data, i), j)))
              {s} = if j < m.cols - 1 do
                s = (s <> " ")
                {s}
              else
                {s}
              end
              j = j + 1
              while_fun_27.(while_fun_27, j, s)
            else
              {j, s}
            end
          end
          {j, s} = try do
              while_fun_27.(while_fun_27, j, s)
            catch
              {:break, {j, s}} -> {j, s}
            end

          s = (s <> "]")
          {s} = if i < m.rows - 1 do
            s = (s <> "\n ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_26.(while_fun_26, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_26.(while_fun_26, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      m = make_matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
      IO.puts(Kernel.inspect(matrix_to_string(m)))
      IO.puts(Kernel.inspect(matrix_columns(m)))
      IO.puts(((Kernel.to_string(m.rows) <> ",") <> Kernel.to_string(m.cols)))
      IO.puts(Kernel.inspect(matrix_is_invertible(m)))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_identity(m))))
      IO.puts(Kernel.inspect(matrix_determinant(m)))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_minors(m))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_cofactors(m))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_adjugate(m))))
      m2 = matrix_mul_scalar(m, 3.0)
      IO.puts(Kernel.inspect(matrix_to_string(m2)))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_add(m, m2))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_sub(m, m2))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_pow(m, 3))))
      m3 = matrix_add_row(m, [10.0, 11.0, 12.0])
      IO.puts(Kernel.inspect(matrix_to_string(m3)))
      m4 = matrix_add_column(m2, [8.0, 16.0, 32.0])
      IO.puts(Kernel.inspect(matrix_to_string(matrix_mul(m3, m4))))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
