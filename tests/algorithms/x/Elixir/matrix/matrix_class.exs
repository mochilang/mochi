# Code generated by Mochi transpiler 2025-08-16 09:25 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_matrix(values) do
    try do
      r = _len(values)
      if r == 0 do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      c = _len(Enum.at(values, 0, []))
      i = 0
      while_fun = fn while_fun, i ->
        if i < r do
          if _len(Enum.at(values, i, [])) != c do
            throw {:return, %{data: [], rows: 0, cols: 0}}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      _ = try do
          while_fun.(while_fun, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, %{data: values, rows: r, cols: c}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_columns(m) do
    try do
      cols = []
      j = 0
      while_fun_2 = fn while_fun_2, cols, j ->
        if j < m.cols do
          col = []
          i = 0
          while_fun_3 = fn while_fun_3, col, i ->
            if i < m.rows do
              col = (col ++ [Enum.at(Enum.at(m.data, i, 0), j, 0)])
              i = i + 1
              while_fun_3.(while_fun_3, col, i)
            else
              {col, i}
            end
          end
          {col, _} = try do
              while_fun_3.(while_fun_3, col, i)
            catch
              {:break, {col, _}} -> {col, 0}
            end

          cols = (cols ++ [col])
          j = j + 1
          while_fun_2.(while_fun_2, cols, j)
        else
          {cols, j}
        end
      end
      {cols, _} = try do
          while_fun_2.(while_fun_2, cols, j)
        catch
          {:break, {cols, _}} -> {cols, 0}
        end

      throw {:return, cols}
    catch
      {:return, val} -> val
    end
  end
  def matrix_identity(m) do
    try do
      vals = []
      i = 0
      while_fun_4 = fn while_fun_4, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_5 = fn while_fun_5, j, row ->
            if j < m.cols do
              v = (if i == j, do: 1.0, else: 0.0)
              row = (row ++ [v])
              j = j + 1
              while_fun_5.(while_fun_5, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_5.(while_fun_5, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_4.(while_fun_4, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_4.(while_fun_4, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_minor(m, r, c) do
    try do
      vals = []
      i = 0
      while_fun_6 = fn while_fun_6, i, vals ->
        if i < m.rows do
          vals = if i != r do
            row = []
            j = 0
            while_fun_7 = fn while_fun_7, j, row ->
              if j < m.cols do
                row = if j != c do
                  row = (row ++ [Enum.at(Enum.at(m.data, i, 0), j, 0)])
                  row
                else
                  row
                end
                j = j + 1
                while_fun_7.(while_fun_7, j, row)
              else
                {j, row}
              end
            end
            {_, row} = try do
                while_fun_7.(while_fun_7, j, row)
              catch
                {:break, {_, row}} -> {0, row}
              end

            vals = (vals ++ [row])
            vals
          else
            vals
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_6.(while_fun_6, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      sub = %{data: vals, rows: m.rows - 1, cols: m.cols - 1}
      throw {:return, matrix_determinant(sub)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_cofactor(m, r, c) do
    try do
      minor = matrix_minor(m, r, c)
      if rem((r + c), 2) == 0 do
        throw {:return, minor}
      end
      throw {:return, -1.0 * minor}
    catch
      {:return, val} -> val
    end
  end
  def matrix_minors(m) do
    try do
      vals = []
      i = 0
      while_fun_8 = fn while_fun_8, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < m.cols do
              row = (row ++ [matrix_minor(m, i, j)])
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_8.(while_fun_8, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_8.(while_fun_8, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_cofactors(m) do
    try do
      vals = []
      i = 0
      while_fun_10 = fn while_fun_10, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_11 = fn while_fun_11, j, row ->
            if j < m.cols do
              row = (row ++ [matrix_cofactor(m, i, j)])
              j = j + 1
              while_fun_11.(while_fun_11, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_11.(while_fun_11, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_10.(while_fun_10, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_10.(while_fun_10, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_determinant(m) do
    try do
      if m.rows != m.cols do
        throw {:return, 0.0}
      end
      if m.rows == 0 do
        throw {:return, 0.0}
      end
      if m.rows == 1 do
        throw {:return, Enum.at(Enum.at(m.data, 0, 0), 0, 0)}
      end
      if m.rows == 2 do
        throw {:return, Enum.at(Enum.at(m.data, 0, 0), 0, 0) * Enum.at(Enum.at(m.data, 1, 0), 1, 0) - Enum.at(Enum.at(m.data, 0, 0), 1, 0) * Enum.at(Enum.at(m.data, 1, 0), 0, 0)}
      end
      sum = 0.0
      j = 0
      while_fun_12 = fn while_fun_12, j, sum ->
        if j < m.cols do
          sum = sum + Enum.at(Enum.at(m.data, 0, 0), j, 0) * matrix_cofactor(m, 0, j)
          j = j + 1
          while_fun_12.(while_fun_12, j, sum)
        else
          {j, sum}
        end
      end
      {_, sum} = try do
          while_fun_12.(while_fun_12, j, sum)
        catch
          {:break, {_, sum}} -> {0, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def matrix_is_invertible(m) do
    try do
      throw {:return, matrix_determinant(m) != 0.0}
    catch
      {:return, val} -> val
    end
  end
  def matrix_adjugate(m) do
    try do
      cof = matrix_cofactors(m)
      vals = []
      i = 0
      while_fun_13 = fn while_fun_13, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_14 = fn while_fun_14, j, row ->
            if j < m.cols do
              row = (row ++ [Enum.at(Enum.at(cof.data, j, 0), i, 0)])
              j = j + 1
              while_fun_14.(while_fun_14, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_14.(while_fun_14, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_13.(while_fun_13, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_13.(while_fun_13, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_inverse(m) do
    try do
      det = matrix_determinant(m)
      if det == 0.0 do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      adj = matrix_adjugate(m)
      throw {:return, matrix_mul_scalar(adj, 1.0 / det)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add_row(m, row) do
    try do
      newData = m.data
      newData = (newData ++ [row])
      throw {:return, %{data: newData, rows: m.rows + 1, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add_column(m, col) do
    try do
      newData = []
      i = 0
      while_fun_15 = fn while_fun_15, i, newData ->
        if i < m.rows do
          newData = (newData ++ [(Enum.at(m.data, i, 0) ++ [Enum.at(col, i, [])])])
          i = i + 1
          while_fun_15.(while_fun_15, i, newData)
        else
          {i, newData}
        end
      end
      {_, newData} = try do
          while_fun_15.(while_fun_15, i, newData)
        catch
          {:break, {_, newData}} -> {0, newData}
        end

      throw {:return, %{data: newData, rows: m.rows, cols: m.cols + 1}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_scalar(m, s) do
    try do
      vals = []
      i = 0
      while_fun_16 = fn while_fun_16, i, vals ->
        if i < m.rows do
          row = []
          j = 0
          while_fun_17 = fn while_fun_17, j, row ->
            if j < m.cols do
              row = (row ++ [Enum.at(Enum.at(m.data, i, 0), j, 0) * s])
              j = j + 1
              while_fun_17.(while_fun_17, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_17.(while_fun_17, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_16.(while_fun_16, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_16.(while_fun_16, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: m.rows, cols: m.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_neg(m) do
    try do
      throw {:return, matrix_mul_scalar(m, -1.0)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add(a, b) do
    try do
      if a.rows != b.rows || a.cols != b.cols do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      vals = []
      i = 0
      while_fun_18 = fn while_fun_18, i, vals ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_19 = fn while_fun_19, j, row ->
            if j < a.cols do
              row = (row ++ [Enum.at(Enum.at(a.data, i, 0), j, 0) + Enum.at(Enum.at(b.data, i, 0), j, 0)])
              j = j + 1
              while_fun_19.(while_fun_19, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_19.(while_fun_19, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_18.(while_fun_18, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_18.(while_fun_18, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: a.rows, cols: a.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_sub(a, b) do
    try do
      if a.rows != b.rows || a.cols != b.cols do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      vals = []
      i = 0
      while_fun_20 = fn while_fun_20, i, vals ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_21 = fn while_fun_21, j, row ->
            if j < a.cols do
              row = (row ++ [Enum.at(Enum.at(a.data, i, 0), j, 0) - Enum.at(Enum.at(b.data, i, 0), j, 0)])
              j = j + 1
              while_fun_21.(while_fun_21, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_21.(while_fun_21, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_20.(while_fun_20, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_20.(while_fun_20, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: a.rows, cols: a.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_dot(row, col) do
    try do
      sum = 0.0
      i = 0
      while_fun_22 = fn while_fun_22, i, sum ->
        if i < _len(row) do
          sum = sum + Enum.at(row, i, []) * Enum.at(col, i, [])
          i = i + 1
          while_fun_22.(while_fun_22, i, sum)
        else
          {i, sum}
        end
      end
      {_, sum} = try do
          while_fun_22.(while_fun_22, i, sum)
        catch
          {:break, {_, sum}} -> {0, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul(a, b) do
    try do
      if a.cols != b.rows do
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      bcols = matrix_columns(b)
      vals = []
      i = 0
      while_fun_23 = fn while_fun_23, i, vals ->
        if i < a.rows do
          row = []
          j = 0
          while_fun_24 = fn while_fun_24, j, row ->
            if j < b.cols do
              row = (row ++ [matrix_dot(Enum.at(a.data, i, 0), Enum.at(bcols, j, []))])
              j = j + 1
              while_fun_24.(while_fun_24, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_24.(while_fun_24, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          vals = (vals ++ [row])
          i = i + 1
          while_fun_23.(while_fun_23, i, vals)
        else
          {i, vals}
        end
      end
      {_, vals} = try do
          while_fun_23.(while_fun_23, i, vals)
        catch
          {:break, {_, vals}} -> {0, vals}
        end

      throw {:return, %{data: vals, rows: a.rows, cols: b.cols}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_pow(m, p) do
    try do
      if p == 0 do
        throw {:return, matrix_identity(m)}
      end
      if p < 0 do
        if matrix_is_invertible(m) do
          throw {:return, matrix_pow(matrix_inverse(m), -p)}
        end
        throw {:return, %{data: [], rows: 0, cols: 0}}
      end
      result = m
      i = 1
      while_fun_25 = fn while_fun_25, i, result ->
        if i < p do
          result = matrix_mul(result, m)
          i = i + 1
          while_fun_25.(while_fun_25, i, result)
        else
          {i, result}
        end
      end
      {_, result} = try do
          while_fun_25.(while_fun_25, i, result)
        catch
          {:break, {_, result}} -> {0, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def matrix_to_string(m) do
    try do
      if m.rows == 0 do
        throw {:return, "[]"}
      end
      s = "["
      i = 0
      while_fun_26 = fn while_fun_26, i, s ->
        if i < m.rows do
          s = (s <> "[")
          j = 0
          while_fun_27 = fn while_fun_27, j, s ->
            if j < m.cols do
              s = (s <> Kernel.to_string(Enum.at(Enum.at(m.data, i, 0), j, 0)))
              s = if j < m.cols - 1 do
                s = (s <> " ")
                s
              else
                s
              end
              j = j + 1
              while_fun_27.(while_fun_27, j, s)
            else
              {j, s}
            end
          end
          {_, s} = try do
              while_fun_27.(while_fun_27, j, s)
            catch
              {:break, {_, s}} -> {0, s}
            end

          s = (s <> "]")
          s = if i < m.rows - 1 do
            s = (s <> "\n ")
            s
          else
            s
          end
          i = i + 1
          while_fun_26.(while_fun_26, i, s)
        else
          {i, s}
        end
      end
      {_, s} = try do
          while_fun_26.(while_fun_26, i, s)
        catch
          {:break, {_, s}} -> {0, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      m = make_matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
      IO.puts(Kernel.inspect(matrix_to_string(m)))
      IO.puts(Kernel.inspect(matrix_columns(m)))
      IO.puts(((Kernel.to_string(m.rows) <> ",") <> Kernel.to_string(m.cols)))
      IO.puts(Kernel.inspect(matrix_is_invertible(m)))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_identity(m))))
      IO.puts(Kernel.inspect(matrix_determinant(m)))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_minors(m))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_cofactors(m))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_adjugate(m))))
      m2 = matrix_mul_scalar(m, 3.0)
      IO.puts(Kernel.inspect(matrix_to_string(m2)))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_add(m, m2))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_sub(m, m2))))
      IO.puts(Kernel.inspect(matrix_to_string(matrix_pow(m, 3))))
      m3 = matrix_add_row(m, [10.0, 11.0, 12.0])
      IO.puts(Kernel.inspect(matrix_to_string(m3)))
      m4 = matrix_add_column(m2, [8.0, 16.0, 32.0])
      IO.puts(Kernel.inspect(matrix_to_string(matrix_mul(m3, m4))))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
