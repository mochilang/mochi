# Code generated by Mochi transpiler 2025-08-12 09:13 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def is_valid_sudoku_board(board) do
    try do
      if _len(board) != Process.get(:num_squares) do
        throw {:return, false}
      end
      i = 0
      while_fun = fn while_fun, i ->
        if i < Process.get(:num_squares) do
          if _len(Enum.at(board, i, [])) != Process.get(:num_squares) do
            throw {:return, false}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      rows = []
      cols = []
      boxes = []
      i = 0
      while_fun_2 = fn while_fun_2, boxes, cols, i, rows ->
        if i < Process.get(:num_squares) do
          rows = (rows ++ [[]])
          cols = (cols ++ [[]])
          boxes = (boxes ++ [[]])
          i = i + 1
          while_fun_2.(while_fun_2, boxes, cols, i, rows)
        else
          {boxes, cols, i, rows}
        end
      end
      {boxes, cols, i, rows} = try do
          while_fun_2.(while_fun_2, boxes, cols, i, rows)
        catch
          {:break, {boxes, cols, i, rows}} -> {boxes, cols, i, rows}
        end

      try do
        for r <- (0..(Process.get(:num_squares) - 1)) do
          try do
            try do
              for c <- (0..(Process.get(:num_squares) - 1)) do
                try do
                  value = Enum.at(Enum.at(board, r, []), c, 0)
                  if value == Process.get(:empty_cell) do
                    throw {:continue, {boxes, cols, rows}}
                  end
                  box = Kernel.trunc(div(r, 3)) * 3 + Kernel.trunc(div(c, 3))
                  if value in Enum.at(rows, r, []) || value in Enum.at(cols, c, []) || value in Enum.at(boxes, box, []) do
                    throw {:return, false}
                  end
                  rows = List.replace_at(rows, r, (Enum.at(rows, r, []) ++ [value]))
                  cols = List.replace_at(cols, c, (Enum.at(cols, c, []) ++ [value]))
                  boxes = List.replace_at(boxes, box, (Enum.at(boxes, box, []) ++ [value]))
                catch
                  :continue -> nil
                end
              end
            catch
              :break -> nil
            end
          catch
            :continue -> nil
          end
        end
      catch
        :break -> nil
      end
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:num_squares, 9)
  Process.put(:empty_cell, ".")
  Process.put(:valid_board, [["5", "3", ".", ".", "7", ".", ".", ".", "."], ["6", ".", ".", "1", "9", "5", ".", ".", "."], [".", "9", "8", ".", ".", ".", ".", "6", "."], ["8", ".", ".", ".", "6", ".", ".", ".", "3"], ["4", ".", ".", "8", ".", "3", ".", ".", "1"], ["7", ".", ".", ".", "2", ".", ".", ".", "6"], [".", "6", ".", ".", ".", ".", "2", "8", "."], [".", ".", ".", "4", "1", "9", ".", ".", "5"], [".", ".", ".", ".", "8", ".", ".", "7", "9"]])
  Process.put(:invalid_board, [["8", "3", ".", ".", "7", ".", ".", ".", "."], ["6", ".", ".", "1", "9", "5", ".", ".", "."], [".", "9", "8", ".", ".", ".", ".", "6", "."], ["8", ".", ".", ".", "6", ".", ".", ".", "3"], ["4", ".", ".", "8", ".", "3", ".", ".", "1"], ["7", ".", ".", ".", "2", ".", ".", ".", "6"], [".", "6", ".", ".", ".", ".", "2", "8", "."], [".", ".", ".", "4", "1", "9", ".", ".", "5"], [".", ".", ".", ".", "8", ".", ".", "7", "9"]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(is_valid_sudoku_board(Process.get(:valid_board))))
    IO.puts(Kernel.inspect(is_valid_sudoku_board(Process.get(:invalid_board))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
