# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def add(matrices) do
    try do
      rows = _len(Enum.at(matrices, 0))
      cols = _len(Enum.at(Enum.at(matrices, 0), 0))
      r = 0
      result = []
      while_fun = fn while_fun, r, result ->
        if r < rows do
          row = []
          c = 0
          while_fun_2 = fn while_fun_2, c, row ->
            if c < cols do
              sum = 0.0
              m = 0
              while_fun_3 = fn while_fun_3, m, sum ->
                if m < _len(matrices) do
                  sum = sum + Enum.at(Enum.at(Enum.at(matrices, m), r), c)
                  m = m + 1
                  while_fun_3.(while_fun_3, m, sum)
                else
                  {m, sum}
                end
              end
              {m, sum} = try do
                  while_fun_3.(while_fun_3, m, sum)
                catch
                  {:break, {m, sum}} -> {m, sum}
                end

              row = (row ++ [sum])
              c = c + 1
              while_fun_2.(while_fun_2, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_2.(while_fun_2, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          result = (result ++ [row])
          r = r + 1
          while_fun.(while_fun, r, result)
        else
          {r, result}
        end
      end
      {r, result} = try do
          while_fun.(while_fun, r, result)
        catch
          {:break, {r, result}} -> {r, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def subtract(a, b) do
    try do
      rows = _len(a)
      cols = _len(Enum.at(a, 0))
      r = 0
      result = []
      while_fun_4 = fn while_fun_4, r, result ->
        if r < rows do
          row = []
          c = 0
          while_fun_5 = fn while_fun_5, c, row ->
            if c < cols do
              row = (row ++ [Enum.at(Enum.at(a, r), c) - Enum.at(Enum.at(b, r), c)])
              c = c + 1
              while_fun_5.(while_fun_5, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_5.(while_fun_5, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          result = (result ++ [row])
          r = r + 1
          while_fun_4.(while_fun_4, r, result)
        else
          {r, result}
        end
      end
      {r, result} = try do
          while_fun_4.(while_fun_4, r, result)
        catch
          {:break, {r, result}} -> {r, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def scalar_multiply(matrix, n) do
    try do
      result = []
      i = 0
      while_fun_6 = fn while_fun_6, i, result ->
        if i < _len(matrix) do
          row = []
          j = 0
          while_fun_7 = fn while_fun_7, j, row ->
            if j < _len(Enum.at(matrix, i)) do
              row = (row ++ [Enum.at(Enum.at(matrix, i), j) * n])
              j = j + 1
              while_fun_7.(while_fun_7, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_7.(while_fun_7, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_6.(while_fun_6, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_6.(while_fun_6, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def multiply(a, b) do
    try do
      rowsA = _len(a)
      colsA = _len(Enum.at(a, 0))
      rowsB = _len(b)
      colsB = _len(Enum.at(b, 0))
      result = []
      i = 0
      while_fun_8 = fn while_fun_8, i, result ->
        if i < rowsA do
          row = []
          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < colsB do
              sum = 0.0
              k = 0
              while_fun_10 = fn while_fun_10, k, sum ->
                if k < colsA do
                  sum = sum + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_10.(while_fun_10, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_10.(while_fun_10, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [sum])
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_8.(while_fun_8, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_8.(while_fun_8, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def identity(n) do
    try do
      result = []
      i = 0
      while_fun_11 = fn while_fun_11, i, result ->
        if i < n do
          row = []
          j = 0
          while_fun_12 = fn while_fun_12, j, row ->
            if j < n do
              row = (if i == j, do: (row ++ [1.0]), else: (row ++ [0.0]))
              j = j + 1
              while_fun_12.(while_fun_12, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_12.(while_fun_12, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_11.(while_fun_11, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_11.(while_fun_11, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def transpose(matrix) do
    try do
      rows = _len(matrix)
      cols = _len(Enum.at(matrix, 0))
      result = []
      c = 0
      while_fun_13 = fn while_fun_13, c, result ->
        if c < cols do
          row = []
          r = 0
          while_fun_14 = fn while_fun_14, r, row ->
            if r < rows do
              row = (row ++ [Enum.at(Enum.at(matrix, r), c)])
              r = r + 1
              while_fun_14.(while_fun_14, r, row)
            else
              {r, row}
            end
          end
          {r, row} = try do
              while_fun_14.(while_fun_14, r, row)
            catch
              {:break, {r, row}} -> {r, row}
            end

          result = (result ++ [row])
          c = c + 1
          while_fun_13.(while_fun_13, c, result)
        else
          {c, result}
        end
      end
      {c, result} = try do
          while_fun_13.(while_fun_13, c, result)
        catch
          {:break, {c, result}} -> {c, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def minor(matrix, row, column) do
    try do
      result = []
      i = 0
      while_fun_15 = fn while_fun_15, i, result ->
        if i < _len(matrix) do
          {result} = if i != row do
            new_row = []
            j = 0
            while_fun_16 = fn while_fun_16, j, new_row ->
              if j < _len(Enum.at(matrix, i)) do
                {new_row} = if j != column do
                  new_row = (new_row ++ [Enum.at(Enum.at(matrix, i), j)])
                  {new_row}
                else
                  {new_row}
                end
                j = j + 1
                while_fun_16.(while_fun_16, j, new_row)
              else
                {j, new_row}
              end
            end
            {j, new_row} = try do
                while_fun_16.(while_fun_16, j, new_row)
              catch
                {:break, {j, new_row}} -> {j, new_row}
              end

            result = (result ++ [new_row])
            {result}
          else
            {result}
          end
          i = i + 1
          while_fun_15.(while_fun_15, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_15.(while_fun_15, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def determinant(matrix) do
    try do
      if _len(matrix) == 1 do
        throw {:return, Enum.at(Enum.at(matrix, 0), 0)}
      end
      det = 0.0
      c = 0
      while_fun_17 = fn while_fun_17, c, det ->
        if c < _len(Enum.at(matrix, 0)) do
          sub = minor(matrix, 0, c)
          sign = (if rem(c, 2) == 0, do: 1.0, else: -1.0)
          det = det + Enum.at(Enum.at(matrix, 0), c) * determinant(sub) * sign
          c = c + 1
          while_fun_17.(while_fun_17, c, det)
        else
          {c, det}
        end
      end
      {c, det} = try do
          while_fun_17.(while_fun_17, c, det)
        catch
          {:break, {c, det}} -> {c, det}
        end

      throw {:return, det}
    catch
      {:return, val} -> val
    end
  end
  def inverse(matrix) do
    try do
      det = determinant(matrix)
      if det == 0.0 do
        throw {:return, []}
      end
      size = _len(matrix)
      matrix_minor = []
      i = 0
      while_fun_18 = fn while_fun_18, i, matrix_minor ->
        if i < size do
          row = []
          j = 0
          while_fun_19 = fn while_fun_19, j, row ->
            if j < size do
              m = minor(matrix, i, j)
              row = (row ++ [determinant(m)])
              j = j + 1
              while_fun_19.(while_fun_19, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_19.(while_fun_19, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          matrix_minor = (matrix_minor ++ [row])
          i = i + 1
          while_fun_18.(while_fun_18, i, matrix_minor)
        else
          {i, matrix_minor}
        end
      end
      {i, matrix_minor} = try do
          while_fun_18.(while_fun_18, i, matrix_minor)
        catch
          {:break, {i, matrix_minor}} -> {i, matrix_minor}
        end

      cofactors = []
      i = 0
      while_fun_20 = fn while_fun_20, cofactors, i ->
        if i < size do
          row = []
          j = 0
          while_fun_21 = fn while_fun_21, j, row ->
            if j < size do
              sign = (if rem((i + j), 2) == 0, do: 1.0, else: -1.0)
              row = (row ++ [Enum.at(Enum.at(matrix_minor, i), j) * sign])
              j = j + 1
              while_fun_21.(while_fun_21, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_21.(while_fun_21, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          cofactors = (cofactors ++ [row])
          i = i + 1
          while_fun_20.(while_fun_20, cofactors, i)
        else
          {cofactors, i}
        end
      end
      {cofactors, i} = try do
          while_fun_20.(while_fun_20, cofactors, i)
        catch
          {:break, {cofactors, i}} -> {cofactors, i}
        end

      adjugate = transpose(cofactors)
      throw {:return, scalar_multiply(adjugate, 1.0 / det)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      matrix_a = [[12.0, 10.0], [3.0, 9.0]]
      matrix_b = [[3.0, 4.0], [7.0, 4.0]]
      matrix_c = [[11.0, 12.0, 13.0, 14.0], [21.0, 22.0, 23.0, 24.0], [31.0, 32.0, 33.0, 34.0], [41.0, 42.0, 43.0, 44.0]]
      matrix_d = [[3.0, 0.0, 2.0], [2.0, 0.0, -2.0], [0.0, 1.0, 1.0]]
      IO.puts((("Add Operation, add(matrix_a, matrix_b) = " <> Kernel.inspect(add([matrix_a, matrix_b]))) <> " \n"))
      IO.puts((("Multiply Operation, multiply(matrix_a, matrix_b) = " <> Kernel.inspect(multiply(matrix_a, matrix_b))) <> " \n"))
      IO.puts((("Identity: " <> Kernel.inspect(identity(5))) <> "\n"))
      IO.puts((((("Minor of " <> Kernel.inspect(matrix_c)) <> " = ") <> Kernel.inspect(minor(matrix_c, 1, 2))) <> " \n"))
      IO.puts((((("Determinant of " <> Kernel.inspect(matrix_b)) <> " = ") <> Kernel.inspect(determinant(matrix_b))) <> " \n"))
      IO.puts((((("Inverse of " <> Kernel.inspect(matrix_d)) <> " = ") <> Kernel.inspect(inverse(matrix_d))) <> "\n"))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
