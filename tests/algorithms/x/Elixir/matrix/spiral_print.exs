# Code generated by Mochi transpiler 2025-08-12 13:41 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def is_valid_matrix(matrix) do
    try do
      if _len(matrix) == 0 do
        throw {:return, false}
      end
      cols = _len(Enum.at(matrix, 0, []))
      Enum.each(matrix, fn row ->
        if _len(row) != cols do
          throw {:return, false}
        end
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def spiral_traversal(matrix) do
    try do
      if !is_valid_matrix(matrix) do
        throw {:return, []}
      end
      rows = _len(matrix)
      cols = _len(Enum.at(matrix, 0, []))
      top = 0
      bottom = rows - 1
      left = 0
      right = cols - 1
      result = []
      while_fun = fn while_fun, bottom, left, result, right, top ->
        if left <= right && top <= bottom do
          i = left
          while_fun_2 = fn while_fun_2, i, result ->
            if i <= right do
              result = (result ++ [Enum.at(Enum.at(matrix, top, []), i, 0)])
              i = i + 1
              while_fun_2.(while_fun_2, i, result)
            else
              {i, result}
            end
          end
          {i, result} = try do
              while_fun_2.(while_fun_2, i, result)
            catch
              {:break, {i, result}} -> {i, result}
            end

          top = top + 1
          i = top
          while_fun_3 = fn while_fun_3, i, result ->
            if i <= bottom do
              result = (result ++ [Enum.at(Enum.at(matrix, i, []), right, 0)])
              i = i + 1
              while_fun_3.(while_fun_3, i, result)
            else
              {i, result}
            end
          end
          {i, result} = try do
              while_fun_3.(while_fun_3, i, result)
            catch
              {:break, {i, result}} -> {i, result}
            end

          right = right - 1
          {bottom, i, result} = if top <= bottom do
            i = right
            while_fun_4 = fn while_fun_4, i, result ->
              if i >= left do
                result = (result ++ [Enum.at(Enum.at(matrix, bottom, []), i, 0)])
                i = i - 1
                while_fun_4.(while_fun_4, i, result)
              else
                {i, result}
              end
            end
            {i, result} = try do
                while_fun_4.(while_fun_4, i, result)
              catch
                {:break, {i, result}} -> {i, result}
              end

            bottom = bottom - 1
            {bottom, i, result}
          else
            {bottom, i, result}
          end
          {i, left, result} = if left <= right do
            i = bottom
            while_fun_5 = fn while_fun_5, i, result ->
              if i >= top do
                result = (result ++ [Enum.at(Enum.at(matrix, i, []), left, 0)])
                i = i - 1
                while_fun_5.(while_fun_5, i, result)
              else
                {i, result}
              end
            end
            {i, result} = try do
                while_fun_5.(while_fun_5, i, result)
              catch
                {:break, {i, result}} -> {i, result}
              end

            left = left + 1
            {i, left, result}
          else
            {i, left, result}
          end
          while_fun.(while_fun, bottom, left, result, right, top)
        else
          {bottom, left, result, right, top}
        end
      end
      {bottom, left, result, right, top} = try do
          while_fun.(while_fun, bottom, left, result, right, top)
        catch
          {:break, {bottom, left, result, right, top}} -> {bottom, left, result, right, top}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def spiral_print_clockwise(matrix) do
    try do
      Enum.each(spiral_traversal(matrix), fn value ->
        IO.puts(Kernel.to_string(value))
      end)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
      spiral_print_clockwise(a)
      IO.puts(Kernel.inspect(spiral_traversal(a)))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
