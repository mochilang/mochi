# Code generated by Mochi transpiler 2025-08-08 17:33 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def make_angle(deg) do
    try do
      if deg < 0.0 || deg > 360.0 do
        raise("degrees must be between 0 and 360")
      end
      throw {:return, %{degrees: deg}}
    catch
      {:return, val} -> val
    end
  end
  def make_side(length, angle) do
    try do
      if length <= 0.0 do
        raise("length must be positive")
      end
      throw {:return, %{length: length, angle: angle, next: -1}}
    catch
      {:return, val} -> val
    end
  end
  def ellipse_area(e) do
    try do
      throw {:return, Process.get(:pi) * e.major * e.minor}
    catch
      {:return, val} -> val
    end
  end
  def ellipse_perimeter(e) do
    try do
      throw {:return, Process.get(:pi) * (e.major + e.minor)}
    catch
      {:return, val} -> val
    end
  end
  def circle_area(c) do
    try do
      e = %{major: c.radius, minor: c.radius}
      area = ellipse_area(e)
      throw {:return, area}
    catch
      {:return, val} -> val
    end
  end
  def circle_perimeter(c) do
    try do
      e = %{major: c.radius, minor: c.radius}
      per = ellipse_perimeter(e)
      throw {:return, per}
    catch
      {:return, val} -> val
    end
  end
  def circle_diameter(c) do
    try do
      throw {:return, c.radius * 2.0}
    catch
      {:return, val} -> val
    end
  end
  def circle_max_parts(num_cuts) do
    try do
      if num_cuts < 0.0 do
        raise("num_cuts must be positive")
      end
      throw {:return, (num_cuts + 2.0 + num_cuts * num_cuts) * 0.5}
    catch
      {:return, val} -> val
    end
  end
  def make_polygon() do
    try do
      s = []
      throw {:return, %{sides: s}}
    catch
      {:return, val} -> val
    end
  end
  def polygon_add_side(p, s) do
    try do
      p = Map.put(p, :sides, (p.sides ++ [s]))
    catch
      {:return, val} -> val
    end
  end
  def polygon_get_side(p, index) do
    try do
      throw {:return, Enum.at(p.sides, index)}
    catch
      {:return, val} -> val
    end
  end
  def polygon_set_side(p, index, s) do
    try do
      tmp = p.sides
      tmp = List.replace_at(tmp, index, s)
      p = Map.put(p, :sides, tmp)
    catch
      {:return, val} -> val
    end
  end
  def make_rectangle(short_len, long_len) do
    try do
      if short_len <= 0.0 || long_len <= 0.0 do
        raise("length must be positive")
      end
      short = make_side(short_len, make_angle(90.0))
      long = make_side(long_len, make_angle(90.0))
      p = make_polygon()
      polygon_add_side(p, short)
      polygon_add_side(p, long)
      throw {:return, %{short_side: short, long_side: long, poly: p}}
    catch
      {:return, val} -> val
    end
  end
  def rectangle_perimeter(r) do
    try do
      throw {:return, (r.short_side.length + r.long_side.length) * 2.0}
    catch
      {:return, val} -> val
    end
  end
  def rectangle_area(r) do
    try do
      throw {:return, r.short_side.length * r.long_side.length}
    catch
      {:return, val} -> val
    end
  end
  def make_square(side_len) do
    try do
      rect = make_rectangle(side_len, side_len)
      throw {:return, %{side: rect.short_side, rect: rect}}
    catch
      {:return, val} -> val
    end
  end
  def square_perimeter(s) do
    try do
      p = rectangle_perimeter(s.rect)
      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def square_area(s) do
    try do
      a = rectangle_area(s.rect)
      throw {:return, a}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      a = make_angle(90.0)
      IO.puts(a.degrees)
      s = make_side(5.0, a)
      IO.puts(s.length)
      e = %{major: 5.0, minor: 10.0}
      IO.puts(Kernel.inspect(ellipse_area(e)))
      IO.puts(Kernel.inspect(ellipse_perimeter(e)))
      c = %{radius: 5.0}
      IO.puts(Kernel.inspect(circle_area(c)))
      IO.puts(Kernel.inspect(circle_perimeter(c)))
      IO.puts(Kernel.inspect(circle_diameter(c)))
      IO.puts(Kernel.inspect(circle_max_parts(7.0)))
      r = make_rectangle(5.0, 10.0)
      IO.puts(Kernel.inspect(rectangle_perimeter(r)))
      IO.puts(Kernel.inspect(rectangle_area(r)))
      q = make_square(5.0)
      IO.puts(Kernel.inspect(square_perimeter(q)))
      IO.puts(Kernel.inspect(square_area(q)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  def bench_main() do
    Process.put(:pi, 3.141592653589793)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
