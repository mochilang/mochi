# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_process(name, arrival, burst) do
    try do
      throw {:return, %{process_name: name, arrival_time: arrival, stop_time: arrival, burst_time: burst, waiting_time: 0, turnaround_time: 0}}
    catch
      {:return, val} -> val
    end
  end
  def make_mlfq(nqueues, time_slices, queue, current_time) do
    try do
      throw {:return, %{number_of_queues: nqueues, time_slices: time_slices, ready_queue: queue, current_time: current_time, finish_queue: []}}
    catch
      {:return, val} -> val
    end
  end
  def calculate_sequence_of_finish_queue(mlfq) do
    try do
      seq = []
      i = 0
      while_fun = fn while_fun, i, seq ->
        if i < _len(Map.get(mlfq, :finish_queue, [])) do
          p = Enum.at(mlfq.finish_queue, i, 0)
          seq = (seq ++ [p.process_name])
          i = i + 1
          while_fun.(while_fun, i, seq)
        else
          {i, seq}
        end
      end
      {_, seq} = try do
          while_fun.(while_fun, i, seq)
        catch
          {:break, {_, seq}} -> {0, seq}
        end

      throw {:return, seq}
    catch
      {:return, val} -> val
    end
  end
  def calculate_waiting_time(queue) do
    try do
      times = []
      i = 0
      while_fun_2 = fn while_fun_2, i, times ->
        if i < _len(queue) do
          p = Enum.at(queue, i, [])
          times = (times ++ [p.waiting_time])
          i = i + 1
          while_fun_2.(while_fun_2, i, times)
        else
          {i, times}
        end
      end
      {_, times} = try do
          while_fun_2.(while_fun_2, i, times)
        catch
          {:break, {_, times}} -> {0, times}
        end

      throw {:return, times}
    catch
      {:return, val} -> val
    end
  end
  def calculate_turnaround_time(queue) do
    try do
      times = []
      i = 0
      while_fun_3 = fn while_fun_3, i, times ->
        if i < _len(queue) do
          p = Enum.at(queue, i, [])
          times = (times ++ [p.turnaround_time])
          i = i + 1
          while_fun_3.(while_fun_3, i, times)
        else
          {i, times}
        end
      end
      {_, times} = try do
          while_fun_3.(while_fun_3, i, times)
        catch
          {:break, {_, times}} -> {0, times}
        end

      throw {:return, times}
    catch
      {:return, val} -> val
    end
  end
  def calculate_completion_time(queue) do
    try do
      times = []
      i = 0
      while_fun_4 = fn while_fun_4, i, times ->
        if i < _len(queue) do
          p = Enum.at(queue, i, [])
          times = (times ++ [p.stop_time])
          i = i + 1
          while_fun_4.(while_fun_4, i, times)
        else
          {i, times}
        end
      end
      {_, times} = try do
          while_fun_4.(while_fun_4, i, times)
        catch
          {:break, {_, times}} -> {0, times}
        end

      throw {:return, times}
    catch
      {:return, val} -> val
    end
  end
  def calculate_remaining_burst_time_of_processes(queue) do
    try do
      times = []
      i = 0
      while_fun_5 = fn while_fun_5, i, times ->
        if i < _len(queue) do
          p = Enum.at(queue, i, [])
          times = (times ++ [p.burst_time])
          i = i + 1
          while_fun_5.(while_fun_5, i, times)
        else
          {i, times}
        end
      end
      {_, times} = try do
          while_fun_5.(while_fun_5, i, times)
        catch
          {:break, {_, times}} -> {0, times}
        end

      throw {:return, times}
    catch
      {:return, val} -> val
    end
  end
  def update_waiting_time(mlfq, process) do
    try do
      process = Map.put(process, :waiting_time, process.waiting_time + (mlfq.current_time - process.stop_time))
      throw {:return, process.waiting_time}
    catch
      {:return, val} -> val
    end
  end
  def first_come_first_served(mlfq, ready_queue) do
    try do
      finished = []
      rq = ready_queue
      while_fun_6 = fn while_fun_6, finished, rq ->
        if _len(rq) != 0 do
          cp = Enum.at(rq, 0, [])
          rq = _slice(rq, 1, _len(rq) - (1))
          if mlfq.current_time < cp.arrival_time do
            mlfq = Map.put(mlfq, :current_time, cp.arrival_time)
          end
          update_waiting_time(mlfq, cp)
          mlfq = Map.put(mlfq, :current_time, mlfq.current_time + cp.burst_time)
          cp = Map.put(cp, :burst_time, 0)
          cp = Map.put(cp, :turnaround_time, mlfq.current_time - cp.arrival_time)
          cp = Map.put(cp, :stop_time, mlfq.current_time)
          finished = (finished ++ [cp])
          while_fun_6.(while_fun_6, finished, rq)
        else
          {finished, rq}
        end
      end
      {finished, rq} = try do
          while_fun_6.(while_fun_6, finished, rq)
        catch
          {:break, {finished, rq}} -> {finished, rq}
        end

      mlfq = Map.put(mlfq, :finish_queue, (mlfq.finish_queue ++ finished))
      throw {:return, finished}
    catch
      {:return, val} -> val
    end
  end
  def round_robin(mlfq, ready_queue, time_slice) do
    try do
      finished = []
      rq = ready_queue
      count = _len(rq)
      i = 0
      while_fun_7 = fn while_fun_7, finished, i, rq ->
        if i < count do
          cp = Enum.at(rq, 0, [])
          rq = _slice(rq, 1, _len(rq) - (1))
          if mlfq.current_time < cp.arrival_time do
            mlfq = Map.put(mlfq, :current_time, cp.arrival_time)
          end
          update_waiting_time(mlfq, cp)
          {cp, finished, rq} = if cp.burst_time > time_slice do
            mlfq = Map.put(mlfq, :current_time, mlfq.current_time + time_slice)
            cp = Map.put(cp, :burst_time, cp.burst_time - time_slice)
            cp = Map.put(cp, :stop_time, mlfq.current_time)
            rq = (rq ++ [cp])
            {cp, finished, rq}
          else
            mlfq = Map.put(mlfq, :current_time, mlfq.current_time + cp.burst_time)
            cp = Map.put(cp, :burst_time, 0)
            cp = Map.put(cp, :stop_time, mlfq.current_time)
            cp = Map.put(cp, :turnaround_time, mlfq.current_time - cp.arrival_time)
            finished = (finished ++ [cp])
            {cp, finished, rq}
          end
          i = i + 1
          while_fun_7.(while_fun_7, finished, i, rq)
        else
          {finished, i, rq}
        end
      end
      {finished, _, rq} = try do
          while_fun_7.(while_fun_7, finished, i, rq)
        catch
          {:break, {finished, _, rq}} -> {finished, 0, rq}
        end

      mlfq = Map.put(mlfq, :finish_queue, (mlfq.finish_queue ++ finished))
      throw {:return, %{finished: finished, ready: rq}}
    catch
      {:return, val} -> val
    end
  end
  def multi_level_feedback_queue(mlfq) do
    try do
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < mlfq.number_of_queues - 1 do
          rr = round_robin(mlfq, mlfq.ready_queue, Enum.at(mlfq.time_slices, i, 0))
          mlfq = Map.put(mlfq, :ready_queue, rr.ready)
          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      _ = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {_}} -> 0
        end

      first_come_first_served(mlfq, mlfq.ready_queue)
      throw {:return, mlfq.finish_queue}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:number_of_queues, 3)
  Process.put(:time_slices, [17, 25])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:p1, make_process("P1", 0, 53))
    Process.put(:p2, make_process("P2", 0, 17))
    Process.put(:p3, make_process("P3", 0, 68))
    Process.put(:p4, make_process("P4", 0, 24))
    Process.put(:queue, [Process.get(:p1), Process.get(:p2), Process.get(:p3), Process.get(:p4)])
    Process.put(:mlfq, make_mlfq(Process.get(:number_of_queues), Process.get(:time_slices), Process.get(:queue), 0))
    Process.put(:finish_queue, multi_level_feedback_queue(Process.get(:mlfq)))
    IO.puts(("waiting time:\t\t\t" <> Kernel.inspect(calculate_waiting_time([Process.get(:p1), Process.get(:p2), Process.get(:p3), Process.get(:p4)]))))
    IO.puts(("completion time:\t\t" <> Kernel.inspect(calculate_completion_time([Process.get(:p1), Process.get(:p2), Process.get(:p3), Process.get(:p4)]))))
    IO.puts(("turnaround time:\t\t" <> Kernel.inspect(calculate_turnaround_time([Process.get(:p1), Process.get(:p2), Process.get(:p3), Process.get(:p4)]))))
    IO.puts(("sequence of finished processes:\t" <> Kernel.inspect(calculate_sequence_of_finish_queue(Process.get(:mlfq)))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
