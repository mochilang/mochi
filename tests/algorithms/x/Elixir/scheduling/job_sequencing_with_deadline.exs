# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sort_jobs_by_profit(jobs) do
    try do
      js = jobs
      i = 0
      while_fun = fn while_fun, i, js ->
        if i < _len(js) do
          j = 0
          while_fun_2 = fn while_fun_2, j, js ->
            if j < _len(js) - i - 1 do
              a = Enum.at(js, j, [])
              b = Enum.at(js, j + 1, [])
              js = if a.profit < b.profit do
                js = List.replace_at(js, j, b)
                js = List.replace_at(js, j + 1, a)
                js
              else
                js
              end
              j = j + 1
              while_fun_2.(while_fun_2, j, js)
            else
              {j, js}
            end
          end
          {_, js} = try do
              while_fun_2.(while_fun_2, j, js)
            catch
              {:break, {_, js}} -> {0, js}
            end

          i = i + 1
          while_fun.(while_fun, i, js)
        else
          {i, js}
        end
      end
      {_, js} = try do
          while_fun.(while_fun, i, js)
        catch
          {:break, {_, js}} -> {0, js}
        end

      throw {:return, js}
    catch
      {:return, val} -> val
    end
  end
  def max_deadline(jobs) do
    try do
      max_d = 0
      i = 0
      while_fun_3 = fn while_fun_3, i, max_d ->
        if i < _len(jobs) do
          job = Enum.at(jobs, i, [])
          d = job.deadline
          max_d = if d > max_d do
            max_d = d
            max_d
          else
            max_d
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, max_d)
        else
          {i, max_d}
        end
      end
      {_, max_d} = try do
          while_fun_3.(while_fun_3, i, max_d)
        catch
          {:break, {_, max_d}} -> {0, max_d}
        end

      throw {:return, max_d}
    catch
      {:return, val} -> val
    end
  end
  def job_sequencing_with_deadlines(jobs) do
    try do
      js = sort_jobs_by_profit(jobs)
      max_d = max_deadline(js)
      time_slots = []
      t = 0
      while_fun_4 = fn while_fun_4, t, time_slots ->
        if t < max_d do
          time_slots = (time_slots ++ [0 - 1])
          t = t + 1
          while_fun_4.(while_fun_4, t, time_slots)
        else
          {t, time_slots}
        end
      end
      {t, time_slots} = try do
          while_fun_4.(while_fun_4, t, time_slots)
        catch
          {:break, {t, time_slots}} -> {t, time_slots}
        end

      count = 0
      max_profit = 0
      i = 0
      while_fun_5 = fn while_fun_5, count, i, max_profit, time_slots ->
        if i < _len(js) do
          job = Enum.at(js, i, [])
          j = job.deadline - 1
          while_fun_6 = fn while_fun_6, count, j, max_profit, time_slots ->
            if j >= 0 do
              {count, max_profit, time_slots} = if Enum.at(time_slots, j, []) == 0 - 1 do
                time_slots = List.replace_at(time_slots, j, job.id)
                count = count + 1
                max_profit = max_profit + job.profit
                throw {:break, {count, j, max_profit, time_slots}}
                {count, max_profit, time_slots}
              else
                {count, max_profit, time_slots}
              end
              j = j - 1
              while_fun_6.(while_fun_6, count, j, max_profit, time_slots)
            else
              {count, j, max_profit, time_slots}
            end
          end
          {count, _, max_profit, time_slots} = try do
              while_fun_6.(while_fun_6, count, j, max_profit, time_slots)
            catch
              {:break, {count, _, max_profit, time_slots}} -> {count, 0, max_profit, time_slots}
            end

          i = i + 1
          while_fun_5.(while_fun_5, count, i, max_profit, time_slots)
        else
          {count, i, max_profit, time_slots}
        end
      end
      {count, _, max_profit, time_slots} = try do
          while_fun_5.(while_fun_5, count, i, max_profit, time_slots)
        catch
          {:break, {count, _, max_profit, time_slots}} -> {count, 0, max_profit, time_slots}
        end

      result = []
      result = (result ++ [count])
      result = (result ++ [max_profit])
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:jobs1, [])
  Process.put(:jobs2, [])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:jobs1, (Process.get(:jobs1) ++ [%{id: 1, deadline: 4, profit: 20}]))
    Process.put(:jobs1, (Process.get(:jobs1) ++ [%{id: 2, deadline: 1, profit: 10}]))
    Process.put(:jobs1, (Process.get(:jobs1) ++ [%{id: 3, deadline: 1, profit: 40}]))
    Process.put(:jobs1, (Process.get(:jobs1) ++ [%{id: 4, deadline: 1, profit: 30}]))
    IO.puts(Kernel.inspect(job_sequencing_with_deadlines(Process.get(:jobs1))))
    Process.put(:jobs2, (Process.get(:jobs2) ++ [%{id: 1, deadline: 2, profit: 100}]))
    Process.put(:jobs2, (Process.get(:jobs2) ++ [%{id: 2, deadline: 1, profit: 19}]))
    Process.put(:jobs2, (Process.get(:jobs2) ++ [%{id: 3, deadline: 2, profit: 27}]))
    Process.put(:jobs2, (Process.get(:jobs2) ++ [%{id: 4, deadline: 1, profit: 25}]))
    Process.put(:jobs2, (Process.get(:jobs2) ++ [%{id: 5, deadline: 1, profit: 15}]))
    IO.puts(Kernel.inspect(job_sequencing_with_deadlines(Process.get(:jobs2))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
