# Code generated by Mochi transpiler 2025-08-22 15:25 +0700
defmodule Main do
  @data_dir "/workspace/mochi/tests/github/TheAlgorithms/Mochi/project_euler/problem_042"
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _ord(s) do
    case String.to_charlist(s) do
      [c | _] -> c
      _ -> 0
    end
  end
  defp _read_file(path) do
    p = if @data_dir != nil and @data_dir != "" and not File.exists?(path) do
      Path.join(@data_dir, path)
    else
      path
    end
    case File.read(p) do
      {:ok, data} -> data
      _ -> ""
    end
  end
  def triangular_numbers(limit) do
    try do
      res = []
      n = 1
      while_fun = fn while_fun, n, res ->
        if n <= limit do
          res = (res ++ [div((n * (n + 1)), 2)])
          n = n + 1
          while_fun.(while_fun, n, res)
        else
          {n, res}
        end
      end
      {_, res} = try do
          while_fun.(while_fun, n, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def parse_words(text) do
    try do
      words = []
      current = ""
      i = 0
      while_fun_2 = fn while_fun_2, current, i, words ->
        if i < _len(text) do
          c = _slice(text, i, (i + 1) - i)
          {current, words} = if c == "," do
            words = (words ++ [current])
            current = ""
            {current, words}
          else
            current = if c == "\"" do
              current
            else
              current = if c == "\r" || c == "\n" do
                current
              else
                current = (current <> c)
                current
              end
              current
            end
            {current, words}
          end
          i = i + 1
          while_fun_2.(while_fun_2, current, i, words)
        else
          {current, i, words}
        end
      end
      {current, _, words} = try do
          while_fun_2.(while_fun_2, current, i, words)
        catch
          {:break, {current, _, words}} -> {current, 0, words}
        end

      words = if _len(current) > 0 do
        words = (words ++ [current])
        words
      else
        words
      end
      throw {:return, words}
    catch
      {:return, val} -> val
    end
  end
  def word_value(word) do
    try do
      total = 0
      i = 0
      while_fun_3 = fn while_fun_3, i, total ->
        if i < _len(word) do
          total = total + _ord(_slice(word, i, (i + 1) - i)) - 64
          i = i + 1
          while_fun_3.(while_fun_3, i, total)
        else
          {i, total}
        end
      end
      {_, total} = try do
          while_fun_3.(while_fun_3, i, total)
        catch
          {:break, {_, total}} -> {0, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def contains(xs, target) do
    try do
      Enum.each(xs, fn x ->
        if x == target do
          throw {:return, true}
        end
      end)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def solution() do
    try do
      text = _read_file("words.txt")
      words = parse_words(text)
      tri = triangular_numbers(100)
      count = 0
      {count} = Enum.reduce(words, {count}, fn w, {count} ->
        v = word_value(w)
        count = if contains(tri, v) do
          count = count + 1
          count
        else
          count
        end
        {count}
      end)
      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(solution()))
  end
end
Main.main()
