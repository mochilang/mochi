# Code generated by Mochi transpiler 2025-08-16 12:46 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def is_leap(year) do
    try do
      throw {:return, ((if (rem(year, 4) == 0 && rem(year, 100) != 0) || (rem(year, 400) == 0), do: true, else: false))}
    catch
      {:return, val} -> val
    end
  end
  def count_sundays() do
    try do
      days_per_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      day = 6
      month = 1
      year = 1901
      sundays = 0
      while_fun = fn while_fun, day, month, sundays, year ->
        if year < 2001 do
          day = day + 7
          {day, month} = if is_leap(year) do
            {day, month} = if day > Enum.at(days_per_month, month - 1, []) && month != 2 do
              month = month + 1
              day = day - Enum.at(days_per_month, month - 2, [])
              {day, month}
            else
              {day, month} = if day > 29 && month == 2 do
                month = month + 1
                day = day - 29
                {day, month}
              else
                {day, month}
              end
              {day, month}
            end
            {day, month}
          else
            {day, month} = if day > Enum.at(days_per_month, month - 1, []) do
              month = month + 1
              day = day - Enum.at(days_per_month, month - 2, [])
              {day, month}
            else
              {day, month}
            end
            {day, month}
          end
          {month, year} = if month > 12 do
            year = year + 1
            month = 1
            {month, year}
          else
            {month, year}
          end
          sundays = if year < 2001 && day == 1 do
            sundays = sundays + 1
            sundays
          else
            sundays
          end
          while_fun.(while_fun, day, month, sundays, year)
        else
          {day, month, sundays, year}
        end
      end
      {day, month, sundays, year} = try do
          while_fun.(while_fun, day, month, sundays, year)
        catch
          {:break, {day, month, sundays, year}} -> {day, month, sundays, year}
        end

      throw {:return, sundays}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(count_sundays()))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
