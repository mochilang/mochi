# Code generated by Mochi transpiler 2025-08-12 12:29 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def contains(xs, value) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == value do
            throw {:return, true}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def solution(n) do
    try do
      zmulti = []
      xmulti = []
      temp = 1
      while_fun_2 = fn while_fun_2, temp, zmulti ->
        if true do
          result = 3 * temp
          {temp, zmulti} = if result < n do
            zmulti = (zmulti ++ [result])
            temp = temp + 1
            {temp, zmulti}
          else
            throw {:break, {temp, zmulti}}
            {temp, zmulti}
          end
          while_fun_2.(while_fun_2, temp, zmulti)
        else
          {temp, zmulti}
        end
      end
      {temp, zmulti} = try do
          while_fun_2.(while_fun_2, temp, zmulti)
        catch
          {:break, {temp, zmulti}} -> {temp, zmulti}
        end

      temp = 1
      while_fun_3 = fn while_fun_3, temp, xmulti ->
        if true do
          result = 5 * temp
          {temp, xmulti} = if result < n do
            xmulti = (xmulti ++ [result])
            temp = temp + 1
            {temp, xmulti}
          else
            throw {:break, {temp, xmulti}}
            {temp, xmulti}
          end
          while_fun_3.(while_fun_3, temp, xmulti)
        else
          {temp, xmulti}
        end
      end
      {temp, xmulti} = try do
          while_fun_3.(while_fun_3, temp, xmulti)
        catch
          {:break, {temp, xmulti}} -> {temp, xmulti}
        end

      collection = []
      i = 0
      while_fun_4 = fn while_fun_4, collection, i ->
        if i < _len(zmulti) do
          v = Enum.at(zmulti, i, [])
          {collection} = if !contains(collection, v) do
            collection = (collection ++ [v])
            {collection}
          else
            {collection}
          end
          i = i + 1
          while_fun_4.(while_fun_4, collection, i)
        else
          {collection, i}
        end
      end
      {collection, i} = try do
          while_fun_4.(while_fun_4, collection, i)
        catch
          {:break, {collection, i}} -> {collection, i}
        end

      i = 0
      while_fun_5 = fn while_fun_5, collection, i ->
        if i < _len(xmulti) do
          v = Enum.at(xmulti, i, [])
          {collection} = if !contains(collection, v) do
            collection = (collection ++ [v])
            {collection}
          else
            {collection}
          end
          i = i + 1
          while_fun_5.(while_fun_5, collection, i)
        else
          {collection, i}
        end
      end
      {collection, i} = try do
          while_fun_5.(while_fun_5, collection, i)
        catch
          {:break, {collection, i}} -> {collection, i}
        end

      total = 0
      i = 0
      while_fun_6 = fn while_fun_6, i, total ->
        if i < _len(collection) do
          total = total + Enum.at(collection, i, [])
          i = i + 1
          while_fun_6.(while_fun_6, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_6.(while_fun_6, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def test_solution() do
    try do
      if solution(3) != 0 do
        raise("solution(3) failed")
      end
      if solution(4) != 3 do
        raise("solution(4) failed")
      end
      if solution(10) != 23 do
        raise("solution(10) failed")
      end
      if solution(600) != 83700 do
        raise("solution(600) failed")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_solution()
      IO.puts(("solution() = " <> Kernel.inspect(solution(1000))))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
