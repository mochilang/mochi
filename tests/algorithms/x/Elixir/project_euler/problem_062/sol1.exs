# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_digits(num) do
    try do
      cube = num * num * num
      s = Kernel.to_string(cube)
      counts = []
      j = 0
      while_fun = fn while_fun, counts, j ->
        if j < 10 do
          counts = (counts ++ [0])
          j = j + 1
          while_fun.(while_fun, counts, j)
        else
          {counts, j}
        end
      end
      {counts, _} = try do
          while_fun.(while_fun, counts, j)
        catch
          {:break, {counts, _}} -> {counts, 0}
        end

      i = 0
      while_fun_2 = fn while_fun_2, counts, i ->
        if i < _len(s) do
          d = String.to_integer(String.at(s, i))
          counts = List.replace_at(counts, d, Enum.at(counts, d, []) + 1)
          i = i + 1
          while_fun_2.(while_fun_2, counts, i)
        else
          {counts, i}
        end
      end
      {counts, _} = try do
          while_fun_2.(while_fun_2, counts, i)
        catch
          {:break, {counts, _}} -> {counts, 0}
        end

      result = ""
      d = 0
      while_fun_3 = fn while_fun_3, d, result ->
        if d < 10 do
          c = Enum.at(counts, d, [])
          while_fun_4 = fn while_fun_4, c, result ->
            if c > 0 do
              result = (result <> Kernel.to_string(d))
              c = c - 1
              while_fun_4.(while_fun_4, c, result)
            else
              {c, result}
            end
          end
          {c, result} = try do
              while_fun_4.(while_fun_4, c, result)
            catch
              {:break, {c, result}} -> {c, result}
            end

          d = d + 1
          while_fun_3.(while_fun_3, d, result)
        else
          {d, result}
        end
      end
      {d, result} = try do
          while_fun_3.(while_fun_3, d, result)
        catch
          {:break, {d, result}} -> {d, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def solution(max_base) do
    try do
      freqs = %{}
      num = 0
      while_fun_5 = fn while_fun_5, freqs, num ->
        if true do
          digits = get_digits(num)
          arr = []
          arr = if Map.has_key?(freqs, digits) do
            arr = freqs[digits]
            arr
          else
            arr
          end
          arr = (arr ++ [num])
          freqs = Map.put(freqs, digits, arr)
          if _len(arr) == max_base do
            base = Enum.at(arr, 0, [])
            throw {:return, base * base * base}
          end
          num = num + 1
          while_fun_5.(while_fun_5, freqs, num)
        else
          {freqs, num}
        end
      end
      {freqs, num} = try do
          while_fun_5.(while_fun_5, freqs, num)
        catch
          {:break, {freqs, num}} -> {freqs, num}
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(("solution() = " <> Kernel.inspect(solution(5))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
