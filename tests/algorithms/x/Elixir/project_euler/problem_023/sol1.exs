# Code generated by Mochi transpiler 2025-08-16 12:46 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def int_sqrt(n) do
    try do
      x = 1
      while_fun = fn while_fun, x ->
        if (x + 1) * (x + 1) <= n do
          x = x + 1
          while_fun.(while_fun, x)
        else
          x
        end
      end
      x = try do
          while_fun.(while_fun, x)
        catch
          {:break, {x}} -> x
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def solution(limit) do
    try do
      sum_divs = []
      i = 0
      while_fun_2 = fn while_fun_2, i, sum_divs ->
        if i <= limit do
          sum_divs = (sum_divs ++ [1])
          i = i + 1
          while_fun_2.(while_fun_2, i, sum_divs)
        else
          {i, sum_divs}
        end
      end
      {_, sum_divs} = try do
          while_fun_2.(while_fun_2, i, sum_divs)
        catch
          {:break, {_, sum_divs}} -> {0, sum_divs}
        end

      sqrt_limit = int_sqrt(limit)
      i = 2
      while_fun_3 = fn while_fun_3, i, sum_divs ->
        if i <= sqrt_limit do
          sum_divs = List.replace_at(sum_divs, i * i, Enum.at(sum_divs, i * i, []) + i)
          k = i + 1
          while_fun_4 = fn while_fun_4, k, sum_divs ->
            if k <= div(limit, i) do
              sum_divs = List.replace_at(sum_divs, k * i, Enum.at(sum_divs, k * i, []) + k + i)
              k = k + 1
              while_fun_4.(while_fun_4, k, sum_divs)
            else
              {k, sum_divs}
            end
          end
          {_, sum_divs} = try do
              while_fun_4.(while_fun_4, k, sum_divs)
            catch
              {:break, {_, sum_divs}} -> {0, sum_divs}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, sum_divs)
        else
          {i, sum_divs}
        end
      end
      {_, sum_divs} = try do
          while_fun_3.(while_fun_3, i, sum_divs)
        catch
          {:break, {_, sum_divs}} -> {0, sum_divs}
        end

      is_abundant = []
      i = 0
      while_fun_5 = fn while_fun_5, i, is_abundant ->
        if i <= limit do
          is_abundant = (is_abundant ++ [false])
          i = i + 1
          while_fun_5.(while_fun_5, i, is_abundant)
        else
          {i, is_abundant}
        end
      end
      {_, is_abundant} = try do
          while_fun_5.(while_fun_5, i, is_abundant)
        catch
          {:break, {_, is_abundant}} -> {0, is_abundant}
        end

      abundants = []
      res = 0
      n = 1
      while_fun_6 = fn while_fun_6, abundants, is_abundant, n, res ->
        if n <= limit do
          {abundants, is_abundant} = if Enum.at(sum_divs, n, []) > n do
            abundants = (abundants ++ [n])
            is_abundant = List.replace_at(is_abundant, n, true)
            {abundants, is_abundant}
          else
            {abundants, is_abundant}
          end
          has_pair = false
          j = 0
          while_fun_7 = fn while_fun_7, has_pair, j ->
            if j < _len(abundants) do
              a = Enum.at(abundants, j, [])
              if a > n do
                throw {:break, {has_pair, j}}
              end
              b = n - a
              has_pair = if b <= limit && Enum.at(is_abundant, b, []) do
                has_pair = true
                throw {:break, {has_pair, j}}
                has_pair
              else
                has_pair
              end
              j = j + 1
              while_fun_7.(while_fun_7, has_pair, j)
            else
              {has_pair, j}
            end
          end
          {has_pair, _} = try do
              while_fun_7.(while_fun_7, has_pair, j)
            catch
              {:break, {has_pair, _}} -> {has_pair, 0}
            end

          res = if !has_pair do
            res = res + n
            res
          else
            res
          end
          n = n + 1
          while_fun_6.(while_fun_6, abundants, is_abundant, n, res)
        else
          {abundants, is_abundant, n, res}
        end
      end
      {abundants, is_abundant, n, res} = try do
          while_fun_6.(while_fun_6, abundants, is_abundant, n, res)
        catch
          {:break, {abundants, is_abundant, n, res}} -> {abundants, is_abundant, n, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(solution(28123)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
