# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def parse_int(s) do
    try do
      value = 0
      i = 0
      while_fun = fn while_fun, i, value ->
        if i < _len(s) do
          c = String.at(s, i)
          value = value * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(c))
          i = i + 1
          while_fun.(while_fun, i, value)
        else
          {i, value}
        end
      end
      {_, value} = try do
          while_fun.(while_fun, i, value)
        catch
          {:break, {_, value}} -> {0, value}
        end

      throw {:return, value}
    catch
      {:return, val} -> val
    end
  end
  def join(xs) do
    try do
      s = ""
      i = 0
      while_fun_2 = fn while_fun_2, i, s ->
        if i < _len(xs) do
          s = (s <> Enum.at(xs, i, []))
          i = i + 1
          while_fun_2.(while_fun_2, i, s)
        else
          {i, s}
        end
      end
      {_, s} = try do
          while_fun_2.(while_fun_2, i, s)
        catch
          {:break, {_, s}} -> {0, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def contains(xs, c) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == c do
            throw {:return, true}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      _ = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def index_of(xs, c) do
    try do
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == c do
            throw {:return, i}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      _ = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def remove_at(xs, idx) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(xs) do
          res = if i != idx do
            res = (res ++ [Enum.at(xs, i, [])])
            res
          else
            res
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def unique_chars(logins) do
    try do
      chars = []
      i = 0
      while_fun_6 = fn while_fun_6, chars, i ->
        if i < _len(logins) do
          login = Enum.at(logins, i, [])
          j = 0
          while_fun_7 = fn while_fun_7, chars, j ->
            if j < _len(login) do
              c = String.at(login, j)
              chars = if !contains(chars, c) do
                chars = (chars ++ [c])
                chars
              else
                chars
              end
              j = j + 1
              while_fun_7.(while_fun_7, chars, j)
            else
              {chars, j}
            end
          end
          {chars, _} = try do
              while_fun_7.(while_fun_7, chars, j)
            catch
              {:break, {chars, _}} -> {chars, 0}
            end

          i = i + 1
          while_fun_6.(while_fun_6, chars, i)
        else
          {chars, i}
        end
      end
      {chars, _} = try do
          while_fun_6.(while_fun_6, chars, i)
        catch
          {:break, {chars, _}} -> {chars, 0}
        end

      throw {:return, chars}
    catch
      {:return, val} -> val
    end
  end
  def satisfies(permutation, logins) do
    try do
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < _len(logins) do
          login = Enum.at(logins, i, [])
          i0 = index_of(permutation, String.at(login, 0))
          i1 = index_of(permutation, String.at(login, 1))
          i2 = index_of(permutation, String.at(login, 2))
          if !(i0 < i1 && i1 < i2) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      _ = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def search(chars, current, logins) do
    try do
      if _len(chars) == 0 do
        if satisfies(current, logins) do
          throw {:return, join(current)}
        end
        throw {:return, ""}
      end
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < _len(chars) do
          c = Enum.at(chars, i, [])
          rest = remove_at(chars, i)
          next = (current ++ [c])
          res = search(rest, next, logins)
          if res != "" do
            throw {:return, res}
          end
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      _ = try do
          while_fun_9.(while_fun_9, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, ""}
    catch
      {:return, val} -> val
    end
  end
  def find_secret_passcode(logins) do
    try do
      chars = unique_chars(logins)
      s = search(chars, [], logins)
      if s == "" do
        throw {:return, -1}
      end
      throw {:return, parse_int(s)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:logins1, ["135", "259", "235", "189", "690", "168", "120", "136", "289", "589", "160", "165", "580", "369", "250", "280"])
  Process.put(:logins2, ["426", "281", "061", "819", "268", "406", "420", "428", "209", "689", "019", "421", "469", "261", "681", "201"])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(find_secret_passcode(Process.get(:logins1))))
    IO.puts(Kernel.inspect(find_secret_passcode(Process.get(:logins2))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
