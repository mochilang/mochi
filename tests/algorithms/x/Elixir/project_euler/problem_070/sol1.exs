# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def get_totients(max_one) do
    try do
      totients = []
      i = 0
      while_fun = fn while_fun, i, totients ->
        if i < max_one do
          totients = (totients ++ [i])
          i = i + 1
          while_fun.(while_fun, i, totients)
        else
          {i, totients}
        end
      end
      {_, totients} = try do
          while_fun.(while_fun, i, totients)
        catch
          {:break, {_, totients}} -> {0, totients}
        end

      i = 2
      while_fun_2 = fn while_fun_2, i, totients ->
        if i < max_one do
          totients = if Enum.at(totients, i, []) == i do
            x = i
            while_fun_3 = fn while_fun_3, totients, x ->
              if x < max_one do
                totients = List.replace_at(totients, x, Enum.at(totients, x, []) - div(Enum.at(totients, x, []), i))
                x = x + i
                while_fun_3.(while_fun_3, totients, x)
              else
                {totients, x}
              end
            end
            {totients, x} = try do
                while_fun_3.(while_fun_3, totients, x)
              catch
                {:break, {totients, x}} -> {totients, x}
              end

            totients
          else
            totients
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, totients)
        else
          {i, totients}
        end
      end
      {_, totients} = try do
          while_fun_2.(while_fun_2, i, totients)
        catch
          {:break, {_, totients}} -> {0, totients}
        end

      throw {:return, totients}
    catch
      {:return, val} -> val
    end
  end
  def has_same_digits(num1, num2) do
    try do
      count1 = []
      count2 = []
      i = 0
      while_fun_4 = fn while_fun_4, count1, count2, i ->
        if i < 10 do
          count1 = (count1 ++ [0])
          count2 = (count2 ++ [0])
          i = i + 1
          while_fun_4.(while_fun_4, count1, count2, i)
        else
          {count1, count2, i}
        end
      end
      {count1, count2, _} = try do
          while_fun_4.(while_fun_4, count1, count2, i)
        catch
          {:break, {count1, count2, _}} -> {count1, count2, 0}
        end

      n1 = num1
      n2 = num2
      count1 = if n1 == 0 do
        count1 = List.replace_at(count1, 0, Enum.at(count1, 0, []) + 1)
        count1
      else
        count1
      end
      count2 = if n2 == 0 do
        count2 = List.replace_at(count2, 0, Enum.at(count2, 0, []) + 1)
        count2
      else
        count2
      end
      while_fun_5 = fn while_fun_5, count1, n1 ->
        if n1 > 0 do
          d1 = rem(n1, 10)
          count1 = List.replace_at(count1, d1, Enum.at(count1, d1, []) + 1)
          n1 = div(n1, 10)
          while_fun_5.(while_fun_5, count1, n1)
        else
          {count1, n1}
        end
      end
      {count1, n1} = try do
          while_fun_5.(while_fun_5, count1, n1)
        catch
          {:break, {count1, n1}} -> {count1, n1}
        end

      while_fun_6 = fn while_fun_6, count2, n2 ->
        if n2 > 0 do
          d2 = rem(n2, 10)
          count2 = List.replace_at(count2, d2, Enum.at(count2, d2, []) + 1)
          n2 = div(n2, 10)
          while_fun_6.(while_fun_6, count2, n2)
        else
          {count2, n2}
        end
      end
      {count2, n2} = try do
          while_fun_6.(while_fun_6, count2, n2)
        catch
          {:break, {count2, n2}} -> {count2, n2}
        end

      i = 0
      while_fun_7 = fn while_fun_7, i ->
        if i < 10 do
          if Enum.at(count1, i, []) != Enum.at(count2, i, []) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      _ = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def solution(max_n) do
    try do
      min_numerator = 1
      min_denominator = 0
      totients = get_totients(max_n + 1)
      i = 2
      while_fun_8 = fn while_fun_8, i, min_denominator, min_numerator ->
        if i <= max_n do
          t = Enum.at(totients, i, [])
          {min_denominator, min_numerator} = if i * min_denominator < min_numerator * t && has_same_digits(i, t) do
            min_numerator = i
            min_denominator = t
            {min_denominator, min_numerator}
          else
            {min_denominator, min_numerator}
          end
          i = i + 1
          while_fun_8.(while_fun_8, i, min_denominator, min_numerator)
        else
          {i, min_denominator, min_numerator}
        end
      end
      {_, min_denominator, min_numerator} = try do
          while_fun_8.(while_fun_8, i, min_denominator, min_numerator)
        catch
          {:break, {_, min_denominator, min_numerator}} -> {0, min_denominator, min_numerator}
        end

      throw {:return, min_numerator}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(solution(10000)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
