# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def range_desc(start, end_) do
    try do
      res = []
      i = start
      while_fun = fn while_fun, i, res ->
        if i >= end_ do
          res = (res ++ [i])
          i = i - 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def range_asc(start, end_) do
    try do
      res = []
      i = start
      while_fun_2 = fn while_fun_2, i, res ->
        if i <= end_ do
          res = (res ++ [i])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def concat_lists(a, b) do
    try do
      res = a
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(b) do
          res = (res ++ [Enum.at(b, i, [])])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def swap(xs, i, j) do
    try do
      res = []
      k = 0
      while_fun_4 = fn while_fun_4, k, res ->
        if k < _len(xs) do
          res = if k == i do
            res = (res ++ [Enum.at(xs, j, [])])
            res
          else
            res = if k == j do
              res = (res ++ [Enum.at(xs, i, [])])
              res
            else
              res = (res ++ [Enum.at(xs, k, [])])
              res
            end
            res
          end
          k = k + 1
          while_fun_4.(while_fun_4, k, res)
        else
          {k, res}
        end
      end
      {_, res} = try do
          while_fun_4.(while_fun_4, k, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def generate_gon_ring(gon_side, perm) do
    try do
      result = []
      result = (result ++ [Enum.at(perm, 0, [])])
      result = (result ++ [Enum.at(perm, 1, [])])
      result = (result ++ [Enum.at(perm, 2, [])])
      extended = (perm ++ [Enum.at(perm, 1, [])])
      magic_number = (if gon_side < 5, do: 1, else: 2)
      i = 1
      while_fun_5 = fn while_fun_5, i, result ->
        if i < div(_len(extended), 3) + magic_number do
          result = (result ++ [Enum.at(extended, 2 * i + 1, [])])
          result = (result ++ [Enum.at(result, 3 * i - 1, [])])
          result = (result ++ [Enum.at(extended, 2 * i + 2, [])])
          i = i + 1
          while_fun_5.(while_fun_5, i, result)
        else
          {i, result}
        end
      end
      {_, result} = try do
          while_fun_5.(while_fun_5, i, result)
        catch
          {:break, {_, result}} -> {0, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def min_outer(numbers) do
    try do
      min_val = Enum.at(numbers, 0, [])
      i = 3
      while_fun_6 = fn while_fun_6, i, min_val ->
        if i < _len(numbers) do
          min_val = if Enum.at(numbers, i, []) < min_val do
            min_val = Enum.at(numbers, i, [])
            min_val
          else
            min_val
          end
          i = i + 3
          while_fun_6.(while_fun_6, i, min_val)
        else
          {i, min_val}
        end
      end
      {_, min_val} = try do
          while_fun_6.(while_fun_6, i, min_val)
        catch
          {:break, {_, min_val}} -> {0, min_val}
        end

      throw {:return, min_val}
    catch
      {:return, val} -> val
    end
  end
  def is_magic_gon(numbers) do
    try do
      if rem(_len(numbers), 3) != 0 do
        throw {:return, false}
      end
      if min_outer(numbers) != Enum.at(numbers, 0, []) do
        throw {:return, false}
      end
      total = Enum.at(numbers, 0, []) + Enum.at(numbers, 1, []) + Enum.at(numbers, 2, [])
      i = 3
      while_fun_7 = fn while_fun_7, i ->
        if i < _len(numbers) do
          if Enum.at(numbers, i, []) + Enum.at(numbers, i + 1, []) + Enum.at(numbers, i + 2, []) != total do
            throw {:return, false}
          end
          i = i + 3
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      _ = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def permute_search(nums, start, gon_side, current_max) do
    try do
      if start == _len(nums) do
        ring = generate_gon_ring(gon_side, nums)
        if is_magic_gon(ring) do
          s = ""
          k = 0
          while_fun_8 = fn while_fun_8, k, s ->
            if k < _len(ring) do
              s = (s <> Kernel.to_string(Enum.at(ring, k, [])))
              k = k + 1
              while_fun_8.(while_fun_8, k, s)
            else
              {k, s}
            end
          end
          {_, s} = try do
              while_fun_8.(while_fun_8, k, s)
            catch
              {:break, {_, s}} -> {0, s}
            end

          if s > current_max do
            throw {:return, s}
          end
        end
        throw {:return, current_max}
      end
      res = current_max
      i = start
      while_fun_9 = fn while_fun_9, i, res ->
        if i < _len(nums) do
          swapped = swap(nums, start, i)
          candidate = permute_search(swapped, start + 1, gon_side, res)
          res = if candidate > res do
            res = candidate
            res
          else
            res
          end
          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def solution(gon_side) do
    try do
      if gon_side < 3 || gon_side > 5 do
        throw {:return, ""}
      end
      small = range_desc(gon_side + 1, 1)
      big = range_asc(gon_side + 2, gon_side * 2)
      numbers = concat_lists(small, big)
      max_str = permute_search(numbers, 0, gon_side, "")
      throw {:return, max_str}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(solution(5)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
