# Code generated by Mochi transpiler 2025-08-23 14:49 +0700
defmodule Main do
  @data_dir nil
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def collatz_length(n) do
    try do
      num = n
      sequence = []
      while_fun = fn while_fun, num, sequence ->
        if !(Map.has_key?(Process.get(:collatz_cache), num)) do
          sequence = (sequence ++ [num])
          num = (if rem(num, 2) == 0, do: (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((div(num, 2))), else: 3 * num + 1)
          while_fun.(while_fun, num, sequence)
        else
          {num, sequence}
        end
      end
      {num, sequence} = try do
          while_fun.(while_fun, num, sequence)
        catch
          {:break, {num, sequence}} -> {num, sequence}
        end

      length = Process.get(:collatz_cache)[num]
      i = _len(sequence) - 1
      while_fun_2 = fn while_fun_2, i, length ->
        if i >= 0 do
          length = length + 1
          Process.put(:collatz_cache, Map.put(Process.get(:collatz_cache), Enum.at(sequence, i, []), length))
          i = i - 1
          while_fun_2.(while_fun_2, i, length)
        else
          {i, length}
        end
      end
      {_, length} = try do
          while_fun_2.(while_fun_2, i, length)
        catch
          {:break, {_, length}} -> {0, length}
        end

      throw {:return, length}
    catch
      {:return, val} -> val
    end
  end
  def solution(limit) do
    try do
      max_len = 0
      max_start = 1
      i = 1
      while_fun_3 = fn while_fun_3, i, max_len, max_start ->
        if i < limit do
          length = collatz_length(i)
          {max_len, max_start} = if length > max_len do
            max_len = length
            max_start = i
            {max_len, max_start}
          else
            {max_len, max_start}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, max_len, max_start)
        else
          {i, max_len, max_start}
        end
      end
      {_, max_len, max_start} = try do
          while_fun_3.(while_fun_3, i, max_len, max_start)
        catch
          {:break, {_, max_len, max_start}} -> {0, max_len, max_start}
        end

      throw {:return, max_start}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:collatz_cache, %{1 => 1})
  def main() do
    Process.put(:input_str, _input())
    Process.put(:limit, String.to_integer(Process.get(:input_str)))
    IO.puts(Kernel.inspect(solution(Process.get(:limit))))
  end
end
Main.main()
