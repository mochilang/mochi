# Code generated by Mochi transpiler 2025-08-23 14:49 +0700
defmodule Main do
  @data_dir nil
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def solution(n) do
    try do
      counters = []
      i = 0
      while_fun = fn while_fun, counters, i ->
        if i <= n do
          counters = (counters ++ [0])
          i = i + 1
          while_fun.(while_fun, counters, i)
        else
          {counters, i}
        end
      end
      {counters, _} = try do
          while_fun.(while_fun, counters, i)
        catch
          {:break, {counters, _}} -> {counters, 0}
        end

      counters = List.replace_at(counters, 1, 1)
      largest_number = 1
      pre_counter = 1
      start = 2
      while_fun_2 = fn while_fun_2, counters, largest_number, pre_counter, start ->
        if start < n do
          number = start
          counter = 0
          while_fun_3 = fn while_fun_3, counter, number ->
            if true do
              counter = if number < _len(counters) && Enum.at(counters, number, []) != 0 do
                counter = counter + Enum.at(counters, number, [])
                throw {:break, {counter, number}}
                counter
              else
                counter
              end
              number = (if rem(number, 2) == 0, do: div(number, 2), else: 3 * number + 1)
              counter = counter + 1
              while_fun_3.(while_fun_3, counter, number)
            else
              {counter, number}
            end
          end
          {counter, number} = try do
              while_fun_3.(while_fun_3, counter, number)
            catch
              {:break, {counter, number}} -> {counter, number}
            end

          counters = if start < _len(counters) && Enum.at(counters, start, []) == 0 do
            counters = List.replace_at(counters, start, counter)
            counters
          else
            counters
          end
          {largest_number, pre_counter} = if counter > pre_counter do
            largest_number = start
            pre_counter = counter
            {largest_number, pre_counter}
          else
            {largest_number, pre_counter}
          end
          start = start + 1
          while_fun_2.(while_fun_2, counters, largest_number, pre_counter, start)
        else
          {counters, largest_number, pre_counter, start}
        end
      end
      {counters, largest_number, pre_counter, start} = try do
          while_fun_2.(while_fun_2, counters, largest_number, pre_counter, start)
        catch
          {:break, {counters, largest_number, pre_counter, start}} -> {counters, largest_number, pre_counter, start}
        end

      throw {:return, largest_number}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:input_str, _input())
    Process.put(:n, String.to_integer(Process.get(:input_str)))
    IO.puts(Kernel.inspect(solution(Process.get(:n))))
  end
end
Main.main()
