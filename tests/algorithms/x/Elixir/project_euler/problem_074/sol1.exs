# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sum_digit_factorials(n) do
    try do
      if Map.has_key?(Process.get(:cache_sum_digit_factorials), n) do
        throw {:return, Process.get(:cache_sum_digit_factorials)[n]}
      end
      m = n
      ret = 0
      ret = if m == 0 do
        ret = Enum.at(Process.get(:digit_factorials), 0, [])
        ret
      else
        ret
      end
      while_fun = fn while_fun, m, ret ->
        if m > 0 do
          digit = rem(m, 10)
          ret = ret + Enum.at(Process.get(:digit_factorials), digit, [])
          m = div(m, 10)
          while_fun.(while_fun, m, ret)
        else
          {m, ret}
        end
      end
      {_, ret} = try do
          while_fun.(while_fun, m, ret)
        catch
          {:break, {_, ret}} -> {0, ret}
        end

      Process.put(:cache_sum_digit_factorials, Map.put(Process.get(:cache_sum_digit_factorials), n, ret))
      throw {:return, ret}
    catch
      {:return, val} -> val
    end
  end
  def chain_length(n) do
    try do
      if Map.has_key?(Process.get(:chain_length_cache), n) do
        throw {:return, Process.get(:chain_length_cache)[n]}
      end
      chain = []
      seen = %{}
      current = n
      while_fun_2 = fn while_fun_2, chain, current, seen ->
        if true do
          if Map.has_key?(Process.get(:chain_length_cache), current) do
            known = Process.get(:chain_length_cache)[current]
            total = known
            i = _len(chain) - 1
            while_fun_3 = fn while_fun_3, i, total ->
              if i >= 0 do
                total = total + 1
                Process.put(:chain_length_cache, Map.put(Process.get(:chain_length_cache), Enum.at(chain, i, []), total))
                i = i - 1
                while_fun_3.(while_fun_3, i, total)
              else
                {i, total}
              end
            end
            {_, total} = try do
                while_fun_3.(while_fun_3, i, total)
              catch
                {:break, {_, total}} -> {0, total}
              end

            throw {:return, Process.get(:chain_length_cache)[n]}
          end
          if Map.has_key?(seen, current) do
            loop_start = seen[current]
            loop_len = _len(chain) - loop_start
            i = _len(chain) - 1
            ahead = 0
            while_fun_4 = fn while_fun_4, ahead, i ->
              if i >= 0 do
                if i >= loop_start do
                  Process.put(:chain_length_cache, Map.put(Process.get(:chain_length_cache), Enum.at(chain, i, []), loop_len))
                else
                  Process.put(:chain_length_cache, Map.put(Process.get(:chain_length_cache), Enum.at(chain, i, []), loop_len + (ahead + 1)))
                end
                ahead = ahead + 1
                i = i - 1
                while_fun_4.(while_fun_4, ahead, i)
              else
                {ahead, i}
              end
            end
            {ahead, _} = try do
                while_fun_4.(while_fun_4, ahead, i)
              catch
                {:break, {ahead, _}} -> {ahead, 0}
              end

            throw {:return, Process.get(:chain_length_cache)[n]}
          end
          seen = Map.put(seen, current, _len(chain))
          chain = (chain ++ [current])
          current = sum_digit_factorials(current)
          while_fun_2.(while_fun_2, chain, current, seen)
        else
          {chain, current, seen}
        end
      end
      {chain, current, seen} = try do
          while_fun_2.(while_fun_2, chain, current, seen)
        catch
          {:break, {chain, current, seen}} -> {chain, current, seen}
        end

    catch
      {:return, val} -> val
    end
  end
  def solution(num_terms, max_start) do
    try do
      count = 0
      i = 1
      while_fun_5 = fn while_fun_5, count, i ->
        if i < max_start do
          count = if chain_length(i) == num_terms do
            count = count + 1
            count
          else
            count
          end
          i = i + 1
          while_fun_5.(while_fun_5, count, i)
        else
          {count, i}
        end
      end
      {count, _} = try do
          while_fun_5.(while_fun_5, count, i)
        catch
          {:break, {count, _}} -> {count, 0}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:digit_factorials, [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880])
  Process.put(:cache_sum_digit_factorials, %{145 => 145})
  Process.put(:chain_length_cache, %{145 => 0, 169 => 3, 36301 => 3, 1454 => 3, 871 => 2, 45361 => 2, 872 => 2})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(("solution() = " <> Kernel.inspect(solution(60, 1000))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
