# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def gcd(a, b) do
    try do
      x = a
      y = b
      while_fun = fn while_fun, x, y ->
        if y != 0 do
          t = rem(x, y)
          x = y
          y = t
          while_fun.(while_fun, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun.(while_fun, x, y)
        catch
          {:break, {x, y}} -> {x, y}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def solution(limit) do
    try do
      frequencies = %{}
      m = 2
      while_fun_2 = fn while_fun_2, frequencies, m ->
        if 2 * m * (m + 1) <= limit do
          {frequencies, _} = try do
            n = (rem(m, 2)) + 1
            while_fun_3 = fn while_fun_3, frequencies, n ->
              if n < m do
                {frequencies, _} = try do
                  n = if gcd(m, n) > 1 do
                    n = n + 2
                    throw {:continue, {frequencies, n}}
                    n
                  else
                    n
                  end
                  primitive_perimeter = 2 * m * (m + n)
                  perimeter = primitive_perimeter
                  while_fun_4 = fn while_fun_4, frequencies, perimeter ->
                    if perimeter <= limit do
                      frequencies = if !(Map.has_key?(frequencies, perimeter)) do
                        frequencies = Map.put(frequencies, perimeter, 0)
                        frequencies
                      else
                        frequencies
                      end
                      frequencies = Map.put(frequencies, perimeter, frequencies[perimeter] + 1)
                      perimeter = perimeter + primitive_perimeter
                      while_fun_4.(while_fun_4, frequencies, perimeter)
                    else
                      {frequencies, perimeter}
                    end
                  end
                  {frequencies, perimeter} = try do
                      while_fun_4.(while_fun_4, frequencies, perimeter)
                    catch
                      {:break, {frequencies, perimeter}} -> {frequencies, perimeter}
                    end

                  n = n + 2
                  {frequencies, _}
                catch
                  {:continue, {frequencies, _}} -> {frequencies, 0}
                end
                while_fun_3.(while_fun_3, frequencies, n)
              else
                {frequencies, n}
              end
            end
            {frequencies, _} = try do
                while_fun_3.(while_fun_3, frequencies, n)
              catch
                {:break, {frequencies, _}} -> {frequencies, 0}
              end

            m = m + 1
            {frequencies, _}
          catch
            {:continue, {frequencies, _}} -> {frequencies, 0}
          end
          while_fun_2.(while_fun_2, frequencies, m)
        else
          {frequencies, m}
        end
      end
      {frequencies, _} = try do
          while_fun_2.(while_fun_2, frequencies, m)
        catch
          {:break, {frequencies, _}} -> {frequencies, 0}
        end

      count = 0
      {count} = Enum.reduce(Map.keys(frequencies), {count}, fn p, {count} ->
        count = if frequencies[p] == 1 do
          count = count + 1
          count
        else
          count
        end
        {count}
      end)
      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:result, solution(1500000))
    IO.puts(("solution() = " <> Kernel.to_string(Process.get(:result))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
