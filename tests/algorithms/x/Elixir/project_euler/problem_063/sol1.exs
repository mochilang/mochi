# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  def pow(base, exponent) do
    try do
      result = 1
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < exponent do
          result = result * base
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {_, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {_, result}} -> {0, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def num_digits(n) do
    try do
      if n == 0 do
        throw {:return, 1}
      end
      count = 0
      x = n
      while_fun_2 = fn while_fun_2, count, x ->
        if x > 0 do
          x = div(x, 10)
          count = count + 1
          while_fun_2.(while_fun_2, count, x)
        else
          {count, x}
        end
      end
      {count, x} = try do
          while_fun_2.(while_fun_2, count, x)
        catch
          {:break, {count, x}} -> {count, x}
        end

      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def solution(max_base, max_power) do
    try do
      total = 0
      base = 1
      while_fun_3 = fn while_fun_3, base, total ->
        if base < max_base do
          power = 1
          while_fun_4 = fn while_fun_4, power, total ->
            if power < max_power do
              digits = num_digits(pow(base, power))
              total = if digits == power do
                total = total + 1
                total
              else
                total
              end
              power = power + 1
              while_fun_4.(while_fun_4, power, total)
            else
              {power, total}
            end
          end
          {power, total} = try do
              while_fun_4.(while_fun_4, power, total)
            catch
              {:break, {power, total}} -> {power, total}
            end

          base = base + 1
          while_fun_3.(while_fun_3, base, total)
        else
          {base, total}
        end
      end
      {base, total} = try do
          while_fun_3.(while_fun_3, base, total)
        catch
          {:break, {base, total}} -> {base, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(("solution(10, 22) = " <> Kernel.inspect(solution(10, 22))))
  end
end
Main.main()
