# Code generated by Mochi transpiler 2025-08-23 01:20 +0700
defmodule Main do
  @data_dir nil
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def generate_primes(limit) do
    try do
      is_prime = []
      i = 0
      while_fun = fn while_fun, i, is_prime ->
        if i <= limit do
          is_prime = (is_prime ++ [true])
          i = i + 1
          while_fun.(while_fun, i, is_prime)
        else
          {i, is_prime}
        end
      end
      {_, is_prime} = try do
          while_fun.(while_fun, i, is_prime)
        catch
          {:break, {_, is_prime}} -> {0, is_prime}
        end

      is_prime = List.replace_at(is_prime, 0, false)
      is_prime = List.replace_at(is_prime, 1, false)
      i = 2
      while_fun_2 = fn while_fun_2, i, is_prime ->
        if i * i <= limit do
          is_prime = if Enum.at(is_prime, i, []) do
            j = i * i
            while_fun_3 = fn while_fun_3, is_prime, j ->
              if j <= limit do
                is_prime = List.replace_at(is_prime, j, false)
                j = j + i
                while_fun_3.(while_fun_3, is_prime, j)
              else
                {is_prime, j}
              end
            end
            {is_prime, _} = try do
                while_fun_3.(while_fun_3, is_prime, j)
              catch
                {:break, {is_prime, _}} -> {is_prime, 0}
              end

            is_prime
          else
            is_prime
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, is_prime)
        else
          {i, is_prime}
        end
      end
      {_, is_prime} = try do
          while_fun_2.(while_fun_2, i, is_prime)
        catch
          {:break, {_, is_prime}} -> {0, is_prime}
        end

      primes = []
      i = 2
      while_fun_4 = fn while_fun_4, i ->
        if i <= limit do
          if Enum.at(is_prime, i, []) do
            primes = (primes ++ [i])
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      _ = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, primes}
    catch
      {:return, val} -> val
    end
  end
  def contains(xs, value) do
    try do
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == value do
            throw {:return, true}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      _ = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def partition(n) do
    try do
      if n < 0 do
        throw {:return, []}
      end
      if n == 0 do
        throw {:return, [1]}
      end
      if Map.has_key?(Process.get(:partition_cache), n) do
        throw {:return, Process.get(:partition_cache)[n]}
      end
      ret = []
      {ret} = Enum.reduce(Process.get(:primes), {ret}, fn prime, {ret} ->
        try do
          if prime > n do
            throw :continue
          end
          subs = partition(n - prime)
          {ret} = Enum.reduce(subs, {ret}, fn sub, {ret} ->
            prod = sub * prime
            ret = if !contains(ret, prod) do
              ret = (ret ++ [prod])
              ret
            else
              ret
            end
            {ret}
          end)
        catch
          :continue -> {ret}
        end
        {ret}
      end)
      Process.put(:partition_cache, Map.put(Process.get(:partition_cache), n, ret))
      throw {:return, ret}
    catch
      {:return, val} -> val
    end
  end
  def solution(threshold) do
    try do
      number_to_partition = 1
      while_fun_6 = fn while_fun_6, number_to_partition ->
        if number_to_partition < Process.get(:num_primes) do
          parts = partition(number_to_partition)
          if _len(parts) > threshold do
            throw {:return, number_to_partition}
          end
          number_to_partition = number_to_partition + 1
          while_fun_6.(while_fun_6, number_to_partition)
        else
          number_to_partition
        end
      end
      number_to_partition = try do
          while_fun_6.(while_fun_6, number_to_partition)
        catch
          {:break, {number_to_partition}} -> number_to_partition
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:num_primes, 100)
  Process.put(:partition_cache, %{})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:primes, generate_primes(Process.get(:num_primes)))
    Process.put(:result, solution(5000))
    IO.puts(("solution() = " <> Kernel.to_string(Process.get(:result))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
