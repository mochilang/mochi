# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def exp_approx(x) do
    try do
      sum = 1.0
      term = 1.0
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i <= 20 do
          term = term * x / (:erlang.float(i))
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(vector) do
    try do
      result = []
      i = 0
      while_fun_2 = fn while_fun_2, i, result ->
        if i < _len(vector) do
          v = Enum.at(vector, i)
          s = 1.0 / (1.0 + exp_approx(-v))
          result = (result ++ [s])
          i = i + 1
          while_fun_2.(while_fun_2, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_2.(while_fun_2, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def swish(vector, beta) do
    try do
      result = []
      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(vector) do
          v = Enum.at(vector, i)
          s = 1.0 / (1.0 + exp_approx(-beta * v))
          result = (result ++ [v * s])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid_linear_unit(vector) do
    try do
      throw {:return, swish(vector, 1.0)}
    catch
      {:return, val} -> val
    end
  end
  def approx_equal(a, b, eps) do
    try do
      diff = (if a > b, do: a - b, else: b - a)
      throw {:return, diff < eps}
    catch
      {:return, val} -> val
    end
  end
  def approx_equal_list(a, b, eps) do
    try do
      if _len(a) != _len(b) do
        throw {:return, false}
      end
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(a) do
          if !approx_equal(Enum.at(a, i), Enum.at(b, i), eps) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def test_swish() do
    try do
      v = [-1.0, 1.0, 2.0]
      eps = 0.001
      if !approx_equal_list(sigmoid(v), [0.26894142, 0.73105858, 0.88079708], eps) do
        raise("sigmoid incorrect")
      end
      if !approx_equal_list(sigmoid_linear_unit(v), [-0.26894142, 0.73105858, 1.76159416], eps) do
        raise("sigmoid_linear_unit incorrect")
      end
      if !approx_equal_list(swish(v, 2.0), [-0.11920292, 0.88079708, 1.96402758], eps) do
        raise("swish incorrect")
      end
      if !approx_equal_list(swish([-2.0], 1.0), [-0.23840584], eps) do
        raise("swish with parameter 1 incorrect")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      test_swish()
      IO.puts(Kernel.inspect(sigmoid([-1.0, 1.0, 2.0])))
      IO.puts(Kernel.inspect(sigmoid_linear_unit([-1.0, 1.0, 2.0])))
      IO.puts(Kernel.inspect(swish([-1.0, 1.0, 2.0], 2.0)))
      IO.puts(Kernel.inspect(swish([-2.0], 1.0)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
