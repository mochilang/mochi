# Code generated by Mochi transpiler 2025-08-12 09:13 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random() do
    try do
      throw {:return, (1.0 * rand()) / 2147483648.0}
    catch
      {:return, val} -> val
    end
  end
  def expApprox(x) do
    try do
      y = x
      is_neg = false
      {is_neg, y} = if x < 0.0 do
        is_neg = true
        y = -x
        {is_neg, y}
      else
        {is_neg, y}
      end
      term = 1.0
      sum = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 30 do
          term = term * y / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      if is_neg do
        throw {:return, 1.0 / sum}
      end
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(z) do
    try do
      throw {:return, 1.0 / (1.0 + expApprox(-z))}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid_vec(v) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(v) do
          res = (res ++ [sigmoid(Enum.at(v, i, []))])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid_derivative(out) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(out) do
          val = Enum.at(out, i, [])
          res = (res ++ [val * (1.0 - val)])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def random_vector(n) do
    try do
      v = []
      i = 0
      while_fun_4 = fn while_fun_4, i, v ->
        if i < n do
          v = (v ++ [random() - 0.5])
          i = i + 1
          while_fun_4.(while_fun_4, i, v)
        else
          {i, v}
        end
      end
      {i, v} = try do
          while_fun_4.(while_fun_4, i, v)
        catch
          {:break, {i, v}} -> {i, v}
        end

      throw {:return, v}
    catch
      {:return, val} -> val
    end
  end
  def random_matrix(r, c) do
    try do
      m = []
      i = 0
      while_fun_5 = fn while_fun_5, i, m ->
        if i < r do
          m = (m ++ [random_vector(c)])
          i = i + 1
          while_fun_5.(while_fun_5, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_5.(while_fun_5, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def matvec(mat, vec) do
    try do
      res = []
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(mat) do
          s = 0.0
          j = 0
          while_fun_7 = fn while_fun_7, j, s ->
            if j < _len(vec) do
              s = s + Enum.at(Enum.at(mat, i, []), j, 0) * Enum.at(vec, j, [])
              j = j + 1
              while_fun_7.(while_fun_7, j, s)
            else
              {j, s}
            end
          end
          {j, s} = try do
              while_fun_7.(while_fun_7, j, s)
            catch
              {:break, {j, s}} -> {j, s}
            end

          res = (res ++ [s])
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matTvec(mat, vec) do
    try do
      cols = _len(Enum.at(mat, 0, []))
      res = []
      j = 0
      while_fun_8 = fn while_fun_8, j, res ->
        if j < cols do
          s = 0.0
          i = 0
          while_fun_9 = fn while_fun_9, i, s ->
            if i < _len(mat) do
              s = s + Enum.at(Enum.at(mat, i, []), j, 0) * Enum.at(vec, i, [])
              i = i + 1
              while_fun_9.(while_fun_9, i, s)
            else
              {i, s}
            end
          end
          {i, s} = try do
              while_fun_9.(while_fun_9, i, s)
            catch
              {:break, {i, s}} -> {i, s}
            end

          res = (res ++ [s])
          j = j + 1
          while_fun_8.(while_fun_8, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_8.(while_fun_8, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_10 = fn while_fun_10, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i, []) - Enum.at(b, i, [])])
          i = i + 1
          while_fun_10.(while_fun_10, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_10.(while_fun_10, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_mul(a, b) do
    try do
      res = []
      i = 0
      while_fun_11 = fn while_fun_11, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i, []) * Enum.at(b, i, [])])
          i = i + 1
          while_fun_11.(while_fun_11, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_11.(while_fun_11, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_scalar_mul(v, s) do
    try do
      res = []
      i = 0
      while_fun_12 = fn while_fun_12, i, res ->
        if i < _len(v) do
          res = (res ++ [Enum.at(v, i, []) * s])
          i = i + 1
          while_fun_12.(while_fun_12, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_12.(while_fun_12, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def outer(a, b) do
    try do
      res = []
      i = 0
      while_fun_13 = fn while_fun_13, i, res ->
        if i < _len(a) do
          row = []
          j = 0
          while_fun_14 = fn while_fun_14, j, row ->
            if j < _len(b) do
              row = (row ++ [Enum.at(a, i, []) * Enum.at(b, j, [])])
              j = j + 1
              while_fun_14.(while_fun_14, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_14.(while_fun_14, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_13.(while_fun_13, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_13.(while_fun_13, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def mat_scalar_mul(mat, s) do
    try do
      res = []
      i = 0
      while_fun_15 = fn while_fun_15, i, res ->
        if i < _len(mat) do
          row = []
          j = 0
          while_fun_16 = fn while_fun_16, j, row ->
            if j < _len(Enum.at(mat, i, [])) do
              row = (row ++ [Enum.at(Enum.at(mat, i, []), j, 0) * s])
              j = j + 1
              while_fun_16.(while_fun_16, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_16.(while_fun_16, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_15.(while_fun_15, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_15.(while_fun_15, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def mat_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_17 = fn while_fun_17, i, res ->
        if i < _len(a) do
          row = []
          j = 0
          while_fun_18 = fn while_fun_18, j, row ->
            if j < _len(Enum.at(a, i, [])) do
              row = (row ++ [Enum.at(Enum.at(a, i, []), j, 0) - Enum.at(Enum.at(b, i, []), j, 0)])
              j = j + 1
              while_fun_18.(while_fun_18, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_18.(while_fun_18, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_17.(while_fun_17, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_17.(while_fun_17, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def init_layer(units, back_units, lr) do
    try do
      throw {:return, %{units: units, weight: random_matrix(units, back_units), bias: random_vector(units), output: [], xdata: [], learn_rate: lr}}
    catch
      {:return, val} -> val
    end
  end
  def forward(layers, x) do
    try do
      data = x
      i = 0
      while_fun_19 = fn while_fun_19, data, i, layers ->
        if i < _len(layers) do
          layer = Enum.at(layers, i, [])
          layer = Map.put(layer, :xdata, data)
          {data, layer} = if i == 0 do
            layer = Map.put(layer, :output, data)
            {data, layer}
          else
            z = vec_sub(matvec(layer.weight, data), layer.bias)
            layer = Map.put(layer, :output, sigmoid_vec(z))
            data = layer.output
            {data, layer}
          end
          layers = List.replace_at(layers, i, layer)
          i = i + 1
          while_fun_19.(while_fun_19, data, i, layers)
        else
          {data, i, layers}
        end
      end
      {data, i, layers} = try do
          while_fun_19.(while_fun_19, data, i, layers)
        catch
          {:break, {data, i, layers}} -> {data, i, layers}
        end

      throw {:return, layers}
    catch
      {:return, val} -> val
    end
  end
  def backward(layers, grad) do
    try do
      g = grad
      i = _len(layers) - 1
      while_fun_20 = fn while_fun_20, g, i, layers ->
        if i > 0 do
          layer = Enum.at(layers, i, [])
          deriv = sigmoid_derivative(layer.output)
          delta = vec_mul(g, deriv)
          grad_w = outer(delta, layer.xdata)
          layer = Map.put(layer, :weight, mat_sub(layer.weight, mat_scalar_mul(grad_w, layer.learn_rate)))
          layer = Map.put(layer, :bias, vec_sub(layer.bias, vec_scalar_mul(delta, layer.learn_rate)))
          g = matTvec(layer.weight, delta)
          layers = List.replace_at(layers, i, layer)
          i = i - 1
          while_fun_20.(while_fun_20, g, i, layers)
        else
          {g, i, layers}
        end
      end
      {g, i, layers} = try do
          while_fun_20.(while_fun_20, g, i, layers)
        catch
          {:break, {g, i, layers}} -> {g, i, layers}
        end

      throw {:return, layers}
    catch
      {:return, val} -> val
    end
  end
  def calc_loss(y, yhat) do
    try do
      s = 0.0
      i = 0
      while_fun_21 = fn while_fun_21, i, s ->
        if i < _len(y) do
          d = Enum.at(y, i, []) - Enum.at(yhat, i, [])
          s = s + d * d
          i = i + 1
          while_fun_21.(while_fun_21, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_21.(while_fun_21, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def calc_gradient(y, yhat) do
    try do
      g = []
      i = 0
      while_fun_22 = fn while_fun_22, g, i ->
        if i < _len(y) do
          g = (g ++ [2.0 * (Enum.at(yhat, i, []) - Enum.at(y, i, []))])
          i = i + 1
          while_fun_22.(while_fun_22, g, i)
        else
          {g, i}
        end
      end
      {g, i} = try do
          while_fun_22.(while_fun_22, g, i)
        catch
          {:break, {g, i}} -> {g, i}
        end

      throw {:return, g}
    catch
      {:return, val} -> val
    end
  end
  def train(layers, xdata, ydata, rounds, acc) do
    try do
      r = 0
      while_fun_23 = fn while_fun_23, layers, r ->
        if r < rounds do
          i = 0
          while_fun_24 = fn while_fun_24, i, layers ->
            if i < _len(xdata) do
              layers = forward(layers, Enum.at(xdata, i, []))
              out = Enum.at(layers, _len(layers) - 1, [])["output"]
              grad = calc_gradient(Enum.at(ydata, i, []), out)
              layers = backward(layers, grad)
              i = i + 1
              while_fun_24.(while_fun_24, i, layers)
            else
              {i, layers}
            end
          end
          {i, layers} = try do
              while_fun_24.(while_fun_24, i, layers)
            catch
              {:break, {i, layers}} -> {i, layers}
            end

          r = r + 1
          while_fun_23.(while_fun_23, layers, r)
        else
          {layers, r}
        end
      end
      {layers, r} = try do
          while_fun_23.(while_fun_23, layers, r)
        catch
          {:break, {layers, r}} -> {layers, r}
        end

      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  def create_data() do
    try do
      x = []
      i = 0
      while_fun_25 = fn while_fun_25, i, x ->
        if i < 10 do
          x = (x ++ [random_vector(10)])
          i = i + 1
          while_fun_25.(while_fun_25, i, x)
        else
          {i, x}
        end
      end
      {i, x} = try do
          while_fun_25.(while_fun_25, i, x)
        catch
          {:break, {i, x}} -> {i, x}
        end

      y = [[0.8, 0.4], [0.4, 0.3], [0.34, 0.45], [0.67, 0.32], [0.88, 0.67], [0.78, 0.77], [0.55, 0.66], [0.55, 0.43], [0.54, 0.1], [0.1, 0.5]]
      throw {:return, %{x: x, y: y}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      data = create_data()
      x = data.x
      y = data.y
      layers = []
      layers = (layers ++ [init_layer(10, 0, 0.3)])
      layers = (layers ++ [init_layer(20, 10, 0.3)])
      layers = (layers ++ [init_layer(30, 20, 0.3)])
      layers = (layers ++ [init_layer(2, 30, 0.3)])
      final_mse = train(layers, x, y, 100, 0.01)
      IO.puts(final_mse)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
  def bench_main() do
    Process.put(:seed, 1)
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
