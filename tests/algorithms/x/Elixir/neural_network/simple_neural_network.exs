# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def randint(low, high) do
    try do
      throw {:return, (rem(rand(), (high - low + 1))) + low}
    catch
      {:return, val} -> val
    end
  end
  def expApprox(x) do
    try do
      y = x
      is_neg = false
      {is_neg, y} = if x < 0.0 do
        is_neg = true
        y = -x
        {is_neg, y}
      else
        {is_neg, y}
      end
      term = 1.0
      sum = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 30 do
          term = term * y / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      if is_neg do
        throw {:return, 1.0 / sum}
      end
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(x) do
    try do
      throw {:return, 1.0 / (1.0 + expApprox(-x))}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid_derivative(sig_val) do
    try do
      throw {:return, sig_val * (1.0 - sig_val)}
    catch
      {:return, val} -> val
    end
  end
  def forward_propagation(expected, number_propagations) do
    try do
      weight = 2.0 * (:erlang.float(randint(1, 100))) - 1.0
      layer_1 = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, layer_1, weight ->
        if i < number_propagations do
          layer_1 = sigmoid(Process.get(:initial_value) * weight)
          layer_1_error = (:erlang.float(expected) / 100.0) - layer_1
          layer_1_delta = layer_1_error * sigmoid_derivative(layer_1)
          weight = weight + Process.get(:initial_value) * layer_1_delta
          i = i + 1
          while_fun_2.(while_fun_2, i, layer_1, weight)
        else
          {i, layer_1, weight}
        end
      end
      {i, layer_1, weight} = try do
          while_fun_2.(while_fun_2, i, layer_1, weight)
        catch
          {:break, {i, layer_1, weight}} -> {i, layer_1, weight}
        end

      throw {:return, layer_1 * 100.0}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
  Process.put(:initial_value, 0.02)
  def main() do
    Process.put(:seed, 1)
    Process.put(:result, forward_propagation(32, 450000))
    IO.puts(Process.get(:result))
  end
end
Main.main()
