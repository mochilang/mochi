# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def random() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 13 + 7), 100))
      throw {:return, (:erlang.float(Process.get(:seed))) / 100.0}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(x) do
    try do
      throw {:return, 1.0 / (1.0 + exp(-x))}
    catch
      {:return, val} -> val
    end
  end
  def to_float(x) do
    try do
      throw {:return, x * 1.0}
    catch
      {:return, val} -> val
    end
  end
  def exp(x) do
    try do
      term = 1.0
      sum = 1.0
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n < 20 do
          term = term * x / to_float(n)
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def convolve(data, kernel, step, bias) do
    try do
      size_data = _len(data)
      size_kernel = _len(kernel)
      out = []
      i = 0
      while_fun_2 = fn while_fun_2, i, out ->
        if i <= size_data - size_kernel do
          row = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row ->
            if j <= size_data - size_kernel do
              sum = 0.0
              a = 0
              while_fun_4 = fn while_fun_4, a, sum ->
                if a < size_kernel do
                  b = 0
                  while_fun_5 = fn while_fun_5, b, sum ->
                    if b < size_kernel do
                      sum = sum + Enum.at(Enum.at(data, i + a), j + b) * Enum.at(Enum.at(kernel, a), b)
                      b = b + 1
                      while_fun_5.(while_fun_5, b, sum)
                    else
                      {b, sum}
                    end
                  end
                  {b, sum} = try do
                      while_fun_5.(while_fun_5, b, sum)
                    catch
                      {:break, {b, sum}} -> {b, sum}
                    end

                  a = a + 1
                  while_fun_4.(while_fun_4, a, sum)
                else
                  {a, sum}
                end
              end
              {a, sum} = try do
                  while_fun_4.(while_fun_4, a, sum)
                catch
                  {:break, {a, sum}} -> {a, sum}
                end

              row = (row ++ [sigmoid(sum - bias)])
              j = j + step
              while_fun_3.(while_fun_3, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_3.(while_fun_3, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          out = (out ++ [row])
          i = i + step
          while_fun_2.(while_fun_2, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_2.(while_fun_2, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def average_pool(map, size) do
    try do
      out = []
      i = 0
      while_fun_6 = fn while_fun_6, i, out ->
        if i < _len(map) do
          row = []
          j = 0
          while_fun_7 = fn while_fun_7, j, row ->
            if j < _len(Enum.at(map, i)) do
              sum = 0.0
              a = 0
              while_fun_8 = fn while_fun_8, a, sum ->
                if a < size do
                  b = 0
                  while_fun_9 = fn while_fun_9, b, sum ->
                    if b < size do
                      sum = sum + Enum.at(Enum.at(map, i + a), j + b)
                      b = b + 1
                      while_fun_9.(while_fun_9, b, sum)
                    else
                      {b, sum}
                    end
                  end
                  {b, sum} = try do
                      while_fun_9.(while_fun_9, b, sum)
                    catch
                      {:break, {b, sum}} -> {b, sum}
                    end

                  a = a + 1
                  while_fun_8.(while_fun_8, a, sum)
                else
                  {a, sum}
                end
              end
              {a, sum} = try do
                  while_fun_8.(while_fun_8, a, sum)
                catch
                  {:break, {a, sum}} -> {a, sum}
                end

              row = (row ++ [sum / (:erlang.float((size * size)))])
              j = j + size
              while_fun_7.(while_fun_7, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_7.(while_fun_7, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          out = (out ++ [row])
          i = i + size
          while_fun_6.(while_fun_6, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_6.(while_fun_6, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def flatten(maps) do
    try do
      out = []
      i = 0
      while_fun_10 = fn while_fun_10, i, out ->
        if i < _len(maps) do
          j = 0
          while_fun_11 = fn while_fun_11, j, out ->
            if j < _len(Enum.at(maps, i)) do
              k = 0
              while_fun_12 = fn while_fun_12, k, out ->
                if k < _len(Enum.at(Enum.at(maps, i), j)) do
                  out = (out ++ [Enum.at(Enum.at(Enum.at(maps, i), j), k)])
                  k = k + 1
                  while_fun_12.(while_fun_12, k, out)
                else
                  {k, out}
                end
              end
              {k, out} = try do
                  while_fun_12.(while_fun_12, k, out)
                catch
                  {:break, {k, out}} -> {k, out}
                end

              j = j + 1
              while_fun_11.(while_fun_11, j, out)
            else
              {j, out}
            end
          end
          {j, out} = try do
              while_fun_11.(while_fun_11, j, out)
            catch
              {:break, {j, out}} -> {j, out}
            end

          i = i + 1
          while_fun_10.(while_fun_10, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_10.(while_fun_10, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def vec_mul_mat(v, m) do
    try do
      cols = _len(Enum.at(m, 0))
      res = []
      j = 0
      while_fun_13 = fn while_fun_13, j, res ->
        if j < cols do
          sum = 0.0
          i = 0
          while_fun_14 = fn while_fun_14, i, sum ->
            if i < _len(v) do
              sum = sum + Enum.at(v, i) * Enum.at(Enum.at(m, i), j)
              i = i + 1
              while_fun_14.(while_fun_14, i, sum)
            else
              {i, sum}
            end
          end
          {i, sum} = try do
              while_fun_14.(while_fun_14, i, sum)
            catch
              {:break, {i, sum}} -> {i, sum}
            end

          res = (res ++ [sum])
          j = j + 1
          while_fun_13.(while_fun_13, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_13.(while_fun_13, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matT_vec_mul(m, v) do
    try do
      res = []
      i = 0
      while_fun_15 = fn while_fun_15, i, res ->
        if i < _len(m) do
          sum = 0.0
          j = 0
          while_fun_16 = fn while_fun_16, j, sum ->
            if j < _len(Enum.at(m, i)) do
              sum = sum + Enum.at(Enum.at(m, i), j) * Enum.at(v, j)
              j = j + 1
              while_fun_16.(while_fun_16, j, sum)
            else
              {j, sum}
            end
          end
          {j, sum} = try do
              while_fun_16.(while_fun_16, j, sum)
            catch
              {:break, {j, sum}} -> {j, sum}
            end

          res = (res ++ [sum])
          i = i + 1
          while_fun_15.(while_fun_15, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_15.(while_fun_15, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_add(a, b) do
    try do
      res = []
      i = 0
      while_fun_17 = fn while_fun_17, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) + Enum.at(b, i)])
          i = i + 1
          while_fun_17.(while_fun_17, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_17.(while_fun_17, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_18 = fn while_fun_18, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) - Enum.at(b, i)])
          i = i + 1
          while_fun_18.(while_fun_18, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_18.(while_fun_18, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_mul(a, b) do
    try do
      res = []
      i = 0
      while_fun_19 = fn while_fun_19, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) * Enum.at(b, i)])
          i = i + 1
          while_fun_19.(while_fun_19, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_19.(while_fun_19, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_map_sig(v) do
    try do
      res = []
      i = 0
      while_fun_20 = fn while_fun_20, i, res ->
        if i < _len(v) do
          res = (res ++ [sigmoid(Enum.at(v, i))])
          i = i + 1
          while_fun_20.(while_fun_20, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_20.(while_fun_20, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def new_cnn() do
    try do
      k1 = [[1.0, 0.0], [0.0, 1.0]]
      k2 = [[0.0, 1.0], [1.0, 0.0]]
      conv_kernels = [k1, k2]
      conv_bias = [0.0, 0.0]
      conv_step = 2
      pool_size = 2
      input_size = 2
      hidden_size = 2
      output_size = 2
      w_hidden = []
      i = 0
      while_fun_21 = fn while_fun_21, i, w_hidden ->
        if i < input_size do
          row = []
          j = 0
          while_fun_22 = fn while_fun_22, j, row ->
            if j < hidden_size do
              row = (row ++ [random() - 0.5])
              j = j + 1
              while_fun_22.(while_fun_22, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_22.(while_fun_22, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          w_hidden = (w_hidden ++ [row])
          i = i + 1
          while_fun_21.(while_fun_21, i, w_hidden)
        else
          {i, w_hidden}
        end
      end
      {i, w_hidden} = try do
          while_fun_21.(while_fun_21, i, w_hidden)
        catch
          {:break, {i, w_hidden}} -> {i, w_hidden}
        end

      w_out = []
      i = 0
      while_fun_23 = fn while_fun_23, i, w_out ->
        if i < hidden_size do
          row = []
          j = 0
          while_fun_24 = fn while_fun_24, j, row ->
            if j < output_size do
              row = (row ++ [random() - 0.5])
              j = j + 1
              while_fun_24.(while_fun_24, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_24.(while_fun_24, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          w_out = (w_out ++ [row])
          i = i + 1
          while_fun_23.(while_fun_23, i, w_out)
        else
          {i, w_out}
        end
      end
      {i, w_out} = try do
          while_fun_23.(while_fun_23, i, w_out)
        catch
          {:break, {i, w_out}} -> {i, w_out}
        end

      b_hidden = [0.0, 0.0]
      b_out = [0.0, 0.0]
      throw {:return, %{conv_kernels: conv_kernels, conv_bias: conv_bias, conv_step: conv_step, pool_size: pool_size, w_hidden: w_hidden, w_out: w_out, b_hidden: b_hidden, b_out: b_out, rate_weight: 0.2, rate_bias: 0.2}}
    catch
      {:return, val} -> val
    end
  end
  def forward(cnn, data) do
    try do
      maps = []
      i = 0
      while_fun_25 = fn while_fun_25, i, maps ->
        if i < _len(Map.get(cnn, :conv_kernels, [])) do
          conv_map = convolve(data, Enum.at(cnn.conv_kernels, i), cnn.conv_step, Enum.at(cnn.conv_bias, i))
          pooled = average_pool(conv_map, cnn.pool_size)
          maps = (maps ++ [pooled])
          i = i + 1
          while_fun_25.(while_fun_25, i, maps)
        else
          {i, maps}
        end
      end
      {i, maps} = try do
          while_fun_25.(while_fun_25, i, maps)
        catch
          {:break, {i, maps}} -> {i, maps}
        end

      flat = flatten(maps)
      hidden_net = vec_add(vec_mul_mat(flat, cnn.w_hidden), cnn.b_hidden)
      hidden_out = vec_map_sig(hidden_net)
      out_net = vec_add(vec_mul_mat(hidden_out, cnn.w_out), cnn.b_out)
      out = vec_map_sig(out_net)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def train(cnn, samples, epochs) do
    try do
      w_out = cnn.w_out
      b_out = cnn.b_out
      w_hidden = cnn.w_hidden
      b_hidden = cnn.b_hidden
      e = 0
      while_fun_26 = fn while_fun_26, b_hidden, b_out, e, w_hidden, w_out ->
        if e < epochs do
          s = 0
          while_fun_27 = fn while_fun_27, b_hidden, b_out, s, w_hidden, w_out ->
            if s < _len(samples) do
              data = Enum.at(samples, s)["image"]
              target = Enum.at(samples, s)["target"]
              maps = []
              i = 0
              while_fun_28 = fn while_fun_28, i, maps ->
                if i < _len(Map.get(cnn, :conv_kernels, [])) do
                  conv_map = convolve(data, Enum.at(cnn.conv_kernels, i), cnn.conv_step, Enum.at(cnn.conv_bias, i))
                  pooled = average_pool(conv_map, cnn.pool_size)
                  maps = (maps ++ [pooled])
                  i = i + 1
                  while_fun_28.(while_fun_28, i, maps)
                else
                  {i, maps}
                end
              end
              {i, maps} = try do
                  while_fun_28.(while_fun_28, i, maps)
                catch
                  {:break, {i, maps}} -> {i, maps}
                end

              flat = flatten(maps)
              hidden_net = vec_add(vec_mul_mat(flat, w_hidden), b_hidden)
              hidden_out = vec_map_sig(hidden_net)
              out_net = vec_add(vec_mul_mat(hidden_out, w_out), b_out)
              out = vec_map_sig(out_net)
              error_out = vec_sub(target, out)
              pd_out = vec_mul(error_out, vec_mul(out, vec_sub([1.0, 1.0], out)))
              error_hidden = matT_vec_mul(w_out, pd_out)
              pd_hidden = vec_mul(error_hidden, vec_mul(hidden_out, vec_sub([1.0, 1.0], hidden_out)))
              j = 0
              while_fun_29 = fn while_fun_29, j, w_out ->
                if j < _len(w_out) do
                  k = 0
                  while_fun_30 = fn while_fun_30, k, w_out ->
                    if k < _len(Enum.at(w_out, j)) do
                      w_out = List.replace_at(w_out, j, List.replace_at(Enum.at(w_out, j), k, Enum.at(Enum.at(w_out, j), k) + cnn.rate_weight * Enum.at(hidden_out, j) * Enum.at(pd_out, k)))
                      k = k + 1
                      while_fun_30.(while_fun_30, k, w_out)
                    else
                      {k, w_out}
                    end
                  end
                  {k, w_out} = try do
                      while_fun_30.(while_fun_30, k, w_out)
                    catch
                      {:break, {k, w_out}} -> {k, w_out}
                    end

                  j = j + 1
                  while_fun_29.(while_fun_29, j, w_out)
                else
                  {j, w_out}
                end
              end
              {j, w_out} = try do
                  while_fun_29.(while_fun_29, j, w_out)
                catch
                  {:break, {j, w_out}} -> {j, w_out}
                end

              j = 0
              while_fun_31 = fn while_fun_31, b_out, j ->
                if j < _len(b_out) do
                  b_out = List.replace_at(b_out, j, Enum.at(b_out, j) - cnn.rate_bias * Enum.at(pd_out, j))
                  j = j + 1
                  while_fun_31.(while_fun_31, b_out, j)
                else
                  {b_out, j}
                end
              end
              {b_out, j} = try do
                  while_fun_31.(while_fun_31, b_out, j)
                catch
                  {:break, {b_out, j}} -> {b_out, j}
                end

              i_h = 0
              while_fun_32 = fn while_fun_32, i_h, w_hidden ->
                if i_h < _len(w_hidden) do
                  j_h = 0
                  while_fun_33 = fn while_fun_33, j_h, w_hidden ->
                    if j_h < _len(Enum.at(w_hidden, i_h)) do
                      w_hidden = List.replace_at(w_hidden, i_h, List.replace_at(Enum.at(w_hidden, i_h), j_h, Enum.at(Enum.at(w_hidden, i_h), j_h) + cnn.rate_weight * Enum.at(flat, i_h) * Enum.at(pd_hidden, j_h)))
                      j_h = j_h + 1
                      while_fun_33.(while_fun_33, j_h, w_hidden)
                    else
                      {j_h, w_hidden}
                    end
                  end
                  {j_h, w_hidden} = try do
                      while_fun_33.(while_fun_33, j_h, w_hidden)
                    catch
                      {:break, {j_h, w_hidden}} -> {j_h, w_hidden}
                    end

                  i_h = i_h + 1
                  while_fun_32.(while_fun_32, i_h, w_hidden)
                else
                  {i_h, w_hidden}
                end
              end
              {i_h, w_hidden} = try do
                  while_fun_32.(while_fun_32, i_h, w_hidden)
                catch
                  {:break, {i_h, w_hidden}} -> {i_h, w_hidden}
                end

              j = 0
              while_fun_34 = fn while_fun_34, b_hidden, j ->
                if j < _len(b_hidden) do
                  b_hidden = List.replace_at(b_hidden, j, Enum.at(b_hidden, j) - cnn.rate_bias * Enum.at(pd_hidden, j))
                  j = j + 1
                  while_fun_34.(while_fun_34, b_hidden, j)
                else
                  {b_hidden, j}
                end
              end
              {b_hidden, j} = try do
                  while_fun_34.(while_fun_34, b_hidden, j)
                catch
                  {:break, {b_hidden, j}} -> {b_hidden, j}
                end

              s = s + 1
              while_fun_27.(while_fun_27, b_hidden, b_out, s, w_hidden, w_out)
            else
              {b_hidden, b_out, s, w_hidden, w_out}
            end
          end
          {b_hidden, b_out, s, w_hidden, w_out} = try do
              while_fun_27.(while_fun_27, b_hidden, b_out, s, w_hidden, w_out)
            catch
              {:break, {b_hidden, b_out, s, w_hidden, w_out}} -> {b_hidden, b_out, s, w_hidden, w_out}
            end

          e = e + 1
          while_fun_26.(while_fun_26, b_hidden, b_out, e, w_hidden, w_out)
        else
          {b_hidden, b_out, e, w_hidden, w_out}
        end
      end
      {b_hidden, b_out, e, w_hidden, w_out} = try do
          while_fun_26.(while_fun_26, b_hidden, b_out, e, w_hidden, w_out)
        catch
          {:break, {b_hidden, b_out, e, w_hidden, w_out}} -> {b_hidden, b_out, e, w_hidden, w_out}
        end

      throw {:return, %{conv_kernels: cnn.conv_kernels, conv_bias: cnn.conv_bias, conv_step: cnn.conv_step, pool_size: cnn.pool_size, w_hidden: w_hidden, w_out: w_out, b_hidden: b_hidden, b_out: b_out, rate_weight: cnn.rate_weight, rate_bias: cnn.rate_bias}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      cnn = new_cnn()
      image = [[1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 1.0]]
      sample = %{image: image, target: [1.0, 0.0]}
      IO.puts("Before training: #{Kernel.inspect(forward(cnn, image))}")
      trained = train(cnn, [sample], 50)
      IO.puts("After training: #{Kernel.inspect(forward(trained, image))}")
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 1)
end
Main.main()
