# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def exp_approx(x) do
    try do
      sum = 1.0
      term = 1.0
      i = 1
      while_fun = fn while_fun, i, sum, term ->
        if i < 10 do
          term = term * x / :erlang.float(i)
          sum = sum + term
          i = i + 1
          while_fun.(while_fun, i, sum, term)
        else
          {i, sum, term}
        end
      end
      {i, sum, term} = try do
          while_fun.(while_fun, i, sum, term)
        catch
          {:break, {i, sum, term}} -> {i, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid(x) do
    try do
      throw {:return, 1.0 / (1.0 + exp_approx(-x))}
    catch
      {:return, val} -> val
    end
  end
  def sigmoid_derivative(x) do
    try do
      throw {:return, x * (1.0 - x)}
    catch
      {:return, val} -> val
    end
  end
  def new_network() do
    try do
      throw {:return, %{w1: [[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8], [0.9, 1.0, 1.1, 1.2]], w2: [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.0, 1.1, 1.2]], w3: [[0.1], [0.2], [0.3]]}}
    catch
      {:return, val} -> val
    end
  end
  def feedforward(net, input) do
    try do
      hidden1 = []
      j = 0
      while_fun_2 = fn while_fun_2, hidden1, j ->
        if j < 4 do
          sum1 = 0.0
          i = 0
          while_fun_3 = fn while_fun_3, i, sum1 ->
            if i < 3 do
              sum1 = sum1 + Enum.at(input, i) * Enum.at(Enum.at(net.w1, i), j)
              i = i + 1
              while_fun_3.(while_fun_3, i, sum1)
            else
              {i, sum1}
            end
          end
          {i, sum1} = try do
              while_fun_3.(while_fun_3, i, sum1)
            catch
              {:break, {i, sum1}} -> {i, sum1}
            end

          hidden1 = (hidden1 ++ [sigmoid(sum1)])
          j = j + 1
          while_fun_2.(while_fun_2, hidden1, j)
        else
          {hidden1, j}
        end
      end
      {hidden1, j} = try do
          while_fun_2.(while_fun_2, hidden1, j)
        catch
          {:break, {hidden1, j}} -> {hidden1, j}
        end

      hidden2 = []
      k = 0
      while_fun_4 = fn while_fun_4, hidden2, k ->
        if k < 3 do
          sum2 = 0.0
          j2 = 0
          while_fun_5 = fn while_fun_5, j2, sum2 ->
            if j2 < 4 do
              sum2 = sum2 + Enum.at(hidden1, j2) * Enum.at(Enum.at(net.w2, j2), k)
              j2 = j2 + 1
              while_fun_5.(while_fun_5, j2, sum2)
            else
              {j2, sum2}
            end
          end
          {j2, sum2} = try do
              while_fun_5.(while_fun_5, j2, sum2)
            catch
              {:break, {j2, sum2}} -> {j2, sum2}
            end

          hidden2 = (hidden2 ++ [sigmoid(sum2)])
          k = k + 1
          while_fun_4.(while_fun_4, hidden2, k)
        else
          {hidden2, k}
        end
      end
      {hidden2, k} = try do
          while_fun_4.(while_fun_4, hidden2, k)
        catch
          {:break, {hidden2, k}} -> {hidden2, k}
        end

      sum3 = 0.0
      k2 = 0
      while_fun_6 = fn while_fun_6, k2, sum3 ->
        if k2 < 3 do
          sum3 = sum3 + Enum.at(hidden2, k2) * Enum.at(Enum.at(net.w3, k2), 0)
          k2 = k2 + 1
          while_fun_6.(while_fun_6, k2, sum3)
        else
          {k2, sum3}
        end
      end
      {k2, sum3} = try do
          while_fun_6.(while_fun_6, k2, sum3)
        catch
          {:break, {k2, sum3}} -> {k2, sum3}
        end

      out = sigmoid(sum3)
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def train(net, inputs, outputs, iterations) do
    try do
      iter = 0
      while_fun_7 = fn while_fun_7, iter, net ->
        if iter < iterations do
          s = 0
          while_fun_8 = fn while_fun_8, net, s ->
            if s < _len(inputs) do
              inp = Enum.at(inputs, s)
              target = Enum.at(outputs, s)
              hidden1 = []
              j = 0
              while_fun_9 = fn while_fun_9, hidden1, j ->
                if j < 4 do
                  sum1 = 0.0
                  i = 0
                  while_fun_10 = fn while_fun_10, i, sum1 ->
                    if i < 3 do
                      sum1 = sum1 + Enum.at(inp, i) * Enum.at(Enum.at(net.w1, i), j)
                      i = i + 1
                      while_fun_10.(while_fun_10, i, sum1)
                    else
                      {i, sum1}
                    end
                  end
                  {i, sum1} = try do
                      while_fun_10.(while_fun_10, i, sum1)
                    catch
                      {:break, {i, sum1}} -> {i, sum1}
                    end

                  hidden1 = (hidden1 ++ [sigmoid(sum1)])
                  j = j + 1
                  while_fun_9.(while_fun_9, hidden1, j)
                else
                  {hidden1, j}
                end
              end
              {hidden1, j} = try do
                  while_fun_9.(while_fun_9, hidden1, j)
                catch
                  {:break, {hidden1, j}} -> {hidden1, j}
                end

              hidden2 = []
              k = 0
              while_fun_11 = fn while_fun_11, hidden2, k ->
                if k < 3 do
                  sum2 = 0.0
                  j2 = 0
                  while_fun_12 = fn while_fun_12, j2, sum2 ->
                    if j2 < 4 do
                      sum2 = sum2 + Enum.at(hidden1, j2) * Enum.at(Enum.at(net.w2, j2), k)
                      j2 = j2 + 1
                      while_fun_12.(while_fun_12, j2, sum2)
                    else
                      {j2, sum2}
                    end
                  end
                  {j2, sum2} = try do
                      while_fun_12.(while_fun_12, j2, sum2)
                    catch
                      {:break, {j2, sum2}} -> {j2, sum2}
                    end

                  hidden2 = (hidden2 ++ [sigmoid(sum2)])
                  k = k + 1
                  while_fun_11.(while_fun_11, hidden2, k)
                else
                  {hidden2, k}
                end
              end
              {hidden2, k} = try do
                  while_fun_11.(while_fun_11, hidden2, k)
                catch
                  {:break, {hidden2, k}} -> {hidden2, k}
                end

              sum3 = 0.0
              k3 = 0
              while_fun_13 = fn while_fun_13, k3, sum3 ->
                if k3 < 3 do
                  sum3 = sum3 + Enum.at(hidden2, k3) * Enum.at(Enum.at(net.w3, k3), 0)
                  k3 = k3 + 1
                  while_fun_13.(while_fun_13, k3, sum3)
                else
                  {k3, sum3}
                end
              end
              {k3, sum3} = try do
                  while_fun_13.(while_fun_13, k3, sum3)
                catch
                  {:break, {k3, sum3}} -> {k3, sum3}
                end

              output = sigmoid(sum3)
              error = target - output
              delta_output = error * sigmoid_derivative(output)
              new_w3 = []
              k4 = 0
              while_fun_14 = fn while_fun_14, k4, new_w3 ->
                if k4 < 3 do
                  w3row = Enum.at(net.w3, k4)
                  w3row = List.replace_at(w3row, 0, Enum.at(w3row, 0) + Enum.at(hidden2, k4) * delta_output)
                  new_w3 = (new_w3 ++ [w3row])
                  k4 = k4 + 1
                  while_fun_14.(while_fun_14, k4, new_w3)
                else
                  {k4, new_w3}
                end
              end
              {k4, new_w3} = try do
                  while_fun_14.(while_fun_14, k4, new_w3)
                catch
                  {:break, {k4, new_w3}} -> {k4, new_w3}
                end

              net = Map.put(net, :w3, new_w3)
              delta_hidden2 = []
              k5 = 0
              while_fun_15 = fn while_fun_15, delta_hidden2, k5 ->
                if k5 < 3 do
                  row = Enum.at(net.w3, k5)
                  dh2 = Enum.at(row, 0) * delta_output * sigmoid_derivative(Enum.at(hidden2, k5))
                  delta_hidden2 = (delta_hidden2 ++ [dh2])
                  k5 = k5 + 1
                  while_fun_15.(while_fun_15, delta_hidden2, k5)
                else
                  {delta_hidden2, k5}
                end
              end
              {delta_hidden2, k5} = try do
                  while_fun_15.(while_fun_15, delta_hidden2, k5)
                catch
                  {:break, {delta_hidden2, k5}} -> {delta_hidden2, k5}
                end

              new_w2 = []
              j = 0
              while_fun_16 = fn while_fun_16, j, new_w2 ->
                if j < 4 do
                  w2row = Enum.at(net.w2, j)
                  k6 = 0
                  while_fun_17 = fn while_fun_17, k6, w2row ->
                    if k6 < 3 do
                      w2row = List.replace_at(w2row, k6, Enum.at(w2row, k6) + Enum.at(hidden1, j) * Enum.at(delta_hidden2, k6))
                      k6 = k6 + 1
                      while_fun_17.(while_fun_17, k6, w2row)
                    else
                      {k6, w2row}
                    end
                  end
                  {k6, w2row} = try do
                      while_fun_17.(while_fun_17, k6, w2row)
                    catch
                      {:break, {k6, w2row}} -> {k6, w2row}
                    end

                  new_w2 = (new_w2 ++ [w2row])
                  j = j + 1
                  while_fun_16.(while_fun_16, j, new_w2)
                else
                  {j, new_w2}
                end
              end
              {j, new_w2} = try do
                  while_fun_16.(while_fun_16, j, new_w2)
                catch
                  {:break, {j, new_w2}} -> {j, new_w2}
                end

              net = Map.put(net, :w2, new_w2)
              delta_hidden1 = []
              j = 0
              while_fun_18 = fn while_fun_18, delta_hidden1, j ->
                if j < 4 do
                  sumdh = 0.0
                  k7 = 0
                  while_fun_19 = fn while_fun_19, k7, sumdh ->
                    if k7 < 3 do
                      row2 = Enum.at(net.w2, j)
                      sumdh = sumdh + Enum.at(row2, k7) * Enum.at(delta_hidden2, k7)
                      k7 = k7 + 1
                      while_fun_19.(while_fun_19, k7, sumdh)
                    else
                      {k7, sumdh}
                    end
                  end
                  {k7, sumdh} = try do
                      while_fun_19.(while_fun_19, k7, sumdh)
                    catch
                      {:break, {k7, sumdh}} -> {k7, sumdh}
                    end

                  delta_hidden1 = (delta_hidden1 ++ [sumdh * sigmoid_derivative(Enum.at(hidden1, j))])
                  j = j + 1
                  while_fun_18.(while_fun_18, delta_hidden1, j)
                else
                  {delta_hidden1, j}
                end
              end
              {delta_hidden1, j} = try do
                  while_fun_18.(while_fun_18, delta_hidden1, j)
                catch
                  {:break, {delta_hidden1, j}} -> {delta_hidden1, j}
                end

              new_w1 = []
              i2 = 0
              while_fun_20 = fn while_fun_20, i2, j, new_w1 ->
                if i2 < 3 do
                  w1row = Enum.at(net.w1, i2)
                  j = 0
                  while_fun_21 = fn while_fun_21, j, w1row ->
                    if j < 4 do
                      w1row = List.replace_at(w1row, j, Enum.at(w1row, j) + Enum.at(inp, i2) * Enum.at(delta_hidden1, j))
                      j = j + 1
                      while_fun_21.(while_fun_21, j, w1row)
                    else
                      {j, w1row}
                    end
                  end
                  {j, w1row} = try do
                      while_fun_21.(while_fun_21, j, w1row)
                    catch
                      {:break, {j, w1row}} -> {j, w1row}
                    end

                  new_w1 = (new_w1 ++ [w1row])
                  i2 = i2 + 1
                  while_fun_20.(while_fun_20, i2, j, new_w1)
                else
                  {i2, j, new_w1}
                end
              end
              {i2, j, new_w1} = try do
                  while_fun_20.(while_fun_20, i2, j, new_w1)
                catch
                  {:break, {i2, j, new_w1}} -> {i2, j, new_w1}
                end

              net = Map.put(net, :w1, new_w1)
              s = s + 1
              while_fun_8.(while_fun_8, net, s)
            else
              {net, s}
            end
          end
          {net, s} = try do
              while_fun_8.(while_fun_8, net, s)
            catch
              {:break, {net, s}} -> {net, s}
            end

          iter = iter + 1
          while_fun_7.(while_fun_7, iter, net)
        else
          {iter, net}
        end
      end
      {iter, net} = try do
          while_fun_7.(while_fun_7, iter, net)
        catch
          {:break, {iter, net}} -> {iter, net}
        end

    catch
      {:return, val} -> val
    end
  end
  def predict(net, input) do
    try do
      out = feedforward(net, input)
      if out > 0.6 do
        throw {:return, 1}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def example() do
    try do
      inputs = [[0.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [0.0, 1.0, 1.0], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [1.0, 1.0, 0.0], [1.0, 1.0, 1.0]]
      outputs = [0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0]
      net = new_network()
      train(net, inputs, outputs, 10)
      result = predict(net, [1.0, 1.0, 1.0])
      IO.puts(Kernel.to_string(result))
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      example()
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
