# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_data(source_data) do
    try do
      data_lists = []
      i = 0
      while_fun = fn while_fun, data_lists, i ->
        if i < _len(source_data) do
          row = Enum.at(source_data, i)
          j = 0
          while_fun_2 = fn while_fun_2, data_lists, j ->
            if j < _len(row) do
              {data_lists} = if _len(data_lists) < j + 1 do
                empty = []
                data_lists = (data_lists ++ [empty])
                {data_lists}
              else
                {data_lists}
              end
              data_lists = List.replace_at(data_lists, j, (Enum.at(data_lists, j) ++ [Enum.at(row, j)]))
              j = j + 1
              while_fun_2.(while_fun_2, data_lists, j)
            else
              {data_lists, j}
            end
          end
          {data_lists, j} = try do
              while_fun_2.(while_fun_2, data_lists, j)
            catch
              {:break, {data_lists, j}} -> {data_lists, j}
            end

          i = i + 1
          while_fun.(while_fun, data_lists, i)
        else
          {data_lists, i}
        end
      end
      {data_lists, i} = try do
          while_fun.(while_fun, data_lists, i)
        catch
          {:break, {data_lists, i}} -> {data_lists, i}
        end

      throw {:return, data_lists}
    catch
      {:return, val} -> val
    end
  end
  def calculate_each_score(data_lists, weights) do
    try do
      score_lists = []
      i = 0
      while_fun_3 = fn while_fun_3, i, score_lists ->
        if i < _len(data_lists) do
          dlist = Enum.at(data_lists, i)
          weight = Enum.at(weights, i)
          mind = Enum.at(dlist, 0)
          maxd = Enum.at(dlist, 0)
          j = 1
          while_fun_4 = fn while_fun_4, j, maxd, mind ->
            if j < _len(dlist) do
              val = Enum.at(dlist, j)
              {mind} = if val < mind do
                mind = val
                {mind}
              else
                {mind}
              end
              {maxd} = if val > maxd do
                maxd = val
                {maxd}
              else
                {maxd}
              end
              j = j + 1
              while_fun_4.(while_fun_4, j, maxd, mind)
            else
              {j, maxd, mind}
            end
          end
          {j, maxd, mind} = try do
              while_fun_4.(while_fun_4, j, maxd, mind)
            catch
              {:break, {j, maxd, mind}} -> {j, maxd, mind}
            end

          score = []
          j = 0
          {j, score} = if weight == 0 do
            while_fun_5 = fn while_fun_5, j, score ->
              if j < _len(dlist) do
                item = Enum.at(dlist, j)
                score = (if maxd - mind == 0.0, do: (score ++ [1.0]), else: (score ++ [1.0 - ((item - mind) / (maxd - mind))]))
                j = j + 1
                while_fun_5.(while_fun_5, j, score)
              else
                {j, score}
              end
            end
            {j, score} = try do
                while_fun_5.(while_fun_5, j, score)
              catch
                {:break, {j, score}} -> {j, score}
              end

            {j, score}
          else
            while_fun_6 = fn while_fun_6, j, score ->
              if j < _len(dlist) do
                item = Enum.at(dlist, j)
                score = (if maxd - mind == 0.0, do: (score ++ [0.0]), else: (score ++ [(item - mind) / (maxd - mind)]))
                j = j + 1
                while_fun_6.(while_fun_6, j, score)
              else
                {j, score}
              end
            end
            {j, score} = try do
                while_fun_6.(while_fun_6, j, score)
              catch
                {:break, {j, score}} -> {j, score}
              end

            {j, score}
          end
          score_lists = (score_lists ++ [score])
          i = i + 1
          while_fun_3.(while_fun_3, i, score_lists)
        else
          {i, score_lists}
        end
      end
      {i, score_lists} = try do
          while_fun_3.(while_fun_3, i, score_lists)
        catch
          {:break, {i, score_lists}} -> {i, score_lists}
        end

      throw {:return, score_lists}
    catch
      {:return, val} -> val
    end
  end
  def generate_final_scores(score_lists) do
    try do
      count = _len(Enum.at(score_lists, 0))
      final_scores = []
      i = 0
      while_fun_7 = fn while_fun_7, final_scores, i ->
        if i < count do
          final_scores = (final_scores ++ [0.0])
          i = i + 1
          while_fun_7.(while_fun_7, final_scores, i)
        else
          {final_scores, i}
        end
      end
      {final_scores, i} = try do
          while_fun_7.(while_fun_7, final_scores, i)
        catch
          {:break, {final_scores, i}} -> {final_scores, i}
        end

      i = 0
      while_fun_8 = fn while_fun_8, final_scores, i ->
        if i < _len(score_lists) do
          slist = Enum.at(score_lists, i)
          j = 0
          while_fun_9 = fn while_fun_9, final_scores, j ->
            if j < _len(slist) do
              final_scores = List.replace_at(final_scores, j, Enum.at(final_scores, j) + Enum.at(slist, j))
              j = j + 1
              while_fun_9.(while_fun_9, final_scores, j)
            else
              {final_scores, j}
            end
          end
          {final_scores, j} = try do
              while_fun_9.(while_fun_9, final_scores, j)
            catch
              {:break, {final_scores, j}} -> {final_scores, j}
            end

          i = i + 1
          while_fun_8.(while_fun_8, final_scores, i)
        else
          {final_scores, i}
        end
      end
      {final_scores, i} = try do
          while_fun_8.(while_fun_8, final_scores, i)
        catch
          {:break, {final_scores, i}} -> {final_scores, i}
        end

      throw {:return, final_scores}
    catch
      {:return, val} -> val
    end
  end
  def procentual_proximity(source_data, weights) do
    try do
      data_lists = get_data(source_data)
      score_lists = calculate_each_score(data_lists, weights)
      final_scores = generate_final_scores(score_lists)
      i = 0
      while_fun_10 = fn while_fun_10, i, source_data ->
        if i < _len(final_scores) do
          source_data = List.replace_at(source_data, i, (Enum.at(source_data, i) ++ [Enum.at(final_scores, i)]))
          i = i + 1
          while_fun_10.(while_fun_10, i, source_data)
        else
          {i, source_data}
        end
      end
      {i, source_data} = try do
          while_fun_10.(while_fun_10, i, source_data)
        catch
          {:break, {i, source_data}} -> {i, source_data}
        end

      throw {:return, source_data}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:vehicles, [])
  Process.put(:weights, [0, 0, 1])
  def main() do
    Process.put(:vehicles, (Process.get(:vehicles) ++ [[20.0, 60.0, 2012.0]]))
    Process.put(:vehicles, (Process.get(:vehicles) ++ [[23.0, 90.0, 2015.0]]))
    Process.put(:vehicles, (Process.get(:vehicles) ++ [[22.0, 50.0, 2011.0]]))
    Process.put(:result, procentual_proximity(Process.get(:vehicles), Process.get(:weights)))
    IO.puts(Kernel.inspect(Process.get(:result)))
  end
end
Main.main()
