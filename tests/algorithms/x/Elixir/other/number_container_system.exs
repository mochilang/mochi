# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def remove_at(xs, idx) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) do
          {res} = if i != idx do
            res = (res ++ [Enum.at(xs, i, [])])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def insert_at(xs, idx, val) do
    try do
      res = []
      i = 0
      while_fun_2 = fn while_fun_2, i, res ->
        if i < _len(xs) do
          {res} = if i == idx do
            res = (res ++ [val])
            {res}
          else
            {res}
          end
          res = (res ++ [Enum.at(xs, i, [])])
          i = i + 1
          while_fun_2.(while_fun_2, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_2.(while_fun_2, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      {res} = if idx == _len(xs) do
        res = (res ++ [val])
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def binary_search_delete(array, item) do
    try do
      low = 0
      high = _len(array) - 1
      arr = array
      while_fun_3 = fn while_fun_3, arr, high, low ->
        if low <= high do
          mid = div((low + high), 2)
          {arr, high, low} = if Enum.at(arr, mid, []) == item do
            arr = remove_at(arr, mid)
            throw {:return, arr}
            {arr, high, low}
          else
            {high, low} = if Enum.at(arr, mid, []) < item do
              low = mid + 1
              {high, low}
            else
              high = mid - 1
              {high, low}
            end
            {arr, high, low}
          end
          while_fun_3.(while_fun_3, arr, high, low)
        else
          {arr, high, low}
        end
      end
      {arr, high, low} = try do
          while_fun_3.(while_fun_3, arr, high, low)
        catch
          {:break, {arr, high, low}} -> {arr, high, low}
        end

      IO.puts("ValueError: Either the item is not in the array or the array was unsorted")
      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def binary_search_insert(array, index) do
    try do
      low = 0
      high = _len(array) - 1
      arr = array
      while_fun_4 = fn while_fun_4, arr, high, low ->
        if low <= high do
          mid = div((low + high), 2)
          {arr, high, low} = if Enum.at(arr, mid, []) == index do
            arr = insert_at(arr, mid + 1, index)
            throw {:return, arr}
            {arr, high, low}
          else
            {high, low} = if Enum.at(arr, mid, []) < index do
              low = mid + 1
              {high, low}
            else
              high = mid - 1
              {high, low}
            end
            {arr, high, low}
          end
          while_fun_4.(while_fun_4, arr, high, low)
        else
          {arr, high, low}
        end
      end
      {arr, high, low} = try do
          while_fun_4.(while_fun_4, arr, high, low)
        catch
          {:break, {arr, high, low}} -> {arr, high, low}
        end

      arr = insert_at(arr, low, index)
      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def change(cont, idx, num) do
    try do
      numbermap = cont.numbermap
      indexmap = cont.indexmap
      {numbermap} = if Map.has_key?(indexmap, idx) do
        old = indexmap[idx]
        indexes = numbermap[old]
        numbermap = Map.put(numbermap, old, ((if _len(indexes) == 1, do: [], else: binary_search_delete(indexes, idx))))
        {numbermap}
      else
        {numbermap}
      end
      indexmap = Map.put(indexmap, idx, num)
      numbermap = Map.put(numbermap, num, ((if Map.has_key?(numbermap, num), do: binary_search_insert(numbermap[num], idx), else: [idx])))
      throw {:return, %{numbermap: numbermap, indexmap: indexmap}}
    catch
      {:return, val} -> val
    end
  end
  def find(cont, num) do
    try do
      numbermap = cont.numbermap
      if Map.has_key?(numbermap, num) do
        arr = numbermap[num]
        if _len(arr) > 0 do
          throw {:return, Enum.at(arr, 0, [])}
        end
      end
      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:nm, %{})
  Process.put(:im, %{})
  def main() do
    Process.put(:cont, %{numbermap: Process.get(:nm), indexmap: Process.get(:im)})
    IO.puts(Kernel.inspect(find(Process.get(:cont), 10)))
    Process.put(:cont, change(Process.get(:cont), 0, 10))
    IO.puts(Kernel.inspect(find(Process.get(:cont), 10)))
    Process.put(:cont, change(Process.get(:cont), 0, 20))
    IO.puts(Kernel.inspect(find(Process.get(:cont), 10)))
    IO.puts(Kernel.inspect(find(Process.get(:cont), 20)))
  end
end
Main.main()
