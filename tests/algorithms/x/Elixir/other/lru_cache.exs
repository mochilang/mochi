# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_list() do
    try do
      nodes = []
      head = %{key: 0, value: 0, prev: 0 - 1, next: 1}
      tail = %{key: 0, value: 0, prev: 0, next: 0 - 1}
      nodes = (nodes ++ [head])
      nodes = (nodes ++ [tail])
      throw {:return, %{nodes: nodes, head: 0, tail: 1}}
    catch
      {:return, val} -> val
    end
  end
  def dll_add(lst, idx) do
    try do
      nodes = lst.nodes
      tail_idx = lst.tail
      tail_node = Enum.at(nodes, tail_idx)
      prev_idx = tail_node.prev
      node_ = Enum.at(nodes, idx)
      node_ = Map.put(node_, :prev, prev_idx)
      node_ = Map.put(node_, :next, tail_idx)
      nodes = List.replace_at(nodes, idx, node_)
      prev_node = Enum.at(nodes, prev_idx)
      prev_node = Map.put(prev_node, :next, idx)
      nodes = List.replace_at(nodes, prev_idx, prev_node)
      tail_node = Map.put(tail_node, :prev, idx)
      nodes = List.replace_at(nodes, tail_idx, tail_node)
      lst = Map.put(lst, :nodes, nodes)
      throw {:return, lst}
    catch
      {:return, val} -> val
    end
  end
  def dll_remove(lst, idx) do
    try do
      nodes = lst.nodes
      node_ = Enum.at(nodes, idx)
      prev_idx = node_.prev
      next_idx = node_.next
      if prev_idx == 0 - 1 || next_idx == 0 - 1 do
        throw {:return, lst}
      end
      prev_node = Enum.at(nodes, prev_idx)
      prev_node = Map.put(prev_node, :next, next_idx)
      nodes = List.replace_at(nodes, prev_idx, prev_node)
      next_node = Enum.at(nodes, next_idx)
      next_node = Map.put(next_node, :prev, prev_idx)
      nodes = List.replace_at(nodes, next_idx, next_node)
      node_ = Map.put(node_, :prev, 0 - 1)
      node_ = Map.put(node_, :next, 0 - 1)
      nodes = List.replace_at(nodes, idx, node_)
      lst = Map.put(lst, :nodes, nodes)
      throw {:return, lst}
    catch
      {:return, val} -> val
    end
  end
  def new_cache(cap) do
    try do
      empty_map = %{}
      throw {:return, %{list: new_list(), capacity: cap, num_keys: 0, hits: 0, misses: 0, cache: empty_map}}
    catch
      {:return, val} -> val
    end
  end
  def lru_get(c, key) do
    try do
      cache = c
      key_str = Kernel.to_string(key)
      {cache} = if Map.has_key?(cache.cache, key_str) do
        idx = cache.cache[key_str]
        {cache} = if idx != 0 - 1 do
          cache = Map.put(cache, :hits, cache.hits + 1)
          node_ = Enum.at(cache.list.nodes, idx)
          value = node_.value
          cache = Map.put(cache, :list, dll_remove(cache.list, idx))
          cache = Map.put(cache, :list, dll_add(cache.list, idx))
          throw {:return, %{cache: cache, value: value, ok: true}}
          {cache}
        else
          {cache}
        end
        {cache}
      else
        {cache}
      end
      cache = Map.put(cache, :misses, cache.misses + 1)
      throw {:return, %{cache: cache, value: 0, ok: false}}
    catch
      {:return, val} -> val
    end
  end
  def lru_put(c, key, value) do
    try do
      cache = c
      key_str = Kernel.to_string(key)
      {cache} = if !(Map.has_key?(cache.cache, key_str)) do
        {cache} = if cache.num_keys >= cache.capacity do
          head_node = Enum.at(cache.list.nodes, cache.list.head)
          first_idx = head_node.next
          first_node = Enum.at(cache.list.nodes, first_idx)
          old_key = first_node.key
          cache = Map.put(cache, :list, dll_remove(cache.list, first_idx))
          mdel = cache.cache
          mdel = Map.put(mdel, Kernel.to_string(old_key), 0 - 1)
          cache = Map.put(cache, :cache, mdel)
          cache = Map.put(cache, :num_keys, cache.num_keys - 1)
          {cache}
        else
          {cache}
        end
        nodes = cache.list.nodes
        new_node = %{key: key, value: value, prev: 0 - 1, next: 0 - 1}
        nodes = (nodes ++ [new_node])
        idx = _len(nodes) - 1
        cache = Kernel.put_in(cache, [:list, :nodes], nodes)
        cache = Map.put(cache, :list, dll_add(cache.list, idx))
        m = cache.cache
        m = Map.put(m, key_str, idx)
        cache = Map.put(cache, :cache, m)
        cache = Map.put(cache, :num_keys, cache.num_keys + 1)
        {cache}
      else
        m = cache.cache
        idx = m[key_str]
        nodes = cache.list.nodes
        node_ = Enum.at(nodes, idx)
        node_ = Map.put(node_, :value, value)
        nodes = List.replace_at(nodes, idx, node_)
        cache = Kernel.put_in(cache, [:list, :nodes], nodes)
        cache = Map.put(cache, :list, dll_remove(cache.list, idx))
        cache = Map.put(cache, :list, dll_add(cache.list, idx))
        cache = Map.put(cache, :cache, m)
        {cache}
      end
      throw {:return, cache}
    catch
      {:return, val} -> val
    end
  end
  def cache_info(cache) do
    try do
      throw {:return, (((((((("CacheInfo(hits=" <> Kernel.to_string(cache.hits)) <> ", misses=") <> Kernel.to_string(cache.misses)) <> ", capacity=") <> Kernel.to_string(cache.capacity)) <> ", current size=") <> Kernel.to_string(cache.num_keys)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def print_result(res) do
    try do
      if res.ok do
        IO.puts(Kernel.to_string(res.value))
      else
        IO.puts("None")
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      cache = new_cache(2)
      cache = lru_put(cache, 1, 1)
      cache = lru_put(cache, 2, 2)
      r1 = lru_get(cache, 1)
      cache = r1.cache
      print_result(r1)
      cache = lru_put(cache, 3, 3)
      r2 = lru_get(cache, 2)
      cache = r2.cache
      print_result(r2)
      cache = lru_put(cache, 4, 4)
      r3 = lru_get(cache, 1)
      cache = r3.cache
      print_result(r3)
      r4 = lru_get(cache, 3)
      cache = r4.cache
      print_result(r4)
      r5 = lru_get(cache, 4)
      cache = r5.cache
      print_result(r5)
      IO.puts(Kernel.inspect(cache_info(cache)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
