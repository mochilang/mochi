# Code generated by Mochi transpiler 2025-08-12 09:13 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_value(t) do
    try do
      throw {:return, t.value}
    catch
      {:return, val} -> val
    end
  end
  def get_weight(t) do
    try do
      throw {:return, t.weight}
    catch
      {:return, val} -> val
    end
  end
  def get_name(t) do
    try do
      throw {:return, t.name}
    catch
      {:return, val} -> val
    end
  end
  def value_weight(t) do
    try do
      throw {:return, t.value / t.weight}
    catch
      {:return, val} -> val
    end
  end
  def build_menu(names, values, weights) do
    try do
      menu = []
      i = 0
      while_fun = fn while_fun, i, menu ->
        if i < _len(values) && i < _len(names) && i < _len(weights) do
          menu = (menu ++ [%{name: Enum.at(names, i, []), value: Enum.at(values, i, []), weight: Enum.at(weights, i, [])}])
          i = i + 1
          while_fun.(while_fun, i, menu)
        else
          {i, menu}
        end
      end
      {i, menu} = try do
          while_fun.(while_fun, i, menu)
        catch
          {:break, {i, menu}} -> {i, menu}
        end

      throw {:return, menu}
    catch
      {:return, val} -> val
    end
  end
  def sort_desc(items, key_func) do
    try do
      arr = []
      i = 0
      while_fun_2 = fn while_fun_2, arr, i ->
        if i < _len(items) do
          arr = (arr ++ [Enum.at(items, i, [])])
          i = i + 1
          while_fun_2.(while_fun_2, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_2.(while_fun_2, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      j = 1
      while_fun_3 = fn while_fun_3, arr, j ->
        if j < _len(arr) do
          key_item = Enum.at(arr, j, [])
          key_val = key_func.(key_item)
          k = j - 1
          while_fun_4 = fn while_fun_4, arr, k ->
            if k >= 0 && key_func.(Enum.at(arr, k, [])) < key_val do
              arr = List.replace_at(arr, k + 1, Enum.at(arr, k, []))
              k = k - 1
              while_fun_4.(while_fun_4, arr, k)
            else
              {arr, k}
            end
          end
          {arr, k} = try do
              while_fun_4.(while_fun_4, arr, k)
            catch
              {:break, {arr, k}} -> {arr, k}
            end

          arr = List.replace_at(arr, k + 1, key_item)
          j = j + 1
          while_fun_3.(while_fun_3, arr, j)
        else
          {arr, j}
        end
      end
      {arr, j} = try do
          while_fun_3.(while_fun_3, arr, j)
        catch
          {:break, {arr, j}} -> {arr, j}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def greedy(items, max_cost, key_func) do
    try do
      items_copy = sort_desc(items, key_func)
      result = []
      total_value = 0.0
      total_cost = 0.0
      i = 0
      while_fun_5 = fn while_fun_5, i, result, total_cost, total_value ->
        if i < _len(items_copy) do
          it = Enum.at(items_copy, i, [])
          w = get_weight(it)
          {result, total_cost, total_value} = if total_cost + w <= max_cost do
            result = (result ++ [it])
            total_cost = total_cost + w
            total_value = total_value + get_value(it)
            {result, total_cost, total_value}
          else
            {result, total_cost, total_value}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, result, total_cost, total_value)
        else
          {i, result, total_cost, total_value}
        end
      end
      {i, result, total_cost, total_value} = try do
          while_fun_5.(while_fun_5, i, result, total_cost, total_value)
        catch
          {:break, {i, result, total_cost, total_value}} -> {i, result, total_cost, total_value}
        end

      throw {:return, %{items: result, total_value: total_value}}
    catch
      {:return, val} -> val
    end
  end
  def thing_to_string(t) do
    try do
      throw {:return, (((((("Thing(" <> t.name) <> ", ") <> Kernel.to_string(t.value)) <> ", ") <> Kernel.to_string(t.weight)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def list_to_string(ts) do
    try do
      s = "["
      i = 0
      while_fun_6 = fn while_fun_6, i, s ->
        if i < _len(ts) do
          s = (s <> thing_to_string(Enum.at(ts, i, [])))
          {s} = if i < _len(ts) - 1 do
            s = (s <> ", ")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_6.(while_fun_6, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:food, ["Burger", "Pizza", "Coca Cola", "Rice", "Sambhar", "Chicken", "Fries", "Milk"])
  Process.put(:value, [80.0, 100.0, 60.0, 70.0, 50.0, 110.0, 90.0, 60.0])
  Process.put(:weight, [40.0, 60.0, 40.0, 70.0, 100.0, 85.0, 55.0, 70.0])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:foods, build_menu(Process.get(:food), Process.get(:value), Process.get(:weight)))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:foods))))
    Process.put(:res, greedy(Process.get(:foods), 500.0, &get_value/1))
    IO.puts(Kernel.inspect(list_to_string(Process.get(:res).items)))
    IO.puts(Kernel.to_string(Process.get(:res).total_value))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
