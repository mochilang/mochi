# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_cache(n) do
    try do
      if n < 0 do
        raise("n should be an integer greater than 0.")
      end
      cap = (if n == 0, do: 2147483647, else: n)
      throw {:return, %{max_capacity: cap, store: []}}
    catch
      {:return, val} -> val
    end
  end
  def remove_element(xs, x) do
    try do
      res = []
      removed = false
      i = 0
      while_fun = fn while_fun, i, removed, res ->
        if i < _len(xs) do
          v = Enum.at(xs, i)
          {removed, res} = if removed == false && v == x do
            removed = true
            {removed, res}
          else
            res = (res ++ [v])
            {removed, res}
          end
          i = i + 1
          while_fun.(while_fun, i, removed, res)
        else
          {i, removed, res}
        end
      end
      {i, removed, res} = try do
          while_fun.(while_fun, i, removed, res)
        catch
          {:break, {i, removed, res}} -> {i, removed, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def refer(cache, x) do
    try do
      store = cache.store
      exists = false
      i = 0
      while_fun_2 = fn while_fun_2, exists, i ->
        if i < _len(store) do
          {exists} = if Enum.at(store, i) == x do
            exists = true
            {exists}
          else
            {exists}
          end
          i = i + 1
          while_fun_2.(while_fun_2, exists, i)
        else
          {exists, i}
        end
      end
      {exists, i} = try do
          while_fun_2.(while_fun_2, exists, i)
        catch
          {:break, {exists, i}} -> {exists, i}
        end

      {store} = if exists do
        store = remove_element(store, x)
        {store}
      else
        {store} = if _len(store) == cache.max_capacity do
          new_store = []
          j = 0
          while_fun_3 = fn while_fun_3, j, new_store ->
            if j < _len(store) - 1 do
              new_store = (new_store ++ [Enum.at(store, j)])
              j = j + 1
              while_fun_3.(while_fun_3, j, new_store)
            else
              {j, new_store}
            end
          end
          {j, new_store} = try do
              while_fun_3.(while_fun_3, j, new_store)
            catch
              {:break, {j, new_store}} -> {j, new_store}
            end

          store = new_store
          {store}
        else
          {store}
        end
        {store}
      end
      store = ([x] ++ store)
      throw {:return, %{max_capacity: cache.max_capacity, store: store}}
    catch
      {:return, val} -> val
    end
  end
  def display(cache) do
    try do
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(Map.get(cache, :store, [])) do
          IO.puts(Enum.at(cache.store, i))
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def repr_item(s) do
    try do
      all_digits = true
      i = 0
      while_fun_5 = fn while_fun_5, all_digits, i ->
        if i < _len(s) do
          ch = String.at(s, i)
          {all_digits} = if ch < "0" || ch > "9" do
            all_digits = false
            {all_digits}
          else
            {all_digits}
          end
          i = i + 1
          while_fun_5.(while_fun_5, all_digits, i)
        else
          {all_digits, i}
        end
      end
      {all_digits, i} = try do
          while_fun_5.(while_fun_5, all_digits, i)
        catch
          {:break, {all_digits, i}} -> {all_digits, i}
        end

      if all_digits do
        throw {:return, s}
      end
      throw {:return, (("'" <> s) <> "'")}
    catch
      {:return, val} -> val
    end
  end
  def cache_repr(cache) do
    try do
      res = (("LRUCache(" <> Kernel.to_string(cache.max_capacity)) <> ") => [")
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(Map.get(cache, :store, [])) do
          res = (res <> repr_item(Enum.at(cache.store, i)))
          {res} = if i < _len(Map.get(cache, :store, [])) - 1 do
            res = (res <> ", ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res <> "]")
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:lru, new_cache(4))
    Process.put(:lru, refer(Process.get(:lru), "A"))
    Process.put(:lru, refer(Process.get(:lru), "2"))
    Process.put(:lru, refer(Process.get(:lru), "3"))
    Process.put(:lru, refer(Process.get(:lru), "A"))
    Process.put(:lru, refer(Process.get(:lru), "4"))
    Process.put(:lru, refer(Process.get(:lru), "5"))
    Process.put(:r, cache_repr(Process.get(:lru)))
    IO.puts(Process.get(:r))
    if Process.get(:r) != "LRUCache(4) => [5, 4, 'A', 3]" do
      raise("Assertion error")
    end
  end
end
Main.main()
