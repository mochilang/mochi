# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def lfu_new(cap) do
    try do
      throw {:return, %{entries: [], capacity: cap, hits: 0, miss: 0, tick: 0}}
    catch
      {:return, val} -> val
    end
  end
  def find_entry(entries, key) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(entries) do
          e = Enum.at(entries, i)
          if e.key == key do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def lfu_get(cache, key) do
    try do
      idx = find_entry(cache.entries, key)
      if idx == 0 - 1 do
        new_cache = %{entries: cache.entries, capacity: cache.capacity, hits: cache.hits, miss: cache.miss + 1, tick: cache.tick}
        throw {:return, %{cache: new_cache, value: 0, ok: false}}
      end
      entries = cache.entries
      e = Enum.at(entries, idx)
      e = Map.put(e, :freq, e.freq + 1)
      new_tick = cache.tick + 1
      e = Map.put(e, :order, new_tick)
      entries = List.replace_at(entries, idx, e)
      new_cache = %{entries: entries, capacity: cache.capacity, hits: cache.hits + 1, miss: cache.miss, tick: new_tick}
      throw {:return, %{cache: new_cache, value: e.val, ok: true}}
    catch
      {:return, val} -> val
    end
  end
  def remove_lfu(entries) do
    try do
      if _len(entries) == 0 do
        throw {:return, entries}
      end
      min_idx = 0
      i = 1
      while_fun_2 = fn while_fun_2, i, min_idx ->
        if i < _len(entries) do
          e = Enum.at(entries, i)
          m = Enum.at(entries, min_idx)
          {min_idx} = if e.freq < m.freq || (e.freq == m.freq && e.order < m.order) do
            min_idx = i
            {min_idx}
          else
            {min_idx}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, min_idx)
        else
          {i, min_idx}
        end
      end
      {i, min_idx} = try do
          while_fun_2.(while_fun_2, i, min_idx)
        catch
          {:break, {i, min_idx}} -> {i, min_idx}
        end

      res = []
      j = 0
      while_fun_3 = fn while_fun_3, j, res ->
        if j < _len(entries) do
          {res} = if j != min_idx do
            res = (res ++ [Enum.at(entries, j)])
            {res}
          else
            {res}
          end
          j = j + 1
          while_fun_3.(while_fun_3, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_3.(while_fun_3, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def lfu_put(cache, key, value) do
    try do
      entries = cache.entries
      idx = find_entry(entries, key)
      {entries} = if idx != 0 - 1 do
        e = Enum.at(entries, idx)
        e = Map.put(e, :val, value)
        e = Map.put(e, :freq, e.freq + 1)
        new_tick = cache.tick + 1
        e = Map.put(e, :order, new_tick)
        entries = List.replace_at(entries, idx, e)
        throw {:return, %{entries: entries, capacity: cache.capacity, hits: cache.hits, miss: cache.miss, tick: new_tick}}
        {entries}
      else
        {entries}
      end
      {entries} = if _len(entries) >= cache.capacity do
        entries = remove_lfu(entries)
        {entries}
      else
        {entries}
      end
      new_tick = cache.tick + 1
      new_entry = %{key: key, val: value, freq: 1, order: new_tick}
      entries = (entries ++ [new_entry])
      throw {:return, %{entries: entries, capacity: cache.capacity, hits: cache.hits, miss: cache.miss, tick: new_tick}}
    catch
      {:return, val} -> val
    end
  end
  def cache_info(cache) do
    try do
      throw {:return, (((((((("CacheInfo(hits=" <> Kernel.to_string(cache.hits)) <> ", misses=") <> Kernel.to_string(cache.miss)) <> ", capacity=") <> Kernel.to_string(cache.capacity)) <> ", current_size=") <> Kernel.inspect(_len(Map.get(cache, :entries, [])))) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      cache = lfu_new(2)
      cache = lfu_put(cache, 1, 1)
      cache = lfu_put(cache, 2, 2)
      r = lfu_get(cache, 1)
      cache = r.cache
      if r.ok do
        IO.puts(Kernel.to_string(r.value))
      else
        IO.puts("None")
      end
      cache = lfu_put(cache, 3, 3)
      r = lfu_get(cache, 2)
      cache = r.cache
      if r.ok do
        IO.puts(Kernel.to_string(r.value))
      else
        IO.puts("None")
      end
      cache = lfu_put(cache, 4, 4)
      r = lfu_get(cache, 1)
      cache = r.cache
      if r.ok do
        IO.puts(Kernel.to_string(r.value))
      else
        IO.puts("None")
      end
      r = lfu_get(cache, 3)
      cache = r.cache
      if r.ok do
        IO.puts(Kernel.to_string(r.value))
      else
        IO.puts("None")
      end
      r = lfu_get(cache, 4)
      cache = r.cache
      if r.ok do
        IO.puts(Kernel.to_string(r.value))
      else
        IO.puts("None")
      end
      IO.puts(Kernel.inspect(cache_info(cache)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
