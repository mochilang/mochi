# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  def floyd(n) do
    try do
      result = ""
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < n do
          j = 0
          while_fun_2 = fn while_fun_2, j, result ->
            if j < n - i - 1 do
              result = (result <> " ")
              j = j + 1
              while_fun_2.(while_fun_2, j, result)
            else
              {j, result}
            end
          end
          {j, result} = try do
              while_fun_2.(while_fun_2, j, result)
            catch
              {:break, {j, result}} -> {j, result}
            end

          k = 0
          while_fun_3 = fn while_fun_3, k, result ->
            if k < i + 1 do
              result = (result <> "* ")
              k = k + 1
              while_fun_3.(while_fun_3, k, result)
            else
              {k, result}
            end
          end
          {k, result} = try do
              while_fun_3.(while_fun_3, k, result)
            catch
              {:break, {k, result}} -> {k, result}
            end

          result = (result <> "\n")
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def reverse_floyd(n) do
    try do
      result = ""
      i = n
      while_fun_4 = fn while_fun_4, i, result ->
        if i > 0 do
          j = i
          while_fun_5 = fn while_fun_5, j, result ->
            if j > 0 do
              result = (result <> "* ")
              j = j - 1
              while_fun_5.(while_fun_5, j, result)
            else
              {j, result}
            end
          end
          {j, result} = try do
              while_fun_5.(while_fun_5, j, result)
            catch
              {:break, {j, result}} -> {j, result}
            end

          result = (result <> "\n")
          k = n - i + 1
          while_fun_6 = fn while_fun_6, k, result ->
            if k > 0 do
              result = (result <> " ")
              k = k - 1
              while_fun_6.(while_fun_6, k, result)
            else
              {k, result}
            end
          end
          {k, result} = try do
              while_fun_6.(while_fun_6, k, result)
            catch
              {:break, {k, result}} -> {k, result}
            end

          i = i - 1
          while_fun_4.(while_fun_4, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_4.(while_fun_4, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def pretty_print(n) do
    try do
      if n <= 0 do
        throw {:return, "       ...       ....        nothing printing :("}
      end
      upper_half = floyd(n)
      lower_half = reverse_floyd(n)
      throw {:return, (upper_half <> lower_half)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(Kernel.inspect(pretty_print(3)))
      IO.puts(Kernel.inspect(pretty_print(0)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
