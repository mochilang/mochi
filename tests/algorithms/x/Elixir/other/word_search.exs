# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def rand_range(max) do
    try do
      throw {:return, rem(rand(), max)}
    catch
      {:return, val} -> val
    end
  end
  def shuffle(list_int) do
    try do
      i = _len(list_int) - 1
      while_fun = fn while_fun, i, list_int ->
        if i > 0 do
          j = rand_range(i + 1)
          tmp = Enum.at(list_int, i)
          list_int = List.replace_at(list_int, i, Enum.at(list_int, j))
          list_int = List.replace_at(list_int, j, tmp)
          i = i - 1
          while_fun.(while_fun, i, list_int)
        else
          {i, list_int}
        end
      end
      {i, list_int} = try do
          while_fun.(while_fun, i, list_int)
        catch
          {:break, {i, list_int}} -> {i, list_int}
        end

      throw {:return, list_int}
    catch
      {:return, val} -> val
    end
  end
  def rand_letter() do
    try do
      letters = "abcdefghijklmnopqrstuvwxyz"
      i = rand_range(26)
      throw {:return, _slice(letters, i, (i + 1) - i)}
    catch
      {:return, val} -> val
    end
  end
  def make_word_search(words, width, height) do
    try do
      board = []
      r = 0
      while_fun_2 = fn while_fun_2, board, r ->
        if r < height do
          row = []
          c = 0
          while_fun_3 = fn while_fun_3, c, row ->
            if c < width do
              row = (row ++ [""])
              c = c + 1
              while_fun_3.(while_fun_3, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_3.(while_fun_3, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          board = (board ++ [row])
          r = r + 1
          while_fun_2.(while_fun_2, board, r)
        else
          {board, r}
        end
      end
      {board, r} = try do
          while_fun_2.(while_fun_2, board, r)
        catch
          {:break, {board, r}} -> {board, r}
        end

      throw {:return, %{words: words, width: width, height: height, board: board}}
    catch
      {:return, val} -> val
    end
  end
  def insert_dir(ws, word, dr, dc, rows, cols) do
    try do
      word_len = _len(word)
      ri = 0
      while_fun_4 = fn while_fun_4, ri ->
        if ri < _len(rows) do
          {ri} = try do
            row = Enum.at(rows, ri)
            ci = 0
            while_fun_5 = fn while_fun_5, ci ->
              if ci < _len(cols) do
                {ci} = try do
                  col = Enum.at(cols, ci)
                  end_r = row + dr * (word_len - 1)
                  end_c = col + dc * (word_len - 1)
                  {ci} = if end_r < 0 || end_r >= ws.height || end_c < 0 || end_c >= ws.width do
                    ci = ci + 1
                    throw {:continue, {ci}}
                    {ci}
                  else
                    {ci}
                  end
                  k = 0
                  ok = true
                  while_fun_6 = fn while_fun_6, k, ok ->
                    if k < word_len do
                      rr = row + dr * k
                      cc = col + dc * k
                      {ok} = if Enum.at(Enum.at(ws.board, rr), cc) != "" do
                        ok = false
                        throw {:break, {k, ok}}
                        {ok}
                      else
                        {ok}
                      end
                      k = k + 1
                      while_fun_6.(while_fun_6, k, ok)
                    else
                      {k, ok}
                    end
                  end
                  {k, ok} = try do
                      while_fun_6.(while_fun_6, k, ok)
                    catch
                      {:break, {k, ok}} -> {k, ok}
                    end

                  {k} = if ok do
                    k = 0
                    while_fun_7 = fn while_fun_7, k ->
                      if k < word_len do
                        rr2 = row + dr * k
                        cc2 = col + dc * k
                        row_list = Enum.at(ws.board, rr2)
                        row_list = List.replace_at(row_list, cc2, _slice(word, k, (k + 1) - k))
                        k = k + 1
                        while_fun_7.(while_fun_7, k)
                      else
                        k
                      end
                    end
                    k = try do
                        while_fun_7.(while_fun_7, k)
                      catch
                        {:break, {k}} -> k
                      end

                    throw {:return, true}
                    {k}
                  else
                    {k}
                  end
                  ci = ci + 1
                  {ci}
                catch
                  {:continue, {ci}} -> {ci}
                end
                while_fun_5.(while_fun_5, ci)
              else
                ci
              end
            end
            ci = try do
                while_fun_5.(while_fun_5, ci)
              catch
                {:break, {ci}} -> ci
              end

            ri = ri + 1
            {ri}
          catch
            {:continue, {ri}} -> {ri}
          end
          while_fun_4.(while_fun_4, ri)
        else
          ri
        end
      end
      ri = try do
          while_fun_4.(while_fun_4, ri)
        catch
          {:break, {ri}} -> ri
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def generate_board(ws) do
    try do
      dirs_r = [-1, -1, 0, 1, 1, 1, 0, -1]
      dirs_c = [0, 1, 1, 1, 0, -1, -1, -1]
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < _len(Map.get(ws, :words, [])) do
          word = Enum.at(ws.words, i)
          rows = []
          r = 0
          while_fun_9 = fn while_fun_9, r, rows ->
            if r < ws.height do
              rows = (rows ++ [r])
              r = r + 1
              while_fun_9.(while_fun_9, r, rows)
            else
              {r, rows}
            end
          end
          {r, rows} = try do
              while_fun_9.(while_fun_9, r, rows)
            catch
              {:break, {r, rows}} -> {r, rows}
            end

          cols = []
          c = 0
          while_fun_10 = fn while_fun_10, c, cols ->
            if c < ws.width do
              cols = (cols ++ [c])
              c = c + 1
              while_fun_10.(while_fun_10, c, cols)
            else
              {c, cols}
            end
          end
          {c, cols} = try do
              while_fun_10.(while_fun_10, c, cols)
            catch
              {:break, {c, cols}} -> {c, cols}
            end

          rows = shuffle(rows)
          cols = shuffle(cols)
          d = rand_range(8)
          insert_dir(ws, word, Enum.at(dirs_r, d), Enum.at(dirs_c, d), rows, cols)
          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      i = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def visualise(ws, add_fake_chars) do
    try do
      result = ""
      r = 0
      while_fun_11 = fn while_fun_11, r, result ->
        if r < ws.height do
          c = 0
          while_fun_12 = fn while_fun_12, c, result ->
            if c < ws.width do
              ch = Enum.at(Enum.at(ws.board, r), c)
              {ch} = if ch == "" do
                ch = (if add_fake_chars, do: rand_letter(), else: "#")
                {ch}
              else
                {ch}
              end
              result = ((result <> ch) <> " ")
              c = c + 1
              while_fun_12.(while_fun_12, c, result)
            else
              {c, result}
            end
          end
          {c, result} = try do
              while_fun_12.(while_fun_12, c, result)
            catch
              {:break, {c, result}} -> {c, result}
            end

          result = (result <> "\n")
          r = r + 1
          while_fun_11.(while_fun_11, r, result)
        else
          {r, result}
        end
      end
      {r, result} = try do
          while_fun_11.(while_fun_11, r, result)
        catch
          {:break, {r, result}} -> {r, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      words = ["cat", "dog", "snake", "fish"]
      ws = make_word_search(words, 10, 10)
      generate_board(ws)
      IO.puts(Kernel.inspect(visualise(ws, true)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:seed, 123456789)
end
Main.main()
