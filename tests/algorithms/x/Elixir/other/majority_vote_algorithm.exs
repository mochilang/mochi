# Code generated by Mochi transpiler 2025-08-12 10:04 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def index_of(xs, x) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(xs) do
          if Enum.at(xs, i, []) == x do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def majority_vote(votes, votes_needed_to_win) do
    try do
      if votes_needed_to_win < 2 do
        throw {:return, []}
      end
      candidates = []
      counts = []
      i = 0
      while_fun_2 = fn while_fun_2, candidates, counts, i ->
        if i < _len(votes) do
          v = Enum.at(votes, i, [])
          idx = index_of(candidates, v)
          {candidates, counts} = if idx != 0 - 1 do
            counts = List.replace_at(counts, idx, Enum.at(counts, idx, []) + 1)
            {candidates, counts}
          else
            {candidates, counts} = if _len(candidates) < votes_needed_to_win - 1 do
              candidates = (candidates ++ [v])
              counts = (counts ++ [1])
              {candidates, counts}
            else
              j = 0
              while_fun_3 = fn while_fun_3, counts, j ->
                if j < _len(counts) do
                  counts = List.replace_at(counts, j, Enum.at(counts, j, []) - 1)
                  j = j + 1
                  while_fun_3.(while_fun_3, counts, j)
                else
                  {counts, j}
                end
              end
              {counts, j} = try do
                  while_fun_3.(while_fun_3, counts, j)
                catch
                  {:break, {counts, j}} -> {counts, j}
                end

              new_candidates = []
              new_counts = []
              j = 0
              while_fun_4 = fn while_fun_4, j, new_candidates, new_counts ->
                if j < _len(candidates) do
                  {new_candidates, new_counts} = if Enum.at(counts, j, []) > 0 do
                    new_candidates = (new_candidates ++ [Enum.at(candidates, j, [])])
                    new_counts = (new_counts ++ [Enum.at(counts, j, [])])
                    {new_candidates, new_counts}
                  else
                    {new_candidates, new_counts}
                  end
                  j = j + 1
                  while_fun_4.(while_fun_4, j, new_candidates, new_counts)
                else
                  {j, new_candidates, new_counts}
                end
              end
              {j, new_candidates, new_counts} = try do
                  while_fun_4.(while_fun_4, j, new_candidates, new_counts)
                catch
                  {:break, {j, new_candidates, new_counts}} -> {j, new_candidates, new_counts}
                end

              candidates = new_candidates
              counts = new_counts
              {candidates, counts}
            end
            {candidates, counts}
          end
          i = i + 1
          while_fun_2.(while_fun_2, candidates, counts, i)
        else
          {candidates, counts, i}
        end
      end
      {candidates, counts, i} = try do
          while_fun_2.(while_fun_2, candidates, counts, i)
        catch
          {:break, {candidates, counts, i}} -> {candidates, counts, i}
        end

      final_counts = []
      j = 0
      while_fun_5 = fn while_fun_5, final_counts, j ->
        if j < _len(candidates) do
          final_counts = (final_counts ++ [0])
          j = j + 1
          while_fun_5.(while_fun_5, final_counts, j)
        else
          {final_counts, j}
        end
      end
      {final_counts, j} = try do
          while_fun_5.(while_fun_5, final_counts, j)
        catch
          {:break, {final_counts, j}} -> {final_counts, j}
        end

      i = 0
      while_fun_6 = fn while_fun_6, final_counts, i ->
        if i < _len(votes) do
          v = Enum.at(votes, i, [])
          idx = index_of(candidates, v)
          {final_counts} = if idx != 0 - 1 do
            final_counts = List.replace_at(final_counts, idx, Enum.at(final_counts, idx, []) + 1)
            {final_counts}
          else
            {final_counts}
          end
          i = i + 1
          while_fun_6.(while_fun_6, final_counts, i)
        else
          {final_counts, i}
        end
      end
      {final_counts, i} = try do
          while_fun_6.(while_fun_6, final_counts, i)
        catch
          {:break, {final_counts, i}} -> {final_counts, i}
        end

      result = []
      j = 0
      while_fun_7 = fn while_fun_7, j, result ->
        if j < _len(candidates) do
          {result} = if Enum.at(final_counts, j, []) * votes_needed_to_win > _len(votes) do
            result = (result ++ [Enum.at(candidates, j, [])])
            {result}
          else
            {result}
          end
          j = j + 1
          while_fun_7.(while_fun_7, j, result)
        else
          {j, result}
        end
      end
      {j, result} = try do
          while_fun_7.(while_fun_7, j, result)
        catch
          {:break, {j, result}} -> {j, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      votes = [1, 2, 2, 3, 1, 3, 2]
      IO.puts(Kernel.inspect(majority_vote(votes, 3)))
      IO.puts(Kernel.inspect(majority_vote(votes, 2)))
      IO.puts(Kernel.inspect(majority_vote(votes, 4)))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
