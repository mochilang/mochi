# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def new_clause(lits) do
    try do
      m = %{}
      names = []
      i = 0
      while_fun = fn while_fun, i, m, names ->
        if i < _len(lits) do
          lit = Enum.at(lits, i)
          m = Map.put(m, lit, 0 - 1)
          names = (names ++ [lit])
          i = i + 1
          while_fun.(while_fun, i, m, names)
        else
          {i, m, names}
        end
      end
      {i, m, names} = try do
          while_fun.(while_fun, i, m, names)
        catch
          {:break, {i, m, names}} -> {i, m, names}
        end

      throw {:return, %{literals: m, names: names}}
    catch
      {:return, val} -> val
    end
  end
  def assign_clause(c, model) do
    try do
      lits = c.literals
      i = 0
      while_fun_2 = fn while_fun_2, i, lits ->
        if i < _len(Map.get(c, :names, [])) do
          lit = Enum.at(c.names, i)
          symbol = _slice(lit, 0, 2 - (0))
          {lits} = if Map.has_key?(model, symbol) do
            value = model[symbol]
            {value} = if _slice(lit, _len(lit) - 1, _len(lit) - (_len(lit) - 1)) == "'" && value != 0 - 1 do
              value = 1 - value
              {value}
            else
              {value}
            end
            lits = Map.put(lits, lit, value)
            {lits}
          else
            {lits}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, lits)
        else
          {i, lits}
        end
      end
      {i, lits} = try do
          while_fun_2.(while_fun_2, i, lits)
        catch
          {:break, {i, lits}} -> {i, lits}
        end

      c = Map.put(c, :literals, lits)
      throw {:return, c}
    catch
      {:return, val} -> val
    end
  end
  def evaluate_clause(c, model) do
    try do
      i = 0
      while_fun_3 = fn while_fun_3, i ->
        if i < _len(Map.get(c, :names, [])) do
          lit = Enum.at(c.names, i)
          sym = (if _slice(lit, _len(lit) - 1, _len(lit) - (_len(lit) - 1)) == "'", do: _slice(lit, 0, 2 - (0)), else: (lit <> "'"))
          if Map.has_key?(c.literals, sym) do
            throw {:return, %{value: 1, clause: c}}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          {:break, {i}} -> i
        end

      c = assign_clause(c, model)
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < _len(Map.get(c, :names, [])) do
          lit = Enum.at(c.names, i)
          value = c.literals[lit]
          if value == 1 do
            throw {:return, %{value: 1, clause: c}}
          end
          if value == 0 - 1 do
            throw {:return, %{value: 0 - 1, clause: c}}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, {i}} -> i
        end

      any_true = 0
      i = 0
      while_fun_5 = fn while_fun_5, any_true, i ->
        if i < _len(Map.get(c, :names, [])) do
          lit = Enum.at(c.names, i)
          {any_true} = if c.literals[lit] == 1 do
            any_true = 1
            {any_true}
          else
            {any_true}
          end
          i = i + 1
          while_fun_5.(while_fun_5, any_true, i)
        else
          {any_true, i}
        end
      end
      {any_true, i} = try do
          while_fun_5.(while_fun_5, any_true, i)
        catch
          {:break, {any_true, i}} -> {any_true, i}
        end

      throw {:return, %{value: any_true, clause: c}}
    catch
      {:return, val} -> val
    end
  end
  def new_formula(cs) do
    try do
      throw {:return, %{clauses: cs}}
    catch
      {:return, val} -> val
    end
  end
  def remove_symbol(symbols, s) do
    try do
      res = []
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(symbols) do
          {res} = if Enum.at(symbols, i) != s do
            res = (res ++ [Enum.at(symbols, i)])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def dpll_algorithm(clauses, symbols, model) do
    try do
      all_true = true
      i = 0
      while_fun_7 = fn while_fun_7, all_true, i ->
        if i < _len(clauses) do
          ev = evaluate_clause(Enum.at(clauses, i), model)
          clauses = List.replace_at(clauses, i, ev.clause)
          {all_true} = if ev.value == 0 do
            throw {:return, %{sat: false, model: %{}}}
            {all_true}
          else
            {all_true} = if ev.value == 0 - 1 do
              all_true = false
              {all_true}
            else
              {all_true}
            end
            {all_true}
          end
          i = i + 1
          while_fun_7.(while_fun_7, all_true, i)
        else
          {all_true, i}
        end
      end
      {all_true, i} = try do
          while_fun_7.(while_fun_7, all_true, i)
        catch
          {:break, {all_true, i}} -> {all_true, i}
        end

      if all_true do
        throw {:return, %{sat: true, model: model}}
      end
      p = Enum.at(symbols, 0)
      rest = remove_symbol(symbols, p)
      tmp1 = model
      tmp2 = model
      tmp1 = Map.put(tmp1, p, 1)
      tmp2 = Map.put(tmp2, p, 0)
      res1 = dpll_algorithm(clauses, rest, tmp1)
      if res1.sat do
        throw {:return, res1}
      end
      throw {:return, dpll_algorithm(clauses, rest, tmp2)}
    catch
      {:return, val} -> val
    end
  end
  def str_clause(c) do
    try do
      line = "{"
      first = true
      i = 0
      while_fun_8 = fn while_fun_8, first, i, line ->
        if i < _len(Map.get(c, :names, [])) do
          lit = Enum.at(c.names, i)
          {first, line} = if first do
            first = false
            {first, line}
          else
            line = (line <> " , ")
            {first, line}
          end
          line = (line <> lit)
          i = i + 1
          while_fun_8.(while_fun_8, first, i, line)
        else
          {first, i, line}
        end
      end
      {first, i, line} = try do
          while_fun_8.(while_fun_8, first, i, line)
        catch
          {:break, {first, i, line}} -> {first, i, line}
        end

      line = (line <> "}")
      throw {:return, line}
    catch
      {:return, val} -> val
    end
  end
  def str_formula(f) do
    try do
      line = "{"
      i = 0
      while_fun_9 = fn while_fun_9, i, line ->
        if i < _len(Map.get(f, :clauses, [])) do
          line = (line <> str_clause(Enum.at(f.clauses, i)))
          {line} = if i < _len(Map.get(f, :clauses, [])) - 1 do
            line = (line <> " , ")
            {line}
          else
            {line}
          end
          i = i + 1
          while_fun_9.(while_fun_9, i, line)
        else
          {i, line}
        end
      end
      {i, line} = try do
          while_fun_9.(while_fun_9, i, line)
        catch
          {:break, {i, line}} -> {i, line}
        end

      line = (line <> "}")
      throw {:return, line}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:symbols, ["A4", "A3", "A5", "A1"])
  Process.put(:model, %{})
  def main() do
    Process.put(:clause1, new_clause(["A4", "A3", "A5'", "A1", "A3'"]))
    Process.put(:clause2, new_clause(["A4"]))
    Process.put(:formula, new_formula([Process.get(:clause1), Process.get(:clause2)]))
    Process.put(:formula_str, str_formula(Process.get(:formula)))
    Process.put(:clauses, [Process.get(:clause1), Process.get(:clause2)])
    Process.put(:result, dpll_algorithm(Process.get(:clauses), Process.get(:symbols), Process.get(:model)))
    if Process.get(:result).sat do
      IO.puts((("The formula " <> Process.get(:formula_str)) <> " is satisfiable."))
    else
      IO.puts((("The formula " <> Process.get(:formula_str)) <> " is not satisfiable."))
    end
  end
end
Main.main()
