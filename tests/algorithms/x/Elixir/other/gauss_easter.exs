# Code generated by Mochi transpiler 2025-08-09 23:14 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def gauss_easter(year) do
    try do
      metonic_cycle = rem(year, 19)
      julian_leap_year = rem(year, 4)
      non_leap_year = rem(year, 7)
      leap_day_inhibits = div(year, 100)
      lunar_orbit_correction = div((13 + 8 * leap_day_inhibits), 25)
      leap_day_reinstall_number = (:erlang.float(leap_day_inhibits)) / 4.0
      secular_moon_shift = :math.fmod((15.0 - (:erlang.float(lunar_orbit_correction)) + (:erlang.float(leap_day_inhibits)) - leap_day_reinstall_number) * 1.0, 30.0 * 1.0)
      century_starting_point = :math.fmod((4.0 + (:erlang.float(leap_day_inhibits)) - leap_day_reinstall_number) * 1.0, 7.0 * 1.0)
      days_to_add = :math.fmod((19.0 * (:erlang.float(metonic_cycle)) + secular_moon_shift) * 1.0, 30.0 * 1.0)
      days_from_phm_to_sunday = :math.fmod((2.0 * (:erlang.float(julian_leap_year)) + 4.0 * (:erlang.float(non_leap_year)) + 6.0 * days_to_add + century_starting_point) * 1.0, 7.0 * 1.0)
      if days_to_add == 29.0 && days_from_phm_to_sunday == 6.0 do
        throw {:return, %{month: 4, day: 19}}
      end
      if days_to_add == 28.0 && days_from_phm_to_sunday == 6.0 do
        throw {:return, %{month: 4, day: 18}}
      end
      offset = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((days_to_add + days_from_phm_to_sunday))
      total = 22 + offset
      if total > 31 do
        throw {:return, %{month: 4, day: total - 31}}
      end
      throw {:return, %{month: 3, day: total}}
    catch
      {:return, val} -> val
    end
  end
  def format_date(year, d) do
    try do
      month = (if d.month < 10, do: ("0" <> Kernel.to_string(d.month)), else: Kernel.to_string(d.month))
      day = (if d.day < 10, do: ("0" <> Kernel.to_string(d.day)), else: Kernel.to_string(d.day))
      throw {:return, ((((Kernel.to_string(year) <> "-") <> month) <> "-") <> day)}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:years, [1994, 2000, 2010, 2021, 2023, 2032, 2100])
  Process.put(:i, 0)
  def main() do
    while_fun = fn while_fun ->
      if Process.get(:i) < _len(Process.get(:years)) do
        y = Enum.at(Process.get(:years), Process.get(:i))
        e = gauss_easter(y)
        IO.puts(((("Easter in " <> Kernel.to_string(y)) <> " is ") <> format_date(y, e)))
        Process.put(:i, Process.get(:i) + 1)
        while_fun.(while_fun)
      else
        nil
      end
    end
    try do
      while_fun.(while_fun)
    catch
      :break -> nil
    end

  end
end
Main.main()
