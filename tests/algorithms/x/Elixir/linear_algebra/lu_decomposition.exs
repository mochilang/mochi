# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def lu_decomposition(mat) do
    try do
      n = _len(mat)
      if n == 0 do
        throw {:return, %{lower: [], upper: []}}
      end
      m = _len(Enum.at(mat, 0, []))
      if n != m do
        raise("Matrix must be square")
      end
      lower = []
      upper = []
      i = 0
      while_fun = fn while_fun, i, lower, upper ->
        if i < n do
          lrow = []
          urow = []
          j = 0
          while_fun_2 = fn while_fun_2, j, lrow, urow ->
            if j < n do
              lrow = (lrow ++ [0.0])
              urow = (urow ++ [0.0])
              j = j + 1
              while_fun_2.(while_fun_2, j, lrow, urow)
            else
              {j, lrow, urow}
            end
          end
          {j, lrow, urow} = try do
              while_fun_2.(while_fun_2, j, lrow, urow)
            catch
              {:break, {j, lrow, urow}} -> {j, lrow, urow}
            end

          lower = (lower ++ [lrow])
          upper = (upper ++ [urow])
          i = i + 1
          while_fun.(while_fun, i, lower, upper)
        else
          {i, lower, upper}
        end
      end
      {i, lower, upper} = try do
          while_fun.(while_fun, i, lower, upper)
        catch
          {:break, {i, lower, upper}} -> {i, lower, upper}
        end

      i = 0
      while_fun_3 = fn while_fun_3, i, lower, upper ->
        if i < n do
          j1 = 0
          while_fun_4 = fn while_fun_4, j1, lower ->
            if j1 < i do
              total = 0.0
              k = 0
              while_fun_5 = fn while_fun_5, k, total ->
                if k < i do
                  total = total + Enum.at(Enum.at(lower, i, []), k, 0) * Enum.at(Enum.at(upper, k, []), j1, 0)
                  k = k + 1
                  while_fun_5.(while_fun_5, k, total)
                else
                  {k, total}
                end
              end
              {k, total} = try do
                  while_fun_5.(while_fun_5, k, total)
                catch
                  {:break, {k, total}} -> {k, total}
                end

              if Enum.at(Enum.at(upper, j1, []), j1, 0) == 0.0 do
                raise("No LU decomposition exists")
              end
              lower = List.replace_at(lower, i, List.replace_at(Enum.at(lower, i), j1, (Enum.at(Enum.at(mat, i, []), j1, 0) - total) / Enum.at(Enum.at(upper, j1, []), j1, 0)))
              j1 = j1 + 1
              while_fun_4.(while_fun_4, j1, lower)
            else
              {j1, lower}
            end
          end
          {j1, lower} = try do
              while_fun_4.(while_fun_4, j1, lower)
            catch
              {:break, {j1, lower}} -> {j1, lower}
            end

          lower = List.replace_at(lower, i, List.replace_at(Enum.at(lower, i), i, 1.0))
          j2 = i
          while_fun_6 = fn while_fun_6, j2, upper ->
            if j2 < n do
              total2 = 0.0
              k2 = 0
              while_fun_7 = fn while_fun_7, k2, total2 ->
                if k2 < i do
                  total2 = total2 + Enum.at(Enum.at(lower, i, []), k2, 0) * Enum.at(Enum.at(upper, k2, []), j2, 0)
                  k2 = k2 + 1
                  while_fun_7.(while_fun_7, k2, total2)
                else
                  {k2, total2}
                end
              end
              {k2, total2} = try do
                  while_fun_7.(while_fun_7, k2, total2)
                catch
                  {:break, {k2, total2}} -> {k2, total2}
                end

              upper = List.replace_at(upper, i, List.replace_at(Enum.at(upper, i), j2, Enum.at(Enum.at(mat, i, []), j2, 0) - total2))
              j2 = j2 + 1
              while_fun_6.(while_fun_6, j2, upper)
            else
              {j2, upper}
            end
          end
          {j2, upper} = try do
              while_fun_6.(while_fun_6, j2, upper)
            catch
              {:break, {j2, upper}} -> {j2, upper}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, lower, upper)
        else
          {i, lower, upper}
        end
      end
      {i, lower, upper} = try do
          while_fun_3.(while_fun_3, i, lower, upper)
        catch
          {:break, {i, lower, upper}} -> {i, lower, upper}
        end

      throw {:return, %{lower: lower, upper: upper}}
    catch
      {:return, val} -> val
    end
  end
  def print_matrix(mat) do
    try do
      i = 0
      while_fun_8 = fn while_fun_8, i ->
        if i < _len(mat) do
          line = ""
          j = 0
          while_fun_9 = fn while_fun_9, j, line ->
            if j < _len(Enum.at(mat, i, [])) do
              line = (line <> Kernel.to_string(Enum.at(Enum.at(mat, i, []), j, 0)))
              {line} = if j + 1 < _len(Enum.at(mat, i, [])) do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              j = j + 1
              while_fun_9.(while_fun_9, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_9.(while_fun_9, j, line)
            catch
              {:break, {j, line}} -> {j, line}
            end

          IO.puts(line)
          i = i + 1
          while_fun_8.(while_fun_8, i)
        else
          i
        end
      end
      i = try do
          while_fun_8.(while_fun_8, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:matrix, [[2.0, -2.0, 1.0], [0.0, 1.0, 2.0], [5.0, 3.0, 1.0]])
    Process.put(:result, lu_decomposition(Process.get(:matrix)))
    print_matrix(Process.get(:result).lower)
    print_matrix(Process.get(:result).upper)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
