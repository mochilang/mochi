# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def invert_matrix(matrix) do
    try do
      n = _len(matrix)
      aug = []
      i = 0
      while_fun = fn while_fun, aug, i ->
        if i < n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < n do
              row = (row ++ [Enum.at(Enum.at(matrix, i), j)])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          k = 0
          while_fun_3 = fn while_fun_3, k, row ->
            if k < n do
              row = (if i == k, do: (row ++ [1.0]), else: (row ++ [0.0]))
              k = k + 1
              while_fun_3.(while_fun_3, k, row)
            else
              {k, row}
            end
          end
          {k, row} = try do
              while_fun_3.(while_fun_3, k, row)
            catch
              {:break, {k, row}} -> {k, row}
            end

          aug = (aug ++ [row])
          i = i + 1
          while_fun.(while_fun, aug, i)
        else
          {aug, i}
        end
      end
      {aug, i} = try do
          while_fun.(while_fun, aug, i)
        catch
          {:break, {aug, i}} -> {aug, i}
        end

      col = 0
      while_fun_4 = fn while_fun_4, aug, col ->
        if col < n do
          pivot_row = col
          r = col
          while_fun_5 = fn while_fun_5, pivot_row, r ->
            if r < n do
              {pivot_row} = if Enum.at(Enum.at(aug, r), col) != 0.0 do
                pivot_row = r
                throw {:break, {pivot_row, r}}
                {pivot_row}
              else
                {pivot_row}
              end
              r = r + 1
              while_fun_5.(while_fun_5, pivot_row, r)
            else
              {pivot_row, r}
            end
          end
          {pivot_row, r} = try do
              while_fun_5.(while_fun_5, pivot_row, r)
            catch
              {:break, {pivot_row, r}} -> {pivot_row, r}
            end

          if Enum.at(Enum.at(aug, pivot_row), col) == 0.0 do
            raise("Matrix is not invertible")
          end
          {aug} = if pivot_row != col do
            temp = Enum.at(aug, col)
            aug = List.replace_at(aug, col, Enum.at(aug, pivot_row))
            aug = List.replace_at(aug, pivot_row, temp)
            {aug}
          else
            {aug}
          end
          pivot = Enum.at(Enum.at(aug, col), col)
          c = 0
          while_fun_6 = fn while_fun_6, aug, c ->
            if c < 2 * n do
              aug = List.replace_at(aug, col, List.replace_at(Enum.at(aug, col), c, Enum.at(Enum.at(aug, col), c) / pivot))
              c = c + 1
              while_fun_6.(while_fun_6, aug, c)
            else
              {aug, c}
            end
          end
          {aug, c} = try do
              while_fun_6.(while_fun_6, aug, c)
            catch
              {:break, {aug, c}} -> {aug, c}
            end

          r2 = 0
          while_fun_7 = fn while_fun_7, aug, r2 ->
            if r2 < n do
              {aug} = if r2 != col do
                factor = Enum.at(Enum.at(aug, r2), col)
                c2 = 0
                while_fun_8 = fn while_fun_8, aug, c2 ->
                  if c2 < 2 * n do
                    aug = List.replace_at(aug, r2, List.replace_at(Enum.at(aug, r2), c2, Enum.at(Enum.at(aug, r2), c2) - factor * Enum.at(Enum.at(aug, col), c2)))
                    c2 = c2 + 1
                    while_fun_8.(while_fun_8, aug, c2)
                  else
                    {aug, c2}
                  end
                end
                {aug, c2} = try do
                    while_fun_8.(while_fun_8, aug, c2)
                  catch
                    {:break, {aug, c2}} -> {aug, c2}
                  end

                {aug}
              else
                {aug}
              end
              r2 = r2 + 1
              while_fun_7.(while_fun_7, aug, r2)
            else
              {aug, r2}
            end
          end
          {aug, r2} = try do
              while_fun_7.(while_fun_7, aug, r2)
            catch
              {:break, {aug, r2}} -> {aug, r2}
            end

          col = col + 1
          while_fun_4.(while_fun_4, aug, col)
        else
          {aug, col}
        end
      end
      {aug, col} = try do
          while_fun_4.(while_fun_4, aug, col)
        catch
          {:break, {aug, col}} -> {aug, col}
        end

      inv = []
      r3 = 0
      while_fun_9 = fn while_fun_9, inv, r3 ->
        if r3 < n do
          row = []
          c3 = 0
          while_fun_10 = fn while_fun_10, c3, row ->
            if c3 < n do
              row = (row ++ [Enum.at(Enum.at(aug, r3), c3 + n)])
              c3 = c3 + 1
              while_fun_10.(while_fun_10, c3, row)
            else
              {c3, row}
            end
          end
          {c3, row} = try do
              while_fun_10.(while_fun_10, c3, row)
            catch
              {:break, {c3, row}} -> {c3, row}
            end

          inv = (inv ++ [row])
          r3 = r3 + 1
          while_fun_9.(while_fun_9, inv, r3)
        else
          {inv, r3}
        end
      end
      {inv, r3} = try do
          while_fun_9.(while_fun_9, inv, r3)
        catch
          {:break, {inv, r3}} -> {inv, r3}
        end

      throw {:return, inv}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:mat, [[4.0, 7.0], [2.0, 6.0]])
  def main() do
    IO.puts("Original Matrix:")
    IO.puts(Kernel.inspect(Process.get(:mat)))
    IO.puts("Inverted Matrix:")
    IO.puts(Kernel.inspect(invert_matrix(Process.get(:mat))))
  end
end
Main.main()
