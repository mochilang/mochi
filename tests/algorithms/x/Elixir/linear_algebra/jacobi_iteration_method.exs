# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def strictly_diagonally_dominant(matrix) do
    try do
      n = _len(matrix)
      i = 0
      while_fun = fn while_fun, i ->
        if i < n do
          sum = 0.0
          j = 0
          while_fun_2 = fn while_fun_2, j, sum ->
            if j < n do
              {sum} = if i != j do
                sum = sum + absf(Enum.at(Enum.at(matrix, i), j))
                {sum}
              else
                {sum}
              end
              j = j + 1
              while_fun_2.(while_fun_2, j, sum)
            else
              {j, sum}
            end
          end
          {j, sum} = try do
              while_fun_2.(while_fun_2, j, sum)
            catch
              {:break, {j, sum}} -> {j, sum}
            end

          if absf(Enum.at(Enum.at(matrix, i), i)) <= sum do
            raise("Coefficient matrix is not strictly diagonally dominant")
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def jacobi_iteration_method(coefficient, constant, init_val, iterations) do
    try do
      n = _len(coefficient)
      if n == 0 do
        raise("Coefficient matrix cannot be empty")
      end
      if _len(constant) != n do
        raise("Constant vector length must equal number of rows in coefficient matrix")
      end
      if _len(init_val) != n do
        raise("Initial values count must match matrix size")
      end
      r = 0
      while_fun_3 = fn while_fun_3, r ->
        if r < n do
          if _len(Enum.at(coefficient, r)) != n do
            raise("Coefficient matrix must be square")
          end
          r = r + 1
          while_fun_3.(while_fun_3, r)
        else
          r
        end
      end
      r = try do
          while_fun_3.(while_fun_3, r)
        catch
          {:break, {r}} -> r
        end

      if iterations <= 0 do
        raise("Iterations must be at least 1")
      end
      strictly_diagonally_dominant(coefficient)
      x = init_val
      k = 0
      while_fun_4 = fn while_fun_4, k, x ->
        if k < iterations do
          new_x = []
          i = 0
          while_fun_5 = fn while_fun_5, i, new_x ->
            if i < n do
              sum = 0.0
              j = 0
              while_fun_6 = fn while_fun_6, j, sum ->
                if j < n do
                  {sum} = if i != j do
                    sum = sum + Enum.at(Enum.at(coefficient, i), j) * Enum.at(x, j)
                    {sum}
                  else
                    {sum}
                  end
                  j = j + 1
                  while_fun_6.(while_fun_6, j, sum)
                else
                  {j, sum}
                end
              end
              {j, sum} = try do
                  while_fun_6.(while_fun_6, j, sum)
                catch
                  {:break, {j, sum}} -> {j, sum}
                end

              value = (Enum.at(constant, i) - sum) / Enum.at(Enum.at(coefficient, i), i)
              new_x = (new_x ++ [value])
              i = i + 1
              while_fun_5.(while_fun_5, i, new_x)
            else
              {i, new_x}
            end
          end
          {i, new_x} = try do
              while_fun_5.(while_fun_5, i, new_x)
            catch
              {:break, {i, new_x}} -> {i, new_x}
            end

          x = new_x
          k = k + 1
          while_fun_4.(while_fun_4, k, x)
        else
          {k, x}
        end
      end
      {k, x} = try do
          while_fun_4.(while_fun_4, k, x)
        catch
          {:break, {k, x}} -> {k, x}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:coefficient, [[4.0, 1.0, 1.0], [1.0, 5.0, 2.0], [1.0, 2.0, 4.0]])
  Process.put(:iterations, 3)
  def main() do
    Process.put(:constant, [2.0, -6.0, -4.0])
    Process.put(:init_val, [0.5, -0.5, -0.5])
    Process.put(:result, jacobi_iteration_method(Process.get(:coefficient), Process.get(:constant), Process.get(:init_val), Process.get(:iterations)))
    IO.puts(Kernel.inspect(Process.get(:result)))
  end
end
Main.main()
