# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def retroactive_resolution(coefficients, vector) do
    try do
      rows = _len(coefficients)
      x = []
      i = 0
      while_fun = fn while_fun, i, x ->
        if i < rows do
          inner = []
          inner = (inner ++ [0.0])
          x = (x ++ [inner])
          i = i + 1
          while_fun.(while_fun, i, x)
        else
          {i, x}
        end
      end
      {i, x} = try do
          while_fun.(while_fun, i, x)
        catch
          {:break, {i, x}} -> {i, x}
        end

      r = rows - 1
      while_fun_2 = fn while_fun_2, r, x ->
        if r >= 0 do
          total = 0.0
          c = r + 1
          while_fun_3 = fn while_fun_3, c, total ->
            if c < rows do
              total = total + Enum.at(Enum.at(coefficients, r), c) * Enum.at(Enum.at(x, c), 0)
              c = c + 1
              while_fun_3.(while_fun_3, c, total)
            else
              {c, total}
            end
          end
          {c, total} = try do
              while_fun_3.(while_fun_3, c, total)
            catch
              {:break, {c, total}} -> {c, total}
            end

          x = List.replace_at(x, r, List.replace_at(Enum.at(x, r), 0, (Enum.at(Enum.at(vector, r), 0) - total) / Enum.at(Enum.at(coefficients, r), r)))
          r = r - 1
          while_fun_2.(while_fun_2, r, x)
        else
          {r, x}
        end
      end
      {r, x} = try do
          while_fun_2.(while_fun_2, r, x)
        catch
          {:break, {r, x}} -> {r, x}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def gaussian_elimination(coefficients, vector) do
    try do
      rows = _len(coefficients)
      columns = _len(Enum.at(coefficients, 0))
      if rows != columns do
        throw {:return, []}
      end
      augmented = []
      i = 0
      while_fun_4 = fn while_fun_4, augmented, i ->
        if i < rows do
          row = []
          j = 0
          while_fun_5 = fn while_fun_5, j, row ->
            if j < columns do
              row = (row ++ [Enum.at(Enum.at(coefficients, i), j)])
              j = j + 1
              while_fun_5.(while_fun_5, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_5.(while_fun_5, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          row = (row ++ [Enum.at(Enum.at(vector, i), 0)])
          augmented = (augmented ++ [row])
          i = i + 1
          while_fun_4.(while_fun_4, augmented, i)
        else
          {augmented, i}
        end
      end
      {augmented, i} = try do
          while_fun_4.(while_fun_4, augmented, i)
        catch
          {:break, {augmented, i}} -> {augmented, i}
        end

      row_idx = 0
      while_fun_6 = fn while_fun_6, augmented, row_idx ->
        if row_idx < rows - 1 do
          pivot = Enum.at(Enum.at(augmented, row_idx), row_idx)
          col = row_idx + 1
          while_fun_7 = fn while_fun_7, augmented, col ->
            if col < rows do
              factor = Enum.at(Enum.at(augmented, col), row_idx) / pivot
              k = row_idx
              while_fun_8 = fn while_fun_8, augmented, k ->
                if k < columns + 1 do
                  augmented = List.replace_at(augmented, col, List.replace_at(Enum.at(augmented, col), k, Enum.at(Enum.at(augmented, col), k) - factor * Enum.at(Enum.at(augmented, row_idx), k)))
                  k = k + 1
                  while_fun_8.(while_fun_8, augmented, k)
                else
                  {augmented, k}
                end
              end
              {augmented, k} = try do
                  while_fun_8.(while_fun_8, augmented, k)
                catch
                  {:break, {augmented, k}} -> {augmented, k}
                end

              col = col + 1
              while_fun_7.(while_fun_7, augmented, col)
            else
              {augmented, col}
            end
          end
          {augmented, col} = try do
              while_fun_7.(while_fun_7, augmented, col)
            catch
              {:break, {augmented, col}} -> {augmented, col}
            end

          row_idx = row_idx + 1
          while_fun_6.(while_fun_6, augmented, row_idx)
        else
          {augmented, row_idx}
        end
      end
      {augmented, row_idx} = try do
          while_fun_6.(while_fun_6, augmented, row_idx)
        catch
          {:break, {augmented, row_idx}} -> {augmented, row_idx}
        end

      coeffs = []
      vec = []
      r = 0
      while_fun_9 = fn while_fun_9, coeffs, r, vec ->
        if r < rows do
          row = []
          c = 0
          while_fun_10 = fn while_fun_10, c, row ->
            if c < columns do
              row = (row ++ [Enum.at(Enum.at(augmented, r), c)])
              c = c + 1
              while_fun_10.(while_fun_10, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_10.(while_fun_10, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          coeffs = (coeffs ++ [row])
          vec = (vec ++ [[Enum.at(Enum.at(augmented, r), columns)]])
          r = r + 1
          while_fun_9.(while_fun_9, coeffs, r, vec)
        else
          {coeffs, r, vec}
        end
      end
      {coeffs, r, vec} = try do
          while_fun_9.(while_fun_9, coeffs, r, vec)
        catch
          {:break, {coeffs, r, vec}} -> {coeffs, r, vec}
        end

      x = retroactive_resolution(coeffs, vec)
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts(Kernel.inspect(gaussian_elimination([[1.0, -4.0, -2.0], [5.0, 2.0, -2.0], [1.0, -1.0, 0.0]], [[-2.0], [-3.0], [4.0]])))
    IO.puts(Kernel.inspect(gaussian_elimination([[1.0, 2.0], [5.0, 2.0]], [[5.0], [5.0]])))
  end
end
Main.main()
