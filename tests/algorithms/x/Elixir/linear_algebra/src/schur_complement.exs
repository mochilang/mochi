# Code generated by Mochi transpiler 2025-08-08 20:44 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def identity(n) do
    try do
      mat = []
      i = 0
      while_fun = fn while_fun, i, mat ->
        if i < n do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < n do
              row = (if i == j, do: (row ++ [1.0]), else: (row ++ [0.0]))
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun.(while_fun, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun.(while_fun, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, mat}
    catch
      {:return, val} -> val
    end
  end
  def transpose(mat) do
    try do
      rows = _len(mat)
      cols = _len(Enum.at(mat, 0))
      res = []
      j = 0
      while_fun_3 = fn while_fun_3, j, res ->
        if j < cols do
          row = []
          i = 0
          while_fun_4 = fn while_fun_4, i, row ->
            if i < rows do
              row = (row ++ [Enum.at(Enum.at(mat, i), j)])
              i = i + 1
              while_fun_4.(while_fun_4, i, row)
            else
              {i, row}
            end
          end
          {i, row} = try do
              while_fun_4.(while_fun_4, i, row)
            catch
              {:break, {i, row}} -> {i, row}
            end

          res = (res ++ [row])
          j = j + 1
          while_fun_3.(while_fun_3, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_3.(while_fun_3, j, res)
        catch
          {:break, {j, res}} -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matmul(a, b) do
    try do
      rows = _len(a)
      cols = _len(Enum.at(b, 0))
      inner = _len(Enum.at(a, 0))
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < rows do
          row = []
          j = 0
          while_fun_6 = fn while_fun_6, j, row ->
            if j < cols do
              sum = 0.0
              k = 0
              while_fun_7 = fn while_fun_7, k, sum ->
                if k < inner do
                  sum = sum + Enum.at(Enum.at(a, i), k) * Enum.at(Enum.at(b, k), j)
                  k = k + 1
                  while_fun_7.(while_fun_7, k, sum)
                else
                  {k, sum}
                end
              end
              {k, sum} = try do
                  while_fun_7.(while_fun_7, k, sum)
                catch
                  {:break, {k, sum}} -> {k, sum}
                end

              row = (row ++ [sum])
              j = j + 1
              while_fun_6.(while_fun_6, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_6.(while_fun_6, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def mat_sub(a, b) do
    try do
      rows = _len(a)
      cols = _len(Enum.at(a, 0))
      res = []
      i = 0
      while_fun_8 = fn while_fun_8, i, res ->
        if i < rows do
          row = []
          j = 0
          while_fun_9 = fn while_fun_9, j, row ->
            if j < cols do
              row = (row ++ [Enum.at(Enum.at(a, i), j) - Enum.at(Enum.at(b, i), j)])
              j = j + 1
              while_fun_9.(while_fun_9, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_9.(while_fun_9, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_8.(while_fun_8, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_8.(while_fun_8, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def inverse(mat) do
    try do
      n = _len(mat)
      id = identity(n)
      aug = []
      i = 0
      while_fun_10 = fn while_fun_10, aug, i ->
        if i < n do
          row = (Enum.at(mat, i) ++ Enum.at(id, i))
          aug = (aug ++ [row])
          i = i + 1
          while_fun_10.(while_fun_10, aug, i)
        else
          {aug, i}
        end
      end
      {aug, i} = try do
          while_fun_10.(while_fun_10, aug, i)
        catch
          {:break, {aug, i}} -> {aug, i}
        end

      col = 0
      while_fun_11 = fn while_fun_11, aug, col ->
        if col < n do
          pivot_row = Enum.at(aug, col)
          pivot = Enum.at(pivot_row, col)
          if pivot == 0.0 do
            raise("matrix is singular")
          end
          j = 0
          while_fun_12 = fn while_fun_12, j, pivot_row ->
            if j < 2 * n do
              pivot_row = List.replace_at(pivot_row, j, Enum.at(pivot_row, j) / pivot)
              j = j + 1
              while_fun_12.(while_fun_12, j, pivot_row)
            else
              {j, pivot_row}
            end
          end
          {j, pivot_row} = try do
              while_fun_12.(while_fun_12, j, pivot_row)
            catch
              {:break, {j, pivot_row}} -> {j, pivot_row}
            end

          aug = List.replace_at(aug, col, pivot_row)
          r = 0
          while_fun_13 = fn while_fun_13, aug, j, r ->
            if r < n do
              {aug, j} = if r != col do
                row_r = Enum.at(aug, r)
                factor = Enum.at(row_r, col)
                j = 0
                while_fun_14 = fn while_fun_14, j, row_r ->
                  if j < 2 * n do
                    row_r = List.replace_at(row_r, j, Enum.at(row_r, j) - factor * Enum.at(pivot_row, j))
                    j = j + 1
                    while_fun_14.(while_fun_14, j, row_r)
                  else
                    {j, row_r}
                  end
                end
                {j, row_r} = try do
                    while_fun_14.(while_fun_14, j, row_r)
                  catch
                    {:break, {j, row_r}} -> {j, row_r}
                  end

                aug = List.replace_at(aug, r, row_r)
                {aug, j}
              else
                {aug, j}
              end
              r = r + 1
              while_fun_13.(while_fun_13, aug, j, r)
            else
              {aug, j, r}
            end
          end
          {aug, j, r} = try do
              while_fun_13.(while_fun_13, aug, j, r)
            catch
              {:break, {aug, j, r}} -> {aug, j, r}
            end

          col = col + 1
          while_fun_11.(while_fun_11, aug, col)
        else
          {aug, col}
        end
      end
      {aug, col} = try do
          while_fun_11.(while_fun_11, aug, col)
        catch
          {:break, {aug, col}} -> {aug, col}
        end

      inv = []
      r = 0
      while_fun_15 = fn while_fun_15, inv, r ->
        if r < n do
          row = []
          c = n
          while_fun_16 = fn while_fun_16, c, row ->
            if c < 2 * n do
              row = (row ++ [Enum.at(Enum.at(aug, r), c)])
              c = c + 1
              while_fun_16.(while_fun_16, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_16.(while_fun_16, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          inv = (inv ++ [row])
          r = r + 1
          while_fun_15.(while_fun_15, inv, r)
        else
          {inv, r}
        end
      end
      {inv, r} = try do
          while_fun_15.(while_fun_15, inv, r)
        catch
          {:break, {inv, r}} -> {inv, r}
        end

      throw {:return, inv}
    catch
      {:return, val} -> val
    end
  end
  def schur_complement(mat_a, mat_b, mat_c, pseudo_inv) do
    try do
      a_rows = _len(mat_a)
      a_cols = _len(Enum.at(mat_a, 0))
      if a_rows != a_cols do
        raise("Matrix A must be square")
      end
      if a_rows != _len(mat_b) do
        raise("Expected the same number of rows for A and B")
      end
      if _len(Enum.at(mat_b, 0)) != _len(Enum.at(mat_c, 0)) do
        raise("Expected the same number of columns for B and C")
      end
      a_inv = nil
      a_inv = (if pseudo_inv.ok, do: pseudo_inv.value, else: inverse(mat_a))
      bt = transpose(mat_b)
      a_inv_b = matmul(a_inv, mat_b)
      bt_a_inv_b = matmul(bt, a_inv_b)
      throw {:return, mat_sub(mat_c, bt_a_inv_b)}
    catch
      {:return, val} -> val
    end
  end
  def print_matrix(mat) do
    try do
      i = 0
      while_fun_17 = fn while_fun_17, i ->
        if i < _len(mat) do
          line = ""
          j = 0
          row = Enum.at(mat, i)
          while_fun_18 = fn while_fun_18, j, line ->
            if j < _len(row) do
              line = (line <> Kernel.to_string(Enum.at(row, j)))
              {line} = if j + 1 < _len(row) do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              j = j + 1
              while_fun_18.(while_fun_18, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_18.(while_fun_18, j, line)
            catch
              {:break, {j, line}} -> {j, line}
            end

          IO.puts(line)
          i = i + 1
          while_fun_17.(while_fun_17, i)
        else
          i
        end
      end
      i = try do
          while_fun_17.(while_fun_17, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      a = [[1.0, 2.0], [2.0, 1.0]]
      b = [[0.0, 3.0], [3.0, 0.0]]
      c = [[2.0, 1.0], [6.0, 3.0]]
      none = %{value: [], ok: false}
      s = schur_complement(a, b, c, none)
      print_matrix(s)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
