# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rank_of_matrix(matrix) do
    try do
      rows = _len(matrix)
      if rows == 0 do
        throw {:return, 0}
      end
      columns = (if _len(Enum.at(matrix, 0)) > 0, do: _len(Enum.at(matrix, 0)), else: 0)
      rank = (if rows < columns, do: rows, else: columns)
      row = 0
      while_fun = fn while_fun, matrix, rank, row ->
        if row < rank do
          {matrix, rank, row} = if Enum.at(Enum.at(matrix, row), row) != 0.0 do
            col = row + 1
            while_fun_2 = fn while_fun_2, col, matrix ->
              if col < rows do
                mult = Enum.at(Enum.at(matrix, col), row) / Enum.at(Enum.at(matrix, row), row)
                i = row
                while_fun_3 = fn while_fun_3, i, matrix ->
                  if i < columns do
                    matrix = List.replace_at(matrix, col, List.replace_at(Enum.at(matrix, col), i, Enum.at(Enum.at(matrix, col), i) - mult * Enum.at(Enum.at(matrix, row), i)))
                    i = i + 1
                    while_fun_3.(while_fun_3, i, matrix)
                  else
                    {i, matrix}
                  end
                end
                {i, matrix} = try do
                    while_fun_3.(while_fun_3, i, matrix)
                  catch
                    {:break, {i, matrix}} -> {i, matrix}
                  end

                col = col + 1
                while_fun_2.(while_fun_2, col, matrix)
              else
                {col, matrix}
              end
            end
            {col, matrix} = try do
                while_fun_2.(while_fun_2, col, matrix)
              catch
                {:break, {col, matrix}} -> {col, matrix}
              end

            {matrix, rank, row}
          else
            reduce = true
            i = row + 1
            while_fun_4 = fn while_fun_4, i, matrix, reduce ->
              if i < rows do
                {matrix, reduce} = if Enum.at(Enum.at(matrix, i), row) != 0.0 do
                  temp = Enum.at(matrix, row)
                  matrix = List.replace_at(matrix, row, Enum.at(matrix, i))
                  matrix = List.replace_at(matrix, i, temp)
                  reduce = false
                  throw {:break, {i, matrix, reduce}}
                  {matrix, reduce}
                else
                  {matrix, reduce}
                end
                i = i + 1
                while_fun_4.(while_fun_4, i, matrix, reduce)
              else
                {i, matrix, reduce}
              end
            end
            {i, matrix, reduce} = try do
                while_fun_4.(while_fun_4, i, matrix, reduce)
              catch
                {:break, {i, matrix, reduce}} -> {i, matrix, reduce}
              end

            {matrix, rank} = if reduce do
              rank = rank - 1
              j = 0
              while_fun_5 = fn while_fun_5, j, matrix ->
                if j < rows do
                  matrix = List.replace_at(matrix, j, List.replace_at(Enum.at(matrix, j), row, Enum.at(Enum.at(matrix, j), rank)))
                  j = j + 1
                  while_fun_5.(while_fun_5, j, matrix)
                else
                  {j, matrix}
                end
              end
              {j, matrix} = try do
                  while_fun_5.(while_fun_5, j, matrix)
                catch
                  {:break, {j, matrix}} -> {j, matrix}
                end

              {matrix, rank}
            else
              {matrix, rank}
            end
            row = row - 1
            {matrix, rank, row}
          end
          row = row + 1
          while_fun.(while_fun, matrix, rank, row)
        else
          {matrix, rank, row}
        end
      end
      {matrix, rank, row} = try do
          while_fun.(while_fun, matrix, rank, row)
        catch
          {:break, {matrix, rank, row}} -> {matrix, rank, row}
        end

      throw {:return, rank}
    catch
      {:return, val} -> val
    end
  end
  def main() do
  end
end
Main.main()
