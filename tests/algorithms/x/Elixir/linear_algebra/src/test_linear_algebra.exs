# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def int_to_string(n) do
    try do
      if n == 0 do
        throw {:return, "0"}
      end
      num = n
      neg = false
      {neg, num} = if num < 0 do
        neg = true
        num = -num
        {neg, num}
      else
        {neg, num}
      end
      res = ""
      while_fun = fn while_fun, num, res ->
        if num > 0 do
          digit = rem(num, 10)
          ch = _slice("0123456789", digit, digit + 1 - (digit))
          res = (ch <> res)
          num = div(num, 10)
          while_fun.(while_fun, num, res)
        else
          {num, res}
        end
      end
      {num, res} = try do
          while_fun.(while_fun, num, res)
        catch
          {:break, {num, res}} -> {num, res}
        end

      {res} = if neg do
        res = ("-" <> res)
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def float_to_string(x, dec) do
    try do
      neg = false
      num = x
      {neg, num} = if num < 0.0 do
        neg = true
        num = -num
        {neg, num}
      else
        {neg, num}
      end
      int_part = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(num)
      res = int_to_string(int_part)
      {res} = if dec > 0 do
        res = (res <> ".")
        frac = num - (:erlang.float(int_part))
        i = 0
        while_fun_2 = fn while_fun_2, frac, i, res ->
          if i < dec do
            frac = frac * 10.0
            digit = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(frac)
            res = (res <> _slice("0123456789", digit, digit + 1 - (digit)))
            frac = frac - (:erlang.float(digit))
            i = i + 1
            while_fun_2.(while_fun_2, frac, i, res)
          else
            {frac, i, res}
          end
        end
        {frac, i, res} = try do
            while_fun_2.(while_fun_2, frac, i, res)
          catch
            {:break, {frac, i, res}} -> {frac, i, res}
          end

        {res}
      else
        {res}
      end
      {res} = if neg do
        res = ("-" <> res)
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vector_component(v, i) do
    try do
      throw {:return, Enum.at(v, i, [])}
    catch
      {:return, val} -> val
    end
  end
  def vector_str_int(v) do
    try do
      s = "("
      i = 0
      while_fun_3 = fn while_fun_3, i, s ->
        if i < _len(v) do
          s = (s <> int_to_string(Enum.at(v, i, [])))
          {s} = if i + 1 < _len(v) do
            s = (s <> ",")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> ")")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def vector_str_float(v, dec) do
    try do
      s = "("
      i = 0
      while_fun_4 = fn while_fun_4, i, s ->
        if i < _len(v) do
          s = (s <> float_to_string(Enum.at(v, i, []), dec))
          {s} = if i + 1 < _len(v) do
            s = (s <> ",")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_4.(while_fun_4, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> ")")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def vector_add(a, b) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i, []) + Enum.at(b, i, [])])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vector_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i, []) - Enum.at(b, i, [])])
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vector_scalar_mul(v, s) do
    try do
      res = []
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < _len(v) do
          res = (res ++ [(:erlang.float(Enum.at(v, i, []))) * s])
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vector_dot(a, b) do
    try do
      sum = 0
      i = 0
      while_fun_8 = fn while_fun_8, i, sum ->
        if i < _len(a) do
          sum = sum + Enum.at(a, i, []) * Enum.at(b, i, [])
          i = i + 1
          while_fun_8.(while_fun_8, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_8.(while_fun_8, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def sqrt_newton(x) do
    try do
      if x == 0.0 do
        throw {:return, 0.0}
      end
      low = 0.0
      high = x
      {high} = if x < 1.0 do
        high = 1.0
        {high}
      else
        {high}
      end
      mid = 0.0
      i = 0
      while_fun_9 = fn while_fun_9, high, i, low, mid ->
        if i < 40 do
          mid = (low + high) / 2.0
          {high, low} = if mid * mid > x do
            high = mid
            {high, low}
          else
            low = mid
            {high, low}
          end
          i = i + 1
          while_fun_9.(while_fun_9, high, i, low, mid)
        else
          {high, i, low, mid}
        end
      end
      {high, i, low, mid} = try do
          while_fun_9.(while_fun_9, high, i, low, mid)
        catch
          {:break, {high, i, low, mid}} -> {high, i, low, mid}
        end

      throw {:return, mid}
    catch
      {:return, val} -> val
    end
  end
  def euclidean_length(v) do
    try do
      sum = 0.0
      i = 0
      while_fun_10 = fn while_fun_10, i, sum ->
        if i < _len(v) do
          val = :erlang.float(Enum.at(v, i, []))
          sum = sum + val * val
          i = i + 1
          while_fun_10.(while_fun_10, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_10.(while_fun_10, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sqrt_newton(sum)}
    catch
      {:return, val} -> val
    end
  end
  def zero_vector(n) do
    try do
      v = []
      i = 0
      while_fun_11 = fn while_fun_11, i, v ->
        if i < n do
          v = (v ++ [0])
          i = i + 1
          while_fun_11.(while_fun_11, i, v)
        else
          {i, v}
        end
      end
      {i, v} = try do
          while_fun_11.(while_fun_11, i, v)
        catch
          {:break, {i, v}} -> {i, v}
        end

      throw {:return, v}
    catch
      {:return, val} -> val
    end
  end
  def unit_basis_vector(n, idx) do
    try do
      v = zero_vector(n)
      v = List.replace_at(v, idx, 1)
      throw {:return, v}
    catch
      {:return, val} -> val
    end
  end
  def axpy(a, x, y) do
    try do
      res = []
      i = 0
      while_fun_12 = fn while_fun_12, i, res ->
        if i < _len(x) do
          res = (res ++ [a * Enum.at(x, i, []) + Enum.at(y, i, [])])
          i = i + 1
          while_fun_12.(while_fun_12, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_12.(while_fun_12, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def copy_vector(x) do
    try do
      res = []
      i = 0
      while_fun_13 = fn while_fun_13, i, res ->
        if i < _len(x) do
          res = (res ++ [Enum.at(x, i, [])])
          i = i + 1
          while_fun_13.(while_fun_13, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_13.(while_fun_13, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def change_component(v, idx, val) do
    try do
      v = List.replace_at(v, idx, val)
    catch
      {:return, val} -> val
    end
  end
  def matrix_str(m) do
    try do
      s = ""
      i = 0
      while_fun_14 = fn while_fun_14, i, s ->
        if i < _len(m) do
          s = (s <> "|")
          j = 0
          while_fun_15 = fn while_fun_15, j, s ->
            if j < _len(Enum.at(m, 0, [])) do
              s = (s <> int_to_string(Enum.at(Enum.at(m, i, []), j, 0)))
              {s} = if j + 1 < _len(Enum.at(m, 0, [])) do
                s = (s <> ",")
                {s}
              else
                {s}
              end
              j = j + 1
              while_fun_15.(while_fun_15, j, s)
            else
              {j, s}
            end
          end
          {j, s} = try do
              while_fun_15.(while_fun_15, j, s)
            catch
              {:break, {j, s}} -> {j, s}
            end

          s = (s <> "|\n")
          i = i + 1
          while_fun_14.(while_fun_14, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_14.(while_fun_14, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def submatrix(m, row, col) do
    try do
      res = []
      i = 0
      while_fun_16 = fn while_fun_16, i, res ->
        if i < _len(m) do
          {res} = if i != row do
            r = []
            j = 0
            while_fun_17 = fn while_fun_17, j, r ->
              if j < _len(Enum.at(m, 0, [])) do
                {r} = if j != col do
                  r = (r ++ [Enum.at(Enum.at(m, i, []), j, 0)])
                  {r}
                else
                  {r}
                end
                j = j + 1
                while_fun_17.(while_fun_17, j, r)
              else
                {j, r}
              end
            end
            {j, r} = try do
                while_fun_17.(while_fun_17, j, r)
              catch
                {:break, {j, r}} -> {j, r}
              end

            res = (res ++ [r])
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_16.(while_fun_16, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_16.(while_fun_16, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def determinant(m) do
    try do
      n = _len(m)
      if n == 1 do
        throw {:return, Enum.at(Enum.at(m, 0, []), 0, 0)}
      end
      if n == 2 do
        throw {:return, Enum.at(Enum.at(m, 0, []), 0, 0) * Enum.at(Enum.at(m, 1, []), 1, 0) - Enum.at(Enum.at(m, 0, []), 1, 0) * Enum.at(Enum.at(m, 1, []), 0, 0)}
      end
      det = 0
      c = 0
      while_fun_18 = fn while_fun_18, c, det ->
        if c < n do
          sub = submatrix(m, 0, c)
          sign = 1
          {sign} = if rem(c, 2) == 1 do
            sign = -1
            {sign}
          else
            {sign}
          end
          det = det + sign * Enum.at(Enum.at(m, 0, []), c, 0) * determinant(sub)
          c = c + 1
          while_fun_18.(while_fun_18, c, det)
        else
          {c, det}
        end
      end
      {c, det} = try do
          while_fun_18.(while_fun_18, c, det)
        catch
          {:break, {c, det}} -> {c, det}
        end

      throw {:return, det}
    catch
      {:return, val} -> val
    end
  end
  def matrix_minor(m, row, col) do
    try do
      throw {:return, determinant(submatrix(m, row, col))}
    catch
      {:return, val} -> val
    end
  end
  def matrix_cofactor(m, row, col) do
    try do
      sign = 1
      {sign} = if rem((row + col), 2) == 1 do
        sign = -1
        {sign}
      else
        {sign}
      end
      throw {:return, sign * matrix_minor(m, row, col)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_vector(m, v) do
    try do
      res = []
      i = 0
      while_fun_19 = fn while_fun_19, i, res ->
        if i < _len(m) do
          sum = 0
          j = 0
          while_fun_20 = fn while_fun_20, j, sum ->
            if j < _len(Enum.at(m, 0, [])) do
              sum = sum + Enum.at(Enum.at(m, i, []), j, 0) * Enum.at(v, j, [])
              j = j + 1
              while_fun_20.(while_fun_20, j, sum)
            else
              {j, sum}
            end
          end
          {j, sum} = try do
              while_fun_20.(while_fun_20, j, sum)
            catch
              {:break, {j, sum}} -> {j, sum}
            end

          res = (res ++ [sum])
          i = i + 1
          while_fun_19.(while_fun_19, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_19.(while_fun_19, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_scalar(m, s) do
    try do
      res = []
      i = 0
      while_fun_21 = fn while_fun_21, i, res ->
        if i < _len(m) do
          row = []
          j = 0
          while_fun_22 = fn while_fun_22, j, row ->
            if j < _len(Enum.at(m, 0, [])) do
              row = (row ++ [Enum.at(Enum.at(m, i, []), j, 0) * s])
              j = j + 1
              while_fun_22.(while_fun_22, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_22.(while_fun_22, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_21.(while_fun_21, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_21.(while_fun_21, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matrix_change_component(m, i, j, val) do
    try do
      m = List.replace_at(m, i, List.replace_at(Enum.at(m, i), j, val))
    catch
      {:return, val} -> val
    end
  end
  def matrix_component(m, i, j) do
    try do
      throw {:return, Enum.at(Enum.at(m, i, []), j, 0)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add(a, b) do
    try do
      res = []
      i = 0
      while_fun_23 = fn while_fun_23, i, res ->
        if i < _len(a) do
          row = []
          j = 0
          while_fun_24 = fn while_fun_24, j, row ->
            if j < _len(Enum.at(a, 0, [])) do
              row = (row ++ [Enum.at(Enum.at(a, i, []), j, 0) + Enum.at(Enum.at(b, i, []), j, 0)])
              j = j + 1
              while_fun_24.(while_fun_24, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_24.(while_fun_24, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_23.(while_fun_23, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_23.(while_fun_23, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matrix_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_25 = fn while_fun_25, i, res ->
        if i < _len(a) do
          row = []
          j = 0
          while_fun_26 = fn while_fun_26, j, row ->
            if j < _len(Enum.at(a, 0, [])) do
              row = (row ++ [Enum.at(Enum.at(a, i, []), j, 0) - Enum.at(Enum.at(b, i, []), j, 0)])
              j = j + 1
              while_fun_26.(while_fun_26, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_26.(while_fun_26, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_25.(while_fun_25, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_25.(while_fun_25, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def square_zero_matrix(n) do
    try do
      m = []
      i = 0
      while_fun_27 = fn while_fun_27, i, m ->
        if i < n do
          m = (m ++ [zero_vector(n)])
          i = i + 1
          while_fun_27.(while_fun_27, i, m)
        else
          {i, m}
        end
      end
      {i, m} = try do
          while_fun_27.(while_fun_27, i, m)
        catch
          {:break, {i, m}} -> {i, m}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def assert_int(name, actual, expected) do
    try do
      if actual == expected do
        IO.puts((name <> " ok"))
      else
        IO.puts(((((name <> " fail ") <> int_to_string(actual)) <> " != ") <> int_to_string(expected)))
      end
    catch
      {:return, val} -> val
    end
  end
  def assert_str(name, actual, expected) do
    try do
      if actual == expected do
        IO.puts((name <> " ok"))
      else
        IO.puts((name <> " fail"))
        IO.puts(actual)
        IO.puts(expected)
      end
    catch
      {:return, val} -> val
    end
  end
  def assert_float(name, actual, expected, eps) do
    try do
      diff = actual - expected
      {diff} = if diff < 0.0 do
        diff = -diff
        {diff}
      else
        {diff}
      end
      if diff <= eps do
        IO.puts((name <> " ok"))
      else
        IO.puts((name <> " fail"))
      end
    catch
      {:return, val} -> val
    end
  end
  Process.put(:vx, [1, 2, 3])
  Process.put(:vs, [0, 0, 0, 0, 0, 1])
  Process.put(:vsize, [1, 2, 3, 4])
  Process.put(:va, [1, 2, 3])
  Process.put(:vb, [1, 1, 1])
  Process.put(:zcount, 0)
  Process.put(:zi, 0)
  Process.put(:vchange, [1, 0, 0])
  Process.put(:ma, [[1, 2, 3], [2, 4, 5], [6, 7, 8]])
  Process.put(:mb, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  Process.put(:mc, [[1, 2, 3], [2, 4, 5], [6, 7, 8]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    assert_int("component0", vector_component(Process.get(:vx), 0), 1)
    assert_int("component2", vector_component(Process.get(:vx), 2), 3)
    assert_str("str_vector", vector_str_int(Process.get(:vs)), "(0,0,0,0,0,1)")
    assert_int("size", _len(Process.get(:vsize)), 4)
    Process.put(:vsum, vector_add(Process.get(:va), Process.get(:vb)))
    assert_int("add0", vector_component(Process.get(:vsum), 0), 2)
    assert_int("add1", vector_component(Process.get(:vsum), 1), 3)
    assert_int("add2", vector_component(Process.get(:vsum), 2), 4)
    Process.put(:vsub, vector_sub(Process.get(:va), Process.get(:vb)))
    assert_int("sub0", vector_component(Process.get(:vsub), 0), 0)
    assert_int("sub1", vector_component(Process.get(:vsub), 1), 1)
    assert_int("sub2", vector_component(Process.get(:vsub), 2), 2)
    Process.put(:vmul, vector_scalar_mul(Process.get(:va), 3.0))
    assert_str("scalar_mul", vector_str_float(Process.get(:vmul), 1), "(3.0,6.0,9.0)")
    assert_int("dot_product", vector_dot([2, -1, 4], [1, -2, -1]), 0)
    Process.put(:zvec, zero_vector(10))
    Process.put(:zstr, vector_str_int(Process.get(:zvec)))
    while_fun_28 = fn while_fun_28 ->
      if Process.get(:zi) < _len(Process.get(:zstr)) do
        if _slice(Process.get(:zstr), Process.get(:zi), Process.get(:zi) + 1 - (Process.get(:zi))) == "0" do
          Process.put(:zcount, Process.get(:zcount) + 1)
        end
        Process.put(:zi, Process.get(:zi) + 1)
        while_fun_28.(while_fun_28)
      else
        nil
      end
    end
    try do
      while_fun_28.(while_fun_28)
    catch
      :break -> nil
    end

    assert_int("zero_vector", Process.get(:zcount), 10)
    assert_str("unit_basis", vector_str_int(unit_basis_vector(3, 1)), "(0,1,0)")
    assert_str("axpy", vector_str_int(axpy(2, [1, 2, 3], [1, 0, 1])), "(3,4,7)")
    Process.put(:vcopy, copy_vector([1, 0, 0, 0, 0, 0]))
    assert_str("copy", vector_str_int(Process.get(:vcopy)), "(1,0,0,0,0,0)")
    change_component(Process.get(:vchange), 0, 0)
    change_component(Process.get(:vchange), 1, 1)
    assert_str("change_component", vector_str_int(Process.get(:vchange)), "(0,1,0)")
    assert_str("matrix_str", matrix_str(Process.get(:ma)), "|1,2,3|\n|2,4,5|\n|6,7,8|\n")
    assert_int("determinant", determinant(Process.get(:ma)), -5)
    Process.put(:mv, matrix_mul_vector(Process.get(:mb), [1, 2, 3]))
    assert_str("matrix_vec_mul", vector_str_int(Process.get(:mv)), "(14,32,50)")
    Process.put(:msc, matrix_mul_scalar(Process.get(:mb), 2))
    assert_str("matrix_scalar_mul", matrix_str(Process.get(:msc)), "|2,4,6|\n|8,10,12|\n|14,16,18|\n")
    matrix_change_component(Process.get(:mc), 0, 2, 5)
    assert_str("change_component_matrix", matrix_str(Process.get(:mc)), "|1,2,5|\n|2,4,5|\n|6,7,8|\n")
    assert_int("matrix_component", matrix_component(Process.get(:mc), 2, 1), 7)
    Process.put(:madd, matrix_add([[1, 2, 3], [2, 4, 5], [6, 7, 8]], [[1, 2, 7], [2, 4, 5], [6, 7, 10]]))
    assert_str("matrix_add", matrix_str(Process.get(:madd)), "|2,4,10|\n|4,8,10|\n|12,14,18|\n")
    Process.put(:msub, matrix_sub([[1, 2, 3], [2, 4, 5], [6, 7, 8]], [[1, 2, 7], [2, 4, 5], [6, 7, 10]]))
    assert_str("matrix_sub", matrix_str(Process.get(:msub)), "|0,0,-4|\n|0,0,0|\n|0,0,-2|\n")
    Process.put(:mzero, square_zero_matrix(5))
    assert_str("square_zero_matrix", matrix_str(Process.get(:mzero)), "|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n")
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
