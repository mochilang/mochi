# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def panic(msg) do
    try do
      IO.puts(msg)
    catch
      {:return, val} -> val
    end
  end
  def abs_float(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def copy_matrix(src) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(src) do
          row_src = Enum.at(src, i)
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < _len(row_src) do
              row = (row ++ [Enum.at(row_src, j)])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def solve_linear_system(matrix) do
    try do
      ab = copy_matrix(matrix)
      num_rows = _len(ab)
      num_cols = _len(Enum.at(ab, 0)) - 1
      if num_rows != num_cols do
        panic("Matrix is not square")
        throw {:return, []}
      end
      column_num = 0
      while_fun_3 = fn while_fun_3, ab, column_num ->
        if column_num < num_rows do
          i = column_num
          while_fun_4 = fn while_fun_4, ab, i ->
            if i < num_cols do
              {ab} = if abs_float(Enum.at(Enum.at(ab, i), column_num)) > abs_float(Enum.at(Enum.at(ab, column_num), column_num)) do
                temp = Enum.at(ab, column_num)
                ab = List.replace_at(ab, column_num, Enum.at(ab, i))
                ab = List.replace_at(ab, i, temp)
                {ab}
              else
                {ab}
              end
              i = i + 1
              while_fun_4.(while_fun_4, ab, i)
            else
              {ab, i}
            end
          end
          {ab, i} = try do
              while_fun_4.(while_fun_4, ab, i)
            catch
              {:break, {ab, i}} -> {ab, i}
            end

          if abs_float(Enum.at(Enum.at(ab, column_num), column_num)) < 0.00000001 do
            panic("Matrix is singular")
            throw {:return, []}
          end
          {ab, i} = if column_num != 0 do
            i = column_num
            while_fun_5 = fn while_fun_5, ab, i ->
              if i < num_rows do
                factor = Enum.at(Enum.at(ab, i), column_num - 1) / Enum.at(Enum.at(ab, column_num - 1), column_num - 1)
                j = 0
                while_fun_6 = fn while_fun_6, ab, j ->
                  if j < _len(Enum.at(ab, i)) do
                    ab = List.replace_at(ab, i, List.replace_at(Enum.at(ab, i), j, Enum.at(Enum.at(ab, i), j) - factor * Enum.at(Enum.at(ab, column_num - 1), j)))
                    j = j + 1
                    while_fun_6.(while_fun_6, ab, j)
                  else
                    {ab, j}
                  end
                end
                {ab, j} = try do
                    while_fun_6.(while_fun_6, ab, j)
                  catch
                    {:break, {ab, j}} -> {ab, j}
                  end

                i = i + 1
                while_fun_5.(while_fun_5, ab, i)
              else
                {ab, i}
              end
            end
            {ab, i} = try do
                while_fun_5.(while_fun_5, ab, i)
              catch
                {:break, {ab, i}} -> {ab, i}
              end

            {ab, i}
          else
            {ab, i}
          end
          column_num = column_num + 1
          while_fun_3.(while_fun_3, ab, column_num)
        else
          {ab, column_num}
        end
      end
      {ab, column_num} = try do
          while_fun_3.(while_fun_3, ab, column_num)
        catch
          {:break, {ab, column_num}} -> {ab, column_num}
        end

      x_lst = []
      t = 0
      while_fun_7 = fn while_fun_7, t, x_lst ->
        if t < num_rows do
          x_lst = (x_lst ++ [0.0])
          t = t + 1
          while_fun_7.(while_fun_7, t, x_lst)
        else
          {t, x_lst}
        end
      end
      {t, x_lst} = try do
          while_fun_7.(while_fun_7, t, x_lst)
        catch
          {:break, {t, x_lst}} -> {t, x_lst}
        end

      column_num = num_rows - 1
      while_fun_8 = fn while_fun_8, ab, column_num, x_lst ->
        if column_num >= 0 do
          x = Enum.at(Enum.at(ab, column_num), num_cols) / Enum.at(Enum.at(ab, column_num), column_num)
          x_lst = List.replace_at(x_lst, column_num, x)
          i = column_num - 1
          while_fun_9 = fn while_fun_9, ab, i ->
            if i >= 0 do
              ab = List.replace_at(ab, i, List.replace_at(Enum.at(ab, i), num_cols, Enum.at(Enum.at(ab, i), num_cols) - Enum.at(Enum.at(ab, i), column_num) * x))
              i = i - 1
              while_fun_9.(while_fun_9, ab, i)
            else
              {ab, i}
            end
          end
          {ab, i} = try do
              while_fun_9.(while_fun_9, ab, i)
            catch
              {:break, {ab, i}} -> {ab, i}
            end

          column_num = column_num - 1
          while_fun_8.(while_fun_8, ab, column_num, x_lst)
        else
          {ab, column_num, x_lst}
        end
      end
      {ab, column_num, x_lst} = try do
          while_fun_8.(while_fun_8, ab, column_num, x_lst)
        catch
          {:break, {ab, column_num, x_lst}} -> {ab, column_num, x_lst}
        end

      throw {:return, x_lst}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:example_matrix, [[5.0, -5.0, -3.0, 4.0, -11.0], [1.0, -4.0, 6.0, -4.0, -10.0], [-2.0, -5.0, 4.0, -5.0, -12.0], [-3.0, -3.0, 5.0, -5.0, 8.0]])
    IO.puts("Matrix:")
    IO.puts(Kernel.inspect(Process.get(:example_matrix)))
    Process.put(:solution, solve_linear_system(Process.get(:example_matrix)))
    IO.puts(Kernel.inspect(Process.get(:solution)))
  end
end
Main.main()
