# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def zeros(n) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < n do
          res = (res ++ [0.0])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def dot(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, sum ->
        if i < _len(a) do
          sum = sum + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_2.(while_fun_2, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def mat_vec_mul(m, v) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(m) do
          s = 0.0
          j = 0
          while_fun_4 = fn while_fun_4, j, s ->
            if j < _len(Enum.at(m, i)) do
              s = s + Enum.at(Enum.at(m, i), j) * Enum.at(v, j)
              j = j + 1
              while_fun_4.(while_fun_4, j, s)
            else
              {j, s}
            end
          end
          {j, s} = try do
              while_fun_4.(while_fun_4, j, s)
            catch
              {:break, {j, s}} -> {j, s}
            end

          res = (res ++ [s])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_add(a, b) do
    try do
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) + Enum.at(b, i)])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def vec_sub(a, b) do
    try do
      res = []
      i = 0
      while_fun_6 = fn while_fun_6, i, res ->
        if i < _len(a) do
          res = (res ++ [Enum.at(a, i) - Enum.at(b, i)])
          i = i + 1
          while_fun_6.(while_fun_6, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_6.(while_fun_6, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def scalar_mul(s, v) do
    try do
      res = []
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < _len(v) do
          res = (res ++ [s * Enum.at(v, i)])
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun_8 = fn while_fun_8, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_8.(while_fun_8, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_8.(while_fun_8, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def norm(v) do
    try do
      throw {:return, sqrtApprox(dot(v, v))}
    catch
      {:return, val} -> val
    end
  end
  def conjugate_gradient(a, b, max_iterations, tol) do
    try do
      n = _len(b)
      x = zeros(n)
      r = vec_sub(b, mat_vec_mul(a, x))
      p = r
      rs_old = dot(r, r)
      i = 0
      while_fun_9 = fn while_fun_9, i, p, r, rs_old ->
        if i < max_iterations do
          ap = mat_vec_mul(a, p)
          alpha = rs_old / dot(p, ap)
          x = vec_add(x, scalar_mul(alpha, p))
          r = vec_sub(r, scalar_mul(alpha, ap))
          rs_new = dot(r, r)
          if sqrtApprox(rs_new) < tol do
            throw {:break, {i, p, r, rs_old}}
          end
          beta = rs_new / rs_old
          p = vec_add(r, scalar_mul(beta, p))
          rs_old = rs_new
          i = i + 1
          while_fun_9.(while_fun_9, i, p, r, rs_old)
        else
          {i, p, r, rs_old}
        end
      end
      {i, p, r, rs_old} = try do
          while_fun_9.(while_fun_9, i, p, r, rs_old)
        catch
          {:break, {i, p, r, rs_old}} -> {i, p, r, rs_old}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    Process.put(:a, [[8.73256573, -5.02034289, -2.68709226], [-5.02034289, 3.78188322, 0.91980451], [-2.68709226, 0.91980451, 1.94746467]])
    Process.put(:b, [-5.80872761, 3.23807431, 1.95381422])
    Process.put(:x, conjugate_gradient(Process.get(:a), Process.get(:b), 1000, 0.00000001))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:x), 0)))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:x), 1)))
    IO.puts(Kernel.to_string(Enum.at(Process.get(:x), 2)))
  end
end
Main.main()
