# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rand() do
    try do
      Process.put(:seed, rem((Process.get(:seed) * 1103515245 + 12345), 2147483648))
      throw {:return, Process.get(:seed)}
    catch
      {:return, val} -> val
    end
  end
  def random_int(a, b) do
    try do
      r = rem(rand(), (b - a + 1))
      throw {:return, a + r}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def arcsin_taylor(x) do
    try do
      term = x
      sum = x
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n < 10 do
          num = (2.0 * (:erlang.float(n)) - 1.0) * (2.0 * (:erlang.float(n)) - 1.0) * x * x * term
          den = (2.0 * (:erlang.float(n))) * (2.0 * (:erlang.float(n)) + 1.0)
          term = num / den
          sum = sum + term
          n = n + 1
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def acos_taylor(x) do
    try do
      throw {:return, Process.get(:pi) / 2.0 - arcsin_taylor(x)}
    catch
      {:return, val} -> val
    end
  end
  def vector_len(v) do
    try do
      throw {:return, _len(Map.get(v, :components, []))}
    catch
      {:return, val} -> val
    end
  end
  def vector_to_string(v) do
    try do
      s = "("
      i = 0
      while_fun_3 = fn while_fun_3, i, s ->
        if i < _len(Map.get(v, :components, [])) do
          s = (s <> Kernel.to_string(Enum.at(v.components, i)))
          {s} = if i < _len(Map.get(v, :components, [])) - 1 do
            s = (s <> ",")
            {s}
          else
            {s}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      s = (s <> ")")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def vector_add(a, b) do
    try do
      size = vector_len(a)
      if size != vector_len(b) do
        throw {:return, %{components: []}}
      end
      res = []
      i = 0
      while_fun_4 = fn while_fun_4, i, res ->
        if i < size do
          res = (res ++ [Enum.at(a.components, i) + Enum.at(b.components, i)])
          i = i + 1
          while_fun_4.(while_fun_4, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_4.(while_fun_4, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def vector_sub(a, b) do
    try do
      size = vector_len(a)
      if size != vector_len(b) do
        throw {:return, %{components: []}}
      end
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < size do
          res = (res ++ [Enum.at(a.components, i) - Enum.at(b.components, i)])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def vector_eq(a, b) do
    try do
      if vector_len(a) != vector_len(b) do
        throw {:return, false}
      end
      i = 0
      while_fun_6 = fn while_fun_6, i ->
        if i < vector_len(a) do
          if Enum.at(a.components, i) != Enum.at(b.components, i) do
            throw {:return, false}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      i = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def vector_mul_scalar(v, s) do
    try do
      res = []
      i = 0
      while_fun_7 = fn while_fun_7, i, res ->
        if i < vector_len(v) do
          res = (res ++ [Enum.at(v.components, i) * s])
          i = i + 1
          while_fun_7.(while_fun_7, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_7.(while_fun_7, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def vector_dot(a, b) do
    try do
      size = vector_len(a)
      if size != vector_len(b) do
        throw {:return, 0.0}
      end
      sum = 0.0
      i = 0
      while_fun_8 = fn while_fun_8, i, sum ->
        if i < size do
          sum = sum + Enum.at(a.components, i) * Enum.at(b.components, i)
          i = i + 1
          while_fun_8.(while_fun_8, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_8.(while_fun_8, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def vector_copy(v) do
    try do
      res = []
      i = 0
      while_fun_9 = fn while_fun_9, i, res ->
        if i < vector_len(v) do
          res = (res ++ [Enum.at(v.components, i)])
          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def vector_component(v, idx) do
    try do
      throw {:return, Enum.at(v.components, idx)}
    catch
      {:return, val} -> val
    end
  end
  def vector_change_component(v, pos, value) do
    try do
      comps = v.components
      comps = List.replace_at(comps, pos, value)
      throw {:return, %{components: comps}}
    catch
      {:return, val} -> val
    end
  end
  def vector_euclidean_length(v) do
    try do
      sum = 0.0
      i = 0
      while_fun_10 = fn while_fun_10, i, sum ->
        if i < _len(Map.get(v, :components, [])) do
          sum = sum + Enum.at(v.components, i) * Enum.at(v.components, i)
          i = i + 1
          while_fun_10.(while_fun_10, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_10.(while_fun_10, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      result = sqrtApprox(sum)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def vector_angle(a, b, deg) do
    try do
      num = vector_dot(a, b)
      den = vector_euclidean_length(a) * vector_euclidean_length(b)
      ang = acos_taylor(num / den)
      {ang} = if deg do
        ang = ang * 180.0 / Process.get(:pi)
        {ang}
      else
        {ang}
      end
      throw {:return, ang}
    catch
      {:return, val} -> val
    end
  end
  def zero_vector(d) do
    try do
      res = []
      i = 0
      while_fun_11 = fn while_fun_11, i, res ->
        if i < d do
          res = (res ++ [0.0])
          i = i + 1
          while_fun_11.(while_fun_11, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_11.(while_fun_11, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def unit_basis_vector(d, pos) do
    try do
      res = []
      i = 0
      while_fun_12 = fn while_fun_12, i, res ->
        if i < d do
          res = (if i == pos, do: (res ++ [1.0]), else: (res ++ [0.0]))
          i = i + 1
          while_fun_12.(while_fun_12, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_12.(while_fun_12, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def axpy(s, x, y) do
    try do
      throw {:return, vector_add(vector_mul_scalar(x, s), y)}
    catch
      {:return, val} -> val
    end
  end
  def random_vector(n, a, b) do
    try do
      res = []
      i = 0
      while_fun_13 = fn while_fun_13, i, res ->
        if i < n do
          res = (res ++ [:erlang.float(random_int(a, b))])
          i = i + 1
          while_fun_13.(while_fun_13, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_13.(while_fun_13, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, %{components: res}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_to_string(m) do
    try do
      ans = ""
      i = 0
      while_fun_14 = fn while_fun_14, ans, i ->
        if i < m.height do
          ans = (ans <> "|")
          j = 0
          while_fun_15 = fn while_fun_15, ans, j ->
            if j < m.width do
              ans = (ans <> Kernel.to_string(Enum.at(Enum.at(m.data, i), j)))
              {ans} = if j < m.width - 1 do
                ans = (ans <> ",")
                {ans}
              else
                {ans}
              end
              j = j + 1
              while_fun_15.(while_fun_15, ans, j)
            else
              {ans, j}
            end
          end
          {ans, j} = try do
              while_fun_15.(while_fun_15, ans, j)
            catch
              {:break, {ans, j}} -> {ans, j}
            end

          ans = (ans <> "|\n")
          i = i + 1
          while_fun_14.(while_fun_14, ans, i)
        else
          {ans, i}
        end
      end
      {ans, i} = try do
          while_fun_14.(while_fun_14, ans, i)
        catch
          {:break, {ans, i}} -> {ans, i}
        end

      throw {:return, ans}
    catch
      {:return, val} -> val
    end
  end
  def matrix_add(a, b) do
    try do
      if a.width != b.width || a.height != b.height do
        throw {:return, %{data: [], width: 0, height: 0}}
      end
      mat = []
      i = 0
      while_fun_16 = fn while_fun_16, i, mat ->
        if i < a.height do
          row = []
          j = 0
          while_fun_17 = fn while_fun_17, j, row ->
            if j < a.width do
              row = (row ++ [Enum.at(Enum.at(a.data, i), j) + Enum.at(Enum.at(b.data, i), j)])
              j = j + 1
              while_fun_17.(while_fun_17, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_17.(while_fun_17, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_16.(while_fun_16, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_16.(while_fun_16, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, %{data: mat, width: a.width, height: a.height}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_sub(a, b) do
    try do
      if a.width != b.width || a.height != b.height do
        throw {:return, %{data: [], width: 0, height: 0}}
      end
      mat = []
      i = 0
      while_fun_18 = fn while_fun_18, i, mat ->
        if i < a.height do
          row = []
          j = 0
          while_fun_19 = fn while_fun_19, j, row ->
            if j < a.width do
              row = (row ++ [Enum.at(Enum.at(a.data, i), j) - Enum.at(Enum.at(b.data, i), j)])
              j = j + 1
              while_fun_19.(while_fun_19, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_19.(while_fun_19, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_18.(while_fun_18, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_18.(while_fun_18, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, %{data: mat, width: a.width, height: a.height}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_vector(m, v) do
    try do
      if _len(Map.get(v, :components, [])) != m.width do
        throw {:return, %{components: []}}
      end
      res = zero_vector(m.height)
      i = 0
      while_fun_20 = fn while_fun_20, i, res ->
        if i < m.height do
          sum = 0.0
          j = 0
          while_fun_21 = fn while_fun_21, j, sum ->
            if j < m.width do
              sum = sum + Enum.at(Enum.at(m.data, i), j) * Enum.at(v.components, j)
              j = j + 1
              while_fun_21.(while_fun_21, j, sum)
            else
              {j, sum}
            end
          end
          {j, sum} = try do
              while_fun_21.(while_fun_21, j, sum)
            catch
              {:break, {j, sum}} -> {j, sum}
            end

          res = vector_change_component(res, i, sum)
          i = i + 1
          while_fun_20.(while_fun_20, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_20.(while_fun_20, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matrix_mul_scalar(m, s) do
    try do
      mat = []
      i = 0
      while_fun_22 = fn while_fun_22, i, mat ->
        if i < m.height do
          row = []
          j = 0
          while_fun_23 = fn while_fun_23, j, row ->
            if j < m.width do
              row = (row ++ [Enum.at(Enum.at(m.data, i), j) * s])
              j = j + 1
              while_fun_23.(while_fun_23, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_23.(while_fun_23, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_22.(while_fun_22, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_22.(while_fun_22, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, %{data: mat, width: m.width, height: m.height}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_component(m, x, y) do
    try do
      throw {:return, Enum.at(Enum.at(m.data, x), y)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_change_component(m, x, y, value) do
    try do
      data = m.data
      data = List.replace_at(data, x, List.replace_at(Enum.at(data, x), y, value))
      throw {:return, %{data: data, width: m.width, height: m.height}}
    catch
      {:return, val} -> val
    end
  end
  def matrix_minor(m, x, y) do
    try do
      if m.height != m.width do
        throw {:return, 0.0}
      end
      minor = []
      i = 0
      while_fun_24 = fn while_fun_24, i, minor ->
        if i < m.height do
          {minor} = if i != x do
            row = []
            j = 0
            while_fun_25 = fn while_fun_25, j, row ->
              if j < m.width do
                {row} = if j != y do
                  row = (row ++ [Enum.at(Enum.at(m.data, i), j)])
                  {row}
                else
                  {row}
                end
                j = j + 1
                while_fun_25.(while_fun_25, j, row)
              else
                {j, row}
              end
            end
            {j, row} = try do
                while_fun_25.(while_fun_25, j, row)
              catch
                {:break, {j, row}} -> {j, row}
              end

            minor = (minor ++ [row])
            {minor}
          else
            {minor}
          end
          i = i + 1
          while_fun_24.(while_fun_24, i, minor)
        else
          {i, minor}
        end
      end
      {i, minor} = try do
          while_fun_24.(while_fun_24, i, minor)
        catch
          {:break, {i, minor}} -> {i, minor}
        end

      sub = %{data: minor, width: m.width - 1, height: m.height - 1}
      throw {:return, matrix_determinant(sub)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_cofactor(m, x, y) do
    try do
      sign = (if rem((x + y), 2) == 0, do: 1.0, else: -1.0)
      throw {:return, sign * matrix_minor(m, x, y)}
    catch
      {:return, val} -> val
    end
  end
  def matrix_determinant(m) do
    try do
      if m.height != m.width do
        throw {:return, 0.0}
      end
      if m.height == 0 do
        throw {:return, 0.0}
      end
      if m.height == 1 do
        throw {:return, Enum.at(Enum.at(m.data, 0), 0)}
      end
      if m.height == 2 do
        throw {:return, Enum.at(Enum.at(m.data, 0), 0) * Enum.at(Enum.at(m.data, 1), 1) - Enum.at(Enum.at(m.data, 0), 1) * Enum.at(Enum.at(m.data, 1), 0)}
      end
      sum = 0.0
      y = 0
      while_fun_26 = fn while_fun_26, sum, y ->
        if y < m.width do
          sum = sum + Enum.at(Enum.at(m.data, 0), y) * matrix_cofactor(m, 0, y)
          y = y + 1
          while_fun_26.(while_fun_26, sum, y)
        else
          {sum, y}
        end
      end
      {sum, y} = try do
          while_fun_26.(while_fun_26, sum, y)
        catch
          {:break, {sum, y}} -> {sum, y}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def square_zero_matrix(n) do
    try do
      mat = []
      i = 0
      while_fun_27 = fn while_fun_27, i, mat ->
        if i < n do
          row = []
          j = 0
          while_fun_28 = fn while_fun_28, j, row ->
            if j < n do
              row = (row ++ [0.0])
              j = j + 1
              while_fun_28.(while_fun_28, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_28.(while_fun_28, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_27.(while_fun_27, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_27.(while_fun_27, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, %{data: mat, width: n, height: n}}
    catch
      {:return, val} -> val
    end
  end
  def random_matrix(w, h, a, b) do
    try do
      mat = []
      i = 0
      while_fun_29 = fn while_fun_29, i, mat ->
        if i < h do
          row = []
          j = 0
          while_fun_30 = fn while_fun_30, j, row ->
            if j < w do
              row = (row ++ [:erlang.float(random_int(a, b))])
              j = j + 1
              while_fun_30.(while_fun_30, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_30.(while_fun_30, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          mat = (mat ++ [row])
          i = i + 1
          while_fun_29.(while_fun_29, i, mat)
        else
          {i, mat}
        end
      end
      {i, mat} = try do
          while_fun_29.(while_fun_29, i, mat)
        catch
          {:break, {i, mat}} -> {i, mat}
        end

      throw {:return, %{data: mat, width: w, height: h}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      v1 = %{components: [1.0, 2.0, 3.0]}
      v2 = %{components: [4.0, 5.0, 6.0]}
      IO.puts(Kernel.inspect(vector_to_string(vector_add(v1, v2))))
      IO.puts(Kernel.inspect(vector_dot(v1, v2)))
      IO.puts(Kernel.inspect(vector_euclidean_length(v1)))
      m = %{data: [[1.0, 2.0], [3.0, 4.0]], width: 2, height: 2}
      IO.puts(Kernel.inspect(matrix_determinant(m)))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:seed, 123456789)
end
Main.main()
