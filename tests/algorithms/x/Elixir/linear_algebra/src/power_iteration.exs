# Code generated by Mochi transpiler 2025-08-08 19:19 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x == 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def dot(a, b) do
    try do
      sum = 0.0
      i = 0
      while_fun_2 = fn while_fun_2, i, sum ->
        if i < _len(a) do
          sum = sum + Enum.at(a, i) * Enum.at(b, i)
          i = i + 1
          while_fun_2.(while_fun_2, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_2.(while_fun_2, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def mat_vec_mult(mat, vec) do
    try do
      res = []
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(mat) do
          res = (res ++ [dot(Enum.at(mat, i), vec)])
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def norm(vec) do
    try do
      sum = 0.0
      i = 0
      while_fun_4 = fn while_fun_4, i, sum ->
        if i < _len(vec) do
          sum = sum + Enum.at(vec, i) * Enum.at(vec, i)
          i = i + 1
          while_fun_4.(while_fun_4, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_4.(while_fun_4, i, sum)
        catch
          {:break, {i, sum}} -> {i, sum}
        end

      root = sqrtApprox(sum)
      throw {:return, root}
    catch
      {:return, val} -> val
    end
  end
  def normalize(vec) do
    try do
      n = norm(vec)
      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(vec) do
          res = (res ++ [Enum.at(vec, i) / n])
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def power_iteration(matrix, vector, error_tol, max_iterations) do
    try do
      v = normalize(vector)
      lambda_prev = 0.0
      lambda = 0.0
      err = 1000000000000.0
      iterations = 0
      while_fun_6 = fn while_fun_6, err, iterations, lambda, lambda_prev, v ->
        if err > error_tol && iterations < max_iterations do
          w = mat_vec_mult(matrix, v)
          v = normalize(w)
          mv = mat_vec_mult(matrix, v)
          lambda = dot(v, mv)
          denom = (if lambda != 0.0, do: abs_(lambda), else: 1.0)
          err = abs_(lambda - lambda_prev) / denom
          lambda_prev = lambda
          iterations = iterations + 1
          while_fun_6.(while_fun_6, err, iterations, lambda, lambda_prev, v)
        else
          {err, iterations, lambda, lambda_prev, v}
        end
      end
      {err, iterations, lambda, lambda_prev, v} = try do
          while_fun_6.(while_fun_6, err, iterations, lambda, lambda_prev, v)
        catch
          {:break, {err, iterations, lambda, lambda_prev, v}} -> {err, iterations, lambda, lambda_prev, v}
        end

      throw {:return, %{eigenvalue: lambda, eigenvector: v}}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:input_matrix, [[41.0, 4.0, 20.0], [4.0, 26.0, 30.0], [20.0, 30.0, 50.0]])
  Process.put(:vector, [41.0, 4.0, 20.0])
  def main() do
    Process.put(:result, power_iteration(Process.get(:input_matrix), Process.get(:vector), 0.000000000001, 100))
    IO.puts(Kernel.to_string(Process.get(:result).eigenvalue))
    IO.puts(Kernel.inspect(Process.get(:result).eigenvector))
  end
end
Main.main()
