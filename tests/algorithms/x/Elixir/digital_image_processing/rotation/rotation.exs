# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def mat_inverse3(m) do
    try do
      a = Enum.at(Enum.at(m, 0), 0)
      b = Enum.at(Enum.at(m, 0), 1)
      c = Enum.at(Enum.at(m, 0), 2)
      d = Enum.at(Enum.at(m, 1), 0)
      e = Enum.at(Enum.at(m, 1), 1)
      f = Enum.at(Enum.at(m, 1), 2)
      g = Enum.at(Enum.at(m, 2), 0)
      h = Enum.at(Enum.at(m, 2), 1)
      i = Enum.at(Enum.at(m, 2), 2)
      det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)
      if det == 0.0 do
        raise("singular matrix")
      end
      adj00 = e * i - f * h
      adj01 = c * h - b * i
      adj02 = b * f - c * e
      adj10 = f * g - d * i
      adj11 = a * i - c * g
      adj12 = c * d - a * f
      adj20 = d * h - e * g
      adj21 = b * g - a * h
      adj22 = a * e - b * d
      inv = []
      inv = (inv ++ [[adj00 / det, adj01 / det, adj02 / det]])
      inv = (inv ++ [[adj10 / det, adj11 / det, adj12 / det]])
      inv = (inv ++ [[adj20 / det, adj21 / det, adj22 / det]])
      throw {:return, inv}
    catch
      {:return, val} -> val
    end
  end
  def mat_vec_mul(m, v) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < 3 do
          val = Enum.at(Enum.at(m, i), 0) * Enum.at(v, 0) + Enum.at(Enum.at(m, i), 1) * Enum.at(v, 1) + Enum.at(Enum.at(m, i), 2) * Enum.at(v, 2)
          res = (res ++ [val])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def create_matrix(rows, cols, value) do
    try do
      result = []
      r = 0
      while_fun_2 = fn while_fun_2, r, result ->
        if r < rows do
          row = []
          c = 0
          while_fun_3 = fn while_fun_3, c, row ->
            if c < cols do
              row = (row ++ [value])
              c = c + 1
              while_fun_3.(while_fun_3, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_3.(while_fun_3, c, row)
            catch
              {:break, {c, row}} -> {c, row}
            end

          result = (result ++ [row])
          r = r + 1
          while_fun_2.(while_fun_2, r, result)
        else
          {r, result}
        end
      end
      {r, result} = try do
          while_fun_2.(while_fun_2, r, result)
        catch
          {:break, {r, result}} -> {r, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def round_to_int(x) do
    try do
      throw {:return, ((if x >= 0.0, do: Kernel.trunc(x + 0.5), else: Kernel.trunc(x - 0.5)))}
    catch
      {:return, val} -> val
    end
  end
  def get_rotation(img, pt1, pt2, rows, cols) do
    try do
      src = [[Enum.at(Enum.at(pt1, 0), 0), Enum.at(Enum.at(pt1, 0), 1), 1.0], [Enum.at(Enum.at(pt1, 1), 0), Enum.at(Enum.at(pt1, 1), 1), 1.0], [Enum.at(Enum.at(pt1, 2), 0), Enum.at(Enum.at(pt1, 2), 1), 1.0]]
      inv = mat_inverse3(src)
      vecx = [Enum.at(Enum.at(pt2, 0), 0), Enum.at(Enum.at(pt2, 1), 0), Enum.at(Enum.at(pt2, 2), 0)]
      vecy = [Enum.at(Enum.at(pt2, 0), 1), Enum.at(Enum.at(pt2, 1), 1), Enum.at(Enum.at(pt2, 2), 1)]
      avec = mat_vec_mul(inv, vecx)
      bvec = mat_vec_mul(inv, vecy)
      a0 = Enum.at(avec, 0)
      a1 = Enum.at(avec, 1)
      a2 = Enum.at(avec, 2)
      b0 = Enum.at(bvec, 0)
      b1 = Enum.at(bvec, 1)
      b2 = Enum.at(bvec, 2)
      out = create_matrix(rows, cols, 0)
      y = 0
      while_fun_4 = fn while_fun_4, out, y ->
        if y < rows do
          x = 0
          while_fun_5 = fn while_fun_5, out, x ->
            if x < cols do
              xf = a0 * (1.0 * x) + a1 * (1.0 * y) + a2
              yf = b0 * (1.0 * x) + b1 * (1.0 * y) + b2
              sx = round_to_int(xf)
              sy = round_to_int(yf)
              {out} = if sx >= 0 && sx < cols && sy >= 0 && sy < rows do
                out = List.replace_at(out, sy, List.replace_at(Enum.at(out, sy), sx, Enum.at(Enum.at(img, y), x)))
                {out}
              else
                {out}
              end
              x = x + 1
              while_fun_5.(while_fun_5, out, x)
            else
              {out, x}
            end
          end
          {out, x} = try do
              while_fun_5.(while_fun_5, out, x)
            catch
              {:break, {out, x}} -> {out, x}
            end

          y = y + 1
          while_fun_4.(while_fun_4, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_4.(while_fun_4, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:img, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  Process.put(:pts1, [[0.0, 0.0], [2.0, 0.0], [0.0, 2.0]])
  Process.put(:pts2, [[0.0, 2.0], [0.0, 0.0], [2.0, 2.0]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:rotated, get_rotation(Process.get(:img), Process.get(:pts1), Process.get(:pts2), 3, 3))
    IO.puts(Kernel.to_string(Process.get(:rotated)))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
