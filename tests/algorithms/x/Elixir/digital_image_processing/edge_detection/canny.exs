# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def atanApprox(x) do
    try do
      if x > 1.0 do
        throw {:return, Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      if x < (-1.0) do
        throw {:return, -Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      throw {:return, x / (1.0 + 0.28 * x * x)}
    catch
      {:return, val} -> val
    end
  end
  def atan2Approx(y, x) do
    try do
      if x > 0.0 do
        r = atanApprox(y / x)
        throw {:return, r}
      end
      if x < 0.0 do
        if y >= 0.0 do
          throw {:return, atanApprox(y / x) + Process.get(:pi)}
        end
        throw {:return, atanApprox(y / x) - Process.get(:pi)}
      end
      if y > 0.0 do
        throw {:return, Process.get(:pi) / 2.0}
      end
      if y < 0.0 do
        throw {:return, -Process.get(:pi) / 2.0}
      end
      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  def deg(rad) do
    try do
      throw {:return, rad * 180.0 / Process.get(:pi)}
    catch
      {:return, val} -> val
    end
  end
  def zero_matrix(h, w) do
    try do
      out = []
      i = 0
      while_fun_2 = fn while_fun_2, i, out ->
        if i < h do
          row = []
          j = 0
          while_fun_3 = fn while_fun_3, j, row ->
            if j < w do
              row = (row ++ [0.0])
              j = j + 1
              while_fun_3.(while_fun_3, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_3.(while_fun_3, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          out = (out ++ [row])
          i = i + 1
          while_fun_2.(while_fun_2, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_2.(while_fun_2, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def convolve(img, kernel) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      k = _len(kernel)
      pad = div(k, 2)
      out = zero_matrix(h, w)
      y = pad
      while_fun_4 = fn while_fun_4, out, y ->
        if y < h - pad do
          x = pad
          while_fun_5 = fn while_fun_5, out, x ->
            if x < w - pad do
              sum = 0.0
              ky = 0
              while_fun_6 = fn while_fun_6, ky, sum ->
                if ky < k do
                  kx = 0
                  while_fun_7 = fn while_fun_7, kx, sum ->
                    if kx < k do
                      pixel = Enum.at(Enum.at(img, y - pad + ky), x - pad + kx)
                      weight = Enum.at(Enum.at(kernel, ky), kx)
                      sum = sum + pixel * weight
                      kx = kx + 1
                      while_fun_7.(while_fun_7, kx, sum)
                    else
                      {kx, sum}
                    end
                  end
                  {kx, sum} = try do
                      while_fun_7.(while_fun_7, kx, sum)
                    catch
                      {:break, {kx, sum}} -> {kx, sum}
                    end

                  ky = ky + 1
                  while_fun_6.(while_fun_6, ky, sum)
                else
                  {ky, sum}
                end
              end
              {ky, sum} = try do
                  while_fun_6.(while_fun_6, ky, sum)
                catch
                  {:break, {ky, sum}} -> {ky, sum}
                end

              out = List.replace_at(out, y, List.replace_at(Enum.at(out, y), x, sum))
              x = x + 1
              while_fun_5.(while_fun_5, out, x)
            else
              {out, x}
            end
          end
          {out, x} = try do
              while_fun_5.(while_fun_5, out, x)
            catch
              {:break, {out, x}} -> {out, x}
            end

          y = y + 1
          while_fun_4.(while_fun_4, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_4.(while_fun_4, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def gaussian_blur(img) do
    try do
      throw {:return, convolve(img, Process.get(:gaussian_kernel))}
    catch
      {:return, val} -> val
    end
  end
  def sobel_filter(img) do
    try do
      gx = convolve(img, Process.get(:sobel_gx))
      gy = convolve(img, Process.get(:sobel_gy))
      h = _len(img)
      w = _len(Enum.at(img, 0))
      grad = zero_matrix(h, w)
      dir = zero_matrix(h, w)
      i = 0
      while_fun_8 = fn while_fun_8, dir, grad, i ->
        if i < h do
          j = 0
          while_fun_9 = fn while_fun_9, dir, grad, j ->
            if j < w do
              gxx = Enum.at(Enum.at(gx, i), j)
              gyy = Enum.at(Enum.at(gy, i), j)
              grad = List.replace_at(grad, i, List.replace_at(Enum.at(grad, i), j, sqrtApprox(gxx * gxx + gyy * gyy)))
              dir = List.replace_at(dir, i, List.replace_at(Enum.at(dir, i), j, deg(atan2Approx(gyy, gxx)) + 180.0))
              j = j + 1
              while_fun_9.(while_fun_9, dir, grad, j)
            else
              {dir, grad, j}
            end
          end
          {dir, grad, j} = try do
              while_fun_9.(while_fun_9, dir, grad, j)
            catch
              {:break, {dir, grad, j}} -> {dir, grad, j}
            end

          i = i + 1
          while_fun_8.(while_fun_8, dir, grad, i)
        else
          {dir, grad, i}
        end
      end
      {dir, grad, i} = try do
          while_fun_8.(while_fun_8, dir, grad, i)
        catch
          {:break, {dir, grad, i}} -> {dir, grad, i}
        end

      throw {:return, %{"grad" => grad, "dir" => dir}}
    catch
      {:return, val} -> val
    end
  end
  def suppress_non_maximum(h, w, direction, grad) do
    try do
      dest = zero_matrix(h, w)
      r = 1
      while_fun_10 = fn while_fun_10, dest, r ->
        if r < h - 1 do
          c = 1
          while_fun_11 = fn while_fun_11, c, dest ->
            if c < w - 1 do
              angle = Enum.at(Enum.at(direction, r), c)
              q = 0.0
              p = 0.0
              {p, q} = if (angle >= 0.0 && angle < 22.5) || (angle >= 157.5 && angle <= 180.0) || (angle >= 337.5) do
                q = Enum.at(Enum.at(grad, r), c + 1)
                p = Enum.at(Enum.at(grad, r), c - 1)
                {p, q}
              else
                {p, q} = if (angle >= 22.5 && angle < 67.5) || (angle >= 202.5 && angle < 247.5) do
                  q = Enum.at(Enum.at(grad, r + 1), c - 1)
                  p = Enum.at(Enum.at(grad, r - 1), c + 1)
                  {p, q}
                else
                  {p, q} = if (angle >= 67.5 && angle < 112.5) || (angle >= 247.5 && angle < 292.5) do
                    q = Enum.at(Enum.at(grad, r + 1), c)
                    p = Enum.at(Enum.at(grad, r - 1), c)
                    {p, q}
                  else
                    q = Enum.at(Enum.at(grad, r - 1), c - 1)
                    p = Enum.at(Enum.at(grad, r + 1), c + 1)
                    {p, q}
                  end
                  {p, q}
                end
                {p, q}
              end
              {dest} = if Enum.at(Enum.at(grad, r), c) >= q && Enum.at(Enum.at(grad, r), c) >= p do
                dest = List.replace_at(dest, r, List.replace_at(Enum.at(dest, r), c, Enum.at(Enum.at(grad, r), c)))
                {dest}
              else
                {dest}
              end
              c = c + 1
              while_fun_11.(while_fun_11, c, dest)
            else
              {c, dest}
            end
          end
          {c, dest} = try do
              while_fun_11.(while_fun_11, c, dest)
            catch
              {:break, {c, dest}} -> {c, dest}
            end

          r = r + 1
          while_fun_10.(while_fun_10, dest, r)
        else
          {dest, r}
        end
      end
      {dest, r} = try do
          while_fun_10.(while_fun_10, dest, r)
        catch
          {:break, {dest, r}} -> {dest, r}
        end

      throw {:return, dest}
    catch
      {:return, val} -> val
    end
  end
  def double_threshold(h, w, img, low, high, weak, strong) do
    try do
      r = 0
      while_fun_12 = fn while_fun_12, img, r ->
        if r < h do
          c = 0
          while_fun_13 = fn while_fun_13, c, img ->
            if c < w do
              v = Enum.at(Enum.at(img, r), c)
              {img} = if v >= high do
                img = List.replace_at(img, r, List.replace_at(Enum.at(img, r), c, strong))
                {img}
              else
                {img} = if v < low do
                  img = List.replace_at(img, r, List.replace_at(Enum.at(img, r), c, 0.0))
                  {img}
                else
                  img = List.replace_at(img, r, List.replace_at(Enum.at(img, r), c, weak))
                  {img}
                end
                {img}
              end
              c = c + 1
              while_fun_13.(while_fun_13, c, img)
            else
              {c, img}
            end
          end
          {c, img} = try do
              while_fun_13.(while_fun_13, c, img)
            catch
              {:break, {c, img}} -> {c, img}
            end

          r = r + 1
          while_fun_12.(while_fun_12, img, r)
        else
          {img, r}
        end
      end
      {img, r} = try do
          while_fun_12.(while_fun_12, img, r)
        catch
          {:break, {img, r}} -> {img, r}
        end

    catch
      {:return, val} -> val
    end
  end
  def track_edge(h, w, img, weak, strong) do
    try do
      r = 1
      while_fun_14 = fn while_fun_14, img, r ->
        if r < h - 1 do
          c = 1
          while_fun_15 = fn while_fun_15, c, img ->
            if c < w - 1 do
              {img} = if Enum.at(Enum.at(img, r), c) == weak do
                {img} = if Enum.at(Enum.at(img, r + 1), c) == strong || Enum.at(Enum.at(img, r - 1), c) == strong || Enum.at(Enum.at(img, r), c + 1) == strong || Enum.at(Enum.at(img, r), c - 1) == strong || Enum.at(Enum.at(img, r - 1), c - 1) == strong || Enum.at(Enum.at(img, r - 1), c + 1) == strong || Enum.at(Enum.at(img, r + 1), c - 1) == strong || Enum.at(Enum.at(img, r + 1), c + 1) == strong do
                  img = List.replace_at(img, r, List.replace_at(Enum.at(img, r), c, strong))
                  {img}
                else
                  img = List.replace_at(img, r, List.replace_at(Enum.at(img, r), c, 0.0))
                  {img}
                end
                {img}
              else
                {img}
              end
              c = c + 1
              while_fun_15.(while_fun_15, c, img)
            else
              {c, img}
            end
          end
          {c, img} = try do
              while_fun_15.(while_fun_15, c, img)
            catch
              {:break, {c, img}} -> {c, img}
            end

          r = r + 1
          while_fun_14.(while_fun_14, img, r)
        else
          {img, r}
        end
      end
      {img, r} = try do
          while_fun_14.(while_fun_14, img, r)
        catch
          {:break, {img, r}} -> {img, r}
        end

    catch
      {:return, val} -> val
    end
  end
  def canny(image, low, high, weak, strong) do
    try do
      blurred = gaussian_blur(image)
      sob = sobel_filter(blurred)
      grad = sob["grad"]
      direction = sob["dir"]
      h = _len(image)
      w = _len(Enum.at(image, 0))
      suppressed = suppress_non_maximum(h, w, direction, grad)
      double_threshold(h, w, suppressed, low, high, weak, strong)
      track_edge(h, w, suppressed, weak, strong)
      throw {:return, suppressed}
    catch
      {:return, val} -> val
    end
  end
  def print_image(img) do
    try do
      r = 0
      while_fun_16 = fn while_fun_16, r ->
        if r < _len(img) do
          c = 0
          line = ""
          while_fun_17 = fn while_fun_17, c, line ->
            if c < _len(Enum.at(img, r)) do
              line = ((line <> Kernel.to_string((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.at(Enum.at(img, r), c)))) <> " ")
              c = c + 1
              while_fun_17.(while_fun_17, c, line)
            else
              {c, line}
            end
          end
          {c, line} = try do
              while_fun_17.(while_fun_17, c, line)
            catch
              {:break, {c, line}} -> {c, line}
            end

          IO.puts(line)
          r = r + 1
          while_fun_16.(while_fun_16, r)
        else
          r
        end
      end
      r = try do
          while_fun_16.(while_fun_16, r)
        catch
          {:break, {r}} -> r
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:gaussian_kernel, [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]])
  Process.put(:image, [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]])
  def main() do
    Process.put(:sobel_gx, [[-1.0, 0.0, 1.0], [-2.0, 0.0, 2.0], [-1.0, 0.0, 1.0]])
    Process.put(:sobel_gy, [[1.0, 2.0, 1.0], [0.0, 0.0, 0.0], [-1.0, -2.0, -1.0]])
    Process.put(:edges, canny(Process.get(:image), 20.0, 40.0, 128.0, 255.0))
    print_image(Process.get(:edges))
  end
end
Main.main()
