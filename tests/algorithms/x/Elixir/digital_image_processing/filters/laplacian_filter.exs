# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def make_matrix(rows, cols, value) do
    try do
      result = []
      i = 0
      while_fun = fn while_fun, i ->
        if i < rows do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < cols do
              row = (row ++ [value])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def my_laplacian(src, ksize) do
    try do
      kernel = []
      {kernel} = if ksize == 1 do
        kernel = [[0, -1, 0], [-1, 4, -1], [0, -1, 0]]
        {kernel}
      else
        {kernel} = if ksize == 3 do
          kernel = [[0, 1, 0], [1, -4, 1], [0, 1, 0]]
          {kernel}
        else
          {kernel} = if ksize == 5 do
            kernel = [[0, 0, -1, 0, 0], [0, -1, -2, -1, 0], [-1, -2, 16, -2, -1], [0, -1, -2, -1, 0], [0, 0, -1, 0, 0]]
            {kernel}
          else
            {kernel} = if ksize == 7 do
              kernel = [[0, 0, 0, -1, 0, 0, 0], [0, 0, -2, -3, -2, 0, 0], [0, -2, -7, -10, -7, -2, 0], [-1, -3, -10, 68, -10, -3, -1], [0, -2, -7, -10, -7, -2, 0], [0, 0, -2, -3, -2, 0, 0], [0, 0, 0, -1, 0, 0, 0]]
              {kernel}
            else
              raise("ksize must be in (1, 3, 5, 7)")
              {kernel}
            end
            {kernel}
          end
          {kernel}
        end
        {kernel}
      end
      rows = _len(src)
      cols = _len(Enum.at(src, 0))
      k = _len(kernel)
      pad = div(k, 2)
      output = make_matrix(rows, cols, 0)
      i = 0
      while_fun_3 = fn while_fun_3, i, output ->
        if i < rows do
          j = 0
          while_fun_4 = fn while_fun_4, j, output ->
            if j < cols do
              sum = 0
              ki = 0
              while_fun_5 = fn while_fun_5, ki, sum ->
                if ki < k do
                  kj = 0
                  while_fun_6 = fn while_fun_6, kj, sum ->
                    if kj < k do
                      ii = i + ki - pad
                      jj = j + kj - pad
                      val = 0
                      {val} = if ii >= 0 && ii < rows && jj >= 0 && jj < cols do
                        val = Enum.at(Enum.at(src, ii), jj)
                        {val}
                      else
                        {val}
                      end
                      sum = sum + val * Enum.at(Enum.at(kernel, ki), kj)
                      kj = kj + 1
                      while_fun_6.(while_fun_6, kj, sum)
                    else
                      {kj, sum}
                    end
                  end
                  {kj, sum} = try do
                      while_fun_6.(while_fun_6, kj, sum)
                    catch
                      {:break, {kj, sum}} -> {kj, sum}
                    end

                  ki = ki + 1
                  while_fun_5.(while_fun_5, ki, sum)
                else
                  {ki, sum}
                end
              end
              {ki, sum} = try do
                  while_fun_5.(while_fun_5, ki, sum)
                catch
                  {:break, {ki, sum}} -> {ki, sum}
                end

              output = List.replace_at(output, i, List.replace_at(Enum.at(output, i), j, sum))
              j = j + 1
              while_fun_4.(while_fun_4, j, output)
            else
              {j, output}
            end
          end
          {j, output} = try do
              while_fun_4.(while_fun_4, j, output)
            catch
              {:break, {j, output}} -> {j, output}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, output)
        else
          {i, output}
        end
      end
      {i, output} = try do
          while_fun_3.(while_fun_3, i, output)
        catch
          {:break, {i, output}} -> {i, output}
        end

      throw {:return, output}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:image, [[0, 0, 0, 0, 0], [0, 10, 10, 10, 0], [0, 10, 10, 10, 0], [0, 10, 10, 10, 0], [0, 0, 0, 0, 0]])
  Process.put(:r, 0)
  def main() do
    Process.put(:result, my_laplacian(Process.get(:image), 3))
    while_fun_7 = fn while_fun_7 ->
      if Process.get(:r) < _len(Process.get(:result)) do
        row_str = "["
        c = 0
        while_fun_8 = fn while_fun_8, c, row_str ->
          if c < _len(Enum.at(Process.get(:result), Process.get(:r))) do
            row_str = (row_str <> Kernel.to_string(Enum.at(Enum.at(Process.get(:result), Process.get(:r)), c)))
            {row_str} = if c + 1 < _len(Enum.at(Process.get(:result), Process.get(:r))) do
              row_str = (row_str <> ", ")
              {row_str}
            else
              {row_str}
            end
            c = c + 1
            while_fun_8.(while_fun_8, c, row_str)
          else
            {c, row_str}
          end
        end
        {c, row_str} = try do
            while_fun_8.(while_fun_8, c, row_str)
          catch
            {:break, {c, row_str}} -> {c, row_str}
          end

        row_str = (row_str <> "]")
        IO.puts(row_str)
        Process.put(:r, Process.get(:r) + 1)
        while_fun_7.(while_fun_7)
      else
        nil
      end
    end
    try do
      while_fun_7.(while_fun_7)
    catch
      :break -> nil
    end

  end
end
Main.main()
