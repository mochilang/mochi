# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def abs_(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def expApprox(x) do
    try do
      term = 1.0
      sum = 1.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n < 10 do
          term = term * x / (:erlang.float(n))
          sum = sum + term
          n = n + 1
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def vec_gaussian(mat, variance) do
    try do
      i = 0
      out = []
      while_fun_3 = fn while_fun_3, i, out ->
        if i < _len(mat) do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j < _len(Enum.at(mat, i)) do
              v = Enum.at(Enum.at(mat, i), j)
              e = -(v * v) / (2.0 * variance)
              row = (row ++ [expApprox(e)])
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          out = (out ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_3.(while_fun_3, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def get_slice(img, x, y, kernel_size) do
    try do
      half = div(kernel_size, 2)
      i = x - half
      slice = []
      while_fun_5 = fn while_fun_5, i, slice ->
        if i <= x + half do
          row = []
          j = y - half
          while_fun_6 = fn while_fun_6, j, row ->
            if j <= y + half do
              row = (row ++ [Enum.at(Enum.at(img, i), j)])
              j = j + 1
              while_fun_6.(while_fun_6, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_6.(while_fun_6, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          slice = (slice ++ [row])
          i = i + 1
          while_fun_5.(while_fun_5, i, slice)
        else
          {i, slice}
        end
      end
      {i, slice} = try do
          while_fun_5.(while_fun_5, i, slice)
        catch
          {:break, {i, slice}} -> {i, slice}
        end

      throw {:return, slice}
    catch
      {:return, val} -> val
    end
  end
  def get_gauss_kernel(kernel_size, spatial_variance) do
    try do
      arr = []
      i = 0
      while_fun_7 = fn while_fun_7, arr, i ->
        if i < kernel_size do
          row = []
          j = 0
          while_fun_8 = fn while_fun_8, j, row ->
            if j < kernel_size do
              di = :erlang.float((i - div(kernel_size, 2)))
              dj = :erlang.float((j - div(kernel_size, 2)))
              dist = sqrtApprox(di * di + dj * dj)
              row = (row ++ [dist])
              j = j + 1
              while_fun_8.(while_fun_8, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_8.(while_fun_8, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          arr = (arr ++ [row])
          i = i + 1
          while_fun_7.(while_fun_7, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_7.(while_fun_7, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, vec_gaussian(arr, spatial_variance)}
    catch
      {:return, val} -> val
    end
  end
  def elementwise_sub(mat, value) do
    try do
      res = []
      i = 0
      while_fun_9 = fn while_fun_9, i, res ->
        if i < _len(mat) do
          row = []
          j = 0
          while_fun_10 = fn while_fun_10, j, row ->
            if j < _len(Enum.at(mat, i)) do
              row = (row ++ [Enum.at(Enum.at(mat, i), j) - value])
              j = j + 1
              while_fun_10.(while_fun_10, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_10.(while_fun_10, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def elementwise_mul(a, b) do
    try do
      res = []
      i = 0
      while_fun_11 = fn while_fun_11, i, res ->
        if i < _len(a) do
          row = []
          j = 0
          while_fun_12 = fn while_fun_12, j, row ->
            if j < _len(Enum.at(a, i)) do
              row = (row ++ [Enum.at(Enum.at(a, i), j) * Enum.at(Enum.at(b, i), j)])
              j = j + 1
              while_fun_12.(while_fun_12, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_12.(while_fun_12, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          res = (res ++ [row])
          i = i + 1
          while_fun_11.(while_fun_11, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_11.(while_fun_11, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def matrix_sum(mat) do
    try do
      total = 0.0
      i = 0
      while_fun_13 = fn while_fun_13, i, total ->
        if i < _len(mat) do
          j = 0
          while_fun_14 = fn while_fun_14, j, total ->
            if j < _len(Enum.at(mat, i)) do
              total = total + Enum.at(Enum.at(mat, i), j)
              j = j + 1
              while_fun_14.(while_fun_14, j, total)
            else
              {j, total}
            end
          end
          {j, total} = try do
              while_fun_14.(while_fun_14, j, total)
            catch
              {:break, {j, total}} -> {j, total}
            end

          i = i + 1
          while_fun_13.(while_fun_13, i, total)
        else
          {i, total}
        end
      end
      {i, total} = try do
          while_fun_13.(while_fun_13, i, total)
        catch
          {:break, {i, total}} -> {i, total}
        end

      throw {:return, total}
    catch
      {:return, val} -> val
    end
  end
  def bilateral_filter(img, spatial_variance, intensity_variance, kernel_size) do
    try do
      gauss_ker = get_gauss_kernel(kernel_size, spatial_variance)
      img_s = img
      center = Enum.at(Enum.at(img_s, div(kernel_size, 2)), div(kernel_size, 2))
      img_i = elementwise_sub(img_s, center)
      img_ig = vec_gaussian(img_i, intensity_variance)
      weights = elementwise_mul(gauss_ker, img_ig)
      vals = elementwise_mul(img_s, weights)
      sum_weights = matrix_sum(weights)
      val = 0.0
      {val} = if sum_weights != 0.0 do
        val = matrix_sum(vals) / sum_weights
        {val}
      else
        {val}
      end
      throw {:return, val}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:img, [[0.2, 0.3, 0.4], [0.3, 0.4, 0.5], [0.4, 0.5, 0.6]])
  def main() do
    Process.put(:result, bilateral_filter(Process.get(:img), 1.0, 1.0, 3))
    IO.puts(Process.get(:result))
  end
end
Main.main()
