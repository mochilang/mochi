# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def absf(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      guess = x / 2.0
      i = 0
      while_fun = fn while_fun, guess, i ->
        if i < 20 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun.(while_fun, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun.(while_fun, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def atanApprox(x) do
    try do
      if x > 1.0 do
        throw {:return, Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      if x < (-1.0) do
        throw {:return, -Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      throw {:return, x / (1.0 + 0.28 * x * x)}
    catch
      {:return, val} -> val
    end
  end
  def atan2Approx(y, x) do
    try do
      if x == 0.0 do
        if y > 0.0 do
          throw {:return, Process.get(:pi) / 2.0}
        end
        if y < 0.0 do
          throw {:return, -Process.get(:pi) / 2.0}
        end
        throw {:return, 0.0}
      end
      a = atanApprox(y / x)
      if x > 0.0 do
        throw {:return, a}
      end
      if y >= 0.0 do
        throw {:return, a + Process.get(:pi)}
      end
      throw {:return, a - Process.get(:pi)}
    catch
      {:return, val} -> val
    end
  end
  def zeros(h, w) do
    try do
      m = []
      y = 0
      while_fun_2 = fn while_fun_2, m, y ->
        if y < h do
          row = []
          x = 0
          while_fun_3 = fn while_fun_3, row, x ->
            if x < w do
              row = (row ++ [0.0])
              x = x + 1
              while_fun_3.(while_fun_3, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_3.(while_fun_3, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          m = (m ++ [row])
          y = y + 1
          while_fun_2.(while_fun_2, m, y)
        else
          {m, y}
        end
      end
      {m, y} = try do
          while_fun_2.(while_fun_2, m, y)
        catch
          {:break, {m, y}} -> {m, y}
        end

      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def pad_edge(img, pad) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      out = zeros(h + pad * 2, w + pad * 2)
      y = 0
      while_fun_4 = fn while_fun_4, out, y ->
        if y < h + pad * 2 do
          x = 0
          while_fun_5 = fn while_fun_5, out, x ->
            if x < w + pad * 2 do
              sy = y - pad
              {sy} = if sy < 0 do
                sy = 0
                {sy}
              else
                {sy}
              end
              {sy} = if sy >= h do
                sy = h - 1
                {sy}
              else
                {sy}
              end
              sx = x - pad
              {sx} = if sx < 0 do
                sx = 0
                {sx}
              else
                {sx}
              end
              {sx} = if sx >= w do
                sx = w - 1
                {sx}
              else
                {sx}
              end
              out = List.replace_at(out, y, List.replace_at(Enum.at(out, y), x, Enum.at(Enum.at(img, sy), sx)))
              x = x + 1
              while_fun_5.(while_fun_5, out, x)
            else
              {out, x}
            end
          end
          {out, x} = try do
              while_fun_5.(while_fun_5, out, x)
            catch
              {:break, {out, x}} -> {out, x}
            end

          y = y + 1
          while_fun_4.(while_fun_4, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_4.(while_fun_4, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def img_convolve(img, kernel) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      k = _len(kernel)
      pad = div(k, 2)
      padded = pad_edge(img, pad)
      out = zeros(h, w)
      y = 0
      while_fun_6 = fn while_fun_6, out, y ->
        if y < h do
          x = 0
          while_fun_7 = fn while_fun_7, out, x ->
            if x < w do
              sum = 0.0
              i = 0
              while_fun_8 = fn while_fun_8, i, sum ->
                if i < k do
                  j = 0
                  while_fun_9 = fn while_fun_9, j, sum ->
                    if j < k do
                      sum = sum + Enum.at(Enum.at(padded, y + i), x + j) * (:erlang.float(Enum.at(Enum.at(kernel, i), j)))
                      j = j + 1
                      while_fun_9.(while_fun_9, j, sum)
                    else
                      {j, sum}
                    end
                  end
                  {j, sum} = try do
                      while_fun_9.(while_fun_9, j, sum)
                    catch
                      {:break, {j, sum}} -> {j, sum}
                    end

                  i = i + 1
                  while_fun_8.(while_fun_8, i, sum)
                else
                  {i, sum}
                end
              end
              {i, sum} = try do
                  while_fun_8.(while_fun_8, i, sum)
                catch
                  {:break, {i, sum}} -> {i, sum}
                end

              out = List.replace_at(out, y, List.replace_at(Enum.at(out, y), x, sum))
              x = x + 1
              while_fun_7.(while_fun_7, out, x)
            else
              {out, x}
            end
          end
          {out, x} = try do
              while_fun_7.(while_fun_7, out, x)
            catch
              {:break, {out, x}} -> {out, x}
            end

          y = y + 1
          while_fun_6.(while_fun_6, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_6.(while_fun_6, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def abs_matrix(mat) do
    try do
      h = _len(mat)
      w = _len(Enum.at(mat, 0))
      out = zeros(h, w)
      y = 0
      while_fun_10 = fn while_fun_10, out, y ->
        if y < h do
          x = 0
          while_fun_11 = fn while_fun_11, out, x ->
            if x < w do
              v = Enum.at(Enum.at(mat, y), x)
              {out} = if v < 0.0 do
                out = List.replace_at(out, y, List.replace_at(Enum.at(out, y), x, -v))
                {out}
              else
                out = List.replace_at(out, y, List.replace_at(Enum.at(out, y), x, v))
                {out}
              end
              x = x + 1
              while_fun_11.(while_fun_11, out, x)
            else
              {out, x}
            end
          end
          {out, x} = try do
              while_fun_11.(while_fun_11, out, x)
            catch
              {:break, {out, x}} -> {out, x}
            end

          y = y + 1
          while_fun_10.(while_fun_10, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_10.(while_fun_10, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def max_matrix(mat) do
    try do
      max_val = Enum.at(Enum.at(mat, 0), 0)
      y = 0
      while_fun_12 = fn while_fun_12, max_val, y ->
        if y < _len(mat) do
          x = 0
          while_fun_13 = fn while_fun_13, max_val, x ->
            if x < _len(Enum.at(mat, 0)) do
              {max_val} = if Enum.at(Enum.at(mat, y), x) > max_val do
                max_val = Enum.at(Enum.at(mat, y), x)
                {max_val}
              else
                {max_val}
              end
              x = x + 1
              while_fun_13.(while_fun_13, max_val, x)
            else
              {max_val, x}
            end
          end
          {max_val, x} = try do
              while_fun_13.(while_fun_13, max_val, x)
            catch
              {:break, {max_val, x}} -> {max_val, x}
            end

          y = y + 1
          while_fun_12.(while_fun_12, max_val, y)
        else
          {max_val, y}
        end
      end
      {max_val, y} = try do
          while_fun_12.(while_fun_12, max_val, y)
        catch
          {:break, {max_val, y}} -> {max_val, y}
        end

      throw {:return, max_val}
    catch
      {:return, val} -> val
    end
  end
  def scale_matrix(mat, factor) do
    try do
      h = _len(mat)
      w = _len(Enum.at(mat, 0))
      out = zeros(h, w)
      y = 0
      while_fun_14 = fn while_fun_14, out, y ->
        if y < h do
          x = 0
          while_fun_15 = fn while_fun_15, out, x ->
            if x < w do
              out = List.replace_at(out, y, List.replace_at(Enum.at(out, y), x, Enum.at(Enum.at(mat, y), x) * factor))
              x = x + 1
              while_fun_15.(while_fun_15, out, x)
            else
              {out, x}
            end
          end
          {out, x} = try do
              while_fun_15.(while_fun_15, out, x)
            catch
              {:break, {out, x}} -> {out, x}
            end

          y = y + 1
          while_fun_14.(while_fun_14, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_14.(while_fun_14, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def sobel_filter(image) do
    try do
      h = _len(image)
      w = _len(Enum.at(image, 0))
      img = []
      y0 = 0
      while_fun_16 = fn while_fun_16, img, y0 ->
        if y0 < h do
          row = []
          x0 = 0
          while_fun_17 = fn while_fun_17, row, x0 ->
            if x0 < w do
              row = (row ++ [:erlang.float(Enum.at(Enum.at(image, y0), x0))])
              x0 = x0 + 1
              while_fun_17.(while_fun_17, row, x0)
            else
              {row, x0}
            end
          end
          {row, x0} = try do
              while_fun_17.(while_fun_17, row, x0)
            catch
              {:break, {row, x0}} -> {row, x0}
            end

          img = (img ++ [row])
          y0 = y0 + 1
          while_fun_16.(while_fun_16, img, y0)
        else
          {img, y0}
        end
      end
      {img, y0} = try do
          while_fun_16.(while_fun_16, img, y0)
        catch
          {:break, {img, y0}} -> {img, y0}
        end

      kernel_x = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]
      kernel_y = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]
      dst_x = abs_matrix(img_convolve(img, kernel_x))
      dst_y = abs_matrix(img_convolve(img, kernel_y))
      max_x = max_matrix(dst_x)
      max_y = max_matrix(dst_y)
      dst_x = scale_matrix(dst_x, 255.0 / max_x)
      dst_y = scale_matrix(dst_y, 255.0 / max_y)
      mag = zeros(h, w)
      theta = zeros(h, w)
      y = 0
      while_fun_18 = fn while_fun_18, mag, theta, y ->
        if y < h do
          x = 0
          while_fun_19 = fn while_fun_19, mag, theta, x ->
            if x < w do
              gx = Enum.at(Enum.at(dst_x, y), x)
              gy = Enum.at(Enum.at(dst_y, y), x)
              mag = List.replace_at(mag, y, List.replace_at(Enum.at(mag, y), x, sqrtApprox(gx * gx + gy * gy)))
              theta = List.replace_at(theta, y, List.replace_at(Enum.at(theta, y), x, atan2Approx(gy, gx)))
              x = x + 1
              while_fun_19.(while_fun_19, mag, theta, x)
            else
              {mag, theta, x}
            end
          end
          {mag, theta, x} = try do
              while_fun_19.(while_fun_19, mag, theta, x)
            catch
              {:break, {mag, theta, x}} -> {mag, theta, x}
            end

          y = y + 1
          while_fun_18.(while_fun_18, mag, theta, y)
        else
          {mag, theta, y}
        end
      end
      {mag, theta, y} = try do
          while_fun_18.(while_fun_18, mag, theta, y)
        catch
          {:break, {mag, theta, y}} -> {mag, theta, y}
        end

      max_m = max_matrix(mag)
      mag = scale_matrix(mag, 255.0 / max_m)
      throw {:return, [mag, theta]}
    catch
      {:return, val} -> val
    end
  end
  def print_matrix_int(mat) do
    try do
      y = 0
      while_fun_20 = fn while_fun_20, y ->
        if y < _len(mat) do
          line = ""
          x = 0
          while_fun_21 = fn while_fun_21, line, x ->
            if x < _len(Enum.at(mat, y)) do
              line = (line <> Kernel.to_string((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.at(Enum.at(mat, y), x))))
              {line} = if x < _len(Enum.at(mat, y)) - 1 do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              x = x + 1
              while_fun_21.(while_fun_21, line, x)
            else
              {line, x}
            end
          end
          {line, x} = try do
              while_fun_21.(while_fun_21, line, x)
            catch
              {:break, {line, x}} -> {line, x}
            end

          IO.puts(line)
          y = y + 1
          while_fun_20.(while_fun_20, y)
        else
          y
        end
      end
      y = try do
          while_fun_20.(while_fun_20, y)
        catch
          {:break, {y}} -> y
        end

    catch
      {:return, val} -> val
    end
  end
  def print_matrix_float(mat) do
    try do
      y = 0
      while_fun_22 = fn while_fun_22, y ->
        if y < _len(mat) do
          line = ""
          x = 0
          while_fun_23 = fn while_fun_23, line, x ->
            if x < _len(Enum.at(mat, y)) do
              line = (line <> Kernel.to_string(Enum.at(Enum.at(mat, y), x)))
              {line} = if x < _len(Enum.at(mat, y)) - 1 do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              x = x + 1
              while_fun_23.(while_fun_23, line, x)
            else
              {line, x}
            end
          end
          {line, x} = try do
              while_fun_23.(while_fun_23, line, x)
            catch
              {:break, {line, x}} -> {line, x}
            end

          IO.puts(line)
          y = y + 1
          while_fun_22.(while_fun_22, y)
        else
          y
        end
      end
      y = try do
          while_fun_22.(while_fun_22, y)
        catch
          {:break, {y}} -> y
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      img = [[10, 10, 10, 10, 10], [10, 50, 50, 50, 10], [10, 50, 80, 50, 10], [10, 50, 50, 50, 10], [10, 10, 10, 10, 10]]
      res = sobel_filter(img)
      mag = Enum.at(res, 0)
      theta = Enum.at(res, 1)
      print_matrix_int(mag)
      print_matrix_float(theta)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
end
Main.main()
