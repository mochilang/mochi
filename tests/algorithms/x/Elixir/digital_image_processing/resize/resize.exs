# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def zeros3d(h, w, c) do
    try do
      arr = []
      y = 0
      while_fun = fn while_fun, arr, y ->
        if y < h do
          row = []
          x = 0
          while_fun_2 = fn while_fun_2, row, x ->
            if x < w do
              pixel = []
              k = 0
              while_fun_3 = fn while_fun_3, k, pixel ->
                if k < c do
                  pixel = (pixel ++ [0])
                  k = k + 1
                  while_fun_3.(while_fun_3, k, pixel)
                else
                  {k, pixel}
                end
              end
              {k, pixel} = try do
                  while_fun_3.(while_fun_3, k, pixel)
                catch
                  {:break, {k, pixel}} -> {k, pixel}
                end

              row = (row ++ [pixel])
              x = x + 1
              while_fun_2.(while_fun_2, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_2.(while_fun_2, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          arr = (arr ++ [row])
          y = y + 1
          while_fun.(while_fun, arr, y)
        else
          {arr, y}
        end
      end
      {arr, y} = try do
          while_fun.(while_fun, arr, y)
        catch
          {:break, {arr, y}} -> {arr, y}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def resize_nn(img, dst_w, dst_h) do
    try do
      src_h = _len(img)
      src_w = _len(Enum.at(img, 0))
      channels = _len(Enum.at(Enum.at(img, 0), 0))
      ratio_x = (:erlang.float(src_w)) / (:erlang.float(dst_w))
      ratio_y = (:erlang.float(src_h)) / (:erlang.float(dst_h))
      out = zeros3d(dst_h, dst_w, channels)
      i = 0
      while_fun_4 = fn while_fun_4, i, out ->
        if i < dst_h do
          j = 0
          while_fun_5 = fn while_fun_5, j, out ->
            if j < dst_w do
              src_x = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((ratio_x * (:erlang.float(j))))
              src_y = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((ratio_y * (:erlang.float(i))))
              out = List.replace_at(out, i, List.replace_at(Enum.at(out, i), j, Enum.at(Enum.at(img, src_y), src_x)))
              j = j + 1
              while_fun_5.(while_fun_5, j, out)
            else
              {j, out}
            end
          end
          {j, out} = try do
              while_fun_5.(while_fun_5, j, out)
            catch
              {:break, {j, out}} -> {j, out}
            end

          i = i + 1
          while_fun_4.(while_fun_4, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_4.(while_fun_4, i, out)
        catch
          {:break, {i, out}} -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      img = [[[0, 0, 0], [255, 255, 255]], [[255, 0, 0], [0, 255, 0]]]
      resized = resize_nn(img, 4, 4)
      IO.puts(Kernel.inspect(resized))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
