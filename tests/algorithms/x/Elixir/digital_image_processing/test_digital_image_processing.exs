# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def clamp_byte(x) do
    try do
      if x < 0 do
        throw {:return, 0}
      end
      if x > 255 do
        throw {:return, 255}
      end
      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def convert_to_negative(img) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      out = []
      y = 0
      while_fun = fn while_fun, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_2 = fn while_fun_2, row, x ->
            if x < w do
              row = (row ++ [255 - Enum.at(Enum.at(img, y), x)])
              x = x + 1
              while_fun_2.(while_fun_2, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_2.(while_fun_2, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun.(while_fun, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun.(while_fun, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def change_contrast(img, factor) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      out = []
      y = 0
      while_fun_3 = fn while_fun_3, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_4 = fn while_fun_4, row, x ->
            if x < w do
              p = Enum.at(Enum.at(img, y), x)
              v = div(((p - 128) * factor), 100) + 128
              v = clamp_byte(v)
              row = (row ++ [v])
              x = x + 1
              while_fun_4.(while_fun_4, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_4.(while_fun_4, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_3.(while_fun_3, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_3.(while_fun_3, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def gen_gaussian_kernel(n, sigma) do
    try do
      if n == 3 do
        throw {:return, [[1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0], [2.0 / 16.0, 4.0 / 16.0, 2.0 / 16.0], [1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0]]}
      end
      k = []
      i = 0
      while_fun_5 = fn while_fun_5, i, k ->
        if i < n do
          row = []
          j = 0
          while_fun_6 = fn while_fun_6, j, row ->
            if j < n do
              row = (row ++ [0.0])
              j = j + 1
              while_fun_6.(while_fun_6, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_6.(while_fun_6, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          k = (k ++ [row])
          i = i + 1
          while_fun_5.(while_fun_5, i, k)
        else
          {i, k}
        end
      end
      {i, k} = try do
          while_fun_5.(while_fun_5, i, k)
        catch
          {:break, {i, k}} -> {i, k}
        end

      throw {:return, k}
    catch
      {:return, val} -> val
    end
  end
  def img_convolve(img, kernel) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      out = []
      y = 0
      while_fun_7 = fn while_fun_7, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_8 = fn while_fun_8, row, x ->
            if x < w do
              acc = 0.0
              ky = 0
              while_fun_9 = fn while_fun_9, acc, ky ->
                if ky < _len(kernel) do
                  kx = 0
                  while_fun_10 = fn while_fun_10, acc, kx ->
                    if kx < _len(Enum.at(kernel, 0)) do
                      iy = y + ky - 1
                      ix = x + kx - 1
                      pixel = 0
                      {pixel} = if iy >= 0 && iy < h && ix >= 0 && ix < w do
                        pixel = Enum.at(Enum.at(img, iy), ix)
                        {pixel}
                      else
                        {pixel}
                      end
                      acc = acc + Enum.at(Enum.at(kernel, ky), kx) * (1.0 * pixel)
                      kx = kx + 1
                      while_fun_10.(while_fun_10, acc, kx)
                    else
                      {acc, kx}
                    end
                  end
                  {acc, kx} = try do
                      while_fun_10.(while_fun_10, acc, kx)
                    catch
                      {:break, {acc, kx}} -> {acc, kx}
                    end

                  ky = ky + 1
                  while_fun_9.(while_fun_9, acc, ky)
                else
                  {acc, ky}
                end
              end
              {acc, ky} = try do
                  while_fun_9.(while_fun_9, acc, ky)
                catch
                  {:break, {acc, ky}} -> {acc, ky}
                end

              row = (row ++ [Kernel.trunc(acc)])
              x = x + 1
              while_fun_8.(while_fun_8, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_8.(while_fun_8, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_7.(while_fun_7, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_7.(while_fun_7, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def sort_ints(xs) do
    try do
      arr = xs
      i = 0
      while_fun_11 = fn while_fun_11, arr, i ->
        if i < _len(arr) do
          j = 0
          while_fun_12 = fn while_fun_12, arr, j ->
            if j < _len(arr) - 1 - i do
              {arr} = if Enum.at(arr, j) > Enum.at(arr, j + 1) do
                tmp = Enum.at(arr, j)
                arr = List.replace_at(arr, j, Enum.at(arr, j + 1))
                arr = List.replace_at(arr, j + 1, tmp)
                {arr}
              else
                {arr}
              end
              j = j + 1
              while_fun_12.(while_fun_12, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_12.(while_fun_12, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun_11.(while_fun_11, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_11.(while_fun_11, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def median_filter(img, k) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      offset = div(k, 2)
      out = []
      y = 0
      while_fun_13 = fn while_fun_13, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_14 = fn while_fun_14, row, x ->
            if x < w do
              vals = []
              ky = 0
              while_fun_15 = fn while_fun_15, ky, vals ->
                if ky < k do
                  kx = 0
                  while_fun_16 = fn while_fun_16, kx, vals ->
                    if kx < k do
                      iy = y + ky - offset
                      ix = x + kx - offset
                      pixel = 0
                      {pixel} = if iy >= 0 && iy < h && ix >= 0 && ix < w do
                        pixel = Enum.at(Enum.at(img, iy), ix)
                        {pixel}
                      else
                        {pixel}
                      end
                      vals = (vals ++ [pixel])
                      kx = kx + 1
                      while_fun_16.(while_fun_16, kx, vals)
                    else
                      {kx, vals}
                    end
                  end
                  {kx, vals} = try do
                      while_fun_16.(while_fun_16, kx, vals)
                    catch
                      {:break, {kx, vals}} -> {kx, vals}
                    end

                  ky = ky + 1
                  while_fun_15.(while_fun_15, ky, vals)
                else
                  {ky, vals}
                end
              end
              {ky, vals} = try do
                  while_fun_15.(while_fun_15, ky, vals)
                catch
                  {:break, {ky, vals}} -> {ky, vals}
                end

              sorted = sort_ints(vals)
              row = (row ++ [Enum.at(sorted, div(_len(sorted), 2))])
              x = x + 1
              while_fun_14.(while_fun_14, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_14.(while_fun_14, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_13.(while_fun_13, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_13.(while_fun_13, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def iabs(x) do
    try do
      throw {:return, ((if x < 0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def sobel_filter(img) do
    try do
      gx = [[1, 0, -1], [2, 0, -2], [1, 0, -1]]
      gy = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]
      h = _len(img)
      w = _len(Enum.at(img, 0))
      out = []
      y = 0
      while_fun_17 = fn while_fun_17, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_18 = fn while_fun_18, row, x ->
            if x < w do
              sx = 0
              sy = 0
              ky = 0
              while_fun_19 = fn while_fun_19, ky, sx, sy ->
                if ky < 3 do
                  kx = 0
                  while_fun_20 = fn while_fun_20, kx, sx, sy ->
                    if kx < 3 do
                      iy = y + ky - 1
                      ix = x + kx - 1
                      pixel = 0
                      {pixel} = if iy >= 0 && iy < h && ix >= 0 && ix < w do
                        pixel = Enum.at(Enum.at(img, iy), ix)
                        {pixel}
                      else
                        {pixel}
                      end
                      sx = sx + Enum.at(Enum.at(gx, ky), kx) * pixel
                      sy = sy + Enum.at(Enum.at(gy, ky), kx) * pixel
                      kx = kx + 1
                      while_fun_20.(while_fun_20, kx, sx, sy)
                    else
                      {kx, sx, sy}
                    end
                  end
                  {kx, sx, sy} = try do
                      while_fun_20.(while_fun_20, kx, sx, sy)
                    catch
                      {:break, {kx, sx, sy}} -> {kx, sx, sy}
                    end

                  ky = ky + 1
                  while_fun_19.(while_fun_19, ky, sx, sy)
                else
                  {ky, sx, sy}
                end
              end
              {ky, sx, sy} = try do
                  while_fun_19.(while_fun_19, ky, sx, sy)
                catch
                  {:break, {ky, sx, sy}} -> {ky, sx, sy}
                end

              row = (row ++ [iabs(sx) + iabs(sy)])
              x = x + 1
              while_fun_18.(while_fun_18, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_18.(while_fun_18, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_17.(while_fun_17, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_17.(while_fun_17, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def get_neighbors_pixel(img, x, y) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      neighbors = []
      dy = -1
      while_fun_21 = fn while_fun_21, dy, neighbors ->
        if dy <= 1 do
          dx = -1
          while_fun_22 = fn while_fun_22, dx, neighbors ->
            if dx <= 1 do
              {neighbors} = if !(dx == 0 && dy == 0) do
                ny = y + dy
                nx = x + dx
                val = 0
                {val} = if ny >= 0 && ny < h && nx >= 0 && nx < w do
                  val = Enum.at(Enum.at(img, ny), nx)
                  {val}
                else
                  {val}
                end
                neighbors = (neighbors ++ [val])
                {neighbors}
              else
                {neighbors}
              end
              dx = dx + 1
              while_fun_22.(while_fun_22, dx, neighbors)
            else
              {dx, neighbors}
            end
          end
          {dx, neighbors} = try do
              while_fun_22.(while_fun_22, dx, neighbors)
            catch
              {:break, {dx, neighbors}} -> {dx, neighbors}
            end

          dy = dy + 1
          while_fun_21.(while_fun_21, dy, neighbors)
        else
          {dy, neighbors}
        end
      end
      {dy, neighbors} = try do
          while_fun_21.(while_fun_21, dy, neighbors)
        catch
          {:break, {dy, neighbors}} -> {dy, neighbors}
        end

      throw {:return, neighbors}
    catch
      {:return, val} -> val
    end
  end
  def pow2(e) do
    try do
      r = 1
      i = 0
      while_fun_23 = fn while_fun_23, i, r ->
        if i < e do
          r = r * 2
          i = i + 1
          while_fun_23.(while_fun_23, i, r)
        else
          {i, r}
        end
      end
      {i, r} = try do
          while_fun_23.(while_fun_23, i, r)
        catch
          {:break, {i, r}} -> {i, r}
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def local_binary_value(img, x, y) do
    try do
      center = Enum.at(Enum.at(img, y), x)
      neighbors = get_neighbors_pixel(img, x, y)
      v = 0
      i = 0
      while_fun_24 = fn while_fun_24, i, v ->
        if i < _len(neighbors) do
          {v} = if Enum.at(neighbors, i) >= center do
            v = v + pow2(i)
            {v}
          else
            {v}
          end
          i = i + 1
          while_fun_24.(while_fun_24, i, v)
        else
          {i, v}
        end
      end
      {i, v} = try do
          while_fun_24.(while_fun_24, i, v)
        catch
          {:break, {i, v}} -> {i, v}
        end

      throw {:return, v}
    catch
      {:return, val} -> val
    end
  end
  def local_binary_pattern(img) do
    try do
      h = _len(img)
      w = _len(Enum.at(img, 0))
      out = []
      y = 0
      while_fun_25 = fn while_fun_25, out, y ->
        if y < h do
          row = []
          x = 0
          while_fun_26 = fn while_fun_26, row, x ->
            if x < w do
              row = (row ++ [local_binary_value(img, x, y)])
              x = x + 1
              while_fun_26.(while_fun_26, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_26.(while_fun_26, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          out = (out ++ [row])
          y = y + 1
          while_fun_25.(while_fun_25, out, y)
        else
          {out, y}
        end
      end
      {out, y} = try do
          while_fun_25.(while_fun_25, out, y)
        catch
          {:break, {out, y}} -> {out, y}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:img, [[52, 55, 61], [62, 59, 55], [63, 65, 66]])
  def main() do
    Process.put(:negative, convert_to_negative(Process.get(:img)))
    Process.put(:contrast, change_contrast(Process.get(:img), 110))
    Process.put(:kernel, gen_gaussian_kernel(3, 1.0))
    Process.put(:laplace, [[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]])
    Process.put(:convolved, img_convolve(Process.get(:img), Process.get(:laplace)))
    Process.put(:medianed, median_filter(Process.get(:img), 3))
    Process.put(:sobel, sobel_filter(Process.get(:img)))
    Process.put(:lbp_img, local_binary_pattern(Process.get(:img)))
    IO.puts(Kernel.inspect(Process.get(:negative)))
    IO.puts(Kernel.inspect(Process.get(:contrast)))
    IO.puts(Kernel.inspect(Process.get(:kernel)))
    IO.puts(Kernel.inspect(Process.get(:convolved)))
    IO.puts(Kernel.inspect(Process.get(:medianed)))
    IO.puts(Kernel.inspect(Process.get(:sobel)))
    IO.puts(Kernel.inspect(Process.get(:lbp_img)))
  end
end
Main.main()
