# Code generated by Mochi transpiler 2025-08-08 09:18 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rgb_to_gray(rgb) do
    try do
      gray = []
      i = 0
      while_fun = fn while_fun, gray, i ->
        if i < _len(rgb) do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < _len(Enum.at(rgb, i)) do
              r = :erlang.float(Enum.at(Enum.at(Enum.at(rgb, i), j), 0))
              g = :erlang.float(Enum.at(Enum.at(Enum.at(rgb, i), j), 1))
              b = :erlang.float(Enum.at(Enum.at(Enum.at(rgb, i), j), 2))
              value = 0.2989 * r + 0.587 * g + 0.114 * b
              row = (row ++ [value])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          gray = (gray ++ [row])
          i = i + 1
          while_fun.(while_fun, gray, i)
        else
          {gray, i}
        end
      end
      {gray, i} = try do
          while_fun.(while_fun, gray, i)
        catch
          {:break, {gray, i}} -> {gray, i}
        end

      throw {:return, gray}
    catch
      {:return, val} -> val
    end
  end
  def gray_to_binary(gray) do
    try do
      binary = []
      i = 0
      while_fun_3 = fn while_fun_3, binary, i ->
        if i < _len(gray) do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j < _len(Enum.at(gray, i)) do
              row = (row ++ [Enum.at(Enum.at(gray, i), j) > 127.0 && Enum.at(Enum.at(gray, i), j) <= 255.0])
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          binary = (binary ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, binary, i)
        else
          {binary, i}
        end
      end
      {binary, i} = try do
          while_fun_3.(while_fun_3, binary, i)
        catch
          {:break, {binary, i}} -> {binary, i}
        end

      throw {:return, binary}
    catch
      {:return, val} -> val
    end
  end
  def erosion(image, kernel) do
    try do
      h = _len(image)
      w = _len(Enum.at(image, 0))
      k_h = _len(kernel)
      k_w = _len(Enum.at(kernel, 0))
      pad_y = div(k_h, 2)
      pad_x = div(k_w, 2)
      padded = []
      y = 0
      while_fun_5 = fn while_fun_5, padded, y ->
        if y < h + 2 * pad_y do
          row = []
          x = 0
          while_fun_6 = fn while_fun_6, row, x ->
            if x < w + 2 * pad_x do
              row = (row ++ [false])
              x = x + 1
              while_fun_6.(while_fun_6, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_6.(while_fun_6, row, x)
            catch
              {:break, {row, x}} -> {row, x}
            end

          padded = (padded ++ [row])
          y = y + 1
          while_fun_5.(while_fun_5, padded, y)
        else
          {padded, y}
        end
      end
      {padded, y} = try do
          while_fun_5.(while_fun_5, padded, y)
        catch
          {:break, {padded, y}} -> {padded, y}
        end

      y = 0
      while_fun_7 = fn while_fun_7, padded, y ->
        if y < h do
          x = 0
          while_fun_8 = fn while_fun_8, padded, x ->
            if x < w do
              padded = List.replace_at(padded, pad_y + y, List.replace_at(Enum.at(padded, pad_y + y), pad_x + x, Enum.at(Enum.at(image, y), x)))
              x = x + 1
              while_fun_8.(while_fun_8, padded, x)
            else
              {padded, x}
            end
          end
          {padded, x} = try do
              while_fun_8.(while_fun_8, padded, x)
            catch
              {:break, {padded, x}} -> {padded, x}
            end

          y = y + 1
          while_fun_7.(while_fun_7, padded, y)
        else
          {padded, y}
        end
      end
      {padded, y} = try do
          while_fun_7.(while_fun_7, padded, y)
        catch
          {:break, {padded, y}} -> {padded, y}
        end

      output = []
      y = 0
      while_fun_9 = fn while_fun_9, output, y ->
        if y < h do
          row_out = []
          x = 0
          while_fun_10 = fn while_fun_10, row_out, x ->
            if x < w do
              sum = 0
              ky = 0
              while_fun_11 = fn while_fun_11, ky, sum ->
                if ky < k_h do
                  kx = 0
                  while_fun_12 = fn while_fun_12, kx, sum ->
                    if kx < k_w do
                      {sum} = if Enum.at(Enum.at(kernel, ky), kx) == 1 && Enum.at(Enum.at(padded, y + ky), x + kx) do
                        sum = sum + 1
                        {sum}
                      else
                        {sum}
                      end
                      kx = kx + 1
                      while_fun_12.(while_fun_12, kx, sum)
                    else
                      {kx, sum}
                    end
                  end
                  {kx, sum} = try do
                      while_fun_12.(while_fun_12, kx, sum)
                    catch
                      {:break, {kx, sum}} -> {kx, sum}
                    end

                  ky = ky + 1
                  while_fun_11.(while_fun_11, ky, sum)
                else
                  {ky, sum}
                end
              end
              {ky, sum} = try do
                  while_fun_11.(while_fun_11, ky, sum)
                catch
                  {:break, {ky, sum}} -> {ky, sum}
                end

              row_out = (row_out ++ [sum == 5])
              x = x + 1
              while_fun_10.(while_fun_10, row_out, x)
            else
              {row_out, x}
            end
          end
          {row_out, x} = try do
              while_fun_10.(while_fun_10, row_out, x)
            catch
              {:break, {row_out, x}} -> {row_out, x}
            end

          output = (output ++ [row_out])
          y = y + 1
          while_fun_9.(while_fun_9, output, y)
        else
          {output, y}
        end
      end
      {output, y} = try do
          while_fun_9.(while_fun_9, output, y)
        catch
          {:break, {output, y}} -> {output, y}
        end

      throw {:return, output}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:rgb_img, [[[127, 255, 0]]])
  Process.put(:gray_img, [[127.0, 255.0, 0.0]])
  Process.put(:img1, [[true, true, false]])
  Process.put(:kernel1, [[0, 1, 0]])
  Process.put(:img2, [[true, false, false]])
  Process.put(:kernel2, [[1, 1, 0]])
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    IO.puts(Kernel.inspect(rgb_to_gray(Process.get(:rgb_img))))
    IO.puts(Kernel.inspect(gray_to_binary(Process.get(:gray_img))))
    IO.puts(Kernel.inspect(erosion(Process.get(:img1), Process.get(:kernel1))))
    IO.puts(Kernel.inspect(erosion(Process.get(:img2), Process.get(:kernel2))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
