# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def rgb_to_gray(rgb) do
    try do
      result = []
      i = 0
      while_fun = fn while_fun, i, result ->
        if i < _len(rgb) do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < _len(Enum.at(rgb, i)) do
              r = Enum.at(Enum.at(Enum.at(rgb, i), j), 0)
              g = Enum.at(Enum.at(Enum.at(rgb, i), j), 1)
              b = Enum.at(Enum.at(Enum.at(rgb, i), j), 2)
              gray = 0.2989 * (1.0 * r) + 0.587 * (1.0 * g) + 0.114 * (1.0 * b)
              row = (row ++ [gray])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun.(while_fun, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun.(while_fun, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def gray_to_binary(gray) do
    try do
      result = []
      i = 0
      while_fun_3 = fn while_fun_3, i, result ->
        if i < _len(gray) do
          row = []
          j = 0
          while_fun_4 = fn while_fun_4, j, row ->
            if j < _len(Enum.at(gray, i)) do
              v = Enum.at(Enum.at(gray, i), j)
              row = (if v > 127.0 && v <= 255.0, do: (row ++ [1]), else: (row ++ [0]))
              j = j + 1
              while_fun_4.(while_fun_4, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_4.(while_fun_4, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          result = (result ++ [row])
          i = i + 1
          while_fun_3.(while_fun_3, i, result)
        else
          {i, result}
        end
      end
      {i, result} = try do
          while_fun_3.(while_fun_3, i, result)
        catch
          {:break, {i, result}} -> {i, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def dilation(image, kernel) do
    try do
      img_h = _len(image)
      img_w = _len(Enum.at(image, 0))
      k_h = _len(kernel)
      k_w = _len(Enum.at(kernel, 0))
      pad_h = div(k_h, 2)
      pad_w = div(k_w, 2)
      p_h = img_h + 2 * pad_h
      p_w = img_w + 2 * pad_w
      padded = []
      i = 0
      while_fun_5 = fn while_fun_5, i, padded ->
        if i < p_h do
          row = []
          j = 0
          while_fun_6 = fn while_fun_6, j, row ->
            if j < p_w do
              row = (row ++ [0])
              j = j + 1
              while_fun_6.(while_fun_6, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_6.(while_fun_6, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          padded = (padded ++ [row])
          i = i + 1
          while_fun_5.(while_fun_5, i, padded)
        else
          {i, padded}
        end
      end
      {i, padded} = try do
          while_fun_5.(while_fun_5, i, padded)
        catch
          {:break, {i, padded}} -> {i, padded}
        end

      i = 0
      while_fun_7 = fn while_fun_7, i, padded ->
        if i < img_h do
          j = 0
          while_fun_8 = fn while_fun_8, j, padded ->
            if j < img_w do
              padded = List.replace_at(padded, pad_h + i, List.replace_at(Enum.at(padded, pad_h + i), pad_w + j, Enum.at(Enum.at(image, i), j)))
              j = j + 1
              while_fun_8.(while_fun_8, j, padded)
            else
              {j, padded}
            end
          end
          {j, padded} = try do
              while_fun_8.(while_fun_8, j, padded)
            catch
              {:break, {j, padded}} -> {j, padded}
            end

          i = i + 1
          while_fun_7.(while_fun_7, i, padded)
        else
          {i, padded}
        end
      end
      {i, padded} = try do
          while_fun_7.(while_fun_7, i, padded)
        catch
          {:break, {i, padded}} -> {i, padded}
        end

      output = []
      i = 0
      while_fun_9 = fn while_fun_9, i, output ->
        if i < img_h do
          row = []
          j = 0
          while_fun_10 = fn while_fun_10, j, row ->
            if j < img_w do
              sum = 0
              ky = 0
              while_fun_11 = fn while_fun_11, ky, sum ->
                if ky < k_h do
                  kx = 0
                  while_fun_12 = fn while_fun_12, kx, sum ->
                    if kx < k_w do
                      {sum} = if Enum.at(Enum.at(kernel, ky), kx) == 1 do
                        sum = sum + Enum.at(Enum.at(padded, i + ky), j + kx)
                        {sum}
                      else
                        {sum}
                      end
                      kx = kx + 1
                      while_fun_12.(while_fun_12, kx, sum)
                    else
                      {kx, sum}
                    end
                  end
                  {kx, sum} = try do
                      while_fun_12.(while_fun_12, kx, sum)
                    catch
                      {:break, {kx, sum}} -> {kx, sum}
                    end

                  ky = ky + 1
                  while_fun_11.(while_fun_11, ky, sum)
                else
                  {ky, sum}
                end
              end
              {ky, sum} = try do
                  while_fun_11.(while_fun_11, ky, sum)
                catch
                  {:break, {ky, sum}} -> {ky, sum}
                end

              row = (if sum > 0, do: (row ++ [1]), else: (row ++ [0]))
              j = j + 1
              while_fun_10.(while_fun_10, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_10.(while_fun_10, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          output = (output ++ [row])
          i = i + 1
          while_fun_9.(while_fun_9, i, output)
        else
          {i, output}
        end
      end
      {i, output} = try do
          while_fun_9.(while_fun_9, i, output)
        catch
          {:break, {i, output}} -> {i, output}
        end

      throw {:return, output}
    catch
      {:return, val} -> val
    end
  end
  def print_float_matrix(mat) do
    try do
      i = 0
      while_fun_13 = fn while_fun_13, i ->
        if i < _len(mat) do
          line = ""
          j = 0
          while_fun_14 = fn while_fun_14, j, line ->
            if j < _len(Enum.at(mat, i)) do
              line = (line <> Kernel.to_string(Enum.at(Enum.at(mat, i), j)))
              {line} = if j < _len(Enum.at(mat, i)) - 1 do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              j = j + 1
              while_fun_14.(while_fun_14, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_14.(while_fun_14, j, line)
            catch
              {:break, {j, line}} -> {j, line}
            end

          IO.puts(line)
          i = i + 1
          while_fun_13.(while_fun_13, i)
        else
          i
        end
      end
      i = try do
          while_fun_13.(while_fun_13, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def print_int_matrix(mat) do
    try do
      i = 0
      while_fun_15 = fn while_fun_15, i ->
        if i < _len(mat) do
          line = ""
          j = 0
          while_fun_16 = fn while_fun_16, j, line ->
            if j < _len(Enum.at(mat, i)) do
              line = (line <> Kernel.to_string(Enum.at(Enum.at(mat, i), j)))
              {line} = if j < _len(Enum.at(mat, i)) - 1 do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              j = j + 1
              while_fun_16.(while_fun_16, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_16.(while_fun_16, j, line)
            catch
              {:break, {j, line}} -> {j, line}
            end

          IO.puts(line)
          i = i + 1
          while_fun_15.(while_fun_15, i)
        else
          i
        end
      end
      i = try do
          while_fun_15.(while_fun_15, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      rgb_example = [[[127, 255, 0]]]
      print_float_matrix(rgb_to_gray(rgb_example))
      gray_example = [[26.0, 255.0, 14.0], [5.0, 147.0, 20.0], [1.0, 200.0, 0.0]]
      print_int_matrix(gray_to_binary(gray_example))
      binary_image = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
      kernel = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
      print_int_matrix(dilation(binary_image, kernel))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
