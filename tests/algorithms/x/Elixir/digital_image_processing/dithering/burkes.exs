# Code generated by Mochi transpiler 2025-08-08 11:07 +0700
defmodule Main do
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def get_greyscale(blue, green, red) do
    try do
      b = :erlang.float(blue)
      g = :erlang.float(green)
      r = :erlang.float(red)
      throw {:return, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((0.114 * b + 0.587 * g + 0.299 * r))}
    catch
      {:return, val} -> val
    end
  end
  def zeros(h, w) do
    try do
      table = []
      i = 0
      while_fun = fn while_fun, i, table ->
        if i < h do
          row = []
          j = 0
          while_fun_2 = fn while_fun_2, j, row ->
            if j < w do
              row = (row ++ [0])
              j = j + 1
              while_fun_2.(while_fun_2, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_2.(while_fun_2, j, row)
            catch
              {:break, {j, row}} -> {j, row}
            end

          table = (table ++ [row])
          i = i + 1
          while_fun.(while_fun, i, table)
        else
          {i, table}
        end
      end
      {i, table} = try do
          while_fun.(while_fun, i, table)
        catch
          {:break, {i, table}} -> {i, table}
        end

      throw {:return, table}
    catch
      {:return, val} -> val
    end
  end
  def burkes_dither(img, threshold) do
    try do
      height = _len(img)
      width = _len(Enum.at(img, 0))
      error_table = zeros(height + 1, width + 4)
      output = []
      y = 0
      while_fun_3 = fn while_fun_3, error_table, output, y ->
        if y < height do
          row = []
          x = 0
          while_fun_4 = fn while_fun_4, error_table, row, x ->
            if x < width do
              px = Enum.at(Enum.at(img, y), x)
              grey = get_greyscale(Enum.at(px, 0), Enum.at(px, 1), Enum.at(px, 2))
              total = grey + Enum.at(Enum.at(error_table, y), x + 2)
              new_val = 0
              current_error = 0
              {current_error, new_val} = if threshold > total do
                new_val = 0
                current_error = total
                {current_error, new_val}
              else
                new_val = 255
                current_error = total - 255
                {current_error, new_val}
              end
              row = (row ++ [new_val])
              error_table = List.replace_at(error_table, y, List.replace_at(Enum.at(error_table, y), x + 3, Enum.at(Enum.at(error_table, y), x + 3) + div((8 * current_error), 32)))
              error_table = List.replace_at(error_table, y, List.replace_at(Enum.at(error_table, y), x + 4, Enum.at(Enum.at(error_table, y), x + 4) + div((4 * current_error), 32)))
              error_table = List.replace_at(error_table, y + 1, List.replace_at(Enum.at(error_table, y + 1), x + 2, Enum.at(Enum.at(error_table, y + 1), x + 2) + div((8 * current_error), 32)))
              error_table = List.replace_at(error_table, y + 1, List.replace_at(Enum.at(error_table, y + 1), x + 3, Enum.at(Enum.at(error_table, y + 1), x + 3) + div((4 * current_error), 32)))
              error_table = List.replace_at(error_table, y + 1, List.replace_at(Enum.at(error_table, y + 1), x + 4, Enum.at(Enum.at(error_table, y + 1), x + 4) + div((2 * current_error), 32)))
              error_table = List.replace_at(error_table, y + 1, List.replace_at(Enum.at(error_table, y + 1), x + 1, Enum.at(Enum.at(error_table, y + 1), x + 1) + div((4 * current_error), 32)))
              error_table = List.replace_at(error_table, y + 1, List.replace_at(Enum.at(error_table, y + 1), x, Enum.at(Enum.at(error_table, y + 1), x) + div((2 * current_error), 32)))
              x = x + 1
              while_fun_4.(while_fun_4, error_table, row, x)
            else
              {error_table, row, x}
            end
          end
          {error_table, row, x} = try do
              while_fun_4.(while_fun_4, error_table, row, x)
            catch
              {:break, {error_table, row, x}} -> {error_table, row, x}
            end

          output = (output ++ [row])
          y = y + 1
          while_fun_3.(while_fun_3, error_table, output, y)
        else
          {error_table, output, y}
        end
      end
      {error_table, output, y} = try do
          while_fun_3.(while_fun_3, error_table, output, y)
        catch
          {:break, {error_table, output, y}} -> {error_table, output, y}
        end

      throw {:return, output}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      img = [[[0, 0, 0], [64, 64, 64], [128, 128, 128], [192, 192, 192]], [[255, 255, 255], [200, 200, 200], [150, 150, 150], [100, 100, 100]], [[30, 144, 255], [255, 0, 0], [0, 255, 0], [0, 0, 255]], [[50, 100, 150], [80, 160, 240], [70, 140, 210], [60, 120, 180]]]
      result = burkes_dither(img, 128)
      y = 0
      while_fun_5 = fn while_fun_5, y ->
        if y < _len(result) do
          line = ""
          x = 0
          while_fun_6 = fn while_fun_6, line, x ->
            if x < _len(Enum.at(result, y)) do
              line = (line <> Kernel.to_string(Enum.at(Enum.at(result, y), x)))
              {line} = if x < _len(Enum.at(result, y)) - 1 do
                line = (line <> " ")
                {line}
              else
                {line}
              end
              x = x + 1
              while_fun_6.(while_fun_6, line, x)
            else
              {line, x}
            end
          end
          {line, x} = try do
              while_fun_6.(while_fun_6, line, x)
            catch
              {:break, {line, x}} -> {line, x}
            end

          IO.puts(line)
          y = y + 1
          while_fun_5.(while_fun_5, y)
        else
          y
        end
      end
      y = try do
          while_fun_5.(while_fun_5, y)
        catch
          {:break, {y}} -> y
        end

    catch
      {:return, val} -> val
    end
  end
end
Main.main()
