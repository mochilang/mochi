# Code generated by Mochi transpiler 2025-08-14 10:36 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  def round_int(x) do
    try do
      throw {:return, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((x + 0.5))}
    catch
      {:return, val} -> val
    end
  end
  def hsv_to_rgb(h, s, v) do
    try do
      i = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((h * 6.0))
      f = h * 6.0 - (:erlang.float(i))
      p = v * (1.0 - s)
      q = v * (1.0 - f * s)
      t = v * (1.0 - (1.0 - f) * s)
      mod = rem(i, 6)
      r = 0.0
      g = 0.0
      b = 0.0
      {b, g, r} = if mod == 0 do
        r = v
        g = t
        b = p
        {b, g, r}
      else
        {b, g, r} = if mod == 1 do
          r = q
          g = v
          b = p
          {b, g, r}
        else
          {b, g, r} = if mod == 2 do
            r = p
            g = v
            b = t
            {b, g, r}
          else
            {b, g, r} = if mod == 3 do
              r = p
              g = q
              b = v
              {b, g, r}
            else
              {b, g, r} = if mod == 4 do
                r = t
                g = p
                b = v
                {b, g, r}
              else
                r = v
                g = p
                b = q
                {b, g, r}
              end
              {b, g, r}
            end
            {b, g, r}
          end
          {b, g, r}
        end
        {b, g, r}
      end
      throw {:return, %{r: round_int(r * 255.0), g: round_int(g * 255.0), b: round_int(b * 255.0)}}
    catch
      {:return, val} -> val
    end
  end
  def get_distance(x, y, max_step) do
    try do
      a = x
      b = y
      step = -1
      while_fun = fn while_fun, a, b, step ->
        if step < max_step - 1 do
          step = step + 1
          a_new = a * a - b * b + x
          b = 2.0 * a * b + y
          a = a_new
          if a * a + b * b > 4.0 do
            throw {:break, {a, b, step}}
          end
          while_fun.(while_fun, a, b, step)
        else
          {a, b, step}
        end
      end
      {a, b, step} = try do
          while_fun.(while_fun, a, b, step)
        catch
          {:break, {a, b, step}} -> {a, b, step}
        end

      throw {:return, (:erlang.float(step)) / (:erlang.float((max_step - 1)))}
    catch
      {:return, val} -> val
    end
  end
  def get_black_and_white_rgb(distance) do
    try do
      if distance == 1.0 do
        throw {:return, %{r: 0, g: 0, b: 0}}
      else
        throw {:return, %{r: 255, g: 255, b: 255}}
      end
    catch
      {:return, val} -> val
    end
  end
  def get_color_coded_rgb(distance) do
    try do
      if distance == 1.0 do
        throw {:return, %{r: 0, g: 0, b: 0}}
      else
        throw {:return, hsv_to_rgb(distance, 1.0, 1.0)}
      end
    catch
      {:return, val} -> val
    end
  end
  def get_image(image_width, image_height, figure_center_x, figure_center_y, figure_width, max_step, use_distance_color_coding) do
    try do
      img = []
      figure_height = figure_width / (:erlang.float(image_width)) * (:erlang.float(image_height))
      image_y = 0
      while_fun_2 = fn while_fun_2, image_y, img ->
        if image_y < image_height do
          row = []
          image_x = 0
          while_fun_3 = fn while_fun_3, image_x, row ->
            if image_x < image_width do
              fx = figure_center_x + ((:erlang.float(image_x)) / (:erlang.float(image_width)) - 0.5) * figure_width
              fy = figure_center_y + ((:erlang.float(image_y)) / (:erlang.float(image_height)) - 0.5) * figure_height
              distance = get_distance(fx, fy, max_step)
              rgb = nil
              rgb = (if use_distance_color_coding, do: get_color_coded_rgb(distance), else: get_black_and_white_rgb(distance))
              row = (row ++ [rgb])
              image_x = image_x + 1
              while_fun_3.(while_fun_3, image_x, row)
            else
              {image_x, row}
            end
          end
          {image_x, row} = try do
              while_fun_3.(while_fun_3, image_x, row)
            catch
              {:break, {image_x, row}} -> {image_x, row}
            end

          img = (img ++ [row])
          image_y = image_y + 1
          while_fun_2.(while_fun_2, image_y, img)
        else
          {image_y, img}
        end
      end
      {image_y, img} = try do
          while_fun_2.(while_fun_2, image_y, img)
        catch
          {:break, {image_y, img}} -> {image_y, img}
        end

      throw {:return, img}
    catch
      {:return, val} -> val
    end
  end
  def rgb_to_string(c) do
    try do
      throw {:return, (((((("(" <> Kernel.to_string(c.r)) <> ", ") <> Kernel.to_string(c.g)) <> ", ") <> Kernel.to_string(c.b)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:img1, get_image(10, 10, -0.6, 0.0, 3.2, 50, true))
    IO.puts(Kernel.inspect(rgb_to_string(Enum.at(Enum.at(Process.get(:img1), 0, []), 0, 0))))
    Process.put(:img2, get_image(10, 10, -0.6, 0.0, 3.2, 50, false))
    IO.puts(Kernel.inspect(rgb_to_string(Enum.at(Enum.at(Process.get(:img2), 0, []), 0, 0))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
