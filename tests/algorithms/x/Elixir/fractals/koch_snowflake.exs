# Code generated by Mochi transpiler 2025-08-08 16:28 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def _mod(x, m) do
    try do
      throw {:return, x - (:erlang.float(Kernel.trunc(x / m))) * m}
    catch
      {:return, val} -> val
    end
  end
  def sin(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y3 = y2 * y
      y5 = y3 * y2
      y7 = y5 * y2
      throw {:return, y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0}
    catch
      {:return, val} -> val
    end
  end
  def cos(x) do
    try do
      y = _mod(x + Process.get(:pi), Process.get(:two_pi)) - Process.get(:pi)
      y2 = y * y
      y4 = y2 * y2
      y6 = y4 * y2
      throw {:return, 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0}
    catch
      {:return, val} -> val
    end
  end
  def rotate(v, angle_deg) do
    try do
      theta = angle_deg * Process.get(:pi) / 180.0
      c = cos(theta)
      s = sin(theta)
      throw {:return, %{x: v.x * c - v.y * s, y: v.x * s + v.y * c}}
    catch
      {:return, val} -> val
    end
  end
  def iteration_step(vectors) do
    try do
      new_vectors = []
      i = 0
      while_fun = fn while_fun, i, new_vectors ->
        if i < _len(vectors) - 1 do
          start = Enum.at(vectors, i)
          end_ = Enum.at(vectors, i + 1)
          new_vectors = (new_vectors ++ [start])
          dx = end_.x - start.x
          dy = end_.y - start.y
          one_third = %{x: start.x + dx / 3.0, y: start.y + dy / 3.0}
          mid = rotate(%{x: dx / 3.0, y: dy / 3.0}, 60.0)
          peak = %{x: one_third.x + mid.x, y: one_third.y + mid.y}
          two_third = %{x: start.x + dx * 2.0 / 3.0, y: start.y + dy * 2.0 / 3.0}
          new_vectors = (new_vectors ++ [one_third])
          new_vectors = (new_vectors ++ [peak])
          new_vectors = (new_vectors ++ [two_third])
          i = i + 1
          while_fun.(while_fun, i, new_vectors)
        else
          {i, new_vectors}
        end
      end
      {i, new_vectors} = try do
          while_fun.(while_fun, i, new_vectors)
        catch
          {:break, {i, new_vectors}} -> {i, new_vectors}
        end

      new_vectors = (new_vectors ++ [Enum.at(vectors, _len(vectors) - 1)])
      throw {:return, new_vectors}
    catch
      {:return, val} -> val
    end
  end
  def iterate(initial, steps) do
    try do
      vectors = initial
      i = 0
      while_fun_2 = fn while_fun_2, i, vectors ->
        if i < steps do
          vectors = iteration_step(vectors)
          i = i + 1
          while_fun_2.(while_fun_2, i, vectors)
        else
          {i, vectors}
        end
      end
      {i, vectors} = try do
          while_fun_2.(while_fun_2, i, vectors)
        catch
          {:break, {i, vectors}} -> {i, vectors}
        end

      throw {:return, vectors}
    catch
      {:return, val} -> val
    end
  end
  def vec_to_string(v) do
    try do
      throw {:return, (((("(" <> Kernel.to_string(v.x)) <> ", ") <> Kernel.to_string(v.y)) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def vec_list_to_string(lst) do
    try do
      res = "["
      i = 0
      while_fun_3 = fn while_fun_3, i, res ->
        if i < _len(lst) do
          res = (res <> vec_to_string(Enum.at(lst, i)))
          {res} = if i < _len(lst) - 1 do
            res = (res <> ", ")
            {res}
          else
            {res}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_3.(while_fun_3, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      res = (res <> "]")
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:two_pi, 6.283185307179586)
  Process.put(:vector_1, %{x: 0.0, y: 0.0})
  Process.put(:vector_2, %{x: 0.5, y: 0.8660254})
  Process.put(:vector_3, %{x: 1.0, y: 0.0})
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:initial_vectors, [Process.get(:vector_1), Process.get(:vector_2), Process.get(:vector_3), Process.get(:vector_1)])
    Process.put(:example, iterate([Process.get(:vector_1), Process.get(:vector_3)], 1))
    IO.puts(Kernel.inspect(vec_list_to_string(Process.get(:example))))
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
