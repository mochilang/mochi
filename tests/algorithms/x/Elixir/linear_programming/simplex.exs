# Code generated by Mochi transpiler 2025-08-12 08:38 +0700
defmodule Main do
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  def pivot(t, row, col) do
    try do
      pivotRow = []
      pivotVal = Enum.at(Enum.at(t, row, []), col, 0)
      {pivotRow} = Enum.reduce((0..(_len(Enum.at(t, row, [])) - 1)//1), {pivotRow}, fn j, {pivotRow} ->
        pivotRow = (pivotRow ++ [Enum.at(Enum.at(t, row, []), j, 0) / pivotVal])
        {pivotRow}
      end)
      t = List.replace_at(t, row, pivotRow)
      {t} = Enum.reduce((0..(_len(t) - 1)//1), {t}, fn i, {t} ->
        {t} = if i != row do
          factor = Enum.at(Enum.at(t, i, []), col, 0)
          newRow = []
          {newRow} = Enum.reduce((0..(_len(Enum.at(t, i, [])) - 1)//1), {newRow}, fn j, {newRow} ->
            value = Enum.at(Enum.at(t, i, []), j, 0) - factor * Enum.at(pivotRow, j, [])
            newRow = (newRow ++ [value])
            {newRow}
          end)
          t = List.replace_at(t, i, newRow)
          {t}
        else
          {t}
        end
        {t}
      end)
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def findPivot(t) do
    try do
      col = 0
      minVal = 0.0
      {col, minVal} = Enum.reduce((0..(_len(Enum.at(t, 0, [])) - 1 - 1)//1), {col, minVal}, fn j, {col, minVal} ->
        v = Enum.at(Enum.at(t, 0, []), j, 0)
        {col, minVal} = if v < minVal do
          minVal = v
          col = j
          {col, minVal}
        else
          {col, minVal}
        end
        {col, minVal}
      end)
      if minVal >= 0.0 do
        throw {:return, [-1, -1]}
      end
      row = -1
      minRatio = 0.0
      first = true
      {first, minRatio, row} = Enum.reduce((1..(_len(t) - 1)//1), {first, minRatio, row}, fn i, {first, minRatio, row} ->
        coeff = Enum.at(Enum.at(t, i, []), col, 0)
        {first, minRatio, row} = if coeff > 0.0 do
          rhs = Enum.at(Enum.at(t, i, []), _len(Enum.at(t, i, [])) - 1, 0)
          ratio = rhs / coeff
          {first, minRatio, row} = if first || ratio < minRatio do
            minRatio = ratio
            row = i
            first = false
            {first, minRatio, row}
          else
            {first, minRatio, row}
          end
          {first, minRatio, row}
        else
          {first, minRatio, row}
        end
        {first, minRatio, row}
      end)
      throw {:return, [row, col]}
    catch
      {:return, val} -> val
    end
  end
  def interpret(t, nVars) do
    try do
      lastCol = _len(Enum.at(t, 0, [])) - 1
      p = Enum.at(Enum.at(t, 0, []), lastCol, 0)
      {p} = if p < 0.0 do
        p = -p
        {p}
      else
        {p}
      end
      result = %{}
      result = Map.put(result, "P", p)
      {result} = Enum.reduce((0..(nVars - 1)//1), {result}, fn i, {result} ->
        nzRow = -1
        nzCount = 0
        {nzCount, nzRow} = Enum.reduce((0..(_len(t) - 1)//1), {nzCount, nzRow}, fn r, {nzCount, nzRow} ->
          val = Enum.at(Enum.at(t, r, []), i, 0)
          {nzCount, nzRow} = if val != 0.0 do
            nzCount = nzCount + 1
            nzRow = r
            {nzCount, nzRow}
          else
            {nzCount, nzRow}
          end
          {nzCount, nzRow}
        end)
        {result} = if nzCount == 1 && Enum.at(Enum.at(t, nzRow, []), i, 0) == 1.0 do
          result = Map.put(result, ("x" <> Kernel.to_string(i + 1)), Enum.at(Enum.at(t, nzRow, []), lastCol, 0))
          {result}
        else
          {result}
        end
        {result}
      end)
      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def simplex(tab) do
    try do
      t = tab
      while_fun = fn while_fun, t ->
        if true do
          p = findPivot(t)
          row = Enum.at(p, 0, [])
          col = Enum.at(p, 1, [])
          if row < 0 do
            throw {:break, {t}}
          end
          t = pivot(t, row, col)
          while_fun.(while_fun, t)
        else
          t
        end
      end
      t = try do
          while_fun.(while_fun, t)
        catch
          {:break, {t}} -> t
        end

      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    Process.put(:tableau, [[-1.0, -1.0, 0.0, 0.0, 0.0], [1.0, 3.0, 1.0, 0.0, 4.0], [3.0, 1.0, 0.0, 1.0, 4.0]])
    Process.put(:finalTab, simplex(Process.get(:tableau)))
    Process.put(:res, interpret(Process.get(:finalTab), 2))
    IO.puts(("P: " <> Kernel.to_string(Process.get(:res)["P"])))
    Enum.each((0..(2 - 1)), fn i ->
      key = ("x" <> Kernel.to_string(i + 1))
      if Map.has_key?(Process.get(:res), key) do
        IO.puts(((key <> ": ") <> Kernel.to_string(Process.get(:res)[key])))
      end
    end)
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
