-- Generated by Mochi v0.10.64 on 2025-08-12 13:49 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _str(v)
if type(v) == 'number' then
  local s = tostring(v)
  s = string.gsub(s, '%.0+$', '')
  return s
end
return tostring(v)
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = os.clock()
  function make_matrix(rows, cols, value)
    local arr = {}
    local r = 0
    while (r < rows) do
      local row = {}
      local c = 0
      while (c < cols) do
        row = (function(lst, item)
        lst = lst or {}
        table.insert(lst, item)
        return lst
      end)(row, value)
      c = (c + 1)
    end
    arr = (function(lst, item)
    lst = lst or {}
    table.insert(lst, item)
    return lst
  end)(arr, row)
  r = (r + 1)
end
return {data = arr, rows = rows, cols = cols}
end
function matrix_from_lists(vals)
  local r = (function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' then
        local l = utf8.len(v)
        if l then return l end
        return #v
      elseif type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(vals)
      local c = (((r == 0)) and (0) or ((function(v)
      if type(v) == 'table' and v.items ~= nil then
        return #v.items
      elseif type(v) == 'table' and (v[1] == nil) then
          local c = 0
          for _ in pairs(v) do c = c + 1 end
          return c
        elseif type(v) == 'string' then
            local l = utf8.len(v)
            if l then return l end
            return #v
          elseif type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(vals[0 + 1])))
          return {data = vals, rows = r, cols = c}
        end
        function matrix_to_string(m)
          local s = ""
          local i = 0
          while (i < m.rows) do
            s = (s .. "[")
            local j = 0
            while (j < m.cols) do
              s = (s .. _str(m.data[i + 1][j + 1]))
              if (j < (m.cols - 1)) then
                s = (s .. ", ")
              end
              j = (j + 1)
            end
            s = (s .. "]")
            if (i < (m.rows - 1)) then
              s = (s .. "\n")
            end
            i = (i + 1)
          end
          return s
        end
        function matrix_add(a, b)
          if ((a.rows ~= b.rows) or (a.cols ~= b.cols)) then
            return {data = {}, rows = 0, cols = 0}
          end
          local res = {}
          local i = 0
          while (i < a.rows) do
            local row = {}
            local j = 0
            while (j < a.cols) do
              row = (function(lst, item)
              lst = lst or {}
              table.insert(lst, item)
              return lst
            end)(row, (a.data[i + 1][j + 1] + b.data[i + 1][j + 1]))
            j = (j + 1)
          end
          res = (function(lst, item)
          lst = lst or {}
          table.insert(lst, item)
          return lst
        end)(res, row)
        i = (i + 1)
      end
      return {data = res, rows = a.rows, cols = a.cols}
    end
    function matrix_sub(a, b)
      if ((a.rows ~= b.rows) or (a.cols ~= b.cols)) then
        return {data = {}, rows = 0, cols = 0}
      end
      local res = {}
      local i = 0
      while (i < a.rows) do
        local row = {}
        local j = 0
        while (j < a.cols) do
          row = (function(lst, item)
          lst = lst or {}
          table.insert(lst, item)
          return lst
        end)(row, (a.data[i + 1][j + 1] - b.data[i + 1][j + 1]))
        j = (j + 1)
      end
      res = (function(lst, item)
      lst = lst or {}
      table.insert(lst, item)
      return lst
    end)(res, row)
    i = (i + 1)
  end
  return {data = res, rows = a.rows, cols = a.cols}
end
function matrix_mul_scalar(m, k)
  local res = {}
  local i = 0
  while (i < m.rows) do
    local row = {}
    local j = 0
    while (j < m.cols) do
      row = (function(lst, item)
      lst = lst or {}
      table.insert(lst, item)
      return lst
    end)(row, (m.data[i + 1][j + 1] * k))
    j = (j + 1)
  end
  res = (function(lst, item)
  lst = lst or {}
  table.insert(lst, item)
  return lst
end)(res, row)
i = (i + 1)
end
return {data = res, rows = m.rows, cols = m.cols}
end
function matrix_mul(a, b)
  if (a.cols ~= b.rows) then
    return {data = {}, rows = 0, cols = 0}
  end
  local res = {}
  local i = 0
  while (i < a.rows) do
    local row = {}
    local j = 0
    while (j < b.cols) do
      local sum = 0
      local k = 0
      while (k < a.cols) do
        sum = (sum + (a.data[i + 1][k + 1] * b.data[k + 1][j + 1]))
        k = (k + 1)
      end
      row = (function(lst, item)
      lst = lst or {}
      table.insert(lst, item)
      return lst
    end)(row, sum)
    j = (j + 1)
  end
  res = (function(lst, item)
  lst = lst or {}
  table.insert(lst, item)
  return lst
end)(res, row)
i = (i + 1)
end
return {data = res, rows = a.rows, cols = b.cols}
end
function matrix_transpose(m)
  local res = {}
  local c = 0
  while (c < m.cols) do
    local row = {}
    local r = 0
    while (r < m.rows) do
      row = (function(lst, item)
      lst = lst or {}
      table.insert(lst, item)
      return lst
    end)(row, m.data[r + 1][c + 1])
    r = (r + 1)
  end
  res = (function(lst, item)
  lst = lst or {}
  table.insert(lst, item)
  return lst
end)(res, row)
c = (c + 1)
end
return {data = res, rows = m.cols, cols = m.rows}
end
function sherman_morrison(ainv, u, v)
  local vt = matrix_transpose(v)
  local vu = matrix_mul(matrix_mul(vt, ainv), u)
  local factor = (vu.data[0 + 1][0 + 1] + 1)
  if (factor == 0) then
    return {data = {}, rows = 0, cols = 0}
  end
  local term1 = matrix_mul(ainv, u)
  local term2 = matrix_mul(vt, ainv)
  local numerator = matrix_mul(term1, term2)
  local scaled = matrix_mul_scalar(numerator, (1 / factor))
  return matrix_sub(ainv, scaled)
end
function main()
  local ainv = matrix_from_lists({{1, 0, 0}, {0, 1, 0}, {0, 0, 1}})
  local u = matrix_from_lists({{1}, {2}, {(-3)}})
  local v = matrix_from_lists({{4}, {(-2)}, {5}})
  local result = sherman_morrison(ainv, u, v)
  print((((type(matrix_to_string(result)) == "table")) and (
  (function(v)
  local function encode(x)
  if type(x) == "table" then
    if x.__name and x.__order then
      local parts = {x.__name, " {"}
      for i, k in ipairs(x.__order) do
        if i > 1 then parts[#parts+1] = ", " end
        parts[#parts+1] = k .. " = " .. encode(x[k])
      end
      parts[#parts+1] = "}"
      return table.concat(parts)
    elseif #x > 0 then
        local allTables = true
        for _, v in ipairs(x) do
          if type(v) ~= "table" then allTables = false break end
        end
        local parts = {}
        if not allTables then parts[#parts+1] = "[" end
        for i, val in ipairs(x) do
          parts[#parts+1] = encode(val)
          if i < #x then parts[#parts+1] = " " end
        end
        if not allTables then parts[#parts+1] = "]" end
        return table.concat(parts)
      else
        local keys = {}
        for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
        table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
        local parts = {"{"}
        for i, k in ipairs(keys) do
          parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
          if i < #keys then parts[#parts+1] = ", " end
        end
        parts[#parts+1] = "}"
        return table.concat(parts)
      end
    elseif type(x) == "string" then
        return '"' .. x .. '"'
      else
        return tostring(x)
      end
    end
    return encode(v)
  end)(matrix_to_string(result))) or (matrix_to_string(result))))
end
main()
local _bench_end = os.clock()
collectgarbage()
local _bench_end_mem = collectgarbage('count') * 1024
local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
