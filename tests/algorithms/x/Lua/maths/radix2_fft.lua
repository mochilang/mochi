-- Generated by Mochi v0.10.67 on 2025-08-17 13:22 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _len(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' then
      local l = utf8.len(v)
      if l then return l end
      return #v
    elseif type(v) == 'table' then
        return #v
      else
        return 0
      end
    end
    
    local function _str(v)
    if type(v) == 'number' then
      local s = tostring(v)
      s = string.gsub(s, '%.0+$', '')
      return s
    elseif type(v) == 'table' then
        local parts = {}
        for i = 1, #v do
          parts[#parts+1] = _str(v[i])
        end
        return '[' .. table.concat(parts, ', ') .. ']'
      end
      return tostring(v)
    end
    
    local function slice(lst, s, e)
    local len = #lst
    if s < 0 then s = len + s end
    if s < 0 then s = 0 end
    if e == nil then
      e = len
    elseif e < 0 then
        e = len + e
      end
      if e > len then e = len end
      if s > e then return {} end
      local r = {}
      for i = s + 1, e do
        r[#r+1] = lst[i]
      end
      return r
    end
    do
      collectgarbage()
      local _bench_start_mem = collectgarbage('count') * 1024
      local _bench_start = os.clock()
      function c_add(a, b)
        return {re = (a.re + b.re), im = (a.im + b.im)}
      end
      function c_sub(a, b)
        return {re = (a.re - b.re), im = (a.im - b.im)}
      end
      function c_mul(a, b)
        return {re = ((a.re * b.re) - (a.im * b.im)), im = ((a.re * b.im) + (a.im * b.re))}
      end
      function c_mul_scalar(a, s)
        return {re = (a.re * s), im = (a.im * s)}
      end
      function c_div_scalar(a, s)
        return {re = (a.re / s), im = (a.im / s)}
      end
      function sin_taylor(x)
        local term = x
        local sum = x
        local i = 1
        while (i < 10) do
          local k1 = (2.0 * i)
          local k2 = (k1 + 1.0)
          term = ((((-term) * x) * x) / (k1 * k2))
          sum = (sum + term)
          i = (i + 1)
        end
        return sum
      end
      function cos_taylor(x)
        local term = 1.0
        local sum = 1.0
        local i = 1
        while (i < 10) do
          local k1 = ((2.0 * i) - 1.0)
          local k2 = (2.0 * i)
          term = ((((-term) * x) * x) / (k1 * k2))
          sum = (sum + term)
          i = (i + 1)
        end
        return sum
      end
      function exp_i(theta)
        return {re = cos_taylor(theta), im = sin_taylor(theta)}
      end
      function make_complex_list(n, value)
        local arr = {}
        local i = 0
        while (i < n) do
          arr = (function(lst, item)
          local res = {table.unpack(lst or {})}
          res[#res+1] = item
          return res
        end)(arr, value)
        i = (i + 1)
      end
      return arr
    end
    function fft(a, invert)
      local n = _len(a)
      if (n == 1) then
        return {a[0 + 1]}
      end
      local a0 = {}
      local a1 = {}
      local i = 0
      while (i < (n // 2)) do
        a0 = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(a0, a[(2 * i) + 1])
      a1 = (function(lst, item)
      local res = {table.unpack(lst or {})}
      res[#res+1] = item
      return res
    end)(a1, a[((2 * i) + 1) + 1])
    i = (i + 1)
  end
  local y0 = fft(a0, invert)
  local y1 = fft(a1, invert)
  local angle = (((2.0 * PI) / n) * ((invert) and ((-1.0)) or (1.0)))
  local w = {re = 1.0, im = 0.0}
  local wn = exp_i(angle)
  local y = make_complex_list(n, {re = 0.0, im = 0.0})
  i = 0
  while (i < (n // 2)) do
    local t = c_mul(w, y1[i + 1])
    local u = y0[i + 1]
    local even = c_add(u, t)
    local odd = c_sub(u, t)
    if invert then
      even = c_div_scalar(even, 2.0)
      odd = c_div_scalar(odd, 2.0)
    end
    y[i + 1] = even
    y[(i + (n // 2)) + 1] = odd
    w = c_mul(w, wn)
    i = (i + 1)
  end
  return y
end
function floor(x)
  local i = (function(v) if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((tonumber(x) or 0))
  if (i > x) then
    i = (i - 1)
  end
  return i
end
function pow10(n)
  local p = 1.0
  local i = 0
  while (i < n) do
    p = (p * 10.0)
    i = (i + 1)
  end
  return p
end
function round_to(x, ndigits)
  local m = pow10(ndigits)
  return (floor(((x * m) + 0.5)) / m)
end
function list_to_string(l)
  local s = "["
  local i = 0
  while (i < _len(l)) do
    s = (s .. _str(l[i + 1]))
    if ((i + 1) < _len(l)) then
      s = (s .. ", ")
    end
    i = (i + 1)
  end
  s = (s .. "]")
  return s
end
function multiply_poly(a, b)
  local n = 1
  while (n < ((_len(a) + _len(b)) - 1)) do
    n = (n * 2)
  end
  local fa = make_complex_list(n, {re = 0.0, im = 0.0})
  local fb = make_complex_list(n, {re = 0.0, im = 0.0})
  local i = 0
  while (i < _len(a)) do
    fa[i + 1] = {re = a[i + 1], im = 0.0}
    i = (i + 1)
  end
  i = 0
  while (i < _len(b)) do
    fb[i + 1] = {re = b[i + 1], im = 0.0}
    i = (i + 1)
  end
  fa = fft(fa, false)
  fb = fft(fb, false)
  i = 0
  while (i < n) do
    fa[i + 1] = c_mul(fa[i + 1], fb[i + 1])
    i = (i + 1)
  end
  fa = fft(fa, true)
  local res = {}
  i = 0
  while (i < ((_len(a) + _len(b)) - 1)) do
    local val = fa[i + 1]
    res = (function(lst, item)
    local res = {table.unpack(lst or {})}
    res[#res+1] = item
    return res
  end)(res, round_to(val.re, 8))
  i = (i + 1)
end
while ((_len(res) > 0) and (res[(_len(res) - 1) + 1] == 0.0)) do
  res = (function(lst,s,e)
  local r={}
  for i=s+1,e do
    r[#r+1]=lst[i]
  end
  return r
end)(res, 0, (_len(res) - 1))
end
return res
end
PI = 3.141592653589793
A = {0.0, 1.0, 0.0, 2.0}
B = {2.0, 3.0, 4.0, 0.0}
product = multiply_poly(A, B)
print((((type(list_to_string(product)) == "table")) and (
(function(v)
local function encode(x)
if type(x) == "table" then
  if x.__name and x.__order then
    local parts = {x.__name, " {"}
    for i, k in ipairs(x.__order) do
      if i > 1 then parts[#parts+1] = ", " end
      parts[#parts+1] = k .. " = " .. encode(x[k])
    end
    parts[#parts+1] = "}"
    return table.concat(parts)
  elseif #x > 0 then
      local allTables = true
      for _, v in ipairs(x) do
        if type(v) ~= "table" then allTables = false break end
      end
      local parts = {}
      if not allTables then parts[#parts+1] = "[" end
      for i, val in ipairs(x) do
        parts[#parts+1] = encode(val)
        if i < #x then parts[#parts+1] = " " end
      end
      if not allTables then parts[#parts+1] = "]" end
      return table.concat(parts)
    else
      local keys = {}
      for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
      table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
      local parts = {"{"}
      for i, k in ipairs(keys) do
        parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
        if i < #keys then parts[#parts+1] = ", " end
      end
      parts[#parts+1] = "}"
      return table.concat(parts)
    end
  elseif type(x) == "number" then
      if (math.type and math.type(x) == "integer") or x % 1 == 0 then
        return string.format("%d", x)
      else
        return tostring(x)
      end
    elseif type(x) == "string" then
        return '"' .. x .. '"'
      else
        return tostring(x)
      end
    end
    return encode(v)
  end)(list_to_string(product))) or (list_to_string(product))))
  local _bench_end = os.clock()
  collectgarbage()
  local _bench_end_mem = collectgarbage('count') * 1024
  local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
  local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
  print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
