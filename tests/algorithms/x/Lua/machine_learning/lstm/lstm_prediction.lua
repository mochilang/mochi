-- Generated by Mochi v0.10.66 on 2025-08-15 10:17 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _str(v)
if type(v) == 'number' then
  local s = tostring(v)
  s = string.gsub(s, '%.0+$', '')
  return s
elseif type(v) == 'table' then
    local parts = {}
    for i = 1, #v do
      parts[#parts+1] = _str(v[i])
    end
    return '[' .. table.concat(parts, ', ') .. ']'
  end
  return tostring(v)
end

local function slice(lst, s, e)
local len = #lst
if s < 0 then s = len + s end
if s < 0 then s = 0 end
if e == nil then
  e = len
elseif e < 0 then
    e = len + e
  end
  if e > len then e = len end
  if s > e then return {} end
  local r = {}
  for i = s + 1, e do
    r[#r+1] = lst[i]
  end
  return r
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = os.clock()
  function exp_approx(x)
    local sum = 1.0
    local term = 1.0
    local n = 1
    while (n < 20) do
      term = ((term * x) / n)
      sum = (sum + term)
      n = (n + 1)
    end
    return sum
  end
  function sigmoid(x)
    return (1.0 / (1.0 + exp_approx((-x))))
  end
  function tanh_approx(x)
    local e = exp_approx((2.0 * x))
    return ((e - 1.0) / (e + 1.0))
  end
  function forward(seq, w)
    local i_arr = {}
    local f_arr = {}
    local o_arr = {}
    local g_arr = {}
    local c_arr = {0.0}
    local h_arr = {0.0}
    local t = 0
    while (t < (function(v)
    if type(v) == 'table' and v.items ~= nil then
      return #v.items
    elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
        local c = 0
        for _ in pairs(v) do c = c + 1 end
        return c
      elseif type(v) == 'string' then
          local l = utf8.len(v)
          if l then return l end
          return #v
        elseif type(v) == 'table' then
            return #v
          else
            return 0
          end
        end)(seq)) do
          local x = seq[t + 1]
          local h_prev = h_arr[t + 1]
          local c_prev = c_arr[t + 1]
          local i_t = sigmoid((((w.w_i * x) + (w.u_i * h_prev)) + w.b_i))
          local f_t = sigmoid((((w.w_f * x) + (w.u_f * h_prev)) + w.b_f))
          local o_t = sigmoid((((w.w_o * x) + (w.u_o * h_prev)) + w.b_o))
          local g_t = tanh_approx((((w.w_c * x) + (w.u_c * h_prev)) + w.b_c))
          local c_t = ((f_t * c_prev) + (i_t * g_t))
          local h_t = (o_t * tanh_approx(c_t))
          i_arr = (function(lst, item)
          local res = {table.unpack(lst or {})}
          res[#res+1] = item
          return res
        end)(i_arr, i_t)
        f_arr = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(f_arr, f_t)
      o_arr = (function(lst, item)
      local res = {table.unpack(lst or {})}
      res[#res+1] = item
      return res
    end)(o_arr, o_t)
    g_arr = (function(lst, item)
    local res = {table.unpack(lst or {})}
    res[#res+1] = item
    return res
  end)(g_arr, g_t)
  c_arr = (function(lst, item)
  local res = {table.unpack(lst or {})}
  res[#res+1] = item
  return res
end)(c_arr, c_t)
h_arr = (function(lst, item)
local res = {table.unpack(lst or {})}
res[#res+1] = item
return res
end)(h_arr, h_t)
t = (t + 1)
end
return {i = i_arr, f = f_arr, o = o_arr, g = g_arr, c = c_arr, h = h_arr}
end
function backward(seq, target, w, s, lr)
  local dw_i = 0.0
  local du_i = 0.0
  local db_i = 0.0
  local dw_f = 0.0
  local du_f = 0.0
  local db_f = 0.0
  local dw_o = 0.0
  local du_o = 0.0
  local db_o = 0.0
  local dw_c = 0.0
  local du_c = 0.0
  local db_c = 0.0
  local dw_y = 0.0
  local db_y = 0.0
  local T = (function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' then
        local l = utf8.len(v)
        if l then return l end
        return #v
      elseif type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(seq)
      local h_last = s.h[T + 1]
      local y = ((w.w_y * h_last) + w.b_y)
      local dy = (y - target)
      dw_y = (dy * h_last)
      db_y = dy
      local dh_next = (dy * w.w_y)
      local dc_next = 0.0
      local t = (T - 1)
      while (t >= 0) do
        local i_t = s.i[t + 1]
        local f_t = s.f[t + 1]
        local o_t = s.o[t + 1]
        local g_t = s.g[t + 1]
        local c_t = s.c[(t + 1) + 1]
        local c_prev = s.c[t + 1]
        local h_prev = s.h[t + 1]
        local tanh_c = tanh_approx(c_t)
        local do_t = (dh_next * tanh_c)
        local da_o = ((do_t * o_t) * (1.0 - o_t))
        local dc = (((dh_next * o_t) * (1.0 - (tanh_c * tanh_c))) + dc_next)
        local di_t = (dc * g_t)
        local da_i = ((di_t * i_t) * (1.0 - i_t))
        local dg_t = (dc * i_t)
        local da_g = (dg_t * (1.0 - (g_t * g_t)))
        local df_t = (dc * c_prev)
        local da_f = ((df_t * f_t) * (1.0 - f_t))
        dw_i = (dw_i + (da_i * seq[t + 1]))
        du_i = (du_i + (da_i * h_prev))
        db_i = (db_i + da_i)
        dw_f = (dw_f + (da_f * seq[t + 1]))
        du_f = (du_f + (da_f * h_prev))
        db_f = (db_f + da_f)
        dw_o = (dw_o + (da_o * seq[t + 1]))
        du_o = (du_o + (da_o * h_prev))
        db_o = (db_o + da_o)
        dw_c = (dw_c + (da_g * seq[t + 1]))
        du_c = (du_c + (da_g * h_prev))
        db_c = (db_c + da_g)
        dh_next = ((((da_i * w.u_i) + (da_f * w.u_f)) + (da_o * w.u_o)) + (da_g * w.u_c))
        dc_next = (dc * f_t)
        t = (t - 1)
      end
      w.w_y = (w.w_y - (lr * dw_y))
      w.b_y = (w.b_y - (lr * db_y))
      w.w_i = (w.w_i - (lr * dw_i))
      w.u_i = (w.u_i - (lr * du_i))
      w.b_i = (w.b_i - (lr * db_i))
      w.w_f = (w.w_f - (lr * dw_f))
      w.u_f = (w.u_f - (lr * du_f))
      w.b_f = (w.b_f - (lr * db_f))
      w.w_o = (w.w_o - (lr * dw_o))
      w.u_o = (w.u_o - (lr * du_o))
      w.b_o = (w.b_o - (lr * db_o))
      w.w_c = (w.w_c - (lr * dw_c))
      w.u_c = (w.u_c - (lr * du_c))
      w.b_c = (w.b_c - (lr * db_c))
      return w
    end
    function make_samples(data, look_back)
      local X = {}
      local Y = {}
      local i = 0
      while ((i + look_back) < (function(v)
      if type(v) == 'table' and v.items ~= nil then
        return #v.items
      elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
          local c = 0
          for _ in pairs(v) do c = c + 1 end
          return c
        elseif type(v) == 'string' then
            local l = utf8.len(v)
            if l then return l end
            return #v
          elseif type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(data)) do
            local seq = slice(data, i, (i + look_back))
            X = (function(lst, item)
            local res = {table.unpack(lst or {})}
            res[#res+1] = item
            return res
          end)(X, seq)
          Y = (function(lst, item)
          local res = {table.unpack(lst or {})}
          res[#res+1] = item
          return res
        end)(Y, data[(i + look_back) + 1])
        i = (i + 1)
      end
      return {x = X, y = Y}
    end
    function init_weights()
      return {w_i = 0.1, u_i = 0.2, b_i = 0.0, w_f = 0.1, u_f = 0.2, b_f = 0.0, w_o = 0.1, u_o = 0.2, b_o = 0.0, w_c = 0.1, u_c = 0.2, b_c = 0.0, w_y = 0.1, b_y = 0.0}
    end
    function train(data, look_back, epochs, lr)
      local samples = make_samples(data, look_back)
      local w = init_weights()
      local ep = 0
      while (ep < epochs) do
        local j = 0
        while (j < (function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' then
              local l = utf8.len(v)
              if l then return l end
              return #v
            elseif type(v) == 'table' then
                return #v
              else
                return 0
              end
            end)(samples.x)) do
              local seq = samples.x[j + 1]
              local target = samples.y[j + 1]
              local state = forward(seq, w)
              w = backward(seq, target, w, state, lr)
              j = (j + 1)
            end
            ep = (ep + 1)
          end
          return w
        end
        function predict(seq, w)
          local state = forward(seq, w)
          local h_last = state.h[((function(v)
          if type(v) == 'table' and v.items ~= nil then
            return #v.items
          elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
              local c = 0
              for _ in pairs(v) do c = c + 1 end
              return c
            elseif type(v) == 'string' then
                local l = utf8.len(v)
                if l then return l end
                return #v
              elseif type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(state.h) - 1) + 1]
              return ((w.w_y * h_last) + w.b_y)
            end
            data = {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8}
            look_back = 3
            epochs = 200
            lr = 0.1
            w = train(data, look_back, epochs, lr)
            test_seq = {0.6, 0.7, 0.8}
            pred = predict(test_seq, w)
            print((((type(("Predicted value: " .. _str(pred))) == "table")) and (
            (function(v)
            local function encode(x)
            if type(x) == "table" then
              if x.__name and x.__order then
                local parts = {x.__name, " {"}
                for i, k in ipairs(x.__order) do
                  if i > 1 then parts[#parts+1] = ", " end
                  parts[#parts+1] = k .. " = " .. encode(x[k])
                end
                parts[#parts+1] = "}"
                return table.concat(parts)
              elseif #x > 0 then
                  local allTables = true
                  for _, v in ipairs(x) do
                    if type(v) ~= "table" then allTables = false break end
                  end
                  local parts = {}
                  if not allTables then parts[#parts+1] = "[" end
                  for i, val in ipairs(x) do
                    parts[#parts+1] = encode(val)
                    if i < #x then parts[#parts+1] = " " end
                  end
                  if not allTables then parts[#parts+1] = "]" end
                  return table.concat(parts)
                else
                  local keys = {}
                  for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
                  table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
                  local parts = {"{"}
                  for i, k in ipairs(keys) do
                    parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
                    if i < #keys then parts[#parts+1] = ", " end
                  end
                  parts[#parts+1] = "}"
                  return table.concat(parts)
                end
              elseif type(x) == "string" then
                  return '"' .. x .. '"'
                else
                  return tostring(x)
                end
              end
              return encode(v)
            end)(("Predicted value: " .. _str(pred)))) or (("Predicted value: " .. _str(pred)))))
            local _bench_end = os.clock()
            collectgarbage()
            local _bench_end_mem = collectgarbage('count') * 1024
            local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
            local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
            print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
          end;
