-- Generated by Mochi v0.10.59 on 2025-08-07 08:32 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = os.clock()
  function get_neighbours(p, x_limit, y_limit)
    local deltas = {{x = (0 - 1), y = (0 - 1)}, {x = (0 - 1), y = 0}, {x = (0 - 1), y = 1}, {x = 0, y = (0 - 1)}, {x = 0, y = 1}, {x = 1, y = (0 - 1)}, {x = 1, y = 0}, {x = 1, y = 1}}
    local neighbours = {}
    for _, d in ipairs(deltas) do
      local nx = (p.x + d.x)
      local ny = (p.y + d.y)
      if ((((0 <= nx) and (nx < x_limit)) and (0 <= ny)) and (ny < y_limit)) then
        neighbours = (function(lst, item)
        local res = {table.unpack(lst or {})}
        table.insert(res, item)
        return res
      end)(neighbours, {x = nx, y = ny})
    end
  end
  return neighbours
end
function contains(nodes, p)
  for _, n in ipairs(nodes) do
    if ((n.pos.x == p.x) and (n.pos.y == p.y)) then
      return true
    end
  end
  return false
end
function get_node(nodes, p)
  for _, n in ipairs(nodes) do
    if ((n.pos.x == p.x) and (n.pos.y == p.y)) then
      return n
    end
  end
  return {pos = p, parent = {x = (0 - 1), y = (0 - 1)}, g = 0, h = 0, f = 0}
end
function astar(x_limit, y_limit, start, goal)
  local open = {}
  local closed = {}
  open = (function(lst, item)
  local res = {table.unpack(lst or {})}
  table.insert(res, item)
  return res
end)(open, {pos = start, parent = {x = (0 - 1), y = (0 - 1)}, g = 0, h = 0, f = 0})
local current = open[0 + 1]
while ((function(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' then
      local l = utf8.len(v)
      if l then return l end
      return #v
    elseif type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(open) > 0) do
      local min_index = 0
      local i = 1
      while (i < (function(v)
      if type(v) == 'table' and v.items ~= nil then
        return #v.items
      elseif type(v) == 'table' and (v[1] == nil) then
          local c = 0
          for _ in pairs(v) do c = c + 1 end
          return c
        elseif type(v) == 'string' then
            local l = utf8.len(v)
            if l then return l end
            return #v
          elseif type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(open)) do
            if (open[i + 1].f < open[min_index + 1].f) then
              min_index = i
            end
            i = (i + 1)
          end
          current = open[min_index + 1]
          local new_open = {}
          local j = 0
          while (j < (function(v)
          if type(v) == 'table' and v.items ~= nil then
            return #v.items
          elseif type(v) == 'table' and (v[1] == nil) then
              local c = 0
              for _ in pairs(v) do c = c + 1 end
              return c
            elseif type(v) == 'string' then
                local l = utf8.len(v)
                if l then return l end
                return #v
              elseif type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(open)) do
                if (j ~= min_index) then
                  new_open = (function(lst, item)
                  local res = {table.unpack(lst or {})}
                  table.insert(res, item)
                  return res
                end)(new_open, open[j + 1])
              end
              j = (j + 1)
            end
            open = new_open
            closed = (function(lst, item)
            local res = {table.unpack(lst or {})}
            table.insert(res, item)
            return res
          end)(closed, current)
          if ((current.pos.x == goal.x) and (current.pos.y == goal.y)) then
            break
          end
          local neighbours = get_neighbours(current.pos, x_limit, y_limit)
          for _, np in ipairs(neighbours) do
            if (function(lst, v)
            for _, x in ipairs(lst) do
              if x == v then
                return true
              end
            end
            return false
          end)(closed, np) then
            goto __cont_2
          end
          local g = (current.g + 1)
          local dx = (goal.x - np.x)
          local dy = (goal.y - np.y)
          local h = (tostring((dx * dx)) .. tostring((dy * dy)))
          local f = (tostring(g) .. tostring(h))
          local skip = false
          for _, node in ipairs(open) do
            if (((node.pos.x == np.x) and (node.pos.y == np.y)) and (node.f < f)) then
              skip = true
            end
          end
          if skip then
            goto __cont_2
          end
          open = (function(lst, item)
          local res = {table.unpack(lst or {})}
          table.insert(res, item)
          return res
        end)(open, {pos = np, parent = current.pos, g = g, h = h, f = f})
        ::__cont_2::
      end
      ::__cont_1::
    end
    local path = {}
    path = (function(lst, item)
    local res = {table.unpack(lst or {})}
    table.insert(res, item)
    return res
  end)(path, current.pos)
  while (not ((current.parent.x == (0 - 1)) and (current.parent.y == (0 - 1)))) do
    current = get_node(closed, current.parent)
    path = (function(lst, item)
    local res = {table.unpack(lst or {})}
    table.insert(res, item)
    return res
  end)(path, current.pos)
end
local rev = {}
local k = ((function(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' then
      local l = utf8.len(v)
      if l then return l end
      return #v
    elseif type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(path) - 1)
    while (k >= 0) do
      rev = (function(lst, item)
      local res = {table.unpack(lst or {})}
      table.insert(res, item)
      return res
    end)(rev, path[k + 1])
    k = (k - 1)
  end
  return rev
end
function create_world(x_limit, y_limit)
  local world = {}
  local i = 0
  while (i < x_limit) do
    local row = {}
    local j = 0
    while (j < y_limit) do
      row = (function(lst, item)
      local res = {table.unpack(lst or {})}
      table.insert(res, item)
      return res
    end)(row, 0)
    j = (j + 1)
  end
  world = (function(lst, item)
  local res = {table.unpack(lst or {})}
  table.insert(res, item)
  return res
end)(world, row)
i = (i + 1)
end
return world
end
function mark_path(world, path)
  for _, p in ipairs(path) do
    world[p.x][p.y] = 1
  end
end
function print_world(world)
  for _, row in ipairs(world) do
    print((((type(tostring(row)) == "table")) and (
    (function(v)
    local function encode(x)
    if type(x) == "table" then
      if x.__name and x.__order then
        local parts = {x.__name, " {"}
        for i, k in ipairs(x.__order) do
          if i > 1 then parts[#parts+1] = ", " end
          parts[#parts+1] = k .. " = " .. encode(x[k])
        end
        parts[#parts+1] = "}"
        return table.concat(parts)
      elseif #x > 0 then
          local allTables = true
          for _, v in ipairs(x) do
            if type(v) ~= "table" then allTables = false break end
          end
          local parts = {}
          if not allTables then parts[#parts+1] = "[" end
          for i, val in ipairs(x) do
            parts[#parts+1] = encode(val)
            if i < #x then parts[#parts+1] = " " end
          end
          if not allTables then parts[#parts+1] = "]" end
          return table.concat(parts)
        else
          local keys = {}
          for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
          table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
          local parts = {"{"}
          for i, k in ipairs(keys) do
            parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
            if i < #keys then parts[#parts+1] = ", " end
          end
          parts[#parts+1] = "}"
          return table.concat(parts)
        end
      elseif type(x) == "string" then
          return '"' .. x .. '"'
        else
          return tostring(x)
        end
      end
      return encode(v)
    end)(tostring(row))) or (tostring(row))))
  end
end
world_x = 5
world_y = 5
start = {x = 0, y = 0}
goal = {x = 4, y = 4}
path = astar(world_x, world_y, start, goal)
print((((type((((((((("path from (" .. tostring(start.x)) .. ", ") .. tostring(start.y)) .. ") to (") .. tostring(goal.x)) .. ", ") .. tostring(goal.y)) .. ")")) == "table")) and (
(function(v)
local function encode(x)
if type(x) == "table" then
  if x.__name and x.__order then
    local parts = {x.__name, " {"}
    for i, k in ipairs(x.__order) do
      if i > 1 then parts[#parts+1] = ", " end
      parts[#parts+1] = k .. " = " .. encode(x[k])
    end
    parts[#parts+1] = "}"
    return table.concat(parts)
  elseif #x > 0 then
      local allTables = true
      for _, v in ipairs(x) do
        if type(v) ~= "table" then allTables = false break end
      end
      local parts = {}
      if not allTables then parts[#parts+1] = "[" end
      for i, val in ipairs(x) do
        parts[#parts+1] = encode(val)
        if i < #x then parts[#parts+1] = " " end
      end
      if not allTables then parts[#parts+1] = "]" end
      return table.concat(parts)
    else
      local keys = {}
      for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
      table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
      local parts = {"{"}
      for i, k in ipairs(keys) do
        parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
        if i < #keys then parts[#parts+1] = ", " end
      end
      parts[#parts+1] = "}"
      return table.concat(parts)
    end
  elseif type(x) == "string" then
      return '"' .. x .. '"'
    else
      return tostring(x)
    end
  end
  return encode(v)
end)((((((((("path from (" .. tostring(start.x)) .. ", ") .. tostring(start.y)) .. ") to (") .. tostring(goal.x)) .. ", ") .. tostring(goal.y)) .. ")"))) or ((((((((("path from (" .. tostring(start.x)) .. ", ") .. tostring(start.y)) .. ") to (") .. tostring(goal.x)) .. ", ") .. tostring(goal.y)) .. ")"))))
world = create_world(world_x, world_y)
mark_path(world, path)
print_world(world)
local _bench_end = os.clock()
collectgarbage()
local _bench_end_mem = collectgarbage('count') * 1024
local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
