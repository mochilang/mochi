-- Generated by Mochi v0.10.66 on 2025-08-15 09:59 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _str(v)
if type(v) == 'number' then
  local s = tostring(v)
  s = string.gsub(s, '%.0+$', '')
  return s
elseif type(v) == 'table' then
    local parts = {}
    for i = 1, #v do
      parts[#parts+1] = _str(v[i])
    end
    return '[' .. table.concat(parts, ', ') .. ']'
  end
  return tostring(v)
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = os.clock()
  function get_neighbours(p, x_limit, y_limit)
    local deltas = {{x = (0 - 1), y = (0 - 1)}, {x = (0 - 1), y = 0}, {x = (0 - 1), y = 1}, {x = 0, y = (0 - 1)}, {x = 0, y = 1}, {x = 1, y = (0 - 1)}, {x = 1, y = 0}, {x = 1, y = 1}}
    local neighbours = {}
    for _, d in ipairs(deltas) do
      local nx = (p.x + d.x)
      local ny = (p.y + d.y)
      if ((((0 <= nx) and (nx < x_limit)) and (0 <= ny)) and (ny < y_limit)) then
        neighbours = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(neighbours, {x = nx, y = ny})
    end
  end
  return neighbours
end
function contains(nodes, p)
  for _, n in ipairs(nodes) do
    if ((n.pos.x == p.x) and (n.pos.y == p.y)) then
      return true
    end
  end
  return false
end
function get_node(nodes, p)
  for _, n in ipairs(nodes) do
    if ((n.pos.x == p.x) and (n.pos.y == p.y)) then
      return n
    end
  end
  return {pos = p, parent = {x = (0 - 1), y = (0 - 1)}, g = 0, h = 0, f = 0}
end
function astar(x_limit, y_limit, start, goal)
  local open = {}
  local closed = {}
  open = (function(lst, item)
  local res = {table.unpack(lst or {})}
  res[#res+1] = item
  return res
end)(open, {pos = start, parent = {x = (0 - 1), y = (0 - 1)}, g = 0, h = 0, f = 0})
local current = open[0 + 1]
while ((function(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' then
      local l = utf8.len(v)
      if l then return l end
      return #v
    elseif type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(open) > 0) do
      local min_index = 0
      local i = 1
      while (i < (function(v)
      if type(v) == 'table' and v.items ~= nil then
        return #v.items
      elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
          local c = 0
          for _ in pairs(v) do c = c + 1 end
          return c
        elseif type(v) == 'string' then
            local l = utf8.len(v)
            if l then return l end
            return #v
          elseif type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(open)) do
            if (open[i + 1].f < open[min_index + 1].f) then
              min_index = i
            end
            i = (i + 1)
          end
          current = open[min_index + 1]
          local new_open = {}
          local j = 0
          while (j < (function(v)
          if type(v) == 'table' and v.items ~= nil then
            return #v.items
          elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
              local c = 0
              for _ in pairs(v) do c = c + 1 end
              return c
            elseif type(v) == 'string' then
                local l = utf8.len(v)
                if l then return l end
                return #v
              elseif type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(open)) do
                if (j ~= min_index) then
                  new_open = (function(lst, item)
                  local res = {table.unpack(lst or {})}
                  res[#res+1] = item
                  return res
                end)(new_open, open[j + 1])
              end
              j = (j + 1)
            end
            open = new_open
            closed = (function(lst, item)
            local res = {table.unpack(lst or {})}
            res[#res+1] = item
            return res
          end)(closed, current)
          if ((current.pos.x == goal.x) and (current.pos.y == goal.y)) then
            break
          end
          local neighbours = get_neighbours(current.pos, x_limit, y_limit)
          for _, np in ipairs(neighbours) do
            if contains(closed, np) then
              goto __cont_2
            end
            local g = (current.g + 1)
            local dx = (goal.x - np.x)
            local dy = (goal.y - np.y)
            local h = (tostring((dx * dx)) .. tostring((dy * dy)))
            local f = (tostring(g) .. tostring(h))
            local skip = false
            for _, node in ipairs(open) do
              if (((node.pos.x == np.x) and (node.pos.y == np.y)) and (node.f < f)) then
                skip = true
              end
            end
            if skip then
              goto __cont_2
            end
            open = (function(lst, item)
            local res = {table.unpack(lst or {})}
            res[#res+1] = item
            return res
          end)(open, {pos = np, parent = current.pos, g = g, h = h, f = f})
          ::__cont_2::
        end
        ::__cont_1::
      end
      local path = {}
      path = (function(lst, item)
      local res = {table.unpack(lst or {})}
      res[#res+1] = item
      return res
    end)(path, current.pos)
    while (not ((current.parent.x == (0 - 1)) and (current.parent.y == (0 - 1)))) do
      current = get_node(closed, current.parent)
      path = (function(lst, item)
      local res = {table.unpack(lst or {})}
      res[#res+1] = item
      return res
    end)(path, current.pos)
  end
  local rev = {}
  local k = ((function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' then
        local l = utf8.len(v)
        if l then return l end
        return #v
      elseif type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(path) - 1)
      while (k >= 0) do
        rev = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(rev, path[k + 1])
      k = (k - 1)
    end
    return rev
  end
  function create_world(x_limit, y_limit)
    local world = {}
    local i = 0
    while (i < x_limit) do
      local row = {}
      local j = 0
      while (j < y_limit) do
        row = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(row, 0)
      j = (j + 1)
    end
    world = (function(lst, item)
    local res = {table.unpack(lst or {})}
    res[#res+1] = item
    return res
  end)(world, row)
  i = (i + 1)
end
return world
end
function mark_path(world, path)
  for _, p in ipairs(path) do
    world[p.x + 1][p.y + 1] = 1
  end
end
function print_world(world)
  for _, row in ipairs(world) do
    print((((type(_str(row)) == "table")) and (
    (function(v)
    local function encode(x)
    if type(x) == "table" then
      if x.__name and x.__order then
        local parts = {x.__name, " {"}
        for i, k in ipairs(x.__order) do
          if i > 1 then parts[#parts+1] = ", " end
          parts[#parts+1] = k .. " = " .. encode(x[k])
        end
        parts[#parts+1] = "}"
        return table.concat(parts)
      elseif #x > 0 then
          local allTables = true
          for _, v in ipairs(x) do
            if type(v) ~= "table" then allTables = false break end
          end
          local parts = {}
          if not allTables then parts[#parts+1] = "[" end
          for i, val in ipairs(x) do
            parts[#parts+1] = encode(val)
            if i < #x then parts[#parts+1] = " " end
          end
          if not allTables then parts[#parts+1] = "]" end
          return table.concat(parts)
        else
          local keys = {}
          for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
          table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
          local parts = {"{"}
          for i, k in ipairs(keys) do
            parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
            if i < #keys then parts[#parts+1] = ", " end
          end
          parts[#parts+1] = "}"
          return table.concat(parts)
        end
      elseif type(x) == "string" then
          return '"' .. x .. '"'
        else
          return tostring(x)
        end
      end
      return encode(v)
    end)(_str(row))) or (_str(row))))
  end
end
world_x = 5
world_y = 5
start = {x = 0, y = 0}
goal = {x = 4, y = 4}
path = astar(world_x, world_y, start, goal)
print((((type((((((((("path from (" .. _str(start.x)) .. ", ") .. _str(start.y)) .. ") to (") .. _str(goal.x)) .. ", ") .. _str(goal.y)) .. ")")) == "table")) and (
(function(v)
local function encode(x)
if type(x) == "table" then
  if x.__name and x.__order then
    local parts = {x.__name, " {"}
    for i, k in ipairs(x.__order) do
      if i > 1 then parts[#parts+1] = ", " end
      parts[#parts+1] = k .. " = " .. encode(x[k])
    end
    parts[#parts+1] = "}"
    return table.concat(parts)
  elseif #x > 0 then
      local allTables = true
      for _, v in ipairs(x) do
        if type(v) ~= "table" then allTables = false break end
      end
      local parts = {}
      if not allTables then parts[#parts+1] = "[" end
      for i, val in ipairs(x) do
        parts[#parts+1] = encode(val)
        if i < #x then parts[#parts+1] = " " end
      end
      if not allTables then parts[#parts+1] = "]" end
      return table.concat(parts)
    else
      local keys = {}
      for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
      table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
      local parts = {"{"}
      for i, k in ipairs(keys) do
        parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
        if i < #keys then parts[#parts+1] = ", " end
      end
      parts[#parts+1] = "}"
      return table.concat(parts)
    end
  elseif type(x) == "string" then
      return '"' .. x .. '"'
    else
      return tostring(x)
    end
  end
  return encode(v)
end)((((((((("path from (" .. _str(start.x)) .. ", ") .. _str(start.y)) .. ") to (") .. _str(goal.x)) .. ", ") .. _str(goal.y)) .. ")"))) or ((((((((("path from (" .. _str(start.x)) .. ", ") .. _str(start.y)) .. ") to (") .. _str(goal.x)) .. ", ") .. _str(goal.y)) .. ")"))))
world = create_world(world_x, world_y)
mark_path(world, path)
print_world(world)
local _bench_end = os.clock()
collectgarbage()
local _bench_end_mem = collectgarbage('count') * 1024
local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
