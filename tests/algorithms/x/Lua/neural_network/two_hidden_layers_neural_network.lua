-- Generated by Mochi v0.10.59 on 2025-08-07 11:58 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _str(v)
if type(v) == 'number' then
  local s = tostring(v)
  s = string.gsub(s, '%.0+$', '')
  return s
end
return tostring(v)
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = os.clock()
  function exp_approx(x)
    local sum = 1
    local term = 1
    local i = 1
    while (i < 10) do
      term = ((term * x) / tonumber(i))
      sum = (sum + term)
      i = (i + 1)
    end
    return sum
  end
  function sigmoid(x)
    return (1 / (1 + exp_approx((-x))))
  end
  function sigmoid_derivative(x)
    return (x * (1 - x))
  end
  function new_network()
    return {w1 = {{0.1, 0.2, 0.3, 0.4}, {0.5, 0.6, 0.7, 0.8}, {0.9, 1, 1.1, 1.2}}, w2 = {{0.1, 0.2, 0.3}, {0.4, 0.5, 0.6}, {0.7, 0.8, 0.9}, {1, 1.1, 1.2}}, w3 = {{0.1}, {0.2}, {0.3}}}
  end
  function feedforward(net, input)
    local hidden1 = {}
    local j = 0
    while (j < 4) do
      local sum1 = 0
      local i = 0
      while (i < 3) do
        sum1 = (sum1 + (input[i + 1] * net.w1[i + 1][j + 1]))
        i = (i + 1)
      end
      hidden1 = (function(lst, item)
      local res = {table.unpack(lst or {})}
      table.insert(res, item)
      return res
    end)(hidden1, sigmoid(sum1))
    j = (j + 1)
  end
  local hidden2 = {}
  local k = 0
  while (k < 3) do
    local sum2 = 0
    local j2 = 0
    while (j2 < 4) do
      sum2 = (sum2 + (hidden1[j2 + 1] * net.w2[j2 + 1][k + 1]))
      j2 = (j2 + 1)
    end
    hidden2 = (function(lst, item)
    local res = {table.unpack(lst or {})}
    table.insert(res, item)
    return res
  end)(hidden2, sigmoid(sum2))
  k = (k + 1)
end
local sum3 = 0
local k2 = 0
while (k2 < 3) do
  sum3 = (sum3 + (hidden2[k2 + 1] * net.w3[k2 + 1][0 + 1]))
  k2 = (k2 + 1)
end
local out = sigmoid(sum3)
return out
end
function train(net, inputs, outputs, iterations)
  local iter = 0
  while (iter < iterations) do
    local s = 0
    while (s < (function(v)
    if type(v) == 'table' and v.items ~= nil then
      return #v.items
    elseif type(v) == 'table' and (v[1] == nil) then
        local c = 0
        for _ in pairs(v) do c = c + 1 end
        return c
      elseif type(v) == 'string' then
          local l = utf8.len(v)
          if l then return l end
          return #v
        elseif type(v) == 'table' then
            return #v
          else
            return 0
          end
        end)(inputs)) do
          local inp = inputs[s + 1]
          local target = outputs[s + 1]
          local hidden1 = {}
          local j = 0
          while (j < 4) do
            local sum1 = 0
            local i = 0
            while (i < 3) do
              sum1 = (sum1 + (inp[i + 1] * net.w1[i + 1][j + 1]))
              i = (i + 1)
            end
            hidden1 = (function(lst, item)
            local res = {table.unpack(lst or {})}
            table.insert(res, item)
            return res
          end)(hidden1, sigmoid(sum1))
          j = (j + 1)
        end
        local hidden2 = {}
        local k = 0
        while (k < 3) do
          local sum2 = 0
          local j2 = 0
          while (j2 < 4) do
            sum2 = (sum2 + (hidden1[j2 + 1] * net.w2[j2 + 1][k + 1]))
            j2 = (j2 + 1)
          end
          hidden2 = (function(lst, item)
          local res = {table.unpack(lst or {})}
          table.insert(res, item)
          return res
        end)(hidden2, sigmoid(sum2))
        k = (k + 1)
      end
      local sum3 = 0
      local k3 = 0
      while (k3 < 3) do
        sum3 = (sum3 + (hidden2[k3 + 1] * net.w3[k3 + 1][0 + 1]))
        k3 = (k3 + 1)
      end
      local output = sigmoid(sum3)
      local error = (target - output)
      local delta_output = (error * sigmoid_derivative(output))
      local new_w3 = {}
      local k4 = 0
      while (k4 < 3) do
        local w3row = net.w3[k4 + 1]
        w3row[0 + 1] = (w3row[0 + 1] + (hidden2[k4 + 1] * delta_output))
        new_w3 = (function(lst, item)
        local res = {table.unpack(lst or {})}
        table.insert(res, item)
        return res
      end)(new_w3, w3row)
      k4 = (k4 + 1)
    end
    net.w3 = new_w3
    local delta_hidden2 = {}
    local k5 = 0
    while (k5 < 3) do
      local row = net.w3[k5 + 1]
      local dh2 = ((row[0 + 1] * delta_output) * sigmoid_derivative(hidden2[k5 + 1]))
      delta_hidden2 = (function(lst, item)
      local res = {table.unpack(lst or {})}
      table.insert(res, item)
      return res
    end)(delta_hidden2, dh2)
    k5 = (k5 + 1)
  end
  local new_w2 = {}
  j = 0
  while (j < 4) do
    local w2row = net.w2[j + 1]
    local k6 = 0
    while (k6 < 3) do
      w2row[k6 + 1] = (w2row[k6 + 1] + (hidden1[j + 1] * delta_hidden2[k6 + 1]))
      k6 = (k6 + 1)
    end
    new_w2 = (function(lst, item)
    local res = {table.unpack(lst or {})}
    table.insert(res, item)
    return res
  end)(new_w2, w2row)
  j = (j + 1)
end
net.w2 = new_w2
local delta_hidden1 = {}
j = 0
while (j < 4) do
  local sumdh = 0
  local k7 = 0
  while (k7 < 3) do
    local row2 = net.w2[j + 1]
    sumdh = (sumdh + (row2[k7 + 1] * delta_hidden2[k7 + 1]))
    k7 = (k7 + 1)
  end
  delta_hidden1 = (function(lst, item)
  local res = {table.unpack(lst or {})}
  table.insert(res, item)
  return res
end)(delta_hidden1, (sumdh * sigmoid_derivative(hidden1[j + 1])))
j = (j + 1)
end
local new_w1 = {}
local i2 = 0
while (i2 < 3) do
  local w1row = net.w1[i2 + 1]
  j = 0
  while (j < 4) do
    w1row[j + 1] = (w1row[j + 1] + (inp[i2 + 1] * delta_hidden1[j + 1]))
    j = (j + 1)
  end
  new_w1 = (function(lst, item)
  local res = {table.unpack(lst or {})}
  table.insert(res, item)
  return res
end)(new_w1, w1row)
i2 = (i2 + 1)
end
net.w1 = new_w1
s = (s + 1)
end
iter = (iter + 1)
end
end
function predict(net, input)
  local out = feedforward(net, input)
  if (out > 0.6) then
    return 1
  end
  return 0
end
function example()
  local inputs = {{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1}, {1, 0, 0}, {1, 0, 1}, {1, 1, 0}, {1, 1, 1}}
  local outputs = {0, 1, 1, 0, 1, 0, 0, 1}
  local net = new_network()
  train(net, inputs, outputs, 10)
  local result = predict(net, {1, 1, 1})
  print((((type(_str(result)) == "table")) and (
  (function(v)
  local function encode(x)
  if type(x) == "table" then
    if x.__name and x.__order then
      local parts = {x.__name, " {"}
      for i, k in ipairs(x.__order) do
        if i > 1 then parts[#parts+1] = ", " end
        parts[#parts+1] = k .. " = " .. encode(x[k])
      end
      parts[#parts+1] = "}"
      return table.concat(parts)
    elseif #x > 0 then
        local allTables = true
        for _, v in ipairs(x) do
          if type(v) ~= "table" then allTables = false break end
        end
        local parts = {}
        if not allTables then parts[#parts+1] = "[" end
        for i, val in ipairs(x) do
          parts[#parts+1] = encode(val)
          if i < #x then parts[#parts+1] = " " end
        end
        if not allTables then parts[#parts+1] = "]" end
        return table.concat(parts)
      else
        local keys = {}
        for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
        table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
        local parts = {"{"}
        for i, k in ipairs(keys) do
          parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
          if i < #keys then parts[#parts+1] = ", " end
        end
        parts[#parts+1] = "}"
        return table.concat(parts)
      end
    elseif type(x) == "string" then
        return '"' .. x .. '"'
      else
        return tostring(x)
      end
    end
    return encode(v)
  end)(_str(result))) or (_str(result))))
  return result
end
function main()
  example()
end
main()
local _bench_end = os.clock()
collectgarbage()
local _bench_end_mem = collectgarbage('count') * 1024
local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
