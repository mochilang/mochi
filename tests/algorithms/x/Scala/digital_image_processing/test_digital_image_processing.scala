// Generated by Mochi v0.10.71 on 2025-08-24 09:39:52 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case m: scala.collection.Map[_, _] => scala.collection.immutable.ListMap(m.toSeq.sortBy(_._1.toString): _*).toString.replace("ListMap", "Map")
  case d: Double => { val i = d.toLong; if (d == i.toDouble) java.lang.Long.toString(i) else java.lang.Double.toString(d) }
  case other => String.valueOf(other)
}

def clamp_byte(x: BigInt): BigInt = {
  if (x < BigInt(0)) {
    return BigInt(0)
  }
  if (x > BigInt(255)) {
    return BigInt(255)
  }
  return x
}

def convert_to_negative(img: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var y: BigInt = BigInt(0)
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var x: BigInt = BigInt(0)
    while (x < w) {
      row = ({row += (BigInt(255) - img.lift((y.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((x.toInt).toInt).getOrElse(BigInt(0))); row})
      x = x + BigInt(1)
    }
    out = ({out += (row); out})
    y = y + BigInt(1)
  }
  return out
}

def change_contrast(img: ArrayBuffer[ArrayBuffer[BigInt]], factor: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var y: BigInt = BigInt(0)
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var x: BigInt = BigInt(0)
    while (x < w) {
      var p: BigInt = img.lift((y.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((x.toInt).toInt).getOrElse(BigInt(0))
      var v: BigInt = (p - BigInt(128)) * factor / BigInt(100) + BigInt(128)
      v = clamp_byte(v)
      row = ({row += (v); row})
      x = x + BigInt(1)
    }
    out = ({out += (row); out})
    y = y + BigInt(1)
  }
  return out
}

def gen_gaussian_kernel(n: BigInt, sigma: Double): ArrayBuffer[ArrayBuffer[Double]] = {
  if (n == BigInt(3)) {
    return ArrayBuffer(ArrayBuffer(1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0), ArrayBuffer(2.0 / 16.0, 4.0 / 16.0, 2.0 / 16.0), ArrayBuffer(1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0))
  }
  var k: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < n) {
      row = ({row += (0.0); row})
      j = j + BigInt(1)
    }
    k = ({k += (row); k})
    i = i + BigInt(1)
  }
  return k
}

def img_convolve(img: ArrayBuffer[ArrayBuffer[BigInt]], kernel: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var y: BigInt = BigInt(0)
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var x: BigInt = BigInt(0)
    while (x < w) {
      var acc: Double = 0.0
      var ky: BigInt = BigInt(0)
      while (ky < BigInt((kernel).size)) {
        var kx: BigInt = BigInt(0)
        while (kx < BigInt((kernel.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
          var iy: BigInt = y + ky - BigInt(1)
          var ix: BigInt = x + kx - BigInt(1)
          var pixel: BigInt = BigInt(0)
          if ((((iy >= BigInt(0) && iy < h).asInstanceOf[Boolean] && ix >= BigInt(0)).asInstanceOf[Boolean] && ix < w)) {
            pixel = img.lift((iy.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((ix.toInt).toInt).getOrElse(BigInt(0))
          }
          acc = acc + kernel.lift((ky.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((kx.toInt).toInt).getOrElse(0.0) * (1.0 * pixel.toString.toDouble)
          kx = kx + BigInt(1)
        }
        ky = ky + BigInt(1)
      }
      row = ({row += (BigInt(acc.toString.toDouble.toInt)); row})
      x = x + BigInt(1)
    }
    out = ({out += (row); out})
    y = y + BigInt(1)
  }
  return out
}

def sort_ints(xs: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = xs
  var i: BigInt = BigInt(0)
  while (i < BigInt((arr).size)) {
    var j: BigInt = BigInt(0)
    while (j < BigInt((arr).size) - BigInt(1) - i) {
      if (arr.lift((j.toInt).toInt).getOrElse(BigInt(0)) > arr.lift(((j + BigInt(1)).toInt).toInt).getOrElse(BigInt(0))) {
        var tmp: BigInt = arr.lift((j.toInt).toInt).getOrElse(BigInt(0))
        arr((j).toInt) = arr.lift(((j + BigInt(1)).toInt).toInt).getOrElse(BigInt(0))
        arr((j + BigInt(1)).toInt) = tmp
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return arr
}

def median_filter(img: ArrayBuffer[ArrayBuffer[BigInt]], k: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var offset: BigInt = k / BigInt(2)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var y: BigInt = BigInt(0)
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var x: BigInt = BigInt(0)
    while (x < w) {
      var vals: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
      var ky: BigInt = BigInt(0)
      while (ky < k) {
        var kx: BigInt = BigInt(0)
        while (kx < k) {
          var iy: BigInt = y + ky - offset
          var ix: BigInt = x + kx - offset
          var pixel: BigInt = BigInt(0)
          if ((((iy >= BigInt(0) && iy < h).asInstanceOf[Boolean] && ix >= BigInt(0)).asInstanceOf[Boolean] && ix < w)) {
            pixel = img.lift((iy.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((ix.toInt).toInt).getOrElse(BigInt(0))
          }
          vals = ({vals += (pixel); vals})
          kx = kx + BigInt(1)
        }
        ky = ky + BigInt(1)
      }
      var sorted: ArrayBuffer[BigInt] = sort_ints(vals)
      row = ({row += (sorted.lift(((BigInt((sorted).size) / BigInt(2)).toInt).toInt).getOrElse(BigInt(0))); row})
      x = x + BigInt(1)
    }
    out = ({out += (row); out})
    y = y + BigInt(1)
  }
  return out
}

def iabs(x: BigInt): BigInt = {
  if (x < BigInt(0)) {
    return -x
  }
  return x
}

def sobel_filter(img: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var gx: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(0), BigInt(-1)), ArrayBuffer(BigInt(2), BigInt(0), BigInt(-2)), ArrayBuffer(BigInt(1), BigInt(0), BigInt(-1)))
  var gy: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(1)), ArrayBuffer(BigInt(0), BigInt(0), BigInt(0)), ArrayBuffer(BigInt(-1), BigInt(-2), BigInt(-1)))
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var y: BigInt = BigInt(0)
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var x: BigInt = BigInt(0)
    while (x < w) {
      var sx: BigInt = BigInt(0)
      var sy: BigInt = BigInt(0)
      var ky: BigInt = BigInt(0)
      while (ky < BigInt(3)) {
        var kx: BigInt = BigInt(0)
        while (kx < BigInt(3)) {
          var iy: BigInt = y + ky - BigInt(1)
          var ix: BigInt = x + kx - BigInt(1)
          var pixel: BigInt = BigInt(0)
          if ((((iy >= BigInt(0) && iy < h).asInstanceOf[Boolean] && ix >= BigInt(0)).asInstanceOf[Boolean] && ix < w)) {
            pixel = img.lift((iy.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((ix.toInt).toInt).getOrElse(BigInt(0))
          }
          sx = sx + gx.lift((ky.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((kx.toInt).toInt).getOrElse(BigInt(0)) * pixel
          sy = sy + gy.lift((ky.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((kx.toInt).toInt).getOrElse(BigInt(0)) * pixel
          kx = kx + BigInt(1)
        }
        ky = ky + BigInt(1)
      }
      row = ({row += (iabs(sx) + iabs(sy)); row})
      x = x + BigInt(1)
    }
    out = ({out += (row); out})
    y = y + BigInt(1)
  }
  return out
}

def get_neighbors_pixel(img: ArrayBuffer[ArrayBuffer[BigInt]], x: BigInt, y: BigInt): ArrayBuffer[BigInt] = {
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var neighbors: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var dy: BigInt = BigInt(-1)
  while (dy <= BigInt(1)) {
    var dx: BigInt = BigInt(-1)
    while (dx <= BigInt(1)) {
      if (!(dx == BigInt(0) && dy == BigInt(0))) {
        var ny: BigInt = y + dy
        var nx: BigInt = x + dx
        var `val`: BigInt = BigInt(0)
        if ((((ny >= BigInt(0) && ny < h).asInstanceOf[Boolean] && nx >= BigInt(0)).asInstanceOf[Boolean] && nx < w)) {
          `val` = img.lift((ny.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((nx.toInt).toInt).getOrElse(BigInt(0))
        }
        neighbors = ({neighbors += (`val`); neighbors})
      }
      dx = dx + BigInt(1)
    }
    dy = dy + BigInt(1)
  }
  return neighbors
}

def pow2(e: BigInt): BigInt = {
  var r: BigInt = BigInt(1)
  var i: BigInt = BigInt(0)
  while (i < e) {
    r = r * BigInt(2)
    i = i + BigInt(1)
  }
  return r
}

def local_binary_value(img: ArrayBuffer[ArrayBuffer[BigInt]], x: BigInt, y: BigInt): BigInt = {
  var center: BigInt = img.lift((y.toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((x.toInt).toInt).getOrElse(BigInt(0))
  var neighbors: ArrayBuffer[BigInt] = get_neighbors_pixel(img, x, y)
  var v: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((neighbors).size)) {
    if (neighbors.lift((i.toInt).toInt).getOrElse(BigInt(0)) >= center) {
      v = v + pow2(i)
    }
    i = i + BigInt(1)
  }
  return v
}

def local_binary_pattern(img: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var h: BigInt = BigInt((img).size)
  var w: BigInt = BigInt((img.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[BigInt]())).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var y: BigInt = BigInt(0)
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var x: BigInt = BigInt(0)
    while (x < w) {
      row = ({row += (local_binary_value(img, x, y)); row})
      x = x + BigInt(1)
    }
    out = ({out += (row); out})
    y = y + BigInt(1)
  }
  return out
}

var img: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(52), BigInt(55), BigInt(61)), ArrayBuffer(BigInt(62), BigInt(59), BigInt(55)), ArrayBuffer(BigInt(63), BigInt(65), BigInt(66)))

var kernel: ArrayBuffer[ArrayBuffer[Double]] = gen_gaussian_kernel(BigInt(3), 1.0)

var laplace: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.25, 0.5, 0.25), ArrayBuffer(0.5, -3.0, 0.5), ArrayBuffer(0.25, 0.5, 0.25))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    var negative: ArrayBuffer[ArrayBuffer[BigInt]] = convert_to_negative(img)
    var contrast: ArrayBuffer[ArrayBuffer[BigInt]] = change_contrast(img, BigInt(110))
    var convolved: ArrayBuffer[ArrayBuffer[BigInt]] = img_convolve(img, laplace)
    var medianed: ArrayBuffer[ArrayBuffer[BigInt]] = median_filter(img, BigInt(3))
    var sobel: ArrayBuffer[ArrayBuffer[BigInt]] = sobel_filter(img)
    var lbp_img: ArrayBuffer[ArrayBuffer[BigInt]] = local_binary_pattern(img)
    println(_str(negative))
    println(_str(contrast))
    println(_str(kernel))
    println(_str(convolved))
    println(_str(medianed))
    println(_str(sobel))
    println(_str(lbp_img))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
