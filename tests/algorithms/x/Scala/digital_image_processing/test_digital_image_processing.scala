// Generated by Mochi v0.10.59 on 2025-08-07 00:55:41 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def clamp_byte(x: BigInt): BigInt = {
  if (x < 0) {
    return 0
  }
  if (x > 255) {
    return 255
  }
  return x
}

def convert_to_negative(img: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      row = row :+ 255 - img((y.toInt).toInt)((x.toInt).toInt)
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def change_contrast(img: ArrayBuffer[ArrayBuffer[BigInt]], factor: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      val p: BigInt = img((y.toInt).toInt)((x.toInt).toInt)
      var v: BigInt = (p - 128) * factor / 100 + 128
      v = clamp_byte(v)
      row = row :+ v
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def gen_gaussian_kernel(n: BigInt, sigma: Double): ArrayBuffer[ArrayBuffer[Double]] = {
  if (n == 3) {
    return ArrayBuffer(ArrayBuffer(1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0), ArrayBuffer(2.0 / 16.0, 4.0 / 16.0, 2.0 / 16.0), ArrayBuffer(1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0))
  }
  var k: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
  var i: BigInt = 0
  while (i < n) {
    var row: ArrayBuffer[Double] = ArrayBuffer()
    var j: BigInt = 0
    while (j < n) {
      row = row :+ 0.0
      j = j + 1
    }
    k = k :+ row
    i = i + 1
  }
  return k
}

def img_convolve(img: ArrayBuffer[ArrayBuffer[BigInt]], kernel: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      var acc: Double = 0.0
      var ky: BigInt = 0
      while (ky < BigInt((kernel).size)) {
        var kx: BigInt = 0
        while (kx < BigInt((kernel((0.toInt).toInt)).size)) {
          val iy: BigInt = y + ky - 1
          val ix: BigInt = x + kx - 1
          var pixel: BigInt = 0
          if ((((iy >= 0 && iy < h).asInstanceOf[Boolean] && ix >= 0).asInstanceOf[Boolean] && ix < w).asInstanceOf[Boolean]) {
            pixel = img((iy.toInt).toInt)((ix.toInt).toInt)
          }
          acc = acc + kernel((ky.toInt).toInt)((kx.toInt).toInt) * (1.0 * pixel.toString.toDouble)
          kx = kx + 1
        }
        ky = ky + 1
      }
      row = row :+ BigInt(acc.toString.toDouble.toInt)
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def sort_ints(xs: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = xs
  var i: BigInt = 0
  while (i < BigInt((arr).size)) {
    var j: BigInt = 0
    while (j < BigInt((arr).size) - 1 - i) {
      if (arr((j.toInt).toInt) > arr(((j + 1).toInt).toInt)) {
        val tmp: BigInt = arr((j.toInt).toInt)
        arr((j).toInt) = arr(((j + 1).toInt).toInt)
        arr((j + 1).toInt) = tmp
      }
      j = j + 1
    }
    i = i + 1
  }
  return arr
}

def median_filter(img: ArrayBuffer[ArrayBuffer[BigInt]], k: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  val offset: BigInt = k / 2
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      var vals: ArrayBuffer[BigInt] = ArrayBuffer()
      var ky: BigInt = 0
      while (ky < k) {
        var kx: BigInt = 0
        while (kx < k) {
          val iy: BigInt = y + ky - offset
          val ix: BigInt = x + kx - offset
          var pixel: BigInt = 0
          if ((((iy >= 0 && iy < h).asInstanceOf[Boolean] && ix >= 0).asInstanceOf[Boolean] && ix < w).asInstanceOf[Boolean]) {
            pixel = img((iy.toInt).toInt)((ix.toInt).toInt)
          }
          vals = vals :+ pixel
          kx = kx + 1
        }
        ky = ky + 1
      }
      val sorted: ArrayBuffer[BigInt] = sort_ints(vals)
      row = row :+ sorted(((BigInt((sorted).size) / 2).toInt).toInt)
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def iabs(x: BigInt): BigInt = {
  if (x < 0) {
    return -x
  }
  return x
}

def sobel_filter(img: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  val gx: ArrayBuffer[ArrayBuffer[Any]] = ArrayBuffer(ArrayBuffer(1, 0, -1), ArrayBuffer(2, 0, -2), ArrayBuffer(1, 0, -1))
  val gy: ArrayBuffer[Any] = ArrayBuffer(ArrayBuffer(1, 2, 1), ArrayBuffer(0, 0, 0), ArrayBuffer(-1, -2, -1))
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      var sx: BigInt = 0
      var sy: BigInt = 0
      var ky: BigInt = 0
      while (ky < 3) {
        var kx: BigInt = 0
        while (kx < 3) {
          val iy: BigInt = y + ky - 1
          val ix: BigInt = x + kx - 1
          var pixel: BigInt = 0
          if ((((iy >= 0 && iy < h).asInstanceOf[Boolean] && ix >= 0).asInstanceOf[Boolean] && ix < w).asInstanceOf[Boolean]) {
            pixel = img((iy.toInt).toInt)((ix.toInt).toInt)
          }
          sx = sx + BigInt((gx((ky.toInt).toInt)((kx.toInt).toInt)).toString.toDouble.toInt) * pixel
          sy = sy + gy((ky.toInt).toInt).asInstanceOf[ArrayBuffer[Any]]((kx.toInt).toInt) * pixel
          kx = kx + 1
        }
        ky = ky + 1
      }
      row = row :+ iabs(sx) + iabs(sy)
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def get_neighbors_pixel(img: ArrayBuffer[ArrayBuffer[BigInt]], x: BigInt, y: BigInt): ArrayBuffer[BigInt] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  var neighbors: ArrayBuffer[BigInt] = ArrayBuffer()
  var dy: BigInt = -1
  while (dy <= 1) {
    var dx: BigInt = -1
    while (dx <= 1) {
      if (!(dx == 0 && dy == 0).asInstanceOf[Boolean]) {
        val ny: BigInt = y + dy
        val nx: BigInt = x + dx
        var `val`: BigInt = 0
        if ((((ny >= 0 && ny < h).asInstanceOf[Boolean] && nx >= 0).asInstanceOf[Boolean] && nx < w).asInstanceOf[Boolean]) {
          `val` = img((ny.toInt).toInt)((nx.toInt).toInt)
        }
        neighbors = neighbors :+ `val`
      }
      dx = dx + 1
    }
    dy = dy + 1
  }
  return neighbors
}

def pow2(e: BigInt): BigInt = {
  var r: BigInt = 1
  var i: BigInt = 0
  while (i < e) {
    r = r * 2
    i = i + 1
  }
  return r
}

def local_binary_value(img: ArrayBuffer[ArrayBuffer[BigInt]], x: BigInt, y: BigInt): BigInt = {
  val center: BigInt = img((y.toInt).toInt)((x.toInt).toInt)
  val neighbors: ArrayBuffer[BigInt] = get_neighbors_pixel(img, x, y)
  var v: BigInt = 0
  var i: BigInt = 0
  while (i < BigInt((neighbors).size)) {
    if (neighbors((i.toInt).toInt) >= center) {
      v = v + pow2(i)
    }
    i = i + 1
  }
  return v
}

def local_binary_pattern(img: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      row = row :+ local_binary_value(img, x, y)
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

val img: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(52, 55, 61), ArrayBuffer(62, 59, 55), ArrayBuffer(63, 65, 66))

val negative: ArrayBuffer[ArrayBuffer[BigInt]] = convert_to_negative(img)

val contrast: ArrayBuffer[ArrayBuffer[BigInt]] = change_contrast(img, 110)

val kernel: ArrayBuffer[ArrayBuffer[Double]] = gen_gaussian_kernel(3, 1.0)

val laplace: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.25, 0.5, 0.25), ArrayBuffer(0.5, -3.0, 0.5), ArrayBuffer(0.25, 0.5, 0.25))

val convolved: ArrayBuffer[ArrayBuffer[BigInt]] = img_convolve(img, laplace)

val medianed: ArrayBuffer[ArrayBuffer[BigInt]] = median_filter(img, 3)

val sobel: ArrayBuffer[ArrayBuffer[BigInt]] = sobel_filter(img)

val lbp_img: ArrayBuffer[ArrayBuffer[BigInt]] = local_binary_pattern(img)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(negative)
    println(contrast)
    println(kernel)
    println(convolved)
    println(medianed)
    println(sobel)
    println(lbp_img)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
