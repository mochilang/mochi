// Generated by Mochi v0.10.63 on 2025-08-11 16:34:12 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def insertion_sort(a: ArrayBuffer[BigInt], start: BigInt, `end_`: BigInt): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = a
  var i: BigInt = start
  while (i < `end_`) {
    val key: BigInt = arr.lift((i.toInt).toInt).getOrElse(null)
    var j: BigInt = i
    while (j > start && arr.lift(((j - BigInt(1)).toInt).toInt).getOrElse(null) > key) {
      arr((j).toInt) = arr.lift(((j - BigInt(1)).toInt).toInt).getOrElse(null)
      j = j - BigInt(1)
    }
    arr((j).toInt) = key
    i = i + BigInt(1)
  }
  return arr
}

def heapify(a: ArrayBuffer[BigInt], index: BigInt, heap_size: BigInt): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = a
  var largest: BigInt = index
  val left: BigInt = BigInt(2) * index + BigInt(1)
  val right: BigInt = BigInt(2) * index + BigInt(2)
  if ((left < heap_size && arr.lift((left.toInt).toInt).getOrElse(null) > arr.lift((largest.toInt).toInt).getOrElse(null)).asInstanceOf[Boolean]) {
    largest = left
  }
  if ((right < heap_size && arr.lift((right.toInt).toInt).getOrElse(null) > arr.lift((largest.toInt).toInt).getOrElse(null)).asInstanceOf[Boolean]) {
    largest = right
  }
  if (largest != index) {
    val temp: BigInt = arr.lift((index.toInt).toInt).getOrElse(null)
    arr((index).toInt) = arr.lift((largest.toInt).toInt).getOrElse(null)
    arr((largest).toInt) = temp
    arr = heapify(arr, largest, heap_size)
  }
  return arr
}

def heap_sort(a: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = a
  val n: BigInt = BigInt((arr).size)
  if (n <= BigInt(1)) {
    return arr
  }
  var i: BigInt = n / BigInt(2)
  val _br2 = new Breaks
  _br2.breakable {
    while (true) {
      arr = heapify(arr, i, n)
      if (i == BigInt(0)) {
        _br2.break()
      }
      i = i - BigInt(1)
    }
  }
  i = n - BigInt(1)
  while (i > BigInt(0)) {
    val temp: BigInt = arr.lift((BigInt(0).toInt).toInt).getOrElse(null)
    arr((BigInt(0)).toInt) = arr.lift((i.toInt).toInt).getOrElse(null)
    arr((i).toInt) = temp
    arr = heapify(arr, BigInt(0), i)
    i = i - BigInt(1)
  }
  return arr
}

def median_of_3(arr: ArrayBuffer[BigInt], first: BigInt, middle: BigInt, last: BigInt): BigInt = {
  val a: BigInt = arr.lift((first.toInt).toInt).getOrElse(null)
  val b: BigInt = arr.lift((middle.toInt).toInt).getOrElse(null)
  val c: BigInt = arr.lift((last.toInt).toInt).getOrElse(null)
  if (((a > b && a < c).asInstanceOf[Boolean] || (a < b && a > c).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
    return a
  } else {
    if (((b > a && b < c).asInstanceOf[Boolean] || (b < a && b > c).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      return b
    } else {
      return c
    }
  }
  return null
}

def partition(arr: ArrayBuffer[BigInt], low: BigInt, high: BigInt, pivot: BigInt): BigInt = {
  var i: BigInt = low
  var j: BigInt = high
  while (true) {
    while (arr.lift((i.toInt).toInt).getOrElse(null) < pivot) {
      i = i + BigInt(1)
    }
    j = j - BigInt(1)
    while (pivot < arr.lift((j.toInt).toInt).getOrElse(null)) {
      j = j - BigInt(1)
    }
    if (i >= j) {
      return i
    }
    val temp: BigInt = arr.lift((i.toInt).toInt).getOrElse(null)
    arr((i).toInt) = arr.lift((j.toInt).toInt).getOrElse(null)
    arr((j).toInt) = temp
    i = i + BigInt(1)
  }
  return null
}

def int_log2(n: BigInt): BigInt = {
  var v: BigInt = n
  var r: BigInt = BigInt(0)
  while (v > BigInt(1)) {
    v = v / BigInt(2)
    r = r + BigInt(1)
  }
  return r
}

def intro_sort(arr: ArrayBuffer[BigInt], start: BigInt, `end_`: BigInt, size_threshold: BigInt, max_depth: BigInt): ArrayBuffer[BigInt] = {
  var array: ArrayBuffer[BigInt] = arr
  var s: BigInt = start
  var e: BigInt = `end_`
  var depth: BigInt = max_depth
  while (e - s > size_threshold) {
    if (depth == BigInt(0)) {
      return heap_sort(array)
    }
    depth = depth - BigInt(1)
    val pivot: BigInt = median_of_3(array, s, s + (e - s) / BigInt(2) + BigInt(1), e - BigInt(1))
    val p: BigInt = partition(array, s, e, pivot)
    array = intro_sort(array, p, e, size_threshold, depth)
    e = p
  }
  val res: ArrayBuffer[BigInt] = insertion_sort(array, s, e)
  val `_`: BigInt = BigInt((res).size)
  return res
}

def intro_sort_main(arr: ArrayBuffer[BigInt]): Any = {
  if (BigInt((arr).size) == BigInt(0)) {
    println(arr)
    return
  }
  val max_depth: BigInt = BigInt(2) * int_log2(BigInt((arr).size))
  val sorted: ArrayBuffer[BigInt] = intro_sort(arr, BigInt(0), BigInt((arr).size), BigInt(16), max_depth)
  println(sorted)
  return null
}

val example1: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(4), BigInt(2), BigInt(6), BigInt(8), BigInt(1), BigInt(7), BigInt(8), BigInt(22), BigInt(14), BigInt(56), BigInt(27), BigInt(79), BigInt(23), BigInt(45), BigInt(14), BigInt(12))

val example2: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(21), BigInt(15), BigInt(11), BigInt(45), -BigInt(2), -BigInt(11), BigInt(46))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    intro_sort_main(example1)
    intro_sort_main(example2)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
