// Generated by Mochi v0.10.59 on 2025-08-06 22:18:19 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Token(var offset: BigInt, var length: BigInt, var indicator: String)

def token_to_string(t: Token): String = {
  return "(" + String.valueOf(t.asInstanceOf[Token].offset) + ", " + String.valueOf(t.asInstanceOf[Token].length) + ", " + t.asInstanceOf[Token].indicator + ")"
}

def tokens_to_string(ts: ArrayBuffer[Token]): String = {
  var res: String = "["
  var i: BigInt = 0
  while (i < BigInt((ts).size)) {
    res = res + token_to_string(ts((i.toInt).toInt))
    if (i < BigInt((ts).size) - 1) {
      res = res + ", "
    }
    i = i + 1
  }
  return res + "]"
}

def match_length_from_index(text: String, window: String, text_index: BigInt, window_index: BigInt): BigInt = {
  if ((text_index >= BigInt((text).size) || window_index >= BigInt((window).size)).asInstanceOf[Boolean]) {
    return 0
  }
  val tc: String = text.slice((text_index).toInt, (text_index + 1).toInt)
  val wc: String = window.slice((window_index).toInt, (window_index + 1).toInt)
  if (tc != wc) {
    return 0
  }
  return 1 + match_length_from_index(text, window + tc, text_index + 1, window_index + 1)
}

def find_encoding_token(text: String, search_buffer: String): Token = {
  if (BigInt((text).size) == 0) {
    throw new RuntimeException(String.valueOf("We need some text to work with."))
  }
  var length: BigInt = 0
  var offset: BigInt = 0
  if (BigInt((search_buffer).size) == 0) {
    return Token(offset, length, text.slice((0).toInt, (1).toInt))
  }
  var i: BigInt = 0
  while (i < BigInt((search_buffer).size)) {
    val ch: String = search_buffer.slice((i).toInt, (i + 1).toInt)
    val found_offset: BigInt = BigInt((search_buffer).size) - i
    if (ch == text.slice((0).toInt, (1).toInt)) {
      val found_length: BigInt = match_length_from_index(text, search_buffer, 0, i)
      if (found_length >= length) {
        offset = found_offset
        length = found_length
      }
    }
    i = i + 1
  }
  return Token(offset, length, text.slice((length).toInt, (length + 1).toInt))
}

def lz77_compress(text: String, window_size: BigInt, lookahead: BigInt): ArrayBuffer[Token] = {
  val search_buffer_size: BigInt = window_size - lookahead
  var output: ArrayBuffer[Token] = ArrayBuffer()
  var search_buffer: String = ""
  var remaining: String = text
  while (BigInt((remaining).size) > 0) {
    val token: Token = find_encoding_token(remaining, search_buffer)
    val add_len: BigInt = token.asInstanceOf[Token].length + 1
    search_buffer = search_buffer + remaining.slice((0).toInt, (add_len).toInt)
    if (BigInt((search_buffer).size) > search_buffer_size) {
      search_buffer = search_buffer.slice((BigInt((search_buffer).size) - search_buffer_size).toInt, (BigInt((search_buffer).size)).toInt)
    }
    remaining = remaining.slice((add_len).toInt, (BigInt((remaining).size)).toInt)
    output = output :+ token
  }
  return output
}

def lz77_decompress(tokens: ArrayBuffer[Token]): String = {
  var output: String = ""
  for (t <- tokens) {
    var i: BigInt = 0
    while (i < t.asInstanceOf[Token].length) {
      output = output + output.slice((BigInt((output).size) - t.asInstanceOf[Token].offset).toInt, (BigInt((output).size) - t.asInstanceOf[Token].offset + 1).toInt)
      i = i + 1
    }
    output = output + t.asInstanceOf[Token].indicator
  }
  return output
}

val c1: ArrayBuffer[Token] = lz77_compress("ababcbababaa", 13, 6)

val c2: ArrayBuffer[Token] = lz77_compress("aacaacabcabaaac", 13, 6)

val tokens_example: ArrayBuffer[Token] = ArrayBuffer(Token(0, 0, "c"), Token(0, 0, "a"), Token(0, 0, "b"), Token(0, 0, "r"), Token(3, 1, "c"), Token(2, 1, "d"), Token(7, 4, "r"), Token(3, 5, "d"))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(tokens_to_string(c1))
    println(tokens_to_string(c2))
    println(lz77_decompress(tokens_example))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
