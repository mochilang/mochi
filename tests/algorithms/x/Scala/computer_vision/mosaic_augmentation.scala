// Generated by Mochi v0.10.59 on 2025-08-06 22:14:05 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class MosaicResult(var img: ArrayBuffer[ArrayBuffer[BigInt]], var annos: ArrayBuffer[ArrayBuffer[Double]], var path: String)

def update_image_and_anno(all_img_list: ArrayBuffer[String], all_annos: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]], idxs: ArrayBuffer[BigInt], output_size: ArrayBuffer[BigInt], scale_range: ArrayBuffer[Double], filter_scale: Double): MosaicResult = {
  val height: BigInt = output_size((0.toInt).toInt)
  val width: BigInt = output_size((1.toInt).toInt)
  var output_img: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var r: BigInt = 0
  while (r < height) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var c: BigInt = 0
    while (c < width) {
      row = row :+ BigInt(0)
      c = c + 1
    }
    output_img = output_img :+ row
    r = r + 1
  }
  val scale_x: Double = (scale_range((0.toInt).toInt) + scale_range((1.toInt).toInt)) / 2.0
  val scale_y: Double = (scale_range((0.toInt).toInt) + scale_range((1.toInt).toInt)) / 2.0
  val divid_point_x: BigInt = (scale_x * width.toString.toDouble).toInt
  val divid_point_y: BigInt = (scale_y * height.toString.toDouble).toInt
  var new_anno: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
  var path_list: ArrayBuffer[String] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((idxs).size)) {
    val index: BigInt = idxs((i.toInt).toInt)
    val path: String = all_img_list((index.toInt).toInt)
    path_list = path_list :+ path
    val img_annos: ArrayBuffer[ArrayBuffer[Double]] = all_annos((index.toInt).toInt)
    if (i == 0) {
      var y0: BigInt = 0
      while (y0 < divid_point_y) {
        var x0: BigInt = 0
        while (x0 < divid_point_x) {
          output_img((y0).toInt)((x0).toInt) = i + 1
          x0 = x0 + 1
        }
        y0 = y0 + 1
      }
      var j0: BigInt = 0
      while (j0 < BigInt((img_annos).size)) {
        val bbox: ArrayBuffer[Double] = img_annos((j0.toInt).toInt)
        val xmin: Double = bbox((1.toInt).toInt) * scale_x
        val ymin: Double = bbox((2.toInt).toInt) * scale_y
        val xmax: Double = bbox((3.toInt).toInt) * scale_x
        val ymax: Double = bbox((4.toInt).toInt) * scale_y
        new_anno = new_anno :+ ArrayBuffer((bbox((0.toInt).toInt)).toString.toDouble, xmin.toString.toDouble, ymin.toString.toDouble, xmax.toString.toDouble, ymax.toString.toDouble)
        j0 = j0 + 1
      }
    } else {
      if (i == 1) {
        var y1: BigInt = 0
        while (y1 < divid_point_y) {
          var x1: BigInt = divid_point_x
          while (x1 < width) {
            output_img((y1).toInt)((x1).toInt) = i + 1
            x1 = x1 + 1
          }
          y1 = y1 + 1
        }
        var j1: BigInt = 0
        while (j1 < BigInt((img_annos).size)) {
          val bbox1: ArrayBuffer[Double] = img_annos((j1.toInt).toInt)
          val xmin1: Double = scale_x + bbox1((1.toInt).toInt) * (1.0 - scale_x)
          val ymin1: Double = bbox1((2.toInt).toInt) * scale_y
          val xmax1: Double = scale_x + bbox1((3.toInt).toInt) * (1.0 - scale_x)
          val ymax1: Double = bbox1((4.toInt).toInt) * scale_y
          new_anno = new_anno :+ ArrayBuffer((bbox1((0.toInt).toInt)).toString.toDouble, xmin1.toString.toDouble, ymin1.toString.toDouble, xmax1.toString.toDouble, ymax1.toString.toDouble)
          j1 = j1 + 1
        }
      } else {
        if (i == 2) {
          var y2: BigInt = divid_point_y
          while (y2 < height) {
            var x2: BigInt = 0
            while (x2 < divid_point_x) {
              output_img((y2).toInt)((x2).toInt) = i + 1
              x2 = x2 + 1
            }
            y2 = y2 + 1
          }
          var j2: BigInt = 0
          while (j2 < BigInt((img_annos).size)) {
            val bbox2: ArrayBuffer[Double] = img_annos((j2.toInt).toInt)
            val xmin2: Double = bbox2((1.toInt).toInt) * scale_x
            val ymin2: Double = scale_y + bbox2((2.toInt).toInt) * (1.0 - scale_y)
            val xmax2: Double = bbox2((3.toInt).toInt) * scale_x
            val ymax2: Double = scale_y + bbox2((4.toInt).toInt) * (1.0 - scale_y)
            new_anno = new_anno :+ ArrayBuffer((bbox2((0.toInt).toInt)).toString.toDouble, xmin2.toString.toDouble, ymin2.toString.toDouble, xmax2.toString.toDouble, ymax2.toString.toDouble)
            j2 = j2 + 1
          }
        } else {
          var y3: BigInt = divid_point_y
          while (y3 < height) {
            var x3: BigInt = divid_point_x
            while (x3 < width) {
              output_img((y3).toInt)((x3).toInt) = i + 1
              x3 = x3 + 1
            }
            y3 = y3 + 1
          }
          var j3: BigInt = 0
          while (j3 < BigInt((img_annos).size)) {
            val bbox3: ArrayBuffer[Double] = img_annos((j3.toInt).toInt)
            val xmin3: Double = scale_x + bbox3((1.toInt).toInt) * (1.0 - scale_x)
            val ymin3: Double = scale_y + bbox3((2.toInt).toInt) * (1.0 - scale_y)
            val xmax3: Double = scale_x + bbox3((3.toInt).toInt) * (1.0 - scale_x)
            val ymax3: Double = scale_y + bbox3((4.toInt).toInt) * (1.0 - scale_y)
            new_anno = new_anno :+ ArrayBuffer((bbox3((0.toInt).toInt)).toString.toDouble, xmin3.toString.toDouble, ymin3.toString.toDouble, xmax3.toString.toDouble, ymax3.toString.toDouble)
            j3 = j3 + 1
          }
        }
      }
    }
    i = i + 1
  }
  if (filter_scale > 0.0) {
    var filtered: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
    var k: BigInt = 0
    while (k < BigInt((new_anno).size)) {
      val anno: ArrayBuffer[Double] = new_anno((k.toInt).toInt)
      val w: Double = anno((3.toInt).toInt) - anno((1.toInt).toInt)
      val h: Double = anno((4.toInt).toInt) - anno((2.toInt).toInt)
      if ((filter_scale < w && filter_scale < h).asInstanceOf[Boolean]) {
        filtered = filtered :+ anno
      }
      k = k + 1
    }
    new_anno = filtered
  }
  return MosaicResult(output_img, new_anno, path_list((0.toInt).toInt))
}

def main(): Any = {
  val all_img_list: ArrayBuffer[String] = ArrayBuffer("img0.jpg", "img1.jpg", "img2.jpg", "img3.jpg")
  val all_annos: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]] = ArrayBuffer(ArrayBuffer(ArrayBuffer(0.0, 0.1, 0.1, 0.4, 0.4)), ArrayBuffer(ArrayBuffer(1.0, 0.2, 0.3, 0.5, 0.7)), ArrayBuffer(ArrayBuffer(2.0, 0.6, 0.2, 0.9, 0.5)), ArrayBuffer(ArrayBuffer(3.0, 0.5, 0.5, 0.8, 0.8)))
  val idxs: ArrayBuffer[BigInt] = ArrayBuffer(0, 1, 2, 3)
  val output_size: ArrayBuffer[BigInt] = ArrayBuffer(100, 100)
  val scale_range: ArrayBuffer[Double] = ArrayBuffer(0.4, 0.6)
  val filter_scale: Double = 0.05
  val res: MosaicResult = update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale)
  val new_annos: ArrayBuffer[ArrayBuffer[Double]] = res.asInstanceOf[MosaicResult].annos
  val path: String = res.asInstanceOf[MosaicResult].path
  println("Base image: " + path)
  println("Mosaic annotation count: " + String.valueOf(BigInt((new_annos).size)))
  var i: BigInt = 0
  while (i < BigInt((new_annos).size)) {
    val a: ArrayBuffer[Double] = new_annos((i.toInt).toInt)
    println(String.valueOf(a((0.toInt).toInt)) + " " + String.valueOf(a((1.toInt).toInt)) + " " + String.valueOf(a((2.toInt).toInt)) + " " + String.valueOf(a((3.toInt).toInt)) + " " + String.valueOf(a((4.toInt).toInt)))
    i = i + 1
  }
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
