// Generated by Mochi v0.10.59 on 2025-08-06 22:13:43 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def round_int(x: Double): BigInt = {
  if (x >= 0.0) {
    return (x + 0.5).toInt
  }
  return (x - 0.5).toInt
}

def zeros(rows: BigInt, cols: BigInt): ArrayBuffer[ArrayBuffer[Double]] = {
  var res: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
  var i: BigInt = 0
  while (i < rows) {
    var row: ArrayBuffer[Double] = ArrayBuffer()
    var j: BigInt = 0
    while (j < cols) {
      row = row :+ 0.0
      j = j + 1
    }
    res = res :+ row
    i = i + 1
  }
  return res
}

def warp(image: ArrayBuffer[ArrayBuffer[Double]], h_flow: ArrayBuffer[ArrayBuffer[Double]], v_flow: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[Double]] = {
  val h: BigInt = BigInt((image).size)
  val w: BigInt = BigInt((image((0.toInt).toInt)).size)
  var out: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[Double] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      val sx: BigInt = x - round_int(h_flow((y.toInt).toInt)((x.toInt).toInt))
      val sy: BigInt = y - round_int(v_flow((y.toInt).toInt)((x.toInt).toInt))
      if ((((sx >= 0 && sx < w).asInstanceOf[Boolean] && sy >= 0).asInstanceOf[Boolean] && sy < h).asInstanceOf[Boolean]) {
        row = row :+ image((sy.toInt).toInt)((sx.toInt).toInt)
      } else {
        row = row :+ 0.0
      }
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def convolve(img: ArrayBuffer[ArrayBuffer[Double]], ker: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[Double]] = {
  val h: BigInt = BigInt((img).size)
  val w: BigInt = BigInt((img((0.toInt).toInt)).size)
  val kh: BigInt = BigInt((ker).size)
  val kw: BigInt = BigInt((ker((0.toInt).toInt)).size)
  val py: BigInt = kh / 2
  val px: BigInt = kw / 2
  var out: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
  var y: BigInt = 0
  while (y < h) {
    var row: ArrayBuffer[Double] = ArrayBuffer()
    var x: BigInt = 0
    while (x < w) {
      var s: Double = 0.0
      var ky: BigInt = 0
      while (ky < kh) {
        var kx: BigInt = 0
        while (kx < kw) {
          val iy: BigInt = y + ky - py
          val ix: BigInt = x + kx - px
          if ((((iy >= 0 && iy < h).asInstanceOf[Boolean] && ix >= 0).asInstanceOf[Boolean] && ix < w).asInstanceOf[Boolean]) {
            s = s + img((iy.toInt).toInt)((ix.toInt).toInt) * ker((ky.toInt).toInt)((kx.toInt).toInt)
          }
          kx = kx + 1
        }
        ky = ky + 1
      }
      row = row :+ s
      x = x + 1
    }
    out = out :+ row
    y = y + 1
  }
  return out
}

def horn_schunck(image0: ArrayBuffer[ArrayBuffer[Double]], image1: ArrayBuffer[ArrayBuffer[Double]], num_iter: BigInt, alpha: Double): ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]] = {
  val h: BigInt = BigInt((image0).size)
  val w: BigInt = BigInt((image0((0.toInt).toInt)).size)
  var u: ArrayBuffer[ArrayBuffer[Double]] = zeros(h, w)
  var v: ArrayBuffer[ArrayBuffer[Double]] = zeros(h, w)
  val kernel_x: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(-0.25, 0.25), ArrayBuffer(-0.25, 0.25))
  val kernel_y: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(-0.25, -0.25), ArrayBuffer(0.25, 0.25))
  val kernel_t: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.25, 0.25), ArrayBuffer(0.25, 0.25))
  val laplacian: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.0833333333333, 0.166666666667, 0.0833333333333), ArrayBuffer(0.166666666667, 0.0, 0.166666666667), ArrayBuffer(0.0833333333333, 0.166666666667, 0.0833333333333))
  var it: BigInt = 0
  while (it < num_iter) {
    val warped: ArrayBuffer[ArrayBuffer[Double]] = warp(image0, u, v)
    val dx1: ArrayBuffer[ArrayBuffer[Double]] = convolve(warped, kernel_x)
    val dx2: ArrayBuffer[ArrayBuffer[Double]] = convolve(image1, kernel_x)
    val dy1: ArrayBuffer[ArrayBuffer[Double]] = convolve(warped, kernel_y)
    val dy2: ArrayBuffer[ArrayBuffer[Double]] = convolve(image1, kernel_y)
    val dt1: ArrayBuffer[ArrayBuffer[Double]] = convolve(warped, kernel_t)
    val dt2: ArrayBuffer[ArrayBuffer[Double]] = convolve(image1, kernel_t)
    val avg_u: ArrayBuffer[ArrayBuffer[Double]] = convolve(u, laplacian)
    val avg_v: ArrayBuffer[ArrayBuffer[Double]] = convolve(v, laplacian)
    var y: BigInt = 0
    while (y < h) {
      var x: BigInt = 0
      while (x < w) {
        val dx: Double = dx1((y.toInt).toInt)((x.toInt).toInt) + dx2((y.toInt).toInt)((x.toInt).toInt)
        val dy: Double = dy1((y.toInt).toInt)((x.toInt).toInt) + dy2((y.toInt).toInt)((x.toInt).toInt)
        val dt: Double = dt1((y.toInt).toInt)((x.toInt).toInt) - dt2((y.toInt).toInt)((x.toInt).toInt)
        val au: Double = avg_u((y.toInt).toInt)((x.toInt).toInt)
        val av: Double = avg_v((y.toInt).toInt)((x.toInt).toInt)
        val numer: Double = dx * au + dy * av + dt
        val denom: Double = alpha * alpha + dx * dx + dy * dy
        val upd: Double = numer / denom
        u((y).toInt)((x).toInt) = au - dx * upd
        v((y).toInt)((x).toInt) = av - dy * upd
        x = x + 1
      }
      y = y + 1
    }
    it = it + 1
  }
  return ArrayBuffer(u, v)
}

def print_matrix(mat: ArrayBuffer[ArrayBuffer[Double]]): Any = {
  var y: BigInt = 0
  while (y < BigInt((mat).size)) {
    var row: ArrayBuffer[Double] = mat((y.toInt).toInt)
    var x: BigInt = 0
    var line: String = ""
    while (x < BigInt((row).size)) {
      line = line + String.valueOf(round_int(row((x.toInt).toInt)))
      if (x + 1 < BigInt((row).size)) {
        line = line + " "
      }
      x = x + 1
    }
    println(line)
    y = y + 1
  }
}

def main(): Any = {
  val image0: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.0, 0.0, 2.0), ArrayBuffer(0.0, 0.0, 2.0))
  val image1: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.0, 2.0, 0.0), ArrayBuffer(0.0, 2.0, 0.0))
  val flows: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]] = horn_schunck(image0, image1, 20, 0.1)
  val u: ArrayBuffer[ArrayBuffer[Double]] = flows((0.toInt).toInt)
  val v: ArrayBuffer[ArrayBuffer[Double]] = flows((1.toInt).toInt)
  print_matrix(u)
  println("---")
  print_matrix(v)
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
