// Generated by Mochi v0.10.63 on 2025-08-11 18:48:21 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

sealed trait Tree
case class Leaf(var prediction: Double) extends Tree
case class Branch(var decision_boundary: Double, var left: Tree, var right: Tree) extends Tree


def _mod(x: Double, m: Double): Double = {
  return x - (BigInt((x / m).toString.head.asDigit)).toDouble * m
}

def sin(x: Double): Double = {
  val y: Double = _mod(x + PI, TWO_PI) - PI
  val y2: Double = y * y
  val y3: Double = y2 * y
  val y5: Double = y3 * y2
  val y7: Double = y5 * y2
  return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
}

def rand(): Double = {
  seed = (BigInt(1103515245) * seed + BigInt(12345)) % BigInt("2147483648")
  return seed.toDouble / 2147483648.0
}

def mean(vals: ArrayBuffer[Double]): Double = {
  var sum: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((vals).size)) {
    sum = sum + vals.lift((i.toInt).toInt).getOrElse(0.0)
    i = i + BigInt(1)
  }
  return sum / (BigInt((vals).size)).toDouble
}

def mean_squared_error(labels: ArrayBuffer[Double], prediction: Double): Double = {
  var total: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((labels).size)) {
    val diff: Double = labels.lift((i.toInt).toInt).getOrElse(0.0) - prediction
    total = total + diff * diff
    i = i + BigInt(1)
  }
  return total / (BigInt((labels).size)).toDouble
}

def train_tree(x: ArrayBuffer[Double], y: ArrayBuffer[Double], depth: BigInt, min_leaf_size: BigInt): Tree = {
  if (BigInt((x).size) < BigInt(2) * min_leaf_size) {
    return (Leaf(mean(y))).asInstanceOf[Tree]
  }
  if (depth == BigInt(1)) {
    return (Leaf(mean(y))).asInstanceOf[Tree]
  }
  var best_split: BigInt = BigInt(0)
  var min_error: Double = mean_squared_error(x, mean(y)) * 2.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((x).size)) {
    if (BigInt((x.slice((BigInt(0)).toInt, (i).toInt)).size) < min_leaf_size) {
      i = i
    } else {
      if (BigInt((x.slice((i).toInt, (BigInt((x).size)).toInt)).size) < min_leaf_size) {
        i = i
      } else {
        val err_left: Double = mean_squared_error(x.slice((BigInt(0)).toInt, (i).toInt), mean(y.slice((BigInt(0)).toInt, (i).toInt)))
        val err_right: Double = mean_squared_error(x.slice((i).toInt, (BigInt((x).size)).toInt), mean(y.slice((i).toInt, (BigInt((y).size)).toInt)))
        val err: Double = err_left + err_right
        if (err < min_error) {
          best_split = i
          min_error = err
        }
      }
    }
    i = i + BigInt(1)
  }
  if (best_split != BigInt(0)) {
    val left_x: ArrayBuffer[Double] = x.slice((BigInt(0)).toInt, (best_split).toInt)
    val left_y: ArrayBuffer[Double] = y.slice((BigInt(0)).toInt, (best_split).toInt)
    val right_x: ArrayBuffer[Double] = x.slice((best_split).toInt, (BigInt((x).size)).toInt)
    val right_y: ArrayBuffer[Double] = y.slice((best_split).toInt, (BigInt((y).size)).toInt)
    val boundary: Double = x.lift((best_split.toInt).toInt).getOrElse(0.0)
    val left_tree: Any = train_tree(left_x, left_y, depth - BigInt(1), min_leaf_size)
    val right_tree: Any = train_tree(right_x, right_y, depth - BigInt(1), min_leaf_size)
    return (Branch(boundary, left_tree, right_tree)).asInstanceOf[Tree]
  }
  return (Leaf(mean(y))).asInstanceOf[Tree]
}

def predict(tree: Tree, value: Double): Double = {
  return (tree match { case Leaf(p) => p case Branch(b, l, r) => (if (value >= b) predict(r, value) else predict(l, value)) }).toString.toDouble
}

def main(): Any = {
  var x: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var v: Double = -1.0
  while (v < 1.0) {
    x = x :+ (v)
    v = v + 0.005
  }
  var y: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((x).size)) {
    y = y :+ (sin(x.lift((i.toInt).toInt).getOrElse(0.0)))
    i = i + BigInt(1)
  }
  val tree: Any = train_tree(x, y, BigInt(10), BigInt(10))
  var test_cases: ArrayBuffer[Double] = ArrayBuffer[Double]()
  i = BigInt(0)
  while (i < BigInt(10)) {
    test_cases = test_cases :+ (rand() * 2.0 - 1.0)
    i = i + BigInt(1)
  }
  var predictions: ArrayBuffer[Double] = ArrayBuffer[Double]()
  i = BigInt(0)
  while (i < BigInt((test_cases).size)) {
    predictions = predictions :+ (predict(tree.asInstanceOf[Tree], test_cases.lift((i.toInt).toInt).getOrElse(0.0)))
    i = i + BigInt(1)
  }
  var sum_err: Double = 0.0
  i = BigInt(0)
  while (i < BigInt((test_cases).size)) {
    val diff: Double = predictions.lift((i.toInt).toInt).getOrElse(0.0) - test_cases.lift((i.toInt).toInt).getOrElse(0.0)
    sum_err = sum_err + diff * diff
    i = i + BigInt(1)
  }
  val avg_error: Double = sum_err / (BigInt((test_cases).size)).toDouble
  println("Test values: " + _str(test_cases))
  println("Predictions: " + _str(predictions))
  println("Average error: " + _str(avg_error))
}

val PI: Double = 3.141592653589793

val TWO_PI: Double = 6.283185307179586

var seed: BigInt = BigInt(123456789)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
