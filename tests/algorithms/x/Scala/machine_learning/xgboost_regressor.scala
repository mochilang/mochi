// Generated by Mochi v0.10.59 on 2025-08-07 12:45:52 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Dataset(var data: ArrayBuffer[ArrayBuffer[Double]], var target: ArrayBuffer[Double])

case class Tree(var threshold: Double, var left_value: Double, var right_value: Double)

def data_handling(dataset: Dataset): Dataset = {
  return dataset
}

def xgboost(features: ArrayBuffer[ArrayBuffer[Double]], target: ArrayBuffer[Double], test_features: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[Double] = {
  val learning_rate: Double = 0.5
  val n_estimators: BigInt = BigInt(3)
  var trees: ArrayBuffer[Tree] = ArrayBuffer[Tree]()
  var predictions: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((target).size)) {
    predictions = predictions :+ 0.0
    i = i + BigInt(1)
  }
  var est: BigInt = BigInt(0)
  while (est < n_estimators) {
    var residuals: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((target).size)) {
      residuals = residuals :+ target((j.toInt).toInt) - predictions((j.toInt).toInt)
      j = j + BigInt(1)
    }
    var sum_feat: Double = 0.0
    j = BigInt(0)
    while (j < BigInt((features).size)) {
      sum_feat = sum_feat + features((j.toInt).toInt)((BigInt(0).toInt).toInt)
      j = j + BigInt(1)
    }
    val threshold: Double = sum_feat / (BigInt((features).size)).toString.toDouble
    var left_sum: Double = 0.0
    var left_count: BigInt = BigInt(0)
    var right_sum: Double = 0.0
    var right_count: BigInt = BigInt(0)
    j = BigInt(0)
    while (j < BigInt((features).size)) {
      if (features((j.toInt).toInt)((BigInt(0).toInt).toInt) <= threshold) {
        left_sum = left_sum + residuals((j.toInt).toInt)
        left_count = left_count + BigInt(1)
      } else {
        right_sum = right_sum + residuals((j.toInt).toInt)
        right_count = right_count + BigInt(1)
      }
      j = j + BigInt(1)
    }
    var left_value: Double = 0.0
    if (left_count > BigInt(0)) {
      left_value = left_sum / left_count.toString.toDouble
    }
    var right_value: Double = 0.0
    if (right_count > BigInt(0)) {
      right_value = right_sum / right_count.toString.toDouble
    }
    j = BigInt(0)
    while (j < BigInt((features).size)) {
      if (features((j.toInt).toInt)((BigInt(0).toInt).toInt) <= threshold) {
        predictions((j).toInt) = predictions((j.toInt).toInt) + learning_rate * left_value
      } else {
        predictions((j).toInt) = predictions((j.toInt).toInt) + learning_rate * right_value
      }
      j = j + BigInt(1)
    }
    trees = trees :+ Tree(threshold, left_value, right_value)
    est = est + BigInt(1)
  }
  var preds: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var t: BigInt = BigInt(0)
  while (t < BigInt((test_features).size)) {
    var pred: Double = 0.0
    var k: BigInt = BigInt(0)
    while (k < BigInt((trees).size)) {
      if (test_features((t.toInt).toInt)((BigInt(0).toInt).toInt) <= trees((k.toInt).toInt).threshold) {
        pred = pred + learning_rate * trees((k.toInt).toInt).left_value
      } else {
        pred = pred + learning_rate * trees((k.toInt).toInt).right_value
      }
      k = k + BigInt(1)
    }
    preds = preds :+ pred
    t = t + BigInt(1)
  }
  return preds
}

def mean_absolute_error(y_true: ArrayBuffer[Double], y_pred: ArrayBuffer[Double]): Double = {
  var sum: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((y_true).size)) {
    var diff: Double = y_true((i.toInt).toInt) - y_pred((i.toInt).toInt)
    if (diff < 0.0) {
      diff = -diff
    }
    sum = sum + diff
    i = i + BigInt(1)
  }
  return sum / (BigInt((y_true).size)).toString.toDouble
}

def mean_squared_error(y_true: ArrayBuffer[Double], y_pred: ArrayBuffer[Double]): Double = {
  var sum: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((y_true).size)) {
    val diff: Double = y_true((i.toInt).toInt) - y_pred((i.toInt).toInt)
    sum = sum + diff * diff
    i = i + BigInt(1)
  }
  return sum / (BigInt((y_true).size)).toString.toDouble
}

def main(): Any = {
  val california: Dataset = Dataset(ArrayBuffer(ArrayBuffer(1.0), ArrayBuffer(2.0), ArrayBuffer(3.0), ArrayBuffer(4.0)), ArrayBuffer(2.0, 3.0, 4.0, 5.0))
  val ds: Dataset = data_handling(california)
  val x_train: ArrayBuffer[ArrayBuffer[Double]] = ds.asInstanceOf[Dataset].data
  val y_train: ArrayBuffer[Double] = ds.asInstanceOf[Dataset].target
  val x_test: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(1.5), ArrayBuffer(3.5))
  val y_test: ArrayBuffer[Double] = ArrayBuffer(2.5, 4.5)
  val predictions: ArrayBuffer[Double] = xgboost(x_train, y_train, x_test)
  println("Predictions:")
  println(predictions)
  println("Mean Absolute Error:")
  println(mean_absolute_error(y_test, predictions))
  println("Mean Square Error:")
  println(mean_squared_error(y_test, predictions))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
