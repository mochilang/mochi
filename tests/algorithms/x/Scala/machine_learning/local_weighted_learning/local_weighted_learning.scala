// Generated by Mochi v0.10.59 on 2025-08-07 12:44:01 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def expApprox(x: Double): Double = {
  if (x < 0.0) {
    return 1.0 / expApprox(-x)
  }
  if (x > 1.0) {
    val half: Double = expApprox(x / 2.0)
    return half * half
  }
  var sum: Double = 1.0
  var term: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n < BigInt(20)) {
    term = term * x / n.toString.toDouble
    sum = sum + term
    n = n + BigInt(1)
  }
  return sum
}

def transpose(mat: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[Double]] = {
  val rows: BigInt = BigInt((mat).size)
  val cols: BigInt = BigInt((mat((BigInt(0).toInt).toInt)).size)
  var res: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < cols) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < rows) {
      row = row :+ mat((j.toInt).toInt)((i.toInt).toInt)
      j = j + BigInt(1)
    }
    res = res :+ row
    i = i + BigInt(1)
  }
  return res
}

def matMul(a: ArrayBuffer[ArrayBuffer[Double]], b: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[Double]] = {
  val a_rows: BigInt = BigInt((a).size)
  val a_cols: BigInt = BigInt((a((BigInt(0).toInt).toInt)).size)
  val b_cols: BigInt = BigInt((b((BigInt(0).toInt).toInt)).size)
  var res: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < a_rows) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < b_cols) {
      var sum: Double = 0.0
      var k: BigInt = BigInt(0)
      while (k < a_cols) {
        sum = sum + a((i.toInt).toInt)((k.toInt).toInt) * b((k.toInt).toInt)((j.toInt).toInt)
        k = k + BigInt(1)
      }
      row = row :+ sum
      j = j + BigInt(1)
    }
    res = res :+ row
    i = i + BigInt(1)
  }
  return res
}

def matInv(mat: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[Double]] = {
  val n: BigInt = BigInt((mat).size)
  var aug: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < n) {
      row = row :+ mat((i.toInt).toInt)((j.toInt).toInt)
      j = j + BigInt(1)
    }
    j = BigInt(0)
    while (j < n) {
      if (i == j) {
        row = row :+ 1.0
      } else {
        row = row :+ 0.0
      }
      j = j + BigInt(1)
    }
    aug = aug :+ row
    i = i + BigInt(1)
  }
  var col: BigInt = BigInt(0)
  while (col < n) {
    val pivot: Double = aug((col.toInt).toInt)((col.toInt).toInt)
    if (pivot == 0.0) {
      throw new RuntimeException(String.valueOf("Matrix is singular"))
    }
    var j: BigInt = BigInt(0)
    while (j < BigInt(2) * n) {
      aug((col).toInt)((j).toInt) = aug((col.toInt).toInt)((j.toInt).toInt) / pivot
      j = j + BigInt(1)
    }
    var r: BigInt = BigInt(0)
    while (r < n) {
      if (r != col) {
        val factor: Double = aug((r.toInt).toInt)((col.toInt).toInt)
        j = BigInt(0)
        while (j < BigInt(2) * n) {
          aug((r).toInt)((j).toInt) = aug((r.toInt).toInt)((j.toInt).toInt) - factor * aug((col.toInt).toInt)((j.toInt).toInt)
          j = j + BigInt(1)
        }
      }
      r = r + BigInt(1)
    }
    col = col + BigInt(1)
  }
  var inv: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  i = BigInt(0)
  while (i < n) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < n) {
      row = row :+ aug((i.toInt).toInt)(((j + n).toInt).toInt)
      j = j + BigInt(1)
    }
    inv = inv :+ row
    i = i + BigInt(1)
  }
  return inv
}

def weight_matrix(point: ArrayBuffer[Double], x_train: ArrayBuffer[ArrayBuffer[Double]], tau: Double): ArrayBuffer[ArrayBuffer[Double]] = {
  val m: BigInt = BigInt((x_train).size)
  var weights: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < m) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < m) {
      if (i == j) {
        row = row :+ 1.0
      } else {
        row = row :+ 0.0
      }
      j = j + BigInt(1)
    }
    weights = weights :+ row
    i = i + BigInt(1)
  }
  var j: BigInt = BigInt(0)
  while (j < m) {
    var diff_sq: Double = 0.0
    var k: BigInt = BigInt(0)
    while (k < BigInt((point).size)) {
      val diff: Double = point((k.toInt).toInt) - x_train((j.toInt).toInt)((k.toInt).toInt)
      diff_sq = diff_sq + diff * diff
      k = k + BigInt(1)
    }
    weights((j).toInt)((j).toInt) = expApprox(-diff_sq / (2.0 * tau * tau))
    j = j + BigInt(1)
  }
  return weights
}

def local_weight(point: ArrayBuffer[Double], x_train: ArrayBuffer[ArrayBuffer[Double]], y_train: ArrayBuffer[Double], tau: Double): ArrayBuffer[ArrayBuffer[Double]] = {
  val w: ArrayBuffer[ArrayBuffer[Double]] = weight_matrix(point, x_train, tau)
  val x_t: ArrayBuffer[ArrayBuffer[Double]] = transpose(x_train)
  val x_t_w: ArrayBuffer[ArrayBuffer[Double]] = matMul(x_t, w)
  val x_t_w_x: ArrayBuffer[ArrayBuffer[Double]] = matMul(x_t_w, x_train)
  val inv_part: ArrayBuffer[ArrayBuffer[Double]] = matInv(x_t_w_x)
  var y_col: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((y_train).size)) {
    y_col = y_col :+ ArrayBuffer(y_train((i.toInt).toInt))
    i = i + BigInt(1)
  }
  val x_t_w_y: ArrayBuffer[ArrayBuffer[Double]] = matMul(x_t_w, y_col)
  return matMul(inv_part, x_t_w_y)
}

def local_weight_regression(x_train: ArrayBuffer[ArrayBuffer[Double]], y_train: ArrayBuffer[Double], tau: Double): ArrayBuffer[Double] = {
  val m: BigInt = BigInt((x_train).size)
  var preds: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < m) {
    val theta: ArrayBuffer[ArrayBuffer[Double]] = local_weight(x_train((i.toInt).toInt), x_train, y_train, tau)
    var weights_vec: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var k: BigInt = BigInt(0)
    while (k < BigInt((theta).size)) {
      weights_vec = weights_vec :+ theta((k.toInt).toInt)((BigInt(0).toInt).toInt)
      k = k + BigInt(1)
    }
    var pred: Double = 0.0
    var j: BigInt = BigInt(0)
    while (j < BigInt((x_train((i.toInt).toInt)).size)) {
      pred = pred + x_train((i.toInt).toInt)((j.toInt).toInt) * weights_vec((j.toInt).toInt)
      j = j + BigInt(1)
    }
    preds = preds :+ pred
    i = i + BigInt(1)
  }
  return preds
}

val x_train: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(16.99, 10.34), ArrayBuffer(21.01, 23.68), ArrayBuffer(24.59, 25.69))

val y_train: ArrayBuffer[Double] = ArrayBuffer(1.01, 1.66, 3.5)

val preds: ArrayBuffer[Double] = local_weight_regression(x_train, y_train, 0.6)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(toJson(preds))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
