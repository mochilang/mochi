// Generated by Mochi v0.10.59 on 2025-08-07 12:45:37 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def to_lowercase(s: String): String = {
  var res: String = ""
  var i: BigInt = BigInt(0)
  val _br0 = new Breaks
  _br0.breakable {
    while (i < BigInt((s).size)) {
      val c = s.slice((i.toInt).toInt, (i.toInt).toInt + 1)
      var j: BigInt = BigInt(0)
      var found: Boolean = false
      val _br1 = new Breaks
      _br1.breakable {
        while (j < BigInt((UPPER).length)) {
          if (c == UPPER.slice((j.toInt).toInt, (j.toInt).toInt + 1)) {
            res = res + LOWER.slice((j.toInt).toInt, (j.toInt).toInt + 1)
            found = true
            _br1.break()
          }
          j = j + BigInt(1)
        }
      }
      if (!found) {
        res = res + c
      }
      i = i + BigInt(1)
    }
  }
  return res
}

def is_punct(c: String): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((PUNCT).length)) {
    if (c == PUNCT.slice((i.toInt).toInt, (i.toInt).toInt + 1)) {
      return true
    }
    i = i + BigInt(1)
  }
  return false
}

def clean_text(text: String, keep_newlines: Boolean): String = {
  val lower: String = to_lowercase(text)
  var res: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((lower).size)) {
    val ch = lower.slice((i.toInt).toInt, (i.toInt).toInt + 1)
    if (is_punct(ch)) {
    } else {
      if (ch == "\n") {
        if (keep_newlines) {
          res = res + "\n"
        }
      } else {
        res = res + ch
      }
    }
    i = i + BigInt(1)
  }
  return res
}

def split(s: String, sep: String): ArrayBuffer[String] = {
  var res: ArrayBuffer[String] = ArrayBuffer[String]()
  var current: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).size)) {
    val ch = s.slice((i.toInt).toInt, (i.toInt).toInt + 1)
    if (ch == sep) {
      res = res :+ current
      current = ""
    } else {
      current = current + ch
    }
    i = i + BigInt(1)
  }
  res = res :+ current
  return res
}

def contains(s: String, sub: String): Boolean = {
  val n: BigInt = BigInt((s).size)
  val m: BigInt = BigInt((sub).size)
  if (m == BigInt(0)) {
    return true
  }
  var i: BigInt = BigInt(0)
  val _br5 = new Breaks
  _br5.breakable {
    while (i <= n - m) {
      var j: BigInt = BigInt(0)
      var is_match: Boolean = true
      val _br6 = new Breaks
      _br6.breakable {
        while (j < m) {
          if (s.slice(((i + j).toInt).toInt, ((i + j).toInt).toInt + 1) != sub.slice((j.toInt).toInt, (j.toInt).toInt + 1)) {
            is_match = false
            _br6.break()
          }
          j = j + BigInt(1)
        }
      }
      if (is_match) {
        return true
      }
      i = i + BigInt(1)
    }
  }
  return false
}

def floor(x: Double): Double = {
  var i: BigInt = BigInt(x.toString.toDouble.toInt)
  if ((i.toString.toDouble).toString.toDouble > x) {
    i = i - BigInt(1)
  }
  return i.toString.toDouble
}

def round3(x: Double): Double = {
  return Math.floor(x * 1000.0 + 0.5) / 1000.0
}

def ln(x: Double): Double = {
  val t: Double = (x - 1.0) / (x + 1.0)
  var term: Double = t
  var sum: Double = 0.0
  var k: BigInt = BigInt(1)
  while (k <= BigInt(99)) {
    sum = sum + term / k.toString.toDouble
    term = term * t * t
    k = k + BigInt(2)
  }
  return 2.0 * sum
}

def log10(x: Double): Double = {
  return ln(x) / ln(10.0)
}

def term_frequency(term: String, document: String): BigInt = {
  val clean: String = clean_text(document, false)
  val tokens = ArrayBuffer(clean.split(" "): _*)
  val t: String = to_lowercase(term)
  var count: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((tokens).size)) {
    if ((tokens((i.toInt).toInt) != "" && tokens((i.toInt).toInt) == t).asInstanceOf[Boolean]) {
      count = count + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return count
}

def document_frequency(term: String, corpus: String): ArrayBuffer[BigInt] = {
  val clean: String = clean_text(corpus, true)
  val docs = ArrayBuffer(clean.split("\n"): _*)
  val t: String = to_lowercase(term)
  var matches: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((docs).size)) {
    if ((docs((i.toInt).toInt).contains(t)).asInstanceOf[Boolean]) {
      matches = matches + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return ArrayBuffer(matches, BigInt((docs).size))
}

def inverse_document_frequency(df: BigInt, n: BigInt, smoothing: Boolean): Double = {
  if (smoothing) {
    if (n == BigInt(0)) {
      throw new RuntimeException(String.valueOf("log10(0) is undefined."))
    }
    val ratio: Double = n.toString.toDouble / (1.0 + df.toString.toDouble)
    val l: Double = log10(ratio)
    val result: Double = round3(1.0 + l)
    println(result)
    return result
  }
  if (df == BigInt(0)) {
    throw new RuntimeException(String.valueOf("df must be > 0"))
  }
  if (n == BigInt(0)) {
    throw new RuntimeException(String.valueOf("log10(0) is undefined."))
  }
  val ratio: Double = n.toString.toDouble / df.toString.toDouble
  val l: Double = log10(ratio)
  val result: Double = round3(l)
  println(result)
  return result
}

def tf_idf(tf: BigInt, idf: Double): Double = {
  val prod: Double = tf.toString.toDouble * idf
  val result: Double = round3(prod)
  println(result)
  return result
}

val LOWER: String = "abcdefghijklmnopqrstuvwxyz"

val UPPER: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

val PUNCT: String = "!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~"

val corpus: String = "This is the first document in the corpus.\nThIs is the second document in the corpus.\nTHIS is the third document in the corpus."

val idf_val: Double = inverse_document_frequency(BigInt(1), BigInt(3), false)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(term_frequency("to", "To be, or not to be"))
    println(String.valueOf(document_frequency("first", corpus)))
    tf_idf(BigInt(2), idf_val)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
