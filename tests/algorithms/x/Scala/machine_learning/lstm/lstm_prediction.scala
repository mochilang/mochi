// Generated by Mochi v0.10.67 on 2025-08-16 21:30:49 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case m: scala.collection.Map[_, _] => scala.collection.immutable.ListMap(m.toSeq.sortBy(_._1.toString): _*).toString.replace("ListMap", "Map")
  case d: Double => { val s = java.lang.Double.toString(d); if (s.indexOf('.') < 0 && !s.contains("e") && !s.contains("E")) s + ".0" else s }
  case other => String.valueOf(other)
}

case class LSTMWeights(var w_i: Double, var u_i: Double, var b_i: Double, var w_f: Double, var u_f: Double, var b_f: Double, var w_o: Double, var u_o: Double, var b_o: Double, var w_c: Double, var u_c: Double, var b_c: Double, var w_y: Double, var b_y: Double)

case class LSTMState(var i: ArrayBuffer[Double], var f: ArrayBuffer[Double], var o: ArrayBuffer[Double], var g: ArrayBuffer[Double], var c: ArrayBuffer[Double], var h: ArrayBuffer[Double])

case class Samples(var x: ArrayBuffer[ArrayBuffer[Double]], var y: ArrayBuffer[Double])

def exp_approx(x: Double): Double = {
  var sum: Double = 1.0
  var term: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n < BigInt(20)) {
    term = term * x / n.toString.toDouble
    sum = sum + term
    n = n + BigInt(1)
  }
  return sum
}

def sigmoid(x: Double): Double = {
  return 1.0 / (1.0 + exp_approx(-x))
}

def tanh_approx(x: Double): Double = {
  var e: Double = exp_approx(2.0 * x)
  return (e - 1.0) / (e + 1.0)
}

def forward(seq: ArrayBuffer[Double], w: LSTMWeights): LSTMState = {
  var i_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var f_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var o_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var g_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var c_arr: ArrayBuffer[Double] = ArrayBuffer(0.0)
  var h_arr: ArrayBuffer[Double] = ArrayBuffer(0.0)
  var t: BigInt = BigInt(0)
  while (t < BigInt((seq).size)) {
    var x: Double = seq.lift((t.toInt).toInt).getOrElse(0.0)
    var h_prev: Double = h_arr.lift((t.toInt).toInt).getOrElse(0.0)
    var c_prev: Double = c_arr.lift((t.toInt).toInt).getOrElse(0.0)
    var i_t: Double = sigmoid(w.w_i * x + w.u_i * h_prev + w.b_i)
    var f_t: Double = sigmoid(w.w_f * x + w.u_f * h_prev + w.b_f)
    var o_t: Double = sigmoid(w.w_o * x + w.u_o * h_prev + w.b_o)
    var g_t: Double = tanh_approx(w.w_c * x + w.u_c * h_prev + w.b_c)
    var c_t: Double = f_t * c_prev + i_t * g_t
    var h_t: Double = o_t * tanh_approx(c_t)
    i_arr = (i_arr :+ i_t)
    f_arr = (f_arr :+ f_t)
    o_arr = (o_arr :+ o_t)
    g_arr = (g_arr :+ g_t)
    c_arr = (c_arr :+ c_t)
    h_arr = (h_arr :+ h_t)
    t = t + BigInt(1)
  }
  return LSTMState(i_arr, f_arr, o_arr, g_arr, c_arr, h_arr)
}

def backward(seq: ArrayBuffer[Double], target: Double, w: LSTMWeights, s: LSTMState, lr: Double): LSTMWeights = {
  var dw_i: Double = 0.0
  var du_i: Double = 0.0
  var db_i: Double = 0.0
  var dw_f: Double = 0.0
  var du_f: Double = 0.0
  var db_f: Double = 0.0
  var dw_o: Double = 0.0
  var du_o: Double = 0.0
  var db_o: Double = 0.0
  var dw_c: Double = 0.0
  var du_c: Double = 0.0
  var db_c: Double = 0.0
  var dw_y: Double = 0.0
  var db_y: Double = 0.0
  var T: BigInt = BigInt((seq).size)
  var h_last: Double = s.asInstanceOf[LSTMState].h.lift((T.toInt).toInt).getOrElse(0.0)
  var y: Double = w.w_y * h_last + w.b_y
  var dy: Double = y - target
  dw_y = dy * h_last
  db_y = dy
  var dh_next: Double = dy * w.w_y
  var dc_next: Double = 0.0
  var t: BigInt = T - BigInt(1)
  while (t >= BigInt(0)) {
    var i_t: Double = s.asInstanceOf[LSTMState].i.lift((t.toInt).toInt).getOrElse(0.0)
    var f_t: Double = s.asInstanceOf[LSTMState].f.lift((t.toInt).toInt).getOrElse(0.0)
    var o_t: Double = s.asInstanceOf[LSTMState].o.lift((t.toInt).toInt).getOrElse(0.0)
    var g_t: Double = s.asInstanceOf[LSTMState].g.lift((t.toInt).toInt).getOrElse(0.0)
    var c_t: Double = s.asInstanceOf[LSTMState].c.lift(((t + BigInt(1)).toInt).toInt).getOrElse(0.0)
    var c_prev: Double = s.asInstanceOf[LSTMState].c.lift((t.toInt).toInt).getOrElse(0.0)
    var h_prev: Double = s.asInstanceOf[LSTMState].h.lift((t.toInt).toInt).getOrElse(0.0)
    var tanh_c: Double = tanh_approx(c_t)
    var do_t: Double = dh_next * tanh_c
    var da_o: Double = do_t * o_t * (1.0 - o_t)
    var dc: Double = dh_next * o_t * (1.0 - tanh_c * tanh_c) + dc_next
    var di_t: Double = dc * g_t
    var da_i: Double = di_t * i_t * (1.0 - i_t)
    var dg_t: Double = dc * i_t
    var da_g: Double = dg_t * (1.0 - g_t * g_t)
    var df_t: Double = dc * c_prev
    var da_f: Double = df_t * f_t * (1.0 - f_t)
    dw_i = dw_i + da_i * seq.lift((t.toInt).toInt).getOrElse(0.0)
    du_i = du_i + da_i * h_prev
    db_i = db_i + da_i
    dw_f = dw_f + da_f * seq.lift((t.toInt).toInt).getOrElse(0.0)
    du_f = du_f + da_f * h_prev
    db_f = db_f + da_f
    dw_o = dw_o + da_o * seq.lift((t.toInt).toInt).getOrElse(0.0)
    du_o = du_o + da_o * h_prev
    db_o = db_o + da_o
    dw_c = dw_c + da_g * seq.lift((t.toInt).toInt).getOrElse(0.0)
    du_c = du_c + da_g * h_prev
    db_c = db_c + da_g
    dh_next = da_i * w.u_i + da_f * w.u_f + da_o * w.u_o + da_g * w.u_c
    dc_next = dc * f_t
    t = t - BigInt(1)
  }
  w.w_y = w.w_y - lr * dw_y
  w.b_y = w.b_y - lr * db_y
  w.w_i = w.w_i - lr * dw_i
  w.u_i = w.u_i - lr * du_i
  w.b_i = w.b_i - lr * db_i
  w.w_f = w.w_f - lr * dw_f
  w.u_f = w.u_f - lr * du_f
  w.b_f = w.b_f - lr * db_f
  w.w_o = w.w_o - lr * dw_o
  w.u_o = w.u_o - lr * du_o
  w.b_o = w.b_o - lr * db_o
  w.w_c = w.w_c - lr * dw_c
  w.u_c = w.u_c - lr * du_c
  w.b_c = w.b_c - lr * db_c
  return w
}

def make_samples(data: ArrayBuffer[Double], look_back: BigInt): Samples = {
  var X: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var Y: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i + look_back < BigInt((data).size)) {
    var seq: ArrayBuffer[Double] = data.slice((i).toInt, (i + look_back).toInt)
    X = (X :+ seq)
    Y = (Y :+ data.lift(((i + look_back).toInt).toInt).getOrElse(0.0))
    i = i + BigInt(1)
  }
  return Samples(X, Y)
}

def init_weights(): LSTMWeights = {
  return LSTMWeights(0.1, 0.2, 0.0, 0.1, 0.2, 0.0, 0.1, 0.2, 0.0, 0.1, 0.2, 0.0, 0.1, 0.0)
}

def train(data: ArrayBuffer[Double], look_back: BigInt, epochs: BigInt, lr: Double): LSTMWeights = {
  var samples: Samples = make_samples(data, look_back)
  var w: LSTMWeights = init_weights()
  var ep: BigInt = BigInt(0)
  while (ep < epochs) {
    var j: BigInt = BigInt(0)
    while (j < BigInt((samples.asInstanceOf[Samples].x).size)) {
      var seq: ArrayBuffer[Double] = samples.asInstanceOf[Samples].x.lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]())
      var target: Double = samples.asInstanceOf[Samples].y.lift((j.toInt).toInt).getOrElse(0.0)
      var state: LSTMState = forward(seq, w)
      w = backward(seq, target, w, state, lr)
      j = j + BigInt(1)
    }
    ep = ep + BigInt(1)
  }
  return w
}

def predict(seq: ArrayBuffer[Double], w: LSTMWeights): Double = {
  var state: LSTMState = forward(seq, w)
  var h_last: Double = state.asInstanceOf[LSTMState].h.lift(((BigInt((state.asInstanceOf[LSTMState].h).size) - BigInt(1)).toInt).toInt).getOrElse(0.0)
  return w.w_y * h_last + w.b_y
}

var data: ArrayBuffer[Double] = ArrayBuffer(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8)

var look_back: BigInt = BigInt(3)

var epochs: BigInt = BigInt(200)

var lr: Double = 0.1

var test_seq: ArrayBuffer[Double] = ArrayBuffer(0.6, 0.7, 0.8)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    var w: LSTMWeights = train(data, look_back, epochs, lr)
    var pred: Double = predict(test_seq, w)
    println(_str("Predicted value: " + _str(pred)))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
