// Generated by Mochi v0.10.59 on 2025-08-07 12:44:23 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class LSTMWeights(var w_i: Double, var u_i: Double, var b_i: Double, var w_f: Double, var u_f: Double, var b_f: Double, var w_o: Double, var u_o: Double, var b_o: Double, var w_c: Double, var u_c: Double, var b_c: Double, var w_y: Double, var b_y: Double)

case class LSTMState(var i: ArrayBuffer[Double], var f: ArrayBuffer[Double], var o: ArrayBuffer[Double], var g: ArrayBuffer[Double], var c: ArrayBuffer[Double], var h: ArrayBuffer[Double])

case class Samples(var x: ArrayBuffer[ArrayBuffer[Double]], var y: ArrayBuffer[Double])

def exp_approx(x: Double): Double = {
  var sum: Double = 1.0
  var term: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n < BigInt(20)) {
    term = term * x / n.toString.toDouble
    sum = sum + term
    n = n + BigInt(1)
  }
  return sum
}

def sigmoid(x: Double): Double = {
  return 1.0 / (1.0 + exp_approx(-x))
}

def tanh_approx(x: Double): Double = {
  val e: Double = exp_approx(2.0 * x)
  return (e - 1.0) / (e + 1.0)
}

def forward(seq: ArrayBuffer[Double], w: LSTMWeights): LSTMState = {
  var i_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var f_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var o_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var g_arr: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var c_arr: ArrayBuffer[Double] = ArrayBuffer(0.0)
  var h_arr: ArrayBuffer[Double] = ArrayBuffer(0.0)
  var t: BigInt = BigInt(0)
  while (t < BigInt((seq).size)) {
    val x: Double = seq((t.toInt).toInt)
    val h_prev: Double = h_arr((t.toInt).toInt)
    val c_prev: Double = c_arr((t.toInt).toInt)
    val i_t: Double = sigmoid(w.w_i * x + w.u_i * h_prev + w.b_i)
    val f_t: Double = sigmoid(w.w_f * x + w.u_f * h_prev + w.b_f)
    val o_t: Double = sigmoid(w.w_o * x + w.u_o * h_prev + w.b_o)
    val g_t: Double = tanh_approx(w.w_c * x + w.u_c * h_prev + w.b_c)
    val c_t: Double = f_t * c_prev + i_t * g_t
    val h_t: Double = o_t * tanh_approx(c_t)
    i_arr = i_arr :+ i_t
    f_arr = f_arr :+ f_t
    o_arr = o_arr :+ o_t
    g_arr = g_arr :+ g_t
    c_arr = c_arr :+ c_t
    h_arr = h_arr :+ h_t
    t = t + BigInt(1)
  }
  return LSTMState(i_arr, f_arr, o_arr, g_arr, c_arr, h_arr)
}

def backward(seq: ArrayBuffer[Double], target: Double, w: LSTMWeights, s: LSTMState, lr: Double): LSTMWeights = {
  var dw_i: Double = 0.0
  var du_i: Double = 0.0
  var db_i: Double = 0.0
  var dw_f: Double = 0.0
  var du_f: Double = 0.0
  var db_f: Double = 0.0
  var dw_o: Double = 0.0
  var du_o: Double = 0.0
  var db_o: Double = 0.0
  var dw_c: Double = 0.0
  var du_c: Double = 0.0
  var db_c: Double = 0.0
  var dw_y: Double = 0.0
  var db_y: Double = 0.0
  val T: BigInt = BigInt((seq).size)
  val h_last: Double = s.asInstanceOf[LSTMState].h((T.toInt).toInt)
  val y: Double = w.w_y * h_last + w.b_y
  val dy: Double = y - target
  dw_y = dy * h_last
  db_y = dy
  var dh_next: Double = dy * w.w_y
  var dc_next: Double = 0.0
  var t: BigInt = T - BigInt(1)
  while (t >= BigInt(0)) {
    val i_t: Double = s.asInstanceOf[LSTMState].i((t.toInt).toInt)
    val f_t: Double = s.asInstanceOf[LSTMState].f((t.toInt).toInt)
    val o_t: Double = s.asInstanceOf[LSTMState].o((t.toInt).toInt)
    val g_t: Double = s.asInstanceOf[LSTMState].g((t.toInt).toInt)
    val c_t: Double = s.asInstanceOf[LSTMState].c(((t + BigInt(1)).toInt).toInt)
    val c_prev: Double = s.asInstanceOf[LSTMState].c((t.toInt).toInt)
    val h_prev: Double = s.asInstanceOf[LSTMState].h((t.toInt).toInt)
    val tanh_c: Double = tanh_approx(c_t)
    val do_t: Double = dh_next * tanh_c
    val da_o: Double = do_t * o_t * (1.0 - o_t)
    val dc: Double = dh_next * o_t * (1.0 - tanh_c * tanh_c) + dc_next
    val di_t: Double = dc * g_t
    val da_i: Double = di_t * i_t * (1.0 - i_t)
    val dg_t: Double = dc * i_t
    val da_g: Double = dg_t * (1.0 - g_t * g_t)
    val df_t: Double = dc * c_prev
    val da_f: Double = df_t * f_t * (1.0 - f_t)
    dw_i = dw_i + da_i * seq((t.toInt).toInt)
    du_i = du_i + da_i * h_prev
    db_i = db_i + da_i
    dw_f = dw_f + da_f * seq((t.toInt).toInt)
    du_f = du_f + da_f * h_prev
    db_f = db_f + da_f
    dw_o = dw_o + da_o * seq((t.toInt).toInt)
    du_o = du_o + da_o * h_prev
    db_o = db_o + da_o
    dw_c = dw_c + da_g * seq((t.toInt).toInt)
    du_c = du_c + da_g * h_prev
    db_c = db_c + da_g
    dh_next = da_i * w.u_i + da_f * w.u_f + da_o * w.u_o + da_g * w.u_c
    dc_next = dc * f_t
    t = t - BigInt(1)
  }
  w.w_y = w.w_y - lr * dw_y
  w.b_y = w.b_y - lr * db_y
  w.w_i = w.w_i - lr * dw_i
  w.u_i = w.u_i - lr * du_i
  w.b_i = w.b_i - lr * db_i
  w.w_f = w.w_f - lr * dw_f
  w.u_f = w.u_f - lr * du_f
  w.b_f = w.b_f - lr * db_f
  w.w_o = w.w_o - lr * dw_o
  w.u_o = w.u_o - lr * du_o
  w.b_o = w.b_o - lr * db_o
  w.w_c = w.w_c - lr * dw_c
  w.u_c = w.u_c - lr * du_c
  w.b_c = w.b_c - lr * db_c
  return w
}

def make_samples(data: ArrayBuffer[Double], look_back: BigInt): Samples = {
  var X: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var Y: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i + look_back < BigInt((data).size)) {
    val seq: ArrayBuffer[Double] = data.slice((i).toInt, (i + look_back).toInt)
    X = X :+ seq
    Y = Y :+ data(((i + look_back).toInt).toInt)
    i = i + BigInt(1)
  }
  return Samples(X, Y)
}

def init_weights(): LSTMWeights = {
  return LSTMWeights(0.1, 0.2, 0.0, 0.1, 0.2, 0.0, 0.1, 0.2, 0.0, 0.1, 0.2, 0.0, 0.1, 0.0)
}

def train(data: ArrayBuffer[Double], look_back: BigInt, epochs: BigInt, lr: Double): LSTMWeights = {
  val samples: Samples = make_samples(data, look_back)
  var w: LSTMWeights = init_weights()
  var ep: BigInt = BigInt(0)
  while (ep < epochs) {
    var j: BigInt = BigInt(0)
    while (j < BigInt((samples.asInstanceOf[Samples].x).size)) {
      val seq: ArrayBuffer[Double] = samples.asInstanceOf[Samples].x((j.toInt).toInt)
      val target: Double = samples.asInstanceOf[Samples].y((j.toInt).toInt)
      val state: LSTMState = forward(seq, w)
      w = backward(seq, target, w, state, lr)
      j = j + BigInt(1)
    }
    ep = ep + BigInt(1)
  }
  return w
}

def predict(seq: ArrayBuffer[Double], w: LSTMWeights): Double = {
  val state: LSTMState = forward(seq, w)
  val h_last: Double = state.asInstanceOf[LSTMState].h(((BigInt((state.asInstanceOf[LSTMState].h).size) - BigInt(1)).toInt).toInt)
  return w.w_y * h_last + w.b_y
}

val data: ArrayBuffer[Double] = ArrayBuffer(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8)

val look_back: BigInt = BigInt(3)

val epochs: BigInt = BigInt(200)

val lr: Double = 0.1

val w: LSTMWeights = train(data, look_back, epochs, lr)

val test_seq: ArrayBuffer[Double] = ArrayBuffer(0.6, 0.7, 0.8)

val pred: Double = predict(test_seq, w)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println("Predicted value: " + String.valueOf(pred))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
