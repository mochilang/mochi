// Generated by Mochi v0.10.63 on 2025-08-12 09:00:24 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class Point(var x: BigInt, var y: BigInt)

case class Node(var pos: Point, var parent: Point, var g: BigInt, var h: BigInt, var f: BigInt)

def get_neighbours(p: Point, x_limit: BigInt, y_limit: BigInt): ArrayBuffer[Point] = {
  val deltas: ArrayBuffer[Point] = ArrayBuffer(Point(BigInt(-1), BigInt(-1)), Point(BigInt(-1), BigInt(0)), Point(BigInt(-1), BigInt(1)), Point(BigInt(0), BigInt(-1)), Point(BigInt(0), BigInt(1)), Point(BigInt(1), BigInt(-1)), Point(BigInt(1), BigInt(0)), Point(BigInt(1), BigInt(1)))
  var neighbours: ArrayBuffer[Point] = ArrayBuffer[Point]()
  for (d <- deltas) {
    val nx: BigInt = p.asInstanceOf[Point].x + d.asInstanceOf[Point].x
    val ny: BigInt = p.asInstanceOf[Point].y + d.asInstanceOf[Point].y
    if ((((BigInt(0) <= nx && nx < x_limit).asInstanceOf[Boolean] && BigInt(0) <= ny).asInstanceOf[Boolean] && ny < y_limit).asInstanceOf[Boolean]) {
      neighbours = neighbours :+ (Point(nx, ny))
    }
  }
  return neighbours
}

def contains(nodes: ArrayBuffer[Node], p: Point): Boolean = {
  for (n <- nodes) {
    if ((n.asInstanceOf[Node].pos.asInstanceOf[Point].x == p.asInstanceOf[Point].x && n.asInstanceOf[Node].pos.asInstanceOf[Point].y == p.asInstanceOf[Point].y).asInstanceOf[Boolean]) {
      return true
    }
  }
  return false
}

def get_node(nodes: ArrayBuffer[Node], p: Point): Node = {
  for (n <- nodes) {
    if ((n.asInstanceOf[Node].pos.asInstanceOf[Point].x == p.asInstanceOf[Point].x && n.asInstanceOf[Node].pos.asInstanceOf[Point].y == p.asInstanceOf[Point].y).asInstanceOf[Boolean]) {
      return n
    }
  }
  return Node(p, Point(BigInt(-1), BigInt(-1)), BigInt(0), BigInt(0), BigInt(0))
}

def astar(x_limit: BigInt, y_limit: BigInt, start: Point, goal: Point): ArrayBuffer[Point] = {
  var open: ArrayBuffer[Node] = ArrayBuffer[Node]()
  var closed: ArrayBuffer[Node] = ArrayBuffer[Node]()
  open = open :+ (Node(start, Point(BigInt(-1), BigInt(-1)), BigInt(0), BigInt(0), BigInt(0)))
  var current: Node = open.lift((BigInt(0).toInt).toInt).getOrElse(null)
  val _br3 = new Breaks
  val _ct3 = new Breaks
  _br3.breakable {
    while (BigInt((open).size) > BigInt(0)) {
      _ct3.breakable {
        var min_index: BigInt = BigInt(0)
        var i: BigInt = BigInt(1)
        while (i < BigInt((open).size)) {
          if (open.lift((i.toInt).toInt).getOrElse(null).f < open.lift((min_index.toInt).toInt).getOrElse(null).f) {
            min_index = i
          }
          i = i + BigInt(1)
        }
        current = open.lift((min_index.toInt).toInt).getOrElse(null)
        var new_open: ArrayBuffer[Node] = ArrayBuffer[Node]()
        var j: BigInt = BigInt(0)
        while (j < BigInt((open).size)) {
          if (j != min_index) {
            new_open = new_open :+ (open.lift((j.toInt).toInt).getOrElse(null))
          }
          j = j + BigInt(1)
        }
        open = new_open
        closed = closed :+ (current)
        if ((current.asInstanceOf[Node].pos.asInstanceOf[Point].x == goal.x && current.asInstanceOf[Node].pos.asInstanceOf[Point].y == goal.y).asInstanceOf[Boolean]) {
          _br3.break()
        }
        val neighbours: ArrayBuffer[Point] = get_neighbours(current.asInstanceOf[Node].pos, x_limit, y_limit)
        val _ct6 = new Breaks
        for (np <- neighbours) {
          _ct6.breakable {
            if ((closed.contains(np)).asInstanceOf[Boolean]) {
              _ct6.break()
            }
            val g: BigInt = current.asInstanceOf[Node].g + BigInt(1)
            val dx: BigInt = goal.x - np.asInstanceOf[Point].x
            val dy: BigInt = goal.y - np.asInstanceOf[Point].y
            val h: BigInt = dx * dx + dy * dy
            val f: BigInt = g + h
            var skip: Boolean = false
            for (node <- open) {
              if (((node.asInstanceOf[Node].pos.asInstanceOf[Point].x == np.asInstanceOf[Point].x && node.asInstanceOf[Node].pos.asInstanceOf[Point].y == np.asInstanceOf[Point].y).asInstanceOf[Boolean] && node.asInstanceOf[Node].f < f).asInstanceOf[Boolean]) {
                skip = true
              }
            }
            if (skip) {
              _ct6.break()
            }
            open = open :+ (Node(np, current.asInstanceOf[Node].pos, g, h, f))
          }
        }
      }
    }
  }
  var path: ArrayBuffer[Point] = ArrayBuffer[Point]()
  path = path :+ (current.asInstanceOf[Node].pos)
  while (!(current.asInstanceOf[Node].parent.asInstanceOf[Point].x == BigInt(-1) && current.asInstanceOf[Node].parent.asInstanceOf[Point].y == BigInt(-1)).asInstanceOf[Boolean]) {
    current = get_node(closed, current.asInstanceOf[Node].parent)
    path = path :+ (current.asInstanceOf[Node].pos)
  }
  var rev: ArrayBuffer[Point] = ArrayBuffer[Point]()
  var k: BigInt = BigInt((path).size) - BigInt(1)
  while (k >= BigInt(0)) {
    rev = rev :+ (path.lift((k.toInt).toInt).getOrElse(null))
    k = k - BigInt(1)
  }
  return rev
}

def create_world(x_limit: BigInt, y_limit: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var world: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < x_limit) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var j: BigInt = BigInt(0)
    while (j < y_limit) {
      row = row :+ (BigInt(0))
      j = j + BigInt(1)
    }
    world = world :+ (row)
    i = i + BigInt(1)
  }
  return world
}

def mark_path(world: ArrayBuffer[ArrayBuffer[BigInt]], path: ArrayBuffer[Point]): Any = {
  for (p <- path) {
    world((p.asInstanceOf[Point].x).toInt)((p.asInstanceOf[Point].y).toInt) = BigInt(1)
  }
}

def print_world(world: ArrayBuffer[ArrayBuffer[BigInt]]): Any = {
  for (row <- world) {
    println(_str(row))
  }
}

val world_x: BigInt = BigInt(5)

val world_y: BigInt = BigInt(5)

val start: Point = Point(BigInt(0), BigInt(0))

val goal: Point = Point(BigInt(4), BigInt(4))

val path: ArrayBuffer[Point] = astar(world_x, world_y, start, goal)

val world: ArrayBuffer[ArrayBuffer[BigInt]] = create_world(world_x, world_y)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println("path from (" + _str(start.x) + ", " + _str(start.y) + ") to (" + _str(goal.x) + ", " + _str(goal.y) + ")")
    mark_path(world, path)
    print_world(world)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
