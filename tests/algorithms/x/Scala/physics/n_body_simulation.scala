// Generated by Mochi v0.10.64 on 2025-08-12 12:38:53 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Body(var position_x: Double, var position_y: Double, var velocity_x: Double, var velocity_y: Double, var mass: Double)

case class BodySystem(var bodies: ArrayBuffer[Body], var gravitation_constant: Double, var time_factor: Double, var softening_factor: Double)

def make_body(px: Double, py: Double, vx: Double, vy: Double, mass: Double): Body = {
  return Body(px, py, vx, vy, mass)
}

def update_velocity(body: Body, force_x: Double, force_y: Double, delta_time: Double): Body = {
  body.asInstanceOf[Body].velocity_x = body.asInstanceOf[Body].velocity_x + force_x * delta_time
  body.asInstanceOf[Body].velocity_y = body.asInstanceOf[Body].velocity_y + force_y * delta_time
  return body
}

def update_position(body: Body, delta_time: Double): Body = {
  body.asInstanceOf[Body].position_x = body.asInstanceOf[Body].position_x + body.asInstanceOf[Body].velocity_x * delta_time
  body.asInstanceOf[Body].position_y = body.asInstanceOf[Body].position_y + body.asInstanceOf[Body].velocity_y * delta_time
  return body
}

def make_body_system(bodies: ArrayBuffer[Body], g: Double, tf: Double, sf: Double): BodySystem = {
  return BodySystem(bodies, g, tf, sf)
}

def sqrtApprox(x: Double): Double = {
  var guess: Double = x / 2.0
  var i: BigInt = BigInt(0)
  while (i < BigInt(20)) {
    guess = (guess + x / guess) / 2.0
    i = i + BigInt(1)
  }
  return guess
}

def update_system(system: BodySystem, delta_time: Double): BodySystem = {
  var bodies: ArrayBuffer[Body] = system.asInstanceOf[BodySystem].bodies
  var i: BigInt = BigInt(0)
  while (i < BigInt((bodies).size)) {
    var body1: Body = bodies.lift((i.toInt).toInt).getOrElse(null)
    var force_x: Double = 0.0
    var force_y: Double = 0.0
    var j: BigInt = BigInt(0)
    while (j < BigInt((bodies).size)) {
      if (i != j) {
        val body2: Body = bodies.lift((j.toInt).toInt).getOrElse(null)
        val dif_x: Double = body2.asInstanceOf[Body].position_x - body1.asInstanceOf[Body].position_x
        val dif_y: Double = body2.asInstanceOf[Body].position_y - body1.asInstanceOf[Body].position_y
        val distance_sq: Double = dif_x * dif_x + dif_y * dif_y + system.asInstanceOf[BodySystem].softening_factor
        val distance: Double = sqrtApprox(distance_sq)
        val denom: Double = distance * distance * distance
        force_x = force_x + system.asInstanceOf[BodySystem].gravitation_constant * body2.asInstanceOf[Body].mass * dif_x / denom
        force_y = force_y + system.asInstanceOf[BodySystem].gravitation_constant * body2.asInstanceOf[Body].mass * dif_y / denom
      }
      j = j + BigInt(1)
    }
    body1 = update_velocity(body1, force_x, force_y, delta_time * system.asInstanceOf[BodySystem].time_factor)
    bodies((i).toInt) = body1
    i = i + BigInt(1)
  }
  i = BigInt(0)
  while (i < BigInt((bodies).size)) {
    var body: Body = bodies.lift((i.toInt).toInt).getOrElse(null)
    body = update_position(body, delta_time * system.asInstanceOf[BodySystem].time_factor)
    bodies((i).toInt) = body
    i = i + BigInt(1)
  }
  system.asInstanceOf[BodySystem].bodies = bodies
  return system
}

def main(): Any = {
  val b1: Body = make_body(0.0, 0.0, 0.0, 0.0, 1.0)
  val b2: Body = make_body(10.0, 0.0, 0.0, 0.0, 1.0)
  var sys1: BodySystem = make_body_system(ArrayBuffer(b1, b2), 1.0, 1.0, 0.0)
  sys1 = update_system(sys1, 1.0)
  val b1_after: Body = sys1.asInstanceOf[BodySystem].bodies.lift((BigInt(0).toInt).toInt).getOrElse(null)
  val pos1x: Double = b1_after.asInstanceOf[Body].position_x
  val pos1y: Double = b1_after.asInstanceOf[Body].position_y
  println(toJson(scala.collection.mutable.Map("x" -> (pos1x), "y" -> (pos1y))))
  val vel1x: Double = b1_after.asInstanceOf[Body].velocity_x
  val vel1y: Double = b1_after.asInstanceOf[Body].velocity_y
  println(toJson(scala.collection.mutable.Map("vx" -> (vel1x), "vy" -> (vel1y))))
  val b3: Body = make_body(-10.0, 0.0, 0.0, 0.0, 1.0)
  val b4: Body = make_body(10.0, 0.0, 0.0, 0.0, 4.0)
  var sys2: BodySystem = make_body_system(ArrayBuffer(b3, b4), 1.0, 10.0, 0.0)
  sys2 = update_system(sys2, 1.0)
  val b2_after: Body = sys2.asInstanceOf[BodySystem].bodies.lift((BigInt(0).toInt).toInt).getOrElse(null)
  val pos2x: Double = b2_after.asInstanceOf[Body].position_x
  val pos2y: Double = b2_after.asInstanceOf[Body].position_y
  println(toJson(scala.collection.mutable.Map("x" -> (pos2x), "y" -> (pos2y))))
  val vel2x: Double = b2_after.asInstanceOf[Body].velocity_x
  val vel2y: Double = b2_after.asInstanceOf[Body].velocity_y
  println(toJson(scala.collection.mutable.Map("vx" -> (vel2x), "vy" -> (vel2y))))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
