// Generated by Mochi v0.10.64 on 2025-08-13 16:20:58 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => d.toString
  case other => String.valueOf(other)
}

case class Vec(var x: Double, var y: Double)

def _mod(x: Double, m: Double): Double = {
  return x - (BigInt((x / m).toString.toDouble.toInt)).toDouble * m
}

def sin(x: Double): Double = {
  val y: Double = _mod(x + PI, TWO_PI) - PI
  val y2: Double = y * y
  val y3: Double = y2 * y
  val y5: Double = y3 * y2
  val y7: Double = y5 * y2
  return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
}

def cos(x: Double): Double = {
  val y: Double = _mod(x + PI, TWO_PI) - PI
  val y2: Double = y * y
  val y4: Double = y2 * y2
  val y6: Double = y4 * y2
  return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
}

def rotate(v: Vec, angle_deg: Double): Vec = {
  val theta: Double = angle_deg * PI / 180.0
  val c: Double = cos(theta)
  val s: Double = sin(theta)
  return Vec(v.asInstanceOf[Vec].x * c - v.asInstanceOf[Vec].y * s, v.asInstanceOf[Vec].x * s + v.asInstanceOf[Vec].y * c)
}

def iteration_step(vectors: ArrayBuffer[Vec]): ArrayBuffer[Vec] = {
  var new_vectors: ArrayBuffer[Vec] = ArrayBuffer[Vec]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((vectors).size) - BigInt(1)) {
    val start: Vec = vectors.lift((i.toInt).toInt).getOrElse(null)
    val end: Vec = vectors.lift(((i + BigInt(1)).toInt).toInt).getOrElse(null)
    new_vectors = new_vectors += (start)
    val dx: Double = end.asInstanceOf[Vec].x - start.asInstanceOf[Vec].x
    val dy: Double = end.asInstanceOf[Vec].y - start.asInstanceOf[Vec].y
    val one_third: Vec = Vec(start.asInstanceOf[Vec].x + dx / 3.0, start.asInstanceOf[Vec].y + dy / 3.0)
    val mid: Vec = rotate(Vec(dx / 3.0, dy / 3.0), 60.0)
    val peak: Vec = Vec(one_third.asInstanceOf[Vec].x + mid.asInstanceOf[Vec].x, one_third.asInstanceOf[Vec].y + mid.asInstanceOf[Vec].y)
    val two_third: Vec = Vec(start.asInstanceOf[Vec].x + dx * 2.0 / 3.0, start.asInstanceOf[Vec].y + dy * 2.0 / 3.0)
    new_vectors = new_vectors += (one_third)
    new_vectors = new_vectors += (peak)
    new_vectors = new_vectors += (two_third)
    i = i + BigInt(1)
  }
  new_vectors = new_vectors += (vectors.lift(((BigInt((vectors).size) - BigInt(1)).toInt).toInt).getOrElse(null))
  return new_vectors
}

def iterate(initial: ArrayBuffer[Vec], steps: BigInt): ArrayBuffer[Vec] = {
  var vectors: ArrayBuffer[Vec] = initial
  var i: BigInt = BigInt(0)
  while (i < steps) {
    vectors = iteration_step(vectors)
    i = i + BigInt(1)
  }
  return vectors
}

def vec_to_string(v: Vec): String = {
  return "(" + _str(v.asInstanceOf[Vec].x) + ", " + _str(v.asInstanceOf[Vec].y) + ")"
}

def vec_list_to_string(lst: ArrayBuffer[Vec]): String = {
  var res: String = "["
  var i: BigInt = BigInt(0)
  while (i < BigInt((lst).size)) {
    res = res + vec_to_string(lst.lift((i.toInt).toInt).getOrElse(null))
    if (i < BigInt((lst).size) - BigInt(1)) {
      res = res + ", "
    }
    i = i + BigInt(1)
  }
  res = res + "]"
  return res
}

val PI: Double = 3.141592653589793

val TWO_PI: Double = 6.283185307179586

val VECTOR_1: Vec = Vec(0.0, 0.0)

val VECTOR_2: Vec = Vec(0.5, 0.8660254)

val VECTOR_3: Vec = Vec(1.0, 0.0)

val INITIAL_VECTORS: ArrayBuffer[Vec] = ArrayBuffer(VECTOR_1, VECTOR_2, VECTOR_3, VECTOR_1)

val example: ArrayBuffer[Vec] = iterate(ArrayBuffer(VECTOR_1, VECTOR_3), BigInt(1))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(vec_list_to_string(example))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
