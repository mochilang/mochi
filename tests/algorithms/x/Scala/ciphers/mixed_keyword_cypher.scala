// Generated by Mochi v0.10.59 on 2025-08-06 21:53:17 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def to_upper(s: String): String = {
  var res: String = ""
  var i: BigInt = 0
  val _br0 = new Breaks
  _br0.breakable {
    while (i < BigInt((s).size)) {
      val ch = s.slice((i.toInt).toInt, (i.toInt).toInt + 1)
      var j: BigInt = 0
      var found: Boolean = false
      val _br1 = new Breaks
      _br1.breakable {
        while (j < 26) {
          if (ch == LOWER.slice((j.toInt).toInt, (j.toInt).toInt + 1)) {
            res = res + UPPER.slice((j.toInt).toInt, (j.toInt).toInt + 1)
            found = true
            _br1.break()
          }
          j = j + 1
        }
      }
      if (found == false) {
        res = res + ch
      }
      i = i + 1
    }
  }
  return res
}

def contains(xs: ArrayBuffer[String], x: String): Boolean = {
  var i: BigInt = 0
  while (i < BigInt((xs).size)) {
    if (xs((i.toInt).toInt) == x) {
      return true
    }
    i = i + 1
  }
  return false
}

def contains_char(s: String, ch: String): Boolean = {
  var i: BigInt = 0
  while (i < BigInt((s).size)) {
    if (s.slice((i.toInt).toInt, (i.toInt).toInt + 1) == ch) {
      return true
    }
    i = i + 1
  }
  return false
}

def get_value(keys: ArrayBuffer[String], values: ArrayBuffer[String], key: String): String = {
  var i: BigInt = 0
  while (i < BigInt((keys).size)) {
    if (keys((i.toInt).toInt) == key) {
      return values((i.toInt).toInt)
    }
    i = i + 1
  }
  return null
}

def print_mapping(keys: ArrayBuffer[String], values: ArrayBuffer[String]): Any = {
  var s: String = "{"
  var i: BigInt = 0
  while (i < BigInt((keys).size)) {
    s = s + "'" + keys((i.toInt).toInt) + "': '" + values((i.toInt).toInt) + "'"
    if (i + 1 < BigInt((keys).size)) {
      s = s + ", "
    }
    i = i + 1
  }
  s = s + "}"
  println(s)
}

def mixed_keyword(keyword: String, plaintext: String, verbose: Boolean): String = {
  val alphabet: String = UPPER
  val keyword_u: String = to_upper(keyword)
  val plaintext_u: String = to_upper(plaintext)
  var unique: ArrayBuffer[String] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((keyword_u).size)) {
    val ch = keyword_u.slice((i.toInt).toInt, (i.toInt).toInt + 1)
    if ((contains_char(alphabet, ch) && unique.contains(ch) == false).asInstanceOf[Boolean]) {
      unique = unique :+ ch
    }
    i = i + 1
  }
  val num_unique: BigInt = BigInt((unique).size)
  var shifted: ArrayBuffer[String] = ArrayBuffer()
  i = 0
  while (i < BigInt((unique).size)) {
    shifted = shifted :+ unique((i.toInt).toInt)
    i = i + 1
  }
  i = 0
  while (i < BigInt((alphabet).size)) {
    val ch = alphabet.slice((i.toInt).toInt, (i.toInt).toInt + 1)
    if (unique.contains(ch) == false) {
      shifted = shifted :+ ch
    }
    i = i + 1
  }
  var modified: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
  var k: BigInt = 0
  while (k < BigInt((shifted).size)) {
    var row: ArrayBuffer[String] = ArrayBuffer()
    var r: BigInt = 0
    while (r < num_unique && k + r < BigInt((shifted).size)) {
      row = row :+ shifted(((k + r).toInt).toInt)
      r = r + 1
    }
    modified = modified :+ row
    k = k + num_unique
  }
  var keys: ArrayBuffer[String] = ArrayBuffer()
  var values: ArrayBuffer[String] = ArrayBuffer()
  var column: BigInt = 0
  var letter_index: BigInt = 0
  val _br11 = new Breaks
  _br11.breakable {
    while (column < num_unique) {
      var row_idx: BigInt = 0
      val _br12 = new Breaks
      _br12.breakable {
        while (row_idx < BigInt((modified).size)) {
          var row: ArrayBuffer[String] = modified((row_idx.toInt).toInt)
          if (BigInt((row).size) <= column) {
            _br12.break()
          }
          keys = keys :+ (alphabet.slice((letter_index.toInt).toInt, (letter_index.toInt).toInt + 1)).toString
          values = values :+ row((column.toInt).toInt)
          letter_index = letter_index + 1
          row_idx = row_idx + 1
        }
      }
      column = column + 1
    }
  }
  if (verbose) {
    print_mapping(keys, values)
  }
  var result: String = ""
  i = 0
  while (i < BigInt((plaintext_u).size)) {
    val ch = plaintext_u.slice((i.toInt).toInt, (i.toInt).toInt + 1)
    val mapped: String = get_value(keys, values, ch)
    if (mapped == null) {
      result = result + ch
    } else {
      result = result + mapped
    }
    i = i + 1
  }
  return result
}

val UPPER: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

val LOWER: String = "abcdefghijklmnopqrstuvwxyz"

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(mixed_keyword("college", "UNIVERSITY", true))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
