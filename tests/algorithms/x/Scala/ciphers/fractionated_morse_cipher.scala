// Generated by Mochi v0.10.59 on 2025-08-06 21:49:34 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def encodeToMorse(plaintext: String): String = {
  var morse: String = ""
  var i: BigInt = 0
  while (i < BigInt((plaintext).length)) {
    val ch = plaintext.slice((i).toInt, (i + 1).toInt).toUpperCase()
    var code: String = ""
    if ((MORSE_CODE_DICT.contains(ch)).asInstanceOf[Boolean]) {
      code = MORSE_CODE_DICT.getOrElse(ch.toString, "").asInstanceOf[String]
    }
    if (i > 0) {
      morse = morse + "x"
    }
    morse = morse + code
    i = i + 1
  }
  return morse
}

def encryptFractionatedMorse(plaintext: String, key: String): String = {
  var morseCode: String = encodeToMorse(plaintext)
  var combinedKey: String = key.toUpperCase() + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  var dedupKey: String = ""
  var i: BigInt = 0
  while (i < BigInt((combinedKey).size)) {
    val ch: String = combinedKey.slice((i).toInt, (i + 1).toInt)
    if ((!(dedupKey.contains(ch)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      dedupKey = dedupKey + ch
    }
    i = i + 1
  }
  var paddingLength: BigInt = 3 - BigInt((morseCode).size) % 3
  var p: BigInt = 0
  while (p < paddingLength) {
    morseCode = morseCode + "x"
    p = p + 1
  }
  var dict: scala.collection.mutable.Map[String,String] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,String]]
  var j: BigInt = 0
  while (j < 26) {
    val combo: String = MORSE_COMBINATIONS((j.toInt).toInt)
    val letter: String = dedupKey.slice((j).toInt, (j + 1).toInt)
    dict.update(combo, letter)
    j = j + 1
  }
  dict.update("xxx", "")
  var encrypted: String = ""
  var k: BigInt = 0
  while (k < BigInt((morseCode).size)) {
    val group: String = morseCode.slice((k).toInt, (k + 3).toInt)
    encrypted = encrypted + dict.getOrElse(group.toString, "").asInstanceOf[String]
    k = k + 3
  }
  return encrypted
}

def decryptFractionatedMorse(ciphertext: String, key: String): String = {
  var combinedKey: String = key.toUpperCase() + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  var dedupKey: String = ""
  var i: BigInt = 0
  while (i < BigInt((combinedKey).size)) {
    val ch: String = combinedKey.slice((i).toInt, (i + 1).toInt)
    if ((!(dedupKey.contains(ch)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      dedupKey = dedupKey + ch
    }
    i = i + 1
  }
  var inv: scala.collection.mutable.Map[String,String] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,String]]
  var j: BigInt = 0
  while (j < 26) {
    val letter: String = dedupKey.slice((j).toInt, (j + 1).toInt)
    inv.update(letter, MORSE_COMBINATIONS((j.toInt).toInt))
    j = j + 1
  }
  var morse: String = ""
  var k: BigInt = 0
  while (k < BigInt((ciphertext).length)) {
    val ch: String = ciphertext.slice((k).toInt, (k + 1).toInt)
    if ((inv.contains(ch)).asInstanceOf[Boolean]) {
      morse = morse + inv.getOrElse(ch.toString, "").asInstanceOf[String]
    }
    k = k + 1
  }
  var codes: ArrayBuffer[String] = ArrayBuffer()
  var current: String = ""
  var m: BigInt = 0
  while (m < BigInt((morse).size)) {
    val ch: String = morse.slice((m).toInt, (m + 1).toInt)
    if (ch == "x") {
      codes = codes :+ current
      current = ""
    } else {
      current = current + ch
    }
    m = m + 1
  }
  codes = codes :+ current
  var decrypted: String = ""
  var idx: BigInt = 0
  while (idx < BigInt((codes).size)) {
    val code: String = codes((idx.toInt).toInt)
    decrypted = decrypted + REVERSE_DICT.getOrElse(code.toString, "").asInstanceOf[String]
    idx = idx + 1
  }
  var start: BigInt = 0
  val _br10 = new Breaks
  val _ct10 = new Breaks
  _br10.breakable {
    while (true) {
      _ct10.breakable {
        if (start < BigInt((decrypted).length)) {
          if (decrypted.slice((start).toInt, (start + 1).toInt) == " ") {
            start = start + 1
            _ct10.break()
          }
        }
        _br10.break()
      }
    }
  }
  var end: BigInt = BigInt((decrypted).length)
  val _br11 = new Breaks
  val _ct11 = new Breaks
  _br11.breakable {
    while (true) {
      _ct11.breakable {
        if (end > start) {
          if (decrypted.slice((end - 1).toInt, (end).toInt) == " ") {
            end = end - 1
            _ct11.break()
          }
        }
        _br11.break()
      }
    }
  }
  return decrypted.slice((start).toInt, (end).toInt)
}

val MORSE_CODE_DICT: scala.collection.mutable.Map[String,String] = scala.collection.mutable.Map("A" -> (".-"), "B" -> ("-..."), "C" -> ("-.-."), "D" -> ("-.."), "E" -> ("."), "F" -> ("..-."), "G" -> ("--."), "H" -> ("...."), "I" -> (".."), "J" -> (".---"), "K" -> ("-.-"), "L" -> (".-.."), "M" -> ("--"), "N" -> ("-."), "O" -> ("---"), "P" -> (".--."), "Q" -> ("--.-"), "R" -> (".-."), "S" -> ("..."), "T" -> ("-"), "U" -> ("..-"), "V" -> ("...-"), "W" -> (".--"), "X" -> ("-..-"), "Y" -> ("-.--"), "Z" -> ("--.."), " " -> (""))

val MORSE_COMBINATIONS: ArrayBuffer[String] = ArrayBuffer("...", "..-", "..x", ".-.", ".--", ".-x", ".x.", ".x-", ".xx", "-..", "-.-", "-.x", "--.", "---", "--x", "-x.", "-x-", "-xx", "x..", "x.-", "x.x", "x-.", "x--", "x-x", "xx.", "xx-", "xxx")

val REVERSE_DICT: scala.collection.mutable.Map[String,String] = scala.collection.mutable.Map(".-" -> ("A"), "-..." -> ("B"), "-.-." -> ("C"), "-.." -> ("D"), "." -> ("E"), "..-." -> ("F"), "--." -> ("G"), "...." -> ("H"), ".." -> ("I"), ".---" -> ("J"), "-.-" -> ("K"), ".-.." -> ("L"), "--" -> ("M"), "-." -> ("N"), "---" -> ("O"), ".--." -> ("P"), "--.-" -> ("Q"), ".-." -> ("R"), "..." -> ("S"), "-" -> ("T"), "..-" -> ("U"), "...-" -> ("V"), ".--" -> ("W"), "-..-" -> ("X"), "-.--" -> ("Y"), "--.." -> ("Z"), "" -> (" "))

val plaintext: String = "defend the east"

val key: String = "ROUNDTABLE"

val ciphertext: String = encryptFractionatedMorse(plaintext, key)

val decrypted: String = decryptFractionatedMorse(ciphertext, key)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println((List("Plain Text:", plaintext)).mkString(" "))
    println((List("Encrypted:", ciphertext)).mkString(" "))
    println((List("Decrypted:", decrypted)).mkString(" "))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
