// Generated by Mochi v0.10.59 on 2025-08-06 21:49:10 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def mod_pow(base: BigInt, exp: BigInt, mod: BigInt): BigInt = {
  var result: BigInt = 1
  var b: BigInt = base % mod
  var e: BigInt = exp
  while (e > 0) {
    if (e % 2 == 1) {
      result = result * b % mod
    }
    e = e / 2
    b = b * b % mod
  }
  return result
}

def contains(xs: ArrayBuffer[BigInt], `val`: BigInt): Boolean = {
  var i: BigInt = 0
  while (i < BigInt((xs).size)) {
    if (xs((i.toInt).toInt) == `val`) {
      return true
    }
    i = i + 1
  }
  return false
}

def find_primitive(modulus: BigInt): BigInt = {
  var r: BigInt = 1
  while (r < modulus) {
    var li: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = 0
    var valid: Boolean = true
    while (x < modulus - 1 && valid) {
      val value: BigInt = mod_pow(r, x, modulus)
      if ((li.contains(value)).asInstanceOf[Boolean]) {
        valid = false
      } else {
        li = li :+ value
        x = x + 1
      }
    }
    if (valid) {
      return r
    }
    r = r + 1
  }
  return BigInt((-1).toString.toDouble.toInt)
}

val prime: BigInt = 23

val primitive_root: BigInt = find_primitive(prime)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(find_primitive(7))
    println(find_primitive(11))
    println(find_primitive(8))
    if (primitive_root == 0 - 1) {
      println("Cannot find the primitive for the value: -1")
    } else {
      val a_private: BigInt = 6
      val b_private: BigInt = 15
      val a_public: BigInt = mod_pow(primitive_root, a_private, prime)
      val b_public: BigInt = mod_pow(primitive_root, b_private, prime)
      val a_secret: BigInt = mod_pow(b_public, a_private, prime)
      val b_secret: BigInt = mod_pow(a_public, b_private, prime)
      println("The key value generated by A is: " + String.valueOf(a_secret))
      println("The key value generated by B is: " + String.valueOf(b_secret))
    }
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
