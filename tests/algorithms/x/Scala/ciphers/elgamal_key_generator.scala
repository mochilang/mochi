// Generated by Mochi v0.10.59 on 2025-08-06 21:49:21 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class GCD(var g: BigInt, var x: BigInt, var y: BigInt)

case class PublicKey(var key_size: BigInt, var g: BigInt, var e2: BigInt, var p: BigInt)

case class PrivateKey(var key_size: BigInt, var d: BigInt)

case class KeyPair(var public_key: PublicKey, var private_key: PrivateKey)

def rand(): BigInt = {
  seed = (seed * 1103515245 + 12345) % 2147483647
  return seed
}

def rand_range(min: BigInt, max: BigInt): BigInt = {
  return min + rand() % (max - min + 1)
}

def mod_pow(base: BigInt, exponent: BigInt, modulus: BigInt): BigInt = {
  var result: BigInt = 1
  var b: BigInt = base % modulus
  var e: BigInt = exponent
  while (e > 0) {
    if (e % 2 == 1) {
      result = result * b % modulus
    }
    e = e / 2
    b = b * b % modulus
  }
  return result
}

def extended_gcd(a: BigInt, b: BigInt): GCD = {
  if (b == 0) {
    return GCD(a, 1, 0)
  }
  val res: GCD = extended_gcd(b, a % b)
  return GCD(res.g, res.asInstanceOf[GCD].y, res.asInstanceOf[GCD].x - a / b * res.asInstanceOf[GCD].y)
}

def mod_inverse(a: BigInt, m: BigInt): BigInt = {
  val res: GCD = extended_gcd(a, m)
  if (res.g != 1) {
    throw new RuntimeException(String.valueOf("inverse does not exist"))
  }
  val r: BigInt = res.asInstanceOf[GCD].x % m
  if (r < 0) {
    return r + m
  }
  return r
}

def pow2(n: BigInt): BigInt = {
  var r: BigInt = 1
  var i: BigInt = 0
  while (i < n) {
    r = r * 2
    i = i + 1
  }
  return r
}

def is_probable_prime(n: BigInt, k: BigInt): Boolean = {
  if (n <= 1) {
    return false
  }
  if (n <= 3) {
    return true
  }
  if (n % 2 == 0) {
    return false
  }
  var r: BigInt = 0
  var d: BigInt = n - 1
  while (d % 2 == 0) {
    d = d / 2
    r = r + 1
  }
  var i: BigInt = 0
  val _br3 = new Breaks
  val _ct3 = new Breaks
  _br3.breakable {
    while (i < k) {
      _ct3.breakable {
        val a: BigInt = rand_range(2, n - 2)
        var x: BigInt = mod_pow(a, d, n)
        if ((x == 1 || x == n - 1).asInstanceOf[Boolean]) {
          i = i + 1
          _ct3.break()
        }
        var j: BigInt = 1
        var found: Boolean = false
        val _br4 = new Breaks
        _br4.breakable {
          while (j < r) {
            x = mod_pow(x, 2, n)
            if (x == n - 1) {
              found = true
              _br4.break()
            }
            j = j + 1
          }
        }
        if ((!found).asInstanceOf[Boolean]) {
          return false
        }
        i = i + 1
      }
    }
  }
  return true
}

def generate_large_prime(bits: BigInt): BigInt = {
  val min: BigInt = pow2(bits - 1)
  val max: BigInt = pow2(bits) - 1
  var p: BigInt = rand_range(min, max)
  if (p % 2 == 0) {
    p = p + 1
  }
  while (!is_probable_prime(p, 5)) {
    p = p + 2
    if (p > max) {
      p = min + 1
    }
  }
  return p
}

def primitive_root(p: BigInt): BigInt = {
  val _ct6 = new Breaks
  while (true) {
    _ct6.breakable {
      val g: BigInt = rand_range(3, p - 1)
      if (mod_pow(g, 2, p) == 1) {
        _ct6.break()
      }
      if (mod_pow(g, p, p) == 1) {
        _ct6.break()
      }
      return g
    }
  }
  return null
}

def generate_key(key_size: BigInt): KeyPair = {
  val p: BigInt = generate_large_prime(key_size)
  val e1: BigInt = primitive_root(p)
  val d: BigInt = rand_range(3, p - 1)
  val e2: BigInt = mod_inverse(mod_pow(e1, d, p), p)
  val public_key: PublicKey = PublicKey(key_size, e1, e2, p)
  val private_key: PrivateKey = PrivateKey(key_size, d)
  return KeyPair(public_key, private_key)
}

def main(): Any = {
  val key_size: BigInt = 16
  val kp: KeyPair = generate_key(key_size)
  val pub: PublicKey = kp.asInstanceOf[KeyPair].public_key
  val priv: PrivateKey = kp.asInstanceOf[KeyPair].private_key
  println("public key: (" + String.valueOf(pub.key_size) + ", " + String.valueOf(pub.g) + ", " + String.valueOf(pub.asInstanceOf[PublicKey].e2) + ", " + String.valueOf(pub.asInstanceOf[PublicKey].p) + ")")
  println("private key: (" + String.valueOf(priv.key_size) + ", " + String.valueOf(priv.asInstanceOf[PrivateKey].d) + ")")
}

var seed: BigInt = 123456789

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
