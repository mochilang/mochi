// Generated by Mochi v0.10.61 on 2025-08-08 16:09:27 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole()) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class Complex(var re: Double, var im: Double)

def c_add(a: Complex, b: Complex): Complex = {
  return Complex(a.asInstanceOf[Complex].re + b.asInstanceOf[Complex].re, a.asInstanceOf[Complex].im + b.asInstanceOf[Complex].im)
}

def c_sub(a: Complex, b: Complex): Complex = {
  return Complex(a.asInstanceOf[Complex].re - b.asInstanceOf[Complex].re, a.asInstanceOf[Complex].im - b.asInstanceOf[Complex].im)
}

def c_mul(a: Complex, b: Complex): Complex = {
  return Complex(a.asInstanceOf[Complex].re * b.asInstanceOf[Complex].re - a.asInstanceOf[Complex].im * b.asInstanceOf[Complex].im, a.asInstanceOf[Complex].re * b.asInstanceOf[Complex].im + a.asInstanceOf[Complex].im * b.asInstanceOf[Complex].re)
}

def c_mul_scalar(a: Complex, s: Double): Complex = {
  return Complex(a.asInstanceOf[Complex].re * s, a.asInstanceOf[Complex].im * s)
}

def c_div_scalar(a: Complex, s: Double): Complex = {
  return Complex(a.asInstanceOf[Complex].re / s, a.asInstanceOf[Complex].im / s)
}

def sin_taylor(x: Double): Double = {
  var term: Double = x
  var sum: Double = x
  var i: BigInt = BigInt(1)
  while (i < BigInt(10)) {
    val k1: Double = 2.0 * i.toString.toDouble
    val k2: Double = k1 + 1.0
    term = -term * x * x / (k1 * k2)
    sum = sum + term
    i = i + BigInt(1)
  }
  return sum
}

def cos_taylor(x: Double): Double = {
  var term: Double = 1.0
  var sum: Double = 1.0
  var i: BigInt = BigInt(1)
  while (i < BigInt(10)) {
    val k1: Double = 2.0 * i.toString.toDouble - 1.0
    val k2: Double = 2.0 * i.toString.toDouble
    term = -term * x * x / (k1 * k2)
    sum = sum + term
    i = i + BigInt(1)
  }
  return sum
}

def exp_i(theta: Double): Complex = {
  return Complex(cos_taylor(theta), sin_taylor(theta))
}

def make_complex_list(n: BigInt, value: Complex): ArrayBuffer[Complex] = {
  var arr: ArrayBuffer[Complex] = ArrayBuffer[Complex]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    arr = arr :+ value
    i = i + BigInt(1)
  }
  return arr
}

def fft(a: ArrayBuffer[Complex], invert: Boolean): ArrayBuffer[Complex] = {
  val n: BigInt = BigInt((a).size)
  if (n == BigInt(1)) {
    return ArrayBuffer(a((BigInt(0).toInt).toInt))
  }
  var a0: ArrayBuffer[Complex] = ArrayBuffer[Complex]()
  var a1: ArrayBuffer[Complex] = ArrayBuffer[Complex]()
  var i: BigInt = BigInt(0)
  while (i < n / BigInt(2)) {
    a0 = a0 :+ a(((BigInt(2) * i).toInt).toInt)
    a1 = a1 :+ a(((BigInt(2) * i + BigInt(1)).toInt).toInt)
    i = i + BigInt(1)
  }
  val y0: ArrayBuffer[Complex] = fft(a0, invert)
  val y1: ArrayBuffer[Complex] = fft(a1, invert)
  val angle: Double = 2.0 * PI / n.toString.toDouble * (if (invert) -1.0 else 1.0)
  var w: Complex = Complex(1.0, 0.0)
  val wn: Complex = exp_i(angle)
  var y: ArrayBuffer[Complex] = make_complex_list(n, Complex(0.0, 0.0))
  i = BigInt(0)
  while (i < n / BigInt(2)) {
    val t: Complex = c_mul(w, y1((i.toInt).toInt))
    val u: Complex = y0((i.toInt).toInt)
    var even: Complex = c_add(u, t)
    var odd: Complex = c_sub(u, t)
    if (invert) {
      even = c_div_scalar(even, 2.0)
      odd = c_div_scalar(odd, 2.0)
    }
    y((i).toInt) = even
    y((i + n / BigInt(2)).toInt) = odd
    w = c_mul(w, wn)
    i = i + BigInt(1)
  }
  return y
}

def floor(x: Double): Double = {
  var i: BigInt = BigInt(x.toString.toDouble.toInt)
  if ((i.toString.toDouble) > x) {
    i = i - BigInt(1)
  }
  return i.toString.toDouble
}

def pow10(n: BigInt): Double = {
  var p: Double = 1.0
  var i: BigInt = BigInt(0)
  while (i < n) {
    p = p * 10.0
    i = i + BigInt(1)
  }
  return p
}

def round_to(x: Double, ndigits: BigInt): Double = {
  val m: Double = pow10(ndigits)
  return Math.floor(x * m + 0.5) / m
}

def list_to_string(l: ArrayBuffer[Double]): String = {
  var s: String = "["
  var i: BigInt = BigInt(0)
  while (i < BigInt((l).size)) {
    s = s + _str(l((i.toInt).toInt))
    if (i + BigInt(1) < BigInt((l).size)) {
      s = s + ", "
    }
    i = i + BigInt(1)
  }
  s = s + "]"
  return s
}

def multiply_poly(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var n: BigInt = BigInt(1)
  while (n < BigInt((a).size) + BigInt((b).size) - BigInt(1)) {
    n = n * BigInt(2)
  }
  var fa: ArrayBuffer[Complex] = make_complex_list(n, Complex(0.0, 0.0))
  var fb: ArrayBuffer[Complex] = make_complex_list(n, Complex(0.0, 0.0))
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    fa((i).toInt) = Complex(a((i.toInt).toInt), 0.0)
    i = i + BigInt(1)
  }
  i = BigInt(0)
  while (i < BigInt((b).size)) {
    fb((i).toInt) = Complex(b((i.toInt).toInt), 0.0)
    i = i + BigInt(1)
  }
  fa = fft(fa, false)
  fb = fft(fb, false)
  i = BigInt(0)
  while (i < n) {
    fa((i).toInt) = c_mul(fa((i.toInt).toInt), fb((i.toInt).toInt))
    i = i + BigInt(1)
  }
  fa = fft(fa, true)
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  i = BigInt(0)
  while (i < BigInt((a).size) + BigInt((b).size) - BigInt(1)) {
    val `val`: Complex = fa((i.toInt).toInt)
    res = res :+ round_to(`val`.asInstanceOf[Complex].re, BigInt(8))
    i = i + BigInt(1)
  }
  while (BigInt((res).size) > BigInt(0) && res(((BigInt((res).size) - BigInt(1)).toInt).toInt) == 0.0) {
    res = res.slice((BigInt(0)).toInt, (BigInt((res).size) - BigInt(1)).toInt)
  }
  return res
}

val PI: Double = 3.141592653589793

val A: ArrayBuffer[Double] = ArrayBuffer(0.0, 1.0, 0.0, 2.0)

val B: ArrayBuffer[Double] = ArrayBuffer(2.0, 3.0, 4.0, 0.0)

val product: ArrayBuffer[Double] = multiply_poly(A, B)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(list_to_string(product))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
