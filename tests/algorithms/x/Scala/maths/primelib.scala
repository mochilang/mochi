// Generated by Mochi v0.10.61 on 2025-08-08 16:07:34 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole()) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

def abs_int(x: BigInt): BigInt = {
  if (x < BigInt(0)) {
    return -x
  }
  return x
}

def gcd_iter(a: BigInt, b: BigInt): BigInt = {
  var x: BigInt = abs_int(a)
  var y: BigInt = abs_int(b)
  while (y != BigInt(0)) {
    val t: BigInt = y
    y = x % y
    x = t
  }
  return x
}

def is_prime(n: BigInt): Boolean = {
  if (n <= BigInt(1)) {
    return false
  }
  var d: BigInt = BigInt(2)
  while (d * d <= n) {
    if (n % d == BigInt(0)) {
      return false
    }
    d = d + BigInt(1)
  }
  return true
}

def sieve_er(n: BigInt): ArrayBuffer[BigInt] = {
  var nums: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(2)
  while (i <= n) {
    nums = nums :+ i
    i = i + BigInt(1)
  }
  var idx: BigInt = BigInt(0)
  while (idx < BigInt((nums).size)) {
    var j: BigInt = idx + BigInt(1)
    while (j < BigInt((nums).size)) {
      if (nums((idx.toInt).toInt) != BigInt(0)) {
        if (nums((j.toInt).toInt) % nums((idx.toInt).toInt) == BigInt(0)) {
          nums((j).toInt) = BigInt(0)
        }
      }
      j = j + BigInt(1)
    }
    idx = idx + BigInt(1)
  }
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var k: BigInt = BigInt(0)
  while (k < BigInt((nums).size)) {
    val v: BigInt = nums((k.toInt).toInt)
    if (v != BigInt(0)) {
      res = res :+ v
    }
    k = k + BigInt(1)
  }
  return res
}

def get_prime_numbers(n: BigInt): ArrayBuffer[BigInt] = {
  var ans: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var num: BigInt = BigInt(2)
  while (num <= n) {
    if (is_prime(num)) {
      ans = ans :+ num
    }
    num = num + BigInt(1)
  }
  return ans
}

def prime_factorization(number: BigInt): ArrayBuffer[BigInt] = {
  if (number == BigInt(0)) {
    return ArrayBuffer(BigInt(0))
  }
  if (number == BigInt(1)) {
    return ArrayBuffer(BigInt(1))
  }
  var ans: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  if (is_prime(number)) {
    ans = ans :+ number
    return ans
  }
  var quotient: BigInt = number
  var factor: BigInt = BigInt(2)
  while (quotient != BigInt(1)) {
    if ((is_prime(factor) && quotient % factor == BigInt(0)).asInstanceOf[Boolean]) {
      ans = ans :+ factor
      quotient = quotient / factor
    } else {
      factor = factor + BigInt(1)
    }
  }
  return ans
}

def greatest_prime_factor(number: BigInt): BigInt = {
  val factors: ArrayBuffer[BigInt] = prime_factorization(number)
  var m: BigInt = factors((BigInt(0).toInt).toInt)
  var i: BigInt = BigInt(1)
  while (i < BigInt((factors).size)) {
    if (factors((i.toInt).toInt) > m) {
      m = factors((i.toInt).toInt)
    }
    i = i + BigInt(1)
  }
  return m
}

def smallest_prime_factor(number: BigInt): BigInt = {
  val factors: ArrayBuffer[BigInt] = prime_factorization(number)
  var m: BigInt = factors((BigInt(0).toInt).toInt)
  var i: BigInt = BigInt(1)
  while (i < BigInt((factors).size)) {
    if (factors((i.toInt).toInt) < m) {
      m = factors((i.toInt).toInt)
    }
    i = i + BigInt(1)
  }
  return m
}

def kg_v(number1: BigInt, number2: BigInt): BigInt = {
  if ((number1 < BigInt(1) || number2 < BigInt(1)).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("numbers must be positive"))
  }
  val g: BigInt = gcd_iter(number1, number2)
  return number1 / g * number2
}

def is_even(number: BigInt): Boolean = {
  return number % BigInt(2) == BigInt(0)
}

def is_odd(number: BigInt): Boolean = {
  return number % BigInt(2) != BigInt(0)
}

def goldbach(number: BigInt): ArrayBuffer[BigInt] = {
  if ((!is_even(number) || number <= BigInt(2)).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("number must be even and > 2"))
  }
  val primes: ArrayBuffer[BigInt] = get_prime_numbers(number)
  var i: BigInt = BigInt(0)
  while (i < BigInt((primes).size)) {
    var j: BigInt = i + BigInt(1)
    while (j < BigInt((primes).size)) {
      if (primes((i.toInt).toInt) + primes((j.toInt).toInt) == number) {
        return ArrayBuffer(primes((i.toInt).toInt), primes((j.toInt).toInt))
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return ArrayBuffer[BigInt]()
}

def get_prime(n: BigInt): BigInt = {
  if (n < BigInt(0)) {
    throw new RuntimeException(String.valueOf("n must be non-negative"))
  }
  var index: BigInt = BigInt(0)
  var ans: BigInt = BigInt(2)
  while (index < n) {
    index = index + BigInt(1)
    ans = ans + BigInt(1)
    while (!is_prime(ans)) {
      ans = ans + BigInt(1)
    }
  }
  return ans
}

def get_primes_between(p1: BigInt, p2: BigInt): ArrayBuffer[BigInt] = {
  val bad1: Boolean = !is_prime(p1)
  val bad2: Boolean = !is_prime(p2)
  if (((bad1 || bad2).asInstanceOf[Boolean] || p1 >= p2).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("arguments must be prime and p1 < p2"))
  }
  var num: BigInt = p1 + BigInt(1)
  val _br14 = new Breaks
  _br14.breakable {
    while (num < p2) {
      if (is_prime(num)) {
        _br14.break()
      }
      num = num + BigInt(1)
    }
  }
  var ans: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  val _br15 = new Breaks
  _br15.breakable {
    while (num < p2) {
      ans = ans :+ num
      num = num + BigInt(1)
      val _br16 = new Breaks
      _br16.breakable {
        while (num < p2) {
          if (is_prime(num)) {
            _br16.break()
          }
          num = num + BigInt(1)
        }
      }
    }
  }
  return ans
}

def get_divisors(n: BigInt): ArrayBuffer[BigInt] = {
  if (n < BigInt(1)) {
    throw new RuntimeException(String.valueOf("n must be >= 1"))
  }
  var ans: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var d: BigInt = BigInt(1)
  while (d <= n) {
    if (n % d == BigInt(0)) {
      ans = ans :+ d
    }
    d = d + BigInt(1)
  }
  return ans
}

def is_perfect_number(number: BigInt): Boolean = {
  if (number <= BigInt(1)) {
    throw new RuntimeException(String.valueOf("number must be > 1"))
  }
  val divisors: ArrayBuffer[BigInt] = get_divisors(number)
  var sum: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((divisors).size) - BigInt(1)) {
    sum = sum + divisors((i.toInt).toInt)
    i = i + BigInt(1)
  }
  return sum == number
}

def simplify_fraction(numerator: BigInt, denominator: BigInt): ArrayBuffer[BigInt] = {
  if (denominator == BigInt(0)) {
    throw new RuntimeException(String.valueOf("denominator cannot be zero"))
  }
  val g: BigInt = gcd_iter(abs_int(numerator), abs_int(denominator))
  return ArrayBuffer(numerator / g, denominator / g)
}

def factorial(n: BigInt): BigInt = {
  if (n < BigInt(0)) {
    throw new RuntimeException(String.valueOf("n must be >= 0"))
  }
  var ans: BigInt = BigInt(1)
  var i: BigInt = BigInt(1)
  while (i <= n) {
    ans = ans * i
    i = i + BigInt(1)
  }
  return ans
}

def fib(n: BigInt): BigInt = {
  if (n < BigInt(0)) {
    throw new RuntimeException(String.valueOf("n must be >= 0"))
  }
  if (n <= BigInt(1)) {
    return BigInt(1)
  }
  var tmp: BigInt = BigInt(0)
  var fib1: BigInt = BigInt(1)
  var ans: BigInt = BigInt(1)
  var i: BigInt = BigInt(0)
  while (i < n - BigInt(1)) {
    tmp = ans
    ans = ans + fib1
    fib1 = tmp
    i = i + BigInt(1)
  }
  return ans
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(_str(is_prime(BigInt(97))))
    println(_str(sieve_er(BigInt(20))))
    println(_str(get_prime_numbers(BigInt(20))))
    println(_str(prime_factorization(BigInt(287))))
    println(_str(greatest_prime_factor(BigInt(287))))
    println(_str(smallest_prime_factor(BigInt(287))))
    println(_str(kg_v(BigInt(8), BigInt(10))))
    println(_str(goldbach(BigInt(28))))
    println(_str(get_prime(BigInt(8))))
    println(_str(get_primes_between(BigInt(3), BigInt(20))))
    println(_str(get_divisors(BigInt(28))))
    println(_str(is_perfect_number(BigInt(28))))
    println(_str(simplify_fraction(BigInt(10), BigInt(20))))
    println(_str(factorial(BigInt(5))))
    println(_str(fib(BigInt(10))))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
