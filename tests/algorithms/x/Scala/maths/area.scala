// Generated by Mochi v0.10.66 on 2025-08-16 14:52:13 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case m: scala.collection.Map[_, _] => scala.collection.immutable.ListMap(m.toSeq.sortBy(_._1.toString): _*).toString.replace("ListMap", "Map")
  case d: Double => { val s = java.math.BigDecimal.valueOf(d).stripTrailingZeros.toPlainString; if (s.indexOf('.') < 0 && !s.contains("e") && !s.contains("E")) s + ".0" else s }
  case other => String.valueOf(other)
}

def _mod(x: Double, m: Double): Double = {
  return x - (BigInt((x / m).toString.toDouble.toInt)).toDouble * m
}

def sin_approx(x: Double): Double = {
  var y: Double = _mod(x + PI, TWO_PI) - PI
  var y2: Double = y * y
  var y3: Double = y2 * y
  var y5: Double = y3 * y2
  var y7: Double = y5 * y2
  return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
}

def cos_approx(x: Double): Double = {
  var y: Double = _mod(x + PI, TWO_PI) - PI
  var y2: Double = y * y
  var y4: Double = y2 * y2
  var y6: Double = y4 * y2
  return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
}

def tan_approx(x: Double): Double = {
  return sin_approx(x) / cos_approx(x)
}

def sqrt_approx(x: Double): Double = {
  if (x <= 0.0) {
    return 0.0
  }
  var guess: Double = x / 2.0
  var i: BigInt = BigInt(0)
  while (i < BigInt(20)) {
    guess = (guess + x / guess) / 2.0
    i = i + BigInt(1)
  }
  return guess
}

def surface_area_cube(side_length: Double): Double = {
  if (side_length < 0.0) {
    println(_str("ValueError: surface_area_cube() only accepts non-negative values"))
    return 0.0
  }
  return 6.0 * side_length * side_length
}

def surface_area_cuboid(length: Double, breadth: Double, height: Double): Double = {
  if (((length < 0.0 || breadth < 0.0).asInstanceOf[Boolean] || height < 0.0)) {
    println(_str("ValueError: surface_area_cuboid() only accepts non-negative values"))
    return 0.0
  }
  return 2.0 * (length * breadth + breadth * height + length * height)
}

def surface_area_sphere(radius: Double): Double = {
  if (radius < 0.0) {
    println(_str("ValueError: surface_area_sphere() only accepts non-negative values"))
    return 0.0
  }
  return 4.0 * PI * radius * radius
}

def surface_area_hemisphere(radius: Double): Double = {
  if (radius < 0.0) {
    println(_str("ValueError: surface_area_hemisphere() only accepts non-negative values"))
    return 0.0
  }
  return 3.0 * PI * radius * radius
}

def surface_area_cone(radius: Double, height: Double): Double = {
  if ((radius < 0.0 || height < 0.0)) {
    println(_str("ValueError: surface_area_cone() only accepts non-negative values"))
    return 0.0
  }
  var slant: Double = sqrt_approx(height * height + radius * radius)
  return PI * radius * (radius + slant)
}

def surface_area_conical_frustum(radius1: Double, radius2: Double, height: Double): Double = {
  if (((radius1 < 0.0 || radius2 < 0.0).asInstanceOf[Boolean] || height < 0.0)) {
    println(_str("ValueError: surface_area_conical_frustum() only accepts non-negative values"))
    return 0.0
  }
  var slant: Double = sqrt_approx(height * height + (radius1 - radius2) * (radius1 - radius2))
  return PI * (slant * (radius1 + radius2) + radius1 * radius1 + radius2 * radius2)
}

def surface_area_cylinder(radius: Double, height: Double): Double = {
  if ((radius < 0.0 || height < 0.0)) {
    println(_str("ValueError: surface_area_cylinder() only accepts non-negative values"))
    return 0.0
  }
  return 2.0 * PI * radius * (height + radius)
}

def surface_area_torus(torus_radius: Double, tube_radius: Double): Double = {
  if ((torus_radius < 0.0 || tube_radius < 0.0)) {
    println(_str("ValueError: surface_area_torus() only accepts non-negative values"))
    return 0.0
  }
  if (torus_radius < tube_radius) {
    println(_str("ValueError: surface_area_torus() does not support spindle or self intersecting tori"))
    return 0.0
  }
  return 4.0 * PI * PI * torus_radius * tube_radius
}

def area_rectangle(length: Double, width: Double): Double = {
  if ((length < 0.0 || width < 0.0)) {
    println(_str("ValueError: area_rectangle() only accepts non-negative values"))
    return 0.0
  }
  return length * width
}

def area_square(side_length: Double): Double = {
  if (side_length < 0.0) {
    println(_str("ValueError: area_square() only accepts non-negative values"))
    return 0.0
  }
  return side_length * side_length
}

def area_triangle(base: Double, height: Double): Double = {
  if ((base < 0.0 || height < 0.0)) {
    println(_str("ValueError: area_triangle() only accepts non-negative values"))
    return 0.0
  }
  return base * height / 2.0
}

def area_triangle_three_sides(side1: Double, side2: Double, side3: Double): Double = {
  if (((side1 < 0.0 || side2 < 0.0).asInstanceOf[Boolean] || side3 < 0.0)) {
    println(_str("ValueError: area_triangle_three_sides() only accepts non-negative values"))
    return 0.0
  }
  if (((side1 + side2 < side3 || side1 + side3 < side2).asInstanceOf[Boolean] || side2 + side3 < side1)) {
    println(_str("ValueError: Given three sides do not form a triangle"))
    return 0.0
  }
  var s: Double = (side1 + side2 + side3) / 2.0
  var prod: Double = s * (s - side1) * (s - side2) * (s - side3)
  var res: Double = sqrt_approx(prod)
  return res
}

def area_parallelogram(base: Double, height: Double): Double = {
  if ((base < 0.0 || height < 0.0)) {
    println(_str("ValueError: area_parallelogram() only accepts non-negative values"))
    return 0.0
  }
  return base * height
}

def area_trapezium(base1: Double, base2: Double, height: Double): Double = {
  if (((base1 < 0.0 || base2 < 0.0).asInstanceOf[Boolean] || height < 0.0)) {
    println(_str("ValueError: area_trapezium() only accepts non-negative values"))
    return 0.0
  }
  return 0.5 * (base1 + base2) * height
}

def area_circle(radius: Double): Double = {
  if (radius < 0.0) {
    println(_str("ValueError: area_circle() only accepts non-negative values"))
    return 0.0
  }
  return PI * radius * radius
}

def area_ellipse(radius_x: Double, radius_y: Double): Double = {
  if ((radius_x < 0.0 || radius_y < 0.0)) {
    println(_str("ValueError: area_ellipse() only accepts non-negative values"))
    return 0.0
  }
  return PI * radius_x * radius_y
}

def area_rhombus(diagonal1: Double, diagonal2: Double): Double = {
  if ((diagonal1 < 0.0 || diagonal2 < 0.0)) {
    println(_str("ValueError: area_rhombus() only accepts non-negative values"))
    return 0.0
  }
  return 0.5 * diagonal1 * diagonal2
}

def area_reg_polygon(sides: BigInt, length: Double): Double = {
  if (sides < BigInt(3)) {
    println(_str("ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides"))
    return 0.0
  }
  if (length < 0.0) {
    println(_str("ValueError: area_reg_polygon() only accepts non-negative values as length of a side"))
    return 0.0
  }
  var n: Double = sides.toString.toDouble
  return n * length * length / (4.0 * tan_approx(PI / n))
}

var PI: Double = 3.141592653589793

var TWO_PI: Double = 6.283185307179586

var TRI_THREE_SIDES: Double = area_triangle_three_sides(5.0, 12.0, 13.0)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(_str("[DEMO] Areas of various geometric shapes:"))
    println(_str("Rectangle: " + _str(area_rectangle(10.0, 20.0))))
    println(_str("Square: " + _str(area_square(10.0))))
    println(_str("Triangle: " + _str(area_triangle(10.0, 10.0))))
    println(_str("Triangle Three Sides: " + _str(TRI_THREE_SIDES)))
    println(_str("Parallelogram: " + _str(area_parallelogram(10.0, 20.0))))
    println(_str("Rhombus: " + _str(area_rhombus(10.0, 20.0))))
    println(_str("Trapezium: " + _str(area_trapezium(10.0, 20.0, 30.0))))
    println(_str("Circle: " + _str(area_circle(20.0))))
    println(_str("Ellipse: " + _str(area_ellipse(10.0, 20.0))))
    println(_str(""))
    println(_str("Surface Areas of various geometric shapes:"))
    println(_str("Cube: " + _str(surface_area_cube(20.0))))
    println(_str("Cuboid: " + _str(surface_area_cuboid(10.0, 20.0, 30.0))))
    println(_str("Sphere: " + _str(surface_area_sphere(20.0))))
    println(_str("Hemisphere: " + _str(surface_area_hemisphere(20.0))))
    println(_str("Cone: " + _str(surface_area_cone(10.0, 20.0))))
    println(_str("Conical Frustum: " + _str(surface_area_conical_frustum(10.0, 20.0, 30.0))))
    println(_str("Cylinder: " + _str(surface_area_cylinder(10.0, 20.0))))
    println(_str("Torus: " + _str(surface_area_torus(20.0, 10.0))))
    println(_str("Equilateral Triangle: " + _str(area_reg_polygon(BigInt(3), 10.0))))
    println(_str("Square: " + _str(area_reg_polygon(BigInt(4), 10.0))))
    println(_str("Regular Pentagon: " + _str(area_reg_polygon(BigInt(5), 10.0))))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
