// Generated by Mochi v0.10.59 on 2025-08-07 12:49:22 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Fraction(var numerator: BigInt, var denominator: BigInt)

def pow10(n: BigInt): BigInt = {
  var result: BigInt = BigInt(1)
  var i: BigInt = BigInt(0)
  while (i < n) {
    result = result * BigInt(10)
    i = i + BigInt(1)
  }
  return result
}

def gcd(a: BigInt, b: BigInt): BigInt = {
  var x: BigInt = a
  var y: BigInt = b
  if (x < BigInt(0)) {
    x = -x
  }
  if (y < BigInt(0)) {
    y = -y
  }
  while (y != BigInt(0)) {
    val r: BigInt = x % y
    x = y
    y = r
  }
  return x
}

def parse_decimal(s: String): Fraction = {
  if (BigInt((s).size) == BigInt(0)) {
    throw new RuntimeException(String.valueOf("invalid number"))
  }
  var idx: BigInt = BigInt(0)
  var sign: BigInt = BigInt(1)
  val first: String = s.slice((BigInt(0)).toInt, (BigInt(1)).toInt)
  if (first == "-") {
    sign = -BigInt(1)
    idx = BigInt(1)
  } else {
    if (first == "+") {
      idx = BigInt(1)
    }
  }
  var int_part: String = ""
  val _br2 = new Breaks
  _br2.breakable {
    while (idx < BigInt((s).size)) {
      val c: String = s.slice((idx).toInt, (idx + BigInt(1)).toInt)
      if ((c.charAt(BigInt(0)) >= '0' && c.charAt(BigInt(0)) <= '9').asInstanceOf[Boolean]) {
        int_part = int_part + c
        idx = idx + BigInt(1)
      } else {
        _br2.break()
      }
    }
  }
  var frac_part: String = ""
  if ((idx < BigInt((s).size) && s.slice((idx).toInt, (idx + BigInt(1)).toInt) == ".").asInstanceOf[Boolean]) {
    idx = idx + BigInt(1)
    val _br3 = new Breaks
    _br3.breakable {
      while (idx < BigInt((s).size)) {
        val c: String = s.slice((idx).toInt, (idx + BigInt(1)).toInt)
        if ((c.charAt(BigInt(0)) >= '0' && c.charAt(BigInt(0)) <= '9').asInstanceOf[Boolean]) {
          frac_part = frac_part + c
          idx = idx + BigInt(1)
        } else {
          _br3.break()
        }
      }
    }
  }
  var exp: BigInt = BigInt(0)
  if ((idx < BigInt((s).size) && (s.slice((idx).toInt, (idx + BigInt(1)).toInt) == "e" || s.slice((idx).toInt, (idx + BigInt(1)).toInt) == "E").asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
    idx = idx + BigInt(1)
    var exp_sign: BigInt = BigInt(1)
    if ((idx < BigInt((s).size) && s.slice((idx).toInt, (idx + BigInt(1)).toInt) == "-").asInstanceOf[Boolean]) {
      exp_sign = -BigInt(1)
      idx = idx + BigInt(1)
    } else {
      if ((idx < BigInt((s).size) && s.slice((idx).toInt, (idx + BigInt(1)).toInt) == "+").asInstanceOf[Boolean]) {
        idx = idx + BigInt(1)
      }
    }
    var exp_str: String = ""
    while (idx < BigInt((s).size)) {
      val c: String = s.slice((idx).toInt, (idx + BigInt(1)).toInt)
      if ((c.charAt(BigInt(0)) >= '0' && c.charAt(BigInt(0)) <= '9').asInstanceOf[Boolean]) {
        exp_str = exp_str + c
        idx = idx + BigInt(1)
      } else {
        throw new RuntimeException(String.valueOf("invalid number"))
      }
    }
    if (BigInt((exp_str).size) == BigInt(0)) {
      throw new RuntimeException(String.valueOf("invalid number"))
    }
    exp = exp_sign * BigInt(exp_str.toString.toDouble.toInt)
  }
  if (idx != BigInt((s).size)) {
    throw new RuntimeException(String.valueOf("invalid number"))
  }
  if (BigInt((int_part).size) == BigInt(0)) {
    int_part = "0"
  }
  var num_str: String = int_part + frac_part
  var numerator: BigInt = BigInt(num_str.toString.toDouble.toInt)
  if (sign == BigInt(0) - BigInt(1)) {
    numerator = BigInt(0) - numerator
  }
  var denominator: BigInt = pow10(BigInt((frac_part).size))
  if (exp > BigInt(0)) {
    numerator = numerator * pow10(exp)
  } else {
    if (exp < BigInt(0)) {
      denominator = denominator * pow10(-exp)
    }
  }
  return Fraction(numerator, denominator)
}

def reduce(fr: Fraction): Fraction = {
  val g: BigInt = gcd(fr.asInstanceOf[Fraction].numerator, fr.asInstanceOf[Fraction].denominator)
  return Fraction(fr.asInstanceOf[Fraction].numerator / g, fr.asInstanceOf[Fraction].denominator / g)
}

def decimal_to_fraction_str(s: String): Fraction = {
  return reduce(parse_decimal(s))
}

def decimal_to_fraction(x: Double): Fraction = {
  return decimal_to_fraction_str(String.valueOf(x))
}

def assert_fraction(name: String, fr: Fraction, num: BigInt, den: BigInt): Any = {
  if ((fr.asInstanceOf[Fraction].numerator != num || fr.asInstanceOf[Fraction].denominator != den).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf(name))
  }
}

def test_decimal_to_fraction(): Any = {
  assert_fraction("case1", decimal_to_fraction(2.0), BigInt(2), BigInt(1))
  assert_fraction("case2", decimal_to_fraction(89.0), BigInt(89), BigInt(1))
  assert_fraction("case3", decimal_to_fraction_str("67"), BigInt(67), BigInt(1))
  assert_fraction("case4", decimal_to_fraction_str("45.0"), BigInt(45), BigInt(1))
  assert_fraction("case5", decimal_to_fraction(1.5), BigInt(3), BigInt(2))
  assert_fraction("case6", decimal_to_fraction_str("6.25"), BigInt(25), BigInt(4))
  assert_fraction("case7", decimal_to_fraction(0.0), BigInt(0), BigInt(1))
  assert_fraction("case8", decimal_to_fraction(-2.5), -BigInt(5), BigInt(2))
  assert_fraction("case9", decimal_to_fraction(0.125), BigInt(1), BigInt(8))
  assert_fraction("case10", decimal_to_fraction(1000000.25), BigInt(4000001), BigInt(4))
  assert_fraction("case11", decimal_to_fraction(1.3333), BigInt(13333), BigInt(10000))
  assert_fraction("case12", decimal_to_fraction_str("1.23e2"), BigInt(123), BigInt(1))
  assert_fraction("case13", decimal_to_fraction_str("0.500"), BigInt(1), BigInt(2))
}

def main(): Any = {
  test_decimal_to_fraction()
  val fr: Fraction = decimal_to_fraction(1.5)
  println(String.valueOf(fr.asInstanceOf[Fraction].numerator) + "/" + String.valueOf(fr.asInstanceOf[Fraction].denominator))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
