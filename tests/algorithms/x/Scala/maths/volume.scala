// Generated by Mochi v0.10.61 on 2025-08-08 18:02:51 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole()) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

def minf(a: Double, b: Double): Double = {
  if (a < b) {
    return a
  }
  return b
}

def maxf(a: Double, b: Double): Double = {
  if (a > b) {
    return a
  }
  return b
}

def vol_cube(side_length: Double): Double = {
  if (side_length < 0.0) {
    throw new RuntimeException(String.valueOf("vol_cube() only accepts non-negative values"))
  }
  return side_length * side_length * side_length
}

def vol_spherical_cap(height: Double, radius: Double): Double = {
  if ((height < 0.0 || radius < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_spherical_cap() only accepts non-negative values"))
  }
  return 1.0 / 3.0 * PI * height * height * (3.0 * radius - height)
}

def vol_sphere(radius: Double): Double = {
  if (radius < 0.0) {
    throw new RuntimeException(String.valueOf("vol_sphere() only accepts non-negative values"))
  }
  return 4.0 / 3.0 * PI * radius * radius * radius
}

def vol_spheres_intersect(radius_1: Double, radius_2: Double, centers_distance: Double): Double = {
  if (((radius_1 < 0.0 || radius_2 < 0.0).asInstanceOf[Boolean] || centers_distance < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_spheres_intersect() only accepts non-negative values"))
  }
  if (centers_distance == 0.0) {
    return vol_sphere(minf(radius_1, radius_2))
  }
  val h1: Double = (radius_1 - radius_2 + centers_distance) * (radius_1 + radius_2 - centers_distance) / (2.0 * centers_distance)
  val h2: Double = (radius_2 - radius_1 + centers_distance) * (radius_2 + radius_1 - centers_distance) / (2.0 * centers_distance)
  return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)
}

def vol_spheres_union(radius_1: Double, radius_2: Double, centers_distance: Double): Double = {
  if (((radius_1 <= 0.0 || radius_2 <= 0.0).asInstanceOf[Boolean] || centers_distance < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_spheres_union() only accepts non-negative values, non-zero radius"))
  }
  if (centers_distance == 0.0) {
    return vol_sphere(maxf(radius_1, radius_2))
  }
  return vol_sphere(radius_1) + vol_sphere(radius_2) - vol_spheres_intersect(radius_1, radius_2, centers_distance)
}

def vol_cuboid(width: Double, height: Double, length: Double): Double = {
  if (((width < 0.0 || height < 0.0).asInstanceOf[Boolean] || length < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_cuboid() only accepts non-negative values"))
  }
  return width * height * length
}

def vol_cone(area_of_base: Double, height: Double): Double = {
  if ((height < 0.0 || area_of_base < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_cone() only accepts non-negative values"))
  }
  return area_of_base * height / 3.0
}

def vol_right_circ_cone(radius: Double, height: Double): Double = {
  if ((height < 0.0 || radius < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_right_circ_cone() only accepts non-negative values"))
  }
  return PI * radius * radius * height / 3.0
}

def vol_prism(area_of_base: Double, height: Double): Double = {
  if ((height < 0.0 || area_of_base < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_prism() only accepts non-negative values"))
  }
  return area_of_base * height
}

def vol_pyramid(area_of_base: Double, height: Double): Double = {
  if ((height < 0.0 || area_of_base < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_pyramid() only accepts non-negative values"))
  }
  return area_of_base * height / 3.0
}

def vol_hemisphere(radius: Double): Double = {
  if (radius < 0.0) {
    throw new RuntimeException(String.valueOf("vol_hemisphere() only accepts non-negative values"))
  }
  return radius * radius * radius * PI * 2.0 / 3.0
}

def vol_circular_cylinder(radius: Double, height: Double): Double = {
  if ((height < 0.0 || radius < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_circular_cylinder() only accepts non-negative values"))
  }
  return radius * radius * height * PI
}

def vol_hollow_circular_cylinder(inner_radius: Double, outer_radius: Double, height: Double): Double = {
  if (((inner_radius < 0.0 || outer_radius < 0.0).asInstanceOf[Boolean] || height < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_hollow_circular_cylinder() only accepts non-negative values"))
  }
  if (outer_radius <= inner_radius) {
    throw new RuntimeException(String.valueOf("outer_radius must be greater than inner_radius"))
  }
  return PI * (outer_radius * outer_radius - inner_radius * inner_radius) * height
}

def vol_conical_frustum(height: Double, radius_1: Double, radius_2: Double): Double = {
  if (((radius_1 < 0.0 || radius_2 < 0.0).asInstanceOf[Boolean] || height < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_conical_frustum() only accepts non-negative values"))
  }
  return 1.0 / 3.0 * PI * height * (radius_1 * radius_1 + radius_2 * radius_2 + radius_1 * radius_2)
}

def vol_torus(torus_radius: Double, tube_radius: Double): Double = {
  if ((torus_radius < 0.0 || tube_radius < 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("vol_torus() only accepts non-negative values"))
  }
  return 2.0 * PI * PI * torus_radius * tube_radius * tube_radius
}

def vol_icosahedron(tri_side: Double): Double = {
  if (tri_side < 0.0) {
    throw new RuntimeException(String.valueOf("vol_icosahedron() only accepts non-negative values"))
  }
  return tri_side * tri_side * tri_side * (3.0 + SQRT5) * 5.0 / 12.0
}

def main(): Any = {
  println("Volumes:")
  println("Cube: " + _str(vol_cube(2.0)))
  println("Cuboid: " + _str(vol_cuboid(2.0, 2.0, 2.0)))
  println("Cone: " + _str(vol_cone(2.0, 2.0)))
  println("Right Circular Cone: " + _str(vol_right_circ_cone(2.0, 2.0)))
  println("Prism: " + _str(vol_prism(2.0, 2.0)))
  println("Pyramid: " + _str(vol_pyramid(2.0, 2.0)))
  println("Sphere: " + _str(vol_sphere(2.0)))
  println("Hemisphere: " + _str(vol_hemisphere(2.0)))
  println("Circular Cylinder: " + _str(vol_circular_cylinder(2.0, 2.0)))
  println("Torus: " + _str(vol_torus(2.0, 2.0)))
  println("Conical Frustum: " + _str(vol_conical_frustum(2.0, 2.0, 4.0)))
  println("Spherical cap: " + _str(vol_spherical_cap(1.0, 2.0)))
  println("Spheres intersection: " + _str(vol_spheres_intersect(2.0, 2.0, 1.0)))
  println("Spheres union: " + _str(vol_spheres_union(2.0, 2.0, 1.0)))
  println("Hollow Circular Cylinder: " + _str(vol_hollow_circular_cylinder(1.0, 2.0, 3.0)))
  println("Icosahedron: " + _str(vol_icosahedron(2.5)))
}

val PI: Double = 3.141592653589793

val SQRT5: Double = 2.23606797749979

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
