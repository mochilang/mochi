// Generated by Mochi v0.10.63 on 2025-08-12 08:00:43 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class TextCounts(var single: scala.collection.mutable.Map[String,BigInt], var double: scala.collection.mutable.Map[String,BigInt])

def log2(x: Double): Double = {
  var k: Double = 0.0
  var v: Double = x
  while (v >= 2.0) {
    v = v / 2.0
    k = k + 1.0
  }
  while (v < 1.0) {
    v = v * 2.0
    k = k - 1.0
  }
  val z: Double = (v - 1.0) / (v + 1.0)
  var zpow: Double = z
  var sum: Double = z
  var i: BigInt = BigInt(3)
  while (i <= BigInt(9)) {
    zpow = zpow * z * z
    sum = sum + zpow / i.toString.toDouble
    i = i + BigInt(2)
  }
  val ln2: Double = 0.6931471805599453
  return k + 2.0 * sum / ln2
}

def analyze_text(text: String): TextCounts = {
  var single: scala.collection.mutable.Map[String,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,BigInt]]
  var double: scala.collection.mutable.Map[String,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,BigInt]]
  val n: BigInt = BigInt((text).size)
  if (n == BigInt(0)) {
    return TextCounts(single, double)
  }
  val last: String = text.slice((n - BigInt(1)).toInt, (n).toInt)
  if ((single.contains(last)).asInstanceOf[Boolean]) {
    single.update(last, single.getOrElse(last.toString, BigInt(0)).asInstanceOf[BigInt] + BigInt(1))
  } else {
    single.update(last, BigInt(1))
  }
  val first: String = text.slice((BigInt(0)).toInt, (BigInt(1)).toInt)
  val pair0: String = " " + first
  double.update(pair0, BigInt(1))
  var i: BigInt = BigInt(0)
  while (i < n - BigInt(1)) {
    val ch: String = text.slice((i).toInt, (i + BigInt(1)).toInt)
    if ((single.contains(ch)).asInstanceOf[Boolean]) {
      single.update(ch, single.getOrElse(ch.toString, BigInt(0)).asInstanceOf[BigInt] + BigInt(1))
    } else {
      single.update(ch, BigInt(1))
    }
    val seq: String = text.slice((i).toInt, (i + BigInt(2)).toInt)
    if ((double.contains(seq)).asInstanceOf[Boolean]) {
      double.update(seq, double.getOrElse(seq.toString, BigInt(0)).asInstanceOf[BigInt] + BigInt(1))
    } else {
      double.update(seq, BigInt(1))
    }
    i = i + BigInt(1)
  }
  return TextCounts(single, double)
}

def round_to_int(x: Double): BigInt = {
  if (x < 0.0) {
    return BigInt((x - 0.5).toInt)
  }
  return BigInt((x + 0.5).toInt)
}

def calculate_entropy(text: String): Any = {
  val counts: TextCounts = analyze_text(text)
  val alphas: String = " abcdefghijklmnopqrstuvwxyz"
  var total1: BigInt = BigInt(0)
  for (ch <- counts.asInstanceOf[TextCounts].single.keys) {
    total1 = total1 + counts.asInstanceOf[TextCounts].single.getOrElse(ch.toString, BigInt(0)).asInstanceOf[BigInt]
  }
  var h1: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((alphas).size)) {
    val ch: String = alphas.slice((i).toInt, (i + BigInt(1)).toInt)
    if ((counts.asInstanceOf[TextCounts].single.contains(ch)).asInstanceOf[Boolean]) {
      val prob: Double = (counts.asInstanceOf[TextCounts].single.getOrElse(ch.toString, BigInt(0)).asInstanceOf[BigInt]).toDouble / total1.toString.toDouble
      h1 = h1 + prob * log2(prob)
    }
    i = i + BigInt(1)
  }
  val first_entropy: Double = -h1
  println(_str(round_to_int(first_entropy)) + ".0")
  var total2: BigInt = BigInt(0)
  for (seq <- counts.asInstanceOf[TextCounts].double.keys) {
    total2 = total2 + counts.asInstanceOf[TextCounts].double.getOrElse(seq.toString, BigInt(0)).asInstanceOf[BigInt]
  }
  var h2: Double = 0.0
  var a0: BigInt = BigInt(0)
  while (a0 < BigInt((alphas).size)) {
    val ch0: String = alphas.slice((a0).toInt, (a0 + BigInt(1)).toInt)
    var a1: BigInt = BigInt(0)
    while (a1 < BigInt((alphas).size)) {
      val ch1: String = alphas.slice((a1).toInt, (a1 + BigInt(1)).toInt)
      val seq: String = ch0 + ch1
      if ((counts.asInstanceOf[TextCounts].double.contains(seq)).asInstanceOf[Boolean]) {
        val prob: Double = (counts.asInstanceOf[TextCounts].double.getOrElse(seq.toString, BigInt(0)).asInstanceOf[BigInt]).toDouble / total2.toString.toDouble
        h2 = h2 + prob * log2(prob)
      }
      a1 = a1 + BigInt(1)
    }
    a0 = a0 + BigInt(1)
  }
  val second_entropy: Double = -h2
  println(_str(round_to_int(second_entropy)) + ".0")
  val diff: Double = second_entropy - first_entropy
  println(_str(round_to_int(diff)) + ".0")
}

val text1: String = "Behind Winston's back the voice " + "from the telescreen was still " + "babbling and the overfulfilment"

val text3: String = "Had repulsive dashwoods suspicion sincerity but advantage now him. " + "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. " + "You greatest jointure saw horrible. He private he on be imagine " + "suppose. Fertile beloved evident through no service elderly is. Blind " + "there if every no so at. Own neglected you preferred way sincerity " + "delivered his attempted. To of message cottage windows do besides " + "against uncivil.  Delightful unreserved impossible few estimating " + "men favourable see entreaties. She propriety immediate was improving. " + "He or entrance humoured likewise moderate. Much nor game son say " + "feel. Fat make met can must form into gate. Me we offending prevailed " + "discovery."

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    calculate_entropy(text1)
    calculate_entropy(text3)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
