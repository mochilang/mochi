// Generated by Mochi v0.10.59 on 2025-08-07 08:47:25 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Node(var key: BigInt, var freq: BigInt)

def sort_nodes(nodes: ArrayBuffer[Node]): ArrayBuffer[Node] = {
  var arr: ArrayBuffer[Node] = nodes
  var i: BigInt = 1
  val _br0 = new Breaks
  _br0.breakable {
    while (i < BigInt((arr).size)) {
      val key_node: Node = arr((i.toInt).toInt)
      var j: BigInt = i - 1
      val _br1 = new Breaks
      _br1.breakable {
        while (j >= 0) {
          val temp: Node = arr((j.toInt).toInt)
          if (temp.asInstanceOf[Node].key > key_node.asInstanceOf[Node].key) {
            arr((j + 1).toInt) = temp
            j = j - 1
          } else {
            _br1.break()
          }
        }
      }
      arr((j + 1).toInt) = key_node
      i = i + 1
    }
  }
  return arr
}

def print_node(n: Node): Any = {
  println("Node(key=" + String.valueOf(n.asInstanceOf[Node].key) + ", freq=" + String.valueOf(n.asInstanceOf[Node].freq) + ")")
}

def print_binary_search_tree(root: ArrayBuffer[ArrayBuffer[BigInt]], keys: ArrayBuffer[BigInt], i: BigInt, j: BigInt, parent: BigInt, is_left: Boolean): Any = {
  if (((i > j || i < 0).asInstanceOf[Boolean] || j > BigInt((root).size) - 1).asInstanceOf[Boolean]) {
    return
  }
  val node: BigInt = root((i.toInt).toInt)((j.toInt).toInt)
  if (parent == -1) {
    println(String.valueOf(keys((node.toInt).toInt)) + " is the root of the binary search tree.")
  } else {
    if (is_left) {
      println(String.valueOf(keys((node.toInt).toInt)) + " is the left child of key " + String.valueOf(parent) + ".")
    } else {
      println(String.valueOf(keys((node.toInt).toInt)) + " is the right child of key " + String.valueOf(parent) + ".")
    }
  }
  print_binary_search_tree(root, keys, i, node - 1, keys((node.toInt).toInt), true)
  print_binary_search_tree(root, keys, node + 1, j, keys((node.toInt).toInt), false)
  return null
}

def find_optimal_binary_search_tree(original_nodes: ArrayBuffer[Node]): Any = {
  var nodes: ArrayBuffer[Node] = sort_nodes(original_nodes)
  val n: BigInt = BigInt((nodes).size)
  var keys: ArrayBuffer[BigInt] = ArrayBuffer()
  var freqs: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < n) {
    val node: Node = nodes((i.toInt).toInt)
    keys = keys :+ node.asInstanceOf[Node].key
    freqs = freqs :+ node.asInstanceOf[Node].freq
    i = i + 1
  }
  var dp: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var total: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var root: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  i = 0
  while (i < n) {
    var dp_row: ArrayBuffer[BigInt] = ArrayBuffer()
    var total_row: ArrayBuffer[BigInt] = ArrayBuffer()
    var root_row: ArrayBuffer[BigInt] = ArrayBuffer()
    var j: BigInt = 0
    while (j < n) {
      if (i == j) {
        dp_row = dp_row :+ freqs((i.toInt).toInt)
        total_row = total_row :+ freqs((i.toInt).toInt)
        root_row = root_row :+ i
      } else {
        dp_row = dp_row :+ BigInt(0)
        total_row = total_row :+ BigInt(0)
        root_row = root_row :+ BigInt(0)
      }
      j = j + 1
    }
    dp = dp :+ dp_row
    total = total :+ total_row
    root = root :+ root_row
    i = i + 1
  }
  var interval_length: BigInt = 2
  val INF: BigInt = 2147483647
  while (interval_length <= n) {
    i = 0
    while (i < n - interval_length + 1) {
      var j: BigInt = i + interval_length - 1
      dp((i).toInt)((j).toInt) = INF
      total((i).toInt)((j).toInt) = total((i.toInt).toInt)(((j - 1).toInt).toInt) + freqs((j.toInt).toInt)
      var r: BigInt = root((i.toInt).toInt)(((j - 1).toInt).toInt)
      while (r <= root(((i + 1).toInt).toInt)((j.toInt).toInt)) {
        val left: BigInt = (if (r != i) dp((i.toInt).toInt)(((r - 1).toInt).toInt) else 0)
        val right: BigInt = (if (r != j) dp(((r + 1).toInt).toInt)((j.toInt).toInt) else 0)
        val cost: BigInt = left + total((i.toInt).toInt)((j.toInt).toInt) + right
        if (dp((i.toInt).toInt)((j.toInt).toInt) > cost) {
          dp((i).toInt)((j).toInt) = cost
          root((i).toInt)((j).toInt) = r
        }
        r = r + 1
      }
      i = i + 1
    }
    interval_length = interval_length + 1
  }
  println("Binary search tree nodes:")
  i = 0
  while (i < n) {
    print_node(nodes((i.toInt).toInt))
    i = i + 1
  }
  println("\nThe cost of optimal BST for given tree nodes is " + String.valueOf(dp((0.toInt).toInt)(((n - 1).toInt).toInt)) + ".")
  print_binary_search_tree(root, keys, 0, n - 1, -1, false)
}

def main(): Any = {
  val nodes: ArrayBuffer[Node] = ArrayBuffer(Node(12, 8), Node(10, 34), Node(20, 50), Node(42, 3), Node(25, 40), Node(37, 30))
  find_optimal_binary_search_tree(nodes)
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
