// Generated by Mochi v0.10.63 on 2025-08-11 16:32:42 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class SearchProblem(var x: Double, var y: Double, var step: Double)

def score(p: SearchProblem, f: (Double, Double) => Double): Double = {
  return f(p.asInstanceOf[SearchProblem].x, p.asInstanceOf[SearchProblem].y)
}

def get_neighbors(p: SearchProblem): ArrayBuffer[SearchProblem] = {
  val s: Double = p.asInstanceOf[SearchProblem].step
  var ns: ArrayBuffer[SearchProblem] = ArrayBuffer[SearchProblem]()
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x - s, p.asInstanceOf[SearchProblem].y - s, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x - s, p.asInstanceOf[SearchProblem].y, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x - s, p.asInstanceOf[SearchProblem].y + s, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x, p.asInstanceOf[SearchProblem].y - s, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x, p.asInstanceOf[SearchProblem].y + s, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x + s, p.asInstanceOf[SearchProblem].y - s, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x + s, p.asInstanceOf[SearchProblem].y, s))
  ns = ns :+ (SearchProblem(p.asInstanceOf[SearchProblem].x + s, p.asInstanceOf[SearchProblem].y + s, s))
  return ns
}

def remove_at(lst: ArrayBuffer[SearchProblem], idx: BigInt): ArrayBuffer[SearchProblem] = {
  var res: ArrayBuffer[SearchProblem] = ArrayBuffer[SearchProblem]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((lst).size)) {
    if (i != idx) {
      res = res :+ (lst.lift((i.toInt).toInt).getOrElse(null))
    }
    i = i + BigInt(1)
  }
  return res
}

def rand(): BigInt = {
  val _t: BigInt = _now()
  seed = (seed * BigInt(1103515245) + BigInt(12345)) % BigInt("2147483648")
  return seed
}

def random_float(): Double = {
  return (rand()).toString.toDouble / 2147483648.0
}

def randint(low: BigInt, high: BigInt): BigInt = {
  return rand() % (high - low + BigInt(1)) + low
}

def expApprox(x: Double): Double = {
  var y: Double = x
  var is_neg: Boolean = false
  if (x < 0.0) {
    is_neg = true
    y = -x
  }
  var term: Double = 1.0
  var sum: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n < BigInt(30)) {
    term = term * y / n.toString.toDouble
    sum = sum + term
    n = n + BigInt(1)
  }
  if (is_neg) {
    return 1.0 / sum
  }
  return sum
}

def simulated_annealing(search_prob: SearchProblem, f: (Double, Double) => Double, find_max: Boolean, max_x: Double, min_x: Double, max_y: Double, min_y: Double, start_temp: Double, rate_of_decrease: Double, threshold_temp: Double): SearchProblem = {
  var search_end: Boolean = false
  var current_state: SearchProblem = search_prob
  var current_temp: Double = start_temp
  var best_state: SearchProblem = current_state
  val _ct2 = new Breaks
  while (!search_end) {
    _ct2.breakable {
      val current_score: Double = score(current_state, f)
      if (score(best_state, f) < current_score) {
        best_state = current_state
      }
      var next_state: SearchProblem = current_state
      var found_next: Boolean = false
      var neighbors: ArrayBuffer[SearchProblem] = get_neighbors(current_state)
      val _ct3 = new Breaks
      while (!found_next && BigInt((neighbors).size) > BigInt(0)) {
        _ct3.breakable {
          val idx: BigInt = randint(BigInt(0), BigInt((neighbors).size) - BigInt(1))
          val picked_neighbor: SearchProblem = neighbors.lift((idx.toInt).toInt).getOrElse(null)
          neighbors = remove_at(neighbors, idx)
          if ((((picked_neighbor.asInstanceOf[SearchProblem].x > max_x || picked_neighbor.asInstanceOf[SearchProblem].x < min_x).asInstanceOf[Boolean] || picked_neighbor.asInstanceOf[SearchProblem].y > max_y).asInstanceOf[Boolean] || picked_neighbor.asInstanceOf[SearchProblem].y < min_y).asInstanceOf[Boolean]) {
            _ct3.break()
          }
          var change: Double = score(picked_neighbor, f) - current_score
          if (!find_max) {
            change = -change
          }
          if (change > 0.0) {
            next_state = picked_neighbor
            found_next = true
          } else {
            val probability: Double = expApprox(change / current_temp)
            if (random_float() < probability) {
              next_state = picked_neighbor
              found_next = true
            }
          }
        }
      }
      current_temp = current_temp - current_temp * rate_of_decrease
      if ((current_temp < threshold_temp || !found_next).asInstanceOf[Boolean]) {
        search_end = true
      } else {
        current_state = next_state
      }
    }
  }
  return best_state
}

def test_f1(x: Double, y: Double): Double = {
  return x * x + y * y
}

def test_f2(x: Double, y: Double): Double = {
  return 3.0 * x * x - 6.0 * y
}

def main(): Any = {
  val prob1: SearchProblem = SearchProblem(12.0, 47.0, 1.0)
  val min_state: SearchProblem = simulated_annealing(prob1, (test_f1 _).asInstanceOf[(Double, Double) => Double], false, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0)
  println((List("min1", test_f1(min_state.asInstanceOf[SearchProblem].x, min_state.asInstanceOf[SearchProblem].y))).mkString(" "))
  val prob2: SearchProblem = SearchProblem(12.0, 47.0, 1.0)
  val max_state: SearchProblem = simulated_annealing(prob2, (test_f1 _).asInstanceOf[(Double, Double) => Double], true, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0)
  println((List("max1", test_f1(max_state.asInstanceOf[SearchProblem].x, max_state.asInstanceOf[SearchProblem].y))).mkString(" "))
  val prob3: SearchProblem = SearchProblem(3.0, 4.0, 1.0)
  val min_state2: SearchProblem = simulated_annealing(prob3, (test_f2 _).asInstanceOf[(Double, Double) => Double], false, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0)
  println((List("min2", test_f2(min_state2.asInstanceOf[SearchProblem].x, min_state2.asInstanceOf[SearchProblem].y))).mkString(" "))
  val prob4: SearchProblem = SearchProblem(3.0, 4.0, 1.0)
  val max_state2: SearchProblem = simulated_annealing(prob4, (test_f2 _).asInstanceOf[(Double, Double) => Double], true, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0)
  println((List("max2", test_f2(max_state2.asInstanceOf[SearchProblem].x, max_state2.asInstanceOf[SearchProblem].y))).mkString(" "))
}

var seed: BigInt = BigInt(1)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
