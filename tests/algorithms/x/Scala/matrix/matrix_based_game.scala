// Generated by Mochi v0.10.64 on 2025-08-12 13:51:14 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class Coord(var x: BigInt, var y: BigInt)

case class PlayResult(var matrix: ArrayBuffer[ArrayBuffer[String]], var score: BigInt)

def is_alnum(ch: String): Boolean = {
  return (((ch.charAt(BigInt(0).toInt) >= '0' && ch.charAt(BigInt(0).toInt) <= '9').asInstanceOf[Boolean] || (ch.charAt(BigInt(0).toInt) >= 'A' && ch.charAt(BigInt(0).toInt) <= 'Z').asInstanceOf[Boolean]).asInstanceOf[Boolean] || (ch.charAt(BigInt(0).toInt) >= 'a' && ch.charAt(BigInt(0).toInt) <= 'z').asInstanceOf[Boolean]).asInstanceOf[Boolean]
}

def to_int(token: String): BigInt = {
  var res: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((token).size)) {
    res = res * BigInt(10) + BigInt((token.slice((i).toInt, (i + BigInt(1)).toInt)))
    i = i + BigInt(1)
  }
  return res
}

def split(s: String, sep: String): ArrayBuffer[String] = {
  var res: ArrayBuffer[String] = ArrayBuffer[String]()
  var current: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).size)) {
    val ch: String = s.slice((i).toInt, (i + BigInt(1)).toInt)
    if (ch == sep) {
      res = res :+ (current)
      current = ""
    } else {
      current = current + ch
    }
    i = i + BigInt(1)
  }
  res = res :+ (current)
  return res
}

def parse_moves(input_str: String): ArrayBuffer[Coord] = {
  val pairs: ArrayBuffer[String] = ArrayBuffer(input_str.split(","): _*)
  var moves: ArrayBuffer[Coord] = ArrayBuffer[Coord]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((pairs).size)) {
    val pair: String = pairs.lift((i.toInt).toInt).getOrElse("")
    var numbers: ArrayBuffer[String] = ArrayBuffer[String]()
    var num: String = ""
    var j: BigInt = BigInt(0)
    while (j < BigInt((pair).size)) {
      val ch: String = pair.slice((j).toInt, (j + BigInt(1)).toInt)
      if (ch == " ") {
        if (num != "") {
          numbers = numbers :+ (num)
          num = ""
        }
      } else {
        num = num + ch
      }
      j = j + BigInt(1)
    }
    if (num != "") {
      numbers = numbers :+ (num)
    }
    if (BigInt((numbers).size) != BigInt(2)) {
      throw new RuntimeException(String.valueOf("Each move must have exactly two numbers."))
    }
    val x: BigInt = to_int(numbers.lift((BigInt(0).toInt).toInt).getOrElse(""))
    val y: BigInt = to_int(numbers.lift((BigInt(1).toInt).toInt).getOrElse(""))
    moves = moves :+ (Coord(x, y))
    i = i + BigInt(1)
  }
  return moves
}

def validate_matrix_size(size: BigInt): Any = {
  if (size <= BigInt(0)) {
    throw new RuntimeException(String.valueOf("Matrix size must be a positive integer."))
  }
}

def validate_matrix_content(matrix: ArrayBuffer[String], size: BigInt): Any = {
  if (BigInt((matrix).size) != size) {
    throw new RuntimeException(String.valueOf("The matrix dont match with size."))
  }
  var i: BigInt = BigInt(0)
  while (i < size) {
    val row: String = matrix.lift((i.toInt).toInt).getOrElse("")
    if (BigInt((row).size) != size) {
      throw new RuntimeException(String.valueOf("Each row in the matrix must have exactly " + _str(size) + " characters."))
    }
    var j: BigInt = BigInt(0)
    while (j < size) {
      val ch: String = row.slice((j).toInt, (j + BigInt(1)).toInt)
      if (!is_alnum(ch)) {
        throw new RuntimeException(String.valueOf("Matrix rows can only contain letters and numbers."))
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
}

def validate_moves(moves: ArrayBuffer[Coord], size: BigInt): Any = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((moves).size)) {
    val mv: Coord = moves.lift((i.toInt).toInt).getOrElse(null)
    if ((((mv.asInstanceOf[Coord].x < BigInt(0) || mv.asInstanceOf[Coord].x >= size).asInstanceOf[Boolean] || mv.asInstanceOf[Coord].y < BigInt(0)).asInstanceOf[Boolean] || mv.asInstanceOf[Coord].y >= size).asInstanceOf[Boolean]) {
      throw new RuntimeException(String.valueOf("Move is out of bounds for a matrix."))
    }
    i = i + BigInt(1)
  }
}

def contains(pos: ArrayBuffer[Coord], r: BigInt, c: BigInt): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((pos).size)) {
    val p: Coord = pos.lift((i.toInt).toInt).getOrElse(null)
    if ((p.asInstanceOf[Coord].x == r && p.asInstanceOf[Coord].y == c).asInstanceOf[Boolean]) {
      return true
    }
    i = i + BigInt(1)
  }
  return false
}

def find_repeat(matrix_g: ArrayBuffer[ArrayBuffer[String]], row: BigInt, _column: BigInt, size: BigInt): ArrayBuffer[Coord] = {
  var column: BigInt = _column
  column = size - BigInt(1) - column
  var visited: ArrayBuffer[Coord] = ArrayBuffer[Coord]()
  var repeated: ArrayBuffer[Coord] = ArrayBuffer[Coord]()
  val color: String = matrix_g.lift((column.toInt).toInt).getOrElse(ArrayBuffer[String]()).lift((row.toInt).toInt).getOrElse("")
  if (color == "-") {
    return repeated
  }
  var stack: ArrayBuffer[Coord] = ArrayBuffer(Coord(column, row))
  val _ct8 = new Breaks
  while (BigInt((stack).size) > BigInt(0)) {
    _ct8.breakable {
      val idx: BigInt = BigInt((stack).size) - BigInt(1)
      val pos: Coord = stack.lift((idx.toInt).toInt).getOrElse(null)
      stack = stack.slice((BigInt(0)).toInt, (idx).toInt)
      if ((((pos.asInstanceOf[Coord].x < BigInt(0) || pos.asInstanceOf[Coord].x >= size).asInstanceOf[Boolean] || pos.asInstanceOf[Coord].y < BigInt(0)).asInstanceOf[Boolean] || pos.asInstanceOf[Coord].y >= size).asInstanceOf[Boolean]) {
        _ct8.break()
      }
      if (contains(visited, pos.asInstanceOf[Coord].x, pos.asInstanceOf[Coord].y)) {
        _ct8.break()
      }
      visited = visited :+ (pos)
      if (matrix_g.lift((pos.asInstanceOf[Coord].x.toInt).toInt).getOrElse(ArrayBuffer[String]()).lift((pos.asInstanceOf[Coord].y.toInt).toInt).getOrElse("") == color) {
        repeated = repeated :+ (pos)
        stack = stack :+ (Coord(pos.asInstanceOf[Coord].x - BigInt(1), pos.asInstanceOf[Coord].y))
        stack = stack :+ (Coord(pos.asInstanceOf[Coord].x + BigInt(1), pos.asInstanceOf[Coord].y))
        stack = stack :+ (Coord(pos.asInstanceOf[Coord].x, pos.asInstanceOf[Coord].y - BigInt(1)))
        stack = stack :+ (Coord(pos.asInstanceOf[Coord].x, pos.asInstanceOf[Coord].y + BigInt(1)))
      }
    }
  }
  return repeated
}

def increment_score(count: BigInt): BigInt = {
  return count * (count + BigInt(1)) / BigInt(2)
}

def move_x(matrix_g: ArrayBuffer[ArrayBuffer[String]], column: BigInt, size: BigInt): ArrayBuffer[ArrayBuffer[String]] = {
  var new_list: ArrayBuffer[String] = ArrayBuffer[String]()
  var row: BigInt = BigInt(0)
  while (row < size) {
    val `val`: String = matrix_g.lift((row.toInt).toInt).getOrElse(ArrayBuffer[String]()).lift((column.toInt).toInt).getOrElse("")
    if (`val` != "-") {
      new_list = new_list :+ (`val`)
    } else {
      new_list = (ArrayBuffer(`val`) ++ new_list).asInstanceOf[ArrayBuffer[String]]
    }
    row = row + BigInt(1)
  }
  row = BigInt(0)
  while (row < size) {
    matrix_g((row).toInt)((column).toInt) = new_list.lift((row.toInt).toInt).getOrElse("")
    row = row + BigInt(1)
  }
  return matrix_g
}

def move_y(matrix_g: ArrayBuffer[ArrayBuffer[String]], size: BigInt): ArrayBuffer[ArrayBuffer[String]] = {
  var empty_cols: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var column: BigInt = size - BigInt(1)
  val _br11 = new Breaks
  _br11.breakable {
    while (column >= BigInt(0)) {
      var row: BigInt = BigInt(0)
      var all_empty: Boolean = true
      val _br12 = new Breaks
      _br12.breakable {
        while (row < size) {
          if (matrix_g.lift((row.toInt).toInt).getOrElse(ArrayBuffer[String]()).lift((column.toInt).toInt).getOrElse("") != "-") {
            all_empty = false
            _br12.break()
          }
          row = row + BigInt(1)
        }
      }
      if (all_empty) {
        empty_cols = empty_cols :+ (column)
      }
      column = column - BigInt(1)
    }
  }
  var i: BigInt = BigInt(0)
  while (i < BigInt((empty_cols).size)) {
    val col: BigInt = empty_cols.lift((i.toInt).toInt).getOrElse(BigInt(0))
    var c: BigInt = col + BigInt(1)
    while (c < size) {
      var r: BigInt = BigInt(0)
      while (r < size) {
        matrix_g((r).toInt)((c - BigInt(1)).toInt) = matrix_g.lift((r.toInt).toInt).getOrElse(ArrayBuffer[String]()).lift((c.toInt).toInt).getOrElse("")
        r = r + BigInt(1)
      }
      c = c + BigInt(1)
    }
    var r: BigInt = BigInt(0)
    while (r < size) {
      matrix_g((r).toInt)((size - BigInt(1)).toInt) = "-"
      r = r + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return matrix_g
}

def play(_matrix_g: ArrayBuffer[ArrayBuffer[String]], pos_x: BigInt, pos_y: BigInt, size: BigInt): PlayResult = {
  var matrix_g: ArrayBuffer[ArrayBuffer[String]] = _matrix_g
  val same_colors: ArrayBuffer[Coord] = find_repeat(matrix_g, pos_x, pos_y, size)
  if (BigInt((same_colors).size) != BigInt(0)) {
    var i: BigInt = BigInt(0)
    while (i < BigInt((same_colors).size)) {
      val p: Coord = same_colors.lift((i.toInt).toInt).getOrElse(null)
      matrix_g((p.asInstanceOf[Coord].x).toInt)((p.asInstanceOf[Coord].y).toInt) = "-"
      i = i + BigInt(1)
    }
    var column: BigInt = BigInt(0)
    while (column < size) {
      matrix_g = move_x(matrix_g, column, size)
      column = column + BigInt(1)
    }
    matrix_g = move_y(matrix_g, size)
  }
  val sc: BigInt = increment_score(BigInt((same_colors).size))
  return PlayResult(matrix_g, sc)
}

def build_matrix(matrix: ArrayBuffer[String]): ArrayBuffer[ArrayBuffer[String]] = {
  var res: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer[ArrayBuffer[String]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((matrix).size)) {
    val row: String = matrix.lift((i.toInt).toInt).getOrElse("")
    var row_list: ArrayBuffer[String] = ArrayBuffer[String]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((row).size)) {
      row_list = row_list :+ (row.slice((j).toInt, (j + BigInt(1)).toInt))
      j = j + BigInt(1)
    }
    res = res :+ (row_list)
    i = i + BigInt(1)
  }
  return res
}

def process_game(size: BigInt, matrix: ArrayBuffer[String], moves: ArrayBuffer[Coord]): BigInt = {
  var game_matrix: ArrayBuffer[ArrayBuffer[String]] = build_matrix(matrix)
  var total: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((moves).size)) {
    val mv: Coord = moves.lift((i.toInt).toInt).getOrElse(null)
    val res: PlayResult = play(game_matrix, mv.asInstanceOf[Coord].x, mv.asInstanceOf[Coord].y, size)
    game_matrix = res.asInstanceOf[PlayResult].matrix
    total = total + res.asInstanceOf[PlayResult].score
    i = i + BigInt(1)
  }
  return total
}

def main(): Any = {
  val size: BigInt = BigInt(4)
  val matrix: ArrayBuffer[String] = ArrayBuffer("RRBG", "RBBG", "YYGG", "XYGG")
  val moves: ArrayBuffer[Coord] = parse_moves("0 1,1 1")
  validate_matrix_size(size)
  validate_matrix_content(matrix, size)
  validate_moves(moves, size)
  val score: BigInt = process_game(size, matrix, moves)
  println(_str(score))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
