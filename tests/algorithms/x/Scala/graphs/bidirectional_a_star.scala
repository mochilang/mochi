// Generated by Mochi v0.10.59 on 2025-08-07 09:54:19 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Pos(var y: BigInt, var x: BigInt)

case class Node(var pos: Pos, var g_cost: BigInt, var h_cost: Double, var f_cost: Double, var path: ArrayBuffer[Pos])

def abs(x: BigInt): BigInt = {
  if (x < 0) {
    return -x
  }
  return x
}

def sqrtApprox(x: Double): Double = {
  if (x <= 0.0) {
    return 0.0
  }
  var guess: Double = x
  var i: BigInt = 0
  while (i < 10) {
    guess = (guess + x / guess) / 2.0
    i = i + 1
  }
  return guess
}

def heuristic(a: Pos, b: Pos): Double = {
  val dy: BigInt = a.asInstanceOf[Pos].y - b.asInstanceOf[Pos].y
  val dx: BigInt = a.asInstanceOf[Pos].x - b.asInstanceOf[Pos].x
  if (HEURISTIC == 1) {
    return (dy.abs + dx.abs).toString.toDouble
  }
  val dyf: Double = dy.toString.toDouble
  val dxf: Double = dx.toString.toDouble
  return sqrtApprox(dyf * dyf + dxf * dxf)
}

def pos_equal(a: Pos, b: Pos): Boolean = {
  return (a.asInstanceOf[Pos].y == b.asInstanceOf[Pos].y && a.asInstanceOf[Pos].x == b.asInstanceOf[Pos].x).asInstanceOf[Boolean]
}

def contains_pos(lst: ArrayBuffer[Pos], p: Pos): Boolean = {
  var i: BigInt = 0
  while (i < BigInt((lst).size)) {
    if (pos_equal(lst((i.toInt).toInt), p)) {
      return true
    }
    i = i + 1
  }
  return false
}

def open_index_of_pos(open: ArrayBuffer[Node], p: Pos): BigInt = {
  var i: BigInt = 0
  while (i < BigInt((open).size)) {
    if (pos_equal(open((i.toInt).toInt).pos, p)) {
      return i
    }
    i = i + 1
  }
  return 0 - 1
}

def remove_node_at(nodes: ArrayBuffer[Node], idx: BigInt): ArrayBuffer[Node] = {
  var res: ArrayBuffer[Node] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((nodes).size)) {
    if (i != idx) {
      res = res :+ nodes((i.toInt).toInt)
    }
    i = i + 1
  }
  return res
}

def append_pos_list(path: ArrayBuffer[Pos], p: Pos): ArrayBuffer[Pos] = {
  var res: ArrayBuffer[Pos] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((path).size)) {
    res = res :+ path((i.toInt).toInt)
    i = i + 1
  }
  res = res :+ p
  return res
}

def reverse_pos_list(lst: ArrayBuffer[Pos]): ArrayBuffer[Pos] = {
  var res: ArrayBuffer[Pos] = ArrayBuffer()
  var i: BigInt = BigInt((lst).size) - 1
  while (i >= 0) {
    res = res :+ lst((i.toInt).toInt)
    i = i - 1
  }
  return res
}

def concat_pos_lists(a: ArrayBuffer[Pos], b: ArrayBuffer[Pos]): ArrayBuffer[Pos] = {
  var res: ArrayBuffer[Pos] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((a).size)) {
    res = res :+ a((i.toInt).toInt)
    i = i + 1
  }
  var j: BigInt = 0
  while (j < BigInt((b).size)) {
    res = res :+ b((j.toInt).toInt)
    j = j + 1
  }
  return res
}

def get_successors(p: Pos): ArrayBuffer[Pos] = {
  var res: ArrayBuffer[Pos] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((delta).size)) {
    val nx: BigInt = p.asInstanceOf[Pos].x + delta((i.toInt).toInt)((1.toInt).toInt)
    val ny: BigInt = p.asInstanceOf[Pos].y + delta((i.toInt).toInt)((0.toInt).toInt)
    if ((((nx >= 0 && ny >= 0).asInstanceOf[Boolean] && nx < BigInt((grid((0.toInt).toInt)).size)).asInstanceOf[Boolean] && ny < BigInt((grid).size)).asInstanceOf[Boolean]) {
      if (grid((ny.toInt).toInt)((nx.toInt).toInt) == 0) {
        res = res :+ Pos(ny, nx)
      }
    }
    i = i + 1
  }
  return res
}

def find_lowest_f(open: ArrayBuffer[Node]): BigInt = {
  var best: BigInt = 0
  var i: BigInt = 1
  while (i < BigInt((open).size)) {
    if (open((i.toInt).toInt).f_cost < open((best.toInt).toInt).f_cost) {
      best = i
    }
    i = i + 1
  }
  return best
}

def astar(start: Pos, goal: Pos): ArrayBuffer[Pos] = {
  val h0: Double = heuristic(start, goal)
  var open: ArrayBuffer[Node] = ArrayBuffer(Node(start, 0, h0, h0, ArrayBuffer(start)))
  var closed: ArrayBuffer[Pos] = ArrayBuffer()
  val _ct10 = new Breaks
  while (BigInt((open).size) > 0) {
    _ct10.breakable {
      val idx: BigInt = find_lowest_f(open)
      val current: Node = open((idx.toInt).toInt)
      open = remove_node_at(open, idx)
      if (pos_equal(current.asInstanceOf[Node].pos, goal)) {
        return current.asInstanceOf[Node].path
      }
      closed = closed :+ current.asInstanceOf[Node].pos
      val succ: ArrayBuffer[Pos] = get_successors(current.asInstanceOf[Node].pos)
      var i: BigInt = 0
      val _ct11 = new Breaks
      while (i < BigInt((succ).size)) {
        _ct11.breakable {
          val pos: Pos = succ((i.toInt).toInt)
          if (contains_pos(closed, pos)) {
            i = i + 1
            _ct11.break()
          }
          val tentative_g: BigInt = current.asInstanceOf[Node].g_cost + 1
          val idx_open: BigInt = open_index_of_pos(open, pos)
          if ((idx_open == 0 - 1 || tentative_g < open((idx_open.toInt).toInt).g_cost).asInstanceOf[Boolean]) {
            val new_path: ArrayBuffer[Pos] = append_pos_list(current.asInstanceOf[Node].path, pos)
            val h: Double = heuristic(pos, goal)
            val f: Double = tentative_g.toString.toDouble + h
            if (idx_open != 0 - 1) {
              open = remove_node_at(open, idx_open)
            }
            open = open :+ Node(pos, tentative_g, h, f, new_path)
          }
          i = i + 1
        }
      }
    }
  }
  return ArrayBuffer(start)
}

def combine_paths(fwd: Node, bwd: Node): ArrayBuffer[Pos] = {
  var bwd_copy: ArrayBuffer[Pos] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((bwd.asInstanceOf[Node].path).size) - 1) {
    bwd_copy = bwd_copy :+ bwd.asInstanceOf[Node].path((i.toInt).toInt)
    i = i + 1
  }
  bwd_copy = reverse_pos_list(bwd_copy)
  return concat_pos_lists(fwd.asInstanceOf[Node].path, bwd_copy)
}

def bidirectional_astar(start: Pos, goal: Pos): ArrayBuffer[Pos] = {
  val hf: Double = heuristic(start, goal)
  val hb: Double = heuristic(goal, start)
  var open_f: ArrayBuffer[Node] = ArrayBuffer(Node(start, 0, hf, hf, ArrayBuffer(start)))
  var open_b: ArrayBuffer[Node] = ArrayBuffer(Node(goal, 0, hb, hb, ArrayBuffer(goal)))
  var closed_f: ArrayBuffer[Pos] = ArrayBuffer()
  var closed_b: ArrayBuffer[Pos] = ArrayBuffer()
  val _ct13 = new Breaks
  while (BigInt((open_f).size) > 0 && BigInt((open_b).size) > 0) {
    _ct13.breakable {
      val idx_f: BigInt = find_lowest_f(open_f)
      val current_f: Node = open_f((idx_f.toInt).toInt)
      open_f = remove_node_at(open_f, idx_f)
      val idx_b: BigInt = find_lowest_f(open_b)
      val current_b: Node = open_b((idx_b.toInt).toInt)
      open_b = remove_node_at(open_b, idx_b)
      if (pos_equal(current_f.asInstanceOf[Node].pos, current_b.asInstanceOf[Node].pos)) {
        return combine_paths(current_f, current_b)
      }
      closed_f = closed_f :+ current_f.asInstanceOf[Node].pos
      closed_b = closed_b :+ current_b.asInstanceOf[Node].pos
      val succ_f: ArrayBuffer[Pos] = get_successors(current_f.asInstanceOf[Node].pos)
      var i: BigInt = 0
      val _ct14 = new Breaks
      while (i < BigInt((succ_f).size)) {
        _ct14.breakable {
          val pos: Pos = succ_f((i.toInt).toInt)
          if (contains_pos(closed_f, pos)) {
            i = i + 1
            _ct14.break()
          }
          val tentative_g: BigInt = current_f.asInstanceOf[Node].g_cost + 1
          val h: Double = heuristic(pos, current_b.asInstanceOf[Node].pos)
          val f: Double = tentative_g.toString.toDouble + h
          val idx_open: BigInt = open_index_of_pos(open_f, pos)
          if ((idx_open == 0 - 1 || tentative_g < open_f((idx_open.toInt).toInt).g_cost).asInstanceOf[Boolean]) {
            val new_path: ArrayBuffer[Pos] = append_pos_list(current_f.asInstanceOf[Node].path, pos)
            if (idx_open != 0 - 1) {
              open_f = remove_node_at(open_f, idx_open)
            }
            open_f = open_f :+ Node(pos, tentative_g, h, f, new_path)
          }
          i = i + 1
        }
      }
      val succ_b: ArrayBuffer[Pos] = get_successors(current_b.asInstanceOf[Node].pos)
      i = 0
      val _ct15 = new Breaks
      while (i < BigInt((succ_b).size)) {
        _ct15.breakable {
          val pos: Pos = succ_b((i.toInt).toInt)
          if (contains_pos(closed_b, pos)) {
            i = i + 1
            _ct15.break()
          }
          val tentative_g: BigInt = current_b.asInstanceOf[Node].g_cost + 1
          val h: Double = heuristic(pos, current_f.asInstanceOf[Node].pos)
          val f: Double = tentative_g.toString.toDouble + h
          val idx_open: BigInt = open_index_of_pos(open_b, pos)
          if ((idx_open == 0 - 1 || tentative_g < open_b((idx_open.toInt).toInt).g_cost).asInstanceOf[Boolean]) {
            val new_path: ArrayBuffer[Pos] = append_pos_list(current_b.asInstanceOf[Node].path, pos)
            if (idx_open != 0 - 1) {
              open_b = remove_node_at(open_b, idx_open)
            }
            open_b = open_b :+ Node(pos, tentative_g, h, f, new_path)
          }
          i = i + 1
        }
      }
    }
  }
  return ArrayBuffer(start)
}

def path_to_string(path: ArrayBuffer[Pos]): String = {
  if (BigInt((path).size) == 0) {
    return "[]"
  }
  var s: String = "[(" + String.valueOf(path((0.toInt).toInt).y) + ", " + String.valueOf(path((0.toInt).toInt).x) + ")"
  var i: BigInt = 1
  while (i < BigInt((path).size)) {
    s = s + ", (" + String.valueOf(path((i.toInt).toInt).y) + ", " + String.valueOf(path((i.toInt).toInt).x) + ")"
    i = i + 1
  }
  s = s + "]"
  return s
}

val HEURISTIC: BigInt = 0

val grid: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(0, 0, 0, 0, 0, 0, 0), ArrayBuffer(0, 1, 0, 0, 0, 0, 0), ArrayBuffer(0, 0, 0, 0, 0, 0, 0), ArrayBuffer(0, 0, 1, 0, 0, 0, 0), ArrayBuffer(1, 0, 1, 0, 0, 0, 0), ArrayBuffer(0, 0, 0, 0, 0, 0, 0), ArrayBuffer(0, 0, 0, 0, 1, 0, 0))

val delta: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(-1, 0), ArrayBuffer(0, -1), ArrayBuffer(1, 0), ArrayBuffer(0, 1))

val start: Pos = Pos(0, 0)

val goal: Pos = Pos(BigInt((grid).size) - 1, BigInt((grid((0.toInt).toInt)).size) - 1)

val path1: ArrayBuffer[Pos] = astar(start, goal)

val path2: ArrayBuffer[Pos] = bidirectional_astar(start, goal)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(path_to_string(path1))
    println(path_to_string(path2))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
