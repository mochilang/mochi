// Generated by Mochi v0.10.59 on 2025-08-07 11:22:27 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class DirectedGraph(var graph: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]])

case class Graph(var graph: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]])

def list_contains_int(xs: ArrayBuffer[BigInt], x: BigInt): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((xs).size)) {
    if (xs((i.toInt).toInt) == x) {
      return true
    }
    i = i + BigInt(1)
  }
  return false
}

def edge_exists(edges: ArrayBuffer[ArrayBuffer[BigInt]], w: BigInt, v: BigInt): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    if ((edges((i.toInt).toInt)((BigInt(0).toInt).toInt) == w && edges((i.toInt).toInt)((BigInt(1).toInt).toInt) == v).asInstanceOf[Boolean]) {
      return true
    }
    i = i + BigInt(1)
  }
  return false
}

def first_key(m: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]]): BigInt = {
  for (k <- m.keys) {
    return k
  }
  return BigInt(0)
}

def rand_range(low: BigInt, high: BigInt): BigInt = {
  return _now() % (high - low) + low
}

def dg_make_graph(): DirectedGraph = {
  return DirectedGraph(scala.collection.mutable.Map())
}

def dg_add_pair(g: DirectedGraph, u: BigInt, v: BigInt, w: BigInt): Any = {
  if ((g.graph.contains(u)).asInstanceOf[Boolean]) {
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    if (!edge_exists(edges, w, v)) {
      edges = edges :+ ArrayBuffer(BigInt(w.toString.toDouble.toInt), BigInt(v.toString.toDouble.toInt))
      var m: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
      m.update(u, edges)
      g.graph = m
    }
  } else {
    var m0: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m0.update(u, ArrayBuffer(ArrayBuffer(w, v)))
    g.graph = m0
  }
  if (!(g.graph.contains(v)).asInstanceOf[Boolean]) {
    var m1: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m1.update(v, ArrayBuffer())
    g.graph = m1
  }
}

def dg_remove_pair(g: DirectedGraph, u: BigInt, v: BigInt): Any = {
  if ((g.graph.contains(u)).asInstanceOf[Boolean]) {
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    var new_edges: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
    var i: BigInt = BigInt(0)
    while (i < BigInt((edges).size)) {
      if (edges((i.toInt).toInt)((BigInt(1).toInt).toInt) != v) {
        new_edges = new_edges :+ edges((i.toInt).toInt)
      }
      i = i + BigInt(1)
    }
    var m: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m.update(u, new_edges)
    g.graph = m
  }
}

def dg_all_nodes(g: DirectedGraph): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  for (k <- g.graph.keys) {
    res = res :+ k
  }
  return res
}

def dg_dfs_util(g: DirectedGraph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], _order: ArrayBuffer[BigInt], d: BigInt): ArrayBuffer[BigInt] = {
  var order: ArrayBuffer[BigInt] = _order
  visited.update(node, true)
  order = order :+ node
  if ((d != -BigInt(1) && node == d).asInstanceOf[Boolean]) {
    return order
  }
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      order = dg_dfs_util(g, neigh, visited, order, d)
      if ((d != -BigInt(1) && order(((BigInt((order).size) - BigInt(1)).toInt).toInt) == d).asInstanceOf[Boolean]) {
        return order
      }
    }
    i = i + BigInt(1)
  }
  return order
}

def dg_dfs(g: DirectedGraph, s: BigInt, d: BigInt): ArrayBuffer[BigInt] = {
  if (s == d) {
    return ArrayBuffer[BigInt]()
  }
  val start: BigInt = (if (s == -BigInt(2)) first_key(g.graph) else s)
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var order: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  order = dg_dfs_util(g, start, visited, order, d)
  return order
}

def dg_bfs(g: DirectedGraph, s: BigInt): ArrayBuffer[BigInt] = {
  var queue: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var order: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  val start: BigInt = (if (s == -BigInt(2)) first_key(g.graph) else s)
  queue = queue :+ start
  visited.update(start, true)
  while (BigInt((queue).size) > BigInt(0)) {
    val node: BigInt = queue((BigInt(0).toInt).toInt)
    queue = queue.slice((BigInt(1)).toInt, (BigInt((queue).size)).toInt)
    order = order :+ node
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    var i: BigInt = BigInt(0)
    while (i < BigInt((edges).size)) {
      val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
      if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
        queue = queue :+ neigh
        visited.update(neigh, true)
      }
      i = i + BigInt(1)
    }
  }
  return order
}

def dg_in_degree(g: DirectedGraph, u: BigInt): BigInt = {
  var count: BigInt = BigInt(0)
  for (k <- g.graph.keys) {
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(k, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    var i: BigInt = BigInt(0)
    while (i < BigInt((edges).size)) {
      if (edges((i.toInt).toInt)((BigInt(1).toInt).toInt) == u) {
        count = count + BigInt(1)
      }
      i = i + BigInt(1)
    }
  }
  return count
}

def dg_out_degree(g: DirectedGraph, u: BigInt): BigInt = {
  if ((g.graph.contains(u)).asInstanceOf[Boolean]) {
    return BigInt((g.graph.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]).size)
  }
  return BigInt(0)
}

def dg_topo_util(g: DirectedGraph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], _stack: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var stack: ArrayBuffer[BigInt] = _stack
  visited.update(node, true)
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      stack = dg_topo_util(g, neigh, visited, stack)
    }
    i = i + BigInt(1)
  }
  stack = stack :+ node
  return stack
}

def dg_topological_sort(g: DirectedGraph): ArrayBuffer[BigInt] = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var stack: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  for (k <- g.graph.keys) {
    if (!(visited.contains(k)).asInstanceOf[Boolean]) {
      stack = dg_topo_util(g, k, visited, stack)
    }
  }
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt((stack).size) - BigInt(1)
  while (i >= BigInt(0)) {
    res = res :+ stack((i.toInt).toInt)
    i = i - BigInt(1)
  }
  return res
}

def dg_cycle_util(g: DirectedGraph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], rec: scala.collection.mutable.Map[BigInt,Boolean], _res: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = _res
  visited.update(node, true)
  rec.update(node, true)
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      res = dg_cycle_util(g, neigh, visited, rec, res)
    } else {
      if (rec.getOrElse(neigh, false).asInstanceOf[Boolean]) {
        if (!list_contains_int(res, neigh)) {
          res = res :+ neigh
        }
        if (!list_contains_int(res, node)) {
          res = res :+ node
        }
      }
    }
    i = i + BigInt(1)
  }
  rec.update(node, false)
  return res
}

def dg_cycle_nodes(g: DirectedGraph): ArrayBuffer[BigInt] = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var rec: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  for (k <- g.graph.keys) {
    if (!(visited.contains(k)).asInstanceOf[Boolean]) {
      res = dg_cycle_util(g, k, visited, rec, res)
    }
  }
  return res
}

def dg_has_cycle_util(g: DirectedGraph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], rec: scala.collection.mutable.Map[BigInt,Boolean]): Boolean = {
  visited.update(node, true)
  rec.update(node, true)
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      if (dg_has_cycle_util(g, neigh, visited, rec)) {
        return true
      }
    } else {
      if (rec.getOrElse(neigh, false).asInstanceOf[Boolean]) {
        return true
      }
    }
    i = i + BigInt(1)
  }
  rec.update(node, false)
  return false
}

def dg_has_cycle(g: DirectedGraph): Boolean = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var rec: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  for (k <- g.graph.keys) {
    if (!(visited.contains(k)).asInstanceOf[Boolean]) {
      if (dg_has_cycle_util(g, k, visited, rec)) {
        return true
      }
    }
  }
  return false
}

def dg_fill_graph_randomly(g: DirectedGraph, c: BigInt): Any = {
  var count: BigInt = c
  if (count == -BigInt(1)) {
    count = rand_range(BigInt(10), BigInt(10010))
  }
  var i: BigInt = BigInt(0)
  while (i < count) {
    var edge_count: BigInt = rand_range(BigInt(1), BigInt(103))
    var j: BigInt = BigInt(0)
    while (j < edge_count) {
      val n: BigInt = rand_range(BigInt(0), count)
      if (n != i) {
        dg_add_pair(g, i, n, BigInt(1))
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
}

def dg_dfs_time(g: DirectedGraph, s: BigInt, e: BigInt): BigInt = {
  val begin: BigInt = _now()
  dg_dfs(g, s, e)
  val end: BigInt = _now()
  return end - begin
}

def dg_bfs_time(g: DirectedGraph, s: BigInt): BigInt = {
  val begin: BigInt = _now()
  dg_bfs(g, s)
  val end: BigInt = _now()
  return end - begin
}

def g_make_graph(): Graph = {
  return Graph(scala.collection.mutable.Map())
}

def g_add_pair(g: Graph, u: BigInt, v: BigInt, w: BigInt): Any = {
  if ((g.graph.contains(u)).asInstanceOf[Boolean]) {
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    if (!edge_exists(edges, w, v)) {
      edges = edges :+ ArrayBuffer(BigInt(w.toString.toDouble.toInt), BigInt(v.toString.toDouble.toInt))
      var m: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
      m.update(u, edges)
      g.graph = m
    }
  } else {
    var m0: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m0.update(u, ArrayBuffer(ArrayBuffer(w, v)))
    g.graph = m0
  }
  if ((g.graph.contains(v)).asInstanceOf[Boolean]) {
    var edges2: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(v, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    if (!edge_exists(edges2, w, u)) {
      edges2 = edges2 :+ ArrayBuffer(BigInt(w.toString.toDouble.toInt), BigInt(u.toString.toDouble.toInt))
      var m2: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
      m2.update(v, edges2)
      g.graph = m2
    }
  } else {
    var m3: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m3.update(v, ArrayBuffer(ArrayBuffer(w, u)))
    g.graph = m3
  }
}

def g_remove_pair(g: Graph, u: BigInt, v: BigInt): Any = {
  if ((g.graph.contains(u)).asInstanceOf[Boolean]) {
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    var new_edges: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
    var i: BigInt = BigInt(0)
    while (i < BigInt((edges).size)) {
      if (edges((i.toInt).toInt)((BigInt(1).toInt).toInt) != v) {
        new_edges = new_edges :+ edges((i.toInt).toInt)
      }
      i = i + BigInt(1)
    }
    var m: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m.update(u, new_edges)
    g.graph = m
  }
  if ((g.graph.contains(v)).asInstanceOf[Boolean]) {
    var edges2: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(v, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    var new_edges2: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((edges2).size)) {
      if (edges2((j.toInt).toInt)((BigInt(1).toInt).toInt) != u) {
        new_edges2 = new_edges2 :+ edges2((j.toInt).toInt)
      }
      j = j + BigInt(1)
    }
    var m2: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = g.graph
    m2.update(v, new_edges2)
    g.graph = m2
  }
}

def g_all_nodes(g: Graph): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  for (k <- g.graph.keys) {
    res = res :+ k
  }
  return res
}

def g_dfs_util(g: Graph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], _order: ArrayBuffer[BigInt], d: BigInt): ArrayBuffer[BigInt] = {
  var order: ArrayBuffer[BigInt] = _order
  visited.update(node, true)
  order = order :+ node
  if ((d != -BigInt(1) && node == d).asInstanceOf[Boolean]) {
    return order
  }
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      order = g_dfs_util(g, neigh, visited, order, d)
      if ((d != -BigInt(1) && order(((BigInt((order).size) - BigInt(1)).toInt).toInt) == d).asInstanceOf[Boolean]) {
        return order
      }
    }
    i = i + BigInt(1)
  }
  return order
}

def g_dfs(g: Graph, s: BigInt, d: BigInt): ArrayBuffer[BigInt] = {
  if (s == d) {
    return ArrayBuffer[BigInt]()
  }
  val start: BigInt = (if (s == -BigInt(2)) first_key(g.graph) else s)
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var order: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  order = g_dfs_util(g, start, visited, order, d)
  return order
}

def g_bfs(g: Graph, s: BigInt): ArrayBuffer[BigInt] = {
  var queue: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var order: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  val start: BigInt = (if (s == -BigInt(2)) first_key(g.graph) else s)
  queue = queue :+ start
  visited.update(start, true)
  while (BigInt((queue).size) > BigInt(0)) {
    val node: BigInt = queue((BigInt(0).toInt).toInt)
    queue = queue.slice((BigInt(1)).toInt, (BigInt((queue).size)).toInt)
    order = order :+ node
    var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
    var i: BigInt = BigInt(0)
    while (i < BigInt((edges).size)) {
      val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
      if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
        queue = queue :+ neigh
        visited.update(neigh, true)
      }
      i = i + BigInt(1)
    }
  }
  return order
}

def g_degree(g: Graph, u: BigInt): BigInt = {
  if ((g.graph.contains(u)).asInstanceOf[Boolean]) {
    return BigInt((g.graph.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]).size)
  }
  return BigInt(0)
}

def g_cycle_util(g: Graph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], parent: BigInt, _res: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = _res
  visited.update(node, true)
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      res = g_cycle_util(g, neigh, visited, node, res)
    } else {
      if (neigh != parent) {
        if (!list_contains_int(res, neigh)) {
          res = res :+ neigh
        }
        if (!list_contains_int(res, node)) {
          res = res :+ node
        }
      }
    }
    i = i + BigInt(1)
  }
  return res
}

def g_cycle_nodes(g: Graph): ArrayBuffer[BigInt] = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  for (k <- g.graph.keys) {
    if (!(visited.contains(k)).asInstanceOf[Boolean]) {
      res = g_cycle_util(g, k, visited, -BigInt(1), res)
    }
  }
  return res
}

def g_has_cycle_util(g: Graph, node: BigInt, visited: scala.collection.mutable.Map[BigInt,Boolean], parent: BigInt): Boolean = {
  visited.update(node, true)
  var edges: ArrayBuffer[ArrayBuffer[BigInt]] = g.graph.getOrElse(node, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
  var i: BigInt = BigInt(0)
  while (i < BigInt((edges).size)) {
    val neigh: BigInt = edges((i.toInt).toInt)((BigInt(1).toInt).toInt)
    if (!(visited.contains(neigh)).asInstanceOf[Boolean]) {
      if (g_has_cycle_util(g, neigh, visited, node)) {
        return true
      }
    } else {
      if (neigh != parent) {
        return true
      }
    }
    i = i + BigInt(1)
  }
  return false
}

def g_has_cycle(g: Graph): Boolean = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  for (k <- g.graph.keys) {
    if (!(visited.contains(k)).asInstanceOf[Boolean]) {
      if (g_has_cycle_util(g, k, visited, -BigInt(1))) {
        return true
      }
    }
  }
  return false
}

def g_fill_graph_randomly(g: Graph, c: BigInt): Any = {
  var count: BigInt = c
  if (count == -BigInt(1)) {
    count = rand_range(BigInt(10), BigInt(10010))
  }
  var i: BigInt = BigInt(0)
  while (i < count) {
    var edge_count: BigInt = rand_range(BigInt(1), BigInt(103))
    var j: BigInt = BigInt(0)
    while (j < edge_count) {
      val n: BigInt = rand_range(BigInt(0), count)
      if (n != i) {
        g_add_pair(g, i, n, BigInt(1))
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
}

def g_dfs_time(g: Graph, s: BigInt, e: BigInt): BigInt = {
  val begin: BigInt = _now()
  g_dfs(g, s, e)
  val end: BigInt = _now()
  return end - begin
}

def g_bfs_time(g: Graph, s: BigInt): BigInt = {
  val begin: BigInt = _now()
  g_bfs(g, s)
  val end: BigInt = _now()
  return end - begin
}

def main(): Any = {
  var dg: DirectedGraph = dg_make_graph()
  dg_add_pair(dg, BigInt(0), BigInt(1), BigInt(5))
  dg_add_pair(dg, BigInt(0), BigInt(2), BigInt(3))
  dg_add_pair(dg, BigInt(1), BigInt(3), BigInt(2))
  dg_add_pair(dg, BigInt(2), BigInt(3), BigInt(4))
  println(String.valueOf(dg_dfs(dg, -BigInt(2), -BigInt(1))))
  println(String.valueOf(dg_bfs(dg, -BigInt(2))))
  println(String.valueOf(dg_in_degree(dg, BigInt(3))))
  println(String.valueOf(dg_out_degree(dg, BigInt(0))))
  println(String.valueOf(dg_topological_sort(dg)))
  println(String.valueOf(dg_has_cycle(dg)))
  var ug: Graph = g_make_graph()
  g_add_pair(ug, BigInt(0), BigInt(1), BigInt(1))
  g_add_pair(ug, BigInt(1), BigInt(2), BigInt(1))
  g_add_pair(ug, BigInt(2), BigInt(0), BigInt(1))
  println(String.valueOf(g_dfs(ug, -BigInt(2), -BigInt(1))))
  println(String.valueOf(g_bfs(ug, -BigInt(2))))
  println(String.valueOf(g_degree(ug, BigInt(1))))
  println(String.valueOf(g_has_cycle(ug)))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
