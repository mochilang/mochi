// Generated by Mochi v0.10.66 on 2025-08-15 10:18:25 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole()) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class NodesData(var map: scala.collection.mutable.Map[String,ArrayBuffer[String]], var keys: ArrayBuffer[String])

case class ClusterData(var clusters: scala.collection.mutable.Map[BigInt,ArrayBuffer[String]], var weights: ArrayBuffer[BigInt])

case class GraphData(var edges: scala.collection.mutable.Map[String,ArrayBuffer[String]], var keys: ArrayBuffer[String])

def contains(lst: ArrayBuffer[String], item: String): Boolean = {
  for (v <- lst) {
    if (v == item) {
      return true
    }
  }
  return false
}

def get_distinct_edge(edge_array: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]): ArrayBuffer[String] = {
  var distinct: ArrayBuffer[String] = ArrayBuffer[String]()
  for (row <- edge_array) {
    for (item <- row) {
      var e: String = item.lift((BigInt(0).toInt).toInt).getOrElse("")
      if (!(distinct.contains(e))) {
        distinct = (distinct :+ e)
      }
    }
  }
  return distinct
}

def get_bitcode(edge_array: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]], de: String): String = {
  var bitcode: String = ""
  var i: BigInt = BigInt(0)
  val _br3 = new Breaks
  _br3.breakable {
    while (i < BigInt((edge_array).size)) {
      var found: Boolean = false
      val _br4 = new Breaks
      _br4.breakable {
        for (item <- edge_array.lift((i.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[String]]())) {
          if (item.lift((BigInt(0).toInt).toInt).getOrElse("") == de) {
            found = true
            _br4.break()
          }
        }
      }
      if (found) {
        bitcode = bitcode + "1"
      } else {
        bitcode = bitcode + "0"
      }
      i = i + BigInt(1)
    }
  }
  return bitcode
}

def count_ones(s: String): BigInt = {
  var c: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).size)) {
    if (s.slice((i).toInt, (i + BigInt(1)).toInt) == "1") {
      c = c + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return c
}

def get_frequency_table(edge_array: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]): ArrayBuffer[scala.collection.mutable.Map[String,String]] = {
  var distinct: ArrayBuffer[String] = get_distinct_edge(edge_array)
  var table: ArrayBuffer[scala.collection.mutable.Map[String,String]] = ArrayBuffer[scala.collection.mutable.Map[String,String]]()
  for (e <- distinct) {
    var bit: String = get_bitcode(edge_array, e)
    var cnt: BigInt = count_ones(bit)
    var entry: scala.collection.mutable.Map[String,String] = (scala.collection.mutable.Map("edge" -> (e), "count" -> (_str(cnt)), "bit" -> (bit))).asInstanceOf[scala.collection.mutable.Map[String,String]]
    table = (table :+ entry)
  }
  var i: BigInt = BigInt(0)
  while (i < BigInt((table).size)) {
    var max_i: BigInt = i
    var j: BigInt = i + BigInt(1)
    while (j < BigInt((table).size)) {
      if (BigInt((table.lift((j.toInt).toInt).getOrElse(null).getOrElse("count", "").asInstanceOf[String]).toString.toDouble.toInt) > BigInt((table.lift((max_i.toInt).toInt).getOrElse(null).getOrElse("count", "").asInstanceOf[String]).toString.toDouble.toInt)) {
        max_i = j
      }
      j = j + BigInt(1)
    }
    var tmp: scala.collection.mutable.Map[String,String] = table.lift((i.toInt).toInt).getOrElse(null)
    table((i).toInt) = table.lift((max_i.toInt).toInt).getOrElse(null)
    table((max_i).toInt) = tmp
    i = i + BigInt(1)
  }
  return table
}

def get_nodes(freq_table: ArrayBuffer[scala.collection.mutable.Map[String,String]]): NodesData = {
  var nodes: scala.collection.mutable.Map[String,ArrayBuffer[String]] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,ArrayBuffer[String]]]
  var keys: ArrayBuffer[String] = ArrayBuffer[String]()
  for (f <- freq_table) {
    var code: String = f.getOrElse("bit", "").asInstanceOf[String]
    var edge: String = f.getOrElse("edge", "").asInstanceOf[String]
    if ((nodes.contains(code))) {
      nodes.update(code, (nodes.getOrElse(code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ edge))
    } else {
      nodes.update(code, ArrayBuffer(edge))
      keys = (keys :+ code)
    }
  }
  return NodesData(nodes, keys)
}

def get_cluster(nodes: NodesData): ClusterData = {
  var clusters: scala.collection.mutable.Map[BigInt,ArrayBuffer[String]] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,ArrayBuffer[String]]]
  var weights: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((nodes.keys).size)) {
    var code: String = nodes.keys.lift((i.toInt).toInt).getOrElse("")
    var wt: BigInt = count_ones(code)
    if ((clusters.contains(wt))) {
      clusters.update(wt, (clusters.getOrElse(wt, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ code))
    } else {
      clusters.update(wt, ArrayBuffer(code))
      weights = (weights :+ wt)
    }
    i = i + BigInt(1)
  }
  return ClusterData(clusters, weights)
}

def get_support(clusters: ClusterData): ArrayBuffer[BigInt] = {
  var sup: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((clusters.asInstanceOf[ClusterData].weights).size)) {
    var w: BigInt = clusters.asInstanceOf[ClusterData].weights.lift((i.toInt).toInt).getOrElse(BigInt(0))
    sup = (sup :+ w * BigInt(100) / BigInt((clusters.asInstanceOf[ClusterData].weights).size))
    i = i + BigInt(1)
  }
  return sup
}

def contains_bits(a: String, b: String): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    var c1: String = a.slice((i).toInt, (i + BigInt(1)).toInt)
    var c2: String = b.slice((i).toInt, (i + BigInt(1)).toInt)
    if ((c1 == "1" && c2 != "1")) {
      return false
    }
    i = i + BigInt(1)
  }
  return true
}

def max_cluster_key(clusters: ClusterData): BigInt = {
  var m: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((clusters.asInstanceOf[ClusterData].weights).size)) {
    var w: BigInt = clusters.asInstanceOf[ClusterData].weights.lift((i.toInt).toInt).getOrElse(BigInt(0))
    if (w > m) {
      m = w
    }
    i = i + BigInt(1)
  }
  return m
}

def get_cluster_codes(clusters: ClusterData, wt: BigInt): ArrayBuffer[String] = {
  if ((clusters.asInstanceOf[ClusterData].clusters.contains(wt))) {
    return clusters.asInstanceOf[ClusterData].clusters.getOrElse(wt, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]
  }
  return ArrayBuffer[String]()
}

def create_edge(nodes: NodesData, graph: scala.collection.mutable.Map[String,ArrayBuffer[String]], gkeys: ArrayBuffer[String], clusters: ClusterData, c1: BigInt, maxk: BigInt): ArrayBuffer[String] = {
  var keys: ArrayBuffer[String] = gkeys
  var codes1: ArrayBuffer[String] = get_cluster_codes(clusters, c1)
  var idx1: BigInt = BigInt(0)
  val _br14 = new Breaks
  _br14.breakable {
    while (idx1 < BigInt((codes1).size)) {
      var i_code: String = codes1.lift((idx1.toInt).toInt).getOrElse("")
      var count: BigInt = BigInt(0)
      var c2: BigInt = c1 + BigInt(1)
      val _br15 = new Breaks
      _br15.breakable {
        while (c2 <= maxk) {
          var codes2: ArrayBuffer[String] = get_cluster_codes(clusters, c2)
          var j: BigInt = BigInt(0)
          while (j < BigInt((codes2).size)) {
            var j_code: String = codes2.lift((j.toInt).toInt).getOrElse("")
            if (contains_bits(i_code, j_code)) {
              if ((graph.contains(i_code))) {
                graph.update(i_code, (graph.getOrElse(i_code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ j_code))
              } else {
                graph.update(i_code, ArrayBuffer(j_code))
                if (!(keys.contains(i_code))) {
                  keys = (keys :+ i_code)
                }
              }
              if (!(keys.contains(j_code))) {
                keys = (keys :+ j_code)
              }
              count = count + BigInt(1)
            }
            j = j + BigInt(1)
          }
          if (count == BigInt(0)) {
            c2 = c2 + BigInt(1)
          } else {
            _br15.break()
          }
        }
      }
      idx1 = idx1 + BigInt(1)
    }
  }
  return keys
}

def construct_graph(clusters: ClusterData, nodes: NodesData): GraphData = {
  var maxk: BigInt = max_cluster_key(clusters)
  var top_codes: ArrayBuffer[String] = get_cluster_codes(clusters, maxk)
  var graph: scala.collection.mutable.Map[String,ArrayBuffer[String]] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,ArrayBuffer[String]]]
  var keys: ArrayBuffer[String] = ArrayBuffer("Header")
  graph.update("Header", ArrayBuffer())
  var i: BigInt = BigInt(0)
  while (i < BigInt((top_codes).size)) {
    var code: String = top_codes.lift((i.toInt).toInt).getOrElse("")
    graph.update("Header", (graph.getOrElse("Header", ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ code))
    graph.update(code, ArrayBuffer("Header"))
    keys = (keys :+ code)
    i = i + BigInt(1)
  }
  var c: BigInt = BigInt(1)
  while (c < maxk) {
    keys = create_edge(nodes, graph, keys, clusters, c, maxk)
    c = c + BigInt(1)
  }
  return GraphData(graph, keys)
}

def copy_list(lst: ArrayBuffer[String]): ArrayBuffer[String] = {
  var n: ArrayBuffer[String] = ArrayBuffer[String]()
  for (v <- lst) {
    n = (n :+ v)
  }
  return n
}

def my_dfs(graph: scala.collection.mutable.Map[String,ArrayBuffer[String]], start: String, end: String, path: ArrayBuffer[String]): Any = {
  var new_path: ArrayBuffer[String] = copy_list(path)
  new_path = (new_path :+ start)
  if (start == end) {
    paths = (paths :+ new_path)
    return
  }
  for (node <- graph.getOrElse(start.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]) {
    var seen: Boolean = false
    for (p <- new_path) {
      if (p == node) {
        seen = true
      }
    }
    if (!seen) {
      my_dfs(graph, node, end, new_path)
    }
  }
  return null
}

def find_freq_subgraph_given_support(s: BigInt, clusters: ClusterData, graph: GraphData): Any = {
  var k: BigInt = s * BigInt((clusters.asInstanceOf[ClusterData].weights).size) / BigInt(100)
  var codes: ArrayBuffer[String] = get_cluster_codes(clusters, k)
  var i: BigInt = BigInt(0)
  while (i < BigInt((codes).size)) {
    my_dfs(graph.asInstanceOf[GraphData].edges, codes.lift((i.toInt).toInt).getOrElse(""), "Header", ArrayBuffer[String]())
    i = i + BigInt(1)
  }
}

def node_edges(nodes: NodesData, code: String): ArrayBuffer[String] = {
  return nodes.asInstanceOf[NodesData].map.getOrElse(code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]
}

def freq_subgraphs_edge_list(paths: ArrayBuffer[ArrayBuffer[String]], nodes: NodesData): ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = {
  var freq_sub_el: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]()
  for (path <- paths) {
    var el: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer[ArrayBuffer[String]]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((path).size) - BigInt(1)) {
      var code: String = path.lift((j.toInt).toInt).getOrElse("")
      var edge_list: ArrayBuffer[String] = node_edges(nodes, code)
      var e: BigInt = BigInt(0)
      while (e < BigInt((edge_list).size)) {
        var edge: String = edge_list.lift((e.toInt).toInt).getOrElse("")
        var a: String = edge.slice((BigInt(0)).toInt, (BigInt(1)).toInt)
        var b: String = edge.slice((BigInt(1)).toInt, (BigInt(2)).toInt)
        el = (el :+ ArrayBuffer(a.toString, b.toString))
        e = e + BigInt(1)
      }
      j = j + BigInt(1)
    }
    freq_sub_el = (freq_sub_el :+ el)
  }
  return freq_sub_el
}

def print_all(nodes: NodesData, support: ArrayBuffer[BigInt], clusters: ClusterData, graph: GraphData, freq_subgraph_edge_list: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]): Any = {
  println("\nNodes\n")
  var i: BigInt = BigInt(0)
  while (i < BigInt((nodes.keys).size)) {
    var code: String = nodes.keys.lift((i.toInt).toInt).getOrElse("")
    println(code)
    println(nodes.asInstanceOf[NodesData].map.getOrElse(code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]])
    i = i + BigInt(1)
  }
  println("\nSupport\n")
  println(support)
  println("\nCluster\n")
  var j: BigInt = BigInt(0)
  while (j < BigInt((clusters.asInstanceOf[ClusterData].weights).size)) {
    var w: BigInt = clusters.asInstanceOf[ClusterData].weights.lift((j.toInt).toInt).getOrElse(BigInt(0))
    println(_str(w) + ":" + _str(clusters.asInstanceOf[ClusterData].clusters.getOrElse(w, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]))
    j = j + BigInt(1)
  }
  println("\nGraph\n")
  var k: BigInt = BigInt(0)
  while (k < BigInt((graph.keys).size)) {
    var key: String = graph.keys.lift((k.toInt).toInt).getOrElse("")
    println(key)
    println(graph.asInstanceOf[GraphData].edges.getOrElse(key.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]])
    k = k + BigInt(1)
  }
  println("\nEdge List of Frequent subgraphs\n")
  for (el <- freq_subgraph_edge_list) {
    println(el)
  }
}

def main(): Any = {
  var frequency_table: ArrayBuffer[scala.collection.mutable.Map[String,String]] = get_frequency_table(EDGE_ARRAY)
  var nodes: NodesData = get_nodes(frequency_table)
  var clusters: ClusterData = get_cluster(nodes)
  var support: ArrayBuffer[BigInt] = get_support(clusters)
  var graph: GraphData = construct_graph(clusters, nodes)
  find_freq_subgraph_given_support(BigInt(60), clusters, graph)
  var freq_subgraph_edge_list: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = freq_subgraphs_edge_list(paths, nodes)
  print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
}

var EDGE_ARRAY: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = ArrayBuffer(ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("ad", "e5"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("be", "e6"), ArrayBuffer("bh", "e12"), ArrayBuffer("cd", "e2"), ArrayBuffer("ce", "e4"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("dg", "e5"), ArrayBuffer("dh", "e10"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("fg", "e6"), ArrayBuffer("gh", "e6"), ArrayBuffer("hi", "e3")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("ad", "e5"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("be", "e6"), ArrayBuffer("cd", "e2"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("fg", "e6")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("dg", "e5"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("eh", "e12"), ArrayBuffer("fg", "e6"), ArrayBuffer("fh", "e10"), ArrayBuffer("gh", "e6")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("bh", "e12"), ArrayBuffer("cd", "e2"), ArrayBuffer("df", "e8"), ArrayBuffer("dh", "e10")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("ad", "e5"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("cd", "e2"), ArrayBuffer("ce", "e4"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("dg", "e5"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("fg", "e6")))

var paths: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer[ArrayBuffer[String]]()

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
