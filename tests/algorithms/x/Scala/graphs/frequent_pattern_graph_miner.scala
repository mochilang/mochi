// Generated by Mochi v0.10.59 on 2025-08-07 11:23:04 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class NodesData(var map: scala.collection.mutable.Map[String,ArrayBuffer[String]], var keys: ArrayBuffer[String])

case class ClusterData(var clusters: scala.collection.mutable.Map[BigInt,ArrayBuffer[String]], var weights: ArrayBuffer[BigInt])

case class GraphData(var edges: scala.collection.mutable.Map[String,ArrayBuffer[String]], var keys: ArrayBuffer[String])

def contains(lst: ArrayBuffer[String], item: String): Boolean = {
  for (v <- lst) {
    if (v == item) {
      return true
    }
  }
  return false
}

def get_distinct_edge(edge_array: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]): ArrayBuffer[String] = {
  var distinct: ArrayBuffer[String] = ArrayBuffer[String]()
  for (row <- edge_array) {
    for (item <- row) {
      val e: String = item((BigInt(0).toInt).toInt)
      if (!(distinct.contains(e)).asInstanceOf[Boolean]) {
        distinct = distinct :+ e
      }
    }
  }
  return distinct
}

def get_bitcode(edge_array: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]], de: String): String = {
  var bitcode: String = ""
  var i: BigInt = BigInt(0)
  val _br3 = new Breaks
  _br3.breakable {
    while (i < BigInt((edge_array).size)) {
      var found: Boolean = false
      val _br4 = new Breaks
      _br4.breakable {
        for (item <- edge_array((i.toInt).toInt)) {
          if (item((BigInt(0).toInt).toInt) == de) {
            found = true
            _br4.break()
          }
        }
      }
      if (found) {
        bitcode = bitcode + "1"
      } else {
        bitcode = bitcode + "0"
      }
      i = i + BigInt(1)
    }
  }
  return bitcode
}

def count_ones(s: String): BigInt = {
  var c: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).size)) {
    if (s.slice((i).toInt, (i + BigInt(1)).toInt) == "1") {
      c = c + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return c
}

def get_frequency_table(edge_array: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]): ArrayBuffer[scala.collection.mutable.Map[String,String]] = {
  val distinct: ArrayBuffer[String] = get_distinct_edge(edge_array)
  var table: ArrayBuffer[scala.collection.mutable.Map[String,String]] = ArrayBuffer[scala.collection.mutable.Map[String,String]]()
  for (e <- distinct) {
    val bit: String = get_bitcode(edge_array, e)
    val cnt: BigInt = count_ones(bit)
    var entry: scala.collection.mutable.Map[String,String] = (scala.collection.mutable.Map("edge" -> (e), "count" -> (String.valueOf(cnt)), "bit" -> (bit))).asInstanceOf[scala.collection.mutable.Map[String,String]]
    table = table :+ entry
  }
  var i: BigInt = BigInt(0)
  while (i < BigInt((table).size)) {
    var max_i: BigInt = i
    var j: BigInt = i + BigInt(1)
    while (j < BigInt((table).size)) {
      if ((toi(table((j.toInt).toInt).getOrElse("count", "").asInstanceOf[String])).toString > (toi(table((max_i.toInt).toInt).getOrElse("count", "").asInstanceOf[String])).toString) {
        max_i = j
      }
      j = j + BigInt(1)
    }
    val tmp: scala.collection.mutable.Map[String,String] = table((i.toInt).toInt)
    table((i).toInt) = table((max_i.toInt).toInt)
    table((max_i).toInt) = tmp
    i = i + BigInt(1)
  }
  return table
}

def get_nodes(freq_table: ArrayBuffer[scala.collection.mutable.Map[String,String]]): NodesData = {
  var nodes: scala.collection.mutable.Map[String,ArrayBuffer[String]] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,ArrayBuffer[String]]]
  var keys: ArrayBuffer[String] = ArrayBuffer[String]()
  for (f <- freq_table) {
    val code: String = f.getOrElse("bit", "").asInstanceOf[String]
    val edge: String = f.getOrElse("edge", "").asInstanceOf[String]
    if ((nodes.contains(code)).asInstanceOf[Boolean]) {
      nodes.update(code, nodes.getOrElse(code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ edge)
    } else {
      nodes.update(code, ArrayBuffer(edge))
      keys = keys :+ code
    }
  }
  return NodesData(nodes, keys)
}

def get_cluster(nodes: NodesData): ClusterData = {
  var clusters: scala.collection.mutable.Map[BigInt,ArrayBuffer[String]] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,ArrayBuffer[String]]]
  var weights: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((nodes.keys).size)) {
    val code: String = nodes.keys((i.toInt).toInt)
    val wt: BigInt = count_ones(code)
    if ((clusters.contains(wt)).asInstanceOf[Boolean]) {
      clusters.update(wt, clusters.getOrElse(wt, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ code)
    } else {
      clusters.update(wt, ArrayBuffer(code))
      weights = weights :+ wt
    }
    i = i + BigInt(1)
  }
  return ClusterData(clusters, weights)
}

def get_support(clusters: ClusterData): ArrayBuffer[BigInt] = {
  var sup: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((clusters.asInstanceOf[ClusterData].weights).size)) {
    val w: BigInt = clusters.asInstanceOf[ClusterData].weights((i.toInt).toInt)
    sup = sup :+ w * BigInt(100) / BigInt((clusters.asInstanceOf[ClusterData].weights).size)
    i = i + BigInt(1)
  }
  return sup
}

def contains_bits(a: String, b: String): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    val c1: String = a.slice((i).toInt, (i + BigInt(1)).toInt)
    val c2: String = b.slice((i).toInt, (i + BigInt(1)).toInt)
    if ((c1 == "1" && c2 != "1").asInstanceOf[Boolean]) {
      return false
    }
    i = i + BigInt(1)
  }
  return true
}

def max_cluster_key(clusters: ClusterData): BigInt = {
  var m: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((clusters.asInstanceOf[ClusterData].weights).size)) {
    val w: BigInt = clusters.asInstanceOf[ClusterData].weights((i.toInt).toInt)
    if (w > m) {
      m = w
    }
    i = i + BigInt(1)
  }
  return m
}

def get_cluster_codes(clusters: ClusterData, wt: BigInt): ArrayBuffer[String] = {
  if ((clusters.asInstanceOf[ClusterData].clusters.contains(wt)).asInstanceOf[Boolean]) {
    return clusters.asInstanceOf[ClusterData].clusters.getOrElse(wt, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]
  }
  return ArrayBuffer[String]()
}

def create_edge(nodes: NodesData, graph: scala.collection.mutable.Map[String,ArrayBuffer[String]], gkeys: ArrayBuffer[String], clusters: ClusterData, c1: BigInt, maxk: BigInt): ArrayBuffer[String] = {
  var keys: ArrayBuffer[String] = gkeys
  val codes1: ArrayBuffer[String] = get_cluster_codes(clusters, c1)
  var idx1: BigInt = BigInt(0)
  val _br14 = new Breaks
  _br14.breakable {
    while (idx1 < BigInt((codes1).size)) {
      val i_code: String = codes1((idx1.toInt).toInt)
      var count: BigInt = BigInt(0)
      var c2: BigInt = c1 + BigInt(1)
      val _br15 = new Breaks
      _br15.breakable {
        while (c2 <= maxk) {
          val codes2: ArrayBuffer[String] = get_cluster_codes(clusters, c2)
          var j: BigInt = BigInt(0)
          while (j < BigInt((codes2).size)) {
            val j_code: String = codes2((j.toInt).toInt)
            if (contains_bits(i_code, j_code)) {
              if ((graph.contains(i_code)).asInstanceOf[Boolean]) {
                graph.update(i_code, graph.getOrElse(i_code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ j_code)
              } else {
                graph.update(i_code, ArrayBuffer(j_code))
                if (!(keys.contains(i_code)).asInstanceOf[Boolean]) {
                  keys = keys :+ i_code
                }
              }
              if (!(keys.contains(j_code)).asInstanceOf[Boolean]) {
                keys = keys :+ j_code
              }
              count = count + BigInt(1)
            }
            j = j + BigInt(1)
          }
          if (count == BigInt(0)) {
            c2 = c2 + BigInt(1)
          } else {
            _br15.break()
          }
        }
      }
      idx1 = idx1 + BigInt(1)
    }
  }
  return keys
}

def construct_graph(clusters: ClusterData, nodes: NodesData): GraphData = {
  val maxk: BigInt = max_cluster_key(clusters)
  val top_codes: ArrayBuffer[String] = get_cluster_codes(clusters, maxk)
  var graph: scala.collection.mutable.Map[String,ArrayBuffer[String]] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,ArrayBuffer[String]]]
  var keys: ArrayBuffer[String] = ArrayBuffer("Header")
  graph.update("Header", ArrayBuffer())
  var i: BigInt = BigInt(0)
  while (i < BigInt((top_codes).size)) {
    val code: String = top_codes((i.toInt).toInt)
    graph.update("Header", graph.getOrElse("Header", ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]] :+ code)
    graph.update(code, ArrayBuffer("Header"))
    keys = keys :+ code
    i = i + BigInt(1)
  }
  var c: BigInt = BigInt(1)
  while (c < maxk) {
    keys = create_edge(nodes, graph, keys, clusters, c, maxk)
    c = c + BigInt(1)
  }
  return GraphData(graph, keys)
}

def copy_list(lst: ArrayBuffer[String]): ArrayBuffer[String] = {
  var n: ArrayBuffer[String] = ArrayBuffer[String]()
  for (v <- lst) {
    n = n :+ v
  }
  return n
}

def my_dfs(graph: scala.collection.mutable.Map[String,ArrayBuffer[String]], start: String, end: String, path: ArrayBuffer[String]): Any = {
  var new_path: ArrayBuffer[String] = copy_list(path)
  new_path = new_path :+ start
  if (start == end) {
    paths = paths :+ new_path
    return
  }
  for (node <- graph.getOrElse(start.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]) {
    var seen: Boolean = false
    for (p <- new_path) {
      if (p == node) {
        seen = true
      }
    }
    if (!seen) {
      my_dfs(graph, node, end, new_path)
    }
  }
  return null
}

def find_freq_subgraph_given_support(s: BigInt, clusters: ClusterData, graph: GraphData): Any = {
  val k: BigInt = s * BigInt((clusters.asInstanceOf[ClusterData].weights).size) / BigInt(100)
  val codes: ArrayBuffer[String] = get_cluster_codes(clusters, k)
  var i: BigInt = BigInt(0)
  while (i < BigInt((codes).size)) {
    my_dfs(graph.asInstanceOf[GraphData].edges, codes((i.toInt).toInt), "Header", ArrayBuffer[String]())
    i = i + BigInt(1)
  }
}

def node_edges(nodes: NodesData, code: String): ArrayBuffer[String] = {
  return nodes.asInstanceOf[NodesData].map.getOrElse(code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]
}

def freq_subgraphs_edge_list(paths: ArrayBuffer[ArrayBuffer[String]], nodes: NodesData): ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = {
  var freq_sub_el: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]()
  for (path <- paths) {
    var el: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer[ArrayBuffer[String]]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((path).size) - BigInt(1)) {
      val code: String = path((j.toInt).toInt)
      val edge_list: ArrayBuffer[String] = node_edges(nodes, code)
      var e: BigInt = BigInt(0)
      while (e < BigInt((edge_list).size)) {
        val edge: String = edge_list((e.toInt).toInt)
        val a: String = edge.slice((BigInt(0)).toInt, (BigInt(1)).toInt)
        val b: String = edge.slice((BigInt(1)).toInt, (BigInt(2)).toInt)
        el = el :+ ArrayBuffer(a.toString, b.toString)
        e = e + BigInt(1)
      }
      j = j + BigInt(1)
    }
    freq_sub_el = freq_sub_el :+ el
  }
  return freq_sub_el
}

def print_all(nodes: NodesData, support: ArrayBuffer[BigInt], clusters: ClusterData, graph: GraphData, freq_subgraph_edge_list: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]]): Any = {
  println("\nNodes\n")
  var i: BigInt = BigInt(0)
  while (i < BigInt((nodes.keys).size)) {
    val code: String = nodes.keys((i.toInt).toInt)
    println(code)
    println(nodes.asInstanceOf[NodesData].map.getOrElse(code.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]])
    i = i + BigInt(1)
  }
  println("\nSupport\n")
  println(support)
  println("\nCluster\n")
  var j: BigInt = BigInt(0)
  while (j < BigInt((clusters.asInstanceOf[ClusterData].weights).size)) {
    val w: BigInt = clusters.asInstanceOf[ClusterData].weights((j.toInt).toInt)
    println(String.valueOf(w) + ":" + String.valueOf(clusters.asInstanceOf[ClusterData].clusters.getOrElse(w, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]]))
    j = j + BigInt(1)
  }
  println("\nGraph\n")
  var k: BigInt = BigInt(0)
  while (k < BigInt((graph.keys).size)) {
    val key: String = graph.keys((k.toInt).toInt)
    println(key)
    println(graph.asInstanceOf[GraphData].edges.getOrElse(key.toString, ArrayBuffer[String]()).asInstanceOf[ArrayBuffer[String]])
    k = k + BigInt(1)
  }
  println("\nEdge List of Frequent subgraphs\n")
  for (el <- freq_subgraph_edge_list) {
    println(el)
  }
}

def main(): Any = {
  val frequency_table: ArrayBuffer[scala.collection.mutable.Map[String,String]] = get_frequency_table(EDGE_ARRAY)
  val nodes: NodesData = get_nodes(frequency_table)
  val clusters: ClusterData = get_cluster(nodes)
  val support: ArrayBuffer[BigInt] = get_support(clusters)
  val graph: GraphData = construct_graph(clusters, nodes)
  find_freq_subgraph_given_support(BigInt(60), clusters, graph)
  val freq_subgraph_edge_list: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = freq_subgraphs_edge_list(paths, nodes)
  print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
}

val EDGE_ARRAY: ArrayBuffer[ArrayBuffer[ArrayBuffer[String]]] = ArrayBuffer(ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("ad", "e5"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("be", "e6"), ArrayBuffer("bh", "e12"), ArrayBuffer("cd", "e2"), ArrayBuffer("ce", "e4"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("dg", "e5"), ArrayBuffer("dh", "e10"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("fg", "e6"), ArrayBuffer("gh", "e6"), ArrayBuffer("hi", "e3")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("ad", "e5"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("be", "e6"), ArrayBuffer("cd", "e2"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("fg", "e6")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("dg", "e5"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("eh", "e12"), ArrayBuffer("fg", "e6"), ArrayBuffer("fh", "e10"), ArrayBuffer("gh", "e6")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("bh", "e12"), ArrayBuffer("cd", "e2"), ArrayBuffer("df", "e8"), ArrayBuffer("dh", "e10")), ArrayBuffer(ArrayBuffer("ab", "e1"), ArrayBuffer("ac", "e3"), ArrayBuffer("ad", "e5"), ArrayBuffer("bc", "e4"), ArrayBuffer("bd", "e2"), ArrayBuffer("cd", "e2"), ArrayBuffer("ce", "e4"), ArrayBuffer("de", "e1"), ArrayBuffer("df", "e8"), ArrayBuffer("dg", "e5"), ArrayBuffer("ef", "e3"), ArrayBuffer("eg", "e2"), ArrayBuffer("fg", "e6")))

var paths: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer[ArrayBuffer[String]]()

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
