// Generated by Mochi v0.10.65 on 2025-08-14 10:12:49 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => d.toString
  case other => String.valueOf(other)
}

case class Edge(var u: BigInt, var v: BigInt, var w: BigInt)

case class Graph(var num_nodes: BigInt, var edges: ArrayBuffer[Edge], var component: scala.collection.mutable.Map[BigInt,BigInt])

case class UnionResult(var graph: Graph, var component_size: ArrayBuffer[BigInt])

def new_graph(num_nodes: BigInt): Graph = {
  return Graph(num_nodes, ArrayBuffer(), scala.collection.mutable.Map())
}

def add_edge(g: Graph, u: BigInt, v: BigInt, w: BigInt): Graph = {
  var es: ArrayBuffer[Edge] = g.asInstanceOf[Graph].edges
  es = es += (Edge(u, v, w))
  return Graph(g.asInstanceOf[Graph].num_nodes, es, g.asInstanceOf[Graph].component)
}

def find_component(g: Graph, node: BigInt): BigInt = {
  if (g.asInstanceOf[Graph].component.getOrElse(node, BigInt(0)).asInstanceOf[BigInt] == node) {
    return node
  }
  return find_component(g, g.asInstanceOf[Graph].component.getOrElse(node, BigInt(0)).asInstanceOf[BigInt])
}

def set_component(_g: Graph, node: BigInt): Graph = {
  var g: Graph = _g
  if (g.asInstanceOf[Graph].component.getOrElse(node, BigInt(0)).asInstanceOf[BigInt] != node) {
    var comp: scala.collection.mutable.Map[BigInt,BigInt] = g.asInstanceOf[Graph].component
    var k: BigInt = BigInt(0)
    while (k < g.asInstanceOf[Graph].num_nodes) {
      comp.update(k, find_component(g, k))
      k = k + BigInt(1)
    }
    g = Graph(g.asInstanceOf[Graph].num_nodes, g.asInstanceOf[Graph].edges, comp)
  }
  return g
}

def union(_g: Graph, component_size: ArrayBuffer[BigInt], u: BigInt, v: BigInt): UnionResult = {
  var g: Graph = _g
  var comp_size: ArrayBuffer[BigInt] = component_size
  var comp: scala.collection.mutable.Map[BigInt,BigInt] = g.asInstanceOf[Graph].component
  if (comp_size.lift((u.toInt).toInt).getOrElse(BigInt(0)) <= comp_size.lift((v.toInt).toInt).getOrElse(BigInt(0))) {
    comp.update(u, v)
    comp_size((v).toInt) = comp_size.lift((v.toInt).toInt).getOrElse(BigInt(0)) + comp_size.lift((u.toInt).toInt).getOrElse(BigInt(0))
    g = Graph(g.asInstanceOf[Graph].num_nodes, g.asInstanceOf[Graph].edges, comp)
    g = set_component(g, u)
  } else {
    comp.update(v, u)
    comp_size((u).toInt) = comp_size.lift((u.toInt).toInt).getOrElse(BigInt(0)) + comp_size.lift((v.toInt).toInt).getOrElse(BigInt(0))
    g = Graph(g.asInstanceOf[Graph].num_nodes, g.asInstanceOf[Graph].edges, comp)
    g = set_component(g, v)
  }
  return UnionResult(g, comp_size)
}

def create_empty_edges(n: BigInt): ArrayBuffer[Edge] = {
  var res: ArrayBuffer[Edge] = ArrayBuffer[Edge]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    res = res += (Edge(BigInt(-1), BigInt(-1), BigInt(-1)))
    i = i + BigInt(1)
  }
  return res
}

def boruvka(_g: Graph): BigInt = {
  var g: Graph = _g
  var component_size: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < g.asInstanceOf[Graph].num_nodes) {
    component_size = component_size += (BigInt(1))
    var comp: scala.collection.mutable.Map[BigInt,BigInt] = g.asInstanceOf[Graph].component
    comp.update(i, i)
    g = Graph(g.asInstanceOf[Graph].num_nodes, g.asInstanceOf[Graph].edges, comp)
    i = i + BigInt(1)
  }
  var mst_weight: BigInt = BigInt(0)
  var num_components: BigInt = g.asInstanceOf[Graph].num_nodes
  var minimum_weight_edge: ArrayBuffer[Edge] = create_empty_edges(g.asInstanceOf[Graph].num_nodes)
  while (num_components > BigInt(1)) {
    for (e <- g.asInstanceOf[Graph].edges) {
      val u: BigInt = e.asInstanceOf[Edge].u
      val v: BigInt = e.asInstanceOf[Edge].v
      val w: BigInt = e.asInstanceOf[Edge].w
      val u_comp: BigInt = g.asInstanceOf[Graph].component.getOrElse(u, BigInt(0)).asInstanceOf[BigInt]
      val v_comp: BigInt = g.asInstanceOf[Graph].component.getOrElse(v, BigInt(0)).asInstanceOf[BigInt]
      if (u_comp != v_comp) {
        val current_u: Edge = minimum_weight_edge.lift((u_comp.toInt).toInt).getOrElse(null)
        if ((current_u.asInstanceOf[Edge].u == BigInt(-1) || current_u.asInstanceOf[Edge].w > w).asInstanceOf[Boolean]) {
          minimum_weight_edge((u_comp).toInt) = Edge(u, v, w)
        }
        val current_v: Edge = minimum_weight_edge.lift((v_comp.toInt).toInt).getOrElse(null)
        if ((current_v.asInstanceOf[Edge].u == BigInt(-1) || current_v.asInstanceOf[Edge].w > w).asInstanceOf[Boolean]) {
          minimum_weight_edge((v_comp).toInt) = Edge(u, v, w)
        }
      }
    }
    for (e <- minimum_weight_edge) {
      if (e.asInstanceOf[Edge].u != BigInt(-1)) {
        val u: BigInt = e.asInstanceOf[Edge].u
        val v: BigInt = e.asInstanceOf[Edge].v
        val w: BigInt = e.asInstanceOf[Edge].w
        val u_comp: BigInt = g.asInstanceOf[Graph].component.getOrElse(u, BigInt(0)).asInstanceOf[BigInt]
        val v_comp: BigInt = g.asInstanceOf[Graph].component.getOrElse(v, BigInt(0)).asInstanceOf[BigInt]
        if (u_comp != v_comp) {
          mst_weight = mst_weight + w
          val res: UnionResult = union(g, component_size, u_comp, v_comp)
          g = res.asInstanceOf[UnionResult].graph
          component_size = res.asInstanceOf[UnionResult].component_size
          println("Added edge [" + _str(u) + " - " + _str(v) + "]")
          println("Added weight: " + _str(w))
          println("")
          num_components = num_components - BigInt(1)
        }
      }
    }
    minimum_weight_edge = create_empty_edges(g.asInstanceOf[Graph].num_nodes)
  }
  println("The total weight of the minimal spanning tree is: " + _str(mst_weight))
  return mst_weight
}

def main(): Any = {
  var g: Graph = new_graph(BigInt(8))
  val edges: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(0), BigInt(1), BigInt(10)), ArrayBuffer(BigInt(0), BigInt(2), BigInt(6)), ArrayBuffer(BigInt(0), BigInt(3), BigInt(5)), ArrayBuffer(BigInt(1), BigInt(3), BigInt(15)), ArrayBuffer(BigInt(2), BigInt(3), BigInt(4)), ArrayBuffer(BigInt(3), BigInt(4), BigInt(8)), ArrayBuffer(BigInt(4), BigInt(5), BigInt(10)), ArrayBuffer(BigInt(4), BigInt(6), BigInt(6)), ArrayBuffer(BigInt(4), BigInt(7), BigInt(5)), ArrayBuffer(BigInt(5), BigInt(7), BigInt(15)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(4)))
  for (e <- edges) {
    g = add_edge(g, e.lift((BigInt(0).toInt).toInt).getOrElse(BigInt(0)), e.lift((BigInt(1).toInt).toInt).getOrElse(BigInt(0)), e.lift((BigInt(2).toInt).toInt).getOrElse(BigInt(0)))
  }
  boruvka(g)
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
