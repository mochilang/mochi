// Generated by Mochi v0.10.59 on 2025-08-07 11:14:30 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Edge(var to: String, var cost: BigInt)

case class QItem(var node: String, var cost: BigInt)

case class PassResult(var queue: ArrayBuffer[QItem], var dist: BigInt)

def get_min_index(q: ArrayBuffer[QItem]): BigInt = {
  var idx: BigInt = 0
  var i: BigInt = 1
  while (i < BigInt((q).size)) {
    if ((q((i.toInt).toInt).cost).toString < (q((idx.toInt).toInt).cost).toString) {
      idx = i
    }
    i = i + 1
  }
  return idx
}

def remove_at(q: ArrayBuffer[QItem], idx: BigInt): ArrayBuffer[QItem] = {
  var res: ArrayBuffer[QItem] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((q).size)) {
    if (i != idx) {
      res = res :+ q((i.toInt).toInt)
    }
    i = i + 1
  }
  return res
}

def pass_and_relaxation(graph: scala.collection.mutable.Map[String,ArrayBuffer[Edge]], v: String, visited_forward: scala.collection.mutable.Map[String,Boolean], visited_backward: scala.collection.mutable.Map[String,Boolean], cst_fwd: scala.collection.mutable.Map[String,BigInt], cst_bwd: scala.collection.mutable.Map[String,BigInt], queue: ArrayBuffer[QItem], parent: scala.collection.mutable.Map[String,String], shortest_distance: BigInt): PassResult = {
  var q: ArrayBuffer[QItem] = queue
  var sd: BigInt = shortest_distance
  val _ct2 = new Breaks
  for (e <- graph.getOrElse(v.toString, ArrayBuffer[Edge]()).asInstanceOf[ArrayBuffer[Edge]]) {
    _ct2.breakable {
      val nxt: String = e.asInstanceOf[Edge].to
      val d: BigInt = e.cost
      if ((visited_forward.contains(nxt)).asInstanceOf[Boolean]) {
        _ct2.break()
      }
      val old_cost: BigInt = (if (cst_fwd.contains(nxt)) cst_fwd.getOrElse(nxt.toString, null).asInstanceOf[BigInt] else 2147483647)
      val new_cost: BigInt = cst_fwd.getOrElse(v.toString, null).asInstanceOf[BigInt] + d
      if (new_cost < old_cost) {
        q = q :+ QItem(nxt, new_cost)
        cst_fwd.update(nxt, new_cost)
        parent.update(nxt, v)
      }
      if ((visited_backward.contains(nxt)).asInstanceOf[Boolean]) {
        val alt: BigInt = cst_fwd.getOrElse(v.toString, null).asInstanceOf[BigInt] + d + cst_bwd.getOrElse(nxt.toString, null).asInstanceOf[BigInt]
        if (alt < sd) {
          sd = alt
        }
      }
    }
  }
  return PassResult(q, sd)
}

def bidirectional_dij(source: String, destination: String, graph_forward: scala.collection.mutable.Map[String,ArrayBuffer[Edge]], graph_backward: scala.collection.mutable.Map[String,ArrayBuffer[Edge]]): BigInt = {
  var shortest_path_distance: BigInt = -1
  var visited_forward: scala.collection.mutable.Map[String,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,Boolean]]
  var visited_backward: scala.collection.mutable.Map[String,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,Boolean]]
  var cst_fwd: scala.collection.mutable.Map[String,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,BigInt]]
  cst_fwd.update(source, 0)
  var cst_bwd: scala.collection.mutable.Map[String,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,BigInt]]
  cst_bwd.update(destination, 0)
  var parent_forward: scala.collection.mutable.Map[String,String] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,String]]
  parent_forward.update(source, "")
  var parent_backward: scala.collection.mutable.Map[String,String] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,String]]
  parent_backward.update(destination, "")
  var queue_forward: ArrayBuffer[QItem] = ArrayBuffer()
  queue_forward = queue_forward :+ QItem(source, 0)
  var queue_backward: ArrayBuffer[QItem] = ArrayBuffer()
  queue_backward = queue_backward :+ QItem(destination, 0)
  var shortest_distance: BigInt = 2147483647
  if (source == destination) {
    return 0
  }
  val _br3 = new Breaks
  _br3.breakable {
    while (BigInt((queue_forward).size) > 0 && BigInt((queue_backward).size) > 0) {
      val idx_f: BigInt = get_min_index(queue_forward)
      val item_f: QItem = queue_forward((idx_f.toInt).toInt)
      queue_forward = remove_at(queue_forward, idx_f)
      val v_fwd: String = item_f.asInstanceOf[QItem].node
      visited_forward.update(v_fwd, true)
      val idx_b: BigInt = get_min_index(queue_backward)
      val item_b: QItem = queue_backward((idx_b.toInt).toInt)
      queue_backward = remove_at(queue_backward, idx_b)
      val v_bwd: String = item_b.asInstanceOf[QItem].node
      visited_backward.update(v_bwd, true)
      val res_f: PassResult = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, parent_forward, shortest_distance)
      queue_forward = res_f.asInstanceOf[PassResult].queue
      shortest_distance = res_f.asInstanceOf[PassResult].dist
      val res_b: PassResult = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, parent_backward, shortest_distance)
      queue_backward = res_b.asInstanceOf[PassResult].queue
      shortest_distance = res_b.asInstanceOf[PassResult].dist
      if (cst_fwd.getOrElse(v_fwd.toString, null).asInstanceOf[BigInt] + cst_bwd.getOrElse(v_bwd.toString, null).asInstanceOf[BigInt] >= shortest_distance) {
        _br3.break()
      }
    }
  }
  if (shortest_distance != 2147483647) {
    shortest_path_distance = shortest_distance
  }
  return shortest_path_distance
}

var graph_fwd: scala.collection.mutable.Map[String,ArrayBuffer[Edge]] = (scala.collection.mutable.Map("B" -> (ArrayBuffer(Edge("C", 1))), "C" -> (ArrayBuffer(Edge("D", 1))), "D" -> (ArrayBuffer(Edge("F", 1))), "E" -> (ArrayBuffer(Edge("B", 1), Edge("G", 2))), "F" -> (ArrayBuffer()), "G" -> (ArrayBuffer(Edge("F", 1))))).asInstanceOf[scala.collection.mutable.Map[String,ArrayBuffer[Edge]]]

var graph_bwd: scala.collection.mutable.Map[String,ArrayBuffer[Edge]] = (scala.collection.mutable.Map("B" -> (ArrayBuffer(Edge("E", 1))), "C" -> (ArrayBuffer(Edge("B", 1))), "D" -> (ArrayBuffer(Edge("C", 1))), "F" -> (ArrayBuffer(Edge("D", 1), Edge("G", 1))), "E" -> (ArrayBuffer()), "G" -> (ArrayBuffer(Edge("E", 2))))).asInstanceOf[scala.collection.mutable.Map[String,ArrayBuffer[Edge]]]

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(String.valueOf(bidirectional_dij("E", "F", graph_fwd, graph_bwd)))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
