// Generated by Mochi v0.10.59 on 2025-08-07 11:21:52 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class NodeCost(var node: String, var cost: BigInt)

val G: scala.collection.mutable.Map[String,scala.collection.mutable.Map[String,BigInt]] = scala.collection.mutable.Map("A" -> (scala.collection.mutable.Map("B" -> (BigInt(2)), "C" -> (BigInt(5)))), "B" -> (scala.collection.mutable.Map("A" -> (BigInt(2)), "D" -> (BigInt(3)), "E" -> (BigInt(1)), "F" -> (BigInt(1)))), "C" -> (scala.collection.mutable.Map("A" -> (BigInt(5)), "F" -> (BigInt(3)))), "D" -> (scala.collection.mutable.Map("B" -> (BigInt(3)))), "E" -> (scala.collection.mutable.Map("B" -> (BigInt(4)), "F" -> (BigInt(3)))), "F" -> (scala.collection.mutable.Map("C" -> (BigInt(3)), "E" -> (BigInt(3)))))

val G2: scala.collection.mutable.Map[String,scala.collection.mutable.Map[String,BigInt]] = scala.collection.mutable.Map("B" -> (scala.collection.mutable.Map("C" -> (BigInt(1)))), "C" -> (scala.collection.mutable.Map("D" -> (BigInt(1)))), "D" -> (scala.collection.mutable.Map("F" -> (BigInt(1)))), "E" -> (scala.collection.mutable.Map("B" -> (BigInt(1)), "F" -> (BigInt(3)))), "F" -> (scala.collection.mutable.Map()))

val G3: scala.collection.mutable.Map[String,scala.collection.mutable.Map[String,BigInt]] = scala.collection.mutable.Map("B" -> (scala.collection.mutable.Map("C" -> (BigInt(1)))), "C" -> (scala.collection.mutable.Map("D" -> (BigInt(1)))), "D" -> (scala.collection.mutable.Map("F" -> (BigInt(1)))), "E" -> (scala.collection.mutable.Map("B" -> (BigInt(1)), "G" -> (BigInt(2)))), "F" -> (scala.collection.mutable.Map()), "G" -> (scala.collection.mutable.Map("F" -> (BigInt(1)))))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    var heap: ArrayBuffer[NodeCost] = ArrayBuffer(NodeCost("E", BigInt(0)))
    var visited: scala.collection.mutable.Map[String,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,Boolean]]
    var result: BigInt = -BigInt(1)
    val _br0 = new Breaks
    val _ct0 = new Breaks
    _br0.breakable {
      while (BigInt((heap).size) > BigInt(0)) {
        _ct0.breakable {
          var best_idx: BigInt = BigInt(0)
          var i: BigInt = BigInt(1)
          while (i < BigInt((heap).size)) {
            if (heap((i.toInt).toInt).cost < heap((best_idx.toInt).toInt).cost) {
              best_idx = i
            }
            i = i + BigInt(1)
          }
          val best: NodeCost = heap((best_idx.toInt).toInt)
          var new_heap: ArrayBuffer[NodeCost] = ArrayBuffer[NodeCost]()
          var j: BigInt = BigInt(0)
          while (j < BigInt((heap).size)) {
            if (j != best_idx) {
              new_heap = new_heap :+ heap((j.toInt).toInt)
            }
            j = j + BigInt(1)
          }
          heap = new_heap
          val u: String = best.asInstanceOf[NodeCost].node
          val cost: BigInt = best.asInstanceOf[NodeCost].cost
          if ((visited.contains(u)).asInstanceOf[Boolean]) {
            _ct0.break()
          }
          visited.update(u, true)
          if (u == "C") {
            result = cost
            _br0.break()
          }
          val _ct3 = new Breaks
          for (v <- G.getOrElse(u.toString, null).asInstanceOf[scala.collection.mutable.Map[String,BigInt]].keys) {
            _ct3.breakable {
              if ((visited.contains(v)).asInstanceOf[Boolean]) {
                _ct3.break()
              }
              val next_cost: BigInt = cost + G.getOrElse(u.toString, null).asInstanceOf[scala.collection.mutable.Map[String,BigInt]].getOrElse(v.toString, null).asInstanceOf[BigInt]
              heap = heap :+ NodeCost(v, next_cost)
            }
          }
        }
      }
    }
    println(result)
    var heap2: ArrayBuffer[NodeCost] = ArrayBuffer(NodeCost("E", BigInt(0)))
    var visited2: scala.collection.mutable.Map[String,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,Boolean]]
    var result2: BigInt = -BigInt(1)
    val _br4 = new Breaks
    val _ct4 = new Breaks
    _br4.breakable {
      while (BigInt((heap2).size) > BigInt(0)) {
        _ct4.breakable {
          var best2_idx: BigInt = BigInt(0)
          var i2: BigInt = BigInt(1)
          while (i2 < BigInt((heap2).size)) {
            if (heap2((i2.toInt).toInt).cost < heap2((best2_idx.toInt).toInt).cost) {
              best2_idx = i2
            }
            i2 = i2 + BigInt(1)
          }
          val best2: NodeCost = heap2((best2_idx.toInt).toInt)
          var new_heap2: ArrayBuffer[NodeCost] = ArrayBuffer[NodeCost]()
          var j2: BigInt = BigInt(0)
          while (j2 < BigInt((heap2).size)) {
            if (j2 != best2_idx) {
              new_heap2 = new_heap2 :+ heap2((j2.toInt).toInt)
            }
            j2 = j2 + BigInt(1)
          }
          heap2 = new_heap2
          val u2: String = best2.asInstanceOf[NodeCost].node
          val cost2: BigInt = best2.asInstanceOf[NodeCost].cost
          if ((visited2.contains(u2)).asInstanceOf[Boolean]) {
            _ct4.break()
          }
          visited2.update(u2, true)
          if (u2 == "F") {
            result2 = cost2
            _br4.break()
          }
          val _ct7 = new Breaks
          for (v2 <- G2.getOrElse(u2.toString, null).asInstanceOf[scala.collection.mutable.Map[String,BigInt]].keys) {
            _ct7.breakable {
              if ((visited2.contains(v2)).asInstanceOf[Boolean]) {
                _ct7.break()
              }
              val next_cost2: BigInt = cost2 + G2.getOrElse(u2.toString, null).asInstanceOf[scala.collection.mutable.Map[String,BigInt]].getOrElse(v2.toString, null).asInstanceOf[BigInt]
              heap2 = heap2 :+ NodeCost(v2, next_cost2)
            }
          }
        }
      }
    }
    println(result2)
    var heap3: ArrayBuffer[NodeCost] = ArrayBuffer(NodeCost("E", BigInt(0)))
    var visited3: scala.collection.mutable.Map[String,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[String,Boolean]]
    var result3: BigInt = -BigInt(1)
    val _br8 = new Breaks
    val _ct8 = new Breaks
    _br8.breakable {
      while (BigInt((heap3).size) > BigInt(0)) {
        _ct8.breakable {
          var best3_idx: BigInt = BigInt(0)
          var i3: BigInt = BigInt(1)
          while (i3 < BigInt((heap3).size)) {
            if (heap3((i3.toInt).toInt).cost < heap3((best3_idx.toInt).toInt).cost) {
              best3_idx = i3
            }
            i3 = i3 + BigInt(1)
          }
          val best3: NodeCost = heap3((best3_idx.toInt).toInt)
          var new_heap3: ArrayBuffer[NodeCost] = ArrayBuffer[NodeCost]()
          var j3: BigInt = BigInt(0)
          while (j3 < BigInt((heap3).size)) {
            if (j3 != best3_idx) {
              new_heap3 = new_heap3 :+ heap3((j3.toInt).toInt)
            }
            j3 = j3 + BigInt(1)
          }
          heap3 = new_heap3
          val u3: String = best3.asInstanceOf[NodeCost].node
          val cost3: BigInt = best3.asInstanceOf[NodeCost].cost
          if ((visited3.contains(u3)).asInstanceOf[Boolean]) {
            _ct8.break()
          }
          visited3.update(u3, true)
          if (u3 == "F") {
            result3 = cost3
            _br8.break()
          }
          val _ct11 = new Breaks
          for (v3 <- G3.getOrElse(u3.toString, null).asInstanceOf[scala.collection.mutable.Map[String,BigInt]].keys) {
            _ct11.breakable {
              if ((visited3.contains(v3)).asInstanceOf[Boolean]) {
                _ct11.break()
              }
              val next_cost3: BigInt = cost3 + G3.getOrElse(u3.toString, null).asInstanceOf[scala.collection.mutable.Map[String,BigInt]].getOrElse(v3.toString, null).asInstanceOf[BigInt]
              heap3 = heap3 :+ NodeCost(v3, next_cost3)
            }
          }
        }
      }
    }
    println(result3)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
