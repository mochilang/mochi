// Generated by Mochi v0.10.59 on 2025-08-07 11:14:18 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def dfs(g: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]], s: BigInt): Any = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var stack: ArrayBuffer[BigInt] = ArrayBuffer()
  visited.update(s, true)
  stack = stack :+ s
  println(s)
  val _br0 = new Breaks
  _br0.breakable {
    while (BigInt((stack).size) > 0) {
      val u: BigInt = stack(((BigInt((stack).size) - 1).toInt).toInt)
      var found: Boolean = false
      val _br1 = new Breaks
      _br1.breakable {
        for (v <- g.getOrElse(u, ArrayBuffer[BigInt]()).asInstanceOf[ArrayBuffer[BigInt]]) {
          if (!(visited.contains(v)).asInstanceOf[Boolean]) {
            visited.update(v, true)
            stack = stack :+ v
            println(v)
            found = true
            _br1.break()
          }
        }
      }
      if (!found) {
        stack = stack.slice((0).toInt, (BigInt((stack).size) - 1).toInt)
      }
    }
  }
}

def bfs(g: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]], s: BigInt): Any = {
  var visited: scala.collection.mutable.Map[BigInt,Boolean] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,Boolean]]
  var q: ArrayBuffer[BigInt] = ArrayBuffer()
  visited.update(s, true)
  q = q :+ s
  println(s)
  while (BigInt((q).size) > 0) {
    val u: BigInt = q((0.toInt).toInt)
    q = q.slice((1).toInt, (BigInt((q).size)).toInt)
    for (v <- g.getOrElse(u, ArrayBuffer[BigInt]()).asInstanceOf[ArrayBuffer[BigInt]]) {
      if (!(visited.contains(v)).asInstanceOf[Boolean]) {
        visited.update(v, true)
        q = q :+ v
        println(v)
      }
    }
  }
}

def sort_ints(a: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = a
  var i: BigInt = 0
  while (i < BigInt((arr).size)) {
    var j: BigInt = 0
    while (j < BigInt((arr).size) - i - 1) {
      if (arr((j.toInt).toInt) > arr(((j + 1).toInt).toInt)) {
        val tmp: BigInt = arr((j.toInt).toInt)
        arr((j).toInt) = arr(((j + 1).toInt).toInt)
        arr((j + 1).toInt) = tmp
      }
      j = j + 1
    }
    i = i + 1
  }
  return arr
}

def dijkstra(g: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]], s: BigInt): Any = {
  var dist: scala.collection.mutable.Map[BigInt,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,BigInt]]
  dist.update(s, 0)
  var path: scala.collection.mutable.Map[BigInt,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,BigInt]]
  path.update(s, 0)
  var known: ArrayBuffer[BigInt] = ArrayBuffer()
  var keys: ArrayBuffer[BigInt] = ArrayBuffer(s)
  while (BigInt((known).size) < BigInt((keys).size)) {
    var mini: BigInt = 100000
    var u: BigInt = -1
    var i: BigInt = 0
    while (i < BigInt((keys).size)) {
      val k: BigInt = keys((i.toInt).toInt)
      val d: BigInt = dist.getOrElse(k, null).asInstanceOf[BigInt]
      if ((!(known.contains(k)).asInstanceOf[Boolean] && d < mini).asInstanceOf[Boolean]) {
        mini = d
        u = k
      }
      i = i + 1
    }
    known = known :+ u
    for (e <- g.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]) {
      val v: BigInt = e((0.toInt).toInt)
      val w: BigInt = e((1.toInt).toInt)
      if (!(keys.contains(v)).asInstanceOf[Boolean]) {
        keys = keys :+ v
      }
      val alt: BigInt = dist.getOrElse(u, null).asInstanceOf[BigInt] + w
      val cur: BigInt = (if (dist.contains(v)) dist.getOrElse(v, null).asInstanceOf[BigInt] else 100000)
      if ((!(known.contains(v)).asInstanceOf[Boolean] && alt < cur).asInstanceOf[Boolean]) {
        dist.update(v, alt)
        path.update(v, u)
      }
    }
  }
  val ordered: ArrayBuffer[BigInt] = sort_ints(keys)
  var idx: BigInt = 0
  while (idx < BigInt((ordered).size)) {
    val k: BigInt = ordered((idx.toInt).toInt)
    if (k != s) {
      println(dist.getOrElse(k, null).asInstanceOf[BigInt])
    }
    idx = idx + 1
  }
}

def topo(g: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]], n: BigInt): Any = {
  var ind: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i <= n) {
    ind = ind :+ BigInt(0)
    i = i + 1
  }
  var node: BigInt = 1
  while (node <= n) {
    for (v <- g.getOrElse(node, ArrayBuffer[BigInt]()).asInstanceOf[ArrayBuffer[BigInt]]) {
      ind((v).toInt) = ind((v.toInt).toInt) + 1
    }
    node = node + 1
  }
  var q: ArrayBuffer[BigInt] = ArrayBuffer()
  var j: BigInt = 1
  while (j <= n) {
    if (ind((j.toInt).toInt) == 0) {
      q = q :+ j
    }
    j = j + 1
  }
  while (BigInt((q).size) > 0) {
    val v: BigInt = q((0.toInt).toInt)
    q = q.slice((1).toInt, (BigInt((q).size)).toInt)
    println(v)
    for (w <- g.getOrElse(v, ArrayBuffer[BigInt]()).asInstanceOf[ArrayBuffer[BigInt]]) {
      ind((w).toInt) = ind((w.toInt).toInt) - 1
      if (ind((w.toInt).toInt) == 0) {
        q = q :+ w
      }
    }
  }
}

def floyd(a: ArrayBuffer[ArrayBuffer[BigInt]]): Any = {
  val n: BigInt = BigInt((a).size)
  var dist: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var i: BigInt = 0
  while (i < n) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var j: BigInt = 0
    while (j < n) {
      row = row :+ a((i.toInt).toInt)((j.toInt).toInt)
      j = j + 1
    }
    dist = dist :+ row
    i = i + 1
  }
  var k: BigInt = 0
  while (k < n) {
    var ii: BigInt = 0
    while (ii < n) {
      var jj: BigInt = 0
      while (jj < n) {
        if (dist((ii.toInt).toInt)((jj.toInt).toInt) > dist((ii.toInt).toInt)((k.toInt).toInt) + dist((k.toInt).toInt)((jj.toInt).toInt)) {
          dist((ii).toInt)((jj).toInt) = dist((ii.toInt).toInt)((k.toInt).toInt) + dist((k.toInt).toInt)((jj.toInt).toInt)
        }
        jj = jj + 1
      }
      ii = ii + 1
    }
    k = k + 1
  }
  println(dist)
}

def prim(g: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]], s: BigInt, n: BigInt): BigInt = {
  var dist: scala.collection.mutable.Map[BigInt,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,BigInt]]
  dist.update(s, 0)
  var known: ArrayBuffer[BigInt] = ArrayBuffer()
  var keys: ArrayBuffer[BigInt] = ArrayBuffer(s)
  var total: BigInt = 0
  while (BigInt((known).size) < n) {
    var mini: BigInt = 100000
    var u: BigInt = -1
    var i: BigInt = 0
    while (i < BigInt((keys).size)) {
      val k: BigInt = keys((i.toInt).toInt)
      val d: BigInt = dist.getOrElse(k, null).asInstanceOf[BigInt]
      if ((!(known.contains(k)).asInstanceOf[Boolean] && d < mini).asInstanceOf[Boolean]) {
        mini = d
        u = k
      }
      i = i + 1
    }
    known = known :+ u
    total = total + mini
    for (e <- g.getOrElse(u, ArrayBuffer[ArrayBuffer[BigInt]]()).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]) {
      val v: BigInt = e((0.toInt).toInt)
      val w: BigInt = e((1.toInt).toInt)
      if (!(keys.contains(v)).asInstanceOf[Boolean]) {
        keys = keys :+ v
      }
      val cur: BigInt = (if (dist.contains(v)) dist.getOrElse(v, null).asInstanceOf[BigInt] else 100000)
      if ((!(known.contains(v)).asInstanceOf[Boolean] && w < cur).asInstanceOf[Boolean]) {
        dist.update(v, w)
      }
    }
  }
  return total
}

def sort_edges(edges: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var es: ArrayBuffer[ArrayBuffer[BigInt]] = edges
  var i: BigInt = 0
  while (i < BigInt((es).size)) {
    var j: BigInt = 0
    while (j < BigInt((es).size) - i - 1) {
      if (es((j.toInt).toInt)((2.toInt).toInt) > es(((j + 1).toInt).toInt)((2.toInt).toInt)) {
        val tmp: ArrayBuffer[BigInt] = es((j.toInt).toInt)
        es((j).toInt) = es(((j + 1).toInt).toInt)
        es((j + 1).toInt) = tmp
      }
      j = j + 1
    }
    i = i + 1
  }
  return es
}

def find_parent(parent: ArrayBuffer[BigInt], x: BigInt): BigInt = {
  var r: BigInt = x
  while (parent((r.toInt).toInt) != r) {
    r = parent((r.toInt).toInt)
  }
  return r
}

def union_parent(parent: ArrayBuffer[BigInt], a: BigInt, b: BigInt): Any = {
  parent((a).toInt) = b
}

def kruskal(edges: ArrayBuffer[ArrayBuffer[BigInt]], n: BigInt): BigInt = {
  var es: ArrayBuffer[ArrayBuffer[BigInt]] = sort_edges(edges)
  var parent: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i <= n) {
    parent = parent :+ i
    i = i + 1
  }
  var total: BigInt = 0
  var count: BigInt = 0
  var idx: BigInt = 0
  while (count < n - 1 && idx < BigInt((es).size)) {
    val e: ArrayBuffer[BigInt] = es((idx.toInt).toInt)
    idx = idx + 1
    val u: BigInt = e((0.toInt).toInt)
    val v: BigInt = e((1.toInt).toInt)
    val w: BigInt = e((2.toInt).toInt)
    val ru: BigInt = find_parent(parent, u)
    val rv: BigInt = find_parent(parent, v)
    if (ru != rv) {
      union_parent(parent, ru, rv)
      total = total + w
      count = count + 1
    }
  }
  return total
}

def find_isolated_nodes(g: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]], nodes: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var isolated: ArrayBuffer[BigInt] = ArrayBuffer()
  for (node <- nodes) {
    if (BigInt((g.getOrElse(node, ArrayBuffer[BigInt]()).asInstanceOf[ArrayBuffer[BigInt]]).size) == 0) {
      isolated = isolated :+ node
    }
  }
  return isolated
}

val g_dfs: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]] = scala.collection.mutable.Map(BigInt(1) -> (ArrayBuffer(2, 3)), BigInt(2) -> (ArrayBuffer(4, 5)), BigInt(3) -> (ArrayBuffer()), BigInt(4) -> (ArrayBuffer()), BigInt(5) -> (ArrayBuffer()))

val g_bfs: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]] = scala.collection.mutable.Map(BigInt(1) -> (ArrayBuffer(2, 3)), BigInt(2) -> (ArrayBuffer(4, 5)), BigInt(3) -> (ArrayBuffer(6, 7)), BigInt(4) -> (ArrayBuffer()), BigInt(5) -> (ArrayBuffer(8)), BigInt(6) -> (ArrayBuffer()), BigInt(7) -> (ArrayBuffer()), BigInt(8) -> (ArrayBuffer()))

val g_weighted: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = scala.collection.mutable.Map(BigInt(1) -> (ArrayBuffer(ArrayBuffer(2, 7), ArrayBuffer(3, 9), ArrayBuffer(6, 14))), BigInt(2) -> (ArrayBuffer(ArrayBuffer(1, 7), ArrayBuffer(3, 10), ArrayBuffer(4, 15))), BigInt(3) -> (ArrayBuffer(ArrayBuffer(1, 9), ArrayBuffer(2, 10), ArrayBuffer(4, 11), ArrayBuffer(6, 2))), BigInt(4) -> (ArrayBuffer(ArrayBuffer(2, 15), ArrayBuffer(3, 11), ArrayBuffer(5, 6))), BigInt(5) -> (ArrayBuffer(ArrayBuffer(4, 6), ArrayBuffer(6, 9))), BigInt(6) -> (ArrayBuffer(ArrayBuffer(1, 14), ArrayBuffer(3, 2), ArrayBuffer(5, 9))))

val g_topo: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]] = scala.collection.mutable.Map(BigInt(1) -> (ArrayBuffer(2, 3)), BigInt(2) -> (ArrayBuffer(4)), BigInt(3) -> (ArrayBuffer(4)), BigInt(4) -> (ArrayBuffer()))

val matrix: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(0, 5, 9, 100000), ArrayBuffer(100000, 0, 2, 8), ArrayBuffer(100000, 100000, 0, 7), ArrayBuffer(4, 100000, 100000, 0))

val g_prim: scala.collection.mutable.Map[BigInt,ArrayBuffer[ArrayBuffer[BigInt]]] = scala.collection.mutable.Map(BigInt(1) -> (ArrayBuffer(ArrayBuffer(2, 1), ArrayBuffer(3, 3))), BigInt(2) -> (ArrayBuffer(ArrayBuffer(1, 1), ArrayBuffer(3, 1), ArrayBuffer(4, 6))), BigInt(3) -> (ArrayBuffer(ArrayBuffer(1, 3), ArrayBuffer(2, 1), ArrayBuffer(4, 2))), BigInt(4) -> (ArrayBuffer(ArrayBuffer(2, 6), ArrayBuffer(3, 2))))

val edges_kruskal: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(1, 2, 1), ArrayBuffer(2, 3, 2), ArrayBuffer(1, 3, 2), ArrayBuffer(3, 4, 1))

val g_iso: scala.collection.mutable.Map[BigInt,ArrayBuffer[BigInt]] = scala.collection.mutable.Map(BigInt(1) -> (ArrayBuffer(2, 3)), BigInt(2) -> (ArrayBuffer(1, 3)), BigInt(3) -> (ArrayBuffer(1, 2)), BigInt(4) -> (ArrayBuffer()))

val iso: ArrayBuffer[BigInt] = find_isolated_nodes(g_iso, ArrayBuffer(1, 2, 3, 4))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    dfs(g_dfs, 1)
    bfs(g_bfs, 1)
    dijkstra(g_weighted, 1)
    topo(g_topo, 4)
    floyd(matrix)
    println(prim(g_prim, 1, 4))
    println(kruskal(edges_kruskal, 4))
    println(iso)
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
