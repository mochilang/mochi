// Generated by Mochi v0.10.64 on 2025-08-12 09:35:01 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class DataSet(var images: ArrayBuffer[ArrayBuffer[BigInt]], var labels: ArrayBuffer[ArrayBuffer[BigInt]], var num_examples: BigInt, var index_in_epoch: BigInt, var epochs_completed: BigInt)

case class Datasets(var train: DataSet, var validation: DataSet, var test_ds: DataSet)

case class BatchResult(var dataset: DataSet, var images: ArrayBuffer[ArrayBuffer[BigInt]], var labels: ArrayBuffer[ArrayBuffer[BigInt]])

def dense_to_one_hot(labels: ArrayBuffer[BigInt], num_classes: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var result: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((labels).size)) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var j: BigInt = BigInt(0)
    while (j < num_classes) {
      if (j == labels.lift((i.toInt).toInt).getOrElse(BigInt(0))) {
        row = row :+ (BigInt(1))
      } else {
        row = row :+ (BigInt(0))
      }
      j = j + BigInt(1)
    }
    result = result :+ (row)
    i = i + BigInt(1)
  }
  return result
}

def new_dataset(images: ArrayBuffer[ArrayBuffer[BigInt]], labels: ArrayBuffer[ArrayBuffer[BigInt]]): DataSet = {
  return DataSet(images, labels, BigInt((images).size), BigInt(0), BigInt(0))
}

def next_batch(ds: DataSet, batch_size: BigInt): BatchResult = {
  val start: BigInt = ds.asInstanceOf[DataSet].index_in_epoch
  if (start + batch_size > ds.asInstanceOf[DataSet].num_examples) {
    val rest: BigInt = ds.asInstanceOf[DataSet].num_examples - start
    val images_rest: ArrayBuffer[ArrayBuffer[BigInt]] = ds.images.slice((start).toInt, (ds.asInstanceOf[DataSet].num_examples).toInt)
    val labels_rest: ArrayBuffer[ArrayBuffer[BigInt]] = ds.labels.slice((start).toInt, (ds.asInstanceOf[DataSet].num_examples).toInt)
    val new_index: BigInt = batch_size - rest
    val images_new: ArrayBuffer[ArrayBuffer[BigInt]] = ds.images.slice((BigInt(0)).toInt, (new_index).toInt)
    val labels_new: ArrayBuffer[ArrayBuffer[BigInt]] = ds.labels.slice((BigInt(0)).toInt, (new_index).toInt)
    val batch_images: ArrayBuffer[Any] = images_rest ++ images_new
    val batch_labels: ArrayBuffer[Any] = labels_rest ++ labels_new
    val new_ds: DataSet = DataSet(ds.images, ds.labels, ds.asInstanceOf[DataSet].num_examples, new_index, ds.asInstanceOf[DataSet].epochs_completed + BigInt(1))
    return BatchResult(new_ds, batch_images, batch_labels)
  } else {
    val end: BigInt = start + batch_size
    val batch_images: ArrayBuffer[ArrayBuffer[BigInt]] = ds.images.slice((start).toInt, (end).toInt)
    val batch_labels: ArrayBuffer[ArrayBuffer[BigInt]] = ds.labels.slice((start).toInt, (end).toInt)
    val new_ds: DataSet = DataSet(ds.images, ds.labels, ds.asInstanceOf[DataSet].num_examples, end, ds.asInstanceOf[DataSet].epochs_completed)
    return BatchResult(new_ds, batch_images, batch_labels)
  }
  return null
}

def read_data_sets(train_images: ArrayBuffer[ArrayBuffer[BigInt]], train_labels_raw: ArrayBuffer[BigInt], test_images: ArrayBuffer[ArrayBuffer[BigInt]], test_labels_raw: ArrayBuffer[BigInt], validation_size: BigInt, num_classes: BigInt): Datasets = {
  val train_labels: ArrayBuffer[ArrayBuffer[BigInt]] = dense_to_one_hot(train_labels_raw, num_classes)
  val test_labels: ArrayBuffer[ArrayBuffer[BigInt]] = dense_to_one_hot(test_labels_raw, num_classes)
  val validation_images: ArrayBuffer[ArrayBuffer[BigInt]] = train_images.slice((BigInt(0)).toInt, (validation_size).toInt)
  val validation_labels: ArrayBuffer[ArrayBuffer[BigInt]] = train_labels.slice((BigInt(0)).toInt, (validation_size).toInt)
  val train_images_rest: ArrayBuffer[ArrayBuffer[BigInt]] = train_images.slice((validation_size).toInt, (BigInt((train_images).size)).toInt)
  val train_labels_rest: ArrayBuffer[ArrayBuffer[BigInt]] = train_labels.slice((validation_size).toInt, (BigInt((train_labels).size)).toInt)
  val train: DataSet = new_dataset(train_images_rest, train_labels_rest)
  val validation: DataSet = new_dataset(validation_images, validation_labels)
  val testset: DataSet = new_dataset(test_images, test_labels)
  return Datasets(train, validation, testset)
}

def main(): Any = {
  val train_images: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(0), BigInt(1)), ArrayBuffer(BigInt(1), BigInt(2)), ArrayBuffer(BigInt(2), BigInt(3)), ArrayBuffer(BigInt(3), BigInt(4)), ArrayBuffer(BigInt(4), BigInt(5)))
  val train_labels_raw: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(0), BigInt(1), BigInt(2), BigInt(3), BigInt(4))
  val test_images: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(5), BigInt(6)), ArrayBuffer(BigInt(6), BigInt(7)))
  val test_labels_raw: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(5), BigInt(6))
  val data: Datasets = read_data_sets(train_images, train_labels_raw, test_images, test_labels_raw, BigInt(2), BigInt(10))
  var ds: DataSet = data.asInstanceOf[Datasets].train
  var res: BatchResult = next_batch(ds, BigInt(2))
  ds = res.asInstanceOf[BatchResult].dataset
  println(_str(res.images))
  println(_str(res.labels))
  res = next_batch(ds, BigInt(2))
  ds = res.asInstanceOf[BatchResult].dataset
  println(_str(res.images))
  println(_str(res.labels))
  res = next_batch(ds, BigInt(2))
  ds = res.asInstanceOf[BatchResult].dataset
  println(_str(res.images))
  println(_str(res.labels))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
