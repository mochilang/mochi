// Generated by Mochi v0.10.69 on 2025-08-22 13:17:13 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case m: scala.collection.Map[_, _] => scala.collection.immutable.ListMap(m.toSeq.sortBy(_._1.toString): _*).toString.replace("ListMap", "Map")
  case d: Double => { val i = d.toLong; if (d == i.toDouble) java.lang.Long.toString(i) else java.lang.Double.toString(d) }
  case other => String.valueOf(other)
}

case class Layer(var units: BigInt, var weight: ArrayBuffer[ArrayBuffer[Double]], var bias: ArrayBuffer[Double], var output: ArrayBuffer[Double], var xdata: ArrayBuffer[Double], var learn_rate: Double)

case class Data(var x: ArrayBuffer[ArrayBuffer[Double]], var y: ArrayBuffer[ArrayBuffer[Double]])

def rand(): BigInt = {
  seed = (seed * BigInt(1103515245) + BigInt(12345)) % BigInt("2147483648")
  return seed
}

def random(): Double = {
  return 1.0 * (rand()).toString.toDouble / 2.147483648e+09
}

def expApprox(x: Double): Double = {
  var y: Double = x
  var is_neg: Boolean = false
  if (x < 0.0) {
    is_neg = true
    y = -x
  }
  var term: Double = 1.0
  var sum: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n < BigInt(30)) {
    term = term * y / n.toString.toDouble
    sum = sum + term
    n = n + BigInt(1)
  }
  if (is_neg) {
    return 1.0 / sum
  }
  return sum
}

def sigmoid(z: Double): Double = {
  return 1.0 / (1.0 + expApprox(-z))
}

def sigmoid_vec(v: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    res = (res :+ (sigmoid(v.lift((i.toInt).toInt).getOrElse(0.0))))
    i = i + BigInt(1)
  }
  return res
}

def sigmoid_derivative(out: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((out).size)) {
    var `val`: Double = out.lift((i.toInt).toInt).getOrElse(0.0)
    res = (res :+ (`val` * (1.0 - `val`)))
    i = i + BigInt(1)
  }
  return res
}

def random_vector(n: BigInt): ArrayBuffer[Double] = {
  var v: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    v = (v :+ (random() - 0.5))
    i = i + BigInt(1)
  }
  return v
}

def random_matrix(r: BigInt, c: BigInt): ArrayBuffer[ArrayBuffer[Double]] = {
  var m: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < r) {
    m = (m :+ (random_vector(c)))
    i = i + BigInt(1)
  }
  return m
}

def matvec(mat: ArrayBuffer[ArrayBuffer[Double]], vec: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((mat).size)) {
    var s: Double = 0.0
    var j: BigInt = BigInt(0)
    while (j < BigInt((vec).size)) {
      s = s + mat.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0) * vec.lift((j.toInt).toInt).getOrElse(0.0)
      j = j + BigInt(1)
    }
    res = (res :+ (s))
    i = i + BigInt(1)
  }
  return res
}

def matTvec(mat: ArrayBuffer[ArrayBuffer[Double]], vec: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var cols: BigInt = BigInt((mat.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var j: BigInt = BigInt(0)
  while (j < cols) {
    var s: Double = 0.0
    var i: BigInt = BigInt(0)
    while (i < BigInt((mat).size)) {
      s = s + mat.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0) * vec.lift((i.toInt).toInt).getOrElse(0.0)
      i = i + BigInt(1)
    }
    res = (res :+ (s))
    j = j + BigInt(1)
  }
  return res
}

def vec_sub(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = (res :+ (a.lift((i.toInt).toInt).getOrElse(0.0) - b.lift((i.toInt).toInt).getOrElse(0.0)))
    i = i + BigInt(1)
  }
  return res
}

def vec_mul(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = (res :+ (a.lift((i.toInt).toInt).getOrElse(0.0) * b.lift((i.toInt).toInt).getOrElse(0.0)))
    i = i + BigInt(1)
  }
  return res
}

def vec_scalar_mul(v: ArrayBuffer[Double], s: Double): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    res = (res :+ (v.lift((i.toInt).toInt).getOrElse(0.0) * s))
    i = i + BigInt(1)
  }
  return res
}

def outer(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[ArrayBuffer[Double]] = {
  var res: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((b).size)) {
      row = (row :+ (a.lift((i.toInt).toInt).getOrElse(0.0) * b.lift((j.toInt).toInt).getOrElse(0.0)))
      j = j + BigInt(1)
    }
    res = (res :+ (row))
    i = i + BigInt(1)
  }
  return res
}

def mat_scalar_mul(mat: ArrayBuffer[ArrayBuffer[Double]], s: Double): ArrayBuffer[ArrayBuffer[Double]] = {
  var res: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((mat).size)) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((mat.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
      row = (row :+ (mat.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0) * s))
      j = j + BigInt(1)
    }
    res = (res :+ (row))
    i = i + BigInt(1)
  }
  return res
}

def mat_sub(a: ArrayBuffer[ArrayBuffer[Double]], b: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[ArrayBuffer[Double]] = {
  var res: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((a.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
      row = (row :+ (a.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0) - b.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0)))
      j = j + BigInt(1)
    }
    res = (res :+ (row))
    i = i + BigInt(1)
  }
  return res
}

def init_layer(units: BigInt, back_units: BigInt, lr: Double): Layer = {
  return Layer(units, random_matrix(units, back_units), random_vector(units), ArrayBuffer(), ArrayBuffer(), lr)
}

def forward(layers: ArrayBuffer[Layer], x: ArrayBuffer[Double]): ArrayBuffer[Layer] = {
  var data: ArrayBuffer[Double] = x
  var i: BigInt = BigInt(0)
  while (i < BigInt((layers).size)) {
    var layer: Layer = layers.lift((i.toInt).toInt).getOrElse(null)
    layer.asInstanceOf[Layer].xdata = data
    if (i == BigInt(0)) {
      layer.asInstanceOf[Layer].output = data
    } else {
      var z: ArrayBuffer[Double] = vec_sub(matvec(layer.asInstanceOf[Layer].weight, data), layer.asInstanceOf[Layer].bias)
      layer.asInstanceOf[Layer].output = sigmoid_vec(z)
      data = layer.asInstanceOf[Layer].output
    }
    layers((i).toInt) = layer
    i = i + BigInt(1)
  }
  return layers
}

def backward(layers: ArrayBuffer[Layer], grad: ArrayBuffer[Double]): ArrayBuffer[Layer] = {
  var g: ArrayBuffer[Double] = grad
  var i: BigInt = BigInt((layers).size) - BigInt(1)
  while (i > BigInt(0)) {
    var layer: Layer = layers.lift((i.toInt).toInt).getOrElse(null)
    var deriv: ArrayBuffer[Double] = sigmoid_derivative(layer.asInstanceOf[Layer].output)
    var delta: ArrayBuffer[Double] = vec_mul(g, deriv)
    var grad_w: ArrayBuffer[ArrayBuffer[Double]] = outer(delta, layer.asInstanceOf[Layer].xdata)
    layer.asInstanceOf[Layer].weight = mat_sub(layer.asInstanceOf[Layer].weight, mat_scalar_mul(grad_w, layer.asInstanceOf[Layer].learn_rate))
    layer.asInstanceOf[Layer].bias = vec_sub(layer.asInstanceOf[Layer].bias, vec_scalar_mul(delta, layer.asInstanceOf[Layer].learn_rate))
    g = matTvec(layer.asInstanceOf[Layer].weight, delta)
    layers((i).toInt) = layer
    i = i - BigInt(1)
  }
  return layers
}

def calc_loss(y: ArrayBuffer[Double], yhat: ArrayBuffer[Double]): Double = {
  var s: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((y).size)) {
    var d: Double = y.lift((i.toInt).toInt).getOrElse(0.0) - yhat.lift((i.toInt).toInt).getOrElse(0.0)
    s = s + d * d
    i = i + BigInt(1)
  }
  return s
}

def calc_gradient(y: ArrayBuffer[Double], yhat: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var g: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((y).size)) {
    g = (g :+ (2.0 * (yhat.lift((i.toInt).toInt).getOrElse(0.0) - y.lift((i.toInt).toInt).getOrElse(0.0))))
    i = i + BigInt(1)
  }
  return g
}

def train(_layers: ArrayBuffer[Layer], xdata: ArrayBuffer[ArrayBuffer[Double]], ydata: ArrayBuffer[ArrayBuffer[Double]], rounds: BigInt, acc: Double): Double = {
  var layers: ArrayBuffer[Layer] = _layers
  var r: BigInt = BigInt(0)
  while (r < rounds) {
    var i: BigInt = BigInt(0)
    while (i < BigInt((xdata).size)) {
      layers = forward(layers, xdata.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()))
      var out: ArrayBuffer[Double] = layers.lift(((BigInt((layers).size) - BigInt(1)).toInt).toInt).getOrElse(null).output
      var grad: ArrayBuffer[Double] = calc_gradient(ydata.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()), out)
      layers = backward(layers, grad)
      i = i + BigInt(1)
    }
    r = r + BigInt(1)
  }
  return 0.0
}

def create_data(): Data = {
  var x: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt(10)) {
    x = (x :+ (random_vector(BigInt(10))))
    i = i + BigInt(1)
  }
  var y: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.8, 0.4), ArrayBuffer(0.4, 0.3), ArrayBuffer(0.34, 0.45), ArrayBuffer(0.67, 0.32), ArrayBuffer(0.88, 0.67), ArrayBuffer(0.78, 0.77), ArrayBuffer(0.55, 0.66), ArrayBuffer(0.55, 0.43), ArrayBuffer(0.54, 0.1), ArrayBuffer(0.1, 0.5))
  return Data(x, y)
}

def main(): Any = {
  var data: Data = create_data()
  var x: ArrayBuffer[ArrayBuffer[Double]] = data.asInstanceOf[Data].x
  var y: ArrayBuffer[ArrayBuffer[Double]] = data.asInstanceOf[Data].y
  var layers: ArrayBuffer[Layer] = ArrayBuffer[Layer]()
  layers = (layers :+ (init_layer(BigInt(10), BigInt(0), 0.3)))
  layers = (layers :+ (init_layer(BigInt(20), BigInt(10), 0.3)))
  layers = (layers :+ (init_layer(BigInt(30), BigInt(20), 0.3)))
  layers = (layers :+ (init_layer(BigInt(2), BigInt(30), 0.3)))
  var final_mse: Double = train(layers, x, y, BigInt(100), 0.01)
  println(_str(final_mse))
}

var seed: BigInt = BigInt(1)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
