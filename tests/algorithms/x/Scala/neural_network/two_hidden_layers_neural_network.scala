// Generated by Mochi v0.10.64 on 2025-08-12 09:35:15 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class Network(var w1: ArrayBuffer[ArrayBuffer[Double]], var w2: ArrayBuffer[ArrayBuffer[Double]], var w3: ArrayBuffer[ArrayBuffer[Double]])

def exp_approx(x: Double): Double = {
  var sum: Double = 1.0
  var term: Double = 1.0
  var i: BigInt = BigInt(1)
  while (i < BigInt(10)) {
    term = term * x / (i.toString()).toDouble
    sum = sum + term
    i = i + BigInt(1)
  }
  return sum
}

def sigmoid(x: Double): Double = {
  return 1.0 / (1.0 + exp_approx(-x))
}

def sigmoid_derivative(x: Double): Double = {
  return x * (1.0 - x)
}

def new_network(): Network = {
  return Network(ArrayBuffer(ArrayBuffer(0.1, 0.2, 0.3, 0.4), ArrayBuffer(0.5, 0.6, 0.7, 0.8), ArrayBuffer(0.9, 1.0, 1.1, 1.2)), ArrayBuffer(ArrayBuffer(0.1, 0.2, 0.3), ArrayBuffer(0.4, 0.5, 0.6), ArrayBuffer(0.7, 0.8, 0.9), ArrayBuffer(1.0, 1.1, 1.2)), ArrayBuffer(ArrayBuffer(0.1), ArrayBuffer(0.2), ArrayBuffer(0.3)))
}

def feedforward(net: Network, input: ArrayBuffer[Double]): Double = {
  var hidden1: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var j: BigInt = BigInt(0)
  while (j < BigInt(4)) {
    var sum1: Double = 0.0
    var i: BigInt = BigInt(0)
    while (i < BigInt(3)) {
      sum1 = sum1 + input.lift((i.toInt).toInt).getOrElse(0.0) * net.asInstanceOf[Network].w1.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0)
      i = i + BigInt(1)
    }
    hidden1 = hidden1 :+ (sigmoid(sum1))
    j = j + BigInt(1)
  }
  var hidden2: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var k: BigInt = BigInt(0)
  while (k < BigInt(3)) {
    var sum2: Double = 0.0
    var j2: BigInt = BigInt(0)
    while (j2 < BigInt(4)) {
      sum2 = sum2 + hidden1.lift((j2.toInt).toInt).getOrElse(0.0) * net.asInstanceOf[Network].w2.lift((j2.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((k.toInt).toInt).getOrElse(0.0)
      j2 = j2 + BigInt(1)
    }
    hidden2 = hidden2 :+ (sigmoid(sum2))
    k = k + BigInt(1)
  }
  var sum3: Double = 0.0
  var k2: BigInt = BigInt(0)
  while (k2 < BigInt(3)) {
    sum3 = sum3 + hidden2.lift((k2.toInt).toInt).getOrElse(0.0) * net.asInstanceOf[Network].w3.lift((k2.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((BigInt(0).toInt).toInt).getOrElse(0.0)
    k2 = k2 + BigInt(1)
  }
  val out: Double = sigmoid(sum3)
  return out
}

def train(net: Network, inputs: ArrayBuffer[ArrayBuffer[Double]], outputs: ArrayBuffer[Double], iterations: BigInt): Any = {
  var iter: BigInt = BigInt(0)
  while (iter < iterations) {
    var s: BigInt = BigInt(0)
    while (s < BigInt((inputs).size)) {
      val inp: ArrayBuffer[Double] = inputs.lift((s.toInt).toInt).getOrElse(ArrayBuffer[Double]())
      val target: Double = outputs.lift((s.toInt).toInt).getOrElse(0.0)
      var hidden1: ArrayBuffer[Double] = ArrayBuffer[Double]()
      var j: BigInt = BigInt(0)
      while (j < BigInt(4)) {
        var sum1: Double = 0.0
        var i: BigInt = BigInt(0)
        while (i < BigInt(3)) {
          sum1 = sum1 + inp.lift((i.toInt).toInt).getOrElse(0.0) * net.asInstanceOf[Network].w1.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0)
          i = i + BigInt(1)
        }
        hidden1 = hidden1 :+ (sigmoid(sum1))
        j = j + BigInt(1)
      }
      var hidden2: ArrayBuffer[Double] = ArrayBuffer[Double]()
      var k: BigInt = BigInt(0)
      while (k < BigInt(3)) {
        var sum2: Double = 0.0
        var j2: BigInt = BigInt(0)
        while (j2 < BigInt(4)) {
          sum2 = sum2 + hidden1.lift((j2.toInt).toInt).getOrElse(0.0) * net.asInstanceOf[Network].w2.lift((j2.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((k.toInt).toInt).getOrElse(0.0)
          j2 = j2 + BigInt(1)
        }
        hidden2 = hidden2 :+ (sigmoid(sum2))
        k = k + BigInt(1)
      }
      var sum3: Double = 0.0
      var k3: BigInt = BigInt(0)
      while (k3 < BigInt(3)) {
        sum3 = sum3 + hidden2.lift((k3.toInt).toInt).getOrElse(0.0) * net.asInstanceOf[Network].w3.lift((k3.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((BigInt(0).toInt).toInt).getOrElse(0.0)
        k3 = k3 + BigInt(1)
      }
      val output: Double = sigmoid(sum3)
      val error: Double = target - output
      val delta_output: Double = error * sigmoid_derivative(output)
      var new_w3: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
      var k4: BigInt = BigInt(0)
      while (k4 < BigInt(3)) {
        var w3row: ArrayBuffer[Double] = net.asInstanceOf[Network].w3.lift((k4.toInt).toInt).getOrElse(ArrayBuffer[Double]())
        w3row((BigInt(0)).toInt) = w3row.lift((BigInt(0).toInt).toInt).getOrElse(0.0) + hidden2.lift((k4.toInt).toInt).getOrElse(0.0) * delta_output
        new_w3 = new_w3 :+ (w3row)
        k4 = k4 + BigInt(1)
      }
      net.asInstanceOf[Network].w3 = new_w3
      var delta_hidden2: ArrayBuffer[Double] = ArrayBuffer[Double]()
      var k5: BigInt = BigInt(0)
      while (k5 < BigInt(3)) {
        val row: ArrayBuffer[Double] = net.asInstanceOf[Network].w3.lift((k5.toInt).toInt).getOrElse(ArrayBuffer[Double]())
        val dh2: Double = row.lift((BigInt(0).toInt).toInt).getOrElse(0.0) * delta_output * sigmoid_derivative(hidden2.lift((k5.toInt).toInt).getOrElse(0.0))
        delta_hidden2 = delta_hidden2 :+ (dh2)
        k5 = k5 + BigInt(1)
      }
      var new_w2: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
      j = BigInt(0)
      while (j < BigInt(4)) {
        var w2row: ArrayBuffer[Double] = net.asInstanceOf[Network].w2.lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]())
        var k6: BigInt = BigInt(0)
        while (k6 < BigInt(3)) {
          w2row((k6).toInt) = w2row.lift((k6.toInt).toInt).getOrElse(0.0) + hidden1.lift((j.toInt).toInt).getOrElse(0.0) * delta_hidden2.lift((k6.toInt).toInt).getOrElse(0.0)
          k6 = k6 + BigInt(1)
        }
        new_w2 = new_w2 :+ (w2row)
        j = j + BigInt(1)
      }
      net.asInstanceOf[Network].w2 = new_w2
      var delta_hidden1: ArrayBuffer[Double] = ArrayBuffer[Double]()
      j = BigInt(0)
      while (j < BigInt(4)) {
        var sumdh: Double = 0.0
        var k7: BigInt = BigInt(0)
        while (k7 < BigInt(3)) {
          val row2: ArrayBuffer[Double] = net.asInstanceOf[Network].w2.lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]())
          sumdh = sumdh + row2.lift((k7.toInt).toInt).getOrElse(0.0) * delta_hidden2.lift((k7.toInt).toInt).getOrElse(0.0)
          k7 = k7 + BigInt(1)
        }
        delta_hidden1 = delta_hidden1 :+ (sumdh * sigmoid_derivative(hidden1.lift((j.toInt).toInt).getOrElse(0.0)))
        j = j + BigInt(1)
      }
      var new_w1: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
      var i2: BigInt = BigInt(0)
      while (i2 < BigInt(3)) {
        var w1row: ArrayBuffer[Double] = net.asInstanceOf[Network].w1.lift((i2.toInt).toInt).getOrElse(ArrayBuffer[Double]())
        j = BigInt(0)
        while (j < BigInt(4)) {
          w1row((j).toInt) = w1row.lift((j.toInt).toInt).getOrElse(0.0) + inp.lift((i2.toInt).toInt).getOrElse(0.0) * delta_hidden1.lift((j.toInt).toInt).getOrElse(0.0)
          j = j + BigInt(1)
        }
        new_w1 = new_w1 :+ (w1row)
        i2 = i2 + BigInt(1)
      }
      net.asInstanceOf[Network].w1 = new_w1
      s = s + BigInt(1)
    }
    iter = iter + BigInt(1)
  }
}

def predict(net: Network, input: ArrayBuffer[Double]): BigInt = {
  val out: Double = feedforward(net, input)
  if (out > 0.6) {
    return BigInt(1)
  }
  return BigInt(0)
}

def example(): BigInt = {
  val inputs: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.0, 0.0, 0.0), ArrayBuffer(0.0, 0.0, 1.0), ArrayBuffer(0.0, 1.0, 0.0), ArrayBuffer(0.0, 1.0, 1.0), ArrayBuffer(1.0, 0.0, 0.0), ArrayBuffer(1.0, 0.0, 1.0), ArrayBuffer(1.0, 1.0, 0.0), ArrayBuffer(1.0, 1.0, 1.0))
  val outputs: ArrayBuffer[Double] = ArrayBuffer(0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0)
  var net: Network = new_network()
  train(net, inputs, outputs, BigInt(10))
  val result: BigInt = predict(net, ArrayBuffer(1.0, 1.0, 1.0))
  println(_str(result))
  return result
}

def main(): Any = {
  example()
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
