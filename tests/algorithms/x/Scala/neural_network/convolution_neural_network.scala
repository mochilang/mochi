// Generated by Mochi v0.10.64 on 2025-08-12 13:53:48 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class CNN(var conv_kernels: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]], var conv_bias: ArrayBuffer[Double], var conv_step: BigInt, var pool_size: BigInt, var w_hidden: ArrayBuffer[ArrayBuffer[Double]], var w_out: ArrayBuffer[ArrayBuffer[Double]], var b_hidden: ArrayBuffer[Double], var b_out: ArrayBuffer[Double], var rate_weight: Double, var rate_bias: Double)

case class TrainSample(var image: ArrayBuffer[ArrayBuffer[Double]], var target: ArrayBuffer[Double])

def random(): Double = {
  seed = (seed * BigInt(13) + BigInt(7)) % BigInt(100)
  return seed.toDouble / 100.0
}

def sigmoid(x: Double): Double = {
  return 1.0 / (1.0 + exp(-x))
}

def to_float(x: BigInt): Double = {
  return x.toString.toDouble * 1.0
}

def exp(x: Double): Double = {
  var term: Double = 1.0
  var sum: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n < BigInt(20)) {
    term = term * x / (n.toString()).toDouble
    sum = sum + term
    n = n + BigInt(1)
  }
  return sum
}

def convolve(data: ArrayBuffer[ArrayBuffer[Double]], kernel: ArrayBuffer[ArrayBuffer[Double]], step: BigInt, bias: Double): ArrayBuffer[ArrayBuffer[Double]] = {
  val size_data: BigInt = BigInt((data).size)
  val size_kernel: BigInt = BigInt((kernel).size)
  var out: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i <= size_data - size_kernel) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j <= size_data - size_kernel) {
      var sum: Double = 0.0
      var a: BigInt = BigInt(0)
      while (a < size_kernel) {
        var b: BigInt = BigInt(0)
        while (b < size_kernel) {
          sum = sum + data.lift(((i + a).toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift(((j + b).toInt).toInt).getOrElse(0.0) * kernel.lift((a.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((b.toInt).toInt).getOrElse(0.0)
          b = b + BigInt(1)
        }
        a = a + BigInt(1)
      }
      row = row :+ (sigmoid(sum - bias))
      j = j + step
    }
    out = out :+ (row)
    i = i + step
  }
  return out
}

def average_pool(map: ArrayBuffer[ArrayBuffer[Double]], size: BigInt): ArrayBuffer[ArrayBuffer[Double]] = {
  var out: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((map).size)) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((map.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
      var sum: Double = 0.0
      var a: BigInt = BigInt(0)
      while (a < size) {
        var b: BigInt = BigInt(0)
        while (b < size) {
          sum = sum + map.lift(((i + a).toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift(((j + b).toInt).toInt).getOrElse(0.0)
          b = b + BigInt(1)
        }
        a = a + BigInt(1)
      }
      row = row :+ (sum / (size * size).toString.toDouble)
      j = j + size
    }
    out = out :+ (row)
    i = i + size
  }
  return out
}

def flatten(maps: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]]): ArrayBuffer[Double] = {
  var out: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((maps).size)) {
    var j: BigInt = BigInt(0)
    while (j < BigInt((maps.lift((i.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Double]]())).size)) {
      var k: BigInt = BigInt(0)
      while (k < BigInt((maps.lift((i.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Double]]()).lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
        out = out :+ (maps.lift((i.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Double]]()).lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((k.toInt).toInt).getOrElse(0.0))
        k = k + BigInt(1)
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return out
}

def vec_mul_mat(v: ArrayBuffer[Double], m: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[Double] = {
  var cols: BigInt = BigInt((m.lift((BigInt(0).toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var j: BigInt = BigInt(0)
  while (j < cols) {
    var sum: Double = 0.0
    var i: BigInt = BigInt(0)
    while (i < BigInt((v).size)) {
      sum = sum + v.lift((i.toInt).toInt).getOrElse(0.0) * m.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0)
      i = i + BigInt(1)
    }
    res = res :+ (sum)
    j = j + BigInt(1)
  }
  return res
}

def matT_vec_mul(m: ArrayBuffer[ArrayBuffer[Double]], v: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((m).size)) {
    var sum: Double = 0.0
    var j: BigInt = BigInt(0)
    while (j < BigInt((m.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
      sum = sum + m.lift((i.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j.toInt).toInt).getOrElse(0.0) * v.lift((j.toInt).toInt).getOrElse(0.0)
      j = j + BigInt(1)
    }
    res = res :+ (sum)
    i = i + BigInt(1)
  }
  return res
}

def vec_add(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = res :+ (a.lift((i.toInt).toInt).getOrElse(0.0) + b.lift((i.toInt).toInt).getOrElse(0.0))
    i = i + BigInt(1)
  }
  return res
}

def vec_sub(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = res :+ (a.lift((i.toInt).toInt).getOrElse(0.0) - b.lift((i.toInt).toInt).getOrElse(0.0))
    i = i + BigInt(1)
  }
  return res
}

def vec_mul(a: ArrayBuffer[Double], b: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = res :+ (a.lift((i.toInt).toInt).getOrElse(0.0) * b.lift((i.toInt).toInt).getOrElse(0.0))
    i = i + BigInt(1)
  }
  return res
}

def vec_map_sig(v: ArrayBuffer[Double]): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    res = res :+ (sigmoid(v.lift((i.toInt).toInt).getOrElse(0.0)))
    i = i + BigInt(1)
  }
  return res
}

def new_cnn(): CNN = {
  val k1: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(1.0, 0.0), ArrayBuffer(0.0, 1.0))
  val k2: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(0.0, 1.0), ArrayBuffer(1.0, 0.0))
  val conv_kernels: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]] = ArrayBuffer(k1, k2)
  val conv_bias: ArrayBuffer[Double] = ArrayBuffer(0.0, 0.0)
  val conv_step: BigInt = BigInt(2)
  val pool_size: BigInt = BigInt(2)
  val input_size: BigInt = BigInt(2)
  val hidden_size: BigInt = BigInt(2)
  val output_size: BigInt = BigInt(2)
  var w_hidden: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  var i: BigInt = BigInt(0)
  while (i < input_size) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < hidden_size) {
      row = row :+ (random() - 0.5)
      j = j + BigInt(1)
    }
    w_hidden = w_hidden :+ (row)
    i = i + BigInt(1)
  }
  var w_out: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer[ArrayBuffer[Double]]()
  i = BigInt(0)
  while (i < hidden_size) {
    var row: ArrayBuffer[Double] = ArrayBuffer[Double]()
    var j: BigInt = BigInt(0)
    while (j < output_size) {
      row = row :+ (random() - 0.5)
      j = j + BigInt(1)
    }
    w_out = w_out :+ (row)
    i = i + BigInt(1)
  }
  val b_hidden: ArrayBuffer[Double] = ArrayBuffer(0.0, 0.0)
  val b_out: ArrayBuffer[Double] = ArrayBuffer(0.0, 0.0)
  return CNN(conv_kernels, conv_bias, conv_step, pool_size, w_hidden, w_out, b_hidden, b_out, 0.2, 0.2)
}

def forward(cnn: CNN, data: ArrayBuffer[ArrayBuffer[Double]]): ArrayBuffer[Double] = {
  var maps: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]] = ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((cnn.asInstanceOf[CNN].conv_kernels).size)) {
    val conv_map: ArrayBuffer[ArrayBuffer[Double]] = convolve(data, cnn.asInstanceOf[CNN].conv_kernels.lift((i.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Double]]()), cnn.asInstanceOf[CNN].conv_step, cnn.asInstanceOf[CNN].conv_bias.lift((i.toInt).toInt).getOrElse(0.0))
    val pooled: ArrayBuffer[ArrayBuffer[Double]] = average_pool(conv_map, cnn.asInstanceOf[CNN].pool_size)
    maps = maps :+ (pooled)
    i = i + BigInt(1)
  }
  val flat: ArrayBuffer[Double] = flatten(maps)
  val hidden_net: ArrayBuffer[Double] = vec_add(vec_mul_mat(flat, cnn.asInstanceOf[CNN].w_hidden), cnn.asInstanceOf[CNN].b_hidden)
  val hidden_out: ArrayBuffer[Double] = vec_map_sig(hidden_net)
  val out_net: ArrayBuffer[Double] = vec_add(vec_mul_mat(hidden_out, cnn.asInstanceOf[CNN].w_out), cnn.asInstanceOf[CNN].b_out)
  val out: ArrayBuffer[Double] = vec_map_sig(out_net)
  return out
}

def train(cnn: CNN, samples: ArrayBuffer[TrainSample], epochs: BigInt): CNN = {
  var w_out: ArrayBuffer[ArrayBuffer[Double]] = cnn.asInstanceOf[CNN].w_out
  var b_out: ArrayBuffer[Double] = cnn.asInstanceOf[CNN].b_out
  var w_hidden: ArrayBuffer[ArrayBuffer[Double]] = cnn.asInstanceOf[CNN].w_hidden
  var b_hidden: ArrayBuffer[Double] = cnn.asInstanceOf[CNN].b_hidden
  var e: BigInt = BigInt(0)
  while (e < epochs) {
    var s: BigInt = BigInt(0)
    while (s < BigInt((samples).size)) {
      val data: ArrayBuffer[ArrayBuffer[Double]] = samples.lift((s.toInt).toInt).getOrElse(null).image
      val target: ArrayBuffer[Double] = samples.lift((s.toInt).toInt).getOrElse(null).target
      var maps: ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]] = ArrayBuffer[ArrayBuffer[ArrayBuffer[Double]]]()
      var i: BigInt = BigInt(0)
      while (i < BigInt((cnn.asInstanceOf[CNN].conv_kernels).size)) {
        val conv_map: ArrayBuffer[ArrayBuffer[Double]] = convolve(data, cnn.asInstanceOf[CNN].conv_kernels.lift((i.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Double]]()), cnn.asInstanceOf[CNN].conv_step, cnn.asInstanceOf[CNN].conv_bias.lift((i.toInt).toInt).getOrElse(0.0))
        val pooled: ArrayBuffer[ArrayBuffer[Double]] = average_pool(conv_map, cnn.asInstanceOf[CNN].pool_size)
        maps = maps :+ (pooled)
        i = i + BigInt(1)
      }
      val flat: ArrayBuffer[Double] = flatten(maps)
      val hidden_net: ArrayBuffer[Double] = vec_add(vec_mul_mat(flat, w_hidden), b_hidden)
      val hidden_out: ArrayBuffer[Double] = vec_map_sig(hidden_net)
      val out_net: ArrayBuffer[Double] = vec_add(vec_mul_mat(hidden_out, w_out), b_out)
      val out: ArrayBuffer[Double] = vec_map_sig(out_net)
      val error_out: ArrayBuffer[Double] = vec_sub(target, out)
      val pd_out: ArrayBuffer[Double] = vec_mul(error_out, vec_mul(out, vec_sub(ArrayBuffer(1.0, 1.0), out)))
      val error_hidden: ArrayBuffer[Double] = matT_vec_mul(w_out, pd_out)
      val pd_hidden: ArrayBuffer[Double] = vec_mul(error_hidden, vec_mul(hidden_out, vec_sub(ArrayBuffer(1.0, 1.0), hidden_out)))
      var j: BigInt = BigInt(0)
      while (j < BigInt((w_out).size)) {
        var k: BigInt = BigInt(0)
        while (k < BigInt((w_out.lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
          w_out((j).toInt)((k).toInt) = w_out.lift((j.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((k.toInt).toInt).getOrElse(0.0) + cnn.asInstanceOf[CNN].rate_weight * hidden_out.lift((j.toInt).toInt).getOrElse(0.0) * pd_out.lift((k.toInt).toInt).getOrElse(0.0)
          k = k + BigInt(1)
        }
        j = j + BigInt(1)
      }
      j = BigInt(0)
      while (j < BigInt((b_out).size)) {
        b_out((j).toInt) = b_out.lift((j.toInt).toInt).getOrElse(0.0) - cnn.asInstanceOf[CNN].rate_bias * pd_out.lift((j.toInt).toInt).getOrElse(0.0)
        j = j + BigInt(1)
      }
      var i_h: BigInt = BigInt(0)
      while (i_h < BigInt((w_hidden).size)) {
        var j_h: BigInt = BigInt(0)
        while (j_h < BigInt((w_hidden.lift((i_h.toInt).toInt).getOrElse(ArrayBuffer[Double]())).size)) {
          w_hidden((i_h).toInt)((j_h).toInt) = w_hidden.lift((i_h.toInt).toInt).getOrElse(ArrayBuffer[Double]()).lift((j_h.toInt).toInt).getOrElse(0.0) + cnn.asInstanceOf[CNN].rate_weight * flat.lift((i_h.toInt).toInt).getOrElse(0.0) * pd_hidden.lift((j_h.toInt).toInt).getOrElse(0.0)
          j_h = j_h + BigInt(1)
        }
        i_h = i_h + BigInt(1)
      }
      j = BigInt(0)
      while (j < BigInt((b_hidden).size)) {
        b_hidden((j).toInt) = b_hidden.lift((j.toInt).toInt).getOrElse(0.0) - cnn.asInstanceOf[CNN].rate_bias * pd_hidden.lift((j.toInt).toInt).getOrElse(0.0)
        j = j + BigInt(1)
      }
      s = s + BigInt(1)
    }
    e = e + BigInt(1)
  }
  return CNN(cnn.asInstanceOf[CNN].conv_kernels, cnn.asInstanceOf[CNN].conv_bias, cnn.asInstanceOf[CNN].conv_step, cnn.asInstanceOf[CNN].pool_size, w_hidden, w_out, b_hidden, b_out, cnn.asInstanceOf[CNN].rate_weight, cnn.asInstanceOf[CNN].rate_bias)
}

def main(): Any = {
  val cnn: CNN = new_cnn()
  val image: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer(ArrayBuffer(1.0, 0.0, 1.0, 0.0), ArrayBuffer(0.0, 1.0, 0.0, 1.0), ArrayBuffer(1.0, 0.0, 1.0, 0.0), ArrayBuffer(0.0, 1.0, 0.0, 1.0))
  val sample: TrainSample = TrainSample(image, ArrayBuffer(1.0, 0.0))
  println((List("Before training:", forward(cnn, image))).mkString(" "))
  val trained: CNN = train(cnn, ArrayBuffer(sample), BigInt(50))
  println((List("After training:", forward(trained, image))).mkString(" "))
}

var seed: BigInt = BigInt(1)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
