// Generated by Mochi v0.10.64 on 2025-08-13 16:21:56 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Angle(var degrees: Double)

case class Side(var length: Double, var angle: Angle, var next: BigInt)

case class Ellipse(var major: Double, var minor: Double)

case class Circle(var radius: Double)

case class Polygon(var sides: ArrayBuffer[Side])

case class Rectangle(var short_side: Side, var long_side: Side, var poly: Polygon)

case class Square(var side: Side, var rect: Rectangle)

def make_angle(deg: Double): Angle = {
  if ((deg < 0.0 || deg > 360.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("degrees must be between 0 and 360"))
  }
  return Angle(deg)
}

def make_side(length: Double, angle: Angle): Side = {
  if (length <= 0.0) {
    throw new RuntimeException(String.valueOf("length must be positive"))
  }
  return Side(length, angle, -BigInt(1))
}

def ellipse_area(e: Ellipse): Double = {
  return PI * e.asInstanceOf[Ellipse].major * e.asInstanceOf[Ellipse].minor
}

def ellipse_perimeter(e: Ellipse): Double = {
  return PI * (e.asInstanceOf[Ellipse].major + e.asInstanceOf[Ellipse].minor)
}

def circle_area(c: Circle): Double = {
  val e: Ellipse = Ellipse(c.asInstanceOf[Circle].radius, c.asInstanceOf[Circle].radius)
  val area: Double = ellipse_area(e)
  return area
}

def circle_perimeter(c: Circle): Double = {
  val e: Ellipse = Ellipse(c.asInstanceOf[Circle].radius, c.asInstanceOf[Circle].radius)
  val per: Double = ellipse_perimeter(e)
  return per
}

def circle_diameter(c: Circle): Double = {
  return c.asInstanceOf[Circle].radius * 2.0
}

def circle_max_parts(num_cuts: Double): Double = {
  if (num_cuts < 0.0) {
    throw new RuntimeException(String.valueOf("num_cuts must be positive"))
  }
  return (num_cuts + 2.0 + num_cuts * num_cuts) * 0.5
}

def make_polygon(): Polygon = {
  var s: ArrayBuffer[Side] = ArrayBuffer[Side]()
  return Polygon(s)
}

def polygon_add_side(p: Polygon, s: Side): Any = {
  p.asInstanceOf[Polygon].sides = p.asInstanceOf[Polygon].sides += (s)
}

def polygon_get_side(p: Polygon, index: BigInt): Side = {
  return p.asInstanceOf[Polygon].sides.lift((index.toInt).toInt).getOrElse(null)
}

def polygon_set_side(p: Polygon, index: BigInt, s: Side): Any = {
  var tmp: ArrayBuffer[Side] = p.asInstanceOf[Polygon].sides
  tmp((index).toInt) = s
  p.asInstanceOf[Polygon].sides = tmp
}

def make_rectangle(short_len: Double, long_len: Double): Rectangle = {
  if ((short_len <= 0.0 || long_len <= 0.0).asInstanceOf[Boolean]) {
    throw new RuntimeException(String.valueOf("length must be positive"))
  }
  val short: Side = make_side(short_len, make_angle(90.0))
  val long: Side = make_side(long_len, make_angle(90.0))
  var p: Polygon = make_polygon()
  polygon_add_side(p, short)
  polygon_add_side(p, long)
  return Rectangle(short, long, p)
}

def rectangle_perimeter(r: Rectangle): Double = {
  return (r.asInstanceOf[Rectangle].short_side.asInstanceOf[Side].length + r.asInstanceOf[Rectangle].long_side.asInstanceOf[Side].length) * 2.0
}

def rectangle_area(r: Rectangle): Double = {
  return r.asInstanceOf[Rectangle].short_side.asInstanceOf[Side].length * r.asInstanceOf[Rectangle].long_side.asInstanceOf[Side].length
}

def make_square(side_len: Double): Square = {
  val rect: Rectangle = make_rectangle(side_len, side_len)
  return Square(rect.asInstanceOf[Rectangle].short_side, rect)
}

def square_perimeter(s: Square): Double = {
  val p: Double = rectangle_perimeter(s.asInstanceOf[Square].rect)
  return p
}

def square_area(s: Square): Double = {
  val a: Double = rectangle_area(s.asInstanceOf[Square].rect)
  return a
}

def main(): Any = {
  val a: Angle = make_angle(90.0)
  println(a.asInstanceOf[Angle].degrees)
  val s: Side = make_side(5.0, a)
  println(s.asInstanceOf[Side].length)
  val e: Ellipse = Ellipse(5.0, 10.0)
  println(ellipse_area(e))
  println(ellipse_perimeter(e))
  val c: Circle = Circle(5.0)
  println(circle_area(c))
  println(circle_perimeter(c))
  println(circle_diameter(c))
  println(circle_max_parts(7.0))
  val r: Rectangle = make_rectangle(5.0, 10.0)
  println(rectangle_perimeter(r))
  println(rectangle_area(r))
  val q: Square = make_square(5.0)
  println(square_perimeter(q))
  println(square_area(q))
}

val PI: Double = 3.141592653589793

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
