// Generated by Mochi v0.10.59 on 2025-08-06 22:55:16 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class DS(var parent: ArrayBuffer[BigInt], var rank: ArrayBuffer[BigInt])

case class FindResult(var ds: DS, var root: BigInt)

def make_set(ds: DS, x: BigInt): DS = {
  var p: ArrayBuffer[BigInt] = ds.parent
  var r: ArrayBuffer[BigInt] = ds.rank
  p((x).toInt) = x
  r((x).toInt) = 0
  return DS(p, r)
}

def find_set(ds: DS, x: BigInt): FindResult = {
  if (ds.parent((x.toInt).toInt) == x) {
    return FindResult(ds, x)
  }
  val res: FindResult = find_set(ds, ds.parent((x.toInt).toInt))
  var p: ArrayBuffer[BigInt] = res.ds.asInstanceOf[DS].parent
  p((x).toInt) = res.root
  return FindResult(DS(p, res.ds.asInstanceOf[DS].rank), res.root)
}

def union_set(ds: DS, x: BigInt, y: BigInt): DS = {
  val fx: FindResult = find_set(ds, x)
  val ds1: DS = fx.asInstanceOf[FindResult].ds
  val x_root: BigInt = fx.asInstanceOf[FindResult].root
  val fy: FindResult = find_set(ds1, y)
  val ds2: DS = fy.asInstanceOf[FindResult].ds
  val y_root: BigInt = fy.asInstanceOf[FindResult].root
  if (x_root == y_root) {
    return ds2
  }
  var p: ArrayBuffer[BigInt] = ds2.asInstanceOf[DS].parent
  var r: ArrayBuffer[BigInt] = ds2.asInstanceOf[DS].rank
  if (r((x_root.toInt).toInt) > r((y_root.toInt).toInt)) {
    p((y_root).toInt) = x_root
  } else {
    p((x_root).toInt) = y_root
    if (r((x_root.toInt).toInt) == r((y_root.toInt).toInt)) {
      r((y_root).toInt) = r((y_root.toInt).toInt) + 1
    }
  }
  return DS(p, r)
}

def same_python_set(a: BigInt, b: BigInt): Boolean = {
  if ((a < 3 && b < 3).asInstanceOf[Boolean]) {
    return true
  }
  if ((((a >= 3 && a < 6).asInstanceOf[Boolean] && b >= 3).asInstanceOf[Boolean] && b < 6).asInstanceOf[Boolean]) {
    return true
  }
  return false
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    var ds: DS = DS(ArrayBuffer(), ArrayBuffer())
    var i: BigInt = 0
    while (i < 6) {
      ds.parent = ds.parent :+ BigInt(0)
      ds.rank = ds.rank :+ BigInt(0)
      ds = make_set(ds, i)
      i = i + 1
    }
    ds = union_set(ds, 0, 1)
    ds = union_set(ds, 1, 2)
    ds = union_set(ds, 3, 4)
    ds = union_set(ds, 3, 5)
    i = 0
    while (i < 6) {
      var j: BigInt = 0
      while (j < 6) {
        val res_i: FindResult = find_set(ds, i)
        ds = res_i.ds
        val root_i: BigInt = res_i.root
        val res_j: FindResult = find_set(ds, j)
        ds = res_j.ds
        val root_j: BigInt = res_j.root
        val same: Boolean = same_python_set(i, j)
        val root_same: Boolean = root_i == root_j
        if (same) {
          if (!root_same) {
            throw new RuntimeException(String.valueOf("nodes should be in same set"))
          }
        } else {
          if (root_same) {
            throw new RuntimeException(String.valueOf("nodes should be in different sets"))
          }
        }
        j = j + 1
      }
      i = i + 1
    }
    i = 0
    while (i < 6) {
      val res: FindResult = find_set(ds, i)
      ds = res.ds
      println(String.valueOf(res.root))
      i = i + 1
    }
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
