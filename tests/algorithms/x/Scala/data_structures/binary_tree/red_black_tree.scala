// Generated by Mochi v0.10.59 on 2025-08-06 22:23:21 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class RBTree(var nodes: ArrayBuffer[ArrayBuffer[BigInt]], var root: BigInt)

def make_tree(): RBTree = {
  return RBTree(ArrayBuffer(), -1)
}

def rotate_left(t: RBTree, x: BigInt): RBTree = {
  var nodes: ArrayBuffer[ArrayBuffer[BigInt]] = t.asInstanceOf[RBTree].nodes
  val y: BigInt = nodes((x.toInt).toInt)((RIGHT.toInt).toInt)
  val yLeft: BigInt = nodes((y.toInt).toInt)((LEFT.toInt).toInt)
  nodes((x).toInt)((RIGHT).toInt) = yLeft
  if (yLeft != NEG_ONE) {
    nodes((yLeft).toInt)((PARENT).toInt) = x
  }
  val xParent: BigInt = nodes((x.toInt).toInt)((PARENT.toInt).toInt)
  nodes((y).toInt)((PARENT).toInt) = xParent
  if (xParent == NEG_ONE) {
    t.asInstanceOf[RBTree].root = y
  } else {
    if (x == nodes((xParent.toInt).toInt)((LEFT.toInt).toInt)) {
      nodes((xParent).toInt)((LEFT).toInt) = y
    } else {
      nodes((xParent).toInt)((RIGHT).toInt) = y
    }
  }
  nodes((y).toInt)((LEFT).toInt) = x
  nodes((x).toInt)((PARENT).toInt) = y
  t.asInstanceOf[RBTree].nodes = nodes
  return t
}

def rotate_right(t: RBTree, x: BigInt): RBTree = {
  var nodes: ArrayBuffer[ArrayBuffer[BigInt]] = t.asInstanceOf[RBTree].nodes
  val y: BigInt = nodes((x.toInt).toInt)((LEFT.toInt).toInt)
  val yRight: BigInt = nodes((y.toInt).toInt)((RIGHT.toInt).toInt)
  nodes((x).toInt)((LEFT).toInt) = yRight
  if (yRight != NEG_ONE) {
    nodes((yRight).toInt)((PARENT).toInt) = x
  }
  val xParent: BigInt = nodes((x.toInt).toInt)((PARENT.toInt).toInt)
  nodes((y).toInt)((PARENT).toInt) = xParent
  if (xParent == NEG_ONE) {
    t.asInstanceOf[RBTree].root = y
  } else {
    if (x == nodes((xParent.toInt).toInt)((RIGHT.toInt).toInt)) {
      nodes((xParent).toInt)((RIGHT).toInt) = y
    } else {
      nodes((xParent).toInt)((LEFT).toInt) = y
    }
  }
  nodes((y).toInt)((RIGHT).toInt) = x
  nodes((x).toInt)((PARENT).toInt) = y
  t.asInstanceOf[RBTree].nodes = nodes
  return t
}

def insert_fix(_t: RBTree, _z: BigInt): RBTree = {
  var t: RBTree = _t
  var z: BigInt = _z
  var nodes: ArrayBuffer[ArrayBuffer[BigInt]] = t.asInstanceOf[RBTree].nodes
  while (z != t.asInstanceOf[RBTree].root && nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((COLOR.toInt).toInt) == 1) {
    if (nodes((z.toInt).toInt)((PARENT.toInt).toInt) == nodes((nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((LEFT.toInt).toInt)) {
      val y: BigInt = nodes((nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((RIGHT.toInt).toInt)
      if ((y != NEG_ONE && nodes((y.toInt).toInt)((COLOR.toInt).toInt) == 1).asInstanceOf[Boolean]) {
        nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt)).toInt)((COLOR).toInt) = 0
        nodes((y).toInt)((COLOR).toInt) = 0
        val gp: BigInt = nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt)
        nodes((gp).toInt)((COLOR).toInt) = 1
        z = gp
      } else {
        if (z == nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((RIGHT.toInt).toInt)) {
          z = nodes((z.toInt).toInt)((PARENT.toInt).toInt)
          t.asInstanceOf[RBTree].nodes = nodes
          t = rotate_left(t, z)
          nodes = t.asInstanceOf[RBTree].nodes
        }
        nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt)).toInt)((COLOR).toInt) = 0
        val gp: BigInt = nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt)
        nodes((gp).toInt)((COLOR).toInt) = 1
        t.asInstanceOf[RBTree].nodes = nodes
        t = rotate_right(t, gp)
        nodes = t.asInstanceOf[RBTree].nodes
      }
    } else {
      val y: BigInt = nodes((nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((LEFT.toInt).toInt)
      if ((y != NEG_ONE && nodes((y.toInt).toInt)((COLOR.toInt).toInt) == 1).asInstanceOf[Boolean]) {
        nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt)).toInt)((COLOR).toInt) = 0
        nodes((y).toInt)((COLOR).toInt) = 0
        val gp: BigInt = nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt)
        nodes((gp).toInt)((COLOR).toInt) = 1
        z = gp
      } else {
        if (z == nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((LEFT.toInt).toInt)) {
          z = nodes((z.toInt).toInt)((PARENT.toInt).toInt)
          t.asInstanceOf[RBTree].nodes = nodes
          t = rotate_right(t, z)
          nodes = t.asInstanceOf[RBTree].nodes
        }
        nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt)).toInt)((COLOR).toInt) = 0
        val gp: BigInt = nodes((nodes((z.toInt).toInt)((PARENT.toInt).toInt).toInt).toInt)((PARENT.toInt).toInt)
        nodes((gp).toInt)((COLOR).toInt) = 1
        t.asInstanceOf[RBTree].nodes = nodes
        t = rotate_left(t, gp)
        nodes = t.asInstanceOf[RBTree].nodes
      }
    }
  }
  nodes = t.asInstanceOf[RBTree].nodes
  nodes((t.asInstanceOf[RBTree].root).toInt)((COLOR).toInt) = 0
  t.asInstanceOf[RBTree].nodes = nodes
  return t
}

def tree_insert(_t: RBTree, v: BigInt): RBTree = {
  var t: RBTree = _t
  var nodes: ArrayBuffer[ArrayBuffer[BigInt]] = t.asInstanceOf[RBTree].nodes
  val node: ArrayBuffer[BigInt] = ArrayBuffer(v, 1, -1, -1, -1)
  nodes = nodes :+ node
  val idx: BigInt = BigInt((nodes).size) - 1
  var y: BigInt = NEG_ONE
  var x: BigInt = t.asInstanceOf[RBTree].root
  while (x != NEG_ONE) {
    y = x
    if (v < nodes((x.toInt).toInt)((LABEL.toInt).toInt)) {
      x = nodes((x.toInt).toInt)((LEFT.toInt).toInt)
    } else {
      x = nodes((x.toInt).toInt)((RIGHT.toInt).toInt)
    }
  }
  nodes((idx).toInt)((PARENT).toInt) = y
  if (y == NEG_ONE) {
    t.asInstanceOf[RBTree].root = idx
  } else {
    if (v < nodes((y.toInt).toInt)((LABEL.toInt).toInt)) {
      nodes((y).toInt)((LEFT).toInt) = idx
    } else {
      nodes((y).toInt)((RIGHT).toInt) = idx
    }
  }
  t.asInstanceOf[RBTree].nodes = nodes
  t = insert_fix(t, idx)
  return t
}

def inorder(t: RBTree, x: BigInt, _acc: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var acc: ArrayBuffer[BigInt] = _acc
  if (x == NEG_ONE) {
    return acc
  }
  acc = inorder(t, t.asInstanceOf[RBTree].nodes((x.toInt).toInt)((LEFT.toInt).toInt), acc)
  acc = acc :+ t.asInstanceOf[RBTree].nodes((x.toInt).toInt)((LABEL.toInt).toInt)
  acc = inorder(t, t.asInstanceOf[RBTree].nodes((x.toInt).toInt)((RIGHT.toInt).toInt), acc)
  return acc
}

def main(): Any = {
  var t: RBTree = make_tree()
  val values: ArrayBuffer[BigInt] = ArrayBuffer(10, 20, 30, 15, 25, 5, 1)
  var i: BigInt = 0
  while (i < BigInt((values).size)) {
    t = tree_insert(t, values((i.toInt).toInt))
    i = i + 1
  }
  var res: ArrayBuffer[BigInt] = ArrayBuffer()
  res = inorder(t, t.asInstanceOf[RBTree].root, res)
  println(String.valueOf(res))
}

val LABEL: BigInt = 0

val COLOR: BigInt = 1

val PARENT: BigInt = 2

val LEFT: BigInt = 3

val RIGHT: BigInt = 4

val NEG_ONE: BigInt = -1

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
