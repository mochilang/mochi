// Generated by Mochi v0.10.59 on 2025-08-06 22:20:34 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def new_node(value: BigInt): BigInt = {
  val node: scala.collection.mutable.Map[String,BigInt] = scala.collection.mutable.Map("data" -> (BigInt(value.toString.toDouble.toInt)), "left" -> (NIL), "right" -> (NIL), "height" -> (BigInt(1)))
  nodes = nodes :+ node
  return BigInt((nodes).size) - 1
}

def get_height(i: BigInt): BigInt = {
  if (i == NIL) {
    return 0
  }
  return nodes((i.toInt).toInt).getOrElse("height", null).asInstanceOf[BigInt]
}

def my_max(a: BigInt, b: BigInt): BigInt = {
  if (a > b) {
    return a
  }
  return b
}

def update_height(i: BigInt): Any = {
  nodes((i).toInt).update("height", my_max(get_height(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]), get_height(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt])) + 1)
}

def right_rotation(i: BigInt): BigInt = {
  val left: BigInt = nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]
  nodes((i).toInt).update("left", nodes((left.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt])
  nodes((left).toInt).update("right", i)
  update_height(i)
  update_height(left)
  return left
}

def left_rotation(i: BigInt): BigInt = {
  val right: BigInt = nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt]
  nodes((i).toInt).update("right", nodes((right.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt])
  nodes((right).toInt).update("left", i)
  update_height(i)
  update_height(right)
  return right
}

def lr_rotation(i: BigInt): BigInt = {
  nodes((i).toInt).update("left", left_rotation(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]))
  return right_rotation(i)
}

def rl_rotation(i: BigInt): BigInt = {
  nodes((i).toInt).update("right", right_rotation(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt]))
  return left_rotation(i)
}

def insert_node(_i: BigInt, value: BigInt): BigInt = {
  var i: BigInt = _i
  if (i == NIL) {
    return new_node(value)
  }
  if (value < nodes((i.toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt]) {
    nodes((i).toInt).update("left", insert_node(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt], value))
    if (get_height(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]) - get_height(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt]) == 2) {
      if (value < nodes((nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt].toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt]) {
        i = right_rotation(i)
      } else {
        i = lr_rotation(i)
      }
    }
  } else {
    nodes((i).toInt).update("right", insert_node(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt], value))
    if (get_height(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt]) - get_height(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]) == 2) {
      if (value < nodes((nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt].toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt]) {
        i = rl_rotation(i)
      } else {
        i = left_rotation(i)
      }
    }
  }
  update_height(i)
  return i
}

def get_left_most(i: BigInt): BigInt = {
  var cur: BigInt = i
  while (nodes((cur.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt] != NIL) {
    cur = nodes((cur.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]
  }
  return nodes((cur.toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt]
}

def del_node(_i: BigInt, value: BigInt): BigInt = {
  var i: BigInt = _i
  if (i == NIL) {
    return NIL
  }
  if (value < nodes((i.toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt]) {
    nodes((i).toInt).update("left", del_node(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt], value))
  } else {
    if (value > nodes((i.toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt]) {
      nodes((i).toInt).update("right", del_node(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt], value))
    } else {
      if ((nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt] != NIL && nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt] != NIL).asInstanceOf[Boolean]) {
        val temp: BigInt = get_left_most(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt])
        nodes((i).toInt).update("data", temp)
        nodes((i).toInt).update("right", del_node(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt], temp))
      } else {
        if (nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt] != NIL) {
          i = nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]
        } else {
          i = nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt]
        }
      }
    }
  }
  if (i == NIL) {
    return NIL
  }
  val lh: BigInt = get_height(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt])
  val rh: BigInt = get_height(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt])
  if (rh - lh == 2) {
    if (get_height(nodes((nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt].toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt]) > get_height(nodes((nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt].toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt])) {
      i = left_rotation(i)
    } else {
      i = rl_rotation(i)
    }
  } else {
    if (lh - rh == 2) {
      if (get_height(nodes((nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt].toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt]) > get_height(nodes((nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt].toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt])) {
        i = right_rotation(i)
      } else {
        i = lr_rotation(i)
      }
    }
  }
  update_height(i)
  return i
}

def inorder(i: BigInt): String = {
  if (i == NIL) {
    return ""
  }
  val left: String = inorder(nodes((i.toInt).toInt).getOrElse("left", null).asInstanceOf[BigInt])
  val right: String = inorder(nodes((i.toInt).toInt).getOrElse("right", null).asInstanceOf[BigInt])
  var res: String = String.valueOf(nodes((i.toInt).toInt).getOrElse("data", null).asInstanceOf[BigInt])
  if (left != "") {
    res = left + " " + res
  }
  if (right != "") {
    res = res + " " + right
  }
  return res
}

def main(): Any = {
  nodes = ArrayBuffer()
  var root: BigInt = NIL
  root = insert_node(root, 4)
  root = insert_node(root, 2)
  root = insert_node(root, 3)
  println(inorder(root))
  println(String.valueOf(get_height(root)))
  root = del_node(root, 3)
  println(inorder(root))
}

val NIL: BigInt = 0 - 1

var nodes: ArrayBuffer[scala.collection.mutable.Map[String,BigInt]] = ArrayBuffer()

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
