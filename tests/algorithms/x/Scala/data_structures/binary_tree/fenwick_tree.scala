// Generated by Mochi v0.10.59 on 2025-08-06 22:21:46 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class FenwickTree(var size: BigInt, var tree: ArrayBuffer[BigInt])

def fenwick_from_list(arr: ArrayBuffer[BigInt]): FenwickTree = {
  val size: BigInt = BigInt((arr).size)
  var tree: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < size) {
    tree = tree :+ arr((i.toInt).toInt)
    i = i + 1
  }
  i = 1
  while (i < size) {
    val j: BigInt = fenwick_next(i)
    if (j < size) {
      tree((j).toInt) = tree((j.toInt).toInt) + tree((i.toInt).toInt)
    }
    i = i + 1
  }
  return FenwickTree(size, tree)
}

def fenwick_empty(size: BigInt): FenwickTree = {
  var tree: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < size) {
    tree = tree :+ BigInt(0)
    i = i + 1
  }
  return FenwickTree(size, tree)
}

def fenwick_get_array(f: FenwickTree): ArrayBuffer[BigInt] = {
  var arr: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < f.size) {
    arr = arr :+ f.tree((i.toInt).toInt)
    i = i + 1
  }
  i = f.size - 1
  while (i > 0) {
    val j: BigInt = fenwick_next(i)
    if (j < f.size) {
      arr((j).toInt) = arr((j.toInt).toInt) - arr((i.toInt).toInt)
    }
    i = i - 1
  }
  return arr
}

def bit_and(a: BigInt, b: BigInt): BigInt = {
  var ua: BigInt = a
  var ub: BigInt = b
  var res: BigInt = 0
  var bit: BigInt = 1
  while (ua != 0 || ub != 0) {
    if ((ua % 2 == 1 && ub % 2 == 1).asInstanceOf[Boolean]) {
      res = res + bit
    }
    ua = ua / 2
    ub = ub / 2
    bit = bit * 2
  }
  return res
}

def low_bit(x: BigInt): BigInt = {
  if (x == 0) {
    return 0
  }
  return x - bit_and(x, x - 1)
}

def fenwick_next(index: BigInt): BigInt = {
  return index + low_bit(index)
}

def fenwick_prev(index: BigInt): BigInt = {
  return index - low_bit(index)
}

def fenwick_add(f: FenwickTree, index: BigInt, value: BigInt): FenwickTree = {
  var tree: ArrayBuffer[BigInt] = f.tree
  if (index == 0) {
    tree((0).toInt) = tree((0.toInt).toInt) + value
    return FenwickTree(f.size, tree)
  }
  var i: BigInt = index
  while (i < f.size) {
    tree((i).toInt) = tree((i.toInt).toInt) + value
    i = fenwick_next(i)
  }
  return FenwickTree(f.size, tree)
}

def fenwick_update(f: FenwickTree, index: BigInt, value: BigInt): FenwickTree = {
  val current: BigInt = fenwick_get(f, index)
  return fenwick_add(f, index, value - current)
}

def fenwick_prefix(f: FenwickTree, right: BigInt): BigInt = {
  if (right == 0) {
    return 0
  }
  var result: BigInt = f.tree((0.toInt).toInt)
  var r: BigInt = right - 1
  while (r > 0) {
    result = result + f.tree((r.toInt).toInt)
    r = fenwick_prev(r)
  }
  return result
}

def fenwick_query(f: FenwickTree, left: BigInt, right: BigInt): BigInt = {
  return fenwick_prefix(f, right) - fenwick_prefix(f, left)
}

def fenwick_get(f: FenwickTree, index: BigInt): BigInt = {
  return fenwick_query(f, index, index + 1)
}

def fenwick_rank_query(f: FenwickTree, value: BigInt): BigInt = {
  var v: BigInt = value - f.tree((0.toInt).toInt)
  if (v < 0) {
    return -1
  }
  var j: BigInt = 1
  while (j * 2 < f.size) {
    j = j * 2
  }
  var i: BigInt = 0
  var jj: BigInt = j
  while (jj > 0) {
    if ((i + jj < f.size && f.tree(((i + jj).toInt).toInt) <= v).asInstanceOf[Boolean]) {
      v = v - f.tree(((i + jj).toInt).toInt)
      i = i + jj
    }
    jj = jj / 2
  }
  return i
}

val f_base: FenwickTree = fenwick_from_list(ArrayBuffer(1, 2, 3, 4, 5))

val f2: FenwickTree = fenwick_from_list(ArrayBuffer(1, 2, 3, 4, 5))

val f3: FenwickTree = fenwick_from_list(ArrayBuffer(1, 2, 0, 3, 0, 5))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println(fenwick_get_array(f_base))
    var f: FenwickTree = fenwick_from_list(ArrayBuffer(1, 2, 3, 4, 5))
    f = fenwick_add(f, 0, 1)
    f = fenwick_add(f, 1, 2)
    f = fenwick_add(f, 2, 3)
    f = fenwick_add(f, 3, 4)
    f = fenwick_add(f, 4, 5)
    println(fenwick_get_array(f))
    println(fenwick_prefix(f2, 3))
    println(fenwick_query(f2, 1, 4))
    println(fenwick_rank_query(f3, 0))
    println(fenwick_rank_query(f3, 2))
    println(fenwick_rank_query(f3, 1))
    println(fenwick_rank_query(f3, 3))
    println(fenwick_rank_query(f3, 5))
    println(fenwick_rank_query(f3, 6))
    println(fenwick_rank_query(f3, 11))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
