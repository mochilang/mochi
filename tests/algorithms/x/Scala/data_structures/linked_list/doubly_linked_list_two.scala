// Generated by Mochi v0.10.59 on 2025-08-07 00:48:10 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Node(var data: BigInt, var prev_index: BigInt, var next_index: BigInt)

case class LinkedList(var nodes: ArrayBuffer[Node], var head_idx: BigInt, var tail_idx: BigInt)

def empty_list(): LinkedList = {
  return LinkedList(ArrayBuffer(), -1, -1)
}

def get_head_data(ll: LinkedList): BigInt = {
  if (ll.asInstanceOf[LinkedList].head_idx == -1) {
    return -1
  }
  val node: Node = ll.asInstanceOf[LinkedList].nodes((ll.asInstanceOf[LinkedList].head_idx.toInt).toInt)
  return node.asInstanceOf[Node].data
}

def get_tail_data(ll: LinkedList): BigInt = {
  if (ll.asInstanceOf[LinkedList].tail_idx == -1) {
    return -1
  }
  val node: Node = ll.asInstanceOf[LinkedList].nodes((ll.asInstanceOf[LinkedList].tail_idx.toInt).toInt)
  return node.asInstanceOf[Node].data
}

def insert_before_node(ll: LinkedList, idx: BigInt, new_idx: BigInt): Any = {
  var nodes: ArrayBuffer[Node] = ll.asInstanceOf[LinkedList].nodes
  var new_node: Node = nodes((new_idx.toInt).toInt)
  new_node.asInstanceOf[Node].next_index = idx
  var node: Node = nodes((idx.toInt).toInt)
  val p: BigInt = node.asInstanceOf[Node].prev_index
  new_node.asInstanceOf[Node].prev_index = p
  nodes((new_idx).toInt) = new_node
  if (p == -1) {
    ll.asInstanceOf[LinkedList].head_idx = new_idx
  } else {
    var prev_node: Node = nodes((p.toInt).toInt)
    prev_node.asInstanceOf[Node].next_index = new_idx
    nodes((p).toInt) = prev_node
  }
  node.asInstanceOf[Node].prev_index = new_idx
  nodes((idx).toInt) = node
  ll.asInstanceOf[LinkedList].nodes = nodes
}

def insert_after_node(ll: LinkedList, idx: BigInt, new_idx: BigInt): Any = {
  var nodes: ArrayBuffer[Node] = ll.asInstanceOf[LinkedList].nodes
  var new_node: Node = nodes((new_idx.toInt).toInt)
  new_node.asInstanceOf[Node].prev_index = idx
  var node: Node = nodes((idx.toInt).toInt)
  val nxt: BigInt = node.asInstanceOf[Node].next_index
  new_node.asInstanceOf[Node].next_index = nxt
  nodes((new_idx).toInt) = new_node
  if (nxt == -1) {
    ll.asInstanceOf[LinkedList].tail_idx = new_idx
  } else {
    var next_node: Node = nodes((nxt.toInt).toInt)
    next_node.asInstanceOf[Node].prev_index = new_idx
    nodes((nxt).toInt) = next_node
  }
  node.asInstanceOf[Node].next_index = new_idx
  nodes((idx).toInt) = node
  ll.asInstanceOf[LinkedList].nodes = nodes
}

def set_head(ll: LinkedList, idx: BigInt): Any = {
  if (ll.asInstanceOf[LinkedList].head_idx == -1) {
    ll.asInstanceOf[LinkedList].head_idx = idx
    ll.asInstanceOf[LinkedList].tail_idx = idx
  } else {
    insert_before_node(ll, ll.asInstanceOf[LinkedList].head_idx, idx)
  }
}

def set_tail(ll: LinkedList, idx: BigInt): Any = {
  if (ll.asInstanceOf[LinkedList].tail_idx == -1) {
    ll.asInstanceOf[LinkedList].head_idx = idx
    ll.asInstanceOf[LinkedList].tail_idx = idx
  } else {
    insert_after_node(ll, ll.asInstanceOf[LinkedList].tail_idx, idx)
  }
}

def insert(ll: LinkedList, value: BigInt): Any = {
  var nodes: ArrayBuffer[Node] = ll.asInstanceOf[LinkedList].nodes
  nodes = nodes :+ Node(value, -1, -1)
  val idx: BigInt = BigInt((nodes).size) - 1
  ll.asInstanceOf[LinkedList].nodes = nodes
  if (ll.asInstanceOf[LinkedList].head_idx == -1) {
    ll.asInstanceOf[LinkedList].head_idx = idx
    ll.asInstanceOf[LinkedList].tail_idx = idx
  } else {
    insert_after_node(ll, ll.asInstanceOf[LinkedList].tail_idx, idx)
  }
}

def insert_at_position(ll: LinkedList, position: BigInt, value: BigInt): Any = {
  var current: BigInt = ll.asInstanceOf[LinkedList].head_idx
  var current_pos: BigInt = 1
  while (current != -1) {
    if (current_pos == position) {
      var nodes: ArrayBuffer[Node] = ll.asInstanceOf[LinkedList].nodes
      nodes = nodes :+ Node(value, -1, -1)
      val new_idx: BigInt = BigInt((nodes).size) - 1
      ll.asInstanceOf[LinkedList].nodes = nodes
      insert_before_node(ll, current, new_idx)
      return
    }
    val node: Node = ll.asInstanceOf[LinkedList].nodes((current.toInt).toInt)
    current = node.asInstanceOf[Node].next_index
    current_pos = current_pos + 1
  }
  insert(ll, value)
  return null
}

def get_node(ll: LinkedList, item: BigInt): BigInt = {
  var current: BigInt = ll.asInstanceOf[LinkedList].head_idx
  while (current != -1) {
    val node: Node = ll.asInstanceOf[LinkedList].nodes((current.toInt).toInt)
    if (node.asInstanceOf[Node].data == item) {
      return current
    }
    current = node.asInstanceOf[Node].next_index
  }
  return -1
}

def remove_node_pointers(ll: LinkedList, idx: BigInt): Any = {
  var nodes: ArrayBuffer[Node] = ll.asInstanceOf[LinkedList].nodes
  var node: Node = nodes((idx.toInt).toInt)
  val nxt: BigInt = node.asInstanceOf[Node].next_index
  val p: BigInt = node.asInstanceOf[Node].prev_index
  if (nxt != -1) {
    var nxt_node: Node = nodes((nxt.toInt).toInt)
    nxt_node.asInstanceOf[Node].prev_index = p
    nodes((nxt).toInt) = nxt_node
  }
  if (p != -1) {
    var prev_node: Node = nodes((p.toInt).toInt)
    prev_node.asInstanceOf[Node].next_index = nxt
    nodes((p).toInt) = prev_node
  }
  node.asInstanceOf[Node].next_index = -1
  node.asInstanceOf[Node].prev_index = -1
  nodes((idx).toInt) = node
  ll.asInstanceOf[LinkedList].nodes = nodes
}

def delete_value(ll: LinkedList, value: BigInt): Any = {
  val idx: BigInt = get_node(ll, value)
  if (idx == -1) {
    return
  }
  if (idx == ll.asInstanceOf[LinkedList].head_idx) {
    val node: Node = ll.asInstanceOf[LinkedList].nodes((idx.toInt).toInt)
    ll.asInstanceOf[LinkedList].head_idx = node.asInstanceOf[Node].next_index
  }
  if (idx == ll.asInstanceOf[LinkedList].tail_idx) {
    val node: Node = ll.asInstanceOf[LinkedList].nodes((idx.toInt).toInt)
    ll.asInstanceOf[LinkedList].tail_idx = node.asInstanceOf[Node].prev_index
  }
  remove_node_pointers(ll, idx)
  return null
}

def contains(ll: LinkedList, value: BigInt): Boolean = {
  return get_node(ll, value) != -1
}

def is_empty(ll: LinkedList): Boolean = {
  return ll.asInstanceOf[LinkedList].head_idx == -1
}

def to_string(ll: LinkedList): String = {
  var res: String = ""
  var first: Boolean = true
  var current: BigInt = ll.asInstanceOf[LinkedList].head_idx
  while (current != -1) {
    val node: Node = ll.asInstanceOf[LinkedList].nodes((current.toInt).toInt)
    val `val`: String = String.valueOf(node.asInstanceOf[Node].data)
    if (first) {
      res = `val`
      first = false
    } else {
      res = res + " " + `val`
    }
    current = node.asInstanceOf[Node].next_index
  }
  return res
}

def print_list(ll: LinkedList): Any = {
  var current: BigInt = ll.asInstanceOf[LinkedList].head_idx
  while (current != -1) {
    val node: Node = ll.asInstanceOf[LinkedList].nodes((current.toInt).toInt)
    println(String.valueOf(node.asInstanceOf[Node].data))
    current = node.asInstanceOf[Node].next_index
  }
}

def main(): Any = {
  var ll: LinkedList = empty_list()
  println(String.valueOf(get_head_data(ll)))
  println(String.valueOf(get_tail_data(ll)))
  println(String.valueOf(is_empty(ll)))
  insert(ll, 10)
  println(String.valueOf(get_head_data(ll)))
  println(String.valueOf(get_tail_data(ll)))
  insert_at_position(ll, 3, 20)
  println(String.valueOf(get_head_data(ll)))
  println(String.valueOf(get_tail_data(ll)))
  var nodes: ArrayBuffer[Node] = ll.asInstanceOf[LinkedList].nodes
  nodes = nodes :+ Node(1000, -1, -1)
  val idx_head: BigInt = BigInt((nodes).size) - 1
  ll.asInstanceOf[LinkedList].nodes = nodes
  set_head(ll, idx_head)
  nodes = ll.asInstanceOf[LinkedList].nodes
  nodes = nodes :+ Node(2000, -1, -1)
  val idx_tail: BigInt = BigInt((nodes).size) - 1
  ll.asInstanceOf[LinkedList].nodes = nodes
  set_tail(ll, idx_tail)
  print_list(ll)
  println(String.valueOf(is_empty(ll)))
  print_list(ll)
  println(String.valueOf(ll.contains(10)))
  delete_value(ll, 10)
  println(String.valueOf(ll.contains(10)))
  delete_value(ll, 2000)
  println(String.valueOf(get_tail_data(ll)))
  delete_value(ll, 1000)
  println(String.valueOf(get_tail_data(ll)))
  println(String.valueOf(get_head_data(ll)))
  print_list(ll)
  delete_value(ll, 20)
  print_list(ll)
  var i: BigInt = 1
  while (i < 10) {
    insert(ll, i)
    i = i + 1
  }
  print_list(ll)
  var ll2: LinkedList = empty_list()
  insert_at_position(ll2, 1, 10)
  println(to_string(ll2))
  insert_at_position(ll2, 2, 20)
  println(to_string(ll2))
  insert_at_position(ll2, 1, 30)
  println(to_string(ll2))
  insert_at_position(ll2, 3, 40)
  println(to_string(ll2))
  insert_at_position(ll2, 5, 50)
  println(to_string(ll2))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
