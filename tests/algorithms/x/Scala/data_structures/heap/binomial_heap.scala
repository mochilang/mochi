// Generated by Mochi v0.10.59 on 2025-08-06 23:35:20 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class BinomialHeap(var data: ArrayBuffer[BigInt])

case class DeleteResult(var heap: BinomialHeap, var value: BigInt)

def new_heap(): BinomialHeap = {
  return BinomialHeap(ArrayBuffer())
}

def swap(data: ArrayBuffer[BigInt], i: BigInt, j: BigInt): Any = {
  val tmp: BigInt = data((i.toInt).toInt)
  data((i).toInt) = data((j.toInt).toInt)
  data((j).toInt) = tmp
}

def sift_up(data: ArrayBuffer[BigInt], idx: BigInt): Any = {
  var i: BigInt = idx
  val _br0 = new Breaks
  _br0.breakable {
    while (i > 0) {
      val parent: BigInt = (i - 1) / 2
      if (data((parent.toInt).toInt) <= data((i.toInt).toInt)) {
        _br0.break()
      }
      swap(data, parent, i)
      i = parent
    }
  }
}

def sift_down(data: ArrayBuffer[BigInt], idx: BigInt): Any = {
  var i: BigInt = idx
  val n: BigInt = BigInt((data).size)
  val _br1 = new Breaks
  _br1.breakable {
    while (true) {
      val left: BigInt = 2 * i + 1
      val right: BigInt = left + 1
      var smallest: BigInt = i
      if ((left < n && data((left.toInt).toInt) < data((smallest.toInt).toInt)).asInstanceOf[Boolean]) {
        smallest = left
      }
      if ((right < n && data((right.toInt).toInt) < data((smallest.toInt).toInt)).asInstanceOf[Boolean]) {
        smallest = right
      }
      if (smallest == i) {
        _br1.break()
      }
      swap(data, i, smallest)
      i = smallest
    }
  }
}

def insert(heap: BinomialHeap, v: BigInt): BinomialHeap = {
  var d: ArrayBuffer[BigInt] = heap.asInstanceOf[BinomialHeap].data
  d = d :+ v
  sift_up(d, BigInt((d).size) - 1)
  return BinomialHeap(d)
}

def peek(heap: BinomialHeap): BigInt = {
  return heap.asInstanceOf[BinomialHeap].data((0.toInt).toInt)
}

def is_empty(heap: BinomialHeap): Boolean = {
  return BigInt((heap.asInstanceOf[BinomialHeap].data).size) == 0
}

def delete_min(heap: BinomialHeap): DeleteResult = {
  var d: ArrayBuffer[BigInt] = heap.asInstanceOf[BinomialHeap].data
  val min: BigInt = d((0.toInt).toInt)
  d((0).toInt) = d(((BigInt((d).size) - 1).toInt).toInt)
  d = d.slice((0).toInt, (BigInt((d).size) - 1).toInt)
  if (BigInt((d).size) > 0) {
    sift_down(d, 0)
  }
  return DeleteResult(BinomialHeap(d), min)
}

def main(): Any = {
  var h: BinomialHeap = new_heap()
  h = insert(h, 10)
  h = insert(h, 3)
  h = insert(h, 7)
  println(String.valueOf(peek(h)))
  val d1: DeleteResult = delete_min(h)
  h = d1.asInstanceOf[DeleteResult].heap
  println(String.valueOf(d1.asInstanceOf[DeleteResult].value))
  val d2: DeleteResult = delete_min(h)
  h = d2.asInstanceOf[DeleteResult].heap
  println(String.valueOf(d2.asInstanceOf[DeleteResult].value))
  val d3: DeleteResult = delete_min(h)
  h = d3.asInstanceOf[DeleteResult].heap
  println(String.valueOf(d3.asInstanceOf[DeleteResult].value))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
