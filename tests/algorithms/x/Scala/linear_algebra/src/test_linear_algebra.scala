// Generated by Mochi v0.10.59 on 2025-08-07 12:42:00 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def int_to_string(n: BigInt): String = {
  if (n == BigInt(0)) {
    return "0"
  }
  var num: BigInt = n
  var neg: Boolean = false
  if (num < BigInt(0)) {
    neg = true
    num = -num
  }
  var res: String = ""
  while (num > BigInt(0)) {
    val digit: BigInt = num % BigInt(10)
    val ch: String = "0123456789".slice((digit).toInt, (digit + BigInt(1)).toInt)
    res = ch + res
    num = num / BigInt(10)
  }
  if (neg) {
    res = "-" + res
  }
  return res
}

def float_to_string(x: Double, dec: BigInt): String = {
  var neg: Boolean = false
  var num: Double = x
  if (num < 0.0) {
    neg = true
    num = -num
  }
  val int_part: BigInt = BigInt(num.toString.toDouble.toInt)
  var res: String = int_to_string(int_part)
  if (dec > BigInt(0)) {
    res = res + "."
    var frac: Double = num - int_part.toString.toDouble
    var i: BigInt = BigInt(0)
    while (i < dec) {
      frac = frac * 10.0
      val digit: BigInt = BigInt(frac.toString.toDouble.toInt)
      res = res + "0123456789".slice((digit).toInt, (digit + BigInt(1)).toInt)
      frac = frac - digit.toString.toDouble
      i = i + BigInt(1)
    }
  }
  if (neg) {
    res = "-" + res
  }
  return res
}

def vector_component(v: ArrayBuffer[BigInt], i: BigInt): BigInt = {
  return v((i.toInt).toInt)
}

def vector_str_int(v: ArrayBuffer[BigInt]): String = {
  var s: String = "("
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    s = s + int_to_string(v((i.toInt).toInt))
    if (i + BigInt(1) < BigInt((v).size)) {
      s = s + ","
    }
    i = i + BigInt(1)
  }
  s = s + ")"
  return s
}

def vector_str_float(v: ArrayBuffer[Double], dec: BigInt): String = {
  var s: String = "("
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    s = s + float_to_string(v((i.toInt).toInt), dec)
    if (i + BigInt(1) < BigInt((v).size)) {
      s = s + ","
    }
    i = i + BigInt(1)
  }
  s = s + ")"
  return s
}

def vector_add(a: ArrayBuffer[BigInt], b: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = res :+ a((i.toInt).toInt) + b((i.toInt).toInt)
    i = i + BigInt(1)
  }
  return res
}

def vector_sub(a: ArrayBuffer[BigInt], b: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    res = res :+ a((i.toInt).toInt) - b((i.toInt).toInt)
    i = i + BigInt(1)
  }
  return res
}

def vector_scalar_mul(v: ArrayBuffer[BigInt], s: Double): ArrayBuffer[Double] = {
  var res: ArrayBuffer[Double] = ArrayBuffer[Double]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    res = res :+ (v((i.toInt).toInt)).toString.toDouble * s
    i = i + BigInt(1)
  }
  return res
}

def vector_dot(a: ArrayBuffer[BigInt], b: ArrayBuffer[BigInt]): BigInt = {
  var sum: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    sum = sum + a((i.toInt).toInt) * b((i.toInt).toInt)
    i = i + BigInt(1)
  }
  return sum
}

def sqrt_newton(x: Double): Double = {
  if (x == 0.0) {
    return 0.0
  }
  var low: Double = 0.0
  var high: Double = x
  if (x < 1.0) {
    high = 1.0
  }
  var mid: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt(40)) {
    mid = (low + high) / 2.0
    if (mid * mid > x) {
      high = mid
    } else {
      low = mid
    }
    i = i + BigInt(1)
  }
  return mid
}

def euclidean_length(v: ArrayBuffer[BigInt]): Double = {
  var sum: Double = 0.0
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    val `val`: Double = (v((i.toInt).toInt)).toString.toDouble
    sum = sum + `val` * `val`
    i = i + BigInt(1)
  }
  return sqrt_newton(sum)
}

def zero_vector(n: BigInt): ArrayBuffer[BigInt] = {
  var v: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    v = v :+ BigInt(0)
    i = i + BigInt(1)
  }
  return v
}

def unit_basis_vector(n: BigInt, idx: BigInt): ArrayBuffer[BigInt] = {
  var v: ArrayBuffer[BigInt] = zero_vector(n)
  v((idx).toInt) = BigInt(1)
  return v
}

def axpy(a: BigInt, x: ArrayBuffer[BigInt], y: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((x).size)) {
    res = res :+ a * x((i.toInt).toInt) + y((i.toInt).toInt)
    i = i + BigInt(1)
  }
  return res
}

def copy_vector(x: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((x).size)) {
    res = res :+ x((i.toInt).toInt)
    i = i + BigInt(1)
  }
  return res
}

def change_component(v: ArrayBuffer[BigInt], idx: BigInt, `val`: BigInt): Any = {
  v((idx).toInt) = `val`
}

def matrix_str(m: ArrayBuffer[ArrayBuffer[BigInt]]): String = {
  var s: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((m).size)) {
    s = s + "|"
    var j: BigInt = BigInt(0)
    while (j < BigInt((m((BigInt(0).toInt).toInt)).size)) {
      s = s + int_to_string(m((i.toInt).toInt)((j.toInt).toInt))
      if (j + BigInt(1) < BigInt((m((BigInt(0).toInt).toInt)).size)) {
        s = s + ","
      }
      j = j + BigInt(1)
    }
    s = s + "|\n"
    i = i + BigInt(1)
  }
  return s
}

def submatrix(m: ArrayBuffer[ArrayBuffer[BigInt]], row: BigInt, col: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var res: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((m).size)) {
    if (i != row) {
      var r: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
      var j: BigInt = BigInt(0)
      while (j < BigInt((m((BigInt(0).toInt).toInt)).size)) {
        if (j != col) {
          r = r :+ m((i.toInt).toInt)((j.toInt).toInt)
        }
        j = j + BigInt(1)
      }
      res = res :+ r
    }
    i = i + BigInt(1)
  }
  return res
}

def determinant(m: ArrayBuffer[ArrayBuffer[BigInt]]): BigInt = {
  val n: BigInt = BigInt((m).size)
  if (n == BigInt(1)) {
    return m((BigInt(0).toInt).toInt)((BigInt(0).toInt).toInt)
  }
  if (n == BigInt(2)) {
    return m((BigInt(0).toInt).toInt)((BigInt(0).toInt).toInt) * m((BigInt(1).toInt).toInt)((BigInt(1).toInt).toInt) - m((BigInt(0).toInt).toInt)((BigInt(1).toInt).toInt) * m((BigInt(1).toInt).toInt)((BigInt(0).toInt).toInt)
  }
  var det: BigInt = BigInt(0)
  var c: BigInt = BigInt(0)
  while (c < n) {
    val sub: ArrayBuffer[ArrayBuffer[BigInt]] = submatrix(m, BigInt(0), c)
    var sign: BigInt = BigInt(1)
    if (c % BigInt(2) == BigInt(1)) {
      sign = -BigInt(1)
    }
    det = det + sign * m((BigInt(0).toInt).toInt)((c.toInt).toInt) * determinant(sub)
    c = c + BigInt(1)
  }
  return det
}

def matrix_minor(m: ArrayBuffer[ArrayBuffer[BigInt]], row: BigInt, col: BigInt): BigInt = {
  return determinant(submatrix(m, row, col))
}

def matrix_cofactor(m: ArrayBuffer[ArrayBuffer[BigInt]], row: BigInt, col: BigInt): BigInt = {
  var sign: BigInt = BigInt(1)
  if ((row + col) % BigInt(2) == BigInt(1)) {
    sign = -BigInt(1)
  }
  return sign * matrix_minor(m, row, col)
}

def matrix_mul_vector(m: ArrayBuffer[ArrayBuffer[BigInt]], v: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((m).size)) {
    var sum: BigInt = BigInt(0)
    var j: BigInt = BigInt(0)
    while (j < BigInt((m((BigInt(0).toInt).toInt)).size)) {
      sum = sum + m((i.toInt).toInt)((j.toInt).toInt) * v((j.toInt).toInt)
      j = j + BigInt(1)
    }
    res = res :+ sum
    i = i + BigInt(1)
  }
  return res
}

def matrix_mul_scalar(m: ArrayBuffer[ArrayBuffer[BigInt]], s: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var res: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((m).size)) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((m((BigInt(0).toInt).toInt)).size)) {
      row = row :+ m((i.toInt).toInt)((j.toInt).toInt) * s
      j = j + BigInt(1)
    }
    res = res :+ row
    i = i + BigInt(1)
  }
  return res
}

def matrix_change_component(m: ArrayBuffer[ArrayBuffer[BigInt]], i: BigInt, j: BigInt, `val`: BigInt): Any = {
  m((i).toInt)((j).toInt) = `val`
}

def matrix_component(m: ArrayBuffer[ArrayBuffer[BigInt]], i: BigInt, j: BigInt): BigInt = {
  return m((i.toInt).toInt)((j.toInt).toInt)
}

def matrix_add(a: ArrayBuffer[ArrayBuffer[BigInt]], b: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var res: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((a((BigInt(0).toInt).toInt)).size)) {
      row = row :+ a((i.toInt).toInt)((j.toInt).toInt) + b((i.toInt).toInt)((j.toInt).toInt)
      j = j + BigInt(1)
    }
    res = res :+ row
    i = i + BigInt(1)
  }
  return res
}

def matrix_sub(a: ArrayBuffer[ArrayBuffer[BigInt]], b: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var res: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var j: BigInt = BigInt(0)
    while (j < BigInt((a((BigInt(0).toInt).toInt)).size)) {
      row = row :+ a((i.toInt).toInt)((j.toInt).toInt) - b((i.toInt).toInt)((j.toInt).toInt)
      j = j + BigInt(1)
    }
    res = res :+ row
    i = i + BigInt(1)
  }
  return res
}

def square_zero_matrix(n: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var m: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
  var i: BigInt = BigInt(0)
  while (i < n) {
    m = m :+ zero_vector(n)
    i = i + BigInt(1)
  }
  return m
}

def assert_int(name: String, actual: BigInt, expected: BigInt): Any = {
  if (actual == expected) {
    println(name + " ok")
  } else {
    println(name + " fail " + int_to_string(actual) + " != " + int_to_string(expected))
  }
}

def assert_str(name: String, actual: String, expected: String): Any = {
  if (actual == expected) {
    println(name + " ok")
  } else {
    println(name + " fail")
    println(actual)
    println(expected)
  }
}

def assert_float(name: String, actual: Double, expected: Double, eps: Double): Any = {
  var diff: Double = actual - expected
  if (diff < 0.0) {
    diff = -diff
  }
  if (diff <= eps) {
    println(name + " ok")
  } else {
    println(name + " fail")
  }
}

val vx: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(2), BigInt(3))

val vs: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(0), BigInt(0), BigInt(0), BigInt(0), BigInt(0), BigInt(1))

val vsize: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(2), BigInt(3), BigInt(4))

val va: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(2), BigInt(3))

val vb: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(1), BigInt(1))

val vsum: ArrayBuffer[BigInt] = vector_add(va, vb)

val vsub: ArrayBuffer[BigInt] = vector_sub(va, vb)

val vmul: ArrayBuffer[Double] = vector_scalar_mul(va, 3.0)

val zvec: ArrayBuffer[BigInt] = zero_vector(BigInt(10))

val zstr: String = vector_str_int(zvec)

val vcopy: ArrayBuffer[BigInt] = copy_vector(ArrayBuffer(BigInt(1), BigInt(0), BigInt(0), BigInt(0), BigInt(0), BigInt(0)))

var vchange: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(0), BigInt(0))

var ma: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(8)))

var mb: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(4), BigInt(5), BigInt(6)), ArrayBuffer(BigInt(7), BigInt(8), BigInt(9)))

val mv: ArrayBuffer[BigInt] = matrix_mul_vector(mb, ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)))

val msc: ArrayBuffer[ArrayBuffer[BigInt]] = matrix_mul_scalar(mb, BigInt(2))

var mc: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(8)))

var madd: ArrayBuffer[ArrayBuffer[BigInt]] = matrix_add(ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(8))), ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(7)), ArrayBuffer(BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(10))))

var msub: ArrayBuffer[ArrayBuffer[BigInt]] = matrix_sub(ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(8))), ArrayBuffer(ArrayBuffer(BigInt(1), BigInt(2), BigInt(7)), ArrayBuffer(BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(6), BigInt(7), BigInt(10))))

val mzero: ArrayBuffer[ArrayBuffer[BigInt]] = square_zero_matrix(BigInt(5))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    assert_int("component0", vector_component(vx, BigInt(0)), BigInt(1))
    assert_int("component2", vector_component(vx, BigInt(2)), BigInt(3))
    assert_str("str_vector", vector_str_int(vs), "(0,0,0,0,0,1)")
    assert_int("size", BigInt((vsize).size), BigInt(4))
    assert_int("add0", vector_component(vsum, BigInt(0)), BigInt(2))
    assert_int("add1", vector_component(vsum, BigInt(1)), BigInt(3))
    assert_int("add2", vector_component(vsum, BigInt(2)), BigInt(4))
    assert_int("sub0", vector_component(vsub, BigInt(0)), BigInt(0))
    assert_int("sub1", vector_component(vsub, BigInt(1)), BigInt(1))
    assert_int("sub2", vector_component(vsub, BigInt(2)), BigInt(2))
    assert_str("scalar_mul", vector_str_float(vmul, BigInt(1)), "(3.0,6.0,9.0)")
    assert_int("dot_product", vector_dot(ArrayBuffer(BigInt(2), -BigInt(1), BigInt(4)), ArrayBuffer(BigInt(1), -BigInt(2), -BigInt(1))), BigInt(0))
    var zcount: BigInt = BigInt(0)
    var zi: BigInt = BigInt(0)
    while (zi < BigInt((zstr).length)) {
      if (zstr.slice((zi).toInt, (zi + BigInt(1)).toInt) == "0") {
        zcount = zcount + BigInt(1)
      }
      zi = zi + BigInt(1)
    }
    assert_int("zero_vector", zcount, BigInt(10))
    assert_str("unit_basis", vector_str_int(unit_basis_vector(BigInt(3), BigInt(1))), "(0,1,0)")
    assert_str("axpy", vector_str_int(axpy(BigInt(2), ArrayBuffer(BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(1), BigInt(0), BigInt(1)))), "(3,4,7)")
    assert_str("copy", vector_str_int(vcopy), "(1,0,0,0,0,0)")
    change_component(vchange, BigInt(0), BigInt(0))
    change_component(vchange, BigInt(1), BigInt(1))
    assert_str("change_component", vector_str_int(vchange), "(0,1,0)")
    assert_str("matrix_str", matrix_str(ma), "|1,2,3|\n|2,4,5|\n|6,7,8|\n")
    assert_int("determinant", determinant(ma), -BigInt(5))
    assert_str("matrix_vec_mul", vector_str_int(mv), "(14,32,50)")
    assert_str("matrix_scalar_mul", matrix_str(msc), "|2,4,6|\n|8,10,12|\n|14,16,18|\n")
    matrix_change_component(mc, BigInt(0), BigInt(2), BigInt(5))
    assert_str("change_component_matrix", matrix_str(mc), "|1,2,5|\n|2,4,5|\n|6,7,8|\n")
    assert_int("matrix_component", matrix_component(mc, BigInt(2), BigInt(1)), BigInt(7))
    assert_str("matrix_add", matrix_str(madd), "|2,4,10|\n|4,8,10|\n|12,14,18|\n")
    assert_str("matrix_sub", matrix_str(msub), "|0,0,-4|\n|0,0,0|\n|0,0,-2|\n")
    assert_str("square_zero_matrix", matrix_str(mzero), "|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n")
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
