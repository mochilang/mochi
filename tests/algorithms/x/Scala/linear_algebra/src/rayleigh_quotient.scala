// Generated by Mochi v0.10.59 on 2025-08-07 12:41:44 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Complex(var re: Double, var im: Double)

def complex_conj(z: Complex): Complex = {
  return Complex(z.asInstanceOf[Complex].re, -z.asInstanceOf[Complex].im)
}

def complex_eq(a: Complex, b: Complex): Boolean = {
  return (a.re == b.re && a.im == b.im).asInstanceOf[Boolean]
}

def complex_add(a: Complex, b: Complex): Complex = {
  return Complex(a.re + b.re, a.im + b.im)
}

def complex_mul(a: Complex, b: Complex): Complex = {
  val real: Double = a.re * b.re - a.im * b.im
  val imag: Double = a.re * b.im + a.im * b.re
  return Complex(real, imag)
}

def conj_vector(v: ArrayBuffer[Complex]): ArrayBuffer[Complex] = {
  var res: ArrayBuffer[Complex] = ArrayBuffer[Complex]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((v).size)) {
    res = res :+ complex_conj(v((i.toInt).toInt))
    i = i + BigInt(1)
  }
  return res
}

def vec_mat_mul(v: ArrayBuffer[Complex], m: ArrayBuffer[ArrayBuffer[Complex]]): ArrayBuffer[Complex] = {
  var result: ArrayBuffer[Complex] = ArrayBuffer[Complex]()
  var col: BigInt = BigInt(0)
  while (col < BigInt((m((BigInt(0).toInt).toInt)).size)) {
    var sum: Complex = Complex(0.0, 0.0)
    var row: BigInt = BigInt(0)
    while (row < BigInt((v).size)) {
      sum = complex_add(sum, complex_mul(v((row.toInt).toInt), m((row.toInt).toInt)((col.toInt).toInt)))
      row = row + BigInt(1)
    }
    result = result :+ sum
    col = col + BigInt(1)
  }
  return result
}

def dot(a: ArrayBuffer[Complex], b: ArrayBuffer[Complex]): Complex = {
  var sum: Complex = Complex(0.0, 0.0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    sum = complex_add(sum, complex_mul(a((i.toInt).toInt), b((i.toInt).toInt)))
    i = i + BigInt(1)
  }
  return sum
}

def is_hermitian(m: ArrayBuffer[ArrayBuffer[Complex]]): Boolean = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((m).size)) {
    var j: BigInt = BigInt(0)
    while (j < BigInt((m).size)) {
      if (!complex_eq(m((i.toInt).toInt)((j.toInt).toInt), complex_conj(m((j.toInt).toInt)((i.toInt).toInt)))) {
        return false
      }
      j = j + BigInt(1)
    }
    i = i + BigInt(1)
  }
  return true
}

def rayleigh_quotient(a: ArrayBuffer[ArrayBuffer[Complex]], v: ArrayBuffer[Complex]): Double = {
  val v_star: ArrayBuffer[Complex] = conj_vector(v)
  val v_star_dot: ArrayBuffer[Complex] = vec_mat_mul(v_star, a)
  val num: Complex = dot(v_star_dot, v)
  val den: Complex = dot(v_star, v)
  return num.asInstanceOf[Complex].re / den.asInstanceOf[Complex].re
}

val a: ArrayBuffer[ArrayBuffer[Complex]] = ArrayBuffer(ArrayBuffer(Complex(2.0, 0.0), Complex(2.0, 1.0), Complex(4.0, 0.0)), ArrayBuffer(Complex(2.0, -1.0), Complex(3.0, 0.0), Complex(0.0, 1.0)), ArrayBuffer(Complex(4.0, 0.0), Complex(0.0, -1.0), Complex(1.0, 0.0)))

val v: ArrayBuffer[Complex] = ArrayBuffer(Complex(1.0, 0.0), Complex(2.0, 0.0), Complex(3.0, 0.0))

val b: ArrayBuffer[ArrayBuffer[Complex]] = ArrayBuffer(ArrayBuffer(Complex(1.0, 0.0), Complex(2.0, 0.0), Complex(4.0, 0.0)), ArrayBuffer(Complex(2.0, 0.0), Complex(3.0, 0.0), Complex(-1.0, 0.0)), ArrayBuffer(Complex(4.0, 0.0), Complex(-1.0, 0.0), Complex(1.0, 0.0)))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    if (is_hermitian(a)) {
      val r1: Double = rayleigh_quotient(a, v)
      println(r1)
      println("\n")
    }
    if (is_hermitian(b)) {
      val r2: Double = rayleigh_quotient(b, v)
      println(r2)
    }
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
