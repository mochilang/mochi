// Generated by Mochi v0.10.63 on 2025-08-12 08:52:36 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class DecodeResult(var data: ArrayBuffer[BigInt], var ack: Boolean)

def index_of(s: String, ch: String): BigInt = {
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).size)) {
    if (s.slice((i.toInt).toInt, (i.toInt).toInt + 1) == ch) {
      return i
    }
    i = i + BigInt(1)
  }
  return -BigInt(1)
}

def ord(ch: String): BigInt = {
  val upper: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  val lower: String = "abcdefghijklmnopqrstuvwxyz"
  var idx: BigInt = index_of(upper, ch)
  if (idx >= BigInt(0)) {
    return BigInt(65) + idx
  }
  idx = index_of(lower, ch)
  if (idx >= BigInt(0)) {
    return BigInt(97) + idx
  }
  return BigInt(0)
}

def chr(n: BigInt): String = {
  val upper: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  val lower: String = "abcdefghijklmnopqrstuvwxyz"
  if ((n >= BigInt(65) && n < BigInt(91)).asInstanceOf[Boolean]) {
    return upper.slice((n - BigInt(65)).toInt, (n - BigInt(64)).toInt)
  }
  if ((n >= BigInt(97) && n < BigInt(123)).asInstanceOf[Boolean]) {
    return lower.slice((n - BigInt(97)).toInt, (n - BigInt(96)).toInt)
  }
  return "?"
}

def text_to_bits(text: String): String = {
  var bits: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((text).size)) {
    val code: BigInt = ord((text.slice((i.toInt).toInt, (i.toInt).toInt + 1)).toString)
    var j: BigInt = BigInt(7)
    while (j >= BigInt(0)) {
      val p: BigInt = pow2(j)
      if (code / p % BigInt(2) == BigInt(1)) {
        bits = bits + "1"
      } else {
        bits = bits + "0"
      }
      j = j - BigInt(1)
    }
    i = i + BigInt(1)
  }
  return bits
}

def text_from_bits(bits: String): String = {
  var text: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((bits).size)) {
    var code: BigInt = BigInt(0)
    var j: BigInt = BigInt(0)
    while (j < BigInt(8) && i + j < BigInt((bits).size)) {
      code = code * BigInt(2)
      if (bits.slice(((i + j).toInt).toInt, ((i + j).toInt).toInt + 1) == "1") {
        code = code + BigInt(1)
      }
      j = j + BigInt(1)
    }
    text = text + chr(code)
    i = i + BigInt(8)
  }
  return text
}

def bool_to_string(b: Boolean): String = {
  if (b) {
    return "True"
  }
  return "False"
}

def string_to_bitlist(s: String): ArrayBuffer[BigInt] = {
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).size)) {
    if (s.slice((i.toInt).toInt, (i.toInt).toInt + 1) == "1") {
      res = res :+ (BigInt(1))
    } else {
      res = res :+ (BigInt(0))
    }
    i = i + BigInt(1)
  }
  return res
}

def bitlist_to_string(bits: ArrayBuffer[BigInt]): String = {
  var s: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((bits).size)) {
    if (bits.lift((i.toInt).toInt).getOrElse(BigInt(0)) == BigInt(1)) {
      s = s + "1"
    } else {
      s = s + "0"
    }
    i = i + BigInt(1)
  }
  return s
}

def is_power_of_two(x: BigInt): Boolean = {
  if (x < BigInt(1)) {
    return false
  }
  var p: BigInt = BigInt(1)
  while (p < x) {
    p = p * BigInt(2)
  }
  return p == x
}

def list_eq(a: ArrayBuffer[BigInt], b: ArrayBuffer[BigInt]): Boolean = {
  if (BigInt((a).size) != BigInt((b).size)) {
    return false
  }
  var i: BigInt = BigInt(0)
  while (i < BigInt((a).size)) {
    if (a.lift((i.toInt).toInt).getOrElse(BigInt(0)) != b.lift((i.toInt).toInt).getOrElse(BigInt(0))) {
      return false
    }
    i = i + BigInt(1)
  }
  return true
}

def pow2(e: BigInt): BigInt = {
  var res: BigInt = BigInt(1)
  var i: BigInt = BigInt(0)
  while (i < e) {
    res = res * BigInt(2)
    i = i + BigInt(1)
  }
  return res
}

def has_bit(n: BigInt, b: BigInt): Boolean = {
  val p: BigInt = pow2(b)
  if (n / p % BigInt(2) == BigInt(1)) {
    return true
  }
  return false
}

def hamming_encode(r: BigInt, data_bits: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  val total: BigInt = r + BigInt((data_bits).size)
  var data_ord: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var cont_data: BigInt = BigInt(0)
  var x: BigInt = BigInt(1)
  while (x <= total) {
    if (is_power_of_two(x)) {
      data_ord = data_ord :+ (BigInt((-BigInt(1)).toString.toDouble.toInt))
    } else {
      data_ord = data_ord :+ (data_bits.lift((cont_data.toInt).toInt).getOrElse(BigInt(0)))
      cont_data = cont_data + BigInt(1)
    }
    x = x + BigInt(1)
  }
  var parity: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var bp: BigInt = BigInt(0)
  while (bp < r) {
    var cont_bo: BigInt = BigInt(0)
    var j: BigInt = BigInt(0)
    while (j < BigInt((data_ord).size)) {
      val bit: BigInt = data_ord.lift((j.toInt).toInt).getOrElse(BigInt(0))
      if (bit >= BigInt(0)) {
        val pos: BigInt = j + BigInt(1)
        if ((has_bit(pos, bp) && bit == BigInt(1)).asInstanceOf[Boolean]) {
          cont_bo = cont_bo + BigInt(1)
        }
      }
      j = j + BigInt(1)
    }
    parity = parity :+ (cont_bo % BigInt(2))
    bp = bp + BigInt(1)
  }
  var result: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var cont_bp: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < BigInt((data_ord).size)) {
    if (data_ord.lift((i.toInt).toInt).getOrElse(BigInt(0)) < BigInt(0)) {
      result = result :+ (parity.lift((cont_bp.toInt).toInt).getOrElse(BigInt(0)))
      cont_bp = cont_bp + BigInt(1)
    } else {
      result = result :+ (data_ord.lift((i.toInt).toInt).getOrElse(BigInt(0)))
    }
    i = i + BigInt(1)
  }
  return result
}

def hamming_decode(r: BigInt, code: ArrayBuffer[BigInt]): DecodeResult = {
  var data_output: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var parity_received: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(1)
  var idx: BigInt = BigInt(0)
  while (i <= BigInt((code).size)) {
    if (is_power_of_two(i)) {
      parity_received = parity_received :+ (code.lift((idx.toInt).toInt).getOrElse(BigInt(0)))
    } else {
      data_output = data_output :+ (code.lift((idx.toInt).toInt).getOrElse(BigInt(0)))
    }
    idx = idx + BigInt(1)
    i = i + BigInt(1)
  }
  val recomputed: ArrayBuffer[BigInt] = hamming_encode(r, data_output)
  var parity_calc: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var j: BigInt = BigInt(0)
  while (j < BigInt((recomputed).size)) {
    if (is_power_of_two(j + BigInt(1))) {
      parity_calc = parity_calc :+ (recomputed.lift((j.toInt).toInt).getOrElse(BigInt(0)))
    }
    j = j + BigInt(1)
  }
  val ack: Boolean = list_eq(parity_received, parity_calc)
  return DecodeResult(data_output, ack)
}

def main(): Any = {
  val sizePari: BigInt = BigInt(4)
  val be: BigInt = BigInt(2)
  val text: String = "Message01"
  val binary: String = text_to_bits(text)
  println("Text input in binary is '" + binary + "'")
  val data_bits: ArrayBuffer[BigInt] = string_to_bitlist(binary)
  val encoded: ArrayBuffer[BigInt] = hamming_encode(sizePari, data_bits)
  println("Data converted ----------> " + bitlist_to_string(encoded))
  val decoded: DecodeResult = hamming_decode(sizePari, encoded)
  println("Data receive ------------> " + bitlist_to_string(decoded.asInstanceOf[DecodeResult].data) + " -- Data integrity: " + bool_to_string(decoded.asInstanceOf[DecodeResult].ack))
  var corrupted: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((encoded).size)) {
    corrupted = corrupted :+ (encoded.lift((i.toInt).toInt).getOrElse(BigInt(0)))
    i = i + BigInt(1)
  }
  val pos: BigInt = be - BigInt(1)
  if (corrupted.lift((pos.toInt).toInt).getOrElse(BigInt(0)) == BigInt(0)) {
    corrupted((pos).toInt) = BigInt(1)
  } else {
    corrupted((pos).toInt) = BigInt(0)
  }
  val decoded_err: DecodeResult = hamming_decode(sizePari, corrupted)
  println("Data receive (error) ----> " + bitlist_to_string(decoded_err.asInstanceOf[DecodeResult].data) + " -- Data integrity: " + bool_to_string(decoded_err.asInstanceOf[DecodeResult].ack))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
