// Generated by Mochi v0.10.59 on 2025-08-06 21:24:12 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def compare_string(string1: String, string2: String): String = {
  var result: String = ""
  var count: BigInt = 0
  var i: BigInt = 0
  while (i < BigInt((string1).size)) {
    val c1: String = string1.slice((i).toInt, (i + 1).toInt)
    val c2: String = string2.slice((i).toInt, (i + 1).toInt)
    if (c1 != c2) {
      count = count + 1
      result = result + "_"
    } else {
      result = result + c1
    }
    i = i + 1
  }
  if (count > 1) {
    return ""
  }
  return result
}

def contains_string(arr: ArrayBuffer[String], value: String): Boolean = {
  var i: BigInt = 0
  while (i < BigInt((arr).size)) {
    if (arr((i.toInt).toInt) == value) {
      return true
    }
    i = i + 1
  }
  return false
}

def unique_strings(arr: ArrayBuffer[String]): ArrayBuffer[String] = {
  var res: ArrayBuffer[String] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((arr).size)) {
    if ((!contains_string(res, arr((i.toInt).toInt))).asInstanceOf[Boolean]) {
      res = res :+ arr((i.toInt).toInt)
    }
    i = i + 1
  }
  return res
}

def check(binary: ArrayBuffer[String]): ArrayBuffer[String] = {
  var pi: ArrayBuffer[String] = ArrayBuffer()
  var current: ArrayBuffer[String] = binary
  while (true) {
    var check1: ArrayBuffer[String] = ArrayBuffer()
    var i: BigInt = 0
    while (i < BigInt((current).size)) {
      check1 = check1 :+ "$"
      i = i + 1
    }
    var temp: ArrayBuffer[String] = ArrayBuffer()
    i = 0
    while (i < BigInt((current).size)) {
      var j: BigInt = i + 1
      while (j < BigInt((current).size)) {
        val k: String = compare_string(current((i.toInt).toInt), current((j.toInt).toInt))
        if (k == "") {
          check1((i).toInt) = "*"
          check1((j).toInt) = "*"
          temp = temp :+ "X"
        }
        j = j + 1
      }
      i = i + 1
    }
    i = 0
    while (i < BigInt((current).size)) {
      if (check1((i.toInt).toInt) == "$") {
        pi = pi :+ current((i.toInt).toInt)
      }
      i = i + 1
    }
    if (BigInt((temp).size) == 0) {
      return pi
    }
    current = unique_strings(temp)
  }
  return ArrayBuffer()
}

def decimal_to_binary(no_of_variable: BigInt, minterms: ArrayBuffer[BigInt]): ArrayBuffer[String] = {
  var temp: ArrayBuffer[String] = ArrayBuffer()
  var idx: BigInt = 0
  while (idx < BigInt((minterms).size)) {
    var minterm: BigInt = minterms((idx.toInt).toInt)
    var string: String = ""
    var i: BigInt = 0
    while (i < no_of_variable) {
      string = String.valueOf(minterm % 2) + string
      minterm = minterm / 2
      i = i + 1
    }
    temp = temp :+ string
    idx = idx + 1
  }
  return temp
}

def is_for_table(string1: String, string2: String, count: BigInt): Boolean = {
  var count_n: BigInt = 0
  var i: BigInt = 0
  while (i < BigInt((string1).size)) {
    val c1: String = string1.slice((i).toInt, (i + 1).toInt)
    val c2: String = string2.slice((i).toInt, (i + 1).toInt)
    if (c1 != c2) {
      count_n = count_n + 1
    }
    i = i + 1
  }
  return count_n == count
}

def count_ones(row: ArrayBuffer[BigInt]): BigInt = {
  var c: BigInt = 0
  var j: BigInt = 0
  while (j < BigInt((row).size)) {
    if (row((j.toInt).toInt) == 1) {
      c = c + 1
    }
    j = j + 1
  }
  return c
}

def selection(chart: ArrayBuffer[ArrayBuffer[BigInt]], prime_implicants: ArrayBuffer[String]): ArrayBuffer[String] = {
  var temp: ArrayBuffer[String] = ArrayBuffer()
  var select: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((chart).size)) {
    select = select :+ BigInt(0)
    i = i + 1
  }
  var col: BigInt = 0
  while (col < BigInt((chart((0.toInt).toInt)).size)) {
    var count: BigInt = 0
    var row: BigInt = 0
    while (row < BigInt((chart).size)) {
      if (chart((row.toInt).toInt)((col.toInt).toInt) == 1) {
        count = count + 1
      }
      row = row + 1
    }
    if (count == 1) {
      var rem: BigInt = 0
      row = 0
      while (row < BigInt((chart).size)) {
        if (chart((row.toInt).toInt)((col.toInt).toInt) == 1) {
          rem = row
        }
        row = row + 1
      }
      select((rem).toInt) = 1
    }
    col = col + 1
  }
  i = 0
  while (i < BigInt((select).size)) {
    if (select((i.toInt).toInt) == 1) {
      var j: BigInt = 0
      while (j < BigInt((chart((0.toInt).toInt)).size)) {
        if (chart((i.toInt).toInt)((j.toInt).toInt) == 1) {
          var r: BigInt = 0
          while (r < BigInt((chart).size)) {
            chart((r).toInt)((j).toInt) = 0
            r = r + 1
          }
        }
        j = j + 1
      }
      temp = temp :+ prime_implicants((i.toInt).toInt)
    }
    i = i + 1
  }
  while (true) {
    var counts: ArrayBuffer[BigInt] = ArrayBuffer()
    var r: BigInt = 0
    while (r < BigInt((chart).size)) {
      counts = counts :+ count_ones(chart((r.toInt).toInt))
      r = r + 1
    }
    var max_n: BigInt = counts((0.toInt).toInt)
    var rem: BigInt = 0
    var k: BigInt = 1
    while (k < BigInt((counts).size)) {
      if (counts((k.toInt).toInt) > max_n) {
        max_n = counts((k.toInt).toInt)
        rem = k
      }
      k = k + 1
    }
    if (max_n == 0) {
      return temp
    }
    temp = temp :+ prime_implicants((rem.toInt).toInt)
    var j: BigInt = 0
    while (j < BigInt((chart((0.toInt).toInt)).size)) {
      if (chart((rem.toInt).toInt)((j.toInt).toInt) == 1) {
        var r2: BigInt = 0
        while (r2 < BigInt((chart).size)) {
          chart((r2).toInt)((j).toInt) = 0
          r2 = r2 + 1
        }
      }
      j = j + 1
    }
  }
  return ArrayBuffer()
}

def count_char(s: String, ch: String): BigInt = {
  var cnt: BigInt = 0
  var i: BigInt = 0
  while (i < BigInt((s).size)) {
    if (s.slice((i).toInt, (i + 1).toInt) == ch) {
      cnt = cnt + 1
    }
    i = i + 1
  }
  return cnt
}

def prime_implicant_chart(prime_implicants: ArrayBuffer[String], binary: ArrayBuffer[String]): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var chart: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt((prime_implicants).size)) {
    var row: ArrayBuffer[BigInt] = ArrayBuffer()
    var j: BigInt = 0
    while (j < BigInt((binary).size)) {
      row = row :+ BigInt(0)
      j = j + 1
    }
    chart = chart :+ row
    i = i + 1
  }
  i = 0
  while (i < BigInt((prime_implicants).size)) {
    val count: BigInt = count_char(prime_implicants((i.toInt).toInt), "_")
    var j: BigInt = 0
    while (j < BigInt((binary).size)) {
      if (is_for_table(prime_implicants((i.toInt).toInt), binary((j.toInt).toInt), count)) {
        chart((i).toInt)((j).toInt) = 1
      }
      j = j + 1
    }
    i = i + 1
  }
  return chart
}

def main(): Any = {
  val no_of_variable: BigInt = 3
  val minterms: ArrayBuffer[BigInt] = ArrayBuffer(1, 5, 7)
  val binary: ArrayBuffer[String] = decimal_to_binary(no_of_variable, minterms)
  val prime_implicants: ArrayBuffer[String] = check(binary)
  println("Prime Implicants are:")
  println(String.valueOf(prime_implicants))
  val chart: ArrayBuffer[ArrayBuffer[BigInt]] = prime_implicant_chart(prime_implicants, binary)
  val essential_prime_implicants: ArrayBuffer[String] = selection(chart, prime_implicants)
  println("Essential Prime Implicants are:")
  println(String.valueOf(essential_prime_implicants))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
