// Generated by Mochi v0.10.59 on 2025-08-06 21:26:43 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def rand(): BigInt = {
  seed = (seed * 1103515245 + 12345) % BigInt("2147483648")
  return seed
}

def randint(a: BigInt, b: BigInt): BigInt = {
  val r: BigInt = rand()
  return a + r % (b - a + 1)
}

def random(): Double = {
  return 1.0 * (rand()).toString.toDouble / 2147483648.0
}

def construct_highway(number_of_cells: BigInt, frequency: BigInt, _initial_speed: BigInt, random_frequency: Boolean, random_speed: Boolean, max_speed: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var initial_speed: BigInt = _initial_speed
  var row: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < number_of_cells) {
    row = row :+ BigInt((-1).toString.toDouble.toInt)
    i = i + 1
  }
  var highway: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
  highway = highway :+ row
  i = 0
  if (initial_speed < 0) {
    initial_speed = 0
  }
  while (i < number_of_cells) {
    var speed: BigInt = initial_speed
    if (random_speed) {
      speed = randint(0, max_speed)
    }
    highway((0).toInt)((i).toInt) = speed
    var step: BigInt = frequency
    if (random_frequency) {
      step = randint(1, max_speed * 2)
    }
    i = i + step
  }
  return highway
}

def get_distance(highway_now: ArrayBuffer[BigInt], car_index: BigInt): BigInt = {
  var distance: BigInt = 0
  var i: BigInt = car_index + 1
  while (i < BigInt((highway_now).size)) {
    if (highway_now((i.toInt).toInt) > NEG_ONE) {
      return distance
    }
    distance = distance + 1
    i = i + 1
  }
  return distance + get_distance(highway_now, BigInt((-1).toString.toDouble.toInt))
}

def update(highway_now: ArrayBuffer[BigInt], probability: Double, max_speed: BigInt): ArrayBuffer[BigInt] = {
  val number_of_cells: BigInt = BigInt((highway_now).size)
  var next_highway: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = 0
  while (i < number_of_cells) {
    next_highway = next_highway :+ BigInt((-1).toString.toDouble.toInt)
    i = i + 1
  }
  var car_index: BigInt = 0
  while (car_index < number_of_cells) {
    val speed: BigInt = highway_now((car_index.toInt).toInt)
    if (speed > NEG_ONE) {
      var new_speed: BigInt = speed + 1
      if (new_speed > max_speed) {
        new_speed = max_speed
      }
      val dn: BigInt = get_distance(highway_now, car_index) - 1
      if (new_speed > dn) {
        new_speed = dn
      }
      if (random() < probability) {
        new_speed = new_speed - 1
        if (new_speed < 0) {
          new_speed = 0
        }
      }
      next_highway((car_index).toInt) = new_speed
    }
    car_index = car_index + 1
  }
  return next_highway
}

def simulate(_highway: ArrayBuffer[ArrayBuffer[BigInt]], number_of_update: BigInt, probability: Double, max_speed: BigInt): ArrayBuffer[ArrayBuffer[BigInt]] = {
  var highway: ArrayBuffer[ArrayBuffer[BigInt]] = _highway
  val number_of_cells: BigInt = BigInt((highway((0.toInt).toInt)).size)
  var i: BigInt = 0
  while (i < number_of_update) {
    val next_speeds: ArrayBuffer[BigInt] = update(highway((i.toInt).toInt), probability, max_speed)
    var real_next: ArrayBuffer[BigInt] = ArrayBuffer()
    var j: BigInt = 0
    while (j < number_of_cells) {
      real_next = real_next :+ BigInt((-1).toString.toDouble.toInt)
      j = j + 1
    }
    var k: BigInt = 0
    while (k < number_of_cells) {
      val speed: BigInt = next_speeds((k.toInt).toInt)
      if (speed > NEG_ONE) {
        val index: BigInt = (k + speed) % number_of_cells
        real_next((index).toInt) = speed
      }
      k = k + 1
    }
    highway = highway :+ real_next
    i = i + 1
  }
  return highway
}

def main(): Any = {
  val ex1: ArrayBuffer[ArrayBuffer[BigInt]] = simulate(construct_highway(6, 3, 0, false, false, 2), 2, 0.0, 2)
  println(String.valueOf(ex1))
  val ex2: ArrayBuffer[ArrayBuffer[BigInt]] = simulate(construct_highway(5, 2, BigInt((-2).toString.toDouble.toInt), false, false, 2), 3, 0.0, 2)
  println(String.valueOf(ex2))
}

var seed: BigInt = 1

val NEG_ONE = -1

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
