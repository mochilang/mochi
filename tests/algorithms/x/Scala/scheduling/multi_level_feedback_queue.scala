// Generated by Mochi v0.10.63 on 2025-08-11 16:31:14 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case d: Double => if (d.isWhole) d.toLong.toString else d.toString
  case other => String.valueOf(other)
}

case class Process(var process_name: String, var arrival_time: BigInt, var stop_time: BigInt, var burst_time: BigInt, var waiting_time: BigInt, var turnaround_time: BigInt)

case class MLFQ(var number_of_queues: BigInt, var time_slices: ArrayBuffer[BigInt], var ready_queue: ArrayBuffer[Process], var current_time: BigInt, var finish_queue: ArrayBuffer[Process])

case class RRResult(var finished: ArrayBuffer[Process], var ready: ArrayBuffer[Process])

def make_process(name: String, arrival: BigInt, burst: BigInt): Process = {
  return Process(name, arrival, arrival, burst, BigInt(0), BigInt(0))
}

def make_mlfq(nqueues: BigInt, time_slices: ArrayBuffer[BigInt], queue: ArrayBuffer[Process], current_time: BigInt): MLFQ = {
  return MLFQ(nqueues, time_slices, queue, current_time, ArrayBuffer())
}

def calculate_sequence_of_finish_queue(mlfq: MLFQ): ArrayBuffer[String] = {
  var seq: ArrayBuffer[String] = ArrayBuffer[String]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((mlfq.finish_queue).size)) {
    val p: Process = mlfq.finish_queue.lift((i.toInt).toInt).getOrElse(null)
    seq = seq :+ (p.asInstanceOf[Process].process_name)
    i = i + BigInt(1)
  }
  return seq
}

def calculate_waiting_time(queue: ArrayBuffer[Process]): ArrayBuffer[BigInt] = {
  var times: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((queue).size)) {
    val p: Process = queue.lift((i.toInt).toInt).getOrElse(null)
    times = times :+ (p.asInstanceOf[Process].waiting_time)
    i = i + BigInt(1)
  }
  return times
}

def calculate_turnaround_time(queue: ArrayBuffer[Process]): ArrayBuffer[BigInt] = {
  var times: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((queue).size)) {
    val p: Process = queue.lift((i.toInt).toInt).getOrElse(null)
    times = times :+ (p.asInstanceOf[Process].turnaround_time)
    i = i + BigInt(1)
  }
  return times
}

def calculate_completion_time(queue: ArrayBuffer[Process]): ArrayBuffer[BigInt] = {
  var times: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((queue).size)) {
    val p: Process = queue.lift((i.toInt).toInt).getOrElse(null)
    times = times :+ (p.asInstanceOf[Process].stop_time)
    i = i + BigInt(1)
  }
  return times
}

def calculate_remaining_burst_time_of_processes(queue: ArrayBuffer[Process]): ArrayBuffer[BigInt] = {
  var times: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((queue).size)) {
    val p: Process = queue.lift((i.toInt).toInt).getOrElse(null)
    times = times :+ (p.asInstanceOf[Process].burst_time)
    i = i + BigInt(1)
  }
  return times
}

def update_waiting_time(mlfq: MLFQ, process: Process): BigInt = {
  process.asInstanceOf[Process].waiting_time = process.asInstanceOf[Process].waiting_time + (mlfq.current_time - process.asInstanceOf[Process].stop_time)
  return process.asInstanceOf[Process].waiting_time
}

def first_come_first_served(mlfq: MLFQ, ready_queue: ArrayBuffer[Process]): ArrayBuffer[Process] = {
  var finished: ArrayBuffer[Process] = ArrayBuffer[Process]()
  var rq: ArrayBuffer[Process] = ready_queue
  while (BigInt((rq).size) != BigInt(0)) {
    var cp: Process = rq.lift((BigInt(0).toInt).toInt).getOrElse(null)
    rq = rq.slice((BigInt(1)).toInt, (BigInt((rq).size)).toInt)
    if (mlfq.current_time < cp.asInstanceOf[Process].arrival_time) {
      mlfq.current_time = cp.asInstanceOf[Process].arrival_time
    }
    update_waiting_time(mlfq, cp)
    mlfq.current_time = mlfq.current_time + cp.asInstanceOf[Process].burst_time
    cp.asInstanceOf[Process].burst_time = BigInt(0)
    cp.asInstanceOf[Process].turnaround_time = mlfq.current_time - cp.asInstanceOf[Process].arrival_time
    cp.asInstanceOf[Process].stop_time = mlfq.current_time
    finished = finished :+ (cp)
  }
  mlfq.finish_queue = (mlfq.finish_queue ++ finished).asInstanceOf[ArrayBuffer[Process]]
  return finished
}

def round_robin(mlfq: MLFQ, ready_queue: ArrayBuffer[Process], time_slice: BigInt): RRResult = {
  var finished: ArrayBuffer[Process] = ArrayBuffer[Process]()
  var rq: ArrayBuffer[Process] = ready_queue
  var count: BigInt = BigInt((rq).size)
  var i: BigInt = BigInt(0)
  while (i < count) {
    var cp: Process = rq.lift((BigInt(0).toInt).toInt).getOrElse(null)
    rq = rq.slice((BigInt(1)).toInt, (BigInt((rq).size)).toInt)
    if (mlfq.current_time < cp.asInstanceOf[Process].arrival_time) {
      mlfq.current_time = cp.asInstanceOf[Process].arrival_time
    }
    update_waiting_time(mlfq, cp)
    if (cp.asInstanceOf[Process].burst_time > time_slice) {
      mlfq.current_time = mlfq.current_time + time_slice
      cp.asInstanceOf[Process].burst_time = cp.asInstanceOf[Process].burst_time - time_slice
      cp.asInstanceOf[Process].stop_time = mlfq.current_time
      rq = rq :+ (cp)
    } else {
      mlfq.current_time = mlfq.current_time + cp.asInstanceOf[Process].burst_time
      cp.asInstanceOf[Process].burst_time = BigInt(0)
      cp.asInstanceOf[Process].stop_time = mlfq.current_time
      cp.asInstanceOf[Process].turnaround_time = mlfq.current_time - cp.asInstanceOf[Process].arrival_time
      finished = finished :+ (cp)
    }
    i = i + BigInt(1)
  }
  mlfq.finish_queue = (mlfq.finish_queue ++ finished).asInstanceOf[ArrayBuffer[Process]]
  return RRResult(finished, rq)
}

def multi_level_feedback_queue(mlfq: MLFQ): ArrayBuffer[Process] = {
  var i: BigInt = BigInt(0)
  while (i < mlfq.number_of_queues - BigInt(1)) {
    val rr: RRResult = round_robin(mlfq, mlfq.ready_queue, mlfq.time_slices.lift((i.toInt).toInt).getOrElse(null))
    mlfq.ready_queue = rr.asInstanceOf[RRResult].ready
    i = i + BigInt(1)
  }
  first_come_first_served(mlfq, mlfq.ready_queue)
  return mlfq.finish_queue
}

val P1: Process = make_process("P1", BigInt(0), BigInt(53))

val P2: Process = make_process("P2", BigInt(0), BigInt(17))

val P3: Process = make_process("P3", BigInt(0), BigInt(68))

val P4: Process = make_process("P4", BigInt(0), BigInt(24))

val number_of_queues: BigInt = BigInt(3)

val time_slices: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(17), BigInt(25))

val queue: ArrayBuffer[Process] = ArrayBuffer(P1, P2, P3, P4)

val mlfq: MLFQ = make_mlfq(number_of_queues, time_slices, queue, BigInt(0))

val finish_queue: ArrayBuffer[Process] = multi_level_feedback_queue(mlfq)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    println("waiting time:\t\t\t" + _str(calculate_waiting_time(ArrayBuffer(P1, P2, P3, P4))))
    println("completion time:\t\t" + _str(calculate_completion_time(ArrayBuffer(P1, P2, P3, P4))))
    println("turnaround time:\t\t" + _str(calculate_turnaround_time(ArrayBuffer(P1, P2, P3, P4))))
    println("sequence of finished processes:\t" + _str(calculate_sequence_of_finish_queue(mlfq)))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
