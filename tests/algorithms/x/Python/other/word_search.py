# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 17:42 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class WordSearch:
    words: [string]
    width: int
    height: int
    board: [[string]]

seed = 123456789
def rand():
    global seed
    seed = (seed * 1103515245 + 12345) % 2147483648
    return seed
def rand_range(max):
    return rand() % max
def shuffle(list_int):
    i = len(list_int) - 1
    while i > 0:
        j = rand_range(i + 1)
        tmp = list_int[i]
        list_int[i] = list_int[j]
        list_int[j] = tmp
        i = i - 1
    return list_int
def rand_letter():
    letters = "abcdefghijklmnopqrstuvwxyz"
    i = rand_range(26)
    return letters[i:i + 1]
def make_word_search(words, width, height):
    board = []
    r = 0
    while r < height:
        row = []
        c = 0
        while c < width:
            row = _append(row, "")
            c = c + 1
        board = _append(board, row)
        r = r + 1
    return WordSearch(words=words, width=width, height=height, board=board)
def insert_dir(ws, word, dr, dc, rows, cols):
    word_len = len(word)
    ri = 0
    while ri < len(rows):
        row = rows[ri]
        ci = 0
        while ci < len(cols):
            col = cols[ci]
            end_r = row + dr * (word_len - 1)
            end_c = col + dc * (word_len - 1)
            if end_r < 0 or end_r >= ws.height or end_c < 0 or end_c >= ws.width:
                ci = ci + 1
                continue
            k = 0
            ok = True
            while k < word_len:
                rr = row + dr * k
                cc = col + dc * k
                if ws.board[rr][cc] != "":
                    ok = False
                    break
                k = k + 1
            if ok:
                k = 0
                while k < word_len:
                    rr2 = row + dr * k
                    cc2 = col + dc * k
                    row_list = ws.board[rr2]
                    row_list[cc2] = word[k:k + 1]
                    k = k + 1
                return True
            ci = ci + 1
        ri = ri + 1
    return False
def generate_board(ws):
    dirs_r = [-1, -1, 0, 1, 1, 1, 0, -1]
    dirs_c = [0, 1, 1, 1, 0, -1, -1, -1]
    i = 0
    while i < len(ws.words):
        word = ws.words[i]
        rows = []
        r = 0
        while r < ws.height:
            rows = _append(rows, r)
            r = r + 1
        cols = []
        c = 0
        while c < ws.width:
            cols = _append(cols, c)
            c = c + 1
        rows = shuffle(rows)
        cols = shuffle(cols)
        d = rand_range(8)
        insert_dir(ws, word, dirs_r[d], dirs_c[d], rows, cols)
        i = i + 1
def visualise(ws, add_fake_chars):
    result = ""
    r = 0
    while r < ws.height:
        c = 0
        while c < ws.width:
            ch = ws.board[r][c]
            if ch == "":
                if add_fake_chars:
                    ch = rand_letter()
                else:
                    ch = "#"
            result = result + ch + " "
            c = c + 1
        result = result + "\n"
        r = r + 1
    return result
def main():
    words = ["cat", "dog", "snake", "fish"]
    ws = make_word_search(words, 10, 10)
    generate_board(ws)
    print(visualise(ws, True))
main()
