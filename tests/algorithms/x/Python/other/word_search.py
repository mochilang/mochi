# Code generated by Mochi transpiler.
# Version 0.10.73, generated on 2025-08-25 23:46 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    lst.append(v)
    return lst


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class WordSearch:
    words: List[str]
    width: int
    height: int
    board: List[List[str]]

seed = 123456789
def rand():
    global seed
    seed = (seed * 1103515245 + 12345) % 2147483648
    return seed
def rand_range(max_):
    return rand() % max_
def shuffle(list_int):
    i = len(list_int) - 1
    while i > 0:
        j = rand_range(i + 1)
        tmp = list_int[i]
        list_int[i] = list_int[j]
        list_int[j] = tmp
        i = i - 1
    return list_int
def rand_letter():
    letters = "abcdefghijklmnopqrstuvwxyz"
    i = rand_range(26)
    return letters[i:i + 1]
def make_word_search(words, width, height):
    board = []
    r = 0
    while r < height:
        row = []
        c = 0
        while c < width:
            row = _append(row, "")
            c = c + 1
        board = _append(board, row)
        r = r + 1
    return WordSearch(words=words, width=width, height=height, board=board)
def insert_dir(ws, word, dr, dc, rows, cols):
    word_len = len(word)
    ri = 0
    while ri < len(rows):
        row = rows[ri]
        ci = 0
        while ci < len(cols):
            col = cols[ci]
            end_r = row + dr * (word_len - 1)
            end_c = col + dc * (word_len - 1)
            if end_r < 0 or end_r >= ws.height or end_c < 0 or end_c >= ws.width:
                ci = ci + 1
                continue
            k = 0
            ok = True
            while k < word_len:
                rr = row + dr * k
                cc = col + dc * k
                if ws.board[rr][cc] != "":
                    ok = False
                    break
                k = k + 1
            if ok:
                k = 0
                while k < word_len:
                    rr2 = row + dr * k
                    cc2 = col + dc * k
                    row_list = ws.board[rr2]
                    row_list[cc2] = word[k:k + 1]
                    k = k + 1
                return True
            ci = ci + 1
        ri = ri + 1
    return False
def generate_board(ws):
    dirs_r = [-1, -1, 0, 1, 1, 1, 0, -1]
    dirs_c = [0, 1, 1, 1, 0, -1, -1, -1]
    i = 0
    while i < len(ws.words):
        word = ws.words[i]
        rows = []
        r = 0
        while r < ws.height:
            rows = _append(rows, r)
            r = r + 1
        cols = []
        c = 0
        while c < ws.width:
            cols = _append(cols, c)
            c = c + 1
        rows = shuffle(rows)
        cols = shuffle(cols)
        d = rand_range(8)
        insert_dir(ws, word, dirs_r[d], dirs_c[d], rows, cols)
        i = i + 1
def visualise(ws, add_fake_chars):
    result = ""
    r = 0
    while r < ws.height:
        c = 0
        while c < ws.width:
            ch = ws.board[r][c]
            if ch == "":
                if add_fake_chars:
                    ch = rand_letter()
                else:
                    ch = "#"
            result = result + ch + " "
            c = c + 1
        result = result + "\n"
        r = r + 1
    return result
def main():
    if resource:
        _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_start = 0
    _bench_start = _now()
    try:
        words = ["cat", "dog", "snake", "fish"]
        ws = make_word_search(words, 10, 10)
        generate_board(ws)
        print(visualise(ws, True))
    finally:
        _bench_end = _now()
        if resource:
            _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        else:
            _bench_mem_end = 0
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": (_bench_mem_end - _bench_mem_start)*1024, "name": "main"}, indent=2))
main()

