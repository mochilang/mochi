# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 09:25 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class Clause:
        literals: Dict[str, int]
        names: [string]
    def new_clause(lits):
        m = {}
        names = []
        i = 0
        while i < len(lits):
            lit = lits[i]
            m[lit] = 0 - 1
            names = _append(names, lit)
            i = i + 1
        return Clause(literals=m, names=names)
    def assign_clause(c, model):
        lits = c.literals
        i = 0
        while i < len(c.names):
            lit = c.names[i]
            symbol = lit[0:2]
            if symbol in model:
                value = model.get(symbol, 0)
                if lit[len(lit) - 1:len(lit)] == "'" and value != 0 - 1:
                    value = 1 - value
                lits[lit] = value
            i = i + 1
        c.literals = lits
        return c
    @dataclass
    class EvalResult:
        value: int
        clause: Clause
    def evaluate_clause(c, model):
        i = 0
        while i < len(c.names):
            lit = c.names[i]
            sym = (lit[0:2] if lit[len(lit) - 1:len(lit)] == "'" else lit + "'")
            if sym in c.literals:
                return EvalResult(value=1, clause=c)
            i = i + 1
        c = assign_clause(c, model)
        i = 0
        while i < len(c.names):
            lit = c.names[i]
            value = c.literals[lit]
            if value == 1:
                return EvalResult(value=1, clause=c)
            if value == 0 - 1:
                return EvalResult(value=0 - 1, clause=c)
            i = i + 1
        any_true = 0
        i = 0
        while i < len(c.names):
            lit = c.names[i]
            if c.literals[lit] == 1:
                any_true = 1
            i = i + 1
        return EvalResult(value=any_true, clause=c)
    @dataclass
    class Formula:
        clauses: [Clause]
    def new_formula(cs):
        return Formula(clauses=cs)
    @dataclass
    class DPLLResult:
        sat: bool
        model: Dict[str, int]
    def remove_symbol(symbols, s):
        res = []
        i = 0
        while i < len(symbols):
            if symbols[i] != s:
                res = _append(res, symbols[i])
            i = i + 1
        return res
    def dpll_algorithm(clauses, symbols, model):
        all_true = True
        i = 0
        while i < len(clauses):
            ev = evaluate_clause(clauses[i], model)
            clauses = _set_index(clauses, i, ev.clause)
            if ev.value == 0:
                return DPLLResult(sat=False, model={})
            else:
                if ev.value == 0 - 1:
                    all_true = False
            i = i + 1
        if all_true:
            return DPLLResult(sat=True, model=model)
        p = symbols[0]
        rest = remove_symbol(symbols, p)
        tmp1 = model
        tmp2 = model
        tmp1[p] = 1
        tmp2[p] = 0
        res1 = dpll_algorithm(clauses, rest, tmp1)
        if res1.sat:
            return res1
        return dpll_algorithm(clauses, rest, tmp2)
    def str_clause(c):
        line = "{"
        first = True
        i = 0
        while i < len(c.names):
            lit = c.names[i]
            if first:
                first = False
            else:
                line = line + " , "
            line = line + lit
            i = i + 1
        line = line + "}"
        return line
    def str_formula(f):
        line = "{"
        i = 0
        while i < len(f.clauses):
            line = line + str_clause(f.clauses[i])
            if i < len(f.clauses) - 1:
                line = line + " , "
            i = i + 1
        line = line + "}"
        return line
    clause1 = new_clause(["A4", "A3", "A5'", "A1", "A3'"])
    clause2 = new_clause(["A4"])
    formula = new_formula([clause1, clause2])
    formula_str = str_formula(formula)
    clauses = [clause1, clause2]
    symbols = ["A4", "A3", "A5", "A1"]
    model = {}
    result = dpll_algorithm(clauses, symbols, model)
    if result.sat:
        print("The formula " + formula_str + " is satisfiable.")
    else:
        print("The formula " + formula_str + " is not satisfiable.")
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

