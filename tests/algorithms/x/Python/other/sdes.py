# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 17:42 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)

def apply_table(inp, table):
    res = ""
    i = 0
    while i < len(table):
        idx = table[i] - 1
        if idx < 0:
            idx = len(inp) - 1
        res = res + inp[idx:idx + 1]
        i = i + 1
    return res
def left_shift(data):
    return data[1:len(data)] + data[0:1]
def xor(a, b):
    res = ""
    i = 0
    while i < len(a) and i < len(b):
        if a[i:i + 1] == b[i:i + 1]:
            res = res + "0"
        else:
            res = res + "1"
        i = i + 1
    return res
def int_to_binary(n):
    if n == 0:
        return "0"
    res = ""
    num = n
    while num > 0:
        res = _str(num % 2) + res
        num = num // 2
    return res
def pad_left(s, width):
    res = s
    while len(res) < width:
        res = "0" + res
    return res
def bin_to_int(s):
    result = 0
    i = 0
    while i < len(s):
        digit = int(s[i:i + 1])
        result = result * 2 + digit
        i = i + 1
    return result
def apply_sbox(s, data):
    row_bits = data[0:1] + data[len(data) - 1:len(data)]
    col_bits = data[1:3]
    row = bin_to_int(row_bits)
    col = bin_to_int(col_bits)
    val = s[row][col]
    out = int_to_binary(val)
    return out
p4_table = [2, 4, 3, 1]
def f(expansion, s0, s1, key, message):
    left = message[0:4]
    right = message[4:8]
    temp = apply_table(right, expansion)
    temp = xor(temp, key)
    left_bin_str = apply_sbox(s0, temp[0:4])
    right_bin_str = apply_sbox(s1, temp[4:8])
    left_bin_str = pad_left(left_bin_str, 2)
    right_bin_str = pad_left(right_bin_str, 2)
    temp = apply_table(left_bin_str + right_bin_str, p4_table)
    temp = xor(left, temp)
    return temp + right
key = "1010000010"
message = "11010111"
p8_table = [6, 3, 7, 4, 8, 5, 10, 9]
p10_table = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]
IP = [2, 6, 3, 1, 4, 8, 5, 7]
IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]
expansion = [4, 1, 2, 3, 2, 3, 4, 1]
s0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]
s1 = [[0, 1, 2, 3], [2, 0, 1, 3], [3, 0, 1, 0], [2, 1, 0, 3]]
temp = apply_table(key, p10_table)
left = temp[0:5]
right = temp[5:10]
left = left_shift(left)
right = left_shift(right)
key1 = apply_table(left + right, p8_table)
left = left_shift(left)
right = left_shift(right)
left = left_shift(left)
right = left_shift(right)
key2 = apply_table(left + right, p8_table)
temp = apply_table(message, IP)
temp = f(expansion, s0, s1, key1, temp)
temp = temp[4:8] + temp[0:4]
temp = f(expansion, s0, s1, key2, temp)
CT = apply_table(temp, IP_inv)
print("Cipher text is: " + CT)
temp = apply_table(CT, IP)
temp = f(expansion, s0, s1, key2, temp)
temp = temp[4:8] + temp[0:4]
temp = f(expansion, s0, s1, key1, temp)
PT = apply_table(temp, IP_inv)
print("Plain text after decypting is: " + PT)
