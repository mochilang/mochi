# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-13 16:39 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    lst.append(v)
    return lst


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".17g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class TransformTables:
    costs: [[int]]
    ops: [[string]]

def string_to_chars(s):
    chars = []
    i = 0
    while i < len(s):
        chars = _append(chars, s[i:i + 1])
        i = i + 1
    return chars
def join_chars(chars):
    res = ""
    i = 0
    while i < len(chars):
        res = res + chars[i]
        i = i + 1
    return res
def insert_at(chars, index, ch):
    res = []
    i = 0
    while i < index:
        res = _append(res, chars[i])
        i = i + 1
    res = _append(res, ch)
    while i < len(chars):
        res = _append(res, chars[i])
        i = i + 1
    return res
def remove_at(chars, index):
    res = []
    i = 0
    while i < len(chars):
        if i != index:
            res = _append(res, chars[i])
        i = i + 1
    return res
def make_matrix_int(rows, cols, init):
    matrix = []
    for _ in range(0, rows):
        row = []
        for _2 in range(0, cols):
            row = _append(row, init)
        matrix = _append(matrix, row)
    return matrix
def make_matrix_string(rows, cols, init):
    matrix = []
    for _ in range(0, rows):
        row = []
        for _2 in range(0, cols):
            row = _append(row, init)
        matrix = _append(matrix, row)
    return matrix
def compute_transform_tables(source_string, destination_string, copy_cost, replace_cost, delete_cost, insert_cost):
    source_seq = string_to_chars(source_string)
    dest_seq = string_to_chars(destination_string)
    m = len(source_seq)
    n = len(dest_seq)
    costs = make_matrix_int(m + 1, n + 1, 0)
    ops = make_matrix_string(m + 1, n + 1, "0")
    i = 1
    while i <= m:
        costs[i][0] = i * delete_cost
        ops[i][0] = "D" + source_seq[i - 1]
        i = i + 1
    j = 1
    while j <= n:
        costs[0][j] = j * insert_cost
        ops[0][j] = "I" + dest_seq[j - 1]
        j = j + 1
    i = 1
    while i <= m:
        j = 1
        while j <= n:
            if source_seq[i - 1] == dest_seq[j - 1]:
                costs[i][j] = costs[i - 1][j - 1] + copy_cost
                ops[i][j] = "C" + source_seq[i - 1]
            else:
                costs[i][j] = costs[i - 1][j - 1] + replace_cost
                ops[i][j] = "R" + source_seq[i - 1] + dest_seq[j - 1]
            if costs[i - 1][j] + delete_cost < costs[i][j]:
                costs[i][j] = costs[i - 1][j] + delete_cost
                ops[i][j] = "D" + source_seq[i - 1]
            if costs[i][j - 1] + insert_cost < costs[i][j]:
                costs[i][j] = costs[i][j - 1] + insert_cost
                ops[i][j] = "I" + dest_seq[j - 1]
            j = j + 1
        i = i + 1
    return TransformTables(costs=costs, ops=ops)
def assemble_transformation(ops, i, j):
    if i == 0 and j == 0:
        return []
    op = ops[i][j]
    kind = op[0:1]
    if kind == "C" or kind == "R":
        seq = assemble_transformation(ops, i - 1, j - 1)
        seq = _append(seq, op)
        return seq
    else:
        if kind == "D":
            seq = assemble_transformation(ops, i - 1, j)
            seq = _append(seq, op)
            return seq
        else:
            seq = assemble_transformation(ops, i, j - 1)
            seq = _append(seq, op)
            return seq
def main():
    copy_cost = -1
    replace_cost = 1
    delete_cost = 2
    insert_cost = 2
    src = "Python"
    dst = "Algorithms"
    tables = compute_transform_tables(src, dst, copy_cost, replace_cost, delete_cost, insert_cost)
    operations = tables.ops
    m = len(operations)
    n = len(operations[0])
    sequence = assemble_transformation(operations, m - 1, n - 1)
    string_list = string_to_chars(src)
    idx = 0
    cost = 0
    k = 0
    while k < len(sequence):
        print(join_chars(string_list))
        op = sequence[k]
        kind = op[0:1]
        if kind == "C":
            cost = cost + copy_cost
        else:
            if kind == "R":
                string_list[idx] = op[2:3]
                cost = cost + replace_cost
            else:
                if kind == "D":
                    string_list = remove_at(string_list, idx)
                    cost = cost + delete_cost
                else:
                    string_list = insert_at(string_list, idx, op[1:2])
                    cost = cost + insert_cost
        idx = idx + 1
        k = k + 1
    print(join_chars(string_list))
    print("Cost: " + _str(cost))
main()

