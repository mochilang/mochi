# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-15 09:59 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class CalcResult:
    ok: bool
    value: float
    error: str

def calc_profit(profit, weight, max_weight):
    if len(profit) != len(weight):
        return CalcResult(ok=False, value=0.0, error="The length of profit and weight must be same.")
    if max_weight <= 0:
        return CalcResult(ok=False, value=0.0, error="max_weight must greater than zero.")
    i = 0
    while i < len(profit):
        if profit[i] < 0:
            return CalcResult(ok=False, value=0.0, error="Profit can not be negative.")
        if weight[i] < 0:
            return CalcResult(ok=False, value=0.0, error="Weight can not be negative.")
        i = i + 1
    used = []
    j = 0
    while j < len(profit):
        used = _append(used, False)
        j = j + 1
    limit = 0
    gain = 0.0
    while limit < max_weight:
        max_ratio = -1.0
        idx = 0 - 1
        k = 0
        while k < len(profit):
            if not used[k]:
                ratio = (float(profit[k])) / (float(weight[k]))
                if ratio > max_ratio:
                    max_ratio = ratio
                    idx = k
            k = k + 1
        if idx == 0 - 1:
            break
        used[idx] = True
        if max_weight - limit >= weight[idx]:
            limit = limit + weight[idx]
            gain = gain + (float(profit[idx]))
        else:
            gain = gain + ((float((max_weight - limit))) / (float(weight[idx]))) * (float(profit[idx]))
            break
    return CalcResult(ok=True, value=gain, error="")
def test_sorted():
    profit = [10, 20, 30, 40, 50, 60]
    weight = [2, 4, 6, 8, 10, 12]
    res = calc_profit(profit, weight, 100)
    return res.ok and res.value == 210.0
def test_negative_max_weight():
    profit = [10, 20, 30, 40, 50, 60]
    weight = [2, 4, 6, 8, 10, 12]
    res = calc_profit(profit, weight, -15)
    return not res.ok and res.error == "max_weight must greater than zero."
def test_negative_profit_value():
    profit = [10, -20, 30, 40, 50, 60]
    weight = [2, 4, 6, 8, 10, 12]
    res = calc_profit(profit, weight, 15)
    return not res.ok and res.error == "Profit can not be negative."
def test_negative_weight_value():
    profit = [10, 20, 30, 40, 50, 60]
    weight = [2, -4, 6, -8, 10, 12]
    res = calc_profit(profit, weight, 15)
    return not res.ok and res.error == "Weight can not be negative."
def test_null_max_weight():
    profit = [10, 20, 30, 40, 50, 60]
    weight = [2, 4, 6, 8, 10, 12]
    res = calc_profit(profit, weight, 0)
    return not res.ok and res.error == "max_weight must greater than zero."
def test_unequal_list_length():
    profit = [10, 20, 30, 40, 50]
    weight = [2, 4, 6, 8, 10, 12]
    res = calc_profit(profit, weight, 100)
    return not res.ok and res.error == "The length of profit and weight must be same."
print(("True" if test_sorted() else "False"))
print(("True" if test_negative_max_weight() else "False"))
print(("True" if test_negative_profit_value() else "False"))
print(("True" if test_negative_weight_value() else "False"))
print(("True" if test_null_max_weight() else "False"))
print(("True" if test_unequal_list_length() else "False"))
print(("True" if True else "False"))

