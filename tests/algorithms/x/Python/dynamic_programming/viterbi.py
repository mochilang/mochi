# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def key(state, obs):
    return state + "|" + obs
def viterbi(observations, states, start_p, trans_p, emit_p):
    if len(observations) == 0 or len(states) == 0:
        panic("empty parameters")
    probs = {}
    ptrs = {}
    first_obs = observations[0]
    i = 0
    while i < len(states):
        state = states[i]
        probs[key(state, first_obs)] = start_p.get(state) * emit_p.get(state).get(first_obs)
        ptrs[key(state, first_obs)] = ""
        i = i + 1
    t = 1
    while t < len(observations):
        obs = observations[t]
        j = 0
        while j < len(states):
            state = states[j]
            max_prob = -1.0
            prev_state = ""
            k = 0
            while k < len(states):
                state0 = states[k]
                obs0 = observations[t - 1]
                prob_prev = probs[key(state0, obs0)]
                prob = prob_prev * trans_p.get(state0).get(state) * emit_p.get(state).get(obs)
                if prob > max_prob:
                    max_prob = prob
                    prev_state = state0
                k = k + 1
            probs[key(state, obs)] = max_prob
            ptrs[key(state, obs)] = prev_state
            j = j + 1
        t = t + 1
    path = []
    n = 0
    while n < len(observations):
        path = _append(path, "")
        n = n + 1
    last_obs = observations[len(observations) - 1]
    max_final = -1.0
    last_state = ""
    m = 0
    while m < len(states):
        state = states[m]
        prob = probs[key(state, last_obs)]
        if prob > max_final:
            max_final = prob
            last_state = state
        m = m + 1
    last_index = len(observations) - 1
    path[last_index] = last_state
    idx = last_index
    while idx > 0:
        obs = observations[idx]
        prev = ptrs[key(path[idx], obs)]
        path[idx - 1] = prev
        idx = idx - 1
    return path
def join_words(words):
    res = ""
    i = 0
    while i < len(words):
        if i > 0:
            res = res + " "
        res = res + words[i]
        i = i + 1
    return res
observations = ["normal", "cold", "dizzy"]
states = ["Healthy", "Fever"]
start_p = {"Healthy": 0.6, "Fever": 0.4}
trans_p = {"Healthy": {"Healthy": 0.7, "Fever": 0.3}, "Fever": {"Healthy": 0.4, "Fever": 0.6}}
emit_p = {"Healthy": {"normal": 0.5, "cold": 0.4, "dizzy": 0.1}, "Fever": {"normal": 0.1, "cold": 0.3, "dizzy": 0.6}}
result = viterbi(observations, states, start_p, trans_p, emit_p)
print(join_words(result))
