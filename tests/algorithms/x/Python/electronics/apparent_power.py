# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))

PI = 3.141592653589793
def abs(x):
    if x < 0.0:
        return -x
    return x
def to_radians(deg):
    return deg * PI / 180.0
def sin_taylor(x):
    term = x
    sum = x
    i = 1
    while i < 10:
        k1 = 2.0 * (float(i))
        k2 = k1 + 1.0
        term = -term * x * x // (k1 * k2)
        sum = sum + term
        i = i + 1
    return sum
def cos_taylor(x):
    term = 1.0
    sum = 1.0
    i = 1
    while i < 10:
        k1 = 2.0 * (float(i)) - 1.0
        k2 = 2.0 * (float(i))
        term = -term * x * x // (k1 * k2)
        sum = sum + term
        i = i + 1
    return sum
def rect(mag, angle):
    c = cos_taylor(angle)
    s = sin_taylor(angle)
    return [mag * c, mag * s]
def multiply(a, b):
    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]]
def apparent_power(voltage, current, voltage_angle, current_angle):
    vrad = to_radians(voltage_angle)
    irad = to_radians(current_angle)
    vrect = rect(voltage, vrad)
    irect = rect(current, irad)
    result = multiply(vrect, irect)
    return result
def approx_equal(a, b, eps):
    return abs(a[0] - b[0]) < eps and abs(a[1] - b[1]) < eps
# test zero phase
s = apparent_power(100.0, 5.0, 0.0, 0.0)
expected = [500.0, 0.0]
assert approx_equal(s, expected, 0.001)
# test orthogonal voltage
s = apparent_power(100.0, 5.0, 90.0, 0.0)
expected = [0.0, 500.0]
assert approx_equal(s, expected, 0.5)
# test negative angles
s = apparent_power(100.0, 5.0, -45.0, -60.0)
expected = [-129.40952255126027, -482.9629131445341]
assert approx_equal(s, expected, 0.001)
# test another case
s = apparent_power(200.0, 10.0, -30.0, -90.0)
expected = [-1000.0, -1732.0508075688776]
assert approx_equal(s, expected, 0.001)
