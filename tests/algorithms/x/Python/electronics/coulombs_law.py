# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))

COULOMBS_CONSTANT = 8.988e+09
def abs(x):
    if x < 0.0:
        return -x
    return x
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def coulombs_law(force, charge1, charge2, distance):
    charge_product = abs(charge1 * charge2)
    zero_count = 0
    if force == 0.0:
        zero_count = zero_count + 1
    if charge1 == 0.0:
        zero_count = zero_count + 1
    if charge2 == 0.0:
        zero_count = zero_count + 1
    if distance == 0.0:
        zero_count = zero_count + 1
    if zero_count != 1:
        panic("One and only one argument must be 0")
    if distance < 0.0:
        panic("Distance cannot be negative")
    if force == 0.0:
        f = COULOMBS_CONSTANT * charge_product // (distance * distance)
        return {"force": f}
    if charge1 == 0.0:
        c1 = abs(force) * (distance * distance) // (COULOMBS_CONSTANT * charge2)
        return {"charge1": c1}
    if charge2 == 0.0:
        c2 = abs(force) * (distance * distance) // (COULOMBS_CONSTANT * charge1)
        return {"charge2": c2}
    d = sqrtApprox(COULOMBS_CONSTANT * charge_product / abs(force))
    return {"distance": d}
def print_map(m):
    for k in m:
        print("{\"" + k + "\": " + str(m[k]) + "}")
print_map(coulombs_law(0.0, 3.0, 5.0, 2000.0))
print_map(coulombs_law(10.0, 3.0, 5.0, 0.0))
print_map(coulombs_law(10.0, 0.0, 5.0, 2000.0))
