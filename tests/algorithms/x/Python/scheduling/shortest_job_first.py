# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-11 16:20 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def calculate_waitingtime(arrival_time, burst_time, no_of_processes):
    remaining_time = []
    i = 0
    while i < no_of_processes:
        remaining_time = _append(remaining_time, burst_time[i])
        i = i + 1
    waiting_time = []
    i = 0
    while i < no_of_processes:
        waiting_time = _append(waiting_time, 0)
        i = i + 1
    complete = 0
    increment_time = 0
    minm = 1000000000
    short = 0
    check = False
    while complete != no_of_processes:
        j = 0
        while j < no_of_processes:
            if arrival_time[j] <= increment_time and remaining_time[j] > 0 and remaining_time[j] < minm:
                minm = remaining_time[j]
                short = j
                check = True
            j = j + 1
        if not check:
            increment_time = increment_time + 1
            continue
        remaining_time[short] = remaining_time[short] - 1
        minm = remaining_time[short]
        if minm == 0:
            minm = 1000000000
        if remaining_time[short] == 0:
            complete = complete + 1
            check = False
            finish_time = increment_time + 1
            finar = finish_time - arrival_time[short]
            waiting_time[short] = finar - burst_time[short]
            if waiting_time[short] < 0:
                waiting_time[short] = 0
        increment_time = increment_time + 1
    return waiting_time
def calculate_turnaroundtime(burst_time, no_of_processes, waiting_time):
    turn_around_time = []
    i = 0
    while i < no_of_processes:
        turn_around_time = _append(turn_around_time, burst_time[i] + waiting_time[i])
        i = i + 1
    return turn_around_time
def to_float(x):
    return x * 1.0
def calculate_average_times(waiting_time, turn_around_time, no_of_processes):
    total_waiting_time = 0
    total_turn_around_time = 0
    i = 0
    while i < no_of_processes:
        total_waiting_time = total_waiting_time + waiting_time[i]
        total_turn_around_time = total_turn_around_time + turn_around_time[i]
        i = i + 1
    avg_wait = float(total_waiting_time) / float(no_of_processes)
    avg_turn = float(total_turn_around_time) / float(no_of_processes)
    print("Average waiting time = " + _str(avg_wait))
    print("Average turn around time = " + _str(avg_turn))
print(calculate_waitingtime([1, 2, 3, 4], [3, 3, 5, 1], 4))
print(calculate_waitingtime([1, 2, 3], [2, 5, 1], 3))
print(calculate_waitingtime([2, 3], [5, 1], 2))
print(calculate_turnaroundtime([3, 3, 5, 1], 4, [0, 3, 5, 0]))
print(calculate_turnaroundtime([3, 3], 2, [0, 3]))
print(calculate_turnaroundtime([8, 10, 1], 3, [1, 0, 3]))
calculate_average_times([0, 3, 5, 0], [3, 6, 10, 1], 4)
calculate_average_times([2, 3], [3, 6], 2)
calculate_average_times([10, 4, 3], [2, 7, 6], 3)

