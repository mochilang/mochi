# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-11 16:20 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _concat(a, b):
    if a is None:
        return b
    if b is None:
        return a
    return a + b


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)

@dataclass
class Process:
    process_name: str
    arrival_time: int
    stop_time: int
    burst_time: int
    waiting_time: int
    turnaround_time: int

def make_process(name, arrival, burst):
    return Process(process_name=name, arrival_time=arrival, stop_time=arrival, burst_time=burst, waiting_time=0, turnaround_time=0)
@dataclass
class MLFQ:
    number_of_queues: int
    time_slices: [int]
    ready_queue: [Process]
    current_time: int
    finish_queue: [Process]

def make_mlfq(nqueues, time_slices, queue, current_time):
    return MLFQ(number_of_queues=nqueues, time_slices=time_slices, ready_queue=queue, current_time=current_time, finish_queue=[])
def calculate_sequence_of_finish_queue(mlfq):
    seq = []
    i = 0
    while i < len(mlfq.finish_queue):
        p = mlfq.finish_queue[i]
        seq = _append(seq, p.process_name)
        i = i + 1
    return seq
def calculate_waiting_time(queue):
    times = []
    i = 0
    while i < len(queue):
        p = queue[i]
        times = _append(times, p.waiting_time)
        i = i + 1
    return times
def calculate_turnaround_time(queue):
    times = []
    i = 0
    while i < len(queue):
        p = queue[i]
        times = _append(times, p.turnaround_time)
        i = i + 1
    return times
def calculate_completion_time(queue):
    times = []
    i = 0
    while i < len(queue):
        p = queue[i]
        times = _append(times, p.stop_time)
        i = i + 1
    return times
def calculate_remaining_burst_time_of_processes(queue):
    times = []
    i = 0
    while i < len(queue):
        p = queue[i]
        times = _append(times, p.burst_time)
        i = i + 1
    return times
def update_waiting_time(mlfq, process):
    process.waiting_time = process.waiting_time + (mlfq.current_time - process.stop_time)
    return process.waiting_time
def first_come_first_served(mlfq, ready_queue):
    finished = []
    rq = ready_queue
    while len(rq) != 0:
        cp = rq[0]
        rq = rq[1:len(rq)]
        if mlfq.current_time < cp.arrival_time:
            mlfq.current_time = cp.arrival_time
        update_waiting_time(mlfq, cp)
        mlfq.current_time = mlfq.current_time + cp.burst_time
        cp.burst_time = 0
        cp.turnaround_time = mlfq.current_time - cp.arrival_time
        cp.stop_time = mlfq.current_time
        finished = _append(finished, cp)
    mlfq.finish_queue = _concat(mlfq.finish_queue, finished)
    return finished
@dataclass
class RRResult:
    finished: [Process]
    ready: [Process]

def round_robin(mlfq, ready_queue, time_slice):
    finished = []
    rq = ready_queue
    count = len(rq)
    i = 0
    while i < count:
        cp = rq[0]
        rq = rq[1:len(rq)]
        if mlfq.current_time < cp.arrival_time:
            mlfq.current_time = cp.arrival_time
        update_waiting_time(mlfq, cp)
        if cp.burst_time > time_slice:
            mlfq.current_time = mlfq.current_time + time_slice
            cp.burst_time = cp.burst_time - time_slice
            cp.stop_time = mlfq.current_time
            rq = _append(rq, cp)
        else:
            mlfq.current_time = mlfq.current_time + cp.burst_time
            cp.burst_time = 0
            cp.stop_time = mlfq.current_time
            cp.turnaround_time = mlfq.current_time - cp.arrival_time
            finished = _append(finished, cp)
        i = i + 1
    mlfq.finish_queue = _concat(mlfq.finish_queue, finished)
    return RRResult(finished=finished, ready=rq)
def multi_level_feedback_queue(mlfq):
    i = 0
    while i < mlfq.number_of_queues - 1:
        rr = round_robin(mlfq, mlfq.ready_queue, mlfq.time_slices[i])
        mlfq.ready_queue = rr.ready
        i = i + 1
    first_come_first_served(mlfq, mlfq.ready_queue)
    return mlfq.finish_queue
P1 = make_process("P1", 0, 53)
P2 = make_process("P2", 0, 17)
P3 = make_process("P3", 0, 68)
P4 = make_process("P4", 0, 24)
number_of_queues = 3
time_slices = [17, 25]
queue = [P1, P2, P3, P4]
mlfq = make_mlfq(number_of_queues, time_slices, queue, 0)
finish_queue = multi_level_feedback_queue(mlfq)
print("waiting time:\t\t\t" + _str(calculate_waiting_time([P1, P2, P3, P4])))
print("completion time:\t\t" + _str(calculate_completion_time([P1, P2, P3, P4])))
print("turnaround time:\t\t" + _str(calculate_turnaround_time([P1, P2, P3, P4])))
print("sequence of finished processes:\t" + _str(calculate_sequence_of_finish_queue(mlfq)))

