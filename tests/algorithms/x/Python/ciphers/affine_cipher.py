# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 20:44 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

SYMBOLS = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
def gcd(a, b):
    x = a
    y = b
    while y != 0:
        temp = x % y
        x = y
        y = temp
    return x
def mod_inverse(a, m):
    if gcd(a, m) != 1:
        panic("mod inverse of " + str(a) + " and " + str(m) + " does not exist")
    u1 = 1
    u2 = 0
    u3 = a
    v1 = 0
    v2 = 1
    v3 = m
    while v3 != 0:
        q = u3 // v3
        t1 = u1 - q * v1
        t2 = u2 - q * v2
        t3 = u3 - q * v3
        u1 = v1
        u2 = v2
        u3 = v3
        v1 = t1
        v2 = t2
        v3 = t3
    res = u1 % m
    if res < 0:
        return res + m
    return res
def find_symbol(ch):
    i = 0
    while i < len(SYMBOLS):
        if SYMBOLS[i] == ch:
            return i
        i = i + 1
    return -1
def check_keys(key_a, key_b, mode):
    m = len(SYMBOLS)
    if mode == "encrypt":
        if key_a == 1:
            panic("The affine cipher becomes weak when key A is set to 1. Choose different key")
        if key_b == 0:
            panic("The affine cipher becomes weak when key B is set to 0. Choose different key")
    if key_a < 0 or key_b < 0 or key_b > m - 1:
        panic("Key A must be greater than 0 and key B must be between 0 and " + str(m - 1))
    if gcd(key_a, m) != 1:
        panic("Key A " + str(key_a) + " and the symbol set size " + str(m) + " are not relatively prime. Choose a different key.")
def encrypt_message(key, message):
    m = len(SYMBOLS)
    key_a = key // m
    key_b = key % m
    check_keys(key_a, key_b, "encrypt")
    cipher_text = ""
    i = 0
    while i < len(message):
        ch = message[i]
        index = find_symbol(ch)
        if index >= 0:
            cipher_text = cipher_text + SYMBOLS[(index * key_a + key_b) % m]
        else:
            cipher_text = cipher_text + ch
        i = i + 1
    return cipher_text
def decrypt_message(key, message):
    m = len(SYMBOLS)
    key_a = key // m
    key_b = key % m
    check_keys(key_a, key_b, "decrypt")
    inv = mod_inverse(key_a, m)
    plain_text = ""
    i = 0
    while i < len(message):
        ch = message[i]
        index = find_symbol(ch)
        if index >= 0:
            n = (index - key_b) * inv
            pos = n % m
            final = (pos + m if pos < 0 else pos)
            plain_text = plain_text + SYMBOLS[final]
        else:
            plain_text = plain_text + ch
        i = i + 1
    return plain_text
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        key = 4545
        msg = "The affine cipher is a type of monoalphabetic substitution cipher."
        enc = encrypt_message(key, msg)
        print(enc)
        print(decrypt_message(key, enc))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
