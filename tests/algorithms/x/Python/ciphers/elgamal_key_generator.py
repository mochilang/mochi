# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))

seed = 123456789
def rand():
    global seed
    seed = (seed * 1103515245 + 12345) % 2147483647
    return seed
def rand_range(min, max):
    return min + rand() % (max - min + 1)
def mod_pow(base, exponent, modulus):
    result = 1
    b = base % modulus
    e = exponent
    while e > 0:
        if e % 2 == 1:
            result = (result * b) % modulus
        e = e // 2
        b = (b * b) % modulus
    return result
@dataclass
class GCD:
    g: int
    x: int
    y: int

def extended_gcd(a, b):
    if b == 0:
        return GCD(g=a, x=1, y=0)
    res = extended_gcd(b, a % b)
    return GCD(g=res.g, x=res.y, y=res.x - (a // b) * res.y)
def mod_inverse(a, m):
    res = extended_gcd(a, m)
    if res.g != 1:
        panic("inverse does not exist")
    r = res.x % m
    if r < 0:
        return r + m
    return r
def pow2(n):
    r = 1
    i = 0
    while i < n:
        r = r * 2
        i = i + 1
    return r
def is_probable_prime(n, k):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0:
        return False
    r = 0
    d = n - 1
    while d % 2 == 0:
        d = d // 2
        r = r + 1
    i = 0
    while i < k:
        a = rand_range(2, n - 2)
        x = mod_pow(a, d, n)
        if x == 1 or x == n - 1:
            i = i + 1
            continue
        j = 1
        found = False
        while j < r:
            x = mod_pow(x, 2, n)
            if x == n - 1:
                found = True
                break
            j = j + 1
        if not found:
            return False
        i = i + 1
    return True
def generate_large_prime(bits):
    min = pow2(bits - 1)
    max = pow2(bits) - 1
    p = rand_range(min, max)
    if p % 2 == 0:
        p = p + 1
    while not is_probable_prime(p, 5):
        p = p + 2
        if p > max:
            p = min + 1
    return p
def primitive_root(p):
    while True:
        g = rand_range(3, p - 1)
        if mod_pow(g, 2, p) == 1:
            continue
        if mod_pow(g, p, p) == 1:
            continue
        return g
@dataclass
class PublicKey:
    key_size: int
    g: int
    e2: int
    p: int

@dataclass
class PrivateKey:
    key_size: int
    d: int

@dataclass
class KeyPair:
    public_key: PublicKey
    private_key: PrivateKey

def generate_key(key_size):
    p = generate_large_prime(key_size)
    e1 = primitive_root(p)
    d = rand_range(3, p - 1)
    e2 = mod_inverse(mod_pow(e1, d, p), p)
    public_key = PublicKey(key_size=key_size, g=e1, e2=e2, p=p)
    private_key = PrivateKey(key_size=key_size, d=d)
    return KeyPair(public_key=public_key, private_key=private_key)
def main():
    key_size = 16
    kp = generate_key(key_size)
    pub = kp.public_key
    priv = kp.private_key
    print("public key: (" + str(pub.key_size) + ", " + str(pub.g) + ", " + str(pub.e2) + ", " + str(pub.p) + ")")
    print("private key: (" + str(priv.key_size) + ", " + str(priv.d) + ")")
main()
