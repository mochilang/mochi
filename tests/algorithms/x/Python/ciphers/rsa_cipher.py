# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]

BYTE_SIZE = 256
def pow_int(base, exp):
    result = 1
    i = 0
    while i < exp:
        result = result * base
        i = i + 1
    return result
def mod_pow(base, exponent, modulus):
    result = 1
    b = base % modulus
    e = exponent
    while e > 0:
        if e % 2 == 1:
            result = (result * b) % modulus
        e = e // 2
        b = (b * b) % modulus
    return result
def ord(ch):
    if ch == " ":
        return 32
    if ch == "a":
        return 97
    if ch == "b":
        return 98
    if ch == "c":
        return 99
    if ch == "d":
        return 100
    if ch == "e":
        return 101
    if ch == "f":
        return 102
    if ch == "g":
        return 103
    if ch == "h":
        return 104
    if ch == "i":
        return 105
    if ch == "j":
        return 106
    if ch == "k":
        return 107
    if ch == "l":
        return 108
    if ch == "m":
        return 109
    if ch == "n":
        return 110
    if ch == "o":
        return 111
    if ch == "p":
        return 112
    if ch == "q":
        return 113
    if ch == "r":
        return 114
    if ch == "s":
        return 115
    if ch == "t":
        return 116
    if ch == "u":
        return 117
    if ch == "v":
        return 118
    if ch == "w":
        return 119
    if ch == "x":
        return 120
    if ch == "y":
        return 121
    if ch == "z":
        return 122
    return 0
def chr(code):
    if code == 32:
        return " "
    if code == 97:
        return "a"
    if code == 98:
        return "b"
    if code == 99:
        return "c"
    if code == 100:
        return "d"
    if code == 101:
        return "e"
    if code == 102:
        return "f"
    if code == 103:
        return "g"
    if code == 104:
        return "h"
    if code == 105:
        return "i"
    if code == 106:
        return "j"
    if code == 107:
        return "k"
    if code == 108:
        return "l"
    if code == 109:
        return "m"
    if code == 110:
        return "n"
    if code == 111:
        return "o"
    if code == 112:
        return "p"
    if code == 113:
        return "q"
    if code == 114:
        return "r"
    if code == 115:
        return "s"
    if code == 116:
        return "t"
    if code == 117:
        return "u"
    if code == 118:
        return "v"
    if code == 119:
        return "w"
    if code == 120:
        return "x"
    if code == 121:
        return "y"
    if code == 122:
        return "z"
    return ""
def get_blocks_from_text(message, block_size):
    block_ints = []
    block_start = 0
    while block_start < len(message):
        block_int = 0
        i = block_start
        while i < block_start + block_size and i < len(message):
            block_int = block_int + ord(message[i]) * pow_int(BYTE_SIZE, i - block_start)
            i = i + 1
        block_ints = _append(block_ints, block_int)
        block_start = block_start + block_size
    return block_ints
def get_text_from_blocks(block_ints, message_length, block_size):
    message = ""
    for block_int in block_ints:
        block = block_int
        i = block_size - 1
        block_message = ""
        while i >= 0:
            if len(message) + i < message_length:
                ascii_number = block // pow_int(BYTE_SIZE, i)
                block = block % pow_int(BYTE_SIZE, i)
                block_message = chr(ascii_number) + block_message
            i = i - 1
        message = message + block_message
    return message
def encrypt_message(message, n, e, block_size):
    encrypted = []
    blocks = get_blocks_from_text(message, block_size)
    for block in blocks:
        encrypted = _append(encrypted, mod_pow(block, e, n))
    return encrypted
def decrypt_message(blocks, message_length, n, d, block_size):
    decrypted_blocks = []
    for block in blocks:
        decrypted_blocks = _append(decrypted_blocks, mod_pow(block, d, n))
    message = ""
    for num in decrypted_blocks:
        message = message + chr(num)
    return message
def main():
    message = "hello world"
    n = 3233
    e = 17
    d = 2753
    block_size = 1
    encrypted = encrypt_message(message, n, e, block_size)
    print(str(encrypted))
    decrypted = decrypt_message(encrypted, len(message), n, d, block_size)
    print(decrypted)
main()
