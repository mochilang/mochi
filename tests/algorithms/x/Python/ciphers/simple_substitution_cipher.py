# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
LOWERCASE = "abcdefghijklmnopqrstuvwxyz"
seed = 1
def rand(n):
    global seed
    seed = (seed * 1664525 + 1013904223) % 2147483647
    return seed % n
def get_random_key():
    chars = []
    i = 0
    while i < len(LETTERS):
        chars = _append(chars, LETTERS[i])
        i = i + 1
    j = len(chars) - 1
    while j > 0:
        k = rand(j + 1)
        tmp = chars[j]
        chars[j] = chars[k]
        chars[k] = tmp
        j = j - 1
    res = ""
    i = 0
    while i < len(chars):
        res = res + chars[i]
        i = i + 1
    return res
def check_valid_key(key):
    if len(key) != len(LETTERS):
        return False
    used = {}
    i = 0
    while i < len(key):
        ch = key[i]
        if used[ch]:
            return False
        used[ch] = True
        i = i + 1
    i = 0
    while i < len(LETTERS):
        ch = LETTERS[i]
        if not used[ch]:
            return False
        i = i + 1
    return True
def index_in(s, ch):
    i = 0
    while i < len(s):
        if s[i] == ch:
            return i
        i = i + 1
    return -1
def char_to_upper(c):
    i = 0
    while i < len(LOWERCASE):
        if c == LOWERCASE[i]:
            return LETTERS[i]
        i = i + 1
    return c
def char_to_lower(c):
    i = 0
    while i < len(LETTERS):
        if c == LETTERS[i]:
            return LOWERCASE[i]
        i = i + 1
    return c
def is_upper(c):
    i = 0
    while i < len(LETTERS):
        if c == LETTERS[i]:
            return True
        i = i + 1
    return False
def translate_message(key, message, mode):
    chars_a = LETTERS
    chars_b = key
    if mode == "decrypt":
        tmp = chars_a
        chars_a = chars_b
        chars_b = tmp
    translated = ""
    i = 0
    while i < len(message):
        symbol = message[i]
        upper_symbol = char_to_upper(symbol)
        idx = index_in(chars_a, upper_symbol)
        if idx >= 0:
            mapped = chars_b[idx]
            if is_upper(symbol):
                translated = translated + mapped
            else:
                translated = translated + char_to_lower(mapped)
        else:
            translated = translated + symbol
        i = i + 1
    return translated
def encrypt_message(key, message):
    res = translate_message(key, message, "encrypt")
    return res
def decrypt_message(key, message):
    res = translate_message(key, message, "decrypt")
    return res
key = "LFWOAYUISVKMNXPBDCRJTQEGHZ"
print(encrypt_message(key, "Harshil Darji"))
print(decrypt_message(key, "Ilcrism Olcvs"))
