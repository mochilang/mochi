# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]

KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
def mod36(n):
    r = n % 36
    if r < 0:
        r = r + 36
    return r
def gcd(a, b):
    x = a
    y = b
    while y != 0:
        t = y
        y = x % y
        x = t
    if x < 0:
        x = -x
    return x
def replace_letters(letter):
    i = 0
    while i < len(KEY_STRING):
        if KEY_STRING[i] == letter:
            return i
        i = i + 1
    return 0
def replace_digits(num):
    idx = mod36(num)
    return KEY_STRING[idx]
def to_upper(c):
    lower = "abcdefghijklmnopqrstuvwxyz"
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    i = 0
    while i < len(lower):
        if c == lower[i]:
            return upper[i]
        i = i + 1
    return c
def process_text(text, break_key):
    chars = []
    i = 0
    while i < len(text):
        c = to_upper(text[i])
        j = 0
        ok = False
        while j < len(KEY_STRING):
            if KEY_STRING[j] == c:
                ok = True
                break
            j = j + 1
        if ok:
            chars = _append(chars, c)
        i = i + 1
    if len(chars) == 0:
        return ""
    last = chars[len(chars) - 1]
    while len(chars) % break_key != 0:
        chars = _append(chars, last)
    res = ""
    k = 0
    while k < len(chars):
        res = res + chars[k]
        k = k + 1
    return res
def matrix_minor(m, row, col):
    res = []
    i = 0
    while i < len(m):
        if i != row:
            r = []
            j = 0
            while j < len(m[i]):
                if j != col:
                    r = _append(r, m[i][j])
                j = j + 1
            res = _append(res, r)
        i = i + 1
    return res
def determinant(m):
    n = len(m)
    if n == 1:
        return m[0][0]
    if n == 2:
        return m[0][0] * m[1][1] - m[0][1] * m[1][0]
    det = 0
    col = 0
    while col < n:
        minor_mat = matrix_minor(m, 0, col)
        sign = 1
        if col % 2 == 1:
            sign = -1
        det = det + sign * m[0][col] * determinant(minor_mat)
        col = col + 1
    return det
def cofactor_matrix(m):
    n = len(m)
    res = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            minor_mat = matrix_minor(m, i, j)
            det_minor = determinant(minor_mat)
            sign = 1
            if (i + j) % 2 == 1:
                sign = -1
            row = _append(row, sign * det_minor)
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def transpose(m):
    rows = len(m)
    cols = len(m[0])
    res = []
    j = 0
    while j < cols:
        row = []
        i = 0
        while i < rows:
            row = _append(row, m[i][j])
            i = i + 1
        res = _append(res, row)
        j = j + 1
    return res
def matrix_mod(m):
    res = []
    i = 0
    while i < len(m):
        row = []
        j = 0
        while j < len(m[i]):
            row = _append(row, mod36(m[i][j]))
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def scalar_matrix_mult(s, m):
    res = []
    i = 0
    while i < len(m):
        row = []
        j = 0
        while j < len(m[i]):
            row = _append(row, mod36(s * m[i][j]))
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def adjugate(m):
    cof = cofactor_matrix(m)
    n = len(cof)
    res = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row = _append(row, cof[j][i])
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def multiply_matrix_vector(m, v):
    n = len(m)
    res = []
    i = 0
    while i < n:
        sum = 0
        j = 0
        while j < n:
            sum = sum + m[i][j] * v[j]
            j = j + 1
        res = _append(res, mod36(sum))
        i = i + 1
    return res
def inverse_key(key):
    det_val = determinant(key)
    det_mod = mod36(det_val)
    det_inv = 0
    i = 0
    while i < 36:
        if (det_mod * i) % 36 == 1:
            det_inv = i
            break
        i = i + 1
    adj = adjugate(key)
    tmp = scalar_matrix_mult(det_inv, adj)
    res = matrix_mod(tmp)
    return res
def hill_encrypt(key, text):
    break_key = len(key)
    processed = process_text(text, break_key)
    encrypted = ""
    i = 0
    while i < len(processed):
        vec = []
        j = 0
        while j < break_key:
            vec = _append(vec, replace_letters(processed[i + j]))
            j = j + 1
        enc_vec = multiply_matrix_vector(key, vec)
        k = 0
        while k < break_key:
            encrypted = encrypted + replace_digits(enc_vec[k])
            k = k + 1
        i = i + break_key
    return encrypted
def hill_decrypt(key, text):
    break_key = len(key)
    decrypt_key = inverse_key(key)
    processed = process_text(text, break_key)
    decrypted = ""
    i = 0
    while i < len(processed):
        vec = []
        j = 0
        while j < break_key:
            vec = _append(vec, replace_letters(processed[i + j]))
            j = j + 1
        dec_vec = multiply_matrix_vector(decrypt_key, vec)
        k = 0
        while k < break_key:
            decrypted = decrypted + replace_digits(dec_vec[k])
            k = k + 1
        i = i + break_key
    return decrypted
key = [[2, 5], [1, 6]]
print(hill_encrypt(key, "testing hill cipher"))
print(hill_encrypt(key, "hello"))
print(hill_decrypt(key, "WHXYJOLM9C6XT085LL"))
print(hill_decrypt(key, "85FF00"))
