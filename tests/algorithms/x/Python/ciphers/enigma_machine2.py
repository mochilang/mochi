# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]

abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
low_abc = "abcdefghijklmnopqrstuvwxyz"
rotor1 = "EGZWVONAHDCLFQMSIPJBYUKXTR"
rotor2 = "FOBHMDKEXQNRAULPGSJVTYICZW"
rotor3 = "ZJXESIUQLHAVRMDOYGTNFWPBKC"
rotor4 = "RMDJXFUWGISLHVTCQNKYPBEZOA"
rotor5 = "SGLCPQWZHKXAREONTFBVIYJUDM"
rotor6 = "HVSICLTYKQUBXDWAJZOMFGPREN"
rotor7 = "RZWQHFMVDBKICJLNTUXAGYPSOE"
rotor8 = "LFKIJODBEGAMQPXVUHYSTCZRWN"
rotor9 = "KOAEGVDHXPQZMLFTYWJNBRCIUS"
reflector_pairs = ["AN", "BO", "CP", "DQ", "ER", "FS", "GT", "HU", "IV", "JW", "KX", "LY", "MZ"]
def list_contains(xs, x):
    i = 0
    while i < len(xs):
        if xs[i] == x:
            return True
        i = i + 1
    return False
def index_in_string(s, ch):
    i = 0
    while i < len(s):
        if s[i:i + 1] == ch:
            return i
        i = i + 1
    return -1
def contains_char(s, ch):
    return index_in_string(s, ch) >= 0
def to_uppercase(s):
    res = ""
    i = 0
    while i < len(s):
        ch = s[i:i + 1]
        idx = index_in_string(low_abc, ch)
        if idx >= 0:
            res = res + abc[idx:idx + 1]
        else:
            res = res + ch
        i = i + 1
    return res
def plugboard_map(pb, ch):
    i = 0
    while i < len(pb):
        pair = pb[i]
        a = pair[0:1]
        b = pair[1:2]
        if ch == a:
            return b
        if ch == b:
            return a
        i = i + 1
    return ch
def reflector_map(ch):
    i = 0
    while i < len(reflector_pairs):
        pair = reflector_pairs[i]
        a = pair[0:1]
        b = pair[1:2]
        if ch == a:
            return b
        if ch == b:
            return a
        i = i + 1
    return ch
def count_unique(xs):
    unique = []
    i = 0
    while i < len(xs):
        if not list_contains(unique, xs[i]):
            unique = _append(unique, xs[i])
        i = i + 1
    return len(unique)
def build_plugboard(pbstring):
    if len(pbstring) == 0:
        return []
    if len(pbstring) % 2 != 0:
        panic("Odd number of symbols(" + str(len(pbstring)) + ")")
    pbstring_nospace = ""
    i = 0
    while i < len(pbstring):
        ch = pbstring[i:i + 1]
        if ch != " ":
            pbstring_nospace = pbstring_nospace + ch
        i = i + 1
    seen = []
    i = 0
    while i < len(pbstring_nospace):
        ch = pbstring_nospace[i:i + 1]
        if not contains_char(abc, ch):
            panic("'" + ch + "' not in list of symbols")
        if list_contains(seen, ch):
            panic("Duplicate symbol(" + ch + ")")
        seen = _append(seen, ch)
        i = i + 1
    pb = []
    i = 0
    while i < len(pbstring_nospace) - 1:
        a = pbstring_nospace[i:i + 1]
        b = pbstring_nospace[i + 1:i + 2]
        pb = _append(pb, a + b)
        i = i + 2
    return pb
def validator(rotpos, rotsel, pb):
    if count_unique(rotsel) < 3:
        panic("Please use 3 unique rotors (not " + str(count_unique(rotsel)) + ")")
    if len(rotpos) != 3:
        panic("Rotor position must have 3 values")
    r1 = rotpos[0]
    r2 = rotpos[1]
    r3 = rotpos[2]
    if not (0 < r1 and r1 <= len(abc)):
        panic("First rotor position is not within range of 1..26 (" + str(r1) + ")")
    if not (0 < r2 and r2 <= len(abc)):
        panic("Second rotor position is not within range of 1..26 (" + str(r2) + ")")
    if not (0 < r3 and r3 <= len(abc)):
        panic("Third rotor position is not within range of 1..26 (" + str(r3) + ")")
def enigma(text, rotor_position, rotor_selection, plugb):
    up_text = to_uppercase(text)
    up_pb = to_uppercase(plugb)
    validator(rotor_position, rotor_selection, up_pb)
    plugboard = build_plugboard(up_pb)
    rotorpos1 = rotor_position[0] - 1
    rotorpos2 = rotor_position[1] - 1
    rotorpos3 = rotor_position[2] - 1
    rotor_a = rotor_selection[0]
    rotor_b = rotor_selection[1]
    rotor_c = rotor_selection[2]
    result = ""
    i = 0
    while i < len(up_text):
        symbol = up_text[i:i + 1]
        if contains_char(abc, symbol):
            symbol = plugboard_map(plugboard, symbol)
            index = index_in_string(abc, symbol) + rotorpos1
            symbol = rotor_a[index % len(abc):index % len(abc) + 1]
            index = index_in_string(abc, symbol) + rotorpos2
            symbol = rotor_b[index % len(abc):index % len(abc) + 1]
            index = index_in_string(abc, symbol) + rotorpos3
            symbol = rotor_c[index % len(abc):index % len(abc) + 1]
            symbol = reflector_map(symbol)
            index = index_in_string(rotor_c, symbol) - rotorpos3
            if index < 0:
                index = index + len(abc)
            symbol = abc[index:index + 1]
            index = index_in_string(rotor_b, symbol) - rotorpos2
            if index < 0:
                index = index + len(abc)
            symbol = abc[index:index + 1]
            index = index_in_string(rotor_a, symbol) - rotorpos1
            if index < 0:
                index = index + len(abc)
            symbol = abc[index:index + 1]
            symbol = plugboard_map(plugboard, symbol)
            rotorpos1 = rotorpos1 + 1
            if rotorpos1 >= len(abc):
                rotorpos1 = 0
                rotorpos2 = rotorpos2 + 1
            if rotorpos2 >= len(abc):
                rotorpos2 = 0
                rotorpos3 = rotorpos3 + 1
            if rotorpos3 >= len(abc):
                rotorpos3 = 0
        result = result + symbol
        i = i + 1
    return result
def main():
    message = "This is my Python script that emulates the Enigma machine from WWII."
    rotor_pos = [1, 1, 1]
    pb = "pictures"
    rotor_sel = [rotor2, rotor4, rotor8]
    en = enigma(message, rotor_pos, rotor_sel, pb)
    print("Encrypted message: " + en)
    print("Decrypted message: " + enigma(en, rotor_pos, rotor_sel, pb))
main()
