# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import os
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def ord(ch):
    digits = "0123456789"
    i = 0
    while i < len(digits):
        if digits[i:i + 1] == ch:
            return 48 + i
        i = i + 1
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    i = 0
    while i < len(upper):
        if upper[i:i + 1] == ch:
            return 65 + i
        i = i + 1
    lower = "abcdefghijklmnopqrstuvwxyz"
    i = 0
    while i < len(lower):
        if lower[i:i + 1] == ch:
            return 97 + i
        i = i + 1
    return 0
def neg_pos(iterlist):
    i = 1
    while i < len(iterlist):
        iterlist[i] = -iterlist[i]
        i = i + 2
    return iterlist
def passcode_creator():
    choices = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    seed = _now()
    length = 10 + (seed % 11)
    password = []
    i = 0
    while i < length:
        seed = (seed * 1103515245 + 12345) % 2147483647
        idx = seed % len(choices)
        password = _append(password, choices[idx:idx + 1])
        i = i + 1
    return password
def unique_sorted(chars):
    uniq = []
    i = 0
    while i < len(chars):
        ch = chars[i]
        if not (ch in uniq):
            uniq = _append(uniq, ch)
        i = i + 1
    j = 0
    while j < len(uniq):
        k = j + 1
        min_idx = j
        while k < len(uniq):
            if uniq[k] < uniq[min_idx]:
                min_idx = k
            k = k + 1
        if min_idx != j:
            tmp = uniq[j]
            uniq[j] = uniq[min_idx]
            uniq[min_idx] = tmp
        j = j + 1
    return uniq
def make_key_list(passcode):
    key_list_options = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n"
    breakpoints = unique_sorted(passcode)
    keys_l = []
    temp_list = []
    i = 0
    while i < len(key_list_options):
        ch = key_list_options[i:i + 1]
        temp_list = _append(temp_list, ch)
        if ch in breakpoints or i == len(key_list_options) - 1:
            k = len(temp_list) - 1
            while k >= 0:
                keys_l = _append(keys_l, temp_list[k])
                k = k - 1
            temp_list = []
        i = i + 1
    return keys_l
def make_shift_key(passcode):
    codes = []
    i = 0
    while i < len(passcode):
        codes = _append(codes, ord(passcode[i]))
        i = i + 1
    codes = neg_pos(codes)
    total = 0
    i = 0
    while i < len(codes):
        total = total + codes[i]
        i = i + 1
    if total > 0:
        return total
    return len(passcode)
@dataclass
class Cipher:
    passcode: [string]
    key_list: [string]
    shift_key: int

def new_cipher(passcode_str):
    passcode = []
    if len(passcode_str) == 0:
        passcode = passcode_creator()
    else:
        i = 0
        while i < len(passcode_str):
            passcode = _append(passcode, passcode_str[i:i + 1])
            i = i + 1
    key_list = make_key_list(passcode)
    shift_key = make_shift_key(passcode)
    return Cipher(passcode=passcode, key_list=key_list, shift_key=shift_key)
def index_of(lst, ch):
    i = 0
    while i < len(lst):
        if lst[i] == ch:
            return i
        i = i + 1
    return -1
def encrypt(c, plaintext):
    encoded = ""
    i = 0
    n = len(c.key_list)
    while i < len(plaintext):
        ch = plaintext[i:i + 1]
        position = index_of(c.key_list, ch)
        new_pos = (position + c.shift_key) % n
        encoded = encoded + c.key_list[new_pos]
        i = i + 1
    return encoded
def decrypt(c, encoded_message):
    decoded = ""
    i = 0
    n = len(c.key_list)
    while i < len(encoded_message):
        ch = encoded_message[i:i + 1]
        position = index_of(c.key_list, ch)
        new_pos = (position - c.shift_key) % n
        if new_pos < 0:
            new_pos = new_pos + n
        decoded = decoded + c.key_list[new_pos]
        i = i + 1
    return decoded
def test_end_to_end():
    msg = "Hello, this is a modified Caesar cipher"
    cip = new_cipher("")
    return decrypt(cip, encrypt(cip, msg))
ssc = new_cipher("4PYIXyqeQZr44")
encoded = encrypt(ssc, "Hello, this is a modified Caesar cipher")
print(encoded)
print(decrypt(ssc, encoded))
