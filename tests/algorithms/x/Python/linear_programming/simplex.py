# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 11:48 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if abs(v - round(v)) < 1e-9:
            return str(float(round(v)))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def pivot(t, row, col):
        pivotRow = []
        pivotVal = t[row][col]
        for j in range(0, len(t[row])):
            pivotRow = _append(pivotRow, t[row][j] / pivotVal)
        t[row] = pivotRow
        for i in range(0, len(t)):
            if i != row:
                factor = t[i][col]
                newRow = []
                for j in range(0, len(t[i])):
                    value = t[i][j] - factor * pivotRow[j]
                    newRow = _append(newRow, value)
                t[i] = newRow
        return t
    def findPivot(t):
        col = 0
        minVal = 0.0
        for j in range(0, len(t[0]) - 1):
            v = t[0][j]
            if v < minVal:
                minVal = v
                col = j
        if minVal >= 0.0:
            return [-1, -1]
        row = -1
        minRatio = 0.0
        first = True
        for i in range(1, len(t)):
            coeff = t[i][col]
            if coeff > 0.0:
                rhs = t[i][len(t[i]) - 1]
                ratio = rhs / coeff
                if first or ratio < minRatio:
                    minRatio = ratio
                    row = i
                    first = False
        return [row, col]
    def interpret(t, nVars):
        lastCol = len(t[0]) - 1
        p = t[0][lastCol]
        if p < 0.0:
            p = -p
        result = {}
        result["P"] = p
        for i in range(0, nVars):
            nzRow = -1
            nzCount = 0
            for r in range(0, len(t)):
                val = t[r][i]
                if val != 0.0:
                    nzCount = nzCount + 1
                    nzRow = r
            if nzCount == 1 and t[nzRow][i] == 1.0:
                result["x" + _str(i + 1)] = t[nzRow][lastCol]
        return result
    def simplex(tab):
        t = tab
        while True:
            p = findPivot(t)
            row = p[0]
            col = p[1]
            if row < 0:
                break
            t = pivot(t, row, col)
        return t
    tableau = [[-1.0, -1.0, 0.0, 0.0, 0.0], [1.0, 3.0, 1.0, 0.0, 4.0], [3.0, 1.0, 0.0, 1.0, 4.0]]
    finalTab = simplex(tableau)
    res = interpret(finalTab, 2)
    print("P: " + _str(res.get("P", 0.0)))
    for i in range(0, 2):
        key = "x" + _str(i + 1)
        if key in res:
            print(key + ": " + _str(res.get(key, 0.0)))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

