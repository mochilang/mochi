# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 10:00 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class ConnMock:
        recv_called: int
        send_called: int
        close_called: int
    def make_conn_mock():
        return ConnMock(recv_called=0, send_called=0, close_called=0)
    def conn_recv(conn, size):
        conn.recv_called = conn.recv_called + 1
        return 0
    def conn_send(conn, data):
        conn.send_called = conn.send_called + 1
    def conn_close(conn):
        conn.close_called = conn.close_called + 1
    @dataclass
    class SocketMock:
        bind_called: int
        listen_called: int
        accept_called: int
        shutdown_called: int
        close_called: int
        conn: ConnMock
    def make_socket_mock(conn):
        return SocketMock(bind_called=0, listen_called=0, accept_called=0, shutdown_called=0, close_called=0, conn=conn)
    def socket_bind(sock):
        sock.bind_called = sock.bind_called + 1
    def socket_listen(sock):
        sock.listen_called = sock.listen_called + 1
    def socket_accept(sock):
        sock.accept_called = sock.accept_called + 1
        return sock.conn
    def socket_shutdown(sock):
        sock.shutdown_called = sock.shutdown_called + 1
    def socket_close(sock):
        sock.close_called = sock.close_called + 1
    @dataclass
    class FileMock:
        read_called: int
        data: [int]
    def make_file_mock(values):
        return FileMock(read_called=0, data=values)
    def file_read(f, size):
        if f.read_called < len(f.data):
            value = f.data[f.read_called]
            f.read_called = f.read_called + 1
            return value
        f.read_called = f.read_called + 1
        return 0
    def file_open():
        return make_file_mock([1, 0])
    def send_file(sock, f):
        socket_bind(sock)
        socket_listen(sock)
        conn = socket_accept(sock)
        _ = conn_recv(conn, 1024)
        data = file_read(f, 1024)
        while data != 0:
            conn_send(conn, data)
            data = file_read(f, 1024)
        conn_close(conn)
        socket_shutdown(sock)
        socket_close(sock)
    def test_send_file_running_as_expected():
        conn = make_conn_mock()
        sock = make_socket_mock(conn)
        f = file_open()
        send_file(sock, f)
        if sock.bind_called == 1 and sock.listen_called == 1 and sock.accept_called == 1 and conn.recv_called == 1 and f.read_called >= 1 and conn.send_called == 1 and conn.close_called == 1 and sock.shutdown_called == 1 and sock.close_called == 1:
            return "pass"
        return "fail"
    print(test_send_file_running_as_expected())
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

