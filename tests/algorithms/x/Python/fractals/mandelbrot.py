# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 10:00 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    lst.append(v)
    return lst


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class RGB:
        r: int
        g: int
        b: int
    def round_int(x):
        return int((x + 0.5))
    def hsv_to_rgb(h, s, v):
        i = int((h * 6.0))
        f = h * 6.0 - (float(i))
        p = v * (1.0 - s)
        q = v * (1.0 - f * s)
        t = v * (1.0 - (1.0 - f) * s)
        mod = i % 6
        r = 0.0
        g = 0.0
        b = 0.0
        if mod == 0:
            r = v
            g = t
            b = p
        else:
            if mod == 1:
                r = q
                g = v
                b = p
            else:
                if mod == 2:
                    r = p
                    g = v
                    b = t
                else:
                    if mod == 3:
                        r = p
                        g = q
                        b = v
                    else:
                        if mod == 4:
                            r = t
                            g = p
                            b = v
                        else:
                            r = v
                            g = p
                            b = q
        return RGB(r=round_int(r * 255.0), g=round_int(g * 255.0), b=round_int(b * 255.0))
    def get_distance(x, y, max_step):
        a = x
        b = y
        step = -1
        while step < max_step - 1:
            step = step + 1
            a_new = a * a - b * b + x
            b = 2.0 * a * b + y
            a = a_new
            if a * a + b * b > 4.0:
                break
        return (float(step)) / (float((max_step - 1)))
    def get_black_and_white_rgb(distance):
        if distance == 1.0:
            return RGB(r=0, g=0, b=0)
        else:
            return RGB(r=255, g=255, b=255)
    def get_color_coded_rgb(distance):
        if distance == 1.0:
            return RGB(r=0, g=0, b=0)
        else:
            return hsv_to_rgb(distance, 1.0, 1.0)
    def get_image(image_width, image_height, figure_center_x, figure_center_y, figure_width, max_step, use_distance_color_coding):
        img = []
        figure_height = figure_width / (float(image_width)) * (float(image_height))
        image_y = 0
        while image_y < image_height:
            row = []
            image_x = 0
            while image_x < image_width:
                fx = figure_center_x + ((float(image_x)) / (float(image_width)) - 0.5) * figure_width
                fy = figure_center_y + ((float(image_y)) / (float(image_height)) - 0.5) * figure_height
                distance = get_distance(fx, fy, max_step)
                rgb = {}
                if use_distance_color_coding:
                    rgb = get_color_coded_rgb(distance)
                else:
                    rgb = get_black_and_white_rgb(distance)
                row = _append(row, rgb)
                image_x = image_x + 1
            img = _append(img, row)
            image_y = image_y + 1
        return img
    def rgb_to_string(c):
        return "(" + _str(c.r) + ", " + _str(c.g) + ", " + _str(c.b) + ")"
    img1 = get_image(10, 10, -0.6, 0.0, 3.2, 50, True)
    print(rgb_to_string(img1[0][0]))
    img2 = get_image(10, 10, -0.6, 0.0, 3.2, 50, False)
    print(rgb_to_string(img2[0][0]))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

