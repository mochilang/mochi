# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]

@dataclass
class Complex:
    re: float
    im: float

def complex_add(a, b):
    return Complex(re=a.re + b.re, im=a.im + b.im)
def complex_mul(a, b):
    real = a.re * b.re - a.im * b.im
    imag = a.re * b.im + a.im * b.re
    return Complex(re=real, im=imag)
def sqrtApprox(x):
    guess = x / 2.0
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def complex_abs(a):
    return sqrtApprox(a.re * a.re + a.im * a.im)
def sin_taylor(x):
    term = x
    sum = x
    i = 1
    while i < 10:
        k1 = 2.0 * (float(i))
        k2 = 2.0 * (float(i)) + 1.0
        term = -term * x * x // (k1 * k2)
        sum = sum + term
        i = i + 1
    return sum
def cos_taylor(x):
    term = 1.0
    sum = 1.0
    i = 1
    while i < 10:
        k1 = 2.0 * (float(i)) - 1.0
        k2 = 2.0 * (float(i))
        term = -term * x * x // (k1 * k2)
        sum = sum + term
        i = i + 1
    return sum
def exp_taylor(x):
    term = 1.0
    sum = 1.0
    i = 1.0
    while i < 20.0:
        term = term * x // i
        sum = sum + term
        i = i + 1.0
    return sum
def complex_exp(z):
    e = exp_taylor(z.re)
    return Complex(re=e * cos_taylor(z.im), im=e * sin_taylor(z.im))
def eval_quadratic(c, z):
    return complex_add(complex_mul(z, z), c)
def eval_exponential(c, z):
    return complex_add(complex_exp(z), c)
def iterate_function(eval_function, c, nb_iterations, z0, infinity):
    z_n = z0
    i = 0
    while i < nb_iterations:
        z_n = eval_function(c, z_n)
        if complex_abs(z_n) > infinity:
            return z_n
        i = i + 1
    return z_n
def prepare_grid(window_size, nb_pixels):
    grid = []
    i = 0
    while i < nb_pixels:
        row = []
        j = 0
        while j < nb_pixels:
            real = -window_size + 2.0 * window_size * (float(i)) // (float((nb_pixels - 1)))
            imag = -window_size + 2.0 * window_size * (float(j)) // (float((nb_pixels - 1)))
            row = _append(row, Complex(re=real, im=imag))
            j = j + 1
        grid = _append(grid, row)
        i = i + 1
    return grid
def julia_demo():
    grid = prepare_grid(1.0, 5)
    c_poly = Complex(re=-0.4, im=0.6)
    c_exp = Complex(re=-2.0, im=0.0)
    poly_result = []
    exp_result = []
    y = 0
    while y < len(grid):
        row_poly = []
        row_exp = []
        x = 0
        while x < len(grid[y]):
            z0 = grid[y][x]
            z_poly = iterate_function(eval_quadratic, c_poly, 20, z0, 4.0)
            z_exp = iterate_function(eval_exponential, c_exp, 10, z0, 1e+10)
            row_poly = _append(row_poly, (1 if complex_abs(z_poly) < 2.0 else 0))
            row_exp = _append(row_exp, (1 if complex_abs(z_exp) < 10000.0 else 0))
            x = x + 1
        poly_result = _append(poly_result, row_poly)
        exp_result = _append(exp_result, row_exp)
        y = y + 1
    print(poly_result)
    print(exp_result)
julia_demo()
