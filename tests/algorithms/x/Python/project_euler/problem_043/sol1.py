# Code generated by Mochi transpiler.
# Version 0.10.71, generated on 2025-08-23 15:31 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]

def is_substring_divisible(num):
    if num[3] % 2 != 0:
        return False
    if (num[2] + num[3] + num[4]) % 3 != 0:
        return False
    if num[5] % 5 != 0:
        return False
    primes = [7, 11, 13, 17]
    i = 0
    while i < len(primes):
        p = primes[i]
        idx = i + 4
        val = num[idx] * 100 + num[idx + 1] * 10 + num[idx + 2]
        if val % p != 0:
            return False
        i = i + 1
    return True
def remove_at(xs, idx):
    res = []
    i = 0
    while i < len(xs):
        if i != idx:
            res = _append(res, xs[i])
        i = i + 1
    return res
def digits_to_number(xs):
    value = 0
    i = 0
    while i < len(xs):
        value = value * 10 + xs[i]
        i = i + 1
    return value
def search(prefix, remaining):
    if len(remaining) == 0:
        if is_substring_divisible(prefix):
            return digits_to_number(prefix)
        return 0
    total = 0
    i = 0
    while i < len(remaining):
        d = remaining[i]
        next_prefix = _append(prefix, d)
        next_remaining = remove_at(remaining, i)
        total = total + search(next_prefix, next_remaining)
        i = i + 1
    return total
def solution(n):
    digits = []
    i = 0
    while i < n:
        digits = _append(digits, i)
        i = i + 1
    return search([], digits)
print("solution() =", solution(10))

