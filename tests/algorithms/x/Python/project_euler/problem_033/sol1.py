# Code generated by Mochi transpiler.
# Version 0.10.71, generated on 2025-08-23 15:31 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


import builtins
def _str(v):
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(int(builtins.round(v)))
        return builtins.str(v)
    return builtins.str(v)

@dataclass
class FractionPair:
    num: int
    den: int

def gcd(a, b):
    x = (-a if a < 0 else a)
    y = (-b if b < 0 else b)
    while y != 0:
        t = x % y
        x = y
        y = t
    return x
def is_digit_cancelling(num, den):
    if num >= den:
        return False
    num_unit = num % 10
    num_tens = num // 10
    den_unit = den % 10
    den_tens = den // 10
    if num_unit != den_tens:
        return False
    if den_unit == 0:
        return False
    return num * den_unit == num_tens * den
def find_fractions():
    sols = []
    num = 10
    while num < 100:
        den = num + 1
        while den < 100:
            if is_digit_cancelling(num, den):
                sols = _append(sols, FractionPair(num=num, den=den))
            den = den + 1
        num = num + 1
    return sols
def solution():
    fracs = find_fractions()
    num_prod = 1
    den_prod = 1
    i = 0
    while i < len(fracs):
        f = fracs[i]
        num_prod = num_prod * f.num
        den_prod = den_prod * f.den
        i = i + 1
    g = gcd(num_prod, den_prod)
    return den_prod // g
def main():
    print(_str(solution()))
main()

