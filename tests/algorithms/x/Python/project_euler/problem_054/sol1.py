# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-09 23:14 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def card_value(c):
    if c == "2":
        return 2
    if c == "3":
        return 3
    if c == "4":
        return 4
    if c == "5":
        return 5
    if c == "6":
        return 6
    if c == "7":
        return 7
    if c == "8":
        return 8
    if c == "9":
        return 9
    if c == "T":
        return 10
    if c == "J":
        return 11
    if c == "Q":
        return 12
    if c == "K":
        return 13
    if c == "A":
        return 14
    return 0
def sort_desc(xs):
    arr = xs
    n = len(arr)
    i = 0
    while i < n:
        j = 0
        while j < n - 1:
            if arr[j] < arr[j + 1]:
                tmp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = tmp
            j = j + 1
        i = i + 1
    return arr
def filter_not(xs, v):
    res = []
    for x in xs:
        if x != v:
            res = _append(res, x)
    return res
def hand_rank(hand):
    ranks = []
    suits = []
    for card in hand:
        ranks = _append(ranks, card_value(card[0]))
        suits = _append(suits, card[1])
    ranks = sort_desc(ranks)
    flush = True
    i = 1
    while i < len(suits):
        if suits[i] != suits[0]:
            flush = False
        i = i + 1
    straight = True
    i = 0
    while i < 4:
        if ranks[i] - ranks[i + 1] != 1:
            straight = False
        i = i + 1
    if not straight and ranks[0] == 14 and ranks[1] == 5 and ranks[2] == 4 and ranks[3] == 3 and ranks[4] == 2:
        straight = True
        ranks = [5, 4, 3, 2, 1]
    counts = {}
    for r in ranks:
        if r in counts:
            counts[r] = counts.get(r, None) + 1
        else:
            counts[r] = 1
    uniq = []
    for r in ranks:
        exists = False
        for u in uniq:
            if u == r:
                exists = True
        if not exists:
            uniq = _append(uniq, r)
    count_vals = []
    for u in uniq:
        count_vals = _append(count_vals, [counts.get(u, None), u])
    n = len(count_vals)
    i2 = 0
    while i2 < n:
        j2 = 0
        while j2 < n - 1:
            a = count_vals[j2]
            b = count_vals[j2 + 1]
            if a[0] < b[0] or (a[0] == b[0] and a[1] < b[1]):
                tmp = count_vals[j2]
                count_vals[j2] = count_vals[j2 + 1]
                count_vals[j2 + 1] = tmp
            j2 = j2 + 1
        i2 = i2 + 1
    c1 = count_vals[0][0]
    v1 = count_vals[0][1]
    rank = []
    if straight and flush:
        if ranks[0] == 14:
            rank = _append(rank, 9)
            rank = _append(rank, 14)
            return rank
        rank = _append(rank, 8)
        rank = _append(rank, ranks[0])
        return rank
    if c1 == 4:
        kicker = 0
        for r in ranks:
            if r != v1:
                kicker = r
        rank = _append(rank, 7)
        rank = _append(rank, v1)
        rank = _append(rank, kicker)
        return rank
    if c1 == 3:
        c2 = count_vals[1][0]
        v2 = count_vals[1][1]
        if c2 == 2:
            rank = _append(rank, 6)
            rank = _append(rank, v1)
            rank = _append(rank, v2)
            return rank
        rank = _append(rank, 3)
        rank = _append(rank, v1)
        for r in ranks:
            if r != v1:
                rank = _append(rank, r)
        return rank
    if c1 == 2:
        c2 = count_vals[1][0]
        v2 = count_vals[1][1]
        if c2 == 2:
            high_pair = v1
            low_pair = v2
            if low_pair > high_pair:
                tmp = high_pair
                high_pair = low_pair
                low_pair = tmp
            kicker = 0
            for r in ranks:
                if r != high_pair and r != low_pair:
                    kicker = r
            rank = _append(rank, 2)
            rank = _append(rank, high_pair)
            rank = _append(rank, low_pair)
            rank = _append(rank, kicker)
            return rank
        rank = _append(rank, 1)
        rank = _append(rank, v1)
        for r in ranks:
            if r != v1:
                rank = _append(rank, r)
        return rank
    if flush:
        rank = _append(rank, 5)
        for r in ranks:
            rank = _append(rank, r)
        return rank
    if straight:
        rank = _append(rank, 4)
        rank = _append(rank, ranks[0])
        return rank
    rank = _append(rank, 0)
    for r in ranks:
        rank = _append(rank, r)
    return rank
def compare_hands(h1, h2):
    r1 = hand_rank(h1)
    r2 = hand_rank(h2)
    i = 0
    while i < len(r1) and i < len(r2):
        if r1[i] > r2[i]:
            return 1
        if r1[i] < r2[i]:
            return -1
        i = i + 1
    return 0
def solution():
    hands = [{f'c'+str(i):cols[i] for i in range(len(cols))} for cols in [line.strip().split(" ") for line in open("/workspace/mochi/tests/github/TheAlgorithms/Python/project_euler/problem_054/poker_hands.txt")]]
    wins = 0
    for h in hands:
        p1 = [h.get("c0"), h.get("c1"), h.get("c2"), h.get("c3"), h.get("c4")]
        p2 = [h.get("c5"), h.get("c6"), h.get("c7"), h.get("c8"), h.get("c9")]
        if compare_hands(p1, p2) == 1:
            wins = wins + 1
    return wins
print(solution())

