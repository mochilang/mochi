# Code generated by Mochi transpiler.
# Version 0.10.71, generated on 2025-08-23 15:31 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


import builtins
def _str(v):
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(int(builtins.round(v)))
        return builtins.str(v)
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def int_sqrt(n):
    x = 1
    while (x + 1) * (x + 1) <= n:
        x = x + 1
    return x
def solution(limit):
    sum_divs = []
    i = 0
    while i <= limit:
        sum_divs = _append(sum_divs, 1)
        i = i + 1
    sqrt_limit = int_sqrt(limit)
    i = 2
    while i <= sqrt_limit:
        sum_divs[i * i] = sum_divs[i * i] + i
        k = i + 1
        while k <= (limit // i):
            sum_divs[k * i] = sum_divs[k * i] + k + i
            k = k + 1
        i = i + 1
    is_abundant = []
    i = 0
    while i <= limit:
        is_abundant = _append(is_abundant, False)
        i = i + 1
    abundants = []
    res = 0
    n = 1
    while n <= limit:
        if sum_divs[n] > n:
            abundants = _append(abundants, n)
            is_abundant[n] = True
        has_pair = False
        j = 0
        while j < len(abundants):
            a = abundants[j]
            if a > n:
                break
            b = n - a
            if b <= limit and is_abundant[b]:
                has_pair = True
                break
            j = j + 1
        if not has_pair:
            res = res + n
        n = n + 1
    return res
print(_str(solution(28123)))

