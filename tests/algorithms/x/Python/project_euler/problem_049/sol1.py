# Code generated by Mochi transpiler.
# Version 0.10.71, generated on 2025-08-23 15:31 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


import builtins
def _str(v):
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(int(builtins.round(v)))
        return builtins.str(v)
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def is_prime(number):
    if 1 < number and number < 4:
        return True
    if number < 2 or number % 2 == 0 or number % 3 == 0:
        return False
    i = 5
    while i * i <= number:
        if number % i == 0 or number % (i + 2) == 0:
            return False
        i = i + 6
    return True
def search(target, arr):
    left = 0
    right = len(arr) - 1
    while left <= right:
        middle = (left + right) // 2
        if arr[middle] == target:
            return True
        if arr[middle] < target:
            left = middle + 1
        else:
            right = middle - 1
    return False
def sort_int(xs):
    arr = xs
    i = 0
    while i < len(arr):
        j = i + 1
        while j < len(arr):
            if arr[j] < arr[i]:
                tmp = arr[i]
                arr[i] = arr[j]
                arr[j] = tmp
            j = j + 1
        i = i + 1
    return arr
def permutations_of_number(n):
    s = _str(n)
    d = []
    i = 0
    while i < len(s):
        d = _append(d, int(s[i]))
        i = i + 1
    res = []
    a = 0
    while a < len(d):
        b = 0
        while b < len(d):
            if b != a:
                c = 0
                while c < len(d):
                    if c != a and c != b:
                        e = 0
                        while e < len(d):
                            if e != a and e != b and e != c:
                                val = d[a] * 1000 + d[b] * 100 + d[c] * 10 + d[e]
                                res = _append(res, val)
                            e = e + 1
                    c = c + 1
            b = b + 1
        a = a + 1
    return res
def abs_int(x):
    if x < 0:
        return -x
    return x
def contains_int(xs, v):
    i = 0
    while i < len(xs):
        if xs[i] == v:
            return True
        i = i + 1
    return False
def solution():
    prime_list = []
    n = 1001
    while n < 10000:
        if is_prime(n):
            prime_list = _append(prime_list, n)
        n = n + 2
    candidates = []
    i = 0
    while i < len(prime_list):
        number = prime_list[i]
        tmp = []
        perms = permutations_of_number(number)
        j = 0
        while j < len(perms):
            prime = perms[j]
            if prime % 2 != 0 and search(prime, prime_list):
                tmp = _append(tmp, prime)
            j = j + 1
        tmp = sort_int(tmp)
        if len(tmp) >= 3:
            candidates = _append(candidates, tmp)
        i = i + 1
    passed = []
    i = 0
    while i < len(candidates):
        candidate = candidates[i]
        found = False
        a = 0
        while a < len(candidate):
            b = a + 1
            while b < len(candidate):
                c = b + 1
                while c < len(candidate):
                    x = candidate[a]
                    y = candidate[b]
                    z = candidate[c]
                    if abs_int(x - y) == abs_int(y - z) and x != y and x != z and y != z:
                        triple = sort_int([x, y, z])
                        passed = _append(passed, triple)
                        found = True
                        break
                    c = c + 1
                if found:
                    break
                b = b + 1
            if found:
                break
            a = a + 1
        i = i + 1
    answer_nums = []
    i = 0
    while i < len(passed):
        seq = passed[i]
        val = int(_str(seq[0]) + _str(seq[1]) + _str(seq[2]))
        if not contains_int(answer_nums, val):
            answer_nums = _append(answer_nums, val)
        i = i + 1
    max_val = answer_nums[0]
    i = 1
    while i < len(answer_nums):
        if answer_nums[i] > max_val:
            max_val = answer_nums[i]
        i = i + 1
    return max_val
print(solution())

