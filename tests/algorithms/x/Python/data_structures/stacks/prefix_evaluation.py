# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 06:45 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]

def split_custom(s, sep):
    res = []
    current = ""
    i = 0
    while i < len(s):
        ch = s[i:i + 1]
        if ch == sep:
            res = _append(res, current)
            current = ""
        else:
            current = current + ch
        i = i + 1
    res = _append(res, current)
    return res
def tokenize(s):
    parts = split_custom(s, " ")
    res = []
    i = 0
    while i < len(parts):
        p = parts[i]
        if p != "":
            res = _append(res, p)
        i = i + 1
    return res
def is_digit(ch):
    return ch >= "0" and ch <= "9"
def is_operand(token):
    if token == "":
        return False
    i = 0
    while i < len(token):
        ch = token[i:i + 1]
        if not is_digit(ch):
            return False
        i = i + 1
    return True
def to_int(token):
    res = 0
    i = 0
    while i < len(token):
        res = res * 10 + (int(token[i:i + 1]))
        i = i + 1
    return res
def apply_op(op, a, b):
    if op == "+":
        return a + b
    if op == "-":
        return a - b
    if op == "*":
        return a * b
    if op == "/":
        return a // b
    return 0.0
def evaluate(expression):
    tokens = tokenize(expression)
    stack = []
    i = len(tokens) - 1
    while i >= 0:
        token = tokens[i]
        if token != "":
            if is_operand(token):
                stack = _append(stack, (float(to_int(token))))
            else:
                o1 = stack[len(stack) - 1]
                o2 = stack[len(stack) - 2]
                stack = stack[0:len(stack) - 2]
                res = apply_op(token, o1, o2)
                stack = _append(stack, res)
        i = i - 1
    return stack[0]
def eval_rec(tokens, pos):
    token = tokens[pos]
    next = pos + 1
    if is_operand(token):
        return [(float(to_int(token))), (float(next))]
    left = eval_rec(tokens, next)
    a = left[0]
    p1 = int(left[1])
    right = eval_rec(tokens, p1)
    b = right[0]
    p2 = right[1]
    return [apply_op(token, a, b), p2]
def evaluate_recursive(expression):
    tokens = tokenize(expression)
    res = eval_rec(tokens, 0)
    return res[0]
test_expression = "+ 9 * 2 6"
print(str(evaluate(test_expression)))
test_expression2 = "/ * 10 2 + 4 1 "
print(str(evaluate(test_expression2)))
test_expression3 = "+ * 2 3 / 8 4"
print(str(evaluate_recursive(test_expression3)))
