# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:18 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Node:
    data: int
    prev_index: int
    next_index: int

@dataclass
class LinkedList:
    nodes: [Node]
    head_idx: int
    tail_idx: int

def empty_list():
    return LinkedList(nodes=[], head_idx=-1, tail_idx=-1)
def get_head_data(ll):
    if ll.head_idx == (-1):
        return -1
    node = ll.nodes[ll.head_idx]
    return node.data
def get_tail_data(ll):
    if ll.tail_idx == (-1):
        return -1
    node = ll.nodes[ll.tail_idx]
    return node.data
def insert_before_node(ll, idx, new_idx):
    nodes = ll.nodes
    new_node = nodes[new_idx]
    new_node.next_index = idx
    node = nodes[idx]
    p = node.prev_index
    new_node.prev_index = p
    nodes[new_idx] = new_node
    if p == (-1):
        ll.head_idx = new_idx
    else:
        prev_node = nodes[p]
        prev_node.next_index = new_idx
        nodes[p] = prev_node
    node.prev_index = new_idx
    nodes[idx] = node
    ll.nodes = nodes
def insert_after_node(ll, idx, new_idx):
    nodes = ll.nodes
    new_node = nodes[new_idx]
    new_node.prev_index = idx
    node = nodes[idx]
    nxt = node.next_index
    new_node.next_index = nxt
    nodes[new_idx] = new_node
    if nxt == (-1):
        ll.tail_idx = new_idx
    else:
        next_node = nodes[nxt]
        next_node.prev_index = new_idx
        nodes[nxt] = next_node
    node.next_index = new_idx
    nodes[idx] = node
    ll.nodes = nodes
def set_head(ll, idx):
    if ll.head_idx == (-1):
        ll.head_idx = idx
        ll.tail_idx = idx
    else:
        insert_before_node(ll, ll.head_idx, idx)
def set_tail(ll, idx):
    if ll.tail_idx == (-1):
        ll.head_idx = idx
        ll.tail_idx = idx
    else:
        insert_after_node(ll, ll.tail_idx, idx)
def insert(ll, value):
    nodes = ll.nodes
    nodes = _append(nodes, Node(data=value, prev_index=-1, next_index=-1))
    idx = len(nodes) - 1
    ll.nodes = nodes
    if ll.head_idx == (-1):
        ll.head_idx = idx
        ll.tail_idx = idx
    else:
        insert_after_node(ll, ll.tail_idx, idx)
def insert_at_position(ll, position, value):
    current = ll.head_idx
    current_pos = 1
    while current != (-1):
        if current_pos == position:
            nodes = ll.nodes
            nodes = _append(nodes, Node(data=value, prev_index=-1, next_index=-1))
            new_idx = len(nodes) - 1
            ll.nodes = nodes
            insert_before_node(ll, current, new_idx)
            return
        node = ll.nodes[current]
        current = node.next_index
        current_pos = current_pos + 1
    insert(ll, value)
def get_node(ll, item):
    current = ll.head_idx
    while current != (-1):
        node = ll.nodes[current]
        if node.data == item:
            return current
        current = node.next_index
    return -1
def remove_node_pointers(ll, idx):
    nodes = ll.nodes
    node = nodes[idx]
    nxt = node.next_index
    p = node.prev_index
    if nxt != (-1):
        nxt_node = nodes[nxt]
        nxt_node.prev_index = p
        nodes[nxt] = nxt_node
    if p != (-1):
        prev_node = nodes[p]
        prev_node.next_index = nxt
        nodes[p] = prev_node
    node.next_index = -1
    node.prev_index = -1
    nodes[idx] = node
    ll.nodes = nodes
def delete_value(ll, value):
    idx = get_node(ll, value)
    if idx == (-1):
        return
    if idx == ll.head_idx:
        node = ll.nodes[idx]
        ll.head_idx = node.next_index
    if idx == ll.tail_idx:
        node = ll.nodes[idx]
        ll.tail_idx = node.prev_index
    remove_node_pointers(ll, idx)
def contains(ll, value):
    return get_node(ll, value) != (-1)
def is_empty(ll):
    return ll.head_idx == (-1)
def to_string(ll):
    res = ""
    first = True
    current = ll.head_idx
    while current != (-1):
        node = ll.nodes[current]
        val = str(node.data)
        if first:
            res = val
            first = False
        else:
            res = res + " " + val
        current = node.next_index
    return res
def print_list(ll):
    current = ll.head_idx
    while current != (-1):
        node = ll.nodes[current]
        print(str(node.data))
        current = node.next_index
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        ll = empty_list()
        print(str(get_head_data(ll)))
        print(str(get_tail_data(ll)))
        print(str(is_empty(ll)))
        insert(ll, 10)
        print(str(get_head_data(ll)))
        print(str(get_tail_data(ll)))
        insert_at_position(ll, 3, 20)
        print(str(get_head_data(ll)))
        print(str(get_tail_data(ll)))
        nodes = ll.nodes
        nodes = _append(nodes, Node(data=1000, prev_index=-1, next_index=-1))
        idx_head = len(nodes) - 1
        ll.nodes = nodes
        set_head(ll, idx_head)
        nodes = ll.nodes
        nodes = _append(nodes, Node(data=2000, prev_index=-1, next_index=-1))
        idx_tail = len(nodes) - 1
        ll.nodes = nodes
        set_tail(ll, idx_tail)
        print_list(ll)
        print(str(is_empty(ll)))
        print_list(ll)
        print(str(10 in ll))
        delete_value(ll, 10)
        print(str(10 in ll))
        delete_value(ll, 2000)
        print(str(get_tail_data(ll)))
        delete_value(ll, 1000)
        print(str(get_tail_data(ll)))
        print(str(get_head_data(ll)))
        print_list(ll)
        delete_value(ll, 20)
        print_list(ll)
        i = 1
        while i < 10:
            insert(ll, i)
            i = i + 1
        print_list(ll)
        ll2 = empty_list()
        insert_at_position(ll2, 1, 10)
        print(to_string(ll2))
        insert_at_position(ll2, 2, 20)
        print(to_string(ll2))
        insert_at_position(ll2, 1, 30)
        print(to_string(ll2))
        insert_at_position(ll2, 3, 40)
        print(to_string(ll2))
        insert_at_position(ll2, 5, 50)
        print(to_string(ll2))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
