# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:18 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class RadixNode:
    prefix: str
    is_leaf: bool
    children: Dict[str, int]

@dataclass
class RadixTree:
    nodes: [RadixNode]

@dataclass
class MatchResult:
    common: str
    rem_prefix: str
    rem_word: str

def new_node(prefix, is_leaf):
    return RadixNode(prefix=prefix, is_leaf=is_leaf, children={})
def new_tree():
    nodes = [new_node("", False)]
    return RadixTree(nodes=nodes)
def match_prefix(node, word):
    x = 0
    p = node.prefix
    w = word
    min_len = len(p)
    if len(w) < min_len:
        min_len = len(w)
    while x < min_len:
        if p[x:x + 1] != w[x:x + 1]:
            break
        x = x + 1
    common = p[0:x]
    rem_prefix = p[x:len(p)]
    rem_word = w[x:len(w)]
    return MatchResult(common=common, rem_prefix=rem_prefix, rem_word=rem_word)
def insert_many(tree, words):
    for w in words:
        insert(tree, 0, w)
def insert(tree, idx, word):
    nodes = tree.nodes
    node = nodes[idx]
    if (node.prefix == word) and (not node.is_leaf):
        node.is_leaf = True
        nodes[idx] = node
        tree.nodes = nodes
        return
    first = word[0:1]
    children = node.children
    if not has_key(children, first):
        new_idx = len(nodes)
        nodes = _append(nodes, new_node(word, True))
        children[first] = new_idx
        node.children = children
        nodes[idx] = node
        tree.nodes = nodes
        return
    child_idx = children[first]
    child = nodes[child_idx]
    res = match_prefix(child, word)
    if res.rem_prefix == "":
        insert(tree, child_idx, res.rem_word)
        return
    child.prefix = res.rem_prefix
    nodes[child_idx] = child
    new_children = {}
    new_children[res.rem_prefix[0:1]] = child_idx
    new_idx = len(nodes)
    nodes = _append(nodes, new_node(res.common, False))
    nodes[new_idx].children = new_children
    if res.rem_word == "":
        nodes[new_idx].is_leaf = True
    else:
        insert(tree, new_idx, res.rem_word)
    children[first] = new_idx
    node.children = children
    nodes[idx] = node
    tree.nodes = nodes
def find(tree, idx, word):
    nodes = tree.nodes
    node = nodes[idx]
    first = word[0:1]
    children = node.children
    if not has_key(children, first):
        return False
    child_idx = children[first]
    child = nodes[child_idx]
    res = match_prefix(child, word)
    if res.rem_prefix != "":
        return False
    if res.rem_word == "":
        return child.is_leaf
    return find(tree, child_idx, res.rem_word)
def remove_key(m, k):
    out = {}
    for key in m:
        if key != k:
            out[key] = m[key]
    return out
def has_key(m, k):
    for key in m:
        if key == k:
            return True
    return False
def delete(tree, idx, word):
    nodes = tree.nodes
    node = nodes[idx]
    first = word[0:1]
    children = node.children
    if not has_key(children, first):
        return False
    child_idx = children[first]
    child = nodes[child_idx]
    res = match_prefix(child, word)
    if res.rem_prefix != "":
        return False
    if res.rem_word != "":
        deleted = delete(tree, child_idx, res.rem_word)
        if deleted:
            nodes = tree.nodes
            node = nodes[idx]
        return deleted
    if not child.is_leaf:
        return False
    if len(child.children) == 0:
        children = remove_key(children, first)
        node.children = children
        nodes[idx] = node
        tree.nodes = nodes
        if (len(children) == 1) and (not node.is_leaf):
            only_key = ""
            for k in children:
                only_key = k
            merge_idx = children[only_key]
            merge_node = nodes[merge_idx]
            node.is_leaf = merge_node.is_leaf
            node.prefix = node.prefix + merge_node.prefix
            node.children = merge_node.children
            nodes[idx] = node
            tree.nodes = nodes
    else:
        if len(child.children) > 1:
            child.is_leaf = False
            nodes[child_idx] = child
            tree.nodes = nodes
        else:
            only_key = ""
            for k in child.children:
                only_key = k
            merge_idx = child.children[only_key]
            merge_node = nodes[merge_idx]
            child.is_leaf = merge_node.is_leaf
            child.prefix = child.prefix + merge_node.prefix
            child.children = merge_node.children
            nodes[child_idx] = child
            tree.nodes = nodes
    return True
def print_tree(tree, idx, height):
    nodes = tree.nodes
    node = nodes[idx]
    if node.prefix != "":
        line = ""
        i = 0
        while i < height:
            line = line + "-"
            i = i + 1
        line = line + " " + node.prefix
        if node.is_leaf:
            line = line + "  (leaf)"
        print(line)
    children = node.children
    for k in children:
        child_idx = children[k]
        print_tree(tree, child_idx, height + 1)
def test_trie():
    words = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"]
    tree = new_tree()
    insert_many(tree, words)
    ok = True
    for w in words:
        if not find(tree, 0, w):
            ok = False
    if find(tree, 0, "bandanas"):
        ok = False
    if find(tree, 0, "apps"):
        ok = False
    delete(tree, 0, "all")
    if find(tree, 0, "all"):
        ok = False
    delete(tree, 0, "banana")
    if find(tree, 0, "banana"):
        ok = False
    if not find(tree, 0, "bananas"):
        ok = False
    return ok
def pytests():
    if not test_trie():
        panic("test failed")
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        tree = new_tree()
        words = ["banana", "bananas", "bandanas", "bandana", "band", "apple", "all", "beast"]
        insert_many(tree, words)
        print("Words: " + str(words))
        print("Tree:")
        print_tree(tree, 0, 0)
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
