# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:44 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Bucket:
    state: int
    key: int
    val: int

@dataclass
class HashMap:
    buckets: [Bucket]
    len: int
    cap_num: int
    cap_den: int
    initial_size: int

def make_buckets(n):
    buckets = []
    i = 0
    while i < n:
        buckets = _append(buckets, Bucket(state=0, key=0, val=0))
        i = i + 1
    return buckets
def hashmap_new(initial_size):
    return HashMap(buckets=make_buckets(initial_size), len=0, cap_num=3, cap_den=4, initial_size=initial_size)
def bucket_index(hm, key):
    ind = key % len(hm.buckets)
    if ind < 0:
        ind = ind + len(hm.buckets)
    return ind
def next_index(hm, ind):
    return (ind + 1) % len(hm.buckets)
def try_set(hm, ind, key, val):
    buckets = hm.buckets
    b = buckets[ind]
    if b.state == 0 or b.state == 2:
        buckets[ind] = Bucket(state=1, key=key, val=val)
        hm.buckets = buckets
        hm.len = hm.len + 1
        return True
    if b.key == key:
        buckets[ind] = Bucket(state=1, key=key, val=val)
        hm.buckets = buckets
        return True
    return False
def is_full(hm):
    limit = len(hm.buckets) * hm.cap_num // hm.cap_den
    return hm.len >= limit
def is_sparse(hm):
    if len(hm.buckets) <= hm.initial_size:
        return False
    limit = len(hm.buckets) * hm.cap_num // (2 * hm.cap_den)
    return hm.len < limit
def resize(hm, new_size):
    old = hm.buckets
    hm.buckets = make_buckets(new_size)
    hm.len = 0
    i = 0
    while i < len(old):
        it = old[i]
        if it.state == 1:
            add_item(hm, it.key, it.val)
        i = i + 1
def size_up(hm):
    resize(hm, len(hm.buckets) * 2)
def size_down(hm):
    resize(hm, len(hm.buckets) // 2)
def add_item(hm, key, val):
    ind = bucket_index(hm, key)
    i = 0
    while i < len(hm.buckets):
        if try_set(hm, ind, key, val):
            break
        ind = next_index(hm, ind)
        i = i + 1
def hashmap_set(hm, key, val):
    if is_full(hm):
        size_up(hm)
    add_item(hm, key, val)
def hashmap_get(hm, key):
    buckets = hm.buckets
    ind = bucket_index(hm, key)
    i = 0
    while i < len(buckets):
        it = buckets[ind]
        if it.state == 0:
            break
        if it.state == 1 and it.key == key:
            return it.val
        ind = next_index(hm, ind)
        i = i + 1
    return 0
def hashmap_del(hm, key):
    buckets = hm.buckets
    ind = bucket_index(hm, key)
    i = 0
    while i < len(buckets):
        it = buckets[ind]
        if it.state == 0:
            print("KeyError: " + str(key))
            return
        if it.state == 1 and it.key == key:
            buckets[ind] = Bucket(state=2, key=0, val=0)
            hm.buckets = buckets
            hm.len = hm.len - 1
            break
        ind = next_index(hm, ind)
        i = i + 1
    if is_sparse(hm):
        size_down(hm)
def hashmap_len(hm):
    return hm.len
def hashmap_repr(hm):
    out = "HashMap("
    first = True
    i = 0
    while i < len(hm.buckets):
        b = hm.buckets[i]
        if b.state == 1:
            if not first:
                out = out + ", "
            else:
                first = False
            out = out + str(b.key) + ": " + str(b.val)
        i = i + 1
    out = out + ")"
    return out
hm = hashmap_new(5)
hashmap_set(hm, 1, 10)
hashmap_set(hm, 2, 20)
hashmap_set(hm, 3, 30)
print(hashmap_repr(hm))
print(str(hashmap_get(hm, 2)))
hashmap_del(hm, 1)
print(hashmap_repr(hm))
print(str(hashmap_len(hm)))
