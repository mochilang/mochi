# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:18 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    @dataclass
    class HashTable:
        size_table: int
        values: [int]
        lim_charge: float
    def create_hash_table(size):
        vals = []
        i = 0
        while i < size:
            vals = _append(vals, None)
            i = i + 1
        return HashTable(size_table=size, values=vals, lim_charge=0.75)
    def hash_function(table, key):
        return key % table.size_table
    def balanced_factor(table):
        count = 0
        i = 0
        while i < len(table.values):
            if table.values[i] != None:
                count = count + 1
            i = i + 1
        return (float(count)) // (float(table.size_table))
    def collision_resolution(table, key):
        i = 1
        new_key = hash_function(table, key + i * i)
        while table.values[new_key] != None and table.values[new_key] != key:
            i = i + 1
            if balanced_factor(table) >= table.lim_charge:
                return table.size_table
            new_key = hash_function(table, key + i * i)
        return new_key
    def insert_data(table, data):
        key = hash_function(table, data)
        vals = table.values
        if vals[key] == None:
            vals[key] = data
        else:
            if vals[key] == data:
                table.values = vals
                return
            else:
                new_key = collision_resolution(table, key)
                if new_key < len(vals) and vals[new_key] == None:
                    vals[new_key] = data
        table.values = vals
    def int_to_string(n):
        if n == 0:
            return "0"
        num = n
        neg = False
        if num < 0:
            neg = True
            num = -num
        res = ""
        while num > 0:
            digit = num % 10
            ch = "0123456789"[digit:digit + 1]
            res = ch + res
            num = num // 10
        if neg:
            res = "-" + res
        return res
    def keys_to_string(table):
        result = "{"
        first = True
        i = 0
        while i < len(table.values):
            v = table.values[i]
            if v != None:
                if not first:
                    result = result + ", "
                result = result + int_to_string(i) + ": " + int_to_string(v)
                first = False
            i = i + 1
        result = result + "}"
        return result
    qp = create_hash_table(8)
    insert_data(qp, 0)
    insert_data(qp, 999)
    insert_data(qp, 111)
    print(keys_to_string(qp))
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
