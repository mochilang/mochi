# Code generated by Mochi transpiler.
# Version 0.10.72, generated on 2025-08-24 16:59 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


import builtins
def _str(v):
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(int(builtins.round(v)))
        return builtins.str(v)
    return builtins.str(v)

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class Entry:
        key: str
        value: str
    @dataclass
    class HashMap:
        entries: List[Entry]
    @dataclass
    class GetResult:
        found: bool
        value: str
    @dataclass
    class DelResult:
        map_: HashMap
        ok: bool
    def make_hash_map():
        return HashMap(entries=[])
    def hm_len(m):
        return len(m.entries)
    def hm_set(m, key, value):
        entries = m.entries
        updated = False
        new_entries = []
        i = 0
        while i < len(entries):
            e = entries[i]
            if e.key == key:
                new_entries = _append(new_entries, Entry(key=key, value=value))
                updated = True
            else:
                new_entries = _append(new_entries, e)
            i = i + 1
        if not updated:
            new_entries = _append(new_entries, Entry(key=key, value=value))
        return HashMap(entries=new_entries)
    def hm_get(m, key):
        i = 0
        while i < len(m.entries):
            e = m.entries[i]
            if e.key == key:
                return GetResult(found=True, value=e.value)
            i = i + 1
        return GetResult(found=False, value="")
    def hm_del(m, key):
        entries = m.entries
        new_entries = []
        removed = False
        i = 0
        while i < len(entries):
            e = entries[i]
            if e.key == key:
                removed = True
            else:
                new_entries = _append(new_entries, e)
            i = i + 1
        if removed:
            return DelResult(map_=HashMap(entries=new_entries), ok=True)
        return DelResult(map_=m, ok=False)
    def test_add_items():
        h = make_hash_map()
        h = hm_set(h, "key_a", "val_a")
        h = hm_set(h, "key_b", "val_b")
        a = hm_get(h, "key_a")
        b = hm_get(h, "key_b")
        return hm_len(h) == 2 and a.found and b.found and a.value == "val_a" and b.value == "val_b"
    def test_overwrite_items():
        h = make_hash_map()
        h = hm_set(h, "key_a", "val_a")
        h = hm_set(h, "key_a", "val_b")
        a = hm_get(h, "key_a")
        return hm_len(h) == 1 and a.found and a.value == "val_b"
    def test_delete_items():
        h = make_hash_map()
        h = hm_set(h, "key_a", "val_a")
        h = hm_set(h, "key_b", "val_b")
        d1 = hm_del(h, "key_a")
        h = d1.map_
        d2 = hm_del(h, "key_b")
        h = d2.map_
        h = hm_set(h, "key_a", "val_a")
        d3 = hm_del(h, "key_a")
        h = d3.map_
        return hm_len(h) == 0
    def test_access_absent_items():
        h = make_hash_map()
        g1 = hm_get(h, "key_a")
        d1 = hm_del(h, "key_a")
        h = d1.map_
        h = hm_set(h, "key_a", "val_a")
        d2 = hm_del(h, "key_a")
        h = d2.map_
        d3 = hm_del(h, "key_a")
        h = d3.map_
        g2 = hm_get(h, "key_a")
        return g1.found == False and d1.ok == False and d2.ok and d3.ok == False and g2.found == False and hm_len(h) == 0
    def test_add_with_resize_up():
        h = make_hash_map()
        i = 0
        while i < 5:
            s = _str(i)
            h = hm_set(h, s, s)
            i = i + 1
        return hm_len(h) == 5
    def test_add_with_resize_down():
        h = make_hash_map()
        i = 0
        while i < 5:
            s = _str(i)
            h = hm_set(h, s, s)
            i = i + 1
        j = 0
        while j < 5:
            s = _str(j)
            d = hm_del(h, s)
            h = d.map_
            j = j + 1
        h = hm_set(h, "key_a", "val_b")
        a = hm_get(h, "key_a")
        return hm_len(h) == 1 and a.found and a.value == "val_b"
    print(("True" if test_add_items() else "False"))
    print(("True" if test_overwrite_items() else "False"))
    print(("True" if test_delete_items() else "False"))
    print(("True" if test_access_absent_items() else "False"))
    print(("True" if test_add_with_resize_up() else "False"))
    print(("True" if test_add_with_resize_down() else "False"))
    print(("True" if True else "False"))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": (_bench_mem_end - _bench_mem_start)*1024, "name": "main"}, indent=2))

