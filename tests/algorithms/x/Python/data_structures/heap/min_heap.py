# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:18 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    @dataclass
    class Node:
        name: str
        val: int
    @dataclass
    class MinHeap:
        heap: [Node]
        idx_of_element: Dict[str, int]
        heap_dict: Dict[str, int]
    def get_parent_idx(idx):
        return (idx - 1) // 2
    def get_left_child_idx(idx):
        return idx * 2 + 1
    def get_right_child_idx(idx):
        return idx * 2 + 2
    def remove_key(m, k):
        out = {}
        for key in m:
            if key != k:
                out[key] = m[key]
        return out
    def slice_without_last(xs):
        res = []
        i = 0
        while i < len(xs) - 1:
            res = _append(res, xs[i])
            i = i + 1
        return res
    def sift_down(mh, idx):
        heap = mh.heap
        idx_map = mh.idx_of_element
        i = idx
        while True:
            left = get_left_child_idx(i)
            right = get_right_child_idx(i)
            smallest = i
            if left < len(heap) and heap[left].val < heap[smallest].val:
                smallest = left
            if right < len(heap) and heap[right].val < heap[smallest].val:
                smallest = right
            if smallest != i:
                tmp = heap[i]
                heap[i] = heap[smallest]
                heap[smallest] = tmp
                idx_map[heap[i].name] = i
                idx_map[heap[smallest].name] = smallest
                i = smallest
            else:
                break
        mh.heap = heap
        mh.idx_of_element = idx_map
    def sift_up(mh, idx):
        heap = mh.heap
        idx_map = mh.idx_of_element
        i = idx
        p = get_parent_idx(i)
        while p >= 0 and heap[p].val > heap[i].val:
            tmp = heap[p]
            heap[p] = heap[i]
            heap[i] = tmp
            idx_map[heap[p].name] = p
            idx_map[heap[i].name] = i
            i = p
            p = get_parent_idx(i)
        mh.heap = heap
        mh.idx_of_element = idx_map
    def new_min_heap(array):
        idx_map = {}
        val_map = {}
        heap = array
        i = 0
        while i < len(array):
            n = array[i]
            idx_map[n.name] = i
            val_map[n.name] = n.val
            i = i + 1
        mh = MinHeap(heap=heap, idx_of_element=idx_map, heap_dict=val_map)
        start = get_parent_idx(len(array) - 1)
        while start >= 0:
            sift_down(mh, start)
            start = start - 1
        return mh
    def peek(mh):
        return mh.heap[0]
    def remove_min(mh):
        heap = mh.heap
        idx_map = mh.idx_of_element
        val_map = mh.heap_dict
        last_idx = len(heap) - 1
        top = heap[0]
        last = heap[last_idx]
        heap[0] = last
        idx_map[last.name] = 0
        heap = slice_without_last(heap)
        idx_map = remove_key(idx_map, top.name)
        val_map = remove_key(val_map, top.name)
        mh.heap = heap
        mh.idx_of_element = idx_map
        mh.heap_dict = val_map
        if len(heap) > 0:
            sift_down(mh, 0)
        return top
    def insert(mh, node):
        heap = mh.heap
        idx_map = mh.idx_of_element
        val_map = mh.heap_dict
        heap = _append(heap, node)
        idx = len(heap) - 1
        idx_map[node.name] = idx
        val_map[node.name] = node.val
        mh.heap = heap
        mh.idx_of_element = idx_map
        mh.heap_dict = val_map
        sift_up(mh, idx)
    def is_empty(mh):
        return len(mh.heap) == 0
    def get_value(mh, key):
        return mh.heap_dict[key]
    def decrease_key(mh, node, new_value):
        heap = mh.heap
        val_map = mh.heap_dict
        idx_map = mh.idx_of_element
        idx = idx_map[node.name]
        if not (heap[idx].val > new_value):
            panic("newValue must be less than current value")
        node.val = new_value
        heap[idx].val = new_value
        val_map[node.name] = new_value
        mh.heap = heap
        mh.heap_dict = val_map
        sift_up(mh, idx)
    def node_to_string(n):
        return "Node(" + n.name + ", " + str(n.val) + ")"
    r = Node(name="R", val=-1)
    b = Node(name="B", val=6)
    a = Node(name="A", val=3)
    x = Node(name="X", val=1)
    e = Node(name="E", val=4)
    my_min_heap = new_min_heap([r, b, a, x, e])
    print("Min Heap - before decrease key")
    for n in my_min_heap.heap:
        print(node_to_string(n))
    print("Min Heap - After decrease key of node [B -> -17]")
    decrease_key(my_min_heap, b, -17)
    for n in my_min_heap.heap:
        print(node_to_string(n))
    print(str(get_value(my_min_heap, "B")))
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
