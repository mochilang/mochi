# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:44 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class DS:
    parent: [int]
    rank: [int]

@dataclass
class FindResult:
    ds: DS
    root: int

def make_set(ds, x):
    p = ds.parent
    r = ds.rank
    p[x] = x
    r[x] = 0
    return DS(parent=p, rank=r)
def find_set(ds, x):
    if ds.parent[x] == x:
        return FindResult(ds=ds, root=x)
    res = find_set(ds, ds.parent[x])
    p = res.ds.parent
    p[x] = res.root
    return FindResult(ds=DS(parent=p, rank=res.ds.rank), root=res.root)
def union_set(ds, x, y):
    fx = find_set(ds, x)
    ds1 = fx.ds
    x_root = fx.root
    fy = find_set(ds1, y)
    ds2 = fy.ds
    y_root = fy.root
    if x_root == y_root:
        return ds2
    p = ds2.parent
    r = ds2.rank
    if r[x_root] > r[y_root]:
        p[y_root] = x_root
    else:
        p[x_root] = y_root
        if r[x_root] == r[y_root]:
            r[y_root] = r[y_root] + 1
    return DS(parent=p, rank=r)
def same_python_set(a, b):
    if a < 3 and b < 3:
        return True
    if a >= 3 and a < 6 and b >= 3 and b < 6:
        return True
    return False
ds = DS(parent=[], rank=[])
i = 0
while i < 6:
    ds.parent = _append(ds.parent, 0)
    ds.rank = _append(ds.rank, 0)
    ds = make_set(ds, i)
    i = i + 1
ds = union_set(ds, 0, 1)
ds = union_set(ds, 1, 2)
ds = union_set(ds, 3, 4)
ds = union_set(ds, 3, 5)
i = 0
while i < 6:
    j = 0
    while j < 6:
        res_i = find_set(ds, i)
        ds = res_i.ds
        root_i = res_i.root
        res_j = find_set(ds, j)
        ds = res_j.ds
        root_j = res_j.root
        same = same_python_set(i, j)
        root_same = root_i == root_j
        if same:
            if not root_same:
                panic("nodes should be in same set")
        else:
            if root_same:
                panic("nodes should be in different sets")
        j = j + 1
    i = i + 1
i = 0
while i < 6:
    res = find_set(ds, i)
    ds = res.ds
    print(str(res.root))
    i = i + 1
