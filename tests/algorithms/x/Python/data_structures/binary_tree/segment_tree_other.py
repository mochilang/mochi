# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]

@dataclass
class Node:
    start: int
    end: int
    val: int
    mid: int
    left: int
    right: int

@dataclass
class BuildResult:
    nodes: [Node]
    idx: int

@dataclass
class SegmentTree:
    arr: [int]
    op: int

def combine(a, b, op):
    if op == 0:
        return a + b
    if op == 1:
        if a > b:
            return a
        return b
    if a < b:
        return a
    return b
def build_tree(nodes, arr, start, end, op):
    if start == end:
        node = Node(start=start, end=end, val=arr[start], mid=start, left=-1, right=-1)
        new_nodes = _append(nodes, node)
        return BuildResult(nodes=new_nodes, idx=len(new_nodes) - 1)
    mid = (start + end) // 2
    left_res = build_tree(nodes, arr, start, mid, op)
    right_res = build_tree(left_res.nodes, arr, mid + 1, end, op)
    left_node = right_res.nodes[left_res.idx]
    right_node = right_res.nodes[right_res.idx]
    val = combine(left_node.val, right_node.val, op)
    parent = Node(start=start, end=end, val=val, mid=mid, left=left_res.idx, right=right_res.idx)
    new_nodes = _append(right_res.nodes, parent)
    return BuildResult(nodes=new_nodes, idx=len(new_nodes) - 1)
def new_segment_tree(collection, op):
    return SegmentTree(arr=collection, op=op)
def update(tree, i, val):
    new_arr = []
    idx = 0
    while idx < len(tree.arr):
        if idx == i:
            new_arr = _append(new_arr, val)
        else:
            new_arr = _append(new_arr, tree.arr[idx])
        idx = idx + 1
    return SegmentTree(arr=new_arr, op=tree.op)
def query_range(tree, i, j):
    result = tree.arr[i]
    idx = i + 1
    while idx <= j:
        result = combine(result, tree.arr[idx], tree.op)
        idx = idx + 1
    return result
def traverse(tree):
    if len(tree.arr) == 0:
        return []
    res = build_tree([], tree.arr, 0, len(tree.arr) - 1, tree.op)
    return res.nodes
def node_to_string(node):
    return "SegmentTreeNode(start=" + str(node.start) + ", end=" + str(node.end) + ", val=" + str(node.val) + ")"
def print_traverse(tree):
    nodes = traverse(tree)
    i = 0
    while i < len(nodes):
        print(node_to_string(nodes[i]))
        i = i + 1
    print("")
arr = [2, 1, 5, 3, 4]
for op in [0, 1, 2]:
    print("**************************************************")
    tree = new_segment_tree(arr, op)
    print_traverse(tree)
    tree = update(tree, 1, 5)
    print_traverse(tree)
    print(query_range(tree, 3, 4))
    print(query_range(tree, 2, 2))
    print(query_range(tree, 1, 3))
    print("")
