# Code generated by Mochi transpiler.
# Version 0.10.72, generated on 2025-08-24 16:59 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


import builtins
def _str(v):
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(int(builtins.round(v)))
        return builtins.str(v)
    return builtins.str(v)

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class Node:
        start: int
        end: int
        val: int
        mid: int
        left: int
        right: int
    @dataclass
    class BuildResult:
        nodes: List[Node]
        idx: int
    @dataclass
    class SegmentTree:
        arr: List[int]
        op: int
    def combine(a, b, op):
        if op == 0:
            return a + b
        if op == 1:
            if a > b:
                return a
            return b
        if a < b:
            return a
        return b
    def build_tree(nodes, arr, start, end, op):
        if start == end:
            node = Node(start=start, end=end, val=arr[start], mid=start, left=-1, right=-1)
            new_nodes = _append(nodes, node)
            return BuildResult(nodes=new_nodes, idx=len(new_nodes) - 1)
        mid = (start + end) // 2
        left_res = build_tree(nodes, arr, start, mid, op)
        right_res = build_tree(left_res.nodes, arr, mid + 1, end, op)
        left_node = right_res.nodes[left_res.idx]
        right_node = right_res.nodes[right_res.idx]
        val = combine(left_node.val, right_node.val, op)
        parent = Node(start=start, end=end, val=val, mid=mid, left=left_res.idx, right=right_res.idx)
        new_nodes = _append(right_res.nodes, parent)
        return BuildResult(nodes=new_nodes, idx=len(new_nodes) - 1)
    def new_segment_tree(collection, op):
        return SegmentTree(arr=collection, op=op)
    def update(tree, i, val):
        new_arr = []
        idx = 0
        while idx < len(tree.arr):
            if idx == i:
                new_arr = _append(new_arr, val)
            else:
                new_arr = _append(new_arr, tree.arr[idx])
            idx = idx + 1
        return SegmentTree(arr=new_arr, op=tree.op)
    def query_range(tree, i, j):
        result = tree.arr[i]
        idx = i + 1
        while idx <= j:
            result = combine(result, tree.arr[idx], tree.op)
            idx = idx + 1
        return result
    def traverse(tree):
        if len(tree.arr) == 0:
            return []
        res = build_tree([], tree.arr, 0, len(tree.arr) - 1, tree.op)
        return res.nodes
    def node_to_string(node):
        return "SegmentTreeNode(start=" + _str(node.start) + ", end=" + _str(node.end) + ", val=" + _str(node.val) + ")"
    def print_traverse(tree):
        nodes = traverse(tree)
        i = 0
        while i < len(nodes):
            print(node_to_string(nodes[i]))
            i = i + 1
        print("")
    arr = [2, 1, 5, 3, 4]
    for op in [0, 1, 2]:
        print("**************************************************")
        tree = new_segment_tree(arr, op)
        print_traverse(tree)
        tree = update(tree, 1, 5)
        print_traverse(tree)
        print(query_range(tree, 3, 4))
        print(query_range(tree, 2, 2))
        print(query_range(tree, 1, 3))
        print("")
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": (_bench_mem_end - _bench_mem_start)*1024, "name": "main"}, indent=2))

