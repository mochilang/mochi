# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class FenwickTree:
    size: int
    tree: [int]

def fenwick_from_list(arr):
    size = len(arr)
    tree = []
    i = 0
    while i < size:
        tree = _append(tree, arr[i])
        i = i + 1
    i = 1
    while i < size:
        j = fenwick_next(i)
        if j < size:
            tree[j] = tree[j] + tree[i]
        i = i + 1
    return FenwickTree(size=size, tree=tree)
def fenwick_empty(size):
    tree = []
    i = 0
    while i < size:
        tree = _append(tree, 0)
        i = i + 1
    return FenwickTree(size=size, tree=tree)
def fenwick_get_array(f):
    arr = []
    i = 0
    while i < f.size:
        arr = _append(arr, f.tree[i])
        i = i + 1
    i = f.size - 1
    while i > 0:
        j = fenwick_next(i)
        if j < f.size:
            arr[j] = arr[j] - arr[i]
        i = i - 1
    return arr
def bit_and(a, b):
    ua = a
    ub = b
    res = 0
    bit = 1
    while ua != 0 or ub != 0:
        if ua % 2 == 1 and ub % 2 == 1:
            res = res + bit
        ua = int((ua // 2))
        ub = int((ub // 2))
        bit = bit * 2
    return res
def low_bit(x):
    if x == 0:
        return 0
    return x - bit_and(x, x - 1)
def fenwick_next(index):
    return index + low_bit(index)
def fenwick_prev(index):
    return index - low_bit(index)
def fenwick_add(f, index, value):
    tree = f.tree
    if index == 0:
        tree[0] = tree[0] + value
        return FenwickTree(size=f.size, tree=tree)
    i = index
    while i < f.size:
        tree[i] = tree[i] + value
        i = fenwick_next(i)
    return FenwickTree(size=f.size, tree=tree)
def fenwick_update(f, index, value):
    current = fenwick_get(f, index)
    return fenwick_add(f, index, value - current)
def fenwick_prefix(f, right):
    if right == 0:
        return 0
    result = f.tree[0]
    r = right - 1
    while r > 0:
        result = result + f.tree[r]
        r = fenwick_prev(r)
    return result
def fenwick_query(f, left, right):
    return fenwick_prefix(f, right) - fenwick_prefix(f, left)
def fenwick_get(f, index):
    return fenwick_query(f, index, index + 1)
def fenwick_rank_query(f, value):
    v = value - f.tree[0]
    if v < 0:
        return -1
    j = 1
    while j * 2 < f.size:
        j = j * 2
    i = 0
    jj = j
    while jj > 0:
        if i + jj < f.size and f.tree[i + jj] <= v:
            v = v - f.tree[i + jj]
            i = i + jj
        jj = jj // 2
    return i
f_base = fenwick_from_list([1, 2, 3, 4, 5])
print(fenwick_get_array(f_base))
f = fenwick_from_list([1, 2, 3, 4, 5])
f = fenwick_add(f, 0, 1)
f = fenwick_add(f, 1, 2)
f = fenwick_add(f, 2, 3)
f = fenwick_add(f, 3, 4)
f = fenwick_add(f, 4, 5)
print(fenwick_get_array(f))
f2 = fenwick_from_list([1, 2, 3, 4, 5])
print(fenwick_prefix(f2, 3))
print(fenwick_query(f2, 1, 4))
f3 = fenwick_from_list([1, 2, 0, 3, 0, 5])
print(fenwick_rank_query(f3, 0))
print(fenwick_rank_query(f3, 2))
print(fenwick_rank_query(f3, 1))
print(fenwick_rank_query(f3, 3))
print(fenwick_rank_query(f3, 5))
print(fenwick_rank_query(f3, 6))
print(fenwick_rank_query(f3, 11))
