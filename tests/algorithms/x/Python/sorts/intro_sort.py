# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-11 16:20 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def insertion_sort(a, start, end_):
    arr = a
    i = start
    while i < end_:
        key = arr[i]
        j = i
        while j > start and arr[j - 1] > key:
            arr[j] = arr[j - 1]
            j = j - 1
        arr[j] = key
        i = i + 1
    return arr
def heapify(a, index, heap_size):
    arr = a
    largest = index
    left = 2 * index + 1
    right = 2 * index + 2
    if left < heap_size and arr[left] > arr[largest]:
        largest = left
    if right < heap_size and arr[right] > arr[largest]:
        largest = right
    if largest != index:
        temp = arr[index]
        arr[index] = arr[largest]
        arr[largest] = temp
        arr = heapify(arr, largest, heap_size)
    return arr
def heap_sort(a):
    arr = a
    n = len(arr)
    if n <= 1:
        return arr
    i = n // 2
    while True:
        arr = heapify(arr, i, n)
        if i == 0:
            break
        i = i - 1
    i = n - 1
    while i > 0:
        temp = arr[0]
        arr[0] = arr[i]
        arr[i] = temp
        arr = heapify(arr, 0, i)
        i = i - 1
    return arr
def median_of_3(arr, first, middle, last):
    a = arr[first]
    b = arr[middle]
    c = arr[last]
    if (a > b and a < c) or (a < b and a > c):
        return a
    else:
        if (b > a and b < c) or (b < a and b > c):
            return b
        else:
            return c
def partition(arr, low, high, pivot):
    i = low
    j = high
    while True:
        while arr[i] < pivot:
            i = i + 1
        j = j - 1
        while pivot < arr[j]:
            j = j - 1
        if i >= j:
            return i
        temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
        i = i + 1
def int_log2(n):
    v = n
    r = 0
    while v > 1:
        v = v // 2
        r = r + 1
    return r
def intro_sort(arr, start, end_, size_threshold, max_depth):
    array = arr
    s = start
    e = end_
    depth = max_depth
    while e - s > size_threshold:
        if depth == 0:
            return heap_sort(array)
        depth = depth - 1
        pivot = median_of_3(array, s, s + ((e - s) // 2) + 1, e - 1)
        p = partition(array, s, e, pivot)
        array = intro_sort(array, p, e, size_threshold, depth)
        e = p
    res = insertion_sort(array, s, e)
    _ = len(res)
    return res
def intro_sort_main(arr):
    if len(arr) == 0:
        print(arr)
        return
    max_depth = 2 * int_log2(len(arr))
    sorted = intro_sort(arr, 0, len(arr), 16, max_depth)
    print(sorted)
example1 = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
intro_sort_main(example1)
example2 = [21, 15, 11, 45, -2, -11, 46]
intro_sort_main(example2)

