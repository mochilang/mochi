# Code generated by Mochi transpiler.
# Version 0.10.64, generated on 2025-08-12 15:27 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    PI = 3.141592653589793
    TWO_PI = 6.283185307179586
    g = 9.80665
    def _mod(x, m):
        return x - (float(int(x // m))) * m
    def sin(x):
        y = _mod(x + PI, TWO_PI) - PI
        y2 = y * y
        y3 = y2 * y
        y5 = y3 * y2
        y7 = y5 * y2
        return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
    def deg_to_rad(deg):
        return deg * PI / 180.0
    def floor(x):
        i = int(x)
        if (float(i)) > x:
            i = i - 1
        return float(i)
    def pow10(n):
        result = 1.0
        i = 0
        while i < n:
            result = result * 10.0
            i = i + 1
        return result
    def round(x, n):
        m = pow10(n)
        y = floor(x * m + 0.5)
        return y // m
    def check_args(init_velocity, angle):
        if angle > 90.0 or angle < 1.0:
            panic("Invalid angle. Range is 1-90 degrees.")
        if init_velocity < 0.0:
            panic("Invalid velocity. Should be a positive number.")
    def horizontal_distance(init_velocity, angle):
        check_args(init_velocity, angle)
        radians = deg_to_rad(2.0 * angle)
        return round((init_velocity * init_velocity * sin(radians)) / g, 2)
    def max_height(init_velocity, angle):
        check_args(init_velocity, angle)
        radians = deg_to_rad(angle)
        s = sin(radians)
        return round((init_velocity * init_velocity * s * s) / (2.0 * g), 2)
    def total_time(init_velocity, angle):
        check_args(init_velocity, angle)
        radians = deg_to_rad(angle)
        return round((2.0 * init_velocity * sin(radians)) / g, 2)
    v0 = 25.0
    angle = 20.0
    print(horizontal_distance(v0, angle))
    print(max_height(v0, angle))
    print(total_time(v0, angle))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

