# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 17:42 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)

PI = 3.141592653589793
REDUCED_PLANCK_CONSTANT = 1.054571817e-34
SPEED_OF_LIGHT = 3e+08
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 100:
        guess = (guess + x / guess) / 2.0
        i = i + 1
    return guess
def casimir_force(force, area, distance):
    zero_count = 0
    if force == 0.0:
        zero_count = zero_count + 1
    if area == 0.0:
        zero_count = zero_count + 1
    if distance == 0.0:
        zero_count = zero_count + 1
    if zero_count != 1:
        panic("One and only one argument must be 0")
    if force < 0.0:
        panic("Magnitude of force can not be negative")
    if distance < 0.0:
        panic("Distance can not be negative")
    if area < 0.0:
        panic("Area can not be negative")
    if force == 0.0:
        num = REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * PI * PI * area
        den = 240.0 * distance * distance * distance * distance
        f = num / den
        return {"force": f}
    if area == 0.0:
        num = 240.0 * force * distance * distance * distance * distance
        den = REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * PI * PI
        a = num / den
        return {"area": a}
    num = REDUCED_PLANCK_CONSTANT * SPEED_OF_LIGHT * PI * PI * area
    den = 240.0 * force
    inner = num / den
    d = sqrtApprox(sqrtApprox(inner))
    return {"distance": d}
def main():
    print(_str(casimir_force(0.0, 4.0, 0.03)))
    print(_str(casimir_force(2.635e-10, 0.0023, 0.0)))
    print(_str(casimir_force(2.737e-18, 0.0, 0.0023746)))
main()
