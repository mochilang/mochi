# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 11:48 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def expApprox(x):
    y = x
    is_neg = False
    if x < 0.0:
        is_neg = True
        y = -x
    term = 1.0
    sum_ = 1.0
    n = 1
    while n < 30:
        term = term * y / (float(n))
        sum_ = sum_ + term
        n = n + 1
    if is_neg:
        return 1.0 / sum_
    return sum_
def sigmoid(z):
    return 1.0 / (1.0 + expApprox(-z))
def dot(a, b):
    s = 0.0
    i = 0
    while i < len(a):
        s = s + a[i] * b[i]
        i = i + 1
    return s
def zeros(n):
    res = []
    i = 0
    while i < n:
        res = _append(res, 0.0)
        i = i + 1
    return res
def logistic_reg(alpha, x, y, iterations):
    m = len(x)
    n = len(x[0])
    theta = zeros(n)
    iter_ = 0
    while iter_ < iterations:
        grad = zeros(n)
        i = 0
        while i < m:
            z = dot(x[i], theta)
            h = sigmoid(z)
            k = 0
            while k < n:
                grad[k] = grad[k] + (h - y[i]) * x[i][k]
                k = k + 1
            i = i + 1
        k2 = 0
        while k2 < n:
            theta = _set_index(theta, k2, theta[k2] - alpha * grad[k2] / (float(m)))
            k2 = k2 + 1
        iter_ = iter_ + 1
    return theta
x = [[0.5, 1.5], [1.0, 1.0], [1.5, 0.5], [3.0, 3.5], [3.5, 3.0], [4.0, 4.0]]
y = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0]
alpha = 0.1
iterations = 1000
theta = logistic_reg(alpha, x, y, iterations)
for i in range(0, len(theta)):
    print(theta[i])

