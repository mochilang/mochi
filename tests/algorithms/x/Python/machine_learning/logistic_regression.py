# Code generated by Mochi transpiler.
# Version 0.10.67, generated on 2025-08-16 21:23 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def expApprox(x):
        y = x
        is_neg = False
        if x < 0.0:
            is_neg = True
            y = -x
        term = 1.0
        sum_ = 1.0
        n = 1
        while n < 30:
            term = term * y / (float(n))
            sum_ = sum_ + term
            n = n + 1
        if is_neg:
            return 1.0 / sum_
        return sum_
    def sigmoid(z):
        return 1.0 / (1.0 + expApprox(-z))
    def dot(a, b):
        s = 0.0
        i = 0
        while i < len(a):
            s = s + a[i] * b[i]
            i = i + 1
        return s
    def zeros(n):
        res = []
        i = 0
        while i < n:
            res = _append(res, 0.0)
            i = i + 1
        return res
    def logistic_reg(alpha, x, y, iterations):
        m = len(x)
        n = len(x[0])
        theta = zeros(n)
        iter_ = 0
        while iter_ < iterations:
            grad = zeros(n)
            i = 0
            while i < m:
                z = dot(x[i], theta)
                h = sigmoid(z)
                k = 0
                while k < n:
                    grad[k] = grad[k] + (h - y[i]) * x[i][k]
                    k = k + 1
                i = i + 1
            k2 = 0
            while k2 < n:
                theta = _set_index(theta, k2, theta[k2] - alpha * grad[k2] / (float(m)))
                k2 = k2 + 1
            iter_ = iter_ + 1
        return theta
    x = [[0.5, 1.5], [1.0, 1.0], [1.5, 0.5], [3.0, 3.5], [3.5, 3.0], [4.0, 4.0]]
    y = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0]
    alpha = 0.1
    iterations = 1000
    theta = logistic_reg(alpha, x, y, iterations)
    for i in range(0, len(theta)):
        print(theta[i])
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

