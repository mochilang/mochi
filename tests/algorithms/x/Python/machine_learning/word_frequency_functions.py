# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 11:48 +0700
import math

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if abs(v - round(v)) < 1e-9:
            return str(float(round(v)))
        return format(v, ".15g")
    return str(v)

LOWER = "abcdefghijklmnopqrstuvwxyz"
UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
PUNCT = "!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~"
def to_lowercase(s):
    res = ""
    i = 0
    while i < len(s):
        c = s[i]
        j = 0
        found = False
        while j < len(UPPER):
            if c == UPPER[j]:
                res = res + LOWER[j]
                found = True
                break
            j = j + 1
        if not found:
            res = res + c
        i = i + 1
    return res
def is_punct(c):
    i = 0
    while i < len(PUNCT):
        if c == PUNCT[i]:
            return True
        i = i + 1
    return False
def clean_text(text, keep_newlines):
    lower = to_lowercase(text)
    res = ""
    i = 0
    while i < len(lower):
        ch = lower[i]
        if is_punct(ch):
            pass
        else:
            if ch == "\n":
                if keep_newlines:
                    res = res + "\n"
            else:
                res = res + ch
        i = i + 1
    return res
def split(s, sep):
    res = []
    current = ""
    i = 0
    while i < len(s):
        ch = s[i]
        if ch == sep:
            res = _append(res, current)
            current = ""
        else:
            current = current + ch
        i = i + 1
    res = _append(res, current)
    return res
def contains(s, sub):
    n = len(s)
    m = len(sub)
    if m == 0:
        return True
    i = 0
    while i <= n - m:
        j = 0
        is_match = True
        while j < m:
            if s[i + j] != sub[j]:
                is_match = False
                break
            j = j + 1
        if is_match:
            return True
        i = i + 1
    return False
def floor(x):
    i = int(x)
    if (float(i)) > x:
        i = i - 1
    return float(i)
def round3(x):
    return math.floor(x * 1000.0 + 0.5) / 1000.0
def ln(x):
    t = (x - 1.0) / (x + 1.0)
    term = t
    sum_ = 0.0
    k = 1
    while k <= 99:
        sum_ = sum_ + term / (float(k))
        term = term * t * t
        k = k + 2
    return 2.0 * sum_
def log10(x):
    return math.log(x) / math.log(10.0)
def term_frequency(term, document):
    clean = clean_text(document, False)
    tokens = clean.split(" ")
    t = to_lowercase(term)
    count = 0
    i = 0
    while i < len(tokens):
        if tokens[i] != "" and tokens[i] == t:
            count = count + 1
        i = i + 1
    return count
def document_frequency(term, corpus):
    clean = clean_text(corpus, True)
    docs = clean.split("\n")
    t = to_lowercase(term)
    matches = 0
    i = 0
    while i < len(docs):
        if contains(docs[i], t):
            matches = matches + 1
        i = i + 1
    return [matches, len(docs)]
def inverse_document_frequency(df, n, smoothing):
    if smoothing:
        if n == 0:
            panic("log10(0) is undefined.")
        ratio = (float(n)) / (1.0 + (float(df)))
        l = log10(ratio)
        result = round3(1.0 + l)
        print(result)
        return result
    if df == 0:
        panic("df must be > 0")
    if n == 0:
        panic("log10(0) is undefined.")
    ratio = (float(n)) / (float(df))
    l = log10(ratio)
    result = round3(l)
    print(result)
    return result
def tf_idf(tf, idf):
    prod = (float(tf)) * idf
    result = round3(prod)
    print(result)
    return result
print(term_frequency("to", "To be, or not to be"))
corpus = "This is the first document in the corpus.\nThIs is the second document in the corpus.\nTHIS is the third document in the corpus."
print(_str(document_frequency("first", corpus)))
idf_val = inverse_document_frequency(1, 3, False)
tf_idf(2, idf_val)

