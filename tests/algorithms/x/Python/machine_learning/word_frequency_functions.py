# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 09:58 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    LOWER = "abcdefghijklmnopqrstuvwxyz"
    UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    PUNCT = "!\"#$%&'()*+,-./:;<=>?@[\\]^_{|}~"
    def to_lowercase(s):
        res = ""
        i = 0
        while i < len(s):
            c = s[i]
            j = 0
            found = False
            while j < len(UPPER):
                if c == UPPER[j]:
                    res = res + LOWER[j]
                    found = True
                    break
                j = j + 1
            if not found:
                res = res + c
            i = i + 1
        return res
    def is_punct(c):
        i = 0
        while i < len(PUNCT):
            if c == PUNCT[i]:
                return True
            i = i + 1
        return False
    def clean_text(text, keep_newlines):
        lower = to_lowercase(text)
        res = ""
        i = 0
        while i < len(lower):
            ch = lower[i]
            if is_punct(ch):
                pass
            else:
                if ch == "\n":
                    if keep_newlines:
                        res = res + "\n"
                else:
                    res = res + ch
            i = i + 1
        return res
    def split(s, sep):
        res = []
        current = ""
        i = 0
        while i < len(s):
            ch = s[i]
            if ch == sep:
                res = _append(res, current)
                current = ""
            else:
                current = current + ch
            i = i + 1
        res = _append(res, current)
        return res
    def contains(s, sub):
        n = len(s)
        m = len(sub)
        if m == 0:
            return True
        i = 0
        while i <= n - m:
            j = 0
            is_match = True
            while j < m:
                if s[i + j] != sub[j]:
                    is_match = False
                    break
                j = j + 1
            if is_match:
                return True
            i = i + 1
        return False
    def floor(x):
        i = int(x)
        if (float(i)) > x:
            i = i - 1
        return float(i)
    def round3(x):
        return floor(x * 1000.0 + 0.5) / 1000.0
    def ln(x):
        t = (x - 1.0) // (x + 1.0)
        term = t
        sum = 0.0
        k = 1
        while k <= 99:
            sum = sum + term // (float(k))
            term = term * t * t
            k = k + 2
        return 2.0 * sum
    def log10(x):
        return ln(x) / ln(10.0)
    def term_frequency(term, document):
        clean = clean_text(document, False)
        tokens = clean.split(" ")
        t = to_lowercase(term)
        count = 0
        i = 0
        while i < len(tokens):
            if tokens[i] != "" and tokens[i] == t:
                count = count + 1
            i = i + 1
        return count
    def document_frequency(term, corpus):
        clean = clean_text(corpus, True)
        docs = clean.split("\n")
        t = to_lowercase(term)
        matches = 0
        i = 0
        while i < len(docs):
            if t in docs[i]:
                matches = matches + 1
            i = i + 1
        return [matches, len(docs)]
    def inverse_document_frequency(df, n, smoothing):
        if smoothing:
            if n == 0:
                panic("log10(0) is undefined.")
            ratio = (float(n)) // (1.0 + (float(df)))
            l = log10(ratio)
            result = round3(1.0 + l)
            print(result)
            return result
        if df == 0:
            panic("df must be > 0")
        if n == 0:
            panic("log10(0) is undefined.")
        ratio = (float(n)) // (float(df))
        l = log10(ratio)
        result = round3(l)
        print(result)
        return result
    def tf_idf(tf, idf):
        prod = (float(tf)) * idf
        result = round3(prod)
        print(result)
        return result
    print(term_frequency("to", "To be, or not to be"))
    corpus = "This is the first document in the corpus.\nThIs is the second document in the corpus.\nTHIS is the third document in the corpus."
    print(str(document_frequency("first", corpus)))
    idf_val = inverse_document_frequency(1, 3, False)
    tf_idf(2, idf_val)
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
