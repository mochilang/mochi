# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 11:48 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def dot(a, b):
    sum_ = 0.0
    i = 0
    while i < len(a):
        sum_ = sum_ + a[i] * b[i]
        i = i + 1
    return sum_
def maxf(a, b):
    if a > b:
        return a
    return b
def minf(a, b):
    if a < b:
        return a
    return b
def absf(x):
    if x >= 0.0:
        return x
    return 0.0 - x
def predict_raw(samples, labels, alphas, b, x):
    res = 0.0
    i = 0
    while i < len(samples):
        res = res + alphas[i] * labels[i] * dot(samples[i], x)
        i = i + 1
    return res + b
def smo_train(samples, labels, c, tol, max_passes):
    m = len(samples)
    alphas = []
    i = 0
    while i < m:
        alphas = _append(alphas, 0.0)
        i = i + 1
    b = 0.0
    passes = 0
    while passes < max_passes:
        num_changed = 0
        i1 = 0
        while i1 < m:
            Ei = predict_raw(samples, labels, alphas, b, samples[i1]) - labels[i1]
            if (labels[i1] * Ei < 0.0 - tol and alphas[i1] < c) or (labels[i1] * Ei > tol and alphas[i1] > 0.0):
                i2 = (i1 + 1) % m
                Ej = predict_raw(samples, labels, alphas, b, samples[i2]) - labels[i2]
                alpha1_old = alphas[i1]
                alpha2_old = alphas[i2]
                L = 0.0
                H = 0.0
                if labels[i1] != labels[i2]:
                    L = maxf(0.0, alpha2_old - alpha1_old)
                    H = minf(c, c + alpha2_old - alpha1_old)
                else:
                    L = maxf(0.0, alpha2_old + alpha1_old - c)
                    H = minf(c, alpha2_old + alpha1_old)
                if L == H:
                    i1 = i1 + 1
                    continue
                eta = 2.0 * dot(samples[i1], samples[i2]) - dot(samples[i1], samples[i1]) - dot(samples[i2], samples[i2])
                if eta >= 0.0:
                    i1 = i1 + 1
                    continue
                alphas[i2] = alpha2_old - labels[i2] * (Ei - Ej) / eta
                if alphas[i2] > H:
                    alphas[i2] = H
                if alphas[i2] < L:
                    alphas[i2] = L
                if absf(alphas[i2] - alpha2_old) < 1e-05:
                    i1 = i1 + 1
                    continue
                alphas[i1] = alpha1_old + labels[i1] * labels[i2] * (alpha2_old - alphas[i2])
                b1 = b - Ei - labels[i1] * (alphas[i1] - alpha1_old) * dot(samples[i1], samples[i1]) - labels[i2] * (alphas[i2] - alpha2_old) * dot(samples[i1], samples[i2])
                b2 = b - Ej - labels[i1] * (alphas[i1] - alpha1_old) * dot(samples[i1], samples[i2]) - labels[i2] * (alphas[i2] - alpha2_old) * dot(samples[i2], samples[i2])
                if alphas[i1] > 0.0 and alphas[i1] < c:
                    b = b1
                else:
                    if alphas[i2] > 0.0 and alphas[i2] < c:
                        b = b2
                    else:
                        b = (b1 + b2) / 2.0
                num_changed = num_changed + 1
            i1 = i1 + 1
        if num_changed == 0:
            passes = passes + 1
        else:
            passes = 0
    return [alphas, [b]]
def predict(samples, labels, model, x):
    alphas = model[0]
    b = model[1][0]
    val = predict_raw(samples, labels, alphas, b, x)
    if val >= 0.0:
        return 1.0
    return -1.0
samples = [[2.0, 2.0], [1.5, 1.5], [0.0, 0.0], [0.5, 0.0]]
labels = [1.0, 1.0, -1.0, -1.0]
model = smo_train(samples, labels, 1.0, 0.001, 10)
print(predict(samples, labels, model, [1.5, 1.0]))
print(predict(samples, labels, model, [0.2, 0.1]))

