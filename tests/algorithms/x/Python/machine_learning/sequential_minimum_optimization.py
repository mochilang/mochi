# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 09:58 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    def dot(a, b):
        sum = 0.0
        i = 0
        while i < len(a):
            sum = sum + a[i] * b[i]
            i = i + 1
        return sum
    def maxf(a, b):
        if a > b:
            return a
        return b
    def minf(a, b):
        if a < b:
            return a
        return b
    def absf(x):
        if x >= 0.0:
            return x
        return 0.0 - x
    def predict_raw(samples, labels, alphas, b, x):
        res = 0.0
        i = 0
        while i < len(samples):
            res = res + alphas[i] * labels[i] * dot(samples[i], x)
            i = i + 1
        return res + b
    def smo_train(samples, labels, c, tol, max_passes):
        m = len(samples)
        alphas = []
        i = 0
        while i < m:
            alphas = _append(alphas, 0.0)
            i = i + 1
        b = 0.0
        passes = 0
        while passes < max_passes:
            num_changed = 0
            i1 = 0
            while i1 < m:
                Ei = predict_raw(samples, labels, alphas, b, samples[i1]) - labels[i1]
                if (labels[i1] * Ei < 0.0 - tol and alphas[i1] < c) or (labels[i1] * Ei > tol and alphas[i1] > 0.0):
                    i2 = (i1 + 1) % m
                    Ej = predict_raw(samples, labels, alphas, b, samples[i2]) - labels[i2]
                    alpha1_old = alphas[i1]
                    alpha2_old = alphas[i2]
                    L = 0.0
                    H = 0.0
                    if labels[i1] != labels[i2]:
                        L = maxf(0.0, alpha2_old - alpha1_old)
                        H = minf(c, c + alpha2_old - alpha1_old)
                    else:
                        L = maxf(0.0, alpha2_old + alpha1_old - c)
                        H = minf(c, alpha2_old + alpha1_old)
                    if L == H:
                        i1 = i1 + 1
                        continue
                    eta = 2.0 * dot(samples[i1], samples[i2]) - dot(samples[i1], samples[i1]) - dot(samples[i2], samples[i2])
                    if eta >= 0.0:
                        i1 = i1 + 1
                        continue
                    alphas[i2] = alpha2_old - labels[i2] * (Ei - Ej) // eta
                    if alphas[i2] > H:
                        alphas[i2] = H
                    if alphas[i2] < L:
                        alphas[i2] = L
                    if absf(alphas[i2] - alpha2_old) < 1e-05:
                        i1 = i1 + 1
                        continue
                    alphas[i1] = alpha1_old + labels[i1] * labels[i2] * (alpha2_old - alphas[i2])
                    b1 = b - Ei - labels[i1] * (alphas[i1] - alpha1_old) * dot(samples[i1], samples[i1]) - labels[i2] * (alphas[i2] - alpha2_old) * dot(samples[i1], samples[i2])
                    b2 = b - Ej - labels[i1] * (alphas[i1] - alpha1_old) * dot(samples[i1], samples[i2]) - labels[i2] * (alphas[i2] - alpha2_old) * dot(samples[i2], samples[i2])
                    if alphas[i1] > 0.0 and alphas[i1] < c:
                        b = b1
                    else:
                        if alphas[i2] > 0.0 and alphas[i2] < c:
                            b = b2
                        else:
                            b = (b1 + b2) / 2.0
                    num_changed = num_changed + 1
                i1 = i1 + 1
            if num_changed == 0:
                passes = passes + 1
            else:
                passes = 0
        return [alphas, [b]]
    def predict(samples, labels, model, x):
        alphas = model[0]
        b = model[1][0]
        val = predict_raw(samples, labels, alphas, b, x)
        if val >= 0.0:
            return 1.0
        return -1.0
    samples = [[2.0, 2.0], [1.5, 1.5], [0.0, 0.0], [0.5, 0.0]]
    labels = [1.0, 1.0, -1.0, -1.0]
    model = smo_train(samples, labels, 1.0, 0.001, 10)
    print(predict(samples, labels, model, [1.5, 1.0]))
    print(predict(samples, labels, model, [0.2, 0.1]))
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
