# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class PointLabel:
    point: [float]
    label: int

@dataclass
class KNN:
    data: [PointLabel]
    labels: [string]

def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def make_knn(train_data, train_target, class_labels):
    items = []
    i = 0
    while i < len(train_data):
        pl = PointLabel(point=train_data[i], label=train_target[i])
        items = _append(items, pl)
        i = i + 1
    return KNN(data=items, labels=class_labels)
def euclidean_distance(a, b):
    sum = 0.0
    i = 0
    while i < len(a):
        diff = a[i] - b[i]
        sum = sum + diff * diff
        i = i + 1
    return sqrtApprox(sum)
@dataclass
class DistLabel:
    dist: float
    label: int

def classify(knn, pred_point, k):
    distances = []
    i = 0
    while i < len(knn.data):
        d = euclidean_distance(knn.data[i].point, pred_point)
        distances = _append(distances, DistLabel(dist=d, label=knn.data[i].label))
        i = i + 1
    votes = []
    count = 0
    while count < k:
        min_index = 0
        j = 1
        while j < len(distances):
            if distances[j].dist < distances[min_index].dist:
                min_index = j
            j = j + 1
        votes = _append(votes, distances[min_index].label)
        distances[min_index].dist = 1e+18
        count = count + 1
    tally = []
    t = 0
    while t < len(knn.labels):
        tally = _append(tally, 0)
        t = t + 1
    v = 0
    while v < len(votes):
        lbl = votes[v]
        tally[lbl] = tally[lbl] + 1
        v = v + 1
    max_idx = 0
    m = 1
    while m < len(tally):
        if tally[m] > tally[max_idx]:
            max_idx = m
        m = m + 1
    return knn.labels[max_idx]
train_X = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.5], [3.0, 3.0], [2.0, 3.0], [3.0, 2.0]]
train_y = [0, 0, 0, 0, 1, 1, 1]
classes = ["A", "B"]
knn = make_knn(train_X, train_y, classes)
point = [1.2, 1.2]
print(classify(knn, point, 5))
