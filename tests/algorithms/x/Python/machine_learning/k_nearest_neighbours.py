# Code generated by Mochi transpiler.
# Version 0.10.67, generated on 2025-08-16 21:23 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class PointLabel:
        point: [float]
        label: int
    @dataclass
    class KNN:
        data: [PointLabel]
        labels: [string]
    def sqrtApprox(x):
        if x <= 0.0:
            return 0.0
        guess = x
        i = 0
        while i < 20:
            guess = (guess + x / guess) / 2.0
            i = i + 1
        return guess
    def make_knn(train_data, train_target, class_labels):
        items = []
        i = 0
        while i < len(train_data):
            pl = PointLabel(point=train_data[i], label=train_target[i])
            items = _append(items, pl)
            i = i + 1
        return KNN(data=items, labels=class_labels)
    def euclidean_distance(a, b):
        sum_ = 0.0
        i = 0
        while i < len(a):
            diff = a[i] - b[i]
            sum_ = sum_ + diff * diff
            i = i + 1
        return sqrtApprox(sum_)
    @dataclass
    class DistLabel:
        dist: float
        label: int
    def classify(knn, pred_point, k):
        distances = []
        i = 0
        while i < len(knn.data):
            d = euclidean_distance(knn.data[i].point, pred_point)
            distances = _append(distances, DistLabel(dist=d, label=knn.data[i].label))
            i = i + 1
        votes = []
        count = 0
        while count < k:
            min_index = 0
            j = 1
            while j < len(distances):
                if distances[j].dist < distances[min_index].dist:
                    min_index = j
                j = j + 1
            votes = _append(votes, distances[min_index].label)
            distances[min_index].dist = 1e+18
            count = count + 1
        tally = []
        t = 0
        while t < len(knn.labels):
            tally = _append(tally, 0)
            t = t + 1
        v = 0
        while v < len(votes):
            lbl = votes[v]
            tally[lbl] = tally[lbl] + 1
            v = v + 1
        max_idx = 0
        m = 1
        while m < len(tally):
            if tally[m] > tally[max_idx]:
                max_idx = m
            m = m + 1
        return knn.labels[max_idx]
    train_X = [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.5], [3.0, 3.0], [2.0, 3.0], [3.0, 2.0]]
    train_y = [0, 0, 0, 0, 1, 1, 1]
    classes = ["A", "B"]
    knn = make_knn(train_X, train_y, classes)
    point = [1.2, 1.2]
    print(classify(knn, point, 5))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

