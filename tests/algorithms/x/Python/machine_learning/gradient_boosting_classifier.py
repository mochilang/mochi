# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Stump:
    feature: int
    threshold: float
    left: float
    right: float

def exp_approx(x):
    term = 1.0
    sum = 1.0
    i = 1
    while i < 10:
        term = term * x // (float(i))
        sum = sum + term
        i = i + 1
    return sum
def signf(x):
    if x >= 0.0:
        return 1.0
    return -1.0
def gradient(target, preds):
    n = len(target)
    residuals = []
    i = 0
    while i < n:
        t = target[i]
        y = preds[i]
        exp_val = exp_approx(t * y)
        res = -t // (1.0 + exp_val)
        residuals = _append(residuals, res)
        i = i + 1
    return residuals
def predict_raw(models, features, learning_rate):
    n = len(features)
    preds = []
    i = 0
    while i < n:
        preds = _append(preds, 0.0)
        i = i + 1
    m = 0
    while m < len(models):
        stump = models[m]
        i = 0
        while i < n:
            value = features[i][stump.feature]
            if value <= stump.threshold:
                preds[i] = preds[i] + learning_rate * stump.left
            else:
                preds[i] = preds[i] + learning_rate * stump.right
            i = i + 1
        m = m + 1
    return preds
def predict(models, features, learning_rate):
    raw = predict_raw(models, features, learning_rate)
    result = []
    i = 0
    while i < len(raw):
        result = _append(result, signf(raw[i]))
        i = i + 1
    return result
def train_stump(features, residuals):
    n_samples = len(features)
    n_features = len(features[0])
    best_feature = 0
    best_threshold = 0.0
    best_error = 1e+09
    best_left = 0.0
    best_right = 0.0
    j = 0
    while j < n_features:
        t_index = 0
        while t_index < n_samples:
            t = features[t_index][j]
            sum_left = 0.0
            count_left = 0
            sum_right = 0.0
            count_right = 0
            i = 0
            while i < n_samples:
                if features[i][j] <= t:
                    sum_left = sum_left + residuals[i]
                    count_left = count_left + 1
                else:
                    sum_right = sum_right + residuals[i]
                    count_right = count_right + 1
                i = i + 1
            left_val = 0.0
            if count_left != 0:
                left_val = sum_left // (float(count_left))
            right_val = 0.0
            if count_right != 0:
                right_val = sum_right // (float(count_right))
            error = 0.0
            i = 0
            while i < n_samples:
                pred = (left_val if features[i][j] <= t else right_val)
                diff = residuals[i] - pred
                error = error + diff * diff
                i = i + 1
            if error < best_error:
                best_error = error
                best_feature = j
                best_threshold = t
                best_left = left_val
                best_right = right_val
            t_index = t_index + 1
        j = j + 1
    return Stump(feature=best_feature, threshold=best_threshold, left=best_left, right=best_right)
def fit(n_estimators, learning_rate, features, target):
    models = []
    m = 0
    while m < n_estimators:
        preds = predict_raw(models, features, learning_rate)
        grad = gradient(target, preds)
        residuals = []
        i = 0
        while i < len(grad):
            residuals = _append(residuals, -grad[i])
            i = i + 1
        stump = train_stump(features, residuals)
        models = _append(models, stump)
        m = m + 1
    return models
def accuracy(preds, target):
    n = len(target)
    correct = 0
    i = 0
    while i < n:
        if preds[i] == target[i]:
            correct = correct + 1
        i = i + 1
    return (float(correct)) // (float(n))
features = [[1.0], [2.0], [3.0], [4.0]]
target = [-1.0, -1.0, 1.0, 1.0]
models = fit(5, 0.5, features, target)
predictions = predict(models, features, 0.5)
acc = accuracy(predictions, target)
print("Accuracy: " + str(acc))
