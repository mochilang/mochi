# Code generated by Mochi transpiler.
# Version 0.10.67, generated on 2025-08-16 19:42 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    import builtins
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(float(builtins.round(v)))
        return builtins.format(v, ".15g")
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class Stump:
        feature: int
        threshold: float
        left: float
        right: float
    def exp_approx(x):
        term = 1.0
        sum_ = 1.0
        i = 1
        while i < 10:
            term = term * x / (float(i))
            sum_ = sum_ + term
            i = i + 1
        return sum_
    def signf(x):
        if x >= 0.0:
            return 1.0
        return -1.0
    def gradient(target, preds):
        n = len(target)
        residuals = []
        i = 0
        while i < n:
            t = target[i]
            y = preds[i]
            exp_val = exp_approx(t * y)
            res = -t / (1.0 + exp_val)
            residuals = _append(residuals, res)
            i = i + 1
        return residuals
    def predict_raw(models, features, learning_rate):
        n = len(features)
        preds = []
        i = 0
        while i < n:
            preds = _append(preds, 0.0)
            i = i + 1
        m = 0
        while m < len(models):
            stump = models[m]
            i = 0
            while i < n:
                value = features[i][stump.feature]
                if value <= stump.threshold:
                    preds[i] = preds[i] + learning_rate * stump.left
                else:
                    preds[i] = preds[i] + learning_rate * stump.right
                i = i + 1
            m = m + 1
        return preds
    def predict(models, features, learning_rate):
        raw = predict_raw(models, features, learning_rate)
        result = []
        i = 0
        while i < len(raw):
            result = _append(result, signf(raw[i]))
            i = i + 1
        return result
    def train_stump(features, residuals):
        n_samples = len(features)
        n_features = len(features[0])
        best_feature = 0
        best_threshold = 0.0
        best_error = 1e+09
        best_left = 0.0
        best_right = 0.0
        j = 0
        while j < n_features:
            t_index = 0
            while t_index < n_samples:
                t = features[t_index][j]
                sum_left = 0.0
                count_left = 0
                sum_right = 0.0
                count_right = 0
                i = 0
                while i < n_samples:
                    if features[i][j] <= t:
                        sum_left = sum_left + residuals[i]
                        count_left = count_left + 1
                    else:
                        sum_right = sum_right + residuals[i]
                        count_right = count_right + 1
                    i = i + 1
                left_val = 0.0
                if count_left != 0:
                    left_val = sum_left / (float(count_left))
                right_val = 0.0
                if count_right != 0:
                    right_val = sum_right / (float(count_right))
                error = 0.0
                i = 0
                while i < n_samples:
                    pred = (left_val if features[i][j] <= t else right_val)
                    diff = residuals[i] - pred
                    error = error + diff * diff
                    i = i + 1
                if error < best_error:
                    best_error = error
                    best_feature = j
                    best_threshold = t
                    best_left = left_val
                    best_right = right_val
                t_index = t_index + 1
            j = j + 1
        return Stump(feature=best_feature, threshold=best_threshold, left=best_left, right=best_right)
    def fit(n_estimators, learning_rate, features, target):
        models = []
        m = 0
        while m < n_estimators:
            preds = predict_raw(models, features, learning_rate)
            grad = gradient(target, preds)
            residuals = []
            i = 0
            while i < len(grad):
                residuals = _append(residuals, -grad[i])
                i = i + 1
            stump = train_stump(features, residuals)
            models = _append(models, stump)
            m = m + 1
        return models
    def accuracy(preds, target):
        n = len(target)
        correct = 0
        i = 0
        while i < n:
            if preds[i] == target[i]:
                correct = correct + 1
            i = i + 1
        return (float(correct)) / (float(n))
    features = [[1.0], [2.0], [3.0], [4.0]]
    target = [-1.0, -1.0, 1.0, 1.0]
    models = fit(5, 0.5, features, target)
    predictions = predict(models, features, 0.5)
    acc = accuracy(predictions, target)
    print("Accuracy: " + _str(acc))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

