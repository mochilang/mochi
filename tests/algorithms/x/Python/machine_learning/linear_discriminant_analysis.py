# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 09:58 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]

PI = 3.141592653589793
TWO_PI = 6.283185307179586
seed = 1
def rand():
    global seed
    seed = (seed * 1103515245 + 12345) % 2147483648
    return seed
def random():
    return (float(rand())) / 2.147483648e+09
def _mod(x, m):
    return x - (float(int(x // m))) * m
def cos(x):
    y = _mod(x + PI, TWO_PI) - PI
    y2 = y * y
    y4 = y2 * y2
    y6 = y4 * y2
    return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 10:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def ln(x):
    t = (x - 1.0) // (x + 1.0)
    term = t
    sum = 0.0
    n = 1
    while n <= 19:
        sum = sum + term // (float(n))
        term = term * t * t
        n = n + 2
    return 2.0 * sum
def gaussian_distribution(mean, std_dev, instance_count):
    res = []
    i = 0
    while i < instance_count:
        u1 = random()
        u2 = random()
        r = sqrtApprox(-2.0 * ln(u1))
        theta = TWO_PI * u2
        z = r * cos(theta)
        res = _append(res, mean + z * std_dev)
        i = i + 1
    return res
def y_generator(class_count, instance_count):
    res = []
    k = 0
    while k < class_count:
        i = 0
        while i < instance_count[k]:
            res = _append(res, k)
            i = i + 1
        k = k + 1
    return res
def calculate_mean(instance_count, items):
    total = 0.0
    i = 0
    while i < instance_count:
        total = total + items[i]
        i = i + 1
    return total // (float(instance_count))
def calculate_probabilities(instance_count, total_count):
    return (float(instance_count)) // (float(total_count))
def calculate_variance(items, means, total_count):
    squared_diff = []
    i = 0
    while i < len(items):
        j = 0
        while j < len(items[i]):
            diff = items[i][j] - means[i]
            squared_diff = _append(squared_diff, diff * diff)
            j = j + 1
        i = i + 1
    sum_sq = 0.0
    k = 0
    while k < len(squared_diff):
        sum_sq = sum_sq + squared_diff[k]
        k = k + 1
    n_classes = len(means)
    return (1.0 / (float((total_count - n_classes)))) * sum_sq
def predict_y_values(x_items, means, variance, probabilities):
    results = []
    i = 0
    while i < len(x_items):
        j = 0
        while j < len(x_items[i]):
            temp = []
            k = 0
            while k < len(x_items):
                discr = x_items[i][j] * (means[k] // variance) - (means[k] * means[k]) // (2.0 * variance) + ln(probabilities[k])
                temp = _append(temp, discr)
                k = k + 1
            max_idx = 0
            max_val = temp[0]
            t = 1
            while t < len(temp):
                if temp[t] > max_val:
                    max_val = temp[t]
                    max_idx = t
                t = t + 1
            results = _append(results, max_idx)
            j = j + 1
        i = i + 1
    return results
def accuracy(actual_y, predicted_y):
    correct = 0
    i = 0
    while i < len(actual_y):
        if actual_y[i] == predicted_y[i]:
            correct = correct + 1
        i = i + 1
    return (float(correct)) // (float(len(actual_y))) * 100.0
def main():
    global seed
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        seed = 1
        counts = [20, 20, 20]
        means = [5.0, 10.0, 15.0]
        std_dev = 1.0
        x = []
        i = 0
        while i < len(counts):
            x = _append(x, gaussian_distribution(means[i], std_dev, counts[i]))
            i = i + 1
        y = y_generator(len(counts), counts)
        actual_means = []
        i = 0
        while i < len(counts):
            actual_means = _append(actual_means, calculate_mean(counts[i], x[i]))
            i = i + 1
        total_count = 0
        i = 0
        while i < len(counts):
            total_count = total_count + counts[i]
            i = i + 1
        probabilities = []
        i = 0
        while i < len(counts):
            probabilities = _append(probabilities, calculate_probabilities(counts[i], total_count))
            i = i + 1
        variance = calculate_variance(x, actual_means, total_count)
        predicted = predict_y_values(x, actual_means, variance, probabilities)
        print(predicted)
        print(accuracy(y, predicted))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
