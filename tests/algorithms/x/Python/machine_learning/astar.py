# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:54 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Point:
    x: int
    y: int

@dataclass
class Node:
    pos: Point
    parent: Point
    g: int
    h: int
    f: int

def get_neighbours(p, x_limit, y_limit):
    deltas = [Point(x=(0 - 1), y=(0 - 1)), Point(x=(0 - 1), y=0), Point(x=(0 - 1), y=1), Point(x=0, y=(0 - 1)), Point(x=0, y=1), Point(x=1, y=(0 - 1)), Point(x=1, y=0), Point(x=1, y=1)]
    neighbours = []
    for d in deltas:
        nx = p.x + d.x
        ny = p.y + d.y
        if 0 <= nx and nx < x_limit and 0 <= ny and ny < y_limit:
            neighbours = _append(neighbours, Point(x=nx, y=ny))
    return neighbours
def contains(nodes, p):
    for n in nodes:
        if n.pos.x == p.x and n.pos.y == p.y:
            return True
    return False
def get_node(nodes, p):
    for n in nodes:
        if n.pos.x == p.x and n.pos.y == p.y:
            return n
    return Node(pos=p, parent=Point(x=(0 - 1), y=(0 - 1)), g=0, h=0, f=0)
def astar(x_limit, y_limit, start, goal):
    open = []
    closed = []
    open = _append(open, Node(pos=start, parent=Point(x=(0 - 1), y=(0 - 1)), g=0, h=0, f=0))
    current = open[0]
    while len(open) > 0:
        min_index = 0
        i = 1
        while i < len(open):
            if open[i].f < open[min_index].f:
                min_index = i
            i = i + 1
        current = open[min_index]
        new_open = []
        j = 0
        while j < len(open):
            if j != min_index:
                new_open = _append(new_open, open[j])
            j = j + 1
        open = new_open
        closed = _append(closed, current)
        if current.pos.x == goal.x and current.pos.y == goal.y:
            break
        neighbours = get_neighbours(current.pos, x_limit, y_limit)
        for np in neighbours:
            if np in closed:
                continue
            g = current.g + 1
            dx = goal.x - np.x
            dy = goal.y - np.y
            h = dx * dx + dy * dy
            f = g + h
            skip = False
            for node in open:
                if node.pos.x == np.x and node.pos.y == np.y and node.f < f:
                    skip = True
            if skip:
                continue
            open = _append(open, Node(pos=np, parent=current.pos, g=g, h=h, f=f))
    path = []
    path = _append(path, current.pos)
    while not (current.parent.x == (0 - 1) and current.parent.y == (0 - 1)):
        current = get_node(closed, current.parent)
        path = _append(path, current.pos)
    rev = []
    k = len(path) - 1
    while k >= 0:
        rev = _append(rev, path[k])
        k = k - 1
    return rev
def create_world(x_limit, y_limit):
    world = []
    i = 0
    while i < x_limit:
        row = []
        j = 0
        while j < y_limit:
            row = _append(row, 0)
            j = j + 1
        world = _append(world, row)
        i = i + 1
    return world
def mark_path(world, path):
    for p in path:
        world[p.x][p.y] = 1
def print_world(world):
    for row in world:
        print(str(row))
world_x = 5
world_y = 5
start = Point(x=0, y=0)
goal = Point(x=4, y=4)
path = astar(world_x, world_y, start, goal)
print("path from (" + str(start.x) + ", " + str(start.y) + ") to (" + str(goal.x) + ", " + str(goal.y) + ")")
world = create_world(world_x, world_y)
mark_path(world, path)
print_world(world)
