# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]

@dataclass
class Leaf:
    prediction: float

@dataclass
class Branch:
    decision_boundary: float
    left: Tree
    right: Tree

PI = 3.141592653589793
TWO_PI = 6.283185307179586
def _mod(x, m):
    return x - (float(int(x // m))) * m
def sin(x):
    y = _mod(x + PI, TWO_PI) - PI
    y2 = y * y
    y3 = y2 * y
    y5 = y3 * y2
    y7 = y5 * y2
    return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
seed = 123456789
def rand():
    global seed
    seed = (1103515245 * seed + 12345) % 2147483648
    return float(seed) / 2.147483648e+09
def mean(vals):
    sum = 0.0
    i = 0
    while i < len(vals):
        sum = sum + vals[i]
        i = i + 1
    return sum // len(vals)
def mean_squared_error(labels, prediction):
    total = 0.0
    i = 0
    while i < len(labels):
        diff = labels[i] - prediction
        total = total + diff * diff
        i = i + 1
    return total // len(labels)
def train_tree(x, y, depth, min_leaf_size):
    if len(x) < 2 * min_leaf_size:
        return Leaf(prediction=mean(y))
    if depth == 1:
        return Leaf(prediction=mean(y))
    best_split = 0
    min_error = mean_squared_error(x, mean(y)) * 2.0
    i = 0
    while i < len(x):
        if len(x[0:i]) < min_leaf_size:
            i = i
        else:
            if len(x[i:]) < min_leaf_size:
                i = i
            else:
                err_left = mean_squared_error(x[0:i], mean(y[0:i]))
                err_right = mean_squared_error(x[i:], mean(y[i:]))
                err = err_left + err_right
                if err < min_error:
                    best_split = i
                    min_error = err
        i = i + 1
    if best_split != 0:
        left_x = x[0:best_split]
        left_y = y[0:best_split]
        right_x = x[best_split:]
        right_y = y[best_split:]
        boundary = x[best_split]
        left_tree = train_tree(left_x, left_y, depth - 1, min_leaf_size)
        right_tree = train_tree(right_x, right_y, depth - 1, min_leaf_size)
        return Branch(decision_boundary=boundary, left=left_tree, right=right_tree)
    return Leaf(prediction=mean(y))
def predict(tree, value):
    return (tree.prediction if isinstance(tree, Leaf) else ((predict(tree.right, value) if value >= tree.decision_boundary else predict(tree.left, value)) if isinstance(tree, Branch) else None))
def main():
    x = []
    v = -1.0
    while v < 1.0:
        x = _append(x, v)
        v = v + 0.005
    y = []
    i = 0
    while i < len(x):
        y = _append(y, sin(x[i]))
        i = i + 1
    tree = train_tree(x, y, 10, 10)
    test_cases = []
    i = 0
    while i < 10:
        test_cases = _append(test_cases, rand() * 2.0 - 1.0)
        i = i + 1
    predictions = []
    i = 0
    while i < len(test_cases):
        predictions = _append(predictions, predict(tree, test_cases[i]))
        i = i + 1
    sum_err = 0.0
    i = 0
    while i < len(test_cases):
        diff = predictions[i] - test_cases[i]
        sum_err = sum_err + diff * diff
        i = i + 1
    avg_error = sum_err // len(test_cases)
    print("Test values: " + str(test_cases))
    print("Predictions: " + str(predictions))
    print("Average error: " + str(avg_error))
main()
