# Code generated by Mochi transpiler.
# Version 0.10.67, generated on 2025-08-16 19:42 +0700
import json
import math
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    import builtins
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(float(builtins.round(v)))
        return builtins.format(v, ".15g")
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def exp_taylor(x):
        term = 1.0
        sum_ = 1.0
        i = 1.0
        while i < 20.0:
            term = term * x / i
            sum_ = sum_ + term
            i = i + 1.0
        return sum_
    def sigmoid(x):
        return 1.0 / (1.0 + math.exp(-x))
    X = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]
    Y = [0.0, 1.0, 0.0, 0.0]
    test_data = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]]
    w1 = [[0.5, -0.5], [0.5, 0.5]]
    b1 = [0.0, 0.0]
    w2 = [0.5, -0.5]
    b2 = 0.0
    def train(epochs, lr):
        global b2
        e = 0
        while e < epochs:
            i = 0
            while i < len(X):
                x0 = X[i][0]
                x1 = X[i][1]
                target = Y[i]
                z1 = w1[0][0] * x0 + w1[1][0] * x1 + b1[0]
                z2 = w1[0][1] * x0 + w1[1][1] * x1 + b1[1]
                h1 = sigmoid(z1)
                h2 = sigmoid(z2)
                z3 = w2[0] * h1 + w2[1] * h2 + b2
                out = sigmoid(z3)
                error = out - target
                d1 = h1 * (1.0 - h1) * w2[0] * error
                d2 = h2 * (1.0 - h2) * w2[1] * error
                w2 = _set_index(w2, 0, w2[0] - lr * error * h1)
                w2 = _set_index(w2, 1, w2[1] - lr * error * h2)
                b2 = b2 - lr * error
                w1[0][0] = w1[0][0] - lr * d1 * x0
                w1[1][0] = w1[1][0] - lr * d1 * x1
                b1 = _set_index(b1, 0, b1[0] - lr * d1)
                w1[0][1] = w1[0][1] - lr * d2 * x0
                w1[1][1] = w1[1][1] - lr * d2 * x1
                b1 = _set_index(b1, 1, b1[1] - lr * d2)
                i = i + 1
            e = e + 1
    def predict(samples):
        preds = []
        i = 0
        while i < len(samples):
            x0 = samples[i][0]
            x1 = samples[i][1]
            z1 = w1[0][0] * x0 + w1[1][0] * x1 + b1[0]
            z2 = w1[0][1] * x0 + w1[1][1] * x1 + b1[1]
            h1 = sigmoid(z1)
            h2 = sigmoid(z2)
            z3 = w2[0] * h1 + w2[1] * h2 + b2
            out = sigmoid(z3)
            label = 0
            if out >= 0.5:
                label = 1
            preds = _append(preds, label)
            i = i + 1
        return preds
    def wrapper(y):
        return y
    train(4000, 0.5)
    preds = wrapper(predict(test_data))
    print(_str(preds))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

