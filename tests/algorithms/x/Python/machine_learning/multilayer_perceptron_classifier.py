# Code generated by Mochi transpiler.
# Version 0.10.67, generated on 2025-08-16 21:23 +0700
import math

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    import builtins
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(float(builtins.round(v)))
        return builtins.format(v, ".15g")
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def exp_taylor(x):
    term = 1.0
    sum_ = 1.0
    i = 1.0
    while i < 20.0:
        term = term * x / i
        sum_ = sum_ + term
        i = i + 1.0
    return sum_
def sigmoid(x):
    return 1.0 / (1.0 + math.exp(-x))
X = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]
Y = [0.0, 1.0, 0.0, 0.0]
test_data = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]]
w1 = [[0.5, -0.5], [0.5, 0.5]]
b1 = [0.0, 0.0]
w2 = [0.5, -0.5]
b2 = 0.0
def train(epochs, lr):
    global b1, b2, w1, w2
    e = 0
    while e < epochs:
        i = 0
        while i < len(X):
            x0 = X[i][0]
            x1 = X[i][1]
            target = Y[i]
            z1 = w1[0][0] * x0 + w1[1][0] * x1 + b1[0]
            z2 = w1[0][1] * x0 + w1[1][1] * x1 + b1[1]
            h1 = sigmoid(z1)
            h2 = sigmoid(z2)
            z3 = w2[0] * h1 + w2[1] * h2 + b2
            out = sigmoid(z3)
            error = out - target
            d1 = h1 * (1.0 - h1) * w2[0] * error
            d2 = h2 * (1.0 - h2) * w2[1] * error
            w2 = _set_index(w2, 0, w2[0] - lr * error * h1)
            w2 = _set_index(w2, 1, w2[1] - lr * error * h2)
            b2 = b2 - lr * error
            w1[0][0] = w1[0][0] - lr * d1 * x0
            w1[1][0] = w1[1][0] - lr * d1 * x1
            b1 = _set_index(b1, 0, b1[0] - lr * d1)
            w1[0][1] = w1[0][1] - lr * d2 * x0
            w1[1][1] = w1[1][1] - lr * d2 * x1
            b1 = _set_index(b1, 1, b1[1] - lr * d2)
            i = i + 1
        e = e + 1
def predict(samples):
    preds = []
    i = 0
    while i < len(samples):
        x0 = samples[i][0]
        x1 = samples[i][1]
        z1 = w1[0][0] * x0 + w1[1][0] * x1 + b1[0]
        z2 = w1[0][1] * x0 + w1[1][1] * x1 + b1[1]
        h1 = sigmoid(z1)
        h2 = sigmoid(z2)
        z3 = w2[0] * h1 + w2[1] * h2 + b2
        out = sigmoid(z3)
        label = 0
        if out >= 0.5:
            label = 1
        preds = _append(preds, label)
        i = i + 1
    return preds
def wrapper(y):
    return y
train(4000, 0.5)
preds = wrapper(predict(test_data))
print(_str(preds))

