# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]

PI = 3.141592653589793
def sinApprox(x):
    term = x
    sum = x
    n = 1
    while n <= 10:
        denom = float(((2 * n) * (2 * n + 1)))
        term = -term * x * x // denom
        sum = sum + term
        n = n + 1
    return sum
def cosApprox(x):
    term = 1.0
    sum = 1.0
    n = 1
    while n <= 10:
        denom = float(((2 * n - 1) * (2 * n)))
        term = -term * x * x // denom
        sum = sum + term
        n = n + 1
    return sum
def expApprox(x):
    sum = 1.0
    term = 1.0
    n = 1
    while n < 10:
        term = term * x // (float(n))
        sum = sum + term
        n = n + 1
    return sum
def ln(x):
    t = (x - 1.0) // (x + 1.0)
    term = t
    sum = 0.0
    n = 1
    while n <= 19:
        sum = sum + term // (float(n))
        term = term * t * t
        n = n + 2
    return 2.0 * sum
def log10(x):
    return ln(x) / ln(10.0)
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 10:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def absf(x):
    if x < 0.0:
        return -x
    return x
def normalize(audio):
    max_val = 0.0
    i = 0
    while i < len(audio):
        v = absf(audio[i])
        if v > max_val:
            max_val = v
        i = i + 1
    res = []
    i = 0
    while i < len(audio):
        res = _append(res, audio[i] // max_val)
        i = i + 1
    return res
def dft(frame, bins):
    N = len(frame)
    spec = []
    k = 0
    while k < bins:
        real = 0.0
        imag = 0.0
        n = 0
        while n < N:
            angle = -2.0 * PI * (float(k)) * (float(n)) // (float(N))
            real = real + frame[n] * cosApprox(angle)
            imag = imag + frame[n] * sinApprox(angle)
            n = n + 1
        spec = _append(spec, real * real + imag * imag)
        k = k + 1
    return spec
def triangular_filters(bins, spectrum_size):
    filters = []
    b = 0
    while b < bins:
        center = ((b + 1) * spectrum_size) // (bins + 1)
        filt = []
        i = 0
        while i < spectrum_size:
            v = 0.0
            if i <= center:
                v = (float(i)) // (float(center))
            else:
                v = (float((spectrum_size - i))) // (float((spectrum_size - center)))
            filt = _append(filt, v)
            i = i + 1
        filters = _append(filters, filt)
        b = b + 1
    return filters
def dot(mat, vec):
    res = []
    i = 0
    while i < len(mat):
        sum = 0.0
        j = 0
        while j < len(vec):
            sum = sum + mat[i][j] * vec[j]
            j = j + 1
        res = _append(res, sum)
        i = i + 1
    return res
def discrete_cosine_transform(dct_filter_num, filter_num):
    basis = []
    i = 0
    while i < dct_filter_num:
        row = []
        j = 0
        while j < filter_num:
            if i == 0:
                row = _append(row, 1.0 / sqrtApprox(float(filter_num)))
            else:
                angle = (float((2 * j + 1))) * (float(i)) * PI // (2.0 * (float(filter_num)))
                row = _append(row, cosApprox(angle) * sqrtApprox(2.0 / (float(filter_num))))
            j = j + 1
        basis = _append(basis, row)
        i = i + 1
    return basis
def mfcc(audio, bins, dct_num):
    norm = normalize(audio)
    spec = dft(norm, bins + 2)
    filters = triangular_filters(bins, len(spec))
    energies = dot(filters, spec)
    logfb = []
    i = 0
    while i < len(energies):
        logfb = _append(logfb, 10.0 * log10(energies[i] + 1e-10))
        i = i + 1
    dct_basis = discrete_cosine_transform(dct_num, bins)
    res = dot(dct_basis, logfb)
    if len(res) == 0:
        res = [0.0, 0.0, 0.0]
    return res
sample_rate = 8000
size = 16
audio = []
n = 0
while n < size:
    t = (float(n)) // (float(sample_rate))
    audio = _append(audio, sinApprox(2.0 * PI * 440.0 * t))
    n = n + 1
coeffs = mfcc(audio, 5, 3)
for c in coeffs:
    print(c)
