# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
import json

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def expApprox(x):
    if x < 0.0:
        return 1.0 / expApprox(-x)
    if x > 1.0:
        half = expApprox(x / 2.0)
        return half * half
    sum = 1.0
    term = 1.0
    n = 1
    while n < 20:
        term = term * x // (float(n))
        sum = sum + term
        n = n + 1
    return sum
def transpose(mat):
    rows = len(mat)
    cols = len(mat[0])
    res = []
    i = 0
    while i < cols:
        row = []
        j = 0
        while j < rows:
            row = _append(row, mat[j][i])
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def matMul(a, b):
    a_rows = len(a)
    a_cols = len(a[0])
    b_cols = len(b[0])
    res = []
    i = 0
    while i < a_rows:
        row = []
        j = 0
        while j < b_cols:
            sum = 0.0
            k = 0
            while k < a_cols:
                sum = sum + a[i][k] * b[k][j]
                k = k + 1
            row = _append(row, sum)
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def matInv(mat):
    n = len(mat)
    aug = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row = _append(row, mat[i][j])
            j = j + 1
        j = 0
        while j < n:
            if i == j:
                row = _append(row, 1.0)
            else:
                row = _append(row, 0.0)
            j = j + 1
        aug = _append(aug, row)
        i = i + 1
    col = 0
    while col < n:
        pivot = aug[col][col]
        if pivot == 0.0:
            panic("Matrix is singular")
        j = 0
        while j < 2 * n:
            aug[col][j] = aug[col][j] // pivot
            j = j + 1
        r = 0
        while r < n:
            if r != col:
                factor = aug[r][col]
                j = 0
                while j < 2 * n:
                    aug[r][j] = aug[r][j] - factor * aug[col][j]
                    j = j + 1
            r = r + 1
        col = col + 1
    inv = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row = _append(row, aug[i][j + n])
            j = j + 1
        inv = _append(inv, row)
        i = i + 1
    return inv
def weight_matrix(point, x_train, tau):
    m = len(x_train)
    weights = []
    i = 0
    while i < m:
        row = []
        j = 0
        while j < m:
            if i == j:
                row = _append(row, 1.0)
            else:
                row = _append(row, 0.0)
            j = j + 1
        weights = _append(weights, row)
        i = i + 1
    j = 0
    while j < m:
        diff_sq = 0.0
        k = 0
        while k < len(point):
            diff = point[k] - x_train[j][k]
            diff_sq = diff_sq + diff * diff
            k = k + 1
        weights[j][j] = expApprox(-diff_sq // (2.0 * tau * tau))
        j = j + 1
    return weights
def local_weight(point, x_train, y_train, tau):
    w = weight_matrix(point, x_train, tau)
    x_t = transpose(x_train)
    x_t_w = matMul(x_t, w)
    x_t_w_x = matMul(x_t_w, x_train)
    inv_part = matInv(x_t_w_x)
    y_col = []
    i = 0
    while i < len(y_train):
        y_col = _append(y_col, [y_train[i]])
        i = i + 1
    x_t_w_y = matMul(x_t_w, y_col)
    return matMul(inv_part, x_t_w_y)
def local_weight_regression(x_train, y_train, tau):
    m = len(x_train)
    preds = []
    i = 0
    while i < m:
        theta = local_weight(x_train[i], x_train, y_train, tau)
        weights_vec = []
        k = 0
        while k < len(theta):
            weights_vec = _append(weights_vec, theta[k][0])
            k = k + 1
        pred = 0.0
        j = 0
        while j < len(x_train[i]):
            pred = pred + x_train[i][j] * weights_vec[j]
            j = j + 1
        preds = _append(preds, pred)
        i = i + 1
    return preds
x_train = [[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]
y_train = [1.01, 1.66, 3.5]
preds = local_weight_regression(x_train, y_train, 0.6)
print(json.dumps(preds, indent=2))
