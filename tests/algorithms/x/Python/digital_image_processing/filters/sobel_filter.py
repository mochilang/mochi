# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 06:45 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

PI = 3.141592653589793
def absf(x):
    if x < 0.0:
        return -x
    return x
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x / 2.0
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def atanApprox(x):
    if x > 1.0:
        return PI / 2.0 - x // (x * x + 0.28)
    if x < (-1.0):
        return -PI / 2.0 - x // (x * x + 0.28)
    return x // (1.0 + 0.28 * x * x)
def atan2Approx(y, x):
    if x == 0.0:
        if y > 0.0:
            return PI / 2.0
        if y < 0.0:
            return -PI / 2.0
        return 0.0
    a = atanApprox(y // x)
    if x > 0.0:
        return a
    if y >= 0.0:
        return a + PI
    return a - PI
def zeros(h, w):
    m = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            row = _append(row, 0.0)
            x = x + 1
        m = _append(m, row)
        y = y + 1
    return m
def pad_edge(img, pad):
    h = len(img)
    w = len(img[0])
    out = zeros(h + pad * 2, w + pad * 2)
    y = 0
    while y < h + pad * 2:
        x = 0
        while x < w + pad * 2:
            sy = y - pad
            if sy < 0:
                sy = 0
            if sy >= h:
                sy = h - 1
            sx = x - pad
            if sx < 0:
                sx = 0
            if sx >= w:
                sx = w - 1
            out[y][x] = img[sy][sx]
            x = x + 1
        y = y + 1
    return out
def img_convolve(img, kernel):
    h = len(img)
    w = len(img[0])
    k = len(kernel)
    pad = k // 2
    padded = pad_edge(img, pad)
    out = zeros(h, w)
    y = 0
    while y < h:
        x = 0
        while x < w:
            sum = 0.0
            i = 0
            while i < k:
                j = 0
                while j < k:
                    sum = sum + padded[y + i][x + j] * (float(kernel[i][j]))
                    j = j + 1
                i = i + 1
            out[y][x] = sum
            x = x + 1
        y = y + 1
    return out
def abs_matrix(mat):
    h = len(mat)
    w = len(mat[0])
    out = zeros(h, w)
    y = 0
    while y < h:
        x = 0
        while x < w:
            v = mat[y][x]
            if v < 0.0:
                out[y][x] = -v
            else:
                out[y][x] = v
            x = x + 1
        y = y + 1
    return out
def max_matrix(mat):
    max_val = mat[0][0]
    y = 0
    while y < len(mat):
        x = 0
        while x < len(mat[0]):
            if mat[y][x] > max_val:
                max_val = mat[y][x]
            x = x + 1
        y = y + 1
    return max_val
def scale_matrix(mat, factor):
    h = len(mat)
    w = len(mat[0])
    out = zeros(h, w)
    y = 0
    while y < h:
        x = 0
        while x < w:
            out[y][x] = mat[y][x] * factor
            x = x + 1
        y = y + 1
    return out
def sobel_filter(image):
    h = len(image)
    w = len(image[0])
    img = []
    y0 = 0
    while y0 < h:
        row = []
        x0 = 0
        while x0 < w:
            row = _append(row, float(image[y0][x0]))
            x0 = x0 + 1
        img = _append(img, row)
        y0 = y0 + 1
    kernel_x = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]
    kernel_y = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]
    dst_x = abs_matrix(img_convolve(img, kernel_x))
    dst_y = abs_matrix(img_convolve(img, kernel_y))
    max_x = max_matrix(dst_x)
    max_y = max_matrix(dst_y)
    dst_x = scale_matrix(dst_x, 255.0 / max_x)
    dst_y = scale_matrix(dst_y, 255.0 / max_y)
    mag = zeros(h, w)
    theta = zeros(h, w)
    y = 0
    while y < h:
        x = 0
        while x < w:
            gx = dst_x[y][x]
            gy = dst_y[y][x]
            mag[y][x] = sqrtApprox(gx * gx + gy * gy)
            theta[y][x] = atan2Approx(gy, gx)
            x = x + 1
        y = y + 1
    max_m = max_matrix(mag)
    mag = scale_matrix(mag, 255.0 / max_m)
    return [mag, theta]
def print_matrix_int(mat):
    y = 0
    while y < len(mat):
        line = ""
        x = 0
        while x < len(mat[y]):
            line = line + str(int(mat[y][x]))
            if x < len(mat[y]) - 1:
                line = line + " "
            x = x + 1
        print(line)
        y = y + 1
def print_matrix_float(mat):
    y = 0
    while y < len(mat):
        line = ""
        x = 0
        while x < len(mat[y]):
            line = line + str(mat[y][x])
            if x < len(mat[y]) - 1:
                line = line + " "
            x = x + 1
        print(line)
        y = y + 1
def main():
    img = [[10, 10, 10, 10, 10], [10, 50, 50, 50, 10], [10, 50, 80, 50, 10], [10, 50, 50, 50, 10], [10, 10, 10, 10, 10]]
    res = sobel_filter(img)
    mag = res[0]
    theta = res[1]
    print_matrix_int(mag)
    print_matrix_float(theta)
main()
