# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 06:45 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def clamp_byte(x):
    if x < 0:
        return 0
    if x > 255:
        return 255
    return x
def convert_to_negative(img):
    h = len(img)
    w = len(img[0])
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            row = _append(row, 255 - img[y][x])
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def change_contrast(img, factor):
    h = len(img)
    w = len(img[0])
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            p = img[y][x]
            v = ((p - 128) * factor) // 100 + 128
            v = clamp_byte(v)
            row = _append(row, v)
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def gen_gaussian_kernel(n, sigma):
    if n == 3:
        return [[1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0], [2.0 / 16.0, 4.0 / 16.0, 2.0 / 16.0], [1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0]]
    k = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row = _append(row, 0.0)
            j = j + 1
        k = _append(k, row)
        i = i + 1
    return k
def img_convolve(img, kernel):
    h = len(img)
    w = len(img[0])
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            acc = 0.0
            ky = 0
            while ky < len(kernel):
                kx = 0
                while kx < len(kernel[0]):
                    iy = y + ky - 1
                    ix = x + kx - 1
                    pixel = 0
                    if iy >= 0 and iy < h and ix >= 0 and ix < w:
                        pixel = img[iy][ix]
                    acc = acc + kernel[ky][kx] * (1.0 * pixel)
                    kx = kx + 1
                ky = ky + 1
            row = _append(row, int(acc))
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def sort_ints(xs):
    arr = xs
    i = 0
    while i < len(arr):
        j = 0
        while j < len(arr) - 1 - i:
            if arr[j] > arr[j + 1]:
                tmp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = tmp
            j = j + 1
        i = i + 1
    return arr
def median_filter(img, k):
    h = len(img)
    w = len(img[0])
    offset = k // 2
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            vals = []
            ky = 0
            while ky < k:
                kx = 0
                while kx < k:
                    iy = y + ky - offset
                    ix = x + kx - offset
                    pixel = 0
                    if iy >= 0 and iy < h and ix >= 0 and ix < w:
                        pixel = img[iy][ix]
                    vals = _append(vals, pixel)
                    kx = kx + 1
                ky = ky + 1
            sorted = sort_ints(vals)
            row = _append(row, sorted[len(sorted) // 2])
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def iabs(x):
    if x < 0:
        return -x
    return x
def sobel_filter(img):
    gx = [[1, 0, -1], [2, 0, -2], [1, 0, -1]]
    gy = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]
    h = len(img)
    w = len(img[0])
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            sx = 0
            sy = 0
            ky = 0
            while ky < 3:
                kx = 0
                while kx < 3:
                    iy = y + ky - 1
                    ix = x + kx - 1
                    pixel = 0
                    if iy >= 0 and iy < h and ix >= 0 and ix < w:
                        pixel = img[iy][ix]
                    sx = sx + gx[ky][kx] * pixel
                    sy = sy + gy[ky][kx] * pixel
                    kx = kx + 1
                ky = ky + 1
            row = _append(row, iabs(sx) + iabs(sy))
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def get_neighbors_pixel(img, x, y):
    h = len(img)
    w = len(img[0])
    neighbors = []
    dy = -1
    while dy <= 1:
        dx = -1
        while dx <= 1:
            if not (dx == 0 and dy == 0):
                ny = y + dy
                nx = x + dx
                val = 0
                if ny >= 0 and ny < h and nx >= 0 and nx < w:
                    val = img[ny][nx]
                neighbors = _append(neighbors, val)
            dx = dx + 1
        dy = dy + 1
    return neighbors
def pow2(e):
    r = 1
    i = 0
    while i < e:
        r = r * 2
        i = i + 1
    return r
def local_binary_value(img, x, y):
    center = img[y][x]
    neighbors = get_neighbors_pixel(img, x, y)
    v = 0
    i = 0
    while i < len(neighbors):
        if neighbors[i] >= center:
            v = v + pow2(i)
        i = i + 1
    return v
def local_binary_pattern(img):
    h = len(img)
    w = len(img[0])
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            row = _append(row, local_binary_value(img, x, y))
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
img = [[52, 55, 61], [62, 59, 55], [63, 65, 66]]
negative = convert_to_negative(img)
contrast = change_contrast(img, 110)
kernel = gen_gaussian_kernel(3, 1.0)
laplace = [[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]]
convolved = img_convolve(img, laplace)
medianed = median_filter(img, 3)
sobel = sobel_filter(img)
lbp_img = local_binary_pattern(img)
print(negative)
print(contrast)
print(kernel)
print(convolved)
print(medianed)
print(sobel)
print(lbp_img)
