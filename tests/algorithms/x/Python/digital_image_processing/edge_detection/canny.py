# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:08 +0700
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    PI = 3.141592653589793
    def sqrtApprox(x):
        guess = x / 2.0
        i = 0
        while i < 20:
            guess = (guess + x // guess) / 2.0
            i = i + 1
        return guess
    def atanApprox(x):
        if x > 1.0:
            return PI / 2.0 - x // (x * x + 0.28)
        if x < (-1.0):
            return -PI / 2.0 - x // (x * x + 0.28)
        return x // (1.0 + 0.28 * x * x)
    def atan2Approx(y, x):
        if x > 0.0:
            r = atanApprox(y // x)
            return r
        if x < 0.0:
            if y >= 0.0:
                return atanApprox(y // x) + PI
            return atanApprox(y // x) - PI
        if y > 0.0:
            return PI / 2.0
        if y < 0.0:
            return -PI / 2.0
        return 0.0
    def deg(rad):
        return rad * 180.0 / PI
    GAUSSIAN_KERNEL = [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]]
    SOBEL_GX = [[-1.0, 0.0, 1.0], [-2.0, 0.0, 2.0], [-1.0, 0.0, 1.0]]
    SOBEL_GY = [[1.0, 2.0, 1.0], [0.0, 0.0, 0.0], [-1.0, -2.0, -1.0]]
    def zero_matrix(h, w):
        out = []
        i = 0
        while i < h:
            row = []
            j = 0
            while j < w:
                row = _append(row, 0.0)
                j = j + 1
            out = _append(out, row)
            i = i + 1
        return out
    def convolve(img, kernel):
        h = len(img)
        w = len(img[0])
        k = len(kernel)
        pad = k // 2
        out = zero_matrix(h, w)
        y = pad
        while y < h - pad:
            x = pad
            while x < w - pad:
                sum = 0.0
                ky = 0
                while ky < k:
                    kx = 0
                    while kx < k:
                        pixel = img[y - pad + ky][x - pad + kx]
                        weight = kernel[ky][kx]
                        sum = sum + pixel * weight
                        kx = kx + 1
                    ky = ky + 1
                out[y][x] = sum
                x = x + 1
            y = y + 1
        return out
    def gaussian_blur(img):
        return convolve(img, GAUSSIAN_KERNEL)
    def sobel_filter(img):
        gx = convolve(img, SOBEL_GX)
        gy = convolve(img, SOBEL_GY)
        h = len(img)
        w = len(img[0])
        grad = zero_matrix(h, w)
        dir = zero_matrix(h, w)
        i = 0
        while i < h:
            j = 0
            while j < w:
                gxx = gx[i][j]
                gyy = gy[i][j]
                grad[i][j] = sqrtApprox(gxx * gxx + gyy * gyy)
                dir[i][j] = deg(atan2Approx(gyy, gxx)) + 180.0
                j = j + 1
            i = i + 1
        return {"grad": grad, "dir": dir}
    def suppress_non_maximum(h, w, direction, grad):
        dest = zero_matrix(h, w)
        r = 1
        while r < h - 1:
            c = 1
            while c < w - 1:
                angle = direction[r][c]
                q = 0.0
                p = 0.0
                if (angle >= 0.0 and angle < 22.5) or (angle >= 157.5 and angle <= 180.0) or (angle >= 337.5):
                    q = grad[r][c + 1]
                    p = grad[r][c - 1]
                else:
                    if (angle >= 22.5 and angle < 67.5) or (angle >= 202.5 and angle < 247.5):
                        q = grad[r + 1][c - 1]
                        p = grad[r - 1][c + 1]
                    else:
                        if (angle >= 67.5 and angle < 112.5) or (angle >= 247.5 and angle < 292.5):
                            q = grad[r + 1][c]
                            p = grad[r - 1][c]
                        else:
                            q = grad[r - 1][c - 1]
                            p = grad[r + 1][c + 1]
                if grad[r][c] >= q and grad[r][c] >= p:
                    dest[r][c] = grad[r][c]
                c = c + 1
            r = r + 1
        return dest
    def double_threshold(h, w, img, low, high, weak, strong):
        r = 0
        while r < h:
            c = 0
            while c < w:
                v = img[r][c]
                if v >= high:
                    img[r][c] = strong
                else:
                    if v < low:
                        img[r][c] = 0.0
                    else:
                        img[r][c] = weak
                c = c + 1
            r = r + 1
    def track_edge(h, w, img, weak, strong):
        r = 1
        while r < h - 1:
            c = 1
            while c < w - 1:
                if img[r][c] == weak:
                    if img[r + 1][c] == strong or img[r - 1][c] == strong or img[r][c + 1] == strong or img[r][c - 1] == strong or img[r - 1][c - 1] == strong or img[r - 1][c + 1] == strong or img[r + 1][c - 1] == strong or img[r + 1][c + 1] == strong:
                        img[r][c] = strong
                    else:
                        img[r][c] = 0.0
                c = c + 1
            r = r + 1
    def canny(image, low, high, weak, strong):
        blurred = gaussian_blur(image)
        sob = sobel_filter(blurred)
        grad = sob.get("grad", [])
        direction = sob.get("dir", [])
        h = len(image)
        w = len(image[0])
        suppressed = suppress_non_maximum(h, w, direction, grad)
        double_threshold(h, w, suppressed, low, high, weak, strong)
        track_edge(h, w, suppressed, weak, strong)
        return suppressed
    def print_image(img):
        r = 0
        while r < len(img):
            c = 0
            line = ""
            while c < len(img[r]):
                line = line + str(int(img[r][c])) + " "
                c = c + 1
            print(line)
            r = r + 1
    image = [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]]
    edges = canny(image, 20.0, 40.0, 128.0, 255.0)
    print_image(edges)
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
