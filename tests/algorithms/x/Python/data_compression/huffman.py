# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Leaf:
    symbol: str
    freq: int

@dataclass
class Node:
    freq: int
    left: Huffman
    right: Huffman

def get_freq(n):
    return (n.freq if isinstance(n, Leaf) else (n.freq if isinstance(n, Node) else None))
def sort_nodes(nodes):
    arr = nodes
    i = 1
    while i < len(arr):
        key = arr[i]
        j = i - 1
        while j >= 0 and get_freq(arr[j]) > get_freq(key):
            arr[j + 1] = arr[j]
            j = j - 1
        arr[j + 1] = key
        i = i + 1
    return arr
def rest(nodes):
    res = []
    i = 1
    while i < len(nodes):
        res = _append(res, nodes[i])
        i = i + 1
    return res
def count_freq(text):
    chars = []
    freqs = []
    i = 0
    while i < len(text):
        c = text[i:i + 1]
        j = 0
        found = False
        while j < len(chars):
            if chars[j] == c:
                freqs[j] = freqs[j] + 1
                found = True
                break
            j = j + 1
        if not found:
            chars = _append(chars, c)
            freqs = _append(freqs, 1)
        i = i + 1
    leaves = []
    k = 0
    while k < len(chars):
        leaves = _append(leaves, Leaf(symbol=chars[k], freq=freqs[k]))
        k = k + 1
    return sort_nodes(leaves)
def build_tree(nodes):
    arr = nodes
    while len(arr) > 1:
        left = arr[0]
        arr = rest(arr)
        right = arr[0]
        arr = rest(arr)
        node = Node(freq=get_freq(left) + get_freq(right), left=left, right=right)
        arr = _append(arr, node)
        arr = sort_nodes(arr)
    return arr[0]
def concat_pairs(a, b):
    res = a
    i = 0
    while i < len(b):
        res = _append(res, b[i])
        i = i + 1
    return res
def collect_codes(tree, prefix):
    return ([[tree.symbol, prefix]] if isinstance(tree, Leaf) else (concat_pairs(collect_codes(tree.left, prefix + "0"), collect_codes(tree.right, prefix + "1")) if isinstance(tree, Node) else None))
def find_code(pairs, ch):
    i = 0
    while i < len(pairs):
        if pairs[i][0] == ch:
            return pairs[i][1]
        i = i + 1
    return ""
def huffman_encode(text):
    if text == "":
        return ""
    leaves = count_freq(text)
    tree = build_tree(leaves)
    codes = collect_codes(tree, "")
    encoded = ""
    i = 0
    while i < len(text):
        c = text[i:i + 1]
        encoded = encoded + find_code(codes, c) + " "
        i = i + 1
    return encoded
print(huffman_encode("beep boop beer!"))
