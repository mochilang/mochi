# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]

def conv2d(image, kernel):
    rows = len(image)
    cols = len(image[0])
    k = len(kernel)
    output = []
    i = 0
    while i <= rows - k:
        row = []
        j = 0
        while j <= cols - k:
            sum = 0.0
            ki = 0
            while ki < k:
                kj = 0
                while kj < k:
                    sum = sum + image[i + ki][j + kj] * kernel[ki][kj]
                    kj = kj + 1
                ki = ki + 1
            row = _append(row, sum)
            j = j + 1
        output = _append(output, row)
        i = i + 1
    return output
def relu_matrix(m):
    out = []
    for row in m:
        new_row = []
        for v in row:
            if v > 0.0:
                new_row = _append(new_row, v)
            else:
                new_row = _append(new_row, 0.0)
        out = _append(out, new_row)
    return out
def max_pool2x2(m):
    rows = len(m)
    cols = len(m[0])
    out = []
    i = 0
    while i < rows:
        new_row = []
        j = 0
        while j < cols:
            max_val = m[i][j]
            if m[i][j + 1] > max_val:
                max_val = m[i][j + 1]
            if m[i + 1][j] > max_val:
                max_val = m[i + 1][j]
            if m[i + 1][j + 1] > max_val:
                max_val = m[i + 1][j + 1]
            new_row = _append(new_row, max_val)
            j = j + 2
        out = _append(out, new_row)
        i = i + 2
    return out
def flatten(m):
    res = []
    for row in m:
        for v in row:
            res = _append(res, v)
    return res
def dense(inputs, weights, bias):
    s = bias
    i = 0
    while i < len(inputs):
        s = s + inputs[i] * weights[i]
        i = i + 1
    return s
def exp_approx(x):
    sum = 1.0
    term = 1.0
    i = 1
    while i <= 10:
        term = term * x // i
        sum = sum + term
        i = i + 1
    return sum
def sigmoid(x):
    return 1.0 / (1.0 + exp_approx(-x))
image = [[0.0, 1.0, 1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 1.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]
kernel = [[1.0, 0.0, -1.0], [1.0, 0.0, -1.0], [1.0, 0.0, -1.0]]
conv = conv2d(image, kernel)
activated = relu_matrix(conv)
pooled = max_pool2x2(activated)
flat = flatten(pooled)
weights = [0.5, -0.4, 0.3, 0.1]
bias = 0.0
output = dense(flat, weights, bias)
probability = sigmoid(output)
if probability >= 0.5:
    print("Abnormality detected")
else:
    print("Normal")
print("Probability:")
print(probability)
