# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class MosaicResult:
    img: [[int]]
    annos: [[float]]
    path: str

def update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale):
    height = output_size[0]
    width = output_size[1]
    output_img = []
    r = 0
    while r < height:
        row = []
        c = 0
        while c < width:
            row = _append(row, 0)
            c = c + 1
        output_img = _append(output_img, row)
        r = r + 1
    scale_x = (scale_range[0] + scale_range[1]) / 2.0
    scale_y = (scale_range[0] + scale_range[1]) / 2.0
    divid_point_x = (int((scale_x * (float(width)))))
    divid_point_y = (int((scale_y * (float(height)))))
    new_anno = []
    path_list = []
    i = 0
    while i < len(idxs):
        index = idxs[i]
        path = all_img_list[index]
        path_list = _append(path_list, path)
        img_annos = all_annos[index]
        if i == 0:
            y0 = 0
            while y0 < divid_point_y:
                x0 = 0
                while x0 < divid_point_x:
                    output_img[y0][x0] = i + 1
                    x0 = x0 + 1
                y0 = y0 + 1
            j0 = 0
            while j0 < len(img_annos):
                bbox = img_annos[j0]
                xmin = bbox[1] * scale_x
                ymin = bbox[2] * scale_y
                xmax = bbox[3] * scale_x
                ymax = bbox[4] * scale_y
                new_anno = _append(new_anno, [bbox[0], xmin, ymin, xmax, ymax])
                j0 = j0 + 1
        else:
            if i == 1:
                y1 = 0
                while y1 < divid_point_y:
                    x1 = divid_point_x
                    while x1 < width:
                        output_img[y1][x1] = i + 1
                        x1 = x1 + 1
                    y1 = y1 + 1
                j1 = 0
                while j1 < len(img_annos):
                    bbox1 = img_annos[j1]
                    xmin1 = scale_x + bbox1[1] * (1.0 - scale_x)
                    ymin1 = bbox1[2] * scale_y
                    xmax1 = scale_x + bbox1[3] * (1.0 - scale_x)
                    ymax1 = bbox1[4] * scale_y
                    new_anno = _append(new_anno, [bbox1[0], xmin1, ymin1, xmax1, ymax1])
                    j1 = j1 + 1
            else:
                if i == 2:
                    y2 = divid_point_y
                    while y2 < height:
                        x2 = 0
                        while x2 < divid_point_x:
                            output_img[y2][x2] = i + 1
                            x2 = x2 + 1
                        y2 = y2 + 1
                    j2 = 0
                    while j2 < len(img_annos):
                        bbox2 = img_annos[j2]
                        xmin2 = bbox2[1] * scale_x
                        ymin2 = scale_y + bbox2[2] * (1.0 - scale_y)
                        xmax2 = bbox2[3] * scale_x
                        ymax2 = scale_y + bbox2[4] * (1.0 - scale_y)
                        new_anno = _append(new_anno, [bbox2[0], xmin2, ymin2, xmax2, ymax2])
                        j2 = j2 + 1
                else:
                    y3 = divid_point_y
                    while y3 < height:
                        x3 = divid_point_x
                        while x3 < width:
                            output_img[y3][x3] = i + 1
                            x3 = x3 + 1
                        y3 = y3 + 1
                    j3 = 0
                    while j3 < len(img_annos):
                        bbox3 = img_annos[j3]
                        xmin3 = scale_x + bbox3[1] * (1.0 - scale_x)
                        ymin3 = scale_y + bbox3[2] * (1.0 - scale_y)
                        xmax3 = scale_x + bbox3[3] * (1.0 - scale_x)
                        ymax3 = scale_y + bbox3[4] * (1.0 - scale_y)
                        new_anno = _append(new_anno, [bbox3[0], xmin3, ymin3, xmax3, ymax3])
                        j3 = j3 + 1
        i = i + 1
    if filter_scale > 0.0:
        filtered = []
        k = 0
        while k < len(new_anno):
            anno = new_anno[k]
            w = anno[3] - anno[1]
            h = anno[4] - anno[2]
            if filter_scale < w and filter_scale < h:
                filtered = _append(filtered, anno)
            k = k + 1
        new_anno = filtered
    return MosaicResult(img=output_img, annos=new_anno, path=path_list[0])
def main():
    all_img_list = ["img0.jpg", "img1.jpg", "img2.jpg", "img3.jpg"]
    all_annos = [[[0.0, 0.1, 0.1, 0.4, 0.4]], [[1.0, 0.2, 0.3, 0.5, 0.7]], [[2.0, 0.6, 0.2, 0.9, 0.5]], [[3.0, 0.5, 0.5, 0.8, 0.8]]]
    idxs = [0, 1, 2, 3]
    output_size = [100, 100]
    scale_range = [0.4, 0.6]
    filter_scale = 0.05
    res = update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale)
    new_annos = res.annos
    path = res.path
    print("Base image: " + path)
    print("Mosaic annotation count: " + str(len(new_annos)))
    i = 0
    while i < len(new_annos):
        a = new_annos[i]
        print(str(a[0]) + " " + str(a[1]) + " " + str(a[2]) + " " + str(a[3]) + " " + str(a[4]))
        i = i + 1
main()
