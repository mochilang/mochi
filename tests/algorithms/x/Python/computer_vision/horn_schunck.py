# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-06 22:12 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        return [v]
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def round_int(x):
    if x >= 0.0:
        return int(x + 0.5)
    return int(x - 0.5)
def zeros(rows, cols):
    res = []
    i = 0
    while i < rows:
        row = []
        j = 0
        while j < cols:
            row = _append(row, 0.0)
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def warp(image, h_flow, v_flow):
    h = len(image)
    w = len(image[0])
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            sx = x - round_int(h_flow[y][x])
            sy = y - round_int(v_flow[y][x])
            if sx >= 0 and sx < w and sy >= 0 and sy < h:
                row = _append(row, image[sy][sx])
            else:
                row = _append(row, 0.0)
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def convolve(img, ker):
    h = len(img)
    w = len(img[0])
    kh = len(ker)
    kw = len(ker[0])
    py = kh // 2
    px = kw // 2
    out = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            s = 0.0
            ky = 0
            while ky < kh:
                kx = 0
                while kx < kw:
                    iy = y + ky - py
                    ix = x + kx - px
                    if iy >= 0 and iy < h and ix >= 0 and ix < w:
                        s = s + img[iy][ix] * ker[ky][kx]
                    kx = kx + 1
                ky = ky + 1
            row = _append(row, s)
            x = x + 1
        out = _append(out, row)
        y = y + 1
    return out
def horn_schunck(image0, image1, num_iter, alpha):
    h = len(image0)
    w = len(image0[0])
    u = zeros(h, w)
    v = zeros(h, w)
    kernel_x = [[-0.25, 0.25], [-0.25, 0.25]]
    kernel_y = [[-0.25, -0.25], [0.25, 0.25]]
    kernel_t = [[0.25, 0.25], [0.25, 0.25]]
    laplacian = [[0.0833333333333, 0.166666666667, 0.0833333333333], [0.166666666667, 0.0, 0.166666666667], [0.0833333333333, 0.166666666667, 0.0833333333333]]
    it = 0
    while it < num_iter:
        warped = warp(image0, u, v)
        dx1 = convolve(warped, kernel_x)
        dx2 = convolve(image1, kernel_x)
        dy1 = convolve(warped, kernel_y)
        dy2 = convolve(image1, kernel_y)
        dt1 = convolve(warped, kernel_t)
        dt2 = convolve(image1, kernel_t)
        avg_u = convolve(u, laplacian)
        avg_v = convolve(v, laplacian)
        y = 0
        while y < h:
            x = 0
            while x < w:
                dx = dx1[y][x] + dx2[y][x]
                dy = dy1[y][x] + dy2[y][x]
                dt = dt1[y][x] - dt2[y][x]
                au = avg_u[y][x]
                av = avg_v[y][x]
                numer = dx * au + dy * av + dt
                denom = alpha * alpha + dx * dx + dy * dy
                upd = numer // denom
                u[y][x] = au - dx * upd
                v[y][x] = av - dy * upd
                x = x + 1
            y = y + 1
        it = it + 1
    return [u, v]
def print_matrix(mat):
    y = 0
    while y < len(mat):
        row = mat[y]
        x = 0
        line = ""
        while x < len(row):
            line = line + str(round_int(row[x]))
            if x + 1 < len(row):
                line = line + " "
            x = x + 1
        print(line)
        y = y + 1
def main():
    image0 = [[0.0, 0.0, 2.0], [0.0, 0.0, 2.0]]
    image1 = [[0.0, 2.0, 0.0], [0.0, 2.0, 0.0]]
    flows = horn_schunck(image0, image1, 20, 0.1)
    u = flows[0]
    v = flows[1]
    print_matrix(u)
    print("---")
    print_matrix(v)
main()
