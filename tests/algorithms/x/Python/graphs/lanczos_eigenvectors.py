# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 15:46 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    seed = 123456789
    def rand():
        global seed
        seed = (seed * 1103515245 + 12345) % 2147483648
        return seed
    def random():
        return (1.0 * rand()) / 2.147483648e+09
    def sqrtApprox(x):
        if x <= 0.0:
            return 0.0
        guess = x
        i = 0
        while i < 20:
            guess = (guess + x / guess) / 2.0
            i = i + 1
        return guess
    def absf(x):
        return (-x if x < 0.0 else x)
    def dot(a, b):
        s = 0.0
        i = 0
        while i < len(a):
            s = s + a[i] * b[i]
            i = i + 1
        return s
    def vector_scale(v, s):
        res = []
        i = 0
        while i < len(v):
            res = _append(res, v[i] * s)
            i = i + 1
        return res
    def vector_sub(a, b):
        res = []
        i = 0
        while i < len(a):
            res = _append(res, a[i] - b[i])
            i = i + 1
        return res
    def vector_add(a, b):
        res = []
        i = 0
        while i < len(a):
            res = _append(res, a[i] + b[i])
            i = i + 1
        return res
    def zeros_matrix(r, c):
        m = []
        i = 0
        while i < r:
            row = []
            j = 0
            while j < c:
                row = _append(row, 0.0)
                j = j + 1
            m = _append(m, row)
            i = i + 1
        return m
    @dataclass
    class LanczosResult:
        t: [[float]]
        q: [[float]]
    @dataclass
    class EigenResult:
        values: [float]
        vectors: [[float]]
    def column(m, idx):
        col = []
        i = 0
        while i < len(m):
            col = _append(col, m[i][idx])
            i = i + 1
        return col
    def validate_adjacency_list(graph):
        i = 0
        while i < len(graph):
            j = 0
            while j < len(graph[i]):
                v = graph[i][j]
                if v < 0 or v >= len(graph):
                    panic("Invalid neighbor")
                j = j + 1
            i = i + 1
    def multiply_matrix_vector(graph, vector):
        n = len(graph)
        if len(vector) != n:
            panic("Vector length must match number of nodes")
        result = []
        i = 0
        while i < n:
            sum = 0.0
            j = 0
            while j < len(graph[i]):
                nb = graph[i][j]
                sum = sum + vector[nb]
                j = j + 1
            result = _append(result, sum)
            i = i + 1
        return result
    def lanczos_iteration(graph, k):
        n = len(graph)
        if k < 1 or k > n:
            panic("invalid number of eigenvectors")
        q = zeros_matrix(n, k)
        t = zeros_matrix(k, k)
        v = []
        i = 0
        while i < n:
            v = _append(v, random())
            i = i + 1
        ss = 0.0
        i = 0
        while i < n:
            ss = ss + v[i] * v[i]
            i = i + 1
        vnorm = sqrtApprox(ss)
        i = 0
        while i < n:
            q[i][0] = v[i] / vnorm
            i = i + 1
        beta = 0.0
        j = 0
        while j < k:
            w = multiply_matrix_vector(graph, column(q, j))
            if j > 0:
                w = vector_sub(w, vector_scale(column(q, j - 1), beta))
            alpha = dot(column(q, j), w)
            w = vector_sub(w, vector_scale(column(q, j), alpha))
            ss2 = 0.0
            p = 0
            while p < n:
                ss2 = ss2 + w[p] * w[p]
                p = p + 1
            beta = sqrtApprox(ss2)
            t[j][j] = alpha
            if j < k - 1:
                t[j][j + 1] = beta
                t[j + 1][j] = beta
                if beta > 1e-10:
                    wnorm = vector_scale(w, 1.0 / beta)
                    r = 0
                    while r < n:
                        q[r][j + 1] = wnorm[r]
                        r = r + 1
            j = j + 1
        return LanczosResult(t=t, q=q)
    def jacobi_eigen(a_in, max_iter):
        n = len(a_in)
        a = a_in
        v = zeros_matrix(n, n)
        i = 0
        while i < n:
            v[i][i] = 1.0
            i = i + 1
        iter = 0
        while iter < max_iter:
            p = 0
            q = 1
            max = absf(a[p][q])
            i = 0
            while i < n:
                j = i + 1
                while j < n:
                    val = absf(a[i][j])
                    if val > max:
                        max = val
                        p = i
                        q = j
                    j = j + 1
                i = i + 1
            if max < 1e-08:
                break
            app = a[p][p]
            aqq = a[q][q]
            apq = a[p][q]
            theta = (aqq - app) / (2.0 * apq)
            t = 1.0 / (absf(theta) + sqrtApprox(theta * theta + 1.0))
            if theta < 0.0:
                t = -t
            c = 1.0 / sqrtApprox(1.0 + t * t)
            s = t * c
            tau = s / (1.0 + c)
            a[p][p] = app - t * apq
            a[q][q] = aqq + t * apq
            a[p][q] = 0.0
            a[q][p] = 0.0
            k = 0
            while k < n:
                if k != p and k != q:
                    akp = a[k][p]
                    akq = a[k][q]
                    a[k][p] = akp - s * (akq + tau * akp)
                    a[p][k] = a[k][p]
                    a[k][q] = akq + s * (akp - tau * akq)
                    a[q][k] = a[k][q]
                k = k + 1
            k = 0
            while k < n:
                vkp = v[k][p]
                vkq = v[k][q]
                v[k][p] = vkp - s * (vkq + tau * vkp)
                v[k][q] = vkq + s * (vkp - tau * vkq)
                k = k + 1
            iter = iter + 1
        eigenvalues = []
        i = 0
        while i < n:
            eigenvalues = _append(eigenvalues, a[i][i])
            i = i + 1
        return EigenResult(values=eigenvalues, vectors=v)
    def matmul(a, b):
        rows = len(a)
        cols = len(b[0])
        inner = len(b)
        m = zeros_matrix(rows, cols)
        i = 0
        while i < rows:
            j = 0
            while j < cols:
                s = 0.0
                k = 0
                while k < inner:
                    s = s + a[i][k] * b[k][j]
                    k = k + 1
                m[i][j] = s
                j = j + 1
            i = i + 1
        return m
    def sort_eigenpairs(vals, vecs):
        n = len(vals)
        values = vals
        vectors = vecs
        i = 0
        while i < n:
            j = 0
            while j < n - 1:
                if values[j] < values[j + 1]:
                    tmp = values[j]
                    values[j] = values[j + 1]
                    values[j + 1] = tmp
                    r = 0
                    while r < len(vectors):
                        tv = vectors[r][j]
                        vectors[r][j] = vectors[r][j + 1]
                        vectors[r][j + 1] = tv
                        r = r + 1
                j = j + 1
            i = i + 1
        return EigenResult(values=values, vectors=vectors)
    def find_lanczos_eigenvectors(graph, k):
        validate_adjacency_list(graph)
        res = lanczos_iteration(graph, k)
        eig = jacobi_eigen(res.t, 50)
        sorted = sort_eigenpairs(eig.values, eig.vectors)
        final_vectors = matmul(res.q, sorted.vectors)
        return EigenResult(values=sorted.values, vectors=final_vectors)
    def list_to_string(arr):
        s = "["
        i = 0
        while i < len(arr):
            s = s + _str(arr[i])
            if i < len(arr) - 1:
                s = s + ", "
            i = i + 1
        return s + "]"
    def matrix_to_string(m):
        s = "["
        i = 0
        while i < len(m):
            s = s + list_to_string(m[i])
            if i < len(m) - 1:
                s = s + "; "
            i = i + 1
        return s + "]"
    graph = [[1, 2], [0, 2], [0, 1]]
    result = find_lanczos_eigenvectors(graph, 2)
    print(list_to_string(result.values))
    print(matrix_to_string(result.vectors))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

