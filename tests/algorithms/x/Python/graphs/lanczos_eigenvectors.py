# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-07 17:24 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

seed = 123456789
def rand():
    global seed
    seed = (seed * 1103515245 + 12345) % 2147483648
    return seed
def random():
    return (1.0 * rand()) / 2.147483648e+09
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def absf(x):
    return (-x if x < 0.0 else x)
def dot(a, b):
    s = 0.0
    i = 0
    while i < len(a):
        s = s + a[i] * b[i]
        i = i + 1
    return s
def vector_scale(v, s):
    res = []
    i = 0
    while i < len(v):
        res = _append(res, v[i] * s)
        i = i + 1
    return res
def vector_sub(a, b):
    res = []
    i = 0
    while i < len(a):
        res = _append(res, a[i] - b[i])
        i = i + 1
    return res
def vector_add(a, b):
    res = []
    i = 0
    while i < len(a):
        res = _append(res, a[i] + b[i])
        i = i + 1
    return res
def zeros_matrix(r, c):
    m = []
    i = 0
    while i < r:
        row = []
        j = 0
        while j < c:
            row = _append(row, 0.0)
            j = j + 1
        m = _append(m, row)
        i = i + 1
    return m
@dataclass
class LanczosResult:
    t: [[float]]
    q: [[float]]

@dataclass
class EigenResult:
    values: [float]
    vectors: [[float]]

def column(m, idx):
    col = []
    i = 0
    while i < len(m):
        col = _append(col, m[i][idx])
        i = i + 1
    return col
def validate_adjacency_list(graph):
    i = 0
    while i < len(graph):
        j = 0
        while j < len(graph[i]):
            v = graph[i][j]
            if v < 0 or v >= len(graph):
                panic("Invalid neighbor")
            j = j + 1
        i = i + 1
def multiply_matrix_vector(graph, vector):
    n = len(graph)
    if len(vector) != n:
        panic("Vector length must match number of nodes")
    result = []
    i = 0
    while i < n:
        sum = 0.0
        j = 0
        while j < len(graph[i]):
            nb = graph[i][j]
            sum = sum + vector[nb]
            j = j + 1
        result = _append(result, sum)
        i = i + 1
    return result
def lanczos_iteration(graph, k):
    n = len(graph)
    if k < 1 or k > n:
        panic("invalid number of eigenvectors")
    q = zeros_matrix(n, k)
    t = zeros_matrix(k, k)
    v = []
    i = 0
    while i < n:
        v = _append(v, random())
        i = i + 1
    ss = 0.0
    i = 0
    while i < n:
        ss = ss + v[i] * v[i]
        i = i + 1
    vnorm = sqrtApprox(ss)
    i = 0
    while i < n:
        q[i][0] = v[i] // vnorm
        i = i + 1
    beta = 0.0
    j = 0
    while j < k:
        w = multiply_matrix_vector(graph, column(q, j))
        if j > 0:
            w = vector_sub(w, vector_scale(column(q, j - 1), beta))
        alpha = dot(column(q, j), w)
        w = vector_sub(w, vector_scale(column(q, j), alpha))
        ss2 = 0.0
        p = 0
        while p < n:
            ss2 = ss2 + w[p] * w[p]
            p = p + 1
        beta = sqrtApprox(ss2)
        t[j][j] = alpha
        if j < k - 1:
            t[j][j + 1] = beta
            t[j + 1][j] = beta
            if beta > 1e-10:
                wnorm = vector_scale(w, 1.0 / beta)
                r = 0
                while r < n:
                    q[r][j + 1] = wnorm[r]
                    r = r + 1
        j = j + 1
    return LanczosResult(t=t, q=q)
def jacobi_eigen(a_in, max_iter):
    n = len(a_in)
    a = a_in
    v = zeros_matrix(n, n)
    i = 0
    while i < n:
        v[i][i] = 1.0
        i = i + 1
    iter = 0
    while iter < max_iter:
        p = 0
        q = 1
        max = absf(a[p][q])
        i = 0
        while i < n:
            j = i + 1
            while j < n:
                val = absf(a[i][j])
                if val > max:
                    max = val
                    p = i
                    q = j
                j = j + 1
            i = i + 1
        if max < 1e-08:
            break
        app = a[p][p]
        aqq = a[q][q]
        apq = a[p][q]
        theta = (aqq - app) // (2.0 * apq)
        t = 1.0 / (absf(theta) + sqrtApprox(theta * theta + 1.0))
        if theta < 0.0:
            t = -t
        c = 1.0 / sqrtApprox(1.0 + t * t)
        s = t * c
        tau = s // (1.0 + c)
        a[p][p] = app - t * apq
        a[q][q] = aqq + t * apq
        a[p][q] = 0.0
        a[q][p] = 0.0
        k = 0
        while k < n:
            if k != p and k != q:
                akp = a[k][p]
                akq = a[k][q]
                a[k][p] = akp - s * (akq + tau * akp)
                a[p][k] = a[k][p]
                a[k][q] = akq + s * (akp - tau * akq)
                a[q][k] = a[k][q]
            k = k + 1
        k = 0
        while k < n:
            vkp = v[k][p]
            vkq = v[k][q]
            v[k][p] = vkp - s * (vkq + tau * vkp)
            v[k][q] = vkq + s * (vkp - tau * vkq)
            k = k + 1
        iter = iter + 1
    eigenvalues = []
    i = 0
    while i < n:
        eigenvalues = _append(eigenvalues, a[i][i])
        i = i + 1
    return EigenResult(values=eigenvalues, vectors=v)
def matmul(a, b):
    rows = len(a)
    cols = len(b[0])
    inner = len(b)
    m = zeros_matrix(rows, cols)
    i = 0
    while i < rows:
        j = 0
        while j < cols:
            s = 0.0
            k = 0
            while k < inner:
                s = s + a[i][k] * b[k][j]
                k = k + 1
            m[i][j] = s
            j = j + 1
        i = i + 1
    return m
def sort_eigenpairs(vals, vecs):
    n = len(vals)
    values = vals
    vectors = vecs
    i = 0
    while i < n:
        j = 0
        while j < n - 1:
            if values[j] < values[j + 1]:
                tmp = values[j]
                values[j] = values[j + 1]
                values[j + 1] = tmp
                r = 0
                while r < len(vectors):
                    tv = vectors[r][j]
                    vectors[r][j] = vectors[r][j + 1]
                    vectors[r][j + 1] = tv
                    r = r + 1
            j = j + 1
        i = i + 1
    return EigenResult(values=values, vectors=vectors)
def find_lanczos_eigenvectors(graph, k):
    validate_adjacency_list(graph)
    res = lanczos_iteration(graph, k)
    eig = jacobi_eigen(res.t, 50)
    sorted = sort_eigenpairs(eig.values, eig.vectors)
    final_vectors = matmul(res.q, sorted.vectors)
    return EigenResult(values=sorted.values, vectors=final_vectors)
def list_to_string(arr):
    s = "["
    i = 0
    while i < len(arr):
        s = s + str(arr[i])
        if i < len(arr) - 1:
            s = s + ", "
        i = i + 1
    return s + "]"
def matrix_to_string(m):
    s = "["
    i = 0
    while i < len(m):
        s = s + list_to_string(m[i])
        if i < len(m) - 1:
            s = s + "; "
        i = i + 1
    return s + "]"
graph = [[1, 2], [0, 2], [0, 1]]
result = find_lanczos_eigenvectors(graph, 2)
print(list_to_string(result.values))
print(matrix_to_string(result.vectors))
