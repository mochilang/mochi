# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 15:46 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class NodeCost:
        node: str
        cost: int
    G = {"A": {"B": 2, "C": 5}, "B": {"A": 2, "D": 3, "E": 1, "F": 1}, "C": {"A": 5, "F": 3}, "D": {"B": 3}, "E": {"B": 4, "F": 3}, "F": {"C": 3, "E": 3}}
    heap = [NodeCost(node="E", cost=0)]
    visited = {}
    result = -1
    while len(heap) > 0:
        best_idx = 0
        i = 1
        while i < len(heap):
            if heap[i].cost < heap[best_idx].cost:
                best_idx = i
            i = i + 1
        best = heap[best_idx]
        new_heap = []
        j = 0
        while j < len(heap):
            if j != best_idx:
                new_heap = _append(new_heap, heap[j])
            j = j + 1
        heap = new_heap
        u = best.node
        cost = best.cost
        if u in visited:
            continue
        visited[u] = True
        if u == "C":
            result = cost
            break
        for v in G.get(u, {}):
            if v in visited:
                continue
            next_cost = cost + G.get(u, {}).get(v, 0)
            heap = _append(heap, NodeCost(node=v, cost=next_cost))
    print(result)
    G2 = {"B": {"C": 1}, "C": {"D": 1}, "D": {"F": 1}, "E": {"B": 1, "F": 3}, "F": {}}
    heap2 = [NodeCost(node="E", cost=0)]
    visited2 = {}
    result2 = -1
    while len(heap2) > 0:
        best2_idx = 0
        i2 = 1
        while i2 < len(heap2):
            if heap2[i2].cost < heap2[best2_idx].cost:
                best2_idx = i2
            i2 = i2 + 1
        best2 = heap2[best2_idx]
        new_heap2 = []
        j2 = 0
        while j2 < len(heap2):
            if j2 != best2_idx:
                new_heap2 = _append(new_heap2, heap2[j2])
            j2 = j2 + 1
        heap2 = new_heap2
        u2 = best2.node
        cost2 = best2.cost
        if u2 in visited2:
            continue
        visited2[u2] = True
        if u2 == "F":
            result2 = cost2
            break
        for v2 in G2.get(u2, None):
            if v2 in visited2:
                continue
            next_cost2 = cost2 + G2.get(u2, None)[v2]
            heap2 = _append(heap2, NodeCost(node=v2, cost=next_cost2))
    print(result2)
    G3 = {"B": {"C": 1}, "C": {"D": 1}, "D": {"F": 1}, "E": {"B": 1, "G": 2}, "F": {}, "G": {"F": 1}}
    heap3 = [NodeCost(node="E", cost=0)]
    visited3 = {}
    result3 = -1
    while len(heap3) > 0:
        best3_idx = 0
        i3 = 1
        while i3 < len(heap3):
            if heap3[i3].cost < heap3[best3_idx].cost:
                best3_idx = i3
            i3 = i3 + 1
        best3 = heap3[best3_idx]
        new_heap3 = []
        j3 = 0
        while j3 < len(heap3):
            if j3 != best3_idx:
                new_heap3 = _append(new_heap3, heap3[j3])
            j3 = j3 + 1
        heap3 = new_heap3
        u3 = best3.node
        cost3 = best3.cost
        if u3 in visited3:
            continue
        visited3[u3] = True
        if u3 == "F":
            result3 = cost3
            break
        for v3 in G3.get(u3, None):
            if v3 in visited3:
                continue
            next_cost3 = cost3 + G3.get(u3, None)[v3]
            heap3 = _append(heap3, NodeCost(node=v3, cost=next_cost3))
    print(result3)
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

