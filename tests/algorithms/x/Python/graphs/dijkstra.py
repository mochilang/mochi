# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class NodeCost:
    node: str
    cost: int

G = {"A": {"B": 2, "C": 5}, "B": {"A": 2, "D": 3, "E": 1, "F": 1}, "C": {"A": 5, "F": 3}, "D": {"B": 3}, "E": {"B": 4, "F": 3}, "F": {"C": 3, "E": 3}}
heap = [NodeCost(node="E", cost=0)]
visited = {}
result = -1
while len(heap) > 0:
    best_idx = 0
    i = 1
    while i < len(heap):
        if heap[i].cost < heap[best_idx].cost:
            best_idx = i
        i = i + 1
    best = heap[best_idx]
    new_heap = []
    j = 0
    while j < len(heap):
        if j != best_idx:
            new_heap = _append(new_heap, heap[j])
        j = j + 1
    heap = new_heap
    u = best.node
    cost = best.cost
    if u in visited:
        continue
    visited[u] = True
    if u == "C":
        result = cost
        break
    for v in G.get(u, {}):
        if v in visited:
            continue
        next_cost = cost + G.get(u, {}).get(v, 0)
        heap = _append(heap, NodeCost(node=v, cost=next_cost))
print(result)
G2 = {"B": {"C": 1}, "C": {"D": 1}, "D": {"F": 1}, "E": {"B": 1, "F": 3}, "F": {}}
heap2 = [NodeCost(node="E", cost=0)]
visited2 = {}
result2 = -1
while len(heap2) > 0:
    best2_idx = 0
    i2 = 1
    while i2 < len(heap2):
        if heap2[i2].cost < heap2[best2_idx].cost:
            best2_idx = i2
        i2 = i2 + 1
    best2 = heap2[best2_idx]
    new_heap2 = []
    j2 = 0
    while j2 < len(heap2):
        if j2 != best2_idx:
            new_heap2 = _append(new_heap2, heap2[j2])
        j2 = j2 + 1
    heap2 = new_heap2
    u2 = best2.node
    cost2 = best2.cost
    if u2 in visited2:
        continue
    visited2[u2] = True
    if u2 == "F":
        result2 = cost2
        break
    for v2 in G2.get(u2, None):
        if v2 in visited2:
            continue
        next_cost2 = cost2 + G2.get(u2, None)[v2]
        heap2 = _append(heap2, NodeCost(node=v2, cost=next_cost2))
print(result2)
G3 = {"B": {"C": 1}, "C": {"D": 1}, "D": {"F": 1}, "E": {"B": 1, "G": 2}, "F": {}, "G": {"F": 1}}
heap3 = [NodeCost(node="E", cost=0)]
visited3 = {}
result3 = -1
while len(heap3) > 0:
    best3_idx = 0
    i3 = 1
    while i3 < len(heap3):
        if heap3[i3].cost < heap3[best3_idx].cost:
            best3_idx = i3
        i3 = i3 + 1
    best3 = heap3[best3_idx]
    new_heap3 = []
    j3 = 0
    while j3 < len(heap3):
        if j3 != best3_idx:
            new_heap3 = _append(new_heap3, heap3[j3])
        j3 = j3 + 1
    heap3 = new_heap3
    u3 = best3.node
    cost3 = best3.cost
    if u3 in visited3:
        continue
    visited3[u3] = True
    if u3 == "F":
        result3 = cost3
        break
    for v3 in G3.get(u3, None):
        if v3 in visited3:
            continue
        next_cost3 = cost3 + G3.get(u3, None)[v3]
        heap3 = _append(heap3, NodeCost(node=v3, cost=next_cost3))
print(result3)
