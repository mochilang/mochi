# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 17:09 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Edge:
    u: int
    v: int
    w: int

@dataclass
class Graph:
    num_nodes: int
    edges: [Edge]
    component: Dict[int, int]

@dataclass
class UnionResult:
    graph: Graph
    component_size: [int]

def new_graph(num_nodes):
    return Graph(num_nodes=num_nodes, edges=[], component={})
def add_edge(g, u, v, w):
    es = g.edges
    es = _append(es, Edge(u=u, v=v, w=w))
    return Graph(num_nodes=g.num_nodes, edges=es, component=g.component)
def find_component(g, node):
    if g.component[node] == node:
        return node
    return find_component(g, g.component[node])
def set_component(g, node):
    if g.component[node] != node:
        comp = g.component
        k = 0
        while k < g.num_nodes:
            comp[k] = find_component(g, k)
            k = k + 1
        g = Graph(num_nodes=g.num_nodes, edges=g.edges, component=comp)
    return g
def union(g, component_size, u, v):
    comp_size = component_size
    comp = g.component
    if comp_size[u] <= comp_size[v]:
        comp[u] = v
        comp_size[v] = comp_size[v] + comp_size[u]
        g = Graph(num_nodes=g.num_nodes, edges=g.edges, component=comp)
        g = set_component(g, u)
    else:
        comp[v] = u
        comp_size[u] = comp_size[u] + comp_size[v]
        g = Graph(num_nodes=g.num_nodes, edges=g.edges, component=comp)
        g = set_component(g, v)
    return UnionResult(graph=g, component_size=comp_size)
def create_empty_edges(n):
    res = []
    i = 0
    while i < n:
        res = _append(res, Edge(u=0 - 1, v=0 - 1, w=0 - 1))
        i = i + 1
    return res
def boruvka(g):
    component_size = []
    i = 0
    while i < g.num_nodes:
        component_size = _append(component_size, 1)
        comp = g.component
        comp[i] = i
        g = Graph(num_nodes=g.num_nodes, edges=g.edges, component=comp)
        i = i + 1
    mst_weight = 0
    num_components = g.num_nodes
    minimum_weight_edge = create_empty_edges(g.num_nodes)
    while num_components > 1:
        for e in g.edges:
            u = e.u
            v = e.v
            w = e.w
            u_comp = g.component[u]
            v_comp = g.component[v]
            if u_comp != v_comp:
                current_u = minimum_weight_edge[u_comp]
                if current_u.u == 0 - 1 or current_u.w > w:
                    minimum_weight_edge[u_comp] = Edge(u=u, v=v, w=w)
                current_v = minimum_weight_edge[v_comp]
                if current_v.u == 0 - 1 or current_v.w > w:
                    minimum_weight_edge[v_comp] = Edge(u=u, v=v, w=w)
        for e in minimum_weight_edge:
            if e.u != 0 - 1:
                u = e.u
                v = e.v
                w = e.w
                u_comp = g.component[u]
                v_comp = g.component[v]
                if u_comp != v_comp:
                    mst_weight = mst_weight + w
                    res = union(g, component_size, u_comp, v_comp)
                    g = res.graph
                    component_size = res.component_size
                    print("Added edge [" + _str(u) + " - " + _str(v) + "]")
                    print("Added weight: " + _str(w))
                    print("")
                    num_components = num_components - 1
        minimum_weight_edge = create_empty_edges(g.num_nodes)
    print("The total weight of the minimal spanning tree is: " + _str(mst_weight))
    return mst_weight
def main():
    g = new_graph(8)
    edges = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4], [3, 4, 8], [4, 5, 10], [4, 6, 6], [4, 7, 5], [5, 7, 15], [6, 7, 4]]
    for e in edges:
        g = add_edge(g, e[0], e[1], e[2])
    boruvka(g)
main()

