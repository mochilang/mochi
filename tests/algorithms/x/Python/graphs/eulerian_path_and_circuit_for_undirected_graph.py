# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class CheckResult:
    status: int
    odd_node: int

def make_matrix(n):
    matrix = []
    i = 0
    while i <= n:
        row = []
        j = 0
        while j <= n:
            row = _append(row, False)
            j = j + 1
        matrix = _append(matrix, row)
        i = i + 1
    return matrix
def dfs(u, graph, visited_edge, path):
    path = _append(path, u)
    if u in graph:
        neighbors = graph.get(u, [])
        i = 0
        while i < len(neighbors):
            v = neighbors[i]
            if visited_edge[u][v] == False:
                visited_edge[u][v] = True
                visited_edge[v][u] = True
                path = dfs(v, graph, visited_edge, path)
            i = i + 1
    return path
def check_circuit_or_path(graph, max_node):
    odd_degree_nodes = 0
    odd_node = -1
    i = 0
    while i < max_node:
        if i in graph:
            if len(graph.get(i, [])) % 2 == 1:
                odd_degree_nodes = odd_degree_nodes + 1
                odd_node = i
        i = i + 1
    if odd_degree_nodes == 0:
        return CheckResult(status=1, odd_node=odd_node)
    if odd_degree_nodes == 2:
        return CheckResult(status=2, odd_node=odd_node)
    return CheckResult(status=3, odd_node=odd_node)
def check_euler(graph, max_node):
    visited_edge = make_matrix(max_node)
    res = check_circuit_or_path(graph, max_node)
    if res.status == 3:
        print("graph is not Eulerian")
        print("no path")
        return
    start_node = 1
    if res.status == 2:
        start_node = res.odd_node
        print("graph has a Euler path")
    if res.status == 1:
        print("graph has a Euler cycle")
    path = dfs(start_node, graph, visited_edge, [])
    print(str(path))
g1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}
g2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}
g3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}
g4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}
g5 = {1: [], 2: []}
max_node = 10
check_euler(g1, max_node)
check_euler(g2, max_node)
check_euler(g3, max_node)
check_euler(g4, max_node)
check_euler(g5, max_node)
