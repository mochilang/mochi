# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

W1 = 1.0
W2 = 1.0
n = 20
n_heuristic = 3
@dataclass
class Pos:
    x: int
    y: int

@dataclass
class PQNode:
    pos: Pos
    pri: float

@dataclass
class PQPopResult:
    pq: [PQNode]
    node: PQNode

INF = 1e+09
t = 1
def pos_equal(a, b):
    return a.x == b.x and a.y == b.y
def pos_key(p):
    return str(p.x) + "," + str(p.y)
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 10:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def consistent_heuristic(p, goal):
    dx = float((p.x - goal.x))
    dy = float((p.y - goal.y))
    return sqrtApprox(dx * dx + dy * dy)
def iabs(x):
    if x < 0:
        return -x
    return x
def heuristic_1(p, goal):
    return float((iabs(p.x - goal.x) + iabs(p.y - goal.y)))
def heuristic_2(p, goal):
    h = consistent_heuristic(p, goal)
    return h // (float(t))
def heuristic(i, p, goal):
    if i == 0:
        return consistent_heuristic(p, goal)
    if i == 1:
        return heuristic_1(p, goal)
    return heuristic_2(p, goal)
def key_fn(start, i, goal, g_func):
    g = g_func.get(pos_key(start), 0.0)
    return g + W1 * heuristic(i, start, goal)
def valid(p):
    if p.x < 0 or p.x > n - 1:
        return False
    if p.y < 0 or p.y > n - 1:
        return False
    return True
blocks = [Pos(x=0, y=1), Pos(x=1, y=1), Pos(x=2, y=1), Pos(x=3, y=1), Pos(x=4, y=1), Pos(x=5, y=1), Pos(x=6, y=1), Pos(x=7, y=1), Pos(x=8, y=1), Pos(x=9, y=1), Pos(x=10, y=1), Pos(x=11, y=1), Pos(x=12, y=1), Pos(x=13, y=1), Pos(x=14, y=1), Pos(x=15, y=1), Pos(x=16, y=1), Pos(x=17, y=1), Pos(x=18, y=1), Pos(x=19, y=1)]
def in_blocks(p):
    i = 0
    while i < len(blocks):
        if pos_equal(blocks[i], p):
            return True
        i = i + 1
    return False
def pq_put(pq, node, pri):
    updated = False
    i = 0
    while i < len(pq):
        if pos_equal(pq[i].pos, node):
            if pri < pq[i].pri:
                pq[i] = PQNode(pos=node, pri=pri)
            updated = True
        i = i + 1
    if not updated:
        pq = _append(pq, PQNode(pos=node, pri=pri))
    return pq
def pq_minkey(pq):
    if len(pq) == 0:
        return INF
    first = pq[0]
    m = first.pri
    i = 1
    while i < len(pq):
        item = pq[i]
        if item.pri < m:
            m = item.pri
        i = i + 1
    return m
def pq_pop_min(pq):
    best = pq[0]
    idx = 0
    i = 1
    while i < len(pq):
        if pq[i].pri < best.pri:
            best = pq[i]
            idx = i
        i = i + 1
    new_pq = []
    i = 0
    while i < len(pq):
        if i != idx:
            new_pq = _append(new_pq, pq[i])
        i = i + 1
    return PQPopResult(pq=new_pq, node=best)
def pq_remove(pq, node):
    new_pq = []
    i = 0
    while i < len(pq):
        if not pos_equal(pq[i].pos, node):
            new_pq = _append(new_pq, pq[i])
        i = i + 1
    return new_pq
def reconstruct(back_pointer, goal, start):
    path = []
    current = goal
    key = pos_key(current)
    path = _append(path, current)
    while not (pos_equal(current, start)):
        current = back_pointer.get(key, {})
        key = pos_key(current)
        path = _append(path, current)
    rev = []
    i = len(path) - 1
    while i >= 0:
        rev = _append(rev, path[i])
        i = i - 1
    return rev
def neighbours(p):
    left = Pos(x=p.x - 1, y=p.y)
    right = Pos(x=p.x + 1, y=p.y)
    up = Pos(x=p.x, y=p.y + 1)
    down = Pos(x=p.x, y=p.y - 1)
    return [left, right, up, down]
def multi_a_star(start, goal, n_heuristic):
    global t
    g_function = {}
    back_pointer = {}
    visited = {}
    open_list = []
    g_function[pos_key(start)] = 0.0
    g_function[pos_key(goal)] = INF
    back_pointer[pos_key(start)] = Pos(x=-1, y=-1)
    back_pointer[pos_key(goal)] = Pos(x=-1, y=-1)
    visited[pos_key(start)] = True
    i = 0
    while i < n_heuristic:
        open_list = _append(open_list, [])
        pri = key_fn(start, i, goal, g_function)
        open_list[i] = pq_put(open_list[i], start, pri)
        i = i + 1
    while pq_minkey(open_list[0]) < INF:
        chosen = 0
        i = 1
        while i < n_heuristic:
            if pq_minkey(open_list[i]) <= W2 * pq_minkey(open_list[0]):
                chosen = i
                break
            i = i + 1
        if chosen != 0:
            t = t + 1
        pair = pq_pop_min(open_list[chosen])
        open_list[chosen] = pair.pq
        current = pair.node
        i = 0
        while i < n_heuristic:
            if i != chosen:
                open_list[i] = pq_remove(open_list[i], current.pos)
            i = i + 1
        ckey = pos_key(current.pos)
        if ckey in visited:
            continue
        visited[ckey] = True
        if pos_equal(current.pos, goal):
            path = reconstruct(back_pointer, goal, start)
            j = 0
            while j < len(path):
                p = path[j]
                print("(" + str(p.x) + "," + str(p.y) + ")")
                j = j + 1
            return
        neighs = neighbours(current.pos)
        k = 0
        while k < len(neighs):
            nb = neighs[k]
            if valid(nb) and (in_blocks(nb) == False):
                nkey = pos_key(nb)
                tentative = g_function.get(ckey, None) + 1.0
                if not (nkey in g_function) or tentative < g_function.get(nkey, None):
                    g_function[nkey] = tentative
                    back_pointer[nkey] = current.pos
                    i = 0
                    while i < n_heuristic:
                        pri2 = tentative + W1 * heuristic(i, nb, goal)
                        open_list[i] = pq_put(open_list[i], nb, pri2)
                        i = i + 1
            k = k + 1
    print("No path found to goal")
start = Pos(x=0, y=0)
goal = Pos(x=n - 1, y=n - 1)
multi_a_star(start, goal, n_heuristic)
