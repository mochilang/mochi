# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _concat(a, b):
    if a is None:
        return b
    if b is None:
        return a
    return a + b


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Point:
    x: int
    y: int

@dataclass
class Result:
    distance: float
    path: [Point]

def key(p):
    return str(p.x) + "," + str(p.y)
def path_to_string(path):
    s = "["
    i = 0
    while i < len(path):
        pt = path[i]
        s = s + "(" + str(pt.x) + ", " + str(pt.y) + ")"
        if i < len(path) - 1:
            s = s + ", "
        i = i + 1
    s = s + "]"
    return s
def dijkstra(grid, source, destination, allow_diagonal):
    rows = len(grid)
    cols = len(grid[0])
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    if allow_diagonal:
        dx = _concat(dx, [-1, -1, 1, 1])
        dy = _concat(dy, [-1, 1, -1, 1])
    INF = 1e+12
    queue = [source]
    front = 0
    dist_map = {key(source): 0.0}
    prev = {}
    while front < len(queue):
        current = queue[front]
        front = front + 1
        cur_key = key(current)
        if current.x == destination.x and current.y == destination.y:
            break
        i = 0
        while i < len(dx):
            nx = current.x + dx[i]
            ny = current.y + dy[i]
            if nx >= 0 and nx < rows and ny >= 0 and ny < cols:
                if grid[nx][ny] == 1:
                    n_key = str(nx) + "," + str(ny)
                    if not (n_key in dist_map):
                        dist_map[n_key] = dist_map.get(cur_key, 0.0) + 1.0
                        prev[n_key] = current
                        queue = _append(queue, Point(x=nx, y=ny))
            i = i + 1
    dest_key = key(destination)
    if dest_key in dist_map:
        path_rev = [destination]
        step_key = dest_key
        step_pt = destination
        while step_key != key(source):
            step_pt = prev.get(step_key, None)
            step_key = key(step_pt)
            path_rev = _append(path_rev, step_pt)
        path = []
        k = len(path_rev) - 1
        while k >= 0:
            path = _append(path, path_rev[k])
            k = k - 1
        return Result(distance=dist_map.get(dest_key, 0.0), path=path)
    return Result(distance=INF, path=[])
def print_result(res):
    print(str(res.distance) + ", " + path_to_string(res.path))
grid1 = [[1, 1, 1], [0, 1, 0], [0, 1, 1]]
print_result(dijkstra(grid1, Point(x=0, y=0), Point(x=2, y=2), False))
print_result(dijkstra(grid1, Point(x=0, y=0), Point(x=2, y=2), True))
grid2 = [[1, 1, 1], [0, 0, 1], [0, 1, 1]]
print_result(dijkstra(grid2, Point(x=0, y=0), Point(x=2, y=2), False))
