# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 15:46 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _concat(a, b):
    if a is None:
        return b
    if b is None:
        return a
    return a + b


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class Point:
        x: int
        y: int
    @dataclass
    class Result:
        distance: float
        path: [Point]
    def key(p):
        return _str(p.x) + "," + _str(p.y)
    def path_to_string(path):
        s = "["
        i = 0
        while i < len(path):
            pt = path[i]
            s = s + "(" + _str(pt.x) + ", " + _str(pt.y) + ")"
            if i < len(path) - 1:
                s = s + ", "
            i = i + 1
        s = s + "]"
        return s
    def dijkstra(grid, source, destination, allow_diagonal):
        rows = len(grid)
        cols = len(grid[0])
        dx = [-1, 1, 0, 0]
        dy = [0, 0, -1, 1]
        if allow_diagonal:
            dx = _concat(dx, [-1, -1, 1, 1])
            dy = _concat(dy, [-1, 1, -1, 1])
        INF = 1e+12
        queue = [source]
        front = 0
        dist_map = {key(source): 0.0}
        prev = {}
        while front < len(queue):
            current = queue[front]
            front = front + 1
            cur_key = key(current)
            if current.x == destination.x and current.y == destination.y:
                break
            i = 0
            while i < len(dx):
                nx = current.x + dx[i]
                ny = current.y + dy[i]
                if nx >= 0 and nx < rows and ny >= 0 and ny < cols:
                    if grid[nx][ny] == 1:
                        n_key = _str(nx) + "," + _str(ny)
                        if not (n_key in dist_map):
                            dist_map[n_key] = dist_map.get(cur_key, 0.0) + 1.0
                            prev[n_key] = current
                            queue = _append(queue, Point(x=nx, y=ny))
                i = i + 1
        dest_key = key(destination)
        if dest_key in dist_map:
            path_rev = [destination]
            step_key = dest_key
            step_pt = destination
            while step_key != key(source):
                step_pt = prev.get(step_key, None)
                step_key = key(step_pt)
                path_rev = _append(path_rev, step_pt)
            path = []
            k = len(path_rev) - 1
            while k >= 0:
                path = _append(path, path_rev[k])
                k = k - 1
            return Result(distance=dist_map.get(dest_key, 0.0), path=path)
        return Result(distance=INF, path=[])
    def print_result(res):
        print(_str(res.distance) + ", " + path_to_string(res.path))
    grid1 = [[1, 1, 1], [0, 1, 0], [0, 1, 1]]
    print_result(dijkstra(grid1, Point(x=0, y=0), Point(x=2, y=2), False))
    print_result(dijkstra(grid1, Point(x=0, y=0), Point(x=2, y=2), True))
    grid2 = [[1, 1, 1], [0, 0, 1], [0, 1, 1]]
    print_result(dijkstra(grid2, Point(x=0, y=0), Point(x=2, y=2), False))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

