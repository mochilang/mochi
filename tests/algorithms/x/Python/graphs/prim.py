# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-07 17:24 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

INF = 1000000000
def connect(graph, a, b, w):
    u = a - 1
    v = b - 1
    g = graph
    g[u] = _append(g.get(u, []), [v, w])
    g[v] = _append(g.get(v, []), [u, w])
    return g
def in_list(arr, x):
    i = 0
    while i < len(arr):
        if arr[i] == x:
            return True
        i = i + 1
    return False
def prim(graph, s, n):
    dist = {}
    parent = {}
    dist[s] = 0
    parent[s] = -1
    known = []
    keys = [s]
    while len(known) < n:
        mini = INF
        u = -1
        i = 0
        while i < len(keys):
            k = keys[i]
            d = dist.get(k, None)
            if not (in_list(known, k)) and d < mini:
                mini = d
                u = k
            i = i + 1
        known = _append(known, u)
        for e in graph.get(u, []):
            v = e[0]
            w = e[1]
            if not (in_list(keys, v)):
                keys = _append(keys, v)
            cur = (dist.get(v, None) if v in dist else INF)
            if not (in_list(known, v)) and w < cur:
                dist[v] = w
                parent[v] = u
    edges = []
    j = 0
    while j < len(keys):
        v = keys[j]
        if v != s:
            edges = _append(edges, [v + 1, parent.get(v, None) + 1])
        j = j + 1
    return edges
def sort_heap(h, dist):
    a = h
    i = 0
    while i < len(a):
        j = 0
        while j < len(a) - i - 1:
            dj = (dist.get(a[j], 0) if a[j] in dist else INF)
            dj1 = (dist.get(a[j + 1], 0) if a[j + 1] in dist else INF)
            if dj > dj1:
                t = a[j]
                a[j] = a[j + 1]
                a[j + 1] = t
            j = j + 1
        i = i + 1
    return a
def prim_heap(graph, s, n):
    dist = {}
    parent = {}
    dist[s] = 0
    parent[s] = -1
    h = []
    i = 0
    while i < n:
        h = _append(h, i)
        i = i + 1
    h = sort_heap(h, dist)
    known = []
    while len(h) > 0:
        u = h[0]
        h = h[1:len(h)]
        known = _append(known, u)
        for e in graph.get(u, []):
            v = e[0]
            w = e[1]
            cur = (dist.get(v, None) if v in dist else INF)
            if not (in_list(known, v)) and w < cur:
                dist[v] = w
                parent[v] = u
        h = sort_heap(h, dist)
    edges = []
    j = 0
    while j < n:
        if j != s:
            edges = _append(edges, [j + 1, parent.get(j, None) + 1])
        j = j + 1
    return edges
def print_edges(edges):
    i = 0
    while i < len(edges):
        e = edges[i]
        print("(" + str(e[0]) + ", " + str(e[1]) + ")")
        i = i + 1
def test_vector():
    x = 5
    G = {}
    i = 0
    while i < x:
        G[i] = []
        i = i + 1
    G = connect(G, 1, 2, 15)
    G = connect(G, 1, 3, 12)
    G = connect(G, 2, 4, 13)
    G = connect(G, 2, 5, 5)
    G = connect(G, 3, 2, 6)
    G = connect(G, 3, 4, 6)
    mst = prim(G, 0, x)
    print_edges(mst)
    mst_heap = prim_heap(G, 0, x)
    print_edges(mst_heap)
test_vector()
