# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class QueueNode:
    node: str
    weight: int

@dataclass
class MSTResult:
    dist: Dict[str, int]
    parent: Dict[str, str]

def prims_algo(graph):
    INF = 2147483647
    dist = {}
    parent = {}
    queue = []
    for node in graph:
        dist[node] = INF
        parent[node] = ""
        queue = _append(queue, QueueNode(node=node, weight=INF))
    if len(queue) == 0:
        return MSTResult(dist=dist, parent=parent)
    min_idx = 0
    i = 1
    while i < len(queue):
        if queue[i].weight < queue[min_idx].weight:
            min_idx = i
        i = i + 1
    start_node = queue[min_idx]
    start = start_node.node
    new_q = []
    j = 0
    while j < len(queue):
        if j != min_idx:
            new_q = _append(new_q, queue[j])
        j = j + 1
    queue = new_q
    dist[start] = 0
    for neighbour in graph.get(start, {}):
        w = graph.get(start, {}).get(neighbour, 0)
        if dist.get(neighbour, None) > dist.get(start, None) + w:
            dist[neighbour] = dist.get(start, None) + w
            parent[neighbour] = start
            k = 0
            while k < len(queue):
                if queue[k].node == neighbour:
                    queue[k].weight = dist.get(neighbour, None)
                    break
                k = k + 1
    while len(queue) > 0:
        best_idx = 0
        p = 1
        while p < len(queue):
            if queue[p].weight < queue[best_idx].weight:
                best_idx = p
            p = p + 1
        node_entry = queue[best_idx]
        node = node_entry.node
        tmp = []
        q = 0
        while q < len(queue):
            if q != best_idx:
                tmp = _append(tmp, queue[q])
            q = q + 1
        queue = tmp
        for neighbour in graph.get(node, {}):
            w = graph.get(node, {}).get(neighbour, 0)
            if dist.get(neighbour, None) > dist.get(node, None) + w:
                dist[neighbour] = dist.get(node, None) + w
                parent[neighbour] = node
                r = 0
                while r < len(queue):
                    if queue[r].node == neighbour:
                        queue[r].weight = dist.get(neighbour, None)
                        break
                    r = r + 1
    return MSTResult(dist=dist, parent=parent)
def iabs(x):
    if x < 0:
        return -x
    return x
graph = {}
graph["a"] = {"b": 3, "c": 15}
graph["b"] = {"a": 3, "c": 10, "d": 100}
graph["c"] = {"a": 15, "b": 10, "d": 5}
graph["d"] = {"b": 100, "c": 5}
res = prims_algo(graph)
dist = res.dist
print(str(iabs(dist.get("a", 0) - dist.get("b", 0))))
print(str(iabs(dist.get("d", 0) - dist.get("b", 0))))
print(str(iabs(dist.get("a", 0) - dist.get("c", 0))))
