# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def contains(xs, x):
    i = 0
    while i < len(xs):
        if xs[i] == x:
            return True
        i = i + 1
    return False
def contains_key(m, key):
    for k in m:
        if k == key:
            return True
    return False
def bfs_shortest_path(graph, start, goal):
    explored = []
    queue = [[start]]
    if start == goal:
        return [start]
    while len(queue) > 0:
        path = queue[0]
        queue = queue[1:len(queue)]
        node = path[len(path) - 1]
        if not node in explored:
            neighbours = graph[node]
            i = 0
            while i < len(neighbours):
                neighbour = neighbours[i]
                new_path = path
                new_path = _append(new_path, neighbour)
                queue = _append(queue, new_path)
                if neighbour == goal:
                    return new_path
                i = i + 1
            explored = _append(explored, node)
    return []
def bfs_shortest_path_distance(graph, start, target):
    if (contains_key(graph, start) == False) or (contains_key(graph, target) == False):
        return -1
    if start == target:
        return 0
    queue = [start]
    visited = [start]
    dist = {}
    dist[start] = 0
    dist[target] = (-1)
    while len(queue) > 0:
        node = queue[0]
        queue = queue[1:len(queue)]
        if node == target:
            if dist[target] == (-1) or dist[node] < dist[target]:
                dist[target] = dist[node]
        adj = graph[node]
        i = 0
        while i < len(adj):
            next = adj[i]
            if not next in visited:
                visited = _append(visited, next)
                queue = _append(queue, next)
                dist[next] = dist[node] + 1
            i = i + 1
    return dist[target]
demo_graph = {"A": ["B", "C", "E"], "B": ["A", "D", "E"], "C": ["A", "F", "G"], "D": ["B"], "E": ["A", "B", "D"], "F": ["C"], "G": ["C"]}
# test path found
assert bfs_shortest_path(demo_graph, "G", "D") == ["G", "C", "A", "B", "D"]
# test path to self
assert bfs_shortest_path(demo_graph, "G", "G") == ["G"]
# test path not found
assert len(bfs_shortest_path(demo_graph, "G", "Unknown")) == 0
# test distance found
assert bfs_shortest_path_distance(demo_graph, "G", "D") == 4
# test distance to self
assert bfs_shortest_path_distance(demo_graph, "A", "A") == 0
# test distance not found
assert bfs_shortest_path_distance(demo_graph, "A", "Unknown") == (-1)
