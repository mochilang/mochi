# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 15:46 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def contains(xs, x):
    i = 0
    while i < len(xs):
        if xs[i] == x:
            return True
        i = i + 1
    return False
def contains_key(m, key):
    for k in m:
        if k == key:
            return True
    return False
def bfs_shortest_path(graph, start, goal):
    explored = []
    queue = [[start]]
    if start == goal:
        return [start]
    while len(queue) > 0:
        path = queue[0]
        queue = queue[1:]
        node = path[len(path) - 1]
        if not contains(explored, node):
            neighbours = graph.get(node, [])
            i = 0
            while i < len(neighbours):
                neighbour = neighbours[i]
                new_path = path
                new_path = _append(new_path, neighbour)
                queue = _append(queue, new_path)
                if neighbour == goal:
                    return new_path
                i = i + 1
            explored = _append(explored, node)
    return []
def bfs_shortest_path_distance(graph, start, target):
    if (contains_key(graph, start) == False) or (contains_key(graph, target) == False):
        return -1
    if start == target:
        return 0
    queue = [start]
    visited = [start]
    dist = {}
    dist[start] = 0
    dist[target] = (-1)
    while len(queue) > 0:
        node = queue[0]
        queue = queue[1:]
        if node == target:
            if dist.get(target, None) == (-1) or dist.get(node, None) < dist.get(target, None):
                dist[target] = dist.get(node, None)
        adj = graph.get(node, [])
        i = 0
        while i < len(adj):
            next = adj[i]
            if not contains(visited, next):
                visited = _append(visited, next)
                queue = _append(queue, next)
                dist[next] = dist.get(node, None) + 1
            i = i + 1
    return dist.get(target, None)
demo_graph = {"A": ["B", "C", "E"], "B": ["A", "D", "E"], "C": ["A", "F", "G"], "D": ["B"], "E": ["A", "B", "D"], "F": ["C"], "G": ["C"]}
# test path found
assert bfs_shortest_path(demo_graph, "G", "D") == ["G", "C", "A", "B", "D"]
# test path to self
assert bfs_shortest_path(demo_graph, "G", "G") == ["G"]
# test path not found
assert len(bfs_shortest_path(demo_graph, "G", "Unknown")) == 0
# test distance found
assert bfs_shortest_path_distance(demo_graph, "G", "D") == 4
# test distance to self
assert bfs_shortest_path_distance(demo_graph, "A", "A") == 0
# test distance not found
assert bfs_shortest_path_distance(demo_graph, "A", "Unknown") == (-1)

