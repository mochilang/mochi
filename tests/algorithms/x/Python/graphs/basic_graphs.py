# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 10:00 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    lst.append(v)
    return lst


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def dfs(g, s):
        visited = {}
        stack = []
        visited[s] = True
        stack = _append(stack, s)
        print(s)
        while len(stack) > 0:
            u = stack[len(stack) - 1]
            found = False
            for v in g.get(u, []):
                if not (v in visited):
                    visited[v] = True
                    stack = _append(stack, v)
                    print(v)
                    found = True
                    break
            if not found:
                stack = stack[0:len(stack) - 1]
    def bfs(g, s):
        visited = {}
        q = []
        visited[s] = True
        q = _append(q, s)
        print(s)
        while len(q) > 0:
            u = q[0]
            q = q[1:len(q)]
            for v in g.get(u, []):
                if not (v in visited):
                    visited[v] = True
                    q = _append(q, v)
                    print(v)
    def sort_ints(a):
        arr = a
        i = 0
        while i < len(arr):
            j = 0
            while j < len(arr) - i - 1:
                if arr[j] > arr[j + 1]:
                    tmp = arr[j]
                    arr[j] = arr[j + 1]
                    arr[j + 1] = tmp
                j = j + 1
            i = i + 1
        return arr
    def dijkstra(g, s):
        dist = {}
        dist[s] = 0
        path = {}
        path[s] = 0
        known = []
        keys = [s]
        while len(known) < len(keys):
            mini = 100000
            u = -1
            i = 0
            while i < len(keys):
                k = keys[i]
                d = dist.get(k, None)
                if not (k in known) and d < mini:
                    mini = d
                    u = k
                i = i + 1
            known = _append(known, u)
            for e in g.get(u, []):
                v = e[0]
                w = e[1]
                if not (v in keys):
                    keys = _append(keys, v)
                alt = dist.get(u, None) + w
                cur = (dist.get(v, None) if v in dist else 100000)
                if not (v in known) and alt < cur:
                    dist[v] = alt
                    path[v] = u
        ordered = sort_ints(keys)
        idx = 0
        while idx < len(ordered):
            k = ordered[idx]
            if k != s:
                print(dist.get(k, None))
            idx = idx + 1
    def topo(g, n):
        ind = []
        i = 0
        while i <= n:
            ind = _append(ind, 0)
            i = i + 1
        node = 1
        while node <= n:
            for v in g.get(node, []):
                ind[v] = ind[v] + 1
            node = node + 1
        q = []
        j = 1
        while j <= n:
            if ind[j] == 0:
                q = _append(q, j)
            j = j + 1
        while len(q) > 0:
            v = q[0]
            q = q[1:len(q)]
            print(v)
            for w in g.get(v, []):
                ind[w] = ind[w] - 1
                if ind[w] == 0:
                    q = _append(q, w)
    def floyd(a):
        n = len(a)
        dist = []
        i = 0
        while i < n:
            row = []
            j = 0
            while j < n:
                row = _append(row, a[i][j])
                j = j + 1
            dist = _append(dist, row)
            i = i + 1
        k = 0
        while k < n:
            ii = 0
            while ii < n:
                jj = 0
                while jj < n:
                    if dist[ii][jj] > dist[ii][k] + dist[k][jj]:
                        dist[ii][jj] = dist[ii][k] + dist[k][jj]
                    jj = jj + 1
                ii = ii + 1
            k = k + 1
        print(dist)
    def prim(g, s, n):
        dist = {}
        dist[s] = 0
        known = []
        keys = [s]
        total = 0
        while len(known) < n:
            mini = 100000
            u = -1
            i = 0
            while i < len(keys):
                k = keys[i]
                d = dist.get(k, None)
                if not (k in known) and d < mini:
                    mini = d
                    u = k
                i = i + 1
            known = _append(known, u)
            total = total + mini
            for e in g.get(u, []):
                v = e[0]
                w = e[1]
                if not (v in keys):
                    keys = _append(keys, v)
                cur = (dist.get(v, None) if v in dist else 100000)
                if not (v in known) and w < cur:
                    dist[v] = w
        return total
    def sort_edges(edges):
        es = edges
        i = 0
        while i < len(es):
            j = 0
            while j < len(es) - i - 1:
                if es[j][2] > es[j + 1][2]:
                    tmp = es[j]
                    es[j] = es[j + 1]
                    es[j + 1] = tmp
                j = j + 1
            i = i + 1
        return es
    def find_parent(parent, x):
        r = x
        while parent[r] != r:
            r = parent[r]
        return r
    def union_parent(parent, a, b):
        parent[a] = b
    def kruskal(edges, n):
        es = sort_edges(edges)
        parent = []
        i = 0
        while i <= n:
            parent = _append(parent, i)
            i = i + 1
        total = 0
        count = 0
        idx = 0
        while count < n - 1 and idx < len(es):
            e = es[idx]
            idx = idx + 1
            u = e[0]
            v = e[1]
            w = e[2]
            ru = find_parent(parent, u)
            rv = find_parent(parent, v)
            if ru != rv:
                union_parent(parent, ru, rv)
                total = total + w
                count = count + 1
        return total
    def find_isolated_nodes(g, nodes):
        isolated = []
        for node in nodes:
            if len(g.get(node, [])) == 0:
                isolated = _append(isolated, node)
        return isolated
    g_dfs = {1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []}
    g_bfs = {1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []}
    g_weighted = {1: [[2, 7], [3, 9], [6, 14]], 2: [[1, 7], [3, 10], [4, 15]], 3: [[1, 9], [2, 10], [4, 11], [6, 2]], 4: [[2, 15], [3, 11], [5, 6]], 5: [[4, 6], [6, 9]], 6: [[1, 14], [3, 2], [5, 9]]}
    g_topo = {1: [2, 3], 2: [4], 3: [4], 4: []}
    matrix = [[0, 5, 9, 100000], [100000, 0, 2, 8], [100000, 100000, 0, 7], [4, 100000, 100000, 0]]
    g_prim = {1: [[2, 1], [3, 3]], 2: [[1, 1], [3, 1], [4, 6]], 3: [[1, 3], [2, 1], [4, 2]], 4: [[2, 6], [3, 2]]}
    edges_kruskal = [[1, 2, 1], [2, 3, 2], [1, 3, 2], [3, 4, 1]]
    g_iso = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}
    dfs(g_dfs, 1)
    bfs(g_bfs, 1)
    dijkstra(g_weighted, 1)
    topo(g_topo, 4)
    floyd(matrix)
    print(prim(g_prim, 1, 4))
    print(kruskal(edges_kruskal, 4))
    iso = find_isolated_nodes(g_iso, [1, 2, 3, 4])
    print(iso)
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

