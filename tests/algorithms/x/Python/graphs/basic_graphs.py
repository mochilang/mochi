# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def dfs(g, s):
    visited = {}
    stack = []
    visited[s] = True
    stack = _append(stack, s)
    print(s)
    while len(stack) > 0:
        u = stack[len(stack) - 1]
        found = False
        for v in g[u]:
            if not (v in visited):
                visited[v] = True
                stack = _append(stack, v)
                print(v)
                found = True
                break
        if not found:
            stack = stack[0:len(stack) - 1]
def bfs(g, s):
    visited = {}
    q = []
    visited[s] = True
    q = _append(q, s)
    print(s)
    while len(q) > 0:
        u = q[0]
        q = q[1:len(q)]
        for v in g[u]:
            if not (v in visited):
                visited[v] = True
                q = _append(q, v)
                print(v)
def sort_ints(a):
    arr = a
    i = 0
    while i < len(arr):
        j = 0
        while j < len(arr) - i - 1:
            if arr[j] > arr[j + 1]:
                tmp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = tmp
            j = j + 1
        i = i + 1
    return arr
def dijkstra(g, s):
    dist = {}
    dist[s] = 0
    path = {}
    path[s] = 0
    known = []
    keys = [s]
    while len(known) < len(keys):
        mini = 100000
        u = -1
        i = 0
        while i < len(keys):
            k = keys[i]
            d = dist[k]
            if not (k in known) and d < mini:
                mini = d
                u = k
            i = i + 1
        known = _append(known, u)
        for e in g[u]:
            v = e[0]
            w = e[1]
            if not (v in keys):
                keys = _append(keys, v)
            alt = dist[u] + w
            cur = (dist[v] if v in dist else 100000)
            if not (v in known) and alt < cur:
                dist[v] = alt
                path[v] = u
    ordered = sort_ints(keys)
    idx = 0
    while idx < len(ordered):
        k = ordered[idx]
        if k != s:
            print(dist[k])
        idx = idx + 1
def topo(g, n):
    ind = []
    i = 0
    while i <= n:
        ind = _append(ind, 0)
        i = i + 1
    node = 1
    while node <= n:
        for v in g[node]:
            ind[v] = ind[v] + 1
        node = node + 1
    q = []
    j = 1
    while j <= n:
        if ind[j] == 0:
            q = _append(q, j)
        j = j + 1
    while len(q) > 0:
        v = q[0]
        q = q[1:len(q)]
        print(v)
        for w in g[v]:
            ind[w] = ind[w] - 1
            if ind[w] == 0:
                q = _append(q, w)
def floyd(a):
    n = len(a)
    dist = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row = _append(row, a[i][j])
            j = j + 1
        dist = _append(dist, row)
        i = i + 1
    k = 0
    while k < n:
        ii = 0
        while ii < n:
            jj = 0
            while jj < n:
                if dist[ii][jj] > dist[ii][k] + dist[k][jj]:
                    dist[ii][jj] = dist[ii][k] + dist[k][jj]
                jj = jj + 1
            ii = ii + 1
        k = k + 1
    print(dist)
def prim(g, s, n):
    dist = {}
    dist[s] = 0
    known = []
    keys = [s]
    total = 0
    while len(known) < n:
        mini = 100000
        u = -1
        i = 0
        while i < len(keys):
            k = keys[i]
            d = dist[k]
            if not (k in known) and d < mini:
                mini = d
                u = k
            i = i + 1
        known = _append(known, u)
        total = total + mini
        for e in g[u]:
            v = e[0]
            w = e[1]
            if not (v in keys):
                keys = _append(keys, v)
            cur = (dist[v] if v in dist else 100000)
            if not (v in known) and w < cur:
                dist[v] = w
    return total
def sort_edges(edges):
    es = edges
    i = 0
    while i < len(es):
        j = 0
        while j < len(es) - i - 1:
            if es[j][2] > es[j + 1][2]:
                tmp = es[j]
                es[j] = es[j + 1]
                es[j + 1] = tmp
            j = j + 1
        i = i + 1
    return es
def find_parent(parent, x):
    r = x
    while parent[r] != r:
        r = parent[r]
    return r
def union_parent(parent, a, b):
    parent[a] = b
def kruskal(edges, n):
    es = sort_edges(edges)
    parent = []
    i = 0
    while i <= n:
        parent = _append(parent, i)
        i = i + 1
    total = 0
    count = 0
    idx = 0
    while count < n - 1 and idx < len(es):
        e = es[idx]
        idx = idx + 1
        u = e[0]
        v = e[1]
        w = e[2]
        ru = find_parent(parent, u)
        rv = find_parent(parent, v)
        if ru != rv:
            union_parent(parent, ru, rv)
            total = total + w
            count = count + 1
    return total
def find_isolated_nodes(g, nodes):
    isolated = []
    for node in nodes:
        if len(g[node]) == 0:
            isolated = _append(isolated, node)
    return isolated
g_dfs = {1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []}
g_bfs = {1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []}
g_weighted = {1: [[2, 7], [3, 9], [6, 14]], 2: [[1, 7], [3, 10], [4, 15]], 3: [[1, 9], [2, 10], [4, 11], [6, 2]], 4: [[2, 15], [3, 11], [5, 6]], 5: [[4, 6], [6, 9]], 6: [[1, 14], [3, 2], [5, 9]]}
g_topo = {1: [2, 3], 2: [4], 3: [4], 4: []}
matrix = [[0, 5, 9, 100000], [100000, 0, 2, 8], [100000, 100000, 0, 7], [4, 100000, 100000, 0]]
g_prim = {1: [[2, 1], [3, 3]], 2: [[1, 1], [3, 1], [4, 6]], 3: [[1, 3], [2, 1], [4, 2]], 4: [[2, 6], [3, 2]]}
edges_kruskal = [[1, 2, 1], [2, 3, 2], [1, 3, 2], [3, 4, 1]]
g_iso = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}
dfs(g_dfs, 1)
bfs(g_bfs, 1)
dijkstra(g_weighted, 1)
topo(g_topo, 4)
floyd(matrix)
print(prim(g_prim, 1, 4))
print(kruskal(edges_kruskal, 4))
iso = find_isolated_nodes(g_iso, [1, 2, 3, 4])
print(iso)
