# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 15:46 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    seed = 1
    def rand_int(n):
        global seed
        seed = (seed * 1103515245 + 12345) % 2147483648
        return seed % n
    def contains(list, value):
        i = 0
        while i < len(list):
            if list[i] == value:
                return True
            i = i + 1
        return False
    def remove_all(list, value):
        res = []
        i = 0
        while i < len(list):
            if list[i] != value:
                res = _append(res, list[i])
            i = i + 1
        return res
    @dataclass
    class Pair:
        a: str
        b: str
    def partition_graph(graph):
        contracted = {}
        for node in list(graph.keys()):
            contracted[node] = [node]
        graph_copy = {}
        for node in list(graph.keys()):
            lst = []
            neigh = graph.get(node, [])
            i = 0
            while i < len(neigh):
                lst = _append(lst, neigh[i])
                i = i + 1
            graph_copy[node] = lst
        nodes = list(graph_copy.keys())
        while len(nodes) > 2:
            u = nodes[rand_int(len(nodes))]
            u_neighbors = graph_copy.get(u, None)
            v = u_neighbors[rand_int(len(u_neighbors))]
            uv = u + v
            uv_neighbors = []
            i = 0
            while i < len(graph_copy.get(u, None)):
                n = graph_copy.get(u, None)[i]
                if n != u and n != v and contains(uv_neighbors, n) == False:
                    uv_neighbors = _append(uv_neighbors, n)
                i = i + 1
            i = 0
            while i < len(graph_copy.get(v, None)):
                n = graph_copy.get(v, None)[i]
                if n != u and n != v and contains(uv_neighbors, n) == False:
                    uv_neighbors = _append(uv_neighbors, n)
                i = i + 1
            graph_copy[uv] = uv_neighbors
            k = 0
            while k < len(uv_neighbors):
                nb = uv_neighbors[k]
                graph_copy[nb] = _append(graph_copy.get(nb, None), uv)
                graph_copy[nb] = remove_all(graph_copy.get(nb, None), u)
                graph_copy[nb] = remove_all(graph_copy.get(nb, None), v)
                k = k + 1
            group = []
            i = 0
            while i < len(contracted.get(u, None)):
                group = _append(group, contracted.get(u, None)[i])
                i = i + 1
            i = 0
            while i < len(contracted.get(v, None)):
                val = contracted.get(v, None)[i]
                if contains(group, val) == False:
                    group = _append(group, val)
                i = i + 1
            contracted[uv] = group
            nodes = remove_all(nodes, u)
            nodes = remove_all(nodes, v)
            nodes = _append(nodes, uv)
        groups = []
        j = 0
        while j < len(nodes):
            n = nodes[j]
            groups = _append(groups, contracted.get(n, None))
            j = j + 1
        groupA = groups[0]
        groupB = groups[1]
        cut = []
        j = 0
        while j < len(groupA):
            node = groupA[j]
            neigh = graph.get(node, [])
            l = 0
            while l < len(neigh):
                nb = neigh[l]
                if contains(groupB, nb):
                    cut = _append(cut, Pair(a=node, b=nb))
                l = l + 1
            j = j + 1
        return cut
    def cut_to_string(cut):
        s = "{"
        i = 0
        while i < len(cut):
            p = cut[i]
            s = s + "(" + p.a + ", " + p.b + ")"
            if i < len(cut) - 1:
                s = s + ", "
            i = i + 1
        s = s + "}"
        return s
    TEST_GRAPH = {"1": ["2", "3", "4", "5"], "2": ["1", "3", "4", "5"], "3": ["1", "2", "4", "5", "10"], "4": ["1", "2", "3", "5", "6"], "5": ["1", "2", "3", "4", "7"], "6": ["7", "8", "9", "10", "4"], "7": ["6", "8", "9", "10", "5"], "8": ["6", "7", "9", "10"], "9": ["6", "7", "8", "10"], "10": ["6", "7", "8", "9", "3"]}
    result = partition_graph(TEST_GRAPH)
    print(cut_to_string(result))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

