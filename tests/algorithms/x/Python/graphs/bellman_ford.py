# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Edge:
    src: int
    dst: int
    weight: int

INF = 1e+09
def list_to_string(arr):
    s = "["
    i = 0
    while i < len(arr):
        s = s + str(arr[i])
        if i < len(arr) - 1:
            s = s + ", "
        i = i + 1
    return s + "]"
def check_negative_cycle(graph, distance, edge_count):
    j = 0
    while j < edge_count:
        e = graph[j]
        u = e.src
        v = e.dst
        w = float(e.weight)
        if distance[u] < INF and distance[u] + w < distance[v]:
            return True
        j = j + 1
    return False
def bellman_ford(graph, vertex_count, edge_count, src):
    distance = []
    i = 0
    while i < vertex_count:
        distance = _append(distance, INF)
        i = i + 1
    distance[src] = 0.0
    k = 0
    while k < vertex_count - 1:
        j = 0
        while j < edge_count:
            e = graph[j]
            u = e.src
            v = e.dst
            w = float(e.weight)
            if distance[u] < INF and distance[u] + w < distance[v]:
                distance[v] = distance[u] + w
            j = j + 1
        k = k + 1
    if check_negative_cycle(graph, distance, edge_count):
        panic("Negative cycle found")
    return distance
edges = [Edge(src=2, dst=1, weight=-10), Edge(src=3, dst=2, weight=3), Edge(src=0, dst=3, weight=5), Edge(src=0, dst=1, weight=4)]
distances = bellman_ford(edges, 4, len(edges), 0)
print(list_to_string(distances))
