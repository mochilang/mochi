# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]

HEURISTIC = 0
grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]
delta = [[-1, 0], [0, -1], [1, 0], [0, 1]]
@dataclass
class Pos:
    y: int
    x: int

@dataclass
class Node:
    pos: Pos
    g_cost: int
    h_cost: float
    f_cost: float
    path: [Pos]

def abs(x):
    if x < 0:
        return -x
    return x
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 10:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def heuristic(a, b):
    dy = a.y - b.y
    dx = a.x - b.x
    if HEURISTIC == 1:
        return float((abs(dy) + abs(dx)))
    dyf = (float(dy))
    dxf = (float(dx))
    return sqrtApprox(dyf * dyf + dxf * dxf)
def pos_equal(a, b):
    return a.y == b.y and a.x == b.x
def contains_pos(lst, p):
    i = 0
    while i < len(lst):
        if pos_equal(lst[i], p):
            return True
        i = i + 1
    return False
def open_index_of_pos(open, p):
    i = 0
    while i < len(open):
        if pos_equal(open[i].pos, p):
            return i
        i = i + 1
    return 0 - 1
def remove_node_at(nodes, idx):
    res = []
    i = 0
    while i < len(nodes):
        if i != idx:
            res = _append(res, nodes[i])
        i = i + 1
    return res
def append_pos_list(path, p):
    res = []
    i = 0
    while i < len(path):
        res = _append(res, path[i])
        i = i + 1
    res = _append(res, p)
    return res
def reverse_pos_list(lst):
    res = []
    i = len(lst) - 1
    while i >= 0:
        res = _append(res, lst[i])
        i = i - 1
    return res
def concat_pos_lists(a, b):
    res = []
    i = 0
    while i < len(a):
        res = _append(res, a[i])
        i = i + 1
    j = 0
    while j < len(b):
        res = _append(res, b[j])
        j = j + 1
    return res
def get_successors(p):
    res = []
    i = 0
    while i < len(delta):
        nx = p.x + delta[i][1]
        ny = p.y + delta[i][0]
        if nx >= 0 and ny >= 0 and nx < len(grid[0]) and ny < len(grid):
            if grid[ny][nx] == 0:
                res = _append(res, Pos(y=ny, x=nx))
        i = i + 1
    return res
def find_lowest_f(open):
    best = 0
    i = 1
    while i < len(open):
        if open[i].f_cost < open[best].f_cost:
            best = i
        i = i + 1
    return best
def astar(start, goal):
    h0 = heuristic(start, goal)
    open = [Node(pos=start, g_cost=0, h_cost=h0, f_cost=h0, path=[start])]
    closed = []
    while len(open) > 0:
        idx = find_lowest_f(open)
        current = open[idx]
        open = remove_node_at(open, idx)
        if pos_equal(current.pos, goal):
            return current.path
        closed = _append(closed, current.pos)
        succ = get_successors(current.pos)
        i = 0
        while i < len(succ):
            pos = succ[i]
            if contains_pos(closed, pos):
                i = i + 1
                continue
            tentative_g = current.g_cost + 1
            idx_open = open_index_of_pos(open, pos)
            if idx_open == 0 - 1 or tentative_g < open[idx_open].g_cost:
                new_path = append_pos_list(current.path, pos)
                h = heuristic(pos, goal)
                f = (float(tentative_g)) + h
                if idx_open != 0 - 1:
                    open = remove_node_at(open, idx_open)
                open = _append(open, Node(pos=pos, g_cost=tentative_g, h_cost=h, f_cost=f, path=new_path))
            i = i + 1
    return [start]
def combine_paths(fwd, bwd):
    bwd_copy = []
    i = 0
    while i < len(bwd.path) - 1:
        bwd_copy = _append(bwd_copy, bwd.path[i])
        i = i + 1
    bwd_copy = reverse_pos_list(bwd_copy)
    return concat_pos_lists(fwd.path, bwd_copy)
def bidirectional_astar(start, goal):
    hf = heuristic(start, goal)
    hb = heuristic(goal, start)
    open_f = [Node(pos=start, g_cost=0, h_cost=hf, f_cost=hf, path=[start])]
    open_b = [Node(pos=goal, g_cost=0, h_cost=hb, f_cost=hb, path=[goal])]
    closed_f = []
    closed_b = []
    while len(open_f) > 0 and len(open_b) > 0:
        idx_f = find_lowest_f(open_f)
        current_f = open_f[idx_f]
        open_f = remove_node_at(open_f, idx_f)
        idx_b = find_lowest_f(open_b)
        current_b = open_b[idx_b]
        open_b = remove_node_at(open_b, idx_b)
        if pos_equal(current_f.pos, current_b.pos):
            return combine_paths(current_f, current_b)
        closed_f = _append(closed_f, current_f.pos)
        closed_b = _append(closed_b, current_b.pos)
        succ_f = get_successors(current_f.pos)
        i = 0
        while i < len(succ_f):
            pos = succ_f[i]
            if contains_pos(closed_f, pos):
                i = i + 1
                continue
            tentative_g = current_f.g_cost + 1
            h = heuristic(pos, current_b.pos)
            f = (float(tentative_g)) + h
            idx_open = open_index_of_pos(open_f, pos)
            if idx_open == 0 - 1 or tentative_g < open_f[idx_open].g_cost:
                new_path = append_pos_list(current_f.path, pos)
                if idx_open != 0 - 1:
                    open_f = remove_node_at(open_f, idx_open)
                open_f = _append(open_f, Node(pos=pos, g_cost=tentative_g, h_cost=h, f_cost=f, path=new_path))
            i = i + 1
        succ_b = get_successors(current_b.pos)
        i = 0
        while i < len(succ_b):
            pos = succ_b[i]
            if contains_pos(closed_b, pos):
                i = i + 1
                continue
            tentative_g = current_b.g_cost + 1
            h = heuristic(pos, current_f.pos)
            f = (float(tentative_g)) + h
            idx_open = open_index_of_pos(open_b, pos)
            if idx_open == 0 - 1 or tentative_g < open_b[idx_open].g_cost:
                new_path = append_pos_list(current_b.path, pos)
                if idx_open != 0 - 1:
                    open_b = remove_node_at(open_b, idx_open)
                open_b = _append(open_b, Node(pos=pos, g_cost=tentative_g, h_cost=h, f_cost=f, path=new_path))
            i = i + 1
    return [start]
def path_to_string(path):
    if len(path) == 0:
        return "[]"
    s = "[(" + str(path[0].y) + ", " + str(path[0].x) + ")"
    i = 1
    while i < len(path):
        s = s + ", (" + str(path[i].y) + ", " + str(path[i].x) + ")"
        i = i + 1
    s = s + "]"
    return s
start = Pos(y=0, x=0)
goal = Pos(y=len(grid) - 1, x=len(grid[0]) - 1)
path1 = astar(start, goal)
print(path_to_string(path1))
path2 = bidirectional_astar(start, goal)
print(path_to_string(path2))
