# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 15:46 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def push_relabel_max_flow(graph, sources, sinks):
        if len(sources) == 0 or len(sinks) == 0:
            return 0
        g = graph
        source_index = sources[0]
        sink_index = sinks[0]
        if len(sources) > 1 or len(sinks) > 1:
            max_input_flow = 0
            i = 0
            while i < len(sources):
                j = 0
                while j < len(g[sources[i]]):
                    max_input_flow = max_input_flow + g[sources[i]][j]
                    j = j + 1
                i = i + 1
            size = len(g) + 1
            new_graph = []
            zero_row = []
            j = 0
            while j < size:
                zero_row = _append(zero_row, 0)
                j = j + 1
            new_graph = _append(new_graph, zero_row)
            r = 0
            while r < len(g):
                row = [0]
                c = 0
                while c < len(g[r]):
                    row = _append(row, g[r][c])
                    c = c + 1
                new_graph = _append(new_graph, row)
                r = r + 1
            g = new_graph
            i = 0
            while i < len(sources):
                g[0][sources[i] + 1] = max_input_flow
                i = i + 1
            source_index = 0
            size = len(g) + 1
            new_graph = []
            r = 0
            while r < len(g):
                row2 = g[r]
                row2 = _append(row2, 0)
                new_graph = _append(new_graph, row2)
                r = r + 1
            last_row = []
            j = 0
            while j < size:
                last_row = _append(last_row, 0)
                j = j + 1
            new_graph = _append(new_graph, last_row)
            g = new_graph
            i = 0
            while i < len(sinks):
                g[sinks[i] + 1][size - 1] = max_input_flow
                i = i + 1
            sink_index = size - 1
        n = len(g)
        preflow = []
        i = 0
        while i < n:
            row = []
            j = 0
            while j < n:
                row = _append(row, 0)
                j = j + 1
            preflow = _append(preflow, row)
            i = i + 1
        heights = []
        i = 0
        while i < n:
            heights = _append(heights, 0)
            i = i + 1
        excesses = []
        i = 0
        while i < n:
            excesses = _append(excesses, 0)
            i = i + 1
        heights[source_index] = n
        i = 0
        while i < n:
            bandwidth = g[source_index][i]
            preflow[source_index][i] = preflow[source_index][i] + bandwidth
            preflow[i][source_index] = preflow[i][source_index] - bandwidth
            excesses[i] = excesses[i] + bandwidth
            i = i + 1
        vertices_list = []
        i = 0
        while i < n:
            if i != source_index and i != sink_index:
                vertices_list = _append(vertices_list, i)
            i = i + 1
        idx = 0
        while idx < len(vertices_list):
            v = vertices_list[idx]
            prev_height = heights[v]
            while excesses[v] > 0:
                nb = 0
                while nb < n:
                    if g[v][nb] - preflow[v][nb] > 0 and heights[v] > heights[nb]:
                        delta = excesses[v]
                        capacity = g[v][nb] - preflow[v][nb]
                        if delta > capacity:
                            delta = capacity
                        preflow[v][nb] = preflow[v][nb] + delta
                        preflow[nb][v] = preflow[nb][v] - delta
                        excesses[v] = excesses[v] - delta
                        excesses[nb] = excesses[nb] + delta
                    nb = nb + 1
                min_height = -1
                nb = 0
                while nb < n:
                    if g[v][nb] - preflow[v][nb] > 0:
                        if min_height == (-1) or heights[nb] < min_height:
                            min_height = heights[nb]
                    nb = nb + 1
                if min_height != (-1):
                    heights[v] = min_height + 1
                else:
                    break
            if heights[v] > prev_height:
                vertex = vertices_list[idx]
                j = idx
                while j > 0:
                    vertices_list[j] = vertices_list[j - 1]
                    j = j - 1
                vertices_list[0] = vertex
                idx = 0
            else:
                idx = idx + 1
        flow = 0
        i = 0
        while i < n:
            flow = flow + preflow[source_index][i]
            i = i + 1
        if flow < 0:
            flow = -flow
        return flow
    graph = [[0, 7, 0, 0], [0, 0, 6, 0], [0, 0, 0, 8], [9, 0, 0, 0]]
    sources = [0]
    sinks = [3]
    result = push_relabel_max_flow(graph, sources, sinks)
    print("maximum flow is " + _str(result))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

