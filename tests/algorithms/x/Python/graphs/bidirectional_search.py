# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:54 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class ExpandResult:
    queue: [int]
    head: int
    parents: Dict[int, int]
    visited: Dict[int, bool]
    intersection: int
    found: bool

def expand_search(graph, queue, head, parents, visited, opposite_visited):
    if head >= len(queue):
        return ExpandResult(queue=queue, head=head, parents=parents, visited=visited, intersection=0 - 1, found=False)
    current = queue[head]
    head = head + 1
    neighbors = graph.get(current, [])
    q = queue
    p = parents
    v = visited
    i = 0
    while i < len(neighbors):
        neighbor = neighbors[i]
        if v.get(neighbor, False):
            i = i + 1
            continue
        v[neighbor] = True
        p[neighbor] = current
        q = _append(q, neighbor)
        if opposite_visited.get(neighbor, False):
            return ExpandResult(queue=q, head=head, parents=p, visited=v, intersection=neighbor, found=True)
        i = i + 1
    return ExpandResult(queue=q, head=head, parents=p, visited=v, intersection=0 - 1, found=False)
def construct_path(current, parents):
    path = []
    node = current
    while node != 0 - 1:
        path = _append(path, node)
        node = parents.get(node, 0)
    return path
def reverse_list(xs):
    res = []
    i = len(xs)
    while i > 0:
        i = i - 1
        res = _append(res, xs[i])
    return res
@dataclass
class SearchResult:
    path: [int]
    ok: bool

def bidirectional_search(g, start, goal):
    if start == goal:
        return SearchResult(path=[start], ok=True)
    forward_parents = {}
    forward_parents[start] = 0 - 1
    backward_parents = {}
    backward_parents[goal] = 0 - 1
    forward_visited = {}
    forward_visited[start] = True
    backward_visited = {}
    backward_visited[goal] = True
    forward_queue = [start]
    backward_queue = [goal]
    forward_head = 0
    backward_head = 0
    intersection = 0 - 1
    while forward_head < len(forward_queue) and backward_head < len(backward_queue) and intersection == 0 - 1:
        res = expand_search(g, forward_queue, forward_head, forward_parents, forward_visited, backward_visited)
        forward_queue = res.queue
        forward_head = res.head
        forward_parents = res.parents
        forward_visited = res.visited
        if res.found:
            intersection = res.intersection
            break
        res = expand_search(g, backward_queue, backward_head, backward_parents, backward_visited, forward_visited)
        backward_queue = res.queue
        backward_head = res.head
        backward_parents = res.parents
        backward_visited = res.visited
        if res.found:
            intersection = res.intersection
            break
    if intersection == 0 - 1:
        return SearchResult(path=[], ok=False)
    forward_path = construct_path(intersection, forward_parents)
    forward_path = reverse_list(forward_path)
    back_start = backward_parents.get(intersection, None)
    backward_path = construct_path(back_start, backward_parents)
    result = forward_path
    j = 0
    while j < len(backward_path):
        result = _append(result, backward_path[j])
        j = j + 1
    return SearchResult(path=result, ok=True)
def is_edge(g, u, v):
    neighbors = g.get(u, [])
    i = 0
    while i < len(neighbors):
        if neighbors[i] == v:
            return True
        i = i + 1
    return False
def path_exists(g, path):
    if len(path) == 0:
        return False
    i = 0
    while i + 1 < len(path):
        if not is_edge(g, path[i], path[i + 1]):
            return False
        i = i + 1
    return True
def print_path(g, s, t):
    res = bidirectional_search(g, s, t)
    if res.ok and path_exists(g, res.path):
        print("Path from " + str(s) + " to " + str(t) + ": " + str(res.path))
    else:
        print("Path from " + str(s) + " to " + str(t) + ": None")
def main():
    graph = {0: [1, 2], 1: [0, 3, 4], 2: [0, 5, 6], 3: [1, 7], 4: [1, 8], 5: [2, 9], 6: [2, 10], 7: [3, 11], 8: [4, 11], 9: [5, 11], 10: [6, 11], 11: [7, 8, 9, 10]}
    print_path(graph, 0, 11)
    print_path(graph, 5, 5)
    disconnected = {0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3]}
    print_path(disconnected, 0, 3)
main()
