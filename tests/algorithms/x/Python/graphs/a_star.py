# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

DIRECTIONS = [[-1, 0], [0, -1], [1, 0], [0, 1]]
@dataclass
class SearchResult:
    path: [[int]]
    action: [[int]]

def iabs(x):
    if x < 0:
        return -x
    return x
def search(grid, init, goal, cost, heuristic):
    closed = []
    r = 0
    while r < len(grid):
        row = []
        c = 0
        while c < len(grid[0]):
            row = _append(row, 0)
            c = c + 1
        closed = _append(closed, row)
        r = r + 1
    closed[init[0]][init[1]] = 1
    action = []
    r = 0
    while r < len(grid):
        row = []
        c = 0
        while c < len(grid[0]):
            row = _append(row, 0)
            c = c + 1
        action = _append(action, row)
        r = r + 1
    x = init[0]
    y = init[1]
    g = 0
    f = g + heuristic[x][y]
    cell = [[f, g, x, y]]
    found = False
    resign = False
    while (not found) and (not resign):
        if len(cell) == 0:
            panic("Algorithm is unable to find solution")
        else:
            best_i = 0
            best_f = cell[0][0]
            i = 1
            while i < len(cell):
                if cell[i][0] < best_f:
                    best_f = cell[i][0]
                    best_i = i
                i = i + 1
            next_cell = cell[best_i]
            new_cell = []
            i = 0
            while i < len(cell):
                if i != best_i:
                    new_cell = _append(new_cell, cell[i])
                i = i + 1
            cell = new_cell
            x = next_cell[2]
            y = next_cell[3]
            g = next_cell[1]
            if x == goal[0] and y == goal[1]:
                found = True
            else:
                d = 0
                while d < len(DIRECTIONS):
                    x2 = x + DIRECTIONS[d][0]
                    y2 = y + DIRECTIONS[d][1]
                    if x2 >= 0 and x2 < len(grid) and y2 >= 0 and y2 < len(grid[0]) and closed[x2][y2] == 0 and grid[x2][y2] == 0:
                        g2 = g + cost
                        f2 = g2 + heuristic[x2][y2]
                        cell = _append(cell, [f2, g2, x2, y2])
                        closed[x2][y2] = 1
                        action[x2][y2] = d
                    d = d + 1
    invpath = []
    x = goal[0]
    y = goal[1]
    invpath = _append(invpath, [x, y])
    while x != init[0] or y != init[1]:
        dir = action[x][y]
        x2 = x - DIRECTIONS[dir][0]
        y2 = y - DIRECTIONS[dir][1]
        x = x2
        y = y2
        invpath = _append(invpath, [x, y])
    path = []
    idx = len(invpath) - 1
    while idx >= 0:
        path = _append(path, invpath[idx])
        idx = idx - 1
    return SearchResult(path=path, action=action)
def main():
    grid = [[0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0]]
    init = [0, 0]
    goal = [len(grid) - 1, len(grid[0]) - 1]
    cost = 1
    heuristic = []
    i = 0
    while i < len(grid):
        row = []
        j = 0
        while j < len(grid[0]):
            h = iabs(i - goal[0]) + iabs(j - goal[1])
            if grid[i][j] == 1:
                row = _append(row, 99)
            else:
                row = _append(row, h)
            j = j + 1
        heuristic = _append(heuristic, row)
        i = i + 1
    result = search(grid, init, goal, cost, heuristic)
    print("ACTION MAP")
    rr = 0
    while rr < len(result.action):
        print(result.action[rr])
        rr = rr + 1
    p = 0
    while p < len(result.path):
        print(result.path[p])
        p = p + 1
main()
