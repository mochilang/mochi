# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 10:00 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    lst.append(v)
    return lst


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

DIRECTIONS = [[-1, 0], [0, -1], [1, 0], [0, 1]]
@dataclass
class SearchResult:
    path: [[int]]
    action: [[int]]

def iabs(x):
    if x < 0:
        return -x
    return x
def search(grid, init, goal, cost, heuristic):
    closed = []
    r = 0
    while r < len(grid):
        row = []
        c = 0
        while c < len(grid[0]):
            row = _append(row, 0)
            c = c + 1
        closed = _append(closed, row)
        r = r + 1
    closed[init[0]][init[1]] = 1
    action = []
    r = 0
    while r < len(grid):
        row = []
        c = 0
        while c < len(grid[0]):
            row = _append(row, 0)
            c = c + 1
        action = _append(action, row)
        r = r + 1
    x = init[0]
    y = init[1]
    g = 0
    f = g + heuristic[x][y]
    cell = [[f, g, x, y]]
    found = False
    resign = False
    while (not found) and (not resign):
        if len(cell) == 0:
            panic("Algorithm is unable to find solution")
        else:
            best_i = 0
            best_f = cell[0][0]
            i = 1
            while i < len(cell):
                if cell[i][0] < best_f:
                    best_f = cell[i][0]
                    best_i = i
                i = i + 1
            next_cell = cell[best_i]
            new_cell = []
            i = 0
            while i < len(cell):
                if i != best_i:
                    new_cell = _append(new_cell, cell[i])
                i = i + 1
            cell = new_cell
            x = next_cell[2]
            y = next_cell[3]
            g = next_cell[1]
            if x == goal[0] and y == goal[1]:
                found = True
            else:
                d = 0
                while d < len(DIRECTIONS):
                    x2 = x + DIRECTIONS[d][0]
                    y2 = y + DIRECTIONS[d][1]
                    if x2 >= 0 and x2 < len(grid) and y2 >= 0 and y2 < len(grid[0]) and closed[x2][y2] == 0 and grid[x2][y2] == 0:
                        g2 = g + cost
                        f2 = g2 + heuristic[x2][y2]
                        cell = _append(cell, [f2, g2, x2, y2])
                        closed[x2][y2] = 1
                        action[x2][y2] = d
                    d = d + 1
    invpath = []
    x = goal[0]
    y = goal[1]
    invpath = _append(invpath, [x, y])
    while x != init[0] or y != init[1]:
        dir = action[x][y]
        x2 = x - DIRECTIONS[dir][0]
        y2 = y - DIRECTIONS[dir][1]
        x = x2
        y = y2
        invpath = _append(invpath, [x, y])
    path = []
    idx = len(invpath) - 1
    while idx >= 0:
        path = _append(path, invpath[idx])
        idx = idx - 1
    return SearchResult(path=path, action=action)
def main():
    if resource:
        _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_start = 0
    _bench_start = _now()
    try:
        grid = [[0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0]]
        init = [0, 0]
        goal = [len(grid) - 1, len(grid[0]) - 1]
        cost = 1
        heuristic = []
        i = 0
        while i < len(grid):
            row = []
            j = 0
            while j < len(grid[0]):
                h = iabs(i - goal[0]) + iabs(j - goal[1])
                if grid[i][j] == 1:
                    row = _append(row, 99)
                else:
                    row = _append(row, h)
                j = j + 1
            heuristic = _append(heuristic, row)
            i = i + 1
        result = search(grid, init, goal, cost, heuristic)
        print("ACTION MAP")
        rr = 0
        while rr < len(result.action):
            print(result.action[rr])
            rr = rr + 1
        p = 0
        while p < len(result.path):
            print(result.path[p])
            p = p + 1
    finally:
        _bench_end = _now()
        if resource:
            _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        else:
            _bench_mem_end = 0
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()

