# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

EDGE_ARRAY = [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]]
@dataclass
class NodesData:
    map: Dict[str, [string]]
    keys: [string]

@dataclass
class ClusterData:
    clusters: Dict[int, [string]]
    weights: [int]

@dataclass
class GraphData:
    edges: Dict[str, [string]]
    keys: [string]

def contains(lst, item):
    for v in lst:
        if v == item:
            return True
    return False
def get_distinct_edge(edge_array):
    distinct = []
    for row in edge_array:
        for item in row:
            e = item[0]
            if not contains(distinct, e):
                distinct = _append(distinct, e)
    return distinct
def get_bitcode(edge_array, de):
    bitcode = ""
    i = 0
    while i < len(edge_array):
        found = False
        for item in edge_array[i]:
            if item[0] == de:
                found = True
                break
        if found:
            bitcode = bitcode + "1"
        else:
            bitcode = bitcode + "0"
        i = i + 1
    return bitcode
def count_ones(s):
    c = 0
    i = 0
    while i < len(s):
        if s[i:i + 1] == "1":
            c = c + 1
        i = i + 1
    return c
def get_frequency_table(edge_array):
    distinct = get_distinct_edge(edge_array)
    table = []
    for e in distinct:
        bit = get_bitcode(edge_array, e)
        cnt = count_ones(bit)
        entry = {"edge": e, "count": str(cnt), "bit": bit}
        table = _append(table, entry)
    i = 0
    while i < len(table):
        max_i = i
        j = i + 1
        while j < len(table):
            if toi(table[j].get("count")) > toi(table[max_i].get("count")):
                max_i = j
            j = j + 1
        tmp = table[i]
        table[i] = table[max_i]
        table[max_i] = tmp
        i = i + 1
    return table
def get_nodes(freq_table):
    nodes = {}
    keys = []
    for f in freq_table:
        code = f.get("bit", "")
        edge = f.get("edge", "")
        if code in nodes:
            nodes[code] = _append(nodes.get(code, None), edge)
        else:
            nodes[code] = [edge]
            keys = _append(keys, code)
    return NodesData(map=nodes, keys=keys)
def get_cluster(nodes):
    clusters = {}
    weights = []
    i = 0
    while i < len(nodes.keys):
        code = nodes.keys[i]
        wt = count_ones(code)
        if wt in clusters:
            clusters[wt] = _append(clusters.get(wt, None), code)
        else:
            clusters[wt] = [code]
            weights = _append(weights, wt)
        i = i + 1
    return ClusterData(clusters=clusters, weights=weights)
def get_support(clusters):
    sup = []
    i = 0
    while i < len(clusters.weights):
        w = clusters.weights[i]
        sup = _append(sup, w * 100 // len(clusters.weights))
        i = i + 1
    return sup
def contains_bits(a, b):
    i = 0
    while i < len(a):
        c1 = a[i:i + 1]
        c2 = b[i:i + 1]
        if c1 == "1" and c2 != "1":
            return False
        i = i + 1
    return True
def max_cluster_key(clusters):
    m = 0
    i = 0
    while i < len(clusters.weights):
        w = clusters.weights[i]
        if w > m:
            m = w
        i = i + 1
    return m
def get_cluster_codes(clusters, wt):
    if wt in clusters.clusters:
        return clusters.clusters[wt]
    return []
def create_edge(nodes, graph, gkeys, clusters, c1, maxk):
    keys = gkeys
    codes1 = get_cluster_codes(clusters, c1)
    idx1 = 0
    while idx1 < len(codes1):
        i_code = codes1[idx1]
        count = 0
        c2 = c1 + 1
        while c2 <= maxk:
            codes2 = get_cluster_codes(clusters, c2)
            j = 0
            while j < len(codes2):
                j_code = codes2[j]
                if contains_bits(i_code, j_code):
                    if i_code in graph:
                        graph[i_code] = _append(graph.get(i_code, []), j_code)
                    else:
                        graph[i_code] = [j_code]
                        if not contains(keys, i_code):
                            keys = _append(keys, i_code)
                    if not contains(keys, j_code):
                        keys = _append(keys, j_code)
                    count = count + 1
                j = j + 1
            if count == 0:
                c2 = c2 + 1
            else:
                break
        idx1 = idx1 + 1
    return keys
def construct_graph(clusters, nodes):
    maxk = max_cluster_key(clusters)
    top_codes = get_cluster_codes(clusters, maxk)
    graph = {}
    keys = ["Header"]
    graph["Header"] = []
    i = 0
    while i < len(top_codes):
        code = top_codes[i]
        graph["Header"] = _append(graph.get("Header", None), code)
        graph[code] = ["Header"]
        keys = _append(keys, code)
        i = i + 1
    c = 1
    while c < maxk:
        keys = create_edge(nodes, graph, keys, clusters, c, maxk)
        c = c + 1
    return GraphData(edges=graph, keys=keys)
paths = []
def copy_list(lst):
    n = []
    for v in lst:
        n = _append(n, v)
    return n
def my_dfs(graph, start, end, path):
    global paths
    new_path = copy_list(path)
    new_path = _append(new_path, start)
    if start == end:
        paths = _append(paths, new_path)
        return
    for node in graph.get(start, []):
        seen = False
        for p in new_path:
            if p == node:
                seen = True
        if not seen:
            my_dfs(graph, node, end, new_path)
def find_freq_subgraph_given_support(s, clusters, graph):
    k = s * len(clusters.weights) // 100
    codes = get_cluster_codes(clusters, k)
    i = 0
    while i < len(codes):
        my_dfs(graph.edges, codes[i], "Header", [])
        i = i + 1
def node_edges(nodes, code):
    return nodes.map[code]
def freq_subgraphs_edge_list(paths, nodes):
    freq_sub_el = []
    for path in paths:
        el = []
        j = 0
        while j < len(path) - 1:
            code = path[j]
            edge_list = node_edges(nodes, code)
            e = 0
            while e < len(edge_list):
                edge = edge_list[e]
                a = edge[0:1]
                b = edge[1:2]
                el = _append(el, [a, b])
                e = e + 1
            j = j + 1
        freq_sub_el = _append(freq_sub_el, el)
    return freq_sub_el
def print_all(nodes, support, clusters, graph, freq_subgraph_edge_list):
    print("\nNodes\n")
    i = 0
    while i < len(nodes.keys):
        code = nodes.keys[i]
        print(code)
        print(nodes.map[code])
        i = i + 1
    print("\nSupport\n")
    print(support)
    print("\nCluster\n")
    j = 0
    while j < len(clusters.weights):
        w = clusters.weights[j]
        print(str(w) + ":" + str(clusters.clusters[w]))
        j = j + 1
    print("\nGraph\n")
    k = 0
    while k < len(graph.keys):
        key = graph.keys[k]
        print(key)
        print(graph.edges[key])
        k = k + 1
    print("\nEdge List of Frequent subgraphs\n")
    for el in freq_subgraph_edge_list:
        print(el)
def main():
    frequency_table = get_frequency_table(EDGE_ARRAY)
    nodes = get_nodes(frequency_table)
    clusters = get_cluster(nodes)
    support = get_support(clusters)
    graph = construct_graph(clusters, nodes)
    find_freq_subgraph_given_support(60, clusters, graph)
    freq_subgraph_edge_list = freq_subgraphs_edge_list(paths, nodes)
    print_all(nodes, support, clusters, graph, freq_subgraph_edge_list)
main()
