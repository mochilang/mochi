# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 17:21 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]
delta = [[-1, 0], [0, -1], [1, 0], [0, 1]]
def key(y, x):
    return _str(y) + "," + _str(x)
def parse_int(s):
    value = 0
    i = 0
    while i < len(s):
        c = s[i]
        value = value * 10 + (int(c))
        i = i + 1
    return value
def parse_key(k):
    idx = 0
    while idx < len(k) and k[idx:idx + 1] != ",":
        idx = idx + 1
    y = parse_int(k[0:idx])
    x = parse_int(k[idx + 1:len(k)])
    return [y, x]
@dataclass
class Node:
    pos: str
    path: [string]

def neighbors(pos):
    coords = parse_key(pos)
    y = coords[0]
    x = coords[1]
    res = []
    i = 0
    while i < len(delta):
        ny = y + delta[i][0]
        nx = x + delta[i][1]
        if ny >= 0 and ny < len(grid) and nx >= 0 and nx < len(grid[0]):
            if grid[ny][nx] == 0:
                res = _append(res, key(ny, nx))
        i = i + 1
    return res
def reverse_list(lst):
    res = []
    i = len(lst) - 1
    while i >= 0:
        res = _append(res, lst[i])
        i = i - 1
    return res
def bfs(start, goal):
    queue = []
    queue = _append(queue, Node(pos=start, path=[start]))
    head = 0
    visited = {"start": True}
    while head < len(queue):
        node = queue[head]
        head = head + 1
        if node.pos == goal:
            return node.path
        neigh = neighbors(node.pos)
        i = 0
        while i < len(neigh):
            npos = neigh[i]
            if not (npos in visited):
                visited[npos] = True
                new_path = _append(node.path, npos)
                queue = _append(queue, Node(pos=npos, path=new_path))
            i = i + 1
    return []
def bidirectional_bfs(start, goal):
    queue_f = []
    queue_b = []
    queue_f = _append(queue_f, Node(pos=start, path=[start]))
    queue_b = _append(queue_b, Node(pos=goal, path=[goal]))
    head_f = 0
    head_b = 0
    visited_f = {"start": [start]}
    visited_b = {"goal": [goal]}
    while head_f < len(queue_f) and head_b < len(queue_b):
        node_f = queue_f[head_f]
        head_f = head_f + 1
        neigh_f = neighbors(node_f.pos)
        i = 0
        while i < len(neigh_f):
            npos = neigh_f[i]
            if not (npos in visited_f):
                new_path = _append(node_f.path, npos)
                visited_f[npos] = new_path
                if npos in visited_b:
                    rev = reverse_list(visited_b.get(npos, []))
                    j = 1
                    while j < len(rev):
                        new_path = _append(new_path, rev[j])
                        j = j + 1
                    return new_path
                queue_f = _append(queue_f, Node(pos=npos, path=new_path))
            i = i + 1
        node_b = queue_b[head_b]
        head_b = head_b + 1
        neigh_b = neighbors(node_b.pos)
        j = 0
        while j < len(neigh_b):
            nposb = neigh_b[j]
            if not (nposb in visited_b):
                new_path_b = _append(node_b.path, nposb)
                visited_b[nposb] = new_path_b
                if nposb in visited_f:
                    path_f = visited_f.get(nposb, [])
                    new_path_b = reverse_list(new_path_b)
                    t = 1
                    while t < len(new_path_b):
                        path_f = _append(path_f, new_path_b[t])
                        t = t + 1
                    return path_f
                queue_b = _append(queue_b, Node(pos=nposb, path=new_path_b))
            j = j + 1
    return [start]
def path_to_string(path):
    if len(path) == 0:
        return "[]"
    first = parse_key(path[0])
    s = "[(" + _str(first[0]) + ", " + _str(first[1]) + ")"
    i = 1
    while i < len(path):
        c = parse_key(path[i])
        s = s + ", (" + _str(c[0]) + ", " + _str(c[1]) + ")"
        i = i + 1
    s = s + "]"
    return s
start = key(0, 0)
goal = key(len(grid) - 1, len(grid[0]) - 1)
path1 = bfs(start, goal)
print(path_to_string(path1))
path2 = bidirectional_bfs(start, goal)
print(path_to_string(path2))

