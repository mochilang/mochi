# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 10:32 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def list_contains_int(xs, x):
    i = 0
    while i < len(xs):
        if xs[i] == x:
            return True
        i = i + 1
    return False
def edge_exists(edges, w, v):
    i = 0
    while i < len(edges):
        if edges[i][0] == w and edges[i][1] == v:
            return True
        i = i + 1
    return False
def first_key(m):
    for k in m:
        return k
    return 0
def rand_range(low, high):
    return (_now() % (high - low)) + low
@dataclass
class DirectedGraph:
    graph: Dict[int, [[int]]]

def dg_make_graph():
    return DirectedGraph(graph={})
def dg_add_pair(g, u, v, w):
    if u in g.graph:
        edges = g.graph[u]
        if not edge_exists(edges, w, v):
            edges = _append(edges, [w, v])
            m = g.graph
            m[u] = edges
            g.graph = m
    else:
        m0 = g.graph
        m0[u] = [[w, v]]
        g.graph = m0
    if not (v in g.graph):
        m1 = g.graph
        m1[v] = []
        g.graph = m1
def dg_remove_pair(g, u, v):
    if u in g.graph:
        edges = g.graph[u]
        new_edges = []
        i = 0
        while i < len(edges):
            if edges[i][1] != v:
                new_edges = _append(new_edges, edges[i])
            i = i + 1
        m = g.graph
        m[u] = new_edges
        g.graph = m
def dg_all_nodes(g):
    res = []
    for k in g.graph:
        res = _append(res, k)
    return res
def dg_dfs_util(g, node, visited, order, d):
    visited[node] = True
    order = _append(order, node)
    if d != (-1) and node == d:
        return order
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            order = dg_dfs_util(g, neigh, visited, order, d)
            if d != (-1) and order[len(order) - 1] == d:
                return order
        i = i + 1
    return order
def dg_dfs(g, s, d):
    if s == d:
        return []
    start = (first_key(g.graph) if s == (-2) else s)
    visited = {}
    order = []
    order = dg_dfs_util(g, start, visited, order, d)
    return order
def dg_bfs(g, s):
    queue = []
    visited = {}
    order = []
    start = (first_key(g.graph) if s == (-2) else s)
    queue = _append(queue, start)
    visited[start] = True
    while len(queue) > 0:
        node = queue[0]
        queue = queue[1:len(queue)]
        order = _append(order, node)
        edges = g.graph[node]
        i = 0
        while i < len(edges):
            neigh = edges[i][1]
            if not (neigh in visited):
                queue = _append(queue, neigh)
                visited[neigh] = True
            i = i + 1
    return order
def dg_in_degree(g, u):
    count = 0
    for k in g.graph:
        edges = g.graph[k]
        i = 0
        while i < len(edges):
            if edges[i][1] == u:
                count = count + 1
            i = i + 1
    return count
def dg_out_degree(g, u):
    if u in g.graph:
        return len(g.graph[u])
    return 0
def dg_topo_util(g, node, visited, stack):
    visited[node] = True
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            stack = dg_topo_util(g, neigh, visited, stack)
        i = i + 1
    stack = _append(stack, node)
    return stack
def dg_topological_sort(g):
    visited = {}
    stack = []
    for k in g.graph:
        if not (k in visited):
            stack = dg_topo_util(g, k, visited, stack)
    res = []
    i = len(stack) - 1
    while i >= 0:
        res = _append(res, stack[i])
        i = i - 1
    return res
def dg_cycle_util(g, node, visited, rec, res):
    visited[node] = True
    rec[node] = True
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            res = dg_cycle_util(g, neigh, visited, rec, res)
        else:
            if rec.get(neigh, False):
                if not list_contains_int(res, neigh):
                    res = _append(res, neigh)
                if not list_contains_int(res, node):
                    res = _append(res, node)
        i = i + 1
    rec[node] = False
    return res
def dg_cycle_nodes(g):
    visited = {}
    rec = {}
    res = []
    for k in g.graph:
        if not (k in visited):
            res = dg_cycle_util(g, k, visited, rec, res)
    return res
def dg_has_cycle_util(g, node, visited, rec):
    visited[node] = True
    rec[node] = True
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            if dg_has_cycle_util(g, neigh, visited, rec):
                return True
        else:
            if rec.get(neigh, False):
                return True
        i = i + 1
    rec[node] = False
    return False
def dg_has_cycle(g):
    visited = {}
    rec = {}
    for k in g.graph:
        if not (k in visited):
            if dg_has_cycle_util(g, k, visited, rec):
                return True
    return False
def dg_fill_graph_randomly(g, c):
    count = c
    if count == (-1):
        count = rand_range(10, 10010)
    i = 0
    while i < count:
        edge_count = rand_range(1, 103)
        j = 0
        while j < edge_count:
            n = rand_range(0, count)
            if n != i:
                dg_add_pair(g, i, n, 1)
            j = j + 1
        i = i + 1
def dg_dfs_time(g, s, e):
    begin = _now()
    dg_dfs(g, s, e)
    end = _now()
    return end - begin
def dg_bfs_time(g, s):
    begin = _now()
    dg_bfs(g, s)
    end = _now()
    return end - begin
@dataclass
class Graph:
    graph: Dict[int, [[int]]]

def g_make_graph():
    return Graph(graph={})
def g_add_pair(g, u, v, w):
    if u in g.graph:
        edges = g.graph[u]
        if not edge_exists(edges, w, v):
            edges = _append(edges, [w, v])
            m = g.graph
            m[u] = edges
            g.graph = m
    else:
        m0 = g.graph
        m0[u] = [[w, v]]
        g.graph = m0
    if v in g.graph:
        edges2 = g.graph[v]
        if not edge_exists(edges2, w, u):
            edges2 = _append(edges2, [w, u])
            m2 = g.graph
            m2[v] = edges2
            g.graph = m2
    else:
        m3 = g.graph
        m3[v] = [[w, u]]
        g.graph = m3
def g_remove_pair(g, u, v):
    if u in g.graph:
        edges = g.graph[u]
        new_edges = []
        i = 0
        while i < len(edges):
            if edges[i][1] != v:
                new_edges = _append(new_edges, edges[i])
            i = i + 1
        m = g.graph
        m[u] = new_edges
        g.graph = m
    if v in g.graph:
        edges2 = g.graph[v]
        new_edges2 = []
        j = 0
        while j < len(edges2):
            if edges2[j][1] != u:
                new_edges2 = _append(new_edges2, edges2[j])
            j = j + 1
        m2 = g.graph
        m2[v] = new_edges2
        g.graph = m2
def g_all_nodes(g):
    res = []
    for k in g.graph:
        res = _append(res, k)
    return res
def g_dfs_util(g, node, visited, order, d):
    visited[node] = True
    order = _append(order, node)
    if d != (-1) and node == d:
        return order
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            order = g_dfs_util(g, neigh, visited, order, d)
            if d != (-1) and order[len(order) - 1] == d:
                return order
        i = i + 1
    return order
def g_dfs(g, s, d):
    if s == d:
        return []
    start = (first_key(g.graph) if s == (-2) else s)
    visited = {}
    order = []
    order = g_dfs_util(g, start, visited, order, d)
    return order
def g_bfs(g, s):
    queue = []
    visited = {}
    order = []
    start = (first_key(g.graph) if s == (-2) else s)
    queue = _append(queue, start)
    visited[start] = True
    while len(queue) > 0:
        node = queue[0]
        queue = queue[1:len(queue)]
        order = _append(order, node)
        edges = g.graph[node]
        i = 0
        while i < len(edges):
            neigh = edges[i][1]
            if not (neigh in visited):
                queue = _append(queue, neigh)
                visited[neigh] = True
            i = i + 1
    return order
def g_degree(g, u):
    if u in g.graph:
        return len(g.graph[u])
    return 0
def g_cycle_util(g, node, visited, parent, res):
    visited[node] = True
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            res = g_cycle_util(g, neigh, visited, node, res)
        else:
            if neigh != parent:
                if not list_contains_int(res, neigh):
                    res = _append(res, neigh)
                if not list_contains_int(res, node):
                    res = _append(res, node)
        i = i + 1
    return res
def g_cycle_nodes(g):
    visited = {}
    res = []
    for k in g.graph:
        if not (k in visited):
            res = g_cycle_util(g, k, visited, -1, res)
    return res
def g_has_cycle_util(g, node, visited, parent):
    visited[node] = True
    edges = g.graph[node]
    i = 0
    while i < len(edges):
        neigh = edges[i][1]
        if not (neigh in visited):
            if g_has_cycle_util(g, neigh, visited, node):
                return True
        else:
            if neigh != parent:
                return True
        i = i + 1
    return False
def g_has_cycle(g):
    visited = {}
    for k in g.graph:
        if not (k in visited):
            if g_has_cycle_util(g, k, visited, -1):
                return True
    return False
def g_fill_graph_randomly(g, c):
    count = c
    if count == (-1):
        count = rand_range(10, 10010)
    i = 0
    while i < count:
        edge_count = rand_range(1, 103)
        j = 0
        while j < edge_count:
            n = rand_range(0, count)
            if n != i:
                g_add_pair(g, i, n, 1)
            j = j + 1
        i = i + 1
def g_dfs_time(g, s, e):
    begin = _now()
    g_dfs(g, s, e)
    end = _now()
    return end - begin
def g_bfs_time(g, s):
    begin = _now()
    g_bfs(g, s)
    end = _now()
    return end - begin
def main():
    dg = dg_make_graph()
    dg_add_pair(dg, 0, 1, 5)
    dg_add_pair(dg, 0, 2, 3)
    dg_add_pair(dg, 1, 3, 2)
    dg_add_pair(dg, 2, 3, 4)
    print(str(dg_dfs(dg, -2, -1)))
    print(str(dg_bfs(dg, -2)))
    print(str(dg_in_degree(dg, 3)))
    print(str(dg_out_degree(dg, 0)))
    print(str(dg_topological_sort(dg)))
    print(str(dg_has_cycle(dg)))
    ug = g_make_graph()
    g_add_pair(ug, 0, 1, 1)
    g_add_pair(ug, 1, 2, 1)
    g_add_pair(ug, 2, 0, 1)
    print(str(g_dfs(ug, -2, -1)))
    print(str(g_bfs(ug, -2)))
    print(str(g_degree(ug, 1)))
    print(str(g_has_cycle(ug)))
main()
