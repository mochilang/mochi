# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Edge:
    to: str
    cost: int

@dataclass
class QItem:
    node: str
    cost: int

@dataclass
class PassResult:
    queue: [QItem]
    dist: int

def get_min_index(q):
    idx = 0
    i = 1
    while i < len(q):
        if q[i].cost < q[idx].cost:
            idx = i
        i = i + 1
    return idx
def remove_at(q, idx):
    res = []
    i = 0
    while i < len(q):
        if i != idx:
            res = _append(res, q[i])
        i = i + 1
    return res
def pass_and_relaxation(graph, v, visited_forward, visited_backward, cst_fwd, cst_bwd, queue, parent, shortest_distance):
    q = queue
    sd = shortest_distance
    for e in graph[v]:
        nxt = e.to
        d = e.cost
        if nxt in visited_forward:
            continue
        old_cost = (cst_fwd[nxt] if nxt in cst_fwd else 2147483647)
        new_cost = cst_fwd[v] + d
        if new_cost < old_cost:
            q = _append(q, QItem(node=nxt, cost=new_cost))
            cst_fwd[nxt] = new_cost
            parent[nxt] = v
        if nxt in visited_backward:
            alt = cst_fwd[v] + d + cst_bwd[nxt]
            if alt < sd:
                sd = alt
    return PassResult(queue=q, dist=sd)
def bidirectional_dij(source, destination, graph_forward, graph_backward):
    shortest_path_distance = -1
    visited_forward = {}
    visited_backward = {}
    cst_fwd = {}
    cst_fwd[source] = 0
    cst_bwd = {}
    cst_bwd[destination] = 0
    parent_forward = {}
    parent_forward[source] = ""
    parent_backward = {}
    parent_backward[destination] = ""
    queue_forward = []
    queue_forward = _append(queue_forward, QItem(node=source, cost=0))
    queue_backward = []
    queue_backward = _append(queue_backward, QItem(node=destination, cost=0))
    shortest_distance = 2147483647
    if source == destination:
        return 0
    while len(queue_forward) > 0 and len(queue_backward) > 0:
        idx_f = get_min_index(queue_forward)
        item_f = queue_forward[idx_f]
        queue_forward = remove_at(queue_forward, idx_f)
        v_fwd = item_f.node
        visited_forward[v_fwd] = True
        idx_b = get_min_index(queue_backward)
        item_b = queue_backward[idx_b]
        queue_backward = remove_at(queue_backward, idx_b)
        v_bwd = item_b.node
        visited_backward[v_bwd] = True
        res_f = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, parent_forward, shortest_distance)
        queue_forward = res_f.queue
        shortest_distance = res_f.dist
        res_b = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, parent_backward, shortest_distance)
        queue_backward = res_b.queue
        shortest_distance = res_b.dist
        if cst_fwd[v_fwd] + cst_bwd[v_bwd] >= shortest_distance:
            break
    if shortest_distance != 2147483647:
        shortest_path_distance = shortest_distance
    return shortest_path_distance
graph_fwd = {"B": [Edge(to="C", cost=1)], "C": [Edge(to="D", cost=1)], "D": [Edge(to="F", cost=1)], "E": [Edge(to="B", cost=1), Edge(to="G", cost=2)], "F": [], "G": [Edge(to="F", cost=1)]}
graph_bwd = {"B": [Edge(to="E", cost=1)], "C": [Edge(to="B", cost=1)], "D": [Edge(to="C", cost=1)], "F": [Edge(to="D", cost=1), Edge(to="G", cost=1)], "E": [], "G": [Edge(to="E", cost=2)]}
print(str(bidirectional_dij("E", "F", graph_fwd, graph_bwd)))
