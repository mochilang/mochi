# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 10:00 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    lst.append(v)
    return lst


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    @dataclass
    class Edge:
        to: str
        cost: int
    @dataclass
    class QItem:
        node: str
        cost: int
    @dataclass
    class PassResult:
        queue: [QItem]
        dist: int
    def get_min_index(q):
        idx = 0
        i = 1
        while i < len(q):
            if q[i].cost < q[idx].cost:
                idx = i
            i = i + 1
        return idx
    def remove_at(q, idx):
        res = []
        i = 0
        while i < len(q):
            if i != idx:
                res = _append(res, q[i])
            i = i + 1
        return res
    def pass_and_relaxation(graph, v, visited_forward, visited_backward, cst_fwd, cst_bwd, queue, parent, shortest_distance):
        q = queue
        sd = shortest_distance
        for e in graph.get(v, []):
            nxt = e.to
            d = e.cost
            if nxt in visited_forward:
                continue
            old_cost = (cst_fwd.get(nxt, 0) if nxt in cst_fwd else 2147483647)
            new_cost = cst_fwd.get(v, 0) + d
            if new_cost < old_cost:
                q = _append(q, QItem(node=nxt, cost=new_cost))
                cst_fwd[nxt] = new_cost
                parent[nxt] = v
            if nxt in visited_backward:
                alt = cst_fwd.get(v, 0) + d + cst_bwd.get(nxt, 0)
                if alt < sd:
                    sd = alt
        return PassResult(queue=q, dist=sd)
    def bidirectional_dij(source, destination, graph_forward, graph_backward):
        shortest_path_distance = -1
        visited_forward = {}
        visited_backward = {}
        cst_fwd = {}
        cst_fwd[source] = 0
        cst_bwd = {}
        cst_bwd[destination] = 0
        parent_forward = {}
        parent_forward[source] = ""
        parent_backward = {}
        parent_backward[destination] = ""
        queue_forward = []
        queue_forward = _append(queue_forward, QItem(node=source, cost=0))
        queue_backward = []
        queue_backward = _append(queue_backward, QItem(node=destination, cost=0))
        shortest_distance = 2147483647
        if source == destination:
            return 0
        while len(queue_forward) > 0 and len(queue_backward) > 0:
            idx_f = get_min_index(queue_forward)
            item_f = queue_forward[idx_f]
            queue_forward = remove_at(queue_forward, idx_f)
            v_fwd = item_f.node
            visited_forward[v_fwd] = True
            idx_b = get_min_index(queue_backward)
            item_b = queue_backward[idx_b]
            queue_backward = remove_at(queue_backward, idx_b)
            v_bwd = item_b.node
            visited_backward[v_bwd] = True
            res_f = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, parent_forward, shortest_distance)
            queue_forward = res_f.queue
            shortest_distance = res_f.dist
            res_b = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, parent_backward, shortest_distance)
            queue_backward = res_b.queue
            shortest_distance = res_b.dist
            if cst_fwd.get(v_fwd, None) + cst_bwd.get(v_bwd, None) >= shortest_distance:
                break
        if shortest_distance != 2147483647:
            shortest_path_distance = shortest_distance
        return shortest_path_distance
    graph_fwd = {"B": [Edge(to="C", cost=1)], "C": [Edge(to="D", cost=1)], "D": [Edge(to="F", cost=1)], "E": [Edge(to="B", cost=1), Edge(to="G", cost=2)], "F": [], "G": [Edge(to="F", cost=1)]}
    graph_bwd = {"B": [Edge(to="E", cost=1)], "C": [Edge(to="B", cost=1)], "D": [Edge(to="C", cost=1)], "F": [Edge(to="D", cost=1), Edge(to="G", cost=1)], "E": [], "G": [Edge(to="E", cost=2)]}
    print(_str(bidirectional_dij("E", "F", graph_fwd, graph_bwd)))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

