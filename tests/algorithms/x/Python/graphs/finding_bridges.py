# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-15 09:59 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class DfsResult:
    id_: int
    bridges: [[int]]

def dfs(graph, at, parent, visited, ids, low, id_, bridges):
    visited[at] = True
    ids[at] = id_
    low[at] = id_
    current_id = id_ + 1
    res_bridges = bridges
    for to in graph.get(at, []):
        if to == parent:
            continue
        else:
            if not visited[to]:
                result = dfs(graph, to, at, visited, ids, low, current_id, res_bridges)
                current_id = result.id_
                res_bridges = result.bridges
                if low[at] > low[to]:
                    low[at] = low[to]
                if ids[at] < low[to]:
                    edge = ([at, to] if at < to else [to, at])
                    res_bridges = _append(res_bridges, edge)
            else:
                if low[at] > ids[to]:
                    low[at] = ids[to]
    return DfsResult(id_=current_id, bridges=res_bridges)
def compute_bridges(graph):
    n = len(graph)
    visited = []
    ids = []
    low = []
    i = 0
    while i < n:
        visited = _append(visited, False)
        ids = _append(ids, 0)
        low = _append(low, 0)
        i = i + 1
    bridges = []
    id_ = 0
    i = 0
    while i < n:
        if not visited[i]:
            result = dfs(graph, i, -1, visited, ids, low, id_, bridges)
            id_ = result.id_
            bridges = result.bridges
        i = i + 1
    return bridges
def get_demo_graph(index):
    if index == 0:
        return {0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 5], 3: [2, 4], 4: [3], 5: [2, 6, 8], 6: [5, 7], 7: [6, 8], 8: [5, 7]}
    if index == 1:
        return {0: [6], 1: [9], 2: [4, 5], 3: [4], 4: [2, 3], 5: [2], 6: [0, 7], 7: [6], 8: [], 9: [1]}
    if index == 2:
        return {0: [4], 1: [6], 2: [], 3: [5, 6, 7], 4: [0, 6], 5: [3, 8, 9], 6: [1, 3, 4, 7], 7: [3, 6, 8, 9], 8: [5, 7], 9: [5, 7]}
    return {0: [1, 3], 1: [0, 2, 4], 2: [1, 3, 4], 3: [0, 2, 4], 4: [1, 2, 3]}
print(compute_bridges(get_demo_graph(0)))
print(compute_bridges(get_demo_graph(1)))
print(compute_bridges(get_demo_graph(2)))
print(compute_bridges(get_demo_graph(3)))
print(compute_bridges({}))

