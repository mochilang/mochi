# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 08:38 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Edge:
    destination_vertex: int
    weight: int

@dataclass
class AdjacencyList:
    graph: [[Edge]]
    size: int

def new_adjacency_list(size):
    g = []
    i = 0
    while i < size:
        g = _append(g, [])
        i = i + 1
    return AdjacencyList(graph=g, size=size)
def add_edge(al, from_vertex, to_vertex, weight):
    if not (weight == 0 or weight == 1):
        panic("Edge weight must be either 0 or 1.")
    if to_vertex < 0 or to_vertex >= al.size:
        panic("Vertex indexes must be in [0; size).")
    g = al.graph
    edges = g[from_vertex]
    g[from_vertex] = _append(edges, Edge(destination_vertex=to_vertex, weight=weight))
    al.graph = g
def push_front(q, v):
    res = [v]
    i = 0
    while i < len(q):
        res = _append(res, q[i])
        i = i + 1
    return res
def pop_front(q):
    res = []
    i = 1
    while i < len(q):
        res = _append(res, q[i])
        i = i + 1
    return res
def front(q):
    return q[0]
def get_shortest_path(al, start_vertex, finish_vertex):
    queue = [start_vertex]
    distances = []
    i = 0
    while i < al.size:
        distances = _append(distances, -1)
        i = i + 1
    distances[start_vertex] = 0
    while len(queue) > 0:
        current_vertex = front(queue)
        queue = pop_front(queue)
        current_distance = distances[current_vertex]
        edges = al.graph[current_vertex]
        j = 0
        while j < len(edges):
            edge = edges[j]
            new_distance = current_distance + edge.weight
            dest = edge.destination_vertex
            dest_distance = distances[dest]
            if dest_distance >= 0 and new_distance >= dest_distance:
                j = j + 1
                continue
            distances[dest] = new_distance
            if edge.weight == 0:
                queue = push_front(queue, dest)
            else:
                queue = _append(queue, dest)
            j = j + 1
    result = distances[finish_vertex]
    if result < 0:
        panic("No path from start_vertex to finish_vertex.")
    return result
g = new_adjacency_list(11)
add_edge(g, 0, 1, 0)
add_edge(g, 0, 3, 1)
add_edge(g, 1, 2, 0)
add_edge(g, 2, 3, 0)
add_edge(g, 4, 2, 1)
add_edge(g, 4, 5, 1)
add_edge(g, 4, 6, 1)
add_edge(g, 5, 9, 0)
add_edge(g, 6, 7, 1)
add_edge(g, 7, 8, 1)
add_edge(g, 8, 10, 1)
add_edge(g, 9, 7, 0)
add_edge(g, 9, 10, 1)
print(str(get_shortest_path(g, 0, 3)))
print(str(get_shortest_path(g, 4, 10)))
print(str(get_shortest_path(g, 4, 8)))
print(str(get_shortest_path(g, 0, 1)))
