# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 14:44 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    import builtins
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(float(builtins.round(v)))
        return builtins.format(v, ".15g")
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def sqrt(x):
        if x <= 0.0:
            return 0.0
        guess = x
        i = 0
        while i < 10:
            guess = (guess + x / guess) / 2.0
            i = i + 1
        return guess
    def powf(x, n):
        res = 1.0
        i = 0
        while i < n:
            res = res * x
            i = i + 1
        return res
    def roundf(x):
        if x >= 0.0:
            return int((x + 0.5))
        return int((x - 0.5))
    def fib_iterative(n):
        if n < 0:
            panic("n is negative")
        if n == 0:
            return [0]
        fib = [0, 1]
        i = 2
        while i <= n:
            fib = _append(fib, fib[i - 1] + fib[i - 2])
            i = i + 1
        return fib
    def fib_recursive_term(i):
        if i < 0:
            panic("n is negative")
        if i < 2:
            return i
        return fib_recursive_term(i - 1) + fib_recursive_term(i - 2)
    def fib_recursive(n):
        if n < 0:
            panic("n is negative")
        res = []
        i = 0
        while i <= n:
            res = _append(res, fib_recursive_term(i))
            i = i + 1
        return res
    fib_cache_global = {}
    def fib_recursive_cached_term(i):
        if i < 0:
            panic("n is negative")
        if i < 2:
            return i
        if i in fib_cache_global:
            return fib_cache_global.get(i, None)
        val = fib_recursive_cached_term(i - 1) + fib_recursive_cached_term(i - 2)
        fib_cache_global[i] = val
        return val
    def fib_recursive_cached(n):
        if n < 0:
            panic("n is negative")
        res = []
        j = 0
        while j <= n:
            res = _append(res, fib_recursive_cached_term(j))
            j = j + 1
        return res
    fib_memo_cache = {0: 0, 1: 1, 2: 1}
    def fib_memoization_term(num):
        if num in fib_memo_cache:
            return fib_memo_cache.get(num, 0)
        value = fib_memoization_term(num - 1) + fib_memoization_term(num - 2)
        fib_memo_cache[num] = value
        return value
    def fib_memoization(n):
        if n < 0:
            panic("n is negative")
        out = []
        i = 0
        while i <= n:
            out = _append(out, fib_memoization_term(i))
            i = i + 1
        return out
    def fib_binet(n):
        if n < 0:
            panic("n is negative")
        if n >= 1475:
            panic("n is too large")
        sqrt5 = sqrt(5.0)
        phi = (1.0 + sqrt5) / 2.0
        res = []
        i = 0
        while i <= n:
            val = roundf(powf(phi, i) / sqrt5)
            res = _append(res, val)
            i = i + 1
        return res
    def matrix_mul(a, b):
        a00 = a[0][0] * b[0][0] + a[0][1] * b[1][0]
        a01 = a[0][0] * b[0][1] + a[0][1] * b[1][1]
        a10 = a[1][0] * b[0][0] + a[1][1] * b[1][0]
        a11 = a[1][0] * b[0][1] + a[1][1] * b[1][1]
        return [[a00, a01], [a10, a11]]
    def matrix_pow(m, power):
        if power < 0:
            panic("power is negative")
        result = [[1, 0], [0, 1]]
        base = m
        p = power
        while p > 0:
            if p % 2 == 1:
                result = matrix_mul(result, base)
            base = matrix_mul(base, base)
            p = int((p // 2))
        return result
    def fib_matrix(n):
        if n < 0:
            panic("n is negative")
        if n == 0:
            return 0
        m = [[1, 1], [1, 0]]
        res = matrix_pow(m, n - 1)
        return res[0][0]
    def run_tests():
        expected = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
        it = fib_iterative(10)
        rec = fib_recursive(10)
        cache = fib_recursive_cached(10)
        memo = fib_memoization(10)
        bin_ = fib_binet(10)
        m = fib_matrix(10)
        if it != expected:
            panic("iterative failed")
        if rec != expected:
            panic("recursive failed")
        if cache != expected:
            panic("cached failed")
        if memo != expected:
            panic("memoization failed")
        if bin_ != expected:
            panic("binet failed")
        if m != 55:
            panic("matrix failed")
        return m
    print(_str(run_tests()))
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

