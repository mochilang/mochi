# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 16:09 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    @dataclass
    class Complex:
        re: float
        im: float
    def c_add(a, b):
        return Complex(re=a.re + b.re, im=a.im + b.im)
    def c_sub(a, b):
        return Complex(re=a.re - b.re, im=a.im - b.im)
    def c_mul(a, b):
        return Complex(re=a.re * b.re - a.im * b.im, im=a.re * b.im + a.im * b.re)
    def c_mul_scalar(a, s):
        return Complex(re=a.re * s, im=a.im * s)
    def c_div_scalar(a, s):
        return Complex(re=a.re / s, im=a.im / s)
    PI = 3.141592653589793
    def sin_taylor(x):
        term = x
        sum = x
        i = 1
        while i < 10:
            k1 = 2.0 * (float(i))
            k2 = k1 + 1.0
            term = -term * x * x / (k1 * k2)
            sum = sum + term
            i = i + 1
        return sum
    def cos_taylor(x):
        term = 1.0
        sum = 1.0
        i = 1
        while i < 10:
            k1 = 2.0 * (float(i)) - 1.0
            k2 = 2.0 * (float(i))
            term = -term * x * x / (k1 * k2)
            sum = sum + term
            i = i + 1
        return sum
    def exp_i(theta):
        return Complex(re=cos_taylor(theta), im=sin_taylor(theta))
    def make_complex_list(n, value):
        arr = []
        i = 0
        while i < n:
            arr = _append(arr, value)
            i = i + 1
        return arr
    def fft(a, invert):
        n = len(a)
        if n == 1:
            return [a[0]]
        a0 = []
        a1 = []
        i = 0
        while i < (n // 2):
            a0 = _append(a0, a[2 * i])
            a1 = _append(a1, a[2 * i + 1])
            i = i + 1
        y0 = fft(a0, invert)
        y1 = fft(a1, invert)
        angle = 2.0 * PI / (float(n)) * ((-1.0 if invert else 1.0))
        w = Complex(re=1.0, im=0.0)
        wn = exp_i(angle)
        y = make_complex_list(n, Complex(re=0.0, im=0.0))
        i = 0
        while i < (n // 2):
            t = c_mul(w, y1[i])
            u = y0[i]
            even = c_add(u, t)
            odd = c_sub(u, t)
            if invert:
                even = c_div_scalar(even, 2.0)
                odd = c_div_scalar(odd, 2.0)
            y[i] = even
            y[i + (n // 2)] = odd
            w = c_mul(w, wn)
            i = i + 1
        return y
    def floor(x):
        i = int(x)
        if (float(i)) > x:
            i = i - 1
        return float(i)
    def pow10(n):
        p = 1.0
        i = 0
        while i < n:
            p = p * 10.0
            i = i + 1
        return p
    def round_to(x, ndigits):
        m = pow10(ndigits)
        return floor(x * m + 0.5) / m
    def list_to_string(l):
        s = "["
        i = 0
        while i < len(l):
            s = s + _str(l[i])
            if i + 1 < len(l):
                s = s + ", "
            i = i + 1
        s = s + "]"
        return s
    def multiply_poly(a, b):
        n = 1
        while n < len(a) + len(b) - 1:
            n = n * 2
        fa = make_complex_list(n, Complex(re=0.0, im=0.0))
        fb = make_complex_list(n, Complex(re=0.0, im=0.0))
        i = 0
        while i < len(a):
            fa[i] = Complex(re=a[i], im=0.0)
            i = i + 1
        i = 0
        while i < len(b):
            fb[i] = Complex(re=b[i], im=0.0)
            i = i + 1
        fa = fft(fa, False)
        fb = fft(fb, False)
        i = 0
        while i < n:
            fa[i] = c_mul(fa[i], fb[i])
            i = i + 1
        fa = fft(fa, True)
        res = []
        i = 0
        while i < len(a) + len(b) - 1:
            val = fa[i]
            res = _append(res, round_to(val.re, 8))
            i = i + 1
        while len(res) > 0 and res[len(res) - 1] == 0.0:
            res = res[0:len(res) - 1]
        return res
    A = [0.0, 1.0, 0.0, 2.0]
    B = [2.0, 3.0, 4.0, 0.0]
    product = multiply_poly(A, B)
    print(list_to_string(product))
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
