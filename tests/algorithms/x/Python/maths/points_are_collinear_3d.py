# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 16:09 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)

@dataclass
class Point3d:
    x: float
    y: float
    z: float

@dataclass
class Vector3d:
    x: float
    y: float
    z: float

def create_vector(p1, p2):
    vx = p2.x - p1.x
    vy = p2.y - p1.y
    vz = p2.z - p1.z
    return Vector3d(x=vx, y=vy, z=vz)
def get_3d_vectors_cross(ab, ac):
    cx = ab.y * ac.z - ab.z * ac.y
    cy = ab.z * ac.x - ab.x * ac.z
    cz = ab.x * ac.y - ab.y * ac.x
    return Vector3d(x=cx, y=cy, z=cz)
def pow10(exp):
    result = 1.0
    i = 0
    while i < exp:
        result = result * 10.0
        i = i + 1
    return result
def round_float(x, digits):
    factor = pow10(digits)
    v = x * factor
    if v >= 0.0:
        v = v + 0.5
    else:
        v = v - 0.5
    t = int(v)
    return (float(t)) / factor
def is_zero_vector(v, accuracy):
    return round_float(v.x, accuracy) == 0.0 and round_float(v.y, accuracy) == 0.0 and round_float(v.z, accuracy) == 0.0
def are_collinear(a, b, c, accuracy):
    ab = create_vector(a, b)
    ac = create_vector(a, c)
    cross = get_3d_vectors_cross(ab, ac)
    return is_zero_vector(cross, accuracy)
def test_are_collinear():
    p1 = Point3d(x=0.0, y=0.0, z=0.0)
    p2 = Point3d(x=1.0, y=1.0, z=1.0)
    p3 = Point3d(x=2.0, y=2.0, z=2.0)
    if not are_collinear(p1, p2, p3, 10):
        panic("collinear test failed")
    q3 = Point3d(x=1.0, y=2.0, z=3.0)
    if are_collinear(p1, p2, q3, 10):
        panic("non-collinear test failed")
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        test_are_collinear()
        a = Point3d(x=4.802293498137402, y=3.536233125455244, z=0.0)
        b = Point3d(x=-2.186788107953106, y=-9.24561398001649, z=7.141509524846482)
        c = Point3d(x=1.530169574640268, y=-2.447927606600034, z=3.343487096469054)
        print(_str(are_collinear(a, b, c, 10)))
        d = Point3d(x=2.399001826862445, y=-2.452009976680793, z=4.464656666157666)
        e = Point3d(x=-3.682816335934376, y=5.753788986533145, z=9.490993909044244)
        f = Point3d(x=1.962903518985307, y=3.741415730125627, z=7.0)
        print(_str(are_collinear(d, e, f, 10)))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
