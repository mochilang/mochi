# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-09 10:22 +0700
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    def abs_float(x):
        if x < 0.0:
            return -x
        else:
            return x
    def validate_inputs(x_initials, step_size, x_final):
        if x_initials[len(x_initials) - 1] >= x_final:
            panic("The final value of x must be greater than the initial values of x.")
        if step_size <= 0.0:
            panic("Step size must be positive.")
        i = 0
        while i < len(x_initials) - 1:
            diff = x_initials[i + 1] - x_initials[i]
            if abs_float(diff - step_size) > 1e-10:
                panic("x-values must be equally spaced according to step size.")
            i = i + 1
    def list_to_string(xs):
        s = "["
        i = 0
        while i < len(xs):
            s = s + _str(xs[i])
            if i + 1 < len(xs):
                s = s + ", "
            i = i + 1
        s = s + "]"
        return s
    def adams_bashforth_step2(f, x_initials, y_initials, step_size, x_final):
        validate_inputs(x_initials, step_size, x_final)
        if len(x_initials) != 2 or len(y_initials) != 2:
            panic("Insufficient initial points information.")
        x0 = x_initials[0]
        x1 = x_initials[1]
        y = []
        y = _append(y, y_initials[0])
        y = _append(y, y_initials[1])
        n = int(((x_final - x1) / step_size))
        i = 0
        while i < n:
            term = 3.0 * f(x1, y[i + 1]) - f(x0, y[i])
            y_next = y[i + 1] + (step_size / 2.0) * term
            y = _append(y, y_next)
            x0 = x1
            x1 = x1 + step_size
            i = i + 1
        return y
    def adams_bashforth_step3(f, x_initials, y_initials, step_size, x_final):
        validate_inputs(x_initials, step_size, x_final)
        if len(x_initials) != 3 or len(y_initials) != 3:
            panic("Insufficient initial points information.")
        x0 = x_initials[0]
        x1 = x_initials[1]
        x2 = x_initials[2]
        y = []
        y = _append(y, y_initials[0])
        y = _append(y, y_initials[1])
        y = _append(y, y_initials[2])
        n = int(((x_final - x2) / step_size))
        i = 0
        while i <= n:
            term = 23.0 * f(x2, y[i + 2]) - 16.0 * f(x1, y[i + 1]) + 5.0 * f(x0, y[i])
            y_next = y[i + 2] + (step_size / 12.0) * term
            y = _append(y, y_next)
            x0 = x1
            x1 = x2
            x2 = x2 + step_size
            i = i + 1
        return y
    def adams_bashforth_step4(f, x_initials, y_initials, step_size, x_final):
        validate_inputs(x_initials, step_size, x_final)
        if len(x_initials) != 4 or len(y_initials) != 4:
            panic("Insufficient initial points information.")
        x0 = x_initials[0]
        x1 = x_initials[1]
        x2 = x_initials[2]
        x3 = x_initials[3]
        y = []
        y = _append(y, y_initials[0])
        y = _append(y, y_initials[1])
        y = _append(y, y_initials[2])
        y = _append(y, y_initials[3])
        n = int(((x_final - x3) / step_size))
        i = 0
        while i < n:
            term = 55.0 * f(x3, y[i + 3]) - 59.0 * f(x2, y[i + 2]) + 37.0 * f(x1, y[i + 1]) - 9.0 * f(x0, y[i])
            y_next = y[i + 3] + (step_size / 24.0) * term
            y = _append(y, y_next)
            x0 = x1
            x1 = x2
            x2 = x3
            x3 = x3 + step_size
            i = i + 1
        return y
    def adams_bashforth_step5(f, x_initials, y_initials, step_size, x_final):
        validate_inputs(x_initials, step_size, x_final)
        if len(x_initials) != 5 or len(y_initials) != 5:
            panic("Insufficient initial points information.")
        x0 = x_initials[0]
        x1 = x_initials[1]
        x2 = x_initials[2]
        x3 = x_initials[3]
        x4 = x_initials[4]
        y = []
        y = _append(y, y_initials[0])
        y = _append(y, y_initials[1])
        y = _append(y, y_initials[2])
        y = _append(y, y_initials[3])
        y = _append(y, y_initials[4])
        n = int(((x_final - x4) / step_size))
        i = 0
        while i <= n:
            term = 1901.0 * f(x4, y[i + 4]) - 2774.0 * f(x3, y[i + 3]) - 2616.0 * f(x2, y[i + 2]) - 1274.0 * f(x1, y[i + 1]) + 251.0 * f(x0, y[i])
            y_next = y[i + 4] + (step_size / 720.0) * term
            y = _append(y, y_next)
            x0 = x1
            x1 = x2
            x2 = x3
            x3 = x4
            x4 = x4 + step_size
            i = i + 1
        return y
    def f_x(x, y):
        return x
    def f_xy(x, y):
        return x + y
    y2 = adams_bashforth_step2(f_x, [0.0, 0.2], [0.0, 0.0], 0.2, 1.0)
    print(list_to_string(y2))
    y3 = adams_bashforth_step3(f_xy, [0.0, 0.2, 0.4], [0.0, 0.0, 0.04], 0.2, 1.0)
    print(_str(y3[3]))
    y4 = adams_bashforth_step4(f_xy, [0.0, 0.2, 0.4, 0.6], [0.0, 0.0, 0.04, 0.128], 0.2, 1.0)
    print(_str(y4[4]))
    print(_str(y4[5]))
    y5 = adams_bashforth_step5(f_xy, [0.0, 0.2, 0.4, 0.6, 0.8], [0.0, 0.0214, 0.0214, 0.22211, 0.42536], 0.2, 1.0)
    print(_str(y5[len(y5) - 1]))
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

