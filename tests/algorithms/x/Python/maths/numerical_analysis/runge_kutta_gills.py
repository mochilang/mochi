# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 15:42 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def sqrt(x):
    guess = (x / 2.0 if x > 1.0 else 1.0)
    i = 0
    while i < 20:
        guess = 0.5 * (guess + x / guess)
        i = i + 1
    return guess
def runge_kutta_gills(func, x_initial, y_initial, step_size, x_final):
    if x_initial >= x_final:
        panic("The final value of x must be greater than initial value of x.")
    if step_size <= 0.0:
        panic("Step size must be positive.")
    n = int(((x_final - x_initial) / step_size))
    y = []
    i = 0
    while i <= n:
        y = _append(y, 0.0)
        i = i + 1
    y[0] = y_initial
    xi = x_initial
    idx = 0
    root2 = sqrt(2.0)
    while idx < n:
        k1 = step_size * func(xi, y[idx])
        k2 = step_size * func(xi + step_size / 2.0, y[idx] + k1 / 2.0)
        k3 = step_size * func(xi + step_size / 2.0, y[idx] + (-0.5 + 1.0 / root2) * k1 + (1.0 - 1.0 / root2) * k2)
        k4 = step_size * func(xi + step_size, y[idx] - (1.0 / root2) * k2 + (1.0 + 1.0 / root2) * k3)
        y[idx + 1] = y[idx] + (k1 + (2.0 - root2) * k2 + (2.0 + root2) * k3 + k4) / 6.0
        xi = xi + step_size
        idx = idx + 1
    return y
def f1(x, y):
    return (x - y) / 2.0
y1 = runge_kutta_gills(f1, 0.0, 3.0, 0.2, 5.0)
print(str(y1[len(y1) - 1]))
def f2(x, y):
    return x
y2 = runge_kutta_gills(f2, -1.0, 0.0, 0.2, 0.0)
print(str(y2))
