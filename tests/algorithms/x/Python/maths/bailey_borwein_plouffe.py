# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 11:48 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _str(v):
    if isinstance(v, float):
        if abs(v - round(v)) < 1e-9:
            return str(float(round(v)))
        return format(v, ".15g")
    return str(v)

def mod_pow(base, exponent, modulus):
    result = 1
    b = base % modulus
    e = exponent
    while e > 0:
        if e % 2 == 1:
            result = (result * b) % modulus
        b = (b * b) % modulus
        e = e // 2
    return result
def pow_float(base, exponent):
    exp = exponent
    result = 1.0
    if exp < 0:
        exp = -exp
    i = 0
    while i < exp:
        result = result * base
        i = i + 1
    if exponent < 0:
        result = 1.0 / result
    return result
def hex_digit(n):
    if n < 10:
        return _str(n)
    letters = ["a", "b", "c", "d", "e", "f"]
    return letters[n - 10]
def floor_float(x):
    i = int(x)
    if (float(i)) > x:
        i = i - 1
    return float(i)
def subsum(digit_pos_to_extract, denominator_addend, precision):
    total = 0.0
    sum_index = 0
    while sum_index < digit_pos_to_extract + precision:
        denominator = 8 * sum_index + denominator_addend
        if sum_index < digit_pos_to_extract:
            exponent = digit_pos_to_extract - 1 - sum_index
            exponential_term = mod_pow(16, exponent, denominator)
            total = total + (float(exponential_term)) / (float(denominator))
        else:
            exponent = digit_pos_to_extract - 1 - sum_index
            exponential_term = pow_float(16.0, exponent)
            total = total + exponential_term / (float(denominator))
        sum_index = sum_index + 1
    return total
def bailey_borwein_plouffe(digit_position, precision):
    if digit_position <= 0:
        panic("Digit position must be a positive integer")
    if precision < 0:
        panic("Precision must be a nonnegative integer")
    sum_result = 4.0 * subsum(digit_position, 1, precision) - 2.0 * subsum(digit_position, 4, precision) - 1.0 * subsum(digit_position, 5, precision) - 1.0 * subsum(digit_position, 6, precision)
    fraction = sum_result - floor_float(sum_result)
    digit = int((fraction * 16.0))
    hd = hex_digit(digit)
    return hd
digits = ""
i = 1
while i <= 10:
    digits = digits + bailey_borwein_plouffe(i, 1000)
    i = i + 1
print(digits)
print(bailey_borwein_plouffe(5, 10000))

