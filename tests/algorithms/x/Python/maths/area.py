# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 09:58 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    PI = 3.141592653589793
    TWO_PI = 6.283185307179586
    def _mod(x, m):
        return x - (float(int(x // m))) * m
    def sin_approx(x):
        y = _mod(x + PI, TWO_PI) - PI
        y2 = y * y
        y3 = y2 * y
        y5 = y3 * y2
        y7 = y5 * y2
        return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
    def cos_approx(x):
        y = _mod(x + PI, TWO_PI) - PI
        y2 = y * y
        y4 = y2 * y2
        y6 = y4 * y2
        return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
    def tan_approx(x):
        return sin_approx(x) / cos_approx(x)
    def sqrt_approx(x):
        if x <= 0.0:
            return 0.0
        guess = x / 2.0
        i = 0
        while i < 20:
            guess = (guess + x // guess) / 2.0
            i = i + 1
        return guess
    def surface_area_cube(side_length):
        if side_length < 0.0:
            print("ValueError: surface_area_cube() only accepts non-negative values")
            return 0.0
        return 6.0 * side_length * side_length
    def surface_area_cuboid(length, breadth, height):
        if length < 0.0 or breadth < 0.0 or height < 0.0:
            print("ValueError: surface_area_cuboid() only accepts non-negative values")
            return 0.0
        return 2.0 * ((length * breadth) + (breadth * height) + (length * height))
    def surface_area_sphere(radius):
        if radius < 0.0:
            print("ValueError: surface_area_sphere() only accepts non-negative values")
            return 0.0
        return 4.0 * PI * radius * radius
    def surface_area_hemisphere(radius):
        if radius < 0.0:
            print("ValueError: surface_area_hemisphere() only accepts non-negative values")
            return 0.0
        return 3.0 * PI * radius * radius
    def surface_area_cone(radius, height):
        if radius < 0.0 or height < 0.0:
            print("ValueError: surface_area_cone() only accepts non-negative values")
            return 0.0
        slant = sqrt_approx(height * height + radius * radius)
        return PI * radius * (radius + slant)
    def surface_area_conical_frustum(radius1, radius2, height):
        if radius1 < 0.0 or radius2 < 0.0 or height < 0.0:
            print("ValueError: surface_area_conical_frustum() only accepts non-negative values")
            return 0.0
        slant = sqrt_approx(height * height + (radius1 - radius2) * (radius1 - radius2))
        return PI * (slant * (radius1 + radius2) + radius1 * radius1 + radius2 * radius2)
    def surface_area_cylinder(radius, height):
        if radius < 0.0 or height < 0.0:
            print("ValueError: surface_area_cylinder() only accepts non-negative values")
            return 0.0
        return 2.0 * PI * radius * (height + radius)
    def surface_area_torus(torus_radius, tube_radius):
        if torus_radius < 0.0 or tube_radius < 0.0:
            print("ValueError: surface_area_torus() only accepts non-negative values")
            return 0.0
        if torus_radius < tube_radius:
            print("ValueError: surface_area_torus() does not support spindle or self intersecting tori")
            return 0.0
        return 4.0 * PI * PI * torus_radius * tube_radius
    def area_rectangle(length, width):
        if length < 0.0 or width < 0.0:
            print("ValueError: area_rectangle() only accepts non-negative values")
            return 0.0
        return length * width
    def area_square(side_length):
        if side_length < 0.0:
            print("ValueError: area_square() only accepts non-negative values")
            return 0.0
        return side_length * side_length
    def area_triangle(base, height):
        if base < 0.0 or height < 0.0:
            print("ValueError: area_triangle() only accepts non-negative values")
            return 0.0
        return (base * height) / 2.0
    def area_triangle_three_sides(side1, side2, side3):
        if side1 < 0.0 or side2 < 0.0 or side3 < 0.0:
            print("ValueError: area_triangle_three_sides() only accepts non-negative values")
            return 0.0
        if side1 + side2 < side3 or side1 + side3 < side2 or side2 + side3 < side1:
            print("ValueError: Given three sides do not form a triangle")
            return 0.0
        s = (side1 + side2 + side3) / 2.0
        prod = s * (s - side1) * (s - side2) * (s - side3)
        res = sqrt_approx(prod)
        return res
    def area_parallelogram(base, height):
        if base < 0.0 or height < 0.0:
            print("ValueError: area_parallelogram() only accepts non-negative values")
            return 0.0
        return base * height
    def area_trapezium(base1, base2, height):
        if base1 < 0.0 or base2 < 0.0 or height < 0.0:
            print("ValueError: area_trapezium() only accepts non-negative values")
            return 0.0
        return 0.5 * (base1 + base2) * height
    def area_circle(radius):
        if radius < 0.0:
            print("ValueError: area_circle() only accepts non-negative values")
            return 0.0
        return PI * radius * radius
    def area_ellipse(radius_x, radius_y):
        if radius_x < 0.0 or radius_y < 0.0:
            print("ValueError: area_ellipse() only accepts non-negative values")
            return 0.0
        return PI * radius_x * radius_y
    def area_rhombus(diagonal1, diagonal2):
        if diagonal1 < 0.0 or diagonal2 < 0.0:
            print("ValueError: area_rhombus() only accepts non-negative values")
            return 0.0
        return 0.5 * diagonal1 * diagonal2
    def area_reg_polygon(sides, length):
        if sides < 3:
            print("ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides")
            return 0.0
        if length < 0.0:
            print("ValueError: area_reg_polygon() only accepts non-negative values as length of a side")
            return 0.0
        n = float(sides)
        return (n * length * length) // (4.0 * tan_approx(PI / n))
    print("[DEMO] Areas of various geometric shapes:")
    print("Rectangle: " + str(area_rectangle(10.0, 20.0)))
    print("Square: " + str(area_square(10.0)))
    print("Triangle: " + str(area_triangle(10.0, 10.0)))
    TRI_THREE_SIDES = area_triangle_three_sides(5.0, 12.0, 13.0)
    print("Triangle Three Sides: " + str(TRI_THREE_SIDES))
    print("Parallelogram: " + str(area_parallelogram(10.0, 20.0)))
    print("Rhombus: " + str(area_rhombus(10.0, 20.0)))
    print("Trapezium: " + str(area_trapezium(10.0, 20.0, 30.0)))
    print("Circle: " + str(area_circle(20.0)))
    print("Ellipse: " + str(area_ellipse(10.0, 20.0)))
    print("")
    print("Surface Areas of various geometric shapes:")
    print("Cube: " + str(surface_area_cube(20.0)))
    print("Cuboid: " + str(surface_area_cuboid(10.0, 20.0, 30.0)))
    print("Sphere: " + str(surface_area_sphere(20.0)))
    print("Hemisphere: " + str(surface_area_hemisphere(20.0)))
    print("Cone: " + str(surface_area_cone(10.0, 20.0)))
    print("Conical Frustum: " + str(surface_area_conical_frustum(10.0, 20.0, 30.0)))
    print("Cylinder: " + str(surface_area_cylinder(10.0, 20.0)))
    print("Torus: " + str(surface_area_torus(20.0, 10.0)))
    print("Equilateral Triangle: " + str(area_reg_polygon(3, 10.0)))
    print("Square: " + str(area_reg_polygon(4, 10.0)))
    print("Regular Pentagon: " + str(area_reg_polygon(5, 10.0)))
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
