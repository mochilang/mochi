# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 14:44 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _str(v):
    import builtins
    if isinstance(v, float):
        if abs(v - builtins.round(v)) < 1e-9:
            return builtins.str(float(builtins.round(v)))
        return builtins.format(v, ".15g")
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    def log2(x):
        k = 0.0
        v = x
        while v >= 2.0:
            v = v / 2.0
            k = k + 1.0
        while v < 1.0:
            v = v * 2.0
            k = k - 1.0
        z = (v - 1.0) / (v + 1.0)
        zpow = z
        sum_ = z
        i = 3
        while i <= 9:
            zpow = zpow * z * z
            sum_ = sum_ + zpow / (float(i))
            i = i + 2
        ln2 = 0.6931471805599453
        return k + 2.0 * sum_ / ln2
    @dataclass
    class TextCounts:
        single: Dict[str, int]
        double: Dict[str, int]
    def analyze_text(text):
        single = {}
        double = {}
        n = len(text)
        if n == 0:
            return TextCounts(single=single, double=double)
        last = text[n - 1:n]
        if last in single:
            single[last] = single.get(last, None) + 1
        else:
            single[last] = 1
        first = text[0:1]
        pair0 = " " + first
        double[pair0] = 1
        i = 0
        while i < n - 1:
            ch = text[i:i + 1]
            if ch in single:
                single[ch] = single.get(ch, None) + 1
            else:
                single[ch] = 1
            seq = text[i:i + 2]
            if seq in double:
                double[seq] = double.get(seq, None) + 1
            else:
                double[seq] = 1
            i = i + 1
        return TextCounts(single=single, double=double)
    def round_to_int(x):
        if x < 0.0:
            return int((x - 0.5))
        return int((x + 0.5))
    def calculate_entropy(text):
        counts = analyze_text(text)
        alphas = " abcdefghijklmnopqrstuvwxyz"
        total1 = 0
        for ch in counts.single:
            total1 = total1 + counts.single.get(ch, 0)
        h1 = 0.0
        i = 0
        while i < len(alphas):
            ch = alphas[i:i + 1]
            if ch in counts.single:
                prob = (float(counts.single.get(ch, 0))) / (float(total1))
                h1 = h1 + prob * log2(prob)
            i = i + 1
        first_entropy = -h1
        print(_str(round_to_int(first_entropy)) + ".0")
        total2 = 0
        for seq in counts.double:
            total2 = total2 + counts.double.get(seq, 0)
        h2 = 0.0
        a0 = 0
        while a0 < len(alphas):
            ch0 = alphas[a0:a0 + 1]
            a1 = 0
            while a1 < len(alphas):
                ch1 = alphas[a1:a1 + 1]
                seq = ch0 + ch1
                if seq in counts.double:
                    prob = (float(counts.double.get(seq, 0))) / (float(total2))
                    h2 = h2 + prob * log2(prob)
                a1 = a1 + 1
            a0 = a0 + 1
        second_entropy = -h2
        print(_str(round_to_int(second_entropy)) + ".0")
        diff = second_entropy - first_entropy
        print(_str(round_to_int(diff)) + ".0")
    text1 = "Behind Winston's back the voice " + "from the telescreen was still " + "babbling and the overfulfilment"
    calculate_entropy(text1)
    text3 = "Had repulsive dashwoods suspicion sincerity but advantage now him. " + "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. " + "You greatest jointure saw horrible. He private he on be imagine " + "suppose. Fertile beloved evident through no service elderly is. Blind " + "there if every no so at. Own neglected you preferred way sincerity " + "delivered his attempted. To of message cottage windows do besides " + "against uncivil.  Delightful unreserved impossible few estimating " + "men favourable see entreaties. She propriety immediate was improving. " + "He or entrance humoured likewise moderate. Much nor game son say " + "feel. Fat make met can must form into gate. Me we offending prevailed " + "discovery."
    calculate_entropy(text3)
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

