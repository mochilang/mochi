# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 11:48 +0700
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if abs(v - round(v)) < 1e-9:
            return str(float(round(v)))
        return format(v, ".15g")
    return str(v)

def pow_int(base, exp):
    result = 1
    i = 0
    while i < exp:
        result = result * base
        i = i + 1
    return result
def prime_factors(n):
    if n <= 0:
        panic("Only positive integers have prime factors")
    num = n
    pf = []
    while num % 2 == 0:
        pf = _append(pf, 2)
        num = num // 2
    i = 3
    while i * i <= num:
        while num % i == 0:
            pf = _append(pf, i)
            num = num // i
        i = i + 2
    if num > 2:
        pf = _append(pf, num)
    return pf
def number_of_divisors(n):
    if n <= 0:
        panic("Only positive numbers are accepted")
    num = n
    div = 1
    temp = 1
    while num % 2 == 0:
        temp = temp + 1
        num = num // 2
    div = div * temp
    i = 3
    while i * i <= num:
        temp = 1
        while num % i == 0:
            temp = temp + 1
            num = num // i
        div = div * temp
        i = i + 2
    if num > 1:
        div = div * 2
    return div
def sum_of_divisors(n):
    if n <= 0:
        panic("Only positive numbers are accepted")
    num = n
    s = 1
    temp = 1
    while num % 2 == 0:
        temp = temp + 1
        num = num // 2
    if temp > 1:
        s = s * ((pow_int(2, temp) - 1) // (2 - 1))
    i = 3
    while i * i <= num:
        temp = 1
        while num % i == 0:
            temp = temp + 1
            num = num // i
        if temp > 1:
            s = s * ((pow_int(i, temp) - 1) / (i - 1))
        i = i + 2
    return s
def contains(arr, x):
    idx = 0
    while idx < len(arr):
        if arr[idx] == x:
            return True
        idx = idx + 1
    return False
def unique(arr):
    result = []
    idx = 0
    while idx < len(arr):
        v = arr[idx]
        if not contains(result, v):
            result = _append(result, v)
        idx = idx + 1
    return result
def euler_phi(n):
    if n <= 0:
        panic("Only positive numbers are accepted")
    s = n
    factors = unique(prime_factors(n))
    idx = 0
    while idx < len(factors):
        x = factors[idx]
        s = (s // x) * (x - 1)
        idx = idx + 1
    return s
print(_str(prime_factors(100)))
print(_str(number_of_divisors(100)))
print(_str(sum_of_divisors(100)))
print(_str(euler_phi(100)))

