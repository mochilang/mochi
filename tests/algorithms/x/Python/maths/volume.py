# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 17:13 +0700
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)

PI = 3.141592653589793
SQRT5 = 2.23606797749979
def minf(a, b):
    if a < b:
        return a
    return b
def maxf(a, b):
    if a > b:
        return a
    return b
def vol_cube(side_length):
    if side_length < 0.0:
        panic("vol_cube() only accepts non-negative values")
    return side_length * side_length * side_length
def vol_spherical_cap(height, radius):
    if height < 0.0 or radius < 0.0:
        panic("vol_spherical_cap() only accepts non-negative values")
    return (1.0 / 3.0) * PI * height * height * (3.0 * radius - height)
def vol_sphere(radius):
    if radius < 0.0:
        panic("vol_sphere() only accepts non-negative values")
    return (4.0 / 3.0) * PI * radius * radius * radius
def vol_spheres_intersect(radius_1, radius_2, centers_distance):
    if radius_1 < 0.0 or radius_2 < 0.0 or centers_distance < 0.0:
        panic("vol_spheres_intersect() only accepts non-negative values")
    if centers_distance == 0.0:
        return vol_sphere(minf(radius_1, radius_2))
    h1 = (radius_1 - radius_2 + centers_distance) * (radius_1 + radius_2 - centers_distance) / (2.0 * centers_distance)
    h2 = (radius_2 - radius_1 + centers_distance) * (radius_2 + radius_1 - centers_distance) / (2.0 * centers_distance)
    return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)
def vol_spheres_union(radius_1, radius_2, centers_distance):
    if radius_1 <= 0.0 or radius_2 <= 0.0 or centers_distance < 0.0:
        panic("vol_spheres_union() only accepts non-negative values, non-zero radius")
    if centers_distance == 0.0:
        return vol_sphere(maxf(radius_1, radius_2))
    return vol_sphere(radius_1) + vol_sphere(radius_2) - vol_spheres_intersect(radius_1, radius_2, centers_distance)
def vol_cuboid(width, height, length):
    if width < 0.0 or height < 0.0 or length < 0.0:
        panic("vol_cuboid() only accepts non-negative values")
    return width * height * length
def vol_cone(area_of_base, height):
    if height < 0.0 or area_of_base < 0.0:
        panic("vol_cone() only accepts non-negative values")
    return area_of_base * height / 3.0
def vol_right_circ_cone(radius, height):
    if height < 0.0 or radius < 0.0:
        panic("vol_right_circ_cone() only accepts non-negative values")
    return PI * radius * radius * height / 3.0
def vol_prism(area_of_base, height):
    if height < 0.0 or area_of_base < 0.0:
        panic("vol_prism() only accepts non-negative values")
    return area_of_base * height
def vol_pyramid(area_of_base, height):
    if height < 0.0 or area_of_base < 0.0:
        panic("vol_pyramid() only accepts non-negative values")
    return area_of_base * height / 3.0
def vol_hemisphere(radius):
    if radius < 0.0:
        panic("vol_hemisphere() only accepts non-negative values")
    return radius * radius * radius * PI * 2.0 / 3.0
def vol_circular_cylinder(radius, height):
    if height < 0.0 or radius < 0.0:
        panic("vol_circular_cylinder() only accepts non-negative values")
    return radius * radius * height * PI
def vol_hollow_circular_cylinder(inner_radius, outer_radius, height):
    if inner_radius < 0.0 or outer_radius < 0.0 or height < 0.0:
        panic("vol_hollow_circular_cylinder() only accepts non-negative values")
    if outer_radius <= inner_radius:
        panic("outer_radius must be greater than inner_radius")
    return PI * (outer_radius * outer_radius - inner_radius * inner_radius) * height
def vol_conical_frustum(height, radius_1, radius_2):
    if radius_1 < 0.0 or radius_2 < 0.0 or height < 0.0:
        panic("vol_conical_frustum() only accepts non-negative values")
    return (1.0 / 3.0) * PI * height * (radius_1 * radius_1 + radius_2 * radius_2 + radius_1 * radius_2)
def vol_torus(torus_radius, tube_radius):
    if torus_radius < 0.0 or tube_radius < 0.0:
        panic("vol_torus() only accepts non-negative values")
    return 2.0 * PI * PI * torus_radius * tube_radius * tube_radius
def vol_icosahedron(tri_side):
    if tri_side < 0.0:
        panic("vol_icosahedron() only accepts non-negative values")
    return tri_side * tri_side * tri_side * (3.0 + SQRT5) * 5.0 / 12.0
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        print("Volumes:")
        print("Cube: " + _str(vol_cube(2.0)))
        print("Cuboid: " + _str(vol_cuboid(2.0, 2.0, 2.0)))
        print("Cone: " + _str(vol_cone(2.0, 2.0)))
        print("Right Circular Cone: " + _str(vol_right_circ_cone(2.0, 2.0)))
        print("Prism: " + _str(vol_prism(2.0, 2.0)))
        print("Pyramid: " + _str(vol_pyramid(2.0, 2.0)))
        print("Sphere: " + _str(vol_sphere(2.0)))
        print("Hemisphere: " + _str(vol_hemisphere(2.0)))
        print("Circular Cylinder: " + _str(vol_circular_cylinder(2.0, 2.0)))
        print("Torus: " + _str(vol_torus(2.0, 2.0)))
        print("Conical Frustum: " + _str(vol_conical_frustum(2.0, 2.0, 4.0)))
        print("Spherical cap: " + _str(vol_spherical_cap(1.0, 2.0)))
        print("Spheres intersection: " + _str(vol_spheres_intersect(2.0, 2.0, 1.0)))
        print("Spheres union: " + _str(vol_spheres_union(2.0, 2.0, 1.0)))
        print("Hollow Circular Cylinder: " + _str(vol_hollow_circular_cylinder(1.0, 2.0, 3.0)))
        print("Icosahedron: " + _str(vol_icosahedron(2.5)))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
