# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 16:09 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Polynomial:
    degree: int
    coefficients: [float]

def copy_list(xs):
    res = []
    i = 0
    while i < len(xs):
        res = _append(res, xs[i])
        i = i + 1
    return res
def polynomial_new(degree, coeffs):
    if len(coeffs) != degree + 1:
        panic("The number of coefficients should be equal to the degree + 1.")
    return Polynomial(degree=degree, coefficients=copy_list(coeffs))
def add(p, q):
    if p.degree > q.degree:
        coeffs = copy_list(p.coefficients)
        i = 0
        while i <= q.degree:
            coeffs[i] = coeffs[i] + q.coefficients[i]
            i = i + 1
        return Polynomial(degree=p.degree, coefficients=coeffs)
    else:
        coeffs = copy_list(q.coefficients)
        i = 0
        while i <= p.degree:
            coeffs[i] = coeffs[i] + p.coefficients[i]
            i = i + 1
        return Polynomial(degree=q.degree, coefficients=coeffs)
def neg(p):
    coeffs = []
    i = 0
    while i <= p.degree:
        coeffs = _append(coeffs, -p.coefficients[i])
        i = i + 1
    return Polynomial(degree=p.degree, coefficients=coeffs)
def sub(p, q):
    return add(p, neg(q))
def mul(p, q):
    size = p.degree + q.degree + 1
    coeffs = []
    i = 0
    while i < size:
        coeffs = _append(coeffs, 0.0)
        i = i + 1
    i = 0
    while i <= p.degree:
        j = 0
        while j <= q.degree:
            coeffs[i + j] = coeffs[i + j] + p.coefficients[i] * q.coefficients[j]
            j = j + 1
        i = i + 1
    return Polynomial(degree=p.degree + q.degree, coefficients=coeffs)
def power(base, exp):
    result = 1.0
    i = 0
    while i < exp:
        result = result * base
        i = i + 1
    return result
def evaluate(p, x):
    result = 0.0
    i = 0
    while i <= p.degree:
        result = result + p.coefficients[i] * power(x, i)
        i = i + 1
    return result
def poly_to_string(p):
    s = ""
    i = p.degree
    while i >= 0:
        coeff = p.coefficients[i]
        if coeff != 0.0:
            if len(s) > 0:
                if coeff > 0.0:
                    s = s + " + "
                else:
                    s = s + " - "
            else:
                if coeff < 0.0:
                    s = s + "-"
            abs_coeff = (-coeff if coeff < 0.0 else coeff)
            if i == 0:
                s = s + _str(abs_coeff)
            else:
                if i == 1:
                    s = s + _str(abs_coeff) + "x"
                else:
                    s = s + _str(abs_coeff) + "x^" + _str(i)
        i = i - 1
    if s == "":
        s = "0"
    return s
def derivative(p):
    if p.degree == 0:
        return Polynomial(degree=0, coefficients=[0.0])
    coeffs = []
    i = 0
    while i < p.degree:
        coeffs = _append(coeffs, p.coefficients[i + 1] * float(i + 1))
        i = i + 1
    return Polynomial(degree=p.degree - 1, coefficients=coeffs)
def integral(p, constant):
    coeffs = [constant]
    i = 0
    while i <= p.degree:
        coeffs = _append(coeffs, p.coefficients[i] / float(i + 1))
        i = i + 1
    return Polynomial(degree=p.degree + 1, coefficients=coeffs)
def equals(p, q):
    if p.degree != q.degree:
        return False
    i = 0
    while i <= p.degree:
        if p.coefficients[i] != q.coefficients[i]:
            return False
        i = i + 1
    return True
def not_equals(p, q):
    return not equals(p, q)
def test_polynomial():
    p = polynomial_new(2, [1.0, 2.0, 3.0])
    q = polynomial_new(2, [1.0, 2.0, 3.0])
    if poly_to_string(add(p, q)) != "6x^2 + 4x + 2":
        panic("add failed")
    if poly_to_string(sub(p, q)) != "0":
        panic("sub failed")
    if evaluate(p, 2.0) != 17.0:
        panic("evaluate failed")
    if poly_to_string(derivative(p)) != "6x + 2":
        panic("derivative failed")
    integ = poly_to_string(integral(p, 0.0))
    if integ != "1x^3 + 1x^2 + 1x":
        panic("integral failed")
    if not equals(p, q):
        panic("equals failed")
    if not_equals(p, q):
        panic("not_equals failed")
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        test_polynomial()
        p = polynomial_new(2, [1.0, 2.0, 3.0])
        d = derivative(p)
        print(poly_to_string(d))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
