# Code generated by Mochi transpiler.
# Version 0.10.61, generated on 2025-08-08 16:09 +0700
import json
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float) and v.is_integer():
        return str(int(v))
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def floor(x):
    i = int(x)
    if (float(i)) > x:
        i = i - 1
    return float(i)
def pow10(n):
    p = 1.0
    i = 0
    while i < n:
        p = p * 10.0
        i = i + 1
    return p
def round(x, n):
    m = pow10(n)
    return floor(x * m + 0.5) / m
def clone_matrix(mat):
    new_mat = []
    i = 0
    while i < len(mat):
        row = []
        j = 0
        while j < len(mat[i]):
            row = _append(row, mat[i][j])
            j = j + 1
        new_mat = _append(new_mat, row)
        i = i + 1
    return new_mat
def solve_simultaneous(equations):
    n = len(equations)
    if n == 0:
        panic("solve_simultaneous() requires n lists of length n+1")
    m = n + 1
    i = 0
    while i < n:
        if len(equations[i]) != m:
            panic("solve_simultaneous() requires n lists of length n+1")
        i = i + 1
    a = clone_matrix(equations)
    row = 0
    while row < n:
        pivot = row
        while pivot < n and a[pivot][row] == 0.0:
            pivot = pivot + 1
        if pivot == n:
            panic("solve_simultaneous() requires at least 1 full equation")
        if pivot != row:
            temp = a[row]
            a[row] = a[pivot]
            a[pivot] = temp
        pivot_val = a[row][row]
        col = 0
        while col < m:
            a[row][col] = a[row][col] / pivot_val
            col = col + 1
        r = 0
        while r < n:
            if r != row:
                factor = a[r][row]
                c = 0
                while c < m:
                    a[r][c] = a[r][c] - factor * a[row][c]
                    c = c + 1
            r = r + 1
        row = row + 1
    res = []
    k = 0
    while k < n:
        res = _append(res, round(a[k][m - 1], 5))
        k = k + 1
    return res
def test_solver():
    a = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
    r1 = solve_simultaneous(a)
    if not (len(r1) == 2 and r1[0] == (0.0 - 1.0) and r1[1] == 2.0):
        panic("test1 failed")
    b = [[0.0, (0.0 - 3.0), 1.0, 7.0], [3.0, 2.0, (0.0 - 1.0), 11.0], [5.0, 1.0, (0.0 - 2.0), 12.0]]
    r2 = solve_simultaneous(b)
    if not (len(r2) == 3 and r2[0] == 6.4 and r2[1] == 1.2 and r2[2] == 10.6):
        panic("test2 failed")
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        test_solver()
        eq = [[2.0, 1.0, 1.0, 1.0, 1.0, 4.0], [1.0, 2.0, 1.0, 1.0, 1.0, 5.0], [1.0, 1.0, 2.0, 1.0, 1.0, 6.0], [1.0, 1.0, 1.0, 2.0, 1.0, 7.0], [1.0, 1.0, 1.0, 1.0, 2.0, 8.0]]
        print(_str(solve_simultaneous(eq)))
        print(_str(solve_simultaneous([[4.0, 2.0]])))
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
