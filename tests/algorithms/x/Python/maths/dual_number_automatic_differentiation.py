# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 09:58 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Dual:
    real: float
    duals: [float]

def make_dual(real, rank):
    ds = []
    i = 0
    while i < rank:
        ds = _append(ds, 1.0)
        i = i + 1
    return Dual(real=real, duals=ds)
def dual_from_list(real, ds):
    return Dual(real=real, duals=ds)
def dual_add(a, b):
    s_dual = []
    i = 0
    while i < len(a.duals):
        s_dual = _append(s_dual, a.duals[i])
        i = i + 1
    o_dual = []
    j = 0
    while j < len(b.duals):
        o_dual = _append(o_dual, b.duals[j])
        j = j + 1
    if len(s_dual) > len(o_dual):
        diff = len(s_dual) - len(o_dual)
        k = 0
        while k < diff:
            o_dual = _append(o_dual, 1.0)
            k = k + 1
    else:
        if len(s_dual) < len(o_dual):
            diff2 = len(o_dual) - len(s_dual)
            k2 = 0
            while k2 < diff2:
                s_dual = _append(s_dual, 1.0)
                k2 = k2 + 1
    new_duals = []
    idx = 0
    while idx < len(s_dual):
        new_duals = _append(new_duals, s_dual[idx] + o_dual[idx])
        idx = idx + 1
    return Dual(real=a.real + b.real, duals=new_duals)
def dual_add_real(a, b):
    ds = []
    i = 0
    while i < len(a.duals):
        ds = _append(ds, a.duals[i])
        i = i + 1
    return Dual(real=a.real + b, duals=ds)
def dual_mul(a, b):
    new_len = len(a.duals) + len(b.duals) + 1
    new_duals = []
    idx = 0
    while idx < new_len:
        new_duals = _append(new_duals, 0.0)
        idx = idx + 1
    i = 0
    while i < len(a.duals):
        j = 0
        while j < len(b.duals):
            pos = i + j + 1
            val = new_duals[pos] + a.duals[i] * b.duals[j]
            new_duals[pos] = val
            j = j + 1
        i = i + 1
    k = 0
    while k < len(a.duals):
        val = new_duals[k] + a.duals[k] * b.real
        new_duals[k] = val
        k = k + 1
    l = 0
    while l < len(b.duals):
        val = new_duals[l] + b.duals[l] * a.real
        new_duals[l] = val
        l = l + 1
    return Dual(real=a.real * b.real, duals=new_duals)
def dual_mul_real(a, b):
    ds = []
    i = 0
    while i < len(a.duals):
        ds = _append(ds, a.duals[i] * b)
        i = i + 1
    return Dual(real=a.real * b, duals=ds)
def dual_pow(x, n):
    if n < 0:
        panic("power must be a positive integer")
    if n == 0:
        return Dual(real=1.0, duals=[])
    res = x
    i = 1
    while i < n:
        res = dual_mul(res, x)
        i = i + 1
    return res
def factorial(n):
    res = 1.0
    i = 2
    while i <= n:
        res = res * (float(i))
        i = i + 1
    return res
def differentiate(func, position, order):
    d = make_dual(position, 1)
    result = func(d)
    if order == 0:
        return result.real
    return result.duals[order - 1] * factorial(order)
def test_differentiate():
    def f1(x):
        return dual_pow(x, 2)
    if differentiate(f1, 2.0, 2) != 2.0:
        panic("f1 failed")
    def f2(x):
        return dual_mul(dual_pow(x, 2), dual_pow(x, 4))
    if differentiate(f2, 9.0, 2) != 196830.0:
        panic("f2 failed")
    def f3(y):
        return dual_mul_real(dual_pow(dual_add_real(y, 3.0), 6), 0.5)
    if differentiate(f3, 3.5, 4) != 7605.0:
        panic("f3 failed")
    def f4(y):
        return dual_pow(y, 2)
    if differentiate(f4, 4.0, 3) != 0.0:
        panic("f4 failed")
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        test_differentiate()
        def f(y):
            return dual_mul(dual_pow(y, 2), dual_pow(y, 4))
        res = differentiate(f, 9.0, 2)
        print(res)
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
