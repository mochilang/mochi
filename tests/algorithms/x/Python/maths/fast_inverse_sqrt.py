# Code generated by Mochi transpiler.
# Version 0.10.59, generated on 2025-08-07 09:58 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

def pow2_int(n):
    result = 1
    i = 0
    while i < n:
        result = result * 2
        i = i + 1
    return result
def pow2_float(n):
    result = 1.0
    if n >= 0:
        i = 0
        while i < n:
            result = result * 2.0
            i = i + 1
    else:
        i = 0
        m = 0 - n
        while i < m:
            result = result / 2.0
            i = i + 1
    return result
def lshift(num, k):
    result = num
    i = 0
    while i < k:
        result = result * 2
        i = i + 1
    return result
def rshift(num, k):
    result = num
    i = 0
    while i < k:
        result = (result - (result % 2)) // 2
        i = i + 1
    return result
def log2_floor(x):
    n = x
    e = 0
    while n >= 2.0:
        n = n / 2.0
        e = e + 1
    while n < 1.0:
        n = n * 2.0
        e = e - 1
    return e
def float_to_bits(x):
    num = x
    sign = 0
    if num < 0.0:
        sign = 1
        num = -num
    exp = log2_floor(num)
    pow = pow2_float(exp)
    normalized = num // pow
    frac = normalized - 1.0
    mantissa = int((frac * pow2_float(23)))
    exp_bits = exp + 127
    return lshift(sign, 31) + lshift(exp_bits, 23) + mantissa
def bits_to_float(bits):
    sign_bit = rshift(bits, 31) % 2
    sign = 1.0
    if sign_bit == 1:
        sign = -1.0
    exp_bits = rshift(bits, 23) % 256
    exp = exp_bits - 127
    mantissa_bits = bits % pow2_int(23)
    mantissa = 1.0 + (float(mantissa_bits)) / pow2_float(23)
    return sign * mantissa * pow2_float(exp)
def absf(x):
    if x < 0.0:
        return -x
    return x
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x / 2.0
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def is_close(a, b, rel_tol):
    return absf(a - b) <= rel_tol * absf(b)
def fast_inverse_sqrt(number):
    if number <= 0.0:
        panic("Input must be a positive number.")
    i = float_to_bits(number)
    magic = 1597463007
    y_bits = magic - rshift(i, 1)
    y = bits_to_float(y_bits)
    y = y * (1.5 - 0.5 * number * y * y)
    return y
def test_fast_inverse_sqrt():
    if absf(fast_inverse_sqrt(10.0) - 0.3156857923527257) > 0.0001:
        panic("fast_inverse_sqrt(10) failed")
    if absf(fast_inverse_sqrt(4.0) - 0.49915357479239103) > 0.0001:
        panic("fast_inverse_sqrt(4) failed")
    if absf(fast_inverse_sqrt(4.1) - 0.4932849504615651) > 0.0001:
        panic("fast_inverse_sqrt(4.1) failed")
    i = 50
    while i < 60:
        y = fast_inverse_sqrt(float(i))
        actual = 1.0 / sqrtApprox(float(i))
        if not is_close(y, actual, 0.00132):
            panic("relative error too high")
        i = i + 1
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        test_fast_inverse_sqrt()
        i = 5
        while i <= 100:
            diff = (1.0 / sqrtApprox(float(i))) - fast_inverse_sqrt(float(i))
            print(str(i) + ": " + str(diff))
            i = i + 5
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
