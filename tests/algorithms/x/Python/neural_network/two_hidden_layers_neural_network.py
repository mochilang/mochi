# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-16 09:25 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Network:
    w1: [[float]]
    w2: [[float]]
    w3: [[float]]

def exp_approx(x):
    sum_ = 1.0
    term = 1.0
    i = 1
    while i < 10:
        term = term * x / float(i)
        sum_ = sum_ + term
        i = i + 1
    return sum_
def sigmoid(x):
    return 1.0 / (1.0 + exp_approx(-x))
def sigmoid_derivative(x):
    return x * (1.0 - x)
def new_network():
    return Network(w1=[[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8], [0.9, 1.0, 1.1, 1.2]], w2=[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.0, 1.1, 1.2]], w3=[[0.1], [0.2], [0.3]])
def feedforward(net, input_):
    hidden1 = []
    j = 0
    while j < 4:
        sum1 = 0.0
        i = 0
        while i < 3:
            sum1 = sum1 + input_[i] * net.w1[i][j]
            i = i + 1
        hidden1 = _append(hidden1, sigmoid(sum1))
        j = j + 1
    hidden2 = []
    k = 0
    while k < 3:
        sum2 = 0.0
        j2 = 0
        while j2 < 4:
            sum2 = sum2 + hidden1[j2] * net.w2[j2][k]
            j2 = j2 + 1
        hidden2 = _append(hidden2, sigmoid(sum2))
        k = k + 1
    sum3 = 0.0
    k2 = 0
    while k2 < 3:
        sum3 = sum3 + hidden2[k2] * net.w3[k2][0]
        k2 = k2 + 1
    out = sigmoid(sum3)
    return out
def train(net, inputs, outputs, iterations):
    iter_ = 0
    while iter_ < iterations:
        s = 0
        while s < len(inputs):
            inp = inputs[s]
            target = outputs[s]
            hidden1 = []
            j = 0
            while j < 4:
                sum1 = 0.0
                i = 0
                while i < 3:
                    sum1 = sum1 + inp[i] * net.w1[i][j]
                    i = i + 1
                hidden1 = _append(hidden1, sigmoid(sum1))
                j = j + 1
            hidden2 = []
            k = 0
            while k < 3:
                sum2 = 0.0
                j2 = 0
                while j2 < 4:
                    sum2 = sum2 + hidden1[j2] * net.w2[j2][k]
                    j2 = j2 + 1
                hidden2 = _append(hidden2, sigmoid(sum2))
                k = k + 1
            sum3 = 0.0
            k3 = 0
            while k3 < 3:
                sum3 = sum3 + hidden2[k3] * net.w3[k3][0]
                k3 = k3 + 1
            output = sigmoid(sum3)
            error = target - output
            delta_output = error * sigmoid_derivative(output)
            new_w3 = []
            k4 = 0
            while k4 < 3:
                w3row = net.w3[k4]
                w3row[0] = w3row[0] + hidden2[k4] * delta_output
                new_w3 = _append(new_w3, w3row)
                k4 = k4 + 1
            net.w3 = new_w3
            delta_hidden2 = []
            k5 = 0
            while k5 < 3:
                row = net.w3[k5]
                dh2 = row[0] * delta_output * sigmoid_derivative(hidden2[k5])
                delta_hidden2 = _append(delta_hidden2, dh2)
                k5 = k5 + 1
            new_w2 = []
            j = 0
            while j < 4:
                w2row = net.w2[j]
                k6 = 0
                while k6 < 3:
                    w2row[k6] = w2row[k6] + hidden1[j] * delta_hidden2[k6]
                    k6 = k6 + 1
                new_w2 = _append(new_w2, w2row)
                j = j + 1
            net.w2 = new_w2
            delta_hidden1 = []
            j = 0
            while j < 4:
                sumdh = 0.0
                k7 = 0
                while k7 < 3:
                    row2 = net.w2[j]
                    sumdh = sumdh + row2[k7] * delta_hidden2[k7]
                    k7 = k7 + 1
                delta_hidden1 = _append(delta_hidden1, sumdh * sigmoid_derivative(hidden1[j]))
                j = j + 1
            new_w1 = []
            i2 = 0
            while i2 < 3:
                w1row = net.w1[i2]
                j = 0
                while j < 4:
                    w1row[j] = w1row[j] + inp[i2] * delta_hidden1[j]
                    j = j + 1
                new_w1 = _append(new_w1, w1row)
                i2 = i2 + 1
            net.w1 = new_w1
            s = s + 1
        iter_ = iter_ + 1
def predict(net, input_):
    out = feedforward(net, input_)
    if out > 0.6:
        return 1
    return 0
def example():
    inputs = [[0.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [0.0, 1.0, 1.0], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [1.0, 1.0, 0.0], [1.0, 1.0, 1.0]]
    outputs = [0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0]
    net = new_network()
    train(net, inputs, outputs, 10)
    result = predict(net, [1.0, 1.0, 1.0])
    print(_str(result))
    return result
def main():
    if resource:
        _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_start = 0
    _bench_start = _now()
    try:
        example()
    finally:
        _bench_end = _now()
        if resource:
            _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        else:
            _bench_mem_end = 0
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()

