# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def index_of(s, ch):
    i = 0
    while i < len(s):
        if s[i] == ch:
            return i
        i = i + 1
    return -1
def ord(ch):
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    idx = index_of(upper, ch)
    if idx >= 0:
        return 65 + idx
    idx = index_of(lower, ch)
    if idx >= 0:
        return 97 + idx
    return 0
def chr(n):
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    if n >= 65 and n < 91:
        return upper[n - 65:n - 64]
    if n >= 97 and n < 123:
        return lower[n - 97:n - 96]
    return "?"
def text_to_bits(text):
    bits = ""
    i = 0
    while i < len(text):
        code = ord(text[i])
        j = 7
        while j >= 0:
            p = pow2(j)
            if ((code // p) % 2) == 1:
                bits = bits + "1"
            else:
                bits = bits + "0"
            j = j - 1
        i = i + 1
    return bits
def text_from_bits(bits):
    text = ""
    i = 0
    while i < len(bits):
        code = 0
        j = 0
        while j < 8 and i + j < len(bits):
            code = code * 2
            if bits[i + j] == "1":
                code = code + 1
            j = j + 1
        text = text + chr(code)
        i = i + 8
    return text
def bool_to_string(b):
    if b:
        return "True"
    return "False"
def string_to_bitlist(s):
    res = []
    i = 0
    while i < len(s):
        if s[i] == "1":
            res = _append(res, 1)
        else:
            res = _append(res, 0)
        i = i + 1
    return res
def bitlist_to_string(bits):
    s = ""
    i = 0
    while i < len(bits):
        if bits[i] == 1:
            s = s + "1"
        else:
            s = s + "0"
        i = i + 1
    return s
def is_power_of_two(x):
    if x < 1:
        return False
    p = 1
    while p < x:
        p = p * 2
    return p == x
def list_eq(a, b):
    if len(a) != len(b):
        return False
    i = 0
    while i < len(a):
        if a[i] != b[i]:
            return False
        i = i + 1
    return True
def pow2(e):
    res = 1
    i = 0
    while i < e:
        res = res * 2
        i = i + 1
    return res
def has_bit(n, b):
    p = pow2(b)
    if ((n // p) % 2) == 1:
        return True
    return False
@dataclass
class DecodeResult:
    data: [int]
    ack: bool

def hamming_encode(r, data_bits):
    total = r + len(data_bits)
    data_ord = []
    cont_data = 0
    x = 1
    while x <= total:
        if is_power_of_two(x):
            data_ord = _append(data_ord, -1)
        else:
            data_ord = _append(data_ord, data_bits[cont_data])
            cont_data = cont_data + 1
        x = x + 1
    parity = []
    bp = 0
    while bp < r:
        cont_bo = 0
        j = 0
        while j < len(data_ord):
            bit = data_ord[j]
            if bit >= 0:
                pos = j + 1
                if has_bit(pos, bp) and bit == 1:
                    cont_bo = cont_bo + 1
            j = j + 1
        parity = _append(parity, cont_bo % 2)
        bp = bp + 1
    result = []
    cont_bp = 0
    i = 0
    while i < len(data_ord):
        if data_ord[i] < 0:
            result = _append(result, parity[cont_bp])
            cont_bp = cont_bp + 1
        else:
            result = _append(result, data_ord[i])
        i = i + 1
    return result
def hamming_decode(r, code):
    data_output = []
    parity_received = []
    i = 1
    idx = 0
    while i <= len(code):
        if is_power_of_two(i):
            parity_received = _append(parity_received, code[idx])
        else:
            data_output = _append(data_output, code[idx])
        idx = idx + 1
        i = i + 1
    recomputed = hamming_encode(r, data_output)
    parity_calc = []
    j = 0
    while j < len(recomputed):
        if is_power_of_two(j + 1):
            parity_calc = _append(parity_calc, recomputed[j])
        j = j + 1
    ack = list_eq(parity_received, parity_calc)
    return DecodeResult(data=data_output, ack=ack)
def main():
    sizePari = 4
    be = 2
    text = "Message01"
    binary = text_to_bits(text)
    print("Text input in binary is '" + binary + "'")
    data_bits = string_to_bitlist(binary)
    encoded = hamming_encode(sizePari, data_bits)
    print("Data converted ----------> " + bitlist_to_string(encoded))
    decoded = hamming_decode(sizePari, encoded)
    print("Data receive ------------> " + bitlist_to_string(decoded.data) + " -- Data integrity: " + bool_to_string(decoded.ack))
    corrupted = []
    i = 0
    while i < len(encoded):
        corrupted = _append(corrupted, encoded[i])
        i = i + 1
    pos = be - 1
    if corrupted[pos] == 0:
        corrupted[pos] = 1
    else:
        corrupted[pos] = 0
    decoded_err = hamming_decode(sizePari, corrupted)
    print("Data receive (error) ----> " + bitlist_to_string(decoded_err.data) + " -- Data integrity: " + bool_to_string(decoded_err.ack))
main()
