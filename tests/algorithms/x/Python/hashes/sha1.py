# Code generated by Mochi transpiler.
# Version 0.10.66, generated on 2025-08-15 15:17 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    if lst is None:
        lst = []
    return lst + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

MOD = 4294967296
ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
def ord(ch):
    i = 0
    while i < len(ASCII):
        if ASCII[i:i + 1] == ch:
            return 32 + i
        i = i + 1
    return 0
def pow2(n):
    res = 1
    i = 0
    while i < n:
        res = res * 2
        i = i + 1
    return res
def bit_and(a, b):
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32:
        if (x % 2 == 1) and (y % 2 == 1):
            res = res + bit
        x = x // 2
        y = y // 2
        bit = bit * 2
        i = i + 1
    return res
def bit_or(a, b):
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32:
        abit = x % 2
        bbit = y % 2
        if abit == 1 or bbit == 1:
            res = res + bit
        x = x // 2
        y = y // 2
        bit = bit * 2
        i = i + 1
    return res
def bit_xor(a, b):
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32:
        abit = x % 2
        bbit = y % 2
        if (abit == 1 and bbit == 0) or (abit == 0 and bbit == 1):
            res = res + bit
        x = x // 2
        y = y // 2
        bit = bit * 2
        i = i + 1
    return res
def bit_not(a):
    return (MOD - 1) - a
def rotate_left(n, b):
    left = (n * pow2(b)) % MOD
    right = n / pow2(32 - b)
    return (left + right) % MOD
def to_hex32(n):
    digits = "0123456789abcdef"
    num = n
    s = ""
    if num == 0:
        s = "0"
    while num > 0:
        d = num % 16
        s = digits[d:d + 1] + s
        num = num // 16
    while len(s) < 8:
        s = "0" + s
    if len(s) > 8:
        s = s[len(s) - 8:]
    return s
def sha1(message):
    bytes_ = []
    i = 0
    while i < len(message):
        bytes_ = _append(bytes_, ord(message[i:i + 1]))
        i = i + 1
    bytes_ = _append(bytes_, 128)
    while (len(bytes_) + 8) % 64 != 0:
        bytes_ = _append(bytes_, 0)
    bit_len = len(message) * 8
    len_bytes = [0, 0, 0, 0, 0, 0, 0, 0]
    bl = bit_len
    k = 7
    while k >= 0:
        len_bytes[k] = bl % 256
        bl = bl // 256
        k = k - 1
    j = 0
    while j < 8:
        bytes_ = _append(bytes_, len_bytes[j])
        j = j + 1
    blocks = []
    pos = 0
    while pos < len(bytes_):
        block = []
        j2 = 0
        while j2 < 64:
            block = _append(block, bytes_[pos + j2])
            j2 = j2 + 1
        blocks = _append(blocks, block)
        pos = pos + 64
    h0 = 1732584193
    h1 = 4023233417
    h2 = 2562383102
    h3 = 271733878
    h4 = 3285377520
    bindex = 0
    while bindex < len(blocks):
        block = blocks[bindex]
        w = []
        t = 0
        while t < 16:
            j3 = t * 4
            word = (((block[j3] * 256 + block[j3 + 1]) * 256 + block[j3 + 2]) * 256 + block[j3 + 3])
            w = _append(w, word)
            t = t + 1
        while t < 80:
            tmp = bit_xor(bit_xor(bit_xor(w[t - 3], w[t - 8]), w[t - 14]), w[t - 16])
            w = _append(w, rotate_left(tmp, 1))
            t = t + 1
        a = h0
        b = h1
        c = h2
        d = h3
        e = h4
        i2 = 0
        while i2 < 80:
            f = 0
            kconst = 0
            if i2 < 20:
                f = bit_or(bit_and(b, c), bit_and(bit_not(b), d))
                kconst = 1518500249
            else:
                if i2 < 40:
                    f = bit_xor(bit_xor(b, c), d)
                    kconst = 1859775393
                else:
                    if i2 < 60:
                        f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d))
                        kconst = 2400959708
                    else:
                        f = bit_xor(bit_xor(b, c), d)
                        kconst = 3395469782
            temp = (rotate_left(a, 5) + f + e + kconst + w[i2]) % MOD
            e = d
            d = c
            c = rotate_left(b, 30)
            b = a
            a = temp
            i2 = i2 + 1
        h0 = (h0 + a) % MOD
        h1 = (h1 + b) % MOD
        h2 = (h2 + c) % MOD
        h3 = (h3 + d) % MOD
        h4 = (h4 + e) % MOD
        bindex = bindex + 1
    return to_hex32(h0) + to_hex32(h1) + to_hex32(h2) + to_hex32(h3) + to_hex32(h4)
def main():
    if resource:
        _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_start = 0
    _bench_start = _now()
    try:
        print(sha1("Test String"))
    finally:
        _bench_end = _now()
        if resource:
            _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        else:
            _bench_mem_end = 0
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()

