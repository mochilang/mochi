# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]

MOD = 4294967296
ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
def ord(ch):
    i = 0
    while i < len(ASCII):
        if ASCII[i:i + 1] == ch:
            return 32 + i
        i = i + 1
    return 0
def to_little_endian(s):
    if len(s) != 32:
        panic("Input must be of length 32")
    return s[24:32] + s[16:24] + s[8:16] + s[0:8]
def int_to_bits(n, width):
    bits = ""
    num = n
    while num > 0:
        bits = str(num % 2) + bits
        num = num // 2
    while len(bits) < width:
        bits = "0" + bits
    if len(bits) > width:
        bits = bits[len(bits) - width:len(bits)]
    return bits
def bits_to_int(bits):
    num = 0
    i = 0
    while i < len(bits):
        if bits[i:i + 1] == "1":
            num = num * 2 + 1
        else:
            num = num * 2
        i = i + 1
    return num
def to_hex(n):
    digits = "0123456789abcdef"
    if n == 0:
        return "0"
    num = n
    s = ""
    while num > 0:
        d = num % 16
        s = digits[d:d + 1] + s
        num = num // 16
    return s
def reformat_hex(i):
    if i < 0:
        panic("Input must be non-negative")
    hex = to_hex(i)
    while len(hex) < 8:
        hex = "0" + hex
    if len(hex) > 8:
        hex = hex[len(hex) - 8:len(hex)]
    le = ""
    j = len(hex) - 2
    while j >= 0:
        le = le + hex[j:j + 2]
        j = j - 2
    return le
def preprocess(message):
    bit_string = ""
    i = 0
    while i < len(message):
        ch = message[i:i + 1]
        bit_string = bit_string + int_to_bits(ord(ch), 8)
        i = i + 1
    start_len = int_to_bits(len(bit_string), 64)
    bit_string = bit_string + "1"
    while len(bit_string) % 512 != 448:
        bit_string = bit_string + "0"
    bit_string = bit_string + to_little_endian(start_len[32:64]) + to_little_endian(start_len[0:32])
    return bit_string
def get_block_words(bit_string):
    if len(bit_string) % 512 != 0:
        panic("Input must have length that's a multiple of 512")
    blocks = []
    pos = 0
    while pos < len(bit_string):
        block = []
        i = 0
        while i < 512:
            part = bit_string[pos + i:pos + i + 32]
            word = bits_to_int(to_little_endian(part))
            block = _append(block, word)
            i = i + 32
        blocks = _append(blocks, block)
        pos = pos + 512
    return blocks
def bit_and(a, b):
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32:
        if (x % 2 == 1) and (y % 2 == 1):
            res = res + bit
        x = x // 2
        y = y // 2
        bit = bit * 2
        i = i + 1
    return res
def bit_or(a, b):
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32:
        abit = x % 2
        bbit = y % 2
        if abit == 1 or bbit == 1:
            res = res + bit
        x = x // 2
        y = y // 2
        bit = bit * 2
        i = i + 1
    return res
def bit_xor(a, b):
    x = a
    y = b
    res = 0
    bit = 1
    i = 0
    while i < 32:
        abit = x % 2
        bbit = y % 2
        if (abit + bbit) % 2 == 1:
            res = res + bit
        x = x // 2
        y = y // 2
        bit = bit * 2
        i = i + 1
    return res
def not_32(i):
    if i < 0:
        panic("Input must be non-negative")
    return 4294967295 - i
def sum_32(a, b):
    return (a + b) % MOD
def lshift(num, k):
    result = num % MOD
    i = 0
    while i < k:
        result = (result * 2) % MOD
        i = i + 1
    return result
def rshift(num, k):
    result = num
    i = 0
    while i < k:
        result = result // 2
        i = i + 1
    return result
def left_rotate_32(i, shift):
    if i < 0:
        panic("Input must be non-negative")
    if shift < 0:
        panic("Shift must be non-negative")
    left = lshift(i, shift)
    right = rshift(i, 32 - shift)
    return (left + right) % MOD
def md5_me(message):
    bit_string = preprocess(message)
    added_consts = [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]
    shift_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
    a0 = 1732584193
    b0 = 4023233417
    c0 = 2562383102
    d0 = 271733878
    blocks = get_block_words(bit_string)
    bi = 0
    while bi < len(blocks):
        block = blocks[bi]
        a = a0
        b = b0
        c = c0
        d = d0
        i = 0
        while i < 64:
            f = 0
            g = 0
            if i <= 15:
                f = bit_xor(d, bit_and(b, bit_xor(c, d)))
                g = i
            else:
                if i <= 31:
                    f = bit_xor(c, bit_and(d, bit_xor(b, c)))
                    g = (5 * i + 1) % 16
                else:
                    if i <= 47:
                        f = bit_xor(bit_xor(b, c), d)
                        g = (3 * i + 5) % 16
                    else:
                        f = bit_xor(c, bit_or(b, not_32(d)))
                        g = (7 * i) % 16
            f = sum_32(f, a)
            f = sum_32(f, added_consts[i])
            f = sum_32(f, block[g])
            rotated = left_rotate_32(f, shift_amounts[i])
            new_b = sum_32(b, rotated)
            a = d
            d = c
            c = b
            b = new_b
            i = i + 1
        a0 = sum_32(a0, a)
        b0 = sum_32(b0, b)
        c0 = sum_32(c0, c)
        d0 = sum_32(d0, d)
        bi = bi + 1
    digest = reformat_hex(a0) + reformat_hex(b0) + reformat_hex(c0) + reformat_hex(d0)
    return digest
# test md5 empty
assert md5_me("") == "d41d8cd98f00b204e9800998ecf8427e"
# test md5 fox
assert md5_me("The quick brown fox jumps over the lazy dog") == "9e107d9d372bb6826bd81d3542a419d6"
# test md5 fox dot
assert md5_me("The quick brown fox jumps over the lazy dog.") == "e4d909c290d0fb1ca068ffaddf22cbd0"
