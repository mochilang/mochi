# Code generated by Mochi transpiler.
# Version 0.10.65, generated on 2025-08-14 16:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

if resource:
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
else:
    _bench_mem_start = 0
_bench_start = _now()
try:
    K = [0.33, 0.44, 0.55, 0.44, 0.33]
    t = 3
    size = 5
    @dataclass
    class Machine:
        buffer: [float]
        params: [float]
        time: int
    @dataclass
    class PullResult:
        value: int
        machine: Machine
    def round_dec(x, n):
        m10 = 1.0
        i = 0
        while i < n:
            m10 = m10 * 10.0
            i = i + 1
        y = x * m10 + 0.5
        return (1.0 * int(y)) / m10
    def reset():
        return Machine(buffer=K, params=[0.0, 0.0, 0.0, 0.0, 0.0], time=0)
    def push(m, seed):
        buf = m.buffer
        par = m.params
        i = 0
        while i < len(buf):
            value = buf[i]
            e = (1.0 * seed) / value
            next_value = buf[int((i + 1) % size)] + e
            next_value = next_value - (1.0 * int(next_value))
            r = par[i] + e
            r = r - (1.0 * int(r))
            r = r + 3.0
            buf[i] = round_dec(r * next_value * (1.0 - next_value), 10)
            par[i] = r
            i = i + 1
        return Machine(buffer=buf, params=par, time=m.time + 1)
    def xor(a, b):
        aa = a
        bb = b
        res = 0
        bit = 1
        while aa > 0 or bb > 0:
            abit = aa % 2
            bbit = bb % 2
            if abit != bbit:
                res = res + bit
            aa = aa // 2
            bb = bb // 2
            bit = bit * 2
        return res
    def xorshift(x, y):
        xv = x
        yv = y
        xv = xor(xv, yv // 8192)
        yv = xor(yv, xv * 131072)
        xv = xor(xv, yv // 32)
        return xv
    def pull(m):
        buf = m.buffer
        par = m.params
        key = m.time % size
        i = 0
        while i < t:
            r = par[key]
            value = buf[key]
            buf[key] = round_dec(r * value * (1.0 - value), 10)
            new_r = (1.0 * m.time) * 0.01 + r * 1.01
            new_r = new_r - (1.0 * int(new_r))
            par[key] = new_r + 3.0
            i = i + 1
        x = int(buf[int((key + 2) % size)] * 1e+10)
        y = int(buf[int((key + size - 2) % size)] * 1e+10)
        new_machine = Machine(buffer=buf, params=par, time=m.time + 1)
        value = xorshift(x, y) % 4294967295
        return PullResult(value=value, machine=new_machine)
    machine = reset()
    i = 0
    while i < 100:
        machine = push(machine, i)
        i = i + 1
    res = pull(machine)
    print(res.value)
    print(res.machine.buffer)
    print(res.machine.params)
finally:
    _bench_end = _now()
    if resource:
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_end = 0
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))

