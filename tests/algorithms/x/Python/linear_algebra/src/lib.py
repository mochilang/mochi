# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

PI = 3.141592653589793
seed = 123456789
def rand():
    global seed
    seed = (seed * 1103515245 + 12345) % 2147483648
    return seed
def random_int(a, b):
    r = rand() % (b - a + 1)
    return a + r
def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def arcsin_taylor(x):
    term = x
    sum = x
    n = 1
    while n < 10:
        num = (2.0 * (float(n)) - 1.0) * (2.0 * (float(n)) - 1.0) * x * x * term
        den = (2.0 * (float(n))) * (2.0 * (float(n)) + 1.0)
        term = num // den
        sum = sum + term
        n = n + 1
    return sum
def acos_taylor(x):
    return PI / 2.0 - arcsin_taylor(x)
@dataclass
class Vector:
    components: [float]

def vector_len(v):
    return len(v.components)
def vector_to_string(v):
    s = "("
    i = 0
    while i < len(v.components):
        s = s + str(v.components[i])
        if i < len(v.components) - 1:
            s = s + ","
        i = i + 1
    s = s + ")"
    return s
def vector_add(a, b):
    size = vector_len(a)
    if size != vector_len(b):
        return Vector(components=[])
    res = []
    i = 0
    while i < size:
        res = _append(res, a.components[i] + b.components[i])
        i = i + 1
    return Vector(components=res)
def vector_sub(a, b):
    size = vector_len(a)
    if size != vector_len(b):
        return Vector(components=[])
    res = []
    i = 0
    while i < size:
        res = _append(res, a.components[i] - b.components[i])
        i = i + 1
    return Vector(components=res)
def vector_eq(a, b):
    if vector_len(a) != vector_len(b):
        return False
    i = 0
    while i < vector_len(a):
        if a.components[i] != b.components[i]:
            return False
        i = i + 1
    return True
def vector_mul_scalar(v, s):
    res = []
    i = 0
    while i < vector_len(v):
        res = _append(res, v.components[i] * s)
        i = i + 1
    return Vector(components=res)
def vector_dot(a, b):
    size = vector_len(a)
    if size != vector_len(b):
        return 0.0
    sum = 0.0
    i = 0
    while i < size:
        sum = sum + a.components[i] * b.components[i]
        i = i + 1
    return sum
def vector_copy(v):
    res = []
    i = 0
    while i < vector_len(v):
        res = _append(res, v.components[i])
        i = i + 1
    return Vector(components=res)
def vector_component(v, idx):
    return v.components[idx]
def vector_change_component(v, pos, value):
    comps = v.components
    comps[pos] = value
    return Vector(components=comps)
def vector_euclidean_length(v):
    sum = 0.0
    i = 0
    while i < len(v.components):
        sum = sum + v.components[i] * v.components[i]
        i = i + 1
    result = sqrtApprox(sum)
    return result
def vector_angle(a, b, deg):
    num = vector_dot(a, b)
    den = vector_euclidean_length(a) * vector_euclidean_length(b)
    ang = acos_taylor(num // den)
    if deg:
        ang = ang * 180.0 / PI
    return ang
def zero_vector(d):
    res = []
    i = 0
    while i < d:
        res = _append(res, 0.0)
        i = i + 1
    return Vector(components=res)
def unit_basis_vector(d, pos):
    res = []
    i = 0
    while i < d:
        if i == pos:
            res = _append(res, 1.0)
        else:
            res = _append(res, 0.0)
        i = i + 1
    return Vector(components=res)
def axpy(s, x, y):
    return vector_add(vector_mul_scalar(x, s), y)
def random_vector(n, a, b):
    res = []
    i = 0
    while i < n:
        res = _append(res, float(random_int(a, b)))
        i = i + 1
    return Vector(components=res)
@dataclass
class Matrix:
    data: [[float]]
    width: int
    height: int

def matrix_to_string(m):
    ans = ""
    i = 0
    while i < m.height:
        ans = ans + "|"
        j = 0
        while j < m.width:
            ans = ans + str(m.data[i][j])
            if j < m.width - 1:
                ans = ans + ","
            j = j + 1
        ans = ans + "|\n"
        i = i + 1
    return ans
def matrix_add(a, b):
    if a.width != b.width or a.height != b.height:
        return Matrix(data=[], width=0, height=0)
    mat = []
    i = 0
    while i < a.height:
        row = []
        j = 0
        while j < a.width:
            row = _append(row, a.data[i][j] + b.data[i][j])
            j = j + 1
        mat = _append(mat, row)
        i = i + 1
    return Matrix(data=mat, width=a.width, height=a.height)
def matrix_sub(a, b):
    if a.width != b.width or a.height != b.height:
        return Matrix(data=[], width=0, height=0)
    mat = []
    i = 0
    while i < a.height:
        row = []
        j = 0
        while j < a.width:
            row = _append(row, a.data[i][j] - b.data[i][j])
            j = j + 1
        mat = _append(mat, row)
        i = i + 1
    return Matrix(data=mat, width=a.width, height=a.height)
def matrix_mul_vector(m, v):
    if len(v.components) != m.width:
        return Vector(components=[])
    res = zero_vector(m.height)
    i = 0
    while i < m.height:
        sum = 0.0
        j = 0
        while j < m.width:
            sum = sum + m.data[i][j] * v.components[j]
            j = j + 1
        res = vector_change_component(res, i, sum)
        i = i + 1
    return res
def matrix_mul_scalar(m, s):
    mat = []
    i = 0
    while i < m.height:
        row = []
        j = 0
        while j < m.width:
            row = _append(row, m.data[i][j] * s)
            j = j + 1
        mat = _append(mat, row)
        i = i + 1
    return Matrix(data=mat, width=m.width, height=m.height)
def matrix_component(m, x, y):
    return m.data[x][y]
def matrix_change_component(m, x, y, value):
    data = m.data
    data[x][y] = value
    return Matrix(data=data, width=m.width, height=m.height)
def matrix_minor(m, x, y):
    if m.height != m.width:
        return 0.0
    minor = []
    i = 0
    while i < m.height:
        if i != x:
            row = []
            j = 0
            while j < m.width:
                if j != y:
                    row = _append(row, m.data[i][j])
                j = j + 1
            minor = _append(minor, row)
        i = i + 1
    sub = Matrix(data=minor, width=m.width - 1, height=m.height - 1)
    return matrix_determinant(sub)
def matrix_cofactor(m, x, y):
    sign = (1.0 if (x + y) % 2 == 0 else -1.0)
    return sign * matrix_minor(m, x, y)
def matrix_determinant(m):
    if m.height != m.width:
        return 0.0
    if m.height == 0:
        return 0.0
    if m.height == 1:
        return m.data[0][0]
    if m.height == 2:
        return m.data[0][0] * m.data[1][1] - m.data[0][1] * m.data[1][0]
    sum = 0.0
    y = 0
    while y < m.width:
        sum = sum + m.data[0][y] * matrix_cofactor(m, 0, y)
        y = y + 1
    return sum
def square_zero_matrix(n):
    mat = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            row = _append(row, 0.0)
            j = j + 1
        mat = _append(mat, row)
        i = i + 1
    return Matrix(data=mat, width=n, height=n)
def random_matrix(w, h, a, b):
    mat = []
    i = 0
    while i < h:
        row = []
        j = 0
        while j < w:
            row = _append(row, float(random_int(a, b)))
            j = j + 1
        mat = _append(mat, row)
        i = i + 1
    return Matrix(data=mat, width=w, height=h)
def main():
    v1 = Vector(components=[1.0, 2.0, 3.0])
    v2 = Vector(components=[4.0, 5.0, 6.0])
    print(vector_to_string(vector_add(v1, v2)))
    print(str(vector_dot(v1, v2)))
    print(str(vector_euclidean_length(v1)))
    m = Matrix(data=[[1.0, 2.0], [3.0, 4.0]], width=2, height=2)
    print(str(matrix_determinant(m)))
main()
