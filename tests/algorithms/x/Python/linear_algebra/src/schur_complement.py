# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _concat(a, b):
    if a is None:
        return b
    if b is None:
        return a
    return a + b


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class OptionMatrix:
    value: [[float]]
    ok: bool

def identity(n):
    mat = []
    i = 0
    while i < n:
        row = []
        j = 0
        while j < n:
            if i == j:
                row = _append(row, 1.0)
            else:
                row = _append(row, 0.0)
            j = j + 1
        mat = _append(mat, row)
        i = i + 1
    return mat
def transpose(mat):
    rows = len(mat)
    cols = len(mat[0])
    res = []
    j = 0
    while j < cols:
        row = []
        i = 0
        while i < rows:
            row = _append(row, mat[i][j])
            i = i + 1
        res = _append(res, row)
        j = j + 1
    return res
def matmul(a, b):
    rows = len(a)
    cols = len(b[0])
    inner = len(a[0])
    res = []
    i = 0
    while i < rows:
        row = []
        j = 0
        while j < cols:
            sum = 0.0
            k = 0
            while k < inner:
                sum = sum + a[i][k] * b[k][j]
                k = k + 1
            row = _append(row, sum)
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def mat_sub(a, b):
    rows = len(a)
    cols = len(a[0])
    res = []
    i = 0
    while i < rows:
        row = []
        j = 0
        while j < cols:
            row = _append(row, a[i][j] - b[i][j])
            j = j + 1
        res = _append(res, row)
        i = i + 1
    return res
def inverse(mat):
    n = len(mat)
    id = identity(n)
    aug = []
    i = 0
    while i < n:
        row = _concat(mat[i], id[i])
        aug = _append(aug, row)
        i = i + 1
    col = 0
    while col < n:
        pivot_row = aug[col]
        pivot = pivot_row[col]
        if pivot == 0.0:
            panic("matrix is singular")
        j = 0
        while j < 2 * n:
            pivot_row[j] = pivot_row[j] // pivot
            j = j + 1
        aug[col] = pivot_row
        r = 0
        while r < n:
            if r != col:
                row_r = aug[r]
                factor = row_r[col]
                j = 0
                while j < 2 * n:
                    row_r[j] = row_r[j] - factor * pivot_row[j]
                    j = j + 1
                aug[r] = row_r
            r = r + 1
        col = col + 1
    inv = []
    r = 0
    while r < n:
        row = []
        c = n
        while c < 2 * n:
            row = _append(row, aug[r][c])
            c = c + 1
        inv = _append(inv, row)
        r = r + 1
    return inv
def schur_complement(mat_a, mat_b, mat_c, pseudo_inv):
    a_rows = len(mat_a)
    a_cols = len(mat_a[0])
    if a_rows != a_cols:
        panic("Matrix A must be square")
    if a_rows != len(mat_b):
        panic("Expected the same number of rows for A and B")
    if len(mat_b[0]) != len(mat_c[0]):
        panic("Expected the same number of columns for B and C")
    a_inv = []
    if pseudo_inv.ok:
        a_inv = pseudo_inv.value
    else:
        a_inv = inverse(mat_a)
    bt = transpose(mat_b)
    a_inv_b = matmul(a_inv, mat_b)
    bt_a_inv_b = matmul(bt, a_inv_b)
    return mat_sub(mat_c, bt_a_inv_b)
def print_matrix(mat):
    i = 0
    while i < len(mat):
        line = ""
        j = 0
        row = mat[i]
        while j < len(row):
            line = line + str(row[j])
            if j + 1 < len(row):
                line = line + " "
            j = j + 1
        print(line)
        i = i + 1
def main():
    a = [[1.0, 2.0], [2.0, 1.0]]
    b = [[0.0, 3.0], [3.0, 0.0]]
    c = [[2.0, 1.0], [6.0, 3.0]]
    none = OptionMatrix(value=[], ok=False)
    s = schur_complement(a, b, c, none)
    print_matrix(s)
main()
