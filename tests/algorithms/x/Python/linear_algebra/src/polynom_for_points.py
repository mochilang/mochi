# Code generated by Mochi transpiler.
# Version 0.10.60, generated on 2025-08-08 11:13 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise Exception(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

def contains_int(xs, x):
    i = 0
    while i < len(xs):
        if xs[i] == x:
            return True
        i = i + 1
    return False
def split(s, sep):
    res = []
    current = ""
    i = 0
    while i < len(s):
        ch = s[i:i + 1]
        if ch == sep:
            res = _append(res, current)
            current = ""
        else:
            current = current + ch
        i = i + 1
    res = _append(res, current)
    return res
def pow_int_float(base, exp):
    result = 1.0
    i = 0
    while i < exp:
        result = result * (float(base))
        i = i + 1
    return result
def points_to_polynomial(coordinates):
    if len(coordinates) == 0:
        panic("The program cannot work out a fitting polynomial.")
    i = 0
    while i < len(coordinates):
        if len(coordinates[i]) != 2:
            panic("The program cannot work out a fitting polynomial.")
        i = i + 1
    j = 0
    while j < len(coordinates):
        k = j + 1
        while k < len(coordinates):
            if coordinates[j][0] == coordinates[k][0] and coordinates[j][1] == coordinates[k][1]:
                panic("The program cannot work out a fitting polynomial.")
            k = k + 1
        j = j + 1
    set_x = []
    i = 0
    while i < len(coordinates):
        x_val = coordinates[i][0]
        if not contains_int(set_x, x_val):
            set_x = _append(set_x, x_val)
        i = i + 1
    if len(set_x) == 1:
        return "x=" + str(coordinates[0][0])
    if len(set_x) != len(coordinates):
        panic("The program cannot work out a fitting polynomial.")
    n = len(coordinates)
    matrix = []
    row = 0
    while row < n:
        line = []
        col = 0
        while col < n:
            power = pow_int_float(coordinates[row][0], n - (col + 1))
            line = _append(line, power)
            col = col + 1
        matrix = _append(matrix, line)
        row = row + 1
    vector = []
    row = 0
    while row < n:
        vector = _append(vector, float(coordinates[row][1]))
        row = row + 1
    count = 0
    while count < n:
        number = 0
        while number < n:
            if count != number:
                fraction = matrix[number][count] // matrix[count][count]
                cc = 0
                while cc < n:
                    matrix[number][cc] = matrix[number][cc] - matrix[count][cc] * fraction
                    cc = cc + 1
                vector[number] = vector[number] - vector[count] * fraction
            number = number + 1
        count = count + 1
    solution = []
    count = 0
    while count < n:
        value = vector[count] // matrix[count][count]
        solution = _append(solution, str(value))
        count = count + 1
    solved = "f(x)="
    count = 0
    while count < n:
        parts = solution[count].split("e")
        coeff = solution[count]
        if len(parts) > 1:
            coeff = parts[0] + "*10^" + parts[1]
        solved = solved + "x^" + str(n - (count + 1)) + "*" + coeff
        if count + 1 != n:
            solved = solved + "+"
        count = count + 1
    return solved
def main():
    print(points_to_polynomial([[1, 0], [2, 0], [3, 0]]))
    print(points_to_polynomial([[1, 1], [2, 1], [3, 1]]))
    print(points_to_polynomial([[1, 1], [2, 4], [3, 9]]))
    print(points_to_polynomial([[1, 3], [2, 6], [3, 11]]))
    print(points_to_polynomial([[1, -3], [2, -6], [3, -11]]))
    print(points_to_polynomial([[1, 1], [1, 2], [1, 3]]))
    print(points_to_polynomial([[1, 5], [2, 2], [3, 9]]))
main()
