# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-11 16:20 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import time

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    return (lst or []) + [v]

@dataclass
class SearchProblem:
    x: float
    y: float
    step: float

def score(p, f):
    return f(p.x, p.y)
def get_neighbors(p):
    s = p.step
    ns = []
    ns = _append(ns, SearchProblem(x=p.x - s, y=p.y - s, step=s))
    ns = _append(ns, SearchProblem(x=p.x - s, y=p.y, step=s))
    ns = _append(ns, SearchProblem(x=p.x - s, y=p.y + s, step=s))
    ns = _append(ns, SearchProblem(x=p.x, y=p.y - s, step=s))
    ns = _append(ns, SearchProblem(x=p.x, y=p.y + s, step=s))
    ns = _append(ns, SearchProblem(x=p.x + s, y=p.y - s, step=s))
    ns = _append(ns, SearchProblem(x=p.x + s, y=p.y, step=s))
    ns = _append(ns, SearchProblem(x=p.x + s, y=p.y + s, step=s))
    return ns
def remove_at(lst, idx):
    res = []
    i = 0
    while i < len(lst):
        if i != idx:
            res = _append(res, lst[i])
        i = i + 1
    return res
seed = 1
def rand():
    global seed
    _t = _now()
    seed = (seed * 1103515245 + 12345) % 2147483648
    return seed
def random_float():
    return (float(rand())) / 2.147483648e+09
def randint(low, high):
    return (rand() % (high - low + 1)) + low
def expApprox(x):
    y = x
    is_neg = False
    if x < 0.0:
        is_neg = True
        y = -x
    term = 1.0
    sum = 1.0
    n = 1
    while n < 30:
        term = term * y / (float(n))
        sum = sum + term
        n = n + 1
    if is_neg:
        return 1.0 / sum
    return sum
def simulated_annealing(search_prob, f, find_max, max_x, min_x, max_y, min_y, start_temp, rate_of_decrease, threshold_temp):
    search_end = False
    current_state = search_prob
    current_temp = start_temp
    best_state = current_state
    while not search_end:
        current_score = score(current_state, f)
        if score(best_state, f) < current_score:
            best_state = current_state
        next_state = current_state
        found_next = False
        neighbors = get_neighbors(current_state)
        while not found_next and len(neighbors) > 0:
            idx = randint(0, len(neighbors) - 1)
            picked_neighbor = neighbors[idx]
            neighbors = remove_at(neighbors, idx)
            if picked_neighbor.x > max_x or picked_neighbor.x < min_x or picked_neighbor.y > max_y or picked_neighbor.y < min_y:
                continue
            change = score(picked_neighbor, f) - current_score
            if not find_max:
                change = -change
            if change > 0.0:
                next_state = picked_neighbor
                found_next = True
            else:
                probability = expApprox(change // current_temp)
                if random_float() < probability:
                    next_state = picked_neighbor
                    found_next = True
        current_temp = current_temp - (current_temp * rate_of_decrease)
        if current_temp < threshold_temp or (not found_next):
            search_end = True
        else:
            current_state = next_state
    return best_state
def test_f1(x, y):
    return x * x + y * y
def test_f2(x, y):
    return (3.0 * x * x) - (6.0 * y)
def main():
    prob1 = SearchProblem(x=12.0, y=47.0, step=1.0)
    min_state = simulated_annealing(prob1, test_f1, False, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0)
    print("min1", test_f1(min_state.x, min_state.y))
    prob2 = SearchProblem(x=12.0, y=47.0, step=1.0)
    max_state = simulated_annealing(prob2, test_f1, True, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0)
    print("max1", test_f1(max_state.x, max_state.y))
    prob3 = SearchProblem(x=3.0, y=4.0, step=1.0)
    min_state2 = simulated_annealing(prob3, test_f2, False, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0)
    print("min2", test_f2(min_state2.x, min_state2.y))
    prob4 = SearchProblem(x=3.0, y=4.0, step=1.0)
    max_state2 = simulated_annealing(prob4, test_f2, True, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0)
    print("max2", test_f2(max_state2.x, max_state2.y))
main()

