# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-11 16:20 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

@dataclass
class Solution:
    path: [string]
    cost: int

@dataclass
class Swap:
    a: str
    b: str

def path_cost(path, graph):
    total = 0
    i = 0
    while i < len(path) - 1:
        u = path[i]
        v = path[i + 1]
        total = total + graph.get(u, {}).get(v, 0)
        i = i + 1
    return total
def generate_first_solution(graph, start):
    path = []
    visiting = start
    total = 0
    while len(path) < len(graph):
        path = _append(path, visiting)
        best_node = ""
        best_cost = 1000000
        for n in graph.get(visiting, {}):
            if not (n in path) and graph.get(visiting, {}).get(n, 0) < best_cost:
                best_cost = graph.get(visiting, {}).get(n, 0)
                best_node = n
        if best_node == "":
            break
        total = total + best_cost
        visiting = best_node
    path = _append(path, start)
    total = total + graph.get(visiting, {}).get(start, 0)
    return Solution(path=path, cost=total)
def copy_path(path):
    res = []
    i = 0
    while i < len(path):
        res = _append(res, path[i])
        i = i + 1
    return res
def find_neighborhood(sol, graph):
    neighbors = []
    i = 1
    while i < len(sol.path) - 1:
        j = 1
        while j < len(sol.path) - 1:
            if i != j:
                new_path = copy_path(sol.path)
                tmp = new_path[i]
                new_path[i] = new_path[j]
                new_path[j] = tmp
                cost = path_cost(new_path, graph)
                neighbors = _append(neighbors, Solution(path=new_path, cost=cost))
            j = j + 1
        i = i + 1
    return neighbors
def find_swap(a, b):
    i = 0
    while i < len(a):
        if a[i] != b[i]:
            return Swap(a=a[i], b=b[i])
        i = i + 1
    return Swap(a="", b="")
def tabu_search(first, graph, iters, size):
    solution = first
    best = first
    tabu = []
    count = 0
    while count < iters:
        neighborhood = find_neighborhood(solution, graph)
        if len(neighborhood) == 0:
            break
        best_neighbor = neighborhood[0]
        best_move = find_swap(solution.path, best_neighbor.path)
        i = 1
        while i < len(neighborhood):
            cand = neighborhood[i]
            move = find_swap(solution.path, cand.path)
            forbidden = False
            t = 0
            while t < len(tabu):
                if (tabu[t].a == move.a and tabu[t].b == move.b) or (tabu[t].a == move.b and tabu[t].b == move.a):
                    forbidden = True
                t = t + 1
            if forbidden == False and cand.cost < best_neighbor.cost:
                best_neighbor = cand
                best_move = move
            i = i + 1
        solution = best_neighbor
        tabu = _append(tabu, best_move)
        if len(tabu) > size:
            new_tab = []
            j = 1
            while j < len(tabu):
                new_tab = _append(new_tab, tabu[j])
                j = j + 1
            tabu = new_tab
        if solution.cost < best.cost:
            best = solution
        count = count + 1
    return best
graph = {"a": {"b": 20, "c": 18, "d": 22, "e": 26}, "b": {"a": 20, "c": 10, "d": 11, "e": 12}, "c": {"a": 18, "b": 10, "d": 23, "e": 24}, "d": {"a": 22, "b": 11, "c": 23, "e": 40}, "e": {"a": 26, "b": 12, "c": 24, "d": 40}}
first = generate_first_solution(graph, "a")
best = tabu_search(first, graph, 4, 3)
print(_str(best.path))
print(_str(best.cost))

