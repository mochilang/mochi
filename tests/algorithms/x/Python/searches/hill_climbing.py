# Code generated by Mochi transpiler.
# Version 0.10.63, generated on 2025-08-11 16:20 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


def panic(msg):
    raise RuntimeError(msg)


def _append(lst, v):
    return (lst or []) + [v]


def _str(v):
    if isinstance(v, float):
        if v.is_integer():
            return str(int(v))
        return format(v, ".15g")
    return str(v)

@dataclass
class SearchProblem:
    x: float
    y: float
    step: float
    f: Callable[[float, float], float]

def score(sp):
    return sp.f(sp.x, sp.y)
def neighbors(sp):
    s = sp.step
    return [SearchProblem(x=sp.x - s, y=sp.y - s, step=s, f=sp.f), SearchProblem(x=sp.x - s, y=sp.y, step=s, f=sp.f), SearchProblem(x=sp.x - s, y=sp.y + s, step=s, f=sp.f), SearchProblem(x=sp.x, y=sp.y - s, step=s, f=sp.f), SearchProblem(x=sp.x, y=sp.y + s, step=s, f=sp.f), SearchProblem(x=sp.x + s, y=sp.y - s, step=s, f=sp.f), SearchProblem(x=sp.x + s, y=sp.y, step=s, f=sp.f), SearchProblem(x=sp.x + s, y=sp.y + s, step=s, f=sp.f)]
def equal_state(a, b):
    return a.x == b.x and a.y == b.y
def contains_state(lst, sp):
    i = 0
    while i < len(lst):
        if equal_state(lst[i], sp):
            return True
        i = i + 1
    return False
def hill_climbing(sp, find_max, max_x, min_x, max_y, min_y, max_iter):
    current = sp
    visited = []
    iterations = 0
    solution_found = False
    while solution_found == False and iterations < max_iter:
        visited = _append(visited, current)
        iterations = iterations + 1
        current_score = score(current)
        neighs = neighbors(current)
        max_change = -1e+18
        min_change = 1e+18
        next = current
        improved = False
        i = 0
        while i < len(neighs):
            n = neighs[i]
            i = i + 1
            if contains_state(visited, n):
                continue
            if n.x > max_x or n.x < min_x or n.y > max_y or n.y < min_y:
                continue
            change = score(n) - current_score
            if find_max:
                if change > max_change and change > 0.0:
                    max_change = change
                    next = n
                    improved = True
            else:
                if change < min_change and change < 0.0:
                    min_change = change
                    next = n
                    improved = True
        if improved:
            current = next
        else:
            solution_found = True
    return current
def test_f1(x, y):
    return x * x + y * y
def main():
    prob1 = SearchProblem(x=3.0, y=4.0, step=1.0, f=test_f1)
    local_min1 = hill_climbing(prob1, False, 1e+09, -1e+09, 1e+09, -1e+09, 10000)
    print(_str(int(score(local_min1))))
    prob2 = SearchProblem(x=12.0, y=47.0, step=1.0, f=test_f1)
    local_min2 = hill_climbing(prob2, False, 100.0, 5.0, 50.0, -5.0, 10000)
    print(_str(int(score(local_min2))))
    prob3 = SearchProblem(x=3.0, y=4.0, step=1.0, f=test_f1)
    local_max = hill_climbing(prob3, True, 1e+09, -1e+09, 1e+09, -1e+09, 1000)
    print(_str(int(score(local_max))))
main()

