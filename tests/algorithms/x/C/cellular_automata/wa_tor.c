// Generated by Mochi 0.10.32 on 2025-08-06 23:11 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t shuffle_len;
size_t create_board_len;
size_t *create_board_lens;
size_t create_prey_len;
size_t create_predator_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static long long* list_append_int(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_long_longptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long WIDTH = 10LL;
long long HEIGHT = 10LL;
long long PREY_INITIAL_COUNT = 20LL;
long long PREY_REPRODUCTION_TIME = 5LL;
long long PREDATOR_INITIAL_COUNT = 5LL;
long long PREDATOR_REPRODUCTION_TIME = 20LL;
long long PREDATOR_INITIAL_ENERGY = 15LL;
long long PREDATOR_FOOD_VALUE = 5LL;
long long TYPE_PREY = 0LL;
long long TYPE_PREDATOR = 1LL;
long long seed = 123456789LL;
long long **board = NULL;
size_t board_len = 0;
size_t *board_lens = NULL;
size_t board_lens_len = 0;
long long **entities = NULL;
size_t entities_len = 0;
size_t *entities_lens = NULL;
size_t entities_lens_len = 0;
long long dr_init[4] = {-1LL, 0LL, 1LL, 0LL};
long long *dr = dr_init;
size_t dr_len = 4;
long long dc_init[4] = {0LL, 1LL, 0LL, -1LL};
long long *dc = dc_init;
size_t dc_len = 4;
long long t = 0LL;

long long user_rand();
long long rand_range(long long max);
long long * shuffle(long long * list_int, size_t list_int_len);
long long * * create_board();
long long * create_prey(long long r, long long c);
long long * create_predator(long long r, long long c);
long long empty_cell(long long r, long long c);
void add_entity(long long typ);
void setup();
long long inside(long long r, long long c);
long long find_prey(long long r, long long c);
void step_world();
long long count_entities(long long typ);
int main(void);

long long user_rand() {
    seed = ((seed * 1103515245LL) + 12345LL) % 2147483648LL;
    return seed;
}

long long rand_range(long long max) {
    return user_rand() % max;
}

long long * shuffle(long long * list_int, size_t list_int_len) {
    long long i = list_int_len - 1LL;
    while (i > 0LL) {
        long long j = rand_range(i + 1LL);
        long long tmp = list_int[(int)(i)];
        list_int[(int)(i)] = list_int[(int)(j)];
        list_int[(int)(j)] = tmp;
        i = i - 1LL;
    }
    return shuffle_len = list_int_len, list_int;
}

long long * * create_board() {
    long long **board = NULL;
    size_t board_len = 0;
    size_t *board_lens = NULL;
    size_t board_lens_len = 0;
    long long r = 0LL;
    while (r < HEIGHT) {
        long long *row = NULL;
        size_t row_len = 0;
        long long c = 0LL;
        while (c < WIDTH) {
            row = list_append_long_long(row, &row_len, 0LL);
            c = c + 1LL;
        }
        board = list_append_long_longptr(board, &board_len, row);
        board_lens = list_append_szt(board_lens, &board_lens_len, row_len);
        r = r + 1LL;
    }
    return create_board_lens = board_lens, create_board_len = board_len, board;
}

long long * create_prey(long long r, long long c) {
    {
        static long long __tmp0_arr[6];
        __tmp0_arr[0] = TYPE_PREY;
        __tmp0_arr[1] = r;
        __tmp0_arr[2] = c;
        __tmp0_arr[3] = PREY_REPRODUCTION_TIME;
        __tmp0_arr[4] = 0LL;
        __tmp0_arr[5] = 1LL;
        create_prey_len = 6;
        return __tmp0_arr;
    }
}

long long * create_predator(long long r, long long c) {
    {
        static long long __tmp1_arr[6];
        __tmp1_arr[0] = TYPE_PREDATOR;
        __tmp1_arr[1] = r;
        __tmp1_arr[2] = c;
        __tmp1_arr[3] = PREDATOR_REPRODUCTION_TIME;
        __tmp1_arr[4] = PREDATOR_INITIAL_ENERGY;
        __tmp1_arr[5] = 1LL;
        create_predator_len = 6;
        return __tmp1_arr;
    }
}

long long empty_cell(long long r, long long c) {
    return board[(int)(r)][(int)(c)] == 0LL;
}

void add_entity(long long typ) {
    while (1LL) {
        long long r = rand_range(HEIGHT);
        long long c = rand_range(WIDTH);
        if (empty_cell(r, c)) {
            if (typ == TYPE_PREY) {
                board[(int)(r)][(int)(c)] = 1LL;
                entities = list_append_long_longptr(entities, &entities_len, create_prey(r, c));
                entities_lens = list_append_szt(entities_lens, &entities_lens_len, create_prey_len);
            } else {
                board[(int)(r)][(int)(c)] = 2LL;
                entities = list_append_long_longptr(entities, &entities_len, create_predator(r, c));
                entities_lens = list_append_szt(entities_lens, &entities_lens_len, create_predator_len);
            }
            return 0;
        }
    }
}

void setup() {
    long long i = 0LL;
    while (i < PREY_INITIAL_COUNT) {
        add_entity(TYPE_PREY);
        i = i + 1LL;
    }
    i = 0LL;
    while (i < PREDATOR_INITIAL_COUNT) {
        add_entity(TYPE_PREDATOR);
        i = i + 1LL;
    }
}

long long inside(long long r, long long c) {
    return (((r >= 0LL) && (r < HEIGHT)) && (c >= 0LL)) && (c < WIDTH);
}

long long find_prey(long long r, long long c) {
    long long i = 0LL;
    while (i < entities_len) {
        long long *e = entities[(int)(i)];
        size_t e_len = 0;
        if ((((e[(int)(5LL)] == 1LL) && (e[(int)(0LL)] == TYPE_PREY)) && (e[(int)(1LL)] == r)) && (e[(int)(2LL)] == c)) {
            return i;
        }
        i = i + 1LL;
    }
    return -1LL;
}

void step_world() {
    long long i = 0LL;
    while (i < entities_len) {
        long long *e = entities[(int)(i)];
        size_t e_len = entities_lens[i];
        if (e[(int)(5LL)] == 0LL) {
            i = i + 1LL;
            continue;
        }
        long long typ = e[(int)(0LL)];
        long long row = e[(int)(1LL)];
        long long col = e[(int)(2LL)];
        long long repro = e[(int)(3LL)];
        long long energy = e[(int)(4LL)];
        long long *dirs = NULL;
        size_t dirs_len = 0;
        dirs = list_append_int(dirs, &dirs_len, 0LL);
        dirs = list_append_int(dirs, &dirs_len, 1LL);
        dirs = list_append_int(dirs, &dirs_len, 2LL);
        dirs = list_append_int(dirs, &dirs_len, 3LL);
        dirs = shuffle(dirs, dirs_len);
        dirs_len = shuffle_len;
        long long moved = 0LL;
        long long old_r = row;
        long long old_c = col;
        if (typ == TYPE_PREDATOR) {
            long long j = 0LL;
            long long ate = 0LL;
            while (j < 4LL) {
                long long d = dirs[(int)(j)];
                long long nr = row + dr[(int)(d)];
                long long nc = col + dc[(int)(d)];
                if (inside(nr, nc) && (board[(int)(nr)][(int)(nc)] == 1LL)) {
                    long long prey_index = find_prey(nr, nc);
                    if (prey_index >= 0LL) {
                        entities[(int)(prey_index)][(int)(5LL)] = 0LL;
                    }
                    board[(int)(nr)][(int)(nc)] = 2LL;
                    board[(int)(row)][(int)(col)] = 0LL;
                    e[(int)(1LL)] = nr;
                    e[(int)(2LL)] = nc;
                    e[(int)(4LL)] = (energy + PREDATOR_FOOD_VALUE) - 1LL;
                    moved = 1LL;
                    ate = 1LL;
                    break;
                }
                j = j + 1LL;
            }
            if (!(ate)) {
                j = 0LL;
                while (j < 4LL) {
                    long long d = dirs[(int)(j)];
                    long long nr = row + dr[(int)(d)];
                    long long nc = col + dc[(int)(d)];
                    if (inside(nr, nc) && (board[(int)(nr)][(int)(nc)] == 0LL)) {
                        board[(int)(nr)][(int)(nc)] = 2LL;
                        board[(int)(row)][(int)(col)] = 0LL;
                        e[(int)(1LL)] = nr;
                        e[(int)(2LL)] = nc;
                        moved = 1LL;
                        break;
                    }
                    j = j + 1LL;
                }
                e[(int)(4LL)] = energy - 1LL;
            }
            if (e[(int)(4LL)] <= 0LL) {
                e[(int)(5LL)] = 0LL;
                board[(int)(e[(int)(1LL)])][(int)(e[(int)(2LL)])] = 0LL;
            }
        } else {
            long long j = 0LL;
            while (j < 4LL) {
                long long d = dirs[(int)(j)];
                long long nr = row + dr[(int)(d)];
                long long nc = col + dc[(int)(d)];
                if (inside(nr, nc) && (board[(int)(nr)][(int)(nc)] == 0LL)) {
                    board[(int)(nr)][(int)(nc)] = 1LL;
                    board[(int)(row)][(int)(col)] = 0LL;
                    e[(int)(1LL)] = nr;
                    e[(int)(2LL)] = nc;
                    moved = 1LL;
                    break;
                }
                j = j + 1LL;
            }
        }
        if (e[(int)(5LL)] == 1LL) {
            if (moved && (repro <= 0LL)) {
                if (typ == TYPE_PREY) {
                    board[(int)(old_r)][(int)(old_c)] = 1LL;
                    entities = list_append_long_longptr(entities, &entities_len, create_prey(old_r, old_c));
                    entities_lens = list_append_szt(entities_lens, &entities_lens_len, create_prey_len);
                    e[(int)(3LL)] = PREY_REPRODUCTION_TIME;
                } else {
                    board[(int)(old_r)][(int)(old_c)] = 2LL;
                    entities = list_append_long_longptr(entities, &entities_len, create_predator(old_r, old_c));
                    entities_lens = list_append_szt(entities_lens, &entities_lens_len, create_predator_len);
                    e[(int)(3LL)] = PREDATOR_REPRODUCTION_TIME;
                }
            } else {
                e[(int)(3LL)] = repro - 1LL;
            }
        }
        i = i + 1LL;
    }
    long long **alive = NULL;
    size_t alive_len = 0;
    size_t *alive_lens = NULL;
    size_t alive_lens_len = 0;
    long long k = 0LL;
    while (k < entities_len) {
        long long *e2 = entities[(int)(k)];
        size_t e2_len = entities_lens[k];
        if (e2[(int)(5LL)] == 1LL) {
            alive = list_append_long_longptr(alive, &alive_len, e2);
            alive_lens = list_append_szt(alive_lens, &alive_lens_len, e2_len);
        }
        k = k + 1LL;
    }
    entities = alive;
    entities_len = alive_len;
    entities_lens = alive_lens;
    entities_lens_len = alive_lens_len;
}

long long count_entities(long long typ) {
    long long cnt = 0LL;
    long long i = 0LL;
    while (i < entities_len) {
        if ((entities[(int)(i)][(int)(0LL)] == typ) && (entities[(int)(i)][(int)(5LL)] == 1LL)) {
            cnt = cnt + 1LL;
        }
        i = i + 1LL;
    }
    return cnt;
}

int main(void) {
    {
        long long __start = _now();
        board = create_board();
        board_len = create_board_len;
        board_lens = create_board_lens;
        setup();
        while (t < 10LL) {
            step_world();
            t = t + 1LL;
        }
        puts(str_concat("Prey: ", str_int(count_entities(TYPE_PREY))));
        puts(str_concat("Predators: ", str_int(count_entities(TYPE_PREDATOR))));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
