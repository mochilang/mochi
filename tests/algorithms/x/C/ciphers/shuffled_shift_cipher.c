// Generated by Mochi 0.10.32 on 2025-08-07 16:48 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t neg_pos_len;
size_t passcode_creator_len;
size_t unique_sorted_len;
size_t make_key_list_len;

static int contains_str(const char *arr[], size_t len, const char *val) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(arr[i], val) == 0) return 1;
    }
    return 0;
}

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Cipher Cipher;

struct Cipher {
    const char* *passcode;
    size_t passcode_len;
    const char* *key_list;
    size_t key_list_len;
    long long shift_key;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Cipher ssc;
const char* encoded = "";

long long ord(const char* ch);
long long * neg_pos(long long * iterlist, size_t iterlist_len);
const char* * passcode_creator();
const char* * unique_sorted(const char* * chars, size_t chars_len);
const char* * make_key_list(const char* * passcode, size_t passcode_len);
long long make_shift_key(const char* * passcode, size_t passcode_len);
Cipher new_cipher(const char* passcode_str);
long long index_of(const char* * lst, size_t lst_len, const char* ch);
const char* encrypt(Cipher c, const char* plaintext);
const char* decrypt(Cipher c, const char* encoded_message);
const char* test_end_to_end();
int main(void);

long long ord(const char* ch) {
    const char* digits = "0123456789";
    long long i = 0LL;
    while (i < strlen(digits)) {
        if (strcmp(_substring(digits, i, i + 1LL), ch) == 0) {
            return 48LL + i;
        }
        i = i + 1LL;
    }
    const char* upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    i = 0LL;
    while (i < strlen(upper)) {
        if (strcmp(_substring(upper, i, i + 1LL), ch) == 0) {
            return 65LL + i;
        }
        i = i + 1LL;
    }
    const char* lower = "abcdefghijklmnopqrstuvwxyz";
    i = 0LL;
    while (i < strlen(lower)) {
        if (strcmp(_substring(lower, i, i + 1LL), ch) == 0) {
            return 97LL + i;
        }
        i = i + 1LL;
    }
    return 0LL;
}

long long * neg_pos(long long * iterlist, size_t iterlist_len) {
    long long i = 1LL;
    while (i < iterlist_len) {
        iterlist[(int)(i)] = -(iterlist[(int)(i)]);
        i = i + 2LL;
    }
    return neg_pos_len = iterlist_len, iterlist;
}

const char* * passcode_creator() {
    const char* choices = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    long long seed = _now();
    long long length = 10LL + (seed % 11LL);
    const char* *password = NULL;
    size_t password_len = 0;
    long long i = 0LL;
    while (i < length) {
        seed = ((seed * 1103515245LL) + 12345LL) % 2147483647LL;
        long long idx = seed % strlen(choices);
        password = list_append_str(password, &password_len, _substring(choices, idx, idx + 1LL));
        i = i + 1LL;
    }
    return passcode_creator_len = password_len, password;
}

const char* * unique_sorted(const char* * chars, size_t chars_len) {
    const char* *uniq = NULL;
    size_t uniq_len = 0;
    long long i = 0LL;
    while (i < chars_len) {
        const char* ch = chars[(int)(i)];
        if (!(contains_str(uniq, uniq_len, ch))) {
            uniq = list_append_str(uniq, &uniq_len, ch);
        }
        i = i + 1LL;
    }
    long long j = 0LL;
    while (j < uniq_len) {
        long long k = j + 1LL;
        long long min_idx = j;
        while (k < uniq_len) {
            if (strcmp(uniq[(int)(k)], uniq[(int)(min_idx)]) < 0) {
                min_idx = k;
            }
            k = k + 1LL;
        }
        if (min_idx != j) {
            const char* tmp = uniq[(int)(j)];
            uniq[(int)(j)] = uniq[(int)(min_idx)];
            uniq[(int)(min_idx)] = tmp;
        }
        j = j + 1LL;
    }
    return unique_sorted_len = uniq_len, uniq;
}

const char* * make_key_list(const char* * passcode, size_t passcode_len) {
    const char* key_list_options = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n";
    const char* *breakpoints = unique_sorted(passcode, passcode_len);
    size_t breakpoints_len = unique_sorted_len;
    const char* *keys_l = NULL;
    size_t keys_l_len = 0;
    const char* *temp_list = NULL;
    size_t temp_list_len = 0;
    long long i = 0LL;
    while (i < strlen(key_list_options)) {
        const char* ch = _substring(key_list_options, i, i + 1LL);
        temp_list = list_append_str(temp_list, &temp_list_len, ch);
        if ((contains_str(breakpoints, breakpoints_len, ch)) || (i == (strlen(key_list_options) - 1LL))) {
            long long k = temp_list_len - 1LL;
            while (k >= 0LL) {
                keys_l = list_append_str(keys_l, &keys_l_len, temp_list[(int)(k)]);
                k = k - 1LL;
            }
            temp_list = NULL;
            temp_list_len = 0;
        }
        i = i + 1LL;
    }
    return make_key_list_len = keys_l_len, keys_l;
}

long long make_shift_key(const char* * passcode, size_t passcode_len) {
    long long *codes = NULL;
    size_t codes_len = 0;
    long long i = 0LL;
    while (i < passcode_len) {
        codes = list_append_long_long(codes, &codes_len, ord(passcode[(int)(i)]));
        i = i + 1LL;
    }
    codes = neg_pos(codes, codes_len);
    codes_len = neg_pos_len;
    long long total = 0LL;
    i = 0LL;
    while (i < codes_len) {
        total = total + codes[(int)(i)];
        i = i + 1LL;
    }
    if (total > 0LL) {
        return total;
    }
    return passcode_len;
}

Cipher new_cipher(const char* passcode_str) {
    const char* *passcode = NULL;
    size_t passcode_len = 0;
    if (strlen(passcode_str) == 0LL) {
        passcode = passcode_creator();
        passcode_len = passcode_creator_len;
    } else {
        long long i = 0LL;
        while (i < strlen(passcode_str)) {
            passcode = list_append_str(passcode, &passcode_len, _substring(passcode_str, i, i + 1LL));
            i = i + 1LL;
        }
    }
    const char* *key_list = make_key_list(passcode, passcode_len);
    size_t key_list_len = make_key_list_len;
    long long shift_key = make_shift_key(passcode, passcode_len);
    return (Cipher){.passcode = passcode, .passcode_len = passcode_len, .key_list = key_list, .key_list_len = key_list_len, .shift_key = shift_key};
}

long long index_of(const char* * lst, size_t lst_len, const char* ch) {
    long long i = 0LL;
    while (i < lst_len) {
        if (strcmp(lst[(int)(i)], ch) == 0) {
            return i;
        }
        i = i + 1LL;
    }
    return -1LL;
}

const char* encrypt(Cipher c, const char* plaintext) {
    const char* encoded = "";
    long long i = 0LL;
    long long n = c.key_list_len;
    while (i < strlen(plaintext)) {
        const char* ch = _substring(plaintext, i, i + 1LL);
        long long position = index_of(c.key_list, c.key_list_len, ch);
        long long new_pos = (position + c.shift_key) % n;
        encoded = str_concat(encoded, c.key_list[(int)(new_pos)]);
        i = i + 1LL;
    }
    return encoded;
}

const char* decrypt(Cipher c, const char* encoded_message) {
    const char* decoded = "";
    long long i = 0LL;
    long long n = c.key_list_len;
    while (i < strlen(encoded_message)) {
        const char* ch = _substring(encoded_message, i, i + 1LL);
        long long position = index_of(c.key_list, c.key_list_len, ch);
        long long new_pos = (position - c.shift_key) % n;
        if (new_pos < 0LL) {
            new_pos = new_pos + n;
        }
        decoded = str_concat(decoded, c.key_list[(int)(new_pos)]);
        i = i + 1LL;
    }
    return decoded;
}

const char* test_end_to_end() {
    const char* msg = "Hello, this is a modified Caesar cipher";
    Cipher cip = new_cipher("");
    return decrypt(cip, encrypt(cip, msg));
}

int main(void) {
    {
        long long __start = _now();
        ssc = new_cipher("4PYIXyqeQZr44");
        encoded = encrypt(ssc, "Hello, this is a modified Caesar cipher");
        puts(encoded);
        puts(decrypt(ssc, encoded));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
