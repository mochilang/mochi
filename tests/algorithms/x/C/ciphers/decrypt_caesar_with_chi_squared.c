// Generated by Mochi 0.10.32 on 2025-08-07 11:03 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <ctype.h>
#include <math.h>

size_t default_alphabet_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%g", v);
    return strdup(buf);
}

static char* str_upper(const char *s) {
    size_t n = strlen(s);
    char *out = strdup(s);
    for(size_t i=0;i<n;i++) out[i] = toupper((unsigned char)out[i]);
    return out;
}

static char* str_lower(const char *s) {
    size_t n = strlen(s);
    char *out = strdup(s);
    for(size_t i=0;i<n;i++) out[i] = tolower((unsigned char)out[i]);
    return out;
}

typedef struct { const char **keys; double *vals; size_t len; size_t cap; } MapSD;

static double map_get_sd(const char *keys[], const double vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Anon1 Anon1;
typedef struct Anon2 Anon2;
typedef struct Result Result;

struct Anon1 {
    double a;
    double b;
    double c;
    double d;
    double e;
    double f;
    double g;
    double h;
    double i;
    double j;
    double k;
    double l;
    double m;
    double n;
    double o;
    double p;
    double q;
    double r;
    double s;
    double t;
    double u;
    double v;
    double w;
    double x;
    double y;
    double z;
};

struct Anon2 {
};

struct Result {
    long long shift;
    double chi;
    const char* decoded;
};

Result r1;
Result r2;
Result r3;

const char* * default_alphabet();
MapSD default_frequencies();
long long index_of(const char* * xs, size_t xs_len, const char* ch);
long long count_char(const char* s, const char* ch);
Result decrypt_caesar_with_chi_squared(const char* ciphertext, const char* * cipher_alphabet, size_t cipher_alphabet_len, MapSD frequencies_dict, long long case_sensitive);
int main(void);

const char* * default_alphabet() {
    {
        static const char* __tmp0_arr[26];
        __tmp0_arr[0] = "a";
        __tmp0_arr[1] = "b";
        __tmp0_arr[2] = "c";
        __tmp0_arr[3] = "d";
        __tmp0_arr[4] = "e";
        __tmp0_arr[5] = "f";
        __tmp0_arr[6] = "g";
        __tmp0_arr[7] = "h";
        __tmp0_arr[8] = "i";
        __tmp0_arr[9] = "j";
        __tmp0_arr[10] = "k";
        __tmp0_arr[11] = "l";
        __tmp0_arr[12] = "m";
        __tmp0_arr[13] = "n";
        __tmp0_arr[14] = "o";
        __tmp0_arr[15] = "p";
        __tmp0_arr[16] = "q";
        __tmp0_arr[17] = "r";
        __tmp0_arr[18] = "s";
        __tmp0_arr[19] = "t";
        __tmp0_arr[20] = "u";
        __tmp0_arr[21] = "v";
        __tmp0_arr[22] = "w";
        __tmp0_arr[23] = "x";
        __tmp0_arr[24] = "y";
        __tmp0_arr[25] = "z";
        default_alphabet_len = 26;
        return __tmp0_arr;
    }
}

MapSD default_frequencies() {
    {
        static const char* __ret1_keys[26] = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"};
        static double __ret1_vals[26] = {0.08497, 0.01492, 0.02202, 0.04253, 0.11162, 0.02228, 0.02015, 0.06094, 0.07546, 0.00153, 0.01292, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.07587, 0.06327, 0.09356, 0.02758, 0.00978, 0.0256, 0.0015, 0.01994, 0.00077};
        MapSD __ret1 = { __ret1_keys, __ret1_vals, 26, 42 };
        return __ret1;
    }
}

long long index_of(const char* * xs, size_t xs_len, const char* ch) {
    long long i = 0LL;
    while (i < xs_len) {
        if (strcmp(xs[(int)(i)], ch) == 0) {
            return i;
        }
        i = i + 1LL;
    }
    return -1LL;
}

long long count_char(const char* s, const char* ch) {
    long long count = 0LL;
    long long i = 0LL;
    while (i < strlen(s)) {
        if (strcmp(_substring(s, i, i + 1LL), ch) == 0) {
            count = count + 1LL;
        }
        i = i + 1LL;
    }
    return count;
}

Result decrypt_caesar_with_chi_squared(const char* ciphertext, const char* * cipher_alphabet, size_t cipher_alphabet_len, MapSD frequencies_dict, long long case_sensitive) {
    const char* *alphabet_letters = cipher_alphabet;
    size_t alphabet_letters_len = cipher_alphabet_len;
    if (alphabet_letters_len == 0LL) {
        alphabet_letters = default_alphabet();
        alphabet_letters_len = default_alphabet_len;
    }
    MapSD frequencies = frequencies_dict;
    size_t frequencies_len = frequencies_dict.len;
    if (frequencies_len == 0LL) {
        frequencies = default_frequencies();
    }
    if (!(case_sensitive)) {
        ciphertext = str_lower(ciphertext);
    }
    long long best_shift = 0LL;
    double best_chi = 0.0;
    const char* best_text = "";
    long long shift = 0LL;
    while (shift < alphabet_letters_len) {
        const char* decrypted = "";
        long long i = 0LL;
        while (i < strlen(ciphertext)) {
            const char* ch = _substring(ciphertext, i, i + 1LL);
            long long idx = index_of(alphabet_letters, alphabet_letters_len, str_lower(ch));
            if (idx >= 0LL) {
                long long m = alphabet_letters_len;
                long long new_idx = (idx - shift) % m;
                if (new_idx < 0LL) {
                    new_idx = new_idx + m;
                }
                const char* new_char = alphabet_letters[(int)(new_idx)];
                if (case_sensitive && (strcmp(ch, str_lower(ch)) != 0)) {
                    decrypted = str_concat(decrypted, str_upper(new_char));
                } else {
                    decrypted = str_concat(decrypted, new_char);
                }
            } else {
                decrypted = str_concat(decrypted, ch);
            }
            i = i + 1LL;
        }
        double chi = 0.0;
        const char* lowered = (case_sensitive ? str_lower(decrypted) : decrypted);
        long long j = 0LL;
        while (j < alphabet_letters_len) {
            const char* letter = alphabet_letters[(int)(j)];
            long long occ = count_char(lowered, letter);
            if (occ > 0LL) {
                double occf = (double)(occ);
                double expected = map_get_sd(frequencies.keys, frequencies.vals, frequencies.len, letter) * occf;
                double diff = occf - expected;
                chi = chi + (((diff * diff) / expected) * occf);
            }
            j = j + 1LL;
        }
        if ((shift == 0LL) || (chi < best_chi)) {
            best_shift = shift;
            best_chi = chi;
            best_text = decrypted;
        }
        shift = shift + 1LL;
    }
    return (Result){.shift = best_shift, .chi = best_chi, .decoded = best_text};
}

int main(void) {
    {
        long long __start = _now();
        r1 = decrypt_caesar_with_chi_squared("dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!", NULL, 0, (MapSD){0}, 0LL);
        puts(str_concat(str_concat(str_concat(str_concat(str_int(r1.shift), ", "), str_float(r1.chi)), ", "), r1.decoded));
        r2 = decrypt_caesar_with_chi_squared("crybd cdbsxq", NULL, 0, (MapSD){0}, 0LL);
        puts(str_concat(str_concat(str_concat(str_concat(str_int(r2.shift), ", "), str_float(r2.chi)), ", "), r2.decoded));
        r3 = decrypt_caesar_with_chi_squared("Crybd Cdbsxq", NULL, 0, (MapSD){0}, 1LL);
        puts(str_concat(str_concat(str_concat(str_concat(str_int(r3.shift), ", "), str_float(r3.chi)), ", "), r3.decoded));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
