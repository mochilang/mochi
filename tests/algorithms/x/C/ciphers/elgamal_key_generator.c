// Generated by Mochi 0.10.32 on 2025-08-07 11:03 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct GCD GCD;
typedef struct PrivateKey PrivateKey;
typedef struct PublicKey PublicKey;
typedef struct KeyPair KeyPair;

struct GCD {
    long long g;
    long long x;
    long long y;
};

struct PrivateKey {
    long long key_size;
    long long d;
};

struct PublicKey {
    long long key_size;
    long long g;
    long long e2;
    long long p;
};

struct KeyPair {
    PublicKey public_key;
    PrivateKey private_key;
};

long long seed = 123456789LL;

long long user_rand();
long long rand_range(long long min, long long max);
long long mod_pow(long long base, long long exponent, long long modulus);
GCD extended_gcd(long long a, long long b);
long long mod_inverse(long long a, long long m);
long long pow2(long long n);
long long is_probable_prime(long long n, long long k);
long long generate_large_prime(long long bits);
long long primitive_root(long long p);
KeyPair generate_key(long long key_size);
void user_main();
int main(void);

long long user_rand() {
    seed = ((seed * 1103515245LL) + 12345LL) % 2147483647LL;
    return seed;
}

long long rand_range(long long min, long long max) {
    return min + (user_rand() % ((max - min) + 1LL));
}

long long mod_pow(long long base, long long exponent, long long modulus) {
    long long result = 1LL;
    long long b = base % modulus;
    long long e = exponent;
    while (e > 0LL) {
        if ((e % 2LL) == 1LL) {
            result = (result * b) % modulus;
        }
        e = e / 2LL;
        b = (b * b) % modulus;
    }
    return result;
}

GCD extended_gcd(long long a, long long b) {
    if (b == 0LL) {
        return (GCD){.g = a, .x = 1LL, .y = 0LL};
    }
    GCD res = extended_gcd(b, a % b);
    return (GCD){.g = res.g, .x = res.y, .y = res.x - ((a / b) * res.y)};
}

long long mod_inverse(long long a, long long m) {
    GCD res = extended_gcd(a, m);
    if (res.g != 1LL) {
        panic("inverse does not exist");
    }
    long long r = res.x % m;
    if (r < 0LL) {
        return r + m;
    }
    return r;
}

long long pow2(long long n) {
    long long r = 1LL;
    long long i = 0LL;
    while (i < n) {
        r = r * 2LL;
        i = i + 1LL;
    }
    return r;
}

long long is_probable_prime(long long n, long long k) {
    if (n <= 1LL) {
        return 0LL;
    }
    if (n <= 3LL) {
        return 1LL;
    }
    if ((n % 2LL) == 0LL) {
        return 0LL;
    }
    long long r = 0LL;
    long long d = n - 1LL;
    while ((d % 2LL) == 0LL) {
        d = d / 2LL;
        r = r + 1LL;
    }
    long long i = 0LL;
    while (i < k) {
        long long a = rand_range(2LL, n - 2LL);
        long long x = mod_pow(a, d, n);
        if ((x == 1LL) || (x == (n - 1LL))) {
            i = i + 1LL;
            continue;
        }
        long long j = 1LL;
        long long found = 0LL;
        while (j < r) {
            x = mod_pow(x, 2LL, n);
            if (x == (n - 1LL)) {
                found = 1LL;
                break;
            }
            j = j + 1LL;
        }
        if (!(found)) {
            return 0LL;
        }
        i = i + 1LL;
    }
    return 1LL;
}

long long generate_large_prime(long long bits) {
    long long min = pow2(bits - 1LL);
    long long max = pow2(bits) - 1LL;
    long long p = rand_range(min, max);
    if ((p % 2LL) == 0LL) {
        p = p + 1LL;
    }
    while (!(is_probable_prime(p, 5LL))) {
        p = p + 2LL;
        if (p > max) {
            p = min + 1LL;
        }
    }
    return p;
}

long long primitive_root(long long p) {
    while (1LL) {
        long long g = rand_range(3LL, p - 1LL);
        if (mod_pow(g, 2LL, p) == 1LL) {
            continue;
        }
        if (mod_pow(g, p, p) == 1LL) {
            continue;
        }
        return g;
    }
}

KeyPair generate_key(long long key_size) {
    long long p = generate_large_prime(key_size);
    long long e1 = primitive_root(p);
    long long d = rand_range(3LL, p - 1LL);
    long long e2 = mod_inverse(mod_pow(e1, d, p), p);
    PublicKey public_key = (PublicKey){.key_size = key_size, .g = e1, .e2 = e2, .p = p};
    PrivateKey private_key = (PrivateKey){.key_size = key_size, .d = d};
    return (KeyPair){.public_key = public_key, .private_key = private_key};
}

void user_main() {
    long long key_size = 16LL;
    KeyPair kp = generate_key(key_size);
    PublicKey pub = kp.public_key;
    PrivateKey priv = kp.private_key;
    puts(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat("public key: (", str_int(pub.key_size)), ", "), str_int(pub.g)), ", "), str_int(pub.e2)), ", "), str_int(pub.p)), ")"));
    puts(str_concat(str_concat(str_concat(str_concat("private key: (", str_int(priv.key_size)), ", "), str_int(priv.d)), ")"));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
