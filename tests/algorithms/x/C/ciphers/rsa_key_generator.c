// Generated by Mochi 0.10.32 on 2025-08-07 16:48 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Keys Keys;

struct Keys {
    long long *public_key;
    size_t public_key_len;
    long long *private_key;
    size_t private_key_len;
};

long long seed = 1LL;
Keys keys;
long long *pub = NULL;
size_t pub_len = 0;
long long *priv = NULL;
size_t priv_len = 0;

long long pow2(long long exp);
long long next_seed(long long x);
long long rand_range(long long min, long long max);
long long gcd(long long a, long long b);
long long mod_inverse(long long e, long long phi);
long long is_prime(long long n);
long long generate_prime(long long bits);
Keys generate_key(long long bits);
int main(void);

long long pow2(long long exp) {
    long long res = 1LL;
    long long i = 0LL;
    while (i < exp) {
        res = res * 2LL;
        i = i + 1LL;
    }
    return res;
}

long long next_seed(long long x) {
    return ((x * 1103515245LL) + 12345LL) % 2147483648LL;
}

long long rand_range(long long min, long long max) {
    seed = next_seed(seed);
    return min + (seed % (max - min));
}

long long gcd(long long a, long long b) {
    long long x = a;
    long long y = b;
    while (y != 0LL) {
        long long temp = x % y;
        x = y;
        y = temp;
    }
    return x;
}

long long mod_inverse(long long e, long long phi) {
    long long t = 0LL;
    long long newt = 1LL;
    long long r = phi;
    long long newr = e;
    while (newr != 0LL) {
        long long quotient = r / newr;
        long long tmp = newt;
        newt = t - (quotient * newt);
        t = tmp;
        long long tmp_r = newr;
        newr = r - (quotient * newr);
        r = tmp_r;
    }
    if (r > 1LL) {
        return 0LL;
    }
    if (t < 0LL) {
        t = t + phi;
    }
    return t;
}

long long is_prime(long long n) {
    if (n < 2LL) {
        return 0LL;
    }
    long long i = 2LL;
    while ((i * i) <= n) {
        if ((n % i) == 0LL) {
            return 0LL;
        }
        i = i + 1LL;
    }
    return 1LL;
}

long long generate_prime(long long bits) {
    long long min = pow2(bits - 1LL);
    long long max = pow2(bits);
    long long p = rand_range(min, max);
    if ((p % 2LL) == 0LL) {
        p = p + 1LL;
    }
    while (!(is_prime(p))) {
        p = p + 2LL;
        if (p >= max) {
            p = min + 1LL;
        }
    }
    return p;
}

Keys generate_key(long long bits) {
    long long p = generate_prime(bits);
    long long q = generate_prime(bits);
    long long n = p * q;
    long long phi = (p - 1LL) * (q - 1LL);
    long long e = rand_range(2LL, phi);
    while (gcd(e, phi) != 1LL) {
        e = e + 1LL;
        if (e >= phi) {
            e = 2LL;
        }
    }
    long long d = mod_inverse(e, phi);
    return (Keys){.public_key = (int[]){ n, e }, .public_key_len = 2, .private_key = (int[]){ n, d }, .private_key_len = 2};
}

int main(void) {
    {
        long long __start = _now();
        keys = generate_key(8LL);
        pub = keys.public_key;
        priv = keys.private_key;
        puts(str_concat(str_concat(str_concat(str_concat("Public key: (", str_int(pub[(int)(0LL)])), ", "), str_int(pub[(int)(1LL)])), ")"));
        puts(str_concat(str_concat(str_concat(str_concat("Private key: (", str_int(priv[(int)(0LL)])), ", "), str_int(priv[(int)(1LL)])), ")"));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
