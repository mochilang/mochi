// Generated by Mochi 0.10.32 on 2025-08-24 14:55 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <ctype.h>
#include <math.h>


size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_lower(const char *s) {
    size_t n = strlen(s);
    char *out = strdup(s);
    for(size_t i=0;i<n;i++) out[i] = tolower((unsigned char)out[i]);
    return out;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

const char* rstrip_s(const char* s);
const char* normalize_alias(const char* u);
long long has_unit(const char* u);
double from_factor(const char* u);
double to_factor(const char* u);
double length_conversion(double value, const char* from_type, const char* to_type);
int main(void);

const char* rstrip_s(const char* s) {
    if ((strlen(s) > 0LL) && (strcmp((const char[]){s[strlen(s) - 1LL], 0}, "s") == 0)) {
        return _substring(s, 0LL, strlen(s) - 1LL);
    }
    return s;
}

const char* normalize_alias(const char* u) {
    if (strcmp(u, "millimeter") == 0) {
        return "mm";
    }
    if (strcmp(u, "centimeter") == 0) {
        return "cm";
    }
    if (strcmp(u, "meter") == 0) {
        return "m";
    }
    if (strcmp(u, "kilometer") == 0) {
        return "km";
    }
    if (strcmp(u, "inch") == 0) {
        return "in";
    }
    if (strcmp(u, "inche") == 0) {
        return "in";
    }
    if (strcmp(u, "feet") == 0) {
        return "ft";
    }
    if (strcmp(u, "foot") == 0) {
        return "ft";
    }
    if (strcmp(u, "yard") == 0) {
        return "yd";
    }
    if (strcmp(u, "mile") == 0) {
        return "mi";
    }
    return u;
}

long long has_unit(const char* u) {
    return (((((((strcmp(u, "mm") == 0) || (strcmp(u, "cm") == 0)) || (strcmp(u, "m") == 0)) || (strcmp(u, "km") == 0)) || (strcmp(u, "in") == 0)) || (strcmp(u, "ft") == 0)) || (strcmp(u, "yd") == 0)) || (strcmp(u, "mi") == 0);
}

double from_factor(const char* u) {
    if (strcmp(u, "mm") == 0) {
        return 0.001;
    }
    if (strcmp(u, "cm") == 0) {
        return 0.01;
    }
    if (strcmp(u, "m") == 0) {
        return 1.0;
    }
    if (strcmp(u, "km") == 0) {
        return 1000.0;
    }
    if (strcmp(u, "in") == 0) {
        return 0.0254;
    }
    if (strcmp(u, "ft") == 0) {
        return 0.3048;
    }
    if (strcmp(u, "yd") == 0) {
        return 0.9144;
    }
    if (strcmp(u, "mi") == 0) {
        return 1609.34;
    }
    return 0.0;
}

double to_factor(const char* u) {
    if (strcmp(u, "mm") == 0) {
        return 1000.0;
    }
    if (strcmp(u, "cm") == 0) {
        return 100.0;
    }
    if (strcmp(u, "m") == 0) {
        return 1.0;
    }
    if (strcmp(u, "km") == 0) {
        return 0.001;
    }
    if (strcmp(u, "in") == 0) {
        return 39.3701;
    }
    if (strcmp(u, "ft") == 0) {
        return 3.28084;
    }
    if (strcmp(u, "yd") == 0) {
        return 1.09361;
    }
    if (strcmp(u, "mi") == 0) {
        return 0.000621371;
    }
    return 0.0;
}

double length_conversion(double value, const char* from_type, const char* to_type) {
    const char* new_from = normalize_alias(rstrip_s(str_lower(from_type)));
    const char* new_to = normalize_alias(rstrip_s(str_lower(to_type)));
    if (!(has_unit(new_from))) {
        panic(str_concat(str_concat("Invalid 'from_type' value: '", from_type), "'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"));
    }
    if (!(has_unit(new_to))) {
        panic(str_concat(str_concat("Invalid 'to_type' value: '", to_type), "'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"));
    }
    return (value * from_factor(new_from)) * to_factor(new_to);
}

int main(void) {
    {
        long long __start = _now();
        printf("%g\n", length_conversion(4.0, "METER", "FEET"));
        printf("%g\n", length_conversion(1.0, "kilometer", "inch"));
        printf("%g\n", length_conversion(2.0, "feet", "meter"));
        printf("%g\n", length_conversion(2.0, "centimeter", "millimeter"));
        printf("%g\n", length_conversion(4.0, "yard", "kilometer"));
        printf("%g\n", length_conversion(3.0, "foot", "inch"));
        printf("%g\n", length_conversion(3.0, "mm", "in"));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
