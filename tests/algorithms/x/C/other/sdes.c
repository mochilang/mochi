// Generated by Mochi 0.10.32 on 2025-08-23 13:39 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

static int _char_at(const char *s, int idx) {
    int len = (int)strlen(s);
    if (idx < 0 || idx >= len) return 0;
    return (unsigned char)s[idx];
}

long long p4_table_init[4] = {2LL, 4LL, 3LL, 1LL};
long long *p4_table = p4_table_init;
size_t p4_table_len = 4;
const char* key = "1010000010";
const char* message = "11010111";
long long p8_table_init[8] = {6LL, 3LL, 7LL, 4LL, 8LL, 5LL, 10LL, 9LL};
long long *p8_table = p8_table_init;
size_t p8_table_len = 8;
long long p10_table_init[10] = {3LL, 5LL, 2LL, 7LL, 4LL, 10LL, 1LL, 9LL, 8LL, 6LL};
long long *p10_table = p10_table_init;
size_t p10_table_len = 10;
long long IP_init[8] = {2LL, 6LL, 3LL, 1LL, 4LL, 8LL, 5LL, 7LL};
long long *IP = IP_init;
size_t IP_len = 8;
long long IP_inv_init[8] = {4LL, 1LL, 3LL, 5LL, 7LL, 2LL, 8LL, 6LL};
long long *IP_inv = IP_inv_init;
size_t IP_inv_len = 8;
long long expansion_init[8] = {4LL, 1LL, 2LL, 3LL, 2LL, 3LL, 4LL, 1LL};
long long *expansion = expansion_init;
size_t expansion_len = 8;
long long s0_0[4] = {1LL, 0LL, 3LL, 2LL};
long long s0_1[4] = {3LL, 2LL, 1LL, 0LL};
long long s0_2[4] = {0LL, 2LL, 1LL, 3LL};
long long s0_3[4] = {3LL, 1LL, 3LL, 2LL};
long long *s0_init[4] = {s0_0, s0_1, s0_2, s0_3};
long long **s0 = s0_init;
size_t s0_len = 4;
size_t s0_lens_init[4] = {4, 4, 4, 4};
size_t *s0_lens = s0_lens_init;
size_t s0_lens_len = 4;
long long s1_0[4] = {0LL, 1LL, 2LL, 3LL};
long long s1_1[4] = {2LL, 0LL, 1LL, 3LL};
long long s1_2[4] = {3LL, 0LL, 1LL, 0LL};
long long s1_3[4] = {2LL, 1LL, 0LL, 3LL};
long long *s1_init[4] = {s1_0, s1_1, s1_2, s1_3};
long long **s1 = s1_init;
size_t s1_len = 4;
size_t s1_lens_init[4] = {4, 4, 4, 4};
size_t *s1_lens = s1_lens_init;
size_t s1_lens_len = 4;
const char* temp = "";
const char* left = "";
const char* right = "";
const char* key1 = "";
const char* key2 = "";
const char* CT = "";
const char* PT = "";

const char* apply_table(const char* inp, long long * table, size_t table_len);
const char* left_shift(const char* data);
const char* xor(const char* a, const char* b);
const char* int_to_binary(long long n);
const char* pad_left(const char* s, long long width);
long long bin_to_int(const char* s);
const char* apply_sbox(long long * * s, size_t s_len, size_t* s_lens, size_t s_lens_len, const char* data);
const char* f(long long * expansion, size_t expansion_len, long long * * s0, size_t s0_len, size_t* s0_lens, size_t s0_lens_len, long long * * s1, size_t s1_len, size_t* s1_lens, size_t s1_lens_len, const char* key, const char* message);
int main(void);

const char* apply_table(const char* inp, long long * table, size_t table_len) {
    const char* res = "";
    long long i = 0LL;
    while (i < table_len) {
        long long idx = table[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? table_len + _mochi_idx : _mochi_idx;})] - 1LL;
        if (idx < 0LL) {
            idx = strlen(inp) - 1LL;
        }
        res = str_concat(res, _substring(inp, idx, idx + 1LL));
        i = i + 1LL;
    }
    return res;
}

const char* left_shift(const char* data) {
    return str_concat(_substring(data, 1LL, strlen(data)), _substring(data, 0LL, 1LL));
}

const char* xor(const char* a, const char* b) {
    const char* res = "";
    long long i = 0LL;
    while ((i < strlen(a)) && (i < strlen(b))) {
        if (strcmp(_substring(a, i, i + 1LL), _substring(b, i, i + 1LL)) == 0) {
            res = str_concat(res, "0");
        } else {
            res = str_concat(res, "1");
        }
        i = i + 1LL;
    }
    return res;
}

const char* int_to_binary(long long n) {
    if (n == 0LL) {
        return "0";
    }
    const char* res = "";
    long long num = n;
    while (num > 0LL) {
        res = str_concat(str_int(num % 2LL), res);
        num = num / 2LL;
    }
    return res;
}

const char* pad_left(const char* s, long long width) {
    const char* res = s;
    while (strlen(res) < width) {
        res = str_concat("0", res);
    }
    return res;
}

long long bin_to_int(const char* s) {
    long long result = 0LL;
    long long i = 0LL;
    while (i < strlen(s)) {
        long long digit = (int)(_char_at(_substring(s, i, i + 1LL), i));
        result = (result * 2LL) + digit;
        i = i + 1LL;
    }
    return result;
}

const char* apply_sbox(long long * * s, size_t s_len, size_t* s_lens, size_t s_lens_len, const char* data) {
    const char* row_bits = str_concat(_substring(data, 0LL, 1LL), _substring(data, strlen(data) - 1LL, strlen(data)));
    const char* col_bits = _substring(data, 1LL, 3LL);
    long long row = bin_to_int(row_bits);
    long long col = bin_to_int(col_bits);
    long long val = s[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? s_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = col; _mochi_idx < 0 ? s_lens[(int)(row)] + _mochi_idx : _mochi_idx;})];
    const char* out = int_to_binary(val);
    return out;
}

const char* f(long long * expansion, size_t expansion_len, long long * * s0, size_t s0_len, size_t* s0_lens, size_t s0_lens_len, long long * * s1, size_t s1_len, size_t* s1_lens, size_t s1_lens_len, const char* key, const char* message) {
    const char* left = _substring(message, 0LL, 4LL);
    const char* right = _substring(message, 4LL, 8LL);
    const char* temp = apply_table(right, expansion, expansion_len);
    temp = xor(temp, key);
    const char* left_bin_str = apply_sbox(s0, s0_len, s0_lens, s0_len, _substring(temp, 0LL, 4LL));
    const char* right_bin_str = apply_sbox(s1, s1_len, s1_lens, s1_len, _substring(temp, 4LL, 8LL));
    left_bin_str = pad_left(left_bin_str, 2LL);
    right_bin_str = pad_left(right_bin_str, 2LL);
    temp = apply_table(str_concat(left_bin_str, right_bin_str), p4_table, p4_table_len);
    temp = xor(left, temp);
    return str_concat(temp, right);
}

int main(void) {
    {
        long long __start = _now();
        temp = apply_table(key, p10_table, p10_table_len);
        left = _substring(temp, 0LL, 5LL);
        right = _substring(temp, 5LL, 10LL);
        left = left_shift(left);
        right = left_shift(right);
        key1 = apply_table(str_concat(left, right), p8_table, p8_table_len);
        left = left_shift(left);
        right = left_shift(right);
        left = left_shift(left);
        right = left_shift(right);
        key2 = apply_table(str_concat(left, right), p8_table, p8_table_len);
        temp = apply_table(message, IP, IP_len);
        temp = f(expansion, expansion_len, s0, s0_len, s0_lens, s0_len, s1, s1_len, s1_lens, s1_len, key1, temp);
        temp = str_concat(_substring(temp, 4LL, 8LL), _substring(temp, 0LL, 4LL));
        temp = f(expansion, expansion_len, s0, s0_len, s0_lens, s0_len, s1, s1_len, s1_lens, s1_len, key2, temp);
        CT = apply_table(temp, IP_inv, IP_inv_len);
        puts(str_concat("Cipher text is: ", CT));
        temp = apply_table(CT, IP, IP_len);
        temp = f(expansion, expansion_len, s0, s0_len, s0_lens, s0_len, s1, s1_len, s1_lens, s1_len, key2, temp);
        temp = str_concat(_substring(temp, 4LL, 8LL), _substring(temp, 0LL, 4LL));
        temp = f(expansion, expansion_len, s0, s0_len, s0_lens, s0_len, s1, s1_len, s1_lens, s1_len, key1, temp);
        PT = apply_table(temp, IP_inv, IP_inv_len);
        puts(str_concat("Plain text after decypting is: ", PT));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
