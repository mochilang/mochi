// Generated by Mochi 0.10.32 on 2025-08-16 11:14 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long MOD = 4294967296LL;
const char* ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

long long ord(const char* ch);
long long pow2(long long n);
long long bit_and(long long a, long long b);
long long bit_or(long long a, long long b);
long long bit_xor(long long a, long long b);
long long bit_not(long long a);
long long rotate_left(long long n, long long b);
const char* to_hex32(long long n);
const char* sha1(const char* message);
void user_main();
int main(void);

long long ord(const char* ch) {
    long long i = 0LL;
    while (i < strlen(ASCII)) {
        if (strcmp(_substring(ASCII, i, i + 1LL), ch) == 0) {
            return 32LL + i;
        }
        i = i + 1LL;
    }
    return 0LL;
}

long long pow2(long long n) {
    long long res = 1LL;
    long long i = 0LL;
    while (i < n) {
        res = res * 2LL;
        i = i + 1LL;
    }
    return res;
}

long long bit_and(long long a, long long b) {
    long long x = a;
    long long y = b;
    long long res = 0LL;
    long long bit = 1LL;
    long long i = 0LL;
    while (i < 32LL) {
        if (((x % 2LL) == 1LL) && ((y % 2LL) == 1LL)) {
            res = res + bit;
        }
        x = x / 2LL;
        y = y / 2LL;
        bit = bit * 2LL;
        i = i + 1LL;
    }
    return res;
}

long long bit_or(long long a, long long b) {
    long long x = a;
    long long y = b;
    long long res = 0LL;
    long long bit = 1LL;
    long long i = 0LL;
    while (i < 32LL) {
        long long abit = x % 2LL;
        long long bbit = y % 2LL;
        if ((abit == 1LL) || (bbit == 1LL)) {
            res = res + bit;
        }
        x = x / 2LL;
        y = y / 2LL;
        bit = bit * 2LL;
        i = i + 1LL;
    }
    return res;
}

long long bit_xor(long long a, long long b) {
    long long x = a;
    long long y = b;
    long long res = 0LL;
    long long bit = 1LL;
    long long i = 0LL;
    while (i < 32LL) {
        long long abit = x % 2LL;
        long long bbit = y % 2LL;
        if (((abit == 1LL) && (bbit == 0LL)) || ((abit == 0LL) && (bbit == 1LL))) {
            res = res + bit;
        }
        x = x / 2LL;
        y = y / 2LL;
        bit = bit * 2LL;
        i = i + 1LL;
    }
    return res;
}

long long bit_not(long long a) {
    return (MOD - 1LL) - a;
}

long long rotate_left(long long n, long long b) {
    long long left = (n * pow2(b)) % MOD;
    long long right = n / pow2(32LL - b);
    return (left + right) % MOD;
}

const char* to_hex32(long long n) {
    const char* digits = "0123456789abcdef";
    long long num = n;
    const char* s = "";
    if (num == 0LL) {
        s = "0";
    }
    while (num > 0LL) {
        long long d = num % 16LL;
        s = str_concat(_substring(digits, d, d + 1LL), s);
        num = num / 16LL;
    }
    while (strlen(s) < 8LL) {
        s = str_concat("0", s);
    }
    if (strlen(s) > 8LL) {
        s = _substring(s, strlen(s) - 8LL, strlen(s));
    }
    return s;
}

const char* sha1(const char* message) {
    long long *bytes = NULL;
    size_t bytes_len = 0;
    long long i = 0LL;
    while (i < strlen(message)) {
        bytes = list_append_long_long(bytes, &bytes_len, ord(_substring(message, i, i + 1LL)));
        i = i + 1LL;
    }
    bytes = list_append_long_long(bytes, &bytes_len, 128LL);
    while (((bytes_len + 8LL) % 64LL) != 0LL) {
        bytes = list_append_long_long(bytes, &bytes_len, 0LL);
    }
    long long bit_len = strlen(message) * 8LL;
    long long *len_bytes = NULL;
    size_t len_bytes_len = 0;
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    len_bytes = list_append_long_long(len_bytes, &len_bytes_len, 0LL);
    long long bl = bit_len;
    long long k = 7LL;
    while (k >= 0LL) {
        len_bytes[(int)(k)] = bl % 256LL;
        bl = bl / 256LL;
        k = k - 1LL;
    }
    long long j = 0LL;
    while (j < 8LL) {
        bytes = list_append_long_long(bytes, &bytes_len, len_bytes[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? len_bytes_len + _mochi_idx : _mochi_idx;})]);
        j = j + 1LL;
    }
    long long **blocks = NULL;
    size_t blocks_len = 0;
    size_t *blocks_lens = NULL;
    size_t blocks_lens_len = 0;
    long long pos = 0LL;
    while (pos < bytes_len) {
        long long *block = NULL;
        size_t block_len = 0;
        long long j2 = 0LL;
        while (j2 < 64LL) {
            block = list_append_long_long(block, &block_len, bytes[(int)({long long _mochi_idx = pos + j2; _mochi_idx < 0 ? bytes_len + _mochi_idx : _mochi_idx;})]);
            j2 = j2 + 1LL;
        }
        blocks = list_append_intptr(blocks, &blocks_len, block);
        blocks_lens = list_append_szt(blocks_lens, &blocks_lens_len, block_len);
        pos = pos + 64LL;
    }
    long long h0 = 1732584193LL;
    long long h1 = 4023233417LL;
    long long h2 = 2562383102LL;
    long long h3 = 271733878LL;
    long long h4 = 3285377520LL;
    long long bindex = 0LL;
    while (bindex < blocks_len) {
        long long *block = blocks[(int)({long long _mochi_idx = bindex; _mochi_idx < 0 ? blocks_len + _mochi_idx : _mochi_idx;})];
        size_t block_len = blocks_lens[bindex];
        long long *w = NULL;
        size_t w_len = 0;
        long long t = 0LL;
        while (t < 16LL) {
            long long j3 = t * 4LL;
            long long word = (((((block[(int)({long long _mochi_idx = j3; _mochi_idx < 0 ? block_len + _mochi_idx : _mochi_idx;})] * 256LL) + block[(int)({long long _mochi_idx = j3 + 1LL; _mochi_idx < 0 ? block_len + _mochi_idx : _mochi_idx;})]) * 256LL) + block[(int)({long long _mochi_idx = j3 + 2LL; _mochi_idx < 0 ? block_len + _mochi_idx : _mochi_idx;})]) * 256LL) + block[(int)({long long _mochi_idx = j3 + 3LL; _mochi_idx < 0 ? block_len + _mochi_idx : _mochi_idx;})];
            w = list_append_long_long(w, &w_len, word);
            t = t + 1LL;
        }
        while (t < 80LL) {
            long long tmp = bit_xor(bit_xor(bit_xor(w[(int)({long long _mochi_idx = t - 3LL; _mochi_idx < 0 ? w_len + _mochi_idx : _mochi_idx;})], w[(int)({long long _mochi_idx = t - 8LL; _mochi_idx < 0 ? w_len + _mochi_idx : _mochi_idx;})]), w[(int)({long long _mochi_idx = t - 14LL; _mochi_idx < 0 ? w_len + _mochi_idx : _mochi_idx;})]), w[(int)({long long _mochi_idx = t - 16LL; _mochi_idx < 0 ? w_len + _mochi_idx : _mochi_idx;})]);
            w = list_append_long_long(w, &w_len, rotate_left(tmp, 1LL));
            t = t + 1LL;
        }
        long long a = h0;
        long long b = h1;
        long long c = h2;
        long long d = h3;
        long long e = h4;
        long long i2 = 0LL;
        while (i2 < 80LL) {
            long long f = 0LL;
            long long kconst = 0LL;
            if (i2 < 20LL) {
                f = bit_or(bit_and(b, c), bit_and(bit_not(b), d));
                kconst = 1518500249LL;
            } else {
                if (i2 < 40LL) {
                    f = bit_xor(bit_xor(b, c), d);
                    kconst = 1859775393LL;
                } else {
                    if (i2 < 60LL) {
                        f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d));
                        kconst = 2400959708LL;
                    } else {
                        f = bit_xor(bit_xor(b, c), d);
                        kconst = 3395469782LL;
                    }
                }
            }
            long long temp = ((((rotate_left(a, 5LL) + f) + e) + kconst) + w[(int)({long long _mochi_idx = i2; _mochi_idx < 0 ? w_len + _mochi_idx : _mochi_idx;})]) % MOD;
            e = d;
            d = c;
            c = rotate_left(b, 30LL);
            b = a;
            a = temp;
            i2 = i2 + 1LL;
        }
        h0 = (h0 + a) % MOD;
        h1 = (h1 + b) % MOD;
        h2 = (h2 + c) % MOD;
        h3 = (h3 + d) % MOD;
        h4 = (h4 + e) % MOD;
        bindex = bindex + 1LL;
    }
    return str_concat(str_concat(str_concat(str_concat(to_hex32(h0), to_hex32(h1)), to_hex32(h2)), to_hex32(h3)), to_hex32(h4));
}

void user_main() {
    puts(sha1("Test String"));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
