// Generated by Mochi 0.10.32 on 2025-08-19 17:31 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t split_len;
size_t parse_moves_len;
size_t find_repeat_len;
size_t move_x_len;
size_t *move_x_lens;
size_t move_y_len;
size_t *move_y_lens;
size_t build_matrix_len;
size_t *build_matrix_lens;

size_t _slice_Coord_len;
size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char*** list_append_strptr(const char ***arr, size_t *len, const char **val) {
    arr = realloc(arr, (*len + 1) * sizeof(const char**));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t concat_len;
static long long* concat_long_long(long long *a, size_t a_len, const long long *b, size_t b_len) {
    long long *res = realloc(a, (a_len + b_len) * sizeof(long long));
    if (b_len > 0) memcpy(res + a_len, b, b_len * sizeof(long long));
    concat_len = a_len + b_len;
    return res;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static int _atoi(const char *s) {
    return atoi(s);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Coord Coord;
typedef struct PlayResult PlayResult;

struct Coord {
    long long x;
    long long y;
};

struct PlayResult {
    const char* **matrix;
    size_t matrix_len;
    size_t *matrix_lens;
    size_t matrix_lens_len;
    long long score;
};

static struct Coord* _slice_Coord(struct Coord *arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    *out_len = n;
    _slice_Coord_len = n;
    return arr + start;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static Coord* list_append_Coord(Coord *arr, size_t *len, Coord val) {
    arr = realloc(arr, (*len + 1) * sizeof(Coord));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long is_alnum(const char* ch);
long long to_int(const char* token);
const char* * split(const char* s, const char* sep);
Coord * parse_moves(const char* input_str);
void validate_matrix_size(long long size);
void validate_matrix_content(const char* * matrix, size_t matrix_len, long long size);
void validate_moves(Coord * moves, size_t moves_len, long long size);
long long contains(Coord * pos, size_t pos_len, long long r, long long c);
Coord * find_repeat(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long row, long long column, long long size);
long long increment_score(long long count_);
const char* * * move_x(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long column, long long size);
const char* * * move_y(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long size);
PlayResult play(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long pos_x, long long pos_y, long long size);
const char* * * build_matrix(const char* * matrix, size_t matrix_len);
long long process_game(long long size, const char* * matrix, size_t matrix_len, Coord * moves, size_t moves_len);
void user_main();
int main(void);

long long is_alnum(const char* ch) {
    return (((strcmp(ch, "0") >= 0) && (strcmp(ch, "9") <= 0)) || ((strcmp(ch, "A") >= 0) && (strcmp(ch, "Z") <= 0))) || ((strcmp(ch, "a") >= 0) && (strcmp(ch, "z") <= 0));
}

long long to_int(const char* token) {
    long long res = 0LL;
    long long i = 0LL;
    while (i < strlen(token)) {
        res = (res * 10LL) + _atoi(_substring(token, i, i + 1LL));
        i = i + 1LL;
    }
    return res;
}

const char* * split(const char* s, const char* sep) {
    const char* *res = NULL;
    size_t res_len = 0;
    const char* current = "";
    long long i = 0LL;
    while (i < strlen(s)) {
        const char* ch = _substring(s, i, i + 1LL);
        if (strcmp(ch, sep) == 0) {
            res = list_append_str(res, &res_len, current);
            current = "";
        } else {
            current = str_concat(current, ch);
        }
        i = i + 1LL;
    }
    res = list_append_str(res, &res_len, current);
    return split_len = res_len, res;
}

Coord * parse_moves(const char* input_str) {
    const char* *pairs = split(input_str, ",");
    size_t pairs_len = split_len;
    Coord *moves = NULL;
    size_t moves_len = 0;
    long long i = 0LL;
    while (i < pairs_len) {
        const char* pair = pairs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? pairs_len + _mochi_idx : _mochi_idx;})];
        const char* *numbers = NULL;
        size_t numbers_len = 0;
        const char* num = "";
        long long j = 0LL;
        while (j < strlen(pair)) {
            const char* ch = _substring(pair, j, j + 1LL);
            if (strcmp(ch, " ") == 0) {
                if (strcmp(num, "") != 0) {
                    numbers = list_append_str(numbers, &numbers_len, num);
                    num = "";
                }
            } else {
                num = str_concat(num, ch);
            }
            j = j + 1LL;
        }
        if (strcmp(num, "") != 0) {
            numbers = list_append_str(numbers, &numbers_len, num);
        }
        if (numbers_len != 2LL) {
            panic("Each move must have exactly two numbers.");
        }
        long long x = to_int(numbers[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? numbers_len + _mochi_idx : _mochi_idx;})]);
        long long y = to_int(numbers[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? numbers_len + _mochi_idx : _mochi_idx;})]);
        moves = list_append_Coord(moves, &moves_len, (Coord){.x = x, .y = y});
        i = i + 1LL;
    }
    return parse_moves_len = moves_len, moves;
}

void validate_matrix_size(long long size) {
    if (size <= 0LL) {
        panic("Matrix size must be a positive integer.");
    }
}

void validate_matrix_content(const char* * matrix, size_t matrix_len, long long size) {
    if (matrix_len != size) {
        panic("The matrix dont match with size.");
    }
    long long i = 0LL;
    while (i < size) {
        const char* row = matrix[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})];
        if (strlen(row) != size) {
            panic(str_concat(str_concat("Each row in the matrix must have exactly ", str_int(size)), " characters."));
        }
        long long j = 0LL;
        while (j < size) {
            const char* ch = _substring(row, j, j + 1LL);
            if (!(is_alnum(ch))) {
                panic("Matrix rows can only contain letters and numbers.");
            }
            j = j + 1LL;
        }
        i = i + 1LL;
    }
}

void validate_moves(Coord * moves, size_t moves_len, long long size) {
    long long i = 0LL;
    while (i < moves_len) {
        Coord mv = moves[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? moves_len + _mochi_idx : _mochi_idx;})];
        if ((((mv.x < 0LL) || (mv.x >= size)) || (mv.y < 0LL)) || (mv.y >= size)) {
            panic("Move is out of bounds for a matrix.");
        }
        i = i + 1LL;
    }
}

long long contains(Coord * pos, size_t pos_len, long long r, long long c) {
    long long i = 0LL;
    while (i < pos_len) {
        Coord p = pos[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? pos_len + _mochi_idx : _mochi_idx;})];
        if ((p.x == r) && (p.y == c)) {
            return 1LL;
        }
        i = i + 1LL;
    }
    return 0LL;
}

Coord * find_repeat(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long row, long long column, long long size) {
    column = (size - 1LL) - column;
    Coord *visited = NULL;
    size_t visited_len = 0;
    Coord *repeated = NULL;
    size_t repeated_len = 0;
    const char* color = matrix_g[(int)({long long _mochi_idx = column; _mochi_idx < 0 ? matrix_g_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = row; _mochi_idx < 0 ? matrix_g_lens[(int)(column)] + _mochi_idx : _mochi_idx;})];
    if (strcmp(color, "-") == 0) {
        return find_repeat_len = repeated_len, repeated;
    }
    Coord *stack = NULL;
    size_t stack_len = 0;
    stack = list_append_Coord(stack, &stack_len, (Coord){.x = column, .y = row});
    while (stack_len > 0LL) {
        long long idx = stack_len - 1LL;
        Coord pos = stack[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? stack_len + _mochi_idx : _mochi_idx;})];
        stack = _slice_Coord(stack, stack_len, 0LL, idx, &(_slice_Coord_len));
        stack_len = _slice_Coord_len;
        if ((((pos.x < 0LL) || (pos.x >= size)) || (pos.y < 0LL)) || (pos.y >= size)) {
            continue;
        }
        if (contains(visited, visited_len, pos.x, pos.y)) {
            continue;
        }
        visited = list_append_Coord(visited, &visited_len, pos);
        if (strcmp(matrix_g[(int)({long long _mochi_idx = pos.x; _mochi_idx < 0 ? matrix_g_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = pos.y; _mochi_idx < 0 ? matrix_g_lens[(int)(pos.x)] + _mochi_idx : _mochi_idx;})], color) == 0) {
            repeated = list_append_Coord(repeated, &repeated_len, pos);
            stack = list_append_Coord(stack, &stack_len, (Coord){.x = pos.x - 1LL, .y = pos.y});
            stack = list_append_Coord(stack, &stack_len, (Coord){.x = pos.x + 1LL, .y = pos.y});
            stack = list_append_Coord(stack, &stack_len, (Coord){.x = pos.x, .y = pos.y - 1LL});
            stack = list_append_Coord(stack, &stack_len, (Coord){.x = pos.x, .y = pos.y + 1LL});
        }
    }
    return find_repeat_len = repeated_len, repeated;
}

long long increment_score(long long count_) {
    return (count_ * (count_ + 1LL)) / 2LL;
}

const char* * * move_x(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long column, long long size) {
    const char* *new_list = NULL;
    size_t new_list_len = 0;
    long long row = 0LL;
    while (row < size) {
        const char* val = matrix_g[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? matrix_g_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = column; _mochi_idx < 0 ? matrix_g_lens[(int)(row)] + _mochi_idx : _mochi_idx;})];
        if (strcmp(val, "-") != 0) {
            new_list = list_append_str(new_list, &new_list_len, val);
        } else {
            new_list = ({const char** __tmp1 = malloc((new_list_len + 1) * sizeof(const char*)); __tmp1[0] = val; if (new_list_len > 0) memcpy(__tmp1 + 1, new_list, new_list_len * sizeof(const char*)); new_list_len = new_list_len + 1; concat_len = new_list_len; __tmp1;});
            new_list_len = concat_len;
        }
        row = row + 1LL;
    }
    row = 0LL;
    while (row < size) {
        matrix_g[(int)(row)][(int)(column)] = new_list[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? new_list_len + _mochi_idx : _mochi_idx;})];
        row = row + 1LL;
    }
    return move_x_lens = matrix_g_lens, move_x_len = matrix_g_len, matrix_g;
}

const char* * * move_y(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long size) {
    long long *empty_cols = NULL;
    size_t empty_cols_len = 0;
    long long column = size - 1LL;
    while (column >= 0LL) {
        long long row = 0LL;
        long long all_empty = 1LL;
        while (row < size) {
            if (strcmp(matrix_g[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? matrix_g_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = column; _mochi_idx < 0 ? matrix_g_lens[(int)(row)] + _mochi_idx : _mochi_idx;})], "-") != 0) {
                all_empty = 0LL;
                break;
            }
            row = row + 1LL;
        }
        if (all_empty) {
            empty_cols = list_append_long_long(empty_cols, &empty_cols_len, column);
        }
        column = column - 1LL;
    }
    long long i = 0LL;
    while (i < empty_cols_len) {
        long long col = empty_cols[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? empty_cols_len + _mochi_idx : _mochi_idx;})];
        long long c = col + 1LL;
        while (c < size) {
            long long r = 0LL;
            while (r < size) {
                matrix_g[(int)(r)][(int)(c - 1LL)] = matrix_g[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? matrix_g_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = c; _mochi_idx < 0 ? matrix_g_lens[(int)(r)] + _mochi_idx : _mochi_idx;})];
                r = r + 1LL;
            }
            c = c + 1LL;
        }
        long long r = 0LL;
        while (r < size) {
            matrix_g[(int)(r)][(int)(size - 1LL)] = "-";
            r = r + 1LL;
        }
        i = i + 1LL;
    }
    return move_y_lens = matrix_g_lens, move_y_len = matrix_g_len, matrix_g;
}

PlayResult play(const char* * * matrix_g, size_t matrix_g_len, size_t* matrix_g_lens, size_t matrix_g_lens_len, long long pos_x, long long pos_y, long long size) {
    Coord *same_colors = find_repeat(matrix_g, matrix_g_len, matrix_g_lens, matrix_g_len, pos_x, pos_y, size);
    size_t same_colors_len = find_repeat_len;
    if (same_colors_len != 0LL) {
        long long i = 0LL;
        while (i < same_colors_len) {
            Coord p = same_colors[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? same_colors_len + _mochi_idx : _mochi_idx;})];
            matrix_g[(int)(p.x)][(int)(p.y)] = "-";
            i = i + 1LL;
        }
        long long column = 0LL;
        while (column < size) {
            matrix_g = move_x(matrix_g, matrix_g_len, matrix_g_lens, matrix_g_len, column, size);
            matrix_g_len = move_x_len;
            matrix_g_lens = move_x_lens;
            column = column + 1LL;
        }
        matrix_g = move_y(matrix_g, matrix_g_len, matrix_g_lens, matrix_g_len, size);
        matrix_g_len = move_y_len;
        matrix_g_lens = move_y_lens;
    }
    long long sc = increment_score(same_colors_len);
    return (PlayResult){.matrix = matrix_g, .matrix_len = matrix_g_len, .matrix_lens = matrix_g_lens, .matrix_lens_len = matrix_g_len, .score = sc};
}

const char* * * build_matrix(const char* * matrix, size_t matrix_len) {
    const char* **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < matrix_len) {
        const char* row = matrix[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})];
        const char* *row_list = NULL;
        size_t row_list_len = 0;
        long long j = 0LL;
        while (j < strlen(row)) {
            row_list = list_append_str(row_list, &row_list_len, _substring(row, j, j + 1LL));
            j = j + 1LL;
        }
        res = list_append_strptr(res, &res_len, row_list);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_list_len);
        i = i + 1LL;
    }
    return build_matrix_lens = res_lens, build_matrix_len = res_len, res;
}

long long process_game(long long size, const char* * matrix, size_t matrix_len, Coord * moves, size_t moves_len) {
    const char* **game_matrix = build_matrix(matrix, matrix_len);
    size_t game_matrix_len = build_matrix_len;
    size_t *game_matrix_lens = build_matrix_lens;
    size_t game_matrix_lens_len = build_matrix_len;
    long long total = 0LL;
    long long i = 0LL;
    while (i < moves_len) {
        Coord mv = moves[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? moves_len + _mochi_idx : _mochi_idx;})];
        PlayResult res = play(game_matrix, game_matrix_len, game_matrix_lens, game_matrix_len, mv.x, mv.y, size);
        game_matrix = res.matrix;
        total = total + res.score;
        i = i + 1LL;
    }
    return total;
}

void user_main() {
    long long size = 4LL;
    const char* *matrix = NULL;
    size_t matrix_len = 0;
    matrix = list_append_str(matrix, &matrix_len, "RRBG");
    matrix = list_append_str(matrix, &matrix_len, "RBBG");
    matrix = list_append_str(matrix, &matrix_len, "YYGG");
    matrix = list_append_str(matrix, &matrix_len, "XYGG");
    Coord *moves = parse_moves("0 1,1 1");
    size_t moves_len = parse_moves_len;
    validate_matrix_size(size);
    validate_matrix_content(matrix, matrix_len, size);
    validate_moves(moves, moves_len, size);
    long long score = process_game(size, matrix, matrix_len, moves, moves_len);
    puts(str_int(score));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
