// Generated by Mochi 0.10.32 on 2025-08-22 13:08 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t sigmoid_vec_len;
size_t sigmoid_derivative_len;
size_t random_vector_len;
size_t random_matrix_len;
size_t *random_matrix_lens;
size_t matvec_len;
size_t matTvec_len;
size_t vec_sub_len;
size_t vec_mul_len;
size_t vec_scalar_mul_len;
size_t outer_len;
size_t *outer_lens;
size_t mat_scalar_mul_len;
size_t *mat_scalar_mul_lens;
size_t mat_sub_len;
size_t *mat_sub_lens;
size_t forward_len;
size_t backward_len;
size_t calc_gradient_len;

size_t append_len;
static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double* list_append_double_new(const double *arr, size_t len, double val) {
    double *res = malloc((len + 1) * sizeof(double));
    if (arr && len) memcpy(res, arr, len * sizeof(double));
    res[len] = val;
    append_len = len + 1;
    return res;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Data Data;
typedef struct Layer Layer;

struct Data {
    double **x;
    size_t x_len;
    size_t *x_lens;
    size_t x_lens_len;
    double **y;
    size_t y_len;
    size_t *y_lens;
    size_t y_lens_len;
};

struct Layer {
    long long units;
    double **weight;
    size_t weight_len;
    size_t *weight_lens;
    size_t weight_lens_len;
    double *bias;
    size_t bias_len;
    double *output;
    size_t output_len;
    double *xdata;
    size_t xdata_len;
    double learn_rate;
};

static Layer* list_append_Layer(Layer *arr, size_t *len, Layer val) {
    arr = realloc(arr, (*len + 1) * sizeof(Layer));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long seed = 1LL;

long long user_rand();
double user_random();
double expApprox(double x);
double sigmoid(double z);
double * sigmoid_vec(double * v, size_t v_len);
double * sigmoid_derivative(double * out, size_t out_len);
double * random_vector(long long n);
double * * random_matrix(long long r, long long c);
double * matvec(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len, double * vec, size_t vec_len);
double * matTvec(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len, double * vec, size_t vec_len);
double * vec_sub(double * a, size_t a_len, double * b, size_t b_len);
double * vec_mul(double * a, size_t a_len, double * b, size_t b_len);
double * vec_scalar_mul(double * v, size_t v_len, double s);
double * * outer(double * a, size_t a_len, double * b, size_t b_len);
double * * mat_scalar_mul(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len, double s);
double * * mat_sub(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len);
Layer init_layer(long long units, long long back_units, double lr);
Layer * forward(Layer * layers, size_t layers_len, double * x, size_t x_len);
Layer * backward(Layer * layers, size_t layers_len, double * grad, size_t grad_len);
double calc_loss(double * y, size_t y_len, double * yhat, size_t yhat_len);
double * calc_gradient(double * y, size_t y_len, double * yhat, size_t yhat_len);
double train(Layer * layers, size_t layers_len, double * * xdata, size_t xdata_len, size_t* xdata_lens, size_t xdata_lens_len, double * * ydata, size_t ydata_len, size_t* ydata_lens, size_t ydata_lens_len, long long rounds, double acc);
Data create_data();
void user_main();
int main(void);

long long user_rand() {
    seed = ((seed * 1103515245LL) + 12345LL) % 2147483648LL;
    return seed;
}

double user_random() {
    return (1.0 * user_rand()) / 2.147483648e+09;
}

double expApprox(double x) {
    double y = x;
    long long is_neg = 0LL;
    if (x < 0.0) {
        is_neg = 1LL;
        y = -(x);
    }
    double term = 1.0;
    double sum = 1.0;
    long long n = 1LL;
    while (n < 30LL) {
        term = (term * y) / (double)(n);
        sum = sum + term;
        n = n + 1LL;
    }
    if (is_neg) {
        return 1.0 / sum;
    }
    return sum;
}

double sigmoid(double z) {
    return 1.0 / (1.0 + expApprox(-(z)));
}

double * sigmoid_vec(double * v, size_t v_len) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < v_len) {
        res = list_append_double(res, &res_len, sigmoid(v[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? v_len + _mochi_idx : _mochi_idx;})]));
        i = i + 1LL;
    }
    return sigmoid_vec_len = res_len, res;
}

double * sigmoid_derivative(double * out, size_t out_len) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < out_len) {
        double val = out[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? out_len + _mochi_idx : _mochi_idx;})];
        res = list_append_double(res, &res_len, val * (1.0 - val));
        i = i + 1LL;
    }
    return sigmoid_derivative_len = res_len, res;
}

double * random_vector(long long n) {
    double *v = NULL;
    size_t v_len = 0;
    long long i = 0LL;
    while (i < n) {
        v = list_append_double(v, &v_len, user_random() - 0.5);
        i = i + 1LL;
    }
    return random_vector_len = v_len, v;
}

double * * random_matrix(long long r, long long c) {
    double **m = NULL;
    size_t m_len = 0;
    size_t *m_lens = NULL;
    size_t m_lens_len = 0;
    long long i = 0LL;
    while (i < r) {
        m = list_append_doubleptr(m, &m_len, random_vector(c));
        m_lens = list_append_szt(m_lens, &m_lens_len, random_vector_len);
        i = i + 1LL;
    }
    return random_matrix_lens = m_lens, random_matrix_len = m_len, m;
}

double * matvec(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len, double * vec, size_t vec_len) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < mat_len) {
        double s = 0.0;
        long long j = 0LL;
        while (j < vec_len) {
            s = s + (mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? mat_lens[(int)(i)] + _mochi_idx : _mochi_idx;})] * vec[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? vec_len + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        res = list_append_double(res, &res_len, s);
        i = i + 1LL;
    }
    return matvec_len = res_len, res;
}

double * matTvec(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len, double * vec, size_t vec_len) {
    long long cols = mat_lens[(int)(0LL)];
    double *res = NULL;
    size_t res_len = 0;
    long long j = 0LL;
    while (j < cols) {
        double s = 0.0;
        long long i = 0LL;
        while (i < mat_len) {
            s = s + (mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? mat_lens[(int)(i)] + _mochi_idx : _mochi_idx;})] * vec[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? vec_len + _mochi_idx : _mochi_idx;})]);
            i = i + 1LL;
        }
        res = list_append_double(res, &res_len, s);
        j = j + 1LL;
    }
    return matTvec_len = res_len, res;
}

double * vec_sub(double * a, size_t a_len, double * b, size_t b_len) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < a_len) {
        res = list_append_double(res, &res_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})] - b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    return vec_sub_len = res_len, res;
}

double * vec_mul(double * a, size_t a_len, double * b, size_t b_len) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < a_len) {
        res = list_append_double(res, &res_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})] * b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    return vec_mul_len = res_len, res;
}

double * vec_scalar_mul(double * v, size_t v_len, double s) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < v_len) {
        res = list_append_double(res, &res_len, v[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? v_len + _mochi_idx : _mochi_idx;})] * s);
        i = i + 1LL;
    }
    return vec_scalar_mul_len = res_len, res;
}

double * * outer(double * a, size_t a_len, double * b, size_t b_len) {
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < a_len) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < b_len) {
            row = list_append_double(row, &row_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})] * b[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        res = list_append_doubleptr(res, &res_len, row);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_len);
        i = i + 1LL;
    }
    return outer_lens = res_lens, outer_len = res_len, res;
}

double * * mat_scalar_mul(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len, double s) {
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < mat_len) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < mat_lens[(int)(i)]) {
            row = list_append_double(row, &row_len, mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? mat_lens[(int)(i)] + _mochi_idx : _mochi_idx;})] * s);
            j = j + 1LL;
        }
        res = list_append_doubleptr(res, &res_len, row);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_len);
        i = i + 1LL;
    }
    return mat_scalar_mul_lens = res_lens, mat_scalar_mul_len = res_len, res;
}

double * * mat_sub(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len) {
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < a_len) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < a_lens[(int)(i)]) {
            row = list_append_double(row, &row_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_lens[(int)(i)] + _mochi_idx : _mochi_idx;})] - b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? b_lens[(int)(i)] + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        res = list_append_doubleptr(res, &res_len, row);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_len);
        i = i + 1LL;
    }
    return mat_sub_lens = res_lens, mat_sub_len = res_len, res;
}

Layer init_layer(long long units, long long back_units, double lr) {
    return (Layer){.units = units, .weight = random_matrix(units, back_units), .weight_len = random_matrix_len, .weight_lens = random_matrix_lens, .weight_lens_len = random_matrix_len, .bias = random_vector(units), .bias_len = random_vector_len, .output = NULL, .output_len = 0, .xdata = NULL, .xdata_len = 0, .learn_rate = lr};
}

Layer * forward(Layer * layers, size_t layers_len, double * x, size_t x_len) {
    double *data = x;
    size_t data_len = x_len;
    long long i = 0LL;
    while (i < layers_len) {
        Layer layer = layers[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? layers_len + _mochi_idx : _mochi_idx;})];
        layer.xdata = data;
        layer.xdata_len = data_len;
        if (i == 0LL) {
            layer.output = data;
            layer.output_len = data_len;
        } else {
            double *z = ({double* __tmp3 = matvec(layer.weight, layer.weight_len, layer.weight_lens, layer.weight_len, data, data_len); size_t __tmp3_len = matvec_len; vec_sub(__tmp3, __tmp3_len, layer.bias, layer.bias_len);});
            size_t z_len = vec_sub_len;
            layer.output = sigmoid_vec(z, z_len);
            layer.output_len = sigmoid_vec_len;
            data = layer.output;
        }
        layers[(int)(i)] = layer;
        i = i + 1LL;
    }
    return forward_len = layers_len, layers;
}

Layer * backward(Layer * layers, size_t layers_len, double * grad, size_t grad_len) {
    double *g = grad;
    size_t g_len = grad_len;
    long long i = layers_len - 1LL;
    while (i > 0LL) {
        Layer layer = layers[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? layers_len + _mochi_idx : _mochi_idx;})];
        double *deriv = sigmoid_derivative(layer.output, layer.output_len);
        size_t deriv_len = sigmoid_derivative_len;
        double *delta = vec_mul(g, g_len, deriv, deriv_len);
        size_t delta_len = vec_mul_len;
        double **grad_w = outer(delta, delta_len, layer.xdata, layer.xdata_len);
        size_t grad_w_len = outer_len;
        size_t *grad_w_lens = outer_lens;
        size_t grad_w_lens_len = outer_len;
        layer.weight = ({double** __tmp4 = mat_scalar_mul(grad_w, grad_w_len, grad_w_lens, grad_w_len, layer.learn_rate); size_t __tmp4_len = mat_scalar_mul_len; size_t* __tmp4_lens = mat_scalar_mul_lens; mat_sub(layer.weight, layer.weight_len, layer.weight_lens, layer.weight_len, __tmp4, __tmp4_len, __tmp4_lens, __tmp4_len);});
        layer.weight_len = mat_sub_len;
        layer.bias = ({double* __tmp5 = vec_scalar_mul(delta, delta_len, layer.learn_rate); size_t __tmp5_len = vec_scalar_mul_len; vec_sub(layer.bias, layer.bias_len, __tmp5, __tmp5_len);});
        layer.bias_len = vec_sub_len;
        g = matTvec(layer.weight, layer.weight_len, layer.weight_lens, layer.weight_len, delta, delta_len);
        g_len = matTvec_len;
        layers[(int)(i)] = layer;
        i = i - 1LL;
    }
    return backward_len = layers_len, layers;
}

double calc_loss(double * y, size_t y_len, double * yhat, size_t yhat_len) {
    double s = 0.0;
    long long i = 0LL;
    while (i < y_len) {
        double d = y[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})] - yhat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? yhat_len + _mochi_idx : _mochi_idx;})];
        s = s + (d * d);
        i = i + 1LL;
    }
    return s;
}

double * calc_gradient(double * y, size_t y_len, double * yhat, size_t yhat_len) {
    double *g = NULL;
    size_t g_len = 0;
    long long i = 0LL;
    while (i < y_len) {
        g = list_append_double_new(g, g_len, 2.0 * (yhat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? yhat_len + _mochi_idx : _mochi_idx;})] - y[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]));
        g_len++;
        i = i + 1LL;
    }
    return calc_gradient_len = g_len, g;
}

double train(Layer * layers, size_t layers_len, double * * xdata, size_t xdata_len, size_t* xdata_lens, size_t xdata_lens_len, double * * ydata, size_t ydata_len, size_t* ydata_lens, size_t ydata_lens_len, long long rounds, double acc) {
    long long r = 0LL;
    while (r < rounds) {
        long long i = 0LL;
        while (i < xdata_len) {
            layers = forward(layers, layers_len, xdata[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xdata_len + _mochi_idx : _mochi_idx;})], xdata_lens[(int)(i)]);
            layers_len = forward_len;
            double *out = layers[(int)({long long _mochi_idx = layers_len - 1LL; _mochi_idx < 0 ? layers_len + _mochi_idx : _mochi_idx;})].output;
            size_t out_len = layers[(int)({long long _mochi_idx = layers_len - 1LL; _mochi_idx < 0 ? layers_len + _mochi_idx : _mochi_idx;})].output_len;
            double *grad = calc_gradient(ydata[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? ydata_len + _mochi_idx : _mochi_idx;})], ydata_lens[(int)(i)], out, out_len);
            size_t grad_len = calc_gradient_len;
            layers = backward(layers, layers_len, grad, grad_len);
            layers_len = backward_len;
            i = i + 1LL;
        }
        r = r + 1LL;
    }
    return 0.0;
}

Data create_data() {
    double **x = NULL;
    size_t x_len = 0;
    size_t *x_lens = NULL;
    size_t x_lens_len = 0;
    long long i = 0LL;
    while (i < 10LL) {
        x = list_append_doubleptr(x, &x_len, random_vector(10LL));
        x_lens = list_append_szt(x_lens, &x_lens_len, random_vector_len);
        i = i + 1LL;
    }
    double y_0[2] = {0.8, 0.4};
    double y_1[2] = {0.4, 0.3};
    double y_2[2] = {0.34, 0.45};
    double y_3[2] = {0.67, 0.32};
    double y_4[2] = {0.88, 0.67};
    double y_5[2] = {0.78, 0.77};
    double y_6[2] = {0.55, 0.66};
    double y_7[2] = {0.55, 0.43};
    double y_8[2] = {0.54, 0.1};
    double y_9[2] = {0.1, 0.5};
    double *y_init[10] = {y_0, y_1, y_2, y_3, y_4, y_5, y_6, y_7, y_8, y_9};
    double **y = y_init;
    size_t y_len = 10;
    size_t y_lens_init[10] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
    size_t *y_lens = y_lens_init;
    size_t y_lens_len = 10;
    return (Data){.x = x, .x_len = x_len, .x_lens = x_lens, .x_lens_len = x_len, .y = y, .y_len = y_len, .y_lens = y_lens, .y_lens_len = y_len};
}

void user_main() {
    Data data = create_data();
    double **x = data.x;
    size_t x_len = data.x_len;
    size_t *x_lens = data.x_lens;
    size_t x_lens_len = data.x_len;
    double **y = data.y;
    size_t y_len = data.y_len;
    size_t *y_lens = data.y_lens;
    size_t y_lens_len = data.y_len;
    Layer *layers = NULL;
    size_t layers_len = 0;
    layers = list_append_Layer(layers, &layers_len, init_layer(10LL, 0LL, 0.3));
    layers = list_append_Layer(layers, &layers_len, init_layer(20LL, 10LL, 0.3));
    layers = list_append_Layer(layers, &layers_len, init_layer(30LL, 20LL, 0.3));
    layers = list_append_Layer(layers, &layers_len, init_layer(2LL, 30LL, 0.3));
    double final_mse = train(layers, layers_len, x, x_len, x_lens, x_len, y, y_len, y_lens, y_len, 100LL, 0.01);
    printf("%g\n", final_mse);
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
