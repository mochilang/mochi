// Generated by Mochi 0.10.32 on 2025-08-14 09:53 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>


size_t _slice_str_len;
static int contains_str(const char *arr[], size_t len, const char *val) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(arr[i], val) == 0) return 1;
    }
    return 0;
}

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

typedef struct { const char **keys; int *vals; size_t len; size_t cap; } MapSI;

typedef struct { const char **keys; double *vals; size_t len; size_t cap; } MapSD;

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static double map_get_sd(const char *keys[], const double vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char** _slice_str(const char **arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    const char **res = NULL;
    if (n) {
        res = malloc(n * sizeof(const char*));
        memcpy(res, arr + start, n * sizeof(const char*));
    }
    *out_len = n;
    _slice_str_len = n;
    return res;
}

const char* *valid_colors = NULL;
size_t valid_colors_len = 0;
static const char* significant_figures_color_values_keys[26] = {"Black", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey", "White"};
static int significant_figures_color_values_vals[26] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
size_t significant_figures_color_values_len = 10;
MapSI significant_figures_color_values = { significant_figures_color_values_keys, significant_figures_color_values_vals, 10, 26 };
static const char* multiplier_color_values_keys[28] = {"Black", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey", "White", "Gold", "Silver"};
static int multiplier_color_values_vals[28] = {1, 10, 100, 1000, 10000, 100000, 1e+06, 1e+07, 1e+08, 1e+09, 0.1, 0.01};
size_t multiplier_color_values_len = 12;
MapSI multiplier_color_values = { multiplier_color_values_keys, multiplier_color_values_vals, 12, 28 };
static const char* tolerance_color_values_keys[26] = {"Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey", "Gold", "Silver"};
static int tolerance_color_values_vals[26] = {1, 2, 0.05, 0.02, 0.5, 0.25, 0.1, 0.01, 5, 10};
size_t tolerance_color_values_len = 10;
MapSI tolerance_color_values = { tolerance_color_values_keys, tolerance_color_values_vals, 10, 26 };
static const char* temperature_coeffecient_color_values_keys[25] = {"Black", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey"};
static int temperature_coeffecient_color_values_vals[25] = {250, 100, 50, 15, 25, 20, 10, 5, 1};
size_t temperature_coeffecient_color_values_len = 9;
MapSI temperature_coeffecient_color_values = { temperature_coeffecient_color_values_keys, temperature_coeffecient_color_values_vals, 9, 25 };

long long contains(const char* * list, size_t list_len, const char* value);
long long get_significant_digits(const char* * colors, size_t colors_len);
double get_multiplier(const char* color);
double get_tolerance(const char* color);
long long get_temperature_coeffecient(const char* color);
long long get_band_type_count(long long total, const char* typ);
long long check_validity(long long number_of_bands, const char* * colors, size_t colors_len);
const char* calculate_resistance(long long number_of_bands, const char* * color_code_list, size_t color_code_list_len);
int main(void);

long long contains(const char* * list, size_t list_len, const char* value) {
    for (size_t __i = 0; __i < list_len; __i++) {
        const char* c = list[__i];
        if (strcmp(c, value) == 0) {
            return 1LL;
        }
    }
    return 0LL;
}

long long get_significant_digits(const char* * colors, size_t colors_len) {
    long long digit = 0LL;
    for (size_t __i = 0; __i < colors_len; __i++) {
        const char* color = colors[__i];
        if (!(contains_str(significant_figures_color_values.keys, significant_figures_color_values.len, color))) {
            panic(str_concat(color, " is not a valid color for significant figure bands"));
        }
        digit = (digit * 10LL) + map_get_si(significant_figures_color_values.keys, significant_figures_color_values.vals, significant_figures_color_values.len, color);
    }
    return digit;
}

double get_multiplier(const char* color) {
    if (!(contains_str(multiplier_color_values.keys, multiplier_color_values.len, color))) {
        panic(str_concat(color, " is not a valid color for multiplier band"));
    }
    return map_get_si(multiplier_color_values.keys, multiplier_color_values.vals, multiplier_color_values.len, color);
}

double get_tolerance(const char* color) {
    if (!(contains_str(tolerance_color_values.keys, tolerance_color_values.len, color))) {
        panic(str_concat(color, " is not a valid color for tolerance band"));
    }
    return map_get_si(tolerance_color_values.keys, tolerance_color_values.vals, tolerance_color_values.len, color);
}

long long get_temperature_coeffecient(const char* color) {
    if (!(contains_str(temperature_coeffecient_color_values.keys, temperature_coeffecient_color_values.len, color))) {
        panic(str_concat(color, " is not a valid color for temperature coeffecient band"));
    }
    return map_get_si(temperature_coeffecient_color_values.keys, temperature_coeffecient_color_values.vals, temperature_coeffecient_color_values.len, color);
}

long long get_band_type_count(long long total, const char* typ) {
    if (total == 3LL) {
        if (strcmp(typ, "significant") == 0) {
            return 2LL;
        }
        if (strcmp(typ, "multiplier") == 0) {
            return 1LL;
        }
        panic(str_concat(typ, " is not valid for a 3 band resistor"));
    } else {
        if (total == 4LL) {
            if (strcmp(typ, "significant") == 0) {
                return 2LL;
            }
            if (strcmp(typ, "multiplier") == 0) {
                return 1LL;
            }
            if (strcmp(typ, "tolerance") == 0) {
                return 1LL;
            }
            panic(str_concat(typ, " is not valid for a 4 band resistor"));
        } else {
            if (total == 5LL) {
                if (strcmp(typ, "significant") == 0) {
                    return 3LL;
                }
                if (strcmp(typ, "multiplier") == 0) {
                    return 1LL;
                }
                if (strcmp(typ, "tolerance") == 0) {
                    return 1LL;
                }
                panic(str_concat(typ, " is not valid for a 5 band resistor"));
            } else {
                if (total == 6LL) {
                    if (strcmp(typ, "significant") == 0) {
                        return 3LL;
                    }
                    if (strcmp(typ, "multiplier") == 0) {
                        return 1LL;
                    }
                    if (strcmp(typ, "tolerance") == 0) {
                        return 1LL;
                    }
                    if (strcmp(typ, "temp_coeffecient") == 0) {
                        return 1LL;
                    }
                    panic(str_concat(typ, " is not valid for a 6 band resistor"));
                } else {
                    panic(str_concat(str_int(total), " is not a valid number of bands"));
                }
            }
        }
    }
}

long long check_validity(long long number_of_bands, const char* * colors, size_t colors_len) {
    if ((number_of_bands < 3LL) || (number_of_bands > 6LL)) {
        panic("Invalid number of bands. Resistor bands must be 3 to 6");
    }
    if (number_of_bands != colors_len) {
        panic(str_concat(str_concat(str_concat(str_concat("Expecting ", str_int(number_of_bands)), " colors, provided "), str_int(colors_len)), " colors"));
    }
    for (size_t __i = 0; __i < colors_len; __i++) {
        const char* color = colors[__i];
        if (!(contains(valid_colors, valid_colors_len, color))) {
            panic(str_concat(color, " is not a valid color"));
        }
    }
    return 1LL;
}

const char* calculate_resistance(long long number_of_bands, const char* * color_code_list, size_t color_code_list_len) {
    check_validity(number_of_bands, color_code_list, color_code_list_len);
    long long sig_count = get_band_type_count(number_of_bands, "significant");
    const char* *significant_colors = _slice_str(color_code_list, color_code_list_len, 0LL, sig_count, &(_slice_str_len));
    size_t significant_colors_len = _slice_str_len;
    long long significant_digits = get_significant_digits(significant_colors, significant_colors_len);
    const char* multiplier_color = color_code_list[(int)({long long _mochi_idx = sig_count; _mochi_idx < 0 ? color_code_list_len + _mochi_idx : _mochi_idx;})];
    double multiplier = get_multiplier(multiplier_color);
    double tolerance = 20.0;
    if (number_of_bands >= 4LL) {
        const char* tolerance_color = color_code_list[(int)({long long _mochi_idx = sig_count + 1LL; _mochi_idx < 0 ? color_code_list_len + _mochi_idx : _mochi_idx;})];
        tolerance = get_tolerance(tolerance_color);
    }
    long long temp_coeff = 0LL;
    if (number_of_bands == 6LL) {
        const char* temp_color = color_code_list[(int)({long long _mochi_idx = sig_count + 2LL; _mochi_idx < 0 ? color_code_list_len + _mochi_idx : _mochi_idx;})];
        temp_coeff = get_temperature_coeffecient(temp_color);
    }
    double resistance_value = multiplier * significant_digits;
    const char* resistance_str = str_float(resistance_value);
    if (resistance_value == (int)(resistance_value)) {
        resistance_str = str_int((int)(resistance_value));
    }
    const char* answer = str_concat(str_concat(str_concat(resistance_str, "Ω ±"), str_float(tolerance)), "% ");
    if (temp_coeff != 0LL) {
        answer = str_concat(str_concat(answer, str_int(temp_coeff)), " ppm/K");
    }
    return answer;
}

int main(void) {
    {
        long long __start = _now();
        valid_colors = ({const char* *tmp = malloc(12 * sizeof(const char*)); tmp[0] = "Black"; tmp[1] = "Brown"; tmp[2] = "Red"; tmp[3] = "Orange"; tmp[4] = "Yellow"; tmp[5] = "Green"; tmp[6] = "Blue"; tmp[7] = "Violet"; tmp[8] = "Grey"; tmp[9] = "White"; tmp[10] = "Gold"; tmp[11] = "Silver"; tmp;});
        valid_colors_len = 12;
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
