// Generated by Mochi 0.10.32 on 2025-08-23 21:18 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t calculate_sequence_of_finish_queue_len;
size_t calculate_waiting_time_len;
size_t calculate_turnaround_time_len;
size_t calculate_completion_time_len;
size_t calculate_remaining_burst_time_of_processes_len;
size_t first_come_first_served_len;
size_t multi_level_feedback_queue_len;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_int(const long long *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[32];
        snprintf(tmp, sizeof(tmp), "%lld", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static char* str_list_str(const char **arr, size_t len) {
    size_t cap = 2;
    for (size_t i = 0; i < len; i++) cap += strlen(arr[i]) + 1;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        size_t n = strlen(arr[i]);
        memcpy(buf + pos, arr[i], n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t concat_len;
static long long* concat_long_long(long long *a, size_t a_len, const long long *b, size_t b_len) {
    long long *res = realloc(a, (a_len + b_len) * sizeof(long long));
    if (b_len > 0) memcpy(res + a_len, b, b_len * sizeof(long long));
    concat_len = a_len + b_len;
    return res;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct MLFQ MLFQ;
typedef struct Process Process;
typedef struct RRResult RRResult;

struct MLFQ {
    long long number_of_queues;
    long long *time_slices;
    size_t time_slices_len;
    Process *ready_queue;
    size_t ready_queue_len;
    long long current_time;
    Process *finish_queue;
    size_t finish_queue_len;
};

struct Process {
    const char* process_name;
    long long arrival_time;
    long long stop_time;
    long long burst_time;
    long long waiting_time;
    long long turnaround_time;
};

struct RRResult {
    Process *finished;
    size_t finished_len;
    Process *ready;
    size_t ready_len;
};

static Process* list_append_Process(Process *arr, size_t *len, Process val) {
    arr = realloc(arr, (*len + 1) * sizeof(Process));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Process P1;
Process P2;
Process P3;
Process P4;
long long number_of_queues = 3LL;
long long time_slices_init[2] = {17LL, 25LL};
long long *time_slices = time_slices_init;
size_t time_slices_len = 2;
Process *queue = NULL;
size_t queue_len = 0;
MLFQ mlfq;
Process *finish_queue = NULL;
size_t finish_queue_len = 0;

Process make_process(const char* name, long long arrival, long long burst);
MLFQ make_mlfq(long long nqueues, long long * time_slices, size_t time_slices_len, Process * queue, size_t queue_len, long long current_time);
const char* * calculate_sequence_of_finish_queue(MLFQ mlfq);
long long * calculate_waiting_time(Process * queue, size_t queue_len);
long long * calculate_turnaround_time(Process * queue, size_t queue_len);
long long * calculate_completion_time(Process * queue, size_t queue_len);
long long * calculate_remaining_burst_time_of_processes(Process * queue, size_t queue_len);
long long update_waiting_time(MLFQ mlfq, Process process);
Process * first_come_first_served(MLFQ* mlfq, Process * ready_queue, size_t ready_queue_len);
RRResult round_robin(MLFQ* mlfq, Process * ready_queue, size_t ready_queue_len, long long time_slice);
Process * multi_level_feedback_queue(MLFQ mlfq);
int main(void);

Process make_process(const char* name, long long arrival, long long burst) {
    return (Process){.process_name = name, .arrival_time = arrival, .stop_time = arrival, .burst_time = burst, .waiting_time = 0LL, .turnaround_time = 0LL};
}

MLFQ make_mlfq(long long nqueues, long long * time_slices, size_t time_slices_len, Process * queue, size_t queue_len, long long current_time) {
    return (MLFQ){.number_of_queues = nqueues, .time_slices = time_slices, .time_slices_len = time_slices_len, .ready_queue = queue, .ready_queue_len = queue_len, .current_time = current_time, .finish_queue = NULL, .finish_queue_len = 0};
}

const char* * calculate_sequence_of_finish_queue(MLFQ mlfq) {
    const char* *seq = NULL;
    size_t seq_len = 0;
    long long i = 0LL;
    while (i < mlfq.finish_queue_len) {
        Process p = mlfq.finish_queue[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mlfq.finish_queue_len + _mochi_idx : _mochi_idx;})];
        seq = list_append_str(seq, &seq_len, p.process_name);
        i = i + 1LL;
    }
    return calculate_sequence_of_finish_queue_len = seq_len, seq;
}

long long * calculate_waiting_time(Process * queue, size_t queue_len) {
    long long *times = NULL;
    size_t times_len = 0;
    long long i = 0LL;
    while (i < queue_len) {
        Process p = queue[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
        times = list_append_long_long(times, &times_len, p.waiting_time);
        i = i + 1LL;
    }
    return calculate_waiting_time_len = times_len, times;
}

long long * calculate_turnaround_time(Process * queue, size_t queue_len) {
    long long *times = NULL;
    size_t times_len = 0;
    long long i = 0LL;
    while (i < queue_len) {
        Process p = queue[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
        times = list_append_long_long(times, &times_len, p.turnaround_time);
        i = i + 1LL;
    }
    return calculate_turnaround_time_len = times_len, times;
}

long long * calculate_completion_time(Process * queue, size_t queue_len) {
    long long *times = NULL;
    size_t times_len = 0;
    long long i = 0LL;
    while (i < queue_len) {
        Process p = queue[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
        times = list_append_long_long(times, &times_len, p.stop_time);
        i = i + 1LL;
    }
    return calculate_completion_time_len = times_len, times;
}

long long * calculate_remaining_burst_time_of_processes(Process * queue, size_t queue_len) {
    long long *times = NULL;
    size_t times_len = 0;
    long long i = 0LL;
    while (i < queue_len) {
        Process p = queue[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
        times = list_append_long_long(times, &times_len, p.burst_time);
        i = i + 1LL;
    }
    return calculate_remaining_burst_time_of_processes_len = times_len, times;
}

long long update_waiting_time(MLFQ mlfq, Process process) {
    process.waiting_time = process.waiting_time + (mlfq.current_time - process.stop_time);
    return process.waiting_time;
}

Process * first_come_first_served(MLFQ* mlfq, Process * ready_queue, size_t ready_queue_len) {
    Process *finished = NULL;
    size_t finished_len = 0;
    Process *rq = ready_queue;
    size_t rq_len = ready_queue_len;
    while (rq_len != 0LL) {
        Process cp = rq[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? rq_len + _mochi_idx : _mochi_idx;})];
        rq = ;
        if (mlfq->current_time < cp.arrival_time) {
            mlfq->current_time = cp.arrival_time;
        }
        update_waiting_time(*(MLFQ)mlfq, cp);
        mlfq->current_time = mlfq->current_time + cp.burst_time;
        cp.burst_time = 0LL;
        cp.turnaround_time = mlfq->current_time - cp.arrival_time;
        cp.stop_time = mlfq->current_time;
        finished = list_append_Process(finished, &finished_len, cp);
    }
    mlfq->finish_queue = concat_long_long(mlfq->finish_queue, mlfq->finish_queue_len, finished, finished_len);
    mlfq->finish_queue_len = concat_len;
    return first_come_first_served_len = finished_len, finished;
}

RRResult round_robin(MLFQ* mlfq, Process * ready_queue, size_t ready_queue_len, long long time_slice) {
    Process *finished = NULL;
    size_t finished_len = 0;
    Process *rq = ready_queue;
    size_t rq_len = ready_queue_len;
    long long count_ = rq_len;
    long long i = 0LL;
    while (i < count_) {
        Process cp = rq[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? rq_len + _mochi_idx : _mochi_idx;})];
        rq = ;
        if (mlfq->current_time < cp.arrival_time) {
            mlfq->current_time = cp.arrival_time;
        }
        update_waiting_time(*(MLFQ)mlfq, cp);
        if (cp.burst_time > time_slice) {
            mlfq->current_time = mlfq->current_time + time_slice;
            cp.burst_time = cp.burst_time - time_slice;
            cp.stop_time = mlfq->current_time;
            rq = list_append_Process(rq, &rq_len, cp);
        } else {
            mlfq->current_time = mlfq->current_time + cp.burst_time;
            cp.burst_time = 0LL;
            cp.stop_time = mlfq->current_time;
            cp.turnaround_time = mlfq->current_time - cp.arrival_time;
            finished = list_append_Process(finished, &finished_len, cp);
        }
        i = i + 1LL;
    }
    mlfq->finish_queue = concat_long_long(mlfq->finish_queue, mlfq->finish_queue_len, finished, finished_len);
    mlfq->finish_queue_len = concat_len;
    return (RRResult){.finished = finished, .finished_len = finished_len, .ready = rq, .ready_len = rq_len};
}

Process * multi_level_feedback_queue(MLFQ mlfq) {
    long long i = 0LL;
    while (i < (mlfq.number_of_queues - 1LL)) {
        RRResult rr = round_robin(&mlfq, mlfq.ready_queue, mlfq.ready_queue_len, mlfq.time_slices[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mlfq.time_slices_len + _mochi_idx : _mochi_idx;})]);
        mlfq.ready_queue = rr.ready;
        mlfq.ready_queue_len = rr.ready_len;
        i = i + 1LL;
    }
    first_come_first_served(&mlfq, mlfq.ready_queue, mlfq.ready_queue_len);
    return multi_level_feedback_queue_len = mlfq.finish_queue_len, mlfq.finish_queue;
}

int main(void) {
    {
        long long __start = _now();
        P1 = make_process("P1", 0LL, 53LL);
        P2 = make_process("P2", 0LL, 17LL);
        P3 = make_process("P3", 0LL, 68LL);
        P4 = make_process("P4", 0LL, 24LL);
        queue = ({Process *tmp = malloc(4 * sizeof(Process)); tmp[0] = P1; tmp[1] = P2; tmp[2] = P3; tmp[3] = P4; tmp;});
        queue_len = 4;
        mlfq = make_mlfq(number_of_queues, time_slices, time_slices_len, queue, queue_len, 0LL);
        finish_queue = multi_level_feedback_queue(mlfq);
        finish_queue_len = multi_level_feedback_queue_len;
        puts(str_concat("waiting time:\t\t\t", ({long long *__tmp4 = calculate_waiting_time(({Process *tmp = malloc(4 * sizeof(Process)); tmp[0] = P1; tmp[1] = P2; tmp[2] = P3; tmp[3] = P4; tmp;}), 4); char *__res = str_list_int(__tmp4, calculate_waiting_time_len); __res;})));
        puts(str_concat("completion time:\t\t", ({long long *__tmp5 = calculate_completion_time(({Process *tmp = malloc(4 * sizeof(Process)); tmp[0] = P1; tmp[1] = P2; tmp[2] = P3; tmp[3] = P4; tmp;}), 4); char *__res = str_list_int(__tmp5, calculate_completion_time_len); __res;})));
        puts(str_concat("turnaround time:\t\t", ({long long *__tmp6 = calculate_turnaround_time(({Process *tmp = malloc(4 * sizeof(Process)); tmp[0] = P1; tmp[1] = P2; tmp[2] = P3; tmp[3] = P4; tmp;}), 4); char *__res = str_list_int(__tmp6, calculate_turnaround_time_len); __res;})));
        puts(str_concat("sequence of finished processes:\t", ({const char **__tmp7 = calculate_sequence_of_finish_queue(mlfq); char *__res = str_list_str(__tmp7, calculate_sequence_of_finish_queue_len); __res;})));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
