// Generated by Mochi 0.10.32 on 2025-08-25 16:08 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_str(const char **arr, size_t len) {
    size_t cap = 2;
    for (size_t i = 0; i < len; i++) cap += strlen(arr[i]) + 1;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        size_t n = strlen(arr[i]);
        memcpy(buf + pos, arr[i], n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

typedef struct { const char **keys; int *vals; size_t len; size_t cap; } MapSI;

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static void map_set_si(MapSI *m, const char *key, int val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc(m->vals, m->cap * sizeof(int));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct MatchResult MatchResult;
typedef struct RadixNode RadixNode;
typedef struct RadixTree RadixTree;

struct MatchResult {
    const char* common;
    const char* rem_prefix;
    const char* rem_word;
};

struct RadixNode {
    const char* prefix;
    long long is_leaf;
    MapSI children;
};

struct RadixTree {
    RadixNode *nodes;
    size_t nodes_len;
};

static RadixNode* list_append_RadixNode(RadixNode *arr, size_t *len, RadixNode val) {
    arr = realloc(arr, (*len + 1) * sizeof(RadixNode));
    arr[*len] = val;
    (*len)++;
    return arr;
}

RadixNode new_node(const char* prefix, long long is_leaf);
RadixTree new_tree();
MatchResult match_prefix(RadixNode node, const char* word);
void insert_many(RadixTree tree, const char* * words, size_t words_len);
void insert(RadixTree* tree, long long idx, const char* word);
long long find(RadixTree tree, long long idx, const char* word);
MapSI remove_key(MapSI m, const char* k);
long long has_key(MapSI m, const char* k);
long long delete(RadixTree* tree, long long idx, const char* word);
void print_tree(RadixTree tree, long long idx, long long height);
long long test_trie();
void pytests();
void user_main();
int main(void);

RadixNode new_node(const char* prefix, long long is_leaf) {
    return (RadixNode){.prefix = prefix, .is_leaf = is_leaf, .children = (MapSI){0}};
}

RadixTree new_tree() {
    RadixNode *nodes = NULL;
    size_t nodes_len = 0;
    nodes = list_append_RadixNode(nodes, &nodes_len, new_node("", 0LL));
    return (RadixTree){.nodes = nodes, .nodes_len = nodes_len};
}

MatchResult match_prefix(RadixNode node, const char* word) {
    long long x = 0LL;
    const char* p = node.prefix;
    const char* w = word;
    long long min_len = strlen(p);
    if (strlen(w) < min_len) {
        min_len = strlen(w);
    }
    while (x < min_len) {
        if (strcmp(_substring(p, x, x + 1LL), _substring(w, x, x + 1LL)) != 0) {
            break;
        }
        x = x + 1LL;
    }
    const char* common = _substring(p, 0LL, x);
    const char* rem_prefix = _substring(p, x, strlen(p));
    const char* rem_word = _substring(w, x, strlen(w));
    return (MatchResult){.common = common, .rem_prefix = rem_prefix, .rem_word = rem_word};
}

void insert_many(RadixTree tree, const char* * words, size_t words_len) {
    for (size_t __i = 0; __i < words_len; __i++) {
        const char* w = words[__i];
        insert(&tree, 0LL, w);
    }
}

void insert(RadixTree* tree, long long idx, const char* word) {
    RadixNode *nodes = tree->nodes;
    size_t nodes_len = tree->nodes_len;
    RadixNode node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    if ((strcmp(node.prefix, word) == 0) && !(node.is_leaf)) {
        node.is_leaf = 1LL;
        nodes[(int)(idx)] = node;
        tree->nodes = nodes;
        tree->nodes_len = nodes_len;
        return 0;
    }
    const char* first = _substring(word, 0LL, 1LL);
    MapSI children = node.children;
    if (!(has_key(children, first))) {
        long long new_idx = nodes_len;
        nodes = list_append_RadixNode(nodes, &nodes_len, new_node(word, 1LL));
        map_set_si(&(children), first, new_idx);
        node.children = children;
        nodes[(int)(idx)] = node;
        tree->nodes = nodes;
        tree->nodes_len = nodes_len;
        return 0;
    }
    long long child_idx = map_get_si(children.keys, children.vals, children.len, first);
    RadixNode child = nodes[(int)({long long _mochi_idx = child_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    MatchResult res = match_prefix(child, word);
    if (strcmp(res.rem_prefix, "") == 0) {
        insert(tree, child_idx, res.rem_word);
        return 0;
    }
    child.prefix = res.rem_prefix;
    nodes[(int)(child_idx)] = child;
    static const char* new_children_keys[16] = {};
    static int new_children_vals[16] = {};
    size_t new_children_len = 0;
    MapSI new_children = { new_children_keys, new_children_vals, 0, 16 };
    map_set_si(&(new_children), _substring(res.rem_prefix, 0LL, 1LL), child_idx);
    long long new_idx = nodes_len;
    nodes = list_append_RadixNode(nodes, &nodes_len, new_node(res.common, 0LL));
    nodes[(int)(new_idx)].children = new_children;
    if (strcmp(res.rem_word, "") == 0) {
        nodes[(int)(new_idx)].is_leaf = 1LL;
    } else {
        insert(tree, new_idx, res.rem_word);
    }
    map_set_si(&(children), first, new_idx);
    node.children = children;
    nodes[(int)(idx)] = node;
    tree->nodes = nodes;
    tree->nodes_len = nodes_len;
}

long long find(RadixTree tree, long long idx, const char* word) {
    RadixNode *nodes = tree.nodes;
    size_t nodes_len = tree.nodes_len;
    RadixNode node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    const char* first = _substring(word, 0LL, 1LL);
    MapSI children = node.children;
    if (!(has_key(children, first))) {
        return 0LL;
    }
    long long child_idx = map_get_si(children.keys, children.vals, children.len, first);
    RadixNode child = nodes[(int)({long long _mochi_idx = child_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    MatchResult res = match_prefix(child, word);
    if (strcmp(res.rem_prefix, "") != 0) {
        return 0LL;
    }
    if (strcmp(res.rem_word, "") == 0) {
        return child.is_leaf;
    }
    return find(tree, child_idx, res.rem_word);
}

MapSI remove_key(MapSI m, const char* k) {
    static const char* out_keys[16] = {};
    static int out_vals[16] = {};
    size_t out_len = 0;
    MapSI out = { out_keys, out_vals, 0, 16 };
    MapSI __tmp0 = m;
    for (size_t __i = 0; __i < __tmp0.len; __i++) {
        const char* key = __tmp0.keys[__i];
        if (key != k) {
            map_set_si(&(out), key, map_get_si(m.keys, m.vals, m.len, key));
        }
    }
    return out;
}

long long has_key(MapSI m, const char* k) {
    MapSI __tmp1 = m;
    for (size_t __i = 0; __i < __tmp1.len; __i++) {
        const char* key = __tmp1.keys[__i];
        if (key == k) {
            return 1LL;
        }
    }
    return 0LL;
}

long long delete(RadixTree* tree, long long idx, const char* word) {
    RadixNode *nodes = tree->nodes;
    size_t nodes_len = tree->nodes_len;
    RadixNode node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    const char* first = _substring(word, 0LL, 1LL);
    MapSI children = node.children;
    if (!(has_key(children, first))) {
        return 0LL;
    }
    long long child_idx = map_get_si(children.keys, children.vals, children.len, first);
    RadixNode child = nodes[(int)({long long _mochi_idx = child_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    MatchResult res = match_prefix(child, word);
    if (strcmp(res.rem_prefix, "") != 0) {
        return 0LL;
    }
    if (strcmp(res.rem_word, "") != 0) {
        long long deleted = delete(tree, child_idx, res.rem_word);
        if (deleted) {
            nodes = tree->nodes;
            node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
        }
        return deleted;
    }
    if (!(child.is_leaf)) {
        return 0LL;
    }
    if (child.children.len == 0LL) {
        children = remove_key(children, first);
        node.children = children;
        nodes[(int)(idx)] = node;
        tree->nodes = nodes;
        tree->nodes_len = nodes_len;
        if ((children.len == 1LL) && !(node.is_leaf)) {
            const char* only_key = "";
            MapSI __tmp2 = children;
            for (size_t __i = 0; __i < __tmp2.len; __i++) {
                const char* k = __tmp2.keys[__i];
                only_key = k;
            }
            long long merge_idx = map_get_si(children.keys, children.vals, children.len, only_key);
            RadixNode merge_node = nodes[(int)({long long _mochi_idx = merge_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
            node.is_leaf = merge_node.is_leaf;
            node.prefix = str_concat(node.prefix, merge_node.prefix);
            node.children = merge_node.children;
            nodes[(int)(idx)] = node;
            tree->nodes = nodes;
            tree->nodes_len = nodes_len;
        }
    } else {
        if (child.children.len > 1LL) {
            child.is_leaf = 0LL;
            nodes[(int)(child_idx)] = child;
            tree->nodes = nodes;
            tree->nodes_len = nodes_len;
        } else {
            const char* only_key = "";
            MapSI __tmp3 = child.children;
            for (size_t __i = 0; __i < __tmp3.len; __i++) {
                const char* k = __tmp3.keys[__i];
                only_key = k;
            }
            long long merge_idx = map_get_si(child.children.keys, child.children.vals, child.children.len, only_key);
            RadixNode merge_node = nodes[(int)({long long _mochi_idx = merge_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
            child.is_leaf = merge_node.is_leaf;
            child.prefix = str_concat(child.prefix, merge_node.prefix);
            child.children = merge_node.children;
            nodes[(int)(child_idx)] = child;
            tree->nodes = nodes;
            tree->nodes_len = nodes_len;
        }
    }
    return 1LL;
}

void print_tree(RadixTree tree, long long idx, long long height) {
    RadixNode *nodes = tree.nodes;
    size_t nodes_len = tree.nodes_len;
    RadixNode node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    if (strcmp(node.prefix, "") != 0) {
        const char* line = "";
        long long i = 0LL;
        while (i < height) {
            line = str_concat(line, "-");
            i = i + 1LL;
        }
        line = str_concat(str_concat(line, " "), node.prefix);
        if (node.is_leaf) {
            line = str_concat(line, "  (leaf)");
        }
        puts(line);
    }
    MapSI children = node.children;
    MapSI __tmp4 = children;
    for (size_t __i = 0; __i < __tmp4.len; __i++) {
        const char* k = __tmp4.keys[__i];
        long long child_idx = map_get_si(children.keys, children.vals, children.len, k);
        print_tree(tree, child_idx, height + 1LL);
    }
}

long long test_trie() {
    const char* *words = NULL;
    size_t words_len = 0;
    words = list_append_str(words, &words_len, "banana");
    words = list_append_str(words, &words_len, "bananas");
    words = list_append_str(words, &words_len, "bandana");
    words = list_append_str(words, &words_len, "band");
    words = list_append_str(words, &words_len, "apple");
    words = list_append_str(words, &words_len, "all");
    words = list_append_str(words, &words_len, "beast");
    RadixTree tree = new_tree();
    insert_many(tree, words, words_len);
    long long ok = 1LL;
    {
        const char* w_arr[] = {"banana", "bananas", "bandana", "band", "apple", "all", "beast"};
        size_t w_len = sizeof(w_arr) / sizeof(w_arr[0]);
        for (size_t __i = 0; __i < w_len; __i++) {
            const char* w = w_arr[__i];
            if (!(find(tree, 0LL, w))) {
                ok = 0LL;
            }
        }
    }
    if (find(tree, 0LL, "bandanas")) {
        ok = 0LL;
    }
    if (find(tree, 0LL, "apps")) {
        ok = 0LL;
    }
    delete(&tree, 0LL, "all");
    if (find(tree, 0LL, "all")) {
        ok = 0LL;
    }
    delete(&tree, 0LL, "banana");
    if (find(tree, 0LL, "banana")) {
        ok = 0LL;
    }
    if (!(find(tree, 0LL, "bananas"))) {
        ok = 0LL;
    }
    return ok;
}

void pytests() {
    if (!(test_trie())) {
        panic("test failed");
    }
}

void user_main() {
    RadixTree tree = new_tree();
    const char* *words = NULL;
    size_t words_len = 0;
    words = list_append_str(words, &words_len, "banana");
    words = list_append_str(words, &words_len, "bananas");
    words = list_append_str(words, &words_len, "bandanas");
    words = list_append_str(words, &words_len, "bandana");
    words = list_append_str(words, &words_len, "band");
    words = list_append_str(words, &words_len, "apple");
    words = list_append_str(words, &words_len, "all");
    words = list_append_str(words, &words_len, "beast");
    insert_many(tree, words, words_len);
    puts(str_concat("Words: ", str_list_str(words, words_len)));
    puts("Tree:");
    print_tree(tree, 0LL, 0LL);
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
