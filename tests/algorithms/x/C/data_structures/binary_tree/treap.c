// Generated by Mochi 0.10.32 on 2025-08-24 21:19 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t inorder_len;

size_t append_len;
static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_int(const long long *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[32];
        snprintf(tmp, sizeof(tmp), "%lld", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static long long* list_append_int_new(const long long *arr, size_t len, long long val) {
    long long *res = malloc((len + 1) * sizeof(long long));
    if (arr && len) memcpy(res, arr, len * sizeof(long long));
    res[len] = val;
    append_len = len + 1;
    return res;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct SplitResult SplitResult;

struct SplitResult {
    long long left;
    long long right;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long NIL = -1LL;
long long *node_values = NULL;
size_t node_values_len = 0;
double *node_priors = NULL;
size_t node_priors_len = 0;
long long *node_lefts = NULL;
size_t node_lefts_len = 0;
long long *node_rights = NULL;
size_t node_rights_len = 0;
long long seed = 1LL;

double user_random();
long long new_node(long long value);
SplitResult split(long long root, long long value);
long long merge(long long left, long long right);
long long insert(long long root, long long value);
long long erase(long long root, long long value);
long long * inorder(long long i, long long * acc, size_t acc_len);
void user_main();
int main(void);

double user_random() {
    seed = ((seed * 13LL) + 7LL) % 100LL;
    return (double)(seed) / 100.0;
}

long long new_node(long long value) {
    node_values = list_append_long_long(node_values, &node_values_len, value);
    node_priors = list_append_double(node_priors, &node_priors_len, user_random());
    node_lefts = list_append_long_long(node_lefts, &node_lefts_len, NIL);
    node_rights = list_append_long_long(node_rights, &node_rights_len, NIL);
    return node_values_len - 1LL;
}

SplitResult split(long long root, long long value) {
    if (root == NIL) {
        return (SplitResult){.left = NIL, .right = NIL};
    }
    if (value < node_values[(int)({long long _mochi_idx = root; _mochi_idx < 0 ? node_values_len + _mochi_idx : _mochi_idx;})]) {
        SplitResult res = split(node_lefts[(int)({long long _mochi_idx = root; _mochi_idx < 0 ? node_lefts_len + _mochi_idx : _mochi_idx;})], value);
        node_lefts[(int)(root)] = res.right;
        return (SplitResult){.left = res.left, .right = root};
    }
    SplitResult res = split(node_rights[(int)({long long _mochi_idx = root; _mochi_idx < 0 ? node_rights_len + _mochi_idx : _mochi_idx;})], value);
    node_rights[(int)(root)] = res.left;
    return (SplitResult){.left = root, .right = res.right};
}

long long merge(long long left, long long right) {
    if (left == NIL) {
        return right;
    }
    if (right == NIL) {
        return left;
    }
    if (node_priors[(int)({long long _mochi_idx = left; _mochi_idx < 0 ? node_priors_len + _mochi_idx : _mochi_idx;})] < node_priors[(int)({long long _mochi_idx = right; _mochi_idx < 0 ? node_priors_len + _mochi_idx : _mochi_idx;})]) {
        node_rights[(int)(left)] = merge(node_rights[(int)({long long _mochi_idx = left; _mochi_idx < 0 ? node_rights_len + _mochi_idx : _mochi_idx;})], right);
        return left;
    }
    node_lefts[(int)(right)] = merge(left, node_lefts[(int)({long long _mochi_idx = right; _mochi_idx < 0 ? node_lefts_len + _mochi_idx : _mochi_idx;})]);
    return right;
}

long long insert(long long root, long long value) {
    long long node = new_node(value);
    SplitResult res = split(root, value);
    return merge(merge(res.left, node), res.right);
}

long long erase(long long root, long long value) {
    SplitResult res1 = split(root, value - 1LL);
    SplitResult res2 = split(res1.right, value);
    return merge(res1.left, res2.right);
}

long long * inorder(long long i, long long * acc, size_t acc_len) {
    if (i == NIL) {
        return inorder_len = acc_len, acc;
    }
    long long *left_acc = inorder(node_lefts[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? node_lefts_len + _mochi_idx : _mochi_idx;})], acc, acc_len);
    size_t left_acc_len = inorder_len;
    long long *with_node = list_append_int_new(left_acc, left_acc_len, node_values[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? node_values_len + _mochi_idx : _mochi_idx;})]);
    size_t with_node_len = left_acc_len + 1;
    {
        long long* __ret5 = inorder(node_rights[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? node_rights_len + _mochi_idx : _mochi_idx;})], with_node, with_node_len);
        inorder_len = inorder_len;
        return __ret5;
    }
}

void user_main() {
    long long root = NIL;
    root = insert(root, 1LL);
    puts(({long long *__tmp6 = inorder(root, NULL, 0); char *__res = str_list_int(__tmp6, inorder_len); __res;}));
    root = insert(root, 3LL);
    root = insert(root, 5LL);
    root = insert(root, 17LL);
    root = insert(root, 19LL);
    root = insert(root, 2LL);
    root = insert(root, 16LL);
    root = insert(root, 4LL);
    root = insert(root, 0LL);
    puts(({long long *__tmp7 = inorder(root, NULL, 0); char *__res = str_list_int(__tmp7, inorder_len); __res;}));
    root = insert(root, 4LL);
    root = insert(root, 4LL);
    root = insert(root, 4LL);
    puts(({long long *__tmp8 = inorder(root, NULL, 0); char *__res = str_list_int(__tmp8, inorder_len); __res;}));
    root = erase(root, 0LL);
    puts(({long long *__tmp9 = inorder(root, NULL, 0); char *__res = str_list_int(__tmp9, inorder_len); __res;}));
    root = erase(root, 4LL);
    puts(({long long *__tmp10 = inorder(root, NULL, 0); char *__res = str_list_int(__tmp10, inorder_len); __res;}));
}

int main(void) {
    {
        long long __start = _now();
        node_values = NULL;
        node_values = malloc(0 * sizeof(long long));
        node_values_len = 0;
        node_priors = NULL;
        node_priors = malloc(0 * sizeof(double));
        node_priors_len = 0;
        node_lefts = NULL;
        node_lefts = malloc(0 * sizeof(long long));
        node_lefts_len = 0;
        node_rights = NULL;
        node_rights = malloc(0 * sizeof(long long));
        node_rights_len = 0;
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
