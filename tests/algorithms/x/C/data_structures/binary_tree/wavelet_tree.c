// Generated by Mochi 0.10.32 on 2025-08-24 21:19 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t make_list_len;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Node Node;

struct Node {
    long long minn;
    long long maxx;
    long long *map_left;
    size_t map_left_len;
    long long left;
    long long right;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Node *nodes = NULL;
size_t nodes_len = 0;
long long *test_array = NULL;
size_t test_array_len = 0;
long long root = 0;

long long * make_list(long long length, long long value);
long long min_list(long long * arr, size_t arr_len);
long long max_list(long long * arr, size_t arr_len);
long long build_tree(long long * arr, size_t arr_len);
long long rank_till_index(long long node_idx, long long num, long long index);
long long rank(long long node_idx, long long num, long long start, long long end);
long long quantile(long long node_idx, long long index, long long start, long long end);
long long range_counting(long long node_idx, long long start, long long end, long long start_num, long long end_num);
int main(void);

long long * make_list(long long length, long long value) {
    long long *lst = NULL;
    size_t lst_len = 0;
    long long i = 0LL;
    while (i < length) {
        lst = list_append_long_long(lst, &lst_len, value);
        i = i + 1LL;
    }
    return make_list_len = lst_len, lst;
}

long long min_list(long long * arr, size_t arr_len) {
    long long m = arr[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
    long long i = 1LL;
    while (i < arr_len) {
        if (arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] < m) {
            m = arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        }
        i = i + 1LL;
    }
    return m;
}

long long max_list(long long * arr, size_t arr_len) {
    long long m = arr[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
    long long i = 1LL;
    while (i < arr_len) {
        if (arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] > m) {
            m = arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        }
        i = i + 1LL;
    }
    return m;
}

long long build_tree(long long * arr, size_t arr_len) {
    Node n = (Node){.minn = min_list(arr, arr_len), .maxx = max_list(arr, arr_len), .map_left = make_list(arr_len, 0LL), .map_left_len = make_list_len, .left = -1LL, .right = -1LL};
    if (n.minn == n.maxx) {
        nodes = list_append_Node(nodes, &nodes_len, n);
        return nodes_len - 1LL;
    }
    long long pivot = (n.minn + n.maxx) / 2LL;
    long long *left_arr = NULL;
    size_t left_arr_len = 0;
    long long *right_arr = NULL;
    size_t right_arr_len = 0;
    long long i = 0LL;
    while (i < arr_len) {
        long long num = arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        if (num <= pivot) {
            left_arr = list_append_long_long(left_arr, &left_arr_len, num);
        } else {
            right_arr = list_append_long_long(right_arr, &right_arr_len, num);
        }
        long long *ml = n.map_left;
        size_t ml_len = n.map_left_len;
        ml[(int)(i)] = left_arr_len;
        n.map_left = ml;
        n.map_left_len = ml_len;
        i = i + 1LL;
    }
    if (left_arr_len > 0LL) {
        n.left = build_tree(left_arr, left_arr_len);
    }
    if (right_arr_len > 0LL) {
        n.right = build_tree(right_arr, right_arr_len);
    }
    nodes = list_append_Node(nodes, &nodes_len, n);
    return nodes_len - 1LL;
}

long long rank_till_index(long long node_idx, long long num, long long index) {
    if ((index < 0LL) || (node_idx < 0LL)) {
        return 0LL;
    }
    Node node = nodes[(int)({long long _mochi_idx = node_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    if (node.minn == node.maxx) {
        if (node.minn == num) {
            return index + 1LL;
        } else {
            return 0LL;
        }
    }
    long long pivot = (node.minn + node.maxx) / 2LL;
    if (num <= pivot) {
        return rank_till_index(node.left, num, node.map_left[(int)({long long _mochi_idx = index; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})] - 1LL);
    } else {
        return rank_till_index(node.right, num, index - node.map_left[(int)({long long _mochi_idx = index; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})]);
    }
}

long long rank(long long node_idx, long long num, long long start, long long end) {
    if (start > end) {
        return 0LL;
    }
    long long rank_till_end = rank_till_index(node_idx, num, end);
    long long rank_before_start = rank_till_index(node_idx, num, start - 1LL);
    return rank_till_end - rank_before_start;
}

long long quantile(long long node_idx, long long index, long long start, long long end) {
    if (((index > (end - start)) || (start > end)) || (node_idx < 0LL)) {
        return -1LL;
    }
    Node node = nodes[(int)({long long _mochi_idx = node_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    if (node.minn == node.maxx) {
        return node.minn;
    }
    long long left_start;
    if (start == 0LL) {
        left_start = 0LL;
    } else {
        left_start = node.map_left[(int)({long long _mochi_idx = start - 1LL; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})];
    }
    long long num_left = node.map_left[(int)({long long _mochi_idx = end; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})] - left_start;
    if (num_left > index) {
        return quantile(node.left, index, left_start, node.map_left[(int)({long long _mochi_idx = end; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})] - 1LL);
    } else {
        return quantile(node.right, index - num_left, start - left_start, end - node.map_left[(int)({long long _mochi_idx = end; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})]);
    }
}

long long range_counting(long long node_idx, long long start, long long end, long long start_num, long long end_num) {
    if (((start > end) || (node_idx < 0LL)) || (start_num > end_num)) {
        return 0LL;
    }
    Node node = nodes[(int)({long long _mochi_idx = node_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    if ((node.minn > end_num) || (node.maxx < start_num)) {
        return 0LL;
    }
    if ((start_num <= node.minn) && (node.maxx <= end_num)) {
        return (end - start) + 1LL;
    }
    long long left = range_counting(node.left, (start == 0LL ? 0LL : node.map_left[(int)({long long _mochi_idx = start - 1LL; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})]), node.map_left[(int)({long long _mochi_idx = end; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})] - 1LL, start_num, end_num);
    long long right = range_counting(node.right, start - (start == 0LL ? 0LL : node.map_left[(int)({long long _mochi_idx = start - 1LL; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})]), end - node.map_left[(int)({long long _mochi_idx = end; _mochi_idx < 0 ? node.map_left_len + _mochi_idx : _mochi_idx;})], start_num, end_num);
    return left + right;
}

int main(void) {
    {
        long long __start = _now();
        nodes = NULL;
        nodes = malloc(0 * sizeof(Node));
        nodes_len = 0;
        test_array = ({long long *tmp = malloc(20 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 1LL; tmp[2] = 4LL; tmp[3] = 5LL; tmp[4] = 6LL; tmp[5] = 0LL; tmp[6] = 8LL; tmp[7] = 9LL; tmp[8] = 1LL; tmp[9] = 2LL; tmp[10] = 0LL; tmp[11] = 6LL; tmp[12] = 4LL; tmp[13] = 2LL; tmp[14] = 0LL; tmp[15] = 6LL; tmp[16] = 5LL; tmp[17] = 3LL; tmp[18] = 2LL; tmp[19] = 7LL; tmp;});
        test_array = malloc(20 * sizeof(long long));
        test_array_len = 20;
        test_array[0] = 2LL;
        test_array[1] = 1LL;
        test_array[2] = 4LL;
        test_array[3] = 5LL;
        test_array[4] = 6LL;
        test_array[5] = 0LL;
        test_array[6] = 8LL;
        test_array[7] = 9LL;
        test_array[8] = 1LL;
        test_array[9] = 2LL;
        test_array[10] = 0LL;
        test_array[11] = 6LL;
        test_array[12] = 4LL;
        test_array[13] = 2LL;
        test_array[14] = 0LL;
        test_array[15] = 6LL;
        test_array[16] = 5LL;
        test_array[17] = 3LL;
        test_array[18] = 2LL;
        test_array[19] = 7LL;
        root = build_tree(test_array, test_array_len);
        puts(str_concat("rank_till_index 6 at 6 -> ", str_int(rank_till_index(root, 6LL, 6LL))));
        puts(str_concat("rank 6 in [3,13] -> ", str_int(rank(root, 6LL, 3LL, 13LL))));
        puts(str_concat("quantile index 2 in [2,5] -> ", str_int(quantile(root, 2LL, 2LL, 5LL))));
        puts(str_concat("range_counting [3,7] in [1,10] -> ", str_int(range_counting(root, 1LL, 10LL, 3LL, 7LL))));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
