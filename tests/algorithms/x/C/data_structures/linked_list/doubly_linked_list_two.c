// Generated by Mochi 0.10.32 on 2025-08-25 16:08 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct LinkedList LinkedList;
typedef struct Node Node;

struct LinkedList {
    Node *nodes;
    size_t nodes_len;
    long long head_idx;
    long long tail_idx;
};

struct Node {
    long long data;
    long long prev_index;
    long long next_index;
};

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

LinkedList empty_list();
long long get_head_data(LinkedList ll);
long long get_tail_data(LinkedList ll);
void insert_before_node(LinkedList* ll, long long idx, long long new_idx);
void insert_after_node(LinkedList* ll, long long idx, long long new_idx);
void set_head(LinkedList* ll, long long idx);
void set_tail(LinkedList* ll, long long idx);
void insert(LinkedList* ll, long long value);
void insert_at_position(LinkedList* ll, long long position, long long value);
long long get_node(LinkedList ll, long long item);
void remove_node_pointers(LinkedList* ll, long long idx);
void delete_value(LinkedList* ll, long long value);
long long contains(LinkedList ll, long long value);
long long is_empty(LinkedList ll);
const char* to_string(LinkedList ll);
void print_list(LinkedList ll);
void user_main();
int main(void);

LinkedList empty_list() {
    return (LinkedList){.nodes = NULL, .nodes_len = 0, .head_idx = -1LL, .tail_idx = -1LL};
}

long long get_head_data(LinkedList ll) {
    if (ll.head_idx == -1LL) {
        return -1LL;
    }
    Node node = ll.nodes[(int)({long long _mochi_idx = ll.head_idx; _mochi_idx < 0 ? ll.nodes_len + _mochi_idx : _mochi_idx;})];
    return node.data;
}

long long get_tail_data(LinkedList ll) {
    if (ll.tail_idx == -1LL) {
        return -1LL;
    }
    Node node = ll.nodes[(int)({long long _mochi_idx = ll.tail_idx; _mochi_idx < 0 ? ll.nodes_len + _mochi_idx : _mochi_idx;})];
    return node.data;
}

void insert_before_node(LinkedList* ll, long long idx, long long new_idx) {
    Node *nodes = ll->nodes;
    size_t nodes_len = ll->nodes_len;
    Node new_node = nodes[(int)({long long _mochi_idx = new_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    new_node.next_index = idx;
    Node node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    long long p = node.prev_index;
    new_node.prev_index = p;
    nodes[(int)(new_idx)] = new_node;
    if (p == -1LL) {
        ll->head_idx = new_idx;
    } else {
        Node prev_node = nodes[(int)({long long _mochi_idx = p; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
        prev_node.next_index = new_idx;
        nodes[(int)(p)] = prev_node;
    }
    node.prev_index = new_idx;
    nodes[(int)(idx)] = node;
    ll->nodes = nodes;
    ll->nodes_len = nodes_len;
}

void insert_after_node(LinkedList* ll, long long idx, long long new_idx) {
    Node *nodes = ll->nodes;
    size_t nodes_len = ll->nodes_len;
    Node new_node = nodes[(int)({long long _mochi_idx = new_idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    new_node.prev_index = idx;
    Node node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    long long nxt = node.next_index;
    new_node.next_index = nxt;
    nodes[(int)(new_idx)] = new_node;
    if (nxt == -1LL) {
        ll->tail_idx = new_idx;
    } else {
        Node next_node = nodes[(int)({long long _mochi_idx = nxt; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
        next_node.prev_index = new_idx;
        nodes[(int)(nxt)] = next_node;
    }
    node.next_index = new_idx;
    nodes[(int)(idx)] = node;
    ll->nodes = nodes;
    ll->nodes_len = nodes_len;
}

void set_head(LinkedList* ll, long long idx) {
    if (ll->head_idx == -1LL) {
        ll->head_idx = idx;
        ll->tail_idx = idx;
    } else {
        insert_before_node(ll, ll->head_idx, idx);
    }
}

void set_tail(LinkedList* ll, long long idx) {
    if (ll->tail_idx == -1LL) {
        ll->head_idx = idx;
        ll->tail_idx = idx;
    } else {
        insert_after_node(ll, ll->tail_idx, idx);
    }
}

void insert(LinkedList* ll, long long value) {
    Node *nodes = ll->nodes;
    size_t nodes_len = ll->nodes_len;
    nodes = list_append_Node(nodes, &nodes_len, (Node){.data = value, .prev_index = -1LL, .next_index = -1LL});
    long long idx = nodes_len - 1LL;
    ll->nodes = nodes;
    ll->nodes_len = nodes_len;
    if (ll->head_idx == -1LL) {
        ll->head_idx = idx;
        ll->tail_idx = idx;
    } else {
        insert_after_node(ll, ll->tail_idx, idx);
    }
}

void insert_at_position(LinkedList* ll, long long position, long long value) {
    long long current = ll->head_idx;
    long long current_pos = 1LL;
    while (current != -1LL) {
        if (current_pos == position) {
            Node *nodes = ll->nodes;
            size_t nodes_len = ll->nodes_len;
            nodes = list_append_Node(nodes, &nodes_len, (Node){.data = value, .prev_index = -1LL, .next_index = -1LL});
            long long new_idx = nodes_len - 1LL;
            ll->nodes = nodes;
            ll->nodes_len = nodes_len;
            insert_before_node(ll, current, new_idx);
            return 0;
        }
        Node node = ll->nodes[(int)({long long _mochi_idx = current; _mochi_idx < 0 ? ll->nodes_len + _mochi_idx : _mochi_idx;})];
        current = node.next_index;
        current_pos = current_pos + 1LL;
    }
    insert(ll, value);
}

long long get_node(LinkedList ll, long long item) {
    long long current = ll.head_idx;
    while (current != -1LL) {
        Node node = ll.nodes[(int)({long long _mochi_idx = current; _mochi_idx < 0 ? ll.nodes_len + _mochi_idx : _mochi_idx;})];
        if (node.data == item) {
            return current;
        }
        current = node.next_index;
    }
    return -1LL;
}

void remove_node_pointers(LinkedList* ll, long long idx) {
    Node *nodes = ll->nodes;
    size_t nodes_len = ll->nodes_len;
    Node node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    long long nxt = node.next_index;
    long long p = node.prev_index;
    if (nxt != -1LL) {
        Node nxt_node = nodes[(int)({long long _mochi_idx = nxt; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
        nxt_node.prev_index = p;
        nodes[(int)(nxt)] = nxt_node;
    }
    if (p != -1LL) {
        Node prev_node = nodes[(int)({long long _mochi_idx = p; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
        prev_node.next_index = nxt;
        nodes[(int)(p)] = prev_node;
    }
    node.next_index = -1LL;
    node.prev_index = -1LL;
    nodes[(int)(idx)] = node;
    ll->nodes = nodes;
    ll->nodes_len = nodes_len;
}

void delete_value(LinkedList* ll, long long value) {
    long long idx = get_node(*ll, value);
    if (idx == -1LL) {
        return 0;
    }
    if (idx == ll->head_idx) {
        Node node = ll->nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? ll->nodes_len + _mochi_idx : _mochi_idx;})];
        ll->head_idx = node.next_index;
    }
    if (idx == ll->tail_idx) {
        Node node = ll->nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? ll->nodes_len + _mochi_idx : _mochi_idx;})];
        ll->tail_idx = node.prev_index;
    }
    remove_node_pointers(ll, idx);
}

long long contains(LinkedList ll, long long value) {
    return get_node(ll, value) != -1LL;
}

long long is_empty(LinkedList ll) {
    return ll.head_idx == -1LL;
}

const char* to_string(LinkedList ll) {
    const char* res = "";
    long long first = 1LL;
    long long current = ll.head_idx;
    while (current != -1LL) {
        Node node = ll.nodes[(int)({long long _mochi_idx = current; _mochi_idx < 0 ? ll.nodes_len + _mochi_idx : _mochi_idx;})];
        const char* val = str_int(node.data);
        if (first) {
            res = val;
            first = 0LL;
        } else {
            res = str_concat(str_concat(res, " "), val);
        }
        current = node.next_index;
    }
    return res;
}

void print_list(LinkedList ll) {
    long long current = ll.head_idx;
    while (current != -1LL) {
        Node node = ll.nodes[(int)({long long _mochi_idx = current; _mochi_idx < 0 ? ll.nodes_len + _mochi_idx : _mochi_idx;})];
        puts(str_int(node.data));
        current = node.next_index;
    }
}

void user_main() {
    LinkedList ll = empty_list();
    puts(str_int(get_head_data(ll)));
    puts(str_int(get_tail_data(ll)));
    puts(str_int(is_empty(ll)));
    insert(&ll, 10LL);
    puts(str_int(get_head_data(ll)));
    puts(str_int(get_tail_data(ll)));
    insert_at_position(&ll, 3LL, 20LL);
    puts(str_int(get_head_data(ll)));
    puts(str_int(get_tail_data(ll)));
    Node *nodes = ll.nodes;
    size_t nodes_len = ll.nodes_len;
    nodes = list_append_Node(nodes, &nodes_len, (Node){.data = 1000LL, .prev_index = -1LL, .next_index = -1LL});
    long long idx_head = nodes_len - 1LL;
    ll.nodes = nodes;
    ll.nodes_len = nodes_len;
    set_head(&ll, idx_head);
    nodes = ll.nodes;
    nodes = list_append_Node(nodes, &nodes_len, (Node){.data = 2000LL, .prev_index = -1LL, .next_index = -1LL});
    long long idx_tail = nodes_len - 1LL;
    ll.nodes = nodes;
    ll.nodes_len = nodes_len;
    set_tail(&ll, idx_tail);
    print_list(ll);
    puts(str_int(is_empty(ll)));
    print_list(ll);
    puts(str_int(contains(ll, 10LL)));
    delete_value(&ll, 10LL);
    puts(str_int(contains(ll, 10LL)));
    delete_value(&ll, 2000LL);
    puts(str_int(get_tail_data(ll)));
    delete_value(&ll, 1000LL);
    puts(str_int(get_tail_data(ll)));
    puts(str_int(get_head_data(ll)));
    print_list(ll);
    delete_value(&ll, 20LL);
    print_list(ll);
    long long i = 1LL;
    while (i < 10LL) {
        insert(&ll, i);
        i = i + 1LL;
    }
    print_list(ll);
    LinkedList ll2 = empty_list();
    insert_at_position(&ll2, 1LL, 10LL);
    puts(to_string(ll2));
    insert_at_position(&ll2, 2LL, 20LL);
    puts(to_string(ll2));
    insert_at_position(&ll2, 1LL, 30LL);
    puts(to_string(ll2));
    insert_at_position(&ll2, 3LL, 40LL);
    puts(to_string(ll2));
    insert_at_position(&ll2, 5LL, 50LL);
    puts(to_string(ll2));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
