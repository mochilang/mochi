// Generated by Mochi 0.10.32 on 2025-08-25 16:08 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct LinkedDeque LinkedDeque;
typedef struct Node Node;
typedef struct DeleteResult DeleteResult;

struct LinkedDeque {
    Node *nodes;
    size_t nodes_len;
    long long header;
    long long trailer;
    long long size;
};

struct Node {
    const char* data;
    long long prev;
    long long next;
};

struct DeleteResult {
    LinkedDeque deque;
    const char* value;
};

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

LinkedDeque new_deque();
long long is_empty(LinkedDeque d);
const char* front(LinkedDeque d);
const char* back(LinkedDeque d);
LinkedDeque insert(LinkedDeque d, long long pred, const char* value, long long succ);
DeleteResult delete(LinkedDeque d, long long idx);
LinkedDeque add_first(LinkedDeque d, const char* value);
LinkedDeque add_last(LinkedDeque d, const char* value);
DeleteResult remove_first(LinkedDeque d);
DeleteResult remove_last(LinkedDeque d);
void user_main();
int main(void);

LinkedDeque new_deque() {
    Node *nodes = NULL;
    size_t nodes_len = 0;
    nodes = list_append_Node(nodes, &nodes_len, (Node){.data = "", .prev = -1LL, .next = 1LL});
    nodes = list_append_Node(nodes, &nodes_len, (Node){.data = "", .prev = 0LL, .next = -1LL});
    return (LinkedDeque){.nodes = nodes, .nodes_len = nodes_len, .header = 0LL, .trailer = 1LL, .size = 0LL};
}

long long is_empty(LinkedDeque d) {
    return d.size == 0LL;
}

const char* front(LinkedDeque d) {
    if (is_empty(d)) {
        panic("List is empty");
    }
    Node head = d.nodes[(int)({long long _mochi_idx = d.header; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    long long idx = head.next;
    Node node = d.nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    return node.data;
}

const char* back(LinkedDeque d) {
    if (is_empty(d)) {
        panic("List is empty");
    }
    Node tail = d.nodes[(int)({long long _mochi_idx = d.trailer; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    long long idx = tail.prev;
    Node node = d.nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    return node.data;
}

LinkedDeque insert(LinkedDeque d, long long pred, const char* value, long long succ) {
    Node *nodes = d.nodes;
    size_t nodes_len = d.nodes_len;
    long long new_idx = nodes_len;
    nodes = list_append_Node(nodes, &nodes_len, (Node){.data = value, .prev = pred, .next = succ});
    Node pred_node = nodes[(int)({long long _mochi_idx = pred; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    pred_node.next = new_idx;
    nodes[(int)(pred)] = pred_node;
    Node succ_node = nodes[(int)({long long _mochi_idx = succ; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    succ_node.prev = new_idx;
    nodes[(int)(succ)] = succ_node;
    d.nodes = nodes;
    d.nodes_len = nodes_len;
    d.size = d.size + 1LL;
    return d;
}

DeleteResult delete(LinkedDeque d, long long idx) {
    Node *nodes = d.nodes;
    size_t nodes_len = d.nodes_len;
    Node node = nodes[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    long long pred = node.prev;
    long long succ = node.next;
    Node pred_node = nodes[(int)({long long _mochi_idx = pred; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    pred_node.next = succ;
    nodes[(int)(pred)] = pred_node;
    Node succ_node = nodes[(int)({long long _mochi_idx = succ; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})];
    succ_node.prev = pred;
    nodes[(int)(succ)] = succ_node;
    const char* val = node.data;
    d.nodes = nodes;
    d.nodes_len = nodes_len;
    d.size = d.size - 1LL;
    return (DeleteResult){.deque = d, .value = val};
}

LinkedDeque add_first(LinkedDeque d, const char* value) {
    Node head = d.nodes[(int)({long long _mochi_idx = d.header; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    long long succ = head.next;
    return insert(d, d.header, value, succ);
}

LinkedDeque add_last(LinkedDeque d, const char* value) {
    Node tail = d.nodes[(int)({long long _mochi_idx = d.trailer; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    long long pred = tail.prev;
    return insert(d, pred, value, d.trailer);
}

DeleteResult remove_first(LinkedDeque d) {
    if (is_empty(d)) {
        panic("remove_first from empty list");
    }
    Node head = d.nodes[(int)({long long _mochi_idx = d.header; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    long long idx = head.next;
    return delete(d, idx);
}

DeleteResult remove_last(LinkedDeque d) {
    if (is_empty(d)) {
        panic("remove_first from empty list");
    }
    Node tail = d.nodes[(int)({long long _mochi_idx = d.trailer; _mochi_idx < 0 ? d.nodes_len + _mochi_idx : _mochi_idx;})];
    long long idx = tail.prev;
    return delete(d, idx);
}

void user_main() {
    LinkedDeque d = new_deque();
    d = add_first(d, "A");
    puts(front(d));
    d = add_last(d, "B");
    puts(back(d));
    DeleteResult r = remove_first(d);
    d = r.deque;
    puts(r.value);
    r = remove_last(d);
    d = r.deque;
    puts(r.value);
    puts(str_int(is_empty(d)));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
