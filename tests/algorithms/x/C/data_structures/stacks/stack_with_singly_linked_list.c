// Generated by Mochi 0.10.32 on 2025-08-08 09:18 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Node Node;
typedef struct Stack Stack;
typedef struct PopResult PopResult;

struct Node {
    const char* value;
    long long next;
};

struct Stack {
    Node *nodes;
    size_t nodes_len;
    long long top;
};

struct PopResult {
    Stack stack;
    const char* value;
};

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Stack empty_stack();
long long is_empty(Stack stack);
Stack push(Stack stack, const char* item);
PopResult pop(Stack stack);
const char* peek(Stack stack);
Stack clear(Stack stack);
void user_main();
int main(void);

Stack empty_stack() {
    return (Stack){.nodes = NULL, .nodes_len = 0, .top = -1LL};
}

long long is_empty(Stack stack) {
    return stack.top == -1LL;
}

Stack push(Stack stack, const char* item) {
    Node new_node = (Node){.value = item, .next = stack.top};
    Node *new_nodes = stack.nodes;
    size_t new_nodes_len = stack.nodes_len;
    new_nodes = list_append_Node(new_nodes, &new_nodes_len, new_node);
    long long new_top = new_nodes_len - 1LL;
    return (Stack){.nodes = new_nodes, .nodes_len = new_nodes_len, .top = new_top};
}

PopResult pop(Stack stack) {
    if (stack.top == -1LL) {
        panic("pop from empty stack");
    }
    Node node = stack.nodes[(int)(stack.top)];
    long long new_top = node.next;
    Stack new_stack = (Stack){.nodes = stack.nodes, .nodes_len = stack.nodes_len, .top = new_top};
    return (PopResult){.stack = new_stack, .value = node.value};
}

const char* peek(Stack stack) {
    if (stack.top == -1LL) {
        panic("peek from empty stack");
    }
    Node node = stack.nodes[(int)(stack.top)];
    return node.value;
}

Stack clear(Stack stack) {
    return (Stack){.nodes = NULL, .nodes_len = 0, .top = -1LL};
}

void user_main() {
    Stack stack = empty_stack();
    printf("%d\n", is_empty(stack));
    stack = push(stack, "5");
    stack = push(stack, "9");
    stack = push(stack, "python");
    printf("%d\n", is_empty(stack));
    PopResult res = pop(stack);
    stack = res.stack;
    puts(res.value);
    stack = push(stack, "algorithms");
    res = pop(stack);
    stack = res.stack;
    puts(res.value);
    res = pop(stack);
    stack = res.stack;
    puts(res.value);
    res = pop(stack);
    stack = res.stack;
    puts(res.value);
    printf("%d\n", is_empty(stack));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
