// Generated by Mochi 0.10.32 on 2025-08-25 10:35 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

size_t hypercube_points_len;
size_t *hypercube_points_lens;
size_t sort_points_len;
size_t *sort_points_lens;
size_t sublist_len;
size_t *sublist_lens;
size_t shift_nodes_len;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t concat_len;
static void* concat_generic(void *a, size_t a_len, const void *b, size_t b_len, size_t elem_size) {
    void *res = realloc(a, (a_len + b_len) * elem_size);
    if (b_len > 0) memcpy((char*)res + a_len * elem_size, b, b_len * elem_size);
    concat_len = a_len + b_len;
    return res;
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct BuildResult BuildResult;
typedef struct Node Node;
typedef struct SearchResult SearchResult;

struct BuildResult {
    long long index;
    Node *nodes;
    size_t nodes_len;
};

struct Node {
    double *point;
    size_t point_len;
    long long left;
    long long right;
};

struct SearchResult {
    double *point;
    size_t point_len;
    double dist;
    long long visited;
};

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long seed = 1LL;

long long user_rand();
double user_random();
double * * hypercube_points(long long num_points, double cube_size, long long num_dimensions);
double * * sort_points(double * * points, size_t points_len, size_t* points_lens, size_t points_lens_len, long long axis);
double * * sublist(double * * arr, size_t arr_len, size_t* arr_lens, size_t arr_lens_len, long long start, long long end);
Node * shift_nodes(Node * nodes, size_t nodes_len, long long offset);
BuildResult build_kdtree(double * * points, size_t points_len, size_t* points_lens, size_t points_lens_len, long long depth);
double square_distance(double * a, size_t a_len, double * b, size_t b_len);
SearchResult nearest_neighbour_search(Node * tree, size_t tree_len, long long root, double * query_point, size_t query_point_len);
const char* list_to_string(double * arr, size_t arr_len);
const char* user_main();
int main(void);

long long user_rand() {
    seed = ((seed * 1103515245LL) + 12345LL) % 2147483648LL;
    return seed;
}

double user_random() {
    return (1.0 * user_rand()) / 2.147483648e+09;
}

double * * hypercube_points(long long num_points, double cube_size, long long num_dimensions) {
    double **pts = NULL;
    size_t pts_len = 0;
    size_t *pts_lens = NULL;
    size_t pts_lens_len = 0;
    long long i = 0LL;
    while (i < num_points) {
        double *p = NULL;
        size_t p_len = 0;
        long long j = 0LL;
        while (j < num_dimensions) {
            p = list_append_double(p, &p_len, cube_size * user_random());
            j = j + 1LL;
        }
        pts = list_append_doubleptr(pts, &pts_len, p);
        pts_lens = list_append_szt(pts_lens, &pts_lens_len, p_len);
        i = i + 1LL;
    }
    return hypercube_points_lens = pts_lens, hypercube_points_len = pts_len, pts;
}

double * * sort_points(double * * points, size_t points_len, size_t* points_lens, size_t points_lens_len, long long axis) {
    long long n = points_len;
    long long i = 1LL;
    while (i < n) {
        double *key = points[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? points_len + _mochi_idx : _mochi_idx;})];
        size_t key_len = points_lens[(int)(i)];
        long long j = i - 1LL;
        while ((j >= 0LL) && (points[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? points_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = axis; _mochi_idx < 0 ? points_lens[(int)(j)] + _mochi_idx : _mochi_idx;})] > key[(int)({long long _mochi_idx = axis; _mochi_idx < 0 ? key_len + _mochi_idx : _mochi_idx;})])) {
            points[(int)(j + 1LL)] = points[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? points_len + _mochi_idx : _mochi_idx;})];
            j = j - 1LL;
        }
        points[(int)(j + 1LL)] = key;
        i = i + 1LL;
    }
    return sort_points_lens = points_lens, sort_points_len = points_len, points;
}

double * * sublist(double * * arr, size_t arr_len, size_t* arr_lens, size_t arr_lens_len, long long start, long long end) {
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = start;
    while (i < end) {
        res = list_append_doubleptr(res, &res_len, arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})]);
        res_lens = list_append_szt(res_lens, &res_lens_len, arr_lens[(int)(i)]);
        i = i + 1LL;
    }
    return sublist_lens = res_lens, sublist_len = res_len, res;
}

Node * shift_nodes(Node * nodes, size_t nodes_len, long long offset) {
    long long i = 0LL;
    while (i < nodes_len) {
        if (nodes[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})].left != (0LL - 1LL)) {
            nodes[(int)(i)].left = nodes[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})].left + offset;
        }
        if (nodes[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})].right != (0LL - 1LL)) {
            nodes[(int)(i)].right = nodes[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})].right + offset;
        }
        i = i + 1LL;
    }
    return shift_nodes_len = nodes_len, nodes;
}

BuildResult build_kdtree(double * * points, size_t points_len, size_t* points_lens, size_t points_lens_len, long long depth) {
    if (points_len == 0LL) {
        return (BuildResult){.index = -1LL, .nodes = NULL, .nodes_len = 0};
    }
    long long k = points_lens[(int)(0LL)];
    long long axis = depth % k;
    points = sort_points(points, points_len, points_lens, points_len, axis);
    points_len = sort_points_len;
    points_lens = sort_points_lens;
    long long median = points_len / 2LL;
    double **left_points = sublist(points, points_len, points_lens, points_len, 0LL, median);
    size_t left_points_len = sublist_len;
    size_t *left_points_lens = sublist_lens;
    size_t left_points_lens_len = sublist_len;
    double **right_points = sublist(points, points_len, points_lens, points_len, median + 1LL, points_len);
    size_t right_points_len = sublist_len;
    size_t *right_points_lens = sublist_lens;
    size_t right_points_lens_len = sublist_len;
    BuildResult left_res = build_kdtree(left_points, left_points_len, left_points_lens, left_points_len, depth + 1LL);
    BuildResult right_res = build_kdtree(right_points, right_points_len, right_points_lens, right_points_len, depth + 1LL);
    long long offset = left_res.nodes_len + 1LL;
    Node *shifted_right = shift_nodes(right_res.nodes, right_res.nodes_len, offset);
    size_t shifted_right_len = shift_nodes_len;
    Node *nodes = left_res.nodes;
    size_t nodes_len = left_res.nodes_len;
    long long left_index = left_res.index;
    long long right_index;
    if (right_res.index == (0LL - 1LL)) {
        right_index = -1LL;
    } else {
        right_index = right_res.index + offset;
    }
    nodes = list_append_Node(nodes, &nodes_len, (Node){.point = points[(int)({long long _mochi_idx = median; _mochi_idx < 0 ? points_len + _mochi_idx : _mochi_idx;})], .point_len = points_lens[(int)(median)], .left = left_index, .right = right_index});
    nodes = (Node*)concat_generic(nodes, nodes_len, shifted_right, shifted_right_len, sizeof(Node));
    nodes_len = concat_len;
    long long root_index = left_res.nodes_len;
    return (BuildResult){.index = root_index, .nodes = nodes, .nodes_len = nodes_len};
}

double square_distance(double * a, size_t a_len, double * b, size_t b_len) {
    double sum = 0.0;
    long long i = 0LL;
    while (i < a_len) {
        double diff = a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})] - b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})];
        sum = sum + (diff * diff);
        i = i + 1LL;
    }
    return sum;
}

SearchResult nearest_neighbour_search(Node * tree, size_t tree_len, long long root, double * query_point, size_t query_point_len) {
    double *nearest_point = NULL;
    size_t nearest_point_len = 0;
    double nearest_dist = 0.0;
    long long visited = 0LL;
    long long i = 0LL;
    while (i < tree_len) {
        Node node = tree[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? tree_len + _mochi_idx : _mochi_idx;})];
        double dist = square_distance(query_point, query_point_len, node.point, node.point_len);
        visited = visited + 1LL;
        if ((visited == 1LL) || (dist < nearest_dist)) {
            nearest_point = node.point;
            nearest_dist = dist;
        }
        i = i + 1LL;
    }
    return (SearchResult){.point = nearest_point, .point_len = nearest_point_len, .dist = nearest_dist, .visited = visited};
}

const char* list_to_string(double * arr, size_t arr_len) {
    const char* s = "[";
    long long i = 0LL;
    while (i < arr_len) {
        s = str_concat(s, str_float(arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})]));
        if (i < (arr_len - 1LL)) {
            s = str_concat(s, ", ");
        }
        i = i + 1LL;
    }
    return str_concat(s, "]");
}

const char* user_main() {
    long long num_points = 5000LL;
    double cube_size = 10.0;
    long long num_dimensions = 10LL;
    double **pts = hypercube_points(num_points, cube_size, num_dimensions);
    size_t pts_len = hypercube_points_len;
    size_t *pts_lens = hypercube_points_lens;
    size_t pts_lens_len = hypercube_points_len;
    BuildResult build = build_kdtree(pts, pts_len, pts_lens, pts_len, 0LL);
    long long root = build.index;
    Node *tree = build.nodes;
    size_t tree_len = build.nodes_len;
    double *query = NULL;
    size_t query_len = 0;
    long long i = 0LL;
    while (i < num_dimensions) {
        query = list_append_double(query, &query_len, user_random());
        i = i + 1LL;
    }
    SearchResult res = nearest_neighbour_search(tree, tree_len, root, query, query_len);
    puts(str_concat("Query point: ", list_to_string(query, query_len)));
    puts(str_concat("Nearest point: ", list_to_string(res.point, res.point_len)));
    puts(str_concat("Distance: ", str_float(res.dist)));
    puts(str_concat("Nodes visited: ", str_int(res.visited)));
}

int main(void) {
    user_main();
    return 0;
}
