// Generated by Mochi 0.10.32 on 2025-08-08 19:48 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t repeat_int_len;
size_t repeat_bool_len;
size_t set_int_len;
size_t set_bool_len;
size_t keys_len;
size_t *keys_lens;

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct HashTable HashTable;

struct HashTable {
    long long size_table;
    long long *values;
    size_t values_len;
    long long *filled;
    size_t filled_len;
    long long charge_factor;
    double lim_charge;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long * repeat_int(long long n, long long val);
long long * repeat_bool(long long n, long long val);
long long * set_int(long long * xs, size_t xs_len, long long idx, long long value);
long long * set_bool(long long * xs, size_t xs_len, long long idx, long long value);
HashTable create_table(long long size_table, long long charge_factor, double lim_charge);
long long hash_function(HashTable ht, long long key);
long long is_prime(long long n);
long long next_prime(long long value, long long factor);
HashTable set_value(HashTable ht, long long key, long long data);
long long collision_resolution(HashTable ht, long long key);
HashTable rehashing(HashTable ht);
HashTable insert_data(HashTable ht, long long data);
long long * * keys(HashTable ht);
void user_main();
int main(void);

long long * repeat_int(long long n, long long val) {
    long long *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < n) {
        res = list_append_long_long(res, &res_len, val);
        i = i + 1LL;
    }
    return repeat_int_len = res_len, res;
}

long long * repeat_bool(long long n, long long val) {
    long long *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < n) {
        res = list_append_long_long(res, &res_len, val);
        i = i + 1LL;
    }
    return repeat_bool_len = res_len, res;
}

long long * set_int(long long * xs, size_t xs_len, long long idx, long long value) {
    long long *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < xs_len) {
        if (i == idx) {
            res = list_append_long_long(res, &res_len, value);
        } else {
            res = list_append_long_long(res, &res_len, xs[(int)(i)]);
        }
        i = i + 1LL;
    }
    return set_int_len = res_len, res;
}

long long * set_bool(long long * xs, size_t xs_len, long long idx, long long value) {
    long long *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < xs_len) {
        if (i == idx) {
            res = list_append_long_long(res, &res_len, value);
        } else {
            res = list_append_long_long(res, &res_len, xs[(int)(i)]);
        }
        i = i + 1LL;
    }
    return set_bool_len = res_len, res;
}

HashTable create_table(long long size_table, long long charge_factor, double lim_charge) {
    return (HashTable){.size_table = size_table, .values = repeat_int(size_table, 0LL), .values_len = repeat_int_len, .filled = repeat_bool(size_table, 0LL), .filled_len = repeat_bool_len, .charge_factor = charge_factor, .lim_charge = lim_charge};
}

long long hash_function(HashTable ht, long long key) {
    long long k = key % ht.size_table;
    if (k < 0LL) {
        k = k + ht.size_table;
    }
    return k;
}

long long is_prime(long long n) {
    if (n < 2LL) {
        return 0LL;
    }
    if ((n % 2LL) == 0LL) {
        return n == 2LL;
    }
    long long i = 3LL;
    while ((i * i) <= n) {
        if ((n % i) == 0LL) {
            return 0LL;
        }
        i = i + 2LL;
    }
    return 1LL;
}

long long next_prime(long long value, long long factor) {
    long long candidate = (value * factor) + 1LL;
    while (!(is_prime(candidate))) {
        candidate = candidate + 1LL;
    }
    return candidate;
}

HashTable set_value(HashTable ht, long long key, long long data) {
    long long *new_values = set_int(ht.values, ht.values_len, key, data);
    size_t new_values_len = set_int_len;
    long long *new_filled = set_bool(ht.filled, ht.filled_len, key, 1LL);
    size_t new_filled_len = set_bool_len;
    return (HashTable){.size_table = ht.size_table, .values = new_values, .values_len = new_values_len, .filled = new_filled, .filled_len = new_filled_len, .charge_factor = ht.charge_factor, .lim_charge = ht.lim_charge};
}

long long collision_resolution(HashTable ht, long long key) {
    long long new_key = hash_function(ht, key + 1LL);
    long long steps = 0LL;
    while (ht.filled[(int)(new_key)]) {
        new_key = hash_function(ht, new_key + 1LL);
        steps = steps + 1LL;
        if (steps >= ht.size_table) {
            return -1LL;
        }
    }
    return new_key;
}

HashTable rehashing(HashTable ht) {
    long long *survivors = NULL;
    size_t survivors_len = 0;
    long long i = 0LL;
    while (i < ht.values_len) {
        if (ht.filled[(int)(i)]) {
            survivors = list_append_long_long(survivors, &survivors_len, ht.values[(int)(i)]);
        }
        i = i + 1LL;
    }
    long long new_size = next_prime(ht.size_table, 2LL);
    HashTable new_ht = create_table(new_size, ht.charge_factor, ht.lim_charge);
    i = 0LL;
    while (i < survivors_len) {
        new_ht = insert_data(new_ht, survivors[(int)(i)]);
        i = i + 1LL;
    }
    return new_ht;
}

HashTable insert_data(HashTable ht, long long data) {
    long long key = hash_function(ht, data);
    if (!(ht.filled[(int)(key)])) {
        return set_value(ht, key, data);
    }
    if (ht.values[(int)(key)] == data) {
        return ht;
    }
    long long new_key = collision_resolution(ht, key);
    if (new_key >= 0LL) {
        return set_value(ht, new_key, data);
    }
    HashTable resized = rehashing(ht);
    return insert_data(resized, data);
}

long long * * keys(HashTable ht) {
    long long **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < ht.values_len) {
        if (ht.filled[(int)(i)]) {
            res = list_append_intptr(res, &res_len, ({int *tmp = malloc(2 * sizeof(int)); tmp[0] = i; tmp[1] = ht.values[(int)(i)]; tmp;}));
            res_lens = list_append_szt(res_lens, &res_lens_len, 2);
        }
        i = i + 1LL;
    }
    return keys_lens = res_lens, keys_len = res_len, res;
}

void user_main() {
    HashTable ht = create_table(3LL, 1LL, 0.75);
    ht = insert_data(ht, 17LL);
    ht = insert_data(ht, 18LL);
    ht = insert_data(ht, 99LL);
    printf("%d\n", keys(ht));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
