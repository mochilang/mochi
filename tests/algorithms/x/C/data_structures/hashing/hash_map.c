// Generated by Mochi 0.10.32 on 2025-08-24 21:19 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t make_buckets_len;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Bucket Bucket;
typedef struct HashMap HashMap;

struct Bucket {
    long long state;
    long long key;
    long long val;
};

struct HashMap {
    Bucket *buckets;
    size_t buckets_len;
    long long len;
    long long cap_num;
    long long cap_den;
    long long initial_size;
};

static Bucket* list_append_Bucket(Bucket *arr, size_t *len, Bucket val) {
    arr = realloc(arr, (*len + 1) * sizeof(Bucket));
    arr[*len] = val;
    (*len)++;
    return arr;
}

HashMap hm;

Bucket * make_buckets(long long n);
HashMap hashmap_new(long long initial_size);
long long bucket_index(HashMap hm, long long key);
long long next_index(HashMap hm, long long ind);
long long try_set(HashMap* hm, long long ind, long long key, long long val);
long long is_full(HashMap hm);
long long is_sparse(HashMap hm);
void resize(HashMap* hm, long long new_size);
void size_up(HashMap hm);
void size_down(HashMap hm);
void add_item(HashMap hm, long long key, long long val);
void hashmap_set(HashMap hm, long long key, long long val);
long long hashmap_get(HashMap hm, long long key);
void hashmap_del(HashMap* hm, long long key);
long long hashmap_len(HashMap hm);
const char* hashmap_repr(HashMap hm);
int main(void);

Bucket * make_buckets(long long n) {
    Bucket *buckets = NULL;
    size_t buckets_len = 0;
    long long i = 0LL;
    while (i < n) {
        buckets = list_append_Bucket(buckets, &buckets_len, (Bucket){.state = 0LL, .key = 0LL, .val = 0LL});
        i = i + 1LL;
    }
    return make_buckets_len = buckets_len, buckets;
}

HashMap hashmap_new(long long initial_size) {
    return (HashMap){.buckets = make_buckets(initial_size), .buckets_len = make_buckets_len, .len = 0LL, .cap_num = 3LL, .cap_den = 4LL, .initial_size = initial_size};
}

long long bucket_index(HashMap hm, long long key) {
    long long ind = key % hm.buckets_len;
    if (ind < 0LL) {
        ind = ind + hm.buckets_len;
    }
    return ind;
}

long long next_index(HashMap hm, long long ind) {
    return (ind + 1LL) % hm.buckets_len;
}

long long try_set(HashMap* hm, long long ind, long long key, long long val) {
    Bucket *buckets = hm->buckets;
    size_t buckets_len = hm->buckets_len;
    Bucket b = buckets[(int)({long long _mochi_idx = ind; _mochi_idx < 0 ? buckets_len + _mochi_idx : _mochi_idx;})];
    if ((b.state == 0LL) || (b.state == 2LL)) {
        buckets[(int)(ind)] = (Bucket){.state = 1LL, .key = key, .val = val};
        hm->buckets = buckets;
        hm->buckets_len = buckets_len;
        hm->len = hm->len + 1LL;
        return 1LL;
    }
    if (b.key == key) {
        buckets[(int)(ind)] = (Bucket){.state = 1LL, .key = key, .val = val};
        hm->buckets = buckets;
        hm->buckets_len = buckets_len;
        return 1LL;
    }
    return 0LL;
}

long long is_full(HashMap hm) {
    long long limit = (hm.buckets_len * hm.cap_num) / hm.cap_den;
    return hm.len >= limit;
}

long long is_sparse(HashMap hm) {
    if (hm.buckets_len <= hm.initial_size) {
        return 0LL;
    }
    long long limit = (hm.buckets_len * hm.cap_num) / (2LL * hm.cap_den);
    return hm.len < limit;
}

void resize(HashMap* hm, long long new_size) {
    Bucket *old = hm->buckets;
    size_t old_len = hm->buckets_len;
    hm->buckets = make_buckets(new_size);
    hm->buckets_len = make_buckets_len;
    hm->len = 0LL;
    long long i = 0LL;
    while (i < old_len) {
        Bucket it = old[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? old_len + _mochi_idx : _mochi_idx;})];
        if (it.state == 1LL) {
            add_item(*hm, it.key, it.val);
        }
        i = i + 1LL;
    }
}

void size_up(HashMap hm) {
    resize(&hm, hm.buckets_len * 2LL);
}

void size_down(HashMap hm) {
    resize(&hm, hm.buckets_len / 2LL);
}

void add_item(HashMap hm, long long key, long long val) {
    long long ind = bucket_index(hm, key);
    long long i = 0LL;
    while (i < hm.buckets_len) {
        if (try_set(&hm, ind, key, val)) {
            break;
        }
        ind = next_index(hm, ind);
        i = i + 1LL;
    }
}

void hashmap_set(HashMap hm, long long key, long long val) {
    if (is_full(hm)) {
        size_up(hm);
    }
    add_item(hm, key, val);
}

long long hashmap_get(HashMap hm, long long key) {
    Bucket *buckets = hm.buckets;
    size_t buckets_len = hm.buckets_len;
    long long ind = bucket_index(hm, key);
    long long i = 0LL;
    while (i < buckets_len) {
        Bucket it = buckets[(int)({long long _mochi_idx = ind; _mochi_idx < 0 ? buckets_len + _mochi_idx : _mochi_idx;})];
        if (it.state == 0LL) {
            break;
        }
        if ((it.state == 1LL) && (it.key == key)) {
            return it.val;
        }
        ind = next_index(hm, ind);
        i = i + 1LL;
    }
    return 0LL;
}

void hashmap_del(HashMap* hm, long long key) {
    Bucket *buckets = hm->buckets;
    size_t buckets_len = hm->buckets_len;
    long long ind = bucket_index(*hm, key);
    long long i = 0LL;
    while (i < buckets_len) {
        Bucket it = buckets[(int)({long long _mochi_idx = ind; _mochi_idx < 0 ? buckets_len + _mochi_idx : _mochi_idx;})];
        if (it.state == 0LL) {
            puts(str_concat("KeyError: ", str_int(key)));
            return 0;
        }
        if ((it.state == 1LL) && (it.key == key)) {
            buckets[(int)(ind)] = (Bucket){.state = 2LL, .key = 0LL, .val = 0LL};
            hm->buckets = buckets;
            hm->buckets_len = buckets_len;
            hm->len = hm->len - 1LL;
            break;
        }
        ind = next_index(*hm, ind);
        i = i + 1LL;
    }
    if (is_sparse(*hm)) {
        size_down(*hm);
    }
}

long long hashmap_len(HashMap hm) {
    return hm.len;
}

const char* hashmap_repr(HashMap hm) {
    const char* out = "HashMap(";
    long long first = 1LL;
    long long i = 0LL;
    while (i < hm.buckets_len) {
        Bucket b = hm.buckets[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? hm.buckets_len + _mochi_idx : _mochi_idx;})];
        if (b.state == 1LL) {
            if (!(first)) {
                out = str_concat(out, ", ");
            } else {
                first = 0LL;
            }
            out = str_concat(str_concat(str_concat(out, str_int(b.key)), ": "), str_int(b.val));
        }
        i = i + 1LL;
    }
    out = str_concat(out, ")");
    return out;
}

int main(void) {
    {
        long long __start = _now();
        hm = hashmap_new(5LL);
        hashmap_set(hm, 1LL, 10LL);
        hashmap_set(hm, 2LL, 20LL);
        hashmap_set(hm, 3LL, 30LL);
        puts(hashmap_repr(hm));
        puts(str_int(hashmap_get(hm, 2LL)));
        hashmap_del(&hm, 1LL);
        puts(hashmap_repr(hm));
        puts(str_int(hashmap_len(hm)));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
