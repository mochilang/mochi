// Generated by Mochi 0.10.32 on 2025-08-08 19:48 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Entry Entry;
typedef struct GetResult GetResult;
typedef struct HashMap HashMap;
typedef struct DelResult DelResult;

struct Entry {
    const char* key;
    const char* value;
};

struct GetResult {
    long long found;
    const char* value;
};

struct HashMap {
    Entry *entries;
    size_t entries_len;
};

struct DelResult {
    HashMap map;
    long long ok;
};

static Entry* list_append_Entry(Entry *arr, size_t *len, Entry val) {
    arr = realloc(arr, (*len + 1) * sizeof(Entry));
    arr[*len] = val;
    (*len)++;
    return arr;
}

HashMap make_hash_map();
long long hm_len(HashMap m);
HashMap hm_set(HashMap m, const char* key, const char* value);
GetResult hm_get(HashMap m, const char* key);
DelResult hm_del(HashMap m, const char* key);
long long test_add_items();
long long test_overwrite_items();
long long test_delete_items();
long long test_access_absent_items();
long long test_add_with_resize_up();
long long test_add_with_resize_down();
int main(void);

HashMap make_hash_map() {
    return (HashMap){.entries = NULL, .entries_len = 0};
}

long long hm_len(HashMap m) {
    return m.entries_len;
}

HashMap hm_set(HashMap m, const char* key, const char* value) {
    Entry *entries = m.entries;
    size_t entries_len = m.entries_len;
    long long updated = 0LL;
    Entry *new_entries = NULL;
    size_t new_entries_len = 0;
    long long i = 0LL;
    while (i < entries_len) {
        Entry e = entries[(int)(i)];
        if (strcmp(e.key, key) == 0) {
            new_entries = list_append_Entry(new_entries, &new_entries_len, (Entry){.key = key, .value = value});
            updated = 1LL;
        } else {
            new_entries = list_append_Entry(new_entries, &new_entries_len, e);
        }
        i = i + 1LL;
    }
    if (!(updated)) {
        new_entries = list_append_Entry(new_entries, &new_entries_len, (Entry){.key = key, .value = value});
    }
    return (HashMap){.entries = new_entries, .entries_len = new_entries_len};
}

GetResult hm_get(HashMap m, const char* key) {
    long long i = 0LL;
    while (i < m.entries_len) {
        Entry e = m.entries[(int)(i)];
        if (strcmp(e.key, key) == 0) {
            return (GetResult){.found = 1LL, .value = e.value};
        }
        i = i + 1LL;
    }
    return (GetResult){.found = 0LL, .value = ""};
}

DelResult hm_del(HashMap m, const char* key) {
    Entry *entries = m.entries;
    size_t entries_len = m.entries_len;
    Entry *new_entries = NULL;
    size_t new_entries_len = 0;
    long long removed = 0LL;
    long long i = 0LL;
    while (i < entries_len) {
        Entry e = entries[(int)(i)];
        if (strcmp(e.key, key) == 0) {
            removed = 1LL;
        } else {
            new_entries = list_append_Entry(new_entries, &new_entries_len, e);
        }
        i = i + 1LL;
    }
    if (removed) {
        return (DelResult){.map = (HashMap){.entries = new_entries, .entries_len = new_entries_len}, .ok = 1LL};
    }
    return (DelResult){.map = m, .ok = 0LL};
}

long long test_add_items() {
    HashMap h = make_hash_map();
    h = hm_set(h, "key_a", "val_a");
    h = hm_set(h, "key_b", "val_b");
    GetResult a = hm_get(h, "key_a");
    GetResult b = hm_get(h, "key_b");
    return ((((hm_len(h) == 2LL) && a.found) && b.found) && (strcmp(a.value, "val_a") == 0)) && (strcmp(b.value, "val_b") == 0);
}

long long test_overwrite_items() {
    HashMap h = make_hash_map();
    h = hm_set(h, "key_a", "val_a");
    h = hm_set(h, "key_a", "val_b");
    GetResult a = hm_get(h, "key_a");
    return ((hm_len(h) == 1LL) && a.found) && (strcmp(a.value, "val_b") == 0);
}

long long test_delete_items() {
    HashMap h = make_hash_map();
    h = hm_set(h, "key_a", "val_a");
    h = hm_set(h, "key_b", "val_b");
    DelResult d1 = hm_del(h, "key_a");
    h = d1.map;
    DelResult d2 = hm_del(h, "key_b");
    h = d2.map;
    h = hm_set(h, "key_a", "val_a");
    DelResult d3 = hm_del(h, "key_a");
    h = d3.map;
    return hm_len(h) == 0LL;
}

long long test_access_absent_items() {
    HashMap h = make_hash_map();
    GetResult g1 = hm_get(h, "key_a");
    DelResult d1 = hm_del(h, "key_a");
    h = d1.map;
    h = hm_set(h, "key_a", "val_a");
    DelResult d2 = hm_del(h, "key_a");
    h = d2.map;
    DelResult d3 = hm_del(h, "key_a");
    h = d3.map;
    GetResult g2 = hm_get(h, "key_a");
    return (((((g1.found == 0LL) && (d1.ok == 0LL)) && d2.ok) && (d3.ok == 0LL)) && (g2.found == 0LL)) && (hm_len(h) == 0LL);
}

long long test_add_with_resize_up() {
    HashMap h = make_hash_map();
    long long i = 0LL;
    while (i < 5LL) {
        const char* s = str_int(i);
        h = hm_set(h, s, s);
        i = i + 1LL;
    }
    return hm_len(h) == 5LL;
}

long long test_add_with_resize_down() {
    HashMap h = make_hash_map();
    long long i = 0LL;
    while (i < 5LL) {
        const char* s = str_int(i);
        h = hm_set(h, s, s);
        i = i + 1LL;
    }
    long long j = 0LL;
    while (j < 5LL) {
        const char* s = str_int(j);
        DelResult d = hm_del(h, s);
        h = d.map;
        j = j + 1LL;
    }
    h = hm_set(h, "key_a", "val_b");
    GetResult a = hm_get(h, "key_a");
    return ((hm_len(h) == 1LL) && a.found) && (strcmp(a.value, "val_b") == 0);
}

int main(void) {
    {
        long long __start = _now();
        printf("%d\n", test_add_items());
        printf("%d\n", test_overwrite_items());
        printf("%d\n", test_delete_items());
        printf("%d\n", test_access_absent_items());
        printf("%d\n", test_add_with_resize_up());
        printf("%d\n", test_add_with_resize_down());
        printf("%d\n", 1LL);
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
