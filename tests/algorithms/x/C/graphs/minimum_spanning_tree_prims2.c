// Generated by Mochi 0.10.32 on 2025-08-16 10:42 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { const char **keys; const char **vals; size_t len; size_t cap; } MapSS;

typedef struct { const char **keys; int *vals; size_t len; size_t cap; } MapSI;

typedef struct { const char **keys; MapSI *vals; size_t len; size_t cap; } MapSMI;

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static void map_set_si(MapSI *m, const char *key, int val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc(m->vals, m->cap * sizeof(int));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static void map_set_smi(MapSMI *m, const char *key, MapSI val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc(m->vals, m->cap * sizeof(MapSI));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static MapSI map_get_smi(const char *keys[], const MapSI vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return (MapSI){0};
}

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static void map_set_ss(MapSS *m, const char *key, const char *val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc((void*)m->vals, m->cap * sizeof(char*));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct MSTResult MSTResult;
typedef struct QueueNode QueueNode;

struct MSTResult {
    MapSI dist;
    MapSS parent;
};

struct QueueNode {
    const char* node;
    long long weight;
};

static QueueNode* list_append_QueueNode(QueueNode *arr, size_t *len, QueueNode val) {
    arr = realloc(arr, (*len + 1) * sizeof(QueueNode));
    arr[*len] = val;
    (*len)++;
    return arr;
}

MapSMI graph = { NULL, NULL, 0, 0 };
MSTResult res;
MapSI dist = (MapSI){0};

MSTResult prims_algo(MapSMI graph);
long long iabs(long long x);
int main(void);

MSTResult prims_algo(MapSMI graph) {
    long long INF = 2147483647LL;
    static const char* dist_keys[16] = {};
    static int dist_vals[16] = {};
    size_t dist_len = 0;
    MapSI dist = { dist_keys, dist_vals, 0, 16 };
    MapSS parent = { NULL, NULL, 0, 0 };
    QueueNode *queue = NULL;
    size_t queue_len = 0;
    for (size_t __i = 0; __i < graph.len; __i++) {
        const char* node = graph.keys[__i];
        map_set_si(&dist, node, INF);
        map_set_ss(&parent, node, "");
        queue = list_append_QueueNode(queue, &queue_len, (QueueNode){.node = node, .weight = INF});
    }
    if (queue_len == 0LL) {
        return (MSTResult){.dist = dist, .parent = parent};
    }
    long long min_idx = 0LL;
    long long i = 1LL;
    while (i < queue_len) {
        if (queue[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})].weight < queue[(int)({long long _mochi_idx = min_idx; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})].weight) {
            min_idx = i;
        }
        i = i + 1LL;
    }
    QueueNode start_node = queue[(int)({long long _mochi_idx = min_idx; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
    const char* start = start_node.node;
    QueueNode *new_q = NULL;
    size_t new_q_len = 0;
    long long j = 0LL;
    while (j < queue_len) {
        if (j != min_idx) {
            new_q = list_append_QueueNode(new_q, &new_q_len, queue[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})]);
        }
        j = j + 1LL;
    }
    queue = new_q;
    queue_len = new_q_len;
    map_set_si(&dist, start, 0LL);
    MapSI __tmp0 = map_get_smi(graph.keys, graph.vals, graph.len, start);
    for (size_t __i = 0; __i < __tmp0.len; __i++) {
        const char* neighbour = __tmp0.keys[__i];
        long long w = map_get_si(map_get_smi(graph.keys, graph.vals, graph.len, start).keys, map_get_smi(graph.keys, graph.vals, graph.len, start).vals, map_get_smi(graph.keys, graph.vals, graph.len, start).len, neighbour);
        if (map_get_si(dist.keys, dist.vals, dist.len, neighbour) > (map_get_si(dist.keys, dist.vals, dist.len, start) + w)) {
            map_set_si(&dist, neighbour, map_get_si(dist.keys, dist.vals, dist.len, start) + w);
            map_set_ss(&parent, neighbour, start);
            long long k = 0LL;
            while (k < queue_len) {
                if (queue[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})].node == neighbour) {
                    queue[(int)(k)].weight = map_get_si(dist.keys, dist.vals, dist.len, neighbour);
                    break;
                }
                k = k + 1LL;
            }
        }
    }
    while (queue_len > 0LL) {
        long long best_idx = 0LL;
        long long p = 1LL;
        while (p < queue_len) {
            if (queue[(int)({long long _mochi_idx = p; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})].weight < queue[(int)({long long _mochi_idx = best_idx; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})].weight) {
                best_idx = p;
            }
            p = p + 1LL;
        }
        QueueNode node_entry = queue[(int)({long long _mochi_idx = best_idx; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
        const char* node = node_entry.node;
        QueueNode *tmp = NULL;
        size_t tmp_len = 0;
        long long q = 0LL;
        while (q < queue_len) {
            if (q != best_idx) {
                tmp = list_append_QueueNode(tmp, &tmp_len, queue[(int)({long long _mochi_idx = q; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})]);
            }
            q = q + 1LL;
        }
        queue = tmp;
        queue_len = tmp_len;
        MapSI __tmp1 = map_get_smi(graph.keys, graph.vals, graph.len, node);
        for (size_t __i = 0; __i < __tmp1.len; __i++) {
            const char* neighbour = __tmp1.keys[__i];
            long long w = map_get_si(map_get_smi(graph.keys, graph.vals, graph.len, node).keys, map_get_smi(graph.keys, graph.vals, graph.len, node).vals, map_get_smi(graph.keys, graph.vals, graph.len, node).len, neighbour);
            if (map_get_si(dist.keys, dist.vals, dist.len, neighbour) > (map_get_si(dist.keys, dist.vals, dist.len, node) + w)) {
                map_set_si(&dist, neighbour, map_get_si(dist.keys, dist.vals, dist.len, node) + w);
                map_set_ss(&parent, neighbour, node);
                long long r = 0LL;
                while (r < queue_len) {
                    if (queue[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})].node == neighbour) {
                        queue[(int)(r)].weight = map_get_si(dist.keys, dist.vals, dist.len, neighbour);
                        break;
                    }
                    r = r + 1LL;
                }
            }
        }
    }
    return (MSTResult){.dist = dist, .parent = parent};
}

long long iabs(long long x) {
    if (x < 0LL) {
        return -(x);
    }
    return x;
}

int main(void) {
    {
        long long __start = _now();
        map_set_smi(&graph, "a", ({const char** __map2_keys = malloc(2 * sizeof(char*)); int *__map2_vals = malloc(2 * sizeof(int)); __map2_keys[0] = "b"; __map2_vals[0] = 3LL; __map2_keys[1] = "c"; __map2_vals[1] = 15LL; MapSI __map2 = { __map2_keys, __map2_vals, 2, 18 }; __map2;}));
        map_set_smi(&graph, "b", ({const char** __map3_keys = malloc(3 * sizeof(char*)); int *__map3_vals = malloc(3 * sizeof(int)); __map3_keys[0] = "a"; __map3_vals[0] = 3LL; __map3_keys[1] = "c"; __map3_vals[1] = 10LL; __map3_keys[2] = "d"; __map3_vals[2] = 100LL; MapSI __map3 = { __map3_keys, __map3_vals, 3, 19 }; __map3;}));
        map_set_smi(&graph, "c", ({const char** __map4_keys = malloc(3 * sizeof(char*)); int *__map4_vals = malloc(3 * sizeof(int)); __map4_keys[0] = "a"; __map4_vals[0] = 15LL; __map4_keys[1] = "b"; __map4_vals[1] = 10LL; __map4_keys[2] = "d"; __map4_vals[2] = 5LL; MapSI __map4 = { __map4_keys, __map4_vals, 3, 19 }; __map4;}));
        map_set_smi(&graph, "d", ({const char** __map5_keys = malloc(2 * sizeof(char*)); int *__map5_vals = malloc(2 * sizeof(int)); __map5_keys[0] = "b"; __map5_vals[0] = 100LL; __map5_keys[1] = "c"; __map5_vals[1] = 5LL; MapSI __map5 = { __map5_keys, __map5_vals, 2, 18 }; __map5;}));
        res = prims_algo(graph);
        dist = res.dist;
        puts(str_int(iabs(map_get_si(dist.keys, dist.vals, dist.len, "a") - map_get_si(dist.keys, dist.vals, dist.len, "b"))));
        puts(str_int(iabs(map_get_si(dist.keys, dist.vals, dist.len, "d") - map_get_si(dist.keys, dist.vals, dist.len, "b"))));
        puts(str_int(iabs(map_get_si(dist.keys, dist.vals, dist.len, "a") - map_get_si(dist.keys, dist.vals, dist.len, "c"))));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
