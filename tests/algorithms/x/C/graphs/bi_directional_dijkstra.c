// Generated by Mochi 0.10.32 on 2025-08-14 09:53 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t remove_at_len;

static int contains_str(const char *arr[], size_t len, const char *val) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(arr[i], val) == 0) return 1;
    }
    return 0;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { const char **keys; void **vals; size_t *lens; size_t len; size_t cap; } MapSL;

typedef struct { const char **keys; const char **vals; size_t len; size_t cap; } MapSS;

typedef struct { const char **keys; int *vals; size_t len; size_t cap; } MapSI;

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static void map_set_si(MapSI *m, const char *key, int val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc(m->vals, m->cap * sizeof(int));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static void map_set_ss(MapSS *m, const char *key, const char *val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc((void*)m->vals, m->cap * sizeof(char*));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static void* map_get_sl(const char *keys[], void *vals[], const size_t lens[], size_t len, const char *key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Edge Edge;
typedef struct PassResult PassResult;
typedef struct QItem QItem;

struct Edge {
    const char* to;
    long long cost;
};

struct PassResult {
    QItem *queue;
    size_t queue_len;
    long long dist;
};

struct QItem {
    const char* node;
    long long cost;
};

static QItem* list_append_QItem(QItem *arr, size_t *len, QItem val) {
    arr = realloc(arr, (*len + 1) * sizeof(QItem));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long get_min_index(QItem * q, size_t q_len);
QItem * remove_at(QItem * q, size_t q_len, long long idx);
PassResult pass_and_relaxation(int graph, const char* v, MapSI visited_forward, MapSI visited_backward, MapSI cst_fwd, MapSI cst_bwd, QItem * queue, size_t queue_len, MapSS parent, long long shortest_distance);
long long bidirectional_dij(const char* source, const char* destination, int graph_forward, int graph_backward);
int main(void);

long long get_min_index(QItem * q, size_t q_len) {
    long long idx = 0LL;
    long long i = 1LL;
    while (i < q_len) {
        if (q[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? q_len + _mochi_idx : _mochi_idx;})].cost < q[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? q_len + _mochi_idx : _mochi_idx;})].cost) {
            idx = i;
        }
        i = i + 1LL;
    }
    return idx;
}

QItem * remove_at(QItem * q, size_t q_len, long long idx) {
    QItem *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < q_len) {
        if (i != idx) {
            res = list_append_QItem(res, &res_len, q[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? q_len + _mochi_idx : _mochi_idx;})]);
        }
        i = i + 1LL;
    }
    return remove_at_len = res_len, res;
}

PassResult pass_and_relaxation(int graph, const char* v, MapSI visited_forward, MapSI visited_backward, MapSI cst_fwd, MapSI cst_bwd, QItem * queue, size_t queue_len, MapSS parent, long long shortest_distance) {
    QItem *q = NULL;
    size_t q_len = 0;
    long long sd = shortest_distance;
    {
        Edge* __tmp0 = map_get_sl(graph.keys, graph.vals, graph.lens, graph.len, v, NULL);
        size_t __tmp0_len = graph_lens[v];
        for (size_t __i = 0; __i < __tmp0_len; __i++) {
            Edge e = __tmp0[__i];
            const char* nxt = e.to;
            long long d = e.cost;
            if (contains_str(visited_forward.keys, visited_forward.len, nxt)) {
                continue;
            }
            long long old_cost = (contains_str(cst_fwd.keys, cst_fwd.len, nxt) ? map_get_si(cst_fwd.keys, cst_fwd.vals, cst_fwd.len, nxt) : 2147483647LL);
            long long new_cost = map_get_si(cst_fwd.keys, cst_fwd.vals, cst_fwd.len, v) + d;
            if (new_cost < old_cost) {
                q = list_append_QItem(q, &q_len, (QItem){.node = nxt, .cost = new_cost});
                cst_fwd[(int)(nxt)] = new_cost;
                map_set_ss(&parent, nxt, v);
            }
            if (contains_str(visited_backward.keys, visited_backward.len, nxt)) {
                long long alt = (map_get_si(cst_fwd.keys, cst_fwd.vals, cst_fwd.len, v) + d) + map_get_si(cst_bwd.keys, cst_bwd.vals, cst_bwd.len, nxt);
                if (alt < sd) {
                    sd = alt;
                }
            }
        }
    }
    return (PassResult){.queue = q, .queue_len = q_len, .dist = sd};
}

long long bidirectional_dij(const char* source, const char* destination, int graph_forward, int graph_backward) {
    double shortest_path_distance = -1.0;
    static const char* visited_forward_keys[16] = {};
    static int visited_forward_vals[16] = {};
    size_t visited_forward_len = 0;
    MapSI visited_forward = { visited_forward_keys, visited_forward_vals, 0, 16 };
    static const char* visited_backward_keys[16] = {};
    static int visited_backward_vals[16] = {};
    size_t visited_backward_len = 0;
    MapSI visited_backward = { visited_backward_keys, visited_backward_vals, 0, 16 };
    static const char* cst_fwd_keys[16] = {};
    static int cst_fwd_vals[16] = {};
    size_t cst_fwd_len = 0;
    MapSI cst_fwd = { cst_fwd_keys, cst_fwd_vals, 0, 16 };
    map_set_si(&cst_fwd, source, 0LL);
    static const char* cst_bwd_keys[16] = {};
    static int cst_bwd_vals[16] = {};
    size_t cst_bwd_len = 0;
    MapSI cst_bwd = { cst_bwd_keys, cst_bwd_vals, 0, 16 };
    map_set_si(&cst_bwd, destination, 0LL);
    MapSS parent_forward = { NULL, NULL, 0, 0 };
    map_set_ss(&parent_forward, source, "");
    MapSS parent_backward = { NULL, NULL, 0, 0 };
    map_set_ss(&parent_backward, destination, "");
    QItem *queue_forward = NULL;
    size_t queue_forward_len = 0;
    queue_forward = list_append_QItem(queue_forward, &queue_forward_len, (QItem){.node = source, .cost = 0LL});
    QItem *queue_backward = NULL;
    size_t queue_backward_len = 0;
    queue_backward = list_append_QItem(queue_backward, &queue_backward_len, (QItem){.node = destination, .cost = 0LL});
    long long shortest_distance = 2147483647LL;
    if (strcmp(source, destination) == 0) {
        return 0LL;
    }
    while ((queue_forward_len > 0LL) && (queue_backward_len > 0LL)) {
        long long idx_f = get_min_index(queue_forward, queue_forward_len);
        QItem item_f = queue_forward[(int)({long long _mochi_idx = idx_f; _mochi_idx < 0 ? queue_forward_len + _mochi_idx : _mochi_idx;})];
        queue_forward = remove_at(queue_forward, queue_forward_len, idx_f);
        queue_forward_len = remove_at_len;
        const char* v_fwd = item_f.node;
        map_set_si(&visited_forward, v_fwd, 1LL);
        long long idx_b = get_min_index(queue_backward, queue_backward_len);
        QItem item_b = queue_backward[(int)({long long _mochi_idx = idx_b; _mochi_idx < 0 ? queue_backward_len + _mochi_idx : _mochi_idx;})];
        queue_backward = remove_at(queue_backward, queue_backward_len, idx_b);
        queue_backward_len = remove_at_len;
        const char* v_bwd = item_b.node;
        map_set_si(&visited_backward, v_bwd, 1LL);
        PassResult res_f = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, queue_forward_len, parent_forward, shortest_distance);
        queue_forward = res_f.queue;
        shortest_distance = res_f.dist;
        PassResult res_b = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, queue_backward_len, parent_backward, shortest_distance);
        queue_backward = res_b.queue;
        shortest_distance = res_b.dist;
        if ((map_get_si(cst_fwd.keys, cst_fwd.vals, cst_fwd.len, v_fwd) + map_get_si(cst_bwd.keys, cst_bwd.vals, cst_bwd.len, v_bwd)) >= shortest_distance) {
            break;
        }
    }
    if (shortest_distance != 2147483647LL) {
        shortest_path_distance = shortest_distance;
    }
    return shortest_path_distance;
}

int main(void) {
    {
        long long __start = _now();
        static const char* graph_fwd_keys[22] = {"B", "C", "D", "E", "F", "G"};
        Edge graph_fwd_vals_0[1] = {(Edge){.to = "C", .cost = 1LL}};
        Edge graph_fwd_vals_1[1] = {(Edge){.to = "D", .cost = 1LL}};
        Edge graph_fwd_vals_2[1] = {(Edge){.to = "F", .cost = 1LL}};
        Edge graph_fwd_vals_3[2] = {(Edge){.to = "B", .cost = 1LL}, (Edge){.to = "G", .cost = 2LL}};
        Edge graph_fwd_vals_4[0] = {};
        Edge graph_fwd_vals_5[1] = {(Edge){.to = "F", .cost = 1LL}};
        static void* graph_fwd_vals[22] = {graph_fwd_vals_0, graph_fwd_vals_1, graph_fwd_vals_2, graph_fwd_vals_3, graph_fwd_vals_4, graph_fwd_vals_5};
        static size_t graph_fwd_lens[22] = {1, 1, 1, 2, 0, 1};
        size_t graph_fwd_len = 6;
        MapSL graph_fwd = { graph_fwd_keys, graph_fwd_vals, graph_fwd_lens, 6, 22 };
        static const char* graph_bwd_keys[22] = {"B", "C", "D", "F", "E", "G"};
        Edge graph_bwd_vals_0[1] = {(Edge){.to = "E", .cost = 1LL}};
        Edge graph_bwd_vals_1[1] = {(Edge){.to = "B", .cost = 1LL}};
        Edge graph_bwd_vals_2[1] = {(Edge){.to = "C", .cost = 1LL}};
        Edge graph_bwd_vals_3[2] = {(Edge){.to = "D", .cost = 1LL}, (Edge){.to = "G", .cost = 1LL}};
        Edge graph_bwd_vals_4[0] = {};
        Edge graph_bwd_vals_5[1] = {(Edge){.to = "E", .cost = 2LL}};
        static void* graph_bwd_vals[22] = {graph_bwd_vals_0, graph_bwd_vals_1, graph_bwd_vals_2, graph_bwd_vals_3, graph_bwd_vals_4, graph_bwd_vals_5};
        static size_t graph_bwd_lens[22] = {1, 1, 1, 2, 0, 1};
        size_t graph_bwd_len = 6;
        MapSL graph_bwd = { graph_bwd_keys, graph_bwd_vals, graph_bwd_lens, 6, 22 };
        puts(str_int(bidirectional_dij("E", "F", graph_fwd, graph_bwd)));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
