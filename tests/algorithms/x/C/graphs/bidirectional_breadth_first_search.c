// Generated by Mochi 0.10.32 on 2025-08-14 09:53 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t parse_key_len;
size_t neighbors_len;
size_t reverse_list_len;
size_t bfs_len;
size_t bidirectional_bfs_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { const char **keys; void **vals; size_t *lens; size_t len; size_t cap; } MapSL;

static void* map_get_sl(const char *keys[], void *vals[], const size_t lens[], size_t len, const char *key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Anon1 Anon1;
typedef struct Anon2 Anon2;
typedef struct Node Node;

struct Anon1 {
    const char* *start;
    size_t start_len;
};

struct Anon2 {
    const char* *goal;
    size_t goal_len;
};

struct Node {
    const char* pos;
    const char* *path;
    size_t path_len;
};

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char* list_append_c_char_new(const const char *arr, size_t len, const char val) {
    const char *res = malloc((len + 1) * sizeof(const char));
    if (arr && len) memcpy(res, arr, len * sizeof(const char));
    res[len] = val;
    return res;
}

long long **grid = NULL;
size_t grid_len = 0;
size_t *grid_lens = NULL;
size_t grid_lens_len = 0;
long long **delta = NULL;
size_t delta_len = 0;
size_t *delta_lens = NULL;
size_t delta_lens_len = 0;
const char* start = "";
const char* goal = "";
const char* *path1 = NULL;
size_t path1_len = 0;
const char* *path2 = NULL;
size_t path2_len = 0;

const char* key(long long y, long long x);
long long parse_int(const char* s);
long long * parse_key(const char* k);
const char* * neighbors(const char* pos);
const char* * reverse_list(const char* * lst, size_t lst_len);
const char* * bfs(const char* start, const char* goal);
const char* * bidirectional_bfs(const char* start, const char* goal);
const char* path_to_string(const char* * path, size_t path_len);
int main(void);

const char* key(long long y, long long x) {
    return str_concat(str_concat(str_int(y), ","), str_int(x));
}

long long parse_int(const char* s) {
    long long value = 0LL;
    long long i = 0LL;
    while (i < strlen(s)) {
        const char* c = (const char[]){s[i], 0};
        value = (value * 10LL) + (int)(c);
        i = i + 1LL;
    }
    return value;
}

long long * parse_key(const char* k) {
    long long idx = 0LL;
    while ((idx < strlen(k)) && (strcmp(_substring(k, idx, idx + 1LL), ",") != 0)) {
        idx = idx + 1LL;
    }
    long long y = parse_int(_substring(k, 0LL, idx));
    long long x = parse_int(_substring(k, idx + 1LL, strlen(k)));
    {
        long long* __tmp0_data = malloc(2 * sizeof(long long));
        __tmp0_data[0] = y;
        __tmp0_data[1] = x;
        parse_key_len = 2;
        return __tmp0_data;
    }
}

const char* * neighbors(const char* pos) {
    long long *coords = parse_key(pos);
    size_t coords_len = parse_key_len;
    long long y = coords[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? coords_len + _mochi_idx : _mochi_idx;})];
    long long x = coords[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? coords_len + _mochi_idx : _mochi_idx;})];
    const char* *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < delta_len) {
        long long ny = y + delta[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? delta_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? delta_lens[i] + _mochi_idx : _mochi_idx;})];
        long long nx = x + delta[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? delta_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? delta_lens[i] + _mochi_idx : _mochi_idx;})];
        if ((((ny >= 0LL) && (ny < grid_len)) && (nx >= 0LL)) && (nx < grid_lens[0LL])) {
            if (grid[(int)({long long _mochi_idx = ny; _mochi_idx < 0 ? grid_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = nx; _mochi_idx < 0 ? grid_lens[ny] + _mochi_idx : _mochi_idx;})] == 0LL) {
                res = list_append_str(res, &res_len, key(ny, nx));
            }
        }
        i = i + 1LL;
    }
    return neighbors_len = res_len, res;
}

const char* * reverse_list(const char* * lst, size_t lst_len) {
    const char* *res = NULL;
    size_t res_len = 0;
    long long i = lst_len - 1LL;
    while (i >= 0LL) {
        res = list_append_str(res, &res_len, lst[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? lst_len + _mochi_idx : _mochi_idx;})]);
        i = i - 1LL;
    }
    return reverse_list_len = res_len, res;
}

const char* * bfs(const char* start, const char* goal) {
    Node *queue = NULL;
    size_t queue_len = 0;
    queue = list_append_Node(queue, &queue_len, (Node){.pos = start, .path = ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = start; tmp;}), .path_len = 1});
    long long head = 0LL;
    MapSI visited = (Anon1){.start = 1LL, .start_len = 0};
    size_t visited_len = 0;
    while (head < queue_len) {
        Node node = queue[(int)({long long _mochi_idx = head; _mochi_idx < 0 ? queue_len + _mochi_idx : _mochi_idx;})];
        head = head + 1LL;
        if (strcmp(node.pos, goal) == 0) {
            return bfs_len = node.path_len, node.path;
        }
        const char* *neigh = neighbors(node.pos);
        size_t neigh_len = neighbors_len;
        long long i = 0LL;
        while (i < neigh_len) {
            const char* npos = neigh[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? neigh_len + _mochi_idx : _mochi_idx;})];
            if (!(npos in visited)) {
                visited[(int)(npos)] = 1LL;
                const char* *new_path = list_append_c_char_new(node.path, node.path_len, npos);
                size_t new_path_len = append_len;
                queue = list_append_Node(queue, &queue_len, (Node){.pos = npos, .path = new_path, .path_len = new_path_len});
            }
            i = i + 1LL;
        }
    }
    {
        const char** __tmp1_data = malloc(0 * sizeof(const char*));
        bfs_len = 0;
        return __tmp1_data;
    }
}

const char* * bidirectional_bfs(const char* start, const char* goal) {
    Node *queue_f = NULL;
    size_t queue_f_len = 0;
    Node *queue_b = NULL;
    size_t queue_b_len = 0;
    queue_f = list_append_Node(queue_f, &queue_f_len, (Node){.pos = start, .path = ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = start; tmp;}), .path_len = 1});
    queue_b = list_append_Node(queue_b, &queue_b_len, (Node){.pos = goal, .path = ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = goal; tmp;}), .path_len = 1});
    long long head_f = 0LL;
    long long head_b = 0LL;
    MapSL visited_f = (Anon1){.start = ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = start; tmp;}), .start_len = 1};
    size_t visited_f_len = 0;
    MapSL visited_b = (Anon2){.goal = ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = goal; tmp;}), .goal_len = 1};
    size_t visited_b_len = 0;
    while ((head_f < queue_f_len) && (head_b < queue_b_len)) {
        Node node_f = queue_f[(int)({long long _mochi_idx = head_f; _mochi_idx < 0 ? queue_f_len + _mochi_idx : _mochi_idx;})];
        head_f = head_f + 1LL;
        const char* *neigh_f = neighbors(node_f.pos);
        size_t neigh_f_len = neighbors_len;
        long long i = 0LL;
        while (i < neigh_f_len) {
            const char* npos = neigh_f[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? neigh_f_len + _mochi_idx : _mochi_idx;})];
            if (!(npos in visited_f)) {
                const char* *new_path = list_append_c_char_new(node_f.path, node_f.path_len, npos);
                size_t new_path_len = append_len;
                visited_f[(int)(npos)] = new_path;
                if (npos in visited_b) {
                    const char* *rev = reverse_list(map_get_sl(visited_b.keys, visited_b.vals, visited_b.lens, visited_b.len, npos, NULL), visited_b_lens[npos]);
                    size_t rev_len = reverse_list_len;
                    long long j = 1LL;
                    while (j < rev_len) {
                        new_path = list_append_str(new_path, &new_path_len, rev[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? rev_len + _mochi_idx : _mochi_idx;})]);
                        j = j + 1LL;
                    }
                    return bidirectional_bfs_len = new_path_len, new_path;
                }
                queue_f = list_append_Node(queue_f, &queue_f_len, (Node){.pos = npos, .path = new_path, .path_len = new_path_len});
            }
            i = i + 1LL;
        }
        Node node_b = queue_b[(int)({long long _mochi_idx = head_b; _mochi_idx < 0 ? queue_b_len + _mochi_idx : _mochi_idx;})];
        head_b = head_b + 1LL;
        const char* *neigh_b = neighbors(node_b.pos);
        size_t neigh_b_len = neighbors_len;
        long long j = 0LL;
        while (j < neigh_b_len) {
            const char* nposb = neigh_b[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? neigh_b_len + _mochi_idx : _mochi_idx;})];
            if (!(nposb in visited_b)) {
                const char* *new_path_b = list_append_c_char_new(node_b.path, node_b.path_len, nposb);
                size_t new_path_b_len = append_len;
                visited_b[(int)(nposb)] = new_path_b;
                if (nposb in visited_f) {
                    long long path_f = map_get_sl(visited_f.keys, visited_f.vals, visited_f.lens, visited_f.len, nposb, NULL);
                    new_path_b = reverse_list(new_path_b, new_path_b_len);
                    new_path_b_len = reverse_list_len;
                    long long t = 1LL;
                    while (t < new_path_b_len) {
                        path_f = list_append_long_long(path_f, &path_f_len, new_path_b[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? new_path_b_len + _mochi_idx : _mochi_idx;})]);
                        t = t + 1LL;
                    }
                    return bidirectional_bfs_len = path_f_len, path_f;
                }
                queue_b = list_append_Node(queue_b, &queue_b_len, (Node){.pos = nposb, .path = new_path_b, .path_len = new_path_b_len});
            }
            j = j + 1LL;
        }
    }
    {
        const char** __tmp2_data = malloc(1 * sizeof(const char*));
        __tmp2_data[0] = start;
        bidirectional_bfs_len = 1;
        return __tmp2_data;
    }
}

const char* path_to_string(const char* * path, size_t path_len) {
    if (path_len == 0LL) {
        return "[]";
    }
    long long *first = parse_key(path[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})]);
    size_t first_len = parse_key_len;
    const char* s = str_concat(str_concat(str_concat(str_concat("[(", str_int(first[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? first_len + _mochi_idx : _mochi_idx;})])), ", "), str_int(first[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? first_len + _mochi_idx : _mochi_idx;})])), ")");
    long long i = 1LL;
    while (i < path_len) {
        long long *c = parse_key(path[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})]);
        size_t c_len = parse_key_len;
        s = str_concat(str_concat(str_concat(str_concat(str_concat(s, ", ("), str_int(c[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? c_len + _mochi_idx : _mochi_idx;})])), ", "), str_int(c[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? c_len + _mochi_idx : _mochi_idx;})])), ")");
        i = i + 1LL;
    }
    s = str_concat(s, "]");
    return s;
}

int main(void) {
    {
        long long __start = _now();
        grid = ({long long** tmp = malloc(7 * sizeof(long long*)); tmp[0] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[1] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 1LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[2] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[3] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 1LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[4] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 0LL; tmp[2] = 1LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[5] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[6] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 1LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp;});
        grid_len = 7;
        grid_lens = ({size_t *tmp = malloc(7 * sizeof(size_t)); tmp[0] = 7; tmp[1] = 7; tmp[2] = 7; tmp[3] = 7; tmp[4] = 7; tmp[5] = 7; tmp[6] = 7; tmp;});
        grid_lens_len = 7;
        delta = ({int** tmp = malloc(4 * sizeof(int*)); tmp[0] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = -1.0; tmp[1] = 0LL; tmp;}); tmp[1] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = -1.0; tmp;}); tmp[2] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 0LL; tmp;}); tmp[3] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 1LL; tmp;}); tmp;});
        delta_len = 4;
        delta_lens = ({size_t *tmp = malloc(4 * sizeof(size_t)); tmp[0] = 2; tmp[1] = 2; tmp[2] = 2; tmp[3] = 2; tmp;});
        delta_lens_len = 4;
        start = key(0LL, 0LL);
        goal = key(grid_len - 1LL, grid_lens[0LL] - 1LL);
        path1 = bfs(start, goal);
        path1_len = bfs_len;
        puts(path_to_string(path1, path1_len));
        path2 = bidirectional_bfs(start, goal);
        path2_len = bidirectional_bfs_len;
        puts(path_to_string(path2, path2_len));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
