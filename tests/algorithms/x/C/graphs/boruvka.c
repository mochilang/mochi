// Generated by Mochi 0.10.32 on 2025-08-14 09:53 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t create_empty_edges_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { int *keys; int *vals; size_t len; size_t cap; } MapII;

static int map_get_ii(const int keys[], const int vals[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) return vals[i];
    }
    return 0;
}

static void map_set_ii(int keys[], int vals[], size_t *len, int key, int val) {
    for (size_t i = 0; i < *len; i++) {
        if (keys[i] == key) { vals[i] = val; return; }
    }
    keys[*len] = key; vals[*len] = val; (*len)++;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Edge Edge;
typedef struct Graph Graph;
typedef struct UnionResult UnionResult;

struct Edge {
    long long u;
    long long v;
    long long w;
};

struct Graph {
    long long num_nodes;
    Edge *edges;
    size_t edges_len;
    MapII component;
};

struct UnionResult {
    Graph graph;
    long long *component_size;
    size_t component_size_len;
};

static Edge* list_append_Edge(Edge *arr, size_t *len, Edge val) {
    arr = realloc(arr, (*len + 1) * sizeof(Edge));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Graph new_graph(long long num_nodes);
Graph add_edge(Graph g, long long u, long long v, long long w);
long long find_component(Graph g, long long node);
Graph set_component(Graph g, long long node);
UnionResult user_union(Graph g, long long * component_size, size_t component_size_len, long long u, long long v);
Edge * create_empty_edges(long long n);
long long boruvka(Graph g);
void user_main();
int main(void);

Graph new_graph(long long num_nodes) {
    return (Graph){.num_nodes = num_nodes, .edges = NULL, .edges_len = 0, .component = {  }};
}

Graph add_edge(Graph g, long long u, long long v, long long w) {
    Edge *es = g.edges;
    size_t es_len = g.edges_len;
    es = list_append_Edge(es, &es_len, (Edge){.u = u, .v = v, .w = w});
    return (Graph){.num_nodes = g.num_nodes, .edges = es, .edges_len = es_len, .component = g.component};
}

long long find_component(Graph g, long long node) {
    if (g.component[(int)({long long _mochi_idx = node; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})] == node) {
        return node;
    }
    return find_component(g, g.component[(int)({long long _mochi_idx = node; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})]);
}

Graph set_component(Graph g, long long node) {
    if (g.component[(int)({long long _mochi_idx = node; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})] != node) {
        MapII comp = g.component;
        size_t comp_len = g.component.len;
        long long k = 0LL;
        while (k < g.num_nodes) {
            map_set_ii(comp_keys, comp_vals, &comp_len, k, find_component(g, k));
            k = k + 1LL;
        }
        g = (Graph){.num_nodes = g.num_nodes, .edges = g.edges, .edges_len = g.edges_len, .component = comp};
    }
    return g;
}

UnionResult user_union(Graph g, long long * component_size, size_t component_size_len, long long u, long long v) {
    long long *comp_size = component_size;
    size_t comp_size_len = component_size_len;
    MapII comp = g.component;
    size_t comp_len = g.component.len;
    if (comp_size[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? comp_size_len + _mochi_idx : _mochi_idx;})] <= comp_size[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? comp_size_len + _mochi_idx : _mochi_idx;})]) {
        map_set_ii(comp_keys, comp_vals, &comp_len, u, v);
        comp_size[(int)(v)] = comp_size[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? comp_size_len + _mochi_idx : _mochi_idx;})] + comp_size[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? comp_size_len + _mochi_idx : _mochi_idx;})];
        g = (Graph){.num_nodes = g.num_nodes, .edges = g.edges, .edges_len = g.edges_len, .component = comp};
        g = set_component(g, u);
    } else {
        map_set_ii(comp_keys, comp_vals, &comp_len, v, u);
        comp_size[(int)(u)] = comp_size[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? comp_size_len + _mochi_idx : _mochi_idx;})] + comp_size[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? comp_size_len + _mochi_idx : _mochi_idx;})];
        g = (Graph){.num_nodes = g.num_nodes, .edges = g.edges, .edges_len = g.edges_len, .component = comp};
        g = set_component(g, v);
    }
    return (UnionResult){.graph = g, .component_size = comp_size, .component_size_len = comp_size_len};
}

Edge * create_empty_edges(long long n) {
    Edge *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < n) {
        res = list_append_Edge(res, &res_len, (Edge){.u = -1LL, .v = -1LL, .w = -1LL});
        i = i + 1LL;
    }
    return create_empty_edges_len = res_len, res;
}

long long boruvka(Graph g) {
    long long *component_size = NULL;
    size_t component_size_len = 0;
    long long i = 0LL;
    while (i < g.num_nodes) {
        component_size = list_append_long_long(component_size, &component_size_len, 1LL);
        MapII comp = g.component;
        size_t comp_len = g.component.len;
        map_set_ii(comp_keys, comp_vals, &comp_len, i, i);
        g = (Graph){.num_nodes = g.num_nodes, .edges = g.edges, .edges_len = g.edges_len, .component = comp};
        i = i + 1LL;
    }
    long long mst_weight = 0LL;
    long long num_components = g.num_nodes;
    Edge *minimum_weight_edge = create_empty_edges(g.num_nodes);
    size_t minimum_weight_edge_len = create_empty_edges_len;
    while (num_components > 1LL) {
        {
            Edge* __tmp0 = g.edges;
            size_t __tmp0_len = g.edges_len;
            for (size_t __i = 0; __i < __tmp0_len; __i++) {
                Edge e = __tmp0[__i];
                long long u = e.u;
                long long v = e.v;
                long long w = e.w;
                long long u_comp = g.component[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})];
                long long v_comp = g.component[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})];
                if (u_comp != v_comp) {
                    Edge current_u = minimum_weight_edge[(int)({long long _mochi_idx = u_comp; _mochi_idx < 0 ? minimum_weight_edge_len + _mochi_idx : _mochi_idx;})];
                    if ((current_u.u == (0LL - 1LL)) || (current_u.w > w)) {
                        minimum_weight_edge[(int)(u_comp)] = (Edge){.u = u, .v = v, .w = w};
                    }
                    Edge current_v = minimum_weight_edge[(int)({long long _mochi_idx = v_comp; _mochi_idx < 0 ? minimum_weight_edge_len + _mochi_idx : _mochi_idx;})];
                    if ((current_v.u == (0LL - 1LL)) || (current_v.w > w)) {
                        minimum_weight_edge[(int)(v_comp)] = (Edge){.u = u, .v = v, .w = w};
                    }
                }
            }
        }
        for (size_t __i = 0; __i < minimum_weight_edge_len; __i++) {
            Edge e = minimum_weight_edge[__i];
            if (e.u != (0LL - 1LL)) {
                long long u = e.u;
                long long v = e.v;
                long long w = e.w;
                long long u_comp = g.component[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})];
                long long v_comp = g.component[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? g.component_len + _mochi_idx : _mochi_idx;})];
                if (u_comp != v_comp) {
                    mst_weight = mst_weight + w;
                    UnionResult res = user_union(g, component_size, component_size_len, u_comp, v_comp);
                    g = res.graph;
                    component_size = res.component_size;
                    puts(str_concat(str_concat(str_concat(str_concat("Added edge [", str_int(u)), " - "), str_int(v)), "]"));
                    puts(str_concat("Added weight: ", str_int(w)));
                    puts("");
                    num_components = num_components - 1LL;
                }
            }
        }
        minimum_weight_edge = create_empty_edges(g.num_nodes);
        minimum_weight_edge_len = create_empty_edges_len;
    }
    puts(str_concat("The total weight of the minimal spanning tree is: ", str_int(mst_weight)));
    return mst_weight;
}

void user_main() {
    Graph g = new_graph(8LL);
    long long edges_0[3] = {0LL, 1LL, 10LL};
    long long edges_1[3] = {0LL, 2LL, 6LL};
    long long edges_2[3] = {0LL, 3LL, 5LL};
    long long edges_3[3] = {1LL, 3LL, 15LL};
    long long edges_4[3] = {2LL, 3LL, 4LL};
    long long edges_5[3] = {3LL, 4LL, 8LL};
    long long edges_6[3] = {4LL, 5LL, 10LL};
    long long edges_7[3] = {4LL, 6LL, 6LL};
    long long edges_8[3] = {4LL, 7LL, 5LL};
    long long edges_9[3] = {5LL, 7LL, 15LL};
    long long edges_10[3] = {6LL, 7LL, 4LL};
    long long *edges_init[11] = {edges_0, edges_1, edges_2, edges_3, edges_4, edges_5, edges_6, edges_7, edges_8, edges_9, edges_10};
    long long **edges = edges_init;
    size_t edges_len = 11;
    size_t edges_lens_init[11] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
    size_t *edges_lens = edges_lens_init;
    size_t edges_lens_len = 11;
    for (size_t __i = 0; __i < edges_len; __i++) {
        long long *e = edges[__i];
        size_t e_len = edges_lens[__i];
        g = add_edge(g, e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})], e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})], e[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})]);
    }
    boruvka(g);
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
