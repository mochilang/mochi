// Generated by Mochi 0.10.32 on 2025-08-15 21:09 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static int contains_str(const char *arr[], size_t len, const char *val) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(arr[i], val) == 0) return 1;
    }
    return 0;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { const char **keys; void **vals; size_t *lens; size_t len; size_t cap; } MapSL;

static void* map_get_sl(const char *keys[], void *vals[], const size_t lens[], size_t len, const char *key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

static size_t map_len_sl(const char *keys[], const size_t lens[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return lens[i];
    }
    return 0;
}

static void map_set_sl(const char *keys[], void *vals[], size_t lens[], size_t *len, const char *key, void *val, size_t val_len) {
    for (size_t i = 0; i < *len; i++) {
        if (strcmp(keys[i], key) == 0) { vals[i] = val; lens[i] = val_len; return; }
    }
    keys[*len] = key; vals[*len] = val; lens[*len] = val_len; (*len)++;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct GraphAdjacencyList GraphAdjacencyList;

struct GraphAdjacencyList {
    MapSL adj_list;
    long long directed;
};

GraphAdjacencyList d_graph;

GraphAdjacencyList make_graph(long long directed);
long long contains_vertex(MapSL m, const char* v);
GraphAdjacencyList add_edge(GraphAdjacencyList g, const char* s, const char* d);
const char* graph_to_string(GraphAdjacencyList g);
int main(void);

GraphAdjacencyList make_graph(long long directed) {
    static const char* m_keys[16] = {};
    static void* m_vals[16] = {};
    static size_t m_lens[16] = {};
    size_t m_len = 0;
    MapSL m = { m_keys, m_vals, m_lens, 0, 16 };
    return (GraphAdjacencyList){.adj_list = m, .directed = directed};
}

long long contains_vertex(MapSL m, const char* v) {
    return contains_str(m.keys, m.len, v);
}

GraphAdjacencyList add_edge(GraphAdjacencyList g, const char* s, const char* d) {
    MapSL adj = g.adj_list;
    if (!(g.directed)) {
        if (contains_vertex(adj, s) && contains_vertex(adj, d)) {
            {
            const char** __tmp0 = map_get_sl(adj.keys, adj.vals, adj.lens, adj.len, s, NULL);
            size_t __tmp1 = map_len_sl(adj.keys, adj.lens, adj.len, s);
            __tmp0 = list_append_str(__tmp0, &__tmp1, d);
            map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, __tmp0, __tmp1);
            }
            {
            const char** __tmp2 = map_get_sl(adj.keys, adj.vals, adj.lens, adj.len, d, NULL);
            size_t __tmp3 = map_len_sl(adj.keys, adj.lens, adj.len, d);
            __tmp2 = list_append_str(__tmp2, &__tmp3, s);
            map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, d, __tmp2, __tmp3);
            }
        } else {
            if (contains_vertex(adj, s)) {
                {
                const char** __tmp4 = map_get_sl(adj.keys, adj.vals, adj.lens, adj.len, s, NULL);
                size_t __tmp5 = map_len_sl(adj.keys, adj.lens, adj.len, s);
                __tmp4 = list_append_str(__tmp4, &__tmp5, d);
                map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, __tmp4, __tmp5);
                }
                map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, d, ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = s; tmp;}), 1);
            } else {
                if (contains_vertex(adj, d)) {
                    {
                    const char** __tmp6 = map_get_sl(adj.keys, adj.vals, adj.lens, adj.len, d, NULL);
                    size_t __tmp7 = map_len_sl(adj.keys, adj.lens, adj.len, d);
                    __tmp6 = list_append_str(__tmp6, &__tmp7, s);
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, d, __tmp6, __tmp7);
                    }
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = d; tmp;}), 1);
                } else {
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = d; tmp;}), 1);
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, d, ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = s; tmp;}), 1);
                }
            }
        }
    } else {
        if (contains_vertex(adj, s) && contains_vertex(adj, d)) {
            {
            const char** __tmp8 = map_get_sl(adj.keys, adj.vals, adj.lens, adj.len, s, NULL);
            size_t __tmp9 = map_len_sl(adj.keys, adj.lens, adj.len, s);
            __tmp8 = list_append_str(__tmp8, &__tmp9, d);
            map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, __tmp8, __tmp9);
            }
        } else {
            if (contains_vertex(adj, s)) {
                {
                const char** __tmp10 = map_get_sl(adj.keys, adj.vals, adj.lens, adj.len, s, NULL);
                size_t __tmp11 = map_len_sl(adj.keys, adj.lens, adj.len, s);
                __tmp10 = list_append_str(__tmp10, &__tmp11, d);
                map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, __tmp10, __tmp11);
                }
                map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, d, NULL, 0);
            } else {
                if (contains_vertex(adj, d)) {
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = d; tmp;}), 1);
                } else {
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, s, ({const char* *tmp = malloc(1 * sizeof(const char*)); tmp[0] = d; tmp;}), 1);
                    map_set_sl(adj.keys, adj.vals, adj.lens, &adj.len, d, NULL, 0);
                }
            }
        }
    }
    g.adj_list = adj;
    return g;
}

const char* graph_to_string(GraphAdjacencyList g) {
    return "map";
}

int main(void) {
    {
        long long __start = _now();
        d_graph = make_graph(1LL);
        d_graph = add_edge(d_graph, "0", "1");
        puts(graph_to_string(d_graph));
        d_graph = add_edge(d_graph, "1", "2");
        d_graph = add_edge(d_graph, "1", "4");
        d_graph = add_edge(d_graph, "1", "5");
        puts(graph_to_string(d_graph));
        d_graph = add_edge(d_graph, "2", "0");
        d_graph = add_edge(d_graph, "2", "6");
        d_graph = add_edge(d_graph, "2", "7");
        puts(graph_to_string(d_graph));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
