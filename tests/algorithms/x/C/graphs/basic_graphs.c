// Generated by Mochi 0.10.32 on 2025-08-25 21:19 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t sort_ints_len;
size_t sort_edges_len;
size_t *sort_edges_lens;
size_t find_isolated_nodes_len;

size_t _slice_int_len;
size_t append_len;
static int contains_int(const int arr[], size_t len, int val) {
    for (size_t i = 0; i < len; i++) {
        if (arr[i] == val) return 1;
    }
    return 0;
}

static int contains_map_int(const int keys[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) return 1;
    }
    return 0;
}

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_int(const long long *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[32];
        snprintf(tmp, sizeof(tmp), "%lld", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static char* str_list_list_int(long long **arr, size_t len, const size_t lens[]) {
    size_t cap = 2;
    for (size_t i = 0; i < len; i++) cap += lens[i] * 32 + 3;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char *inner = str_list_int(arr[i], lens[i]);
        size_t n = strlen(inner);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, inner, n);
        pos += n;
        free(inner);
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

typedef struct MapIL { int *keys; void **vals; size_t *lens; size_t len; size_t cap; } MapIL;

typedef struct MapII { int *keys; int *vals; size_t len; size_t cap; } MapII;

static int map_get_ii(const int keys[], const int vals[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) return vals[i];
    }
    return 0;
}

static void map_set_ii(MapII *m, int key, int val) {
    for (size_t i = 0; i < m->len; i++) {
        if (m->keys[i] == key) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        int *new_keys = malloc(m->cap * sizeof(int));
        int *new_vals = malloc(m->cap * sizeof(int));
        if (m->keys) memcpy(new_keys, m->keys, m->len * sizeof(int));
        if (m->vals) memcpy(new_vals, m->vals, m->len * sizeof(int));
        m->keys = new_keys;
        m->vals = new_vals;
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static void* map_get_il(const int keys[], void *vals[], const size_t lens[], size_t len, int key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

static size_t map_len_il(const int keys[], void *const vals[], const size_t lens[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) { if (vals[i] == NULL) return 0; return lens[i]; }
    }
    return 0;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* _slice_int(const long long *arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    long long *res = NULL;
    if (n) {
        res = malloc(n * sizeof(long long));
        memcpy(res, arr + start, n * sizeof(long long));
    }
    *out_len = n;
    _slice_int_len = n;
    return res;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int g_dfs_keys[21] = {1LL, 2LL, 3LL, 4LL, 5LL};
static long long g_dfs_vals_0[2] = {2LL, 3LL};
static long long g_dfs_vals_1[2] = {4LL, 5LL};
static long long g_dfs_vals_2[0] = {};
static long long g_dfs_vals_3[0] = {};
static long long g_dfs_vals_4[0] = {};
static void* g_dfs_vals[21] = {g_dfs_vals_0, g_dfs_vals_1, g_dfs_vals_2, g_dfs_vals_3, g_dfs_vals_4};
static size_t g_dfs_lens[21] = {2, 2, 0, 0, 0};
size_t g_dfs_len = 5;
MapIL g_dfs = { g_dfs_keys, g_dfs_vals, g_dfs_lens, 5, 21 };
static int g_bfs_keys[24] = {1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL, 8LL};
static long long g_bfs_vals_0[2] = {2LL, 3LL};
static long long g_bfs_vals_1[2] = {4LL, 5LL};
static long long g_bfs_vals_2[2] = {6LL, 7LL};
static long long g_bfs_vals_3[0] = {};
static long long g_bfs_vals_4[1] = {8LL};
static long long g_bfs_vals_5[0] = {};
static long long g_bfs_vals_6[0] = {};
static long long g_bfs_vals_7[0] = {};
static void* g_bfs_vals[24] = {g_bfs_vals_0, g_bfs_vals_1, g_bfs_vals_2, g_bfs_vals_3, g_bfs_vals_4, g_bfs_vals_5, g_bfs_vals_6, g_bfs_vals_7};
static size_t g_bfs_lens[24] = {2, 2, 2, 0, 1, 0, 0, 0};
size_t g_bfs_len = 8;
MapIL g_bfs = { g_bfs_keys, g_bfs_vals, g_bfs_lens, 8, 24 };
static int g_weighted_keys[22] = {1LL, 2LL, 3LL, 4LL, 5LL, 6LL};
static long long* g_weighted_vals_0[3] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 7LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 9LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 6LL; tmp[1] = 14LL; tmp;})};
static long long* g_weighted_vals_1[3] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 7LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 10LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 4LL; tmp[1] = 15LL; tmp;})};
static long long* g_weighted_vals_2[4] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 9LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 10LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 4LL; tmp[1] = 11LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 6LL; tmp[1] = 2LL; tmp;})};
static long long* g_weighted_vals_3[3] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 15LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 11LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 5LL; tmp[1] = 6LL; tmp;})};
static long long* g_weighted_vals_4[2] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 4LL; tmp[1] = 6LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 6LL; tmp[1] = 9LL; tmp;})};
static long long* g_weighted_vals_5[3] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 14LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 2LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 5LL; tmp[1] = 9LL; tmp;})};
static void* g_weighted_vals[22] = {g_weighted_vals_0, g_weighted_vals_1, g_weighted_vals_2, g_weighted_vals_3, g_weighted_vals_4, g_weighted_vals_5};
static size_t g_weighted_lens[22] = {3, 3, 4, 3, 2, 3};
size_t g_weighted_len = 6;
MapIL g_weighted = { g_weighted_keys, g_weighted_vals, g_weighted_lens, 6, 22 };
static int g_topo_keys[20] = {1LL, 2LL, 3LL, 4LL};
static long long g_topo_vals_0[2] = {2LL, 3LL};
static long long g_topo_vals_1[1] = {4LL};
static long long g_topo_vals_2[1] = {4LL};
static long long g_topo_vals_3[0] = {};
static void* g_topo_vals[20] = {g_topo_vals_0, g_topo_vals_1, g_topo_vals_2, g_topo_vals_3};
static size_t g_topo_lens[20] = {2, 1, 1, 0};
size_t g_topo_len = 4;
MapIL g_topo = { g_topo_keys, g_topo_vals, g_topo_lens, 4, 20 };
long long **matrix = NULL;
size_t matrix_len = 0;
size_t *matrix_lens = NULL;
size_t matrix_lens_len = 0;
static int g_prim_keys[20] = {1LL, 2LL, 3LL, 4LL};
static long long* g_prim_vals_0[2] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 1LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 3LL; tmp;})};
static long long* g_prim_vals_1[3] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 1LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 1LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 4LL; tmp[1] = 6LL; tmp;})};
static long long* g_prim_vals_2[3] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 3LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 1LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 4LL; tmp[1] = 2LL; tmp;})};
static long long* g_prim_vals_3[2] = {({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 6LL; tmp;}), ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 2LL; tmp;})};
static void* g_prim_vals[20] = {g_prim_vals_0, g_prim_vals_1, g_prim_vals_2, g_prim_vals_3};
static size_t g_prim_lens[20] = {2, 3, 3, 2};
size_t g_prim_len = 4;
MapIL g_prim = { g_prim_keys, g_prim_vals, g_prim_lens, 4, 20 };
long long **edges_kruskal = NULL;
size_t edges_kruskal_len = 0;
size_t *edges_kruskal_lens = NULL;
size_t edges_kruskal_lens_len = 0;
static int g_iso_keys[20] = {1LL, 2LL, 3LL, 4LL};
static long long g_iso_vals_0[2] = {2LL, 3LL};
static long long g_iso_vals_1[2] = {1LL, 3LL};
static long long g_iso_vals_2[2] = {1LL, 2LL};
static long long g_iso_vals_3[0] = {};
static void* g_iso_vals[20] = {g_iso_vals_0, g_iso_vals_1, g_iso_vals_2, g_iso_vals_3};
static size_t g_iso_lens[20] = {2, 2, 2, 0};
size_t g_iso_len = 4;
MapIL g_iso = { g_iso_keys, g_iso_vals, g_iso_lens, 4, 20 };
long long *iso = NULL;
size_t iso_len = 0;

const char* dfs(MapIL g, long long s);
const char* bfs(MapIL g, long long s);
long long * sort_ints(long long * a, size_t a_len);
const char* dijkstra(int g, long long s);
const char* topo(MapIL g, long long n);
const char* floyd(long long * * a, size_t a_len, size_t* a_lens, size_t a_lens_len);
long long prim(int g, long long s, long long n);
long long * * sort_edges(long long * * edges, size_t edges_len, size_t* edges_lens, size_t edges_lens_len);
long long find_parent(long long * parent, size_t parent_len, long long x);
void union_parent(long long * parent, size_t parent_len, long long a, long long b);
long long kruskal(long long * * edges, size_t edges_len, size_t* edges_lens, size_t edges_lens_len, long long n);
long long * find_isolated_nodes(MapIL g, long long * nodes, size_t nodes_len);
int main(void);

const char* dfs(MapIL g, long long s) {
    MapII visited = { NULL, NULL, 0, 0 };
    long long *stack = NULL;
    size_t stack_len = 0;
    map_set_ii(&(visited), s, 1LL);
    stack = list_append_long_long(stack, &stack_len, s);
    printf("%d\n", s);
    while (stack_len > 0LL) {
        long long u = stack[(int)({long long _mochi_idx = stack_len - 1LL; _mochi_idx < 0 ? stack_len + _mochi_idx : _mochi_idx;})];
        long long found = 0LL;
        {
            size_t __tmp0_len = 0;
            long long* __tmp0 = map_get_il(g.keys, g.vals, g.lens, g.len, u, &__tmp0_len);
            for (size_t __i = 0; __i < __tmp0_len; __i++) {
                long long v = __tmp0[__i];
                if (!(contains_map_int(visited.keys, visited.len, v))) {
                    map_set_ii(&(visited), v, 1LL);
                    stack = list_append_long_long(stack, &stack_len, v);
                    printf("%d\n", v);
                    found = 1LL;
                    break;
                }
            }
        }
        if (!(found)) {
            stack = _slice_int(stack, stack_len, 0LL, stack_len - 1LL, &(_slice_int_len));
            stack_len = _slice_int_len;
        }
    }
}

const char* bfs(MapIL g, long long s) {
    MapII visited = { NULL, NULL, 0, 0 };
    long long *q = NULL;
    size_t q_len = 0;
    map_set_ii(&(visited), s, 1LL);
    q = list_append_long_long(q, &q_len, s);
    printf("%d\n", s);
    while (q_len > 0LL) {
        long long u = q[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? q_len + _mochi_idx : _mochi_idx;})];
        q = _slice_int(q, q_len, 1LL, q_len, &(_slice_int_len));
        q_len = _slice_int_len;
        {
            size_t __tmp1_len = 0;
            long long* __tmp1 = map_get_il(g.keys, g.vals, g.lens, g.len, u, &__tmp1_len);
            for (size_t __i = 0; __i < __tmp1_len; __i++) {
                long long v = __tmp1[__i];
                if (!(contains_map_int(visited.keys, visited.len, v))) {
                    map_set_ii(&(visited), v, 1LL);
                    q = list_append_long_long(q, &q_len, v);
                    printf("%d\n", v);
                }
            }
        }
    }
}

long long * sort_ints(long long * a, size_t a_len) {
    long long *arr = a;
    size_t arr_len = a_len;
    long long i = 0LL;
    while (i < arr_len) {
        long long j = 0LL;
        while (j < ((arr_len - i) - 1LL)) {
            if (arr[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] > arr[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})]) {
                long long tmp = arr[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
                arr[(int)(j)] = arr[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
                arr[(int)(j + 1LL)] = tmp;
            }
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    return sort_ints_len = arr_len, arr;
}

const char* dijkstra(int g, long long s) {
    MapII dist = { NULL, NULL, 0, 0 };
    map_set_ii(&(dist), s, 0LL);
    MapII path = { NULL, NULL, 0, 0 };
    map_set_ii(&(path), s, 0LL);
    long long *known = NULL;
    size_t known_len = 0;
    long long *keys = NULL;
    size_t keys_len = 0;
    while (known_len < keys_len) {
        long long mini = 100000LL;
        long long u = -1LL;
        long long i = 0LL;
        while (i < keys_len) {
            long long k = keys[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? keys_len + _mochi_idx : _mochi_idx;})];
            long long d = map_get_ii(dist.keys, dist.vals, dist.len, k);
            if (!(contains_int(known, known_len, k)) && (d < mini)) {
                mini = d;
                u = k;
            }
            i = i + 1LL;
        }
        known = list_append_long_long(known, &known_len, u);
        {
            long long[]* __tmp2 = map_get_il(g.keys, g.vals, g.lens, g.len, u, NULL);
            size_t __tmp2_len = map_len_il(g.keys, g.vals, g.lens, g.len, u);
            for (size_t __i = 0; __i < __tmp2_len; __i++) {
                long long *e = __tmp2[__i];
                size_t e_len = __tmp2_lens[__i];
                const char* v = e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                const char* w = e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                if (!(contains_int(keys, keys_len, v))) {
                    keys = list_append_long_long(keys, &keys_len, v);
                }
                const char* alt = str_concat(str_int(map_get_ii(dist.keys, dist.vals, dist.len, u)), w);
                long long cur;
                if (contains_map_int(dist.keys, dist.len, v)) {
                    cur = map_get_ii(dist.keys, dist.vals, dist.len, v);
                } else {
                    cur = 100000LL;
                }
                if (!(contains_int(known, known_len, v)) && (alt < cur)) {
                    map_set_ii(&(dist), v, alt);
                    map_set_ii(&(path), v, u);
                }
            }
        }
    }
    long long *ordered = sort_ints(keys, keys_len);
    size_t ordered_len = sort_ints_len;
    long long idx = 0LL;
    while (idx < ordered_len) {
        long long k = ordered[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? ordered_len + _mochi_idx : _mochi_idx;})];
        if (k != s) {
            printf("%d\n", map_get_ii(dist.keys, dist.vals, dist.len, k));
        }
        idx = idx + 1LL;
    }
}

const char* topo(MapIL g, long long n) {
    long long *ind = NULL;
    size_t ind_len = 0;
    long long i = 0LL;
    while (i <= n) {
        ind = list_append_long_long(ind, &ind_len, 0LL);
        i = i + 1LL;
    }
    long long node = 1LL;
    while (node <= n) {
        {
            size_t __tmp3_len = 0;
            long long* __tmp3 = map_get_il(g.keys, g.vals, g.lens, g.len, node, &__tmp3_len);
            for (size_t __i = 0; __i < __tmp3_len; __i++) {
                long long v = __tmp3[__i];
                ind[(int)(v)] = ind[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? ind_len + _mochi_idx : _mochi_idx;})] + 1LL;
            }
        }
        node = node + 1LL;
    }
    long long *q = NULL;
    size_t q_len = 0;
    long long j = 1LL;
    while (j <= n) {
        if (ind[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? ind_len + _mochi_idx : _mochi_idx;})] == 0LL) {
            q = list_append_long_long(q, &q_len, j);
        }
        j = j + 1LL;
    }
    while (q_len > 0LL) {
        long long v = q[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? q_len + _mochi_idx : _mochi_idx;})];
        q = _slice_int(q, q_len, 1LL, q_len, &(_slice_int_len));
        q_len = _slice_int_len;
        printf("%d\n", v);
        {
            size_t __tmp4_len = 0;
            long long* __tmp4 = map_get_il(g.keys, g.vals, g.lens, g.len, v, &__tmp4_len);
            for (size_t __i = 0; __i < __tmp4_len; __i++) {
                long long w = __tmp4[__i];
                ind[(int)(w)] = ind[(int)({long long _mochi_idx = w; _mochi_idx < 0 ? ind_len + _mochi_idx : _mochi_idx;})] - 1LL;
                if (ind[(int)({long long _mochi_idx = w; _mochi_idx < 0 ? ind_len + _mochi_idx : _mochi_idx;})] == 0LL) {
                    q = list_append_long_long(q, &q_len, w);
                }
            }
        }
    }
}

const char* floyd(long long * * a, size_t a_len, size_t* a_lens, size_t a_lens_len) {
    long long n = a_len;
    long long **dist = NULL;
    size_t dist_len = 0;
    size_t *dist_lens = NULL;
    size_t dist_lens_len = 0;
    long long i = 0LL;
    while (i < n) {
        long long *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < n) {
            row = list_append_long_long(row, &row_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_lens[(int)(i)] + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        dist = list_append_intptr(dist, &dist_len, row);
        dist_lens = list_append_szt(dist_lens, &dist_lens_len, row_len);
        i = i + 1LL;
    }
    long long k = 0LL;
    while (k < n) {
        long long ii = 0LL;
        while (ii < n) {
            long long jj = 0LL;
            while (jj < n) {
                if (dist[(int)({long long _mochi_idx = ii; _mochi_idx < 0 ? dist_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = jj; _mochi_idx < 0 ? dist_lens[(int)(ii)] + _mochi_idx : _mochi_idx;})] > (dist[(int)({long long _mochi_idx = ii; _mochi_idx < 0 ? dist_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? dist_lens[(int)(ii)] + _mochi_idx : _mochi_idx;})] + dist[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? dist_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = jj; _mochi_idx < 0 ? dist_lens[(int)(k)] + _mochi_idx : _mochi_idx;})])) {
                    dist[(int)(ii)][(int)(jj)] = dist[(int)({long long _mochi_idx = ii; _mochi_idx < 0 ? dist_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? dist_lens[(int)(ii)] + _mochi_idx : _mochi_idx;})] + dist[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? dist_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = jj; _mochi_idx < 0 ? dist_lens[(int)(k)] + _mochi_idx : _mochi_idx;})];
                }
                jj = jj + 1LL;
            }
            ii = ii + 1LL;
        }
        k = k + 1LL;
    }
    puts(str_list_list_int(dist, dist_len, dist_lens));
}

long long prim(int g, long long s, long long n) {
    MapII dist = { NULL, NULL, 0, 0 };
    map_set_ii(&(dist), s, 0LL);
    long long *known = NULL;
    size_t known_len = 0;
    long long *keys = NULL;
    size_t keys_len = 0;
    long long total = 0LL;
    while (known_len < n) {
        long long mini = 100000LL;
        long long u = -1LL;
        long long i = 0LL;
        while (i < keys_len) {
            long long k = keys[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? keys_len + _mochi_idx : _mochi_idx;})];
            long long d = map_get_ii(dist.keys, dist.vals, dist.len, k);
            if (!(contains_int(known, known_len, k)) && (d < mini)) {
                mini = d;
                u = k;
            }
            i = i + 1LL;
        }
        known = list_append_long_long(known, &known_len, u);
        total = total + mini;
        {
            long long[]* __tmp5 = map_get_il(g.keys, g.vals, g.lens, g.len, u, NULL);
            size_t __tmp5_len = map_len_il(g.keys, g.vals, g.lens, g.len, u);
            for (size_t __i = 0; __i < __tmp5_len; __i++) {
                long long *e = __tmp5[__i];
                size_t e_len = __tmp5_lens[__i];
                const char* v = e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                const char* w = e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                if (!(contains_int(keys, keys_len, v))) {
                    keys = list_append_long_long(keys, &keys_len, v);
                }
                long long cur;
                if (contains_map_int(dist.keys, dist.len, v)) {
                    cur = map_get_ii(dist.keys, dist.vals, dist.len, v);
                } else {
                    cur = 100000LL;
                }
                if (!(contains_int(known, known_len, v)) && (w < cur)) {
                    map_set_ii(&(dist), v, w);
                }
            }
        }
    }
    return total;
}

long long * * sort_edges(long long * * edges, size_t edges_len, size_t* edges_lens, size_t edges_lens_len) {
    long long **es = edges;
    size_t es_len = edges_len;
    size_t *es_lens = edges_lens;
    size_t es_lens_len = edges_len;
    long long i = 0LL;
    while (i < es_len) {
        long long j = 0LL;
        while (j < ((es_len - i) - 1LL)) {
            if (es[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? es_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? es_lens[(int)(j)] + _mochi_idx : _mochi_idx;})] > es[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? es_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? es_lens[(int)(j + 1LL)] + _mochi_idx : _mochi_idx;})]) {
                long long *tmp = es[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? es_len + _mochi_idx : _mochi_idx;})];
                size_t tmp_len = es_lens[(int)(j)];
                es[(int)(j)] = es[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? es_len + _mochi_idx : _mochi_idx;})];
                es[(int)(j + 1LL)] = tmp;
            }
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    return sort_edges_lens = es_lens, sort_edges_len = es_len, es;
}

long long find_parent(long long * parent, size_t parent_len, long long x) {
    long long r = x;
    while (parent[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? parent_len + _mochi_idx : _mochi_idx;})] != r) {
        r = parent[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? parent_len + _mochi_idx : _mochi_idx;})];
    }
    return r;
}

void union_parent(long long * parent, size_t parent_len, long long a, long long b) {
    parent[(int)(a)] = b;
}

long long kruskal(long long * * edges, size_t edges_len, size_t* edges_lens, size_t edges_lens_len, long long n) {
    long long **es = sort_edges(edges, edges_len, edges_lens, edges_len);
    size_t es_len = sort_edges_len;
    size_t *es_lens = sort_edges_lens;
    size_t es_lens_len = sort_edges_len;
    long long *parent = NULL;
    size_t parent_len = 0;
    long long i = 0LL;
    while (i <= n) {
        parent = list_append_long_long(parent, &parent_len, i);
        i = i + 1LL;
    }
    long long total = 0LL;
    long long count_ = 0LL;
    long long idx = 0LL;
    while ((count_ < (n - 1LL)) && (idx < es_len)) {
        long long *e = es[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? es_len + _mochi_idx : _mochi_idx;})];
        size_t e_len = es_lens[(int)(idx)];
        idx = idx + 1LL;
        long long u = e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
        long long v = e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
        long long w = e[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
        long long ru = find_parent(parent, parent_len, u);
        long long rv = find_parent(parent, parent_len, v);
        if (ru != rv) {
            union_parent(parent, parent_len, ru, rv);
            total = total + w;
            count_ = count_ + 1LL;
        }
    }
    return total;
}

long long * find_isolated_nodes(MapIL g, long long * nodes, size_t nodes_len) {
    long long *isolated = NULL;
    size_t isolated_len = 0;
    for (size_t __i = 0; __i < nodes_len; __i++) {
        long long node = nodes[__i];
        if (map_len_il(g.keys, g.vals, g.lens, g.len, node) == 0LL) {
            isolated = list_append_long_long(isolated, &isolated_len, node);
        }
    }
    return find_isolated_nodes_len = isolated_len, isolated;
}

int main(void) {
    {
        long long __start = _now();
        matrix = malloc(4 * sizeof(long long*));
        matrix_len = 4;
        matrix[0] = ({long long *tmp = malloc(4 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 5LL; tmp[2] = 9LL; tmp[3] = 100000LL; tmp;});
        matrix[1] = ({long long *tmp = malloc(4 * sizeof(long long)); tmp[0] = 100000LL; tmp[1] = 0LL; tmp[2] = 2LL; tmp[3] = 8LL; tmp;});
        matrix[2] = ({long long *tmp = malloc(4 * sizeof(long long)); tmp[0] = 100000LL; tmp[1] = 100000LL; tmp[2] = 0LL; tmp[3] = 7LL; tmp;});
        matrix[3] = ({long long *tmp = malloc(4 * sizeof(long long)); tmp[0] = 4LL; tmp[1] = 100000LL; tmp[2] = 100000LL; tmp[3] = 0LL; tmp;});
        matrix_lens = ({size_t *tmp = malloc(4 * sizeof(size_t)); tmp[0] = 4; tmp[1] = 4; tmp[2] = 4; tmp[3] = 4; tmp;});
        matrix_lens_len = 4;
        edges_kruskal = malloc(4 * sizeof(long long*));
        edges_kruskal_len = 4;
        edges_kruskal[0] = ({long long *tmp = malloc(3 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 2LL; tmp[2] = 1LL; tmp;});
        edges_kruskal[1] = ({long long *tmp = malloc(3 * sizeof(long long)); tmp[0] = 2LL; tmp[1] = 3LL; tmp[2] = 2LL; tmp;});
        edges_kruskal[2] = ({long long *tmp = malloc(3 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 3LL; tmp[2] = 2LL; tmp;});
        edges_kruskal[3] = ({long long *tmp = malloc(3 * sizeof(long long)); tmp[0] = 3LL; tmp[1] = 4LL; tmp[2] = 1LL; tmp;});
        edges_kruskal_lens = ({size_t *tmp = malloc(4 * sizeof(size_t)); tmp[0] = 3; tmp[1] = 3; tmp[2] = 3; tmp[3] = 3; tmp;});
        edges_kruskal_lens_len = 4;
        dfs(g_dfs, 1LL);
        bfs(g_bfs, 1LL);
        dijkstra(g_weighted, 1LL);
        topo(g_topo, 4LL);
        floyd(matrix, matrix_len, matrix_lens, matrix_len);
        printf("%d\n", prim(g_prim, 1LL, 4LL));
        printf("%d\n", kruskal(edges_kruskal, edges_kruskal_len, edges_kruskal_lens, edges_kruskal_len, 4LL));
        iso = find_isolated_nodes(g_iso, ({long long *tmp = malloc(4 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 2LL; tmp[2] = 3LL; tmp[3] = 4LL; tmp;}), 4);
        iso_len = find_isolated_nodes_len;
        puts(str_list_int(iso, iso_len));
        long long __end = _now();
        long long __dur_us = (__end - __start + 999) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
