// Generated by Mochi 0.10.32 on 2025-08-14 09:53 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t pheromone_update_len;
size_t *pheromone_update_lens;
size_t remove_value_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

static char* str_list_int(const long long *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[32];
        snprintf(tmp, sizeof(tmp), "%lld", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

typedef struct { int *keys; void **vals; size_t *lens; size_t len; size_t cap; } MapIL;

static void* map_get_il(const int keys[], void *vals[], const size_t lens[], size_t len, int key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double sqrtApprox(double x);
double rand_float();
double pow_float(double base, double exp);
double distance(long long * city1, size_t city1_len, long long * city2, size_t city2_len);
long long choose_weighted(long long * options, size_t options_len, double * weights, size_t weights_len);
long long city_select(double * * pheromone, size_t pheromone_len, size_t* pheromone_lens, size_t pheromone_lens_len, long long current, long long * unvisited, size_t unvisited_len, double alpha, double beta, MapIL cities);
double * * pheromone_update(double * * pheromone, size_t pheromone_len, size_t* pheromone_lens, size_t pheromone_lens_len, MapIL cities, double evaporation, long long * * ants_route, size_t ants_route_len, size_t* ants_route_lens, size_t ants_route_lens_len, double q);
long long * remove_value(long long * lst, size_t lst_len, long long val);
void ant_colony(MapIL cities, long long ants_num, long long iterations, double evaporation, double alpha, double beta, double q);
int main(void);

double sqrtApprox(double x) {
    double guess = x / 2.0;
    long long i = 0LL;
    while (i < 20LL) {
        guess = (guess + (x / guess)) / 2.0;
        i = i + 1LL;
    }
    return guess;
}

double rand_float() {
    return (_now() % 1000000LL) / 1000000.0;
}

double pow_float(double base, double exp) {
    double result = 1.0;
    long long i = 0LL;
    long long e = (int)(exp);
    while (i < e) {
        result = result * base;
        i = i + 1LL;
    }
    return result;
}

double distance(long long * city1, size_t city1_len, long long * city2, size_t city2_len) {
    double dx = city1[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? city1_len + _mochi_idx : _mochi_idx;})] - city2[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? city2_len + _mochi_idx : _mochi_idx;})];
    double dy = city1[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? city1_len + _mochi_idx : _mochi_idx;})] - city2[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? city2_len + _mochi_idx : _mochi_idx;})];
    return sqrtApprox((dx * dx) + (dy * dy));
}

long long choose_weighted(long long * options, size_t options_len, double * weights, size_t weights_len) {
    double total = 0.0;
    long long i = 0LL;
    while (i < weights_len) {
        total = total + weights[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? weights_len + _mochi_idx : _mochi_idx;})];
        i = i + 1LL;
    }
    double r = rand_float() * total;
    double accum = 0.0;
    i = 0LL;
    while (i < weights_len) {
        accum = accum + weights[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? weights_len + _mochi_idx : _mochi_idx;})];
        if (r <= accum) {
            return options[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? options_len + _mochi_idx : _mochi_idx;})];
        }
        i = i + 1LL;
    }
    return options[(int)({long long _mochi_idx = options_len - 1LL; _mochi_idx < 0 ? options_len + _mochi_idx : _mochi_idx;})];
}

long long city_select(double * * pheromone, size_t pheromone_len, size_t* pheromone_lens, size_t pheromone_lens_len, long long current, long long * unvisited, size_t unvisited_len, double alpha, double beta, MapIL cities) {
    double *probs = NULL;
    size_t probs_len = 0;
    long long i = 0LL;
    while (i < unvisited_len) {
        long long city = unvisited[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? unvisited_len + _mochi_idx : _mochi_idx;})];
        double dist = distance(map_get_il(cities_keys, cities_vals, cities_lens, cities_len, city, NULL), cities_lens[city], map_get_il(cities_keys, cities_vals, cities_lens, cities_len, current, NULL), cities_lens[current]);
        double trail = pheromone[(int)({long long _mochi_idx = city; _mochi_idx < 0 ? pheromone_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = current; _mochi_idx < 0 ? pheromone_lens[city] + _mochi_idx : _mochi_idx;})];
        double prob = pow_float(trail, alpha) * pow_float(1.0 / dist, beta);
        probs = list_append_double(probs, &probs_len, prob);
        i = i + 1LL;
    }
    return choose_weighted(unvisited, unvisited_len, probs, probs_len);
}

double * * pheromone_update(double * * pheromone, size_t pheromone_len, size_t* pheromone_lens, size_t pheromone_lens_len, MapIL cities, double evaporation, long long * * ants_route, size_t ants_route_len, size_t* ants_route_lens, size_t ants_route_lens_len, double q) {
    long long n = pheromone_len;
    long long i = 0LL;
    while (i < n) {
        long long j = 0LL;
        while (j < n) {
            pheromone[(int)(i)][(int)(j)] = pheromone[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? pheromone_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? pheromone_lens[i] + _mochi_idx : _mochi_idx;})] * evaporation;
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    long long a = 0LL;
    while (a < ants_route_len) {
        long long *route = ants_route[(int)({long long _mochi_idx = a; _mochi_idx < 0 ? ants_route_len + _mochi_idx : _mochi_idx;})];
        size_t route_len = ants_route_lens[a];
        double total = 0.0;
        long long r = 0LL;
        while (r < (route_len - 1LL)) {
            total = total + distance(map_get_il(cities_keys, cities_vals, cities_lens, cities_len, route[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})], &total_len), cities_lens[route[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})]], map_get_il(cities_keys, cities_vals, cities_lens, cities_len, route[(int)({long long _mochi_idx = r + 1LL; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})], &total_len), cities_lens[route[(int)({long long _mochi_idx = r + 1LL; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})]]);
            r = r + 1LL;
        }
        double delta = q / total;
        r = 0LL;
        while (r < (route_len - 1LL)) {
            long long u = route[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})];
            long long v = route[(int)({long long _mochi_idx = r + 1LL; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})];
            pheromone[(int)(u)][(int)(v)] = pheromone[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? pheromone_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = v; _mochi_idx < 0 ? pheromone_lens[u] + _mochi_idx : _mochi_idx;})] + delta;
            pheromone[(int)(v)][(int)(u)] = pheromone[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? pheromone_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = v; _mochi_idx < 0 ? pheromone_lens[u] + _mochi_idx : _mochi_idx;})];
            r = r + 1LL;
        }
        a = a + 1LL;
    }
    return pheromone_update_lens = pheromone_lens, pheromone_update_len = pheromone_len, pheromone;
}

long long * remove_value(long long * lst, size_t lst_len, long long val) {
    long long *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < lst_len) {
        if (lst[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? lst_len + _mochi_idx : _mochi_idx;})] != val) {
            res = list_append_long_long(res, &res_len, lst[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? lst_len + _mochi_idx : _mochi_idx;})]);
        }
        i = i + 1LL;
    }
    return remove_value_len = res_len, res;
}

void ant_colony(MapIL cities, long long ants_num, long long iterations, double evaporation, double alpha, double beta, double q) {
    long long n = cities_len;
    double **pheromone = NULL;
    size_t pheromone_len = 0;
    size_t *pheromone_lens = NULL;
    size_t pheromone_lens_len = 0;
    long long i = 0LL;
    while (i < n) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < n) {
            row = list_append_double(row, &row_len, 1.0);
            j = j + 1LL;
        }
        pheromone = list_append_doubleptr(pheromone, &pheromone_len, row);
        pheromone_lens = list_append_szt(pheromone_lens, &pheromone_lens_len, row_len);
        i = i + 1LL;
    }
    long long *best_path = NULL;
    size_t best_path_len = 0;
    double best_distance = 1000000000.0;
    long long iter = 0LL;
    while (iter < iterations) {
        long long **ants_route = NULL;
        size_t ants_route_len = 0;
        size_t *ants_route_lens = NULL;
        size_t ants_route_lens_len = 0;
        long long k = 0LL;
        while (k < ants_num) {
            long long *route = NULL;
            size_t route_len = 0;
            route = list_append_long_long(route, &route_len, 0LL);
            long long *unvisited = NULL;
            size_t unvisited_len = 0;
            for (size_t __i = 0; __i < cities.len; __i++) {
                int key = cities.keys[__i];
                if (key != 0LL) {
                    unvisited = list_append_long_long(unvisited, &unvisited_len, key);
                }
            }
            long long current = 0LL;
            while (unvisited_len > 0LL) {
                long long next_city = city_select(pheromone, pheromone_len, pheromone_lens, pheromone_len, current, unvisited, unvisited_len, alpha, beta, cities);
                route = list_append_long_long(route, &route_len, next_city);
                unvisited = remove_value(unvisited, unvisited_len, next_city);
                unvisited_len = remove_value_len;
                current = next_city;
            }
            route = list_append_long_long(route, &route_len, 0LL);
            ants_route = list_append_intptr(ants_route, &ants_route_len, route);
            ants_route_lens = list_append_szt(ants_route_lens, &ants_route_lens_len, route_len);
            k = k + 1LL;
        }
        pheromone = pheromone_update(pheromone, pheromone_len, pheromone_lens, pheromone_len, cities, evaporation, ants_route, ants_route_len, ants_route_lens, ants_route_len, q);
        pheromone_len = pheromone_update_len;
        pheromone_lens = pheromone_update_lens;
        long long a = 0LL;
        while (a < ants_route_len) {
            long long *route = ants_route[(int)({long long _mochi_idx = a; _mochi_idx < 0 ? ants_route_len + _mochi_idx : _mochi_idx;})];
            size_t route_len = ants_route_lens[a];
            double dist = 0.0;
            long long r = 0LL;
            while (r < (route_len - 1LL)) {
                dist = dist + distance(map_get_il(cities_keys, cities_vals, cities_lens, cities_len, route[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})], &dist_len), cities_lens[route[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})]], map_get_il(cities_keys, cities_vals, cities_lens, cities_len, route[(int)({long long _mochi_idx = r + 1LL; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})], &dist_len), cities_lens[route[(int)({long long _mochi_idx = r + 1LL; _mochi_idx < 0 ? route_len + _mochi_idx : _mochi_idx;})]]);
                r = r + 1LL;
            }
            if (dist < best_distance) {
                best_distance = dist;
                best_path = route;
                best_path_len = route_len;
            }
            a = a + 1LL;
        }
        iter = iter + 1LL;
    }
    puts(str_concat("best_path = ", str_list_int(best_path, best_path_len)));
    puts(str_concat("best_distance = ", str_float(best_distance)));
}

int main(void) {
    {
        long long __start = _now();
        static int cities_keys[24] = {0LL, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL};
        long long cities_vals_0[2] = {0LL, 0LL};
        long long cities_vals_1[2] = {0LL, 5LL};
        long long cities_vals_2[2] = {3LL, 8LL};
        long long cities_vals_3[2] = {8LL, 10LL};
        long long cities_vals_4[2] = {12LL, 8LL};
        long long cities_vals_5[2] = {12LL, 4LL};
        long long cities_vals_6[2] = {8LL, 0LL};
        long long cities_vals_7[2] = {6LL, 2LL};
        static void* cities_vals[24] = {cities_vals_0, cities_vals_1, cities_vals_2, cities_vals_3, cities_vals_4, cities_vals_5, cities_vals_6, cities_vals_7};
        static size_t cities_lens[24] = {2, 2, 2, 2, 2, 2, 2, 2};
        size_t cities_len = 8;
        MapIL cities = { cities_keys, cities_vals, cities_lens, 8, 24 };
        ant_colony(cities, 10LL, 20LL, 0.7, 1.0, 5.0, 10.0);
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
