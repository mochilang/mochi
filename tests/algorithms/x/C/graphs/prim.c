// Generated by Mochi 0.10.32 on 2025-08-16 11:14 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t prim_len;
size_t *prim_lens;
size_t sort_heap_len;
size_t prim_heap_len;
size_t *prim_heap_lens;

size_t _slice_int_len;
size_t append_len;
static int contains_map_int(const int keys[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) return 1;
    }
    return 0;
}

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { int *keys; void **vals; size_t *lens; size_t len; size_t cap; } MapIL;

typedef struct { int *keys; int *vals; size_t len; size_t cap; } MapII;

static int map_get_ii(const int keys[], const int vals[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) return vals[i];
    }
    return 0;
}

static void map_set_ii(MapII *m, int key, int val) {
    for (size_t i = 0; i < m->len; i++) {
        if (m->keys[i] == key) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc(m->keys, m->cap * sizeof(int));
        m->vals = realloc(m->vals, m->cap * sizeof(int));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static void* map_get_il(const int keys[], void *vals[], const size_t lens[], size_t len, int key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

static size_t map_len_il(const int keys[], void *const vals[], const size_t lens[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) { if (vals[i] == NULL) return 0; return lens[i]; }
    }
    return 0;
}

static void map_set_il(int **keys, void ***vals, size_t **lens, size_t *len, size_t *cap, int key, void *val, size_t val_len) {
    for (size_t i = 0; i < *len; i++) {
        if ((*keys)[i] == key) { (*vals)[i] = val; (*lens)[i] = val_len; return; }
    }
    if (*len >= *cap) {
        *cap = *cap ? *cap * 2 : 16;
        *keys = realloc(*keys, *cap * sizeof(int));
        *vals = realloc(*vals, *cap * sizeof(void*));
        *lens = realloc(*lens, *cap * sizeof(size_t));
    }
    (*keys)[*len] = key; (*vals)[*len] = val; (*lens)[*len] = val_len; (*len)++;
}

static long long* list_append_int_new(const long long *arr, size_t len, long long val) {
    long long *res = malloc((len + 1) * sizeof(long long));
    if (arr && len) memcpy(res, arr, len * sizeof(long long));
    res[len] = val;
    append_len = len + 1;
    return res;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* _slice_int(const long long *arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    long long *res = NULL;
    if (n) {
        res = malloc(n * sizeof(long long));
        memcpy(res, arr + start, n * sizeof(long long));
    }
    *out_len = n;
    _slice_int_len = n;
    return res;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long INF = 1000000000LL;

int connect(int graph, long long a, long long b, long long w);
long long in_list(long long * arr, size_t arr_len, long long x);
long long * * prim(int graph, long long s, long long n);
long long * sort_heap(long long * h, size_t h_len, MapII dist);
long long * * prim_heap(int graph, long long s, long long n);
void print_edges(long long * * edges, size_t edges_len, size_t* edges_lens, size_t edges_lens_len);
void test_vector();
int main(void);

int connect(int graph, long long a, long long b, long long w) {
    long long u = a - 1LL;
    long long v = b - 1LL;
    long long g = graph;
    g[(int)(u)] = list_append_int_new(g[(int)({long long _mochi_idx = u; _mochi_idx < 0 ? g_len + _mochi_idx : _mochi_idx;})], g.lens[(int)(u)], ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = v; tmp[1] = w; tmp;}));
    g[(int)(v)] = list_append_int_new(g[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? g_len + _mochi_idx : _mochi_idx;})], g.lens[(int)(v)], ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = u; tmp[1] = w; tmp;}));
    return g;
}

long long in_list(long long * arr, size_t arr_len, long long x) {
    long long i = 0LL;
    while (i < arr_len) {
        if (arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] == x) {
            return 1LL;
        }
        i = i + 1LL;
    }
    return 0LL;
}

long long * * prim(int graph, long long s, long long n) {
    MapII dist = { NULL, NULL, 0, 0 };
    MapII parent = { NULL, NULL, 0, 0 };
    map_set_ii(&dist, s, 0LL);
    map_set_ii(&parent, s, -1LL);
    long long *known = NULL;
    size_t known_len = 0;
    long long *keys = NULL;
    size_t keys_len = 0;
    while (known_len < n) {
        long long mini = INF;
        double u = -1LL;
        long long i = 0LL;
        while (i < keys_len) {
            long long k = keys[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? keys_len + _mochi_idx : _mochi_idx;})];
            long long d = map_get_ii(dist.keys, dist.vals, dist.len, k);
            if (!(in_list(known, known_len, k)) && (d < mini)) {
                mini = d;
                u = k;
            }
            i = i + 1LL;
        }
        known = list_append_long_long(known, &known_len, u);
        {
            long long[]* __tmp0 = map_get_il(graph.keys, graph.vals, graph.lens, graph.len, u, NULL);
            size_t __tmp0_len = map_len_il(graph.keys, graph.vals, graph.lens, graph.len, u);
            for (size_t __i = 0; __i < __tmp0_len; __i++) {
                long long *e = __tmp0[__i];
                size_t e_len = __tmp0_lens[__i];
                const char v = e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                const char w = e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                if (!(in_list(keys, keys_len, v))) {
                    keys = list_append_long_long(keys, &keys_len, v);
                }
                long long cur;
                if (contains_map_int(dist.keys, dist.len, v)) {
                    cur = map_get_ii(dist.keys, dist.vals, dist.len, v);
                } else {
                    cur = INF;
                }
                if (!(in_list(known, known_len, v)) && (w < cur)) {
                    map_set_ii(&dist, v, w);
                    map_set_ii(&parent, v, u);
                }
            }
        }
    }
    long long **edges = NULL;
    size_t edges_len = 0;
    size_t *edges_lens = NULL;
    size_t edges_lens_len = 0;
    long long j = 0LL;
    while (j < keys_len) {
        long long v = keys[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? keys_len + _mochi_idx : _mochi_idx;})];
        if (v != s) {
            edges = list_append_intptr(edges, &edges_len, ({long long* tmp = malloc(2 * sizeof(long long)); tmp[0] = v + 1LL; tmp[1] = map_get_ii(parent.keys, parent.vals, parent.len, v) + 1LL; tmp;}));
            edges_lens = list_append_szt(edges_lens, &edges_lens_len, 2);
        }
        j = j + 1LL;
    }
    return prim_lens = edges_lens, prim_len = edges_len, edges;
}

long long * sort_heap(long long * h, size_t h_len, MapII dist) {
    long long *a = h;
    size_t a_len = h_len;
    long long i = 0LL;
    while (i < a_len) {
        long long j = 0LL;
        while (j < ((a_len - i) - 1LL)) {
            long long dj;
            if (contains_map_int(dist.keys, dist.len, a[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})])) {
                dj = map_get_ii(dist.keys, dist.vals, dist.len, a[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})]);
            } else {
                dj = INF;
            }
            long long dj1;
            if (contains_map_int(dist.keys, dist.len, a[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})])) {
                dj1 = map_get_ii(dist.keys, dist.vals, dist.len, a[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})]);
            } else {
                dj1 = INF;
            }
            if (dj > dj1) {
                long long t = a[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})];
                a[(int)(j)] = a[(int)({long long _mochi_idx = j + 1LL; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})];
                a[(int)(j + 1LL)] = t;
            }
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    return sort_heap_len = a_len, a;
}

long long * * prim_heap(int graph, long long s, long long n) {
    MapII dist = { NULL, NULL, 0, 0 };
    MapII parent = { NULL, NULL, 0, 0 };
    map_set_ii(&dist, s, 0LL);
    map_set_ii(&parent, s, -1LL);
    long long *h = NULL;
    size_t h_len = 0;
    long long i = 0LL;
    while (i < n) {
        h = list_append_long_long(h, &h_len, i);
        i = i + 1LL;
    }
    h = sort_heap(h, h_len, dist);
    h_len = sort_heap_len;
    long long *known = NULL;
    size_t known_len = 0;
    while (h_len > 0LL) {
        long long u = h[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? h_len + _mochi_idx : _mochi_idx;})];
        h = _slice_int(h, h_len, 1LL, h_len, &(_slice_int_len));
        h_len = _slice_int_len;
        known = list_append_long_long(known, &known_len, u);
        {
            long long[]* __tmp1 = map_get_il(graph.keys, graph.vals, graph.lens, graph.len, u, NULL);
            size_t __tmp1_len = map_len_il(graph.keys, graph.vals, graph.lens, graph.len, u);
            for (size_t __i = 0; __i < __tmp1_len; __i++) {
                long long *e = __tmp1[__i];
                size_t e_len = __tmp1_lens[__i];
                const char v = e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                const char w = e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})];
                long long cur;
                if (contains_map_int(dist.keys, dist.len, v)) {
                    cur = map_get_ii(dist.keys, dist.vals, dist.len, v);
                } else {
                    cur = INF;
                }
                if (!(in_list(known, known_len, v)) && (w < cur)) {
                    map_set_ii(&dist, v, w);
                    map_set_ii(&parent, v, u);
                }
            }
        }
        h = sort_heap(h, h_len, dist);
        h_len = sort_heap_len;
    }
    long long **edges = NULL;
    size_t edges_len = 0;
    size_t *edges_lens = NULL;
    size_t edges_lens_len = 0;
    long long j = 0LL;
    while (j < n) {
        if (j != s) {
            edges = list_append_intptr(edges, &edges_len, ({long long* tmp = malloc(2 * sizeof(long long)); tmp[0] = j + 1LL; tmp[1] = map_get_ii(parent.keys, parent.vals, parent.len, j) + 1LL; tmp;}));
            edges_lens = list_append_szt(edges_lens, &edges_lens_len, 2);
        }
        j = j + 1LL;
    }
    return prim_heap_lens = edges_lens, prim_heap_len = edges_len, edges;
}

void print_edges(long long * * edges, size_t edges_len, size_t* edges_lens, size_t edges_lens_len) {
    long long i = 0LL;
    while (i < edges_len) {
        long long *e = edges[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? edges_len + _mochi_idx : _mochi_idx;})];
        size_t e_len = edges_lens[i];
        puts(str_concat(str_concat(str_concat(str_concat("(", str_int(e[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})])), ", "), str_int(e[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? e_len + _mochi_idx : _mochi_idx;})])), ")"));
        i = i + 1LL;
    }
}

void test_vector() {
    long long x = 5LL;
    static int G_keys[16] = {};
    static void* G_vals[16] = {};
    static size_t G_lens[16] = {};
    size_t G_len = 0;
    MapIL G = { G_keys, G_vals, G_lens, 0, 16 };
    long long i = 0LL;
    while (i < x) {
        map_set_il(&G.keys, &G.vals, &G.lens, &G.len, &G.cap, i, NULL, 0);
        i = i + 1LL;
    }
    G = connect(G, 1LL, 2LL, 15LL);
    G = connect(G, 1LL, 3LL, 12LL);
    G = connect(G, 2LL, 4LL, 13LL);
    G = connect(G, 2LL, 5LL, 5LL);
    G = connect(G, 3LL, 2LL, 6LL);
    G = connect(G, 3LL, 4LL, 6LL);
    long long **mst = prim(G, 0LL, x);
    size_t mst_len = prim_len;
    size_t *mst_lens = prim_lens;
    size_t mst_lens_len = prim_len;
    print_edges(mst, mst_len, mst_lens, mst_len);
    long long **mst_heap = prim_heap(G, 0LL, x);
    size_t mst_heap_len = prim_heap_len;
    size_t *mst_heap_lens = prim_heap_lens;
    size_t mst_heap_lens_len = prim_heap_len;
    print_edges(mst_heap, mst_heap_len, mst_heap_lens, mst_heap_len);
}

int main(void) {
    {
        long long __start = _now();
        test_vector();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
