// Generated by Mochi 0.10.32 on 2025-08-14 09:53 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t remove_node_at_len;
size_t append_pos_list_len;
size_t reverse_pos_list_len;
size_t concat_pos_lists_len;
size_t get_successors_len;
size_t astar_len;
size_t combine_paths_len;
size_t bidirectional_astar_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Pos Pos;
typedef struct Node Node;

struct Pos {
    long long y;
    long long x;
};

struct Node {
    Pos pos;
    long long g_cost;
    double h_cost;
    double f_cost;
    Pos *path;
    size_t path_len;
};

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static Pos* list_append_Pos(Pos *arr, size_t *len, Pos val) {
    arr = realloc(arr, (*len + 1) * sizeof(Pos));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long HEURISTIC = 0LL;
long long **grid = NULL;
size_t grid_len = 0;
size_t *grid_lens = NULL;
size_t grid_lens_len = 0;
long long **delta = NULL;
size_t delta_len = 0;
size_t *delta_lens = NULL;
size_t delta_lens_len = 0;
Pos start = (Pos){.y = 0LL, .x = 0LL};
Pos goal;
Pos *path1 = NULL;
size_t path1_len = 0;
Pos *path2 = NULL;
size_t path2_len = 0;

long long user_abs(long long x);
double sqrtApprox(double x);
double heuristic(Pos a, Pos b);
long long pos_equal(Pos a, Pos b);
long long contains_pos(Pos * lst, size_t lst_len, Pos p);
long long open_index_of_pos(Node * open, size_t open_len, Pos p);
Node * remove_node_at(Node * nodes, size_t nodes_len, long long idx);
Pos * append_pos_list(Pos * path, size_t path_len, Pos p);
Pos * reverse_pos_list(Pos * lst, size_t lst_len);
Pos * concat_pos_lists(Pos * a, size_t a_len, Pos * b, size_t b_len);
Pos * get_successors(Pos p);
long long find_lowest_f(Node * open, size_t open_len);
Pos * astar(Pos start, Pos goal);
Pos * combine_paths(Node fwd, Node bwd);
Pos * bidirectional_astar(Pos start, Pos goal);
const char* path_to_string(Pos * path, size_t path_len);
int main(void);

long long user_abs(long long x) {
    if (x < 0LL) {
        return -(x);
    }
    return x;
}

double sqrtApprox(double x) {
    if (x <= 0.0) {
        return 0.0;
    }
    double guess = x;
    long long i = 0LL;
    while (i < 10LL) {
        guess = (guess + (x / guess)) / 2.0;
        i = i + 1LL;
    }
    return guess;
}

double heuristic(Pos a, Pos b) {
    long long dy = a.y - b.y;
    long long dx = a.x - b.x;
    if (HEURISTIC == 1LL) {
        return user_abs(dy) + user_abs(dx);
    }
    double dyf = (double)(dy);
    double dxf = (double)(dx);
    return sqrtApprox((dyf * dyf) + (dxf * dxf));
}

long long pos_equal(Pos a, Pos b) {
    return (a.y == b.y) && (a.x == b.x);
}

long long contains_pos(Pos * lst, size_t lst_len, Pos p) {
    long long i = 0LL;
    while (i < lst_len) {
        if (pos_equal(lst[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? lst_len + _mochi_idx : _mochi_idx;})], p)) {
            return 1LL;
        }
        i = i + 1LL;
    }
    return 0LL;
}

long long open_index_of_pos(Node * open, size_t open_len, Pos p) {
    long long i = 0LL;
    while (i < open_len) {
        if (pos_equal(open[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})].pos, p)) {
            return i;
        }
        i = i + 1LL;
    }
    return -1LL;
}

Node * remove_node_at(Node * nodes, size_t nodes_len, long long idx) {
    Node *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < nodes_len) {
        if (i != idx) {
            res = list_append_Node(res, &res_len, nodes[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? nodes_len + _mochi_idx : _mochi_idx;})]);
        }
        i = i + 1LL;
    }
    return remove_node_at_len = res_len, res;
}

Pos * append_pos_list(Pos * path, size_t path_len, Pos p) {
    Pos *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < path_len) {
        res = list_append_Pos(res, &res_len, path[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    res = list_append_Pos(res, &res_len, p);
    return append_pos_list_len = res_len, res;
}

Pos * reverse_pos_list(Pos * lst, size_t lst_len) {
    Pos *res = NULL;
    size_t res_len = 0;
    long long i = lst_len - 1LL;
    while (i >= 0LL) {
        res = list_append_Pos(res, &res_len, lst[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? lst_len + _mochi_idx : _mochi_idx;})]);
        i = i - 1LL;
    }
    return reverse_pos_list_len = res_len, res;
}

Pos * concat_pos_lists(Pos * a, size_t a_len, Pos * b, size_t b_len) {
    Pos *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < a_len) {
        res = list_append_Pos(res, &res_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    long long j = 0LL;
    while (j < b_len) {
        res = list_append_Pos(res, &res_len, b[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})]);
        j = j + 1LL;
    }
    return concat_pos_lists_len = res_len, res;
}

Pos * get_successors(Pos p) {
    Pos *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < delta_len) {
        long long nx = p.x + delta[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? delta_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? delta_lens[i] + _mochi_idx : _mochi_idx;})];
        long long ny = p.y + delta[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? delta_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? delta_lens[i] + _mochi_idx : _mochi_idx;})];
        if ((((nx >= 0LL) && (ny >= 0LL)) && (nx < grid_lens[0LL])) && (ny < grid_len)) {
            if (grid[(int)({long long _mochi_idx = ny; _mochi_idx < 0 ? grid_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = nx; _mochi_idx < 0 ? grid_lens[ny] + _mochi_idx : _mochi_idx;})] == 0LL) {
                res = list_append_Pos(res, &res_len, (Pos){.y = ny, .x = nx});
            }
        }
        i = i + 1LL;
    }
    return get_successors_len = res_len, res;
}

long long find_lowest_f(Node * open, size_t open_len) {
    long long best = 0LL;
    long long i = 1LL;
    while (i < open_len) {
        if (open[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})].f_cost < open[(int)({long long _mochi_idx = best; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})].f_cost) {
            best = i;
        }
        i = i + 1LL;
    }
    return best;
}

Pos * astar(Pos start, Pos goal) {
    double h0 = heuristic(start, goal);
    Node *open = NULL;
    size_t open_len = 0;
    open = list_append_Node(open, &open_len, (Node){.pos = start, .g_cost = 0LL, .h_cost = h0, .f_cost = h0, .path = ({Pos *tmp = malloc(1 * sizeof(Pos)); tmp[0] = start; tmp;}), .path_len = 1});
    Pos *closed = NULL;
    size_t closed_len = 0;
    while (open_len > 0LL) {
        long long idx = find_lowest_f(open, open_len);
        Node current = open[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})];
        open = remove_node_at(open, open_len, idx);
        open_len = remove_node_at_len;
        if (pos_equal(current.pos, goal)) {
            return astar_len = current.path_len, current.path;
        }
        closed = list_append_Pos(closed, &closed_len, current.pos);
        Pos *succ = get_successors(current.pos);
        size_t succ_len = get_successors_len;
        long long i = 0LL;
        while (i < succ_len) {
            Pos pos = succ[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? succ_len + _mochi_idx : _mochi_idx;})];
            if (contains_pos(closed, closed_len, pos)) {
                i = i + 1LL;
                continue;
            }
            long long tentative_g = current.g_cost + 1LL;
            long long idx_open = open_index_of_pos(open, open_len, pos);
            if ((idx_open == (0LL - 1LL)) || (tentative_g < open[(int)({long long _mochi_idx = idx_open; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})].g_cost)) {
                Pos *new_path = append_pos_list(current.path, current.path_len, pos);
                size_t new_path_len = append_pos_list_len;
                double h = heuristic(pos, goal);
                double f = (double)(tentative_g) + h;
                if (idx_open != (0LL - 1LL)) {
                    open = remove_node_at(open, open_len, idx_open);
                    open_len = remove_node_at_len;
                }
                open = list_append_Node(open, &open_len, (Node){.pos = pos, .g_cost = tentative_g, .h_cost = h, .f_cost = f, .path = new_path, .path_len = new_path_len});
            }
            i = i + 1LL;
        }
    }
    {
        Pos* __tmp0_data = malloc(1 * sizeof(Pos));
        __tmp0_data[0] = start;
        astar_len = 1;
        return __tmp0_data;
    }
}

Pos * combine_paths(Node fwd, Node bwd) {
    Pos *bwd_copy = NULL;
    size_t bwd_copy_len = 0;
    long long i = 0LL;
    while (i < (bwd.path_len - 1LL)) {
        bwd_copy = list_append_Pos(bwd_copy, &bwd_copy_len, bwd.path[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? bwd.path_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    bwd_copy = reverse_pos_list(bwd_copy, bwd_copy_len);
    bwd_copy_len = reverse_pos_list_len;
    {
        Pos* __ret1 = concat_pos_lists(fwd.path, fwd.path_len, bwd_copy, bwd_copy_len);
        combine_paths_len = concat_pos_lists_len;
        return __ret1;
    }
}

Pos * bidirectional_astar(Pos start, Pos goal) {
    double hf = heuristic(start, goal);
    double hb = heuristic(goal, start);
    Node *open_f = NULL;
    size_t open_f_len = 0;
    open_f = list_append_Node(open_f, &open_f_len, (Node){.pos = start, .g_cost = 0LL, .h_cost = hf, .f_cost = hf, .path = ({Pos *tmp = malloc(1 * sizeof(Pos)); tmp[0] = start; tmp;}), .path_len = 1});
    Node *open_b = NULL;
    size_t open_b_len = 0;
    open_b = list_append_Node(open_b, &open_b_len, (Node){.pos = goal, .g_cost = 0LL, .h_cost = hb, .f_cost = hb, .path = ({Pos *tmp = malloc(1 * sizeof(Pos)); tmp[0] = goal; tmp;}), .path_len = 1});
    Pos *closed_f = NULL;
    size_t closed_f_len = 0;
    Pos *closed_b = NULL;
    size_t closed_b_len = 0;
    while ((open_f_len > 0LL) && (open_b_len > 0LL)) {
        long long idx_f = find_lowest_f(open_f, open_f_len);
        Node current_f = open_f[(int)({long long _mochi_idx = idx_f; _mochi_idx < 0 ? open_f_len + _mochi_idx : _mochi_idx;})];
        open_f = remove_node_at(open_f, open_f_len, idx_f);
        open_f_len = remove_node_at_len;
        long long idx_b = find_lowest_f(open_b, open_b_len);
        Node current_b = open_b[(int)({long long _mochi_idx = idx_b; _mochi_idx < 0 ? open_b_len + _mochi_idx : _mochi_idx;})];
        open_b = remove_node_at(open_b, open_b_len, idx_b);
        open_b_len = remove_node_at_len;
        if (pos_equal(current_f.pos, current_b.pos)) {
            {
                Pos* __ret2 = combine_paths(current_f, current_b);
                bidirectional_astar_len = combine_paths_len;
                return __ret2;
            }
        }
        closed_f = list_append_Pos(closed_f, &closed_f_len, current_f.pos);
        closed_b = list_append_Pos(closed_b, &closed_b_len, current_b.pos);
        Pos *succ_f = get_successors(current_f.pos);
        size_t succ_f_len = get_successors_len;
        long long i = 0LL;
        while (i < succ_f_len) {
            Pos pos = succ_f[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? succ_f_len + _mochi_idx : _mochi_idx;})];
            if (contains_pos(closed_f, closed_f_len, pos)) {
                i = i + 1LL;
                continue;
            }
            long long tentative_g = current_f.g_cost + 1LL;
            double h = heuristic(pos, current_b.pos);
            double f = (double)(tentative_g) + h;
            long long idx_open = open_index_of_pos(open_f, open_f_len, pos);
            if ((idx_open == (0LL - 1LL)) || (tentative_g < open_f[(int)({long long _mochi_idx = idx_open; _mochi_idx < 0 ? open_f_len + _mochi_idx : _mochi_idx;})].g_cost)) {
                Pos *new_path = append_pos_list(current_f.path, current_f.path_len, pos);
                size_t new_path_len = append_pos_list_len;
                if (idx_open != (0LL - 1LL)) {
                    open_f = remove_node_at(open_f, open_f_len, idx_open);
                    open_f_len = remove_node_at_len;
                }
                open_f = list_append_Node(open_f, &open_f_len, (Node){.pos = pos, .g_cost = tentative_g, .h_cost = h, .f_cost = f, .path = new_path, .path_len = new_path_len});
            }
            i = i + 1LL;
        }
        Pos *succ_b = get_successors(current_b.pos);
        size_t succ_b_len = get_successors_len;
        i = 0LL;
        while (i < succ_b_len) {
            Pos pos = succ_b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? succ_b_len + _mochi_idx : _mochi_idx;})];
            if (contains_pos(closed_b, closed_b_len, pos)) {
                i = i + 1LL;
                continue;
            }
            long long tentative_g = current_b.g_cost + 1LL;
            double h = heuristic(pos, current_f.pos);
            double f = (double)(tentative_g) + h;
            long long idx_open = open_index_of_pos(open_b, open_b_len, pos);
            if ((idx_open == (0LL - 1LL)) || (tentative_g < open_b[(int)({long long _mochi_idx = idx_open; _mochi_idx < 0 ? open_b_len + _mochi_idx : _mochi_idx;})].g_cost)) {
                Pos *new_path = append_pos_list(current_b.path, current_b.path_len, pos);
                size_t new_path_len = append_pos_list_len;
                if (idx_open != (0LL - 1LL)) {
                    open_b = remove_node_at(open_b, open_b_len, idx_open);
                    open_b_len = remove_node_at_len;
                }
                open_b = list_append_Node(open_b, &open_b_len, (Node){.pos = pos, .g_cost = tentative_g, .h_cost = h, .f_cost = f, .path = new_path, .path_len = new_path_len});
            }
            i = i + 1LL;
        }
    }
    {
        Pos* __tmp3_data = malloc(1 * sizeof(Pos));
        __tmp3_data[0] = start;
        bidirectional_astar_len = 1;
        return __tmp3_data;
    }
}

const char* path_to_string(Pos * path, size_t path_len) {
    if (path_len == 0LL) {
        return "[]";
    }
    const char* s = str_concat(str_concat(str_concat(str_concat("[(", str_int(path[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})].y)), ", "), str_int(path[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})].x)), ")");
    long long i = 1LL;
    while (i < path_len) {
        s = str_concat(str_concat(str_concat(str_concat(str_concat(s, ", ("), str_int(path[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})].y)), ", "), str_int(path[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})].x)), ")");
        i = i + 1LL;
    }
    s = str_concat(s, "]");
    return s;
}

int main(void) {
    {
        long long __start = _now();
        grid = ({long long** tmp = malloc(7 * sizeof(long long*)); tmp[0] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[1] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 1LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[2] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[3] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 1LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[4] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 0LL; tmp[2] = 1LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[5] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 0LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp[6] = ({long long *tmp = malloc(7 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 0LL; tmp[2] = 0LL; tmp[3] = 0LL; tmp[4] = 1LL; tmp[5] = 0LL; tmp[6] = 0LL; tmp;}); tmp;});
        grid_len = 7;
        grid_lens = ({size_t *tmp = malloc(7 * sizeof(size_t)); tmp[0] = 7; tmp[1] = 7; tmp[2] = 7; tmp[3] = 7; tmp[4] = 7; tmp[5] = 7; tmp[6] = 7; tmp;});
        grid_lens_len = 7;
        delta = ({int** tmp = malloc(4 * sizeof(int*)); tmp[0] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = -1.0; tmp[1] = 0LL; tmp;}); tmp[1] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = -1.0; tmp;}); tmp[2] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1LL; tmp[1] = 0LL; tmp;}); tmp[3] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 0LL; tmp[1] = 1LL; tmp;}); tmp;});
        delta_len = 4;
        delta_lens = ({size_t *tmp = malloc(4 * sizeof(size_t)); tmp[0] = 2; tmp[1] = 2; tmp[2] = 2; tmp[3] = 2; tmp;});
        delta_lens_len = 4;
        goal = (Pos){.y = grid_len - 1LL, .x = grid_lens[0LL] - 1LL};
        path1 = astar(start, goal);
        path1_len = astar_len;
        puts(path_to_string(path1, path1_len));
        path2 = bidirectional_astar(start, goal);
        path2_len = bidirectional_astar_len;
        puts(path_to_string(path2, path2_len));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
