// Generated by Mochi 0.10.32 on 2025-08-14 21:29 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>


size_t append_len;
static int contains_str(const char *arr[], size_t len, const char *val) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(arr[i], val) == 0) return 1;
    }
    return 0;
}

typedef struct { const char **keys; int *vals; size_t len; size_t cap; } MapSI;

typedef struct { const char **keys; MapSI *vals; size_t len; size_t cap; } MapSMI;

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static void map_set_si(MapSI *m, const char *key, int val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc(m->vals, m->cap * sizeof(int));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static MapSI map_get_smi(const char *keys[], const MapSI vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return (MapSI){0};
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct NodeCost NodeCost;

struct NodeCost {
    const char* node;
    long long cost;
};

static NodeCost* list_append_NodeCost(NodeCost *arr, size_t *len, NodeCost val) {
    arr = realloc(arr, (*len + 1) * sizeof(NodeCost));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char* G_keys[22] = {"A", "B", "C", "D", "E", "F"};
static const char* G_vals_0_keys[2] = {"B", "C"};
static int G_vals_0_vals[2] = {2LL, 5LL};
static const char* G_vals_1_keys[4] = {"A", "D", "E", "F"};
static int G_vals_1_vals[4] = {2LL, 3LL, 1LL, 1LL};
static const char* G_vals_2_keys[2] = {"A", "F"};
static int G_vals_2_vals[2] = {5LL, 3LL};
static const char* G_vals_3_keys[1] = {"B"};
static int G_vals_3_vals[1] = {3LL};
static const char* G_vals_4_keys[2] = {"B", "F"};
static int G_vals_4_vals[2] = {4LL, 3LL};
static const char* G_vals_5_keys[2] = {"C", "E"};
static int G_vals_5_vals[2] = {3LL, 3LL};
static MapSI G_vals[22] = {{ G_vals_0_keys, G_vals_0_vals, 2, 18 }, { G_vals_1_keys, G_vals_1_vals, 4, 20 }, { G_vals_2_keys, G_vals_2_vals, 2, 18 }, { G_vals_3_keys, G_vals_3_vals, 1, 17 }, { G_vals_4_keys, G_vals_4_vals, 2, 18 }, { G_vals_5_keys, G_vals_5_vals, 2, 18 }};
size_t G_len = 6;
MapSMI G = { G_keys, G_vals, 6, 22 };
NodeCost heap_init[1] = {(NodeCost){.node = "E", .cost = 0LL}};
NodeCost *heap = heap_init;
size_t heap_len = 1;
double result = -1LL;
NodeCost heap2_init[1] = {(NodeCost){.node = "E", .cost = 0LL}};
NodeCost *heap2 = heap2_init;
size_t heap2_len = 1;
double result2 = -1LL;
NodeCost heap3_init[1] = {(NodeCost){.node = "E", .cost = 0LL}};
NodeCost *heap3 = heap3_init;
size_t heap3_len = 1;
double result3 = -1LL;

int main(void);

int main(void) {
    static const char* visited_keys[16] = {};
    static int visited_vals[16] = {};
    size_t visited_len = 0;
    MapSI visited = { visited_keys, visited_vals, 0, 16 };
    while (heap_len > 0LL) {
        long long best_idx = 0LL;
        long long i = 1LL;
        while (i < heap_len) {
            if (heap[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? heap_len + _mochi_idx : _mochi_idx;})].cost < heap[(int)({long long _mochi_idx = best_idx; _mochi_idx < 0 ? heap_len + _mochi_idx : _mochi_idx;})].cost) {
                best_idx = i;
            }
            i = i + 1LL;
        }
        NodeCost best = heap[(int)({long long _mochi_idx = best_idx; _mochi_idx < 0 ? heap_len + _mochi_idx : _mochi_idx;})];
        NodeCost *new_heap = NULL;
        size_t new_heap_len = 0;
        long long j = 0LL;
        while (j < heap_len) {
            if (j != best_idx) {
                new_heap = list_append_NodeCost(new_heap, &new_heap_len, heap[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? heap_len + _mochi_idx : _mochi_idx;})]);
            }
            j = j + 1LL;
        }
        heap = new_heap;
        heap_len = new_heap_len;
        const char* u = best.node;
        long long cost = best.cost;
        if (contains_str(visited.keys, visited.len, u)) {
            continue;
        }
        map_set_si(&visited, u, 1LL);
        if (strcmp(u, "C") == 0) {
            result = cost;
            break;
        }
        MapSI __tmp0 = map_get_smi(G.keys, G.vals, G.len, u);
        for (size_t __i = 0; __i < __tmp0.len; __i++) {
            const char* v = __tmp0.keys[__i];
            if (contains_str(visited.keys, visited.len, v)) {
                continue;
            }
            long long next_cost = cost + map_get_si(map_get_smi(G.keys, G.vals, G.len, u).keys, map_get_smi(G.keys, G.vals, G.len, u).vals, map_get_smi(G.keys, G.vals, G.len, u).len, v);
            heap = list_append_NodeCost(heap, &heap_len, (NodeCost){.node = v, .cost = next_cost});
        }
    }
    printf("%g\n", result);
    const char* G2_keys[21] = {"B", "C", "D", "E", "F"};
    const char* G2_vals_0_keys[1] = {"C"};
    int G2_vals_0_vals[1] = {1LL};
    const char* G2_vals_1_keys[1] = {"D"};
    int G2_vals_1_vals[1] = {1LL};
    const char* G2_vals_2_keys[1] = {"F"};
    int G2_vals_2_vals[1] = {1LL};
    const char* G2_vals_3_keys[2] = {"B", "F"};
    int G2_vals_3_vals[2] = {1LL, 3LL};
    const char* G2_vals_4_keys[0] = {};
    int G2_vals_4_vals[0] = {};
    MapSI G2_vals[21] = {{ G2_vals_0_keys, G2_vals_0_vals, 1, 17 }, { G2_vals_1_keys, G2_vals_1_vals, 1, 17 }, { G2_vals_2_keys, G2_vals_2_vals, 1, 17 }, { G2_vals_3_keys, G2_vals_3_vals, 2, 18 }, { G2_vals_4_keys, G2_vals_4_vals, 0, 16 }};
    size_t G2_len = 5;
    MapSMI G2 = { G2_keys, G2_vals, 5, 21 };
    static const char* visited2_keys[16] = {};
    static int visited2_vals[16] = {};
    size_t visited2_len = 0;
    MapSI visited2 = { visited2_keys, visited2_vals, 0, 16 };
    while (heap2_len > 0LL) {
        long long best2_idx = 0LL;
        long long i2 = 1LL;
        while (i2 < heap2_len) {
            if (heap2[(int)({long long _mochi_idx = i2; _mochi_idx < 0 ? heap2_len + _mochi_idx : _mochi_idx;})].cost < heap2[(int)({long long _mochi_idx = best2_idx; _mochi_idx < 0 ? heap2_len + _mochi_idx : _mochi_idx;})].cost) {
                best2_idx = i2;
            }
            i2 = i2 + 1LL;
        }
        NodeCost best2 = heap2[(int)({long long _mochi_idx = best2_idx; _mochi_idx < 0 ? heap2_len + _mochi_idx : _mochi_idx;})];
        NodeCost *new_heap2 = NULL;
        size_t new_heap2_len = 0;
        long long j2 = 0LL;
        while (j2 < heap2_len) {
            if (j2 != best2_idx) {
                new_heap2 = list_append_NodeCost(new_heap2, &new_heap2_len, heap2[(int)({long long _mochi_idx = j2; _mochi_idx < 0 ? heap2_len + _mochi_idx : _mochi_idx;})]);
            }
            j2 = j2 + 1LL;
        }
        heap2 = new_heap2;
        heap2_len = new_heap2_len;
        const char* u2 = best2.node;
        long long cost2 = best2.cost;
        if (contains_str(visited2.keys, visited2.len, u2)) {
            continue;
        }
        map_set_si(&visited2, u2, 1LL);
        if (strcmp(u2, "F") == 0) {
            result2 = cost2;
            break;
        }
        MapSI __tmp1 = map_get_smi(G2.keys, G2.vals, G2.len, u2);
        for (size_t __i = 0; __i < __tmp1.len; __i++) {
            const char* v2 = __tmp1.keys[__i];
            if (contains_str(visited2.keys, visited2.len, v2)) {
                continue;
            }
            long long next_cost2 = cost2 + map_get_si(map_get_smi(G2.keys, G2.vals, G2.len, u2).keys, map_get_smi(G2.keys, G2.vals, G2.len, u2).vals, map_get_smi(G2.keys, G2.vals, G2.len, u2).len, v2);
            heap2 = list_append_NodeCost(heap2, &heap2_len, (NodeCost){.node = v2, .cost = next_cost2});
        }
    }
    printf("%g\n", result2);
    const char* G3_keys[22] = {"B", "C", "D", "E", "F", "G"};
    const char* G3_vals_0_keys[1] = {"C"};
    int G3_vals_0_vals[1] = {1LL};
    const char* G3_vals_1_keys[1] = {"D"};
    int G3_vals_1_vals[1] = {1LL};
    const char* G3_vals_2_keys[1] = {"F"};
    int G3_vals_2_vals[1] = {1LL};
    const char* G3_vals_3_keys[2] = {"B", "G"};
    int G3_vals_3_vals[2] = {1LL, 2LL};
    const char* G3_vals_4_keys[0] = {};
    int G3_vals_4_vals[0] = {};
    const char* G3_vals_5_keys[1] = {"F"};
    int G3_vals_5_vals[1] = {1LL};
    MapSI G3_vals[22] = {{ G3_vals_0_keys, G3_vals_0_vals, 1, 17 }, { G3_vals_1_keys, G3_vals_1_vals, 1, 17 }, { G3_vals_2_keys, G3_vals_2_vals, 1, 17 }, { G3_vals_3_keys, G3_vals_3_vals, 2, 18 }, { G3_vals_4_keys, G3_vals_4_vals, 0, 16 }, { G3_vals_5_keys, G3_vals_5_vals, 1, 17 }};
    size_t G3_len = 6;
    MapSMI G3 = { G3_keys, G3_vals, 6, 22 };
    static const char* visited3_keys[16] = {};
    static int visited3_vals[16] = {};
    size_t visited3_len = 0;
    MapSI visited3 = { visited3_keys, visited3_vals, 0, 16 };
    while (heap3_len > 0LL) {
        long long best3_idx = 0LL;
        long long i3 = 1LL;
        while (i3 < heap3_len) {
            if (heap3[(int)({long long _mochi_idx = i3; _mochi_idx < 0 ? heap3_len + _mochi_idx : _mochi_idx;})].cost < heap3[(int)({long long _mochi_idx = best3_idx; _mochi_idx < 0 ? heap3_len + _mochi_idx : _mochi_idx;})].cost) {
                best3_idx = i3;
            }
            i3 = i3 + 1LL;
        }
        NodeCost best3 = heap3[(int)({long long _mochi_idx = best3_idx; _mochi_idx < 0 ? heap3_len + _mochi_idx : _mochi_idx;})];
        NodeCost *new_heap3 = NULL;
        size_t new_heap3_len = 0;
        long long j3 = 0LL;
        while (j3 < heap3_len) {
            if (j3 != best3_idx) {
                new_heap3 = list_append_NodeCost(new_heap3, &new_heap3_len, heap3[(int)({long long _mochi_idx = j3; _mochi_idx < 0 ? heap3_len + _mochi_idx : _mochi_idx;})]);
            }
            j3 = j3 + 1LL;
        }
        heap3 = new_heap3;
        heap3_len = new_heap3_len;
        const char* u3 = best3.node;
        long long cost3 = best3.cost;
        if (contains_str(visited3.keys, visited3.len, u3)) {
            continue;
        }
        map_set_si(&visited3, u3, 1LL);
        if (strcmp(u3, "F") == 0) {
            result3 = cost3;
            break;
        }
        MapSI __tmp2 = map_get_smi(G3.keys, G3.vals, G3.len, u3);
        for (size_t __i = 0; __i < __tmp2.len; __i++) {
            const char* v3 = __tmp2.keys[__i];
            if (contains_str(visited3.keys, visited3.len, v3)) {
                continue;
            }
            long long next_cost3 = cost3 + map_get_si(map_get_smi(G3.keys, G3.vals, G3.len, u3).keys, map_get_smi(G3.keys, G3.vals, G3.len, u3).vals, map_get_smi(G3.keys, G3.vals, G3.len, u3).len, v3);
            heap3 = list_append_NodeCost(heap3, &heap3_len, (NodeCost){.node = v3, .cost = next_cost3});
        }
    }
    printf("%g\n", result3);
    return 0;
}
