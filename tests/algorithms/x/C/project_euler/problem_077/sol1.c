// Generated by Mochi 0.10.32 on 2025-08-23 21:18 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t generate_primes_len;
size_t partition_len;

size_t append_len;
static int contains_map_int(const int keys[], size_t len, int key) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) return 1;
    }
    return 0;
}

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { int *keys; void **vals; size_t *lens; size_t len; size_t cap; } MapIL;

static void* map_get_il(const int keys[], void *vals[], const size_t lens[], size_t len, int key, size_t *out_len) {
    for (size_t i = 0; i < len; i++) {
        if (keys[i] == key) { if (out_len) *out_len = lens[i]; return vals[i]; }
    }
    if (out_len) *out_len = 0;
    return NULL;
}

static void map_set_il(int **keys, void ***vals, size_t **lens, size_t *len, size_t *cap, int key, void *val, size_t val_len) {
    for (size_t i = 0; i < *len; i++) {
        if ((*keys)[i] == key) { (*vals)[i] = val; (*lens)[i] = val_len; return; }
    }
    if (*len >= *cap) {
        *cap = *cap ? *cap * 2 : 16;
        *keys = realloc(*keys, *cap * sizeof(int));
        *vals = realloc(*vals, *cap * sizeof(void*));
        *lens = realloc(*lens, *cap * sizeof(size_t));
    }
    (*keys)[*len] = key; (*vals)[*len] = val; (*lens)[*len] = val_len; (*len)++;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long NUM_PRIMES = 100LL;
long long *primes = NULL;
size_t primes_len = 0;
static int partition_cache_keys[16] = {};
static void* partition_cache_vals[16] = {};
static size_t partition_cache_lens[16] = {};
size_t partition_cache_len = 0;
MapIL partition_cache = { partition_cache_keys, partition_cache_vals, partition_cache_lens, 0, 16 };
long long result = 0;

long long * generate_primes(long long limit);
long long contains(long long * xs, size_t xs_len, long long value);
long long * partition(long long n);
long long solution(long long threshold);
int main(void);

long long * generate_primes(long long limit) {
    long long *is_prime = NULL;
    size_t is_prime_len = 0;
    long long i = 0LL;
    while (i <= limit) {
        is_prime = list_append_long_long(is_prime, &is_prime_len, 1LL);
        i = i + 1LL;
    }
    is_prime[(int)(0LL)] = 0LL;
    is_prime[(int)(1LL)] = 0LL;
    i = 2LL;
    while ((i * i) <= limit) {
        if (is_prime[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? is_prime_len + _mochi_idx : _mochi_idx;})]) {
            long long j = i * i;
            while (j <= limit) {
                is_prime[(int)(j)] = 0LL;
                j = j + i;
            }
        }
        i = i + 1LL;
    }
    long long *primes = NULL;
    size_t primes_len = 0;
    i = 2LL;
    while (i <= limit) {
        if (is_prime[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? is_prime_len + _mochi_idx : _mochi_idx;})]) {
            primes = list_append_long_long(primes, &primes_len, i);
        }
        i = i + 1LL;
    }
    return generate_primes_len = primes_len, primes;
}

long long contains(long long * xs, size_t xs_len, long long value) {
    long long i = 0LL;
    while (i < xs_len) {
        if (xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})] == value) {
            return 1LL;
        }
        i = i + 1LL;
    }
    return 0LL;
}

long long * partition(long long n) {
    if (n < 0LL) {
        {
            long long* __tmp0_data = malloc(0 * sizeof(long long));
            partition_len = 0;
            return __tmp0_data;
        }
    }
    if (n == 0LL) {
        {
            long long* __tmp1_data = malloc(1 * sizeof(long long));
            __tmp1_data[0] = 1LL;
            partition_len = 1;
            return __tmp1_data;
        }
    }
    if (contains_map_int(partition_cache.keys, partition_cache.len, n)) {
        return map_get_il(partition_cache.keys, partition_cache.vals, partition_cache.lens, partition_cache.len, n, NULL);
    }
    long long *ret = NULL;
    size_t ret_len = 0;
    for (size_t __i = 0; __i < primes_len; __i++) {
        long long prime = primes[__i];
        if (prime > n) {
            continue;
        }
        long long *subs = partition(n - prime);
        size_t subs_len = partition_len;
        for (size_t __i = 0; __i < subs_len; __i++) {
            long long sub = subs[__i];
            long long prod = sub * prime;
            if (!(contains(ret, ret_len, prod))) {
                ret = list_append_long_long(ret, &ret_len, prod);
            }
        }
    }
    map_set_il(&partition_cache.keys, &partition_cache.vals, &partition_cache.lens, &partition_cache.len, &partition_cache.cap, n, ret, ret_len);
    return partition_len = ret_len, ret;
}

long long solution(long long threshold) {
    long long number_to_partition = 1LL;
    while (number_to_partition < NUM_PRIMES) {
        long long *parts = partition(number_to_partition);
        size_t parts_len = partition_len;
        if (parts_len > threshold) {
            return number_to_partition;
        }
        number_to_partition = number_to_partition + 1LL;
    }
    return 0LL;
}

int main(void) {
    {
        long long __start = _now();
        primes = generate_primes(NUM_PRIMES);
        primes_len = generate_primes_len;
        result = solution(5000LL);
        puts(str_concat("solution() = ", str_int(result)));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
