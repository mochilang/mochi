// Generated by Mochi 0.10.32 on 2025-08-23 15:27 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t find_fractions_len;

size_t append_len;
static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Anon1 Anon1;
typedef struct FractionPair FractionPair;

struct Anon1 {
    const char* __name;
    const char* den;
    const char* num;
};

struct FractionPair {
    long long num;
    long long den;
};

static FractionPair* list_append_FractionPair(FractionPair *arr, size_t *len, FractionPair val) {
    arr = realloc(arr, (*len + 1) * sizeof(FractionPair));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long gcd(long long a, long long b);
long long is_digit_cancelling(long long num, long long den);
FractionPair * find_fractions();
long long solution();
void user_main();
int main(void);

long long gcd(long long a, long long b) {
    long long x;
    if (a < 0LL) {
        x = -(a);
    } else {
        x = a;
    }
    long long y;
    if (b < 0LL) {
        y = -(b);
    } else {
        y = b;
    }
    while (y != 0LL) {
        long long t = x % y;
        x = y;
        y = t;
    }
    return x;
}

long long is_digit_cancelling(long long num, long long den) {
    if (num >= den) {
        return 0LL;
    }
    long long num_unit = num % 10LL;
    long long num_tens = num / 10LL;
    long long den_unit = den % 10LL;
    long long den_tens = den / 10LL;
    if (num_unit != den_tens) {
        return 0LL;
    }
    if (den_unit == 0LL) {
        return 0LL;
    }
    return (num * den_unit) == (num_tens * den);
}

FractionPair * find_fractions() {
    FractionPair *sols = NULL;
    size_t sols_len = 0;
    long long num = 10LL;
    while (num < 100LL) {
        long long den = num + 1LL;
        while (den < 100LL) {
            if (is_digit_cancelling(num, den)) {
                sols = list_append_FractionPair(sols, &sols_len, (FractionPair){.num = num, .den = den});
            }
            den = den + 1LL;
        }
        num = num + 1LL;
    }
    return find_fractions_len = sols_len, sols;
}

long long solution() {
    FractionPair *fracs = find_fractions();
    size_t fracs_len = find_fractions_len;
    long long num_prod = 1LL;
    long long den_prod = 1LL;
    long long i = 0LL;
    while (i < fracs_len) {
        FractionPair f = fracs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? fracs_len + _mochi_idx : _mochi_idx;})];
        num_prod = num_prod * f.num;
        den_prod = den_prod * f.den;
        i = i + 1LL;
    }
    long long g = gcd(num_prod, den_prod);
    return den_prod / g;
}

void user_main() {
    puts(str_int(solution()));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
