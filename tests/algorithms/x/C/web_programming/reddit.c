// Generated by Mochi 0.10.32 on 2025-08-24 09:44 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

typedef struct { const char **keys; const char **vals; size_t len; size_t cap; } MapSS;

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static void map_set_ss(MapSS *m, const char *key, const char *val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc((void*)m->vals, m->cap * sizeof(char*));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct ListingData ListingData;
typedef struct Post Post;
typedef struct Child Child;
typedef struct Listing Listing;

struct ListingData {
    Child *children;
    size_t children_len;
};

struct Post {
    const char* title;
    const char* url;
    const char* selftext;
};

struct Child {
    Post data;
};

struct Listing {
    ListingData data;
};

const char* valid_terms_init[50] = {"approved_at_utc", "approved_by", "author_flair_background_color", "author_flair_css_class", "author_flair_richtext", "author_flair_template_id", "author_fullname", "author_premium", "can_mod_post", "category", "clicked", "content_categories", "created_utc", "downs", "edited", "gilded", "gildings", "hidden", "hide_score", "is_created_from_ads_ui", "is_meta", "is_original_content", "is_reddit_media_domain", "is_video", "link_flair_css_class", "link_flair_richtext", "link_flair_text", "link_flair_text_color", "media_embed", "mod_reason_title", "name", "permalink", "pwls", "quarantine", "saved", "score", "secure_media", "secure_media_embed", "selftext", "subreddit", "subreddit_name_prefixed", "subreddit_type", "thumbnail", "title", "top_awarded_type", "total_awards_received", "ups", "upvote_ratio", "url", "user_reports"};
const char* *valid_terms = valid_terms_init;
size_t valid_terms_len = 50;

long long contains(const char* * xs, size_t xs_len, const char* x);
const char* join_with_comma(const char* * xs, size_t xs_len);
int get_subreddit_data(const char* subreddit, long long limit, const char* age, const char* * wanted_data, size_t wanted_data_len);
int main(void);

long long contains(const char* * xs, size_t xs_len, const char* x) {
    long long i = 0LL;
    while (i < xs_len) {
        if (strcmp(xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})], x) == 0) {
            return 1LL;
        }
        i = i + 1LL;
    }
    return 0LL;
}

const char* join_with_comma(const char* * xs, size_t xs_len) {
    const char* s = "";
    long long i = 0LL;
    while (i < xs_len) {
        if (i > 0LL) {
            s = str_concat(s, ", ");
        }
        s = str_concat(s, xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    return s;
}

int get_subreddit_data(const char* subreddit, long long limit, const char* age, const char* * wanted_data, size_t wanted_data_len) {
    const char* *invalid = NULL;
    size_t invalid_len = 0;
    long long i = 0LL;
    while (i < wanted_data_len) {
        const char* term = wanted_data[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? wanted_data_len + _mochi_idx : _mochi_idx;})];
        if (!(contains(valid_terms, valid_terms_len, term))) {
            invalid = list_append_str(invalid, &invalid_len, term);
        }
        i = i + 1LL;
    }
    if (invalid_len > 0LL) {
        const char* msg = str_concat("Invalid search term: ", join_with_comma(invalid, invalid_len));
        panic(msg);
    }
    Listing resp;
    static int result_keys[16] = {};
    static MapSS result_vals[16] = {};
    size_t result_len = 0;
    long long idx = 0LL;
    while (idx < limit) {
        Post post = resp.data.children[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? resp.data.children_len + _mochi_idx : _mochi_idx;})].data;
        MapSS post_map = { NULL, NULL, 0, 0 };
        if (wanted_data_len == 0LL) {
            map_set_ss(&post_map, "title", post.title);
            map_set_ss(&post_map, "url", post.url);
            map_set_ss(&post_map, "selftext", post.selftext);
        } else {
            long long j = 0LL;
            while (j < wanted_data_len) {
                const char* field = wanted_data[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? wanted_data_len + _mochi_idx : _mochi_idx;})];
                if (strcmp(field, "title") == 0) {
                    map_set_ss(&post_map, "title", post.title);
                } else {
                    if (strcmp(field, "url") == 0) {
                        map_set_ss(&post_map, "url", post.url);
                    } else {
                        if (strcmp(field, "selftext") == 0) {
                            map_set_ss(&post_map, "selftext", post.selftext);
                        }
                    }
                }
                j = j + 1LL;
            }
        }
        result[(int)(idx)] = post_map;
        idx = idx + 1LL;
    }
    return result;
}

int main(void) {
    {
        long long __start = _now();
        printf("%d\n", get_subreddit_data("learnpython", 1LL, "new", (const char*[]){"title", "url", "selftext"}, 3));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
