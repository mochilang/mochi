// Generated by Mochi 0.10.32 on 2025-08-16 11:14 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t identity_len;
size_t *identity_lens;
size_t transpose_len;
size_t *transpose_lens;
size_t matmul_len;
size_t *matmul_lens;
size_t mat_sub_len;
size_t *mat_sub_lens;
size_t inverse_len;
size_t *inverse_lens;
size_t schur_complement_len;
size_t *schur_complement_lens;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t concat_len;
static long long* concat_long_long(long long *a, size_t a_len, const long long *b, size_t b_len) {
    long long *res = realloc(a, (a_len + b_len) * sizeof(long long));
    if (b_len > 0) memcpy(res + a_len, b, b_len * sizeof(long long));
    concat_len = a_len + b_len;
    return res;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct OptionMatrix OptionMatrix;

struct OptionMatrix {
    double **value;
    size_t value_len;
    size_t *value_lens;
    size_t value_lens_len;
    long long ok;
};

double * * identity(long long n);
double * * transpose(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len);
double * * matmul(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len);
double * * mat_sub(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len);
double * * inverse(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len);
double * * schur_complement(double * * mat_a, size_t mat_a_len, size_t* mat_a_lens, size_t mat_a_lens_len, double * * mat_b, size_t mat_b_len, size_t* mat_b_lens, size_t mat_b_lens_len, double * * mat_c, size_t mat_c_len, size_t* mat_c_lens, size_t mat_c_lens_len, OptionMatrix pseudo_inv);
void print_matrix(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len);
void user_main();
int main(void);

double * * identity(long long n) {
    double **mat = NULL;
    size_t mat_len = 0;
    size_t *mat_lens = NULL;
    size_t mat_lens_len = 0;
    long long i = 0LL;
    while (i < n) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < n) {
            if (i == j) {
                row = list_append_double(row, &row_len, 1LL);
            } else {
                row = list_append_double(row, &row_len, 0LL);
            }
            j = j + 1LL;
        }
        mat = list_append_doubleptr(mat, &mat_len, row);
        mat_lens = list_append_szt(mat_lens, &mat_lens_len, row_len);
        i = i + 1LL;
    }
    return identity_lens = mat_lens, identity_len = mat_len, mat;
}

double * * transpose(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len) {
    long long rows = mat_len;
    long long cols = mat_lens[0LL];
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long j = 0LL;
    while (j < cols) {
        double *row = NULL;
        size_t row_len = 0;
        long long i = 0LL;
        while (i < rows) {
            row = list_append_double(row, &row_len, mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? mat_lens[i] + _mochi_idx : _mochi_idx;})]);
            i = i + 1LL;
        }
        res = list_append_doubleptr(res, &res_len, row);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_len);
        j = j + 1LL;
    }
    return transpose_lens = res_lens, transpose_len = res_len, res;
}

double * * matmul(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len) {
    long long rows = a_len;
    long long cols = b_lens[0LL];
    long long inner = a_lens[0LL];
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < rows) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < cols) {
            double sum = 0LL;
            long long k = 0LL;
            while (k < inner) {
                sum = sum + (a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? a_lens[i] + _mochi_idx : _mochi_idx;})] * b[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? b_lens[k] + _mochi_idx : _mochi_idx;})]);
                k = k + 1LL;
            }
            row = list_append_double(row, &row_len, sum);
            j = j + 1LL;
        }
        res = list_append_doubleptr(res, &res_len, row);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_len);
        i = i + 1LL;
    }
    return matmul_lens = res_lens, matmul_len = res_len, res;
}

double * * mat_sub(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len) {
    long long rows = a_len;
    long long cols = a_lens[0LL];
    double **res = NULL;
    size_t res_len = 0;
    size_t *res_lens = NULL;
    size_t res_lens_len = 0;
    long long i = 0LL;
    while (i < rows) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < cols) {
            row = list_append_double(row, &row_len, a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_lens[i] + _mochi_idx : _mochi_idx;})] - b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? b_lens[i] + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        res = list_append_doubleptr(res, &res_len, row);
        res_lens = list_append_szt(res_lens, &res_lens_len, row_len);
        i = i + 1LL;
    }
    return mat_sub_lens = res_lens, mat_sub_len = res_len, res;
}

double * * inverse(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len) {
    long long n = mat_len;
    double **id = identity(n);
    size_t id_len = identity_len;
    size_t *id_lens = identity_lens;
    size_t id_lens_len = identity_len;
    double **aug = NULL;
    size_t aug_len = 0;
    size_t *aug_lens = NULL;
    size_t aug_lens_len = 0;
    long long i = 0LL;
    while (i < n) {
        long long row = concat_long_long(mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})], mat_lens[i], id[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? id_len + _mochi_idx : _mochi_idx;})], id_lens[i]);
        aug = list_append_doubleptr(aug, &aug_len, row);
        aug_lens = list_append_szt(aug_lens, &aug_lens_len, row_len);
        i = i + 1LL;
    }
    long long col = 0LL;
    while (col < n) {
        double *pivot_row = aug[(int)({long long _mochi_idx = col; _mochi_idx < 0 ? aug_len + _mochi_idx : _mochi_idx;})];
        size_t pivot_row_len = aug_lens[col];
        double pivot = pivot_row[(int)({long long _mochi_idx = col; _mochi_idx < 0 ? pivot_row_len + _mochi_idx : _mochi_idx;})];
        if (pivot == 0LL) {
            panic("matrix is singular");
        }
        long long j = 0LL;
        while (j < (2LL * n)) {
            pivot_row[(int)(j)] = pivot_row[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? pivot_row_len + _mochi_idx : _mochi_idx;})] / pivot;
            j = j + 1LL;
        }
        aug[(int)(col)] = pivot_row;
        long long r = 0LL;
        while (r < n) {
            if (r != col) {
                double *row_r = aug[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? aug_len + _mochi_idx : _mochi_idx;})];
                size_t row_r_len = aug_lens[r];
                double factor = row_r[(int)({long long _mochi_idx = col; _mochi_idx < 0 ? row_r_len + _mochi_idx : _mochi_idx;})];
                j = 0LL;
                while (j < (2LL * n)) {
                    row_r[(int)(j)] = row_r[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? row_r_len + _mochi_idx : _mochi_idx;})] - (factor * pivot_row[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? pivot_row_len + _mochi_idx : _mochi_idx;})]);
                    j = j + 1LL;
                }
                aug[(int)(r)] = row_r;
            }
            r = r + 1LL;
        }
        col = col + 1LL;
    }
    double **inv = NULL;
    size_t inv_len = 0;
    size_t *inv_lens = NULL;
    size_t inv_lens_len = 0;
    long long r = 0LL;
    while (r < n) {
        double *row = NULL;
        size_t row_len = 0;
        long long c = n;
        while (c < (2LL * n)) {
            row = list_append_double(row, &row_len, aug[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? aug_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = c; _mochi_idx < 0 ? aug_lens[r] + _mochi_idx : _mochi_idx;})]);
            c = c + 1LL;
        }
        inv = list_append_doubleptr(inv, &inv_len, row);
        inv_lens = list_append_szt(inv_lens, &inv_lens_len, row_len);
        r = r + 1LL;
    }
    return inverse_lens = inv_lens, inverse_len = inv_len, inv;
}

double * * schur_complement(double * * mat_a, size_t mat_a_len, size_t* mat_a_lens, size_t mat_a_lens_len, double * * mat_b, size_t mat_b_len, size_t* mat_b_lens, size_t mat_b_lens_len, double * * mat_c, size_t mat_c_len, size_t* mat_c_lens, size_t mat_c_lens_len, OptionMatrix pseudo_inv) {
    long long a_rows = mat_a_len;
    long long a_cols = mat_a_lens[0LL];
    if (a_rows != a_cols) {
        panic("Matrix A must be square");
    }
    if (a_rows != mat_b_len) {
        panic("Expected the same number of rows for A and B");
    }
    if (mat_b_lens[0LL] != mat_c_lens[0LL]) {
        panic("Expected the same number of columns for B and C");
    }
    double **a_inv = NULL;
    size_t a_inv_len = 0;
    size_t *a_inv_lens = NULL;
    size_t a_inv_lens_len = 0;
    if (pseudo_inv.ok) {
        a_inv = pseudo_inv.value;
    } else {
        a_inv = inverse(mat_a, mat_a_len, mat_a_lens, mat_a_len);
        a_inv_len = inverse_len;
        a_inv_lens = inverse_lens;
    }
    double **bt = transpose(mat_b, mat_b_len, mat_b_lens, mat_b_len);
    size_t bt_len = transpose_len;
    size_t *bt_lens = transpose_lens;
    size_t bt_lens_len = transpose_len;
    double **a_inv_b = matmul(a_inv, a_inv_len, a_inv_lens, a_inv_len, mat_b, mat_b_len, mat_b_lens, mat_b_len);
    size_t a_inv_b_len = matmul_len;
    size_t *a_inv_b_lens = matmul_lens;
    size_t a_inv_b_lens_len = matmul_len;
    double **bt_a_inv_b = matmul(bt, bt_len, bt_lens, bt_len, a_inv_b, a_inv_b_len, a_inv_b_lens, a_inv_b_len);
    size_t bt_a_inv_b_len = matmul_len;
    size_t *bt_a_inv_b_lens = matmul_lens;
    size_t bt_a_inv_b_lens_len = matmul_len;
    {
        double** __ret0 = mat_sub(mat_c, mat_c_len, mat_c_lens, mat_c_len, bt_a_inv_b, bt_a_inv_b_len, bt_a_inv_b_lens, bt_a_inv_b_len);
        schur_complement_lens = mat_sub_lens;
schur_complement_len = mat_sub_len;
        return __ret0;
    }
}

void print_matrix(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len) {
    long long i = 0LL;
    while (i < mat_len) {
        const char* line = "";
        long long j = 0LL;
        double *row = mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})];
        size_t row_len = mat_lens[i];
        while (j < row_len) {
            line = str_concat(line, str_float(row[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? row_len + _mochi_idx : _mochi_idx;})]));
            if ((j + 1LL) < row_len) {
                line = str_concat(line, " ");
            }
            j = j + 1LL;
        }
        puts(line);
        i = i + 1LL;
    }
}

void user_main() {
    long long a_0[2] = {1LL, 2LL};
    long long a_1[2] = {2LL, 1LL};
    long long *a_init[2] = {a_0, a_1};
    long long **a = a_init;
    size_t a_len = 2;
    size_t a_lens_init[2] = {2, 2};
    size_t *a_lens = a_lens_init;
    size_t a_lens_len = 2;
    long long b_0[2] = {0LL, 3LL};
    long long b_1[2] = {3LL, 0LL};
    long long *b_init[2] = {b_0, b_1};
    long long **b = b_init;
    size_t b_len = 2;
    size_t b_lens_init[2] = {2, 2};
    size_t *b_lens = b_lens_init;
    size_t b_lens_len = 2;
    long long c_0[2] = {2LL, 1LL};
    long long c_1[2] = {6LL, 3LL};
    long long *c_init[2] = {c_0, c_1};
    long long **c = c_init;
    size_t c_len = 2;
    size_t c_lens_init[2] = {2, 2};
    size_t *c_lens = c_lens_init;
    size_t c_lens_len = 2;
    OptionMatrix none = (OptionMatrix){.value = NULL, .value_len = 0, .value_lens = NULL, .value_lens_len = 0, .ok = 0LL};
    double **s = schur_complement(a, a_len, a_lens, a_len, b, b_len, b_lens, b_len, c, c_len, c_lens, c_len, none);
    size_t s_len = schur_complement_len;
    size_t *s_lens = schur_complement_lens;
    size_t s_lens_len = schur_complement_len;
    print_matrix(s, s_len, s_lens, s_len);
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
