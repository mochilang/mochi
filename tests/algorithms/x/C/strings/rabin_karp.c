// Generated by Mochi 0.10.32 on 2025-08-24 09:44 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


size_t append_len;
#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

long long alphabet_size = 256LL;
long long modulus = 1000003LL;

long long index_of_char(const char* s, const char* ch);
long long ord(const char* ch);
long long rabin_karp(const char* pattern, const char* text);
const char* test_rabin_karp();
int main(void);

long long index_of_char(const char* s, const char* ch) {
    long long i = 0LL;
    while (i < strlen(s)) {
        if (strcmp((const char[]){s[i], 0}, ch) == 0) {
            return i;
        }
        i = i + 1LL;
    }
    return -1LL;
}

long long ord(const char* ch) {
    const char* upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const char* lower = "abcdefghijklmnopqrstuvwxyz";
    const char* digits = "0123456789";
    long long idx = index_of_char(upper, ch);
    if (idx >= 0LL) {
        return 65LL + idx;
    }
    idx = index_of_char(lower, ch);
    if (idx >= 0LL) {
        return 97LL + idx;
    }
    idx = index_of_char(digits, ch);
    if (idx >= 0LL) {
        return 48LL + idx;
    }
    if (strcmp(ch, "ü") == 0) {
        return 252LL;
    }
    if (strcmp(ch, "Ü") == 0) {
        return 220LL;
    }
    if (strcmp(ch, " ") == 0) {
        return 32LL;
    }
    return 0LL;
}

long long rabin_karp(const char* pattern, const char* text) {
    long long p_len = strlen(pattern);
    long long t_len = strlen(text);
    if (p_len > t_len) {
        return 0LL;
    }
    long long p_hash = 0LL;
    long long t_hash = 0LL;
    long long modulus_power = 1LL;
    long long i = 0LL;
    while (i < p_len) {
        p_hash = (ord((const char[]){pattern[i], 0}) + (p_hash * alphabet_size)) % modulus;
        t_hash = (ord((const char[]){text[i], 0}) + (t_hash * alphabet_size)) % modulus;
        if (i != (p_len - 1LL)) {
            modulus_power = (modulus_power * alphabet_size) % modulus;
        }
        i = i + 1LL;
    }
    long long j = 0LL;
    while (j <= (t_len - p_len)) {
        if ((t_hash == p_hash) && (strcmp(_substring(text, j, j + p_len), pattern) == 0)) {
            return 1LL;
        }
        if (j == (t_len - p_len)) {
            j = j + 1LL;
            continue;
        }
        t_hash = (((t_hash - (ord((const char[]){text[j], 0}) * modulus_power)) * alphabet_size) + ord((const char[]){text[j + p_len], 0})) % modulus;
        if (t_hash < 0LL) {
            t_hash = t_hash + modulus;
        }
        j = j + 1LL;
    }
    return 0LL;
}

const char* test_rabin_karp() {
    const char* pattern1 = "abc1abc12";
    const char* text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc";
    const char* text2 = "alskfjaldsk23adsfabcabc";
    if (!(rabin_karp(pattern1, text1)) || rabin_karp(pattern1, text2)) {
        puts("Failure");
        return 0;
    }
    const char* pattern2 = "ABABX";
    const char* text3 = "ABABZABABYABABX";
    if (!(rabin_karp(pattern2, text3))) {
        puts("Failure");
        return 0;
    }
    const char* pattern3 = "AAAB";
    const char* text4 = "ABAAAAAB";
    if (!(rabin_karp(pattern3, text4))) {
        puts("Failure");
        return 0;
    }
    const char* pattern4 = "abcdabcy";
    const char* text5 = "abcxabcdabxabcdabcdabcy";
    if (!(rabin_karp(pattern4, text5))) {
        puts("Failure");
        return 0;
    }
    const char* pattern5 = "Lü";
    const char* text6 = "Lüsai";
    if (!(rabin_karp(pattern5, text6))) {
        puts("Failure");
        return 0;
    }
    const char* pattern6 = "Lue";
    if (rabin_karp(pattern6, text6)) {
        puts("Failure");
        return 0;
    }
    puts("Success.");
}

int main(void) {
    {
        long long __start = _now();
        test_rabin_karp();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
