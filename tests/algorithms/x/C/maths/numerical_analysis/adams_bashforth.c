// Generated by Mochi 0.10.32 on 2025-08-17 12:10 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t adams_bashforth_step2_len;
size_t adams_bashforth_step3_len;
size_t adams_bashforth_step4_len;
size_t adams_bashforth_step5_len;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

double *y2 = NULL;
size_t y2_len = 0;
double *y3 = NULL;
size_t y3_len = 0;
double *y4 = NULL;
size_t y4_len = 0;
double *y5 = NULL;
size_t y5_len = 0;

double abs_float(double x);
void validate_inputs(double * x_initials, size_t x_initials_len, double step_size, double x_final);
const char* list_to_string(double * xs, size_t xs_len);
double * adams_bashforth_step2(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final);
double * adams_bashforth_step3(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final);
double * adams_bashforth_step4(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final);
double * adams_bashforth_step5(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final);
double f_x(double x, double y);
double f_xy(double x, double y);
int main(void);

double abs_float(double x) {
    if (x < 0.0) {
        return -(x);
    } else {
        return x;
    }
}

void validate_inputs(double * x_initials, size_t x_initials_len, double step_size, double x_final) {
    if (x_initials[(int)({long long _mochi_idx = x_initials_len - 1LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})] >= x_final) {
        panic("The final value of x must be greater than the initial values of x.");
    }
    if (step_size <= 0.0) {
        panic("Step size must be positive.");
    }
    long long i = 0LL;
    while (i < (x_initials_len - 1LL)) {
        double diff = x_initials[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})] - x_initials[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
        if (abs_float(diff - step_size) > 1e-10) {
            panic("x-values must be equally spaced according to step size.");
        }
        i = i + 1LL;
    }
}

const char* list_to_string(double * xs, size_t xs_len) {
    const char* s = "[";
    long long i = 0LL;
    while (i < xs_len) {
        s = str_concat(s, str_float(xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})]));
        if ((i + 1LL) < xs_len) {
            s = str_concat(s, ", ");
        }
        i = i + 1LL;
    }
    s = str_concat(s, "]");
    return s;
}

double * adams_bashforth_step2(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final) {
    validate_inputs(x_initials, x_initials_len, step_size, x_final);
    if ((x_initials_len != 2LL) || (y_initials_len != 2LL)) {
        panic("Insufficient initial points information.");
    }
    double x0 = x_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x1 = x_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double *y = NULL;
    size_t y_len = 0;
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    long long n = (x_final - x1) / step_size;
    long long i = 0LL;
    while (i < n) {
        double term = (3.0 * f(x1, y[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})])) - f(x0, y[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]);
        double y_next = y[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})] + ((step_size / 2.0) * term);
        y = list_append_double(y, &y_len, y_next);
        x0 = x1;
        x1 = x1 + step_size;
        i = i + 1LL;
    }
    return adams_bashforth_step2_len = y_len, y;
}

double * adams_bashforth_step3(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final) {
    validate_inputs(x_initials, x_initials_len, step_size, x_final);
    if ((x_initials_len != 3LL) || (y_initials_len != 3LL)) {
        panic("Insufficient initial points information.");
    }
    double x0 = x_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x1 = x_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x2 = x_initials[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double *y = NULL;
    size_t y_len = 0;
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    long long n = (x_final - x2) / step_size;
    long long i = 0LL;
    while (i <= n) {
        double term = ((23.0 * f(x2, y[(int)({long long _mochi_idx = i + 2LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})])) - (16.0 * f(x1, y[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]))) + (5.0 * f(x0, y[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]));
        double y_next = y[(int)({long long _mochi_idx = i + 2LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})] + ((step_size / 12.0) * term);
        y = list_append_double(y, &y_len, y_next);
        x0 = x1;
        x1 = x2;
        x2 = x2 + step_size;
        i = i + 1LL;
    }
    return adams_bashforth_step3_len = y_len, y;
}

double * adams_bashforth_step4(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final) {
    validate_inputs(x_initials, x_initials_len, step_size, x_final);
    if ((x_initials_len != 4LL) || (y_initials_len != 4LL)) {
        panic("Insufficient initial points information.");
    }
    double x0 = x_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x1 = x_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x2 = x_initials[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x3 = x_initials[(int)({long long _mochi_idx = 3LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double *y = NULL;
    size_t y_len = 0;
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 3LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    long long n = (x_final - x3) / step_size;
    long long i = 0LL;
    while (i < n) {
        double term = (((55.0 * f(x3, y[(int)({long long _mochi_idx = i + 3LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})])) - (59.0 * f(x2, y[(int)({long long _mochi_idx = i + 2LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]))) + (37.0 * f(x1, y[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]))) - (9.0 * f(x0, y[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]));
        double y_next = y[(int)({long long _mochi_idx = i + 3LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})] + ((step_size / 24.0) * term);
        y = list_append_double(y, &y_len, y_next);
        x0 = x1;
        x1 = x2;
        x2 = x3;
        x3 = x3 + step_size;
        i = i + 1LL;
    }
    return adams_bashforth_step4_len = y_len, y;
}

double * adams_bashforth_step5(double(*f)(double, double), double * x_initials, size_t x_initials_len, double * y_initials, size_t y_initials_len, double step_size, double x_final) {
    validate_inputs(x_initials, x_initials_len, step_size, x_final);
    if ((x_initials_len != 5LL) || (y_initials_len != 5LL)) {
        panic("Insufficient initial points information.");
    }
    double x0 = x_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x1 = x_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x2 = x_initials[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x3 = x_initials[(int)({long long _mochi_idx = 3LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double x4 = x_initials[(int)({long long _mochi_idx = 4LL; _mochi_idx < 0 ? x_initials_len + _mochi_idx : _mochi_idx;})];
    double *y = NULL;
    size_t y_len = 0;
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 3LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    y = list_append_double(y, &y_len, y_initials[(int)({long long _mochi_idx = 4LL; _mochi_idx < 0 ? y_initials_len + _mochi_idx : _mochi_idx;})]);
    long long n = (x_final - x4) / step_size;
    long long i = 0LL;
    while (i <= n) {
        double term = ((((1901.0 * f(x4, y[(int)({long long _mochi_idx = i + 4LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})])) - (2774.0 * f(x3, y[(int)({long long _mochi_idx = i + 3LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]))) - (2616.0 * f(x2, y[(int)({long long _mochi_idx = i + 2LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]))) - (1274.0 * f(x1, y[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]))) + (251.0 * f(x0, y[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})]));
        double y_next = y[(int)({long long _mochi_idx = i + 4LL; _mochi_idx < 0 ? y_len + _mochi_idx : _mochi_idx;})] + ((step_size / 720.0) * term);
        y = list_append_double(y, &y_len, y_next);
        x0 = x1;
        x1 = x2;
        x2 = x3;
        x3 = x4;
        x4 = x4 + step_size;
        i = i + 1LL;
    }
    return adams_bashforth_step5_len = y_len, y;
}

double f_x(double x, double y) {
    return x;
}

double f_xy(double x, double y) {
    return x + y;
}

int main(void) {
    {
        long long __start = _now();
        y2 = adams_bashforth_step2(f_x, (double[]){0.0, 0.2}, 2, (double[]){0.0, 0.0}, 2, 0.2, 1.0);
        y2_len = adams_bashforth_step2_len;
        puts(list_to_string(y2, y2_len));
        y3 = adams_bashforth_step3(f_xy, (double[]){0.0, 0.2, 0.4}, 3, (double[]){0.0, 0.0, 0.04}, 3, 0.2, 1.0);
        y3_len = adams_bashforth_step3_len;
        puts(str_float(y3[(int)({long long _mochi_idx = 3LL; _mochi_idx < 0 ? y3_len + _mochi_idx : _mochi_idx;})]));
        y4 = adams_bashforth_step4(f_xy, (double[]){0.0, 0.2, 0.4, 0.6}, 4, (double[]){0.0, 0.0, 0.04, 0.128}, 4, 0.2, 1.0);
        y4_len = adams_bashforth_step4_len;
        puts(str_float(y4[(int)({long long _mochi_idx = 4LL; _mochi_idx < 0 ? y4_len + _mochi_idx : _mochi_idx;})]));
        puts(str_float(y4[(int)({long long _mochi_idx = 5LL; _mochi_idx < 0 ? y4_len + _mochi_idx : _mochi_idx;})]));
        y5 = adams_bashforth_step5(f_xy, (double[]){0.0, 0.2, 0.4, 0.6, 0.8}, 5, (double[]){0.0, 0.0214, 0.0214, 0.22211, 0.42536}, 5, 0.2, 1.0);
        y5_len = adams_bashforth_step5_len;
        puts(str_float(y5[(int)({long long _mochi_idx = y5_len - 1LL; _mochi_idx < 0 ? y5_len + _mochi_idx : _mochi_idx;})]));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
