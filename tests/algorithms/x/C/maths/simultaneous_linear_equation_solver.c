// Generated by Mochi 0.10.32 on 2025-08-17 13:11 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t clone_matrix_len;
size_t *clone_matrix_lens;
size_t solve_simultaneous_len;

size_t append_len;
static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_double(const double *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[64];
        snprintf(tmp, sizeof(tmp), "%g", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

double user_floor(double x);
double user_pow10(long long n);
double user_round(double x, long long n);
double * * clone_matrix(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len);
double * solve_simultaneous(double * * equations, size_t equations_len, size_t* equations_lens, size_t equations_lens_len);
void test_solver();
void user_main();
int main(void);

double user_floor(double x) {
    long long i = (int)(x);
    if ((double)(i) > x) {
        i = i - 1LL;
    }
    return (double)(i);
}

double user_pow10(long long n) {
    double p = 1.0;
    long long i = 0LL;
    while (i < n) {
        p = p * 10.0;
        i = i + 1LL;
    }
    return p;
}

double user_round(double x, long long n) {
    double m = user_pow10(n);
    return user_floor((x * m) + 0.5) / m;
}

double * * clone_matrix(double * * mat, size_t mat_len, size_t* mat_lens, size_t mat_lens_len) {
    double **new_mat = NULL;
    size_t new_mat_len = 0;
    size_t *new_mat_lens = NULL;
    size_t new_mat_lens_len = 0;
    long long i = 0LL;
    while (i < mat_len) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < mat_lens[(int)(i)]) {
            row = list_append_double(row, &row_len, mat[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? mat_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? mat_lens[(int)(i)] + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        new_mat = list_append_doubleptr(new_mat, &new_mat_len, row);
        new_mat_lens = list_append_szt(new_mat_lens, &new_mat_lens_len, row_len);
        i = i + 1LL;
    }
    return clone_matrix_lens = new_mat_lens, clone_matrix_len = new_mat_len, new_mat;
}

double * solve_simultaneous(double * * equations, size_t equations_len, size_t* equations_lens, size_t equations_lens_len) {
    long long n = equations_len;
    if (n == 0LL) {
        panic("solve_simultaneous() requires n lists of length n+1");
    }
    long long m = n + 1LL;
    long long i = 0LL;
    while (i < n) {
        if (equations_lens[(int)(i)] != m) {
            panic("solve_simultaneous() requires n lists of length n+1");
        }
        i = i + 1LL;
    }
    double **a = clone_matrix(equations, equations_len, equations_lens, equations_len);
    size_t a_len = clone_matrix_len;
    size_t *a_lens = clone_matrix_lens;
    size_t a_lens_len = clone_matrix_len;
    long long row = 0LL;
    while (row < n) {
        long long pivot = row;
        while ((pivot < n) && (a[(int)({long long _mochi_idx = pivot; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_lens[(int)(pivot)] + _mochi_idx : _mochi_idx;})] == 0.0)) {
            pivot = pivot + 1LL;
        }
        if (pivot == n) {
            panic("solve_simultaneous() requires at least 1 full equation");
        }
        if (pivot != row) {
            double *temp = a[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})];
            size_t temp_len = a_lens[(int)(row)];
            a[(int)(row)] = a[(int)({long long _mochi_idx = pivot; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})];
            a[(int)(pivot)] = temp;
        }
        double pivot_val = a[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_lens[(int)(row)] + _mochi_idx : _mochi_idx;})];
        long long col = 0LL;
        while (col < m) {
            a[(int)(row)][(int)(col)] = a[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = col; _mochi_idx < 0 ? a_lens[(int)(row)] + _mochi_idx : _mochi_idx;})] / pivot_val;
            col = col + 1LL;
        }
        long long r = 0LL;
        while (r < n) {
            if (r != row) {
                double factor = a[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_lens[(int)(r)] + _mochi_idx : _mochi_idx;})];
                long long c = 0LL;
                while (c < m) {
                    a[(int)(r)][(int)(c)] = a[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = c; _mochi_idx < 0 ? a_lens[(int)(r)] + _mochi_idx : _mochi_idx;})] - (factor * a[(int)({long long _mochi_idx = row; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = c; _mochi_idx < 0 ? a_lens[(int)(row)] + _mochi_idx : _mochi_idx;})]);
                    c = c + 1LL;
                }
            }
            r = r + 1LL;
        }
        row = row + 1LL;
    }
    double *res = NULL;
    size_t res_len = 0;
    long long k = 0LL;
    while (k < n) {
        res = list_append_double(res, &res_len, user_round(a[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = m - 1LL; _mochi_idx < 0 ? a_lens[(int)(k)] + _mochi_idx : _mochi_idx;})], 5LL));
        k = k + 1LL;
    }
    return solve_simultaneous_len = res_len, res;
}

void test_solver() {
    double a_0[3] = {1.0, 2.0, 3.0};
    double a_1[3] = {4.0, 5.0, 6.0};
    double *a_init[2] = {a_0, a_1};
    double **a = a_init;
    size_t a_len = 2;
    size_t a_lens_init[2] = {3, 3};
    size_t *a_lens = a_lens_init;
    size_t a_lens_len = 2;
    double *r1 = solve_simultaneous(a, a_len, a_lens, a_len);
    size_t r1_len = solve_simultaneous_len;
    if (!(((r1_len == 2LL) && (r1[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? r1_len + _mochi_idx : _mochi_idx;})] == (0.0 - 1.0))) && (r1[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? r1_len + _mochi_idx : _mochi_idx;})] == 2.0))) {
        panic("test1 failed");
    }
    double b_0[4] = {0.0, 0.0 - 3.0, 1.0, 7.0};
    double b_1[4] = {3.0, 2.0, 0.0 - 1.0, 11.0};
    double b_2[4] = {5.0, 1.0, 0.0 - 2.0, 12.0};
    double *b_init[3] = {b_0, b_1, b_2};
    double **b = b_init;
    size_t b_len = 3;
    size_t b_lens_init[3] = {4, 4, 4};
    size_t *b_lens = b_lens_init;
    size_t b_lens_len = 3;
    double *r2 = solve_simultaneous(b, b_len, b_lens, b_len);
    size_t r2_len = solve_simultaneous_len;
    if (!((((r2_len == 3LL) && (r2[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? r2_len + _mochi_idx : _mochi_idx;})] == 6.4)) && (r2[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? r2_len + _mochi_idx : _mochi_idx;})] == 1.2)) && (r2[(int)({long long _mochi_idx = 2LL; _mochi_idx < 0 ? r2_len + _mochi_idx : _mochi_idx;})] == 10.6))) {
        panic("test2 failed");
    }
}

void user_main() {
    test_solver();
    double eq_0[6] = {2.0, 1.0, 1.0, 1.0, 1.0, 4.0};
    double eq_1[6] = {1.0, 2.0, 1.0, 1.0, 1.0, 5.0};
    double eq_2[6] = {1.0, 1.0, 2.0, 1.0, 1.0, 6.0};
    double eq_3[6] = {1.0, 1.0, 1.0, 2.0, 1.0, 7.0};
    double eq_4[6] = {1.0, 1.0, 1.0, 1.0, 2.0, 8.0};
    double *eq_init[5] = {eq_0, eq_1, eq_2, eq_3, eq_4};
    double **eq = eq_init;
    size_t eq_len = 5;
    size_t eq_lens_init[5] = {6, 6, 6, 6, 6};
    size_t *eq_lens = eq_lens_init;
    size_t eq_lens_len = 5;
    puts(({double *__tmp2 = solve_simultaneous(eq, eq_len, eq_lens, eq_len); char *__res = str_list_double(__tmp2, solve_simultaneous_len); __res;}));
    puts(({double *__tmp3 = solve_simultaneous(({double** tmp = malloc(1 * sizeof(double*)); tmp[0] = (double[]){4.0, 2.0}; tmp;}), 1, ({size_t *tmp = malloc(1 * sizeof(size_t)); tmp[0] = 2; tmp;}), 1); char *__res = str_list_double(__tmp3, solve_simultaneous_len); __res;}));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
