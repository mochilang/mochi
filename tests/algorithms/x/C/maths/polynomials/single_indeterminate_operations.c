// Generated by Mochi 0.10.32 on 2025-08-17 13:11 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t copy_list_len;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Polynomial Polynomial;

struct Polynomial {
    long long degree;
    double *coefficients;
    size_t coefficients_len;
};

double * copy_list(double * xs, size_t xs_len);
Polynomial polynomial_new(long long degree, double * coeffs, size_t coeffs_len);
Polynomial add(Polynomial p, Polynomial q);
Polynomial neg(Polynomial p);
Polynomial sub(Polynomial p, Polynomial q);
Polynomial mul(Polynomial p, Polynomial q);
double power(double base, long long exp);
double evaluate(Polynomial p, double x);
const char* poly_to_string(Polynomial p);
Polynomial derivative(Polynomial p);
Polynomial integral(Polynomial p, double constant);
long long equals(Polynomial p, Polynomial q);
long long not_equals(Polynomial p, Polynomial q);
void test_polynomial();
void user_main();
int main(void);

double * copy_list(double * xs, size_t xs_len) {
    double *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < xs_len) {
        res = list_append_double(res, &res_len, xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    return copy_list_len = res_len, res;
}

Polynomial polynomial_new(long long degree, double * coeffs, size_t coeffs_len) {
    if (coeffs_len != (degree + 1LL)) {
        panic("The number of coefficients should be equal to the degree + 1.");
    }
    return (Polynomial){.degree = degree, .coefficients = copy_list(coeffs, coeffs_len), .coefficients_len = copy_list_len};
}

Polynomial add(Polynomial p, Polynomial q) {
    if (p.degree > q.degree) {
        double *coeffs = copy_list(p.coefficients, p.coefficients_len);
        size_t coeffs_len = copy_list_len;
        long long i = 0LL;
        while (i <= q.degree) {
            coeffs[(int)(i)] = coeffs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? coeffs_len + _mochi_idx : _mochi_idx;})] + q.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? q.coefficients_len + _mochi_idx : _mochi_idx;})];
            i = i + 1LL;
        }
        return (Polynomial){.degree = p.degree, .coefficients = coeffs, .coefficients_len = coeffs_len};
    } else {
        double *coeffs = copy_list(q.coefficients, q.coefficients_len);
        size_t coeffs_len = copy_list_len;
        long long i = 0LL;
        while (i <= p.degree) {
            coeffs[(int)(i)] = coeffs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? coeffs_len + _mochi_idx : _mochi_idx;})] + p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})];
            i = i + 1LL;
        }
        return (Polynomial){.degree = q.degree, .coefficients = coeffs, .coefficients_len = coeffs_len};
    }
}

Polynomial neg(Polynomial p) {
    double *coeffs = NULL;
    size_t coeffs_len = 0;
    long long i = 0LL;
    while (i <= p.degree) {
        coeffs = list_append_double(coeffs, &coeffs_len, -(p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})]));
        i = i + 1LL;
    }
    return (Polynomial){.degree = p.degree, .coefficients = coeffs, .coefficients_len = coeffs_len};
}

Polynomial sub(Polynomial p, Polynomial q) {
    return add(p, neg(q));
}

Polynomial mul(Polynomial p, Polynomial q) {
    long long size = (p.degree + q.degree) + 1LL;
    double *coeffs = NULL;
    size_t coeffs_len = 0;
    long long i = 0LL;
    while (i < size) {
        coeffs = list_append_double(coeffs, &coeffs_len, 0.0);
        i = i + 1LL;
    }
    i = 0LL;
    while (i <= p.degree) {
        long long j = 0LL;
        while (j <= q.degree) {
            coeffs[(int)(i + j)] = coeffs[(int)({long long _mochi_idx = i + j; _mochi_idx < 0 ? coeffs_len + _mochi_idx : _mochi_idx;})] + (p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})] * q.coefficients[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? q.coefficients_len + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    return (Polynomial){.degree = p.degree + q.degree, .coefficients = coeffs, .coefficients_len = coeffs_len};
}

double power(double base, long long exp) {
    double result = 1.0;
    long long i = 0LL;
    while (i < exp) {
        result = result * base;
        i = i + 1LL;
    }
    return result;
}

double evaluate(Polynomial p, double x) {
    double result = 0.0;
    long long i = 0LL;
    while (i <= p.degree) {
        result = result + (p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})] * power(x, i));
        i = i + 1LL;
    }
    return result;
}

const char* poly_to_string(Polynomial p) {
    const char* s = "";
    long long i = p.degree;
    while (i >= 0LL) {
        double coeff = p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})];
        if (coeff != 0.0) {
            if (strlen(s) > 0LL) {
                if (coeff > 0.0) {
                    s = str_concat(s, " + ");
                } else {
                    s = str_concat(s, " - ");
                }
            } else {
                if (coeff < 0.0) {
                    s = str_concat(s, "-");
                }
            }
            double abs_coeff;
            if (coeff < 0.0) {
                abs_coeff = -(coeff);
            } else {
                abs_coeff = coeff;
            }
            if (i == 0LL) {
                s = str_concat(s, str_float(abs_coeff));
            } else {
                if (i == 1LL) {
                    s = str_concat(str_concat(s, str_float(abs_coeff)), "x");
                } else {
                    s = str_concat(str_concat(str_concat(s, str_float(abs_coeff)), "x^"), str_int(i));
                }
            }
        }
        i = i - 1LL;
    }
    if (strcmp(s, "") == 0) {
        s = "0";
    }
    return s;
}

Polynomial derivative(Polynomial p) {
    if (p.degree == 0LL) {
        return (Polynomial){.degree = 0LL, .coefficients = (double[]){0.0}, .coefficients_len = 1};
    }
    double *coeffs = NULL;
    size_t coeffs_len = 0;
    long long i = 0LL;
    while (i < p.degree) {
        coeffs = list_append_double(coeffs, &coeffs_len, p.coefficients[(int)({long long _mochi_idx = i + 1LL; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})] * (double)(i + 1LL));
        i = i + 1LL;
    }
    return (Polynomial){.degree = p.degree - 1LL, .coefficients = coeffs, .coefficients_len = coeffs_len};
}

Polynomial integral(Polynomial p, double constant) {
    double *coeffs = NULL;
    size_t coeffs_len = 0;
    coeffs = list_append_double(coeffs, &coeffs_len, constant);
    long long i = 0LL;
    while (i <= p.degree) {
        coeffs = list_append_double(coeffs, &coeffs_len, p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})] / (double)(i + 1LL));
        i = i + 1LL;
    }
    return (Polynomial){.degree = p.degree + 1LL, .coefficients = coeffs, .coefficients_len = coeffs_len};
}

long long equals(Polynomial p, Polynomial q) {
    if (p.degree != q.degree) {
        return 0LL;
    }
    long long i = 0LL;
    while (i <= p.degree) {
        if (p.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? p.coefficients_len + _mochi_idx : _mochi_idx;})] != q.coefficients[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? q.coefficients_len + _mochi_idx : _mochi_idx;})]) {
            return 0LL;
        }
        i = i + 1LL;
    }
    return 1LL;
}

long long not_equals(Polynomial p, Polynomial q) {
    return !(equals(p, q));
}

void test_polynomial() {
    Polynomial p = polynomial_new(2LL, (double[]){1.0, 2.0, 3.0}, 3);
    Polynomial q = polynomial_new(2LL, (double[]){1.0, 2.0, 3.0}, 3);
    if (strcmp(poly_to_string(add(p, q)), "6x^2 + 4x + 2") != 0) {
        panic("add failed");
    }
    if (strcmp(poly_to_string(sub(p, q)), "0") != 0) {
        panic("sub failed");
    }
    if (evaluate(p, 2.0) != 17.0) {
        panic("evaluate failed");
    }
    if (strcmp(poly_to_string(derivative(p)), "6x + 2") != 0) {
        panic("derivative failed");
    }
    const char* integ = poly_to_string(integral(p, 0.0));
    if (strcmp(integ, "1x^3 + 1x^2 + 1x") != 0) {
        panic("integral failed");
    }
    if (!(equals(p, q))) {
        panic("equals failed");
    }
    if (not_equals(p, q)) {
        panic("not_equals failed");
    }
}

void user_main() {
    test_polynomial();
    Polynomial p = polynomial_new(2LL, (double[]){1.0, 2.0, 3.0}, 3);
    Polynomial d = derivative(p);
    puts(poly_to_string(d));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
