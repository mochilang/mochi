// Generated by Mochi 0.10.32 on 2025-08-17 13:11 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t make_complex_list_len;
size_t fft_len;
size_t multiply_poly_len;

size_t _slice_double_len;
size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%f", v);
    char *p = buf + strlen(buf) - 1;
    while (p > buf && *p == '0') *p-- = '\0';
    if (p > buf && *p == '.') *p = '\0';
    return strdup(buf);
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static double* _slice_double(const double *arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    double *res = NULL;
    if (n) {
        res = malloc(n * sizeof(double));
        memcpy(res, arr + start, n * sizeof(double));
    }
    *out_len = n;
    _slice_double_len = n;
    return res;
}

typedef struct Complex Complex;

struct Complex {
    double re;
    double im;
};

static Complex* list_append_Complex(Complex *arr, size_t *len, Complex val) {
    arr = realloc(arr, (*len + 1) * sizeof(Complex));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double PI = 3.141592653589793;
double A_init[4] = {0.0, 1.0, 0.0, 2.0};
double *A = A_init;
size_t A_len = 4;
double B_init[4] = {2.0, 3.0, 4.0, 0.0};
double *B = B_init;
size_t B_len = 4;
double *product = NULL;
size_t product_len = 0;

Complex c_add(Complex a, Complex b);
Complex c_sub(Complex a, Complex b);
Complex c_mul(Complex a, Complex b);
Complex c_mul_scalar(Complex a, double s);
Complex c_div_scalar(Complex a, double s);
double sin_taylor(double x);
double cos_taylor(double x);
Complex exp_i(double theta);
Complex * make_complex_list(long long n, Complex value);
Complex * fft(Complex * a, size_t a_len, long long invert);
double user_floor(double x);
double user_pow10(long long n);
double round_to(double x, long long ndigits);
const char* list_to_string(double * l, size_t l_len);
double * multiply_poly(double * a, size_t a_len, double * b, size_t b_len);
int main(void);

Complex c_add(Complex a, Complex b) {
    return (Complex){.re = a.re + b.re, .im = a.im + b.im};
}

Complex c_sub(Complex a, Complex b) {
    return (Complex){.re = a.re - b.re, .im = a.im - b.im};
}

Complex c_mul(Complex a, Complex b) {
    return (Complex){.re = (a.re * b.re) - (a.im * b.im), .im = (a.re * b.im) + (a.im * b.re)};
}

Complex c_mul_scalar(Complex a, double s) {
    return (Complex){.re = a.re * s, .im = a.im * s};
}

Complex c_div_scalar(Complex a, double s) {
    return (Complex){.re = a.re / s, .im = a.im / s};
}

double sin_taylor(double x) {
    double term = x;
    double sum = x;
    long long i = 1LL;
    while (i < 10LL) {
        double k1 = 2.0 * (double)(i);
        double k2 = k1 + 1.0;
        term = ((-(term) * x) * x) / (k1 * k2);
        sum = sum + term;
        i = i + 1LL;
    }
    return sum;
}

double cos_taylor(double x) {
    double term = 1.0;
    double sum = 1.0;
    long long i = 1LL;
    while (i < 10LL) {
        double k1 = (2.0 * (double)(i)) - 1.0;
        double k2 = 2.0 * (double)(i);
        term = ((-(term) * x) * x) / (k1 * k2);
        sum = sum + term;
        i = i + 1LL;
    }
    return sum;
}

Complex exp_i(double theta) {
    return (Complex){.re = cos_taylor(theta), .im = sin_taylor(theta)};
}

Complex * make_complex_list(long long n, Complex value) {
    Complex *arr = NULL;
    size_t arr_len = 0;
    long long i = 0LL;
    while (i < n) {
        arr = list_append_Complex(arr, &arr_len, value);
        i = i + 1LL;
    }
    return make_complex_list_len = arr_len, arr;
}

Complex * fft(Complex * a, size_t a_len, long long invert) {
    long long n = a_len;
    if (n == 1LL) {
        {
            Complex* __tmp0_data = malloc(1 * sizeof(Complex));
            __tmp0_data[0] = a[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})];
            fft_len = 1;
            return __tmp0_data;
        }
    }
    Complex *a0 = NULL;
    size_t a0_len = 0;
    Complex *a1 = NULL;
    size_t a1_len = 0;
    long long i = 0LL;
    while (i < (n / 2LL)) {
        a0 = list_append_Complex(a0, &a0_len, a[(int)({long long _mochi_idx = 2LL * i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})]);
        a1 = list_append_Complex(a1, &a1_len, a[(int)({long long _mochi_idx = (2LL * i) + 1LL; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    Complex *y0_ = fft(a0, a0_len, invert);
    size_t y0__len = fft_len;
    Complex *y1_ = fft(a1, a1_len, invert);
    size_t y1__len = fft_len;
    double angle = ((2.0 * PI) / (double)(n)) * (invert ? -1.0 : 1.0);
    Complex w = (Complex){.re = 1.0, .im = 0.0};
    Complex wn = exp_i(angle);
    Complex *y = make_complex_list(n, (Complex){.re = 0.0, .im = 0.0});
    size_t y_len = make_complex_list_len;
    i = 0LL;
    while (i < (n / 2LL)) {
        Complex t = c_mul(w, y1_[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y1__len + _mochi_idx : _mochi_idx;})]);
        Complex u = y0_[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y0__len + _mochi_idx : _mochi_idx;})];
        Complex even = c_add(u, t);
        Complex odd = c_sub(u, t);
        if (invert) {
            even = c_div_scalar(even, 2.0);
            odd = c_div_scalar(odd, 2.0);
        }
        y[(int)(i)] = even;
        y[(int)(i + (n / 2LL))] = odd;
        w = c_mul(w, wn);
        i = i + 1LL;
    }
    return fft_len = y_len, y;
}

double user_floor(double x) {
    long long i = (int)(x);
    if ((double)(i) > x) {
        i = i - 1LL;
    }
    return (double)(i);
}

double user_pow10(long long n) {
    double p = 1.0;
    long long i = 0LL;
    while (i < n) {
        p = p * 10.0;
        i = i + 1LL;
    }
    return p;
}

double round_to(double x, long long ndigits) {
    double m = user_pow10(ndigits);
    return user_floor((x * m) + 0.5) / m;
}

const char* list_to_string(double * l, size_t l_len) {
    const char* s = "[";
    long long i = 0LL;
    while (i < l_len) {
        s = str_concat(s, str_float(l[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? l_len + _mochi_idx : _mochi_idx;})]));
        if ((i + 1LL) < l_len) {
            s = str_concat(s, ", ");
        }
        i = i + 1LL;
    }
    s = str_concat(s, "]");
    return s;
}

double * multiply_poly(double * a, size_t a_len, double * b, size_t b_len) {
    long long n = 1LL;
    while (n < ((a_len + b_len) - 1LL)) {
        n = n * 2LL;
    }
    Complex *fa = make_complex_list(n, (Complex){.re = 0.0, .im = 0.0});
    size_t fa_len = make_complex_list_len;
    Complex *fb = make_complex_list(n, (Complex){.re = 0.0, .im = 0.0});
    size_t fb_len = make_complex_list_len;
    long long i = 0LL;
    while (i < a_len) {
        fa[(int)(i)] = (Complex){.re = a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})], .im = 0.0};
        i = i + 1LL;
    }
    i = 0LL;
    while (i < b_len) {
        fb[(int)(i)] = (Complex){.re = b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})], .im = 0.0};
        i = i + 1LL;
    }
    fa = fft(fa, fa_len, 0LL);
    fa_len = fft_len;
    fb = fft(fb, fb_len, 0LL);
    fb_len = fft_len;
    i = 0LL;
    while (i < n) {
        fa[(int)(i)] = c_mul(fa[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? fa_len + _mochi_idx : _mochi_idx;})], fb[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? fb_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    fa = fft(fa, fa_len, 1LL);
    fa_len = fft_len;
    double *res = NULL;
    size_t res_len = 0;
    i = 0LL;
    while (i < ((a_len + b_len) - 1LL)) {
        Complex val = fa[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? fa_len + _mochi_idx : _mochi_idx;})];
        res = list_append_double(res, &res_len, round_to(val.re, 8LL));
        i = i + 1LL;
    }
    while ((res_len > 0LL) && (res[(int)({long long _mochi_idx = res_len - 1LL; _mochi_idx < 0 ? res_len + _mochi_idx : _mochi_idx;})] == 0.0)) {
        res = _slice_double(res, res_len, 0LL, res_len - 1LL, &(_slice_double_len));
        res_len = _slice_double_len;
    }
    return multiply_poly_len = res_len, res;
}

int main(void) {
    {
        long long __start = _now();
        product = multiply_poly(A, A_len, B, B_len);
        product_len = multiply_poly_len;
        puts(list_to_string(product, product_len));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
