// Generated by Mochi 0.10.32 on 2025-08-11 21:16 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t design_matrix_len;
size_t *design_matrix_lens;
size_t transpose_len;
size_t *transpose_lens;
size_t matmul_len;
size_t *matmul_lens;
size_t matvec_mul_len;
size_t gaussian_elimination_len;
size_t predict_len;

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_double(const double *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[64];
        snprintf(tmp, sizeof(tmp), "%g", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double* list_append_double_new(const double *arr, size_t len, double val) {
    double *res = malloc((len + 1) * sizeof(double));
    if (arr && len) memcpy(res, arr, len * sizeof(double));
    res[len] = val;
    return res;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double *xs = NULL;
size_t xs_len = 0;
double *ys = NULL;
size_t ys_len = 0;
long long i = 0LL;
double **X = NULL;
size_t X_len = 0;
size_t *X_lens = NULL;
size_t X_lens_len = 0;
double **Xt = NULL;
size_t Xt_len = 0;
size_t *Xt_lens = NULL;
size_t Xt_lens_len = 0;
double **XtX = NULL;
size_t XtX_len = 0;
size_t *XtX_lens = NULL;
size_t XtX_lens_len = 0;
double *Xty = NULL;
size_t Xty_len = 0;
double *coeffs = NULL;
size_t coeffs_len = 0;

double * * design_matrix(double * xs, size_t xs_len, long long degree);
double * * transpose(double * * matrix, size_t matrix_len, size_t* matrix_lens, size_t matrix_lens_len);
double * * matmul(double * * A, size_t A_len, size_t* A_lens, size_t A_lens_len, double * * B, size_t B_len, size_t* B_lens, size_t B_lens_len);
double * matvec_mul(double * * A, size_t A_len, size_t* A_lens, size_t A_lens_len, double * v, size_t v_len);
double * gaussian_elimination(double * * A, size_t A_len, size_t* A_lens, size_t A_lens_len, double * b, size_t b_len);
double * predict(double * xs, size_t xs_len, double * coeffs, size_t coeffs_len);
int main(void);

double * * design_matrix(double * xs, size_t xs_len, long long degree) {
    long long i = 0LL;
    double **matrix = NULL;
    size_t matrix_len = 0;
    size_t *matrix_lens = NULL;
    size_t matrix_lens_len = 0;
    while (i < xs_len) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        double pow = 1.0;
        while (j <= degree) {
            row = list_append_double(row, &row_len, pow);
            pow = pow * xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})];
            j = j + 1LL;
        }
        matrix = list_append_doubleptr(matrix, &matrix_len, row);
        matrix_lens = list_append_szt(matrix_lens, &matrix_lens_len, row_len);
        i = i + 1LL;
    }
    return design_matrix_lens = matrix_lens, design_matrix_len = matrix_len, matrix;
}

double * * transpose(double * * matrix, size_t matrix_len, size_t* matrix_lens, size_t matrix_lens_len) {
    long long rows = matrix_len;
    long long cols = matrix_lens[0LL];
    long long j = 0LL;
    double **result = NULL;
    size_t result_len = 0;
    size_t *result_lens = NULL;
    size_t result_lens_len = 0;
    while (j < cols) {
        double *row = NULL;
        size_t row_len = 0;
        long long i = 0LL;
        while (i < rows) {
            row = list_append_double(row, &row_len, matrix[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? matrix_lens[i] + _mochi_idx : _mochi_idx;})]);
            i = i + 1LL;
        }
        result = list_append_doubleptr(result, &result_len, row);
        result_lens = list_append_szt(result_lens, &result_lens_len, row_len);
        j = j + 1LL;
    }
    return transpose_lens = result_lens, transpose_len = result_len, result;
}

double * * matmul(double * * A, size_t A_len, size_t* A_lens, size_t A_lens_len, double * * B, size_t B_len, size_t* B_lens, size_t B_lens_len) {
    long long n = A_len;
    long long m = A_lens[0LL];
    long long p = B_lens[0LL];
    long long i = 0LL;
    double **result = NULL;
    size_t result_len = 0;
    size_t *result_lens = NULL;
    size_t result_lens_len = 0;
    while (i < n) {
        double *row = NULL;
        size_t row_len = 0;
        long long k = 0LL;
        while (k < p) {
            double sum = 0.0;
            long long j = 0LL;
            while (j < m) {
                sum = sum + (A[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? A_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? A_lens[i] + _mochi_idx : _mochi_idx;})] * B[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? B_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? B_lens[j] + _mochi_idx : _mochi_idx;})]);
                j = j + 1LL;
            }
            row = list_append_double(row, &row_len, sum);
            k = k + 1LL;
        }
        result = list_append_doubleptr(result, &result_len, row);
        result_lens = list_append_szt(result_lens, &result_lens_len, row_len);
        i = i + 1LL;
    }
    return matmul_lens = result_lens, matmul_len = result_len, result;
}

double * matvec_mul(double * * A, size_t A_len, size_t* A_lens, size_t A_lens_len, double * v, size_t v_len) {
    long long n = A_len;
    long long m = A_lens[0LL];
    long long i = 0LL;
    double *result = NULL;
    size_t result_len = 0;
    while (i < n) {
        double sum = 0.0;
        long long j = 0LL;
        while (j < m) {
            sum = sum + (A[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? A_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? A_lens[i] + _mochi_idx : _mochi_idx;})] * v[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? v_len + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        result = list_append_double(result, &result_len, sum);
        i = i + 1LL;
    }
    return matvec_mul_len = result_len, result;
}

double * gaussian_elimination(double * * A, size_t A_len, size_t* A_lens, size_t A_lens_len, double * b, size_t b_len) {
    long long n = A_len;
    double **M = NULL;
    size_t M_len = 0;
    size_t *M_lens = NULL;
    size_t M_lens_len = 0;
    long long i = 0LL;
    while (i < n) {
        M = list_append_doubleptr(M, &M_len, list_append_double_new(A[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? A_len + _mochi_idx : _mochi_idx;})], A_lens[(int)(i)], b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})]));
        M_lens = list_append_szt(M_lens, &M_lens_len, A_lens[i] + 1);
        i = i + 1LL;
    }
    long long k = 0LL;
    while (k < n) {
        long long j = k + 1LL;
        while (j < n) {
            double factor = M[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? M_lens[j] + _mochi_idx : _mochi_idx;})] / M[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? M_lens[k] + _mochi_idx : _mochi_idx;})];
            double *rowj = M[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})];
            size_t rowj_len = M_lens[j];
            double *rowk = M[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})];
            size_t rowk_len = M_lens[k];
            long long l = k;
            while (l <= n) {
                rowj[(int)(l)] = rowj[(int)({long long _mochi_idx = l; _mochi_idx < 0 ? rowj_len + _mochi_idx : _mochi_idx;})] - (factor * rowk[(int)({long long _mochi_idx = l; _mochi_idx < 0 ? rowk_len + _mochi_idx : _mochi_idx;})]);
                l = l + 1LL;
            }
            M[(int)(j)] = rowj;
            j = j + 1LL;
        }
        k = k + 1LL;
    }
    double *x = NULL;
    size_t x_len = 0;
    long long t = 0LL;
    while (t < n) {
        x = list_append_long_long(x, &x_len, 0.0);
        t = t + 1LL;
    }
    long long i2 = n - 1LL;
    while (i2 >= 0LL) {
        double sum = M[(int)({long long _mochi_idx = i2; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = n; _mochi_idx < 0 ? M_lens[i2] + _mochi_idx : _mochi_idx;})];
        long long j2 = i2 + 1LL;
        while (j2 < n) {
            sum = sum - (M[(int)({long long _mochi_idx = i2; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j2; _mochi_idx < 0 ? M_lens[i2] + _mochi_idx : _mochi_idx;})] * x[(int)({long long _mochi_idx = j2; _mochi_idx < 0 ? x_len + _mochi_idx : _mochi_idx;})]);
            j2 = j2 + 1LL;
        }
        x[(int)(i2)] = sum / M[(int)({long long _mochi_idx = i2; _mochi_idx < 0 ? M_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = i2; _mochi_idx < 0 ? M_lens[i2] + _mochi_idx : _mochi_idx;})];
        i2 = i2 - 1LL;
    }
    return gaussian_elimination_len = x_len, x;
}

double * predict(double * xs, size_t xs_len, double * coeffs, size_t coeffs_len) {
    long long i = 0LL;
    double *result = NULL;
    size_t result_len = 0;
    while (i < xs_len) {
        double x = xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})];
        long long j = 0LL;
        double pow = 1.0;
        double sum = 0.0;
        while (j < coeffs_len) {
            sum = sum + (coeffs[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? coeffs_len + _mochi_idx : _mochi_idx;})] * pow);
            pow = pow * x;
            j = j + 1LL;
        }
        result = list_append_double(result, &result_len, sum);
        i = i + 1LL;
    }
    return predict_len = result_len, result;
}

int main(void) {
    {
        long long __start = _now();
        xs = ({long long *tmp = malloc(11 * sizeof(long long)); tmp[0] = 0.0; tmp[1] = 1.0; tmp[2] = 2.0; tmp[3] = 3.0; tmp[4] = 4.0; tmp[5] = 5.0; tmp[6] = 6.0; tmp[7] = 7.0; tmp[8] = 8.0; tmp[9] = 9.0; tmp[10] = 10.0; tmp;});
        xs_len = 11;
        ys = NULL;
        ys_len = 0;
        while (i < 11LL) {
            double x = xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})];
            ys = list_append_double(ys, &ys_len, ((((x * x) * x) - ((2.0 * x) * x)) + (3.0 * x)) - 5.0);
            i = i + 1LL;
        }
        X = design_matrix(xs, xs_len, 3LL);
        X_len = design_matrix_len;
        X_lens = design_matrix_lens;
        Xt = transpose(X, X_len, X_lens, X_len);
        Xt_len = transpose_len;
        Xt_lens = transpose_lens;
        XtX = matmul(Xt, Xt_len, Xt_lens, Xt_len, X, X_len, X_lens, X_len);
        XtX_len = matmul_len;
        XtX_lens = matmul_lens;
        Xty = matvec_mul(Xt, Xt_len, Xt_lens, Xt_len, ys, ys_len);
        Xty_len = matvec_mul_len;
        coeffs = gaussian_elimination(XtX, XtX_len, XtX_lens, XtX_len, Xty, Xty_len);
        coeffs_len = gaussian_elimination_len;
        puts(str_list_double(coeffs, coeffs_len));
        puts(({double *__tmp3 = predict(({long long *tmp = malloc(1 * sizeof(long long)); tmp[0] = -(1.0); tmp;}), 1, coeffs, coeffs_len); char *__res = str_list_double(__tmp3, predict_len); __res;}));
        puts(({double *__tmp4 = predict(({double *tmp = malloc(1 * sizeof(double)); tmp[0] = -(2.0); tmp;}), 1, coeffs, coeffs_len); char *__res = str_list_double(__tmp4, predict_len); __res;}));
        puts(({double *__tmp5 = predict(({double *tmp = malloc(1 * sizeof(double)); tmp[0] = 6.0; tmp;}), 1, coeffs, coeffs_len); char *__res = str_list_double(__tmp5, predict_len); __res;}));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
