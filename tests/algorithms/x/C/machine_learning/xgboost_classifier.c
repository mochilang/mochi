// Generated by Mochi 0.10.32 on 2025-08-11 21:16 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t boost_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static size_t concat_len;
static long long* concat_long_long(long long *a, size_t a_len, const long long *b, size_t b_len) {
    long long *res = realloc(a, (a_len + b_len) * sizeof(long long));
    if (b_len > 0) memcpy(res + a_len, b, b_len * sizeof(long long));
    concat_len = a_len + b_len;
    return res;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Stump Stump;

struct Stump {
    long long feature;
    double threshold;
    double left;
    double right;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double mean(double * xs, size_t xs_len);
double stump_predict(Stump s, double * x, size_t x_len);
Stump train_stump(double * * features, size_t features_len, size_t* features_lens, size_t features_lens_len, double * residuals, size_t residuals_len);
Stump * boost(double * * features, size_t features_len, size_t* features_lens, size_t features_lens_len, long long * targets, size_t targets_len, long long rounds);
double predict(Stump * model, size_t model_len, double * x, size_t x_len);
void user_main();
int main(void);

double mean(double * xs, size_t xs_len) {
    double sum = 0.0;
    long long i = 0LL;
    while (i < xs_len) {
        sum = sum + xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})];
        i = i + 1LL;
    }
    return sum / (xs_len * 1.0);
}

double stump_predict(Stump s, double * x, size_t x_len) {
    if (x[(int)({long long _mochi_idx = s.feature; _mochi_idx < 0 ? x_len + _mochi_idx : _mochi_idx;})] < s.threshold) {
        return s.left;
    }
    return s.right;
}

Stump train_stump(double * * features, size_t features_len, size_t* features_lens, size_t features_lens_len, double * residuals, size_t residuals_len) {
    long long best_feature = 0LL;
    double best_threshold = 0.0;
    double best_error = 1000000000.0;
    double best_left = 0.0;
    double best_right = 0.0;
    long long num_features = features_lens[0LL];
    long long f = 0LL;
    while (f < num_features) {
        long long i = 0LL;
        while (i < features_len) {
            double threshold = features[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? features_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = f; _mochi_idx < 0 ? features_lens[i] + _mochi_idx : _mochi_idx;})];
            double *left = NULL;
            size_t left_len = 0;
            double *right = NULL;
            size_t right_len = 0;
            long long j = 0LL;
            while (j < features_len) {
                if (features[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? features_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = f; _mochi_idx < 0 ? features_lens[j] + _mochi_idx : _mochi_idx;})] < threshold) {
                    left = concat_long_long(left, left_len, ({double *tmp = malloc(1 * sizeof(double)); tmp[0] = residuals[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? residuals_len + _mochi_idx : _mochi_idx;})]; tmp;}), 1);
                    left_len = concat_len;
                } else {
                    right = concat_long_long(right, right_len, ({double *tmp = malloc(1 * sizeof(double)); tmp[0] = residuals[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? residuals_len + _mochi_idx : _mochi_idx;})]; tmp;}), 1);
                    right_len = concat_len;
                }
                j = j + 1LL;
            }
            if ((left_len != 0LL) && (right_len != 0LL)) {
                double left_mean = mean(left, left_len);
                double right_mean = mean(right, right_len);
                double err = 0.0;
                j = 0LL;
                while (j < features_len) {
                    double pred = (features[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? features_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = f; _mochi_idx < 0 ? features_lens[j] + _mochi_idx : _mochi_idx;})] < threshold ? left_mean : right_mean);
                    double diff = residuals[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? residuals_len + _mochi_idx : _mochi_idx;})] - pred;
                    err = err + (diff * diff);
                    j = j + 1LL;
                }
                if (err < best_error) {
                    best_error = err;
                    best_feature = f;
                    best_threshold = threshold;
                    best_left = left_mean;
                    best_right = right_mean;
                }
            }
            i = i + 1LL;
        }
        f = f + 1LL;
    }
    return (Stump){.feature = best_feature, .threshold = best_threshold, .left = best_left, .right = best_right};
}

Stump * boost(double * * features, size_t features_len, size_t* features_lens, size_t features_lens_len, long long * targets, size_t targets_len, long long rounds) {
    Stump *model = NULL;
    size_t model_len = 0;
    double *preds = NULL;
    size_t preds_len = 0;
    long long i = 0LL;
    while (i < targets_len) {
        preds = concat_long_long(preds, preds_len, ({long long *tmp = malloc(1 * sizeof(long long)); tmp[0] = 0.0; tmp;}), 1);
        preds_len = concat_len;
        i = i + 1LL;
    }
    long long r = 0LL;
    while (r < rounds) {
        double *residuals = NULL;
        size_t residuals_len = 0;
        long long j = 0LL;
        while (j < targets_len) {
            residuals = concat_long_long(residuals, residuals_len, ({double *tmp = malloc(1 * sizeof(double)); tmp[0] = targets[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? targets_len + _mochi_idx : _mochi_idx;})] - preds[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? preds_len + _mochi_idx : _mochi_idx;})]; tmp;}), 1);
            residuals_len = concat_len;
            j = j + 1LL;
        }
        Stump stump = train_stump(features, features_len, features_lens, features_len, residuals, residuals_len);
        model = concat_long_long(model, model_len, ({Stump *tmp = malloc(1 * sizeof(Stump)); tmp[0] = stump; tmp;}), 1);
        model_len = concat_len;
        j = 0LL;
        while (j < preds_len) {
            preds[(int)(j)] = preds[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? preds_len + _mochi_idx : _mochi_idx;})] + stump_predict(stump, features[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? features_len + _mochi_idx : _mochi_idx;})], features_lens[j]);
            j = j + 1LL;
        }
        r = r + 1LL;
    }
    return boost_len = model_len, model;
}

double predict(Stump * model, size_t model_len, double * x, size_t x_len) {
    double score = 0.0;
    long long i = 0LL;
    while (i < model_len) {
        Stump s = model[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? model_len + _mochi_idx : _mochi_idx;})];
        if (x[(int)({long long _mochi_idx = s.feature; _mochi_idx < 0 ? x_len + _mochi_idx : _mochi_idx;})] < s.threshold) {
            score = score + s.left;
        } else {
            score = score + s.right;
        }
        i = i + 1LL;
    }
    return score;
}

void user_main() {
    double features_0[2] = {5.1, 3.5};
    double features_1[2] = {4.9, 3.0};
    double features_2[2] = {6.2, 3.4};
    double features_3[2] = {5.9, 3.0};
    double *features_init[4] = {features_0, features_1, features_2, features_3};
    double **features = features_init;
    size_t features_len = 4;
    size_t features_lens_init[4] = {2, 2, 2, 2};
    size_t *features_lens = features_lens_init;
    size_t features_lens_len = 4;
    long long *targets = NULL;
    size_t targets_len = 0;
    targets = list_append_long_long(targets, &targets_len, 0LL);
    targets = list_append_long_long(targets, &targets_len, 0LL);
    targets = list_append_long_long(targets, &targets_len, 1LL);
    targets = list_append_long_long(targets, &targets_len, 1LL);
    Stump *model = boost(features, features_len, features_lens, features_len, targets, targets_len, 3LL);
    size_t model_len = boost_len;
    const char* out = "";
    long long i = 0LL;
    while (i < features_len) {
        double s = predict(model, model_len, features[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? features_len + _mochi_idx : _mochi_idx;})], features_lens[i]);
        long long label = (s >= 0.5 ? 1LL : 0LL);
        if (i == 0LL) {
            out = str_int(label);
        } else {
            out = str_concat(str_concat(out, " "), str_int(label));
        }
        i = i + 1LL;
    }
    puts(out);
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
