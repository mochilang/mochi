// Generated by Mochi 0.10.32 on 2025-08-11 21:16 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t standardize_len;
size_t *standardize_lens;
size_t covariance_matrix_len;
size_t *covariance_matrix_lens;
size_t normalize_len;
size_t transpose_len;
size_t *transpose_lens;
size_t matrix_multiply_len;
size_t *matrix_multiply_lens;

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Eigen Eigen;
typedef struct PCAResult PCAResult;

struct Eigen {
    double *values;
    size_t values_len;
    double **vectors;
    size_t vectors_len;
    size_t *vectors_lens;
    size_t vectors_lens_len;
};

struct PCAResult {
    double **transformed;
    size_t transformed_len;
    size_t *transformed_lens;
    size_t transformed_lens_len;
    double *variance_ratio;
    size_t variance_ratio_len;
};

double **data = NULL;
size_t data_len = 0;
size_t *data_lens = NULL;
size_t data_lens_len = 0;
PCAResult result;
long long idx = 0LL;

double sqrt(double x);
double mean(double * xs, size_t xs_len);
double * * standardize(double * * data, size_t data_len, size_t* data_lens, size_t data_lens_len);
double * * covariance_matrix(double * * data, size_t data_len, size_t* data_lens, size_t data_lens_len);
double * normalize(double * vec, size_t vec_len);
Eigen eigen_decomposition_2x2(double * * matrix, size_t matrix_len, size_t* matrix_lens, size_t matrix_lens_len);
double * * transpose(double * * matrix, size_t matrix_len, size_t* matrix_lens, size_t matrix_lens_len);
double * * matrix_multiply(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len);
PCAResult apply_pca(double * * data, size_t data_len, size_t* data_lens, size_t data_lens_len, long long n_components);
int main(void);

double sqrt(double x) {
    long long guess = (x > 1.0 ? x / 2.0 : 1.0);
    long long i = 0LL;
    while (i < 20LL) {
        guess = 0.5 * (guess + (x / guess));
        i = i + 1LL;
    }
    return guess;
}

double mean(double * xs, size_t xs_len) {
    double sum = 0.0;
    long long i = 0LL;
    while (i < xs_len) {
        sum = sum + xs[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? xs_len + _mochi_idx : _mochi_idx;})];
        i = i + 1LL;
    }
    return sum / xs_len;
}

double * * standardize(double * * data, size_t data_len, size_t* data_lens, size_t data_lens_len) {
    long long n_samples = data_len;
    long long n_features = data_lens[0LL];
    double *means = NULL;
    size_t means_len = 0;
    double *stds = NULL;
    size_t stds_len = 0;
    long long j = 0LL;
    while (j < n_features) {
        double *column = NULL;
        size_t column_len = 0;
        long long i = 0LL;
        while (i < n_samples) {
            column = list_append_double(column, &column_len, data[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? data_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? data_lens[i] + _mochi_idx : _mochi_idx;})]);
            i = i + 1LL;
        }
        double m = mean(column, column_len);
        means = list_append_double(means, &means_len, m);
        double variance = 0.0;
        long long k = 0LL;
        while (k < n_samples) {
            double diff = column[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? column_len + _mochi_idx : _mochi_idx;})] - m;
            variance = variance + (diff * diff);
            k = k + 1LL;
        }
        stds = list_append_double(stds, &stds_len, sqrt(variance / (n_samples - 1LL)));
        j = j + 1LL;
    }
    double **standardized = NULL;
    size_t standardized_len = 0;
    size_t *standardized_lens = NULL;
    size_t standardized_lens_len = 0;
    long long r = 0LL;
    while (r < n_samples) {
        double *row = NULL;
        size_t row_len = 0;
        long long c = 0LL;
        while (c < n_features) {
            row = list_append_double(row, &row_len, (data[(int)({long long _mochi_idx = r; _mochi_idx < 0 ? data_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = c; _mochi_idx < 0 ? data_lens[r] + _mochi_idx : _mochi_idx;})] - means[(int)({long long _mochi_idx = c; _mochi_idx < 0 ? means_len + _mochi_idx : _mochi_idx;})]) / stds[(int)({long long _mochi_idx = c; _mochi_idx < 0 ? stds_len + _mochi_idx : _mochi_idx;})]);
            c = c + 1LL;
        }
        standardized = list_append_doubleptr(standardized, &standardized_len, row);
        standardized_lens = list_append_szt(standardized_lens, &standardized_lens_len, row_len);
        r = r + 1LL;
    }
    return standardize_lens = standardized_lens, standardize_len = standardized_len, standardized;
}

double * * covariance_matrix(double * * data, size_t data_len, size_t* data_lens, size_t data_lens_len) {
    long long n_samples = data_len;
    long long n_features = data_lens[0LL];
    double **cov = NULL;
    size_t cov_len = 0;
    size_t *cov_lens = NULL;
    size_t cov_lens_len = 0;
    long long i = 0LL;
    while (i < n_features) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < n_features) {
            double sum = 0.0;
            long long k = 0LL;
            while (k < n_samples) {
                sum = sum + (data[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? data_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = i; _mochi_idx < 0 ? data_lens[k] + _mochi_idx : _mochi_idx;})] * data[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? data_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? data_lens[k] + _mochi_idx : _mochi_idx;})]);
                k = k + 1LL;
            }
            row = list_append_double(row, &row_len, sum / (n_samples - 1LL));
            j = j + 1LL;
        }
        cov = list_append_doubleptr(cov, &cov_len, row);
        cov_lens = list_append_szt(cov_lens, &cov_lens_len, row_len);
        i = i + 1LL;
    }
    return covariance_matrix_lens = cov_lens, covariance_matrix_len = cov_len, cov;
}

double * normalize(double * vec, size_t vec_len) {
    double sum = 0.0;
    long long i = 0LL;
    while (i < vec_len) {
        sum = sum + (vec[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? vec_len + _mochi_idx : _mochi_idx;})] * vec[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? vec_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    double n = sqrt(sum);
    double *res = NULL;
    size_t res_len = 0;
    long long j = 0LL;
    while (j < vec_len) {
        res = list_append_double(res, &res_len, vec[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? vec_len + _mochi_idx : _mochi_idx;})] / n);
        j = j + 1LL;
    }
    return normalize_len = res_len, res;
}

Eigen eigen_decomposition_2x2(double * * matrix, size_t matrix_len, size_t* matrix_lens, size_t matrix_lens_len) {
    double a = matrix[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? matrix_lens[0LL] + _mochi_idx : _mochi_idx;})];
    double b = matrix[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? matrix_lens[0LL] + _mochi_idx : _mochi_idx;})];
    double c = matrix[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? matrix_lens[1LL] + _mochi_idx : _mochi_idx;})];
    double diff = a - c;
    double discriminant = sqrt((diff * diff) + ((4.0 * b) * b));
    double lambda1 = ((a + c) + discriminant) / 2.0;
    double lambda2 = ((a + c) - discriminant) / 2.0;
    double *v1 = NULL;
    size_t v1_len = 0;
    double *v2 = NULL;
    size_t v2_len = 0;
    if (b != 0.0) {
        v1 = normalize(({double *tmp = malloc(2 * sizeof(double)); tmp[0] = lambda1 - c; tmp[1] = b; tmp;}), 2);
        v1_len = normalize_len;
        v2 = normalize(({double *tmp = malloc(2 * sizeof(double)); tmp[0] = lambda2 - c; tmp[1] = b; tmp;}), 2);
        v2_len = normalize_len;
    } else {
        v1 = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1.0; tmp[1] = 0.0; tmp;});
        v1_len = 2;
        v2 = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 0.0; tmp[1] = 1.0; tmp;});
        v2_len = 2;
    }
    double *eigenvalues = NULL;
    size_t eigenvalues_len = 0;
    eigenvalues = list_append_double(eigenvalues, &eigenvalues_len, lambda1);
    eigenvalues = list_append_double(eigenvalues, &eigenvalues_len, lambda2);
    double **eigenvectors = NULL;
    size_t eigenvectors_len = 0;
    size_t *eigenvectors_lens = NULL;
    size_t eigenvectors_lens_len = 0;
    if (eigenvalues[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})] < eigenvalues[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})]) {
        double tmp_val = eigenvalues[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})];
        eigenvalues[(int)(0LL)] = eigenvalues[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})];
        eigenvalues[(int)(1LL)] = tmp_val;
        double *tmp_vec = eigenvectors[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? eigenvectors_len + _mochi_idx : _mochi_idx;})];
        size_t tmp_vec_len = eigenvectors_lens[0LL];
        eigenvectors[(int)(0LL)] = eigenvectors[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? eigenvectors_len + _mochi_idx : _mochi_idx;})];
        eigenvectors[(int)(1LL)] = tmp_vec;
    }
    return (Eigen){.values = eigenvalues, .values_len = eigenvalues_len, .vectors = eigenvectors, .vectors_len = eigenvectors_len, .vectors_lens = eigenvectors_lens, .vectors_lens_len = eigenvectors_len};
}

double * * transpose(double * * matrix, size_t matrix_len, size_t* matrix_lens, size_t matrix_lens_len) {
    long long rows = matrix_len;
    long long cols = matrix_lens[0LL];
    double **trans = NULL;
    size_t trans_len = 0;
    size_t *trans_lens = NULL;
    size_t trans_lens_len = 0;
    long long i = 0LL;
    while (i < cols) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < rows) {
            row = list_append_double(row, &row_len, matrix[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? matrix_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = i; _mochi_idx < 0 ? matrix_lens[j] + _mochi_idx : _mochi_idx;})]);
            j = j + 1LL;
        }
        trans = list_append_doubleptr(trans, &trans_len, row);
        trans_lens = list_append_szt(trans_lens, &trans_lens_len, row_len);
        i = i + 1LL;
    }
    return transpose_lens = trans_lens, transpose_len = trans_len, trans;
}

double * * matrix_multiply(double * * a, size_t a_len, size_t* a_lens, size_t a_lens_len, double * * b, size_t b_len, size_t* b_lens, size_t b_lens_len) {
    long long rows_a = a_len;
    long long cols_a = a_lens[0LL];
    long long rows_b = b_len;
    long long cols_b = b_lens[0LL];
    if (cols_a != rows_b) {
        panic("Incompatible matrices");
    }
    double **result = NULL;
    size_t result_len = 0;
    size_t *result_lens = NULL;
    size_t result_lens_len = 0;
    long long i = 0LL;
    while (i < rows_a) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < cols_b) {
            double sum = 0.0;
            long long k = 0LL;
            while (k < cols_a) {
                sum = sum + (a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = k; _mochi_idx < 0 ? a_lens[i] + _mochi_idx : _mochi_idx;})] * b[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? b_lens[k] + _mochi_idx : _mochi_idx;})]);
                k = k + 1LL;
            }
            row = list_append_double(row, &row_len, sum);
            j = j + 1LL;
        }
        result = list_append_doubleptr(result, &result_len, row);
        result_lens = list_append_szt(result_lens, &result_lens_len, row_len);
        i = i + 1LL;
    }
    return matrix_multiply_lens = result_lens, matrix_multiply_len = result_len, result;
}

PCAResult apply_pca(double * * data, size_t data_len, size_t* data_lens, size_t data_lens_len, long long n_components) {
    double **standardized = standardize(data, data_len, data_lens, data_len);
    size_t standardized_len = standardize_len;
    size_t *standardized_lens = standardize_lens;
    size_t standardized_lens_len = standardize_len;
    double **cov = covariance_matrix(standardized, standardized_len, standardized_lens, standardized_len);
    size_t cov_len = covariance_matrix_len;
    size_t *cov_lens = covariance_matrix_lens;
    size_t cov_lens_len = covariance_matrix_len;
    Eigen eig = eigen_decomposition_2x2(cov, cov_len, cov_lens, cov_len);
    double *eigenvalues = eig.values;
    size_t eigenvalues_len = eig.values_len;
    double **eigenvectors = eig.vectors;
    size_t eigenvectors_len = eig.vectors_len;
    size_t *eigenvectors_lens = eig.vectors_lens;
    size_t eigenvectors_lens_len = eig.vectors_len;
    double **components = transpose(eigenvectors, eigenvectors_len, eigenvectors_lens, eigenvectors_len);
    size_t components_len = transpose_len;
    size_t *components_lens = transpose_lens;
    size_t components_lens_len = transpose_len;
    double **transformed = matrix_multiply(standardized, standardized_len, standardized_lens, standardized_len, components, components_len, components_lens, components_len);
    size_t transformed_len = matrix_multiply_len;
    size_t *transformed_lens = matrix_multiply_lens;
    size_t transformed_lens_len = matrix_multiply_len;
    double total = eigenvalues[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})] + eigenvalues[(int)({long long _mochi_idx = 1LL; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})];
    double *ratios = NULL;
    size_t ratios_len = 0;
    long long i = 0LL;
    while (i < n_components) {
        ratios = list_append_double(ratios, &ratios_len, eigenvalues[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? eigenvalues_len + _mochi_idx : _mochi_idx;})] / total);
        i = i + 1LL;
    }
    return (PCAResult){.transformed = transformed, .transformed_len = transformed_len, .transformed_lens = transformed_lens, .transformed_lens_len = transformed_len, .variance_ratio = ratios, .variance_ratio_len = ratios_len};
}

int main(void) {
    {
        long long __start = _now();
        data = ({double** tmp = malloc(10 * sizeof(double*)); tmp[0] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 2.5; tmp[1] = 2.4; tmp;}); tmp[1] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 0.5; tmp[1] = 0.7; tmp;}); tmp[2] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 2.2; tmp[1] = 2.9; tmp;}); tmp[3] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 1.9; tmp[1] = 2.2; tmp;}); tmp[4] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 3.1; tmp[1] = 3.0; tmp;}); tmp[5] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 2.3; tmp[1] = 2.7; tmp;}); tmp[6] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 2.0; tmp[1] = 1.6; tmp;}); tmp[7] = ({long long *tmp = malloc(2 * sizeof(long long)); tmp[0] = 1.0; tmp[1] = 1.1; tmp;}); tmp[8] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 1.5; tmp[1] = 1.6; tmp;}); tmp[9] = ({double *tmp = malloc(2 * sizeof(double)); tmp[0] = 1.1; tmp[1] = 0.9; tmp;}); tmp;});
        data_len = 10;
        data_lens = ({size_t *tmp = malloc(10 * sizeof(size_t)); tmp[0] = 2; tmp[1] = 2; tmp[2] = 2; tmp[3] = 2; tmp[4] = 2; tmp[5] = 2; tmp[6] = 2; tmp[7] = 2; tmp[8] = 2; tmp[9] = 2; tmp;});
        data_lens_len = 10;
        result = apply_pca(data, data_len, data_lens, data_len, 2LL);
        puts("Transformed Data (first 5 rows):");
        while (idx < 5LL) {
            printf("%d\n", result.transformed[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? result.transformed_len + _mochi_idx : _mochi_idx;})]);
            idx = idx + 1LL;
        }
        puts("Explained Variance Ratio:");
        printf("%d\n", result.variance_ratio);
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
