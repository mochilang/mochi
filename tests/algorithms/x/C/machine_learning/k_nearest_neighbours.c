// Generated by Mochi 0.10.32 on 2025-08-16 20:21 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>


size_t append_len;
#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct DistLabel DistLabel;
typedef struct KNN KNN;
typedef struct PointLabel PointLabel;

struct DistLabel {
    double dist;
    long long label;
};

struct KNN {
    PointLabel *data;
    size_t data_len;
    const char* *labels;
    size_t labels_len;
};

struct PointLabel {
    double *point;
    size_t point_len;
    long long label;
};

static PointLabel* list_append_PointLabel(PointLabel *arr, size_t *len, PointLabel val) {
    arr = realloc(arr, (*len + 1) * sizeof(PointLabel));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static DistLabel* list_append_DistLabel(DistLabel *arr, size_t *len, DistLabel val) {
    arr = realloc(arr, (*len + 1) * sizeof(DistLabel));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double train_X_0[2] = {0.0, 0.0};
double train_X_1[2] = {1.0, 0.0};
double train_X_2[2] = {0.0, 1.0};
double train_X_3[2] = {0.5, 0.5};
double train_X_4[2] = {3.0, 3.0};
double train_X_5[2] = {2.0, 3.0};
double train_X_6[2] = {3.0, 2.0};
double *train_X_init[7] = {train_X_0, train_X_1, train_X_2, train_X_3, train_X_4, train_X_5, train_X_6};
double **train_X = train_X_init;
size_t train_X_len = 7;
size_t train_X_lens_init[7] = {2, 2, 2, 2, 2, 2, 2};
size_t *train_X_lens = train_X_lens_init;
size_t train_X_lens_len = 7;
long long train_y_init[7] = {0LL, 0LL, 0LL, 0LL, 1LL, 1LL, 1LL};
long long *train_y = train_y_init;
size_t train_y_len = 7;
const char* classes_init[2] = {"A", "B"};
const char* *classes = classes_init;
size_t classes_len = 2;
KNN knn;
double point_init[2] = {1.2, 1.2};
double *point = point_init;
size_t point_len = 2;

double sqrtApprox(double x);
KNN make_knn(double * * train_data, size_t train_data_len, size_t* train_data_lens, size_t train_data_lens_len, long long * train_target, size_t train_target_len, const char* * class_labels, size_t class_labels_len);
double euclidean_distance(double * a, size_t a_len, double * b, size_t b_len);
const char* classify(KNN knn, double * pred_point, size_t pred_point_len, long long k);
int main(void);

double sqrtApprox(double x) {
    if (x <= 0.0) {
        return 0.0;
    }
    double guess = x;
    long long i = 0LL;
    while (i < 20LL) {
        guess = (guess + (x / guess)) / 2.0;
        i = i + 1LL;
    }
    return guess;
}

KNN make_knn(double * * train_data, size_t train_data_len, size_t* train_data_lens, size_t train_data_lens_len, long long * train_target, size_t train_target_len, const char* * class_labels, size_t class_labels_len) {
    PointLabel *items = NULL;
    size_t items_len = 0;
    long long i = 0LL;
    while (i < train_data_len) {
        PointLabel pl = (PointLabel){.point = train_data[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? train_data_len + _mochi_idx : _mochi_idx;})], .point_len = train_data_lens[(int)(i)], .label = train_target[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? train_target_len + _mochi_idx : _mochi_idx;})]};
        items = list_append_PointLabel(items, &items_len, pl);
        i = i + 1LL;
    }
    return (KNN){.data = items, .data_len = items_len, .labels = class_labels, .labels_len = class_labels_len};
}

double euclidean_distance(double * a, size_t a_len, double * b, size_t b_len) {
    double sum = 0.0;
    long long i = 0LL;
    while (i < a_len) {
        double diff = a[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})] - b[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? b_len + _mochi_idx : _mochi_idx;})];
        sum = sum + (diff * diff);
        i = i + 1LL;
    }
    return sqrtApprox(sum);
}

const char* classify(KNN knn, double * pred_point, size_t pred_point_len, long long k) {
    DistLabel *distances = NULL;
    size_t distances_len = 0;
    long long i = 0LL;
    while (i < knn.data_len) {
        double d = euclidean_distance(knn.data[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? knn.data_len + _mochi_idx : _mochi_idx;})].point, knn.data[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? knn.data_len + _mochi_idx : _mochi_idx;})].point_len, pred_point, pred_point_len);
        distances = list_append_DistLabel(distances, &distances_len, (DistLabel){.dist = d, .label = knn.data[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? knn.data_len + _mochi_idx : _mochi_idx;})].label});
        i = i + 1LL;
    }
    long long *votes = NULL;
    size_t votes_len = 0;
    long long count = 0LL;
    while (count < k) {
        long long min_index = 0LL;
        long long j = 1LL;
        while (j < distances_len) {
            if (distances[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? distances_len + _mochi_idx : _mochi_idx;})].dist < distances[(int)({long long _mochi_idx = min_index; _mochi_idx < 0 ? distances_len + _mochi_idx : _mochi_idx;})].dist) {
                min_index = j;
            }
            j = j + 1LL;
        }
        votes = list_append_long_long(votes, &votes_len, distances[(int)({long long _mochi_idx = min_index; _mochi_idx < 0 ? distances_len + _mochi_idx : _mochi_idx;})].label);
        distances[(int)(min_index)].dist = 1e+18;
        count = count + 1LL;
    }
    long long *tally = NULL;
    size_t tally_len = 0;
    long long t = 0LL;
    while (t < knn.labels_len) {
        tally = list_append_long_long(tally, &tally_len, 0LL);
        t = t + 1LL;
    }
    long long v = 0LL;
    while (v < votes_len) {
        long long lbl = votes[(int)({long long _mochi_idx = v; _mochi_idx < 0 ? votes_len + _mochi_idx : _mochi_idx;})];
        tally[(int)(lbl)] = tally[(int)({long long _mochi_idx = lbl; _mochi_idx < 0 ? tally_len + _mochi_idx : _mochi_idx;})] + 1LL;
        v = v + 1LL;
    }
    long long max_idx = 0LL;
    long long m = 1LL;
    while (m < tally_len) {
        if (tally[(int)({long long _mochi_idx = m; _mochi_idx < 0 ? tally_len + _mochi_idx : _mochi_idx;})] > tally[(int)({long long _mochi_idx = max_idx; _mochi_idx < 0 ? tally_len + _mochi_idx : _mochi_idx;})]) {
            max_idx = m;
        }
        m = m + 1LL;
    }
    return knn.labels[(int)({long long _mochi_idx = max_idx; _mochi_idx < 0 ? knn.labels_len + _mochi_idx : _mochi_idx;})];
}

int main(void) {
    {
        long long __start = _now();
        knn = make_knn(train_X, train_X_len, train_X_lens, train_X_len, train_y, train_y_len, classes, classes_len);
        puts(classify(knn, point, point_len, 5LL));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
