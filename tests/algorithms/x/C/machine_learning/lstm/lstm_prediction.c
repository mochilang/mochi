// Generated by Mochi 0.10.32 on 2025-08-11 21:16 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>


size_t _slice_double_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%g", v);
    return strdup(buf);
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static double* _slice_double(const double *arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    double *res = NULL;
    if (n) {
        res = malloc(n * sizeof(double));
        memcpy(res, arr + start, n * sizeof(double));
    }
    *out_len = n;
    _slice_double_len = n;
    return res;
}

typedef struct LSTMState LSTMState;
typedef struct LSTMWeights LSTMWeights;
typedef struct Samples Samples;

struct LSTMState {
    double *i;
    size_t i_len;
    double *f;
    size_t f_len;
    double *o;
    size_t o_len;
    double *g;
    size_t g_len;
    double *c;
    size_t c_len;
    double *h;
    size_t h_len;
};

struct LSTMWeights {
    double w_i;
    double u_i;
    double b_i;
    double w_f;
    double u_f;
    double b_f;
    double w_o;
    double u_o;
    double b_o;
    double w_c;
    double u_c;
    double b_c;
    double w_y;
    double b_y;
};

struct Samples {
    double **x;
    size_t x_len;
    size_t *x_lens;
    size_t x_lens_len;
    double *y;
    size_t y_len;
};

double *data = NULL;
size_t data_len = 0;
long long look_back = 3LL;
long long epochs = 200LL;
double lr = 0.1;
LSTMWeights w;
double *test_seq = NULL;
size_t test_seq_len = 0;
double pred = 0;

double exp_approx(double x);
double sigmoid(double x);
double tanh_approx(double x);
LSTMState forward(double * seq, size_t seq_len, LSTMWeights w);
LSTMWeights backward(double * seq, size_t seq_len, double target, LSTMWeights w, LSTMState s, double lr);
Samples make_samples(double * data, size_t data_len, long long look_back);
LSTMWeights init_weights();
LSTMWeights train(double * data, size_t data_len, long long look_back, long long epochs, double lr);
double predict(double * seq, size_t seq_len, LSTMWeights w);
int main(void);

double exp_approx(double x) {
    double sum = 1.0;
    double term = 1.0;
    long long n = 1LL;
    while (n < 20LL) {
        term = (term * x) / (double)(n);
        sum = sum + term;
        n = n + 1LL;
    }
    return sum;
}

double sigmoid(double x) {
    return 1.0 / (1.0 + exp_approx(-(x)));
}

double tanh_approx(double x) {
    double e = exp_approx(2.0 * x);
    return (e - 1.0) / (e + 1.0);
}

LSTMState forward(double * seq, size_t seq_len, LSTMWeights w) {
    double *i_arr = NULL;
    size_t i_arr_len = 0;
    double *f_arr = NULL;
    size_t f_arr_len = 0;
    double *o_arr = NULL;
    size_t o_arr_len = 0;
    double *g_arr = NULL;
    size_t g_arr_len = 0;
    double *c_arr = NULL;
    size_t c_arr_len = 0;
    c_arr = list_append_double(c_arr, &c_arr_len, 0.0);
    double *h_arr = NULL;
    size_t h_arr_len = 0;
    h_arr = list_append_double(h_arr, &h_arr_len, 0.0);
    long long t = 0LL;
    while (t < seq_len) {
        double x = seq[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? seq_len + _mochi_idx : _mochi_idx;})];
        double h_prev = h_arr[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? h_arr_len + _mochi_idx : _mochi_idx;})];
        double c_prev = c_arr[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? c_arr_len + _mochi_idx : _mochi_idx;})];
        double i_t = sigmoid(((w.w_i * x) + (w.u_i * h_prev)) + w.b_i);
        double f_t = sigmoid(((w.w_f * x) + (w.u_f * h_prev)) + w.b_f);
        double o_t = sigmoid(((w.w_o * x) + (w.u_o * h_prev)) + w.b_o);
        double g_t = tanh_approx(((w.w_c * x) + (w.u_c * h_prev)) + w.b_c);
        double c_t = (f_t * c_prev) + (i_t * g_t);
        double h_t = o_t * tanh_approx(c_t);
        i_arr = list_append_double(i_arr, &i_arr_len, i_t);
        f_arr = list_append_double(f_arr, &f_arr_len, f_t);
        o_arr = list_append_double(o_arr, &o_arr_len, o_t);
        g_arr = list_append_double(g_arr, &g_arr_len, g_t);
        c_arr = list_append_double(c_arr, &c_arr_len, c_t);
        h_arr = list_append_double(h_arr, &h_arr_len, h_t);
        t = t + 1LL;
    }
    return (LSTMState){.i = i_arr, .i_len = i_arr_len, .f = f_arr, .f_len = f_arr_len, .o = o_arr, .o_len = o_arr_len, .g = g_arr, .g_len = g_arr_len, .c = c_arr, .c_len = c_arr_len, .h = h_arr, .h_len = h_arr_len};
}

LSTMWeights backward(double * seq, size_t seq_len, double target, LSTMWeights w, LSTMState s, double lr) {
    double dw_i = 0.0;
    double du_i = 0.0;
    double db_i = 0.0;
    double dw_f = 0.0;
    double du_f = 0.0;
    double db_f = 0.0;
    double dw_o = 0.0;
    double du_o = 0.0;
    double db_o = 0.0;
    double dw_c = 0.0;
    double du_c = 0.0;
    double db_c = 0.0;
    double dw_y = 0.0;
    double db_y = 0.0;
    long long T = seq_len;
    double h_last = s.h[(int)({long long _mochi_idx = T; _mochi_idx < 0 ? s.h_len + _mochi_idx : _mochi_idx;})];
    double y = (w.w_y * h_last) + w.b_y;
    double dy = y - target;
    dw_y = dy * h_last;
    db_y = dy;
    double dh_next = dy * w.w_y;
    double dc_next = 0.0;
    long long t = T - 1LL;
    while (t >= 0LL) {
        double i_t = s.i[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? s.i_len + _mochi_idx : _mochi_idx;})];
        double f_t = s.f[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? s.f_len + _mochi_idx : _mochi_idx;})];
        double o_t = s.o[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? s.o_len + _mochi_idx : _mochi_idx;})];
        double g_t = s.g[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? s.g_len + _mochi_idx : _mochi_idx;})];
        double c_t = s.c[(int)({long long _mochi_idx = t + 1LL; _mochi_idx < 0 ? s.c_len + _mochi_idx : _mochi_idx;})];
        double c_prev = s.c[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? s.c_len + _mochi_idx : _mochi_idx;})];
        double h_prev = s.h[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? s.h_len + _mochi_idx : _mochi_idx;})];
        double tanh_c = tanh_approx(c_t);
        double do_t = dh_next * tanh_c;
        double da_o = (do_t * o_t) * (1.0 - o_t);
        double dc = ((dh_next * o_t) * (1.0 - (tanh_c * tanh_c))) + dc_next;
        double di_t = dc * g_t;
        double da_i = (di_t * i_t) * (1.0 - i_t);
        double dg_t = dc * i_t;
        double da_g = dg_t * (1.0 - (g_t * g_t));
        double df_t = dc * c_prev;
        double da_f = (df_t * f_t) * (1.0 - f_t);
        dw_i = dw_i + (da_i * seq[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? seq_len + _mochi_idx : _mochi_idx;})]);
        du_i = du_i + (da_i * h_prev);
        db_i = db_i + da_i;
        dw_f = dw_f + (da_f * seq[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? seq_len + _mochi_idx : _mochi_idx;})]);
        du_f = du_f + (da_f * h_prev);
        db_f = db_f + da_f;
        dw_o = dw_o + (da_o * seq[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? seq_len + _mochi_idx : _mochi_idx;})]);
        du_o = du_o + (da_o * h_prev);
        db_o = db_o + da_o;
        dw_c = dw_c + (da_g * seq[(int)({long long _mochi_idx = t; _mochi_idx < 0 ? seq_len + _mochi_idx : _mochi_idx;})]);
        du_c = du_c + (da_g * h_prev);
        db_c = db_c + da_g;
        dh_next = (((da_i * w.u_i) + (da_f * w.u_f)) + (da_o * w.u_o)) + (da_g * w.u_c);
        dc_next = dc * f_t;
        t = t - 1LL;
    }
    w.w_y = w.w_y - (lr * dw_y);
    w.b_y = w.b_y - (lr * db_y);
    w.w_i = w.w_i - (lr * dw_i);
    w.u_i = w.u_i - (lr * du_i);
    w.b_i = w.b_i - (lr * db_i);
    w.w_f = w.w_f - (lr * dw_f);
    w.u_f = w.u_f - (lr * du_f);
    w.b_f = w.b_f - (lr * db_f);
    w.w_o = w.w_o - (lr * dw_o);
    w.u_o = w.u_o - (lr * du_o);
    w.b_o = w.b_o - (lr * db_o);
    w.w_c = w.w_c - (lr * dw_c);
    w.u_c = w.u_c - (lr * du_c);
    w.b_c = w.b_c - (lr * db_c);
    return w;
}

Samples make_samples(double * data, size_t data_len, long long look_back) {
    double **X = NULL;
    size_t X_len = 0;
    size_t *X_lens = NULL;
    size_t X_lens_len = 0;
    double *Y = NULL;
    size_t Y_len = 0;
    long long i = 0LL;
    while ((i + look_back) < data_len) {
        double *seq = _slice_double(data, data_len, i, i + look_back, &(_slice_double_len));
        size_t seq_len = _slice_double_len;
        X = list_append_doubleptr(X, &X_len, seq);
        X_lens = list_append_szt(X_lens, &X_lens_len, seq_len);
        Y = list_append_double(Y, &Y_len, data[(int)({long long _mochi_idx = i + look_back; _mochi_idx < 0 ? data_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    return (Samples){.x = X, .x_len = X_len, .x_lens = X_lens, .x_lens_len = X_len, .y = Y, .y_len = Y_len};
}

LSTMWeights init_weights() {
    return (LSTMWeights){.w_i = 0.1, .u_i = 0.2, .b_i = 0.0, .w_f = 0.1, .u_f = 0.2, .b_f = 0.0, .w_o = 0.1, .u_o = 0.2, .b_o = 0.0, .w_c = 0.1, .u_c = 0.2, .b_c = 0.0, .w_y = 0.1, .b_y = 0.0};
}

LSTMWeights train(double * data, size_t data_len, long long look_back, long long epochs, double lr) {
    Samples samples = make_samples(data, data_len, look_back);
    LSTMWeights w = init_weights();
    long long ep = 0LL;
    while (ep < epochs) {
        long long j = 0LL;
        while (j < samples.x_len) {
            double *seq = samples.x[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? samples.x_len + _mochi_idx : _mochi_idx;})];
            size_t seq_len = 0;
            double target = samples.y[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? samples.y_len + _mochi_idx : _mochi_idx;})];
            LSTMState state = forward(seq, seq_len, w);
            w = backward(seq, seq_len, target, w, state, lr);
            j = j + 1LL;
        }
        ep = ep + 1LL;
    }
    return w;
}

double predict(double * seq, size_t seq_len, LSTMWeights w) {
    LSTMState state = forward(seq, seq_len, w);
    double h_last = state.h[(int)({long long _mochi_idx = state.h_len - 1LL; _mochi_idx < 0 ? state.h_len + _mochi_idx : _mochi_idx;})];
    return (w.w_y * h_last) + w.b_y;
}

int main(void) {
    {
        long long __start = _now();
        data = ({double *tmp = malloc(8 * sizeof(double)); tmp[0] = 0.1; tmp[1] = 0.2; tmp[2] = 0.3; tmp[3] = 0.4; tmp[4] = 0.5; tmp[5] = 0.6; tmp[6] = 0.7; tmp[7] = 0.8; tmp;});
        data_len = 8;
        w = train(data, data_len, look_back, epochs, lr);
        test_seq = ({double *tmp = malloc(3 * sizeof(double)); tmp[0] = 0.6; tmp[1] = 0.7; tmp[2] = 0.8; tmp;});
        test_seq_len = 3;
        pred = predict(test_seq, test_seq_len, w);
        puts(str_concat("Predicted value: ", str_float(pred)));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
