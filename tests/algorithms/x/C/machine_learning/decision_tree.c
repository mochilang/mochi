// Generated by Mochi 0.10.32 on 2025-08-11 18:06 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>


size_t _slice_double_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%g", v);
    return strdup(buf);
}

static char* str_list_double(const double *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[64];
        snprintf(tmp, sizeof(tmp), "%g", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static double* _slice_double(const double *arr, size_t len, int start, int end, size_t *out_len) {
    if (start < 0) start = 0;
    if ((size_t)end > len) end = len;
    if (start > end) start = end;
    size_t n = end - start;
    double *res = NULL;
    if (n) {
        res = malloc(n * sizeof(double));
        memcpy(res, arr + start, n * sizeof(double));
    }
    *out_len = n;
    _slice_double_len = n;
    return res;
}

typedef struct Anon1 Anon1;
typedef struct Branch Branch;
typedef struct Leaf Leaf;

struct Anon1 {
    double prediction;
    double decision_boundary;
    int left;
    int right;
};

struct Branch {
    double decision_boundary;
    int left;
    int right;
};

struct Leaf {
    double prediction;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double PI = 3.141592653589793;
double TWO_PI = 6.283185307179586;
long long seed = 123456789LL;

double _mod(double x, double m);
double sin(double x);
double user_rand();
double mean(double * vals, size_t vals_len);
double mean_squared_error(double * labels, size_t labels_len, double prediction);
Anon1 train_tree(double * x, size_t x_len, double * y, size_t y_len, long long depth, long long min_leaf_size);
double predict(int tree, double value);
void user_main();
int main(void);

double _mod(double x, double m) {
    return x - ((double)((int)(x / m)) * m);
}

double sin(double x) {
    double y = _mod(x + PI, TWO_PI) - PI;
    double y2 = y * y;
    double y3 = y2 * y;
    double y5 = y3 * y2;
    double y7 = y5 * y2;
    return ((y - (y3 / 6.0)) + (y5 / 120.0)) - (y7 / 5040.0);
}

double user_rand() {
    seed = ((1103515245LL * seed) + 12345LL) % 2147483648LL;
    return (double)(seed) / 2147483648.0;
}

double mean(double * vals, size_t vals_len) {
    double sum = 0.0;
    long long i = 0LL;
    while (i < vals_len) {
        sum = sum + vals[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? vals_len + _mochi_idx : _mochi_idx;})];
        i = i + 1LL;
    }
    return sum / vals_len;
}

double mean_squared_error(double * labels, size_t labels_len, double prediction) {
    double total = 0.0;
    long long i = 0LL;
    while (i < labels_len) {
        double diff = labels[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? labels_len + _mochi_idx : _mochi_idx;})] - prediction;
        total = total + (diff * diff);
        i = i + 1LL;
    }
    return total / labels_len;
}

Anon1 train_tree(double * x, size_t x_len, double * y, size_t y_len, long long depth, long long min_leaf_size) {
    if (x_len < (2LL * min_leaf_size)) {
        return (Anon1){.prediction = mean(y, y_len)};
    }
    if (depth == 1LL) {
        return (Anon1){.prediction = mean(y, y_len)};
    }
    long long best_split = 0LL;
    double min_error = mean_squared_error(x, x_len, mean(y, y_len)) * 2.0;
    long long i = 0LL;
    while (i < x_len) {
        if ((_slice_double(x, x_len, 0LL, i, &(_slice_double_len)), _slice_double_len) < min_leaf_size) {
            i = i;
        } else {
            if ((_slice_double(x, x_len, i, x_len, &(_slice_double_len)), _slice_double_len) < min_leaf_size) {
                i = i;
            } else {
                double err_left = ({size_t __tmp4_len = 0; double* __tmp4 = _slice_double(x, x_len, 0LL, i, &(__tmp4_len)); mean_squared_error(__tmp4, _slice_double_len, ({size_t __tmp5_len = 0; double* __tmp5 = _slice_double(y, y_len, 0LL, i, &(__tmp5_len)); mean(__tmp5, _slice_double_len);}));});
                double err_right = ({size_t __tmp6_len = 0; double* __tmp6 = _slice_double(x, x_len, i, x_len, &(__tmp6_len)); mean_squared_error(__tmp6, _slice_double_len, ({size_t __tmp7_len = 0; double* __tmp7 = _slice_double(y, y_len, i, y_len, &(__tmp7_len)); mean(__tmp7, _slice_double_len);}));});
                double err = err_left + err_right;
                if (err < min_error) {
                    best_split = i;
                    min_error = err;
                }
            }
        }
        i = i + 1LL;
    }
    if (best_split != 0LL) {
        double *left_x = _slice_double(x, x_len, 0LL, best_split, &(_slice_double_len));
        size_t left_x_len = _slice_double_len;
        double *left_y = _slice_double(y, y_len, 0LL, best_split, &(_slice_double_len));
        size_t left_y_len = _slice_double_len;
        double *right_x = _slice_double(x, x_len, best_split, x_len, &(_slice_double_len));
        size_t right_x_len = _slice_double_len;
        double *right_y = _slice_double(y, y_len, best_split, y_len, &(_slice_double_len));
        size_t right_y_len = _slice_double_len;
        double boundary = x[(int)({long long _mochi_idx = best_split; _mochi_idx < 0 ? x_len + _mochi_idx : _mochi_idx;})];
        long long left_tree = train_tree(left_x, left_x_len, left_y, left_y_len, depth - 1LL, min_leaf_size);
        long long right_tree = train_tree(right_x, right_x_len, right_y, right_y_len, depth - 1LL, min_leaf_size);
        return (Anon1){.decision_boundary = boundary, .left = left_tree, .right = right_tree};
    }
    return (Anon1){.prediction = mean(y, y_len)};
}

double predict(int tree, double value) {
    return (tree == Leaf(p) ? p : (value >= b ? predict(r, value) : predict(l, value)));
}

void user_main() {
    double *x = NULL;
    size_t x_len = 0;
    long long v = -(1.0);
    while (v < 1.0) {
        x = list_append_long_long(x, &x_len, v);
        v = v + 0.005;
    }
    double *y = NULL;
    size_t y_len = 0;
    long long i = 0LL;
    while (i < x_len) {
        y = list_append_double(y, &y_len, sin(x[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? x_len + _mochi_idx : _mochi_idx;})]));
        i = i + 1LL;
    }
    Anon1 tree = train_tree(x, x_len, y, y_len, 10LL, 10LL);
    double *test_cases = NULL;
    size_t test_cases_len = 0;
    i = 0LL;
    while (i < 10LL) {
        test_cases = list_append_double(test_cases, &test_cases_len, (user_rand() * 2.0) - 1.0);
        i = i + 1LL;
    }
    double *predictions = NULL;
    size_t predictions_len = 0;
    i = 0LL;
    while (i < test_cases_len) {
        predictions = list_append_double(predictions, &predictions_len, predict(tree, test_cases[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? test_cases_len + _mochi_idx : _mochi_idx;})]));
        i = i + 1LL;
    }
    double sum_err = 0.0;
    i = 0LL;
    while (i < test_cases_len) {
        double diff = predictions[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? predictions_len + _mochi_idx : _mochi_idx;})] - test_cases[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? test_cases_len + _mochi_idx : _mochi_idx;})];
        sum_err = sum_err + (diff * diff);
        i = i + 1LL;
    }
    double avg_error = sum_err / test_cases_len;
    puts(str_concat("Test values: ", str_list_double(test_cases, test_cases_len)));
    puts(str_concat("Predictions: ", str_list_double(predictions, predictions_len)));
    puts(str_concat("Average error: ", str_float(avg_error)));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
