// Generated by Mochi 0.10.32 on 2025-08-16 12:42 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

size_t get_neighbours_len;
size_t astar_len;
size_t create_world_len;
size_t *create_world_lens;

size_t append_len;
static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_list_int(const long long *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[32];
        snprintf(tmp, sizeof(tmp), "%lld", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct Point Point;
typedef struct Node Node;

struct Point {
    long long x;
    long long y;
};

struct Node {
    Point pos;
    Point parent;
    long long g;
    long long h;
    long long f;
};

static Point* list_append_Point(Point *arr, size_t *len, Point val) {
    arr = realloc(arr, (*len + 1) * sizeof(Point));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static Node* list_append_Node(Node *arr, size_t *len, Node val) {
    arr = realloc(arr, (*len + 1) * sizeof(Node));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long world_x = 5LL;
long long world_y = 5LL;
Point start = (Point){.x = 0LL, .y = 0LL};
Point goal = (Point){.x = 4LL, .y = 4LL};
Point *path = NULL;
size_t path_len = 0;
long long **world = NULL;
size_t world_len = 0;
size_t *world_lens = NULL;
size_t world_lens_len = 0;

Point * get_neighbours(Point p, long long x_limit, long long y_limit);
long long contains(Node * nodes, size_t nodes_len, Point p);
Node get_node(Node * nodes, size_t nodes_len, Point p);
Point * astar(long long x_limit, long long y_limit, Point start, Point goal);
long long * * create_world(long long x_limit, long long y_limit);
void mark_path(long long * * world, size_t world_len, size_t* world_lens, size_t world_lens_len, Point * path, size_t path_len);
void print_world(long long * * world, size_t world_len, size_t* world_lens, size_t world_lens_len);
int main(void);

Point * get_neighbours(Point p, long long x_limit, long long y_limit) {
    Point *deltas = NULL;
    size_t deltas_len = 0;
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = -1LL, .y = -1LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = -1LL, .y = 0LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = -1LL, .y = 1LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = 0LL, .y = -1LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = 0LL, .y = 1LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = 1LL, .y = -1LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = 1LL, .y = 0LL});
    deltas = list_append_Point(deltas, &deltas_len, (Point){.x = 1LL, .y = 1LL});
    Point *neighbours = NULL;
    size_t neighbours_len = 0;
    {
        Point d_arr[] = {(Point){.x = -1LL, .y = -1LL}, (Point){.x = -1LL, .y = 0LL}, (Point){.x = -1LL, .y = 1LL}, (Point){.x = 0LL, .y = -1LL}, (Point){.x = 0LL, .y = 1LL}, (Point){.x = 1LL, .y = -1LL}, (Point){.x = 1LL, .y = 0LL}, (Point){.x = 1LL, .y = 1LL}};
        size_t d_len = sizeof(d_arr) / sizeof(d_arr[0]);
        for (size_t __i = 0; __i < d_len; __i++) {
            Point d = d_arr[__i];
            long long nx = p.x + d.x;
            long long ny = p.y + d.y;
            if ((((0LL <= nx) && (nx < x_limit)) && (0LL <= ny)) && (ny < y_limit)) {
                neighbours = list_append_Point(neighbours, &neighbours_len, (Point){.x = nx, .y = ny});
            }
        }
    }
    return get_neighbours_len = neighbours_len, neighbours;
}

long long contains(Node * nodes, size_t nodes_len, Point p) {
    for (size_t __i = 0; __i < nodes_len; __i++) {
        Node n = nodes[__i];
        if ((n.pos.x == p.x) && (n.pos.y == p.y)) {
            return 1LL;
        }
    }
    return 0LL;
}

Node get_node(Node * nodes, size_t nodes_len, Point p) {
    for (size_t __i = 0; __i < nodes_len; __i++) {
        Node n = nodes[__i];
        if ((n.pos.x == p.x) && (n.pos.y == p.y)) {
            return n;
        }
    }
    return (Node){.pos = p, .parent = (Point){.x = -1LL, .y = -1LL}, .g = 0LL, .h = 0LL, .f = 0LL};
}

Point * astar(long long x_limit, long long y_limit, Point start, Point goal) {
    Node *open = NULL;
    size_t open_len = 0;
    Node *closed = NULL;
    size_t closed_len = 0;
    open = list_append_Node(open, &open_len, (Node){.pos = start, .parent = (Point){.x = -1LL, .y = -1LL}, .g = 0LL, .h = 0LL, .f = 0LL});
    Node current = open[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})];
    while (open_len > 0LL) {
        long long min_index = 0LL;
        long long i = 1LL;
        while (i < open_len) {
            if (open[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})].f < open[(int)({long long _mochi_idx = min_index; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})].f) {
                min_index = i;
            }
            i = i + 1LL;
        }
        current = open[(int)({long long _mochi_idx = min_index; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})];
        Node *new_open = NULL;
        size_t new_open_len = 0;
        long long j = 0LL;
        while (j < open_len) {
            if (j != min_index) {
                new_open = list_append_Node(new_open, &new_open_len, open[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? open_len + _mochi_idx : _mochi_idx;})]);
            }
            j = j + 1LL;
        }
        open = new_open;
        open_len = new_open_len;
        closed = list_append_Node(closed, &closed_len, current);
        if ((current.pos.x == goal.x) && (current.pos.y == goal.y)) {
            break;
        }
        Point *neighbours = get_neighbours(current.pos, x_limit, y_limit);
        size_t neighbours_len = get_neighbours_len;
        for (size_t __i = 0; __i < neighbours_len; __i++) {
            Point np = neighbours[__i];
            if (contains(closed, closed_len, np)) {
                continue;
            }
            long long g = current.g + 1LL;
            long long dx = goal.x - np.x;
            long long dy = goal.y - np.y;
            long long h = (dx * dx) + (dy * dy);
            long long f = g + h;
            long long skip = 0LL;
            for (size_t __i = 0; __i < open_len; __i++) {
                Node node = open[__i];
                if (((node.pos.x == np.x) && (node.pos.y == np.y)) && (node.f < f)) {
                    skip = 1LL;
                }
            }
            if (skip) {
                continue;
            }
            open = list_append_Node(open, &open_len, (Node){.pos = np, .parent = current.pos, .g = g, .h = h, .f = f});
        }
    }
    Point *path = NULL;
    size_t path_len = 0;
    path = list_append_Point(path, &path_len, current.pos);
    while (!((current.parent.x == -1LL) && (current.parent.y == -1LL))) {
        current = get_node(closed, closed_len, current.parent);
        path = list_append_Point(path, &path_len, current.pos);
    }
    Point *rev = NULL;
    size_t rev_len = 0;
    long long k = path_len - 1LL;
    while (k >= 0LL) {
        rev = list_append_Point(rev, &rev_len, path[(int)({long long _mochi_idx = k; _mochi_idx < 0 ? path_len + _mochi_idx : _mochi_idx;})]);
        k = k - 1LL;
    }
    return astar_len = rev_len, rev;
}

long long * * create_world(long long x_limit, long long y_limit) {
    long long **world = NULL;
    size_t world_len = 0;
    size_t *world_lens = NULL;
    size_t world_lens_len = 0;
    long long i = 0LL;
    while (i < x_limit) {
        long long *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j < y_limit) {
            row = list_append_long_long(row, &row_len, 0LL);
            j = j + 1LL;
        }
        world = list_append_intptr(world, &world_len, row);
        world_lens = list_append_szt(world_lens, &world_lens_len, row_len);
        i = i + 1LL;
    }
    return create_world_lens = world_lens, create_world_len = world_len, world;
}

void mark_path(long long * * world, size_t world_len, size_t* world_lens, size_t world_lens_len, Point * path, size_t path_len) {
    for (size_t __i = 0; __i < path_len; __i++) {
        Point p = path[__i];
        world[(int)(p.x)][(int)(p.y)] = 1LL;
    }
}

void print_world(long long * * world, size_t world_len, size_t* world_lens, size_t world_lens_len) {
    for (size_t __i = 0; __i < world_len; __i++) {
        long long *row = world[__i];
        size_t row_len = world_lens[__i];
        puts(str_list_int(row, row_len));
    }
}

int main(void) {
    path = astar(world_x, world_y, start, goal);
    path_len = astar_len;
    puts(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat("path from (", str_int(start.x)), ", "), str_int(start.y)), ") to ("), str_int(goal.x)), ", "), str_int(goal.y)), ")"));
    world = create_world(world_x, world_y);
    world_len = create_world_len;
    world_lens = create_world_lens;
    mark_path(world, world_len, world_lens, world_len, path, path_len);
    print_world(world, world_len, world_lens, world_len);
    return 0;
}
