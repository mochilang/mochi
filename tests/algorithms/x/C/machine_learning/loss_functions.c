// Generated by Mochi 0.10.32 on 2025-08-16 20:21 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>


size_t append_len;
static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

double absf(double x);
double maxf(double a, double b);
double minf(double a, double b);
double clip(double x, double lo, double hi);
double to_float(long long x);
double user_powf(double base, double exp);
double user_ln(double x);
double user_exp(double x);
double mean(double * v, size_t v_len);
double binary_cross_entropy(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double epsilon);
double binary_focal_cross_entropy(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double gamma, double alpha, double epsilon);
double categorical_cross_entropy(double * * y_true, size_t y_true_len, size_t* y_true_lens, size_t y_true_lens_len, double * * y_pred, size_t y_pred_len, size_t* y_pred_lens, size_t y_pred_lens_len, double epsilon);
double categorical_focal_cross_entropy(double * * y_true, size_t y_true_len, size_t* y_true_lens, size_t y_true_lens_len, double * * y_pred, size_t y_pred_len, size_t* y_pred_lens, size_t y_pred_lens_len, double * alpha, size_t alpha_len, double gamma, double epsilon);
double hinge_loss(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len);
double huber_loss(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double delta);
double mean_squared_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len);
double mean_absolute_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len);
double mean_squared_logarithmic_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len);
double mean_absolute_percentage_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double epsilon);
double perplexity_loss(long long * * y_true, size_t y_true_len, size_t* y_true_lens, size_t y_true_lens_len, double * * * y_pred, size_t y_pred_len, size_t* y_pred_lens, size_t y_pred_lens_len, double epsilon);
double smooth_l1_loss(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double beta);
double kullback_leibler_divergence(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len);
const char* user_main();
int main(void);

double absf(double x) {
    if (x < 0.0) {
        return -(x);
    }
    return x;
}

double maxf(double a, double b) {
    if (a > b) {
        return a;
    }
    return b;
}

double minf(double a, double b) {
    if (a < b) {
        return a;
    }
    return b;
}

double clip(double x, double lo, double hi) {
    return maxf(lo, minf(x, hi));
}

double to_float(long long x) {
    return x * 1.0;
}

double user_powf(double base, double exp) {
    double result = 1.0;
    long long i = 0LL;
    long long n = (int)(user_exp);
    while (i < n) {
        result = result * base;
        i = i + 1LL;
    }
    return result;
}

double user_ln(double x) {
    if (x <= 0.0) {
        panic("ln domain error");
    }
    double y = (x - 1.0) / (x + 1.0);
    double y2 = y * y;
    double term = y;
    double sum = 0.0;
    long long k = 0LL;
    while (k < 10LL) {
        double denom = to_float((2LL * k) + 1LL);
        sum = sum + (term / denom);
        term = term * y2;
        k = k + 1LL;
    }
    return 2.0 * sum;
}

double user_exp(double x) {
    double term = 1.0;
    double sum = 1.0;
    long long n = 1LL;
    while (n < 20LL) {
        term = (term * x) / to_float(n);
        sum = sum + term;
        n = n + 1LL;
    }
    return sum;
}

double mean(double * v, size_t v_len) {
    double total = 0.0;
    long long i = 0LL;
    while (i < v_len) {
        total = total + v[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? v_len + _mochi_idx : _mochi_idx;})];
        i = i + 1LL;
    }
    return total / to_float(v_len);
}

double binary_cross_entropy(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double epsilon) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double *losses = NULL;
    size_t losses_len = 0;
    long long i = 0LL;
    while (i < y_true_len) {
        double yt = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})];
        double yp = clip(y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})], epsilon, 1.0 - epsilon);
        double loss = -((yt * log(yp)) + ((1.0 - yt) * log(1.0 - yp)));
        losses = list_append_double(losses, &losses_len, loss);
        i = i + 1LL;
    }
    return mean(losses, losses_len);
}

double binary_focal_cross_entropy(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double gamma, double alpha, double epsilon) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double *losses = NULL;
    size_t losses_len = 0;
    long long i = 0LL;
    while (i < y_true_len) {
        double yt = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})];
        double yp = clip(y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})], epsilon, 1.0 - epsilon);
        double term1 = ((alpha * user_powf(1.0 - yp, gamma)) * yt) * log(yp);
        double term2 = (((1.0 - alpha) * user_powf(yp, gamma)) * (1.0 - yt)) * log(1.0 - yp);
        losses = list_append_double(losses, &losses_len, -(term1 + term2));
        i = i + 1LL;
    }
    return mean(losses, losses_len);
}

double categorical_cross_entropy(double * * y_true, size_t y_true_len, size_t* y_true_lens, size_t y_true_lens_len, double * * y_pred, size_t y_pred_len, size_t* y_pred_lens, size_t y_pred_lens_len, double epsilon) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same shape.");
    }
    long long rows = y_true_len;
    double total = 0.0;
    long long i = 0LL;
    while (i < rows) {
        if (y_true_lens[(int)(i)] != y_pred_lens[(int)(i)]) {
            panic("Input arrays must have the same shape.");
        }
        double sum_true = 0.0;
        double sum_pred = 0.0;
        long long j = 0LL;
        while (j < y_true_lens[(int)(i)]) {
            double yt = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_true_lens[(int)(i)] + _mochi_idx : _mochi_idx;})];
            double yp = y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_pred_lens[(int)(i)] + _mochi_idx : _mochi_idx;})];
            if ((yt != 0.0) && (yt != 1.0)) {
                panic("y_true must be one-hot encoded.");
            }
            sum_true = sum_true + yt;
            sum_pred = sum_pred + yp;
            j = j + 1LL;
        }
        if (sum_true != 1.0) {
            panic("y_true must be one-hot encoded.");
        }
        if (absf(sum_pred - 1.0) > epsilon) {
            panic("Predicted probabilities must sum to approximately 1.");
        }
        j = 0LL;
        while (j < y_true_lens[(int)(i)]) {
            double yp = clip(y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_pred_lens[(int)(i)] + _mochi_idx : _mochi_idx;})], epsilon, 1.0);
            total = total - (y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_true_lens[(int)(i)] + _mochi_idx : _mochi_idx;})] * log(yp));
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    return total;
}

double categorical_focal_cross_entropy(double * * y_true, size_t y_true_len, size_t* y_true_lens, size_t y_true_lens_len, double * * y_pred, size_t y_pred_len, size_t* y_pred_lens, size_t y_pred_lens_len, double * alpha, size_t alpha_len, double gamma, double epsilon) {
    if (y_true_len != y_pred_len) {
        panic("Shape of y_true and y_pred must be the same.");
    }
    long long rows = y_true_len;
    long long cols = y_true_lens[(int)(0LL)];
    double *a = alpha;
    size_t a_len = alpha_len;
    if (a_len == 0LL) {
        double *tmp = NULL;
        size_t tmp_len = 0;
        long long j = 0LL;
        while (j < cols) {
            tmp = list_append_double(tmp, &tmp_len, 1.0);
            j = j + 1LL;
        }
        a = tmp;
        a_len = tmp_len;
    }
    if (a_len != cols) {
        panic("Length of alpha must match the number of classes.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < rows) {
        if ((y_true_lens[(int)(i)] != cols) || (y_pred_lens[(int)(i)] != cols)) {
            panic("Shape of y_true and y_pred must be the same.");
        }
        double sum_true = 0.0;
        double sum_pred = 0.0;
        long long j = 0LL;
        while (j < cols) {
            double yt = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_true_lens[(int)(i)] + _mochi_idx : _mochi_idx;})];
            double yp = y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_pred_lens[(int)(i)] + _mochi_idx : _mochi_idx;})];
            if ((yt != 0.0) && (yt != 1.0)) {
                panic("y_true must be one-hot encoded.");
            }
            sum_true = sum_true + yt;
            sum_pred = sum_pred + yp;
            j = j + 1LL;
        }
        if (sum_true != 1.0) {
            panic("y_true must be one-hot encoded.");
        }
        if (absf(sum_pred - 1.0) > epsilon) {
            panic("Predicted probabilities must sum to approximately 1.");
        }
        double row_loss = 0.0;
        j = 0LL;
        while (j < cols) {
            double yp = clip(y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_pred_lens[(int)(i)] + _mochi_idx : _mochi_idx;})], epsilon, 1.0);
            row_loss = row_loss + (((a[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? a_len + _mochi_idx : _mochi_idx;})] * user_powf(1.0 - yp, gamma)) * y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_true_lens[(int)(i)] + _mochi_idx : _mochi_idx;})]) * log(yp));
            j = j + 1LL;
        }
        total = total - row_loss;
        i = i + 1LL;
    }
    return total / to_float(rows);
}

double hinge_loss(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len) {
    if (y_true_len != y_pred_len) {
        panic("Length of predicted and actual array must be same.");
    }
    double *losses = NULL;
    size_t losses_len = 0;
    long long i = 0LL;
    while (i < y_true_len) {
        double yt = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})];
        if ((yt != -1.0) && (yt != 1.0)) {
            panic("y_true can have values -1 or 1 only.");
        }
        double pred = y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})];
        double l = maxf(0.0, 1.0 - (yt * pred));
        losses = list_append_double(losses, &losses_len, l);
        i = i + 1LL;
    }
    return mean(losses, losses_len);
}

double huber_loss(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double delta) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < y_true_len) {
        double diff = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})] - y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})];
        double adiff = absf(diff);
        if (adiff <= delta) {
            total = total + ((0.5 * diff) * diff);
        } else {
            total = total + (delta * (adiff - (0.5 * delta)));
        }
        i = i + 1LL;
    }
    return total / to_float(y_true_len);
}

double mean_squared_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double *losses = NULL;
    size_t losses_len = 0;
    long long i = 0LL;
    while (i < y_true_len) {
        double diff = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})] - y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})];
        losses = list_append_double(losses, &losses_len, diff * diff);
        i = i + 1LL;
    }
    return mean(losses, losses_len);
}

double mean_absolute_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < y_true_len) {
        total = total + absf(y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})] - y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})]);
        i = i + 1LL;
    }
    return total / to_float(y_true_len);
}

double mean_squared_logarithmic_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < y_true_len) {
        double a = log(1.0 + y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})]);
        double b = log(1.0 + y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})]);
        double diff = a - b;
        total = total + (diff * diff);
        i = i + 1LL;
    }
    return total / to_float(y_true_len);
}

double mean_absolute_percentage_error(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double epsilon) {
    if (y_true_len != y_pred_len) {
        panic("The length of the two arrays should be the same.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < y_true_len) {
        double yt = y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})];
        if (yt == 0.0) {
            yt = epsilon;
        }
        total = total + absf((yt - y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})]) / yt);
        i = i + 1LL;
    }
    return total / to_float(y_true_len);
}

double perplexity_loss(long long * * y_true, size_t y_true_len, size_t* y_true_lens, size_t y_true_lens_len, double * * * y_pred, size_t y_pred_len, size_t* y_pred_lens, size_t y_pred_lens_len, double epsilon) {
    long long batch = y_true_len;
    if (batch != y_pred_len) {
        panic("Batch size of y_true and y_pred must be equal.");
    }
    long long sentence_len = y_true_lens[(int)(0LL)];
    if (sentence_len != y_pred_lens[(int)(0LL)]) {
        panic("Sentence length of y_true and y_pred must be equal.");
    }
    long long vocab_size = 0;
    long long b = 0LL;
    double total_perp = 0.0;
    while (b < batch) {
        if ((y_true_lens[(int)(b)] != sentence_len) || (y_pred_lens[(int)(b)] != sentence_len)) {
            panic("Sentence length of y_true and y_pred must be equal.");
        }
        double sum_log = 0.0;
        long long j = 0LL;
        while (j < sentence_len) {
            long long label = y_true[(int)({long long _mochi_idx = b; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_true_lens[(int)(b)] + _mochi_idx : _mochi_idx;})];
            if (label >= vocab_size) {
                panic("Label value must not be greater than vocabulary size.");
            }
            double prob = clip(y_pred[(int)({long long _mochi_idx = b; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = j; _mochi_idx < 0 ? y_pred_lens[(int)(b)] + _mochi_idx : _mochi_idx;})][(int)({long long _mochi_idx = label; _mochi_idx < 0 ? 0 + _mochi_idx : _mochi_idx;})], epsilon, 1.0);
            sum_log = sum_log + log(prob);
            j = j + 1LL;
        }
        double mean_log = sum_log / to_float(sentence_len);
        double perp = exp(-(mean_log));
        total_perp = total_perp + perp;
        b = b + 1LL;
    }
    return total_perp / to_float(batch);
}

double smooth_l1_loss(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len, double beta) {
    if (y_true_len != y_pred_len) {
        panic("The length of the two arrays should be the same.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < y_true_len) {
        double diff = absf(y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})] - y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})]);
        if (diff < beta) {
            total = total + (((0.5 * diff) * diff) / beta);
        } else {
            total = (total + diff) - (0.5 * beta);
        }
        i = i + 1LL;
    }
    return total / to_float(y_true_len);
}

double kullback_leibler_divergence(double * y_true, size_t y_true_len, double * y_pred, size_t y_pred_len) {
    if (y_true_len != y_pred_len) {
        panic("Input arrays must have the same length.");
    }
    double total = 0.0;
    long long i = 0LL;
    while (i < y_true_len) {
        total = total + (y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})] * log(y_true[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_true_len + _mochi_idx : _mochi_idx;})] / y_pred[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? y_pred_len + _mochi_idx : _mochi_idx;})]));
        i = i + 1LL;
    }
    return total;
}

const char* user_main() {
    double *y_true_bc = NULL;
    size_t y_true_bc_len = 0;
    y_true_bc = list_append_double(y_true_bc, &y_true_bc_len, 0.0);
    y_true_bc = list_append_double(y_true_bc, &y_true_bc_len, 1.0);
    y_true_bc = list_append_double(y_true_bc, &y_true_bc_len, 1.0);
    y_true_bc = list_append_double(y_true_bc, &y_true_bc_len, 0.0);
    y_true_bc = list_append_double(y_true_bc, &y_true_bc_len, 1.0);
    double *y_pred_bc = NULL;
    size_t y_pred_bc_len = 0;
    y_pred_bc = list_append_double(y_pred_bc, &y_pred_bc_len, 0.2);
    y_pred_bc = list_append_double(y_pred_bc, &y_pred_bc_len, 0.7);
    y_pred_bc = list_append_double(y_pred_bc, &y_pred_bc_len, 0.9);
    y_pred_bc = list_append_double(y_pred_bc, &y_pred_bc_len, 0.3);
    y_pred_bc = list_append_double(y_pred_bc, &y_pred_bc_len, 0.8);
    printf("%g\n", binary_cross_entropy(y_true_bc, y_true_bc_len, y_pred_bc, y_pred_bc_len, 1e-15));
    printf("%g\n", binary_focal_cross_entropy(y_true_bc, y_true_bc_len, y_pred_bc, y_pred_bc_len, 2.0, 0.25, 1e-15));
    long long y_true_cce_0[3] = {1.0, 0.0, 0.0};
    long long y_true_cce_1[3] = {0.0, 1.0, 0.0};
    long long y_true_cce_2[3] = {0.0, 0.0, 1.0};
    long long *y_true_cce_init[3] = {y_true_cce_0, y_true_cce_1, y_true_cce_2};
    long long **y_true_cce = y_true_cce_init;
    size_t y_true_cce_len = 3;
    size_t y_true_cce_lens_init[3] = {3, 3, 3};
    size_t *y_true_cce_lens = y_true_cce_lens_init;
    size_t y_true_cce_lens_len = 3;
    double y_pred_cce_0[3] = {0.9, 0.1, 0.0};
    double y_pred_cce_1[3] = {0.2, 0.7, 0.1};
    double y_pred_cce_2[3] = {0.0, 0.1, 0.9};
    double *y_pred_cce_init[3] = {y_pred_cce_0, y_pred_cce_1, y_pred_cce_2};
    double **y_pred_cce = y_pred_cce_init;
    size_t y_pred_cce_len = 3;
    size_t y_pred_cce_lens_init[3] = {3, 3, 3};
    size_t *y_pred_cce_lens = y_pred_cce_lens_init;
    size_t y_pred_cce_lens_len = 3;
    printf("%g\n", categorical_cross_entropy(y_true_cce, y_true_cce_len, y_true_cce_lens, y_true_cce_len, y_pred_cce, y_pred_cce_len, y_pred_cce_lens, y_pred_cce_len, 1e-15));
    double *alpha = NULL;
    size_t alpha_len = 0;
    alpha = list_append_double(alpha, &alpha_len, 0.6);
    alpha = list_append_double(alpha, &alpha_len, 0.2);
    alpha = list_append_double(alpha, &alpha_len, 0.7);
    printf("%g\n", categorical_focal_cross_entropy(y_true_cce, y_true_cce_len, y_true_cce_lens, y_true_cce_len, y_pred_cce, y_pred_cce_len, y_pred_cce_lens, y_pred_cce_len, alpha, alpha_len, 2.0, 1e-15));
    double *y_true_hinge = NULL;
    size_t y_true_hinge_len = 0;
    y_true_hinge = list_append_double(y_true_hinge, &y_true_hinge_len, -1.0);
    y_true_hinge = list_append_double(y_true_hinge, &y_true_hinge_len, 1.0);
    y_true_hinge = list_append_double(y_true_hinge, &y_true_hinge_len, 1.0);
    y_true_hinge = list_append_double(y_true_hinge, &y_true_hinge_len, -1.0);
    y_true_hinge = list_append_double(y_true_hinge, &y_true_hinge_len, 1.0);
    double *y_pred_hinge = NULL;
    size_t y_pred_hinge_len = 0;
    y_pred_hinge = list_append_double(y_pred_hinge, &y_pred_hinge_len, -4.0);
    y_pred_hinge = list_append_double(y_pred_hinge, &y_pred_hinge_len, -0.3);
    y_pred_hinge = list_append_double(y_pred_hinge, &y_pred_hinge_len, 0.7);
    y_pred_hinge = list_append_double(y_pred_hinge, &y_pred_hinge_len, 5.0);
    y_pred_hinge = list_append_double(y_pred_hinge, &y_pred_hinge_len, 10.0);
    printf("%g\n", hinge_loss(y_true_hinge, y_true_hinge_len, y_pred_hinge, y_pred_hinge_len));
    double *y_true_huber = NULL;
    size_t y_true_huber_len = 0;
    y_true_huber = list_append_double(y_true_huber, &y_true_huber_len, 0.9);
    y_true_huber = list_append_double(y_true_huber, &y_true_huber_len, 10.0);
    y_true_huber = list_append_double(y_true_huber, &y_true_huber_len, 2.0);
    y_true_huber = list_append_double(y_true_huber, &y_true_huber_len, 1.0);
    y_true_huber = list_append_double(y_true_huber, &y_true_huber_len, 5.2);
    double *y_pred_huber = NULL;
    size_t y_pred_huber_len = 0;
    y_pred_huber = list_append_double(y_pred_huber, &y_pred_huber_len, 0.8);
    y_pred_huber = list_append_double(y_pred_huber, &y_pred_huber_len, 2.1);
    y_pred_huber = list_append_double(y_pred_huber, &y_pred_huber_len, 2.9);
    y_pred_huber = list_append_double(y_pred_huber, &y_pred_huber_len, 4.2);
    y_pred_huber = list_append_double(y_pred_huber, &y_pred_huber_len, 5.2);
    printf("%g\n", huber_loss(y_true_huber, y_true_huber_len, y_pred_huber, y_pred_huber_len, 1.0));
    printf("%g\n", mean_squared_error(y_true_huber, y_true_huber_len, y_pred_huber, y_pred_huber_len));
    printf("%g\n", mean_absolute_error(y_true_huber, y_true_huber_len, y_pred_huber, y_pred_huber_len));
    printf("%g\n", mean_squared_logarithmic_error(y_true_huber, y_true_huber_len, y_pred_huber, y_pred_huber_len));
    double *y_true_mape = NULL;
    size_t y_true_mape_len = 0;
    y_true_mape = list_append_double(y_true_mape, &y_true_mape_len, 10.0);
    y_true_mape = list_append_double(y_true_mape, &y_true_mape_len, 20.0);
    y_true_mape = list_append_double(y_true_mape, &y_true_mape_len, 30.0);
    y_true_mape = list_append_double(y_true_mape, &y_true_mape_len, 40.0);
    double *y_pred_mape = NULL;
    size_t y_pred_mape_len = 0;
    y_pred_mape = list_append_double(y_pred_mape, &y_pred_mape_len, 12.0);
    y_pred_mape = list_append_double(y_pred_mape, &y_pred_mape_len, 18.0);
    y_pred_mape = list_append_double(y_pred_mape, &y_pred_mape_len, 33.0);
    y_pred_mape = list_append_double(y_pred_mape, &y_pred_mape_len, 45.0);
    printf("%g\n", mean_absolute_percentage_error(y_true_mape, y_true_mape_len, y_pred_mape, y_pred_mape_len, 1e-15));
    long long y_true_perp_0[2] = {1LL, 4LL};
    long long y_true_perp_1[2] = {2LL, 3LL};
    long long *y_true_perp_init[2] = {y_true_perp_0, y_true_perp_1};
    long long **y_true_perp = y_true_perp_init;
    size_t y_true_perp_len = 2;
    size_t y_true_perp_lens_init[2] = {2, 2};
    size_t *y_true_perp_lens = y_true_perp_lens_init;
    size_t y_true_perp_lens_len = 2;
    double y_pred_perp_0_0[5] = {0.28, 0.19, 0.21, 0.15, 0.17};
    double y_pred_perp_0_1[5] = {0.24, 0.19, 0.09, 0.18, 0.3};
    double *y_pred_perp_0[2] = {y_pred_perp_0_0, y_pred_perp_0_1};
    size_t y_pred_perp_0_lens[2] = {5, 5};
    double y_pred_perp_1_0[5] = {0.03, 0.26, 0.21, 0.18, 0.32};
    double y_pred_perp_1_1[5] = {0.28, 0.1, 0.33, 0.15, 0.14};
    double *y_pred_perp_1[2] = {y_pred_perp_1_0, y_pred_perp_1_1};
    size_t y_pred_perp_1_lens[2] = {5, 5};
    double **y_pred_perp_init[2] = {y_pred_perp_0, y_pred_perp_1};
    double ***y_pred_perp = y_pred_perp_init;
    size_t y_pred_perp_len = 2;
    size_t y_pred_perp_lens_init[2] = {2, 2};
    size_t *y_pred_perp_lens = y_pred_perp_lens_init;
    size_t y_pred_perp_lens_len = 2;
    size_t *y_pred_perp_lens_lens_init[2] = {y_pred_perp_0_lens, y_pred_perp_1_lens};
    size_t **y_pred_perp_lens_lens = y_pred_perp_lens_lens_init;
    size_t y_pred_perp_lens_lens_len = 2;
    printf("%g\n", perplexity_loss(y_true_perp, y_true_perp_len, y_true_perp_lens, y_true_perp_len, y_pred_perp, y_pred_perp_len, y_pred_perp_lens, y_pred_perp_len, 1e-07));
    double *y_true_smooth = NULL;
    size_t y_true_smooth_len = 0;
    y_true_smooth = list_append_double(y_true_smooth, &y_true_smooth_len, 3.0);
    y_true_smooth = list_append_double(y_true_smooth, &y_true_smooth_len, 5.0);
    y_true_smooth = list_append_double(y_true_smooth, &y_true_smooth_len, 2.0);
    y_true_smooth = list_append_double(y_true_smooth, &y_true_smooth_len, 7.0);
    double *y_pred_smooth = NULL;
    size_t y_pred_smooth_len = 0;
    y_pred_smooth = list_append_double(y_pred_smooth, &y_pred_smooth_len, 2.9);
    y_pred_smooth = list_append_double(y_pred_smooth, &y_pred_smooth_len, 4.8);
    y_pred_smooth = list_append_double(y_pred_smooth, &y_pred_smooth_len, 2.1);
    y_pred_smooth = list_append_double(y_pred_smooth, &y_pred_smooth_len, 7.2);
    printf("%g\n", smooth_l1_loss(y_true_smooth, y_true_smooth_len, y_pred_smooth, y_pred_smooth_len, 1.0));
    double *y_true_kl = NULL;
    size_t y_true_kl_len = 0;
    y_true_kl = list_append_double(y_true_kl, &y_true_kl_len, 0.2);
    y_true_kl = list_append_double(y_true_kl, &y_true_kl_len, 0.3);
    y_true_kl = list_append_double(y_true_kl, &y_true_kl_len, 0.5);
    double *y_pred_kl = NULL;
    size_t y_pred_kl_len = 0;
    y_pred_kl = list_append_double(y_pred_kl, &y_pred_kl_len, 0.3);
    y_pred_kl = list_append_double(y_pred_kl, &y_pred_kl_len, 0.3);
    y_pred_kl = list_append_double(y_pred_kl, &y_pred_kl_len, 0.4);
    printf("%g\n", kullback_leibler_divergence(y_true_kl, y_true_kl_len, y_pred_kl, y_pred_kl_len));
}

int main(void) {
    user_main();
    return 0;
}
