// Generated by Mochi 0.10.32 on 2025-08-23 21:18 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t get_neighbors_len;
size_t remove_at_len;

size_t append_len;
#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct SearchProblem SearchProblem;

struct SearchProblem {
    double x;
    double y;
    double step;
};

static SearchProblem* list_append_SearchProblem(SearchProblem *arr, size_t *len, SearchProblem val) {
    arr = realloc(arr, (*len + 1) * sizeof(SearchProblem));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long seed = 1LL;

double score(SearchProblem p, double(*f)(double, double));
SearchProblem * get_neighbors(SearchProblem p);
SearchProblem * remove_at(SearchProblem * lst, size_t lst_len, long long idx);
long long user_rand();
double random_float();
long long randint(long long low, long long high);
double expApprox(double x);
SearchProblem simulated_annealing(SearchProblem search_prob, double(*f)(double, double), long long find_max, double max_x, double min_x, double max_y, double min_y, double start_temp, double rate_of_decrease, double threshold_temp);
double test_f1(double x, double y);
double test_f2(double x, double y);
void user_main();
int main(void);

double score(SearchProblem p, double(*f)(double, double)) {
    return f(p.x, p.y);
}

SearchProblem * get_neighbors(SearchProblem p) {
    double s = p.step;
    SearchProblem *ns = NULL;
    size_t ns_len = 0;
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x - s, .y = p.y - s, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x - s, .y = p.y, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x - s, .y = p.y + s, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x, .y = p.y - s, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x, .y = p.y + s, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x + s, .y = p.y - s, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x + s, .y = p.y, .step = s});
    ns = list_append_SearchProblem(ns, &ns_len, (SearchProblem){.x = p.x + s, .y = p.y + s, .step = s});
    return get_neighbors_len = ns_len, ns;
}

SearchProblem * remove_at(SearchProblem * lst, size_t lst_len, long long idx) {
    SearchProblem *res = NULL;
    size_t res_len = 0;
    long long i = 0LL;
    while (i < lst_len) {
        if (i != idx) {
            res = list_append_SearchProblem(res, &res_len, lst[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? lst_len + _mochi_idx : _mochi_idx;})]);
        }
        i = i + 1LL;
    }
    return remove_at_len = res_len, res;
}

long long user_rand() {
    long long _t = _now();
    seed = ((seed * 1103515245LL) + 12345LL) % 2147483648LL;
    return seed;
}

double random_float() {
    return (double)(user_rand()) / 2.147483648e+09;
}

long long randint(long long low, long long high) {
    return (user_rand() % ((high - low) + 1LL)) + low;
}

double expApprox(double x) {
    double y = x;
    long long is_neg = 0LL;
    if (x < 0.0) {
        is_neg = 1LL;
        y = -(x);
    }
    double term = 1.0;
    double sum = 1.0;
    long long n = 1LL;
    while (n < 30LL) {
        term = (term * y) / (double)(n);
        sum = sum + term;
        n = n + 1LL;
    }
    if (is_neg) {
        return 1.0 / sum;
    }
    return sum;
}

SearchProblem simulated_annealing(SearchProblem search_prob, double(*f)(double, double), long long find_max, double max_x, double min_x, double max_y, double min_y, double start_temp, double rate_of_decrease, double threshold_temp) {
    long long search_end = 0LL;
    SearchProblem current_state = search_prob;
    double current_temp = start_temp;
    SearchProblem best_state = current_state;
    while (!(search_end)) {
        double current_score = score(current_state, f);
        if (score(best_state, f) < current_score) {
            best_state = current_state;
        }
        SearchProblem next_state = current_state;
        long long found_next = 0LL;
        SearchProblem *neighbors = get_neighbors(current_state);
        size_t neighbors_len = get_neighbors_len;
        while (!(found_next) && (neighbors_len > 0LL)) {
            long long idx = randint(0LL, neighbors_len - 1LL);
            SearchProblem picked_neighbor = neighbors[(int)({long long _mochi_idx = idx; _mochi_idx < 0 ? neighbors_len + _mochi_idx : _mochi_idx;})];
            neighbors = remove_at(neighbors, neighbors_len, idx);
            neighbors_len = remove_at_len;
            if ((((picked_neighbor.x > max_x) || (picked_neighbor.x < min_x)) || (picked_neighbor.y > max_y)) || (picked_neighbor.y < min_y)) {
                continue;
            }
            double change = score(picked_neighbor, f) - current_score;
            if (!(find_max)) {
                change = -(change);
            }
            if (change > 0.0) {
                next_state = picked_neighbor;
                found_next = 1LL;
            } else {
                double probability = expApprox(change / current_temp);
                if (random_float() < probability) {
                    next_state = picked_neighbor;
                    found_next = 1LL;
                }
            }
        }
        current_temp = current_temp - (current_temp * rate_of_decrease);
        if ((current_temp < threshold_temp) || !(found_next)) {
            search_end = 1LL;
        } else {
            current_state = next_state;
        }
    }
    return best_state;
}

double test_f1(double x, double y) {
    return (x * x) + (y * y);
}

double test_f2(double x, double y) {
    return ((3.0 * x) * x) - (6.0 * y);
}

void user_main() {
    SearchProblem prob1 = (SearchProblem){.x = 12.0, .y = 47.0, .step = 1.0};
    SearchProblem min_state = simulated_annealing(prob1, test_f1, 0LL, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0);
    printf("%s %g\n", "min1", test_f1(min_state.x, min_state.y));
    SearchProblem prob2 = (SearchProblem){.x = 12.0, .y = 47.0, .step = 1.0};
    SearchProblem max_state = simulated_annealing(prob2, test_f1, 1LL, 100.0, 5.0, 50.0, -5.0, 100.0, 0.01, 1.0);
    printf("%s %g\n", "max1", test_f1(max_state.x, max_state.y));
    SearchProblem prob3 = (SearchProblem){.x = 3.0, .y = 4.0, .step = 1.0};
    SearchProblem min_state2 = simulated_annealing(prob3, test_f2, 0LL, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0);
    printf("%s %g\n", "min2", test_f2(min_state2.x, min_state2.y));
    SearchProblem prob4 = (SearchProblem){.x = 3.0, .y = 4.0, .step = 1.0};
    SearchProblem max_state2 = simulated_annealing(prob4, test_f2, 1LL, 1000.0, -1000.0, 1000.0, -1000.0, 100.0, 0.01, 1.0);
    printf("%s %g\n", "max2", test_f2(max_state2.x, max_state2.y));
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
