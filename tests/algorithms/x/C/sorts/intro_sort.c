// Generated by Mochi 0.10.32 on 2025-08-24 09:06 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t insertion_sort_len;
size_t heapify_len;
size_t heap_sort_len;
size_t intro_sort_len;

size_t append_len;
static char* str_list_int(const long long *arr, size_t len) {
    size_t cap = len * 32 + 2;
    char *buf = malloc(cap);
    size_t pos = 0;
    buf[pos++] = '[';
    for (size_t i = 0; i < len; i++) {
        char tmp[32];
        snprintf(tmp, sizeof(tmp), "%lld", arr[i]);
        size_t n = strlen(tmp);
        if (pos + n + 2 >= cap) { cap = cap * 2 + n + 2; buf = realloc(buf, cap); }
        memcpy(buf + pos, tmp, n);
        pos += n;
        if (i + 1 < len) buf[pos++] = ' ';
    }
    buf[pos++] = ']';
    buf[pos] = 0;
    return buf;
}

#include <time.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

long long example1_init[16] = {4LL, 2LL, 6LL, 8LL, 1LL, 7LL, 8LL, 22LL, 14LL, 56LL, 27LL, 79LL, 23LL, 45LL, 14LL, 12LL};
long long *example1 = example1_init;
size_t example1_len = 16;
long long example2_init[7] = {21LL, 15LL, 11LL, 45LL, -2LL, -11LL, 46LL};
long long *example2 = example2_init;
size_t example2_len = 7;

long long * insertion_sort(long long * a, size_t a_len, long long start, long long end_);
long long * heapify(long long * a, size_t a_len, long long index, long long heap_size);
long long * heap_sort(long long * a, size_t a_len);
long long median_of_3(long long * arr, size_t arr_len, long long first, long long middle, long long last);
long long partition(long long * arr, size_t arr_len, long long low, long long high, long long pivot);
long long int_log2(long long n);
long long * intro_sort(long long * arr, size_t arr_len, long long start, long long end_, long long size_threshold, long long max_depth);
void intro_sort_main(long long * arr, size_t arr_len);
int main(void);

long long * insertion_sort(long long * a, size_t a_len, long long start, long long end_) {
    long long *arr = a;
    size_t arr_len = a_len;
    long long i = start;
    while (i < end_) {
        long long key = arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        long long j = i;
        while ((j > start) && (arr[(int)({long long _mochi_idx = j - 1LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] > key)) {
            arr[(int)(j)] = arr[(int)({long long _mochi_idx = j - 1LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
            j = j - 1LL;
        }
        arr[(int)(j)] = key;
        i = i + 1LL;
    }
    return insertion_sort_len = arr_len, arr;
}

long long * heapify(long long * a, size_t a_len, long long index, long long heap_size) {
    long long *arr = a;
    size_t arr_len = a_len;
    long long largest = index;
    long long left = (2LL * index) + 1LL;
    long long right = (2LL * index) + 2LL;
    if ((left < heap_size) && (arr[(int)({long long _mochi_idx = left; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] > arr[(int)({long long _mochi_idx = largest; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})])) {
        largest = left;
    }
    if ((right < heap_size) && (arr[(int)({long long _mochi_idx = right; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] > arr[(int)({long long _mochi_idx = largest; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})])) {
        largest = right;
    }
    if (largest != index) {
        long long temp = arr[(int)({long long _mochi_idx = index; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        arr[(int)(index)] = arr[(int)({long long _mochi_idx = largest; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        arr[(int)(largest)] = temp;
        arr = heapify(arr, arr_len, largest, heap_size);
        arr_len = heapify_len;
    }
    return heapify_len = arr_len, arr;
}

long long * heap_sort(long long * a, size_t a_len) {
    long long *arr = a;
    size_t arr_len = a_len;
    long long n = arr_len;
    if (n <= 1LL) {
        return heap_sort_len = arr_len, arr;
    }
    long long i = n / 2LL;
    while (1) {
        arr = heapify(arr, arr_len, i, n);
        arr_len = heapify_len;
        if (i == 0LL) {
            break;
        }
        i = i - 1LL;
    }
    i = n - 1LL;
    while (i > 0LL) {
        long long temp = arr[(int)({long long _mochi_idx = 0LL; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        arr[(int)(0LL)] = arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        arr[(int)(i)] = temp;
        arr = heapify(arr, arr_len, 0LL, i);
        arr_len = heapify_len;
        i = i - 1LL;
    }
    return heap_sort_len = arr_len, arr;
}

long long median_of_3(long long * arr, size_t arr_len, long long first, long long middle, long long last) {
    long long a = arr[(int)({long long _mochi_idx = first; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
    long long b = arr[(int)({long long _mochi_idx = middle; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
    long long c = arr[(int)({long long _mochi_idx = last; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
    if (((a > b) && (a < c)) || ((a < b) && (a > c))) {
        return a;
    } else {
        if (((b > a) && (b < c)) || ((b < a) && (b > c))) {
            return b;
        } else {
            return c;
        }
    }
}

long long partition(long long * arr, size_t arr_len, long long low, long long high, long long pivot) {
    long long i = low;
    long long j = high;
    while (1) {
        while (arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})] < pivot) {
            i = i + 1LL;
        }
        j = j - 1LL;
        while (pivot < arr[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})]) {
            j = j - 1LL;
        }
        if (i >= j) {
            return i;
        }
        long long temp = arr[(int)({long long _mochi_idx = i; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        arr[(int)(i)] = arr[(int)({long long _mochi_idx = j; _mochi_idx < 0 ? arr_len + _mochi_idx : _mochi_idx;})];
        arr[(int)(j)] = temp;
        i = i + 1LL;
    }
}

long long int_log2(long long n) {
    long long v = n;
    long long r = 0LL;
    while (v > 1LL) {
        v = v / 2LL;
        r = r + 1LL;
    }
    return r;
}

long long * intro_sort(long long * arr, size_t arr_len, long long start, long long end_, long long size_threshold, long long max_depth) {
    long long *array = arr;
    size_t array_len = arr_len;
    long long s = start;
    long long e = end_;
    long long depth = max_depth;
    while ((e - s) > size_threshold) {
        if (depth == 0LL) {
            {
                long long* __ret0 = heap_sort(array, array_len);
                intro_sort_len = heap_sort_len;
                return __ret0;
            }
        }
        depth = depth - 1LL;
        long long pivot = median_of_3(array, array_len, s, (s + ((e - s) / 2LL)) + 1LL, e - 1LL);
        long long p = partition(array, array_len, s, e, pivot);
        array = intro_sort(array, array_len, p, e, size_threshold, depth);
        array_len = intro_sort_len;
        e = p;
    }
    long long *res = insertion_sort(array, array_len, s, e);
    size_t res_len = insertion_sort_len;
    long long _ = res_len;
    return intro_sort_len = res_len, res;
}

void intro_sort_main(long long * arr, size_t arr_len) {
    if (arr_len == 0LL) {
        puts(str_list_int(arr, arr_len));
        return 0;
    }
    long long max_depth = 2LL * int_log2(arr_len);
    long long *sorted = intro_sort(arr, arr_len, 0LL, arr_len, 16LL, max_depth);
    size_t sorted_len = intro_sort_len;
    puts(str_list_int(sorted, sorted_len));
}

int main(void) {
    {
        long long __start = _now();
        intro_sort_main(example1, example1_len);
        intro_sort_main(example2, example2_len);
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
