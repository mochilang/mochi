// Generated by Mochi 0.10.32 on 2025-08-08 18:03 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>

size_t lz77_compress_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Anon1 Anon1;
typedef struct Token Token;

struct Anon1 {
    const char* __name;
    const char* indicator;
    const char* length;
    const char* offset;
};

struct Token {
    long long offset;
    long long length;
    const char* indicator;
};

static Token* list_append_Token(Token *arr, size_t *len, Token val) {
    arr = realloc(arr, (*len + 1) * sizeof(Token));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Token *c1 = NULL;
size_t c1_len = 0;
Token *c2 = NULL;
size_t c2_len = 0;
Token tokens_example_init[8] = {(Token){.offset = 0LL, .length = 0LL, .indicator = "c"}, (Token){.offset = 0LL, .length = 0LL, .indicator = "a"}, (Token){.offset = 0LL, .length = 0LL, .indicator = "b"}, (Token){.offset = 0LL, .length = 0LL, .indicator = "r"}, (Token){.offset = 3LL, .length = 1LL, .indicator = "c"}, (Token){.offset = 2LL, .length = 1LL, .indicator = "d"}, (Token){.offset = 7LL, .length = 4LL, .indicator = "r"}, (Token){.offset = 3LL, .length = 5LL, .indicator = "d"}};
Token *tokens_example = tokens_example_init;
size_t tokens_example_len = 8;

const char* token_to_string(Token t);
const char* tokens_to_string(Token * ts, size_t ts_len);
long long match_length_from_index(const char* text, const char* window, long long text_index, long long window_index);
Token find_encoding_token(const char* text, const char* search_buffer);
Token * lz77_compress(const char* text, long long window_size, long long lookahead);
const char* lz77_decompress(Token * tokens, size_t tokens_len);
int main(void);

const char* token_to_string(Token t) {
    return str_concat(str_concat(str_concat(str_concat(str_concat(str_concat("(", str_int(t.offset)), ", "), str_int(t.length)), ", "), t.indicator), ")");
}

const char* tokens_to_string(Token * ts, size_t ts_len) {
    const char* res = "[";
    long long i = 0LL;
    while (i < ts_len) {
        res = str_concat(res, token_to_string(ts[(int)(i)]));
        if (i < (ts_len - 1LL)) {
            res = str_concat(res, ", ");
        }
        i = i + 1LL;
    }
    return str_concat(res, "]");
}

long long match_length_from_index(const char* text, const char* window, long long text_index, long long window_index) {
    if ((text_index >= strlen(text)) || (window_index >= strlen(window))) {
        return 0LL;
    }
    const char* tc = _substring(text, text_index, text_index + 1LL);
    const char* wc = _substring(window, window_index, window_index + 1LL);
    if (strcmp(tc, wc) != 0) {
        return 0LL;
    }
    return 1LL + match_length_from_index(text, str_concat(window, tc), text_index + 1LL, window_index + 1LL);
}

Token find_encoding_token(const char* text, const char* search_buffer) {
    if (strlen(text) == 0LL) {
        panic("We need some text to work with.");
    }
    long long length = 0LL;
    long long offset = 0LL;
    if (strlen(search_buffer) == 0LL) {
        return (Token){.offset = offset, .length = length, .indicator = _substring(text, 0LL, 1LL)};
    }
    long long i = 0LL;
    while (i < strlen(search_buffer)) {
        const char* ch = _substring(search_buffer, i, i + 1LL);
        long long found_offset = strlen(search_buffer) - i;
        if (strcmp(ch, _substring(text, 0LL, 1LL)) == 0) {
            long long found_length = match_length_from_index(text, search_buffer, 0LL, i);
            if (found_length >= length) {
                offset = found_offset;
                length = found_length;
            }
        }
        i = i + 1LL;
    }
    return (Token){.offset = offset, .length = length, .indicator = _substring(text, length, length + 1LL)};
}

Token * lz77_compress(const char* text, long long window_size, long long lookahead) {
    long long search_buffer_size = window_size - lookahead;
    Token *output = NULL;
    size_t output_len = 0;
    const char* search_buffer = "";
    const char* remaining = text;
    while (strlen(remaining) > 0LL) {
        Token token = find_encoding_token(remaining, search_buffer);
        long long add_len = token.length + 1LL;
        search_buffer = str_concat(search_buffer, _substring(remaining, 0LL, add_len));
        if (strlen(search_buffer) > search_buffer_size) {
            search_buffer = _substring(search_buffer, strlen(search_buffer) - search_buffer_size, strlen(search_buffer));
        }
        remaining = _substring(remaining, add_len, strlen(remaining));
        output = list_append_Token(output, &output_len, token);
    }
    return lz77_compress_len = output_len, output;
}

const char* lz77_decompress(Token * tokens, size_t tokens_len) {
    const char* output = "";
    for (size_t __i = 0; __i < tokens_len; __i++) {
        Token t = tokens[__i];
        long long i = 0LL;
        while (i < t.length) {
            output = str_concat(output, _substring(output, strlen(output) - t.offset, (strlen(output) - t.offset) + 1LL));
            i = i + 1LL;
        }
        output = str_concat(output, t.indicator);
    }
    return output;
}

int main(void) {
    {
        long long __start = _now();
        c1 = lz77_compress("ababcbababaa", 13LL, 6LL);
        c1_len = lz77_compress_len;
        puts(tokens_to_string(c1, c1_len));
        c2 = lz77_compress("aacaacabcabaaac", 13LL, 6LL);
        c2_len = lz77_compress_len;
        puts(tokens_to_string(c2, c2_len));
        puts(lz77_decompress(tokens_example, tokens_example_len));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
