// Generated by Mochi 0.10.32 on 2025-08-08 18:03 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

typedef struct { const char **keys; const char **vals; size_t len; size_t cap; } MapSS;

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static void map_set_ss(MapSS *m, const char *key, const char *val) {
    for (size_t i = 0; i < m->len; i++) {
        if (strcmp(m->keys[i], key) == 0) { m->vals[i] = val; return; }
    }
    if (m->len >= m->cap) {
        m->cap = m->cap ? m->cap * 2 : 16;
        m->keys = realloc((void*)m->keys, m->cap * sizeof(char*));
        m->vals = realloc((void*)m->vals, m->cap * sizeof(char*));
    }
    m->keys[m->len] = key; m->vals[m->len] = val; m->len++;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

const char* sample = "1011001";
const char* decompressed = "";

long long list_contains(const char* * xs, size_t xs_len, const char* v);
long long is_power_of_two(long long n);
const char* bin_string(long long n);
const char* decompress_data(const char* data_bits);
int main(void);

long long list_contains(const char* * xs, size_t xs_len, const char* v) {
    long long i = 0LL;
    while (i < xs_len) {
        if (strcmp(xs[(int)(i)], v) == 0) {
            return 1LL;
        }
        i = i + 1LL;
    }
    return 0LL;
}

long long is_power_of_two(long long n) {
    if (n < 1LL) {
        return 0LL;
    }
    long long x = n;
    while (x > 1LL) {
        if ((x % 2LL) != 0LL) {
            return 0LL;
        }
        x = x / 2LL;
    }
    return 1LL;
}

const char* bin_string(long long n) {
    if (n == 0LL) {
        return "0";
    }
    const char* res = "";
    long long x = n;
    while (x > 0LL) {
        long long bit = x % 2LL;
        res = str_concat(str_int(bit), res);
        x = x / 2LL;
    }
    return res;
}

const char* decompress_data(const char* data_bits) {
    static const char* lexicon_keys[18] = {"0", "1"};
    const char* lexicon_vals[18] = {"0", "1"};
    size_t lexicon_len = 2;
    MapSS lexicon = { lexicon_keys, lexicon_vals, 2, 18 };
    const char* *keys = NULL;
    size_t keys_len = 0;
    keys = list_append_str(keys, &keys_len, "0");
    keys = list_append_str(keys, &keys_len, "1");
    const char* result = "";
    const char* curr_string = "";
    long long index = 2LL;
    long long i = 0LL;
    while (i < strlen(data_bits)) {
        curr_string = str_concat(curr_string, _substring(data_bits, i, i + 1LL));
        if (!(list_contains(keys, keys_len, curr_string))) {
            i = i + 1LL;
            continue;
        }
        const char* last_match_id = map_get_ss(lexicon.keys, lexicon.vals, lexicon.len, curr_string);
        result = str_concat(result, last_match_id);
        map_set_ss(&lexicon, curr_string, str_concat(last_match_id, "0"));
        if (is_power_of_two(index)) {
            MapSS new_lex = { NULL, NULL, 0, 0 };
            const char* *new_keys = NULL;
            size_t new_keys_len = 0;
            long long j = 0LL;
            while (j < keys_len) {
                const char* curr_key = keys[(int)(j)];
                map_set_ss(&new_lex, str_concat("0", curr_key), map_get_ss(lexicon.keys, lexicon.vals, lexicon.len, curr_key));
                new_keys = list_append_str(new_keys, &new_keys_len, str_concat("0", curr_key));
                j = j + 1LL;
            }
            lexicon = new_lex;
            keys = new_keys;
            keys_len = new_keys_len;
        }
        const char* new_key = bin_string(index);
        map_set_ss(&lexicon, new_key, str_concat(last_match_id, "1"));
        keys = list_append_str(keys, &keys_len, new_key);
        index = index + 1LL;
        curr_string = "";
        i = i + 1LL;
    }
    return result;
}

int main(void) {
    {
        long long __start = _now();
        decompressed = decompress_data(sample);
        puts(decompressed);
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
