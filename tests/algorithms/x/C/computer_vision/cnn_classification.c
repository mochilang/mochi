// Generated by Mochi 0.10.32 on 2025-08-07 16:48 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>

size_t conv2d_len;
size_t *conv2d_lens;
size_t relu_matrix_len;
size_t *relu_matrix_lens;
size_t max_pool2x2_len;
size_t *max_pool2x2_lens;
size_t flatten_len;

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

double image_0[6] = {0.0, 1.0, 1.0, 0.0, 0.0, 0.0};
double image_1[6] = {0.0, 1.0, 1.0, 0.0, 0.0, 0.0};
double image_2[6] = {0.0, 0.0, 1.0, 1.0, 0.0, 0.0};
double image_3[6] = {0.0, 0.0, 1.0, 1.0, 0.0, 0.0};
double image_4[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
double image_5[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
double *image_init[6] = {image_0, image_1, image_2, image_3, image_4, image_5};
double **image = image_init;
size_t image_len = 6;
size_t image_lens_init[6] = {6, 6, 6, 6, 6, 6};
size_t *image_lens = image_lens_init;
size_t image_lens_len = 6;
double kernel_0[3] = {1.0, 0.0, -(1.0)};
double kernel_1[3] = {1.0, 0.0, -(1.0)};
double kernel_2[3] = {1.0, 0.0, -(1.0)};
double *kernel_init[3] = {kernel_0, kernel_1, kernel_2};
double **kernel = kernel_init;
size_t kernel_len = 3;
size_t kernel_lens_init[3] = {3, 3, 3};
size_t *kernel_lens = kernel_lens_init;
size_t kernel_lens_len = 3;
double **conv = NULL;
size_t conv_len = 0;
size_t *conv_lens = NULL;
size_t conv_lens_len = 0;
double **activated = NULL;
size_t activated_len = 0;
size_t *activated_lens = NULL;
size_t activated_lens_len = 0;
double **pooled = NULL;
size_t pooled_len = 0;
size_t *pooled_lens = NULL;
size_t pooled_lens_len = 0;
double *flat = NULL;
size_t flat_len = 0;
double weights_init[4] = {0.5, -(0.4), 0.3, 0.1};
double *weights = weights_init;
size_t weights_len = 4;
double bias = 0.0;
double output = 0;
double probability = 0;

double * * conv2d(double * * image, size_t image_len, size_t* image_lens, size_t image_lens_len, double * * kernel, size_t kernel_len, size_t* kernel_lens, size_t kernel_lens_len);
double * * relu_matrix(double * * m, size_t m_len, size_t* m_lens, size_t m_lens_len);
double * * max_pool2x2(double * * m, size_t m_len, size_t* m_lens, size_t m_lens_len);
double * flatten(double * * m, size_t m_len, size_t* m_lens, size_t m_lens_len);
double dense(double * inputs, size_t inputs_len, double * weights, size_t weights_len, double bias);
double exp_approx(double x);
double sigmoid(double x);
int main(void);

double * * conv2d(double * * image, size_t image_len, size_t* image_lens, size_t image_lens_len, double * * kernel, size_t kernel_len, size_t* kernel_lens, size_t kernel_lens_len) {
    long long rows = image_len;
    long long cols = image_lens[0LL];
    long long k = kernel_len;
    double **output = NULL;
    size_t output_len = 0;
    size_t *output_lens = NULL;
    size_t output_lens_len = 0;
    long long i = 0LL;
    while (i <= (rows - k)) {
        double *row = NULL;
        size_t row_len = 0;
        long long j = 0LL;
        while (j <= (cols - k)) {
            double sum = 0.0;
            long long ki = 0LL;
            while (ki < k) {
                long long kj = 0LL;
                while (kj < k) {
                    sum = sum + (image[(int)(i + ki)][(int)(j + kj)] * kernel[(int)(ki)][(int)(kj)]);
                    kj = kj + 1LL;
                }
                ki = ki + 1LL;
            }
            row = list_append_double(row, &row_len, sum);
            j = j + 1LL;
        }
        output = list_append_doubleptr(output, &output_len, row);
        output_lens = list_append_szt(output_lens, &output_lens_len, row_len);
        i = i + 1LL;
    }
    return conv2d_lens = output_lens, conv2d_len = output_len, output;
}

double * * relu_matrix(double * * m, size_t m_len, size_t* m_lens, size_t m_lens_len) {
    double **out = NULL;
    size_t out_len = 0;
    size_t *out_lens = NULL;
    size_t out_lens_len = 0;
    for (size_t __i = 0; __i < m_len; __i++) {
        double *row = m[__i];
        size_t row_len = m_lens[__i];
        double *new_row = NULL;
        size_t new_row_len = 0;
        for (size_t __i = 0; __i < row_len; __i++) {
            double v = row[__i];
            if (v > 0.0) {
                new_row = list_append_double(new_row, &new_row_len, v);
            } else {
                new_row = list_append_long_long(new_row, &new_row_len, 0.0);
            }
        }
        out = list_append_doubleptr(out, &out_len, new_row);
        out_lens = list_append_szt(out_lens, &out_lens_len, new_row_len);
    }
    return relu_matrix_lens = out_lens, relu_matrix_len = out_len, out;
}

double * * max_pool2x2(double * * m, size_t m_len, size_t* m_lens, size_t m_lens_len) {
    long long rows = m_len;
    long long cols = m_lens[0LL];
    double **out = NULL;
    size_t out_len = 0;
    size_t *out_lens = NULL;
    size_t out_lens_len = 0;
    long long i = 0LL;
    while (i < rows) {
        double *new_row = NULL;
        size_t new_row_len = 0;
        long long j = 0LL;
        while (j < cols) {
            double max_val = m[(int)(i)][(int)(j)];
            if (m[(int)(i)][(int)(j + 1LL)] > max_val) {
                max_val = m[(int)(i)][(int)(j + 1LL)];
            }
            if (m[(int)(i + 1LL)][(int)(j)] > max_val) {
                max_val = m[(int)(i + 1LL)][(int)(j)];
            }
            if (m[(int)(i + 1LL)][(int)(j + 1LL)] > max_val) {
                max_val = m[(int)(i + 1LL)][(int)(j + 1LL)];
            }
            new_row = list_append_double(new_row, &new_row_len, max_val);
            j = j + 2LL;
        }
        out = list_append_doubleptr(out, &out_len, new_row);
        out_lens = list_append_szt(out_lens, &out_lens_len, new_row_len);
        i = i + 2LL;
    }
    return max_pool2x2_lens = out_lens, max_pool2x2_len = out_len, out;
}

double * flatten(double * * m, size_t m_len, size_t* m_lens, size_t m_lens_len) {
    double *res = NULL;
    size_t res_len = 0;
    for (size_t __i = 0; __i < m_len; __i++) {
        double *row = m[__i];
        size_t row_len = m_lens[__i];
        for (size_t __i = 0; __i < row_len; __i++) {
            double v = row[__i];
            res = list_append_double(res, &res_len, v);
        }
    }
    return flatten_len = res_len, res;
}

double dense(double * inputs, size_t inputs_len, double * weights, size_t weights_len, double bias) {
    double s = bias;
    long long i = 0LL;
    while (i < inputs_len) {
        s = s + (inputs[(int)(i)] * weights[(int)(i)]);
        i = i + 1LL;
    }
    return s;
}

double exp_approx(double x) {
    double sum = 1.0;
    double term = 1.0;
    long long i = 1LL;
    while (i <= 10LL) {
        term = (term * x) / i;
        sum = sum + term;
        i = i + 1LL;
    }
    return sum;
}

double sigmoid(double x) {
    return 1.0 / (1.0 + exp_approx(-(x)));
}

int main(void) {
    {
        long long __start = _now();
        conv = conv2d(image, image_len, image_lens, image_len, kernel, kernel_len, kernel_lens, kernel_len);
        conv_len = conv2d_len;
        conv_lens = conv2d_lens;
        activated = relu_matrix(conv, conv_len, conv_lens, conv_len);
        activated_len = relu_matrix_len;
        activated_lens = relu_matrix_lens;
        pooled = max_pool2x2(activated, activated_len, activated_lens, activated_len);
        pooled_len = max_pool2x2_len;
        pooled_lens = max_pool2x2_lens;
        flat = flatten(pooled, pooled_len, pooled_lens, pooled_len);
        flat_len = flatten_len;
        output = dense(flat, flat_len, weights, weights_len, bias);
        probability = sigmoid(output);
        if (probability >= 0.5) {
            puts("Abnormality detected");
        } else {
            puts("Normal");
        }
        puts("Probability:");
        printf("%g\n", probability);
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
