// Generated by Mochi 0.10.32 on 2025-08-08 11:16 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%g", v);
    return strdup(buf);
}

static long long* list_append_int(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_intptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static void panic(const char *msg) {
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

typedef struct MosaicResult MosaicResult;

struct MosaicResult {
    long long **img;
    size_t img_len;
    size_t *img_lens;
    size_t img_lens_len;
    double **annos;
    size_t annos_len;
    size_t *annos_lens;
    size_t annos_lens_len;
    const char* path;
};

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_long_longptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

MosaicResult update_image_and_anno(const char* * all_img_list, size_t all_img_list_len, double * * * all_annos, size_t all_annos_len, size_t* all_annos_lens, size_t all_annos_lens_len, long long * idxs, size_t idxs_len, long long * output_size, size_t output_size_len, double * scale_range, size_t scale_range_len, double filter_scale);
const char* user_main();
int main(void);

MosaicResult update_image_and_anno(const char* * all_img_list, size_t all_img_list_len, double * * * all_annos, size_t all_annos_len, size_t* all_annos_lens, size_t all_annos_lens_len, long long * idxs, size_t idxs_len, long long * output_size, size_t output_size_len, double * scale_range, size_t scale_range_len, double filter_scale) {
    long long height = output_size[(int)(0LL)];
    long long width = output_size[(int)(1LL)];
    long long **output_img = NULL;
    size_t output_img_len = 0;
    size_t *output_img_lens = NULL;
    size_t output_img_lens_len = 0;
    long long r = 0LL;
    while (r < height) {
        long long *row = NULL;
        size_t row_len = 0;
        long long c = 0LL;
        while (c < width) {
            row = list_append_long_long(row, &row_len, 0LL);
            c = c + 1LL;
        }
        output_img = list_append_long_longptr(output_img, &output_img_len, row);
        output_img_lens = list_append_szt(output_img_lens, &output_img_lens_len, row_len);
        r = r + 1LL;
    }
    double scale_x = (scale_range[(int)(0LL)] + scale_range[(int)(1LL)]) / 2.0;
    double scale_y = (scale_range[(int)(0LL)] + scale_range[(int)(1LL)]) / 2.0;
    long long divid_point_x = scale_x * (double)(width);
    long long divid_point_y = scale_y * (double)(height);
    double **new_anno = NULL;
    size_t new_anno_len = 0;
    size_t *new_anno_lens = NULL;
    size_t new_anno_lens_len = 0;
    const char* *path_list = NULL;
    size_t path_list_len = 0;
    long long i = 0LL;
    while (i < idxs_len) {
        long long index = idxs[(int)(i)];
        const char* path = all_img_list[(int)(index)];
        path_list = list_append_str(path_list, &path_list_len, path);
        double **img_annos = all_annos[(int)(index)];
        size_t img_annos_len = 0;
        if (i == 0LL) {
            long long y0 = 0LL;
            while (y0 < divid_point_y) {
                long long x0 = 0LL;
                while (x0 < divid_point_x) {
                    output_img[(int)(y0)][(int)(x0)] = i + 1LL;
                    x0 = x0 + 1LL;
                }
                y0 = y0 + 1LL;
            }
            long long j0 = 0LL;
            while (j0 < img_annos_len) {
                double *bbox = img_annos[(int)(j0)];
                size_t bbox_len = 0;
                double xmin = bbox[(int)(1LL)] * scale_x;
                double ymin = bbox[(int)(2LL)] * scale_y;
                double xmax = bbox[(int)(3LL)] * scale_x;
                double ymax = bbox[(int)(4LL)] * scale_y;
                new_anno = list_append_doubleptr(new_anno, &new_anno_len, ({double *tmp = malloc(5 * sizeof(double)); tmp[0] = bbox[(int)(0LL)]; tmp[1] = xmin; tmp[2] = ymin; tmp[3] = xmax; tmp[4] = ymax; tmp;}));
                new_anno_lens = list_append_szt(new_anno_lens, &new_anno_lens_len, 5);
                j0 = j0 + 1LL;
            }
        } else {
            if (i == 1LL) {
                long long y1 = 0LL;
                while (y1 < divid_point_y) {
                    long long x1 = divid_point_x;
                    while (x1 < width) {
                        output_img[(int)(y1)][(int)(x1)] = i + 1LL;
                        x1 = x1 + 1LL;
                    }
                    y1 = y1 + 1LL;
                }
                long long j1 = 0LL;
                while (j1 < img_annos_len) {
                    double *bbox1 = img_annos[(int)(j1)];
                    size_t bbox1_len = 0;
                    double xmin1 = scale_x + (bbox1[(int)(1LL)] * (1.0 - scale_x));
                    double ymin1 = bbox1[(int)(2LL)] * scale_y;
                    double xmax1 = scale_x + (bbox1[(int)(3LL)] * (1.0 - scale_x));
                    double ymax1 = bbox1[(int)(4LL)] * scale_y;
                    new_anno = list_append_doubleptr(new_anno, &new_anno_len, ({double *tmp = malloc(5 * sizeof(double)); tmp[0] = bbox1[(int)(0LL)]; tmp[1] = xmin1; tmp[2] = ymin1; tmp[3] = xmax1; tmp[4] = ymax1; tmp;}));
                    new_anno_lens = list_append_szt(new_anno_lens, &new_anno_lens_len, 5);
                    j1 = j1 + 1LL;
                }
            } else {
                if (i == 2LL) {
                    long long y2 = divid_point_y;
                    while (y2 < height) {
                        long long x2 = 0LL;
                        while (x2 < divid_point_x) {
                            output_img[(int)(y2)][(int)(x2)] = i + 1LL;
                            x2 = x2 + 1LL;
                        }
                        y2 = y2 + 1LL;
                    }
                    long long j2 = 0LL;
                    while (j2 < img_annos_len) {
                        double *bbox2 = img_annos[(int)(j2)];
                        size_t bbox2_len = 0;
                        double xmin2 = bbox2[(int)(1LL)] * scale_x;
                        double ymin2 = scale_y + (bbox2[(int)(2LL)] * (1.0 - scale_y));
                        double xmax2 = bbox2[(int)(3LL)] * scale_x;
                        double ymax2 = scale_y + (bbox2[(int)(4LL)] * (1.0 - scale_y));
                        new_anno = list_append_doubleptr(new_anno, &new_anno_len, ({double *tmp = malloc(5 * sizeof(double)); tmp[0] = bbox2[(int)(0LL)]; tmp[1] = xmin2; tmp[2] = ymin2; tmp[3] = xmax2; tmp[4] = ymax2; tmp;}));
                        new_anno_lens = list_append_szt(new_anno_lens, &new_anno_lens_len, 5);
                        j2 = j2 + 1LL;
                    }
                } else {
                    long long y3 = divid_point_y;
                    while (y3 < height) {
                        long long x3 = divid_point_x;
                        while (x3 < width) {
                            output_img[(int)(y3)][(int)(x3)] = i + 1LL;
                            x3 = x3 + 1LL;
                        }
                        y3 = y3 + 1LL;
                    }
                    long long j3 = 0LL;
                    while (j3 < img_annos_len) {
                        double *bbox3 = img_annos[(int)(j3)];
                        size_t bbox3_len = 0;
                        double xmin3 = scale_x + (bbox3[(int)(1LL)] * (1.0 - scale_x));
                        double ymin3 = scale_y + (bbox3[(int)(2LL)] * (1.0 - scale_y));
                        double xmax3 = scale_x + (bbox3[(int)(3LL)] * (1.0 - scale_x));
                        double ymax3 = scale_y + (bbox3[(int)(4LL)] * (1.0 - scale_y));
                        new_anno = list_append_doubleptr(new_anno, &new_anno_len, ({double *tmp = malloc(5 * sizeof(double)); tmp[0] = bbox3[(int)(0LL)]; tmp[1] = xmin3; tmp[2] = ymin3; tmp[3] = xmax3; tmp[4] = ymax3; tmp;}));
                        new_anno_lens = list_append_szt(new_anno_lens, &new_anno_lens_len, 5);
                        j3 = j3 + 1LL;
                    }
                }
            }
        }
        i = i + 1LL;
    }
    if (filter_scale > 0.0) {
        double **filtered = NULL;
        size_t filtered_len = 0;
        size_t *filtered_lens = NULL;
        size_t filtered_lens_len = 0;
        long long k = 0LL;
        while (k < new_anno_len) {
            double *anno = new_anno[(int)(k)];
            size_t anno_len = 0;
            double w = anno[(int)(3LL)] - anno[(int)(1LL)];
            double h = anno[(int)(4LL)] - anno[(int)(2LL)];
            if ((filter_scale < w) && (filter_scale < h)) {
                filtered = list_append_doubleptr(filtered, &filtered_len, anno);
                filtered_lens = list_append_szt(filtered_lens, &filtered_lens_len, anno_len);
            }
            k = k + 1LL;
        }
        new_anno = filtered;
        new_anno_len = filtered_len;
        new_anno_lens = filtered_lens;
        new_anno_lens_len = filtered_lens_len;
    }
    return (MosaicResult){.img = output_img, .img_len = output_img_len, .img_lens = output_img_lens, .img_lens_len = output_img_len, .annos = new_anno, .annos_len = new_anno_len, .annos_lens = new_anno_lens, .annos_lens_len = new_anno_len, .path = path_list[(int)(0LL)]};
}

const char* user_main() {
    const char* *all_img_list = NULL;
    size_t all_img_list_len = 0;
    all_img_list = list_append_str(all_img_list, &all_img_list_len, "img0.jpg");
    all_img_list = list_append_str(all_img_list, &all_img_list_len, "img1.jpg");
    all_img_list = list_append_str(all_img_list, &all_img_list_len, "img2.jpg");
    all_img_list = list_append_str(all_img_list, &all_img_list_len, "img3.jpg");
    double all_annos_0_0[5] = {0.0, 0.1, 0.1, 0.4, 0.4};
    double *all_annos_0_init[1] = {all_annos_0_0};
    double **all_annos_0 = all_annos_0_init;
    double all_annos_1_0[5] = {1.0, 0.2, 0.3, 0.5, 0.7};
    double *all_annos_1_init[1] = {all_annos_1_0};
    double **all_annos_1 = all_annos_1_init;
    double all_annos_2_0[5] = {2.0, 0.6, 0.2, 0.9, 0.5};
    double *all_annos_2_init[1] = {all_annos_2_0};
    double **all_annos_2 = all_annos_2_init;
    double all_annos_3_0[5] = {3.0, 0.5, 0.5, 0.8, 0.8};
    double *all_annos_3_init[1] = {all_annos_3_0};
    double **all_annos_3 = all_annos_3_init;
    double **all_annos_init[4] = {all_annos_0, all_annos_1, all_annos_2, all_annos_3};
    double ***all_annos = all_annos_init;
    size_t all_annos_len = 4;
    size_t all_annos_lens_init[4] = {1, 1, 1, 1};
    size_t *all_annos_lens = all_annos_lens_init;
    size_t all_annos_lens_len = 4;
    long long *idxs = NULL;
    size_t idxs_len = 0;
    idxs = list_append_int(idxs, &idxs_len, 0LL);
    idxs = list_append_int(idxs, &idxs_len, 1LL);
    idxs = list_append_int(idxs, &idxs_len, 2LL);
    idxs = list_append_int(idxs, &idxs_len, 3LL);
    long long *output_size = NULL;
    size_t output_size_len = 0;
    output_size = list_append_int(output_size, &output_size_len, 100LL);
    output_size = list_append_int(output_size, &output_size_len, 100LL);
    double *scale_range = NULL;
    size_t scale_range_len = 0;
    scale_range = list_append_double(scale_range, &scale_range_len, 0.4);
    scale_range = list_append_double(scale_range, &scale_range_len, 0.6);
    double filter_scale = 0.05;
    MosaicResult res = update_image_and_anno(all_img_list, all_img_list_len, all_annos, all_annos_len, all_annos_lens, all_annos_len, idxs, idxs_len, output_size, output_size_len, scale_range, scale_range_len, filter_scale);
    double **new_annos = res.annos;
    size_t new_annos_len = res.annos_len;
    size_t *new_annos_lens = res.annos_lens;
    size_t new_annos_lens_len = res.annos_len;
    const char* path = res.path;
    puts(str_concat("Base image: ", path));
    puts(str_concat("Mosaic annotation count: ", str_int(new_annos_len)));
    long long i = 0LL;
    while (i < new_annos_len) {
        double *a = new_annos[(int)(i)];
        size_t a_len = 0;
        puts(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_float(a[(int)(0LL)]), " "), str_float(a[(int)(1LL)])), " "), str_float(a[(int)(2LL)])), " "), str_float(a[(int)(3LL)])), " "), str_float(a[(int)(4LL)])));
        i = i + 1LL;
    }
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
