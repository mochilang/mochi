;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define WIDTH 10)
(define HEIGHT 10)
(define PREY_INITIAL_COUNT 20)
(define PREY_REPRODUCTION_TIME 5)
(define PREDATOR_INITIAL_COUNT 5)
(define PREDATOR_REPRODUCTION_TIME 20)
(define PREDATOR_INITIAL_ENERGY 15)
(define PREDATOR_FOOD_VALUE 5)
(define TYPE_PREY 0)
(define TYPE_PREDATOR 1)
(define seed 123456789)
(define (rand)
  (let/ec _return (begin
(set! seed (modulo (let ([__l (* seed 1103515245)] [__r 12345]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2147483648))
(_return seed)
))
)
(define (rand_range max)
  (let/ec _return (begin
(_return (modulo (rand) max))
))
)
(define (shuffle list_int)
  (let/ec _return (begin
(define i (- (cond [(string? list_int) (string-length list_int)] [(hash? list_int) (hash-count list_int)] [else (length list_int)]) 1))
(let/ec _break (let loop ()
  (if (> i 0) (let/ec _cont
    (define j (rand_range (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define tmp (if list_int (if (hash? list_int) (hash-ref list_int i #f) (list-ref list_int (int i))) #f))
    (set! list_int (list-set list_int (int i) (if list_int (if (hash? list_int) (hash-ref list_int j #f) (list-ref list_int (int j))) #f)))
    (set! list_int (list-set list_int (int j) tmp))
    (set! i (- i 1))
    (loop)) (void))))
(_return list_int)
))
)
(define (create_board)
  (let/ec _return (begin
(define board (list))
(define r 0)
(let/ec _break (let loop ()
  (if (< r HEIGHT) (let/ec _cont
    (define row (list))
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c WIDTH) (let/ec _cont
    (set! row (append row (list 0)))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! board (append board (list row)))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return board)
))
)
(define (create_prey r c)
  (let/ec _return (begin
(_return (list TYPE_PREY r c PREY_REPRODUCTION_TIME 0 1))
))
)
(define (create_predator r c)
  (let/ec _return (begin
(_return (list TYPE_PREDATOR r c PREDATOR_REPRODUCTION_TIME PREDATOR_INITIAL_ENERGY 1))
))
)
(define board (create_board))
(define entities (list))
(define (empty_cell r c)
  (let/ec _return (begin
(_return (equal? (if (if board (if (hash? board) (hash-ref board r #f) (list-ref board (int r))) #f) (if (hash? (if board (if (hash? board) (hash-ref board r #f) (list-ref board (int r))) #f)) (hash-ref (if board (if (hash? board) (hash-ref board r #f) (list-ref board (int r))) #f) c #f) (list-ref (if board (if (hash? board) (hash-ref board r #f) (list-ref board (int r))) #f) (int c))) #f) 0))
))
)
(define (add_entity typ)
  (let/ec _return (begin
(let/ec _break (let loop ()
  (if #t (let/ec _cont
    (define r (rand_range HEIGHT))
    (define c (rand_range WIDTH))
    (if (empty_cell r c) (let ()
(if (equal? typ TYPE_PREY) (let ()
(set! board (list-set board r (list-set (list-ref board r) c 1)))
(set! entities (append entities (list (create_prey r c))))
) (let ()
(set! board (list-set board r (list-set (list-ref board r) c 2)))
(set! entities (append entities (list (create_predator r c))))
))
(_return void)
) (void))
    (loop)) (void))))
))
)
(define (setup)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i PREY_INITIAL_COUNT) (let/ec _cont
    (add_entity TYPE_PREY)
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i PREDATOR_INITIAL_COUNT) (let/ec _cont
    (add_entity TYPE_PREDATOR)
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define dr (list (- 1) 0 1 0))
(define dc (list 0 1 0 (- 1)))
(define (inside r c)
  (let/ec _return (begin
(_return (and (and (and (>= r 0) (< r HEIGHT)) (>= c 0)) (< c WIDTH)))
))
)
(define (find_prey r c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? entities) (string-length entities)] [(hash? entities) (hash-count entities)] [else (length entities)])) (let/ec _cont
    (define e (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f))
    (if (and (and (and (equal? (if e (if (hash? e) (hash-ref e 5 #f) (list-ref e (int 5))) #f) 1) (equal? (if e (if (hash? e) (hash-ref e 0 #f) (list-ref e (int 0))) #f) TYPE_PREY)) (equal? (if e (if (hash? e) (hash-ref e 1 #f) (list-ref e (int 1))) #f) r)) (equal? (if e (if (hash? e) (hash-ref e 2 #f) (list-ref e (int 2))) #f) c)) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (step_world)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? entities) (string-length entities)] [(hash? entities) (hash-count entities)] [else (length entities)])) (let/ec _cont
    (define e (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f))
    (if (equal? (if e (if (hash? e) (hash-ref e 5 #f) (list-ref e (int 5))) #f) 0) (let ()
(set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(_cont)
) (void))
    (define typ (if e (if (hash? e) (hash-ref e 0 #f) (list-ref e (int 0))) #f))
    (define row (if e (if (hash? e) (hash-ref e 1 #f) (list-ref e (int 1))) #f))
    (define col (if e (if (hash? e) (hash-ref e 2 #f) (list-ref e (int 2))) #f))
    (define repro (if e (if (hash? e) (hash-ref e 3 #f) (list-ref e (int 3))) #f))
    (define energy (if e (if (hash? e) (hash-ref e 4 #f) (list-ref e (int 4))) #f))
    (define dirs (list 0 1 2 3))
    (set! dirs (shuffle dirs))
    (define moved #f)
    (define old_r row)
    (define old_c col)
    (if (equal? typ TYPE_PREDATOR) (let ()
(define j 0)
(define ate #f)
(let/ec _break (let loop ()
  (if (< j 4) (let/ec _cont
    (define d (if dirs (if (hash? dirs) (hash-ref dirs j #f) (list-ref dirs (int j))) #f))
    (define nr (let ([__l row] [__r (if dr (if (hash? dr) (hash-ref dr d #f) (list-ref dr (int d))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define nc (let ([__l col] [__r (if dc (if (hash? dc) (hash-ref dc d #f) (list-ref dc (int d))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (and (inside nr nc) (equal? (if (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) (if (hash? (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f)) (hash-ref (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) nc #f) (list-ref (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) (int nc))) #f) 1)) (let ()
(define prey_index (find_prey nr nc))
(if (>= prey_index 0) (let ()
(set! entities (list-set entities prey_index (list-set (list-ref entities prey_index) 5 0)))
) (void))
(set! board (list-set board nr (list-set (list-ref board nr) nc 2)))
(set! board (list-set board row (list-set (list-ref board row) col 0)))
(set! e (list-set e (int 1) nr))
(set! e (list-set e (int 2) nc))
(set! e (list-set e (int 4) (- (let ([__l energy] [__r PREDATOR_FOOD_VALUE]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 1)))
(set! moved #t)
(set! ate #t)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(if (not ate) (let ()
(set! j 0)
(let/ec _break (let loop ()
  (if (< j 4) (let/ec _cont
    (define d (if dirs (if (hash? dirs) (hash-ref dirs j #f) (list-ref dirs (int j))) #f))
    (define nr (let ([__l row] [__r (if dr (if (hash? dr) (hash-ref dr d #f) (list-ref dr (int d))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define nc (let ([__l col] [__r (if dc (if (hash? dc) (hash-ref dc d #f) (list-ref dc (int d))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (and (inside nr nc) (equal? (if (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) (if (hash? (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f)) (hash-ref (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) nc #f) (list-ref (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) (int nc))) #f) 0)) (let ()
(set! board (list-set board nr (list-set (list-ref board nr) nc 2)))
(set! board (list-set board row (list-set (list-ref board row) col 0)))
(set! e (list-set e (int 1) nr))
(set! e (list-set e (int 2) nc))
(set! moved #t)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! e (list-set e (int 4) (- energy 1)))
) (void))
(if (<= (if e (if (hash? e) (hash-ref e 4 #f) (list-ref e (int 4))) #f) 0) (let ()
(set! e (list-set e (int 5) 0))
(set! board (list-set board (if e (if (hash? e) (hash-ref e 1 #f) (list-ref e (int 1))) #f) (list-set (list-ref board (if e (if (hash? e) (hash-ref e 1 #f) (list-ref e (int 1))) #f)) (if e (if (hash? e) (hash-ref e 2 #f) (list-ref e (int 2))) #f) 0)))
) (void))
) (let ()
(define j 0)
(let/ec _break (let loop ()
  (if (< j 4) (let/ec _cont
    (define d (if dirs (if (hash? dirs) (hash-ref dirs j #f) (list-ref dirs (int j))) #f))
    (define nr (let ([__l row] [__r (if dr (if (hash? dr) (hash-ref dr d #f) (list-ref dr (int d))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define nc (let ([__l col] [__r (if dc (if (hash? dc) (hash-ref dc d #f) (list-ref dc (int d))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (and (inside nr nc) (equal? (if (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) (if (hash? (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f)) (hash-ref (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) nc #f) (list-ref (if board (if (hash? board) (hash-ref board nr #f) (list-ref board (int nr))) #f) (int nc))) #f) 0)) (let ()
(set! board (list-set board nr (list-set (list-ref board nr) nc 1)))
(set! board (list-set board row (list-set (list-ref board row) col 0)))
(set! e (list-set e (int 1) nr))
(set! e (list-set e (int 2) nc))
(set! moved #t)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
    (if (equal? (if e (if (hash? e) (hash-ref e 5 #f) (list-ref e (int 5))) #f) 1) (let ()
(if (and moved (<= repro 0)) (let ()
(if (equal? typ TYPE_PREY) (let ()
(set! board (list-set board old_r (list-set (list-ref board old_r) old_c 1)))
(set! entities (append entities (list (create_prey old_r old_c))))
(set! e (list-set e (int 3) PREY_REPRODUCTION_TIME))
) (let ()
(set! board (list-set board old_r (list-set (list-ref board old_r) old_c 2)))
(set! entities (append entities (list (create_predator old_r old_c))))
(set! e (list-set e (int 3) PREDATOR_REPRODUCTION_TIME))
))
) (let ()
(set! e (list-set e (int 3) (- repro 1)))
))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define alive (list))
(define k 0)
(let/ec _break (let loop ()
  (if (< k (cond [(string? entities) (string-length entities)] [(hash? entities) (hash-count entities)] [else (length entities)])) (let/ec _cont
    (define e2 (if entities (if (hash? entities) (hash-ref entities k #f) (list-ref entities (int k))) #f))
    (if (equal? (if e2 (if (hash? e2) (hash-ref e2 5 #f) (list-ref e2 (int 5))) #f) 1) (let ()
(set! alive (append alive (list e2)))
) (void))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! entities alive)
))
)
(define (count_entities typ)
  (let/ec _return (begin
(define cnt 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? entities) (string-length entities)] [(hash? entities) (hash-count entities)] [else (length entities)])) (let/ec _cont
    (if (and (equal? (if (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f) (if (hash? (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f)) (hash-ref (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f) 0 #f) (list-ref (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f) (int 0))) #f) typ) (equal? (if (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f) (if (hash? (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f)) (hash-ref (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f) 5 #f) (list-ref (if entities (if (hash? entities) (hash-ref entities i #f) (list-ref entities (int i))) #f) (int 5))) #f) 1)) (let ()
(set! cnt (let ([__l cnt] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return cnt)
))
)
(define t 0)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(setup)
(let/ec _break (let loop ()
  (if (< t 10) (let/ec _cont
    (step_world)
    (set! t (let ([__l t] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln (string-append "Prey: " (format "~a" (count_entities TYPE_PREY))))
(displayln (string-append "Predators: " (format "~a" (count_entities TYPE_PREDATOR))))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
