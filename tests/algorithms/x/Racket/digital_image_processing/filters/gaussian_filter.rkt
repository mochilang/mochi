;; Generated by Mochi 0.10.60 on 2025-08-07 14:57 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define PI 3.141592653589793)
(define (expApprox x)
  (let/ec _return (begin
(define sum 1.0)
(define term 1.0)
(define n 1)
(let/ec _break (let loop ()
  (if (< n 10) (let/ec _cont
    (set! term (/ (* term x) (exact->inexact n)))
    (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! n (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sum)
))
)
(define (gen_gaussian_kernel k_size sigma)
  (let/ec _return (begin
(define center (floor (/ k_size 2)))
(define kernel (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i k_size) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j k_size) (let/ec _cont
    (define x (exact->inexact (- i center)))
    (define y (exact->inexact (- j center)))
    (define exponent (- (/ (let ([__l (* x x)] [__r (* y y)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (* (* 2.0 sigma) sigma))))
    (define value (* (/ 1.0 (* (* 2.0 PI) sigma)) (expApprox exponent)))
    (set! row (append row (list value)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! kernel (append kernel (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return kernel)
))
)
(define (gaussian_filter image k_size sigma)
  (let/ec _return (begin
(define height (cond [(string? image) (string-length image)] [(hash? image) (hash-count image)] [else (length image)]))
(define width (cond [(string? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (string-length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [(hash? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (hash-count (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [else (length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))]))
(define dst_height (let ([__l (- height k_size)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define dst_width (let ([__l (- width k_size)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define kernel (gen_gaussian_kernel k_size sigma))
(define dst (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i dst_height) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j dst_width) (let/ec _cont
    (define sum 0.0)
    (define ki 0)
    (let/ec _break (let loop ()
  (if (< ki k_size) (let/ec _cont
    (define kj 0)
    (let/ec _break (let loop ()
  (if (< kj k_size) (let/ec _cont
    (set! sum (let ([__l sum] [__r (* (exact->inexact (if (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l j] [__r kj]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l j] [__r kj]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (if (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f) (if (hash? (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f)) (hash-ref (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f) kj #f) (list-ref (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f) (int kj))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! kj (let ([__l kj] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! ki (let ([__l ki] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list (int sum))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! dst (append dst (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return dst)
))
)
(define (print_image image)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? image) (string-length image)] [(hash? image) (hash-count image)] [else (length image)])) (let/ec _cont
    (displayln (if image (if (hash? image) (hash-ref image i #f) (list-ref image (int i))) #f))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define img (list (list 52 55 61 59 79) (list 62 59 55 104 94) (list 63 65 66 113 144) (list 68 70 70 126 154) (list 70 72 69 128 155)))
(define gaussian3 (gaussian_filter img 3 1.0))
(define gaussian5 (gaussian_filter img 5 0.8))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(print_image gaussian3)
(print_image gaussian5)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
