;; Generated by Mochi 0.10.60 on 2025-08-07 14:57 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define PI 3.141592653589793)
(define (absf x)
  (let/ec _return (begin
(if (< x 0.0) (let ()
(_return (- x))
) (void))
(_return x)
))
)
(define (sqrtApprox x)
  (let/ec _return (begin
(if (<= x 0.0) (let ()
(_return 0.0)
) (void))
(define guess (/ x 2.0))
(define i 0)
(let/ec _break (let loop ()
  (if (< i 20) (let/ec _cont
    (set! guess (/ (let ([__l guess] [__r (/ x guess)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return guess)
))
)
(define (atanApprox x)
  (let/ec _return (begin
(if (> x 1.0) (let ()
(_return (- (/ PI 2.0) (/ x (let ([__l (* x x)] [__r 0.28]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(if (< x (- 1.0)) (let ()
(_return (- (/ (- PI) 2.0) (/ x (let ([__l (* x x)] [__r 0.28]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(_return (/ x (let ([__l 1.0] [__r (* (* 0.28 x) x)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (atan2Approx y x)
  (let/ec _return (begin
(if (equal? x 0.0) (let ()
(if (> y 0.0) (let ()
(_return (/ PI 2.0))
) (void))
(if (< y 0.0) (let ()
(_return (/ (- PI) 2.0))
) (void))
(_return 0.0)
) (void))
(define a (atanApprox (/ y x)))
(if (> x 0.0) (let ()
(_return a)
) (void))
(if (>= y 0.0) (let ()
(_return (let ([__l a] [__r PI]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return (- a PI))
))
)
(define (zeros h w)
  (let/ec _return (begin
(define m (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let/ec _cont
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let/ec _cont
    (set! row (append row (list 0.0)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! m (append m (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return m)
))
)
(define (pad_edge img pad)
  (let/ec _return (begin
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (string-length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [(hash? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (hash-count (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [else (length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))]))
(define out (zeros (let ([__l h] [__r (* pad 2)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l w] [__r (* pad 2)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(define y 0)
(let/ec _break (let loop ()
  (if (< y (let ([__l h] [__r (* pad 2)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x (let ([__l w] [__r (* pad 2)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (define sy (- y pad))
    (if (< sy 0) (let ()
(set! sy 0)
) (void))
    (if (>= sy h) (let ()
(set! sy (- h 1))
) (void))
    (define sx (- x pad))
    (if (< sx 0) (let ()
(set! sx 0)
) (void))
    (if (>= sx w) (let ()
(set! sx (- w 1))
) (void))
    (set! out (list-set out y (list-set (list-ref out y) x (if (if img (if (hash? img) (hash-ref img sy #f) (list-ref img (int sy))) #f) (if (hash? (if img (if (hash? img) (hash-ref img sy #f) (list-ref img (int sy))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img sy #f) (list-ref img (int sy))) #f) sx #f) (list-ref (if img (if (hash? img) (hash-ref img sy #f) (list-ref img (int sy))) #f) (int sx))) #f))))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (img_convolve img kernel)
  (let/ec _return (begin
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (string-length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [(hash? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (hash-count (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [else (length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))]))
(define k (cond [(string? kernel) (string-length kernel)] [(hash? kernel) (hash-count kernel)] [else (length kernel)]))
(define pad (floor (/ k 2)))
(define padded (pad_edge img pad))
(define out (zeros h w))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let/ec _cont
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let/ec _cont
    (define sum 0.0)
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i k) (let/ec _cont
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j k) (let/ec _cont
    (set! sum (let ([__l sum] [__r (* (if (if padded (if (hash? padded) (hash-ref padded (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref padded (int (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if padded (if (hash? padded) (hash-ref padded (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref padded (int (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if padded (if (hash? padded) (hash-ref padded (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref padded (int (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l x] [__r j]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if padded (if (hash? padded) (hash-ref padded (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref padded (int (let ([__l y] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l x] [__r j]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (exact->inexact (if (if kernel (if (hash? kernel) (hash-ref kernel i #f) (list-ref kernel (int i))) #f) (if (hash? (if kernel (if (hash? kernel) (hash-ref kernel i #f) (list-ref kernel (int i))) #f)) (hash-ref (if kernel (if (hash? kernel) (hash-ref kernel i #f) (list-ref kernel (int i))) #f) j #f) (list-ref (if kernel (if (hash? kernel) (hash-ref kernel i #f) (list-ref kernel (int i))) #f) (int j))) #f)))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (list-set out y (list-set (list-ref out y) x sum)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (abs_matrix mat)
  (let/ec _return (begin
(define h (cond [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)]))
(define w (cond [(string? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))]))
(define out (zeros h w))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let/ec _cont
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let/ec _cont
    (define v (if (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) x #f) (list-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (int x))) #f))
    (if (< v 0.0) (let ()
(set! out (list-set out y (list-set (list-ref out y) x (- v))))
) (let ()
(set! out (list-set out y (list-set (list-ref out y) x v)))
))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (max_matrix mat)
  (let/ec _return (begin
(define max_val (if (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f) 0 #f) (list-ref (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f) (int 0))) #f))
(define y 0)
(let/ec _break (let loop ()
  (if (< y (cond [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)])) (let/ec _cont
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x (cond [(string? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))])) (let/ec _cont
    (if (> (if (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) x #f) (list-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (int x))) #f) max_val) (let ()
(set! max_val (if (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) x #f) (list-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (int x))) #f))
) (void))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return max_val)
))
)
(define (scale_matrix mat factor)
  (let/ec _return (begin
(define h (cond [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)]))
(define w (cond [(string? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat 0 #f) (list-ref mat (int 0))) #f))]))
(define out (zeros h w))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let/ec _cont
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let/ec _cont
    (set! out (list-set out y (list-set (list-ref out y) x (* (if (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) x #f) (list-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (int x))) #f) factor))))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (sobel_filter image)
  (let/ec _return (begin
(define h (cond [(string? image) (string-length image)] [(hash? image) (hash-count image)] [else (length image)]))
(define w (cond [(string? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (string-length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [(hash? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (hash-count (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [else (length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))]))
(define img (list))
(define y0 0)
(let/ec _break (let loop ()
  (if (< y0 h) (let/ec _cont
    (define row (list))
    (define x0 0)
    (let/ec _break (let loop ()
  (if (< x0 w) (let/ec _cont
    (set! row (append row (list (exact->inexact (if (if image (if (hash? image) (hash-ref image y0 #f) (list-ref image (int y0))) #f) (if (hash? (if image (if (hash? image) (hash-ref image y0 #f) (list-ref image (int y0))) #f)) (hash-ref (if image (if (hash? image) (hash-ref image y0 #f) (list-ref image (int y0))) #f) x0 #f) (list-ref (if image (if (hash? image) (hash-ref image y0 #f) (list-ref image (int y0))) #f) (int x0))) #f)))))
    (set! x0 (let ([__l x0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! img (append img (list row)))
    (set! y0 (let ([__l y0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define kernel_x (list (list (- 1) 0 1) (list (- 2) 0 2) (list (- 1) 0 1)))
(define kernel_y (list (list 1 2 1) (list 0 0 0) (list (- 1) (- 2) (- 1))))
(define dst_x (abs_matrix (img_convolve img kernel_x)))
(define dst_y (abs_matrix (img_convolve img kernel_y)))
(define max_x (max_matrix dst_x))
(define max_y (max_matrix dst_y))
(set! dst_x (scale_matrix dst_x (/ 255.0 max_x)))
(set! dst_y (scale_matrix dst_y (/ 255.0 max_y)))
(define mag (zeros h w))
(define theta (zeros h w))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let/ec _cont
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let/ec _cont
    (define gx (if (if dst_x (if (hash? dst_x) (hash-ref dst_x y #f) (list-ref dst_x (int y))) #f) (if (hash? (if dst_x (if (hash? dst_x) (hash-ref dst_x y #f) (list-ref dst_x (int y))) #f)) (hash-ref (if dst_x (if (hash? dst_x) (hash-ref dst_x y #f) (list-ref dst_x (int y))) #f) x #f) (list-ref (if dst_x (if (hash? dst_x) (hash-ref dst_x y #f) (list-ref dst_x (int y))) #f) (int x))) #f))
    (define gy (if (if dst_y (if (hash? dst_y) (hash-ref dst_y y #f) (list-ref dst_y (int y))) #f) (if (hash? (if dst_y (if (hash? dst_y) (hash-ref dst_y y #f) (list-ref dst_y (int y))) #f)) (hash-ref (if dst_y (if (hash? dst_y) (hash-ref dst_y y #f) (list-ref dst_y (int y))) #f) x #f) (list-ref (if dst_y (if (hash? dst_y) (hash-ref dst_y y #f) (list-ref dst_y (int y))) #f) (int x))) #f))
    (set! mag (list-set mag y (list-set (list-ref mag y) x (sqrtApprox (let ([__l (* gx gx)] [__r (* gy gy)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! theta (list-set theta y (list-set (list-ref theta y) x (atan2Approx gy gx))))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define max_m (max_matrix mag))
(set! mag (scale_matrix mag (/ 255.0 max_m)))
(_return (list mag theta))
))
)
(define (print_matrix_int mat)
  (let/ec _return (begin
(define y 0)
(let/ec _break (let loop ()
  (if (< y (cond [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)])) (let/ec _cont
    (define line "")
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x (cond [(string? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))])) (let/ec _cont
    (set! line (string-append line (format "~a" (int (if (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) x #f) (list-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (int x))) #f)))))
    (if (< x (- (cond [(string? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))]) 1)) (let ()
(set! line (string-append line " "))
) (void))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (print_matrix_float mat)
  (let/ec _return (begin
(define y 0)
(let/ec _break (let loop ()
  (if (< y (cond [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)])) (let/ec _cont
    (define line "")
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x (cond [(string? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))])) (let/ec _cont
    (set! line (string-append line (format "~a" (if (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) x #f) (list-ref (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f) (int x))) #f))))
    (if (< x (- (cond [(string? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat y #f) (list-ref mat (int y))) #f))]) 1)) (let ()
(set! line (string-append line " "))
) (void))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (main)
  (let/ec _return (begin
(define img (list (list 10 10 10 10 10) (list 10 50 50 50 10) (list 10 50 80 50 10) (list 10 50 50 50 10) (list 10 10 10 10 10)))
(define res (sobel_filter img))
(define mag (if res (if (hash? res) (hash-ref res 0 #f) (list-ref res (int 0))) #f))
(define theta (if res (if (hash? res) (hash-ref res 1 #f) (list-ref res (int 1))) #f))
(print_matrix_int mag)
(print_matrix_float theta)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
