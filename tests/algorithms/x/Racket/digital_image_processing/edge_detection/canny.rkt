;; Generated by Mochi 0.10.60 on 2025-08-07 14:57 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define PI 3.141592653589793)
(define (sqrtApprox x)
  (let/ec _return (begin
(define guess (/ x 2.0))
(define i 0)
(let/ec _break (let loop ()
  (if (< i 20) (let/ec _cont
    (set! guess (/ (let ([__l guess] [__r (/ x guess)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return guess)
))
)
(define (atanApprox x)
  (let/ec _return (begin
(if (> x 1.0) (let ()
(_return (- (/ PI 2.0) (/ x (let ([__l (* x x)] [__r 0.28]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(if (< x (- 1.0)) (let ()
(_return (- (/ (- PI) 2.0) (/ x (let ([__l (* x x)] [__r 0.28]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(_return (/ x (let ([__l 1.0] [__r (* (* 0.28 x) x)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (atan2Approx y x)
  (let/ec _return (begin
(if (> x 0.0) (let ()
(define r (atanApprox (/ y x)))
(_return r)
) (void))
(if (< x 0.0) (let ()
(if (>= y 0.0) (let ()
(_return (let ([__l (atanApprox (/ y x))] [__r PI]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return (- (atanApprox (/ y x)) PI))
) (void))
(if (> y 0.0) (let ()
(_return (/ PI 2.0))
) (void))
(if (< y 0.0) (let ()
(_return (/ (- PI) 2.0))
) (void))
(_return 0.0)
))
)
(define (deg rad)
  (let/ec _return (begin
(_return (/ (* rad 180.0) PI))
))
)
(define GAUSSIAN_KERNEL (list (list 0.0625 0.125 0.0625) (list 0.125 0.25 0.125) (list 0.0625 0.125 0.0625)))
(define SOBEL_GX (list (list (- 1.0) 0.0 1.0) (list (- 2.0) 0.0 2.0) (list (- 1.0) 0.0 1.0)))
(define SOBEL_GY (list (list 1.0 2.0 1.0) (list 0.0 0.0 0.0) (list (- 1.0) (- 2.0) (- 1.0))))
(define (zero_matrix h w)
  (let/ec _return (begin
(define out (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i h) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j w) (let/ec _cont
    (set! row (append row (list 0.0)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (convolve img kernel)
  (let/ec _return (begin
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (string-length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [(hash? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (hash-count (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [else (length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))]))
(define k (cond [(string? kernel) (string-length kernel)] [(hash? kernel) (hash-count kernel)] [else (length kernel)]))
(define pad (floor (/ k 2)))
(define out (zero_matrix h w))
(define y pad)
(let/ec _break (let loop ()
  (if (< y (- h pad)) (let/ec _cont
    (define x pad)
    (let/ec _break (let loop ()
  (if (< x (- w pad)) (let/ec _cont
    (define sum 0.0)
    (define ky 0)
    (let/ec _break (let loop ()
  (if (< ky k) (let/ec _cont
    (define kx 0)
    (let/ec _break (let loop ()
  (if (< kx k) (let/ec _cont
    (define pixel (if (if img (if (hash? img) (hash-ref img (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l (- x pad)] [__r kx]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if img (if (hash? img) (hash-ref img (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l (- y pad)] [__r ky]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l (- x pad)] [__r kx]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
    (define weight (if (if kernel (if (hash? kernel) (hash-ref kernel ky #f) (list-ref kernel (int ky))) #f) (if (hash? (if kernel (if (hash? kernel) (hash-ref kernel ky #f) (list-ref kernel (int ky))) #f)) (hash-ref (if kernel (if (hash? kernel) (hash-ref kernel ky #f) (list-ref kernel (int ky))) #f) kx #f) (list-ref (if kernel (if (hash? kernel) (hash-ref kernel ky #f) (list-ref kernel (int ky))) #f) (int kx))) #f))
    (set! sum (let ([__l sum] [__r (* pixel weight)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! kx (let ([__l kx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! ky (let ([__l ky] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (list-set out y (list-set (list-ref out y) x sum)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (gaussian_blur img)
  (let/ec _return (begin
(_return (convolve img GAUSSIAN_KERNEL))
))
)
(define (sobel_filter img)
  (let/ec _return (begin
(define gx (convolve img SOBEL_GX))
(define gy (convolve img SOBEL_GY))
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (string-length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [(hash? (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f)) (hash-count (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))] [else (length (if img (if (hash? img) (hash-ref img 0 #f) (list-ref img (int 0))) #f))]))
(define grad (zero_matrix h w))
(define dir (zero_matrix h w))
(define i 0)
(let/ec _break (let loop ()
  (if (< i h) (let/ec _cont
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j w) (let/ec _cont
    (define gxx (if (if gx (if (hash? gx) (hash-ref gx i #f) (list-ref gx (int i))) #f) (if (hash? (if gx (if (hash? gx) (hash-ref gx i #f) (list-ref gx (int i))) #f)) (hash-ref (if gx (if (hash? gx) (hash-ref gx i #f) (list-ref gx (int i))) #f) j #f) (list-ref (if gx (if (hash? gx) (hash-ref gx i #f) (list-ref gx (int i))) #f) (int j))) #f))
    (define gyy (if (if gy (if (hash? gy) (hash-ref gy i #f) (list-ref gy (int i))) #f) (if (hash? (if gy (if (hash? gy) (hash-ref gy i #f) (list-ref gy (int i))) #f)) (hash-ref (if gy (if (hash? gy) (hash-ref gy i #f) (list-ref gy (int i))) #f) j #f) (list-ref (if gy (if (hash? gy) (hash-ref gy i #f) (list-ref gy (int i))) #f) (int j))) #f))
    (set! grad (list-set grad i (list-set (list-ref grad i) j (sqrtApprox (let ([__l (* gxx gxx)] [__r (* gyy gyy)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! dir (list-set dir i (list-set (list-ref dir i) j (let ([__l (deg (atan2Approx gyy gxx))] [__r 180.0]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (hash "grad" grad "dir" dir))
))
)
(define (suppress_non_maximum h w direction grad)
  (let/ec _return (begin
(define dest (zero_matrix h w))
(define r 1)
(let/ec _break (let loop ()
  (if (< r (- h 1)) (let/ec _cont
    (define c 1)
    (let/ec _break (let loop ()
  (if (< c (- w 1)) (let/ec _cont
    (define angle (if (if direction (if (hash? direction) (hash-ref direction r #f) (list-ref direction (int r))) #f) (if (hash? (if direction (if (hash? direction) (hash-ref direction r #f) (list-ref direction (int r))) #f)) (hash-ref (if direction (if (hash? direction) (hash-ref direction r #f) (list-ref direction (int r))) #f) c #f) (list-ref (if direction (if (hash? direction) (hash-ref direction r #f) (list-ref direction (int r))) #f) (int c))) #f))
    (define q 0.0)
    (define p 0.0)
    (if (or (or (and (>= angle 0.0) (< angle 22.5)) (and (>= angle 157.5) (<= angle 180.0))) (>= angle 337.5)) (let ()
(set! q (if (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (int (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
(set! p (if (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (- c 1) #f) (list-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (int (- c 1)))) #f))
) (let ()
(if (or (and (>= angle 22.5) (< angle 67.5)) (and (>= angle 202.5) (< angle 247.5))) (let ()
(set! q (if (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (- c 1) #f) (list-ref (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (- c 1)))) #f))
(set! p (if (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (int (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
) (let ()
(if (or (and (>= angle 67.5) (< angle 112.5)) (and (>= angle 247.5) (< angle 292.5))) (let ()
(set! q (if (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) c #f) (list-ref (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int c))) #f))
(set! p (if (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) c #f) (list-ref (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (int c))) #f))
) (let ()
(set! q (if (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (- c 1) #f) (list-ref (if grad (if (hash? grad) (hash-ref grad (- r 1) #f) (list-ref grad (int (- r 1)))) #f) (int (- c 1)))) #f))
(set! p (if (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if grad (if (hash? grad) (hash-ref grad (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref grad (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
))
))
))
    (if (and (>= (if (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) c #f) (list-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (int c))) #f) q) (>= (if (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) c #f) (list-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (int c))) #f) p)) (let ()
(set! dest (list-set dest r (list-set (list-ref dest r) c (if (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (if (hash? (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f)) (hash-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) c #f) (list-ref (if grad (if (hash? grad) (hash-ref grad r #f) (list-ref grad (int r))) #f) (int c))) #f))))
) (void))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return dest)
))
)
(define (double_threshold h w img low high weak strong)
  (let/ec _return (begin
(define r 0)
(let/ec _break (let loop ()
  (if (< r h) (let/ec _cont
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c w) (let/ec _cont
    (define v (if (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (if (hash? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) c #f) (list-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (int c))) #f))
    (if (>= v high) (let ()
(set! img (list-set img r (list-set (list-ref img r) c strong)))
) (let ()
(if (< v low) (let ()
(set! img (list-set img r (list-set (list-ref img r) c 0.0)))
) (let ()
(set! img (list-set img r (list-set (list-ref img r) c weak)))
))
))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (track_edge h w img weak strong)
  (let/ec _return (begin
(define r 1)
(let/ec _break (let loop ()
  (if (< r (- h 1)) (let/ec _cont
    (define c 1)
    (let/ec _break (let loop ()
  (if (< c (- w 1)) (let/ec _cont
    (if (equal? (if (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (if (hash? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) c #f) (list-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (int c))) #f) weak) (let ()
(if (or (or (or (or (or (or (or (equal? (if (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) c #f) (list-ref (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int c))) #f) strong) (equal? (if (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) c #f) (list-ref (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (int c))) #f) strong)) (equal? (if (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (if (hash? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (int (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) strong)) (equal? (if (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (if (hash? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (- c 1) #f) (list-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (int (- c 1)))) #f) strong)) (equal? (if (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (- c 1) #f) (list-ref (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (int (- c 1)))) #f) strong)) (equal? (if (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if img (if (hash? img) (hash-ref img (- r 1) #f) (list-ref img (int (- r 1)))) #f) (int (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) strong)) (equal? (if (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (- c 1) #f) (list-ref (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (- c 1)))) #f) strong)) (equal? (if (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if img (if (hash? img) (hash-ref img (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref img (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) strong)) (let ()
(set! img (list-set img r (list-set (list-ref img r) c strong)))
) (let ()
(set! img (list-set img r (list-set (list-ref img r) c 0.0)))
))
) (void))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (canny image low high weak strong)
  (let/ec _return (begin
(define blurred (gaussian_blur image))
(define sob (sobel_filter blurred))
(define grad (if sob (hash-ref sob "grad" (list)) #f))
(define direction (if sob (hash-ref sob "dir" (list)) #f))
(define h (cond [(string? image) (string-length image)] [(hash? image) (hash-count image)] [else (length image)]))
(define w (cond [(string? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (string-length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [(hash? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (hash-count (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [else (length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))]))
(define suppressed (suppress_non_maximum h w direction grad))
(double_threshold h w suppressed low high weak strong)
(track_edge h w suppressed weak strong)
(_return suppressed)
))
)
(define (print_image img)
  (let/ec _return (begin
(define r 0)
(let/ec _break (let loop ()
  (if (< r (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)])) (let/ec _cont
    (define c 0)
    (define line "")
    (let/ec _break (let loop ()
  (if (< c (cond [(string? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (string-length (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f))] [(hash? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (hash-count (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f))] [else (length (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f))])) (let/ec _cont
    (set! line (string-append (string-append line (format "~a" (int (if (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (if (hash? (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f)) (hash-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) c #f) (list-ref (if img (if (hash? img) (hash-ref img r #f) (list-ref img (int r))) #f) (int c))) #f)))) " "))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define image (list (list 0.0 0.0 0.0 0.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 0.0 0.0 0.0 0.0)))
(define edges (canny image 20.0 40.0 128.0 255.0))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(print_image edges)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
