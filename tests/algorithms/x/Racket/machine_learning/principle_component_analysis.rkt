;; Generated by Mochi 0.10.60 on 2025-08-08 11:18 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (sqrt x)
  (let/ec _return (begin
(define guess (if (> x 1.0) (/ x 2.0) 1.0))
(define i 0)
(let/ec _break (let loop ()
  (if (< i 20) (let/ec _cont
    (set! guess (* 0.5 (let ([__l guess] [__r (/ x guess)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return guess)
))
)
(define (mean xs)
  (let/ec _return (begin
(define sum 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (set! sum (let ([__l sum] [__r (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ sum (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])))
))
)
(define (standardize data)
  (let/ec _return (begin
(define n_samples (cond [(not data) 0] [(string? data) (string-length data)] [(hash? data) (hash-count data)] [else (length data)]))
(define n_features (cond [(not (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f)) 0] [(string? (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f)) (string-length (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f))] [(hash? (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f)) (hash-count (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f))] [else (length (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f))]))
(define means (list))
(define stds (list))
(define j 0)
(let/ec _break (let loop ()
  (if (< j n_features) (let/ec _cont
    (define column (list))
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i n_samples) (let/ec _cont
    (set! column (append column (list (if (if data (if (hash? data) (hash-ref data i #f) (list-ref data (int i))) #f) (if (hash? (if data (if (hash? data) (hash-ref data i #f) (list-ref data (int i))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data i #f) (list-ref data (int i))) #f) j #f) (list-ref (if data (if (hash? data) (hash-ref data i #f) (list-ref data (int i))) #f) (int j))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (define m (mean column))
    (set! means (append means (list m)))
    (define variance 0.0)
    (define k 0)
    (let/ec _break (let loop ()
  (if (< k n_samples) (let/ec _cont
    (define diff (- (if column (if (hash? column) (hash-ref column k #f) (list-ref column (int k))) #f) m))
    (set! variance (let ([__l variance] [__r (* diff diff)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! stds (append stds (list (sqrt (/ variance (- n_samples 1))))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define standardized (list))
(define r 0)
(let/ec _break (let loop ()
  (if (< r n_samples) (let/ec _cont
    (define row (list))
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c n_features) (let/ec _cont
    (set! row (append row (list (/ (- (if (if data (if (hash? data) (hash-ref data r #f) (list-ref data (int r))) #f) (if (hash? (if data (if (hash? data) (hash-ref data r #f) (list-ref data (int r))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data r #f) (list-ref data (int r))) #f) c #f) (list-ref (if data (if (hash? data) (hash-ref data r #f) (list-ref data (int r))) #f) (int c))) #f) (if means (if (hash? means) (hash-ref means c #f) (list-ref means (int c))) #f)) (if stds (if (hash? stds) (hash-ref stds c #f) (list-ref stds (int c))) #f)))))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! standardized (append standardized (list row)))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return standardized)
))
)
(define (covariance_matrix data)
  (let/ec _return (begin
(define n_samples (cond [(not data) 0] [(string? data) (string-length data)] [(hash? data) (hash-count data)] [else (length data)]))
(define n_features (cond [(not (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f)) 0] [(string? (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f)) (string-length (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f))] [(hash? (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f)) (hash-count (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f))] [else (length (if data (if (hash? data) (hash-ref data 0 #f) (list-ref data (int 0))) #f))]))
(define cov (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i n_features) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j n_features) (let/ec _cont
    (define sum 0.0)
    (define k 0)
    (let/ec _break (let loop ()
  (if (< k n_samples) (let/ec _cont
    (set! sum (let ([__l sum] [__r (* (if (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f) (if (hash? (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f) i #f) (list-ref (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f) (int i))) #f) (if (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f) (if (hash? (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f) j #f) (list-ref (if data (if (hash? data) (hash-ref data k #f) (list-ref data (int k))) #f) (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list (/ sum (- n_samples 1)))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! cov (append cov (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return cov)
))
)
(define (normalize vec)
  (let/ec _return (begin
(define sum 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not vec) 0] [(string? vec) (string-length vec)] [(hash? vec) (hash-count vec)] [else (length vec)])) (let/ec _cont
    (set! sum (let ([__l sum] [__r (* (if vec (if (hash? vec) (hash-ref vec i #f) (list-ref vec (int i))) #f) (if vec (if (hash? vec) (hash-ref vec i #f) (list-ref vec (int i))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define n (sqrt sum))
(define res (list))
(define j 0)
(let/ec _break (let loop ()
  (if (< j (cond [(not vec) 0] [(string? vec) (string-length vec)] [(hash? vec) (hash-count vec)] [else (length vec)])) (let/ec _cont
    (set! res (append res (list (/ (if vec (if (hash? vec) (hash-ref vec j #f) (list-ref vec (int j))) #f) n))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (eigen_decomposition_2x2 matrix)
  (let/ec _return (begin
(define a (if (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f) 0 #f) (list-ref (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f) (int 0))) #f))
(define b (if (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f) 1 #f) (list-ref (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f) (int 1))) #f))
(define c (if (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (list-ref matrix (int 1))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (list-ref matrix (int 1))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (list-ref matrix (int 1))) #f) 1 #f) (list-ref (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (list-ref matrix (int 1))) #f) (int 1))) #f))
(define diff (- a c))
(define discriminant (sqrt (let ([__l (* diff diff)] [__r (* (* 4.0 b) b)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(define lambda1 (/ (let ([__l (let ([__l a] [__r c]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r discriminant]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
(define lambda2 (/ (- (let ([__l a] [__r c]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) discriminant) 2.0))
(define v1 (list))
(define v2 (list))
(if (not (equal? b 0.0)) (let ()
(set! v1 (normalize (list (- lambda1 c) b)))
(set! v2 (normalize (list (- lambda2 c) b)))
) (let ()
(set! v1 (list 1.0 0.0))
(set! v2 (list 0.0 1.0))
))
(define eigenvalues (list lambda1 lambda2))
(define eigenvectors (list v1 v2))
(if (< (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 0 #f) (list-ref eigenvalues (int 0))) #f) (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 1 #f) (list-ref eigenvalues (int 1))) #f)) (let ()
(define tmp_val (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 0 #f) (list-ref eigenvalues (int 0))) #f))
(set! eigenvalues (list-set eigenvalues (int 0) (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 1 #f) (list-ref eigenvalues (int 1))) #f)))
(set! eigenvalues (list-set eigenvalues (int 1) tmp_val))
(define tmp_vec (if eigenvectors (if (hash? eigenvectors) (hash-ref eigenvectors 0 #f) (list-ref eigenvectors (int 0))) #f))
(set! eigenvectors (list-set eigenvectors (int 0) (if eigenvectors (if (hash? eigenvectors) (hash-ref eigenvectors 1 #f) (list-ref eigenvectors (int 1))) #f)))
(set! eigenvectors (list-set eigenvectors (int 1) tmp_vec))
) (void))
(_return (let ([h (make-hash)]) (hash-set! h "values" eigenvalues) (hash-set! h "vectors" eigenvectors) h))
))
)
(define (transpose matrix)
  (let/ec _return (begin
(define rows (cond [(not matrix) 0] [(string? matrix) (string-length matrix)] [(hash? matrix) (hash-count matrix)] [else (length matrix)]))
(define cols (cond [(not (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f)) 0] [(string? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f)) (string-length (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f))] [(hash? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f)) (hash-count (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f))] [else (length (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (list-ref matrix (int 0))) #f))]))
(define trans (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i cols) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j rows) (let/ec _cont
    (set! row (append row (list (if (if matrix (if (hash? matrix) (hash-ref matrix j #f) (list-ref matrix (int j))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix j #f) (list-ref matrix (int j))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix j #f) (list-ref matrix (int j))) #f) i #f) (list-ref (if matrix (if (hash? matrix) (hash-ref matrix j #f) (list-ref matrix (int j))) #f) (int i))) #f))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! trans (append trans (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return trans)
))
)
(define (matrix_multiply a b)
  (let/ec _return (begin
(define rows_a (cond [(not a) 0] [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]))
(define cols_a (cond [(not (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f)) 0] [(string? (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f)) (string-length (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f))] [(hash? (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f)) (hash-count (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f))] [else (length (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f))]))
(define rows_b (cond [(not b) 0] [(string? b) (string-length b)] [(hash? b) (hash-count b)] [else (length b)]))
(define cols_b (cond [(not (if b (if (hash? b) (hash-ref b 0 #f) (list-ref b (int 0))) #f)) 0] [(string? (if b (if (hash? b) (hash-ref b 0 #f) (list-ref b (int 0))) #f)) (string-length (if b (if (hash? b) (hash-ref b 0 #f) (list-ref b (int 0))) #f))] [(hash? (if b (if (hash? b) (hash-ref b 0 #f) (list-ref b (int 0))) #f)) (hash-count (if b (if (hash? b) (hash-ref b 0 #f) (list-ref b (int 0))) #f))] [else (length (if b (if (hash? b) (hash-ref b 0 #f) (list-ref b (int 0))) #f))]))
(if (not (equal? cols_a rows_b)) (let ()
(panic "Incompatible matrices")
) (void))
(define result (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i rows_a) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j cols_b) (let/ec _cont
    (define sum 0.0)
    (define k 0)
    (let/ec _break (let loop ()
  (if (< k cols_a) (let/ec _cont
    (set! sum (let ([__l sum] [__r (* (if (if a (if (hash? a) (hash-ref a i #f) (list-ref a (int i))) #f) (if (hash? (if a (if (hash? a) (hash-ref a i #f) (list-ref a (int i))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a i #f) (list-ref a (int i))) #f) k #f) (list-ref (if a (if (hash? a) (hash-ref a i #f) (list-ref a (int i))) #f) (int k))) #f) (if (if b (if (hash? b) (hash-ref b k #f) (list-ref b (int k))) #f) (if (hash? (if b (if (hash? b) (hash-ref b k #f) (list-ref b (int k))) #f)) (hash-ref (if b (if (hash? b) (hash-ref b k #f) (list-ref b (int k))) #f) j #f) (list-ref (if b (if (hash? b) (hash-ref b k #f) (list-ref b (int k))) #f) (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list sum)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! result (append result (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (apply_pca data n_components)
  (let/ec _return (begin
(define standardized (standardize data))
(define cov (covariance_matrix standardized))
(define eig (eigen_decomposition_2x2 cov))
(define eigenvalues (if eig (hash-ref eig "values" #f) #f))
(define eigenvectors (if eig (hash-ref eig "vectors" #f) #f))
(define components (transpose eigenvectors))
(define transformed (matrix_multiply standardized components))
(define total (let ([__l (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 0 #f) (list-ref eigenvalues (int 0))) #f)] [__r (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 1 #f) (list-ref eigenvalues (int 1))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define ratios (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i n_components) (let/ec _cont
    (set! ratios (append ratios (list (/ (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues i #f) (list-ref eigenvalues (int i))) #f) total))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (let ([h (make-hash)]) (hash-set! h "transformed" transformed) (hash-set! h "variance_ratio" ratios) h))
))
)
(define data (list (list 2.5 2.4) (list 0.5 0.7) (list 2.2 2.9) (list 1.9 2.2) (list 3.1 3.0) (list 2.3 2.7) (list 2.0 1.6) (list 1.0 1.1) (list 1.5 1.6) (list 1.1 0.9)))
(define result (apply_pca data 2))
(define idx 0)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln "Transformed Data (first 5 rows):")
(let/ec _break (let loop ()
  (if (< idx 5) (let/ec _cont
    (displayln (if (if result (hash-ref result "transformed" #f) #f) (if (hash? (if result (hash-ref result "transformed" #f) #f)) (hash-ref (if result (hash-ref result "transformed" #f) #f) idx #f) (list-ref (if result (hash-ref result "transformed" #f) #f) (int idx))) #f))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "Explained Variance Ratio:")
(displayln (if result (hash-ref result "variance_ratio" #f) #f))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
