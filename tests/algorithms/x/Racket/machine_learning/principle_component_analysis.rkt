;; Generated by Mochi 0.10.66 on 2025-08-16 12:32 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (number->string x)]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) 0)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (sqrt x)
  (let/ec _return (begin
(define guess (if (let ([__l x] [__r 1.0]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (/ x 2.0) 1.0))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 20]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! guess (* 0.5 (let ([__l guess] [__r (/ x guess)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return guess)
))
)
(define (mean xs)
  (let/ec _return (begin
(define sum 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum (let ([__l sum] [__r (if xs (if (hash? xs) (hash-ref xs i #f) (safe-index xs (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (/ sum (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])))
))
)
(define (standardize data)
  (let/ec _return (begin
(define n_samples (cond [(not data) 0] [(string? data) (string-length data)] [(hash? data) (hash-count data)] [else (length data)]))
(define n_features (cond [(not (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f)) 0] [(string? (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f)) (string-length (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f))] [(hash? (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f)) (hash-count (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f))] [else (length (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f))]))
(define means (list))
(define stds (list))
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r n_features]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define column (list))
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r n_samples]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! column (append (or column (list)) (list (if (if data (if (hash? data) (hash-ref data i #f) (safe-index data (int i))) #f) (if (hash? (if data (if (hash? data) (hash-ref data i #f) (safe-index data (int i))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data i #f) (safe-index data (int i))) #f) j #f) (safe-index (if data (if (hash? data) (hash-ref data i #f) (safe-index data (int i))) #f) (int j))) #f))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define m (mean column))
      (set! means (append (or means (list)) (list m)))
      (define variance 0.0)
      (define k 0)
      (let/ec _break (let loop ()
  (if (let ([__l k] [__r n_samples]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define diff (- (if column (if (hash? column) (hash-ref column k #f) (safe-index column (int k))) #f) m))
      (set! variance (let ([__l variance] [__r (* diff diff)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! stds (append (or stds (list)) (list (sqrt (/ variance (- n_samples 1))))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define standardized (list))
(define r 0)
(let/ec _break (let loop ()
  (if (let ([__l r] [__r n_samples]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (list))
      (define c 0)
      (let/ec _break (let loop ()
  (if (let ([__l c] [__r n_features]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! row (append (or row (list)) (list (/ (- (if (if data (if (hash? data) (hash-ref data r #f) (safe-index data (int r))) #f) (if (hash? (if data (if (hash? data) (hash-ref data r #f) (safe-index data (int r))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data r #f) (safe-index data (int r))) #f) c #f) (safe-index (if data (if (hash? data) (hash-ref data r #f) (safe-index data (int r))) #f) (int c))) #f) (if means (if (hash? means) (hash-ref means c #f) (safe-index means (int c))) #f)) (if stds (if (hash? stds) (hash-ref stds c #f) (safe-index stds (int c))) #f)))))
      (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! standardized (append (or standardized (list)) (list row)))
      (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return standardized)
))
)
(define (covariance_matrix data)
  (let/ec _return (begin
(define n_samples (cond [(not data) 0] [(string? data) (string-length data)] [(hash? data) (hash-count data)] [else (length data)]))
(define n_features (cond [(not (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f)) 0] [(string? (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f)) (string-length (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f))] [(hash? (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f)) (hash-count (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f))] [else (length (if data (if (hash? data) (hash-ref data 0 #f) (safe-index data (int 0))) #f))]))
(define cov (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r n_features]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (list))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r n_features]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sum 0.0)
      (define k 0)
      (let/ec _break (let loop ()
  (if (let ([__l k] [__r n_samples]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum (let ([__l sum] [__r (* (if (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f) (if (hash? (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f) i #f) (safe-index (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f) (int i))) #f) (if (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f) (if (hash? (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f)) (hash-ref (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f) j #f) (safe-index (if data (if (hash? data) (hash-ref data k #f) (safe-index data (int k))) #f) (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! row (append (or row (list)) (list (/ sum (- n_samples 1)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! cov (append (or cov (list)) (list row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return cov)
))
)
(define (normalize vec)
  (let/ec _return (begin
(define sum 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not vec) 0] [(string? vec) (string-length vec)] [(hash? vec) (hash-count vec)] [else (length vec)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum (let ([__l sum] [__r (* (if vec (if (hash? vec) (hash-ref vec i #f) (safe-index vec (int i))) #f) (if vec (if (hash? vec) (hash-ref vec i #f) (safe-index vec (int i))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define n (sqrt sum))
(define res (list))
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not vec) 0] [(string? vec) (string-length vec)] [(hash? vec) (hash-count vec)] [else (length vec)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! res (append (or res (list)) (list (/ (if vec (if (hash? vec) (hash-ref vec j #f) (safe-index vec (int j))) #f) n))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (eigen_decomposition_2x2 matrix)
  (let/ec _return (begin
(define a (if (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f) 0 #f) (safe-index (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f) (int 0))) #f))
(define b (if (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f) 1 #f) (safe-index (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f) (int 1))) #f))
(define c (if (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (safe-index matrix (int 1))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (safe-index matrix (int 1))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (safe-index matrix (int 1))) #f) 1 #f) (safe-index (if matrix (if (hash? matrix) (hash-ref matrix 1 #f) (safe-index matrix (int 1))) #f) (int 1))) #f))
(define diff (- a c))
(define discriminant (sqrt (let ([__l (* diff diff)] [__r (* (* 4.0 b) b)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(define lambda1 (/ (let ([__l (let ([__l a] [__r c]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r discriminant]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
(define lambda2 (/ (- (let ([__l a] [__r c]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) discriminant) 2.0))
(define v1 (list))
(define v2 (list))
(if (not (equal? b 0.0)) (let ()
(set! v1 (normalize (list (- lambda1 c) b)))
(set! v2 (normalize (list (- lambda2 c) b)))
) (let ()
(set! v1 (list 1.0 0.0))
(set! v2 (list 0.0 1.0))
))
(define eigenvalues (list lambda1 lambda2))
(define eigenvectors (list v1 v2))
(if (let ([__l (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 0 #f) (safe-index eigenvalues (int 0))) #f)] [__r (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 1 #f) (safe-index eigenvalues (int 1))) #f)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(define tmp_val (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 0 #f) (safe-index eigenvalues (int 0))) #f))
(set! eigenvalues (list-set eigenvalues (int 0) (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 1 #f) (safe-index eigenvalues (int 1))) #f)))
(set! eigenvalues (list-set eigenvalues (int 1) tmp_val))
(define tmp_vec (if eigenvectors (if (hash? eigenvectors) (hash-ref eigenvectors 0 #f) (safe-index eigenvectors (int 0))) #f))
(set! eigenvectors (list-set eigenvectors (int 0) (if eigenvectors (if (hash? eigenvectors) (hash-ref eigenvectors 1 #f) (safe-index eigenvectors (int 1))) #f)))
(set! eigenvectors (list-set eigenvectors (int 1) tmp_vec))
) (void))
(_return (let ([h (make-hash)]) (hash-set! h "values" eigenvalues) (hash-set! h "vectors" eigenvectors) h))
))
)
(define (transpose matrix)
  (let/ec _return (begin
(define rows (cond [(not matrix) 0] [(string? matrix) (string-length matrix)] [(hash? matrix) (hash-count matrix)] [else (length matrix)]))
(define cols (cond [(not (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f)) 0] [(string? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f)) (string-length (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f))] [(hash? (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f)) (hash-count (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f))] [else (length (if matrix (if (hash? matrix) (hash-ref matrix 0 #f) (safe-index matrix (int 0))) #f))]))
(define trans (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r cols]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (list))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r rows]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! row (append (or row (list)) (list (if (if matrix (if (hash? matrix) (hash-ref matrix j #f) (safe-index matrix (int j))) #f) (if (hash? (if matrix (if (hash? matrix) (hash-ref matrix j #f) (safe-index matrix (int j))) #f)) (hash-ref (if matrix (if (hash? matrix) (hash-ref matrix j #f) (safe-index matrix (int j))) #f) i #f) (safe-index (if matrix (if (hash? matrix) (hash-ref matrix j #f) (safe-index matrix (int j))) #f) (int i))) #f))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! trans (append (or trans (list)) (list row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return trans)
))
)
(define (matrix_multiply a b)
  (let/ec _return (begin
(define rows_a (cond [(not a) 0] [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]))
(define cols_a (cond [(not (if a (if (hash? a) (hash-ref a 0 #f) (safe-index a (int 0))) #f)) 0] [(string? (if a (if (hash? a) (hash-ref a 0 #f) (safe-index a (int 0))) #f)) (string-length (if a (if (hash? a) (hash-ref a 0 #f) (safe-index a (int 0))) #f))] [(hash? (if a (if (hash? a) (hash-ref a 0 #f) (safe-index a (int 0))) #f)) (hash-count (if a (if (hash? a) (hash-ref a 0 #f) (safe-index a (int 0))) #f))] [else (length (if a (if (hash? a) (hash-ref a 0 #f) (safe-index a (int 0))) #f))]))
(define rows_b (cond [(not b) 0] [(string? b) (string-length b)] [(hash? b) (hash-count b)] [else (length b)]))
(define cols_b (cond [(not (if b (if (hash? b) (hash-ref b 0 #f) (safe-index b (int 0))) #f)) 0] [(string? (if b (if (hash? b) (hash-ref b 0 #f) (safe-index b (int 0))) #f)) (string-length (if b (if (hash? b) (hash-ref b 0 #f) (safe-index b (int 0))) #f))] [(hash? (if b (if (hash? b) (hash-ref b 0 #f) (safe-index b (int 0))) #f)) (hash-count (if b (if (hash? b) (hash-ref b 0 #f) (safe-index b (int 0))) #f))] [else (length (if b (if (hash? b) (hash-ref b 0 #f) (safe-index b (int 0))) #f))]))
(if (not (equal? cols_a rows_b)) (let ()
(panic "Incompatible matrices")
) (void))
(define result (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r rows_a]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (list))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r cols_b]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sum 0.0)
      (define k 0)
      (let/ec _break (let loop ()
  (if (let ([__l k] [__r cols_a]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum (let ([__l sum] [__r (* (if (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (if (hash? (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) k #f) (safe-index (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (int k))) #f) (if (if b (if (hash? b) (hash-ref b k #f) (safe-index b (int k))) #f) (if (hash? (if b (if (hash? b) (hash-ref b k #f) (safe-index b (int k))) #f)) (hash-ref (if b (if (hash? b) (hash-ref b k #f) (safe-index b (int k))) #f) j #f) (safe-index (if b (if (hash? b) (hash-ref b k #f) (safe-index b (int k))) #f) (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! row (append (or row (list)) (list sum)))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! result (append (or result (list)) (list row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return result)
))
)
(define (apply_pca data n_components)
  (let/ec _return (begin
(define standardized (standardize data))
(define cov (covariance_matrix standardized))
(define eig (eigen_decomposition_2x2 cov))
(define eigenvalues (if eig (hash-ref eig "values" #f) #f))
(define eigenvectors (if eig (hash-ref eig "vectors" #f) #f))
(define components (transpose eigenvectors))
(define transformed (matrix_multiply standardized components))
(define total (let ([__l (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 0 #f) (safe-index eigenvalues (int 0))) #f)] [__r (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues 1 #f) (safe-index eigenvalues (int 1))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define ratios (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r n_components]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! ratios (append (or ratios (list)) (list (/ (if eigenvalues (if (hash? eigenvalues) (hash-ref eigenvalues i #f) (safe-index eigenvalues (int i))) #f) total))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (let ([h (make-hash)]) (hash-set! h "transformed" transformed) (hash-set! h "variance_ratio" ratios) h))
))
)
(define data (list (list 2.5 2.4) (list 0.5 0.7) (list 2.2 2.9) (list 1.9 2.2) (list 3.1 3.0) (list 2.3 2.7) (list 2.0 1.6) (list 1.0 1.1) (list 1.5 1.6) (list 1.1 0.9)))
(define result (apply_pca data 2))
(define idx 0)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(displayln "Transformed Data (first 5 rows):")
(let/ec _break (let loop ()
  (if (let ([__l idx] [__r 5]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (displayln (if (if result (hash-ref result "transformed" #f) #f) (if (hash? (if result (hash-ref result "transformed" #f) #f)) (hash-ref (if result (hash-ref result "transformed" #f) #f) idx #f) (safe-index (if result (hash-ref result "transformed" #f) #f) (int idx))) #f))
      (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(displayln "Explained Variance Ratio:")
(displayln (if result (hash-ref result "variance_ratio" #f) #f))
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
