;; Generated by Mochi 0.10.60 on 2025-08-08 11:18 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (absf x)
  (let/ec _return (begin
(if (< x 0.0) (let ()
(_return (- x))
) (void))
(_return x)
))
)
(define (maxf a b)
  (let/ec _return (begin
(if (> a b) (let ()
(_return a)
) (void))
(_return b)
))
)
(define (minf a b)
  (let/ec _return (begin
(if (< a b) (let ()
(_return a)
) (void))
(_return b)
))
)
(define (clip x lo hi)
  (let/ec _return (begin
(_return (maxf lo (minf x hi)))
))
)
(define (to_float x)
  (let/ec _return (begin
(_return (* x 1.0))
))
)
(define (powf base exp)
  (let/ec _return (begin
(define result 1.0)
(define i 0)
(define n (int exp))
(let/ec _break (let loop ()
  (if (< i n) (let/ec _cont
    (set! result (* result base))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (ln x)
  (let/ec _return (begin
(if (<= x 0.0) (let ()
(panic "ln domain error")
) (void))
(define y (/ (- x 1.0) (let ([__l x] [__r 1.0]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(define y2 (* y y))
(define term y)
(define sum 0.0)
(define k 0)
(let/ec _break (let loop ()
  (if (< k 10) (let/ec _cont
    (define denom (to_float (let ([__l (* 2 k)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (set! sum (let ([__l sum] [__r (/ term denom)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! term (* term y2))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (* 2.0 sum))
))
)
(define (exp x)
  (let/ec _return (begin
(define term 1.0)
(define sum 1.0)
(define n 1)
(let/ec _break (let loop ()
  (if (< n 20) (let/ec _cont
    (set! term (/ (* term x) (to_float n)))
    (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! n (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sum)
))
)
(define (mean v)
  (let/ec _return (begin
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not v) 0] [(string? v) (string-length v)] [(hash? v) (hash-count v)] [else (length v)])) (let/ec _cont
    (set! total (let ([__l total] [__r (if v (if (hash? v) (hash-ref v i #f) (list-ref v (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float (cond [(not v) 0] [(string? v) (string-length v)] [(hash? v) (hash-count v)] [else (length v)]))))
))
)
(define (binary_cross_entropy y_true y_pred epsilon)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define losses (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define yt (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))
    (define yp (clip (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) epsilon (- 1.0 epsilon)))
    (define loss (- (let ([__l (* yt (ln yp))] [__r (* (- 1.0 yt) (ln (- 1.0 yp)))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (set! losses (append losses (list loss)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (mean losses))
))
)
(define (binary_focal_cross_entropy y_true y_pred gamma alpha epsilon)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define losses (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define yt (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))
    (define yp (clip (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) epsilon (- 1.0 epsilon)))
    (define term1 (* (* (* alpha (powf (- 1.0 yp) gamma)) yt) (ln yp)))
    (define term2 (* (* (* (- 1.0 alpha) (powf yp gamma)) (- 1.0 yt)) (ln (- 1.0 yp))))
    (set! losses (append losses (list (- (let ([__l term1] [__r term2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (mean losses))
))
)
(define (categorical_cross_entropy y_true y_pred epsilon)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same shape.")
) (void))
(define rows (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i rows) (let/ec _cont
    (if (not (equal? (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))]) (cond [(not (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) 0] [(string? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (string-length (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))] [(hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (hash-count (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))] [else (length (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))]))) (let ()
(panic "Input arrays must have the same shape.")
) (void))
    (define sum_true 0.0)
    (define sum_pred 0.0)
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))])) (let/ec _cont
    (define yt (if (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if (hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) j #f) (list-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (int j))) #f))
    (define yp (if (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (int j))) #f))
    (if (and (not (equal? yt 0.0)) (not (equal? yt 1.0))) (let ()
(panic "y_true must be one-hot encoded.")
) (void))
    (set! sum_true (let ([__l sum_true] [__r yt]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! sum_pred (let ([__l sum_pred] [__r yp]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (not (equal? sum_true 1.0)) (let ()
(panic "y_true must be one-hot encoded.")
) (void))
    (if (> (absf (- sum_pred 1.0)) epsilon) (let ()
(panic "Predicted probabilities must sum to approximately 1.")
) (void))
    (set! j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))])) (let/ec _cont
    (define yp (clip (if (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (int j))) #f) epsilon 1.0))
    (set! total (- total (* (if (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if (hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) j #f) (list-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (int j))) #f) (ln yp))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return total)
))
)
(define (categorical_focal_cross_entropy y_true y_pred alpha gamma epsilon)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Shape of y_true and y_pred must be the same.")
) (void))
(define rows (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))
(define cols (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f))]))
(define a alpha)
(if (equal? (cond [(not a) 0] [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]) 0) (let ()
(define tmp (list))
(define j 0)
(let/ec _break (let loop ()
  (if (< j cols) (let/ec _cont
    (set! tmp (append tmp (list 1.0)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! a tmp)
) (void))
(if (not (equal? (cond [(not a) 0] [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]) cols)) (let ()
(panic "Length of alpha must match the number of classes.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i rows) (let/ec _cont
    (if (or (not (equal? (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))]) cols)) (not (equal? (cond [(not (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) 0] [(string? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (string-length (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))] [(hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (hash-count (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))] [else (length (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))]) cols))) (let ()
(panic "Shape of y_true and y_pred must be the same.")
) (void))
    (define sum_true 0.0)
    (define sum_pred 0.0)
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j cols) (let/ec _cont
    (define yt (if (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if (hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) j #f) (list-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (int j))) #f))
    (define yp (if (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (int j))) #f))
    (if (and (not (equal? yt 0.0)) (not (equal? yt 1.0))) (let ()
(panic "y_true must be one-hot encoded.")
) (void))
    (set! sum_true (let ([__l sum_true] [__r yt]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! sum_pred (let ([__l sum_pred] [__r yp]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (not (equal? sum_true 1.0)) (let ()
(panic "y_true must be one-hot encoded.")
) (void))
    (if (> (absf (- sum_pred 1.0)) epsilon) (let ()
(panic "Predicted probabilities must sum to approximately 1.")
) (void))
    (define row_loss 0.0)
    (set! j 0)
    (let/ec _break (let loop ()
  (if (< j cols) (let/ec _cont
    (define yp (clip (if (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f) (int j))) #f) epsilon 1.0))
    (set! row_loss (let ([__l row_loss] [__r (* (* (* (if a (if (hash? a) (hash-ref a j #f) (list-ref a (int j))) #f) (powf (- 1.0 yp) gamma)) (if (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if (hash? (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)) (hash-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) j #f) (list-ref (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (int j))) #f)) (ln yp))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! total (- total row_loss))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float rows)))
))
)
(define (hinge_loss y_true y_pred)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Length of predicted and actual array must be same.")
) (void))
(define losses (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define yt (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))
    (if (and (not (equal? yt (- 1.0))) (not (equal? yt 1.0))) (let ()
(panic "y_true can have values -1 or 1 only.")
) (void))
    (define pred (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))
    (define l (maxf 0.0 (- 1.0 (* yt pred))))
    (set! losses (append losses (list l)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (mean losses))
))
)
(define (huber_loss y_true y_pred delta)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define diff (- (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)))
    (define adiff (absf diff))
    (if (<= adiff delta) (let ()
(set! total (let ([__l total] [__r (* (* 0.5 diff) diff)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(set! total (let ([__l total] [__r (* delta (- adiff (* 0.5 delta)))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))))
))
)
(define (mean_squared_error y_true y_pred)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define losses (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define diff (- (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)))
    (set! losses (append losses (list (* diff diff))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (mean losses))
))
)
(define (mean_absolute_error y_true y_pred)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (set! total (let ([__l total] [__r (absf (- (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))))
))
)
(define (mean_squared_logarithmic_error y_true y_pred)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define a (ln (let ([__l 1.0] [__r (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define b (ln (let ([__l 1.0] [__r (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define diff (- a b))
    (set! total (let ([__l total] [__r (* diff diff)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))))
))
)
(define (mean_absolute_percentage_error y_true y_pred epsilon)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "The length of the two arrays should be the same.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define yt (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f))
    (if (equal? yt 0.0) (let ()
(set! yt epsilon)
) (void))
    (set! total (let ([__l total] [__r (absf (/ (- yt (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f)) yt))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))))
))
)
(define (perplexity_loss y_true y_pred epsilon)
  (let/ec _return (begin
(define batch (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))
(if (not (equal? batch (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Batch size of y_true and y_pred must be equal.")
) (void))
(define sentence_len (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true 0 #f) (list-ref y_true (int 0))) #f))]))
(if (not (equal? sentence_len (cond [(not (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) 0] [(string? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (string-length (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f))] [(hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-count (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f))] [else (length (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f))]))) (let ()
(panic "Sentence length of y_true and y_pred must be equal.")
) (void))
(define vocab_size (cond [(not (if (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) 0 #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (int 0))) #f)) 0] [(string? (if (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) 0 #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (int 0))) #f)) (string-length (if (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) 0 #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (int 0))) #f))] [(hash? (if (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) 0 #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (int 0))) #f)) (hash-count (if (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) 0 #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (int 0))) #f))] [else (length (if (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) 0 #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred 0 #f) (list-ref y_pred (int 0))) #f) (int 0))) #f))]))
(define b 0)
(define total_perp 0.0)
(let/ec _break (let loop ()
  (if (< b batch) (let/ec _cont
    (if (or (not (equal? (cond [(not (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f)) 0] [(string? (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f)) (string-length (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f))] [(hash? (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f)) (hash-count (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f))] [else (length (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f))]) sentence_len)) (not (equal? (cond [(not (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) 0] [(string? (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) (string-length (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f))] [(hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) (hash-count (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f))] [else (length (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f))]) sentence_len))) (let ()
(panic "Sentence length of y_true and y_pred must be equal.")
) (void))
    (define sum_log 0.0)
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j sentence_len) (let/ec _cont
    (define label (if (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f) (if (hash? (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f)) (hash-ref (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f) j #f) (list-ref (if y_true (if (hash? y_true) (hash-ref y_true b #f) (list-ref y_true (int b))) #f) (int j))) #f))
    (if (>= label vocab_size) (let ()
(panic "Label value must not be greater than vocabulary size.")
) (void))
    (define prob (clip (if (if (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (int j))) #f) (if (hash? (if (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (int j))) #f)) (hash-ref (if (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (int j))) #f) label #f) (list-ref (if (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (if (hash? (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f)) (hash-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) j #f) (list-ref (if y_pred (if (hash? y_pred) (hash-ref y_pred b #f) (list-ref y_pred (int b))) #f) (int j))) #f) (int label))) #f) epsilon 1.0))
    (set! sum_log (let ([__l sum_log] [__r (ln prob)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (define mean_log (/ sum_log (to_float sentence_len)))
    (define perp (exp (- mean_log)))
    (set! total_perp (let ([__l total_perp] [__r perp]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! b (let ([__l b] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total_perp (to_float batch)))
))
)
(define (smooth_l1_loss y_true y_pred beta)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "The length of the two arrays should be the same.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (define diff (absf (- (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))))
    (if (< diff beta) (let ()
(set! total (let ([__l total] [__r (/ (* (* 0.5 diff) diff) beta)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(set! total (- (let ([__l total] [__r diff]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (* 0.5 beta)))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (/ total (to_float (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]))))
))
)
(define (kullback_leibler_divergence y_true y_pred)
  (let/ec _return (begin
(if (not (equal? (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)]) (cond [(not y_pred) 0] [(string? y_pred) (string-length y_pred)] [(hash? y_pred) (hash-count y_pred)] [else (length y_pred)]))) (let ()
(panic "Input arrays must have the same length.")
) (void))
(define total 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not y_true) 0] [(string? y_true) (string-length y_true)] [(hash? y_true) (hash-count y_true)] [else (length y_true)])) (let/ec _cont
    (set! total (let ([__l total] [__r (* (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (ln (/ (if y_true (if (hash? y_true) (hash-ref y_true i #f) (list-ref y_true (int i))) #f) (if y_pred (if (hash? y_pred) (hash-ref y_pred i #f) (list-ref y_pred (int i))) #f))))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return total)
))
)
(define (main)
  (let/ec _return (begin
(define y_true_bc (list 0.0 1.0 1.0 0.0 1.0))
(define y_pred_bc (list 0.2 0.7 0.9 0.3 0.8))
(displayln (binary_cross_entropy y_true_bc y_pred_bc 1e-15))
(displayln (binary_focal_cross_entropy y_true_bc y_pred_bc 2.0 0.25 1e-15))
(define y_true_cce (list (list 1.0 0.0 0.0) (list 0.0 1.0 0.0) (list 0.0 0.0 1.0)))
(define y_pred_cce (list (list 0.9 0.1 0.0) (list 0.2 0.7 0.1) (list 0.0 0.1 0.9)))
(displayln (categorical_cross_entropy y_true_cce y_pred_cce 1e-15))
(define alpha (list 0.6 0.2 0.7))
(displayln (categorical_focal_cross_entropy y_true_cce y_pred_cce alpha 2.0 1e-15))
(define y_true_hinge (list (- 1.0) 1.0 1.0 (- 1.0) 1.0))
(define y_pred_hinge (list (- 4.0) (- 0.3) 0.7 5.0 10.0))
(displayln (hinge_loss y_true_hinge y_pred_hinge))
(define y_true_huber (list 0.9 10.0 2.0 1.0 5.2))
(define y_pred_huber (list 0.8 2.1 2.9 4.2 5.2))
(displayln (huber_loss y_true_huber y_pred_huber 1.0))
(displayln (mean_squared_error y_true_huber y_pred_huber))
(displayln (mean_absolute_error y_true_huber y_pred_huber))
(displayln (mean_squared_logarithmic_error y_true_huber y_pred_huber))
(define y_true_mape (list 10.0 20.0 30.0 40.0))
(define y_pred_mape (list 12.0 18.0 33.0 45.0))
(displayln (mean_absolute_percentage_error y_true_mape y_pred_mape 1e-15))
(define y_true_perp (list (list 1 4) (list 2 3)))
(define y_pred_perp (list (list (list 0.28 0.19 0.21 0.15 0.17) (list 0.24 0.19 0.09 0.18 0.3)) (list (list 0.03 0.26 0.21 0.18 0.32) (list 0.28 0.1 0.33 0.15 0.14))))
(displayln (perplexity_loss y_true_perp y_pred_perp 1e-07))
(define y_true_smooth (list 3.0 5.0 2.0 7.0))
(define y_pred_smooth (list 2.9 4.8 2.1 7.2))
(displayln (smooth_l1_loss y_true_smooth y_pred_smooth 1.0))
(define y_true_kl (list 0.2 0.3 0.5))
(define y_pred_kl (list 0.3 0.3 0.4))
(displayln (kullback_leibler_divergence y_true_kl y_pred_kl))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
