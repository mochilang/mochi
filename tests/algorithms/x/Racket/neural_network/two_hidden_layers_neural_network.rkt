;; Generated by Mochi 0.10.73 on 2025-08-26 08:36 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/format racket/system racket/port racket/vector net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define _data_dir "tests/github/TheAlgorithms/Mochi/neural_network")
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x)
     (cond
       [(and (inexact? x) (integer? x)) (format "~a.0" (inexact->exact x))]
       [else (number->string x)])]
    [(vector? x) (format "~a" (map (lambda (v) (cond [(hash? v) (read (open-input-string (to-string v)))] [(vector? v) (vector->list v)] [else v])) (vector->list x)))]
    [(hash? x)
     (format "~a"
             (for/hash ([k (in-hash-keys x)])
               (values k (let ([v (hash-ref x k)]) (if (vector? v) (vector->list v) v)))))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (cond
    [(string? lst) (substring lst start end)]
    [(vector? lst) (vector->list (vector-copy lst start end))]
    [else (take (drop lst start) (- end start))]))

(define (slice seq start end)
  (define len (cond [(string? seq) (string-length seq)] [(vector? seq) (vector-length seq)] [else (length seq)]))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (cond
    [(string? seq) (substring seq s e)]
    [(vector? seq) (vector-copy seq s e)]
    [else (sublist seq s e)]))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (appendv a b)
  (cond
    [(vector? a) (vector-append a (cond [(vector? b) b] [(list? b) (list->vector b)] [else (vector b)]))]
    [(list? a) (append a (cond [(list? b) b] [(vector? b) (vector->list b)] [else (list b)]))]
    [else (append a b)]))
(define (safe-index lst idx) (let ([i (int idx)]) (cond [(list? lst) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) '())] [(vector? lst) (if (and (>= i 0) (< i (vector-length lst))) (vector-ref lst i) '())] [(string? lst) (if (and (>= i 0) (< i (string-length lst))) (substring lst i (add1 i)) "")] [else 0])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_ord s) (char->integer (string-ref s 0)))
(define (read_file path)
  (define p path)
  (let ([root (getenv "MOCHI_ROOT")])
    (when (and root (not (file-exists? p)))
      (set! p (path->string (build-path root _data_dir path)))))
  (with-input-from-file p port->string))
(define (list-set lst idx val)
  (define i (int idx))
  (cond
    [(vector? lst) (when (< i (vector-length lst)) (vector-set! lst i val)) lst]
    [else
     (define len (length lst))
     (cond
       [(>= i len) (append lst (make-list (- i len) '()) (list val))]
       [(zero? i) (cons val (cdr lst))]
       [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))])]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (exp_approx x)
  (let/ec _return (begin
(define sum 1.0)
(define term 1.0)
(define i 1)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 10]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! term (/ (* term x) (float i)))
      (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return sum)
))
)
(define (sigmoid x)
  (let/ec _return (begin
(_return (/ 1.0 (let ([__l 1.0] [__r (exp_approx (- x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (sigmoid_derivative x)
  (let/ec _return (begin
(_return (* x (- 1.0 x)))
))
)
(define (new_network)
  (let/ec _return (begin
(_return (let ([h (make-hash)]) (hash-set! h "w1" (vector (vector 0.1 0.2 0.3 0.4) (vector 0.5 0.6 0.7 0.8) (vector 0.9 1.0 1.1 1.2))) (hash-set! h "w2" (vector (vector 0.1 0.2 0.3) (vector 0.4 0.5 0.6) (vector 0.7 0.8 0.9) (vector 1.0 1.1 1.2))) (hash-set! h "w3" (vector (vector 0.1) (vector 0.2) (vector 0.3))) h))
))
)
(define (feedforward net input)
  (let/ec _return (begin
(define hidden1 (vector))
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sum1 0.0)
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum1 (let ([__l sum1] [__r (* (if input (if (hash? input) (hash-ref input i #f) (safe-index input (int i))) #f) (if (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f) (if (hash? (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f)) (hash-ref (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f) j #f) (safe-index (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f) (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! hidden1 (appendv (or hidden1 (vector)) (sigmoid sum1)))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define hidden2 (vector))
(define k 0)
(let/ec _break (let loop ()
  (if (let ([__l k] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sum2 0.0)
      (define j2 0)
      (let/ec _break (let loop ()
  (if (let ([__l j2] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum2 (let ([__l sum2] [__r (* (if hidden1 (if (hash? hidden1) (hash-ref hidden1 j2 #f) (safe-index hidden1 (int j2))) #f) (if (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f) (if (hash? (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f)) (hash-ref (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f) k #f) (safe-index (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f) (int k))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! j2 (let ([__l j2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! hidden2 (appendv (or hidden2 (vector)) (sigmoid sum2)))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define sum3 0.0)
(define k2 0)
(let/ec _break (let loop ()
  (if (let ([__l k2] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum3 (let ([__l sum3] [__r (* (if hidden2 (if (hash? hidden2) (hash-ref hidden2 k2 #f) (safe-index hidden2 (int k2))) #f) (if (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k2 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k2))) #f) (if (hash? (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k2 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k2))) #f)) (hash-ref (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k2 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k2))) #f) 0 #f) (safe-index (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k2 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k2))) #f) (int 0))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k2 (let ([__l k2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define out (sigmoid sum3))
(_return out)
))
)
(define (train net inputs outputs iterations)
  (let/ec _return (begin
(define iter 0)
(let/ec _break (let loop ()
  (if (let ([__l iter] [__r iterations]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define s 0)
      (let/ec _break (let loop ()
  (if (let ([__l s] [__r (cond [(not inputs) 0] [(string? inputs) (string-length inputs)] [(vector? inputs) (vector-length inputs)] [(hash? inputs) (hash-count inputs)] [else (length inputs)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define inp (if inputs (if (hash? inputs) (hash-ref inputs s #f) (safe-index inputs (int s))) #f))
      (define target (if outputs (if (hash? outputs) (hash-ref outputs s #f) (safe-index outputs (int s))) #f))
      (define hidden1 (vector))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sum1 0.0)
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum1 (let ([__l sum1] [__r (* (if inp (if (hash? inp) (hash-ref inp i #f) (safe-index inp (int i))) #f) (if (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f) (if (hash? (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f)) (hash-ref (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f) j #f) (safe-index (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i))) #f) (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! hidden1 (appendv (or hidden1 (vector)) (sigmoid sum1)))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define hidden2 (vector))
      (define k 0)
      (let/ec _break (let loop ()
  (if (let ([__l k] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sum2 0.0)
      (define j2 0)
      (let/ec _break (let loop ()
  (if (let ([__l j2] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum2 (let ([__l sum2] [__r (* (if hidden1 (if (hash? hidden1) (hash-ref hidden1 j2 #f) (safe-index hidden1 (int j2))) #f) (if (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f) (if (hash? (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f)) (hash-ref (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f) k #f) (safe-index (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j2 #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j2))) #f) (int k))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! j2 (let ([__l j2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! hidden2 (appendv (or hidden2 (vector)) (sigmoid sum2)))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define sum3 0.0)
      (define k3 0)
      (let/ec _break (let loop ()
  (if (let ([__l k3] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! sum3 (let ([__l sum3] [__r (* (if hidden2 (if (hash? hidden2) (hash-ref hidden2 k3 #f) (safe-index hidden2 (int k3))) #f) (if (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k3 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k3))) #f) (if (hash? (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k3 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k3))) #f)) (hash-ref (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k3 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k3))) #f) 0 #f) (safe-index (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k3 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k3))) #f) (int 0))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k3 (let ([__l k3] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define output (sigmoid sum3))
      (define error (- target output))
      (define delta_output (* error (sigmoid_derivative output)))
      (define new_w3 (vector))
      (define k4 0)
      (let/ec _break (let loop ()
  (if (let ([__l k4] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define w3row (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k4 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k4))) #f))
      (vector-set! w3row (int 0) (let ([__l (if w3row (if (hash? w3row) (hash-ref w3row 0 #f) (safe-index w3row (int 0))) #f)] [__r (* (if hidden2 (if (hash? hidden2) (hash-ref hidden2 k4 #f) (safe-index hidden2 (int k4))) #f) delta_output)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! new_w3 (appendv (or new_w3 (vector)) (vector w3row)))
      (set! k4 (let ([__l k4] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (if (hash? net) (hash-set! net "w3" new_w3) (begin (set! net (make-hash)) (hash-set! net "w3" new_w3)))
      (define delta_hidden2 (vector))
      (define k5 0)
      (let/ec _break (let loop ()
  (if (let ([__l k5] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (if (if net (hash-ref net "w3" #f) #f) (if (hash? (if net (hash-ref net "w3" #f) #f)) (hash-ref (if net (hash-ref net "w3" #f) #f) k5 #f) (safe-index (if net (hash-ref net "w3" #f) #f) (int k5))) #f))
      (define dh2 (* (* (if row (if (hash? row) (hash-ref row 0 #f) (safe-index row (int 0))) #f) delta_output) (sigmoid_derivative (if hidden2 (if (hash? hidden2) (hash-ref hidden2 k5 #f) (safe-index hidden2 (int k5))) #f))))
      (set! delta_hidden2 (appendv (or delta_hidden2 (vector)) (vector dh2)))
      (set! k5 (let ([__l k5] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define new_w2 (vector))
      (set! j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define w2row (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j))) #f))
      (define k6 0)
      (let/ec _break (let loop ()
  (if (let ([__l k6] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (vector-set! w2row (int k6) (let ([__l (if w2row (if (hash? w2row) (hash-ref w2row k6 #f) (safe-index w2row (int k6))) #f)] [__r (* (if hidden1 (if (hash? hidden1) (hash-ref hidden1 j #f) (safe-index hidden1 (int j))) #f) (if delta_hidden2 (if (hash? delta_hidden2) (hash-ref delta_hidden2 k6 #f) (safe-index delta_hidden2 (int k6))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k6 (let ([__l k6] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! new_w2 (appendv (or new_w2 (vector)) (vector w2row)))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (if (hash? net) (hash-set! net "w2" new_w2) (begin (set! net (make-hash)) (hash-set! net "w2" new_w2)))
      (define delta_hidden1 (vector))
      (set! j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define sumdh 0.0)
      (define k7 0)
      (let/ec _break (let loop ()
  (if (let ([__l k7] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row2 (if (if net (hash-ref net "w2" #f) #f) (if (hash? (if net (hash-ref net "w2" #f) #f)) (hash-ref (if net (hash-ref net "w2" #f) #f) j #f) (safe-index (if net (hash-ref net "w2" #f) #f) (int j))) #f))
      (set! sumdh (let ([__l sumdh] [__r (* (if row2 (if (hash? row2) (hash-ref row2 k7 #f) (safe-index row2 (int k7))) #f) (if delta_hidden2 (if (hash? delta_hidden2) (hash-ref delta_hidden2 k7 #f) (safe-index delta_hidden2 (int k7))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! k7 (let ([__l k7] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! delta_hidden1 (appendv (or delta_hidden1 (vector)) (vector (* sumdh (sigmoid_derivative (if hidden1 (if (hash? hidden1) (hash-ref hidden1 j #f) (safe-index hidden1 (int j))) #f))))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define new_w1 (vector))
      (define i2 0)
      (let/ec _break (let loop ()
  (if (let ([__l i2] [__r 3]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define w1row (if (if net (hash-ref net "w1" #f) #f) (if (hash? (if net (hash-ref net "w1" #f) #f)) (hash-ref (if net (hash-ref net "w1" #f) #f) i2 #f) (safe-index (if net (hash-ref net "w1" #f) #f) (int i2))) #f))
      (set! j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r 4]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (vector-set! w1row (int j) (let ([__l (if w1row (if (hash? w1row) (hash-ref w1row j #f) (safe-index w1row (int j))) #f)] [__r (* (if inp (if (hash? inp) (hash-ref inp i2 #f) (safe-index inp (int i2))) #f) (if delta_hidden1 (if (hash? delta_hidden1) (hash-ref delta_hidden1 j #f) (safe-index delta_hidden1 (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! new_w1 (appendv (or new_w1 (vector)) (vector w1row)))
      (set! i2 (let ([__l i2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (if (hash? net) (hash-set! net "w1" new_w1) (begin (set! net (make-hash)) (hash-set! net "w1" new_w1)))
      (set! s (let ([__l s] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! iter (let ([__l iter] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
)
(define (predict net input)
  (let/ec _return (begin
(define out (feedforward net input))
(if (let ([__l out] [__r 0.6]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (let ()
(_return 1)
) (void))
(_return 0)
))
)
(define (example)
  (let/ec _return (begin
(define inputs (vector (vector 0.0 0.0 0.0) (vector 0.0 0.0 1.0) (vector 0.0 1.0 0.0) (vector 0.0 1.0 1.0) (vector 1.0 0.0 0.0) (vector 1.0 0.0 1.0) (vector 1.0 1.0 0.0) (vector 1.0 1.0 1.0)))
(define outputs (vector 0.0 1.0 1.0 0.0 1.0 0.0 0.0 1.0))
(define net (new_network))
(train net inputs outputs 10)
(define result (predict net (vector 1.0 1.0 1.0)))
(displayln (to-string (to-string result)))
(_return result)
))
)
(define (main)
  (let/ec _return (begin
(example)
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
