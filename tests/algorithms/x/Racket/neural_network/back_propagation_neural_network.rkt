;; Generated by Mochi 0.10.73 on 2025-08-26 08:36 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/format racket/system racket/port racket/vector net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define _data_dir "tests/github/TheAlgorithms/Mochi/neural_network")
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x)
     (cond
       [(and (inexact? x) (integer? x)) (format "~a.0" (inexact->exact x))]
       [else (number->string x)])]
    [(vector? x) (format "~a" (map (lambda (v) (cond [(hash? v) (read (open-input-string (to-string v)))] [(vector? v) (vector->list v)] [else v])) (vector->list x)))]
    [(hash? x)
     (format "~a"
             (for/hash ([k (in-hash-keys x)])
               (values k (let ([v (hash-ref x k)]) (if (vector? v) (vector->list v) v)))))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (cond
    [(string? lst) (substring lst start end)]
    [(vector? lst) (vector->list (vector-copy lst start end))]
    [else (take (drop lst start) (- end start))]))

(define (slice seq start end)
  (define len (cond [(string? seq) (string-length seq)] [(vector? seq) (vector-length seq)] [(list? seq) (length seq)] [else 0]))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (cond
    [(string? seq) (substring seq s e)]
    [(vector? seq) (vector-copy seq s e)]
    [else (sublist seq s e)]))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (appendv a b)
  (cond
    [(vector? a) (vector-append a (cond [(vector? b) b] [(list? b) (list->vector b)] [else (vector b)]))]
    [(list? a) (append a (cond [(list? b) b] [(vector? b) (vector->list b)] [else (list b)]))]
    [else (append a b)]))
(define (safe-index lst idx) (let ([i (int idx)]) (cond [(list? lst) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) 0)] [(vector? lst) (if (and (>= i 0) (< i (vector-length lst))) (vector-ref lst i) 0)] [(string? lst) (if (and (>= i 0) (< i (string-length lst))) (substring lst i (add1 i)) "")] [else 0])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_ord s) (char->integer (string-ref s 0)))
(define (read_file path)
  (define p path)
  (let ([root (getenv "MOCHI_ROOT")])
    (when (and root (not (file-exists? p)))
      (set! p (path->string (build-path root _data_dir path)))))
  (with-input-from-file p port->string))
(define (list-set lst idx val)
  (define i (int idx))
  (cond
    [(vector? lst) (when (< i (vector-length lst)) (vector-set! lst i val)) lst]
    [else
     (define len (length lst))
     (cond
       [(>= i len) (append lst (make-list (- i len) '()) (list val))]
       [(zero? i) (cons val (cdr lst))]
       [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))])]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define seed 1)
(define (rand)
  (let/ec _return (begin
(set! seed (modulo (let ([__l (* seed 1103515245)] [__r 12345]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2147483648))
(_return seed)
))
)
(define (random)
  (let/ec _return (begin
(_return (/ (* 1.0 (rand)) 2147483648.0))
))
)
(define (expApprox x)
  (let/ec _return (begin
(define y x)
(define is_neg #f)
(if (let ([__l x] [__r 0.0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(set! is_neg #t)
(set! y (- x))
) (void))
(define term 1.0)
(define sum 1.0)
(define n 1)
(let/ec _break (let loop ()
  (if (let ([__l n] [__r 30]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! term (/ (* term y) (exact->inexact n)))
      (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! n (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(if is_neg (let ()
(_return (/ 1.0 sum))
) (void))
(_return sum)
))
)
(define (sigmoid z)
  (let/ec _return (begin
(_return (/ 1.0 (let ([__l 1.0] [__r (expApprox (- z))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (sigmoid_vec v)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not v) 0] [(string? v) (string-length v)] [(vector? v) (vector-length v)] [(hash? v) (hash-count v)] [(list? v) (length v)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! res (appendv (or res (vector)) (sigmoid (if v (if (hash? v) (hash-ref v i #f) (safe-index v (int i))) #f))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (sigmoid_derivative out)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not out) 0] [(string? out) (string-length out)] [(vector? out) (vector-length out)] [(hash? out) (hash-count out)] [(list? out) (length out)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define val (if out (if (hash? out) (hash-ref out i #f) (safe-index out (int i))) #f))
      (set! res (appendv (or res (vector)) (vector (* val (- 1.0 val)))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (random_vector n)
  (let/ec _return (begin
(define v (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r n]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! v (appendv (or v (vector)) (- (random) 0.5)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return v)
))
)
(define (random_matrix r c)
  (let/ec _return (begin
(define m (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r r]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! m (appendv (or m (vector)) (random_vector c)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return m)
))
)
(define (matvec mat vec)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not mat) 0] [(string? mat) (string-length mat)] [(vector? mat) (vector-length mat)] [(hash? mat) (hash-count mat)] [(list? mat) (length mat)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define s 0.0)
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not vec) 0] [(string? vec) (string-length vec)] [(vector? vec) (vector-length vec)] [(hash? vec) (hash-count vec)] [(list? vec) (length vec)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! s (let ([__l s] [__r (* (if (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) j #f) (safe-index (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) (int j))) #f) (if vec (if (hash? vec) (hash-ref vec j #f) (safe-index vec (int j))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! res (appendv (or res (vector)) (vector s)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (matTvec mat vec)
  (let/ec _return (begin
(define cols (cond [(not (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f)) 0] [(string? (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f))] [(vector? (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f)) (vector-length (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f))] [(list? (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f)) (length (if mat (if (hash? mat) (hash-ref mat 0 #f) (safe-index mat (int 0))) #f))] [else 0]))
(define res (vector))
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r cols]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define s 0.0)
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not mat) 0] [(string? mat) (string-length mat)] [(vector? mat) (vector-length mat)] [(hash? mat) (hash-count mat)] [(list? mat) (length mat)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! s (let ([__l s] [__r (* (if (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) j #f) (safe-index (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) (int j))) #f) (if vec (if (hash? vec) (hash-ref vec i #f) (safe-index vec (int i))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! res (appendv (or res (vector)) (vector s)))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (vec_sub a b)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not a) 0] [(string? a) (string-length a)] [(vector? a) (vector-length a)] [(hash? a) (hash-count a)] [(list? a) (length a)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! res (appendv (or res (vector)) (vector (- (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (if b (if (hash? b) (hash-ref b i #f) (safe-index b (int i))) #f)))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (vec_mul a b)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not a) 0] [(string? a) (string-length a)] [(vector? a) (vector-length a)] [(hash? a) (hash-count a)] [(list? a) (length a)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! res (appendv (or res (vector)) (vector (* (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (if b (if (hash? b) (hash-ref b i #f) (safe-index b (int i))) #f)))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (vec_scalar_mul v s)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not v) 0] [(string? v) (string-length v)] [(vector? v) (vector-length v)] [(hash? v) (hash-count v)] [(list? v) (length v)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! res (appendv (or res (vector)) (vector (* (if v (if (hash? v) (hash-ref v i #f) (safe-index v (int i))) #f) s))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (outer a b)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not a) 0] [(string? a) (string-length a)] [(vector? a) (vector-length a)] [(hash? a) (hash-count a)] [(list? a) (length a)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (vector))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not b) 0] [(string? b) (string-length b)] [(vector? b) (vector-length b)] [(hash? b) (hash-count b)] [(list? b) (length b)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! row (appendv (or row (vector)) (vector (* (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (if b (if (hash? b) (hash-ref b j #f) (safe-index b (int j))) #f)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! res (appendv (or res (vector)) (vector row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (mat_scalar_mul mat s)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not mat) 0] [(string? mat) (string-length mat)] [(vector? mat) (vector-length mat)] [(hash? mat) (hash-count mat)] [(list? mat) (length mat)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (vector))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) 0] [(string? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f))] [(vector? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (vector-length (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f))] [(list? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (length (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f))] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! row (appendv (or row (vector)) (vector (* (if (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) j #f) (safe-index (if mat (if (hash? mat) (hash-ref mat i #f) (safe-index mat (int i))) #f) (int j))) #f) s))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! res (appendv (or res (vector)) (vector row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (mat_sub a b)
  (let/ec _return (begin
(define res (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not a) 0] [(string? a) (string-length a)] [(vector? a) (vector-length a)] [(hash? a) (hash-count a)] [(list? a) (length a)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (vector))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) 0] [(string? (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) (string-length (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f))] [(vector? (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) (vector-length (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f))] [(hash? (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) (hash-count (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f))] [(list? (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) (length (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f))] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! row (appendv (or row (vector)) (vector (- (if (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (if (hash? (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) j #f) (safe-index (if a (if (hash? a) (hash-ref a i #f) (safe-index a (int i))) #f) (int j))) #f) (if (if b (if (hash? b) (hash-ref b i #f) (safe-index b (int i))) #f) (if (hash? (if b (if (hash? b) (hash-ref b i #f) (safe-index b (int i))) #f)) (hash-ref (if b (if (hash? b) (hash-ref b i #f) (safe-index b (int i))) #f) j #f) (safe-index (if b (if (hash? b) (hash-ref b i #f) (safe-index b (int i))) #f) (int j))) #f)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! res (appendv (or res (vector)) (vector row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (init_layer units back_units lr)
  (let/ec _return (begin
(_return (let ([h (make-hash)]) (hash-set! h "units" units) (hash-set! h "weight" (random_matrix units back_units)) (hash-set! h "bias" (random_vector units)) (hash-set! h "output" (vector)) (hash-set! h "xdata" (vector)) (hash-set! h "learn_rate" lr) h))
))
)
(define (forward layers x)
  (let/ec _return (begin
(define data x)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not layers) 0] [(string? layers) (string-length layers)] [(vector? layers) (vector-length layers)] [(hash? layers) (hash-count layers)] [(list? layers) (length layers)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define layer (if layers (if (hash? layers) (hash-ref layers i #f) (safe-index layers (int i))) #f))
      (if (hash? layer) (hash-set! layer "xdata" data) (begin (set! layer (make-hash)) (hash-set! layer "xdata" data)))
      (if (equal? i 0) (let ()
(if (hash? layer) (hash-set! layer "output" data) (begin (set! layer (make-hash)) (hash-set! layer "output" data)))
) (let ()
(define z (vec_sub (matvec (if layer (hash-ref layer "weight" #f) #f) data) (if layer (hash-ref layer "bias" #f) #f)))
(if (hash? layer) (hash-set! layer "output" (sigmoid_vec z)) (begin (set! layer (make-hash)) (hash-set! layer "output" (sigmoid_vec z))))
(set! data (if layer (hash-ref layer "output" #f) #f))
))
      (vector-set! layers (int i) layer)
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return layers)
))
)
(define (backward layers grad)
  (let/ec _return (begin
(define g grad)
(define i (- (cond [(not layers) 0] [(string? layers) (string-length layers)] [(vector? layers) (vector-length layers)] [(hash? layers) (hash-count layers)] [(list? layers) (length layers)] [else 0]) 1))
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 0]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (begin
    (let/ec _cont
      (define layer (if layers (if (hash? layers) (hash-ref layers i #f) (safe-index layers (int i))) #f))
      (define deriv (sigmoid_derivative (if layer (hash-ref layer "output" #f) #f)))
      (define delta (vec_mul g deriv))
      (define grad_w (outer delta (if layer (hash-ref layer "xdata" #f) #f)))
      (if (hash? layer) (hash-set! layer "weight" (mat_sub (if layer (hash-ref layer "weight" #f) #f) (mat_scalar_mul grad_w (if layer (hash-ref layer "learn_rate" #f) #f)))) (begin (set! layer (make-hash)) (hash-set! layer "weight" (mat_sub (if layer (hash-ref layer "weight" #f) #f) (mat_scalar_mul grad_w (if layer (hash-ref layer "learn_rate" #f) #f))))))
      (if (hash? layer) (hash-set! layer "bias" (vec_sub (if layer (hash-ref layer "bias" #f) #f) (vec_scalar_mul delta (if layer (hash-ref layer "learn_rate" #f) #f)))) (begin (set! layer (make-hash)) (hash-set! layer "bias" (vec_sub (if layer (hash-ref layer "bias" #f) #f) (vec_scalar_mul delta (if layer (hash-ref layer "learn_rate" #f) #f))))))
      (set! g (matTvec (if layer (hash-ref layer "weight" #f) #f) delta))
      (vector-set! layers (int i) layer)
      (set! i (- i 1))
    )
    (loop)) (void))))
(_return layers)
))
)
(define (calc_loss y yhat)
  (let/ec _return (begin
(define s 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not y) 0] [(string? y) (string-length y)] [(vector? y) (vector-length y)] [(hash? y) (hash-count y)] [(list? y) (length y)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define d (- (if y (if (hash? y) (hash-ref y i #f) (safe-index y (int i))) #f) (if yhat (if (hash? yhat) (hash-ref yhat i #f) (safe-index yhat (int i))) #f)))
      (set! s (let ([__l s] [__r (* d d)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return s)
))
)
(define (calc_gradient y yhat)
  (let/ec _return (begin
(define g (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not y) 0] [(string? y) (string-length y)] [(vector? y) (vector-length y)] [(hash? y) (hash-count y)] [(list? y) (length y)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! g (appendv (or g (vector)) (vector (* 2.0 (- (if yhat (if (hash? yhat) (hash-ref yhat i #f) (safe-index yhat (int i))) #f) (if y (if (hash? y) (hash-ref y i #f) (safe-index y (int i))) #f))))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return g)
))
)
(define (train layers xdata ydata rounds acc)
  (let/ec _return (begin
(define r 0)
(let/ec _break (let loop ()
  (if (let ([__l r] [__r rounds]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xdata) 0] [(string? xdata) (string-length xdata)] [(vector? xdata) (vector-length xdata)] [(hash? xdata) (hash-count xdata)] [(list? xdata) (length xdata)] [else 0])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! layers (forward layers (if xdata (if (hash? xdata) (hash-ref xdata i #f) (safe-index xdata (int i))) #f)))
      (define out (if (if layers (if (hash? layers) (hash-ref layers (- (cond [(not layers) 0] [(string? layers) (string-length layers)] [(vector? layers) (vector-length layers)] [(hash? layers) (hash-count layers)] [(list? layers) (length layers)] [else 0]) 1) #f) (safe-index layers (int (- (cond [(not layers) 0] [(string? layers) (string-length layers)] [(vector? layers) (vector-length layers)] [(hash? layers) (hash-count layers)] [(list? layers) (length layers)] [else 0]) 1)))) #f) (hash-ref (if layers (if (hash? layers) (hash-ref layers (- (cond [(not layers) 0] [(string? layers) (string-length layers)] [(vector? layers) (vector-length layers)] [(hash? layers) (hash-count layers)] [(list? layers) (length layers)] [else 0]) 1) #f) (safe-index layers (int (- (cond [(not layers) 0] [(string? layers) (string-length layers)] [(vector? layers) (vector-length layers)] [(hash? layers) (hash-count layers)] [(list? layers) (length layers)] [else 0]) 1)))) #f) "output" #f) #f))
      (define grad (calc_gradient (if ydata (if (hash? ydata) (hash-ref ydata i #f) (safe-index ydata (int i))) #f) out))
      (set! layers (backward layers grad))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return 0.0)
))
)
(define (create_data)
  (let/ec _return (begin
(define x (vector))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 10]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! x (appendv (or x (vector)) (random_vector 10)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define y (vector (vector 0.8 0.4) (vector 0.4 0.3) (vector 0.34 0.45) (vector 0.67 0.32) (vector 0.88 0.67) (vector 0.78 0.77) (vector 0.55 0.66) (vector 0.55 0.43) (vector 0.54 0.1) (vector 0.1 0.5)))
(_return (let ([h (make-hash)]) (hash-set! h "x" x) (hash-set! h "y" y) h))
))
)
(define (main)
  (let/ec _return (begin
(define data (create_data))
(define x (if data (hash-ref data "x" #f) #f))
(define y (if data (hash-ref data "y" #f) #f))
(define layers (vector))
(set! layers (appendv (or layers (vector)) (init_layer 10 0 0.3)))
(set! layers (appendv (or layers (vector)) (init_layer 20 10 0.3)))
(set! layers (appendv (or layers (vector)) (init_layer 30 20 0.3)))
(set! layers (appendv (or layers (vector)) (init_layer 2 30 0.3)))
(define final_mse (train layers x y 100 0.01))
(displayln (to-string final_mse))
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
