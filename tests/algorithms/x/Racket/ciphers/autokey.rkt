;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define LOWER "abcdefghijklmnopqrstuvwxyz")
(define UPPER "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(define (to_lowercase s)
  (let/ec _return (begin
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (define c (substring s i (+ i 1)))
    (define j 0)
    (define found #f)
    (let/ec _break (let loop ()
  (if (< j 26) (let/ec _cont
    (if (string=? c (substring UPPER j (+ j 1))) (let ()
(set! res (string-append res (substring LOWER j (+ j 1))))
(set! found #t)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (not found) (let ()
(set! res (string-append res c))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (char_index c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i 26) (let/ec _cont
    (if (string=? c (substring LOWER i (+ i 1))) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (index_char i)
  (let/ec _return (begin
(_return (substring LOWER i (+ i 1)))
))
)
(define (encrypt plaintext key)
  (let/ec _return (begin
(if (equal? (cond [(string? plaintext) (string-length plaintext)] [(hash? plaintext) (hash-count plaintext)] [else (length plaintext)]) 0) (let ()
(panic "plaintext is empty")
) (void))
(if (equal? (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]) 0) (let ()
(panic "key is empty")
) (void))
(define full_key (string-append key plaintext))
(set! plaintext (to_lowercase plaintext))
(set! full_key (to_lowercase full_key))
(define p_i 0)
(define k_i 0)
(define ciphertext "")
(let/ec _break (let loop ()
  (if (< p_i (cond [(string? plaintext) (string-length plaintext)] [(hash? plaintext) (hash-count plaintext)] [else (length plaintext)])) (let/ec _cont
    (define p_char (substring plaintext p_i (+ p_i 1)))
    (define p_idx (char_index p_char))
    (if (< p_idx 0) (let ()
(set! ciphertext (string-append ciphertext p_char))
(set! p_i (let ([__l p_i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(define k_char (substring full_key k_i (+ k_i 1)))
(define k_idx (char_index k_char))
(if (< k_idx 0) (let ()
(set! k_i (let ([__l k_i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(define c_idx (modulo (let ([__l p_idx] [__r k_idx]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 26))
(set! ciphertext (string-append ciphertext (index_char c_idx)))
(set! k_i (let ([__l k_i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! p_i (let ([__l p_i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
))
    (loop)) (void))))
(_return ciphertext)
))
)
(define (decrypt ciphertext key)
  (let/ec _return (begin
(if (equal? (cond [(string? ciphertext) (string-length ciphertext)] [(hash? ciphertext) (hash-count ciphertext)] [else (length ciphertext)]) 0) (let ()
(panic "ciphertext is empty")
) (void))
(if (equal? (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]) 0) (let ()
(panic "key is empty")
) (void))
(define current_key (to_lowercase key))
(define c_i 0)
(define k_i 0)
(define plaintext "")
(let/ec _break (let loop ()
  (if (< c_i (cond [(string? ciphertext) (string-length ciphertext)] [(hash? ciphertext) (hash-count ciphertext)] [else (length ciphertext)])) (let/ec _cont
    (define c_char (substring ciphertext c_i (+ c_i 1)))
    (define c_idx (char_index c_char))
    (if (< c_idx 0) (let ()
(set! plaintext (string-append plaintext c_char))
) (let ()
(define k_char (substring current_key k_i (+ k_i 1)))
(define k_idx (char_index k_char))
(define p_idx (modulo (let ([__l (- c_idx k_idx)] [__r 26]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 26))
(define p_char (index_char p_idx))
(set! plaintext (string-append plaintext p_char))
(set! current_key (string-append current_key p_char))
(set! k_i (let ([__l k_i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
    (set! c_i (let ([__l c_i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return plaintext)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln (encrypt "hello world" "coffee"))
(displayln (decrypt "jsqqs avvwo" "coffee"))
(displayln (encrypt "coffee is good as python" "TheAlgorithms"))
(displayln (decrypt "vvjfpk wj ohvp su ddylsv" "TheAlgorithms"))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
