;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define (default_alphabet)
  (let/ec _return (begin
(_return (list "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"))
))
)
(define (default_frequencies)
  (let/ec _return (begin
(_return (hash "a" 0.08497 "b" 0.01492 "c" 0.02202 "d" 0.04253 "e" 0.11162 "f" 0.02228 "g" 0.02015 "h" 0.06094 "i" 0.07546 "j" 0.00153 "k" 0.01292 "l" 0.04025 "m" 0.02406 "n" 0.06749 "o" 0.07507 "p" 0.01929 "q" 0.00095 "r" 0.07587 "s" 0.06327 "t" 0.09356 "u" 0.02758 "v" 0.00978 "w" 0.0256 "x" 0.0015 "y" 0.01994 "z" 0.00077))
))
)
(define (index_of xs ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) ch) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (count_char s ch)
  (let/ec _return (begin
(define count 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (if (string=? (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ch) (let ()
(set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return count)
))
)
(define (decrypt_caesar_with_chi_squared ciphertext cipher_alphabet frequencies_dict case_sensitive)
  (let/ec _return (begin
(define alphabet_letters cipher_alphabet)
(if (equal? (cond [(string? alphabet_letters) (string-length alphabet_letters)] [(hash? alphabet_letters) (hash-count alphabet_letters)] [else (length alphabet_letters)]) 0) (let ()
(set! alphabet_letters (default_alphabet))
) (void))
(define frequencies frequencies_dict)
(if (equal? (cond [(string? frequencies) (string-length frequencies)] [(hash? frequencies) (hash-count frequencies)] [else (length frequencies)]) 0) (let ()
(set! frequencies (default_frequencies))
) (void))
(if (not case_sensitive) (let ()
(set! ciphertext (lower ciphertext))
) (void))
(define best_shift 0)
(define best_chi 0.0)
(define best_text "")
(define shift 0)
(let/ec _break (let loop ()
  (if (< shift (cond [(string? alphabet_letters) (string-length alphabet_letters)] [(hash? alphabet_letters) (hash-count alphabet_letters)] [else (length alphabet_letters)])) (let/ec _cont
    (define decrypted "")
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i (cond [(string? ciphertext) (string-length ciphertext)] [(hash? ciphertext) (hash-count ciphertext)] [else (length ciphertext)])) (let/ec _cont
    (define ch (slice ciphertext i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define idx (index_of alphabet_letters (lower ch)))
    (if (>= idx 0) (let ()
(define m (cond [(string? alphabet_letters) (string-length alphabet_letters)] [(hash? alphabet_letters) (hash-count alphabet_letters)] [else (length alphabet_letters)]))
(define new_idx (modulo (- idx shift) m))
(if (< new_idx 0) (let ()
(set! new_idx (let ([__l new_idx] [__r m]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(define new_char (if alphabet_letters (if (hash? alphabet_letters) (hash-ref alphabet_letters new_idx #f) (list-ref alphabet_letters (int new_idx))) #f))
(if (and case_sensitive (not (equal? ch (lower ch)))) (let ()
(set! decrypted (string-append decrypted (upper new_char)))
) (let ()
(set! decrypted (string-append decrypted new_char))
))
) (let ()
(set! decrypted (string-append decrypted ch))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (define chi 0.0)
    (define lowered (if case_sensitive (lower decrypted) decrypted))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? alphabet_letters) (string-length alphabet_letters)] [(hash? alphabet_letters) (hash-count alphabet_letters)] [else (length alphabet_letters)])) (let/ec _cont
    (define letter (if alphabet_letters (if (hash? alphabet_letters) (hash-ref alphabet_letters j #f) (list-ref alphabet_letters (int j))) #f))
    (define occ (count_char lowered letter))
    (if (> occ 0) (let ()
(define occf (exact->inexact occ))
(define expected (* (if frequencies (hash-ref frequencies letter #f) #f) occf))
(define diff (- occf expected))
(set! chi (let ([__l chi] [__r (* (/ (* diff diff) expected) occf)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (or (equal? shift 0) (< chi best_chi)) (let ()
(set! best_shift shift)
(set! best_chi chi)
(set! best_text decrypted)
) (void))
    (set! shift (let ([__l shift] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (hash "shift" best_shift "chi" best_chi "decoded" best_text))
))
)
(define r1 (decrypt_caesar_with_chi_squared "dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!" (list) (hash) #f))
(define r2 (decrypt_caesar_with_chi_squared "crybd cdbsxq" (list) (hash) #f))
(define r3 (decrypt_caesar_with_chi_squared "Crybd Cdbsxq" (list) (hash) #t))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln (string-append (string-append (string-append (string-append (format "~a" (if r1 (hash-ref r1 "shift" #f) #f)) ", ") (format "~a" (if r1 (hash-ref r1 "chi" #f) #f))) ", ") (if r1 (hash-ref r1 "decoded" #f) #f)))
(displayln (string-append (string-append (string-append (string-append (format "~a" (if r2 (hash-ref r2 "shift" #f) #f)) ", ") (format "~a" (if r2 (hash-ref r2 "chi" #f) #f))) ", ") (if r2 (hash-ref r2 "decoded" #f) #f)))
(displayln (string-append (string-append (string-append (string-append (format "~a" (if r3 (hash-ref r3 "shift" #f) #f)) ", ") (format "~a" (if r3 (hash-ref r3 "chi" #f) #f))) ", ") (if r3 (hash-ref r3 "decoded" #f) #f)))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
