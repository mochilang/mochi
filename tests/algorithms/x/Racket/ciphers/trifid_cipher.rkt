;; Generated by Mochi 0.10.59 on 2025-08-06 22:15 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define triagrams (list "111" "112" "113" "121" "122" "123" "131" "132" "133" "211" "212" "213" "221" "222" "223" "231" "232" "233" "311" "312" "313" "321" "322" "323" "331" "332" "333"))
(define (remove_spaces s)
  (let/ec _return (begin
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (define c (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (not (string=? c " ")) (let ()
(set! res (string-append res c))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (char_to_trigram ch alphabet)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? alphabet) (string-length alphabet)] [(hash? alphabet) (hash-count alphabet)] [else (length alphabet)])) (let/ec _cont
    (if (string=? (slice alphabet i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ch) (let ()
(_return (if triagrams (if (hash? triagrams) (hash-ref triagrams i #f) (list-ref triagrams (int i))) #f))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return "")
))
)
(define (trigram_to_char tri alphabet)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? triagrams) (string-length triagrams)] [(hash? triagrams) (hash-count triagrams)] [else (length triagrams)])) (let/ec _cont
    (if (string=? (if triagrams (if (hash? triagrams) (hash-ref triagrams i #f) (list-ref triagrams (int i))) #f) tri) (let ()
(_return (slice alphabet i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return "")
))
)
(define (encrypt_part part alphabet)
  (let/ec _return (begin
(define one "")
(define two "")
(define three "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? part) (string-length part)] [(hash? part) (hash-count part)] [else (length part)])) (let/ec _cont
    (define tri (char_to_trigram (slice part i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) alphabet))
    (set! one (string-append one (slice tri 0 1)))
    (set! two (string-append two (slice tri 1 2)))
    (set! three (string-append three (slice tri 2 3)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (string-append (string-append one two) three))
))
)
(define (encrypt_message message alphabet period)
  (let/ec _return (begin
(define msg (remove_spaces message))
(define alpha (remove_spaces alphabet))
(if (not (equal? (cond [(string? alpha) (string-length alpha)] [(hash? alpha) (hash-count alpha)] [else (length alpha)]) 27)) (let ()
(_return "")
) (void))
(define encrypted_numeric "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)])) (let/ec _cont
    (define end (let ([__l i] [__r period]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (> end (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)])) (let ()
(set! end (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)]))
) (void))
    (define part (slice msg i end))
    (set! encrypted_numeric (string-append encrypted_numeric (encrypt_part part alpha)))
    (set! i (let ([__l i] [__r period]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define encrypted "")
(define j 0)
(let/ec _break (let loop ()
  (if (< j (cond [(string? encrypted_numeric) (string-length encrypted_numeric)] [(hash? encrypted_numeric) (hash-count encrypted_numeric)] [else (length encrypted_numeric)])) (let/ec _cont
    (define tri (slice encrypted_numeric j (let ([__l j] [__r 3]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (set! encrypted (string-append encrypted (trigram_to_char tri alpha)))
    (set! j (let ([__l j] [__r 3]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return encrypted)
))
)
(define (decrypt_part part alphabet)
  (let/ec _return (begin
(define converted "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? part) (string-length part)] [(hash? part) (hash-count part)] [else (length part)])) (let/ec _cont
    (define tri (char_to_trigram (slice part i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) alphabet))
    (set! converted (string-append converted tri))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define result (list))
(define tmp "")
(define j 0)
(let/ec _break (let loop ()
  (if (< j (cond [(string? converted) (string-length converted)] [(hash? converted) (hash-count converted)] [else (length converted)])) (let/ec _cont
    (set! tmp (string-append tmp (slice converted j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (if (equal? (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)]) (cond [(string? part) (string-length part)] [(hash? part) (hash-count part)] [else (length part)])) (let ()
(set! result (append result (list tmp)))
(set! tmp "")
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (decrypt_message message alphabet period)
  (let/ec _return (begin
(define msg (remove_spaces message))
(define alpha (remove_spaces alphabet))
(if (not (equal? (cond [(string? alpha) (string-length alpha)] [(hash? alpha) (hash-count alpha)] [else (length alpha)]) 27)) (let ()
(_return "")
) (void))
(define decrypted_numeric (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)])) (let/ec _cont
    (define end (let ([__l i] [__r period]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (> end (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)])) (let ()
(set! end (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)]))
) (void))
    (define part (slice msg i end))
    (define groups (decrypt_part part alpha))
    (define k 0)
    (let/ec _break (let loop ()
  (if (< k (cond [(string? (if groups (if (hash? groups) (hash-ref groups 0 #f) (list-ref groups (int 0))) #f)) (string-length (if groups (if (hash? groups) (hash-ref groups 0 #f) (list-ref groups (int 0))) #f))] [(hash? (if groups (if (hash? groups) (hash-ref groups 0 #f) (list-ref groups (int 0))) #f)) (hash-count (if groups (if (hash? groups) (hash-ref groups 0 #f) (list-ref groups (int 0))) #f))] [else (length (if groups (if (hash? groups) (hash-ref groups 0 #f) (list-ref groups (int 0))) #f))])) (let/ec _cont
    (define tri (let ([__l (let ([__l (slice (if groups (if (hash? groups) (hash-ref groups 0 #f) (list-ref groups (int 0))) #f) k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))] [__r (slice (if groups (if (hash? groups) (hash-ref groups 1 #f) (list-ref groups (int 1))) #f) k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (slice (if groups (if (hash? groups) (hash-ref groups 2 #f) (list-ref groups (int 2))) #f) k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! decrypted_numeric (append decrypted_numeric (list tri)))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r period]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define decrypted "")
(define j 0)
(let/ec _break (let loop ()
  (if (< j (cond [(string? decrypted_numeric) (string-length decrypted_numeric)] [(hash? decrypted_numeric) (hash-count decrypted_numeric)] [else (length decrypted_numeric)])) (let/ec _cont
    (set! decrypted (string-append decrypted (trigram_to_char (if decrypted_numeric (if (hash? decrypted_numeric) (hash-ref decrypted_numeric j #f) (list-ref decrypted_numeric (int j))) #f) alpha)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return decrypted)
))
)
(define (main)
  (let/ec _return (begin
(define msg "DEFEND THE EAST WALL OF THE CASTLE.")
(define alphabet "EPSDUCVWYM.ZLKXNBTFGORIJHAQ")
(define encrypted (encrypt_message msg alphabet 5))
(define decrypted (decrypt_message encrypted alphabet 5))
(displayln (string-append "Encrypted: " encrypted))
(displayln (string-append "Decrypted: " decrypted))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
