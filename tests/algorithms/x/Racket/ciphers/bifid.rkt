;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define SQUARE (list (list "a" "b" "c" "d" "e") (list "f" "g" "h" "i" "k") (list "l" "m" "n" "o" "p") (list "q" "r" "s" "t" "u") (list "v" "w" "x" "y" "z")))
(define (index_of s ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (if (string=? (substring s i (+ i 1)) ch) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (to_lower_without_spaces message replace_j)
  (let/ec _return (begin
(define upper_ "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(define lower_ "abcdefghijklmnopqrstuvwxyz")
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? message) (string-length message)] [(hash? message) (hash-count message)] [else (length message)])) (let/ec _cont
    (define ch (substring message i (+ i 1)))
    (define pos (index_of upper_ ch))
    (if (>= pos 0) (let ()
(set! ch (substring lower_ pos (+ pos 1)))
) (void))
    (if (not (string=? ch " ")) (let ()
(if (and replace_j (string=? ch "j")) (let ()
(set! ch "i")
) (void))
(set! res (string-append res ch))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (letter_to_numbers letter)
  (let/ec _return (begin
(define r 0)
(let/ec _break (let loop ()
  (if (< r (cond [(string? SQUARE) (string-length SQUARE)] [(hash? SQUARE) (hash-count SQUARE)] [else (length SQUARE)])) (let/ec _cont
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c (cond [(string? (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f)) (string-length (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f))] [(hash? (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f)) (hash-count (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f))] [else (length (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f))])) (let/ec _cont
    (if (string=? (if (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f) (if (hash? (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f)) (hash-ref (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f) c #f) (list-ref (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE r #f) (list-ref SQUARE (int r))) #f) (int c))) #f) letter) (let ()
(_return (list (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
) (void))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (list 0 0))
))
)
(define (numbers_to_letter row col)
  (let/ec _return (begin
(_return (if (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE (- row 1) #f) (list-ref SQUARE (int (- row 1)))) #f) (if (hash? (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE (- row 1) #f) (list-ref SQUARE (int (- row 1)))) #f)) (hash-ref (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE (- row 1) #f) (list-ref SQUARE (int (- row 1)))) #f) (- col 1) #f) (list-ref (if SQUARE (if (hash? SQUARE) (hash-ref SQUARE (- row 1) #f) (list-ref SQUARE (int (- row 1)))) #f) (int (- col 1)))) #f))
))
)
(define (encode message)
  (let/ec _return (begin
(define clean (to_lower_without_spaces message #t))
(define l (cond [(string? clean) (string-length clean)] [(hash? clean) (hash-count clean)] [else (length clean)]))
(define rows (list))
(define cols (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (define nums (letter_to_numbers (substring clean i (+ i 1))))
    (set! rows (append rows (list (if nums (if (hash? nums) (hash-ref nums 0 #f) (list-ref nums (int 0))) #f))))
    (set! cols (append cols (list (if nums (if (hash? nums) (hash-ref nums 1 #f) (list-ref nums (int 1))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define seq (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (set! seq (append seq (list (if rows (if (hash? rows) (hash-ref rows i #f) (list-ref rows (int i))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (set! seq (append seq (list (if cols (if (hash? cols) (hash-ref cols i #f) (list-ref cols (int i))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define encoded "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (define r (if seq (if (hash? seq) (hash-ref seq (* 2 i) #f) (list-ref seq (int (* 2 i)))) #f))
    (define c (if seq (if (hash? seq) (hash-ref seq (let ([__l (* 2 i)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref seq (int (let ([__l (* 2 i)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
    (set! encoded (string-append encoded (numbers_to_letter r c)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return encoded)
))
)
(define (decode message)
  (let/ec _return (begin
(define clean (to_lower_without_spaces message #f))
(define l (cond [(string? clean) (string-length clean)] [(hash? clean) (hash-count clean)] [else (length clean)]))
(define first (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (define nums (letter_to_numbers (substring clean i (+ i 1))))
    (set! first (append first (list (if nums (if (hash? nums) (hash-ref nums 0 #f) (list-ref nums (int 0))) #f))))
    (set! first (append first (list (if nums (if (hash? nums) (hash-ref nums 1 #f) (list-ref nums (int 1))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define top (list))
(define bottom (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (set! top (append top (list (if first (if (hash? first) (hash-ref first i #f) (list-ref first (int i))) #f))))
    (set! bottom (append bottom (list (if first (if (hash? first) (hash-ref first (let ([__l i] [__r l]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref first (int (let ([__l i] [__r l]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define decoded "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i l) (let/ec _cont
    (define r (if top (if (hash? top) (hash-ref top i #f) (list-ref top (int i))) #f))
    (define c (if bottom (if (hash? bottom) (hash-ref bottom i #f) (list-ref bottom (int i))) #f))
    (set! decoded (string-append decoded (numbers_to_letter r c)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return decoded)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln (encode "testmessage"))
(displayln (encode "Test Message"))
(displayln (encode "test j"))
(displayln (encode "test i"))
(displayln (decode "qtltbdxrxlk"))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
