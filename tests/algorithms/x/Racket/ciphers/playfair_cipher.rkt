;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define (contains xs x)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) x) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (index_of xs x)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) x) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (prepare_input dirty)
  (let/ec _return (begin
(define letters "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(define upper_dirty (upper dirty))
(define filtered "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? upper_dirty) (string-length upper_dirty)] [(hash? upper_dirty) (hash-count upper_dirty)] [else (length upper_dirty)])) (let/ec _cont
    (define c (slice upper_dirty i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (string-contains? letters c) (let ()
(set! filtered (string-append filtered c))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(if (< (cond [(string? filtered) (string-length filtered)] [(hash? filtered) (hash-count filtered)] [else (length filtered)]) 2) (let ()
(_return filtered)
) (void))
(define clean "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (- (cond [(string? filtered) (string-length filtered)] [(hash? filtered) (hash-count filtered)] [else (length filtered)]) 1)) (let/ec _cont
    (define c1 (slice filtered i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define c2 (slice filtered (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (set! clean (string-append clean c1))
    (if (string=? c1 c2) (let ()
(set! clean (string-append clean "X"))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! clean (string-append clean (slice filtered (- (cond [(string? filtered) (string-length filtered)] [(hash? filtered) (hash-count filtered)] [else (length filtered)]) 1) (cond [(string? filtered) (string-length filtered)] [(hash? filtered) (hash-count filtered)] [else (length filtered)]))))
(if (equal? (modulo (cond [(string? clean) (string-length clean)] [(hash? clean) (hash-count clean)] [else (length clean)]) 2) 1) (let ()
(set! clean (string-append clean "X"))
) (void))
(_return clean)
))
)
(define (generate_table key)
  (let/ec _return (begin
(define alphabet "ABCDEFGHIKLMNOPQRSTUVWXYZ")
(define table (list))
(define upper_key (upper key))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? upper_key) (string-length upper_key)] [(hash? upper_key) (hash-count upper_key)] [else (length upper_key)])) (let/ec _cont
    (define c (slice upper_key i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (string-contains? alphabet c) (let ()
(if (not (member c table)) (let ()
(set! table (append table (list c)))
) (void))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? alphabet) (string-length alphabet)] [(hash? alphabet) (hash-count alphabet)] [else (length alphabet)])) (let/ec _cont
    (define c (slice alphabet i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (not (member c table)) (let ()
(set! table (append table (list c)))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return table)
))
)
(define (encode plaintext key)
  (let/ec _return (begin
(define table (generate_table key))
(define text (prepare_input plaintext))
(define cipher "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? text) (string-length text)] [(hash? text) (hash-count text)] [else (length text)])) (let/ec _cont
    (define c1 (slice text i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define c2 (slice text (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define idx1 (index_of table c1))
    (define idx2 (index_of table c2))
    (define row1 (quotient idx1 5))
    (define col1 (modulo idx1 5))
    (define row2 (quotient idx2 5))
    (define col2 (modulo idx2 5))
    (if (equal? row1 row2) (let ()
(set! cipher (string-append cipher (if table (if (hash? table) (hash-ref table (let ([__l (* row1 5)] [__r (modulo (let ([__l col1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row1 5)] [__r (modulo (let ([__l col1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
(set! cipher (string-append cipher (if table (if (hash? table) (hash-ref table (let ([__l (* row2 5)] [__r (modulo (let ([__l col2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row2 5)] [__r (modulo (let ([__l col2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
) (let ()
(if (equal? col1 col2) (let ()
(set! cipher (string-append cipher (if table (if (hash? table) (hash-ref table (let ([__l (* (modulo (let ([__l row1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* (modulo (let ([__l row1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
(set! cipher (string-append cipher (if table (if (hash? table) (hash-ref table (let ([__l (* (modulo (let ([__l row2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* (modulo (let ([__l row2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
) (let ()
(set! cipher (string-append cipher (if table (if (hash? table) (hash-ref table (let ([__l (* row1 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row1 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
(set! cipher (string-append cipher (if table (if (hash? table) (hash-ref table (let ([__l (* row2 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row2 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
))
))
    (set! i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return cipher)
))
)
(define (decode cipher key)
  (let/ec _return (begin
(define table (generate_table key))
(define plain "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? cipher) (string-length cipher)] [(hash? cipher) (hash-count cipher)] [else (length cipher)])) (let/ec _cont
    (define c1 (slice cipher i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define c2 (slice cipher (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define idx1 (index_of table c1))
    (define idx2 (index_of table c2))
    (define row1 (quotient idx1 5))
    (define col1 (modulo idx1 5))
    (define row2 (quotient idx2 5))
    (define col2 (modulo idx2 5))
    (if (equal? row1 row2) (let ()
(set! plain (string-append plain (if table (if (hash? table) (hash-ref table (let ([__l (* row1 5)] [__r (modulo (let ([__l col1] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row1 5)] [__r (modulo (let ([__l col1] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
(set! plain (string-append plain (if table (if (hash? table) (hash-ref table (let ([__l (* row2 5)] [__r (modulo (let ([__l col2] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row2 5)] [__r (modulo (let ([__l col2] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
) (let ()
(if (equal? col1 col2) (let ()
(set! plain (string-append plain (if table (if (hash? table) (hash-ref table (let ([__l (* (modulo (let ([__l row1] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* (modulo (let ([__l row1] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
(set! plain (string-append plain (if table (if (hash? table) (hash-ref table (let ([__l (* (modulo (let ([__l row2] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* (modulo (let ([__l row2] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 5) 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
) (let ()
(set! plain (string-append plain (if table (if (hash? table) (hash-ref table (let ([__l (* row1 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row1 5)] [__r col2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
(set! plain (string-append plain (if table (if (hash? table) (hash-ref table (let ([__l (* row2 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref table (int (let ([__l (* row2 5)] [__r col1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)))
))
))
    (set! i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return plain)
))
)
(define (main)
  (let/ec _return (begin
(displayln (string-join (map (lambda (x) (format "~a" x)) (list "Encoded:" (encode "BYE AND THANKS" "GREETING"))) " "))
(displayln (string-join (map (lambda (x) (format "~a" x)) (list "Decoded:" (decode "CXRBANRLBALQ" "GREETING"))) " "))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
