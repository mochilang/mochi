;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define UPPER "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(define LOWER "abcdefghijklmnopqrstuvwxyz")
(define (to_upper s)
  (let/ec _return (begin
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (define ch (substring s i (+ i 1)))
    (define j 0)
    (define found #f)
    (let/ec _break (let loop ()
  (if (< j 26) (let/ec _cont
    (if (string=? ch (substring LOWER j (+ j 1))) (let ()
(set! res (string-append res (substring UPPER j (+ j 1))))
(set! found #t)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (equal? found #f) (let ()
(set! res (string-append res ch))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (contains xs x)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) x) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (contains_char s ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (if (string=? (substring s i (+ i 1)) ch) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (get_value keys values key)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? keys) (string-length keys)] [(hash? keys) (hash-count keys)] [else (length keys)])) (let/ec _cont
    (if (string=? (if keys (if (hash? keys) (hash-ref keys i #f) (list-ref keys (int i))) #f) key) (let ()
(_return (if values (if (hash? values) (hash-ref values i #f) (list-ref values (int i))) #f))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (print_mapping keys values)
  (let/ec _return (begin
(define s "{")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? keys) (string-length keys)] [(hash? keys) (hash-count keys)] [else (length keys)])) (let/ec _cont
    (set! s (string-append (string-append (string-append (string-append (string-append s "'") (if keys (if (hash? keys) (hash-ref keys i #f) (list-ref keys (int i))) #f)) "': '") (if values (if (hash? values) (hash-ref values i #f) (list-ref values (int i))) #f)) "'"))
    (if (< (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (cond [(string? keys) (string-length keys)] [(hash? keys) (hash-count keys)] [else (length keys)])) (let ()
(set! s (string-append s ", "))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! s (string-append s "}"))
(displayln s)
))
)
(define (mixed_keyword keyword plaintext verbose)
  (let/ec _return (begin
(define alphabet UPPER)
(define keyword_u (to_upper keyword))
(define plaintext_u (to_upper plaintext))
(define unique (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? keyword_u) (string-length keyword_u)] [(hash? keyword_u) (hash-count keyword_u)] [else (length keyword_u)])) (let/ec _cont
    (define ch (substring keyword_u i (+ i 1)))
    (if (and (contains_char alphabet ch) (equal? (member ch unique) #f)) (let ()
(set! unique (append unique (list ch)))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define num_unique (cond [(string? unique) (string-length unique)] [(hash? unique) (hash-count unique)] [else (length unique)]))
(define shifted (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? unique) (string-length unique)] [(hash? unique) (hash-count unique)] [else (length unique)])) (let/ec _cont
    (set! shifted (append shifted (list (if unique (if (hash? unique) (hash-ref unique i #f) (list-ref unique (int i))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? alphabet) (string-length alphabet)] [(hash? alphabet) (hash-count alphabet)] [else (length alphabet)])) (let/ec _cont
    (define ch (substring alphabet i (+ i 1)))
    (if (equal? (member ch unique) #f) (let ()
(set! shifted (append shifted (list ch)))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define modified (list))
(define k 0)
(let/ec _break (let loop ()
  (if (< k (cond [(string? shifted) (string-length shifted)] [(hash? shifted) (hash-count shifted)] [else (length shifted)])) (let/ec _cont
    (define row (list))
    (define r 0)
    (let/ec _break (let loop ()
  (if (and (< r num_unique) (< (let ([__l k] [__r r]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (cond [(string? shifted) (string-length shifted)] [(hash? shifted) (hash-count shifted)] [else (length shifted)]))) (let/ec _cont
    (set! row (append row (list (if shifted (if (hash? shifted) (hash-ref shifted (let ([__l k] [__r r]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref shifted (int (let ([__l k] [__r r]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! modified (append modified (list row)))
    (set! k (let ([__l k] [__r num_unique]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define keys (list))
(define values (list))
(define column 0)
(define letter_index 0)
(let/ec _break (let loop ()
  (if (< column num_unique) (let/ec _cont
    (define row_idx 0)
    (let/ec _break (let loop ()
  (if (< row_idx (cond [(string? modified) (string-length modified)] [(hash? modified) (hash-count modified)] [else (length modified)])) (let/ec _cont
    (define row (if modified (if (hash? modified) (hash-ref modified row_idx #f) (list-ref modified (int row_idx))) #f))
    (if (<= (cond [(string? row) (string-length row)] [(hash? row) (hash-count row)] [else (length row)]) column) (let ()
(_break)
) (void))
    (set! keys (append keys (list (substring alphabet letter_index (+ letter_index 1)))))
    (set! values (append values (list (if row (if (hash? row) (hash-ref row column #f) (list-ref row (int column))) #f))))
    (set! letter_index (let ([__l letter_index] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! row_idx (let ([__l row_idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! column (let ([__l column] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(if verbose (let ()
(print_mapping keys values)
) (void))
(define result "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? plaintext_u) (string-length plaintext_u)] [(hash? plaintext_u) (hash-count plaintext_u)] [else (length plaintext_u)])) (let/ec _cont
    (define ch (substring plaintext_u i (+ i 1)))
    (define mapped (get_value keys values ch))
    (if (equal? mapped #f) (let ()
(set! result (string-append result ch))
) (let ()
(set! result (string-append result mapped))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln (mixed_keyword "college" "UNIVERSITY" #t))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
