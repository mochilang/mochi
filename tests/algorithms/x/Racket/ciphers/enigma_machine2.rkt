;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define abc "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(define low_abc "abcdefghijklmnopqrstuvwxyz")
(define rotor1 "EGZWVONAHDCLFQMSIPJBYUKXTR")
(define rotor2 "FOBHMDKEXQNRAULPGSJVTYICZW")
(define rotor3 "ZJXESIUQLHAVRMDOYGTNFWPBKC")
(define rotor4 "RMDJXFUWGISLHVTCQNKYPBEZOA")
(define rotor5 "SGLCPQWZHKXAREONTFBVIYJUDM")
(define rotor6 "HVSICLTYKQUBXDWAJZOMFGPREN")
(define rotor7 "RZWQHFMVDBKICJLNTUXAGYPSOE")
(define rotor8 "LFKIJODBEGAMQPXVUHYSTCZRWN")
(define rotor9 "KOAEGVDHXPQZMLFTYWJNBRCIUS")
(define reflector_pairs (list "AN" "BO" "CP" "DQ" "ER" "FS" "GT" "HU" "IV" "JW" "KX" "LY" "MZ"))
(define (list_contains xs x)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) x) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (index_in_string s ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (if (string=? (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ch) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (contains_char s ch)
  (let/ec _return (begin
(_return (>= (index_in_string s ch) 0))
))
)
(define (to_uppercase s)
  (let/ec _return (begin
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (define ch (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define idx (index_in_string low_abc ch))
    (if (>= idx 0) (let ()
(set! res (string-append res (slice abc idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (let ()
(set! res (string-append res ch))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (plugboard_map pb ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? pb) (string-length pb)] [(hash? pb) (hash-count pb)] [else (length pb)])) (let/ec _cont
    (define pair (if pb (if (hash? pb) (hash-ref pb i #f) (list-ref pb (int i))) #f))
    (define a (slice pair 0 1))
    (define b (slice pair 1 2))
    (if (string=? ch a) (let ()
(_return b)
) (void))
    (if (string=? ch b) (let ()
(_return a)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return ch)
))
)
(define (reflector_map ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? reflector_pairs) (string-length reflector_pairs)] [(hash? reflector_pairs) (hash-count reflector_pairs)] [else (length reflector_pairs)])) (let/ec _cont
    (define pair (if reflector_pairs (if (hash? reflector_pairs) (hash-ref reflector_pairs i #f) (list-ref reflector_pairs (int i))) #f))
    (define a (slice pair 0 1))
    (define b (slice pair 1 2))
    (if (string=? ch a) (let ()
(_return b)
) (void))
    (if (string=? ch b) (let ()
(_return a)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return ch)
))
)
(define (count_unique xs)
  (let/ec _return (begin
(define unique (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (not (list_contains unique (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f))) (let ()
(set! unique (append unique (list (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (cond [(string? unique) (string-length unique)] [(hash? unique) (hash-count unique)] [else (length unique)]))
))
)
(define (build_plugboard pbstring)
  (let/ec _return (begin
(if (equal? (cond [(string? pbstring) (string-length pbstring)] [(hash? pbstring) (hash-count pbstring)] [else (length pbstring)]) 0) (let ()
(_return (list))
) (void))
(if (not (equal? (modulo (cond [(string? pbstring) (string-length pbstring)] [(hash? pbstring) (hash-count pbstring)] [else (length pbstring)]) 2) 0)) (let ()
(panic (string-append (string-append "Odd number of symbols(" (format "~a" (cond [(string? pbstring) (string-length pbstring)] [(hash? pbstring) (hash-count pbstring)] [else (length pbstring)]))) ")"))
) (void))
(define pbstring_nospace "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? pbstring) (string-length pbstring)] [(hash? pbstring) (hash-count pbstring)] [else (length pbstring)])) (let/ec _cont
    (define ch (slice pbstring i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (not (string=? ch " ")) (let ()
(set! pbstring_nospace (string-append pbstring_nospace ch))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define seen (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? pbstring_nospace) (string-length pbstring_nospace)] [(hash? pbstring_nospace) (hash-count pbstring_nospace)] [else (length pbstring_nospace)])) (let/ec _cont
    (define ch (slice pbstring_nospace i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (not (contains_char abc ch)) (let ()
(panic (string-append (string-append "'" ch) "' not in list of symbols"))
) (void))
    (if (list_contains seen ch) (let ()
(panic (string-append (string-append "Duplicate symbol(" ch) ")"))
) (void))
    (set! seen (append seen (list ch)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define pb (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (- (cond [(string? pbstring_nospace) (string-length pbstring_nospace)] [(hash? pbstring_nospace) (hash-count pbstring_nospace)] [else (length pbstring_nospace)]) 1)) (let/ec _cont
    (define a (slice pbstring_nospace i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define b (slice pbstring_nospace (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (set! pb (append pb (list (string-append a b))))
    (set! i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return pb)
))
)
(define (validator rotpos rotsel pb)
  (let/ec _return (begin
(if (< (count_unique rotsel) 3) (let ()
(panic (string-append (string-append "Please use 3 unique rotors (not " (format "~a" (count_unique rotsel))) ")"))
) (void))
(if (not (equal? (cond [(string? rotpos) (string-length rotpos)] [(hash? rotpos) (hash-count rotpos)] [else (length rotpos)]) 3)) (let ()
(panic "Rotor position must have 3 values")
) (void))
(define r1 (if rotpos (if (hash? rotpos) (hash-ref rotpos 0 #f) (list-ref rotpos (int 0))) #f))
(define r2 (if rotpos (if (hash? rotpos) (hash-ref rotpos 1 #f) (list-ref rotpos (int 1))) #f))
(define r3 (if rotpos (if (hash? rotpos) (hash-ref rotpos 2 #f) (list-ref rotpos (int 2))) #f))
(if (not (and (< 0 r1) (<= r1 (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])))) (let ()
(panic (string-append (string-append "First rotor position is not within range of 1..26 (" (format "~a" r1)) ")"))
) (void))
(if (not (and (< 0 r2) (<= r2 (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])))) (let ()
(panic (string-append (string-append "Second rotor position is not within range of 1..26 (" (format "~a" r2)) ")"))
) (void))
(if (not (and (< 0 r3) (<= r3 (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])))) (let ()
(panic (string-append (string-append "Third rotor position is not within range of 1..26 (" (format "~a" r3)) ")"))
) (void))
))
)
(define (enigma text rotor_position rotor_selection plugb)
  (let/ec _return (begin
(define up_text (to_uppercase text))
(define up_pb (to_uppercase plugb))
(validator rotor_position rotor_selection up_pb)
(define plugboard (build_plugboard up_pb))
(define rotorpos1 (- (if rotor_position (if (hash? rotor_position) (hash-ref rotor_position 0 #f) (list-ref rotor_position (int 0))) #f) 1))
(define rotorpos2 (- (if rotor_position (if (hash? rotor_position) (hash-ref rotor_position 1 #f) (list-ref rotor_position (int 1))) #f) 1))
(define rotorpos3 (- (if rotor_position (if (hash? rotor_position) (hash-ref rotor_position 2 #f) (list-ref rotor_position (int 2))) #f) 1))
(define rotor_a (if rotor_selection (if (hash? rotor_selection) (hash-ref rotor_selection 0 #f) (list-ref rotor_selection (int 0))) #f))
(define rotor_b (if rotor_selection (if (hash? rotor_selection) (hash-ref rotor_selection 1 #f) (list-ref rotor_selection (int 1))) #f))
(define rotor_c (if rotor_selection (if (hash? rotor_selection) (hash-ref rotor_selection 2 #f) (list-ref rotor_selection (int 2))) #f))
(define result "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? up_text) (string-length up_text)] [(hash? up_text) (hash-count up_text)] [else (length up_text)])) (let/ec _cont
    (define symbol (slice up_text i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (contains_char abc symbol) (let ()
(set! symbol (plugboard_map plugboard symbol))
(define index (let ([__l (index_in_string abc symbol)] [__r rotorpos1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! symbol (slice rotor_a (modulo index (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])) (let ([__l (modulo index (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)]))] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! index (let ([__l (index_in_string abc symbol)] [__r rotorpos2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! symbol (slice rotor_b (modulo index (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])) (let ([__l (modulo index (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)]))] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! index (let ([__l (index_in_string abc symbol)] [__r rotorpos3]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! symbol (slice rotor_c (modulo index (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])) (let ([__l (modulo index (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)]))] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! symbol (reflector_map symbol))
(set! index (- (index_in_string rotor_c symbol) rotorpos3))
(if (< index 0) (let ()
(set! index (let ([__l index] [__r (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(set! symbol (slice abc index (let ([__l index] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! index (- (index_in_string rotor_b symbol) rotorpos2))
(if (< index 0) (let ()
(set! index (let ([__l index] [__r (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(set! symbol (slice abc index (let ([__l index] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! index (- (index_in_string rotor_a symbol) rotorpos1))
(if (< index 0) (let ()
(set! index (let ([__l index] [__r (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(set! symbol (slice abc index (let ([__l index] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! symbol (plugboard_map plugboard symbol))
(set! rotorpos1 (let ([__l rotorpos1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (>= rotorpos1 (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])) (let ()
(set! rotorpos1 0)
(set! rotorpos2 (let ([__l rotorpos2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(if (>= rotorpos2 (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])) (let ()
(set! rotorpos2 0)
(set! rotorpos3 (let ([__l rotorpos3] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(if (>= rotorpos3 (cond [(string? abc) (string-length abc)] [(hash? abc) (hash-count abc)] [else (length abc)])) (let ()
(set! rotorpos3 0)
) (void))
) (void))
    (set! result (string-append result symbol))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (main)
  (let/ec _return (begin
(define message "This is my Python script that emulates the Enigma machine from WWII.")
(define rotor_pos (list 1 1 1))
(define pb "pictures")
(define rotor_sel (list rotor2 rotor4 rotor8))
(define en (enigma message rotor_pos rotor_sel pb))
(displayln (string-append "Encrypted message: " en))
(displayln (string-append "Decrypted message: " (enigma en rotor_pos rotor_sel pb)))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
