;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define CHARS (list "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" "1" "2" "3" "4" "5" "6" "7" "8" "9" "0" "&" "@" ":" "," "." "'" "\"" "?" "/" "=" "+" "-" "(" ")" "!" " "))
(define CODES (list ".-" "-..." "-.-." "-.." "." "..-." "--." "...." ".." ".---" "-.-" ".-.." "--" "-." "---" ".--." "--.-" ".-." "..." "-" "..-" "...-" ".--" "-..-" "-.--" "--.." ".----" "..---" "...--" "....-" "....." "-...." "--..." "---.." "----." "-----" ".-..." ".--.-." "---..." "--..--" ".-.-.-" ".----." ".-..-." "..--.." "-..-." "-...-" ".-.-." "-....-" "-.--." "-.--.-" "-.-.--" "/"))
(define (to_upper_char c)
  (let/ec _return (begin
(if (string=? c "a") (let ()
(_return "A")
) (void))
(if (string=? c "b") (let ()
(_return "B")
) (void))
(if (string=? c "c") (let ()
(_return "C")
) (void))
(if (string=? c "d") (let ()
(_return "D")
) (void))
(if (string=? c "e") (let ()
(_return "E")
) (void))
(if (string=? c "f") (let ()
(_return "F")
) (void))
(if (string=? c "g") (let ()
(_return "G")
) (void))
(if (string=? c "h") (let ()
(_return "H")
) (void))
(if (string=? c "i") (let ()
(_return "I")
) (void))
(if (string=? c "j") (let ()
(_return "J")
) (void))
(if (string=? c "k") (let ()
(_return "K")
) (void))
(if (string=? c "l") (let ()
(_return "L")
) (void))
(if (string=? c "m") (let ()
(_return "M")
) (void))
(if (string=? c "n") (let ()
(_return "N")
) (void))
(if (string=? c "o") (let ()
(_return "O")
) (void))
(if (string=? c "p") (let ()
(_return "P")
) (void))
(if (string=? c "q") (let ()
(_return "Q")
) (void))
(if (string=? c "r") (let ()
(_return "R")
) (void))
(if (string=? c "s") (let ()
(_return "S")
) (void))
(if (string=? c "t") (let ()
(_return "T")
) (void))
(if (string=? c "u") (let ()
(_return "U")
) (void))
(if (string=? c "v") (let ()
(_return "V")
) (void))
(if (string=? c "w") (let ()
(_return "W")
) (void))
(if (string=? c "x") (let ()
(_return "X")
) (void))
(if (string=? c "y") (let ()
(_return "Y")
) (void))
(if (string=? c "z") (let ()
(_return "Z")
) (void))
(_return c)
))
)
(define (to_upper s)
  (let/ec _return (begin
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (set! res (string-append res (to_upper_char (substring s i (+ i 1)))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (index_of xs target)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) target) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (encrypt message)
  (let/ec _return (begin
(define msg (to_upper message))
(define res "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? msg) (string-length msg)] [(hash? msg) (hash-count msg)] [else (length msg)])) (let/ec _cont
    (define c (substring msg i (+ i 1)))
    (define idx (index_of CHARS c))
    (if (>= idx 0) (let ()
(if (not (string=? res "")) (let ()
(set! res (string-append res " "))
) (void))
(set! res (string-append res (if CODES (if (hash? CODES) (hash-ref CODES idx #f) (list-ref CODES (int idx))) #f)))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (split_spaces s)
  (let/ec _return (begin
(define res (list))
(define current "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (define ch (substring s i (+ i 1)))
    (if (string=? ch " ") (let ()
(if (not (string=? current "")) (let ()
(set! res (append res (list current)))
(set! current "")
) (void))
) (let ()
(set! current (string-append current ch))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(if (not (string=? current "")) (let ()
(set! res (append res (list current)))
) (void))
(_return res)
))
)
(define (decrypt message)
  (let/ec _return (begin
(define parts (split_spaces message))
(define res "")
(let/ec _break (for ([code parts])
  (let/ec _cont
(define idx (index_of CODES code))
(if (>= idx 0) (let ()
(set! res (string-append res (if CHARS (if (hash? CHARS) (hash-ref CHARS idx #f) (list-ref CHARS (int idx))) #f)))
) (void))
  )))
(_return res)
))
)
(define msg "Morse code here!")
(define enc (encrypt msg))
(define dec (decrypt enc))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln msg)
(displayln enc)
(displayln dec)
(displayln (encrypt "Sos!"))
(displayln (decrypt "... --- ... -.-.--"))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
