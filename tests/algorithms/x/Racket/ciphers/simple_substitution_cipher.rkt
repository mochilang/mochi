;; Generated by Mochi 0.10.59 on 2025-08-06 22:15 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define LETTERS "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(define LOWERCASE "abcdefghijklmnopqrstuvwxyz")
(define seed 1)
(define (rand n)
  (let/ec _return (begin
(set! seed (modulo (let ([__l (* seed 1664525)] [__r 1013904223]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2147483647))
(_return (modulo seed n))
))
)
(define (get_random_key)
  (let/ec _return (begin
(define chars (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? LETTERS) (string-length LETTERS)] [(hash? LETTERS) (hash-count LETTERS)] [else (length LETTERS)])) (let/ec _cont
    (set! chars (append chars (list (substring LETTERS i (+ i 1)))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define j (- (cond [(string? chars) (string-length chars)] [(hash? chars) (hash-count chars)] [else (length chars)]) 1))
(let/ec _break (let loop ()
  (if (> j 0) (let/ec _cont
    (define k (rand (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define tmp (if chars (if (hash? chars) (hash-ref chars j #f) (list-ref chars (int j))) #f))
    (set! chars (list-set chars (int j) (if chars (if (hash? chars) (hash-ref chars k #f) (list-ref chars (int k))) #f)))
    (set! chars (list-set chars (int k) tmp))
    (set! j (- j 1))
    (loop)) (void))))
(define res "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? chars) (string-length chars)] [(hash? chars) (hash-count chars)] [else (length chars)])) (let/ec _cont
    (set! res (string-append res (if chars (if (hash? chars) (hash-ref chars i #f) (list-ref chars (int i))) #f)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (check_valid_key key)
  (let/ec _return (begin
(if (not (equal? (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]) (cond [(string? LETTERS) (string-length LETTERS)] [(hash? LETTERS) (hash-count LETTERS)] [else (length LETTERS)]))) (let ()
(_return #f)
) (void))
(define used (hash))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) (let/ec _cont
    (define ch (substring key i (+ i 1)))
    (if (if used (hash-ref used ch #f) #f) (let ()
(_return #f)
) (void))
    (set! used (hash-set (or used (hash)) ch #t))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? LETTERS) (string-length LETTERS)] [(hash? LETTERS) (hash-count LETTERS)] [else (length LETTERS)])) (let/ec _cont
    (define ch (substring LETTERS i (+ i 1)))
    (if (not (if used (hash-ref used ch #f) #f)) (let ()
(_return #f)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #t)
))
)
(define (index_in s ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (if (string=? (substring s i (+ i 1)) ch) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (char_to_upper c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? LOWERCASE) (string-length LOWERCASE)] [(hash? LOWERCASE) (hash-count LOWERCASE)] [else (length LOWERCASE)])) (let/ec _cont
    (if (string=? c (substring LOWERCASE i (+ i 1))) (let ()
(_return (substring LETTERS i (+ i 1)))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return c)
))
)
(define (char_to_lower c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? LETTERS) (string-length LETTERS)] [(hash? LETTERS) (hash-count LETTERS)] [else (length LETTERS)])) (let/ec _cont
    (if (string=? c (substring LETTERS i (+ i 1))) (let ()
(_return (substring LOWERCASE i (+ i 1)))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return c)
))
)
(define (is_upper c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? LETTERS) (string-length LETTERS)] [(hash? LETTERS) (hash-count LETTERS)] [else (length LETTERS)])) (let/ec _cont
    (if (string=? c (substring LETTERS i (+ i 1))) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (translate_message key message mode)
  (let/ec _return (begin
(define chars_a LETTERS)
(define chars_b key)
(if (string=? mode "decrypt") (let ()
(define tmp chars_a)
(set! chars_a chars_b)
(set! chars_b tmp)
) (void))
(define translated "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? message) (string-length message)] [(hash? message) (hash-count message)] [else (length message)])) (let/ec _cont
    (define symbol (substring message i (+ i 1)))
    (define upper_symbol (char_to_upper symbol))
    (define idx (index_in chars_a upper_symbol))
    (if (>= idx 0) (let ()
(define mapped (substring chars_b idx (+ idx 1)))
(if (is_upper symbol) (let ()
(set! translated (string-append translated mapped))
) (let ()
(set! translated (string-append translated (char_to_lower mapped)))
))
) (let ()
(set! translated (string-append translated symbol))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return translated)
))
)
(define (encrypt_message key message)
  (let/ec _return (begin
(define res (translate_message key message "encrypt"))
(_return res)
))
)
(define (decrypt_message key message)
  (let/ec _return (begin
(define res (translate_message key message "decrypt"))
(_return res)
))
)
(define key "LFWOAYUISVKMNXPBDCRJTQEGHZ")
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln (encrypt_message key "Harshil Darji"))
(displayln (decrypt_message key "Ilcrism Olcvs"))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
