;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define square (list (list "a" "b" "c" "d" "e") (list "f" "g" "h" "i" "k") (list "l" "m" "n" "o" "p") (list "q" "r" "s" "t" "u") (list "v" "w" "x" "y" "z")))
(define (letter_to_numbers letter)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? square) (string-length square)] [(hash? square) (hash-count square)] [else (length square)])) (let/ec _cont
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f)) (string-length (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f))] [(hash? (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f)) (hash-count (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f))] [else (length (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f))])) (let/ec _cont
    (if (string=? (if (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f) (if (hash? (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f)) (hash-ref (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f) j #f) (list-ref (if square (if (hash? square) (hash-ref square i #f) (list-ref square (int i))) #f) (int j))) #f) letter) (let ()
(_return (list (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (list 0 0))
))
)
(define (numbers_to_letter index1 index2)
  (let/ec _return (begin
(_return (if (if square (if (hash? square) (hash-ref square (- index1 1) #f) (list-ref square (int (- index1 1)))) #f) (if (hash? (if square (if (hash? square) (hash-ref square (- index1 1) #f) (list-ref square (int (- index1 1)))) #f)) (hash-ref (if square (if (hash? square) (hash-ref square (- index1 1) #f) (list-ref square (int (- index1 1)))) #f) (- index2 1) #f) (list-ref (if square (if (hash? square) (hash-ref square (- index1 1) #f) (list-ref square (int (- index1 1)))) #f) (int (- index2 1)))) #f))
))
)
(define (char_to_int ch)
  (let/ec _return (begin
(if (string=? ch "1") (let ()
(_return 1)
) (void))
(if (string=? ch "2") (let ()
(_return 2)
) (void))
(if (string=? ch "3") (let ()
(_return 3)
) (void))
(if (string=? ch "4") (let ()
(_return 4)
) (void))
(if (string=? ch "5") (let ()
(_return 5)
) (void))
(_return 0)
))
)
(define (encode message)
  (let/ec _return (begin
(set! message (lower message))
(define encoded "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? message) (string-length message)] [(hash? message) (hash-count message)] [else (length message)])) (let/ec _cont
    (define ch (substring message i (+ i 1)))
    (if (string=? ch "j") (let ()
(set! ch "i")
) (void))
    (if (not (string=? ch " ")) (let ()
(define nums (letter_to_numbers ch))
(set! encoded (string-append (string-append encoded (format "~a" (if nums (if (hash? nums) (hash-ref nums 0 #f) (list-ref nums (int 0))) #f))) (format "~a" (if nums (if (hash? nums) (hash-ref nums 1 #f) (list-ref nums (int 1))) #f))))
) (let ()
(set! encoded (string-append encoded " "))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return encoded)
))
)
(define (decode message)
  (let/ec _return (begin
(define decoded "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? message) (string-length message)] [(hash? message) (hash-count message)] [else (length message)])) (let/ec _cont
    (if (string=? (substring message i (+ i 1)) " ") (let ()
(set! decoded (string-append decoded " "))
(set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(define index1 (char_to_int (substring message i (+ i 1))))
(define index2 (char_to_int (substring message (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (+ (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 1))))
(define letter (numbers_to_letter index1 index2))
(set! decoded (string-append decoded letter))
(set! i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
    (loop)) (void))))
(_return decoded)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(displayln (encode "test message"))
(displayln (encode "Test Message"))
(displayln (decode "44154344 32154343112215"))
(displayln (decode "4415434432154343112215"))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
