;; Generated by Mochi 0.10.59 on 2025-08-06 21:26 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define seed 123456789)
(define (rand)
  (let/ec _return (begin
(set! seed (modulo (let ([__l (* seed 1103515245)] [__r 12345]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2147483647))
(_return seed)
))
)
(define (rand_range min max)
  (let/ec _return (begin
(_return (let ([__l min] [__r (modulo (rand) (let ([__l (- max min)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
)
(define (mod_pow base exponent modulus)
  (let/ec _return (begin
(define result 1)
(define b (modulo base modulus))
(define e exponent)
(let/ec _break (let loop ()
  (if (> e 0) (let/ec _cont
    (if (equal? (modulo e 2) 1) (let ()
(set! result (modulo (* result b) modulus))
) (void))
    (set! e (quotient e 2))
    (set! b (modulo (* b b) modulus))
    (loop)) (void))))
(_return result)
))
)
(define (extended_gcd a b)
  (let/ec _return (begin
(if (equal? b 0) (let ()
(_return (hash "g" a "x" 1 "y" 0))
) (void))
(define res (extended_gcd b (modulo a b)))
(_return (hash "g" (if res (hash-ref res "g" #f) #f) "x" (if res (hash-ref res "y" #f) #f) "y" (- (if res (hash-ref res "x" #f) #f) (* (quotient a b) (if res (hash-ref res "y" #f) #f)))))
))
)
(define (mod_inverse a m)
  (let/ec _return (begin
(define res (extended_gcd a m))
(if (not (equal? (if res (hash-ref res "g" #f) #f) 1)) (let ()
(panic "inverse does not exist")
) (void))
(define r (modulo (if res (hash-ref res "x" #f) #f) m))
(if (< r 0) (let ()
(_return (let ([__l r] [__r m]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return r)
))
)
(define (pow2 n)
  (let/ec _return (begin
(define r 1)
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let/ec _cont
    (set! r (* r 2))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return r)
))
)
(define (is_probable_prime n k)
  (let/ec _return (begin
(if (<= n 1) (let ()
(_return #f)
) (void))
(if (<= n 3) (let ()
(_return #t)
) (void))
(if (equal? (modulo n 2) 0) (let ()
(_return #f)
) (void))
(define r 0)
(define d (- n 1))
(let/ec _break (let loop ()
  (if (equal? (modulo d 2) 0) (let/ec _cont
    (set! d (quotient d 2))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define i 0)
(let/ec _break (let loop ()
  (if (< i k) (let/ec _cont
    (define a (rand_range 2 (- n 2)))
    (define x (mod_pow a d n))
    (if (or (equal? x 1) (equal? x (- n 1))) (let ()
(set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(_cont)
) (void))
    (define j 1)
    (define found #f)
    (let/ec _break (let loop ()
  (if (< j r) (let/ec _cont
    (set! x (mod_pow x 2 n))
    (if (equal? x (- n 1)) (let ()
(set! found #t)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (not found) (let ()
(_return #f)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #t)
))
)
(define (generate_large_prime bits)
  (let/ec _return (begin
(define min (pow2 (- bits 1)))
(define max (- (pow2 bits) 1))
(define p (rand_range min max))
(if (equal? (modulo p 2) 0) (let ()
(set! p (let ([__l p] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(let/ec _break (let loop ()
  (if (not (is_probable_prime p 5)) (let/ec _cont
    (set! p (let ([__l p] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (> p max) (let ()
(set! p (let ([__l min] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (loop)) (void))))
(_return p)
))
)
(define (primitive_root p)
  (let/ec _return (begin
(let/ec _break (let loop ()
  (if #t (let/ec _cont
    (define g (rand_range 3 (- p 1)))
    (if (equal? (mod_pow g 2 p) 1) (let ()
(_cont)
) (void))
    (if (equal? (mod_pow g p p) 1) (let ()
(_cont)
) (void))
    (_return g)
    (loop)) (void))))
))
)
(define (generate_key key_size)
  (let/ec _return (begin
(define p (generate_large_prime key_size))
(define e1 (primitive_root p))
(define d (rand_range 3 (- p 1)))
(define e2 (mod_inverse (mod_pow e1 d p) p))
(define public_key (hash "key_size" key_size "g" e1 "e2" e2 "p" p))
(define private_key (hash "key_size" key_size "d" d))
(_return (hash "public_key" public_key "private_key" private_key))
))
)
(define (main)
  (let/ec _return (begin
(define key_size 16)
(define kp (generate_key key_size))
(define pub (if kp (hash-ref kp "public_key" #f) #f))
(define priv (if kp (hash-ref kp "private_key" #f) #f))
(displayln (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append "public key: (" (format "~a" (if pub (hash-ref pub "key_size" #f) #f))) ", ") (format "~a" (if pub (hash-ref pub "g" #f) #f))) ", ") (format "~a" (if pub (hash-ref pub "e2" #f) #f))) ", ") (format "~a" (if pub (hash-ref pub "p" #f) #f))) ")"))
(displayln (string-append (string-append (string-append (string-append "private key: (" (format "~a" (if priv (hash-ref priv "key_size" #f) #f))) ", ") (format "~a" (if priv (hash-ref priv "d" #f) #f))) ")"))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
