;; Generated by Mochi 0.10.64 on 2025-08-12 11:18 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (split s sep)
  (let/ec _return (begin
(define parts (list))
(define cur "")
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (and (and (let ([__l (cond [(not sep) 0] [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])] [__r 0]) (> (int __l) (int __r))) (let ([__l (let ([__l i] [__r (cond [(not sep) 0] [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])]) (<= (int __l) (int __r)))) (string=? (slice s i (let ([__l i] [__r (cond [(not sep) 0] [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) sep)) (let ()
(set! parts (append (or parts (list)) (list cur)))
(set! cur "")
(set! i (let ([__l i] [__r (cond [(not sep) 0] [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(set! cur (string-append cur (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
    )
    (loop)) (void))))
(set! parts (append (or parts (list)) (list cur)))
(_return parts)
))
)
(define (card_value ch)
  (let/ec _return (begin
(if (string=? ch "A") (let ()
(_return 14)
) (let ()
(if (string=? ch "K") (let ()
(_return 13)
) (let ()
(if (string=? ch "Q") (let ()
(_return 12)
) (let ()
(if (string=? ch "J") (let ()
(_return 11)
) (let ()
(if (string=? ch "T") (let ()
(_return 10)
) (let ()
(if (string=? ch "9") (let ()
(_return 9)
) (let ()
(if (string=? ch "8") (let ()
(_return 8)
) (let ()
(if (string=? ch "7") (let ()
(_return 7)
) (let ()
(if (string=? ch "6") (let ()
(_return 6)
) (let ()
(if (string=? ch "5") (let ()
(_return 5)
) (let ()
(if (string=? ch "4") (let ()
(_return 4)
) (let ()
(if (string=? ch "3") (let ()
(_return 3)
) (let ()
(_return 2)
))
))
))
))
))
))
))
))
))
))
))
))
))
)
(define (parse_hand hand)
  (let/ec _return (begin
(define counts (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 14]) (<= (int __l) (int __r))) (begin
    (let/ec _cont
      (set! counts (append (or counts (list)) (list 0)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define suits (list))
(let/ec _break (for ([card (split hand " ")])
  (let/ec _cont
(define v (card_value (slice card 0 1)))
(set! counts (list-set counts (int v) (let ([__l (if counts (if (hash? counts) (hash-ref counts v #f) (safe-index counts (int v))) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! suits (append (or suits (list)) (list (slice card 1 2))))
  )))
(define vals (list))
(define v 14)
(let/ec _break (let loop ()
  (if (let ([__l v] [__r 2]) (>= (int __l) (int __r))) (begin
    (let/ec _cont
      (define c (if counts (if (hash? counts) (hash-ref counts v #f) (safe-index counts (int v))) #f))
      (define k 0)
      (let/ec _break (let loop ()
  (if (let ([__l k] [__r c]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (set! vals (append (or vals (list)) (list v)))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! v (- v 1))
    )
    (loop)) (void))))
(define is_straight #f)
(if (and (and (and (and (and (equal? (cond [(not vals) 0] [(string? vals) (string-length vals)] [(hash? vals) (hash-count vals)] [else (length vals)]) 5) (equal? (if vals (if (hash? vals) (hash-ref vals 0 #f) (safe-index vals (int 0))) #f) 14)) (equal? (if vals (if (hash? vals) (hash-ref vals 1 #f) (safe-index vals (int 1))) #f) 5)) (equal? (if vals (if (hash? vals) (hash-ref vals 2 #f) (safe-index vals (int 2))) #f) 4)) (equal? (if vals (if (hash? vals) (hash-ref vals 3 #f) (safe-index vals (int 3))) #f) 3)) (equal? (if vals (if (hash? vals) (hash-ref vals 4 #f) (safe-index vals (int 4))) #f) 2)) (let ()
(set! is_straight #t)
(set! vals (list-set vals (int 0) 5))
(set! vals (list-set vals (int 1) 4))
(set! vals (list-set vals (int 2) 3))
(set! vals (list-set vals (int 3) 2))
(set! vals (list-set vals (int 4) 14))
) (let ()
(set! is_straight #t)
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r 4]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (not (equal? (- (if vals (if (hash? vals) (hash-ref vals j #f) (safe-index vals (int j))) #f) (if vals (if (hash? vals) (hash-ref vals (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (safe-index vals (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) 1)) (let ()
(set! is_straight #f)
) (void))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
(define is_flush #t)
(define s0 (if suits (if (hash? suits) (hash-ref suits 0 #f) (safe-index suits (int 0))) #f))
(define t 1)
(let/ec _break (let loop ()
  (if (let ([__l t] [__r (cond [(not suits) 0] [(string? suits) (string-length suits)] [(hash? suits) (hash-count suits)] [else (length suits)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (not (string=? (if suits (if (hash? suits) (hash-ref suits t #f) (safe-index suits (int t))) #f) s0)) (let ()
(set! is_flush #f)
) (void))
      (set! t (let ([__l t] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define four_val 0)
(define three_val 0)
(define pair_vals (list))
(set! v 14)
(let/ec _break (let loop ()
  (if (let ([__l v] [__r 2]) (>= (int __l) (int __r))) (begin
    (let/ec _cont
      (if (equal? (if counts (if (hash? counts) (hash-ref counts v #f) (safe-index counts (int v))) #f) 4) (let ()
(set! four_val v)
) (let ()
(if (equal? (if counts (if (hash? counts) (hash-ref counts v #f) (safe-index counts (int v))) #f) 3) (let ()
(set! three_val v)
) (let ()
(if (equal? (if counts (if (hash? counts) (hash-ref counts v #f) (safe-index counts (int v))) #f) 2) (let ()
(set! pair_vals (append (or pair_vals (list)) (list v)))
) (void))
))
))
      (set! v (- v 1))
    )
    (loop)) (void))))
(define rank 1)
(if (and (and (and is_flush is_straight) (equal? (if vals (if (hash? vals) (hash-ref vals 0 #f) (safe-index vals (int 0))) #f) 14)) (equal? (if vals (if (hash? vals) (hash-ref vals 4 #f) (safe-index vals (int 4))) #f) 10)) (let ()
(set! rank 10)
) (let ()
(if (and is_flush is_straight) (let ()
(set! rank 9)
) (let ()
(if (not (equal? four_val 0)) (let ()
(set! rank 8)
) (let ()
(if (and (not (equal? three_val 0)) (equal? (cond [(not pair_vals) 0] [(string? pair_vals) (string-length pair_vals)] [(hash? pair_vals) (hash-count pair_vals)] [else (length pair_vals)]) 1)) (let ()
(set! rank 7)
) (let ()
(if is_flush (let ()
(set! rank 6)
) (let ()
(if is_straight (let ()
(set! rank 5)
) (let ()
(if (not (equal? three_val 0)) (let ()
(set! rank 4)
) (let ()
(if (equal? (cond [(not pair_vals) 0] [(string? pair_vals) (string-length pair_vals)] [(hash? pair_vals) (hash-count pair_vals)] [else (length pair_vals)]) 2) (let ()
(set! rank 3)
) (let ()
(if (equal? (cond [(not pair_vals) 0] [(string? pair_vals) (string-length pair_vals)] [(hash? pair_vals) (hash-count pair_vals)] [else (length pair_vals)]) 1) (let ()
(set! rank 2)
) (let ()
(set! rank 1)
))
))
))
))
))
))
))
))
))
(_return (let ([h (make-hash)]) (hash-set! h "rank" rank) (hash-set! h "values" vals) h))
))
)
(define (compare a b)
  (let/ec _return (begin
(if (let ([__l (if a (hash-ref a "rank" #f) #f)] [__r (if b (hash-ref b "rank" #f) #f)]) (> (int __l) (int __r))) (let ()
(_return "Win")
) (void))
(if (let ([__l (if a (hash-ref a "rank" #f) #f)] [__r (if b (hash-ref b "rank" #f) #f)]) (< (int __l) (int __r))) (let ()
(_return "Loss")
) (void))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if a (hash-ref a "values" #f) #f)) 0] [(string? (if a (hash-ref a "values" #f) #f)) (string-length (if a (hash-ref a "values" #f) #f))] [(hash? (if a (hash-ref a "values" #f) #f)) (hash-count (if a (hash-ref a "values" #f) #f))] [else (length (if a (hash-ref a "values" #f) #f))])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (let ([__l (if (if a (hash-ref a "values" #f) #f) (if (hash? (if a (hash-ref a "values" #f) #f)) (hash-ref (if a (hash-ref a "values" #f) #f) i #f) (safe-index (if a (hash-ref a "values" #f) #f) (int i))) #f)] [__r (if (if b (hash-ref b "values" #f) #f) (if (hash? (if b (hash-ref b "values" #f) #f)) (hash-ref (if b (hash-ref b "values" #f) #f) i #f) (safe-index (if b (hash-ref b "values" #f) #f) (int i))) #f)]) (> (int __l) (int __r))) (let ()
(_return "Win")
) (void))
      (if (let ([__l (if (if a (hash-ref a "values" #f) #f) (if (hash? (if a (hash-ref a "values" #f) #f)) (hash-ref (if a (hash-ref a "values" #f) #f) i #f) (safe-index (if a (hash-ref a "values" #f) #f) (int i))) #f)] [__r (if (if b (hash-ref b "values" #f) #f) (if (hash? (if b (hash-ref b "values" #f) #f)) (hash-ref (if b (hash-ref b "values" #f) #f) i #f) (safe-index (if b (hash-ref b "values" #f) #f) (int i))) #f)]) (< (int __l) (int __r))) (let ()
(_return "Loss")
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return "Tie")
))
)
(define (main)
  (let/ec _return (begin
(define tests (list (list "2H 3H 4H 5H 6H" "KS AS TS QS JS" "Loss") (list "2H 3H 4H 5H 6H" "AS AD AC AH JD" "Win") (list "AS AH 2H AD AC" "JS JD JC JH 3D" "Win") (list "2S AH 2H AS AC" "JS JD JC JH AD" "Loss") (list "2S AH 2H AS AC" "2H 3H 5H 6H 7H" "Win")))
(let/ec _break (for ([t tests])
  (let/ec _cont
(define res (compare (parse_hand (if t (if (hash? t) (hash-ref t 0 #f) (safe-index t (int 0))) #f)) (parse_hand (if t (if (hash? t) (hash-ref t 1 #f) (safe-index t (int 1))) #f))))
(displayln (string-append (string-append res " expected ") (if t (if (hash? t) (hash-ref t 2 #f) (safe-index t (int 2))) #f)))
  )))
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
