;; Generated by Mochi 0.10.64 on 2025-08-12 11:18 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (parse_int s)
  (let/ec _return (begin
(define value 0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define c (substring s i (+ i 1)))
      (set! value (let ([__l (* value 10)] [__r (int c)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return value)
))
)
(define (join xs)
  (let/ec _return (begin
(define s "")
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (set! s (string-append s (if xs (if (hash? xs) (hash-ref xs i #f) (safe-index xs (int i))) #f)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return s)
))
)
(define (contains xs c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (safe-index xs (int i))) #f) c) (let ()
(_return #t)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return #f)
))
)
(define (index_of xs c)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (safe-index xs (int i))) #f) c) (let ()
(_return i)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (- 1))
))
)
(define (remove_at xs idx)
  (let/ec _return (begin
(define res (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (not (equal? i idx)) (let ()
(set! res (append (or res (list)) (list (if xs (if (hash? xs) (hash-ref xs i #f) (safe-index xs (int i))) #f))))
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (unique_chars logins)
  (let/ec _return (begin
(define chars (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not logins) 0] [(string? logins) (string-length logins)] [(hash? logins) (hash-count logins)] [else (length logins)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define login (if logins (if (hash? logins) (hash-ref logins i #f) (safe-index logins (int i))) #f))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not login) 0] [(string? login) (string-length login)] [(hash? login) (hash-count login)] [else (length login)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define c (substring login j (+ j 1)))
      (if (not (contains chars c)) (let ()
(set! chars (append (or chars (list)) (list c)))
) (void))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return chars)
))
)
(define (satisfies permutation logins)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not logins) 0] [(string? logins) (string-length logins)] [(hash? logins) (hash-count logins)] [else (length logins)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define login (if logins (if (hash? logins) (hash-ref logins i #f) (safe-index logins (int i))) #f))
      (define i0 (index_of permutation (substring login 0 (+ 0 1))))
      (define i1 (index_of permutation (substring login 1 (+ 1 1))))
      (define i2 (index_of permutation (substring login 2 (+ 2 1))))
      (if (not (and (let ([__l i0] [__r i1]) (< (int __l) (int __r))) (let ([__l i1] [__r i2]) (< (int __l) (int __r))))) (let ()
(_return #f)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return #t)
))
)
(define (search chars current logins)
  (let/ec _return (begin
(if (equal? (cond [(not chars) 0] [(string? chars) (string-length chars)] [(hash? chars) (hash-count chars)] [else (length chars)]) 0) (let ()
(if (satisfies current logins) (let ()
(_return (join current))
) (void))
(_return "")
) (void))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not chars) 0] [(string? chars) (string-length chars)] [(hash? chars) (hash-count chars)] [else (length chars)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define c (if chars (if (hash? chars) (hash-ref chars i #f) (safe-index chars (int i))) #f))
      (define rest (remove_at chars i))
      (define next (append (or current (list)) (list c)))
      (define res (search rest next logins))
      (if (not (string=? res "")) (let ()
(_return res)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return "")
))
)
(define (find_secret_passcode logins)
  (let/ec _return (begin
(define chars (unique_chars logins))
(define s (search chars (list) logins))
(if (string=? s "") (let ()
(_return (- 1))
) (void))
(_return (parse_int s))
))
)
(define logins1 (list "135" "259" "235" "189" "690" "168" "120" "136" "289" "589" "160" "165" "580" "369" "250" "280"))
(define logins2 (list "426" "281" "061" "819" "268" "406" "420" "428" "209" "689" "019" "421" "469" "261" "681" "201"))
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(displayln (to-string (find_secret_passcode logins1)))
(displayln (to-string (find_secret_passcode logins2)))
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
