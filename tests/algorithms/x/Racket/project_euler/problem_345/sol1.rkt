;; Generated by Mochi 0.10.64 on 2025-08-12 11:18 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (parse_row row_str)
  (let/ec _return (begin
(define nums (list))
(define current 0)
(define has_digit #f)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not row_str) 0] [(string? row_str) (string-length row_str)] [(hash? row_str) (hash-count row_str)] [else (length row_str)])]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define ch (slice row_str i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (if (string=? ch " ") (let ()
(if has_digit (let ()
(set! nums (append (or nums (list)) (list current)))
(set! current 0)
(set! has_digit #f)
) (void))
) (let ()
(set! current (let ([__l (* current 10)] [__r (int ch)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! has_digit #t)
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(if has_digit (let ()
(set! nums (append (or nums (list)) (list current)))
) (void))
(_return nums)
))
)
(define (parse_matrix matrix_str)
  (let/ec _return (begin
(define matrix (list))
(let/ec _break (for ([row_str matrix_str])
  (let/ec _cont
(define row (parse_row row_str))
(set! matrix (append (or matrix (list)) (list row)))
  )))
(_return matrix)
))
)
(define (bitcount x)
  (let/ec _return (begin
(define count 0)
(define y x)
(let/ec _break (let loop ()
  (if (let ([__l y] [__r 0]) (> (int __l) (int __r))) (begin
    (let/ec _cont
      (if (equal? (modulo y 2) 1) (let ()
(set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! y (floor (/ y 2)))
    )
    (loop)) (void))))
(_return count)
))
)
(define (build_powers n)
  (let/ec _return (begin
(define powers (list))
(define i 0)
(define current 1)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r n]) (<= (int __l) (int __r))) (begin
    (let/ec _cont
      (set! powers (append (or powers (list)) (list current)))
      (set! current (* current 2))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return powers)
))
)
(define (solution matrix_str)
  (let/ec _return (begin
(define arr (parse_matrix matrix_str))
(define n (cond [(not arr) 0] [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]))
(define powers (build_powers n))
(define size (if powers (if (hash? powers) (hash-ref powers n #f) (safe-index powers (int n))) #f))
(define dp (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r size]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (set! dp (append (or dp (list)) (list 0)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define mask 0)
(let/ec _break (let loop ()
  (if (let ([__l mask] [__r size]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (define row (bitcount mask))
      (if (let ([__l row] [__r n]) (< (int __l) (int __r))) (let ()
(define col 0)
(let/ec _break (let loop ()
  (if (let ([__l col] [__r n]) (< (int __l) (int __r))) (begin
    (let/ec _cont
      (if (equal? (modulo (floor (/ mask (if powers (if (hash? powers) (hash-ref powers col #f) (safe-index powers (int col))) #f))) 2) 0) (let ()
(define new_mask (let ([__l mask] [__r (if powers (if (hash? powers) (hash-ref powers col #f) (safe-index powers (int col))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define value (let ([__l (if dp (if (hash? dp) (hash-ref dp mask #f) (safe-index dp (int mask))) #f)] [__r (if (if arr (if (hash? arr) (hash-ref arr row #f) (safe-index arr (int row))) #f) (if (hash? (if arr (if (hash? arr) (hash-ref arr row #f) (safe-index arr (int row))) #f)) (hash-ref (if arr (if (hash? arr) (hash-ref arr row #f) (safe-index arr (int row))) #f) col #f) (safe-index (if arr (if (hash? arr) (hash-ref arr row #f) (safe-index arr (int row))) #f) (int col))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (let ([__l value] [__r (if dp (if (hash? dp) (hash-ref dp new_mask #f) (safe-index dp (int new_mask))) #f)]) (> (int __l) (int __r))) (let ()
(set! dp (list-set dp (int new_mask) value))
) (void))
) (void))
      (set! col (let ([__l col] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
) (void))
      (set! mask (let ([__l mask] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (if dp (if (hash? dp) (hash-ref dp (- size 1) #f) (safe-index dp (int (- size 1)))) #f))
))
)
(define MATRIX_2 (list "7 53 183 439 863 497 383 563 79 973 287 63 343 169 583" "627 343 773 959 943 767 473 103 699 303 957 703 583 639 913" "447 283 463 29 23 487 463 993 119 883 327 493 423 159 743" "217 623 3 399 853 407 103 983 89 463 290 516 212 462 350" "960 376 682 962 300 780 486 502 912 800 250 346 172 812 350" "870 456 192 162 593 473 915 45 989 873 823 965 425 329 803" "973 965 905 919 133 673 665 235 509 613 673 815 165 992 326" "322 148 972 962 286 255 941 541 265 323 925 281 601 95 973" "445 721 11 525 473 65 511 164 138 672 18 428 154 448 848" "414 456 310 312 798 104 566 520 302 248 694 976 430 392 198" "184 829 373 181 631 101 969 613 840 740 778 458 284 760 390" "821 461 843 513 17 901 711 993 293 157 274 94 192 156 574" "34 124 4 878 450 476 712 914 838 669 875 299 823 329 699" "815 559 813 459 522 788 168 586 966 232 308 833 251 631 107" "813 883 451 509 615 77 281 613 459 205 380 274 302 35 805"))
(define result (solution MATRIX_2))
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(displayln (string-append "solution() = " (to-string result)))
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
