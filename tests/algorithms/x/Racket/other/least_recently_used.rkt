;; Generated by Mochi 0.10.64 on 2025-08-12 14:09 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (new_cache n)
  (let/ec _return (begin
(if (let ([__l n] [__r 0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(panic "n should be an integer greater than 0.")
) (void))
(define cap (if (equal? n 0) 2147483647 n))
(_return (let ([h (make-hash)]) (hash-set! h "max_capacity" cap) (hash-set! h "store" (list)) h))
))
)
(define (remove_element xs x)
  (let/ec _return (begin
(define res (list))
(define removed #f)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not xs) 0] [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define v (if xs (if (hash? xs) (hash-ref xs i #f) (safe-index xs (int i))) #f))
      (if (and (not removed) (string=? v x)) (let ()
(set! removed #t)
) (let ()
(set! res (append (or res '()) (or (list v) '())))
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (refer cache x)
  (let/ec _return (begin
(define store (if cache (hash-ref cache "store" #f) #f))
(define exists #f)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not store) 0] [(string? store) (string-length store)] [(hash? store) (hash-count store)] [else (length store)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (string=? (if store (if (hash? store) (hash-ref store i #f) (safe-index store (int i))) #f) x) (let ()
(set! exists #t)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(if exists (let ()
(set! store (remove_element store x))
) (let ()
(if (equal? (cond [(not store) 0] [(string? store) (string-length store)] [(hash? store) (hash-count store)] [else (length store)]) (if cache (hash-ref cache "max_capacity" #f) #f)) (let ()
(define new_store (list))
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r (- (cond [(not store) 0] [(string? store) (string-length store)] [(hash? store) (hash-count store)] [else (length store)]) 1)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! new_store (append (or new_store '()) (or (list (if store (if (hash? store) (hash-ref store j #f) (safe-index store (int j))) #f)) '())))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(set! store new_store)
) (void))
))
(set! store (append (or (list x) '()) (or store '())))
(_return (let ([h (make-hash)]) (hash-set! h "max_capacity" (if cache (hash-ref cache "max_capacity" #f) #f)) (hash-set! h "store" store) h))
))
)
(define (display cache)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if cache (hash-ref cache "store" #f) #f)) 0] [(string? (if cache (hash-ref cache "store" #f) #f)) (string-length (if cache (hash-ref cache "store" #f) #f))] [(hash? (if cache (hash-ref cache "store" #f) #f)) (hash-count (if cache (hash-ref cache "store" #f) #f))] [else (length (if cache (hash-ref cache "store" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (displayln (if (if cache (hash-ref cache "store" #f) #f) (if (hash? (if cache (hash-ref cache "store" #f) #f)) (hash-ref (if cache (hash-ref cache "store" #f) #f) i #f) (safe-index (if cache (hash-ref cache "store" #f) #f) (int i))) #f))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
)
(define (repr_item s)
  (let/ec _return (begin
(define all_digits #t)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define ch (substring s i (+ i 1)))
      (if (or (string<? ch "0") (string>? ch "9")) (let ()
(set! all_digits #f)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(if all_digits (let ()
(_return s)
) (void))
(_return (string-append (string-append "'" s) "'"))
))
)
(define (cache_repr cache)
  (let/ec _return (begin
(define res (string-append (string-append "LRUCache(" (to-string (if cache (hash-ref cache "max_capacity" #f) #f))) ") => ["))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if cache (hash-ref cache "store" #f) #f)) 0] [(string? (if cache (hash-ref cache "store" #f) #f)) (string-length (if cache (hash-ref cache "store" #f) #f))] [(hash? (if cache (hash-ref cache "store" #f) #f)) (hash-count (if cache (hash-ref cache "store" #f) #f))] [else (length (if cache (hash-ref cache "store" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! res (string-append res (repr_item (if (if cache (hash-ref cache "store" #f) #f) (if (hash? (if cache (hash-ref cache "store" #f) #f)) (hash-ref (if cache (hash-ref cache "store" #f) #f) i #f) (safe-index (if cache (hash-ref cache "store" #f) #f) (int i))) #f))))
      (if (let ([__l i] [__r (- (cond [(not (if cache (hash-ref cache "store" #f) #f)) 0] [(string? (if cache (hash-ref cache "store" #f) #f)) (string-length (if cache (hash-ref cache "store" #f) #f))] [(hash? (if cache (hash-ref cache "store" #f) #f)) (hash-count (if cache (hash-ref cache "store" #f) #f))] [else (length (if cache (hash-ref cache "store" #f) #f))]) 1)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(set! res (string-append res ", "))
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(set! res (string-append res "]"))
(_return res)
))
)
(define lru (new_cache 4))
(define r (cache_repr lru))
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(set! lru (refer lru "A"))
(set! lru (refer lru "2"))
(set! lru (refer lru "3"))
(set! lru (refer lru "A"))
(set! lru (refer lru "4"))
(set! lru (refer lru "5"))
(displayln r)
(if (not (string=? r "LRUCache(4) => [5, 4, 'A', 3]")) (let ()
(panic "Assertion error")
) (void))
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
