;; Generated by Mochi 0.10.62 on 2025-08-09 10:22 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (get_data source_data)
  (let/ec _return (begin
(define data_lists (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not source_data) 0] [(string? source_data) (string-length source_data)] [(hash? source_data) (hash-count source_data)] [else (length source_data)])) (begin
    (let/ec _cont
      (define row (if source_data (if (hash? source_data) (hash-ref source_data i #f) (safe-index source_data (int i))) #f))
      (define j 0)
      (let/ec _break (let loop ()
  (if (< j (cond [(not row) 0] [(string? row) (string-length row)] [(hash? row) (hash-count row)] [else (length row)])) (begin
    (let/ec _cont
      (if (< (cond [(not data_lists) 0] [(string? data_lists) (string-length data_lists)] [(hash? data_lists) (hash-count data_lists)] [else (length data_lists)]) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let ()
(define empty (list))
(set! data_lists (append (or data_lists (list)) (list empty)))
) (void))
      (set! data_lists (list-set data_lists (int j) (append (or (if data_lists (if (hash? data_lists) (hash-ref data_lists j #f) (safe-index data_lists (int j))) #f) (list)) (list (if row (if (hash? row) (hash-ref row j #f) (safe-index row (int j))) #f)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return data_lists)
))
)
(define (calculate_each_score data_lists weights)
  (let/ec _return (begin
(define score_lists (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not data_lists) 0] [(string? data_lists) (string-length data_lists)] [(hash? data_lists) (hash-count data_lists)] [else (length data_lists)])) (begin
    (let/ec _cont
      (define dlist (if data_lists (if (hash? data_lists) (hash-ref data_lists i #f) (safe-index data_lists (int i))) #f))
      (define weight (if weights (if (hash? weights) (hash-ref weights i #f) (safe-index weights (int i))) #f))
      (define mind (if dlist (if (hash? dlist) (hash-ref dlist 0 #f) (safe-index dlist (int 0))) #f))
      (define maxd (if dlist (if (hash? dlist) (hash-ref dlist 0 #f) (safe-index dlist (int 0))) #f))
      (define j 1)
      (let/ec _break (let loop ()
  (if (< j (cond [(not dlist) 0] [(string? dlist) (string-length dlist)] [(hash? dlist) (hash-count dlist)] [else (length dlist)])) (begin
    (let/ec _cont
      (define val (if dlist (if (hash? dlist) (hash-ref dlist j #f) (safe-index dlist (int j))) #f))
      (if (< val mind) (let ()
(set! mind val)
) (void))
      (if (> val maxd) (let ()
(set! maxd val)
) (void))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define score (list))
      (set! j 0)
      (if (equal? weight 0) (let ()
(let/ec _break (let loop ()
  (if (< j (cond [(not dlist) 0] [(string? dlist) (string-length dlist)] [(hash? dlist) (hash-count dlist)] [else (length dlist)])) (begin
    (let/ec _cont
      (define item (if dlist (if (hash? dlist) (hash-ref dlist j #f) (safe-index dlist (int j))) #f))
      (if (equal? (- maxd mind) 0.0) (let ()
(set! score (append (or score (list)) (list 1.0)))
) (let ()
(set! score (append (or score (list)) (list (- 1.0 (/ (- item mind) (- maxd mind))))))
))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
) (let ()
(let/ec _break (let loop ()
  (if (< j (cond [(not dlist) 0] [(string? dlist) (string-length dlist)] [(hash? dlist) (hash-count dlist)] [else (length dlist)])) (begin
    (let/ec _cont
      (define item (if dlist (if (hash? dlist) (hash-ref dlist j #f) (safe-index dlist (int j))) #f))
      (if (equal? (- maxd mind) 0.0) (let ()
(set! score (append (or score (list)) (list 0.0)))
) (let ()
(set! score (append (or score (list)) (list (/ (- item mind) (- maxd mind)))))
))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
      (set! score_lists (append (or score_lists (list)) (list score)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return score_lists)
))
)
(define (generate_final_scores score_lists)
  (let/ec _return (begin
(define count (cond [(not (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f)) 0] [(string? (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f)) (string-length (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f))] [(hash? (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f)) (hash-count (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f))] [else (length (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f))]))
(define final_scores (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i count) (begin
    (let/ec _cont
      (set! final_scores (append (or final_scores (list)) (list 0.0)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not score_lists) 0] [(string? score_lists) (string-length score_lists)] [(hash? score_lists) (hash-count score_lists)] [else (length score_lists)])) (begin
    (let/ec _cont
      (define slist (if score_lists (if (hash? score_lists) (hash-ref score_lists i #f) (safe-index score_lists (int i))) #f))
      (define j 0)
      (let/ec _break (let loop ()
  (if (< j (cond [(not slist) 0] [(string? slist) (string-length slist)] [(hash? slist) (hash-count slist)] [else (length slist)])) (begin
    (let/ec _cont
      (set! final_scores (list-set final_scores (int j) (let ([__l (if final_scores (if (hash? final_scores) (hash-ref final_scores j #f) (safe-index final_scores (int j))) #f)] [__r (if slist (if (hash? slist) (hash-ref slist j #f) (safe-index slist (int j))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return final_scores)
))
)
(define (procentual_proximity source_data weights)
  (let/ec _return (begin
(define data_lists (get_data source_data))
(define score_lists (calculate_each_score data_lists weights))
(define final_scores (generate_final_scores score_lists))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not final_scores) 0] [(string? final_scores) (string-length final_scores)] [(hash? final_scores) (hash-count final_scores)] [else (length final_scores)])) (begin
    (let/ec _cont
      (set! source_data (list-set source_data (int i) (append (or (if source_data (if (hash? source_data) (hash-ref source_data i #f) (safe-index source_data (int i))) #f) (list)) (list (if final_scores (if (hash? final_scores) (hash-ref final_scores i #f) (safe-index final_scores (int i))) #f)))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return source_data)
))
)
(define vehicles (list))
(define weights (list 0 0 1))
(define result (procentual_proximity vehicles weights))
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(set! vehicles (append (or vehicles (list)) (list (list 20.0 60.0 2012.0))))
(set! vehicles (append (or vehicles (list)) (list (list 23.0 90.0 2015.0))))
(set! vehicles (append (or vehicles (list)) (list (list 22.0 50.0 2011.0))))
(displayln (to-string result))
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
