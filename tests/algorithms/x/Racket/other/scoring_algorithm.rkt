;; Generated by Mochi 0.10.64 on 2025-08-12 14:09 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (get_data source_data)
  (let/ec _return (begin
(define data_lists (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not source_data) 0] [(string? source_data) (string-length source_data)] [(hash? source_data) (hash-count source_data)] [else (length source_data)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define row (if source_data (if (hash? source_data) (hash-ref source_data i #f) (safe-index source_data (int i))) #f))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not row) 0] [(string? row) (string-length row)] [(hash? row) (hash-count row)] [else (length row)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (let ([__l (cond [(not data_lists) 0] [(string? data_lists) (string-length data_lists)] [(hash? data_lists) (hash-count data_lists)] [else (length data_lists)])] [__r (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(define empty (list))
(set! data_lists (append (or data_lists (list)) (list empty)))
) (void))
      (set! data_lists (list-set data_lists (int j) (append (or (if data_lists (if (hash? data_lists) (hash-ref data_lists j #f) (safe-index data_lists (int j))) #f) (list)) (list (if row (if (hash? row) (hash-ref row j #f) (safe-index row (int j))) #f)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return data_lists)
))
)
(define (calculate_each_score data_lists weights)
  (let/ec _return (begin
(define score_lists (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not data_lists) 0] [(string? data_lists) (string-length data_lists)] [(hash? data_lists) (hash-count data_lists)] [else (length data_lists)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define dlist (if data_lists (if (hash? data_lists) (hash-ref data_lists i #f) (safe-index data_lists (int i))) #f))
      (define weight (if weights (if (hash? weights) (hash-ref weights i #f) (safe-index weights (int i))) #f))
      (define mind (if dlist (if (hash? dlist) (hash-ref dlist 0 #f) (safe-index dlist (int 0))) #f))
      (define maxd (if dlist (if (hash? dlist) (hash-ref dlist 0 #f) (safe-index dlist (int 0))) #f))
      (define j 1)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not dlist) 0] [(string? dlist) (string-length dlist)] [(hash? dlist) (hash-count dlist)] [else (length dlist)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define val (if dlist (if (hash? dlist) (hash-ref dlist j #f) (safe-index dlist (int j))) #f))
      (if (let ([__l val] [__r mind]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(set! mind val)
) (void))
      (if (let ([__l val] [__r maxd]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (let ()
(set! maxd val)
) (void))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define score (list))
      (set! j 0)
      (if (equal? weight 0) (let ()
(let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not dlist) 0] [(string? dlist) (string-length dlist)] [(hash? dlist) (hash-count dlist)] [else (length dlist)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define item (if dlist (if (hash? dlist) (hash-ref dlist j #f) (safe-index dlist (int j))) #f))
      (if (equal? (- maxd mind) 0.0) (let ()
(set! score (append (or score (list)) (list 1.0)))
) (let ()
(set! score (append (or score (list)) (list (- 1.0 (/ (- item mind) (- maxd mind))))))
))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
) (let ()
(let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not dlist) 0] [(string? dlist) (string-length dlist)] [(hash? dlist) (hash-count dlist)] [else (length dlist)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define item (if dlist (if (hash? dlist) (hash-ref dlist j #f) (safe-index dlist (int j))) #f))
      (if (equal? (- maxd mind) 0.0) (let ()
(set! score (append (or score (list)) (list 0.0)))
) (let ()
(set! score (append (or score (list)) (list (/ (- item mind) (- maxd mind)))))
))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
      (set! score_lists (append (or score_lists (list)) (list score)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return score_lists)
))
)
(define (generate_final_scores score_lists)
  (let/ec _return (begin
(define count (cond [(not (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f)) 0] [(string? (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f)) (string-length (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f))] [(hash? (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f)) (hash-count (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f))] [else (length (if score_lists (if (hash? score_lists) (hash-ref score_lists 0 #f) (safe-index score_lists (int 0))) #f))]))
(define final_scores (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r count]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! final_scores (append (or final_scores (list)) (list 0.0)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not score_lists) 0] [(string? score_lists) (string-length score_lists)] [(hash? score_lists) (hash-count score_lists)] [else (length score_lists)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define slist (if score_lists (if (hash? score_lists) (hash-ref score_lists i #f) (safe-index score_lists (int i))) #f))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not slist) 0] [(string? slist) (string-length slist)] [(hash? slist) (hash-count slist)] [else (length slist)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! final_scores (list-set final_scores (int j) (let ([__l (if final_scores (if (hash? final_scores) (hash-ref final_scores j #f) (safe-index final_scores (int j))) #f)] [__r (if slist (if (hash? slist) (hash-ref slist j #f) (safe-index slist (int j))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return final_scores)
))
)
(define (procentual_proximity source_data weights)
  (let/ec _return (begin
(define data_lists (get_data source_data))
(define score_lists (calculate_each_score data_lists weights))
(define final_scores (generate_final_scores score_lists))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not final_scores) 0] [(string? final_scores) (string-length final_scores)] [(hash? final_scores) (hash-count final_scores)] [else (length final_scores)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! source_data (list-set source_data (int i) (append (or (if source_data (if (hash? source_data) (hash-ref source_data i #f) (safe-index source_data (int i))) #f) (list)) (list (if final_scores (if (hash? final_scores) (hash-ref final_scores i #f) (safe-index final_scores (int i))) #f)))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return source_data)
))
)
(define vehicles (list))
(define weights (list 0 0 1))
(define result (procentual_proximity vehicles weights))
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(set! vehicles (append (or vehicles (list)) (list (list 20.0 60.0 2012.0))))
(set! vehicles (append (or vehicles (list)) (list (list 23.0 90.0 2015.0))))
(set! vehicles (append (or vehicles (list)) (list (list 22.0 50.0 2011.0))))
(displayln (to-string result))
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
