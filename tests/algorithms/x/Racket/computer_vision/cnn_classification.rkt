;; Generated by Mochi 0.10.59 on 2025-08-06 22:47 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define (conv2d image kernel)
  (let/ec _return (begin
(define rows (cond [(string? image) (string-length image)] [(hash? image) (hash-count image)] [else (length image)]))
(define cols (cond [(string? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (string-length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [(hash? (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f)) (hash-count (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))] [else (length (if image (if (hash? image) (hash-ref image 0 #f) (list-ref image (int 0))) #f))]))
(define k (cond [(string? kernel) (string-length kernel)] [(hash? kernel) (hash-count kernel)] [else (length kernel)]))
(define output (list))
(define i 0)
(let/ec _break (let loop ()
  (if (<= i (- rows k)) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (<= j (- cols k)) (let/ec _cont
    (define sum 0.0)
    (define ki 0)
    (let/ec _break (let loop ()
  (if (< ki k) (let/ec _cont
    (define kj 0)
    (let/ec _break (let loop ()
  (if (< kj k) (let/ec _cont
    (set! sum (let ([__l sum] [__r (* (if (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l j] [__r kj]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if image (if (hash? image) (hash-ref image (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref image (int (let ([__l i] [__r ki]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l j] [__r kj]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f) (if (hash? (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f)) (hash-ref (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f) kj #f) (list-ref (if kernel (if (hash? kernel) (hash-ref kernel ki #f) (list-ref kernel (int ki))) #f) (int kj))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! kj (let ([__l kj] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! ki (let ([__l ki] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list sum)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! output (append output (list row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return output)
))
)
(define (relu_matrix m)
  (let/ec _return (begin
(define out (list))
(let/ec _break (for ([row m])
  (let/ec _cont
(define new_row (list))
(let/ec _break (for ([v row])
  (let/ec _cont
(if (> v 0.0) (let ()
(set! new_row (append new_row (list v)))
) (let ()
(set! new_row (append new_row (list 0.0)))
))
  )))
(set! out (append out (list new_row)))
  )))
(_return out)
))
)
(define (max_pool2x2 m)
  (let/ec _return (begin
(define rows (cond [(string? m) (string-length m)] [(hash? m) (hash-count m)] [else (length m)]))
(define cols (cond [(string? (if m (if (hash? m) (hash-ref m 0 #f) (list-ref m (int 0))) #f)) (string-length (if m (if (hash? m) (hash-ref m 0 #f) (list-ref m (int 0))) #f))] [(hash? (if m (if (hash? m) (hash-ref m 0 #f) (list-ref m (int 0))) #f)) (hash-count (if m (if (hash? m) (hash-ref m 0 #f) (list-ref m (int 0))) #f))] [else (length (if m (if (hash? m) (hash-ref m 0 #f) (list-ref m (int 0))) #f))]))
(define out (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i rows) (let/ec _cont
    (define new_row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j cols) (let/ec _cont
    (define max_val (if (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (if (hash? (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) j #f) (list-ref (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (int j))) #f))
    (if (> (if (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (if (hash? (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) max_val) (let ()
(set! max_val (if (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (if (hash? (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if m (if (hash? m) (hash-ref m i #f) (list-ref m (int i))) #f) (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
) (void))
    (if (> (if (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) j #f) (list-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int j))) #f) max_val) (let ()
(set! max_val (if (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) j #f) (list-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int j))) #f))
) (void))
    (if (> (if (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) max_val) (let ()
(set! max_val (if (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref (if m (if (hash? m) (hash-ref m (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref m (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f))
) (void))
    (set! new_row (append new_row (list max_val)))
    (set! j (let ([__l j] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list new_row)))
    (set! i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (flatten m)
  (let/ec _return (begin
(define res (list))
(let/ec _break (for ([row m])
  (let/ec _cont
(let/ec _break (for ([v row])
  (let/ec _cont
(set! res (append res (list v)))
  )))
  )))
(_return res)
))
)
(define (dense inputs weights bias)
  (let/ec _return (begin
(define s bias)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? inputs) (string-length inputs)] [(hash? inputs) (hash-count inputs)] [else (length inputs)])) (let/ec _cont
    (set! s (let ([__l s] [__r (* (if inputs (if (hash? inputs) (hash-ref inputs i #f) (list-ref inputs (int i))) #f) (if weights (if (hash? weights) (hash-ref weights i #f) (list-ref weights (int i))) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return s)
))
)
(define (exp_approx x)
  (let/ec _return (begin
(define sum 1.0)
(define term 1.0)
(define i 1)
(let/ec _break (let loop ()
  (if (<= i 10) (let/ec _cont
    (set! term (/ (* term x) i))
    (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sum)
))
)
(define (sigmoid x)
  (let/ec _return (begin
(_return (/ 1.0 (let ([__l 1.0] [__r (exp_approx (- x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define image (list (list 0.0 1.0 1.0 0.0 0.0 0.0) (list 0.0 1.0 1.0 0.0 0.0 0.0) (list 0.0 0.0 1.0 1.0 0.0 0.0) (list 0.0 0.0 1.0 1.0 0.0 0.0) (list 0.0 0.0 0.0 0.0 0.0 0.0) (list 0.0 0.0 0.0 0.0 0.0 0.0)))
(define kernel (list (list 1.0 0.0 (- 1.0)) (list 1.0 0.0 (- 1.0)) (list 1.0 0.0 (- 1.0))))
(define conv (conv2d image kernel))
(define activated (relu_matrix conv))
(define pooled (max_pool2x2 activated))
(define flat (flatten pooled))
(define weights (list 0.5 (- 0.4) 0.3 0.1))
(define bias 0.0)
(define output (dense flat weights bias))
(define probability (sigmoid output))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(if (>= probability 0.5) (let ()
(displayln "Abnormality detected")
) (let ()
(displayln "Normal")
))
(displayln "Probability:")
(displayln probability)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
