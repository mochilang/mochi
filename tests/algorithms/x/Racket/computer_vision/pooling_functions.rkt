;; Generated by Mochi 0.10.59 on 2025-08-06 22:47 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define (maxpooling arr size stride)
  (let/ec _return (begin
(define n (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]))
(if (or (equal? n 0) (not (equal? (cond [(string? (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f)) (string-length (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f))] [(hash? (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f)) (hash-count (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f))] [else (length (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f))]) n))) (let ()
(panic "The input array is not a square matrix")
) (void))
(define result (list))
(define i 0)
(let/ec _break (let loop ()
  (if (<= (let ([__l i] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) n) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (<= (let ([__l j] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) n) (let/ec _cont
    (define max_val (if (if arr (if (hash? arr) (hash-ref arr i #f) (list-ref arr (int i))) #f) (if (hash? (if arr (if (hash? arr) (hash-ref arr i #f) (list-ref arr (int i))) #f)) (hash-ref (if arr (if (hash? arr) (hash-ref arr i #f) (list-ref arr (int i))) #f) j #f) (list-ref (if arr (if (hash? arr) (hash-ref arr i #f) (list-ref arr (int i))) #f) (int j))) #f))
    (define r i)
    (let/ec _break (let loop ()
  (if (< r (let ([__l i] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (define c j)
    (let/ec _break (let loop ()
  (if (< c (let ([__l j] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (define val (if (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f) (if (hash? (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f)) (hash-ref (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f) c #f) (list-ref (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f) (int c))) #f))
    (if (> val max_val) (let ()
(set! max_val val)
) (void))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list max_val)))
    (set! j (let ([__l j] [__r stride]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! result (append result (list row)))
    (set! i (let ([__l i] [__r stride]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (avgpooling arr size stride)
  (let/ec _return (begin
(define n (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]))
(if (or (equal? n 0) (not (equal? (cond [(string? (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f)) (string-length (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f))] [(hash? (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f)) (hash-count (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f))] [else (length (if arr (if (hash? arr) (hash-ref arr 0 #f) (list-ref arr (int 0))) #f))]) n))) (let ()
(panic "The input array is not a square matrix")
) (void))
(define result (list))
(define i 0)
(let/ec _break (let loop ()
  (if (<= (let ([__l i] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) n) (let/ec _cont
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (<= (let ([__l j] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) n) (let/ec _cont
    (define sum 0)
    (define r i)
    (let/ec _break (let loop ()
  (if (< r (let ([__l i] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (define c j)
    (let/ec _break (let loop ()
  (if (< c (let ([__l j] [__r size]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (set! sum (let ([__l sum] [__r (if (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f) (if (hash? (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f)) (hash-ref (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f) c #f) (list-ref (if arr (if (hash? arr) (hash-ref arr r #f) (list-ref arr (int r))) #f) (int c))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list (quotient sum (* size size)))))
    (set! j (let ([__l j] [__r stride]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! result (append result (list row)))
    (set! i (let ([__l i] [__r stride]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (print_matrix mat)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)])) (let/ec _cont
    (define line "")
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))])) (let/ec _cont
    (set! line (string-append line (format "~a" (if (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f) j #f) (list-ref (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f) (int j))) #f))))
    (if (< j (- (cond [(string? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))]) 1)) (let ()
(set! line (string-append line " "))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (main)
  (let/ec _return (begin
(define arr1 (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12) (list 13 14 15 16)))
(define arr2 (list (list 147 180 122) (list 241 76 32) (list 126 13 157)))
(print_matrix (maxpooling arr1 2 2))
(print_matrix (maxpooling arr2 2 1))
(print_matrix (avgpooling arr1 2 2))
(print_matrix (avgpooling arr2 2 1))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
