;; Generated by Mochi 0.10.59 on 2025-08-06 22:47 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define (update_image_and_anno all_img_list all_annos idxs output_size scale_range filter_scale)
  (let/ec _return (begin
(define height (if output_size (if (hash? output_size) (hash-ref output_size 0 #f) (list-ref output_size (int 0))) #f))
(define width (if output_size (if (hash? output_size) (hash-ref output_size 1 #f) (list-ref output_size (int 1))) #f))
(define output_img (list))
(define r 0)
(let/ec _break (let loop ()
  (if (< r height) (let/ec _cont
    (define row (list))
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c width) (let/ec _cont
    (set! row (append row (list 0)))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! output_img (append output_img (list row)))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define scale_x (/ (let ([__l (if scale_range (if (hash? scale_range) (hash-ref scale_range 0 #f) (list-ref scale_range (int 0))) #f)] [__r (if scale_range (if (hash? scale_range) (hash-ref scale_range 1 #f) (list-ref scale_range (int 1))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
(define scale_y (/ (let ([__l (if scale_range (if (hash? scale_range) (hash-ref scale_range 0 #f) (list-ref scale_range (int 0))) #f)] [__r (if scale_range (if (hash? scale_range) (hash-ref scale_range 1 #f) (list-ref scale_range (int 1))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
(define divid_point_x (int (* scale_x (exact->inexact width))))
(define divid_point_y (int (* scale_y (exact->inexact height))))
(define new_anno (list))
(define path_list (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? idxs) (string-length idxs)] [(hash? idxs) (hash-count idxs)] [else (length idxs)])) (let/ec _cont
    (define index (if idxs (if (hash? idxs) (hash-ref idxs i #f) (list-ref idxs (int i))) #f))
    (define path (if all_img_list (if (hash? all_img_list) (hash-ref all_img_list index #f) (list-ref all_img_list (int index))) #f))
    (set! path_list (append path_list (list path)))
    (define img_annos (if all_annos (if (hash? all_annos) (hash-ref all_annos index #f) (list-ref all_annos (int index))) #f))
    (if (equal? i 0) (let ()
(define y0 0)
(let/ec _break (let loop ()
  (if (< y0 divid_point_y) (let/ec _cont
    (define x0 0)
    (let/ec _break (let loop ()
  (if (< x0 divid_point_x) (let/ec _cont
    (set! output_img (list-set output_img y0 (list-set (list-ref output_img y0) x0 (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! x0 (let ([__l x0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y0 (let ([__l y0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define j0 0)
(let/ec _break (let loop ()
  (if (< j0 (cond [(string? img_annos) (string-length img_annos)] [(hash? img_annos) (hash-count img_annos)] [else (length img_annos)])) (let/ec _cont
    (define bbox (if img_annos (if (hash? img_annos) (hash-ref img_annos j0 #f) (list-ref img_annos (int j0))) #f))
    (define xmin (* (if bbox (if (hash? bbox) (hash-ref bbox 1 #f) (list-ref bbox (int 1))) #f) scale_x))
    (define ymin (* (if bbox (if (hash? bbox) (hash-ref bbox 2 #f) (list-ref bbox (int 2))) #f) scale_y))
    (define xmax (* (if bbox (if (hash? bbox) (hash-ref bbox 3 #f) (list-ref bbox (int 3))) #f) scale_x))
    (define ymax (* (if bbox (if (hash? bbox) (hash-ref bbox 4 #f) (list-ref bbox (int 4))) #f) scale_y))
    (set! new_anno (append new_anno (list (list (if bbox (if (hash? bbox) (hash-ref bbox 0 #f) (list-ref bbox (int 0))) #f) xmin ymin xmax ymax))))
    (set! j0 (let ([__l j0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
) (let ()
(if (equal? i 1) (let ()
(define y1 0)
(let/ec _break (let loop ()
  (if (< y1 divid_point_y) (let/ec _cont
    (define x1 divid_point_x)
    (let/ec _break (let loop ()
  (if (< x1 width) (let/ec _cont
    (set! output_img (list-set output_img y1 (list-set (list-ref output_img y1) x1 (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! x1 (let ([__l x1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y1 (let ([__l y1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define j1 0)
(let/ec _break (let loop ()
  (if (< j1 (cond [(string? img_annos) (string-length img_annos)] [(hash? img_annos) (hash-count img_annos)] [else (length img_annos)])) (let/ec _cont
    (define bbox1 (if img_annos (if (hash? img_annos) (hash-ref img_annos j1 #f) (list-ref img_annos (int j1))) #f))
    (define xmin1 (let ([__l scale_x] [__r (* (if bbox1 (if (hash? bbox1) (hash-ref bbox1 1 #f) (list-ref bbox1 (int 1))) #f) (- 1.0 scale_x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define ymin1 (* (if bbox1 (if (hash? bbox1) (hash-ref bbox1 2 #f) (list-ref bbox1 (int 2))) #f) scale_y))
    (define xmax1 (let ([__l scale_x] [__r (* (if bbox1 (if (hash? bbox1) (hash-ref bbox1 3 #f) (list-ref bbox1 (int 3))) #f) (- 1.0 scale_x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define ymax1 (* (if bbox1 (if (hash? bbox1) (hash-ref bbox1 4 #f) (list-ref bbox1 (int 4))) #f) scale_y))
    (set! new_anno (append new_anno (list (list (if bbox1 (if (hash? bbox1) (hash-ref bbox1 0 #f) (list-ref bbox1 (int 0))) #f) xmin1 ymin1 xmax1 ymax1))))
    (set! j1 (let ([__l j1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
) (let ()
(if (equal? i 2) (let ()
(define y2 divid_point_y)
(let/ec _break (let loop ()
  (if (< y2 height) (let/ec _cont
    (define x2 0)
    (let/ec _break (let loop ()
  (if (< x2 divid_point_x) (let/ec _cont
    (set! output_img (list-set output_img y2 (list-set (list-ref output_img y2) x2 (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! x2 (let ([__l x2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y2 (let ([__l y2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define j2 0)
(let/ec _break (let loop ()
  (if (< j2 (cond [(string? img_annos) (string-length img_annos)] [(hash? img_annos) (hash-count img_annos)] [else (length img_annos)])) (let/ec _cont
    (define bbox2 (if img_annos (if (hash? img_annos) (hash-ref img_annos j2 #f) (list-ref img_annos (int j2))) #f))
    (define xmin2 (* (if bbox2 (if (hash? bbox2) (hash-ref bbox2 1 #f) (list-ref bbox2 (int 1))) #f) scale_x))
    (define ymin2 (let ([__l scale_y] [__r (* (if bbox2 (if (hash? bbox2) (hash-ref bbox2 2 #f) (list-ref bbox2 (int 2))) #f) (- 1.0 scale_y))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define xmax2 (* (if bbox2 (if (hash? bbox2) (hash-ref bbox2 3 #f) (list-ref bbox2 (int 3))) #f) scale_x))
    (define ymax2 (let ([__l scale_y] [__r (* (if bbox2 (if (hash? bbox2) (hash-ref bbox2 4 #f) (list-ref bbox2 (int 4))) #f) (- 1.0 scale_y))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! new_anno (append new_anno (list (list (if bbox2 (if (hash? bbox2) (hash-ref bbox2 0 #f) (list-ref bbox2 (int 0))) #f) xmin2 ymin2 xmax2 ymax2))))
    (set! j2 (let ([__l j2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
) (let ()
(define y3 divid_point_y)
(let/ec _break (let loop ()
  (if (< y3 height) (let/ec _cont
    (define x3 divid_point_x)
    (let/ec _break (let loop ()
  (if (< x3 width) (let/ec _cont
    (set! output_img (list-set output_img y3 (list-set (list-ref output_img y3) x3 (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! x3 (let ([__l x3] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! y3 (let ([__l y3] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define j3 0)
(let/ec _break (let loop ()
  (if (< j3 (cond [(string? img_annos) (string-length img_annos)] [(hash? img_annos) (hash-count img_annos)] [else (length img_annos)])) (let/ec _cont
    (define bbox3 (if img_annos (if (hash? img_annos) (hash-ref img_annos j3 #f) (list-ref img_annos (int j3))) #f))
    (define xmin3 (let ([__l scale_x] [__r (* (if bbox3 (if (hash? bbox3) (hash-ref bbox3 1 #f) (list-ref bbox3 (int 1))) #f) (- 1.0 scale_x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define ymin3 (let ([__l scale_y] [__r (* (if bbox3 (if (hash? bbox3) (hash-ref bbox3 2 #f) (list-ref bbox3 (int 2))) #f) (- 1.0 scale_y))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define xmax3 (let ([__l scale_x] [__r (* (if bbox3 (if (hash? bbox3) (hash-ref bbox3 3 #f) (list-ref bbox3 (int 3))) #f) (- 1.0 scale_x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define ymax3 (let ([__l scale_y] [__r (* (if bbox3 (if (hash? bbox3) (hash-ref bbox3 4 #f) (list-ref bbox3 (int 4))) #f) (- 1.0 scale_y))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! new_anno (append new_anno (list (list (if bbox3 (if (hash? bbox3) (hash-ref bbox3 0 #f) (list-ref bbox3 (int 0))) #f) xmin3 ymin3 xmax3 ymax3))))
    (set! j3 (let ([__l j3] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(if (> filter_scale 0.0) (let ()
(define filtered (list))
(define k 0)
(let/ec _break (let loop ()
  (if (< k (cond [(string? new_anno) (string-length new_anno)] [(hash? new_anno) (hash-count new_anno)] [else (length new_anno)])) (let/ec _cont
    (define anno (if new_anno (if (hash? new_anno) (hash-ref new_anno k #f) (list-ref new_anno (int k))) #f))
    (define w (- (if anno (if (hash? anno) (hash-ref anno 3 #f) (list-ref anno (int 3))) #f) (if anno (if (hash? anno) (hash-ref anno 1 #f) (list-ref anno (int 1))) #f)))
    (define h (- (if anno (if (hash? anno) (hash-ref anno 4 #f) (list-ref anno (int 4))) #f) (if anno (if (hash? anno) (hash-ref anno 2 #f) (list-ref anno (int 2))) #f)))
    (if (and (< filter_scale w) (< filter_scale h)) (let ()
(set! filtered (append filtered (list anno)))
) (void))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! new_anno filtered)
) (void))
(_return (hash "img" output_img "annos" new_anno "path" (if path_list (if (hash? path_list) (hash-ref path_list 0 #f) (list-ref path_list (int 0))) #f)))
))
)
(define (main)
  (let/ec _return (begin
(define all_img_list (list "img0.jpg" "img1.jpg" "img2.jpg" "img3.jpg"))
(define all_annos (list (list (list 0.0 0.1 0.1 0.4 0.4)) (list (list 1.0 0.2 0.3 0.5 0.7)) (list (list 2.0 0.6 0.2 0.9 0.5)) (list (list 3.0 0.5 0.5 0.8 0.8))))
(define idxs (list 0 1 2 3))
(define output_size (list 100 100))
(define scale_range (list 0.4 0.6))
(define filter_scale 0.05)
(define res (update_image_and_anno all_img_list all_annos idxs output_size scale_range filter_scale))
(define new_annos (if res (hash-ref res "annos" #f) #f))
(define path (if res (hash-ref res "path" #f) #f))
(displayln (string-append "Base image: " path))
(displayln (string-append "Mosaic annotation count: " (format "~a" (cond [(string? new_annos) (string-length new_annos)] [(hash? new_annos) (hash-count new_annos)] [else (length new_annos)]))))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? new_annos) (string-length new_annos)] [(hash? new_annos) (hash-count new_annos)] [else (length new_annos)])) (let/ec _cont
    (define a (if new_annos (if (hash? new_annos) (hash-ref new_annos i #f) (list-ref new_annos (int i))) #f))
    (displayln (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (format "~a" (if a (if (hash? a) (hash-ref a 0 #f) (list-ref a (int 0))) #f)) " ") (format "~a" (if a (if (hash? a) (hash-ref a 1 #f) (list-ref a (int 1))) #f))) " ") (format "~a" (if a (if (hash? a) (hash-ref a 2 #f) (list-ref a (int 2))) #f))) " ") (format "~a" (if a (if (hash? a) (hash-ref a 3 #f) (list-ref a (int 3))) #f))) " ") (format "~a" (if a (if (hash? a) (hash-ref a 4 #f) (list-ref a (int 4))) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
