;; Generated by Mochi 0.10.66 on 2025-08-16 12:32 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (number->string x)]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) 0)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define (log2 x)
  (let/ec _return (begin
(define k 0.0)
(define v x)
(let/ec _break (let loop ()
  (if (let ([__l v] [__r 2.0]) (cond [(and (number? __l) (number? __r)) (>= __l __r)] [else (>= (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! v (/ v 2.0))
      (set! k (let ([__l k] [__r 1.0]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(let/ec _break (let loop ()
  (if (let ([__l v] [__r 1.0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! v (* v 2.0))
      (set! k (- k 1.0))
    )
    (loop)) (void))))
(define z (/ (- v 1.0) (let ([__l v] [__r 1.0]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(define zpow z)
(define sum z)
(define i 3)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 9]) (cond [(and (number? __l) (number? __r)) (<= __l __r)] [else (<= (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! zpow (* (* zpow z) z))
      (set! sum (let ([__l sum] [__r (/ zpow (exact->inexact i))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (set! i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define ln2 0.6931471805599453)
(_return (let ([__l k] [__r (/ (* 2.0 sum) ln2)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
)
(define (analyze_text text)
  (let/ec _return (begin
(define single (let ([h (make-hash)]) h))
(define double (let ([h (make-hash)]) h))
(define n (cond [(not text) 0] [(string? text) (string-length text)] [(hash? text) (hash-count text)] [else (length text)]))
(if (equal? n 0) (let ()
(_return (let ([h (make-hash)]) (hash-set! h "single" single) (hash-set! h "double" double) h))
) (void))
(define last (slice text (- n 1) n))
(if (hash-has-key? single last) (let ()
(if (hash? single) (hash-set! single last (let ([__l (if single (hash-ref single last 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (begin (set! single (make-hash)) (hash-set! single last (let ([__l (if single (hash-ref single last 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (let ()
(if (hash? single) (hash-set! single last 1) (begin (set! single (make-hash)) (hash-set! single last 1)))
))
(define first (slice text 0 1))
(define pair0 (string-append " " first))
(if (hash? double) (hash-set! double pair0 1) (begin (set! double (make-hash)) (hash-set! double pair0 1)))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (- n 1)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define ch (slice text i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (if (hash-has-key? single ch) (let ()
(if (hash? single) (hash-set! single ch (let ([__l (if single (hash-ref single ch 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (begin (set! single (make-hash)) (hash-set! single ch (let ([__l (if single (hash-ref single ch 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (let ()
(if (hash? single) (hash-set! single ch 1) (begin (set! single (make-hash)) (hash-set! single ch 1)))
))
      (define seq (slice text i (let ([__l i] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (if (hash-has-key? double seq) (let ()
(if (hash? double) (hash-set! double seq (let ([__l (if double (hash-ref double seq 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (begin (set! double (make-hash)) (hash-set! double seq (let ([__l (if double (hash-ref double seq 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (let ()
(if (hash? double) (hash-set! double seq 1) (begin (set! double (make-hash)) (hash-set! double seq 1)))
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (let ([h (make-hash)]) (hash-set! h "single" single) (hash-set! h "double" double) h))
))
)
(define (round_to_int x)
  (let/ec _return (begin
(if (let ([__l x] [__r 0.0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(_return (int (- x 0.5)))
) (void))
(_return (int (let ([__l x] [__r 0.5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (calculate_entropy text)
  (let/ec _return (begin
(define counts (analyze_text text))
(define alphas " abcdefghijklmnopqrstuvwxyz")
(define total1 0)
(let ([__seq (if counts (hash-ref counts "single" #f) #f)]) (let/ec _break (for ([ch (in-hash-keys __seq)])
  (let/ec _cont
(set! total1 (let ([__l total1] [__r (if (if counts (hash-ref counts "single" #f) #f) (if (hash? (if counts (hash-ref counts "single" #f) #f)) (hash-ref (if counts (hash-ref counts "single" #f) #f) ch #f) (safe-index (if counts (hash-ref counts "single" #f) #f) (int ch))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
  ))))
(define h1 0.0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not alphas) 0] [(string? alphas) (string-length alphas)] [(hash? alphas) (hash-count alphas)] [else (length alphas)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define ch (slice alphas i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (if (hash-has-key? (if counts (hash-ref counts "single" #f) #f) ch) (let ()
(define prob (/ (exact->inexact (if (if counts (hash-ref counts "single" #f) #f) (if (hash? (if counts (hash-ref counts "single" #f) #f)) (hash-ref (if counts (hash-ref counts "single" #f) #f) ch #f) (safe-index (if counts (hash-ref counts "single" #f) #f) (int ch))) #f)) (exact->inexact total1)))
(set! h1 (let ([__l h1] [__r (* prob (log2 prob))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define first_entropy (- h1))
(displayln (string-append (to-string (round_to_int first_entropy)) ".0"))
(define total2 0)
(let ([__seq (if counts (hash-ref counts "double" #f) #f)]) (let/ec _break (for ([seq (in-hash-keys __seq)])
  (let/ec _cont
(set! total2 (let ([__l total2] [__r (if (if counts (hash-ref counts "double" #f) #f) (if (hash? (if counts (hash-ref counts "double" #f) #f)) (hash-ref (if counts (hash-ref counts "double" #f) #f) seq #f) (safe-index (if counts (hash-ref counts "double" #f) #f) (int seq))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
  ))))
(define h2 0.0)
(define a0 0)
(let/ec _break (let loop ()
  (if (let ([__l a0] [__r (cond [(not alphas) 0] [(string? alphas) (string-length alphas)] [(hash? alphas) (hash-count alphas)] [else (length alphas)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define ch0 (slice alphas a0 (let ([__l a0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (define a1 0)
      (let/ec _break (let loop ()
  (if (let ([__l a1] [__r (cond [(not alphas) 0] [(string? alphas) (string-length alphas)] [(hash? alphas) (hash-count alphas)] [else (length alphas)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define ch1 (slice alphas a1 (let ([__l a1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (define seq (string-append ch0 ch1))
      (if (hash-has-key? (if counts (hash-ref counts "double" #f) #f) seq) (let ()
(define prob (/ (exact->inexact (if (if counts (hash-ref counts "double" #f) #f) (if (hash? (if counts (hash-ref counts "double" #f) #f)) (hash-ref (if counts (hash-ref counts "double" #f) #f) seq #f) (safe-index (if counts (hash-ref counts "double" #f) #f) (int seq))) #f)) (exact->inexact total2)))
(set! h2 (let ([__l h2] [__r (* prob (log2 prob))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! a1 (let ([__l a1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! a0 (let ([__l a0] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define second_entropy (- h2))
(displayln (string-append (to-string (round_to_int second_entropy)) ".0"))
(define diff (- second_entropy first_entropy))
(displayln (string-append (to-string (round_to_int diff)) ".0"))
))
)
(define text1 (string-append (string-append "Behind Winston's back the voice " "from the telescreen was still ") "babbling and the overfulfilment"))
(define text3 (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append "Had repulsive dashwoods suspicion sincerity but advantage now him. " "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. ") "You greatest jointure saw horrible. He private he on be imagine ") "suppose. Fertile beloved evident through no service elderly is. Blind ") "there if every no so at. Own neglected you preferred way sincerity ") "delivered his attempted. To of message cottage windows do besides ") "against uncivil.  Delightful unreserved impossible few estimating ") "men favourable see entreaties. She propriety immediate was improving. ") "He or entrance humoured likewise moderate. Much nor game son say ") "feel. Fat make met can must form into gate. Me we offending prevailed ") "discovery."))
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(calculate_entropy text1)
(calculate_entropy text3)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
