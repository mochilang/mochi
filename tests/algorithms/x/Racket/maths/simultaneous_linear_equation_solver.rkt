;; Generated by Mochi 0.10.61 on 2025-08-08 17:18 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (let* ([s (format "~a" x)]) (if (regexp-match? #rx"[.]0$" s) (substring s 0 (- (string-length s) 2)) s))]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (floor x)
  (let/ec _return (begin
(define i (int x))
(if (> (exact->inexact i) x) (let ()
(set! i (- i 1))
) (void))
(_return (exact->inexact i))
))
)
(define (pow10 n)
  (let/ec _return (begin
(define p 1.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (begin
    (let/ec _cont
      (set! p (* p 10.0))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return p)
))
)
(define (round x n)
  (let/ec _return (begin
(define m (pow10 n))
(_return (/ (floor (let ([__l (* x m)] [__r 0.5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) m))
))
)
(define (clone_matrix mat)
  (let/ec _return (begin
(define new_mat (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not mat) 0] [(string? mat) (string-length mat)] [(hash? mat) (hash-count mat)] [else (length mat)])) (begin
    (let/ec _cont
      (define row (list))
      (define j 0)
      (let/ec _break (let loop ()
  (if (< j (cond [(not (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) 0] [(string? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (string-length (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))] [(hash? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (hash-count (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))] [else (length (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f))])) (begin
    (let/ec _cont
      (set! row (append row (list (if (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f) (if (hash? (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f)) (hash-ref (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f) j #f) (list-ref (if mat (if (hash? mat) (hash-ref mat i #f) (list-ref mat (int i))) #f) (int j))) #f))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! new_mat (append new_mat (list row)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return new_mat)
))
)
(define (solve_simultaneous equations)
  (let/ec _return (begin
(define n (cond [(not equations) 0] [(string? equations) (string-length equations)] [(hash? equations) (hash-count equations)] [else (length equations)]))
(if (equal? n 0) (let ()
(panic "solve_simultaneous() requires n lists of length n+1")
) (void))
(define m (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (begin
    (let/ec _cont
      (if (not (equal? (cond [(not (if equations (if (hash? equations) (hash-ref equations i #f) (list-ref equations (int i))) #f)) 0] [(string? (if equations (if (hash? equations) (hash-ref equations i #f) (list-ref equations (int i))) #f)) (string-length (if equations (if (hash? equations) (hash-ref equations i #f) (list-ref equations (int i))) #f))] [(hash? (if equations (if (hash? equations) (hash-ref equations i #f) (list-ref equations (int i))) #f)) (hash-count (if equations (if (hash? equations) (hash-ref equations i #f) (list-ref equations (int i))) #f))] [else (length (if equations (if (hash? equations) (hash-ref equations i #f) (list-ref equations (int i))) #f))]) m)) (let ()
(panic "solve_simultaneous() requires n lists of length n+1")
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define a (clone_matrix equations))
(define row 0)
(let/ec _break (let loop ()
  (if (< row n) (begin
    (let/ec _cont
      (define pivot row)
      (let/ec _break (let loop ()
  (if (and (< pivot n) (equal? (if (if a (if (hash? a) (hash-ref a pivot #f) (list-ref a (int pivot))) #f) (if (hash? (if a (if (hash? a) (hash-ref a pivot #f) (list-ref a (int pivot))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a pivot #f) (list-ref a (int pivot))) #f) row #f) (list-ref (if a (if (hash? a) (hash-ref a pivot #f) (list-ref a (int pivot))) #f) (int row))) #f) 0.0)) (begin
    (let/ec _cont
      (set! pivot (let ([__l pivot] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (if (equal? pivot n) (let ()
(panic "solve_simultaneous() requires at least 1 full equation")
) (void))
      (if (not (equal? pivot row)) (let ()
(define temp (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f))
(set! a (list-set a (int row) (if a (if (hash? a) (hash-ref a pivot #f) (list-ref a (int pivot))) #f)))
(set! a (list-set a (int pivot) temp))
) (void))
      (define pivot_val (if (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) (if (hash? (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) row #f) (list-ref (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) (int row))) #f))
      (define col 0)
      (let/ec _break (let loop ()
  (if (< col m) (begin
    (let/ec _cont
      (set! a (list-set a row (list-set (list-ref a row) col (/ (if (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) (if (hash? (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) col #f) (list-ref (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) (int col))) #f) pivot_val))))
      (set! col (let ([__l col] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define r 0)
      (let/ec _break (let loop ()
  (if (< r n) (begin
    (let/ec _cont
      (if (not (equal? r row)) (let ()
(define factor (if (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f) (if (hash? (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f) row #f) (list-ref (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f) (int row))) #f))
(define c 0)
(let/ec _break (let loop ()
  (if (< c m) (begin
    (let/ec _cont
      (set! a (list-set a r (list-set (list-ref a r) c (- (if (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f) (if (hash? (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f) c #f) (list-ref (if a (if (hash? a) (hash-ref a r #f) (list-ref a (int r))) #f) (int c))) #f) (* factor (if (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) (if (hash? (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) c #f) (list-ref (if a (if (hash? a) (hash-ref a row #f) (list-ref a (int row))) #f) (int c))) #f))))))
      (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
) (void))
      (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! row (let ([__l row] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define res (list))
(define k 0)
(let/ec _break (let loop ()
  (if (< k n) (begin
    (let/ec _cont
      (set! res (append res (list (round (if (if a (if (hash? a) (hash-ref a k #f) (list-ref a (int k))) #f) (if (hash? (if a (if (hash? a) (hash-ref a k #f) (list-ref a (int k))) #f)) (hash-ref (if a (if (hash? a) (hash-ref a k #f) (list-ref a (int k))) #f) (- m 1) #f) (list-ref (if a (if (hash? a) (hash-ref a k #f) (list-ref a (int k))) #f) (int (- m 1)))) #f) 5))))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (test_solver)
  (let/ec _return (begin
(define a (list (list 1.0 2.0 3.0) (list 4.0 5.0 6.0)))
(define r1 (solve_simultaneous a))
(if (not (and (and (equal? (cond [(not r1) 0] [(string? r1) (string-length r1)] [(hash? r1) (hash-count r1)] [else (length r1)]) 2) (equal? (if r1 (if (hash? r1) (hash-ref r1 0 #f) (list-ref r1 (int 0))) #f) (- 0.0 1.0))) (equal? (if r1 (if (hash? r1) (hash-ref r1 1 #f) (list-ref r1 (int 1))) #f) 2.0))) (let ()
(panic "test1 failed")
) (void))
(define b (list (list 0.0 (- 0.0 3.0) 1.0 7.0) (list 3.0 2.0 (- 0.0 1.0) 11.0) (list 5.0 1.0 (- 0.0 2.0) 12.0)))
(define r2 (solve_simultaneous b))
(if (not (and (and (and (equal? (cond [(not r2) 0] [(string? r2) (string-length r2)] [(hash? r2) (hash-count r2)] [else (length r2)]) 3) (equal? (if r2 (if (hash? r2) (hash-ref r2 0 #f) (list-ref r2 (int 0))) #f) 6.4)) (equal? (if r2 (if (hash? r2) (hash-ref r2 1 #f) (list-ref r2 (int 1))) #f) 1.2)) (equal? (if r2 (if (hash? r2) (hash-ref r2 2 #f) (list-ref r2 (int 2))) #f) 10.6))) (let ()
(panic "test2 failed")
) (void))
))
)
(define (main)
  (let/ec _return (begin
(test_solver)
(define eq (list (list 2.0 1.0 1.0 1.0 1.0 4.0) (list 1.0 2.0 1.0 1.0 1.0 5.0) (list 1.0 1.0 2.0 1.0 1.0 6.0) (list 1.0 1.0 1.0 2.0 1.0 7.0) (list 1.0 1.0 1.0 1.0 2.0 8.0)))
(displayln (to-string (solve_simultaneous eq)))
(displayln (to-string (solve_simultaneous (list (list 4.0 2.0)))))
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
