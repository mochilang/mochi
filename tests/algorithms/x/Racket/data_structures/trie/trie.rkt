;; Generated by Mochi 0.10.60 on 2025-08-07 14:57 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (new_trie)
  (let/ec _return (begin
(_return (hash "nodes" (list (hash "children" (hash) "is_leaf" #f))))
))
)
(define (remove_key m k)
  (let/ec _return (begin
(define out (hash))
(let/ec _break (for ([key (in-hash-keys m)])
  (let/ec _cont
(if (not (string=? key k)) (let ()
(set! out (hash-set (or out (hash)) key (if m (hash-ref m key 0) #f)))
) (void))
  )))
(_return out)
))
)
(define (insert trie word)
  (let/ec _return (begin
(define nodes (if trie (hash-ref trie "nodes" #f) #f))
(define curr 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? word) (string-length word)] [(hash? word) (hash-count word)] [else (length word)])) (let/ec _cont
    (define ch (substring word i (+ i 1)))
    (define child_idx (- 1))
    (define children (if (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f) (hash-ref (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f) "children" #f) #f))
    (if (hash-has-key? children ch) (let ()
(set! child_idx (if children (hash-ref children ch 0) #f))
) (let ()
(define new_node (hash "children" (hash) "is_leaf" #f))
(set! nodes (append nodes (list new_node)))
(set! child_idx (- (cond [(string? nodes) (string-length nodes)] [(hash? nodes) (hash-count nodes)] [else (length nodes)]) 1))
(define new_children children)
(set! new_children (hash-set (or new_children (hash)) ch child_idx))
(define node (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f))
(set! node (hash-set (or node (hash)) "children" new_children))
(set! nodes (list-set nodes (int curr) node))
))
    (set! curr child_idx)
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define node (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f))
(set! node (hash-set (or node (hash)) "is_leaf" #t))
(set! nodes (list-set nodes (int curr) node))
(set! trie (hash-set (or trie (hash)) "nodes" nodes))
))
)
(define (insert_many trie words)
  (let/ec _return (begin
(let/ec _break (for ([w words])
  (let/ec _cont
(insert trie w)
  )))
))
)
(define (find trie word)
  (let/ec _return (begin
(define nodes (if trie (hash-ref trie "nodes" #f) #f))
(define curr 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? word) (string-length word)] [(hash? word) (hash-count word)] [else (length word)])) (let/ec _cont
    (define ch (substring word i (+ i 1)))
    (define children (if (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f) (hash-ref (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f) "children" #f) #f))
    (if (not (hash-has-key? children ch)) (let ()
(_return #f)
) (void))
    (set! curr (if children (hash-ref children ch 0) #f))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define node (if nodes (if (hash? nodes) (hash-ref nodes curr #f) (list-ref nodes (int curr))) #f))
(_return (if node (hash-ref node "is_leaf" #f) #f))
))
)
(define (delete trie word)
  (let/ec _return (begin
(define nodes (if trie (hash-ref trie "nodes" #f) #f))
(define (_delete idx pos)
  (let/ec _return (begin
(if (equal? pos (cond [(string? word) (string-length word)] [(hash? word) (hash-count word)] [else (length word)])) (let ()
(define node (if nodes (if (hash? nodes) (hash-ref nodes idx #f) (list-ref nodes (int idx))) #f))
(if (not (if node (hash-ref node "is_leaf" #f) #f)) (let ()
(_return #f)
) (void))
(set! node (hash-set (or node (hash)) "is_leaf" #f))
(set! nodes (list-set nodes (int idx) node))
(_return (equal? (cond [(string? (if node (hash-ref node "children" #f) #f)) (string-length (if node (hash-ref node "children" #f) #f))] [(hash? (if node (hash-ref node "children" #f) #f)) (hash-count (if node (hash-ref node "children" #f) #f))] [else (length (if node (hash-ref node "children" #f) #f))]) 0))
) (void))
(define node (if nodes (if (hash? nodes) (hash-ref nodes idx #f) (list-ref nodes (int idx))) #f))
(define children (if node (hash-ref node "children" #f) #f))
(define ch (substring word pos (+ pos 1)))
(if (not (hash-has-key? children ch)) (let ()
(_return #f)
) (void))
(define child_idx (if children (hash-ref children ch 0) #f))
(define should_delete (_delete child_idx (let ([__l pos] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! node (if nodes (if (hash? nodes) (hash-ref nodes idx #f) (list-ref nodes (int idx))) #f))
(if should_delete (let ()
(define new_children (remove_key (if node (hash-ref node "children" #f) #f) ch))
(set! node (hash-set (or node (hash)) "children" new_children))
(set! nodes (list-set nodes (int idx) node))
(_return (and (equal? (cond [(string? new_children) (string-length new_children)] [(hash? new_children) (hash-count new_children)] [else (length new_children)]) 0) (not (if node (hash-ref node "is_leaf" #f) #f))))
) (void))
(set! nodes (list-set nodes (int idx) node))
(_return #f)
))
)
(_delete 0 0)
(set! trie (hash-set (or trie (hash)) "nodes" nodes))
))
)
(define (print_words trie)
  (let/ec _return (begin
(define (dfs idx word)
  (let/ec _return (begin
(define node (if (if trie (hash-ref trie "nodes" #f) #f) (if (hash? (if trie (hash-ref trie "nodes" #f) #f)) (hash-ref (if trie (hash-ref trie "nodes" #f) #f) idx #f) (list-ref (if trie (hash-ref trie "nodes" #f) #f) (int idx))) #f))
(if (if node (hash-ref node "is_leaf" #f) #f) (let ()
(displayln word)
) (void))
(let/ec _break (for ([key (in-hash-keys (if node (hash-ref node "children" #f) #f))])
  (let/ec _cont
(dfs (if (if node (hash-ref node "children" #f) #f) (if (hash? (if node (hash-ref node "children" #f) #f)) (hash-ref (if node (hash-ref node "children" #f) #f) key #f) (list-ref (if node (hash-ref node "children" #f) #f) (int key))) #f) (string-append word key))
  )))
))
)
(dfs 0 "")
))
)
(define (test_trie)
  (let/ec _return (begin
(define words (list "banana" "bananas" "bandana" "band" "apple" "all" "beast"))
(define trie (new_trie))
(insert_many trie words)
(define ok #t)
(let/ec _break (for ([w words])
  (let/ec _cont
(set! ok (and ok (find trie w)))
  )))
(set! ok (and ok (find trie "banana")))
(define t (find trie "bandanas"))
(set! ok (and ok (not t)))
(define t2 (find trie "apps"))
(set! ok (and ok (not t2)))
(set! ok (and ok (find trie "apple")))
(set! ok (and ok (find trie "all")))
(delete trie "all")
(define t3 (find trie "all"))
(set! ok (and ok (not t3)))
(delete trie "banana")
(define t4 (find trie "banana"))
(set! ok (and ok (not t4)))
(set! ok (and ok (find trie "bananas")))
(_return ok)
))
)
(define (print_results msg passes)
  (let/ec _return (begin
(if passes (let ()
(displayln (string-append msg " works!"))
) (let ()
(displayln (string-append msg " doesn't work :("))
))
))
)
(define trie (new_trie))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(print_results "Testing trie functionality" (test_trie))
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
