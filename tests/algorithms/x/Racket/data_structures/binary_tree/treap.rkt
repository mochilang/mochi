;; Generated by Mochi 0.10.59 on 2025-08-06 22:47 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define NIL (- 0 1))
(define node_values (list))
(define node_priors (list))
(define node_lefts (list))
(define node_rights (list))
(define seed 1)
(define (random)
  (let/ec _return (begin
(set! seed (modulo (let ([__l (* seed 13)] [__r 7]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 100))
(_return (/ (exact->inexact seed) 100.0))
))
)
(define (new_node value)
  (let/ec _return (begin
(set! node_values (append node_values (list value)))
(set! node_priors (append node_priors (list (random))))
(set! node_lefts (append node_lefts (list NIL)))
(set! node_rights (append node_rights (list NIL)))
(_return (- (cond [(string? node_values) (string-length node_values)] [(hash? node_values) (hash-count node_values)] [else (length node_values)]) 1))
))
)
(define (split root value)
  (let/ec _return (begin
(if (equal? root NIL) (let ()
(_return (hash "left" NIL "right" NIL))
) (void))
(if (< value (if node_values (if (hash? node_values) (hash-ref node_values root #f) (list-ref node_values (int root))) #f)) (let ()
(define res (string-split (if node_lefts (if (hash? node_lefts) (hash-ref node_lefts root #f) (list-ref node_lefts (int root))) #f) value))
(set! node_lefts (list-set node_lefts (int root) (if res (hash-ref res "right" #f) #f)))
(_return (hash "left" (if res (hash-ref res "left" #f) #f) "right" root))
) (void))
(define res (string-split (if node_rights (if (hash? node_rights) (hash-ref node_rights root #f) (list-ref node_rights (int root))) #f) value))
(set! node_rights (list-set node_rights (int root) (if res (hash-ref res "left" #f) #f)))
(_return (hash "left" root "right" (if res (hash-ref res "right" #f) #f)))
))
)
(define (merge left right)
  (let/ec _return (begin
(if (equal? left NIL) (let ()
(_return right)
) (void))
(if (equal? right NIL) (let ()
(_return left)
) (void))
(if (< (if node_priors (if (hash? node_priors) (hash-ref node_priors left #f) (list-ref node_priors (int left))) #f) (if node_priors (if (hash? node_priors) (hash-ref node_priors right #f) (list-ref node_priors (int right))) #f)) (let ()
(set! node_rights (list-set node_rights (int left) (merge (if node_rights (if (hash? node_rights) (hash-ref node_rights left #f) (list-ref node_rights (int left))) #f) right)))
(_return left)
) (void))
(set! node_lefts (list-set node_lefts (int right) (merge left (if node_lefts (if (hash? node_lefts) (hash-ref node_lefts right #f) (list-ref node_lefts (int right))) #f))))
(_return right)
))
)
(define (insert root value)
  (let/ec _return (begin
(define node (new_node value))
(define res (string-split root value))
(_return (merge (merge (if res (hash-ref res "left" #f) #f) node) (if res (hash-ref res "right" #f) #f)))
))
)
(define (erase root value)
  (let/ec _return (begin
(define res1 (string-split root (- value 1)))
(define res2 (string-split (if res1 (hash-ref res1 "right" #f) #f) value))
(_return (merge (if res1 (hash-ref res1 "left" #f) #f) (if res2 (hash-ref res2 "right" #f) #f)))
))
)
(define (inorder i acc)
  (let/ec _return (begin
(if (equal? i NIL) (let ()
(_return acc)
) (void))
(define left_acc (inorder (if node_lefts (if (hash? node_lefts) (hash-ref node_lefts i #f) (list-ref node_lefts (int i))) #f) acc))
(define with_node (append left_acc (list (if node_values (if (hash? node_values) (hash-ref node_values i #f) (list-ref node_values (int i))) #f))))
(_return (inorder (if node_rights (if (hash? node_rights) (hash-ref node_rights i #f) (list-ref node_rights (int i))) #f) with_node))
))
)
(define (main)
  (let/ec _return (begin
(define root NIL)
(set! root (insert root 1))
(displayln (format "~a" (inorder root (list))))
(set! root (insert root 3))
(set! root (insert root 5))
(set! root (insert root 17))
(set! root (insert root 19))
(set! root (insert root 2))
(set! root (insert root 16))
(set! root (insert root 4))
(set! root (insert root 0))
(displayln (format "~a" (inorder root (list))))
(set! root (insert root 4))
(set! root (insert root 4))
(set! root (insert root 4))
(displayln (format "~a" (inorder root (list))))
(set! root (erase root 0))
(displayln (format "~a" (inorder root (list))))
(set! root (erase root 4))
(displayln (format "~a" (inorder root (list))))
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
