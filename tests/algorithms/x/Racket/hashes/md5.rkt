;; Generated by Mochi 0.10.66 on 2025-08-15 15:17 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (number->string x)]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define MOD 4294967296)
(define ASCII " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")
(define (ord ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not ASCII) 0] [(string? ASCII) (string-length ASCII)] [(hash? ASCII) (hash-count ASCII)] [else (length ASCII)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (string=? (slice ASCII i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ch) (let ()
(_return (let ([__l 32] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return 0)
))
)
(define (to_little_endian s)
  (let/ec _return (begin
(if (not (equal? (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) 32)) (let ()
(panic "Input must be of length 32")
) (void))
(_return (let ([__l (let ([__l (let ([__l (slice s 24 32)] [__r (slice s 16 24)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (slice s 8 16)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (slice s 0 8)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
)
(define (int_to_bits n width)
  (let/ec _return (begin
(define bits "")
(define num n)
(let/ec _break (let loop ()
  (if (let ([__l num] [__r 0]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! bits (string-append (to-string (modulo num 2)) bits))
      (set! num (floor (/ num 2)))
    )
    (loop)) (void))))
(let/ec _break (let loop ()
  (if (let ([__l (cond [(not bits) 0] [(string? bits) (string-length bits)] [(hash? bits) (hash-count bits)] [else (length bits)])] [__r width]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! bits (string-append "0" bits))
    )
    (loop)) (void))))
(if (let ([__l (cond [(not bits) 0] [(string? bits) (string-length bits)] [(hash? bits) (hash-count bits)] [else (length bits)])] [__r width]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (let ()
(set! bits (slice bits (- (cond [(not bits) 0] [(string? bits) (string-length bits)] [(hash? bits) (hash-count bits)] [else (length bits)]) width) (cond [(not bits) 0] [(string? bits) (string-length bits)] [(hash? bits) (hash-count bits)] [else (length bits)])))
) (void))
(_return bits)
))
)
(define (bits_to_int bits)
  (let/ec _return (begin
(define num 0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not bits) 0] [(string? bits) (string-length bits)] [(hash? bits) (hash-count bits)] [else (length bits)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (string=? (slice bits i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) "1") (let ()
(set! num (let ([__l (* num 2)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(set! num (* num 2))
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return num)
))
)
(define (to_hex n)
  (let/ec _return (begin
(define digits "0123456789abcdef")
(if (equal? n 0) (let ()
(_return "0")
) (void))
(define num n)
(define s "")
(let/ec _break (let loop ()
  (if (let ([__l num] [__r 0]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (begin
    (let/ec _cont
      (define d (modulo num 16))
      (set! s (string-append (slice digits d (let ([__l d] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) s))
      (set! num (floor (/ num 16)))
    )
    (loop)) (void))))
(_return s)
))
)
(define (reformat_hex i)
  (let/ec _return (begin
(if (let ([__l i] [__r 0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(panic "Input must be non-negative")
) (void))
(define hex (to_hex i))
(let/ec _break (let loop ()
  (if (let ([__l (cond [(not hex) 0] [(string? hex) (string-length hex)] [(hash? hex) (hash-count hex)] [else (length hex)])] [__r 8]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! hex (string-append "0" hex))
    )
    (loop)) (void))))
(if (let ([__l (cond [(not hex) 0] [(string? hex) (string-length hex)] [(hash? hex) (hash-count hex)] [else (length hex)])] [__r 8]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (let ()
(set! hex (slice hex (- (cond [(not hex) 0] [(string? hex) (string-length hex)] [(hash? hex) (hash-count hex)] [else (length hex)]) 8) (cond [(not hex) 0] [(string? hex) (string-length hex)] [(hash? hex) (hash-count hex)] [else (length hex)])))
) (void))
(define le "")
(define j (- (cond [(not hex) 0] [(string? hex) (string-length hex)] [(hash? hex) (hash-count hex)] [else (length hex)]) 2))
(let/ec _break (let loop ()
  (if (let ([__l j] [__r 0]) (cond [(and (number? __l) (number? __r)) (>= __l __r)] [else (>= (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! le (string-append le (slice hex j (let ([__l j] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
      (set! j (- j 2))
    )
    (loop)) (void))))
(_return le)
))
)
(define (preprocess message)
  (let/ec _return (begin
(define bit_string "")
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not message) 0] [(string? message) (string-length message)] [(hash? message) (hash-count message)] [else (length message)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define ch (slice message i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (set! bit_string (string-append bit_string (int_to_bits (ord ch) 8)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define start_len (int_to_bits (cond [(not bit_string) 0] [(string? bit_string) (string-length bit_string)] [(hash? bit_string) (hash-count bit_string)] [else (length bit_string)]) 64))
(set! bit_string (string-append bit_string "1"))
(let/ec _break (let loop ()
  (if (not (equal? (modulo (cond [(not bit_string) 0] [(string? bit_string) (string-length bit_string)] [(hash? bit_string) (hash-count bit_string)] [else (length bit_string)]) 512) 448)) (begin
    (let/ec _cont
      (set! bit_string (string-append bit_string "0"))
    )
    (loop)) (void))))
(set! bit_string (string-append (string-append bit_string (to_little_endian (slice start_len 32 64))) (to_little_endian (slice start_len 0 32))))
(_return bit_string)
))
)
(define (get_block_words bit_string)
  (let/ec _return (begin
(if (not (equal? (modulo (cond [(not bit_string) 0] [(string? bit_string) (string-length bit_string)] [(hash? bit_string) (hash-count bit_string)] [else (length bit_string)]) 512) 0)) (let ()
(panic "Input must have length that's a multiple of 512")
) (void))
(define blocks (list))
(define pos 0)
(let/ec _break (let loop ()
  (if (let ([__l pos] [__r (cond [(not bit_string) 0] [(string? bit_string) (string-length bit_string)] [(hash? bit_string) (hash-count bit_string)] [else (length bit_string)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define block (list))
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r 512]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define part (slice bit_string (let ([__l pos] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l (let ([__l pos] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r 32]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (define word (bits_to_int (to_little_endian part)))
      (set! block (append (or block (list)) (list word)))
      (set! i (let ([__l i] [__r 32]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! blocks (append (or blocks (list)) (list block)))
      (set! pos (let ([__l pos] [__r 512]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return blocks)
))
)
(define (bit_and a b)
  (let/ec _return (begin
(define x a)
(define y b)
(define res 0)
(define bit 1)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 32]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (and (equal? (modulo x 2) 1) (equal? (modulo y 2) 1)) (let ()
(set! res (let ([__l res] [__r bit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! x (floor (/ x 2)))
      (set! y (floor (/ y 2)))
      (set! bit (* bit 2))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (bit_or a b)
  (let/ec _return (begin
(define x a)
(define y b)
(define res 0)
(define bit 1)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 32]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define abit (modulo x 2))
      (define bbit (modulo y 2))
      (if (or (equal? abit 1) (equal? bbit 1)) (let ()
(set! res (let ([__l res] [__r bit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! x (floor (/ x 2)))
      (set! y (floor (/ y 2)))
      (set! bit (* bit 2))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (bit_xor a b)
  (let/ec _return (begin
(define x a)
(define y b)
(define res 0)
(define bit 1)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r 32]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define abit (modulo x 2))
      (define bbit (modulo y 2))
      (if (equal? (modulo (let ([__l abit] [__r bbit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2) 1) (let ()
(set! res (let ([__l res] [__r bit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! x (floor (/ x 2)))
      (set! y (floor (/ y 2)))
      (set! bit (* bit 2))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return res)
))
)
(define (not_32 i)
  (let/ec _return (begin
(if (let ([__l i] [__r 0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(panic "Input must be non-negative")
) (void))
(_return (- 4294967295 i))
))
)
(define (sum_32 a b)
  (let/ec _return (begin
(_return (modulo (let ([__l a] [__r b]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) MOD))
))
)
(define (lshift num k)
  (let/ec _return (begin
(define result (modulo num MOD))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r k]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! result (modulo (* result 2) MOD))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return result)
))
)
(define (rshift num k)
  (let/ec _return (begin
(define result num)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r k]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! result (floor (/ result 2)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return result)
))
)
(define (left_rotate_32 i shift)
  (let/ec _return (begin
(if (let ([__l i] [__r 0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(panic "Input must be non-negative")
) (void))
(if (let ([__l shift] [__r 0]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (let ()
(panic "Shift must be non-negative")
) (void))
(define left (lshift i shift))
(define right (rshift i (- 32 shift)))
(_return (modulo (let ([__l left] [__r right]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) MOD))
))
)
(define (md5_me message)
  (let/ec _return (begin
(define bit_string (preprocess message))
(define added_consts (list 3614090360 3905402710 606105819 3250441966 4118548399 1200080426 2821735955 4249261313 1770035416 2336552879 4294925233 2304563134 1804603682 4254626195 2792965006 1236535329 4129170786 3225465664 643717713 3921069994 3593408605 38016083 3634488961 3889429448 568446438 3275163606 4107603335 1163531501 2850285829 4243563512 1735328473 2368359562 4294588738 2272392833 1839030562 4259657740 2763975236 1272893353 4139469664 3200236656 681279174 3936430074 3572445317 76029189 3654602809 3873151461 530742520 3299628645 4096336452 1126891415 2878612391 4237533241 1700485571 2399980690 4293915773 2240044497 1873313359 4264355552 2734768916 1309151649 4149444226 3174756917 718787259 3951481745))
(define shift_amounts (list 7 12 17 22 7 12 17 22 7 12 17 22 7 12 17 22 5 9 14 20 5 9 14 20 5 9 14 20 5 9 14 20 4 11 16 23 4 11 16 23 4 11 16 23 4 11 16 23 6 10 15 21 6 10 15 21 6 10 15 21 6 10 15 21))
(define a0 1732584193)
(define b0 4023233417)
(define c0 2562383102)
(define d0 271733878)
(define blocks (get_block_words bit_string))
(define bi 0)
(let/ec _break (let loop ()
  (if (let ([__l bi] [__r (cond [(not blocks) 0] [(string? blocks) (string-length blocks)] [(hash? blocks) (hash-count blocks)] [else (length blocks)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define block (if blocks (if (hash? blocks) (hash-ref blocks bi #f) (safe-index blocks (int bi))) #f))
      (define a a0)
      (define b b0)
      (define c c0)
      (define d d0)
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r 64]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define f 0)
      (define g 0)
      (if (let ([__l i] [__r 15]) (cond [(and (number? __l) (number? __r)) (<= __l __r)] [else (<= (int __l) (int __r))])) (let ()
(set! f (bit_xor d (bit_and b (bit_xor c d))))
(set! g i)
) (let ()
(if (let ([__l i] [__r 31]) (cond [(and (number? __l) (number? __r)) (<= __l __r)] [else (<= (int __l) (int __r))])) (let ()
(set! f (bit_xor c (bit_and d (bit_xor b c))))
(set! g (modulo (let ([__l (* 5 i)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 16))
) (let ()
(if (let ([__l i] [__r 47]) (cond [(and (number? __l) (number? __r)) (<= __l __r)] [else (<= (int __l) (int __r))])) (let ()
(set! f (bit_xor (bit_xor b c) d))
(set! g (modulo (let ([__l (* 3 i)] [__r 5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 16))
) (let ()
(set! f (bit_xor c (bit_or b (not_32 d))))
(set! g (modulo (* 7 i) 16))
))
))
))
      (set! f (sum_32 f a))
      (set! f (sum_32 f (if added_consts (if (hash? added_consts) (hash-ref added_consts i #f) (safe-index added_consts (int i))) #f)))
      (set! f (sum_32 f (if block (if (hash? block) (hash-ref block g #f) (safe-index block (int g))) #f)))
      (define rotated (left_rotate_32 f (if shift_amounts (if (hash? shift_amounts) (hash-ref shift_amounts i #f) (safe-index shift_amounts (int i))) #f)))
      (define new_b (sum_32 b rotated))
      (set! a d)
      (set! d c)
      (set! c b)
      (set! b new_b)
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! a0 (sum_32 a0 a))
      (set! b0 (sum_32 b0 b))
      (set! c0 (sum_32 c0 c))
      (set! d0 (sum_32 d0 d))
      (set! bi (let ([__l bi] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define digest (let ([__l (let ([__l (let ([__l (reformat_hex a0)] [__r (reformat_hex b0)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (reformat_hex c0)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (reformat_hex d0)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(_return digest)
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
