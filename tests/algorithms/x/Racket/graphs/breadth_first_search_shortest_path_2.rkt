;; Generated by Mochi 0.10.60 on 2025-08-07 16:04 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (contains xs x)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (let/ec _cont
    (if (string=? (if xs (if (hash? xs) (hash-ref xs i #f) (list-ref xs (int i))) #f) x) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (contains_key m key)
  (let/ec _return (begin
(let/ec _break (for ([k (in-hash-keys m)])
  (let/ec _cont
(if (string=? k key) (let ()
(_return #t)
) (void))
  )))
(_return #f)
))
)
(define (bfs_shortest_path graph start goal)
  (let/ec _return (begin
(define explored (list))
(define queue (list (list start)))
(if (string=? start goal) (let ()
(_return (list start))
) (void))
(let/ec _break (let loop ()
  (if (> (cond [(string? queue) (string-length queue)] [(hash? queue) (hash-count queue)] [else (length queue)]) 0) (let/ec _cont
    (define path (if queue (if (hash? queue) (hash-ref queue 0 #f) (list-ref queue (int 0))) #f))
    (set! queue (slice queue 1 (cond [(string? queue) (string-length queue)] [(hash? queue) (hash-count queue)] [else (length queue)])))
    (define node (if path (if (hash? path) (hash-ref path (- (cond [(string? path) (string-length path)] [(hash? path) (hash-count path)] [else (length path)]) 1) #f) (list-ref path (int (- (cond [(string? path) (string-length path)] [(hash? path) (hash-count path)] [else (length path)]) 1)))) #f))
    (if (not (contains explored node)) (let ()
(define neighbours (if graph (hash-ref graph node (list)) #f))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? neighbours) (string-length neighbours)] [(hash? neighbours) (hash-count neighbours)] [else (length neighbours)])) (let/ec _cont
    (define neighbour (if neighbours (if (hash? neighbours) (hash-ref neighbours i #f) (list-ref neighbours (int i))) #f))
    (define new_path path)
    (set! new_path (append new_path (list neighbour)))
    (set! queue (append queue (list new_path)))
    (if (string=? neighbour goal) (let ()
(_return new_path)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! explored (append explored (list node)))
) (void))
    (loop)) (void))))
(_return (list))
))
)
(define (bfs_shortest_path_distance graph start target)
  (let/ec _return (begin
(if (or (not (contains_key graph start)) (not (contains_key graph target))) (let ()
(_return (- 1))
) (void))
(if (string=? start target) (let ()
(_return 0)
) (void))
(define queue (list start))
(define visited (list start))
(define dist (hash))
(set! dist (hash-set (or dist (hash)) start 0))
(set! dist (hash-set (or dist (hash)) target (- 1)))
(let/ec _break (let loop ()
  (if (> (cond [(string? queue) (string-length queue)] [(hash? queue) (hash-count queue)] [else (length queue)]) 0) (let/ec _cont
    (define node (if queue (if (hash? queue) (hash-ref queue 0 #f) (list-ref queue (int 0))) #f))
    (set! queue (slice queue 1 (cond [(string? queue) (string-length queue)] [(hash? queue) (hash-count queue)] [else (length queue)])))
    (if (string=? node target) (let ()
(if (or (equal? (if dist (hash-ref dist target 0) #f) (- 1)) (< (if dist (hash-ref dist node 0) #f) (if dist (hash-ref dist target 0) #f))) (let ()
(set! dist (hash-set (or dist (hash)) target (if dist (hash-ref dist node 0) #f)))
) (void))
) (void))
    (define adj (if graph (hash-ref graph node (list)) #f))
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i (cond [(string? adj) (string-length adj)] [(hash? adj) (hash-count adj)] [else (length adj)])) (let/ec _cont
    (define next (if adj (if (hash? adj) (hash-ref adj i #f) (list-ref adj (int i))) #f))
    (if (not (contains visited next)) (let ()
(set! visited (append visited (list next)))
(set! queue (append queue (list next)))
(set! dist (hash-set (or dist (hash)) next (let ([__l (if dist (hash-ref dist node 0) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (loop)) (void))))
(_return (if dist (hash-ref dist target 0) #f))
))
)
(define demo_graph (hash "A" (list "B" "C" "E") "B" (list "A" "D" "E") "C" (list "A" "F" "G") "D" (list "B") "E" (list "A" "B" "D") "F" (list "C") "G" (list "C")))
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
