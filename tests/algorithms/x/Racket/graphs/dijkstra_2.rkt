;; Generated by Mochi 0.10.60 on 2025-08-07 16:04 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define INF 1000000000.0)
(define (print_dist dist)
  (let/ec _return (begin
(displayln "Vertex Distance")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? dist) (string-length dist)] [(hash? dist) (hash-count dist)] [else (length dist)])) (let/ec _cont
    (if (>= (if dist (if (hash? dist) (hash-ref dist i #f) (list-ref dist (int i))) #f) INF) (let ()
(displayln (string-join (map (lambda (x) (format "~a" x)) (list i "\tINF")) " "))
) (let ()
(displayln (string-join (map (lambda (x) (format "~a" x)) (list i "\t" (int (if dist (if (hash? dist) (hash-ref dist i #f) (list-ref dist (int i))) #f)))) " "))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (min_dist mdist vset)
  (let/ec _return (begin
(define min_val INF)
(define min_ind (- 1))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? mdist) (string-length mdist)] [(hash? mdist) (hash-count mdist)] [else (length mdist)])) (let/ec _cont
    (if (and (not (if vset (if (hash? vset) (hash-ref vset i #f) (list-ref vset (int i))) #f)) (< (if mdist (if (hash? mdist) (hash-ref mdist i #f) (list-ref mdist (int i))) #f) min_val)) (let ()
(set! min_val (if mdist (if (hash? mdist) (hash-ref mdist i #f) (list-ref mdist (int i))) #f))
(set! min_ind i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return min_ind)
))
)
(define (dijkstra graph src)
  (let/ec _return (begin
(define v (cond [(string? graph) (string-length graph)] [(hash? graph) (hash-count graph)] [else (length graph)]))
(define mdist (list))
(define vset (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i v) (let/ec _cont
    (set! mdist (append mdist (list INF)))
    (set! vset (append vset (list #f)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! mdist (list-set mdist (int src) 0.0))
(define count 0)
(let/ec _break (let loop ()
  (if (< count (- v 1)) (let/ec _cont
    (define u (min_dist mdist vset))
    (set! vset (list-set vset (int u) #t))
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i v) (let/ec _cont
    (define alt (let ([__l (if mdist (if (hash? mdist) (hash-ref mdist u #f) (list-ref mdist (int u))) #f)] [__r (if (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f) (if (hash? (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f)) (hash-ref (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f) i #f) (list-ref (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f) (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (and (and (not (if vset (if (hash? vset) (hash-ref vset i #f) (list-ref vset (int i))) #f)) (< (if (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f) (if (hash? (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f)) (hash-ref (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f) i #f) (list-ref (if graph (if (hash? graph) (hash-ref graph u #f) (list-ref graph (int u))) #f) (int i))) #f) INF)) (< alt (if mdist (if (hash? mdist) (hash-ref mdist i #f) (list-ref mdist (int i))) #f))) (let ()
(set! mdist (list-set mdist (int i) alt))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return mdist)
))
)
(define (main)
  (let/ec _return (begin
(define graph (list (list 0.0 10.0 INF INF 5.0) (list INF 0.0 1.0 INF 2.0) (list INF INF 0.0 4.0 INF) (list INF INF 6.0 0.0 INF) (list INF 3.0 9.0 2.0 0.0)))
(define dist (dijkstra graph 0))
(print_dist dist)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
