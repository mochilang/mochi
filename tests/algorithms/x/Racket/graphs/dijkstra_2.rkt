;; Generated by Mochi 0.10.65 on 2025-08-14 17:09 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (number->string x)]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define INF 1000000000.0)
(define (print_dist dist)
  (let/ec _return (begin
(displayln "Vertex Distance")
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not dist) 0] [(string? dist) (string-length dist)] [(hash? dist) (hash-count dist)] [else (length dist)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (let ([__l (if dist (if (hash? dist) (hash-ref dist i #f) (safe-index dist (int i))) #f)] [__r INF]) (cond [(and (number? __l) (number? __r)) (>= __l __r)] [else (>= (int __l) (int __r))])) (let ()
(displayln (string-join (map (lambda (x) (to-string x)) (list i "\tINF")) " "))
) (let ()
(displayln (string-join (map (lambda (x) (to-string x)) (list i "\t" (int (if dist (if (hash? dist) (hash-ref dist i #f) (safe-index dist (int i))) #f)))) " "))
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
)
(define (min_dist mdist vset)
  (let/ec _return (begin
(define min_val INF)
(define min_ind (- 1))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not mdist) 0] [(string? mdist) (string-length mdist)] [(hash? mdist) (hash-count mdist)] [else (length mdist)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (and (not (if vset (if (hash? vset) (hash-ref vset i #f) (safe-index vset (int i))) #f)) (let ([__l (if mdist (if (hash? mdist) (hash-ref mdist i #f) (safe-index mdist (int i))) #f)] [__r min_val]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))]))) (let ()
(set! min_val (if mdist (if (hash? mdist) (hash-ref mdist i #f) (safe-index mdist (int i))) #f))
(set! min_ind i)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return min_ind)
))
)
(define (dijkstra graph src)
  (let/ec _return (begin
(define v (cond [(not graph) 0] [(string? graph) (string-length graph)] [(hash? graph) (hash-count graph)] [else (length graph)]))
(define mdist (list))
(define vset (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r v]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! mdist (append (or mdist (list)) (list INF)))
      (set! vset (append (or vset (list)) (list #f)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(set! mdist (list-set mdist (int src) 0.0))
(define count 0)
(let/ec _break (let loop ()
  (if (let ([__l count] [__r (- v 1)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define u (min_dist mdist vset))
      (set! vset (list-set vset (int u) #t))
      (define i 0)
      (let/ec _break (let loop ()
  (if (let ([__l i] [__r v]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define alt (let ([__l (if mdist (if (hash? mdist) (hash-ref mdist u #f) (safe-index mdist (int u))) #f)] [__r (if (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f) (if (hash? (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f)) (hash-ref (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f) i #f) (safe-index (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f) (int i))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (if (and (and (not (if vset (if (hash? vset) (hash-ref vset i #f) (safe-index vset (int i))) #f)) (let ([__l (if (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f) (if (hash? (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f)) (hash-ref (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f) i #f) (safe-index (if graph (if (hash? graph) (hash-ref graph u #f) (safe-index graph (int u))) #f) (int i))) #f)] [__r INF]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))]))) (let ([__l alt] [__r (if mdist (if (hash? mdist) (hash-ref mdist i #f) (safe-index mdist (int i))) #f)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))]))) (let ()
(set! mdist (list-set mdist (int i) alt))
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return mdist)
))
)
(define (main)
  (let/ec _return (begin
(define graph (list (list 0.0 10.0 INF INF 5.0) (list INF 0.0 1.0 INF 2.0) (list INF INF 0.0 4.0 INF) (list INF INF 6.0 0.0 INF) (list INF 3.0 9.0 2.0 0.0)))
(define dist (dijkstra graph 0))
(print_dist dist)
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
