;; Generated by Mochi 0.10.65 on 2025-08-14 17:09 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-monotonic-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (to-string x)
  (cond
    [(number? x) (number->string x)]
    [else (format "~a" x)]))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (to-string s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (safe-index lst idx) (let ([i (int idx)]) (if (and (>= i 0) (< i (length lst))) (list-ref lst i) #f)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (list-set lst idx val)
  (define i (int idx))
  (define len (length lst))
  (cond
    [(>= i len) (append lst (make-list (- i len) '()) (list val))]
    [(zero? i) (cons val (cdr lst))]
    [else (cons (car lst) (list-set (cdr lst) (sub1 i) val))]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (if (string? bs) (string->bytes/utf-8 bs) (list->bytes bs)))))
(define (_fetch url [opts #f]) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define (json-encode x)
  (define (sanitize v)
    (cond
      [(hash? v) (for/hash ([k (in-hash-keys v)]) (values (string->symbol k) (sanitize (hash-ref v k))))]
      [(list? v) (map sanitize v)]
      [else v]))
  (jsexpr->string (sanitize x)))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))
(define __name__ "__main__")
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))

(define EDGE_ARRAY (list (list (list "ab" "e1") (list "ac" "e3") (list "ad" "e5") (list "bc" "e4") (list "bd" "e2") (list "be" "e6") (list "bh" "e12") (list "cd" "e2") (list "ce" "e4") (list "de" "e1") (list "df" "e8") (list "dg" "e5") (list "dh" "e10") (list "ef" "e3") (list "eg" "e2") (list "fg" "e6") (list "gh" "e6") (list "hi" "e3")) (list (list "ab" "e1") (list "ac" "e3") (list "ad" "e5") (list "bc" "e4") (list "bd" "e2") (list "be" "e6") (list "cd" "e2") (list "de" "e1") (list "df" "e8") (list "ef" "e3") (list "eg" "e2") (list "fg" "e6")) (list (list "ab" "e1") (list "ac" "e3") (list "bc" "e4") (list "bd" "e2") (list "de" "e1") (list "df" "e8") (list "dg" "e5") (list "ef" "e3") (list "eg" "e2") (list "eh" "e12") (list "fg" "e6") (list "fh" "e10") (list "gh" "e6")) (list (list "ab" "e1") (list "ac" "e3") (list "bc" "e4") (list "bd" "e2") (list "bh" "e12") (list "cd" "e2") (list "df" "e8") (list "dh" "e10")) (list (list "ab" "e1") (list "ac" "e3") (list "ad" "e5") (list "bc" "e4") (list "bd" "e2") (list "cd" "e2") (list "ce" "e4") (list "de" "e1") (list "df" "e8") (list "dg" "e5") (list "ef" "e3") (list "eg" "e2") (list "fg" "e6"))))
(define (contains lst item)
  (let/ec _return (begin
(let/ec _break (for ([v lst])
  (let/ec _cont
(if (string=? v item) (let ()
(_return #t)
) (void))
  )))
(_return #f)
))
)
(define (get_distinct_edge edge_array)
  (let/ec _return (begin
(define distinct (list))
(let/ec _break (for ([row edge_array])
  (let/ec _cont
(let/ec _break (for ([item row])
  (let/ec _cont
(define e (if item (if (hash? item) (hash-ref item 0 #f) (safe-index item (int 0))) #f))
(if (not (contains distinct e)) (let ()
(set! distinct (append (or distinct (list)) (list e)))
) (void))
  )))
  )))
(_return distinct)
))
)
(define (get_bitcode edge_array de)
  (let/ec _return (begin
(define bitcode "")
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not edge_array) 0] [(string? edge_array) (string-length edge_array)] [(hash? edge_array) (hash-count edge_array)] [else (length edge_array)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define found #f)
      (let/ec _break (for ([item (if edge_array (if (hash? edge_array) (hash-ref edge_array i #f) (safe-index edge_array (int i))) #f)])
  (let/ec _cont
(if (string=? (if item (if (hash? item) (hash-ref item 0 #f) (safe-index item (int 0))) #f) de) (let ()
(set! found #t)
(_break)
) (void))
  )))
      (if found (let ()
(set! bitcode (string-append bitcode "1"))
) (let ()
(set! bitcode (string-append bitcode "0"))
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return bitcode)
))
)
(define (count_ones s)
  (let/ec _return (begin
(define c 0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (string=? (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) "1") (let ()
(set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return c)
))
)
(define (get_frequency_table edge_array)
  (let/ec _return (begin
(define distinct (get_distinct_edge edge_array))
(define table (list))
(let/ec _break (for ([e distinct])
  (let/ec _cont
(define bit (get_bitcode edge_array e))
(define cnt (count_ones bit))
(define entry (let ([h (make-hash)]) (hash-set! h "edge" e) (hash-set! h "count" (to-string cnt)) (hash-set! h "bit" bit) h))
(set! table (append (or table (list)) (list entry)))
  )))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not table) 0] [(string? table) (string-length table)] [(hash? table) (hash-count table)] [else (length table)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define max_i i)
      (define j (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not table) 0] [(string? table) (string-length table)] [(hash? table) (hash-count table)] [else (length table)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (if (let ([__l (int (if (if table (if (hash? table) (hash-ref table j #f) (safe-index table (int j))) #f) (hash-ref (if table (if (hash? table) (hash-ref table j #f) (safe-index table (int j))) #f) "count" "") #f))] [__r (int (if (if table (if (hash? table) (hash-ref table max_i #f) (safe-index table (int max_i))) #f) (hash-ref (if table (if (hash? table) (hash-ref table max_i #f) (safe-index table (int max_i))) #f) "count" "") #f))]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (let ()
(set! max_i j)
) (void))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (define tmp (if table (if (hash? table) (hash-ref table i #f) (safe-index table (int i))) #f))
      (set! table (list-set table (int i) (if table (if (hash? table) (hash-ref table max_i #f) (safe-index table (int max_i))) #f)))
      (set! table (list-set table (int max_i) tmp))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return table)
))
)
(define (get_nodes freq_table)
  (let/ec _return (begin
(define nodes (let ([h (make-hash)]) h))
(define keys (list))
(let/ec _break (for ([f freq_table])
  (let/ec _cont
(define code (if f (if (hash? f) (hash-ref f "bit" #f) (safe-index f (int "bit"))) #f))
(define edge (if f (if (hash? f) (hash-ref f "edge" #f) (safe-index f (int "edge"))) #f))
(if (hash-has-key? nodes code) (let ()
(if (hash? nodes) (hash-set! nodes code (append (or (if nodes (hash-ref nodes code (list)) #f) (list)) (list edge))) (begin (set! nodes (make-hash)) (hash-set! nodes code (append (or (if nodes (hash-ref nodes code (list)) #f) (list)) (list edge)))))
) (let ()
(if (hash? nodes) (hash-set! nodes code (list edge)) (begin (set! nodes (make-hash)) (hash-set! nodes code (list edge))))
(set! keys (append (or keys (list)) (list code)))
))
  )))
(_return (let ([h (make-hash)]) (hash-set! h "map" nodes) (hash-set! h "keys" keys) h))
))
)
(define (get_cluster nodes)
  (let/ec _return (begin
(define clusters (let ([h (make-hash)]) h))
(define weights (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if nodes (hash-ref nodes "keys" #f) #f)) 0] [(string? (if nodes (hash-ref nodes "keys" #f) #f)) (string-length (if nodes (hash-ref nodes "keys" #f) #f))] [(hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-count (if nodes (hash-ref nodes "keys" #f) #f))] [else (length (if nodes (hash-ref nodes "keys" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define code (if (if nodes (hash-ref nodes "keys" #f) #f) (if (hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-ref (if nodes (hash-ref nodes "keys" #f) #f) i #f) (safe-index (if nodes (hash-ref nodes "keys" #f) #f) (int i))) #f))
      (define wt (count_ones code))
      (if (hash-has-key? clusters wt) (let ()
(if (hash? clusters) (hash-set! clusters wt (append (or (if clusters (hash-ref clusters wt (list)) #f) (list)) (list code))) (begin (set! clusters (make-hash)) (hash-set! clusters wt (append (or (if clusters (hash-ref clusters wt (list)) #f) (list)) (list code)))))
) (let ()
(if (hash? clusters) (hash-set! clusters wt (list code)) (begin (set! clusters (make-hash)) (hash-set! clusters wt (list code))))
(set! weights (append (or weights (list)) (list wt)))
))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (let ([h (make-hash)]) (hash-set! h "clusters" clusters) (hash-set! h "weights" weights) h))
))
)
(define (get_support clusters)
  (let/ec _return (begin
(define sup (list))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define w (if (if clusters (hash-ref clusters "weights" #f) #f) (if (hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-ref (if clusters (hash-ref clusters "weights" #f) #f) i #f) (safe-index (if clusters (hash-ref clusters "weights" #f) #f) (int i))) #f))
      (set! sup (append (or sup (list)) (list (floor (/ (* w 100) (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))]))))))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return sup)
))
)
(define (contains_bits a b)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not a) 0] [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define c1 (slice a i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (define c2 (slice b i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
      (if (and (string=? c1 "1") (not (string=? c2 "1"))) (let ()
(_return #f)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return #t)
))
)
(define (max_cluster_key clusters)
  (let/ec _return (begin
(define m 0)
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define w (if (if clusters (hash-ref clusters "weights" #f) #f) (if (hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-ref (if clusters (hash-ref clusters "weights" #f) #f) i #f) (safe-index (if clusters (hash-ref clusters "weights" #f) #f) (int i))) #f))
      (if (let ([__l w] [__r m]) (cond [(and (number? __l) (number? __r)) (> __l __r)] [else (> (int __l) (int __r))])) (let ()
(set! m w)
) (void))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return m)
))
)
(define (get_cluster_codes clusters wt)
  (let/ec _return (begin
(if (hash-has-key? (if clusters (hash-ref clusters "clusters" #f) #f) wt) (let ()
(_return (if (if clusters (hash-ref clusters "clusters" #f) #f) (if (hash? (if clusters (hash-ref clusters "clusters" #f) #f)) (hash-ref (if clusters (hash-ref clusters "clusters" #f) #f) wt #f) (safe-index (if clusters (hash-ref clusters "clusters" #f) #f) (int wt))) #f))
) (void))
(_return (list))
))
)
(define (create_edge nodes graph gkeys clusters c1 maxk)
  (let/ec _return (begin
(define keys gkeys)
(define codes1 (get_cluster_codes clusters c1))
(define idx1 0)
(let/ec _break (let loop ()
  (if (let ([__l idx1] [__r (cond [(not codes1) 0] [(string? codes1) (string-length codes1)] [(hash? codes1) (hash-count codes1)] [else (length codes1)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define i_code (if codes1 (if (hash? codes1) (hash-ref codes1 idx1 #f) (safe-index codes1 (int idx1))) #f))
      (define count 0)
      (define c2 (let ([__l c1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
      (let/ec _break (let loop ()
  (if (let ([__l c2] [__r maxk]) (cond [(and (number? __l) (number? __r)) (<= __l __r)] [else (<= (int __l) (int __r))])) (begin
    (let/ec _cont
      (define codes2 (get_cluster_codes clusters c2))
      (define j 0)
      (let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not codes2) 0] [(string? codes2) (string-length codes2)] [(hash? codes2) (hash-count codes2)] [else (length codes2)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define j_code (if codes2 (if (hash? codes2) (hash-ref codes2 j #f) (safe-index codes2 (int j))) #f))
      (if (contains_bits i_code j_code) (let ()
(if (hash-has-key? graph i_code) (let ()
(if (hash? graph) (hash-set! graph i_code (append (or (if graph (hash-ref graph i_code (list)) #f) (list)) (list j_code))) (begin (set! graph (make-hash)) (hash-set! graph i_code (append (or (if graph (hash-ref graph i_code (list)) #f) (list)) (list j_code)))))
) (let ()
(if (hash? graph) (hash-set! graph i_code (list j_code)) (begin (set! graph (make-hash)) (hash-set! graph i_code (list j_code))))
(if (not (contains keys i_code)) (let ()
(set! keys (append (or keys (list)) (list i_code)))
) (void))
))
(if (not (contains keys j_code)) (let ()
(set! keys (append (or keys (list)) (list j_code)))
) (void))
(set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (if (equal? count 0) (let ()
(set! c2 (let ([__l c2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(_break)
))
    )
    (loop)) (void))))
      (set! idx1 (let ([__l idx1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return keys)
))
)
(define (construct_graph clusters nodes)
  (let/ec _return (begin
(define maxk (max_cluster_key clusters))
(define top_codes (get_cluster_codes clusters maxk))
(define graph (let ([h (make-hash)]) h))
(define keys (list "Header"))
(if (hash? graph) (hash-set! graph "Header" (list)) (begin (set! graph (make-hash)) (hash-set! graph "Header" (list))))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not top_codes) 0] [(string? top_codes) (string-length top_codes)] [(hash? top_codes) (hash-count top_codes)] [else (length top_codes)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define code (if top_codes (if (hash? top_codes) (hash-ref top_codes i #f) (safe-index top_codes (int i))) #f))
      (if (hash? graph) (hash-set! graph "Header" (append (or (if graph (hash-ref graph "Header" (list)) #f) (list)) (list code))) (begin (set! graph (make-hash)) (hash-set! graph "Header" (append (or (if graph (hash-ref graph "Header" (list)) #f) (list)) (list code)))))
      (if (hash? graph) (hash-set! graph code (list "Header")) (begin (set! graph (make-hash)) (hash-set! graph code (list "Header"))))
      (set! keys (append (or keys (list)) (list code)))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(define c 1)
(let/ec _break (let loop ()
  (if (let ([__l c] [__r maxk]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (set! keys (create_edge nodes graph keys clusters c maxk))
      (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(_return (let ([h (make-hash)]) (hash-set! h "edges" graph) (hash-set! h "keys" keys) h))
))
)
(define paths (list))
(define (copy_list lst)
  (let/ec _return (begin
(define n (list))
(let/ec _break (for ([v lst])
  (let/ec _cont
(set! n (append (or n (list)) (list v)))
  )))
(_return n)
))
)
(define (my_dfs graph start end path)
  (let/ec _return (begin
(define new_path (copy_list path))
(set! new_path (append (or new_path (list)) (list start)))
(if (string=? start end) (let ()
(set! paths (append (or paths (list)) (list new_path)))
(_return void)
) (void))
(let/ec _break (for ([node (if graph (hash-ref graph start (list)) #f)])
  (let/ec _cont
(define seen #f)
(let/ec _break (for ([p new_path])
  (let/ec _cont
(if (equal? p node) (let ()
(set! seen #t)
) (void))
  )))
(if (not seen) (let ()
(my_dfs graph node end new_path)
) (void))
  )))
))
)
(define (find_freq_subgraph_given_support s clusters graph)
  (let/ec _return (begin
(define k (floor (/ (* s (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])) 100)))
(define codes (get_cluster_codes clusters k))
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not codes) 0] [(string? codes) (string-length codes)] [(hash? codes) (hash-count codes)] [else (length codes)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (my_dfs (if graph (hash-ref graph "edges" #f) #f) (if codes (if (hash? codes) (hash-ref codes i #f) (safe-index codes (int i))) #f) "Header" (list))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
))
)
(define (node_edges nodes code)
  (let/ec _return (begin
(_return (if (if nodes (hash-ref nodes "map" #f) #f) (if (hash? (if nodes (hash-ref nodes "map" #f) #f)) (hash-ref (if nodes (hash-ref nodes "map" #f) #f) code #f) (safe-index (if nodes (hash-ref nodes "map" #f) #f) (int code))) #f))
))
)
(define (freq_subgraphs_edge_list paths nodes)
  (let/ec _return (begin
(define freq_sub_el (list))
(let/ec _break (for ([path paths])
  (let/ec _cont
(define el (list))
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r (- (cond [(not path) 0] [(string? path) (string-length path)] [(hash? path) (hash-count path)] [else (length path)]) 1)]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define code (if path (if (hash? path) (hash-ref path j #f) (safe-index path (int j))) #f))
      (define edge_list (node_edges nodes code))
      (define e 0)
      (let/ec _break (let loop ()
  (if (let ([__l e] [__r (cond [(not edge_list) 0] [(string? edge_list) (string-length edge_list)] [(hash? edge_list) (hash-count edge_list)] [else (length edge_list)])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define edge (if edge_list (if (hash? edge_list) (hash-ref edge_list e #f) (safe-index edge_list (int e))) #f))
      (define a (slice edge 0 1))
      (define b (slice edge 1 2))
      (set! el (append (or el (list)) (list (list a b))))
      (set! e (let ([__l e] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(set! freq_sub_el (append (or freq_sub_el (list)) (list el)))
  )))
(_return freq_sub_el)
))
)
(define (print_all nodes support clusters graph freq_subgraph_edge_list)
  (let/ec _return (begin
(displayln "\nNodes\n")
(define i 0)
(let/ec _break (let loop ()
  (if (let ([__l i] [__r (cond [(not (if nodes (hash-ref nodes "keys" #f) #f)) 0] [(string? (if nodes (hash-ref nodes "keys" #f) #f)) (string-length (if nodes (hash-ref nodes "keys" #f) #f))] [(hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-count (if nodes (hash-ref nodes "keys" #f) #f))] [else (length (if nodes (hash-ref nodes "keys" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define code (if (if nodes (hash-ref nodes "keys" #f) #f) (if (hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-ref (if nodes (hash-ref nodes "keys" #f) #f) i #f) (safe-index (if nodes (hash-ref nodes "keys" #f) #f) (int i))) #f))
      (displayln code)
      (displayln (if (if nodes (hash-ref nodes "map" #f) #f) (if (hash? (if nodes (hash-ref nodes "map" #f) #f)) (hash-ref (if nodes (hash-ref nodes "map" #f) #f) code #f) (safe-index (if nodes (hash-ref nodes "map" #f) #f) (int code))) #f))
      (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(displayln "\nSupport\n")
(displayln support)
(displayln "\nCluster\n")
(define j 0)
(let/ec _break (let loop ()
  (if (let ([__l j] [__r (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define w (if (if clusters (hash-ref clusters "weights" #f) #f) (if (hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-ref (if clusters (hash-ref clusters "weights" #f) #f) j #f) (safe-index (if clusters (hash-ref clusters "weights" #f) #f) (int j))) #f))
      (displayln (string-append (string-append (to-string w) ":") (to-string (if (if clusters (hash-ref clusters "clusters" #f) #f) (if (hash? (if clusters (hash-ref clusters "clusters" #f) #f)) (hash-ref (if clusters (hash-ref clusters "clusters" #f) #f) w #f) (safe-index (if clusters (hash-ref clusters "clusters" #f) #f) (int w))) #f))))
      (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(displayln "\nGraph\n")
(define k 0)
(let/ec _break (let loop ()
  (if (let ([__l k] [__r (cond [(not (if graph (hash-ref graph "keys" #f) #f)) 0] [(string? (if graph (hash-ref graph "keys" #f) #f)) (string-length (if graph (hash-ref graph "keys" #f) #f))] [(hash? (if graph (hash-ref graph "keys" #f) #f)) (hash-count (if graph (hash-ref graph "keys" #f) #f))] [else (length (if graph (hash-ref graph "keys" #f) #f))])]) (cond [(and (number? __l) (number? __r)) (< __l __r)] [else (< (int __l) (int __r))])) (begin
    (let/ec _cont
      (define key (if (if graph (hash-ref graph "keys" #f) #f) (if (hash? (if graph (hash-ref graph "keys" #f) #f)) (hash-ref (if graph (hash-ref graph "keys" #f) #f) k #f) (safe-index (if graph (hash-ref graph "keys" #f) #f) (int k))) #f))
      (displayln key)
      (displayln (if (if graph (hash-ref graph "edges" #f) #f) (if (hash? (if graph (hash-ref graph "edges" #f) #f)) (hash-ref (if graph (hash-ref graph "edges" #f) #f) key #f) (safe-index (if graph (hash-ref graph "edges" #f) #f) (int key))) #f))
      (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    )
    (loop)) (void))))
(displayln "\nEdge List of Frequent subgraphs\n")
(let/ec _break (for ([el freq_subgraph_edge_list])
  (let/ec _cont
(displayln el)
  )))
))
)
(define (main)
  (let/ec _return (begin
(define frequency_table (get_frequency_table EDGE_ARRAY))
(define nodes (get_nodes frequency_table))
(define clusters (get_cluster nodes))
(define support (get_support clusters))
(define graph (construct_graph clusters nodes))
(find_freq_subgraph_given_support 60 clusters graph)
(define freq_subgraph_edge_list (freq_subgraphs_edge_list paths nodes))
(print_all nodes support clusters graph freq_subgraph_edge_list)
))
)
(let* ([_start_mem (current-memory-use)] [_start (current-inexact-monotonic-milliseconds)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (current-inexact-monotonic-milliseconds)] [_end_mem (current-memory-use)]
         [_dur_us (max 1 (exact-ceiling (* (- _end _start) 1000)))]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
