;; Generated by Mochi 0.10.60 on 2025-08-08 10:32 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define EDGE_ARRAY (list (list (list "ab" "e1") (list "ac" "e3") (list "ad" "e5") (list "bc" "e4") (list "bd" "e2") (list "be" "e6") (list "bh" "e12") (list "cd" "e2") (list "ce" "e4") (list "de" "e1") (list "df" "e8") (list "dg" "e5") (list "dh" "e10") (list "ef" "e3") (list "eg" "e2") (list "fg" "e6") (list "gh" "e6") (list "hi" "e3")) (list (list "ab" "e1") (list "ac" "e3") (list "ad" "e5") (list "bc" "e4") (list "bd" "e2") (list "be" "e6") (list "cd" "e2") (list "de" "e1") (list "df" "e8") (list "ef" "e3") (list "eg" "e2") (list "fg" "e6")) (list (list "ab" "e1") (list "ac" "e3") (list "bc" "e4") (list "bd" "e2") (list "de" "e1") (list "df" "e8") (list "dg" "e5") (list "ef" "e3") (list "eg" "e2") (list "eh" "e12") (list "fg" "e6") (list "fh" "e10") (list "gh" "e6")) (list (list "ab" "e1") (list "ac" "e3") (list "bc" "e4") (list "bd" "e2") (list "bh" "e12") (list "cd" "e2") (list "df" "e8") (list "dh" "e10")) (list (list "ab" "e1") (list "ac" "e3") (list "ad" "e5") (list "bc" "e4") (list "bd" "e2") (list "cd" "e2") (list "ce" "e4") (list "de" "e1") (list "df" "e8") (list "dg" "e5") (list "ef" "e3") (list "eg" "e2") (list "fg" "e6"))))
(define (contains lst item)
  (let/ec _return (begin
(let/ec _break (for ([v lst])
  (let/ec _cont
(if (string=? v item) (let ()
(_return #t)
) (void))
  )))
(_return #f)
))
)
(define (get_distinct_edge edge_array)
  (let/ec _return (begin
(define distinct (list))
(let/ec _break (for ([row edge_array])
  (let/ec _cont
(let/ec _break (for ([item row])
  (let/ec _cont
(define e (if item (if (hash? item) (hash-ref item 0 #f) (list-ref item (int 0))) #f))
(if (not (contains distinct e)) (let ()
(set! distinct (append distinct (list e)))
) (void))
  )))
  )))
(_return distinct)
))
)
(define (get_bitcode edge_array de)
  (let/ec _return (begin
(define bitcode "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not edge_array) 0] [(string? edge_array) (string-length edge_array)] [(hash? edge_array) (hash-count edge_array)] [else (length edge_array)])) (let/ec _cont
    (define found #f)
    (let/ec _break (for ([item (if edge_array (if (hash? edge_array) (hash-ref edge_array i #f) (list-ref edge_array (int i))) #f)])
  (let/ec _cont
(if (string=? (if item (if (hash? item) (hash-ref item 0 #f) (list-ref item (int 0))) #f) de) (let ()
(set! found #t)
(_break)
) (void))
  )))
    (if found (let ()
(set! bitcode (string-append bitcode "1"))
) (let ()
(set! bitcode (string-append bitcode "0"))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return bitcode)
))
)
(define (count_ones s)
  (let/ec _return (begin
(define c 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not s) 0] [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let/ec _cont
    (if (string=? (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) "1") (let ()
(set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return c)
))
)
(define (get_frequency_table edge_array)
  (let/ec _return (begin
(define distinct (get_distinct_edge edge_array))
(define table (list))
(let/ec _break (for ([e distinct])
  (let/ec _cont
(define bit (get_bitcode edge_array e))
(define cnt (count_ones bit))
(define entry (hash "edge" e "count" (format "~a" cnt) "bit" bit))
(set! table (append table (list entry)))
  )))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not table) 0] [(string? table) (string-length table)] [(hash? table) (hash-count table)] [else (length table)])) (let/ec _cont
    (define max_i i)
    (define j (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (let/ec _break (let loop ()
  (if (< j (cond [(not table) 0] [(string? table) (string-length table)] [(hash? table) (hash-count table)] [else (length table)])) (let/ec _cont
    (if (> (int (if (if table (if (hash? table) (hash-ref table j #f) (list-ref table (int j))) #f) (hash-ref (if table (if (hash? table) (hash-ref table j #f) (list-ref table (int j))) #f) "count" "") #f)) (int (if (if table (if (hash? table) (hash-ref table max_i #f) (list-ref table (int max_i))) #f) (hash-ref (if table (if (hash? table) (hash-ref table max_i #f) (list-ref table (int max_i))) #f) "count" "") #f))) (let ()
(set! max_i j)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (define tmp (if table (if (hash? table) (hash-ref table i #f) (list-ref table (int i))) #f))
    (set! table (list-set table (int i) (if table (if (hash? table) (hash-ref table max_i #f) (list-ref table (int max_i))) #f)))
    (set! table (list-set table (int max_i) tmp))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return table)
))
)
(define (get_nodes freq_table)
  (let/ec _return (begin
(define nodes (hash))
(define keys (list))
(let/ec _break (for ([f freq_table])
  (let/ec _cont
(define code (if f (if (hash? f) (hash-ref f "bit" #f) (list-ref f (int "bit"))) #f))
(define edge (if f (if (hash? f) (hash-ref f "edge" #f) (list-ref f (int "edge"))) #f))
(if (hash-has-key? nodes code) (let ()
(set! nodes (hash-set (or nodes (hash)) code (append (if nodes (hash-ref nodes code (list)) #f) (list edge))))
) (let ()
(set! nodes (hash-set (or nodes (hash)) code (list edge)))
(set! keys (append keys (list code)))
))
  )))
(_return (hash "map" nodes "keys" keys))
))
)
(define (get_cluster nodes)
  (let/ec _return (begin
(define clusters (hash))
(define weights (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not (if nodes (hash-ref nodes "keys" #f) #f)) 0] [(string? (if nodes (hash-ref nodes "keys" #f) #f)) (string-length (if nodes (hash-ref nodes "keys" #f) #f))] [(hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-count (if nodes (hash-ref nodes "keys" #f) #f))] [else (length (if nodes (hash-ref nodes "keys" #f) #f))])) (let/ec _cont
    (define code (if (if nodes (hash-ref nodes "keys" #f) #f) (if (hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-ref (if nodes (hash-ref nodes "keys" #f) #f) i #f) (list-ref (if nodes (hash-ref nodes "keys" #f) #f) (int i))) #f))
    (define wt (count_ones code))
    (if (hash-has-key? clusters wt) (let ()
(set! clusters (hash-set (or clusters (hash)) wt (append (if clusters (hash-ref clusters wt (list)) #f) (list code))))
) (let ()
(set! clusters (hash-set (or clusters (hash)) wt (list code)))
(set! weights (append weights (list wt)))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (hash "clusters" clusters "weights" weights))
))
)
(define (get_support clusters)
  (let/ec _return (begin
(define sup (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])) (let/ec _cont
    (define w (if (if clusters (hash-ref clusters "weights" #f) #f) (if (hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-ref (if clusters (hash-ref clusters "weights" #f) #f) i #f) (list-ref (if clusters (hash-ref clusters "weights" #f) #f) (int i))) #f))
    (set! sup (append sup (list (floor (/ (* w 100) (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))]))))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sup)
))
)
(define (contains_bits a b)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not a) 0] [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)])) (let/ec _cont
    (define c1 (slice a i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define c2 (slice b i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (and (string=? c1 "1") (not (string=? c2 "1"))) (let ()
(_return #f)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #t)
))
)
(define (max_cluster_key clusters)
  (let/ec _return (begin
(define m 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])) (let/ec _cont
    (define w (if (if clusters (hash-ref clusters "weights" #f) #f) (if (hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-ref (if clusters (hash-ref clusters "weights" #f) #f) i #f) (list-ref (if clusters (hash-ref clusters "weights" #f) #f) (int i))) #f))
    (if (> w m) (let ()
(set! m w)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return m)
))
)
(define (get_cluster_codes clusters wt)
  (let/ec _return (begin
(if (hash-has-key? (if clusters (hash-ref clusters "clusters" #f) #f) wt) (let ()
(_return (if (if clusters (hash-ref clusters "clusters" #f) #f) (if (hash? (if clusters (hash-ref clusters "clusters" #f) #f)) (hash-ref (if clusters (hash-ref clusters "clusters" #f) #f) wt #f) (list-ref (if clusters (hash-ref clusters "clusters" #f) #f) (int wt))) #f))
) (void))
(_return (list))
))
)
(define (create_edge nodes graph gkeys clusters c1 maxk)
  (let/ec _return (begin
(define keys gkeys)
(define codes1 (get_cluster_codes clusters c1))
(define idx1 0)
(let/ec _break (let loop ()
  (if (< idx1 (cond [(not codes1) 0] [(string? codes1) (string-length codes1)] [(hash? codes1) (hash-count codes1)] [else (length codes1)])) (let/ec _cont
    (define i_code (if codes1 (if (hash? codes1) (hash-ref codes1 idx1 #f) (list-ref codes1 (int idx1))) #f))
    (define count 0)
    (define c2 (let ([__l c1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (let/ec _break (let loop ()
  (if (<= c2 maxk) (let/ec _cont
    (define codes2 (get_cluster_codes clusters c2))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(not codes2) 0] [(string? codes2) (string-length codes2)] [(hash? codes2) (hash-count codes2)] [else (length codes2)])) (let/ec _cont
    (define j_code (if codes2 (if (hash? codes2) (hash-ref codes2 j #f) (list-ref codes2 (int j))) #f))
    (if (contains_bits i_code j_code) (let ()
(if (hash-has-key? graph i_code) (let ()
(set! graph (hash-set (or graph (hash)) i_code (append (if graph (hash-ref graph i_code (list)) #f) (list j_code))))
) (let ()
(set! graph (hash-set (or graph (hash)) i_code (list j_code)))
(if (not (contains keys i_code)) (let ()
(set! keys (append keys (list i_code)))
) (void))
))
(if (not (contains keys j_code)) (let ()
(set! keys (append keys (list j_code)))
) (void))
(set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (equal? count 0) (let ()
(set! c2 (let ([__l c2] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(_break)
))
    (loop)) (void))))
    (set! idx1 (let ([__l idx1] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return keys)
))
)
(define (construct_graph clusters nodes)
  (let/ec _return (begin
(define maxk (max_cluster_key clusters))
(define top_codes (get_cluster_codes clusters maxk))
(define graph (hash))
(define keys (list "Header"))
(set! graph (hash-set (or graph (hash)) "Header" (list)))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not top_codes) 0] [(string? top_codes) (string-length top_codes)] [(hash? top_codes) (hash-count top_codes)] [else (length top_codes)])) (let/ec _cont
    (define code (if top_codes (if (hash? top_codes) (hash-ref top_codes i #f) (list-ref top_codes (int i))) #f))
    (set! graph (hash-set (or graph (hash)) "Header" (append (if graph (hash-ref graph "Header" (list)) #f) (list code))))
    (set! graph (hash-set (or graph (hash)) code (list "Header")))
    (set! keys (append keys (list code)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define c 1)
(let/ec _break (let loop ()
  (if (< c maxk) (let/ec _cont
    (set! keys (create_edge nodes graph keys clusters c maxk))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (hash "edges" graph "keys" keys))
))
)
(define paths (list))
(define (copy_list lst)
  (let/ec _return (begin
(define n (list))
(let/ec _break (for ([v lst])
  (let/ec _cont
(set! n (append n (list v)))
  )))
(_return n)
))
)
(define (my_dfs graph start end path)
  (let/ec _return (begin
(define new_path (copy_list path))
(set! new_path (append new_path (list start)))
(if (string=? start end) (let ()
(set! paths (append paths (list new_path)))
(_return void)
) (void))
(let/ec _break (for ([node (if graph (hash-ref graph start (list)) #f)])
  (let/ec _cont
(define seen #f)
(let/ec _break (for ([p new_path])
  (let/ec _cont
(if (equal? p node) (let ()
(set! seen #t)
) (void))
  )))
(if (not seen) (let ()
(my_dfs graph node end new_path)
) (void))
  )))
))
)
(define (find_freq_subgraph_given_support s clusters graph)
  (let/ec _return (begin
(define k (floor (/ (* s (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])) 100)))
(define codes (get_cluster_codes clusters k))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not codes) 0] [(string? codes) (string-length codes)] [(hash? codes) (hash-count codes)] [else (length codes)])) (let/ec _cont
    (my_dfs (if graph (hash-ref graph "edges" #f) #f) (if codes (if (hash? codes) (hash-ref codes i #f) (list-ref codes (int i))) #f) "Header" (list))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (node_edges nodes code)
  (let/ec _return (begin
(_return (if (if nodes (hash-ref nodes "map" #f) #f) (if (hash? (if nodes (hash-ref nodes "map" #f) #f)) (hash-ref (if nodes (hash-ref nodes "map" #f) #f) code #f) (list-ref (if nodes (hash-ref nodes "map" #f) #f) (int code))) #f))
))
)
(define (freq_subgraphs_edge_list paths nodes)
  (let/ec _return (begin
(define freq_sub_el (list))
(let/ec _break (for ([path paths])
  (let/ec _cont
(define el (list))
(define j 0)
(let/ec _break (let loop ()
  (if (< j (- (cond [(not path) 0] [(string? path) (string-length path)] [(hash? path) (hash-count path)] [else (length path)]) 1)) (let/ec _cont
    (define code (if path (if (hash? path) (hash-ref path j #f) (list-ref path (int j))) #f))
    (define edge_list (node_edges nodes code))
    (define e 0)
    (let/ec _break (let loop ()
  (if (< e (cond [(not edge_list) 0] [(string? edge_list) (string-length edge_list)] [(hash? edge_list) (hash-count edge_list)] [else (length edge_list)])) (let/ec _cont
    (define edge (if edge_list (if (hash? edge_list) (hash-ref edge_list e #f) (list-ref edge_list (int e))) #f))
    (define a (slice edge 0 1))
    (define b (slice edge 1 2))
    (set! el (append el (list (list a b))))
    (set! e (let ([__l e] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! freq_sub_el (append freq_sub_el (list el)))
  )))
(_return freq_sub_el)
))
)
(define (print_all nodes support clusters graph freq_subgraph_edge_list)
  (let/ec _return (begin
(displayln "\nNodes\n")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(not (if nodes (hash-ref nodes "keys" #f) #f)) 0] [(string? (if nodes (hash-ref nodes "keys" #f) #f)) (string-length (if nodes (hash-ref nodes "keys" #f) #f))] [(hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-count (if nodes (hash-ref nodes "keys" #f) #f))] [else (length (if nodes (hash-ref nodes "keys" #f) #f))])) (let/ec _cont
    (define code (if (if nodes (hash-ref nodes "keys" #f) #f) (if (hash? (if nodes (hash-ref nodes "keys" #f) #f)) (hash-ref (if nodes (hash-ref nodes "keys" #f) #f) i #f) (list-ref (if nodes (hash-ref nodes "keys" #f) #f) (int i))) #f))
    (displayln code)
    (displayln (if (if nodes (hash-ref nodes "map" #f) #f) (if (hash? (if nodes (hash-ref nodes "map" #f) #f)) (hash-ref (if nodes (hash-ref nodes "map" #f) #f) code #f) (list-ref (if nodes (hash-ref nodes "map" #f) #f) (int code))) #f))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "\nSupport\n")
(displayln support)
(displayln "\nCluster\n")
(define j 0)
(let/ec _break (let loop ()
  (if (< j (cond [(not (if clusters (hash-ref clusters "weights" #f) #f)) 0] [(string? (if clusters (hash-ref clusters "weights" #f) #f)) (string-length (if clusters (hash-ref clusters "weights" #f) #f))] [(hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-count (if clusters (hash-ref clusters "weights" #f) #f))] [else (length (if clusters (hash-ref clusters "weights" #f) #f))])) (let/ec _cont
    (define w (if (if clusters (hash-ref clusters "weights" #f) #f) (if (hash? (if clusters (hash-ref clusters "weights" #f) #f)) (hash-ref (if clusters (hash-ref clusters "weights" #f) #f) j #f) (list-ref (if clusters (hash-ref clusters "weights" #f) #f) (int j))) #f))
    (displayln (string-append (string-append (format "~a" w) ":") (format "~a" (if (if clusters (hash-ref clusters "clusters" #f) #f) (if (hash? (if clusters (hash-ref clusters "clusters" #f) #f)) (hash-ref (if clusters (hash-ref clusters "clusters" #f) #f) w #f) (list-ref (if clusters (hash-ref clusters "clusters" #f) #f) (int w))) #f))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "\nGraph\n")
(define k 0)
(let/ec _break (let loop ()
  (if (< k (cond [(not (if graph (hash-ref graph "keys" #f) #f)) 0] [(string? (if graph (hash-ref graph "keys" #f) #f)) (string-length (if graph (hash-ref graph "keys" #f) #f))] [(hash? (if graph (hash-ref graph "keys" #f) #f)) (hash-count (if graph (hash-ref graph "keys" #f) #f))] [else (length (if graph (hash-ref graph "keys" #f) #f))])) (let/ec _cont
    (define key (if (if graph (hash-ref graph "keys" #f) #f) (if (hash? (if graph (hash-ref graph "keys" #f) #f)) (hash-ref (if graph (hash-ref graph "keys" #f) #f) k #f) (list-ref (if graph (hash-ref graph "keys" #f) #f) (int k))) #f))
    (displayln key)
    (displayln (if (if graph (hash-ref graph "edges" #f) #f) (if (hash? (if graph (hash-ref graph "edges" #f) #f)) (hash-ref (if graph (hash-ref graph "edges" #f) #f) key #f) (list-ref (if graph (hash-ref graph "edges" #f) #f) (int key))) #f))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "\nEdge List of Frequent subgraphs\n")
(let/ec _break (for ([el freq_subgraph_edge_list])
  (let/ec _cont
(displayln el)
  )))
))
)
(define (main)
  (let/ec _return (begin
(define frequency_table (get_frequency_table EDGE_ARRAY))
(define nodes (get_nodes frequency_table))
(define clusters (get_cluster nodes))
(define support (get_support clusters))
(define graph (construct_graph clusters nodes))
(find_freq_subgraph_given_support 60 clusters graph)
(define freq_subgraph_edge_list (freq_subgraphs_edge_list paths nodes))
(print_all nodes support clusters graph freq_subgraph_edge_list)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
