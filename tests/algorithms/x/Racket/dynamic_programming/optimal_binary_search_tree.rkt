;; Generated by Mochi 0.10.60 on 2025-08-07 16:04 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (let ([ln (read-line)]) (if (eof-object? ln) "" ln)))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (cond
    [(string? s)
     (let loop ([i 0])
       (cond [(>= i (string-length s)) -1]
             [(string=? (substring s i (add1 i)) ch) i]
             [else (loop (add1 i))]))]
    [else
     (let loop ([i 0] [lst s])
       (cond [(null? lst) -1]
             [(equal? (car lst) ch) i]
             [else (loop (add1 i) (cdr lst))]))]))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define Object (hash "keys" (lambda (self m) (let ([lst (hash-keys m)]) (hash "join" (lambda (s sep) (string-join lst sep)))))))
(define stdout (hash "write" (lambda (s) (display s))))

(define (sort_nodes nodes)
  (let/ec _return (begin
(define arr nodes)
(define i 1)
(let/ec _break (let loop ()
  (if (< i (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)])) (let/ec _cont
    (define key_node (if arr (if (hash? arr) (hash-ref arr i #f) (list-ref arr (int i))) #f))
    (define j (- i 1))
    (let/ec _break (let loop ()
  (if (>= j 0) (let/ec _cont
    (define temp (if arr (if (hash? arr) (hash-ref arr j #f) (list-ref arr (int j))) #f))
    (if (> (if temp (hash-ref temp "key" #f) #f) (if key_node (hash-ref key_node "key" #f) #f)) (let ()
(set! arr (list-set arr (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) temp))
(set! j (- j 1))
) (let ()
(_break)
))
    (loop)) (void))))
    (set! arr (list-set arr (int (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) key_node))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return arr)
))
)
(define (print_node n)
  (let/ec _return (begin
(displayln (string-append (string-append (string-append (string-append "Node(key=" (format "~a" (if n (hash-ref n "key" #f) #f))) ", freq=") (format "~a" (if n (hash-ref n "freq" #f) #f))) ")"))
))
)
(define (print_binary_search_tree root keys i j parent is_left)
  (let/ec _return (begin
(if (or (or (> i j) (< i 0)) (> j (- (cond [(string? root) (string-length root)] [(hash? root) (hash-count root)] [else (length root)]) 1))) (let ()
(_return void)
) (void))
(define node (if (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f) (if (hash? (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f)) (hash-ref (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f) j #f) (list-ref (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f) (int j))) #f))
(if (equal? parent (- 1)) (let ()
(displayln (string-append (format "~a" (if keys (if (hash? keys) (hash-ref keys node #f) (list-ref keys (int node))) #f)) " is the root of the binary search tree."))
) (let ()
(if is_left (let ()
(displayln (string-append (string-append (string-append (format "~a" (if keys (if (hash? keys) (hash-ref keys node #f) (list-ref keys (int node))) #f)) " is the left child of key ") (format "~a" parent)) "."))
) (let ()
(displayln (string-append (string-append (string-append (format "~a" (if keys (if (hash? keys) (hash-ref keys node #f) (list-ref keys (int node))) #f)) " is the right child of key ") (format "~a" parent)) "."))
))
))
(print_binary_search_tree root keys i (- node 1) (if keys (if (hash? keys) (hash-ref keys node #f) (list-ref keys (int node))) #f) #t)
(print_binary_search_tree root keys (let ([__l node] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) j (if keys (if (hash? keys) (hash-ref keys node #f) (list-ref keys (int node))) #f) #f)
))
)
(define (find_optimal_binary_search_tree original_nodes)
  (let/ec _return (begin
(define nodes (sort_nodes original_nodes))
(define n (cond [(string? nodes) (string-length nodes)] [(hash? nodes) (hash-count nodes)] [else (length nodes)]))
(define keys (list))
(define freqs (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let/ec _cont
    (define node (if nodes (if (hash? nodes) (hash-ref nodes i #f) (list-ref nodes (int i))) #f))
    (set! keys (append keys (list (if node (hash-ref node "key" #f) #f))))
    (set! freqs (append freqs (list (if node (hash-ref node "freq" #f) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define dp (list))
(define total (list))
(define root (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i n) (let/ec _cont
    (define dp_row (list))
    (define total_row (list))
    (define root_row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j n) (let/ec _cont
    (if (equal? i j) (let ()
(set! dp_row (append dp_row (list (if freqs (if (hash? freqs) (hash-ref freqs i #f) (list-ref freqs (int i))) #f))))
(set! total_row (append total_row (list (if freqs (if (hash? freqs) (hash-ref freqs i #f) (list-ref freqs (int i))) #f))))
(set! root_row (append root_row (list i)))
) (let ()
(set! dp_row (append dp_row (list 0)))
(set! total_row (append total_row (list 0)))
(set! root_row (append root_row (list 0)))
))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! dp (append dp (list dp_row)))
    (set! total (append total (list total_row)))
    (set! root (append root (list root_row)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define interval_length 2)
(define INF 2147483647)
(let/ec _break (let loop ()
  (if (<= interval_length n) (let/ec _cont
    (set! i 0)
    (let/ec _break (let loop ()
  (if (< i (let ([__l (- n interval_length)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (let/ec _cont
    (define j (- (let ([__l i] [__r interval_length]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 1))
    (set! dp (list-set dp i (list-set (list-ref dp i) j INF)))
    (set! total (list-set total i (list-set (list-ref total i) j (let ([__l (if (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f) (if (hash? (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f)) (hash-ref (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f) (- j 1) #f) (list-ref (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f) (int (- j 1)))) #f)] [__r (if freqs (if (hash? freqs) (hash-ref freqs j #f) (list-ref freqs (int j))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (define r (if (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f) (if (hash? (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f)) (hash-ref (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f) (- j 1) #f) (list-ref (if root (if (hash? root) (hash-ref root i #f) (list-ref root (int i))) #f) (int (- j 1)))) #f))
    (let/ec _break (let loop ()
  (if (<= r (if (if root (if (hash? root) (hash-ref root (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref root (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if root (if (hash? root) (hash-ref root (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref root (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if root (if (hash? root) (hash-ref root (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref root (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) j #f) (list-ref (if root (if (hash? root) (hash-ref root (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref root (int (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int j))) #f)) (let/ec _cont
    (define left (if (not (equal? r i)) (if (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f) (if (hash? (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f)) (hash-ref (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f) (- r 1) #f) (list-ref (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f) (int (- r 1)))) #f) 0))
    (define right (if (not (equal? r j)) (if (if dp (if (hash? dp) (hash-ref dp (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref dp (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (if (hash? (if dp (if (hash? dp) (hash-ref dp (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref dp (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f)) (hash-ref (if dp (if (hash? dp) (hash-ref dp (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref dp (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) j #f) (list-ref (if dp (if (hash? dp) (hash-ref dp (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) #f) (list-ref dp (int (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) #f) (int j))) #f) 0))
    (define cost (let ([__l (let ([__l left] [__r (if (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f) (if (hash? (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f)) (hash-ref (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f) j #f) (list-ref (if total (if (hash? total) (hash-ref total i #f) (list-ref total (int i))) #f) (int j))) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r right]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (> (if (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f) (if (hash? (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f)) (hash-ref (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f) j #f) (list-ref (if dp (if (hash? dp) (hash-ref dp i #f) (list-ref dp (int i))) #f) (int j))) #f) cost) (let ()
(set! dp (list-set dp i (list-set (list-ref dp i) j cost)))
(set! root (list-set root i (list-set (list-ref root i) j r)))
) (void))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! interval_length (let ([__l interval_length] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "Binary search tree nodes:")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i n) (let/ec _cont
    (print_node (if nodes (if (hash? nodes) (hash-ref nodes i #f) (list-ref nodes (int i))) #f))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln (string-append (string-append "\nThe cost of optimal BST for given tree nodes is " (format "~a" (if (if dp (if (hash? dp) (hash-ref dp 0 #f) (list-ref dp (int 0))) #f) (if (hash? (if dp (if (hash? dp) (hash-ref dp 0 #f) (list-ref dp (int 0))) #f)) (hash-ref (if dp (if (hash? dp) (hash-ref dp 0 #f) (list-ref dp (int 0))) #f) (- n 1) #f) (list-ref (if dp (if (hash? dp) (hash-ref dp 0 #f) (list-ref dp (int 0))) #f) (int (- n 1)))) #f))) "."))
(print_binary_search_tree root keys 0 (- n 1) (- 1) #f)
))
)
(define (main)
  (let/ec _return (begin
(define nodes (list (hash "key" 12 "freq" 8) (hash "key" 10 "freq" 34) (hash "key" 20 "freq" 50) (hash "key" 42 "freq" 3) (hash "key" 25 "freq" 40) (hash "key" 37 "freq" 30)))
(find_optimal_binary_search_tree nodes)
))
)
(let* ([_start_mem (current-memory-use)] [_start (now)])
  (let/ec _return (begin
(main)
    (void)
  ))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
