// Generated by Mochi 0.10.62 on 2025-08-09 16:19 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Numerics;
using System.Collections;

class Edge {
    public long u;
    public long v;
    public long w;
    public override string ToString() => $"Edge {{u = {u}, v = {v}, w = {w}}}";
}
class Graph {
    public long num_nodes;
    public Edge[] edges;
    public Dictionary<long, long> component;
    public override string ToString() => $"Graph {{num_nodes = {num_nodes}, edges = {edges}, component = {component}}}";
}
class UnionResult {
    public Graph graph;
    public long[] component_size;
    public override string ToString() => $"UnionResult {{graph = {graph}, component_size = {component_size}}}";
}
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalAllocatedBytes(true);
    }
    static string _substr(string s, long start, long end) {
        if (start < 0) start = 0;
        if (end < 0) end = 0;
        if (start > s.Length) start = s.Length;
        if (end > s.Length) end = s.Length;
        if (start > end) start = end;
        return s.Substring((int)start, (int)(end - start));
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(", ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(", ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(", ", parts);
        }
        if (v is string s) return "\"" + s.Replace("\"", "\\\"") + "\"";
        if (v is bool b) return b ? "true" : "false";
        return Convert.ToString(v);
    }
    static string _fmtStr(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmtStr(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmtStr(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmtStr(x));
            return string.Join(" ", parts);
        }
        if (v is string s) return "\"" + s.Replace("\"", "\\\"") + "\"";
        if (v is bool b) return b ? "true" : "false";
        return Convert.ToString(v);
    }
    public static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is string s) return s;
        return _fmt(v);
    }
    public static Graph new_graph(long num_nodes_0) {
        return new Graph{num_nodes = num_nodes_0, edges = new Edge[]{}, component = new Dictionary<long, long>{}};
    }

    public static Graph add_edge(Graph g_1, long u_2, long v_3, long w_4) {
        Edge[] es_5 = g_1.edges;
        es_5 = (Enumerable.ToArray(Enumerable.Append<Edge>(es_5, new Edge{u = u_2, v = v_3, w = w_4})));
        return new Graph{num_nodes = g_1.num_nodes, edges = es_5, component = g_1.component};
    }

    public static long find_component(Graph g_6, long node_7) {
        if (((g_6.component.ContainsKey(node_7) ? g_6.component[node_7] : 0) == node_7)) {
            return node_7;
        };
        return Program.find_component(g_6, (g_6.component.ContainsKey(node_7) ? g_6.component[node_7] : 0));
    }

    public static Graph set_component(Graph g_8, long node_9) {
        if (((g_8.component.ContainsKey(node_9) ? g_8.component[node_9] : 0) != node_9)) {
            Dictionary<long, long> comp_10 = g_8.component;
            foreach (long k_11 in comp_10.Keys) {
                comp_10[k_11] = Program.find_component(g_8, k_11);
            }
            g_8 = new Graph{num_nodes = g_8.num_nodes, edges = g_8.edges, component = comp_10};
        };
        return g_8;
    }

    public static UnionResult union(Graph g_12, long[] component_size_13, long u_14, long v_15) {
        long[] comp_size_16 = component_size_13;
        Dictionary<long, long> comp_17 = g_12.component;
        if ((comp_size_16[(int)(u_14 < 0 ? comp_size_16.Length + (u_14) : u_14)] <= comp_size_16[(int)(v_15 < 0 ? comp_size_16.Length + (v_15) : v_15)])) {
            comp_17[u_14] = v_15;
            comp_size_16[(int)(v_15)] = (comp_size_16[(int)(v_15 < 0 ? comp_size_16.Length + (v_15) : v_15)] + comp_size_16[(int)(u_14 < 0 ? comp_size_16.Length + (u_14) : u_14)]);
            g_12 = new Graph{num_nodes = g_12.num_nodes, edges = g_12.edges, component = comp_17};
            g_12 = Program.set_component(g_12, u_14);
        } else {
            comp_17[v_15] = u_14;
            comp_size_16[(int)(u_14)] = (comp_size_16[(int)(u_14 < 0 ? comp_size_16.Length + (u_14) : u_14)] + comp_size_16[(int)(v_15 < 0 ? comp_size_16.Length + (v_15) : v_15)]);
            g_12 = new Graph{num_nodes = g_12.num_nodes, edges = g_12.edges, component = comp_17};
            g_12 = Program.set_component(g_12, v_15);
        };
        return new UnionResult{graph = g_12, component_size = comp_size_16};
    }

    public static Edge[] create_empty_edges(long n_18) {
        Edge[] res_19 = new Edge[]{};
        long i_20 = 0;
        while ((i_20 < n_18)) {
            res_19 = (Enumerable.ToArray(Enumerable.Append<Edge>(res_19, new Edge{u = -1, v = -1, w = -1})));
            i_20 = (i_20 + 1);
        };
        return res_19;
    }

    public static long boruvka(Graph g_21) {
        long[] component_size_22 = new long[]{};
        long i_23 = 0;
        while ((i_23 < g_21.num_nodes)) {
            component_size_22 = (Enumerable.ToArray(Enumerable.Append<long>(component_size_22, 1)));
            g_21.component[i_23] = i_23;
            i_23 = (i_23 + 1);
        };
        long mst_weight_24 = 0;
        long num_components_25 = g_21.num_nodes;
        Edge[] minimum_weight_edge_26 = Program.create_empty_edges(g_21.num_nodes);
        while ((num_components_25 > 1)) {
            foreach (Edge e_27 in g_21.edges) {
                long u_28 = e_27.u;
                long v_29 = e_27.v;
                long w_30 = e_27.w;
                long u_comp_31 = (g_21.component.ContainsKey(u_28) ? g_21.component[u_28] : 0);
                long v_comp_32 = (g_21.component.ContainsKey(v_29) ? g_21.component[v_29] : 0);
                if ((u_comp_31 != v_comp_32)) {
                    Edge current_u_33 = minimum_weight_edge_26[(int)(u_comp_31 < 0 ? minimum_weight_edge_26.Length + (u_comp_31) : u_comp_31)];
                    if (((current_u_33.u == -1) || (current_u_33.w > w_30))) {
                        minimum_weight_edge_26[(int)(u_comp_31)] = new Edge{u = u_28, v = v_29, w = w_30};
                    }
                    Edge current_v_34 = minimum_weight_edge_26[(int)(v_comp_32 < 0 ? minimum_weight_edge_26.Length + (v_comp_32) : v_comp_32)];
                    if (((current_v_34.u == -1) || (current_v_34.w > w_30))) {
                        minimum_weight_edge_26[(int)(v_comp_32)] = new Edge{u = u_28, v = v_29, w = w_30};
                    }
                }
            }
            foreach (Edge e_35 in minimum_weight_edge_26) {
                if ((e_35.u != -1)) {
                    long u_36 = e_35.u;
                    long v_37 = e_35.v;
                    long w_38 = e_35.w;
                    long u_comp_39 = (g_21.component.ContainsKey(u_36) ? g_21.component[u_36] : 0);
                    long v_comp_40 = (g_21.component.ContainsKey(v_37) ? g_21.component[v_37] : 0);
                    if ((u_comp_39 != v_comp_40)) {
                        mst_weight_24 = (mst_weight_24 + w_38);
                        UnionResult res_41 = Program.union(g_21, component_size_22, u_comp_39, v_comp_40);
                        g_21 = res_41.graph;
                        component_size_22 = res_41.component_size;
                        Console.WriteLine(Program._fmtTop((((("Added edge [" + _fmtStr(u_36)) + " - ") + _fmtStr(v_37)) + "]")));
                        Console.WriteLine(Program._fmtTop(("Added weight: " + _fmtStr(w_38))));
                        Console.WriteLine(Program._fmtTop(""));
                        num_components_25 = (num_components_25 - 1);
                    }
                }
            }
            minimum_weight_edge_26 = Program.create_empty_edges(g_21.num_nodes);
        };
        Console.WriteLine(Program._fmtTop(("The total weight of the minimal spanning tree is: " + _fmtStr(mst_weight_24))));
        return mst_weight_24;
    }

    public static void main() {
        Graph g_42 = Program.new_graph(8);
        long[][] edges_43 = new long[][]{new long[]{0, 1, 10}, new long[]{0, 2, 6}, new long[]{0, 3, 5}, new long[]{1, 3, 15}, new long[]{2, 3, 4}, new long[]{3, 4, 8}, new long[]{4, 5, 10}, new long[]{4, 6, 6}, new long[]{4, 7, 5}, new long[]{5, 7, 15}, new long[]{6, 7, 4}};
        foreach (long[] e_44 in edges_43) {
            g_42 = Program.add_edge(g_42, e_44[(int)(0 < 0 ? e_44.Length + (0) : 0)], e_44[(int)(1 < 0 ? e_44.Length + (1) : 1)], e_44[(int)(2 < 0 ? e_44.Length + (2) : 2)]);
        };
        Program.boruvka(g_42);
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            Program.main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            if (__dur <= 0) __dur = 1;
            var __memDiff = __memEnd - __memStart;
            if (__memDiff <= 0) __memDiff = __memEnd;
            Console.WriteLine("{\"name\":\"main\",\"duration_us\":" + __dur + ",\"memory_bytes\":" + __memDiff + "}");
        }
    }
}
