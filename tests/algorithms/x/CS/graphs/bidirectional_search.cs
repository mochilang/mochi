// Generated by Mochi 0.10.59 on 2025-08-07 00:02 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Numerics;
using System.Collections;

class ExpandResult {
    public long[] queue;
    public long head;
    public Dictionary<long, long> parents;
    public Dictionary<long, bool> visited;
    public long intersection;
    public bool found;
    public override string ToString() => $"ExpandResult {{queue = {queue}, head = {head}, parents = {parents}, visited = {visited}, intersection = {intersection}, found = {found}}}";
}
class SearchResult {
    public long[] path;
    public bool ok;
    public override string ToString() => $"SearchResult {{path = {path}, ok = {ok}}}";
}
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalAllocatedBytes(true);
    }
    static long _len(object v) {
        if (v is Array a) return a.Length;
        if (v is string s) return s.Length;
        if (v is System.Collections.ICollection c) return c.Count;
        return Convert.ToString(v).Length;
    }
    static string _substr(string s, long start, long end) {
        if (start < 0) start = 0;
        if (end < 0) end = 0;
        if (start > s.Length) start = s.Length;
        if (end > s.Length) end = s.Length;
        if (start > end) start = end;
        return s.Substring((int)start, (int)(end - start));
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(", ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(", ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(", ", parts);
        }
        if (v is string s) return "\"" + s.Replace("\"", "\\\"") + "\"";
        if (v is bool b) return b ? "true" : "false";
        return Convert.ToString(v);
    }
    static string _fmtStr(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmtStr(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmtStr(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmtStr(x));
            return string.Join(" ", parts);
        }
        if (v is string s) return "\"" + s.Replace("\"", "\\\"") + "\"";
        if (v is bool b) return b ? "true" : "false";
        return Convert.ToString(v);
    }
    public static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is string s) return s;
        return _fmt(v);
    }
    public static ExpandResult expand_search(Dictionary<long, long[]> graph_0, long[] queue_1, long head_2, Dictionary<long, long> parents_3, Dictionary<long, bool> visited_4, Dictionary<long, bool> opposite_visited_5) {
        if ((head_2 >= queue_1.Length)) {
            return new ExpandResult{queue = queue_1, head = head_2, parents = parents_3, visited = visited_4, intersection = (0 - 1), found = false};
        };
        long current_6 = queue_1[(int)(head_2)];
        head_2 = (head_2 + 1);
        long[] neighbors_7 = (graph_0.ContainsKey(current_6) ? graph_0[current_6] : null);
        long[] q_8 = queue_1;
        Dictionary<long, long> p_9 = parents_3;
        Dictionary<long, bool> v_10 = visited_4;
        long i_11 = 0;
        while ((i_11 < neighbors_7.Length)) {
            long neighbor_12 = neighbors_7[(int)(i_11)];
            if ((v_10.ContainsKey(neighbor_12) ? v_10[neighbor_12] : false)) {
                i_11 = (i_11 + 1);
                continue;
            }
            v_10[neighbor_12] = true;
            p_9[neighbor_12] = current_6;
            q_8 = (Enumerable.ToArray(Enumerable.Append<long>(q_8, neighbor_12)));
            if ((opposite_visited_5.ContainsKey(neighbor_12) ? opposite_visited_5[neighbor_12] : false)) {
                return new ExpandResult{queue = q_8, head = head_2, parents = p_9, visited = v_10, intersection = neighbor_12, found = true};
            }
            i_11 = (i_11 + 1);
        };
        return new ExpandResult{queue = q_8, head = head_2, parents = p_9, visited = v_10, intersection = (0 - 1), found = false};
    }

    public static long[] construct_path(long current_13, Dictionary<long, long> parents_14) {
        long[] path_15 = new long[]{};
        long node_16 = current_13;
        while ((node_16 != (0 - 1))) {
            path_15 = (Enumerable.ToArray(Enumerable.Append<long>(path_15, node_16)));
            node_16 = (parents_14.ContainsKey(node_16) ? parents_14[node_16] : 0);
        };
        return path_15;
    }

    public static long[] reverse_list(long[] xs_17) {
        long[] res_18 = new long[]{};
        long i_19 = xs_17.Length;
        while ((i_19 > 0)) {
            i_19 = (i_19 - 1);
            res_18 = (Enumerable.ToArray(Enumerable.Append<long>(res_18, xs_17[(int)(i_19)])));
        };
        return res_18;
    }

    public static SearchResult bidirectional_search(Dictionary<long, long[]> g_20, long start_21, long goal_22) {
        if ((start_21 == goal_22)) {
            return new SearchResult{path = new long[]{start_21}, ok = true};
        };
        Dictionary<long, long> forward_parents_23 = new Dictionary<long, long>{};
        forward_parents_23[start_21] = (0 - 1);
        Dictionary<long, long> backward_parents_24 = new Dictionary<long, long>{};
        backward_parents_24[goal_22] = (0 - 1);
        Dictionary<long, bool> forward_visited_25 = new Dictionary<long, bool>{};
        forward_visited_25[start_21] = true;
        Dictionary<long, bool> backward_visited_26 = new Dictionary<long, bool>{};
        backward_visited_26[goal_22] = true;
        long[] forward_queue_27 = new long[]{start_21};
        long[] backward_queue_28 = new long[]{goal_22};
        long forward_head_29 = 0;
        long backward_head_30 = 0;
        long intersection_31 = (0 - 1);
        while ((((forward_head_29 < forward_queue_27.Length) && (backward_head_30 < backward_queue_28.Length)) && (intersection_31 == (0 - 1)))) {
            ExpandResult res_32 = Program.expand_search(g_20, forward_queue_27, forward_head_29, forward_parents_23, forward_visited_25, backward_visited_26);
            forward_queue_27 = res_32.queue;
            forward_head_29 = res_32.head;
            forward_parents_23 = res_32.parents;
            forward_visited_25 = res_32.visited;
            if (res_32.found) {
                intersection_31 = res_32.intersection;
                break;
            }
            res_32 = Program.expand_search(g_20, backward_queue_28, backward_head_30, backward_parents_24, backward_visited_26, forward_visited_25);
            backward_queue_28 = res_32.queue;
            backward_head_30 = res_32.head;
            backward_parents_24 = res_32.parents;
            backward_visited_26 = res_32.visited;
            if (res_32.found) {
                intersection_31 = res_32.intersection;
                break;
            }
        };
        if ((intersection_31 == (0 - 1))) {
            return new SearchResult{path = new long[]{}, ok = false};
        };
        long[] forward_path_33 = Program.construct_path(intersection_31, forward_parents_23);
        forward_path_33 = Program.reverse_list(forward_path_33);
        long back_start_34 = (backward_parents_24.ContainsKey(intersection_31) ? backward_parents_24[intersection_31] : 0);
        long[] backward_path_35 = Program.construct_path(back_start_34, backward_parents_24);
        long[] result_36 = forward_path_33;
        long j_37 = 0;
        while ((j_37 < backward_path_35.Length)) {
            result_36 = (Enumerable.ToArray(Enumerable.Append<long>(result_36, backward_path_35[(int)(j_37)])));
            j_37 = (j_37 + 1);
        };
        return new SearchResult{path = result_36, ok = true};
    }

    public static bool is_edge(Dictionary<long, long[]> g_38, long u_39, long v_40) {
        long[] neighbors_41 = (g_38.ContainsKey(u_39) ? g_38[u_39] : null);
        long i_42 = 0;
        while ((i_42 < neighbors_41.Length)) {
            if ((neighbors_41[(int)(i_42)] == v_40)) {
                return true;
            }
            i_42 = (i_42 + 1);
        };
        return false;
    }

    public static bool path_exists(Dictionary<long, long[]> g_43, long[] path_44) {
        if ((path_44.Length == 0)) {
            return false;
        };
        long i_45 = 0;
        while (((i_45 + 1) < path_44.Length)) {
            if ((!Program.is_edge(g_43, path_44[(int)(i_45)], path_44[(int)((i_45 + 1))]))) {
                return false;
            }
            i_45 = (i_45 + 1);
        };
        return true;
    }

    public static void print_path(Dictionary<long, long[]> g_46, long s_47, long t_48) {
        SearchResult res_49 = Program.bidirectional_search(g_46, s_47, t_48);
        if ((res_49.ok && Program.path_exists(g_46, res_49.path))) {
            Console.WriteLine(Program._fmtTop(((((("Path from " + _fmtStr(s_47)) + " to ") + _fmtStr(t_48)) + ": ") + _fmtStr(res_49.path))));
        } else {
            Console.WriteLine(Program._fmtTop((((("Path from " + _fmtStr(s_47)) + " to ") + _fmtStr(t_48)) + ": None")));
        };
    }

    public static void main() {
        Dictionary<long, long[]> graph_50 = new Dictionary<long, long[]>{{0, new long[]{1, 2}}, {1, new long[]{0, 3, 4}}, {2, new long[]{0, 5, 6}}, {3, new long[]{1, 7}}, {4, new long[]{1, 8}}, {5, new long[]{2, 9}}, {6, new long[]{2, 10}}, {7, new long[]{3, 11}}, {8, new long[]{4, 11}}, {9, new long[]{5, 11}}, {10, new long[]{6, 11}}, {11, new long[]{7, 8, 9, 10}}};
        Program.print_path(graph_50, 0, 11);
        Program.print_path(graph_50, 5, 5);
        Dictionary<long, long[]> disconnected_51 = new Dictionary<long, long[]>{{0, new long[]{1, 2}}, {1, new long[]{0}}, {2, new long[]{0}}, {3, new long[]{4}}, {4, new long[]{3}}};
        Program.print_path(disconnected_51, 0, 3);
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            Program.main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            if (__dur <= 0) __dur = 1;
            var __memDiff = __memEnd - __memStart;
            if (__memDiff <= 0) __memDiff = __memEnd;
            Console.WriteLine("{\"name\":\"main\",\"duration_us\":" + __dur + ",\"memory_bytes\":" + __memDiff + "}");
        }
    }
}
