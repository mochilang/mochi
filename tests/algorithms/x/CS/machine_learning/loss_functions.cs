// Generated by Mochi 0.10.63 on 2025-08-11 18:28 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Numerics;
using System.Collections;

#pragma warning disable CS0162
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalAllocatedBytes(true);
    }
    static long _len(object v) {
        if (v is Array a) return a.Length;
        if (v is string s) return s.Length;
        if (v is System.Collections.ICollection c) return c.Count;
        return Convert.ToString(v).Length;
    }
    static T _idx<T>(T[] arr, long i) {
        if (arr == null) return default(T);
        if (i < 0) i += arr.Length;
        if (i < 0 || i >= arr.Length) return default(T);
        return arr[(int)i];
    }
    static long _atoi(object v) {
        if (v == null) return 0;
        if (v is long l) return l;
        if (v is int i) return i;
        if (v is double d) return (long)d;
        if (v is bool b) return b ? 1L : 0L;
        if (v is string s) {
            if (long.TryParse(s, out var n)) return n;
            if (double.TryParse(s, out var f)) return (long)f;
            return 0;
        }
        try { return Convert.ToInt64(v); } catch { return 0; }
    }
    static string _substr(string s, long start, long end) {
        if (start < 0) start = 0;
        if (end < 0) end = 0;
        if (start > s.Length) start = s.Length;
        if (end > s.Length) end = s.Length;
        if (start > end) start = end;
        return s.Substring((int)start, (int)(end - start));
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(", ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(", ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(", ", parts);
        }
        if (v is string s) return "\"" + s.Replace("\"", "\\\"") + "\"";
        if (v is bool b) return b ? "true" : "false";
        return Convert.ToString(v);
    }
    static string _fmtStr(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmtStr(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmtStr(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmtStr(x));
            return string.Join(" ", parts);
        }
        if (v is string s) return "\"" + s.Replace("\"", "\\\"") + "\"";
        if (v is bool b) return b ? "true" : "false";
        return Convert.ToString(v);
    }
    public static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is string s) return s;
        return _fmt(v);
    }
    static string __name__ = "__main__";
    public static double absf(double x_0) {
        if ((x_0 < 0.0)) {
            return -x_0;
        };
        return x_0;
    }

    public static double maxf(double a_1, double b_2) {
        if ((a_1 > b_2)) {
            return a_1;
        };
        return b_2;
    }

    public static double minf(double a_3, double b_4) {
        if ((a_3 < b_4)) {
            return a_3;
        };
        return b_4;
    }

    public static double clip(double x_5, double lo_6, double hi_7) {
        return Program.maxf(lo_6, Program.minf(x_5, hi_7));
    }

    public static double to_float(long x_8) {
        return (x_8 * 1.0);
    }

    public static double powf(double base_9, double exp_10) {
        double result_11 = 1.0;
        long i_12 = 0;
        long n_13 = _atoi(exp_10);
        while ((i_12 < n_13)) {
            result_11 = (result_11 * base_9);
            i_12 = (i_12 + 1);
        };
        return result_11;
    }

    public static double ln(double x_14) {
        if ((x_14 <= 0.0)) {
            throw new Exception("ln domain error");
        };
        double y_15 = ((x_14 - 1.0) / (x_14 + 1.0));
        double y2_16 = (y_15 * y_15);
        double term_17 = y_15;
        double sum_18 = 0.0;
        long k_19 = 0;
        while ((k_19 < 10)) {
            double denom_20 = Program.to_float(((2 * k_19) + 1));
            sum_18 = (sum_18 + (term_17 / denom_20));
            term_17 = (term_17 * y2_16);
            k_19 = (k_19 + 1);
        };
        return (2.0 * sum_18);
    }

    public static double exp(double x_21) {
        return Math.Exp(x_21);
    }

    public static double mean(double[] v_25) {
        double total_26 = 0.0;
        long i_27 = 0;
        while ((i_27 < v_25.Length)) {
            total_26 = (total_26 + _idx(v_25, i_27));
            i_27 = (i_27 + 1);
        };
        return (total_26 / Program.to_float(v_25.Length));
    }

    public static double binary_cross_entropy(double[] y_true_28, double[] y_pred_29, double epsilon_30) {
        if ((y_true_28.Length != y_pred_29.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double[] losses_31 = new double[]{};
        long i_32 = 0;
        while ((i_32 < y_true_28.Length)) {
            double yt_33 = _idx(y_true_28, i_32);
            double yp_34 = Program.clip(_idx(y_pred_29, i_32), epsilon_30, (1.0 - epsilon_30));
            double loss_35 = -((yt_33 * Program.ln(yp_34)) + ((1.0 - yt_33) * Program.ln((1.0 - yp_34))));
            losses_31 = (Enumerable.ToArray(Enumerable.Append<double>(losses_31, loss_35)));
            i_32 = (i_32 + 1);
        };
        return Program.mean(losses_31);
    }

    public static double binary_focal_cross_entropy(double[] y_true_36, double[] y_pred_37, double gamma_38, double alpha_39, double epsilon_40) {
        if ((y_true_36.Length != y_pred_37.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double[] losses_41 = new double[]{};
        long i_42 = 0;
        while ((i_42 < y_true_36.Length)) {
            double yt_43 = _idx(y_true_36, i_42);
            double yp_44 = Program.clip(_idx(y_pred_37, i_42), epsilon_40, (1.0 - epsilon_40));
            double term1_45 = (((alpha_39 * Program.powf((1.0 - yp_44), gamma_38)) * yt_43) * Program.ln(yp_44));
            double term2_46 = ((((1.0 - alpha_39) * Program.powf(yp_44, gamma_38)) * (1.0 - yt_43)) * Program.ln((1.0 - yp_44)));
            losses_41 = (Enumerable.ToArray(Enumerable.Append<double>(losses_41, -(term1_45 + term2_46))));
            i_42 = (i_42 + 1);
        };
        return Program.mean(losses_41);
    }

    public static double categorical_cross_entropy(double[][] y_true_47, double[][] y_pred_48, double epsilon_49) {
        if ((y_true_47.Length != y_pred_48.Length)) {
            throw new Exception("Input arrays must have the same shape.");
        };
        long rows_50 = y_true_47.Length;
        double total_51 = 0.0;
        long i_52 = 0;
        while ((i_52 < rows_50)) {
            if ((_idx(y_true_47, i_52).Length != _idx(y_pred_48, i_52).Length)) {
                throw new Exception("Input arrays must have the same shape.");
            }
            double sum_true_53 = 0.0;
            double sum_pred_54 = 0.0;
            long j_55 = 0;
            while ((j_55 < _idx(y_true_47, i_52).Length)) {
                double yt_56 = _idx(_idx(y_true_47, i_52), j_55);
                double yp_57 = _idx(_idx(y_pred_48, i_52), j_55);
                if (((yt_56 != 0.0) && (yt_56 != 1.0))) {
                    throw new Exception("y_true must be one-hot encoded.");
                }
                sum_true_53 = (sum_true_53 + yt_56);
                sum_pred_54 = (sum_pred_54 + yp_57);
                j_55 = (j_55 + 1);
            }
            if ((sum_true_53 != 1.0)) {
                throw new Exception("y_true must be one-hot encoded.");
            }
            if ((Program.absf((sum_pred_54 - 1.0)) > epsilon_49)) {
                throw new Exception("Predicted probabilities must sum to approximately 1.");
            }
            j_55 = 0;
            while ((j_55 < _idx(y_true_47, i_52).Length)) {
                double yp_58 = Program.clip(_idx(_idx(y_pred_48, i_52), j_55), epsilon_49, 1.0);
                total_51 = (total_51 - (_idx(_idx(y_true_47, i_52), j_55) * Program.ln(yp_58)));
                j_55 = (j_55 + 1);
            }
            i_52 = (i_52 + 1);
        };
        return total_51;
    }

    public static double categorical_focal_cross_entropy(double[][] y_true_59, double[][] y_pred_60, double[] alpha_61, double gamma_62, double epsilon_63) {
        if ((y_true_59.Length != y_pred_60.Length)) {
            throw new Exception("Shape of y_true and y_pred must be the same.");
        };
        long rows_64 = y_true_59.Length;
        long cols_65 = _idx(y_true_59, 0).Length;
        double[] a_66 = alpha_61;
        if ((a_66.Length == 0)) {
            double[] tmp_67 = new double[]{};
            long j_68 = 0;
            while ((j_68 < cols_65)) {
                tmp_67 = (Enumerable.ToArray(Enumerable.Append<double>(tmp_67, 1.0)));
                j_68 = (j_68 + 1);
            }
            a_66 = tmp_67;
        };
        if ((a_66.Length != cols_65)) {
            throw new Exception("Length of alpha must match the number of classes.");
        };
        double total_69 = 0.0;
        long i_70 = 0;
        while ((i_70 < rows_64)) {
            if (((_idx(y_true_59, i_70).Length != cols_65) || (_idx(y_pred_60, i_70).Length != cols_65))) {
                throw new Exception("Shape of y_true and y_pred must be the same.");
            }
            double sum_true_71 = 0.0;
            double sum_pred_72 = 0.0;
            long j_73 = 0;
            while ((j_73 < cols_65)) {
                double yt_74 = _idx(_idx(y_true_59, i_70), j_73);
                double yp_75 = _idx(_idx(y_pred_60, i_70), j_73);
                if (((yt_74 != 0.0) && (yt_74 != 1.0))) {
                    throw new Exception("y_true must be one-hot encoded.");
                }
                sum_true_71 = (sum_true_71 + yt_74);
                sum_pred_72 = (sum_pred_72 + yp_75);
                j_73 = (j_73 + 1);
            }
            if ((sum_true_71 != 1.0)) {
                throw new Exception("y_true must be one-hot encoded.");
            }
            if ((Program.absf((sum_pred_72 - 1.0)) > epsilon_63)) {
                throw new Exception("Predicted probabilities must sum to approximately 1.");
            }
            double row_loss_76 = 0.0;
            j_73 = 0;
            while ((j_73 < cols_65)) {
                double yp_77 = Program.clip(_idx(_idx(y_pred_60, i_70), j_73), epsilon_63, 1.0);
                row_loss_76 = (row_loss_76 + (((_idx(a_66, j_73) * Program.powf((1.0 - yp_77), gamma_62)) * _idx(_idx(y_true_59, i_70), j_73)) * Program.ln(yp_77)));
                j_73 = (j_73 + 1);
            }
            total_69 = (total_69 - row_loss_76);
            i_70 = (i_70 + 1);
        };
        return (total_69 / Program.to_float(rows_64));
    }

    public static double hinge_loss(double[] y_true_78, double[] y_pred_79) {
        if ((y_true_78.Length != y_pred_79.Length)) {
            throw new Exception("Length of predicted and actual array must be same.");
        };
        double[] losses_80 = new double[]{};
        long i_81 = 0;
        while ((i_81 < y_true_78.Length)) {
            double yt_82 = _idx(y_true_78, i_81);
            if (((yt_82 != -1.0) && (yt_82 != 1.0))) {
                throw new Exception("y_true can have values -1 or 1 only.");
            }
            double pred_83 = _idx(y_pred_79, i_81);
            double l_84 = Program.maxf(0.0, (1.0 - (yt_82 * pred_83)));
            losses_80 = (Enumerable.ToArray(Enumerable.Append<double>(losses_80, l_84)));
            i_81 = (i_81 + 1);
        };
        return Program.mean(losses_80);
    }

    public static double huber_loss(double[] y_true_85, double[] y_pred_86, double delta_87) {
        if ((y_true_85.Length != y_pred_86.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double total_88 = 0.0;
        long i_89 = 0;
        while ((i_89 < y_true_85.Length)) {
            double diff_90 = (_idx(y_true_85, i_89) - _idx(y_pred_86, i_89));
            double adiff_91 = Program.absf(diff_90);
            if ((adiff_91 <= delta_87)) {
                total_88 = (total_88 + ((0.5 * diff_90) * diff_90));
            } else {
                total_88 = (total_88 + (delta_87 * (adiff_91 - (0.5 * delta_87))));
            }
            i_89 = (i_89 + 1);
        };
        return (total_88 / Program.to_float(y_true_85.Length));
    }

    public static double mean_squared_error(double[] y_true_92, double[] y_pred_93) {
        if ((y_true_92.Length != y_pred_93.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double[] losses_94 = new double[]{};
        long i_95 = 0;
        while ((i_95 < y_true_92.Length)) {
            double diff_96 = (_idx(y_true_92, i_95) - _idx(y_pred_93, i_95));
            losses_94 = (Enumerable.ToArray(Enumerable.Append<double>(losses_94, (diff_96 * diff_96))));
            i_95 = (i_95 + 1);
        };
        return Program.mean(losses_94);
    }

    public static double mean_absolute_error(double[] y_true_97, double[] y_pred_98) {
        if ((y_true_97.Length != y_pred_98.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double total_99 = 0.0;
        long i_100 = 0;
        while ((i_100 < y_true_97.Length)) {
            total_99 = (total_99 + Program.absf((_idx(y_true_97, i_100) - _idx(y_pred_98, i_100))));
            i_100 = (i_100 + 1);
        };
        return (total_99 / Program.to_float(y_true_97.Length));
    }

    public static double mean_squared_logarithmic_error(double[] y_true_101, double[] y_pred_102) {
        if ((y_true_101.Length != y_pred_102.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double total_103 = 0.0;
        long i_104 = 0;
        while ((i_104 < y_true_101.Length)) {
            double a_105 = Program.ln((1.0 + _idx(y_true_101, i_104)));
            double b_106 = Program.ln((1.0 + _idx(y_pred_102, i_104)));
            double diff_107 = (a_105 - b_106);
            total_103 = (total_103 + (diff_107 * diff_107));
            i_104 = (i_104 + 1);
        };
        return (total_103 / Program.to_float(y_true_101.Length));
    }

    public static double mean_absolute_percentage_error(double[] y_true_108, double[] y_pred_109, double epsilon_110) {
        if ((y_true_108.Length != y_pred_109.Length)) {
            throw new Exception("The length of the two arrays should be the same.");
        };
        double total_111 = 0.0;
        long i_112 = 0;
        while ((i_112 < y_true_108.Length)) {
            double yt_113 = _idx(y_true_108, i_112);
            if ((yt_113 == 0.0)) {
                yt_113 = epsilon_110;
            }
            total_111 = (total_111 + Program.absf(((yt_113 - _idx(y_pred_109, i_112)) / yt_113)));
            i_112 = (i_112 + 1);
        };
        return (total_111 / Program.to_float(y_true_108.Length));
    }

    public static double perplexity_loss(long[][] y_true_114, double[][][] y_pred_115, double epsilon_116) {
        long batch_117 = y_true_114.Length;
        if ((batch_117 != y_pred_115.Length)) {
            throw new Exception("Batch size of y_true and y_pred must be equal.");
        };
        long sentence_len_118 = _idx(y_true_114, 0).Length;
        if ((sentence_len_118 != _idx(y_pred_115, 0).Length)) {
            throw new Exception("Sentence length of y_true and y_pred must be equal.");
        };
        long vocab_size_119 = _idx(_idx(y_pred_115, 0), 0).Length;
        long b_120 = 0;
        double total_perp_121 = 0.0;
        while ((b_120 < batch_117)) {
            if (((_idx(y_true_114, b_120).Length != sentence_len_118) || (_idx(y_pred_115, b_120).Length != sentence_len_118))) {
                throw new Exception("Sentence length of y_true and y_pred must be equal.");
            }
            double sum_log_122 = 0.0;
            long j_123 = 0;
            while ((j_123 < sentence_len_118)) {
                long label_124 = _idx(_idx(y_true_114, b_120), j_123);
                if ((label_124 >= vocab_size_119)) {
                    throw new Exception("Label value must not be greater than vocabulary size.");
                }
                double prob_125 = Program.clip(_idx(_idx(_idx(y_pred_115, b_120), j_123), label_124), epsilon_116, 1.0);
                sum_log_122 = (sum_log_122 + Program.ln(prob_125));
                j_123 = (j_123 + 1);
            }
            double mean_log_126 = (sum_log_122 / Program.to_float(sentence_len_118));
            double perp_127 = Program.exp(-mean_log_126);
            total_perp_121 = (total_perp_121 + perp_127);
            b_120 = (b_120 + 1);
        };
        return (total_perp_121 / Program.to_float(batch_117));
    }

    public static double smooth_l1_loss(double[] y_true_128, double[] y_pred_129, double beta_130) {
        if ((y_true_128.Length != y_pred_129.Length)) {
            throw new Exception("The length of the two arrays should be the same.");
        };
        double total_131 = 0.0;
        long i_132 = 0;
        while ((i_132 < y_true_128.Length)) {
            double diff_133 = Program.absf((_idx(y_true_128, i_132) - _idx(y_pred_129, i_132)));
            if ((diff_133 < beta_130)) {
                total_131 = (total_131 + (((0.5 * diff_133) * diff_133) / beta_130));
            } else {
                total_131 = ((total_131 + diff_133) - (0.5 * beta_130));
            }
            i_132 = (i_132 + 1);
        };
        return (total_131 / Program.to_float(y_true_128.Length));
    }

    public static double kullback_leibler_divergence(double[] y_true_134, double[] y_pred_135) {
        if ((y_true_134.Length != y_pred_135.Length)) {
            throw new Exception("Input arrays must have the same length.");
        };
        double total_136 = 0.0;
        long i_137 = 0;
        while ((i_137 < y_true_134.Length)) {
            total_136 = (total_136 + (_idx(y_true_134, i_137) * Program.ln((_idx(y_true_134, i_137) / _idx(y_pred_135, i_137)))));
            i_137 = (i_137 + 1);
        };
        return total_136;
    }

    public static void main() {
        double[] y_true_bc_138 = new double[]{0.0, 1.0, 1.0, 0.0, 1.0};
        double[] y_pred_bc_139 = new double[]{0.2, 0.7, 0.9, 0.3, 0.8};
        Console.WriteLine(Program._fmtTop(Program.binary_cross_entropy(y_true_bc_138, y_pred_bc_139, 1e-15)));
        Console.WriteLine(Program._fmtTop(Program.binary_focal_cross_entropy(y_true_bc_138, y_pred_bc_139, 2.0, 0.25, 1e-15)));
        double[][] y_true_cce_140 = new double[][]{new double[]{1.0, 0.0, 0.0}, new double[]{0.0, 1.0, 0.0}, new double[]{0.0, 0.0, 1.0}};
        double[][] y_pred_cce_141 = new double[][]{new double[]{0.9, 0.1, 0.0}, new double[]{0.2, 0.7, 0.1}, new double[]{0.0, 0.1, 0.9}};
        Console.WriteLine(Program._fmtTop(Program.categorical_cross_entropy(y_true_cce_140, y_pred_cce_141, 1e-15)));
        double[] alpha_142 = new double[]{0.6, 0.2, 0.7};
        Console.WriteLine(Program._fmtTop(Program.categorical_focal_cross_entropy(y_true_cce_140, y_pred_cce_141, alpha_142, 2.0, 1e-15)));
        double[] y_true_hinge_143 = new double[]{-1.0, 1.0, 1.0, -1.0, 1.0};
        double[] y_pred_hinge_144 = new double[]{-4.0, -0.3, 0.7, 5.0, 10.0};
        Console.WriteLine(Program._fmtTop(Program.hinge_loss(y_true_hinge_143, y_pred_hinge_144)));
        double[] y_true_huber_145 = new double[]{0.9, 10.0, 2.0, 1.0, 5.2};
        double[] y_pred_huber_146 = new double[]{0.8, 2.1, 2.9, 4.2, 5.2};
        Console.WriteLine(Program._fmtTop(Program.huber_loss(y_true_huber_145, y_pred_huber_146, 1.0)));
        Console.WriteLine(Program._fmtTop(Program.mean_squared_error(y_true_huber_145, y_pred_huber_146)));
        Console.WriteLine(Program._fmtTop(Program.mean_absolute_error(y_true_huber_145, y_pred_huber_146)));
        Console.WriteLine(Program._fmtTop(Program.mean_squared_logarithmic_error(y_true_huber_145, y_pred_huber_146)));
        double[] y_true_mape_147 = new double[]{10.0, 20.0, 30.0, 40.0};
        double[] y_pred_mape_148 = new double[]{12.0, 18.0, 33.0, 45.0};
        Console.WriteLine(Program._fmtTop(Program.mean_absolute_percentage_error(y_true_mape_147, y_pred_mape_148, 1e-15)));
        long[][] y_true_perp_149 = new long[][]{new long[]{1, 4}, new long[]{2, 3}};
        double[][][] y_pred_perp_150 = new double[][][]{new double[][]{new double[]{0.28, 0.19, 0.21, 0.15, 0.17}, new double[]{0.24, 0.19, 0.09, 0.18, 0.3}}, new double[][]{new double[]{0.03, 0.26, 0.21, 0.18, 0.32}, new double[]{0.28, 0.1, 0.33, 0.15, 0.14}}};
        Console.WriteLine(Program._fmtTop(Program.perplexity_loss(y_true_perp_149, y_pred_perp_150, 1e-07)));
        double[] y_true_smooth_151 = new double[]{3.0, 5.0, 2.0, 7.0};
        double[] y_pred_smooth_152 = new double[]{2.9, 4.8, 2.1, 7.2};
        Console.WriteLine(Program._fmtTop(Program.smooth_l1_loss(y_true_smooth_151, y_pred_smooth_152, 1.0)));
        double[] y_true_kl_153 = new double[]{0.2, 0.3, 0.5};
        double[] y_pred_kl_154 = new double[]{0.3, 0.3, 0.4};
        Console.WriteLine(Program._fmtTop(Program.kullback_leibler_divergence(y_true_kl_153, y_pred_kl_154)));
    }

    static void Main() {
        _ = __name__;
        {
            var __memStart = _mem();
            var __start = _now();
            Program.main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            if (__dur <= 0) __dur = 1;
            var __memDiff = __memEnd - __memStart;
            if (__memDiff <= 0) __memDiff = __memEnd;
            Console.WriteLine("{\"name\":\"main\",\"duration_us\":" + __dur + ",\"memory_bytes\":" + __memDiff + "}");
        }
    }
}
