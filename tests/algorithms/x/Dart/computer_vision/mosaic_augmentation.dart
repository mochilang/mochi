// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class MosaicResult {
  List<List<int>> img;
  List<List<double>> annos;
  String path;
  MosaicResult({required this.img, required this.annos, required this.path});
}

MosaicResult update_image_and_anno(List<String> all_img_list, List<List<List<double>>> all_annos, List<int> idxs, List<int> output_size, List<double> scale_range, double filter_scale) {
  int height = output_size[0];
  int width = output_size[1];
  List<List<int>> output_img = <List<int>>[];
  int r = 0;
  while (r < height) {
    List<int> row = <int>[];
    int c = 0;
    while (c < width) {
    row = [...row, 0];
    c = c + 1;
  }
    output_img = ([...output_img, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    r = r + 1;
  }
  double scale_x = (scale_range[0] + scale_range[1]) / 2.0;
  double scale_y = (scale_range[0] + scale_range[1]) / 2.0;
  int divid_point_x = scale_x * (width as double) as int;
  int divid_point_y = scale_y * (height as double) as int;
  List<List<double>> new_anno = <List<double>>[];
  List<String> path_list = <String>[];
  int i = 0;
  while (i < idxs.length) {
    int index = idxs[i];
    String path = all_img_list[index];
    path_list = [...path_list, path];
    List<List<double>> img_annos = all_annos[index];
    if (i == 0) {
    int y0 = 0;
    while (y0 < divid_point_y) {
    int x0 = 0;
    while (x0 < divid_point_x) {
    while (output_img[y0]!.length <= x0) { output_img[y0]!.add(0); } output_img[y0]![x0] = i + 1;
    x0 = x0 + 1;
  }
    y0 = y0 + 1;
  };
    int j0 = 0;
    while (j0 < img_annos.length) {
    List<double> bbox = img_annos[j0];
    double xmin = bbox[1] * scale_x;
    double ymin = bbox[2] * scale_y;
    double xmax = bbox[3] * scale_x;
    double ymax = bbox[4] * scale_y;
    new_anno = ([...new_anno, [bbox[0], xmin, ymin, xmax, ymax]] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    j0 = j0 + 1;
  };
  } else {
    if (i == 1) {
    int y1 = 0;
    while (y1 < divid_point_y) {
    int x1 = divid_point_x;
    while (x1 < width) {
    while (output_img[y1]!.length <= x1) { output_img[y1]!.add(0); } output_img[y1]![x1] = i + 1;
    x1 = x1 + 1;
  }
    y1 = y1 + 1;
  };
    int j1 = 0;
    while (j1 < img_annos.length) {
    List<double> bbox1 = img_annos[j1];
    double xmin1 = scale_x + bbox1[1] * (1.0 - scale_x);
    double ymin1 = bbox1[2] * scale_y;
    double xmax1 = scale_x + bbox1[3] * (1.0 - scale_x);
    double ymax1 = bbox1[4] * scale_y;
    new_anno = ([...new_anno, [bbox1[0], xmin1, ymin1, xmax1, ymax1]] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    j1 = j1 + 1;
  };
  } else {
    if (i == 2) {
    int y2 = divid_point_y;
    while (y2 < height) {
    int x2 = 0;
    while (x2 < divid_point_x) {
    while (output_img[y2]!.length <= x2) { output_img[y2]!.add(0); } output_img[y2]![x2] = i + 1;
    x2 = x2 + 1;
  }
    y2 = y2 + 1;
  };
    int j2 = 0;
    while (j2 < img_annos.length) {
    List<double> bbox2 = img_annos[j2];
    double xmin2 = bbox2[1] * scale_x;
    double ymin2 = scale_y + bbox2[2] * (1.0 - scale_y);
    double xmax2 = bbox2[3] * scale_x;
    double ymax2 = scale_y + bbox2[4] * (1.0 - scale_y);
    new_anno = ([...new_anno, [bbox2[0], xmin2, ymin2, xmax2, ymax2]] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    j2 = j2 + 1;
  };
  } else {
    int y3 = divid_point_y;
    while (y3 < height) {
    int x3 = divid_point_x;
    while (x3 < width) {
    while (output_img[y3]!.length <= x3) { output_img[y3]!.add(0); } output_img[y3]![x3] = i + 1;
    x3 = x3 + 1;
  }
    y3 = y3 + 1;
  };
    int j3 = 0;
    while (j3 < img_annos.length) {
    List<double> bbox3 = img_annos[j3];
    double xmin3 = scale_x + bbox3[1] * (1.0 - scale_x);
    double ymin3 = scale_y + bbox3[2] * (1.0 - scale_y);
    double xmax3 = scale_x + bbox3[3] * (1.0 - scale_x);
    double ymax3 = scale_y + bbox3[4] * (1.0 - scale_y);
    new_anno = ([...new_anno, [bbox3[0], xmin3, ymin3, xmax3, ymax3]] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    j3 = j3 + 1;
  };
  };
  };
  }
    i = i + 1;
  }
  if (filter_scale > 0.0) {
    List<List<double>> filtered = <List<double>>[];
    int k = 0;
    while (k < new_anno.length) {
    List<double> anno = new_anno[k];
    double w = anno[3] - anno[1];
    double h = anno[4] - anno[2];
    if (filter_scale < w && filter_scale < h) {
    filtered = ([...filtered, anno] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  }
    k = k + 1;
  };
    new_anno = filtered;
  }
  return MosaicResult(img: output_img, annos: new_anno, path: path_list[0]);
}

dynamic _main() {
  List<String> all_img_list = ["img0.jpg", "img1.jpg", "img2.jpg", "img3.jpg"];
  List<List<List<double>>> all_annos = [[[0.0, 0.1, 0.1, 0.4, 0.4]], [[1.0, 0.2, 0.3, 0.5, 0.7]], [[2.0, 0.6, 0.2, 0.9, 0.5]], [[3.0, 0.5, 0.5, 0.8, 0.8]]];
  List<int> idxs = [0, 1, 2, 3];
  List<int> output_size = [100, 100];
  List<double> scale_range = [0.4, 0.6];
  double filter_scale = 0.05;
  MosaicResult res = update_image_and_anno(all_img_list, all_annos, idxs, output_size, scale_range, filter_scale);
  List<List<double>> new_annos = res.annos;
  String path = res.path;
  print("Base image: " + path);
  print("Mosaic annotation count: " + (new_annos.length).toString());
  int i = 0;
  while (i < new_annos.length) {
    List<double> a = new_annos[i];
    print((a[0]).toString() + " " + (a[1]).toString() + " " + (a[2]).toString() + " " + (a[3]).toString() + " " + (a[4]).toString());
    i = i + 1;
  }
}

void _start() {
  _main();
}

void main() => _start();
