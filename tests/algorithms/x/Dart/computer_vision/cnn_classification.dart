// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

List<List<double>> conv2d(List<List<double>> image, List<List<double>> kernel) {
  int rows = image.length;
  int cols = image[0].length;
  int k = kernel.length;
  List<List<double>> output = <List<double>>[];
  int i = 0;
  while (i <= rows - k) {
    List<double> row = <double>[];
    int j = 0;
    while (j <= cols - k) {
    double sum = 0.0;
    int ki = 0;
    while (ki < k) {
    int kj = 0;
    while (kj < k) {
    sum = sum + image[i + ki][j + kj] * kernel[ki][kj];
    kj = kj + 1;
  }
    ki = ki + 1;
  }
    row = [...row, sum];
    j = j + 1;
  }
    output = ([...output, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return output;
}

List<List<double>> relu_matrix(List<List<double>> m) {
  List<List<double>> out = <List<double>>[];
  for (List<double> row in m) {
    List<double> new_row = <double>[];
    for (double v in row) {
    if (v > 0.0) {
    new_row = [...new_row, v];
  } else {
    new_row = [...new_row, 0.0];
  }
  }
    out = ([...out, new_row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  }
  return out;
}

List<List<double>> max_pool2x2(List<List<double>> m) {
  int rows = m.length;
  int cols = m[0].length;
  List<List<double>> out = <List<double>>[];
  int i = 0;
  while (i < rows) {
    List<double> new_row = <double>[];
    int j = 0;
    while (j < cols) {
    double max_val = m[i][j];
    if (m[i][j + 1] > max_val) {
    max_val = m[i][j + 1];
  }
    if (m[i + 1][j] > max_val) {
    max_val = m[i + 1][j];
  }
    if (m[i + 1][j + 1] > max_val) {
    max_val = m[i + 1][j + 1];
  }
    new_row = [...new_row, max_val];
    j = j + 2;
  }
    out = ([...out, new_row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 2;
  }
  return out;
}

List<double> flatten(List<List<double>> m) {
  List<double> res = <double>[];
  for (List<double> row in m) {
    for (double v in row) {
    res = [...res, v];
  }
  }
  return res;
}

double dense(List<double> inputs, List<double> weights, double bias) {
  double s = bias;
  int i = 0;
  while (i < inputs.length) {
    s = s + inputs[i] * weights[i];
    i = i + 1;
  }
  return s;
}

double exp_approx(double x) {
  double sum = 1.0;
  double term = 1.0;
  int i = 1;
  while (i <= 10) {
    term = term * x / i;
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

double sigmoid(double x) {
  return 1.0 / (1.0 + exp_approx(-x));
}

List<List<double>> image = [[0.0, 1.0, 1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 1.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 1.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]];
List<List<double>> kernel = [[1.0, 0.0, -1.0], [1.0, 0.0, -1.0], [1.0, 0.0, -1.0]];
List<List<double>> conv = conv2d(image, kernel);
List<List<double>> activated = relu_matrix(conv);
List<List<double>> pooled = max_pool2x2(activated);
List<double> flat = flatten(pooled);
List<double> weights = [0.5, -0.4, 0.3, 0.1];
double bias = 0.0;
double output = dense(flat, weights, bias);
double probability = sigmoid(output);
void main() {
  if (probability >= 0.5) {
    print("Abnormality detected");
  } else {
    print("Normal");
  }
  print("Probability:");
  print(probability);
}
