// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

class Network {
  List<List<double>> w1;
  List<List<double>> w2;
  List<List<double>> w3;
  Network({required this.w1, required this.w2, required this.w3});
}

double exp_approx(double x) {
  double sum = 1.0;
  double term = 1.0;
  int i = 1;
  while (i < 10) {
    term = term * x / ((i).toDouble());
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

double sigmoid(double x) {
  return 1.0 / (1.0 + exp_approx(-x));
}

double sigmoid_derivative(double x) {
  return x * (1.0 - x);
}

Network new_network() {
  return Network(w1: [[0.1, 0.2, 0.3, 0.4], [0.5, 0.6, 0.7, 0.8], [0.9, 1.0, 1.1, 1.2]], w2: [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.0, 1.1, 1.2]], w3: [[0.1], [0.2], [0.3]]);
}

double feedforward(Network net, List<double> input) {
  List<double> hidden1 = <double>[];
  int j = 0;
  while (j < 4) {
    double sum1 = 0.0;
    int i = 0;
    while (i < 3) {
    sum1 = sum1 + input[i] * net.w1[i][j];
    i = i + 1;
  }
    hidden1 = (hidden1..add(sigmoid(sum1)));
    j = j + 1;
  }
  List<double> hidden2 = <double>[];
  int k = 0;
  while (k < 3) {
    double sum2 = 0.0;
    int j2 = 0;
    while (j2 < 4) {
    sum2 = sum2 + hidden1[j2] * net.w2[j2][k];
    j2 = j2 + 1;
  }
    hidden2 = (hidden2..add(sigmoid(sum2)));
    k = k + 1;
  }
  double sum3 = 0.0;
  int k2 = 0;
  while (k2 < 3) {
    sum3 = sum3 + hidden2[k2] * net.w3[k2][0];
    k2 = k2 + 1;
  }
  double out = sigmoid(sum3);
  return out;
}

void train(Network net, List<List<double>> inputs, List<double> outputs, int iterations) {
  int iter = 0;
  while (iter < iterations) {
    int s = 0;
    while (s < inputs.length) {
    List<double> inp = inputs[s];
    double target = outputs[s];
    List<double> hidden1 = <double>[];
    int j = 0;
    while (j < 4) {
    double sum1 = 0.0;
    int i = 0;
    while (i < 3) {
    sum1 = sum1 + inp[i] * net.w1[i][j];
    i = i + 1;
  }
    hidden1 = (hidden1..add(sigmoid(sum1)));
    j = j + 1;
  }
    List<double> hidden2 = <double>[];
    int k = 0;
    while (k < 3) {
    double sum2 = 0.0;
    int j2 = 0;
    while (j2 < 4) {
    sum2 = sum2 + hidden1[j2] * net.w2[j2][k];
    j2 = j2 + 1;
  }
    hidden2 = (hidden2..add(sigmoid(sum2)));
    k = k + 1;
  }
    double sum3 = 0.0;
    int k3 = 0;
    while (k3 < 3) {
    sum3 = sum3 + hidden2[k3] * net.w3[k3][0];
    k3 = k3 + 1;
  }
    double output = sigmoid(sum3);
    double error = target - output;
    double delta_output = error * sigmoid_derivative(output);
    List<List<double>> new_w3 = <List<double>>[];
    int k4 = 0;
    while (k4 < 3) {
    List<double> w3row = net.w3[k4];
    while (w3row.length <= 0) { w3row.add(0); } w3row[0] = w3row[0] + hidden2[k4] * delta_output;
    new_w3 = ((new_w3..add(w3row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    k4 = k4 + 1;
  }
    net.w3 = new_w3;
    List<double> delta_hidden2 = <double>[];
    int k5 = 0;
    while (k5 < 3) {
    List<double> row = net.w3[k5];
    double dh2 = row[0] * delta_output * sigmoid_derivative(hidden2[k5]);
    delta_hidden2 = (delta_hidden2..add(dh2));
    k5 = k5 + 1;
  }
    List<List<double>> new_w2 = <List<double>>[];
    j = 0;
    while (j < 4) {
    List<double> w2row = net.w2[j];
    int k6 = 0;
    while (k6 < 3) {
    while (w2row.length <= k6) { w2row.add(0); } w2row[k6] = w2row[k6] + hidden1[j] * delta_hidden2[k6];
    k6 = k6 + 1;
  }
    new_w2 = ((new_w2..add(w2row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    j = j + 1;
  }
    net.w2 = new_w2;
    List<double> delta_hidden1 = <double>[];
    j = 0;
    while (j < 4) {
    double sumdh = 0.0;
    int k7 = 0;
    while (k7 < 3) {
    List<double> row2 = net.w2[j];
    sumdh = sumdh + row2[k7] * delta_hidden2[k7];
    k7 = k7 + 1;
  }
    delta_hidden1 = (delta_hidden1..add(sumdh * sigmoid_derivative(hidden1[j])));
    j = j + 1;
  }
    List<List<double>> new_w1 = <List<double>>[];
    int i2 = 0;
    while (i2 < 3) {
    List<double> w1row = net.w1[i2];
    j = 0;
    while (j < 4) {
    while (w1row.length <= j) { w1row.add(0); } w1row[j] = w1row[j] + inp[i2] * delta_hidden1[j];
    j = j + 1;
  }
    new_w1 = ((new_w1..add(w1row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i2 = i2 + 1;
  }
    net.w1 = new_w1;
    s = s + 1;
  }
    iter = iter + 1;
  }
}

int predict(Network net, List<double> input) {
  double out = feedforward(net, input);
  if (out > 0.6) {
    return 1;
  }
  return 0;
}

int example() {
  List<List<double>> inputs = [[0.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [0.0, 1.0, 1.0], [1.0, 0.0, 0.0], [1.0, 0.0, 1.0], [1.0, 1.0, 0.0], [1.0, 1.0, 1.0]];
  List<double> outputs = [0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0];
  Network net = new_network();
  train(net, inputs, outputs, 10);
  int result = predict(net, [1.0, 1.0, 1.0]);
  print(_str(result));
  return result;
}

void _main() {
  example();
}

void _start() {
  _main();
}

void main() => _start();
