// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class CNN {
  List<List<List<double>>> conv_kernels;
  List<double> conv_bias;
  int conv_step;
  int pool_size;
  List<List<double>> w_hidden;
  List<List<double>> w_out;
  List<double> b_hidden;
  List<double> b_out;
  double rate_weight;
  double rate_bias;
  CNN({required this.conv_kernels, required this.conv_bias, required this.conv_step, required this.pool_size, required this.w_hidden, required this.w_out, required this.b_hidden, required this.b_out, required this.rate_weight, required this.rate_bias});
}

class TrainSample {
  List<List<double>> image;
  List<double> target;
  TrainSample({required this.image, required this.target});
}

int seed = 1;
double random() {
  seed = (seed * 13 + 7) % 100;
  return (seed.toDouble()) / 100.0;
}

double sigmoid(double x) {
  return 1.0 / (1.0 + exp(-x));
}

double to_float(int x) {
  return x * 1.0;
}

double exp(double x) {
  double term = 1.0;
  double sum = 1.0;
  int n = 1;
  while (n < 20) {
    term = term * x / to_float(n);
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

List<List<double>> convolve(List<List<double>> data, List<List<double>> kernel, int step, double bias) {
  int size_data = data.length;
  int size_kernel = kernel.length;
  List<List<double>> out = <List<double>>[];
  int i = 0;
  while (i <= size_data - size_kernel) {
    List<double> row = <double>[];
    int j = 0;
    while (j <= size_data - size_kernel) {
    double sum = 0.0;
    int a = 0;
    while (a < size_kernel) {
    int b = 0;
    while (b < size_kernel) {
    sum = sum + data[i + a][j + b] * kernel[a][b];
    b = b + 1;
  }
    a = a + 1;
  }
    row = (row..add(sigmoid(sum - bias)));
    j = j + step;
  }
    out = ((out..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + step;
  }
  return out;
}

List<List<double>> average_pool(List<List<double>> map, int size) {
  List<List<double>> out = <List<double>>[];
  int i = 0;
  while (i < map.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < map[i].length) {
    double sum = 0.0;
    int a = 0;
    while (a < size) {
    int b = 0;
    while (b < size) {
    sum = sum + map[i + a][j + b];
    b = b + 1;
  }
    a = a + 1;
  }
    row = (row..add(sum / (size * size.toDouble())));
    j = j + size;
  }
    out = ((out..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + size;
  }
  return out;
}

List<double> flatten(List<List<List<double>>> maps) {
  List<double> out = <double>[];
  int i = 0;
  while (i < maps.length) {
    int j = 0;
    while (j < maps[i].length) {
    int k = 0;
    while (k < maps[i][j].length) {
    out = (out..add(maps[i][j][k]));
    k = k + 1;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return out;
}

List<double> vec_mul_mat(List<double> v, List<List<double>> m) {
  int cols = m[0].length;
  List<double> res = <double>[];
  int j = 0;
  while (j < cols) {
    double sum = 0.0;
    int i = 0;
    while (i < v.length) {
    sum = sum + v[i] * m[i][j];
    i = i + 1;
  }
    res = (res..add(sum));
    j = j + 1;
  }
  return res;
}

List<double> matT_vec_mul(List<List<double>> m, List<double> v) {
  List<double> res = <double>[];
  int i = 0;
  while (i < m.length) {
    double sum = 0.0;
    int j = 0;
    while (j < m[i].length) {
    sum = sum + m[i][j] * v[j];
    j = j + 1;
  }
    res = (res..add(sum));
    i = i + 1;
  }
  return res;
}

List<double> vec_add(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = (res..add(a[i] + b[i]));
    i = i + 1;
  }
  return res;
}

List<double> vec_sub(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = (res..add(a[i] - b[i]));
    i = i + 1;
  }
  return res;
}

List<double> vec_mul(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = (res..add(a[i] * b[i]));
    i = i + 1;
  }
  return res;
}

List<double> vec_map_sig(List<double> v) {
  List<double> res = <double>[];
  int i = 0;
  while (i < v.length) {
    res = (res..add(sigmoid(v[i])));
    i = i + 1;
  }
  return res;
}

CNN new_cnn() {
  List<List<double>> k1 = [[1.0, 0.0], [0.0, 1.0]];
  List<List<double>> k2 = [[0.0, 1.0], [1.0, 0.0]];
  List<List<List<double>>> conv_kernels = [k1, k2];
  List<double> conv_bias = [0.0, 0.0];
  int conv_step = 2;
  int pool_size = 2;
  int input_size = 2;
  int hidden_size = 2;
  int output_size = 2;
  List<List<double>> w_hidden = <List<double>>[];
  int i = 0;
  while (i < input_size) {
    List<double> row = <double>[];
    int j = 0;
    while (j < hidden_size) {
    row = (row..add(random() - 0.5));
    j = j + 1;
  }
    w_hidden = ((w_hidden..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  List<List<double>> w_out = <List<double>>[];
  i = 0;
  while (i < hidden_size) {
    List<double> row = <double>[];
    int j = 0;
    while (j < output_size) {
    row = (row..add(random() - 0.5));
    j = j + 1;
  }
    w_out = ((w_out..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  List<double> b_hidden = [0.0, 0.0];
  List<double> b_out = [0.0, 0.0];
  return CNN(conv_kernels: conv_kernels, conv_bias: conv_bias, conv_step: conv_step, pool_size: pool_size, w_hidden: w_hidden, w_out: w_out, b_hidden: b_hidden, b_out: b_out, rate_weight: 0.2, rate_bias: 0.2);
}

List<double> forward(CNN cnn, List<List<double>> data) {
  List<List<List<double>>> maps = <List<List<double>>>[];
  int i = 0;
  while (i < cnn.conv_kernels.length) {
    List<List<double>> conv_map = convolve(data, cnn.conv_kernels[i], cnn.conv_step, cnn.conv_bias[i]);
    List<List<double>> pooled = average_pool(conv_map, cnn.pool_size);
    maps = ((maps..add(pooled)) as List).map((e) => ((e as List).map((e) => (List<double>.from(e) as List<double>)).toList() as List<List<double>>)).toList();
    i = i + 1;
  }
  List<double> flat = flatten(maps);
  List<double> hidden_net = vec_add(vec_mul_mat(flat, cnn.w_hidden), cnn.b_hidden);
  List<double> hidden_out = vec_map_sig(hidden_net);
  List<double> out_net = vec_add(vec_mul_mat(hidden_out, cnn.w_out), cnn.b_out);
  List<double> out = vec_map_sig(out_net);
  return out;
}

CNN train(CNN cnn, List<TrainSample> samples, int epochs) {
  List<List<double>> w_out = cnn.w_out;
  List<double> b_out = cnn.b_out;
  List<List<double>> w_hidden = cnn.w_hidden;
  List<double> b_hidden = cnn.b_hidden;
  int e = 0;
  while (e < epochs) {
    int s = 0;
    while (s < samples.length) {
    List<List<double>> data = samples[s].image;
    List<double> target = samples[s].target;
    List<List<List<double>>> maps = <List<List<double>>>[];
    int i = 0;
    while (i < cnn.conv_kernels.length) {
    List<List<double>> conv_map = convolve(data, cnn.conv_kernels[i], cnn.conv_step, cnn.conv_bias[i]);
    List<List<double>> pooled = average_pool(conv_map, cnn.pool_size);
    maps = ((maps..add(pooled)) as List).map((e) => ((e as List).map((e) => (List<double>.from(e) as List<double>)).toList() as List<List<double>>)).toList();
    i = i + 1;
  }
    List<double> flat = flatten(maps);
    List<double> hidden_net = vec_add(vec_mul_mat(flat, w_hidden), b_hidden);
    List<double> hidden_out = vec_map_sig(hidden_net);
    List<double> out_net = vec_add(vec_mul_mat(hidden_out, w_out), b_out);
    List<double> out = vec_map_sig(out_net);
    List<double> error_out = vec_sub(target, out);
    List<double> pd_out = vec_mul(error_out, vec_mul(out, vec_sub([1.0, 1.0], out)));
    List<double> error_hidden = matT_vec_mul(w_out, pd_out);
    List<double> pd_hidden = vec_mul(error_hidden, vec_mul(hidden_out, vec_sub([1.0, 1.0], hidden_out)));
    int j = 0;
    while (j < w_out.length) {
    int k = 0;
    while (k < w_out[j].length) {
    while (w_out[j]!.length <= k) { w_out[j]!.add(0); } w_out[j]![k] = w_out[j][k] + cnn.rate_weight * hidden_out[j] * pd_out[k];
    k = k + 1;
  }
    j = j + 1;
  }
    j = 0;
    while (j < b_out.length) {
    while (b_out.length <= j) { b_out.add(0); } b_out[j] = b_out[j] - cnn.rate_bias * pd_out[j];
    j = j + 1;
  }
    int i_h = 0;
    while (i_h < w_hidden.length) {
    int j_h = 0;
    while (j_h < w_hidden[i_h].length) {
    while (w_hidden[i_h]!.length <= j_h) { w_hidden[i_h]!.add(0); } w_hidden[i_h]![j_h] = w_hidden[i_h][j_h] + cnn.rate_weight * flat[i_h] * pd_hidden[j_h];
    j_h = j_h + 1;
  }
    i_h = i_h + 1;
  }
    j = 0;
    while (j < b_hidden.length) {
    while (b_hidden.length <= j) { b_hidden.add(0); } b_hidden[j] = b_hidden[j] - cnn.rate_bias * pd_hidden[j];
    j = j + 1;
  }
    s = s + 1;
  }
    e = e + 1;
  }
  return CNN(conv_kernels: cnn.conv_kernels, conv_bias: cnn.conv_bias, conv_step: cnn.conv_step, pool_size: cnn.pool_size, w_hidden: w_hidden, w_out: w_out, b_hidden: b_hidden, b_out: b_out, rate_weight: cnn.rate_weight, rate_bias: cnn.rate_bias);
}

dynamic _main() {
  CNN cnn = new_cnn();
  List<List<double>> image = [[1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 0.0, 1.0]];
  TrainSample sample = TrainSample(image: image, target: [1.0, 0.0]);
  print(["Before training:", "[" + forward(cnn, image).join(', ') + "]"].join(" "));
  CNN trained = train(cnn, [sample], 50);
  print(["After training:", "[" + forward(trained, image).join(', ') + "]"].join(" "));
}

void _start() {
  _main();
}

void main() => _start();
