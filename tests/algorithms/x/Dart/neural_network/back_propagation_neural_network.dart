// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Layer {
  int units;
  List<List<double>> weight;
  List<double> bias;
  List<double> output;
  List<double> xdata;
  double learn_rate;
  Layer({required this.units, required this.weight, required this.bias, required this.output, required this.xdata, required this.learn_rate});
}

class Data {
  List<List<double>> x;
  List<List<double>> y;
  Data({required this.x, required this.y});
}

int seed = 1;
int rand() {
  seed = (seed * 1103515245 + 12345) % 2147483648;
  return seed;
}

double random() {
  return 1.0 * rand() / 2147483648.0;
}

double expApprox(double x) {
  double y = x;
  bool is_neg = false;
  if (x < 0.0) {
    is_neg = true;
    y = -x;
  }
  double term = 1.0;
  double sum = 1.0;
  int n = 1;
  while (n < 30) {
    term = term * y / (n.toDouble());
    sum = sum + term;
    n = n + 1;
  }
  if (is_neg) {
    return 1.0 / sum;
  }
  return sum;
}

double sigmoid(double z) {
  return 1.0 / (1.0 + expApprox(-z));
}

List<double> sigmoid_vec(List<double> v) {
  List<double> res = <double>[];
  int i = 0;
  while (i < v.length) {
    res = (res..add(sigmoid(v[i])));
    i = i + 1;
  }
  return res;
}

List<double> sigmoid_derivative(List<double> out) {
  List<double> res = <double>[];
  int i = 0;
  while (i < out.length) {
    double val = out[i];
    res = (res..add(val * (1.0 - val)));
    i = i + 1;
  }
  return res;
}

List<double> random_vector(int n) {
  List<double> v = <double>[];
  int i = 0;
  while (i < n) {
    v = (v..add(random() - 0.5));
    i = i + 1;
  }
  return v;
}

List<List<double>> random_matrix(int r, int c) {
  List<List<double>> m = <List<double>>[];
  int i = 0;
  while (i < r) {
    m = ((m..add(random_vector(c))) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return m;
}

List<double> matvec(List<List<double>> mat, List<double> vec) {
  List<double> res = <double>[];
  int i = 0;
  while (i < mat.length) {
    double s = 0.0;
    int j = 0;
    while (j < vec.length) {
    s = s + mat[i][j] * vec[j];
    j = j + 1;
  }
    res = (res..add(s));
    i = i + 1;
  }
  return res;
}

List<double> matTvec(List<List<double>> mat, List<double> vec) {
  int cols = mat[0].length;
  List<double> res = <double>[];
  int j = 0;
  while (j < cols) {
    double s = 0.0;
    int i = 0;
    while (i < mat.length) {
    s = s + mat[i][j] * vec[i];
    i = i + 1;
  }
    res = (res..add(s));
    j = j + 1;
  }
  return res;
}

List<double> vec_sub(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = (res..add(a[i] - b[i]));
    i = i + 1;
  }
  return res;
}

List<double> vec_mul(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = (res..add(a[i] * b[i]));
    i = i + 1;
  }
  return res;
}

List<double> vec_scalar_mul(List<double> v, double s) {
  List<double> res = <double>[];
  int i = 0;
  while (i < v.length) {
    res = (res..add(v[i] * s));
    i = i + 1;
  }
  return res;
}

List<List<double>> outer(List<double> a, List<double> b) {
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < a.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < b.length) {
    row = (row..add(a[i] * b[j]));
    j = j + 1;
  }
    res = ((res..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

List<List<double>> mat_scalar_mul(List<List<double>> mat, double s) {
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < mat.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < mat[i].length) {
    row = (row..add(mat[i][j] * s));
    j = j + 1;
  }
    res = ((res..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

List<List<double>> mat_sub(List<List<double>> a, List<List<double>> b) {
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < a.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < a[i].length) {
    row = (row..add(a[i][j] - b[i][j]));
    j = j + 1;
  }
    res = ((res..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

Layer init_layer(int units, int back_units, double lr) {
  return Layer(units: units, weight: random_matrix(units, back_units), bias: random_vector(units), output: [], xdata: [], learn_rate: lr);
}

List<Layer> forward(List<Layer> layers, List<double> x) {
  List<double> data = x;
  int i = 0;
  while (i < layers.length) {
    Layer layer = layers[i];
    layer.xdata = data;
    if (i == 0) {
    layer.output = data;
  } else {
    List<double> z = vec_sub(matvec(layer.weight, data), layer.bias);
    layer.output = sigmoid_vec(z);
    data = layer.output;
  }
    while (layers.length <= i) { layers.add(null as dynamic); } layers[i] = layer;
    i = i + 1;
  }
  return layers;
}

List<Layer> backward(List<Layer> layers, List<double> grad) {
  List<double> g = grad;
  int i = layers.length - 1;
  while (i > 0) {
    Layer layer = layers[i];
    List<double> deriv = sigmoid_derivative(layer.output);
    List<double> delta = vec_mul(g, deriv);
    List<List<double>> grad_w = outer(delta, layer.xdata);
    layer.weight = mat_sub(layer.weight, mat_scalar_mul(grad_w, layer.learn_rate));
    layer.bias = vec_sub(layer.bias, vec_scalar_mul(delta, layer.learn_rate));
    g = matTvec(layer.weight, delta);
    while (layers.length <= i) { layers.add(null as dynamic); } layers[i] = layer;
    i = i - 1;
  }
  return layers;
}

double calc_loss(List<double> y, List<double> yhat) {
  double s = 0.0;
  int i = 0;
  while (i < y.length) {
    double d = y[i] - yhat[i];
    s = s + d * d;
    i = i + 1;
  }
  return s;
}

List<double> calc_gradient(List<double> y, List<double> yhat) {
  List<double> g = <double>[];
  int i = 0;
  while (i < y.length) {
    g = (g..add(2.0 * (yhat[i] - y[i])));
    i = i + 1;
  }
  return g;
}

double train(List<Layer> layers, List<List<double>> xdata, List<List<double>> ydata, int rounds, double acc) {
  int r = 0;
  while (r < rounds) {
    int i = 0;
    while (i < xdata.length) {
    layers = forward(layers, xdata[i]);
    List<double> out = layers[layers.length - 1].output;
    List<double> grad = calc_gradient(ydata[i], out);
    layers = backward(layers, grad);
    i = i + 1;
  }
    r = r + 1;
  }
  return 0.0;
}

Data create_data() {
  List<List<double>> x = <List<double>>[];
  int i = 0;
  while (i < 10) {
    x = ((x..add(random_vector(10))) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  List<List<double>> y = [[0.8, 0.4], [0.4, 0.3], [0.34, 0.45], [0.67, 0.32], [0.88, 0.67], [0.78, 0.77], [0.55, 0.66], [0.55, 0.43], [0.54, 0.1], [0.1, 0.5]];
  return Data(x: x, y: y);
}

void _main() {
  Data data = create_data();
  List<List<double>> x = data.x;
  List<List<double>> y = data.y;
  List<Layer> layers = <Layer>[];
  layers = (layers..add(init_layer(10, 0, 0.3)));
  layers = (layers..add(init_layer(20, 10, 0.3)));
  layers = (layers..add(init_layer(30, 20, 0.3)));
  layers = (layers..add(init_layer(2, 30, 0.3)));
  double final_mse = train(layers, x, y, 100, 0.01);
  print(final_mse);
}

void _start() {
  _main();
}

void main() => _start();
