// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _str(dynamic v) => v.toString();

List<int> calculate_waitingtime(List<int> arrival_time, List<int> burst_time, int no_of_processes) {
  List<int> remaining_time = <int>[];
  int i = 0;
  while (i < no_of_processes) {
    remaining_time = [...remaining_time, burst_time[i]];
    i = i + 1;
  }
  List<int> waiting_time = <int>[];
  i = 0;
  while (i < no_of_processes) {
    waiting_time = [...waiting_time, 0];
    i = i + 1;
  }
  int complete = 0;
  int increment_time = 0;
  int minm = 1000000000;
  int short = 0;
  bool check = false;
  while (complete != no_of_processes) {
    int j = 0;
    while (j < no_of_processes) {
    if (arrival_time[j] <= increment_time && remaining_time[j] > 0 && remaining_time[j] < minm) {
    minm = remaining_time[j];
    short = j;
    check = true;
  }
    j = j + 1;
  }
    if (!check) {
    increment_time = increment_time + 1;
    continue;
  }
    while (remaining_time.length <= short) { remaining_time.add(0); } remaining_time[short] = remaining_time[short] - 1;
    minm = remaining_time[short];
    if (minm == 0) {
    minm = 1000000000;
  }
    if (remaining_time[short] == 0) {
    complete = complete + 1;
    check = false;
    int finish_time = increment_time + 1;
    int finar = finish_time - arrival_time[short];
    while (waiting_time.length <= short) { waiting_time.add(0); } waiting_time[short] = finar - burst_time[short];
    if (waiting_time[short] < 0) {
    while (waiting_time.length <= short) { waiting_time.add(0); } waiting_time[short] = 0;
  };
  }
    increment_time = increment_time + 1;
  }
  return waiting_time;
}

List<int> calculate_turnaroundtime(List<int> burst_time, int no_of_processes, List<int> waiting_time) {
  List<int> turn_around_time = <int>[];
  int i = 0;
  while (i < no_of_processes) {
    turn_around_time = [...turn_around_time, burst_time[i] + waiting_time[i]];
    i = i + 1;
  }
  return turn_around_time;
}

double to_float(int x) {
  return x * 1.0;
}

dynamic calculate_average_times(List<int> waiting_time, List<int> turn_around_time, int no_of_processes) {
  int total_waiting_time = 0;
  int total_turn_around_time = 0;
  int i = 0;
  while (i < no_of_processes) {
    total_waiting_time = total_waiting_time + waiting_time[i];
    total_turn_around_time = total_turn_around_time + turn_around_time[i];
    i = i + 1;
  }
  double avg_wait = total_waiting_time.toDouble() / no_of_processes.toDouble();
  double avg_turn = total_turn_around_time.toDouble() / no_of_processes.toDouble();
  print("Average waiting time = " + _str(avg_wait));
  print("Average turn around time = " + _str(avg_turn));
}

void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print("[" + calculate_waitingtime([1, 2, 3, 4], [3, 3, 5, 1], 4).join(', ') + "]");
  print("[" + calculate_waitingtime([1, 2, 3], [2, 5, 1], 3).join(', ') + "]");
  print("[" + calculate_waitingtime([2, 3], [5, 1], 2).join(', ') + "]");
  print("[" + calculate_turnaroundtime([3, 3, 5, 1], 4, [0, 3, 5, 0]).join(', ') + "]");
  print("[" + calculate_turnaroundtime([3, 3], 2, [0, 3]).join(', ') + "]");
  print("[" + calculate_turnaroundtime([8, 10, 1], 3, [1, 0, 3]).join(', ') + "]");
  calculate_average_times([0, 3, 5, 0], [3, 6, 10, 1], 4);
  calculate_average_times([2, 3], [3, 6], 2);
  calculate_average_times([10, 4, 3], [2, 7, 6], 3);
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
