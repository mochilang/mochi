// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

int WIDTH = 10;
int HEIGHT = 10;
int PREY_INITIAL_COUNT = 20;
int PREY_REPRODUCTION_TIME = 5;
int PREDATOR_INITIAL_COUNT = 5;
int PREDATOR_REPRODUCTION_TIME = 20;
int PREDATOR_INITIAL_ENERGY = 15;
int PREDATOR_FOOD_VALUE = 5;
int TYPE_PREY = 0;
int TYPE_PREDATOR = 1;
int seed = 123456789;
int rand() {
  seed = (seed * 1103515245 + 12345) % 2147483648;
  return seed;
}

int rand_range(int max) {
  return rand() % max;
}

List<int> shuffle(List<int> list_int) {
  int i = list_int.length - 1;
  while (i > 0) {
    int j = rand_range(i + 1);
    int tmp = list_int[i];
    while (list_int.length <= i) { list_int.add(0); } list_int[i] = list_int[j];
    while (list_int.length <= j) { list_int.add(0); } list_int[j] = tmp;
    i = i - 1;
  }
  return list_int;
}

List<List<int>> create_board() {
  List<List<int>> board = <List<int>>[];
  int r = 0;
  while (r < HEIGHT) {
    List<int> row = <int>[];
    int c = 0;
    while (c < WIDTH) {
    row = [...row, 0];
    c = c + 1;
  }
    board = ([...board, row] as List).map((e) => (e as List<int>)).toList();
    r = r + 1;
  }
  return board;
}

List<int> create_prey(int r, int c) {
  return [TYPE_PREY, r, c, PREY_REPRODUCTION_TIME, 0, 1];
}

List<int> create_predator(int r, int c) {
  return [TYPE_PREDATOR, r, c, PREDATOR_REPRODUCTION_TIME, PREDATOR_INITIAL_ENERGY, 1];
}

List<List<int>> board = create_board();
List<List<int>> entities = <List<int>>[];
bool empty_cell(int r, int c) {
  return board[r][c] == 0;
}

void add_entity(int typ) {
  while (true) {
    int r = rand_range(HEIGHT);
    int c = rand_range(WIDTH);
    if (empty_cell(r, c)) {
    if (typ == TYPE_PREY) {
    while (board[r]!.length <= c) { board[r]!.add(0); } board[r]![c] = 1;
    entities = ([...entities, create_prey(r, c)] as List).map((e) => (e as List<int>)).toList();
  } else {
    while (board[r]!.length <= c) { board[r]!.add(0); } board[r]![c] = 2;
    entities = ([...entities, create_predator(r, c)] as List).map((e) => (e as List<int>)).toList();
  };
    return;
  }
  }
}

void setup() {
  int i = 0;
  while (i < PREY_INITIAL_COUNT) {
    add_entity(TYPE_PREY);
    i = i + 1;
  }
  i = 0;
  while (i < PREDATOR_INITIAL_COUNT) {
    add_entity(TYPE_PREDATOR);
    i = i + 1;
  }
}

List<int> dr = [-1, 0, 1, 0];
List<int> dc = [0, 1, 0, -1];
bool inside(int r, int c) {
  return r >= 0 && r < HEIGHT && c >= 0 && c < WIDTH;
}

int find_prey(int r, int c) {
  int i = 0;
  while (i < entities.length) {
    List<int> e = entities[i];
    if (e[5] == 1 && e[0] == TYPE_PREY && e[1] == r && e[2] == c) {
    return i;
  }
    i = i + 1;
  }
  return -1;
}

void step_world() {
  int i = 0;
  while (i < entities.length) {
    List<int> e = entities[i];
    if (e[5] == 0) {
    i = i + 1;
    continue;
  }
    int typ = e[0];
    int row = e[1];
    int col = e[2];
    int repro = e[3];
    int energy = e[4];
    List<int> dirs = [0, 1, 2, 3];
    dirs = shuffle(dirs);
    bool moved = false;
    int old_r = row;
    int old_c = col;
    if (typ == TYPE_PREDATOR) {
    int j = 0;
    bool ate = false;
    while (j < 4) {
    int d = dirs[j];
    int nr = row + dr[d];
    int nc = col + dc[d];
    if (inside(nr, nc) && board[nr][nc] == 1) {
    int prey_index = find_prey(nr, nc);
    if (prey_index >= 0) {
    while (entities[prey_index]!.length <= 5) { entities[prey_index]!.add(0); } entities[prey_index]![5] = 0;
  };
    while (board[nr]!.length <= nc) { board[nr]!.add(0); } board[nr]![nc] = 2;
    while (board[row]!.length <= col) { board[row]!.add(0); } board[row]![col] = 0;
    while (e.length <= 1) { e.add(0); } e[1] = nr;
    while (e.length <= 2) { e.add(0); } e[2] = nc;
    while (e.length <= 4) { e.add(0); } e[4] = energy + PREDATOR_FOOD_VALUE - 1;
    moved = true;
    ate = true;
    break;
  }
    j = j + 1;
  };
    if (!ate) {
    j = 0;
    while (j < 4) {
    int d = dirs[j];
    int nr = row + dr[d];
    int nc = col + dc[d];
    if (inside(nr, nc) && board[nr][nc] == 0) {
    while (board[nr]!.length <= nc) { board[nr]!.add(0); } board[nr]![nc] = 2;
    while (board[row]!.length <= col) { board[row]!.add(0); } board[row]![col] = 0;
    while (e.length <= 1) { e.add(0); } e[1] = nr;
    while (e.length <= 2) { e.add(0); } e[2] = nc;
    moved = true;
    break;
  }
    j = j + 1;
  };
    while (e.length <= 4) { e.add(0); } e[4] = energy - 1;
  };
    if (e[4] <= 0) {
    while (e.length <= 5) { e.add(0); } e[5] = 0;
    while (board[e[1]]!.length <= e[2]) { board[e[1]]!.add(0); } board[e[1]]![e[2]] = 0;
  };
  } else {
    int j = 0;
    while (j < 4) {
    int d = dirs[j];
    int nr = row + dr[d];
    int nc = col + dc[d];
    if (inside(nr, nc) && board[nr][nc] == 0) {
    while (board[nr]!.length <= nc) { board[nr]!.add(0); } board[nr]![nc] = 1;
    while (board[row]!.length <= col) { board[row]!.add(0); } board[row]![col] = 0;
    while (e.length <= 1) { e.add(0); } e[1] = nr;
    while (e.length <= 2) { e.add(0); } e[2] = nc;
    moved = true;
    break;
  }
    j = j + 1;
  };
  }
    if (e[5] == 1) {
    if (moved && repro <= 0) {
    if (typ == TYPE_PREY) {
    while (board[old_r]!.length <= old_c) { board[old_r]!.add(0); } board[old_r]![old_c] = 1;
    entities = ([...entities, create_prey(old_r, old_c)] as List).map((e) => (e as List<int>)).toList();
    while (e.length <= 3) { e.add(0); } e[3] = PREY_REPRODUCTION_TIME;
  } else {
    while (board[old_r]!.length <= old_c) { board[old_r]!.add(0); } board[old_r]![old_c] = 2;
    entities = ([...entities, create_predator(old_r, old_c)] as List).map((e) => (e as List<int>)).toList();
    while (e.length <= 3) { e.add(0); } e[3] = PREDATOR_REPRODUCTION_TIME;
  };
  } else {
    while (e.length <= 3) { e.add(0); } e[3] = repro - 1;
  };
  }
    i = i + 1;
  }
  List<List<int>> alive = <List<int>>[];
  int k = 0;
  while (k < entities.length) {
    List<int> e2 = entities[k];
    if (e2[5] == 1) {
    alive = ([...alive, e2] as List).map((e) => (e as List<int>)).toList();
  }
    k = k + 1;
  }
  entities = alive;
}

int count_entities(int typ) {
  int cnt = 0;
  int i = 0;
  while (i < entities.length) {
    if (entities[i][0] == typ && entities[i][5] == 1) {
    cnt = cnt + 1;
  }
    i = i + 1;
  }
  return cnt;
}

int t = 0;
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  setup();
  while (t < 10) {
    step_world();
    t = t + 1;
  }
  print("Prey: " + (count_entities(TYPE_PREY)).toString());
  print("Predators: " + (count_entities(TYPE_PREDATOR)).toString());
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
