// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

class Solution {
  List<String> path;
  int cost;
  Solution({required this.path, required this.cost});
}

class Swap {
  String a;
  String b;
  Swap({required this.a, required this.b});
}

int path_cost(List<String> path, Map<String, Map<String, int>> graph) {
  int total = 0;
  int i = 0;
  while (i < path.length - 1) {
    String u = path[i];
    String v = path[i + 1];
    total = total + ((graph[u] ?? {})[v] ?? 0);
    i = i + 1;
  }
  return total;
}

Solution generate_first_solution(Map<String, Map<String, int>> graph, String start) {
  List<String> path = <String>[];
  String visiting = start;
  int total = 0;
  while (path.length < graph.length) {
    path = (path..add(visiting));
    String best_node = "";
    int best_cost = 1000000;
    for (var n in graph[visiting]!.keys) {
    if (!path.contains(n) && ((graph[visiting] ?? {})[n] ?? 0) < best_cost) {
    best_cost = (graph[visiting] ?? {})[n]!;
    best_node = n;
  }
  }
    if (best_node == "") {
    break;
  }
    total = total + best_cost;
    visiting = best_node;
  }
  path = (path..add(start));
  total = total + ((graph[visiting] ?? {})[start] ?? 0);
  return Solution(path: path, cost: total);
}

List<String> copy_path(List<String> path) {
  List<String> res = <String>[];
  int i = 0;
  while (i < path.length) {
    res = (res..add(path[i]));
    i = i + 1;
  }
  return res;
}

List<Solution> find_neighborhood(Solution sol, Map<String, Map<String, int>> graph) {
  List<Solution> neighbors = <Solution>[];
  int i = 1;
  while (i < sol.path.length - 1) {
    int j = 1;
    while (j < sol.path.length - 1) {
    if (i != j) {
    List<String> new_path = copy_path(sol.path);
    String tmp = new_path[i];
    while (new_path.length <= i) { new_path.add(""); } new_path[i] = new_path[j];
    while (new_path.length <= j) { new_path.add(""); } new_path[j] = tmp;
    int cost = path_cost(new_path, graph);
    neighbors = (neighbors..add(Solution(path: new_path, cost: cost)));
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return neighbors;
}

Swap find_swap(List<String> a, List<String> b) {
  int i = 0;
  while (i < a.length) {
    if (a[i] != b[i]) {
    return Swap(a: a[i], b: b[i]);
  }
    i = i + 1;
  }
  return Swap(a: "", b: "");
}

Solution tabu_search(Solution first, Map<String, Map<String, int>> graph, int iters, int size) {
  Solution solution = first;
  Solution best = first;
  List<Swap> tabu = <Swap>[];
  int count = 0;
  while (count < iters) {
    List<Solution> neighborhood = find_neighborhood(solution, graph);
    if (neighborhood.length == 0) {
    break;
  }
    Solution best_neighbor = neighborhood[0];
    Swap best_move = find_swap(solution.path, best_neighbor.path);
    int i = 1;
    while (i < neighborhood.length) {
    Solution cand = neighborhood[i];
    Swap move = find_swap(solution.path, cand.path);
    bool forbidden = false;
    int t = 0;
    while (t < tabu.length) {
    if (tabu[t].a == move.a && tabu[t].b == move.b || tabu[t].a == move.b && tabu[t].b == move.a) {
    forbidden = true;
  }
    t = t + 1;
  }
    if (forbidden == false && cand.cost < best_neighbor.cost) {
    best_neighbor = cand;
    best_move = move;
  }
    i = i + 1;
  }
    solution = best_neighbor;
    tabu = (tabu..add(best_move));
    if (tabu.length > size) {
    List<Swap> new_tab = <Swap>[];
    int j = 1;
    while (j < tabu.length) {
    new_tab = (new_tab..add(tabu[j]));
    j = j + 1;
  };
    tabu = new_tab;
  }
    if (solution.cost < best.cost) {
    best = solution;
  }
    count = count + 1;
  }
  return best;
}

Map<String, Map<String, int>> graph = {"a": {"b": 20, "c": 18, "d": 22, "e": 26}, "b": {"a": 20, "c": 10, "d": 11, "e": 12}, "c": {"a": 18, "b": 10, "d": 23, "e": 24}, "d": {"a": 22, "b": 11, "c": 23, "e": 40}, "e": {"a": 26, "b": 12, "c": 24, "d": 40}};
Solution first = generate_first_solution(graph, "a");
Solution best = tabu_search(first, graph, 4, 3);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print(_str(best.path));
  print(_str(best.cost));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
