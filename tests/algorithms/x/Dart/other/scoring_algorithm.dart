// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

List<List<double>> get_data(List<List<double>> source_data) {
  List<List<double>> data_lists = <List<double>>[];
  int i = 0;
  while (i < source_data.length) {
    List<double> row = source_data[i];
    int j = 0;
    while (j < row.length) {
    if (data_lists.length < j + 1) {
    List<double> empty = <double>[];
    data_lists = ((data_lists..add(empty)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  }
    while (data_lists.length <= j) { data_lists.add(<double>[]); } data_lists[j] = (data_lists[j]..add(row[j]));
    j = j + 1;
  }
    i = i + 1;
  }
  return data_lists;
}

List<List<double>> calculate_each_score(List<List<double>> data_lists, List<int> weights) {
  List<List<double>> score_lists = <List<double>>[];
  int i = 0;
  while (i < data_lists.length) {
    List<double> dlist = data_lists[i];
    int weight = weights[i];
    double mind = dlist[0];
    double maxd = dlist[0];
    int j = 1;
    while (j < dlist.length) {
    double val = dlist[j];
    if (val < mind) {
    mind = val;
  }
    if (val > maxd) {
    maxd = val;
  }
    j = j + 1;
  }
    List<double> score = <double>[];
    j = 0;
    if (weight == 0) {
    while (j < dlist.length) {
    double item = dlist[j];
    if (maxd - mind == 0.0) {
    score = (score..add(1.0));
  } else {
    score = (score..add(1.0 - (item - mind) / (maxd - mind)));
  }
    j = j + 1;
  };
  } else {
    while (j < dlist.length) {
    double item = dlist[j];
    if (maxd - mind == 0.0) {
    score = (score..add(0.0));
  } else {
    score = (score..add((item - mind) / (maxd - mind)));
  }
    j = j + 1;
  };
  }
    score_lists = ((score_lists..add(score)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return score_lists;
}

List<double> generate_final_scores(List<List<double>> score_lists) {
  int count = score_lists[0].length;
  List<double> final_scores = <double>[];
  int i = 0;
  while (i < count) {
    final_scores = (final_scores..add(0.0));
    i = i + 1;
  }
  i = 0;
  while (i < score_lists.length) {
    List<double> slist = score_lists[i];
    int j = 0;
    while (j < slist.length) {
    while (final_scores.length <= j) { final_scores.add(0); } final_scores[j] = final_scores[j] + slist[j];
    j = j + 1;
  }
    i = i + 1;
  }
  return final_scores;
}

List<List<double>> procentual_proximity(List<List<double>> source_data, List<int> weights) {
  List<List<double>> data_lists = get_data(source_data);
  List<List<double>> score_lists = calculate_each_score(data_lists, weights);
  List<double> final_scores = generate_final_scores(score_lists);
  int i = 0;
  while (i < final_scores.length) {
    while (source_data.length <= i) { source_data.add(<double>[]); } source_data[i] = (source_data[i]..add(final_scores[i]));
    i = i + 1;
  }
  return source_data;
}

List<List<double>> vehicles = <List<double>>[];
List<int> weights = [0, 0, 1];
List<List<double>> result = procentual_proximity(vehicles, weights);
void main() {
  vehicles = ((vehicles..add([20.0, 60.0, 2012.0])) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  vehicles = ((vehicles..add([23.0, 90.0, 2015.0])) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  vehicles = ((vehicles..add([22.0, 50.0, 2011.0])) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  print(_str(result));
}
