// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { var i = v.toInt(); if (i == 0) return '0'; return i.toString(); } return v.toString(); }

class Node {
  int key;
  int value;
  int prev;
  int next;
  Node({required this.key, required this.value, required this.prev, required this.next});
}

class DoubleLinkedList {
  List<Node> nodes;
  int head;
  int tail;
  DoubleLinkedList({required this.nodes, required this.head, required this.tail});
}

class LRUCache {
  DoubleLinkedList list;
  int capacity;
  int num_keys;
  int hits;
  int misses;
  Map<String, int> cache;
  LRUCache({required this.list, required this.capacity, required this.num_keys, required this.hits, required this.misses, required this.cache});
}

class GetResult {
  LRUCache cache;
  int value;
  bool ok;
  GetResult({required this.cache, required this.value, required this.ok});
}

DoubleLinkedList new_list() {
  List<Node> nodes = <Node>[];
  Node head = Node(key: 0, value: 0, prev: 0 - 1, next: 1);
  Node tail = Node(key: 0, value: 0, prev: 0, next: 0 - 1);
  nodes = [...nodes, head];
  nodes = [...nodes, tail];
  return DoubleLinkedList(nodes: nodes, head: 0, tail: 1);
}

DoubleLinkedList dll_add(DoubleLinkedList lst, int idx) {
  List<Node> nodes = lst.nodes;
  int tail_idx = lst.tail;
  Node tail_node = nodes[tail_idx];
  int prev_idx = tail_node.prev;
  Node node = nodes[idx];
  node.prev = prev_idx;
  node.next = tail_idx;
  while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
  Node prev_node = nodes[prev_idx];
  prev_node.next = idx;
  while (nodes.length <= prev_idx) { nodes.add(null as dynamic); } nodes[prev_idx] = prev_node;
  tail_node.prev = idx;
  while (nodes.length <= tail_idx) { nodes.add(null as dynamic); } nodes[tail_idx] = tail_node;
  lst.nodes = nodes;
  return lst;
}

DoubleLinkedList dll_remove(DoubleLinkedList lst, int idx) {
  List<Node> nodes = lst.nodes;
  Node node = nodes[idx];
  int prev_idx = node.prev;
  int next_idx = node.next;
  if (prev_idx == 0 - 1 || next_idx == 0 - 1) {
    return lst;
  }
  Node prev_node = nodes[prev_idx];
  prev_node.next = next_idx;
  while (nodes.length <= prev_idx) { nodes.add(null as dynamic); } nodes[prev_idx] = prev_node;
  Node next_node = nodes[next_idx];
  next_node.prev = prev_idx;
  while (nodes.length <= next_idx) { nodes.add(null as dynamic); } nodes[next_idx] = next_node;
  node.prev = 0 - 1;
  node.next = 0 - 1;
  while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
  lst.nodes = nodes;
  return lst;
}

LRUCache new_cache(int cap) {
  Map<String, int> empty_map = <String, int>{};
  return LRUCache(list: new_list(), capacity: cap, num_keys: 0, hits: 0, misses: 0, cache: empty_map);
}

GetResult lru_get(LRUCache c, int key) {
  LRUCache cache = c;
  String key_str = _str(key);
  if (cache.cache.containsKey(key_str)) {
    int idx = cache.cache[key_str]!;
    if (idx != 0 - 1) {
    cache.hits = cache.hits + 1;
    Node node = cache.list.nodes[idx];
    int value = node.value;
    cache.list = dll_remove(cache.list, idx);
    cache.list = dll_add(cache.list, idx);
    return GetResult(cache: cache, value: value, ok: true);
  };
  }
  cache.misses = cache.misses + 1;
  return GetResult(cache: cache, value: 0, ok: false);
}

LRUCache lru_put(LRUCache c, int key, int value) {
  LRUCache cache = c;
  String key_str = _str(key);
  if (!cache.cache.containsKey(key_str)) {
    if (cache.num_keys >= cache.capacity) {
    Node head_node = cache.list.nodes[cache.list.head];
    int first_idx = head_node.next;
    Node first_node = cache.list.nodes[first_idx];
    int old_key = first_node.key;
    cache.list = dll_remove(cache.list, first_idx);
    Map<String, int> mdel = cache.cache;
    mdel[_str(old_key)] = 0 - 1;
    cache.cache = mdel;
    cache.num_keys = cache.num_keys - 1;
  };
    List<Node> nodes = cache.list.nodes;
    Node new_node = Node(key: key, value: value, prev: 0 - 1, next: 0 - 1);
    nodes = [...nodes, new_node];
    int idx = nodes.length - 1;
    cache.list!.nodes = nodes;
    cache.list = dll_add(cache.list, idx);
    Map<String, int> m = cache.cache;
    m[key_str] = idx;
    cache.cache = m;
    cache.num_keys = cache.num_keys + 1;
  } else {
    Map<String, int> m = cache.cache;
    int idx = m[key_str]!;
    List<Node> nodes = cache.list.nodes;
    Node node = nodes[idx];
    node.value = value;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    cache.list!.nodes = nodes;
    cache.list = dll_remove(cache.list, idx);
    cache.list = dll_add(cache.list, idx);
    cache.cache = m;
  }
  return cache;
}

String cache_info(LRUCache cache) {
  return "CacheInfo(hits=" + _str(cache.hits) + ", misses=" + _str(cache.misses) + ", capacity=" + _str(cache.capacity) + ", current size=" + _str(cache.num_keys) + ")";
}

void print_result(GetResult res) {
  if (res.ok) {
    print(_str(res.value));
  } else {
    print("None");
  }
}

void _main() {
  LRUCache cache = new_cache(2);
  cache = lru_put(cache, 1, 1);
  cache = lru_put(cache, 2, 2);
  GetResult r1 = lru_get(cache, 1);
  cache = r1.cache;
  print_result(r1);
  cache = lru_put(cache, 3, 3);
  GetResult r2 = lru_get(cache, 2);
  cache = r2.cache;
  print_result(r2);
  cache = lru_put(cache, 4, 4);
  GetResult r3 = lru_get(cache, 1);
  cache = r3.cache;
  print_result(r3);
  GetResult r4 = lru_get(cache, 3);
  cache = r4.cache;
  print_result(r4);
  GetResult r5 = lru_get(cache, 4);
  cache = r5.cache;
  print_result(r5);
  print(cache_info(cache));
}

void _start() {
  _main();
}

void main() => _start();
