// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

class Entry {
  int key;
  int val;
  int freq;
  int order;
  Entry({required this.key, required this.val, required this.freq, required this.order});
}

class LFUCache {
  List<Entry> entries;
  int capacity;
  int hits;
  int miss;
  int tick;
  LFUCache({required this.entries, required this.capacity, required this.hits, required this.miss, required this.tick});
}

class GetResult {
  LFUCache cache;
  int value;
  bool ok;
  GetResult({required this.cache, required this.value, required this.ok});
}

LFUCache lfu_new(int cap) {
  return LFUCache(entries: [], capacity: cap, hits: 0, miss: 0, tick: 0);
}

int find_entry(List<Entry> entries, int key) {
  int i = 0;
  while (i < entries.length) {
    Entry e = entries[i];
    if (e.key == key) {
    return i;
  }
    i = i + 1;
  }
  return 0 - 1;
}

GetResult lfu_get(LFUCache cache, int key) {
  int idx = find_entry(cache.entries, key);
  if (idx == 0 - 1) {
    LFUCache new_cache = LFUCache(entries: cache.entries, capacity: cache.capacity, hits: cache.hits, miss: cache.miss + 1, tick: cache.tick);
    return GetResult(cache: new_cache, value: 0, ok: false);
  }
  List<Entry> entries = cache.entries;
  Entry e = entries[idx];
  e.freq = e.freq + 1;
  int new_tick = cache.tick + 1;
  e.order = new_tick;
  while (entries.length <= idx) { entries.add(null as dynamic); } entries[idx] = e;
  LFUCache new_cache = LFUCache(entries: entries, capacity: cache.capacity, hits: cache.hits + 1, miss: cache.miss, tick: new_tick);
  return GetResult(cache: new_cache, value: e.val, ok: true);
}

List<Entry> remove_lfu(List<Entry> entries) {
  if (entries.length == 0) {
    return entries;
  }
  int min_idx = 0;
  int i = 1;
  while (i < entries.length) {
    Entry e = entries[i];
    Entry m = entries[min_idx];
    if (e.freq < m.freq || e.freq == m.freq && e.order < m.order) {
    min_idx = i;
  }
    i = i + 1;
  }
  List<Entry> res = <Entry>[];
  int j = 0;
  while (j < entries.length) {
    if (j != min_idx) {
    res = (res..add(entries[j]));
  }
    j = j + 1;
  }
  return res;
}

LFUCache lfu_put(LFUCache cache, int key, int value) {
  List<Entry> entries = cache.entries;
  int idx = find_entry(entries, key);
  if (idx != 0 - 1) {
    Entry e = entries[idx];
    e.val = value;
    e.freq = e.freq + 1;
    int new_tick = cache.tick + 1;
    e.order = new_tick;
    while (entries.length <= idx) { entries.add(null as dynamic); } entries[idx] = e;
    return LFUCache(entries: entries, capacity: cache.capacity, hits: cache.hits, miss: cache.miss, tick: new_tick);
  }
  if (entries.length >= cache.capacity) {
    entries = remove_lfu(entries);
  }
  int new_tick = cache.tick + 1;
  Entry new_entry = Entry(key: key, val: value, freq: 1, order: new_tick);
  entries = (entries..add(new_entry));
  return LFUCache(entries: entries, capacity: cache.capacity, hits: cache.hits, miss: cache.miss, tick: new_tick);
}

String cache_info(LFUCache cache) {
  return "CacheInfo(hits=" + _str(cache.hits) + ", misses=" + _str(cache.miss) + ", capacity=" + _str(cache.capacity) + ", current_size=" + _str(cache.entries.length) + ")";
}

void _main() {
  LFUCache cache = lfu_new(2);
  cache = lfu_put(cache, 1, 1);
  cache = lfu_put(cache, 2, 2);
  GetResult r = lfu_get(cache, 1);
  cache = r.cache;
  if (r.ok) {
    print(_str(r.value));
  } else {
    print("None");
  }
  cache = lfu_put(cache, 3, 3);
  r = lfu_get(cache, 2);
  cache = r.cache;
  if (r.ok) {
    print(_str(r.value));
  } else {
    print("None");
  }
  cache = lfu_put(cache, 4, 4);
  r = lfu_get(cache, 1);
  cache = r.cache;
  if (r.ok) {
    print(_str(r.value));
  } else {
    print("None");
  }
  r = lfu_get(cache, 3);
  cache = r.cache;
  if (r.ok) {
    print(_str(r.value));
  } else {
    print("None");
  }
  r = lfu_get(cache, 4);
  cache = r.cache;
  if (r.ok) {
    print(_str(r.value));
  } else {
    print("None");
  }
  print(cache_info(cache));
}

void _start() {
  _main();
}

void main() => _start();
