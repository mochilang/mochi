// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

double int_to_float(int x) {
  return x * 1.0;
}

double abs_float(double x) {
  if (x < 0.0) {
    return 0.0 - x;
  }
  return x;
}

double exp_approx(double x) {
  double term = 1.0;
  double sum = 1.0;
  int i = 1;
  while (i < 10) {
    term = term * x / int_to_float(i);
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

int floor_int(double x) {
  int i = 0;
  while (int_to_float(i + 1) <= x) {
    i = i + 1;
  }
  return i;
}

double dot(List<double> a, List<double> b) {
  double s = 0.0;
  int i = 0;
  while (i < a.length) {
    s = s + a[i] * b[i];
    i = i + 1;
  }
  return s;
}

List<List<double>> transpose(List<List<double>> m) {
  int rows = m.length;
  int cols = m[0].length;
  List<List<double>> res = <List<double>>[];
  int j = 0;
  while (j < cols) {
    List<double> row = <double>[];
    int i = 0;
    while (i < rows) {
    row = [...row, m[i][j]];
    i = i + 1;
  }
    res = ([...res, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    j = j + 1;
  }
  return res;
}

List<List<double>> matmul(List<List<double>> a, List<List<double>> b) {
  int n = a.length;
  int m = b[0].length;
  int p = b.length;
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < n) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m) {
    double s = 0.0;
    int k = 0;
    while (k < p) {
    s = s + a[i][k] * b[k][j];
    k = k + 1;
  }
    row = [...row, s];
    j = j + 1;
  }
    res = ([...res, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

List<double> matvec(List<List<double>> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = [...res, dot(a[i], b)];
    i = i + 1;
  }
  return res;
}

List<List<double>> identity(int n) {
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < n) {
    List<double> row = <double>[];
    int j = 0;
    while (j < n) {
    row = [...row, (i == j ? 1.0 : 0.0)];
    j = j + 1;
  }
    res = ([...res, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

List<List<double>> invert(List<List<double>> mat) {
  int n = mat.length;
  List<List<double>> a = mat;
  List<List<double>> inv = identity(n);
  int i = 0;
  while (i < n) {
    double pivot = a[i][i];
    int j = 0;
    while (j < n) {
    while (a[i]!.length <= j) { a[i]!.add(0); } a[i]![j] = a[i][j] / pivot;
    while (inv[i]!.length <= j) { inv[i]!.add(0); } inv[i]![j] = inv[i][j] / pivot;
    j = j + 1;
  }
    int k = 0;
    while (k < n) {
    if (k != i) {
    double factor = a[k][i];
    j = 0;
    while (j < n) {
    while (a[k]!.length <= j) { a[k]!.add(0); } a[k]![j] = a[k][j] - factor * a[i][j];
    while (inv[k]!.length <= j) { inv[k]!.add(0); } inv[k]![j] = inv[k][j] - factor * inv[i][j];
    j = j + 1;
  };
  }
    k = k + 1;
  }
    i = i + 1;
  }
  return inv;
}

List<double> normal_equation(List<List<double>> X, List<double> y) {
  List<List<double>> Xt = transpose(X);
  List<List<double>> XtX = matmul(Xt, X);
  List<List<double>> XtX_inv = invert(XtX);
  List<double> Xty = matvec(Xt, y);
  return matvec(XtX_inv, Xty);
}

double linear_regression_prediction(List<double> train_dt, List<double> train_usr, List<double> train_mtch, List<double> test_dt, List<double> test_mtch) {
  List<List<double>> X = <List<double>>[];
  int i = 0;
  while (i < train_dt.length) {
    X = ([...X, [1.0, train_dt[i], train_mtch[i]]] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  List<double> beta = normal_equation(X, train_usr);
  return abs_float(beta[0] + test_dt[0] * beta[1] + test_mtch[0] * beta[2]);
}

double sarimax_predictor(List<double> train_user, List<double> train_match, List<double> test_match) {
  int n = train_user.length;
  List<List<double>> X = <List<double>>[];
  List<double> y = <double>[];
  int i = 1;
  while (i < n) {
    X = ([...X, [1.0, train_user[i - 1], train_match[i]]] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    y = [...y, train_user[i]];
    i = i + 1;
  }
  List<double> beta = normal_equation(X, y);
  return beta[0] + beta[1] * train_user[n - 1] + beta[2] * test_match[0];
}

double rbf_kernel(List<double> a, List<double> b, double gamma) {
  double sum = 0.0;
  int i = 0;
  while (i < a.length) {
    double diff = a[i] - b[i];
    sum = sum + diff * diff;
    i = i + 1;
  }
  return exp_approx(-gamma * sum);
}

double support_vector_regressor(List<List<double>> x_train, List<List<double>> x_test, List<double> train_user) {
  double gamma = 0.1;
  List<double> weights = <double>[];
  int i = 0;
  while (i < x_train.length) {
    weights = [...weights, rbf_kernel(x_train[i], x_test[0], gamma)];
    i = i + 1;
  }
  double _num = 0.0;
  double den = 0.0;
  i = 0;
  while (i < train_user.length) {
    _num = _num + weights[i] * train_user[i];
    den = den + weights[i];
    i = i + 1;
  }
  return _num / den;
}

List<double> set_at_float(List<double> xs, int idx, double value) {
  int i = 0;
  List<double> res = <double>[];
  while (i < xs.length) {
    if (i == idx) {
    res = [...res, value];
  } else {
    res = [...res, xs[i]];
  }
    i = i + 1;
  }
  return res;
}

List<double> sort_float(List<double> xs) {
  List<double> res = xs;
  int i = 1;
  while (i < res.length) {
    double key = res[i];
    int j = i - 1;
    while (j >= 0 && res[j] > key) {
    res = set_at_float(res, j + 1, res[j]);
    j = j - 1;
  }
    res = set_at_float(res, j + 1, key);
    i = i + 1;
  }
  return res;
}

double percentile(List<double> data, double q) {
  List<double> sorted = sort_float(data);
  int n = sorted.length;
  double pos = q / 100.0 * int_to_float(n - 1);
  int idx = floor_int(pos);
  double frac = pos - int_to_float(idx);
  if (idx + 1 < n) {
    return sorted[idx] * (1.0 - frac) + sorted[idx + 1] * frac;
  }
  return sorted[idx];
}

double interquartile_range_checker(List<double> train_user) {
  double q1 = percentile(train_user, 25.0);
  double q3 = percentile(train_user, 75.0);
  double iqr = q3 - q1;
  return q1 - iqr * 0.1;
}

bool data_safety_checker(List<double> list_vote, double actual_result) {
  int safe = 0;
  int not_safe = 0;
  int i = 0;
  while (i < list_vote.length) {
    double v = list_vote[i];
    if (v > actual_result) {
    safe = not_safe + 1;
  } else {
    if (abs_float(abs_float(v) - abs_float(actual_result)) <= 0.1) {
    safe = safe + 1;
  } else {
    not_safe = not_safe + 1;
  };
  }
    i = i + 1;
  }
  return safe > not_safe;
}

dynamic _main() {
  List<double> vote = [linear_regression_prediction([2.0, 3.0, 4.0, 5.0], [5.0, 3.0, 4.0, 6.0], [3.0, 1.0, 2.0, 4.0], [2.0], [2.0]), sarimax_predictor([4.0, 2.0, 6.0, 8.0], [3.0, 1.0, 2.0, 4.0], [2.0]), support_vector_regressor([[5.0, 2.0], [1.0, 5.0], [6.0, 2.0]], [[3.0, 2.0]], [2.0, 1.0, 4.0])];
  print(vote[0]);
  print(vote[1]);
  print(vote[2]);
  print(data_safety_checker(vote, 5.0));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
