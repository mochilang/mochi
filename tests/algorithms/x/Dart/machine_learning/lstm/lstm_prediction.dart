// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class LSTMWeights {
  double w_i;
  double u_i;
  double b_i;
  double w_f;
  double u_f;
  double b_f;
  double w_o;
  double u_o;
  double b_o;
  double w_c;
  double u_c;
  double b_c;
  double w_y;
  double b_y;
  LSTMWeights({required this.w_i, required this.u_i, required this.b_i, required this.w_f, required this.u_f, required this.b_f, required this.w_o, required this.u_o, required this.b_o, required this.w_c, required this.u_c, required this.b_c, required this.w_y, required this.b_y});
}

class LSTMState {
  List<double> i;
  List<double> f;
  List<double> o;
  List<double> g;
  List<double> c;
  List<double> h;
  LSTMState({required this.i, required this.f, required this.o, required this.g, required this.c, required this.h});
}

class Samples {
  List<List<double>> x;
  List<double> y;
  Samples({required this.x, required this.y});
}

double exp_approx(double x) {
  double sum = 1.0;
  double term = 1.0;
  int n = 1;
  while (n < 20) {
    term = term * x / ((n).toDouble());
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

double sigmoid(double x) {
  return 1.0 / (1.0 + exp_approx(-x));
}

double tanh_approx(double x) {
  double e = exp_approx(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

LSTMState forward(List<double> seq, LSTMWeights w) {
  List<double> i_arr = <double>[];
  List<double> f_arr = <double>[];
  List<double> o_arr = <double>[];
  List<double> g_arr = <double>[];
  List<double> c_arr = [0.0];
  List<double> h_arr = [0.0];
  int t = 0;
  while (t < seq.length) {
    double x = seq[t];
    double h_prev = h_arr[t];
    double c_prev = c_arr[t];
    double i_t = sigmoid(w.w_i * x + w.u_i * h_prev + w.b_i);
    double f_t = sigmoid(w.w_f * x + w.u_f * h_prev + w.b_f);
    double o_t = sigmoid(w.w_o * x + w.u_o * h_prev + w.b_o);
    double g_t = tanh_approx(w.w_c * x + w.u_c * h_prev + w.b_c);
    double c_t = f_t * c_prev + i_t * g_t;
    double h_t = o_t * tanh_approx(c_t);
    i_arr = [...i_arr, i_t];
    f_arr = [...f_arr, f_t];
    o_arr = [...o_arr, o_t];
    g_arr = [...g_arr, g_t];
    c_arr = [...c_arr, c_t];
    h_arr = [...h_arr, h_t];
    t = t + 1;
  }
  return LSTMState(i: i_arr, f: f_arr, o: o_arr, g: g_arr, c: c_arr, h: h_arr);
}

LSTMWeights backward(List<double> seq, double target, LSTMWeights w, LSTMState s, double lr) {
  double dw_i = 0.0;
  double du_i = 0.0;
  double db_i = 0.0;
  double dw_f = 0.0;
  double du_f = 0.0;
  double db_f = 0.0;
  double dw_o = 0.0;
  double du_o = 0.0;
  double db_o = 0.0;
  double dw_c = 0.0;
  double du_c = 0.0;
  double db_c = 0.0;
  double dw_y = 0.0;
  double db_y = 0.0;
  int T = seq.length;
  double h_last = s.h[T];
  double y = w.w_y * h_last + w.b_y;
  double dy = y - target;
  dw_y = dy * h_last;
  db_y = dy;
  double dh_next = dy * w.w_y;
  double dc_next = 0.0;
  int t = T - 1;
  while (t >= 0) {
    double i_t = s.i[t];
    double f_t = s.f[t];
    double o_t = s.o[t];
    double g_t = s.g[t];
    double c_t = s.c[t + 1];
    double c_prev = s.c[t];
    double h_prev = s.h[t];
    double tanh_c = tanh_approx(c_t);
    double do_t = dh_next * tanh_c;
    double da_o = do_t * o_t * (1.0 - o_t);
    double dc = dh_next * o_t * (1.0 - tanh_c * tanh_c) + dc_next;
    double di_t = dc * g_t;
    double da_i = di_t * i_t * (1.0 - i_t);
    double dg_t = dc * i_t;
    double da_g = dg_t * (1.0 - g_t * g_t);
    double df_t = dc * c_prev;
    double da_f = df_t * f_t * (1.0 - f_t);
    dw_i = dw_i + da_i * seq[t];
    du_i = du_i + da_i * h_prev;
    db_i = db_i + da_i;
    dw_f = dw_f + da_f * seq[t];
    du_f = du_f + da_f * h_prev;
    db_f = db_f + da_f;
    dw_o = dw_o + da_o * seq[t];
    du_o = du_o + da_o * h_prev;
    db_o = db_o + da_o;
    dw_c = dw_c + da_g * seq[t];
    du_c = du_c + da_g * h_prev;
    db_c = db_c + da_g;
    dh_next = da_i * w.u_i + da_f * w.u_f + da_o * w.u_o + da_g * w.u_c;
    dc_next = dc * f_t;
    t = t - 1;
  }
  w.w_y = w.w_y - lr * dw_y;
  w.b_y = w.b_y - lr * db_y;
  w.w_i = w.w_i - lr * dw_i;
  w.u_i = w.u_i - lr * du_i;
  w.b_i = w.b_i - lr * db_i;
  w.w_f = w.w_f - lr * dw_f;
  w.u_f = w.u_f - lr * du_f;
  w.b_f = w.b_f - lr * db_f;
  w.w_o = w.w_o - lr * dw_o;
  w.u_o = w.u_o - lr * du_o;
  w.b_o = w.b_o - lr * db_o;
  w.w_c = w.w_c - lr * dw_c;
  w.u_c = w.u_c - lr * du_c;
  w.b_c = w.b_c - lr * db_c;
  return w;
}

Samples make_samples(List<double> data, int look_back) {
  List<List<double>> X = <List<double>>[];
  List<double> Y = <double>[];
  int i = 0;
  while (i + look_back < data.length) {
    dynamic seq = data.sublist(i, i + look_back);
    X = [...X, seq];
    Y = [...Y, data[i + look_back]];
    i = i + 1;
  }
  return Samples(x: X, y: Y);
}

LSTMWeights init_weights() {
  return LSTMWeights(w_i: 0.1, u_i: 0.2, b_i: 0.0, w_f: 0.1, u_f: 0.2, b_f: 0.0, w_o: 0.1, u_o: 0.2, b_o: 0.0, w_c: 0.1, u_c: 0.2, b_c: 0.0, w_y: 0.1, b_y: 0.0);
}

LSTMWeights train(List<double> data, int look_back, int epochs, double lr) {
  Samples samples = make_samples(data, look_back);
  LSTMWeights w = init_weights();
  int ep = 0;
  while (ep < epochs) {
    int j = 0;
    while (j < samples.x.length) {
    List<double> seq = samples.x[j];
    double target = samples.y[j];
    LSTMState state = forward(seq, w);
    w = backward(seq, target, w, state, lr);
    j = j + 1;
  }
    ep = ep + 1;
  }
  return w;
}

double predict(List<double> seq, LSTMWeights w) {
  LSTMState state = forward(seq, w);
  double h_last = state.h[state.h.length - 1];
  return w.w_y * h_last + w.b_y;
}

List<double> data = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
int look_back = 3;
int epochs = 200;
double lr = 0.1;
LSTMWeights w = train(data, look_back, epochs, lr);
List<double> test_seq = [0.6, 0.7, 0.8];
double pred = predict(test_seq, w);
void main() {
  print("Predicted value: " + (pred).toString());
}
