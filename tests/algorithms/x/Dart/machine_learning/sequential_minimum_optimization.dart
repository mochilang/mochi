// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double dot(List<double> a, List<double> b) {
  double sum = 0.0;
  int i = 0;
  while (i < a.length) {
    sum = sum + a[i] * b[i];
    i = i + 1;
  }
  return sum;
}

double maxf(double a, double b) {
  if (a > b) {
    return a;
  }
  return b;
}

double minf(double a, double b) {
  if (a < b) {
    return a;
  }
  return b;
}

double absf(double x) {
  if (x >= 0.0) {
    return x;
  }
  return 0.0 - x;
}

double predict_raw(List<List<double>> samples, List<double> labels, List<double> alphas, double b, List<double> x) {
  double res = 0.0;
  int i = 0;
  while (i < samples.length) {
    res = res + alphas[i] * labels[i] * dot(samples[i], x);
    i = i + 1;
  }
  return res + b;
}

List<List<double>> smo_train(List<List<double>> samples, List<double> labels, double c, double tol, int max_passes) {
  int m = samples.length;
  List<double> alphas = <double>[];
  int i = 0;
  while (i < m) {
    alphas = [...alphas, 0.0];
    i = i + 1;
  }
  double b = 0.0;
  int passes = 0;
  while (passes < max_passes) {
    int num_changed = 0;
    int i1 = 0;
    while (i1 < m) {
    double Ei = predict_raw(samples, labels, alphas, b, samples[i1]) - labels[i1];
    if (labels[i1] * Ei < 0.0 - tol && alphas[i1] < c || labels[i1] * Ei > tol && alphas[i1] > 0.0) {
    int i2 = (i1 + 1) % m;
    double Ej = predict_raw(samples, labels, alphas, b, samples[i2]) - labels[i2];
    double alpha1_old = alphas[i1];
    double alpha2_old = alphas[i2];
    double L = 0.0;
    double H = 0.0;
    if (labels[i1] != labels[i2]) {
    L = maxf(0.0, alpha2_old - alpha1_old);
    H = minf(c, c + alpha2_old - alpha1_old);
  } else {
    L = maxf(0.0, alpha2_old + alpha1_old - c);
    H = minf(c, alpha2_old + alpha1_old);
  };
    if (L == H) {
    i1 = i1 + 1;
    continue;
  };
    double eta = 2.0 * dot(samples[i1], samples[i2]) - dot(samples[i1], samples[i1]) - dot(samples[i2], samples[i2]);
    if (eta >= 0.0) {
    i1 = i1 + 1;
    continue;
  };
    while (alphas.length <= i2) { alphas.add(0); } alphas[i2] = alpha2_old - labels[i2] * (Ei - Ej) / eta;
    if (alphas[i2] > H) {
    while (alphas.length <= i2) { alphas.add(0); } alphas[i2] = H;
  };
    if (alphas[i2] < L) {
    while (alphas.length <= i2) { alphas.add(0); } alphas[i2] = L;
  };
    if (absf(alphas[i2] - alpha2_old) < 0.00001) {
    i1 = i1 + 1;
    continue;
  };
    while (alphas.length <= i1) { alphas.add(0); } alphas[i1] = alpha1_old + labels[i1] * labels[i2] * (alpha2_old - alphas[i2]);
    double b1 = b - Ei - labels[i1] * (alphas[i1] - alpha1_old) * dot(samples[i1], samples[i1]) - labels[i2] * (alphas[i2] - alpha2_old) * dot(samples[i1], samples[i2]);
    double b2 = b - Ej - labels[i1] * (alphas[i1] - alpha1_old) * dot(samples[i1], samples[i2]) - labels[i2] * (alphas[i2] - alpha2_old) * dot(samples[i2], samples[i2]);
    if (alphas[i1] > 0.0 && alphas[i1] < c) {
    b = b1;
  } else {
    if (alphas[i2] > 0.0 && alphas[i2] < c) {
    b = b2;
  } else {
    b = (b1 + b2) / 2.0;
  };
  };
    num_changed = num_changed + 1;
  }
    i1 = i1 + 1;
  }
    if (num_changed == 0) {
    passes = passes + 1;
  } else {
    passes = 0;
  }
  }
  return [alphas, [b]];
}

double predict(List<List<double>> samples, List<double> labels, List<List<double>> model, List<double> x) {
  List<double> alphas = model[0];
  double b = model[1][0];
  double val = predict_raw(samples, labels, alphas, b, x);
  if (val >= 0.0) {
    return 1.0;
  }
  return -1.0;
}

List<List<double>> samples = [[2.0, 2.0], [1.5, 1.5], [0.0, 0.0], [0.5, 0.0]];
List<double> labels = [1.0, 1.0, -1.0, -1.0];
List<List<double>> model = smo_train(samples, labels, 1.0, 0.001, 10);
void main() {
  print(predict(samples, labels, model, [1.5, 1.0]));
  print(predict(samples, labels, model, [0.2, 0.1]));
}
