// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double expApprox(double x) {
  double y = x;
  bool is_neg = false;
  if (x < 0.0) {
    is_neg = true;
    y = -x;
  }
  double term = 1.0;
  double sum = 1.0;
  int n = 1;
  while (n < 30) {
    term = term * y / (n as double);
    sum = sum + term;
    n = n + 1;
  }
  if (is_neg) {
    return 1.0 / sum;
  }
  return sum;
}

double sigmoid(double z) {
  return 1.0 / (1.0 + expApprox(-z));
}

double dot(List<double> a, List<double> b) {
  double s = 0.0;
  int i = 0;
  while (i < a.length) {
    s = s + a[i] * b[i];
    i = i + 1;
  }
  return s;
}

List<double> zeros(int n) {
  List<double> res = <double>[];
  int i = 0;
  while (i < n) {
    res = [...res, 0.0];
    i = i + 1;
  }
  return res;
}

List<double> logistic_reg(double alpha, List<List<double>> x, List<double> y, int iterations) {
  int m = x.length;
  int n = x[0].length;
  List<double> theta = zeros(n);
  int iter = 0;
  while (iter < iterations) {
    List<double> grad = zeros(n);
    int i = 0;
    while (i < m) {
    double z = dot(x[i], theta);
    double h = sigmoid(z);
    int k = 0;
    while (k < n) {
    while (grad.length <= k) { grad.add(0); } grad[k] = grad[k] + (h - y[i]) * x[i][k];
    k = k + 1;
  }
    i = i + 1;
  }
    int k2 = 0;
    while (k2 < n) {
    while (theta.length <= k2) { theta.add(0); } theta[k2] = theta[k2] - alpha * grad[k2] / (m as double);
    k2 = k2 + 1;
  }
    iter = iter + 1;
  }
  return theta;
}

List<List<double>> x = [[0.5, 1.5], [1.0, 1.0], [1.5, 0.5], [3.0, 3.5], [3.5, 3.0], [4.0, 4.0]];
List<double> y = [0.0, 0.0, 0.0, 1.0, 1.0, 1.0];
double alpha = 0.1;
int iterations = 1000;
List<double> theta = logistic_reg(alpha, x, y, iterations);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  for (int i = 0; i < theta.length; i++) {
    print(theta[i]);
  }
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
