// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Stump {
  int feature;
  double threshold;
  double left;
  double right;
  Stump({required this.feature, required this.threshold, required this.left, required this.right});
}

double exp_approx(double x) {
  double term = 1.0;
  double sum = 1.0;
  int i = 1;
  while (i < 10) {
    term = term * x / ((i).toDouble());
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

double signf(double x) {
  if (x >= 0.0) {
    return 1.0;
  }
  return -1.0;
}

List<double> gradient(List<double> target, List<double> preds) {
  int n = target.length;
  List<double> residuals = <double>[];
  int i = 0;
  while (i < n) {
    double t = target[i];
    double y = preds[i];
    double exp_val = exp_approx(t * y);
    double res = -t / (1.0 + exp_val);
    residuals = [...residuals, res];
    i = i + 1;
  }
  return residuals;
}

List<double> predict_raw(List<Stump> models, List<List<double>> features, double learning_rate) {
  int n = features.length;
  List<double> preds = <double>[];
  int i = 0;
  while (i < n) {
    preds = [...preds, 0.0];
    i = i + 1;
  }
  int m = 0;
  while (m < models.length) {
    Stump stump = models[m];
    i = 0;
    while (i < n) {
    double value = features[i][stump.feature];
    if (value <= stump.threshold) {
    while (preds.length <= i) { preds.add(0); } preds[i] = preds[i] + learning_rate * stump.left;
  } else {
    while (preds.length <= i) { preds.add(0); } preds[i] = preds[i] + learning_rate * stump.right;
  }
    i = i + 1;
  }
    m = m + 1;
  }
  return preds;
}

List<double> predict(List<Stump> models, List<List<double>> features, double learning_rate) {
  List<double> raw = predict_raw(models, features, learning_rate);
  List<double> result = <double>[];
  int i = 0;
  while (i < raw.length) {
    result = [...result, signf(raw[i])];
    i = i + 1;
  }
  return result;
}

Stump train_stump(List<List<double>> features, List<double> residuals) {
  int n_samples = features.length;
  int n_features = features[0].length;
  int best_feature = 0;
  double best_threshold = 0.0;
  double best_error = 1000000000.0;
  double best_left = 0.0;
  double best_right = 0.0;
  int j = 0;
  while (j < n_features) {
    int t_index = 0;
    while (t_index < n_samples) {
    double t = features[t_index][j];
    double sum_left = 0.0;
    int count_left = 0;
    double sum_right = 0.0;
    int count_right = 0;
    int i = 0;
    while (i < n_samples) {
    if (features[i][j] <= t) {
    sum_left = sum_left + residuals[i];
    count_left = count_left + 1;
  } else {
    sum_right = sum_right + residuals[i];
    count_right = count_right + 1;
  }
    i = i + 1;
  }
    double left_val = 0.0;
    if (count_left != 0) {
    left_val = sum_left / ((count_left).toDouble());
  }
    double right_val = 0.0;
    if (count_right != 0) {
    right_val = sum_right / ((count_right).toDouble());
  }
    double error = 0.0;
    i = 0;
    while (i < n_samples) {
    double pred = (features[i][j] <= t ? left_val : right_val);
    double diff = residuals[i] - pred;
    _error = _error + diff * diff;
    i = i + 1;
  }
    if (_error < best_error) {
    best_error = _error;
    best_feature = j;
    best_threshold = t;
    best_left = left_val;
    best_right = right_val;
  }
    t_index = t_index + 1;
  }
    j = j + 1;
  }
  return Stump(feature: best_feature, threshold: best_threshold, left: best_left, right: best_right);
}

List<Stump> fit(int n_estimators, double learning_rate, List<List<double>> features, List<double> target) {
  List<Stump> models = <Stump>[];
  int m = 0;
  while (m < n_estimators) {
    List<double> preds = predict_raw(models, features, learning_rate);
    List<double> grad = gradient(target, preds);
    List<double> residuals = <double>[];
    int i = 0;
    while (i < grad.length) {
    residuals = List<double>.from([...residuals, -grad[i]]);
    i = i + 1;
  }
    Stump stump = train_stump(features, residuals);
    models = [...models, stump];
    m = m + 1;
  }
  return models;
}

double accuracy(List<double> preds, List<double> target) {
  int n = target.length;
  int correct = 0;
  int i = 0;
  while (i < n) {
    if (preds[i] == target[i]) {
    correct = correct + 1;
  }
    i = i + 1;
  }
  return ((correct).toDouble()) / ((n).toDouble());
}

List<List<double>> features = [[1.0], [2.0], [3.0], [4.0]];
List<double> target = [-1.0, -1.0, 1.0, 1.0];
List<Stump> models = fit(5, 0.5, features, target);
List<double> predictions = predict(models, features, 0.5);
double acc = accuracy(predictions, target);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print("Accuracy: " + _str(acc));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
