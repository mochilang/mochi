// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Dataset {
  List<List<double>> data;
  List<double> target;
  Dataset({required this.data, required this.target});
}

class Tree {
  double threshold;
  double left_value;
  double right_value;
  Tree({required this.threshold, required this.left_value, required this.right_value});
}

Dataset data_handling(Dataset dataset) {
  return dataset;
}

List<double> xgboost(List<List<double>> features, List<double> target, List<List<double>> test_features) {
  double learning_rate = 0.5;
  int n_estimators = 3;
  List<Tree> trees = <Tree>[];
  List<double> predictions = <double>[];
  int i = 0;
  while (i < target.length) {
    predictions = [...predictions, 0.0];
    i = i + 1;
  }
  int est = 0;
  while (est < n_estimators) {
    List<double> residuals = <double>[];
    int j = 0;
    while (j < target.length) {
    residuals = [...residuals, target[j] - predictions[j]];
    j = j + 1;
  }
    double sum_feat = 0.0;
    j = 0;
    while (j < features.length) {
    sum_feat = sum_feat + features[j][0];
    j = j + 1;
  }
    double threshold = sum_feat / ((features.length).toDouble());
    double left_sum = 0.0;
    int left_count = 0;
    double right_sum = 0.0;
    int right_count = 0;
    j = 0;
    while (j < features.length) {
    if (features[j][0] <= threshold) {
    left_sum = left_sum + residuals[j];
    left_count = left_count + 1;
  } else {
    right_sum = right_sum + residuals[j];
    right_count = right_count + 1;
  }
    j = j + 1;
  }
    double left_value = 0.0;
    if (left_count > 0) {
    left_value = left_sum / ((left_count).toDouble());
  }
    double right_value = 0.0;
    if (right_count > 0) {
    right_value = right_sum / ((right_count).toDouble());
  }
    j = 0;
    while (j < features.length) {
    if (features[j][0] <= threshold) {
    while (predictions.length <= j) { predictions.add(0); } predictions[j] = predictions[j] + learning_rate * left_value;
  } else {
    while (predictions.length <= j) { predictions.add(0); } predictions[j] = predictions[j] + learning_rate * right_value;
  }
    j = j + 1;
  }
    trees = [...trees, Tree(threshold: threshold, left_value: left_value, right_value: right_value)];
    est = est + 1;
  }
  List<double> preds = <double>[];
  int t = 0;
  while (t < test_features.length) {
    double pred = 0.0;
    int k = 0;
    while (k < trees.length) {
    if (test_features[t][0] <= trees[k].threshold) {
    pred = pred + learning_rate * trees[k].left_value;
  } else {
    pred = pred + learning_rate * trees[k].right_value;
  }
    k = k + 1;
  }
    preds = [...preds, pred];
    t = t + 1;
  }
  return preds;
}

double mean_absolute_error(List<double> y_true, List<double> y_pred) {
  double sum = 0.0;
  int i = 0;
  while (i < y_true.length) {
    double diff = y_true[i] - y_pred[i];
    if (diff < 0.0) {
    diff = -diff;
  }
    sum = sum + diff;
    i = i + 1;
  }
  return sum / ((y_true.length).toDouble());
}

double mean_squared_error(List<double> y_true, List<double> y_pred) {
  double sum = 0.0;
  int i = 0;
  while (i < y_true.length) {
    double diff = y_true[i] - y_pred[i];
    sum = sum + diff * diff;
    i = i + 1;
  }
  return sum / ((y_true.length).toDouble());
}

dynamic _main() {
  Dataset california = Dataset(data: [[1.0], [2.0], [3.0], [4.0]], target: [2.0, 3.0, 4.0, 5.0]);
  Dataset ds = data_handling(california);
  List<List<double>> x_train = ds.data;
  List<double> y_train = ds.target;
  List<List<double>> x_test = [[1.5], [3.5]];
  List<double> y_test = [2.5, 4.5];
  List<double> predictions = xgboost(x_train, y_train, x_test);
  print("Predictions:");
  print(predictions);
  print("Mean Absolute Error:");
  print(mean_absolute_error(y_test, predictions));
  print("Mean Square Error:");
  print(mean_squared_error(y_test, predictions));
}

void _start() {
  _main();
}

void main() => _start();
