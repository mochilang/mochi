// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class PCAResult {
  List<List<double>> transformed;
  List<double> variance_ratio;
  PCAResult({required this.transformed, required this.variance_ratio});
}

class Eigen {
  List<double> values;
  List<List<double>> vectors;
  Eigen({required this.values, required this.vectors});
}

double sqrt(double x) {
  double guess = (x > 1.0 ? x / 2.0 : 1.0);
  int i = 0;
  while (i < 20) {
    guess = 0.5 * (guess + x / guess);
    i = i + 1;
  }
  return guess;
}

double mean(List<double> xs) {
  double sum = 0.0;
  int i = 0;
  while (i < xs.length) {
    sum = sum + xs[i];
    i = i + 1;
  }
  return sum / xs.length;
}

List<List<double>> standardize(List<List<double>> data) {
  int n_samples = data.length;
  int n_features = data[0].length;
  List<double> means = <double>[];
  List<double> stds = <double>[];
  int j = 0;
  while (j < n_features) {
    List<double> column = <double>[];
    int i = 0;
    while (i < n_samples) {
    column = [...column, data[i][j]];
    i = i + 1;
  }
    double m = mean(column);
    means = [...means, m];
    double variance = 0.0;
    int k = 0;
    while (k < n_samples) {
    double diff = column[k] - m;
    variance = variance + diff * diff;
    k = k + 1;
  }
    stds = [...stds, sqrt(variance / (n_samples - 1))];
    j = j + 1;
  }
  List<List<double>> standardized = <List<double>>[];
  int r = 0;
  while (r < n_samples) {
    List<double> row = <double>[];
    int c = 0;
    while (c < n_features) {
    row = [...row, (data[r][c] - means[c]) / stds[c]];
    c = c + 1;
  }
    standardized = ([...standardized, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    r = r + 1;
  }
  return standardized;
}

List<List<double>> covariance_matrix(List<List<double>> data) {
  int n_samples = data.length;
  int n_features = data[0].length;
  List<List<double>> cov = <List<double>>[];
  int i = 0;
  while (i < n_features) {
    List<double> row = <double>[];
    int j = 0;
    while (j < n_features) {
    double sum = 0.0;
    int k = 0;
    while (k < n_samples) {
    sum = sum + data[k][i] * data[k][j];
    k = k + 1;
  }
    row = [...row, sum / (n_samples - 1)];
    j = j + 1;
  }
    cov = ([...cov, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return cov;
}

List<double> normalize(List<double> vec) {
  double sum = 0.0;
  int i = 0;
  while (i < vec.length) {
    sum = sum + vec[i] * vec[i];
    i = i + 1;
  }
  double n = sqrt(sum);
  List<double> res = <double>[];
  int j = 0;
  while (j < vec.length) {
    res = [...res, vec[j] / n];
    j = j + 1;
  }
  return res;
}

Eigen eigen_decomposition_2x2(List<List<double>> matrix) {
  double a = matrix[0][0];
  double b = matrix[0][1];
  double c = matrix[1][1];
  double diff = a - c;
  double discriminant = sqrt(diff * diff + 4.0 * b * b);
  double lambda1 = (a + c + discriminant) / 2.0;
  double lambda2 = (a + c - discriminant) / 2.0;
  List<double> v1 = <double>[];
  List<double> v2 = <double>[];
  if (b != 0.0) {
    v1 = normalize([lambda1 - c, b]);
    v2 = normalize([lambda2 - c, b]);
  } else {
    v1 = [1.0, 0.0];
    v2 = [0.0, 1.0];
  }
  List<double> eigenvalues = [lambda1, lambda2];
  List<List<double>> eigenvectors = [v1, v2];
  if (eigenvalues[0] < eigenvalues[1]) {
    double tmp_val = eigenvalues[0];
    while (eigenvalues.length <= 0) { eigenvalues.add(0); } eigenvalues[0] = eigenvalues[1];
    while (eigenvalues.length <= 1) { eigenvalues.add(0); } eigenvalues[1] = tmp_val;
    List<double> tmp_vec = eigenvectors[0];
    while (eigenvectors.length <= 0) { eigenvectors.add(<double>[]); } eigenvectors[0] = eigenvectors[1];
    while (eigenvectors.length <= 1) { eigenvectors.add(<double>[]); } eigenvectors[1] = tmp_vec;
  }
  return Eigen(values: eigenvalues, vectors: eigenvectors);
}

List<List<double>> transpose(List<List<double>> matrix) {
  int rows = matrix.length;
  int cols = matrix[0].length;
  List<List<double>> trans = <List<double>>[];
  int i = 0;
  while (i < cols) {
    List<double> row = <double>[];
    int j = 0;
    while (j < rows) {
    row = [...row, matrix[j][i]];
    j = j + 1;
  }
    trans = ([...trans, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return trans;
}

List<List<double>> matrix_multiply(List<List<double>> a, List<List<double>> b) {
  int rows_a = a.length;
  int cols_a = a[0].length;
  int rows_b = b.length;
  int cols_b = b[0].length;
  if (cols_a != rows_b) {
    throw Exception("Incompatible matrices");
  }
  List<List<double>> result = <List<double>>[];
  int i = 0;
  while (i < rows_a) {
    List<double> row = <double>[];
    int j = 0;
    while (j < cols_b) {
    double sum = 0.0;
    int k = 0;
    while (k < cols_a) {
    sum = sum + a[i][k] * b[k][j];
    k = k + 1;
  }
    row = [...row, sum];
    j = j + 1;
  }
    result = ([...result, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return result;
}

PCAResult apply_pca(List<List<double>> data, int n_components) {
  List<List<double>> standardized = standardize(data);
  List<List<double>> cov = covariance_matrix(standardized);
  Eigen eig = eigen_decomposition_2x2(cov);
  List<double> eigenvalues = eig.values;
  List<List<double>> eigenvectors = eig.vectors;
  List<List<double>> components = transpose(eigenvectors);
  List<List<double>> transformed = matrix_multiply(standardized, components);
  double total = eigenvalues[0] + eigenvalues[1];
  List<double> ratios = <double>[];
  int i = 0;
  while (i < n_components) {
    ratios = [...ratios, eigenvalues[i] / total];
    i = i + 1;
  }
  return PCAResult(transformed: transformed, variance_ratio: ratios);
}

List<List<double>> data = [[2.5, 2.4], [0.5, 0.7], [2.2, 2.9], [1.9, 2.2], [3.1, 3.0], [2.3, 2.7], [2.0, 1.6], [1.0, 1.1], [1.5, 1.6], [1.1, 0.9]];
PCAResult result = apply_pca(data, 2);
int idx = 0;
void main() {
  print("Transformed Data (first 5 rows):");
  while (idx < 5) {
    print("[" + result.transformed[idx].join(', ') + "]");
    idx = idx + 1;
  }
  print("Explained Variance Ratio:");
  print("[" + result.variance_ratio.join(', ') + "]");
}
