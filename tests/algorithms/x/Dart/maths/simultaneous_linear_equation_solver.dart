// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _str(dynamic v) => v.toString();


Never _error(dynamic msg) {
  throw Exception(msg.toString());
}

double floor(double x) {
  int i = x.toInt();
  if (i.toDouble() > x) {
    i = i - 1;
  }
  return i.toDouble();
}

double pow10(int n) {
  double p = 1.0;
  int i = 0;
  while (i < n) {
    p = p * 10.0;
    i = i + 1;
  }
  return p;
}

double round(double x, int n) {
  double m = pow10(n);
  return floor(x * m + 0.5) / m;
}

List<List<double>> clone_matrix(List<List<double>> mat) {
  List<List<double>> new_mat = <List<double>>[];
  int i = 0;
  while (i < mat.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < mat[i].length) {
    row = [...row, mat[i][j]];
    j = j + 1;
  }
    new_mat = ([...new_mat, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return new_mat;
}

List<double> solve_simultaneous(List<List<double>> equations) {
  int n = equations.length;
  if (n == 0) {
    _error("solve_simultaneous() requires n lists of length n+1");
  }
  int m = n + 1;
  int i = 0;
  while (i < n) {
    if (equations[i].length != m) {
    _error("solve_simultaneous() requires n lists of length n+1");
  }
    i = i + 1;
  }
  List<List<double>> a = clone_matrix(equations);
  int row = 0;
  while (row < n) {
    int pivot = row;
    while (pivot < n && a[pivot][row] == 0.0) {
    pivot = pivot + 1;
  }
    if (pivot == n) {
    _error("solve_simultaneous() requires at least 1 full equation");
  }
    if (pivot != row) {
    List<double> temp = a[row];
    while (a.length <= row) { a.add(<double>[]); } a[row] = a[pivot];
    while (a.length <= pivot) { a.add(<double>[]); } a[pivot] = temp;
  }
    double pivot_val = a[row][row];
    int col = 0;
    while (col < m) {
    while (a[row]!.length <= col) { a[row]!.add(0); } a[row]![col] = a[row][col] / pivot_val;
    col = col + 1;
  }
    int r = 0;
    while (r < n) {
    if (r != row) {
    double factor = a[r][row];
    int c = 0;
    while (c < m) {
    while (a[r]!.length <= c) { a[r]!.add(0); } a[r]![c] = a[r][c] - factor * a[row][c];
    c = c + 1;
  };
  }
    r = r + 1;
  }
    row = row + 1;
  }
  List<double> res = <double>[];
  int k = 0;
  while (k < n) {
    res = [...res, round(a[k][m - 1], 5)];
    k = k + 1;
  }
  return res;
}

void test_solver() {
  List<List<double>> a = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];
  List<double> r1 = solve_simultaneous(a);
  if (!(r1.length == 2 && r1[0] == 0.0 - 1.0 && r1[1] == 2.0)) {
    _error("test1 failed");
  }
  List<List<double>> b = [[0.0, 0.0 - 3.0, 1.0, 7.0], [3.0, 2.0, 0.0 - 1.0, 11.0], [5.0, 1.0, 0.0 - 2.0, 12.0]];
  List<double> r2 = solve_simultaneous(b);
  if (!(r2.length == 3 && r2[0] == 6.4 && r2[1] == 1.2 && r2[2] == 10.6)) {
    _error("test2 failed");
  }
}

void _main() {
  test_solver();
  List<List<double>> eq = [[2.0, 1.0, 1.0, 1.0, 1.0, 4.0], [1.0, 2.0, 1.0, 1.0, 1.0, 5.0], [1.0, 1.0, 2.0, 1.0, 1.0, 6.0], [1.0, 1.0, 1.0, 2.0, 1.0, 7.0], [1.0, 1.0, 1.0, 1.0, 2.0, 8.0]];
  print(_str(solve_simultaneous(eq)));
  print(_str(solve_simultaneous([[4.0, 2.0]])));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
