// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double floor(double x) {
  int i = x as int;
  if ((i as double) > x) {
    i = i - 1;
  }
  return i as double;
}

double pow10(int n) {
  double p = 1.0;
  int i = 0;
  while (i < n) {
    p = p * 10.0;
    i = i + 1;
  }
  return p;
}

double round(double x, int n) {
  double m = pow10(n);
  return floor(x * m + 0.5) / m;
}

List<List<double>> clone_matrix(List<List<double>> mat) {
  List<List<double>> new_mat = <List<double>>[];
  int i = 0;
  while (i < mat.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < mat[i].length) {
    row = [...row, mat[i][j]];
    j = j + 1;
  }
    new_mat = ([...new_mat, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return new_mat;
}

List<double> solve_simultaneous(List<List<double>> equations) {
  int n = equations.length;
  if (n == 0) {
    throw Exception("solve_simultaneous() requires n lists of length n+1");
  }
  int m = n + 1;
  int i = 0;
  while (i < n) {
    if (equations[i].length != m) {
    throw Exception("solve_simultaneous() requires n lists of length n+1");
  }
    i = i + 1;
  }
  List<List<double>> a = clone_matrix(equations);
  int row = 0;
  while (row < n) {
    int pivot = row;
    while (pivot < n && a[pivot][row] == 0.0) {
    pivot = pivot + 1;
  }
    if (pivot == n) {
    throw Exception("solve_simultaneous() requires at least 1 full equation");
  }
    if (pivot != row) {
    List<double> temp = a[row];
    while (a.length <= row) { a.add(<double>[]); } a[row] = a[pivot];
    while (a.length <= pivot) { a.add(<double>[]); } a[pivot] = temp;
  }
    double pivot_val = a[row][row];
    int col = 0;
    while (col < m) {
    while (a[row]!.length <= col) { a[row]!.add(0); } a[row]![col] = a[row][col] / pivot_val;
    col = col + 1;
  }
    int r = 0;
    while (r < n) {
    if (r != row) {
    double factor = a[r][row];
    int c = 0;
    while (c < m) {
    while (a[r]!.length <= c) { a[r]!.add(0); } a[r]![c] = a[r][c] - factor * a[row][c];
    c = c + 1;
  };
  }
    r = r + 1;
  }
    row = row + 1;
  }
  List<double> res = <double>[];
  int k = 0;
  while (k < n) {
    res = [...res, round(a[k][m - 1], 5)];
    k = k + 1;
  }
  return res;
}

void test_solver() {
  List<List<double>> a = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];
  List<double> r1 = solve_simultaneous(a);
  if (!(r1.length == 2 && r1[0] == 0.0 - 1.0 && r1[1] == 2.0)) {
    throw Exception("test1 failed");
  }
  List<List<double>> b = [[0.0, 0.0 - 3.0, 1.0, 7.0], [3.0, 2.0, 0.0 - 1.0, 11.0], [5.0, 1.0, 0.0 - 2.0, 12.0]];
  List<double> r2 = solve_simultaneous(b);
  if (!(r2.length == 3 && r2[0] == 6.4 && r2[1] == 1.2 && r2[2] == 10.6)) {
    throw Exception("test2 failed");
  }
}

void _main() {
  test_solver();
  List<List<double>> eq = [[2.0, 1.0, 1.0, 1.0, 1.0, 4.0], [1.0, 2.0, 1.0, 1.0, 1.0, 5.0], [1.0, 1.0, 2.0, 1.0, 1.0, 6.0], [1.0, 1.0, 1.0, 2.0, 1.0, 7.0], [1.0, 1.0, 1.0, 1.0, 2.0, 8.0]];
  print((solve_simultaneous(eq)).toString());
  print((solve_simultaneous([[4.0, 2.0]])).toString());
}

void _start() {
  _main();
}

void main() => _start();
