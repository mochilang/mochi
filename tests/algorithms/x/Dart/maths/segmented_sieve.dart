// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();


Never _error(dynamic msg) {
  throw Exception(msg.toString());
}

int min_int(int a, int b) {
  if (a < b) {
    return a;
  }
  return b;
}

int int_sqrt(int n) {
  int r = 0;
  while ((r + 1) * (r + 1) <= n) {
    r = r + 1;
  }
  return r;
}

List<int> sieve(int n) {
  if (n <= 0) {
    _error("Number must instead be a positive integer");
  }
  List<int> in_prime = <int>[];
  int start = 2;
  int end = int_sqrt(n);
  List<int> temp = <int>[];
  int i = 0;
  while (i < end + 1) {
    temp = [...temp, 1];
    i = i + 1;
  }
  List<int> prime = <int>[];
  while (start <= end) {
    if (temp[start] == 1) {
    in_prime = [...in_prime, start];
    int j = start * start;
    while (j <= end) {
    while (temp.length <= j) { temp.add(0); } temp[j] = 0;
    j = j + start;
  };
  }
    start = start + 1;
  }
  i = 0;
  while (i < in_prime.length) {
    prime = [...prime, in_prime[i]];
    i = i + 1;
  }
  int low = end + 1;
  int high = min_int(2 * end, n);
  while (low <= n) {
    List<int> tempSeg = <int>[];
    int size = high - low + 1;
    int k = 0;
    while (k < size) {
    tempSeg = [...tempSeg, 1];
    k = k + 1;
  }
    int idx = 0;
    while (idx < in_prime.length) {
    int each = in_prime[idx];
    int t = low ~/ each * each;
    if (t < low) {
    t = t + each;
  }
    int j2 = t;
    while (j2 <= high) {
    while (tempSeg.length <= j2 - low) { tempSeg.add(0); } tempSeg[j2 - low] = 0;
    j2 = j2 + each;
  }
    idx = idx + 1;
  }
    int j3 = 0;
    while (j3 < tempSeg.length) {
    if (tempSeg[j3] == 1) {
    prime = [...prime, j3 + low];
  }
    j3 = j3 + 1;
  }
    low = high + 1;
    high = min_int(high + end, n);
  }
  return prime;
}

bool lists_equal(List<int> a, List<int> b) {
  if (a.length != b.length) {
    return false;
  }
  int m = 0;
  while (m < a.length) {
    if (a[m] != b[m]) {
    return false;
  }
    m = m + 1;
  }
  return true;
}

void test_sieve() {
  List<int> e1 = sieve(8);
  if (!lists_equal(e1, [2, 3, 5, 7])) {
    _error("sieve(8) failed");
  }
  List<int> e2 = sieve(27);
  if (!lists_equal(e2, [2, 3, 5, 7, 11, 13, 17, 19, 23])) {
    _error("sieve(27) failed");
  }
}

void _main() {
  test_sieve();
  print(_str(sieve(30)));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
