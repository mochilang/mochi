// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double ucal(double u, int p) {
  double temp = u;
  int i = 1;
  while (i < p) {
    temp = temp * (u - (i as double));
    i = i + 1;
  }
  return temp;
}

double factorial(int n) {
  double result = 1.0;
  int i = 2;
  while (i <= n) {
    result = result * (i as double);
    i = i + 1;
  }
  return result;
}

double newton_forward_interpolation(List<double> x, List<double> y0, double value) {
  int n = x.length;
  List<List<double>> y = <List<double>>[];
  int i = 0;
  while (i < n) {
    List<double> row = <double>[];
    int j = 0;
    while (j < n) {
    row = [...row, 0.0];
    j = j + 1;
  }
    y = ([...y, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  i = 0;
  while (i < n) {
    while (y[i]!.length <= 0) { y[i]!.add(0); } y[i]![0] = y0[i];
    i = i + 1;
  }
  int i1 = 1;
  while (i1 < n) {
    int j1 = 0;
    while (j1 < n - i1) {
    while (y[j1]!.length <= i1) { y[j1]!.add(0); } y[j1]![i1] = y[j1 + 1][i1 - 1] - y[j1][i1 - 1];
    j1 = j1 + 1;
  }
    i1 = i1 + 1;
  }
  double u = (value - x[0]) / (x[1] - x[0]);
  double sum = y[0][0];
  int k = 1;
  while (k < n) {
    sum = sum + ucal(u, k) * y[0][k] / factorial(k);
    k = k + 1;
  }
  return sum;
}

List<double> x_points = [0.0, 1.0, 2.0, 3.0];
List<double> y_points = [0.0, 1.0, 8.0, 27.0];
void main() {
  print((newton_forward_interpolation(x_points, y_points, 1.5)).toString());
}
