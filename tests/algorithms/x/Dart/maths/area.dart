// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double PI = 3.141592653589793;
double TWO_PI = 6.283185307179586;
double _mod(double x, double m) {
  return x - (x / m as int as double) * m;
}

double sin_approx(double x) {
  double y = _mod(x + PI, TWO_PI) - PI;
  double y2 = y * y;
  double y3 = y2 * y;
  double y5 = y3 * y2;
  double y7 = y5 * y2;
  return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0;
}

double cos_approx(double x) {
  double y = _mod(x + PI, TWO_PI) - PI;
  double y2 = y * y;
  double y4 = y2 * y2;
  double y6 = y4 * y2;
  return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0;
}

double tan_approx(double x) {
  return sin_approx(x) / cos_approx(x);
}

double sqrt_approx(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x / 2.0;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double surface_area_cube(double side_length) {
  if (side_length < 0.0) {
    print("ValueError: surface_area_cube() only accepts non-negative values");
    return 0.0;
  }
  return 6.0 * side_length * side_length;
}

double surface_area_cuboid(double length, double breadth, double height) {
  if (length < 0.0 || breadth < 0.0 || height < 0.0) {
    print("ValueError: surface_area_cuboid() only accepts non-negative values");
    return 0.0;
  }
  return 2.0 * (length * breadth + breadth * height + length * height);
}

double surface_area_sphere(double radius) {
  if (radius < 0.0) {
    print("ValueError: surface_area_sphere() only accepts non-negative values");
    return 0.0;
  }
  return 4.0 * PI * radius * radius;
}

double surface_area_hemisphere(double radius) {
  if (radius < 0.0) {
    print("ValueError: surface_area_hemisphere() only accepts non-negative values");
    return 0.0;
  }
  return 3.0 * PI * radius * radius;
}

double surface_area_cone(double radius, double height) {
  if (radius < 0.0 || height < 0.0) {
    print("ValueError: surface_area_cone() only accepts non-negative values");
    return 0.0;
  }
  double slant = sqrt_approx(height * height + radius * radius);
  return PI * radius * (radius + slant);
}

double surface_area_conical_frustum(double radius1, double radius2, double height) {
  if (radius1 < 0.0 || radius2 < 0.0 || height < 0.0) {
    print("ValueError: surface_area_conical_frustum() only accepts non-negative values");
    return 0.0;
  }
  double slant = sqrt_approx(height * height + (radius1 - radius2) * (radius1 - radius2));
  return PI * (slant * (radius1 + radius2) + radius1 * radius1 + radius2 * radius2);
}

double surface_area_cylinder(double radius, double height) {
  if (radius < 0.0 || height < 0.0) {
    print("ValueError: surface_area_cylinder() only accepts non-negative values");
    return 0.0;
  }
  return 2.0 * PI * radius * (height + radius);
}

double surface_area_torus(double torus_radius, double tube_radius) {
  if (torus_radius < 0.0 || tube_radius < 0.0) {
    print("ValueError: surface_area_torus() only accepts non-negative values");
    return 0.0;
  }
  if (torus_radius < tube_radius) {
    print("ValueError: surface_area_torus() does not support spindle or self intersecting tori");
    return 0.0;
  }
  return 4.0 * PI * PI * torus_radius * tube_radius;
}

double area_rectangle(double length, double width) {
  if (length < 0.0 || width < 0.0) {
    print("ValueError: area_rectangle() only accepts non-negative values");
    return 0.0;
  }
  return length * width;
}

double area_square(double side_length) {
  if (side_length < 0.0) {
    print("ValueError: area_square() only accepts non-negative values");
    return 0.0;
  }
  return side_length * side_length;
}

double area_triangle(double base, double height) {
  if (base < 0.0 || height < 0.0) {
    print("ValueError: area_triangle() only accepts non-negative values");
    return 0.0;
  }
  return base * height / 2.0;
}

double area_triangle_three_sides(double side1, double side2, double side3) {
  if (side1 < 0.0 || side2 < 0.0 || side3 < 0.0) {
    print("ValueError: area_triangle_three_sides() only accepts non-negative values");
    return 0.0;
  }
  if (side1 + side2 < side3 || side1 + side3 < side2 || side2 + side3 < side1) {
    print("ValueError: Given three sides do not form a triangle");
    return 0.0;
  }
  double s = (side1 + side2 + side3) / 2.0;
  double prod = s * (s - side1) * (s - side2) * (s - side3);
  double res = sqrt_approx(prod);
  return res;
}

double area_parallelogram(double base, double height) {
  if (base < 0.0 || height < 0.0) {
    print("ValueError: area_parallelogram() only accepts non-negative values");
    return 0.0;
  }
  return base * height;
}

double area_trapezium(double base1, double base2, double height) {
  if (base1 < 0.0 || base2 < 0.0 || height < 0.0) {
    print("ValueError: area_trapezium() only accepts non-negative values");
    return 0.0;
  }
  return 0.5 * (base1 + base2) * height;
}

double area_circle(double radius) {
  if (radius < 0.0) {
    print("ValueError: area_circle() only accepts non-negative values");
    return 0.0;
  }
  return PI * radius * radius;
}

double area_ellipse(double radius_x, double radius_y) {
  if (radius_x < 0.0 || radius_y < 0.0) {
    print("ValueError: area_ellipse() only accepts non-negative values");
    return 0.0;
  }
  return PI * radius_x * radius_y;
}

double area_rhombus(double diagonal1, double diagonal2) {
  if (diagonal1 < 0.0 || diagonal2 < 0.0) {
    print("ValueError: area_rhombus() only accepts non-negative values");
    return 0.0;
  }
  return 0.5 * diagonal1 * diagonal2;
}

double area_reg_polygon(int sides, double length) {
  if (sides < 3) {
    print("ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides");
    return 0.0;
  }
  if (length < 0.0) {
    print("ValueError: area_reg_polygon() only accepts non-negative values as length of a side");
    return 0.0;
  }
  double n = sides as double;
  return n * length * length / (4.0 * tan_approx(PI / n));
}

double TRI_THREE_SIDES = area_triangle_three_sides(5.0, 12.0, 13.0);
void main() {
  print("[DEMO] Areas of various geometric shapes:");
  print("Rectangle: " + (area_rectangle(10.0, 20.0)).toString());
  print("Square: " + (area_square(10.0)).toString());
  print("Triangle: " + (area_triangle(10.0, 10.0)).toString());
  print("Triangle Three Sides: " + (TRI_THREE_SIDES).toString());
  print("Parallelogram: " + (area_parallelogram(10.0, 20.0)).toString());
  print("Rhombus: " + (area_rhombus(10.0, 20.0)).toString());
  print("Trapezium: " + (area_trapezium(10.0, 20.0, 30.0)).toString());
  print("Circle: " + (area_circle(20.0)).toString());
  print("Ellipse: " + (area_ellipse(10.0, 20.0)).toString());
  print("");
  print("Surface Areas of various geometric shapes:");
  print("Cube: " + (surface_area_cube(20.0)).toString());
  print("Cuboid: " + (surface_area_cuboid(10.0, 20.0, 30.0)).toString());
  print("Sphere: " + (surface_area_sphere(20.0)).toString());
  print("Hemisphere: " + (surface_area_hemisphere(20.0)).toString());
  print("Cone: " + (surface_area_cone(10.0, 20.0)).toString());
  print("Conical Frustum: " + (surface_area_conical_frustum(10.0, 20.0, 30.0)).toString());
  print("Cylinder: " + (surface_area_cylinder(10.0, 20.0)).toString());
  print("Torus: " + (surface_area_torus(20.0, 10.0)).toString());
  print("Equilateral Triangle: " + (area_reg_polygon(3, 10.0)).toString());
  print("Square: " + (area_reg_polygon(4, 10.0)).toString());
  print("Regular Pentagon: " + (area_reg_polygon(5, 10.0)).toString());
}
