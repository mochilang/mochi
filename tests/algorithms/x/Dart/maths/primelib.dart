// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

int abs_int(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

int gcd_iter(int a, int b) {
  int x = abs_int(a);
  int y = abs_int(b);
  while (y != 0) {
    int t = y;
    y = x % y;
    x = t;
  }
  return x;
}

bool is_prime(int n) {
  if (n <= 1) {
    return false;
  }
  int d = 2;
  while (d * d <= n) {
    if (n % d == 0) {
    return false;
  }
    d = d + 1;
  }
  return true;
}

List<int> sieve_er(int n) {
  List<int> nums = <int>[];
  int i = 2;
  while (i <= n) {
    nums = [...nums, i];
    i = i + 1;
  }
  int idx = 0;
  while (idx < nums.length) {
    int j = idx + 1;
    while (j < nums.length) {
    if (nums[idx] != 0) {
    if (nums[j] % nums[idx] == 0) {
    while (nums.length <= j) { nums.add(0); } nums[j] = 0;
  };
  }
    j = j + 1;
  }
    idx = idx + 1;
  }
  List<int> res = <int>[];
  int k = 0;
  while (k < nums.length) {
    int v = nums[k];
    if (v != 0) {
    res = [...res, v];
  }
    k = k + 1;
  }
  return res;
}

List<int> get_prime_numbers(int n) {
  List<int> ans = <int>[];
  int _num = 2;
  while (_num <= n) {
    if (is_prime(_num)) {
    ans = [...ans, _num];
  }
    _num = _num + 1;
  }
  return ans;
}

List<int> prime_factorization(int number) {
  if (number == 0) {
    return [0];
  }
  if (number == 1) {
    return [1];
  }
  List<int> ans = <int>[];
  if (is_prime(number)) {
    ans = [...ans, number];
    return ans;
  }
  int quotient = number;
  int factor = 2;
  while (quotient != 1) {
    if (is_prime(factor) && quotient % factor == 0) {
    ans = [...ans, factor];
    quotient = quotient ~/ factor;
  } else {
    factor = factor + 1;
  }
  }
  return ans;
}

int greatest_prime_factor(int number) {
  List<int> factors = prime_factorization(number);
  int m = factors[0];
  int i = 1;
  while (i < factors.length) {
    if (factors[i] > m) {
    m = factors[i];
  }
    i = i + 1;
  }
  return m;
}

int smallest_prime_factor(int number) {
  List<int> factors = prime_factorization(number);
  int m = factors[0];
  int i = 1;
  while (i < factors.length) {
    if (factors[i] < m) {
    m = factors[i];
  }
    i = i + 1;
  }
  return m;
}

int kg_v(int number1, int number2) {
  if (number1 < 1 || number2 < 1) {
    throw Exception("numbers must be positive");
  }
  int g = gcd_iter(number1, number2);
  return number1 ~/ g * number2;
}

bool is_even(int number) {
  return number % 2 == 0;
}

bool is_odd(int number) {
  return number % 2 != 0;
}

List<int> goldbach(int number) {
  if (!is_even(number) || number <= 2) {
    throw Exception("number must be even and > 2");
  }
  List<int> primes = get_prime_numbers(number);
  int i = 0;
  while (i < primes.length) {
    int j = i + 1;
    while (j < primes.length) {
    if (primes[i] + primes[j] == number) {
    return [primes[i], primes[j]];
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return ([] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
}

int get_prime(int n) {
  if (n < 0) {
    throw Exception("n must be non-negative");
  }
  int index = 0;
  int ans = 2;
  while (index < n) {
    index = index + 1;
    ans = ans + 1;
    while (!is_prime(ans)) {
    ans = ans + 1;
  }
  }
  return ans;
}

List<int> get_primes_between(int p1, int p2) {
  bool bad1 = !is_prime(p1);
  bool bad2 = !is_prime(p2);
  if (bad1 || bad2 || p1 >= p2) {
    throw Exception("arguments must be prime and p1 < p2");
  }
  int _num = p1 + 1;
  while (_num < p2) {
    if (is_prime(_num)) {
    break;
  }
    _num = _num + 1;
  }
  List<int> ans = <int>[];
  while (_num < p2) {
    ans = [...ans, _num];
    _num = _num + 1;
    while (_num < p2) {
    if (is_prime(_num)) {
    break;
  }
    _num = _num + 1;
  }
  }
  return ans;
}

List<int> get_divisors(int n) {
  if (n < 1) {
    throw Exception("n must be >= 1");
  }
  List<int> ans = <int>[];
  int d = 1;
  while (d <= n) {
    if (n % d == 0) {
    ans = [...ans, d];
  }
    d = d + 1;
  }
  return ans;
}

bool is_perfect_number(int number) {
  if (number <= 1) {
    throw Exception("number must be > 1");
  }
  List<int> divisors = get_divisors(number);
  int sum = 0;
  int i = 0;
  while (i < divisors.length - 1) {
    sum = sum + divisors[i];
    i = i + 1;
  }
  return sum == number;
}

List<int> simplify_fraction(int numerator, int denominator) {
  if (denominator == 0) {
    throw Exception("denominator cannot be zero");
  }
  int g = gcd_iter(abs_int(numerator), abs_int(denominator));
  return [numerator ~/ g, denominator ~/ g];
}

int factorial(int n) {
  if (n < 0) {
    throw Exception("n must be >= 0");
  }
  int ans = 1;
  int i = 1;
  while (i <= n) {
    ans = ans * i;
    i = i + 1;
  }
  return ans;
}

int fib(int n) {
  if (n < 0) {
    throw Exception("n must be >= 0");
  }
  if (n <= 1) {
    return 1;
  }
  int tmp = 0;
  int fib1 = 1;
  int ans = 1;
  int i = 0;
  while (i < n - 1) {
    tmp = ans;
    ans = ans + fib1;
    fib1 = tmp;
    i = i + 1;
  }
  return ans;
}

void main() {
  print((is_prime(97)).toString());
  print((sieve_er(20)).toString());
  print((get_prime_numbers(20)).toString());
  print((prime_factorization(287)).toString());
  print((greatest_prime_factor(287)).toString());
  print((smallest_prime_factor(287)).toString());
  print((kg_v(8, 10)).toString());
  print((goldbach(28)).toString());
  print((get_prime(8)).toString());
  print((get_primes_between(3, 20)).toString());
  print((get_divisors(28)).toString());
  print((is_perfect_number(28)).toString());
  print((simplify_fraction(10, 20)).toString());
  print((factorial(5)).toString());
  print((fib(10)).toString());
}
