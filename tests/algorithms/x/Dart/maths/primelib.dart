// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _str(dynamic v) => v.toString();


Never _error(dynamic msg) {
  throw Exception(msg.toString());
}

int abs_int(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

int gcd_iter(int a, int b) {
  int x = abs_int(a);
  int y = abs_int(b);
  while (y != 0) {
    int t = y;
    y = x % y;
    x = t;
  }
  return x;
}

bool is_prime(int n) {
  if (n <= 1) {
    return false;
  }
  int d = 2;
  while (d * d <= n) {
    if (n % d == 0) {
    return false;
  }
    d = d + 1;
  }
  return true;
}

List<int> sieve_er(int n) {
  List<int> nums = <int>[];
  int i = 2;
  while (i <= n) {
    nums = [...nums, i];
    i = i + 1;
  }
  int idx = 0;
  while (idx < nums.length) {
    int j = idx + 1;
    while (j < nums.length) {
    if (nums[idx] != 0) {
    if (nums[j] % nums[idx] == 0) {
    while (nums.length <= j) { nums.add(0); } nums[j] = 0;
  };
  }
    j = j + 1;
  }
    idx = idx + 1;
  }
  List<int> res = <int>[];
  int k = 0;
  while (k < nums.length) {
    int v = nums[k];
    if (v != 0) {
    res = [...res, v];
  }
    k = k + 1;
  }
  return res;
}

List<int> get_prime_numbers(int n) {
  List<int> ans = <int>[];
  int _num = 2;
  while (_num <= n) {
    if (is_prime(_num)) {
    ans = [...ans, _num];
  }
    _num = _num + 1;
  }
  return ans;
}

List<int> prime_factorization(int number) {
  if (number == 0) {
    return [0];
  }
  if (number == 1) {
    return [1];
  }
  List<int> ans = <int>[];
  if (is_prime(number)) {
    ans = [...ans, number];
    return ans;
  }
  int quotient = number;
  int factor = 2;
  while (quotient != 1) {
    if (is_prime(factor) && quotient % factor == 0) {
    ans = [...ans, factor];
    quotient = quotient ~/ factor;
  } else {
    factor = factor + 1;
  }
  }
  return ans;
}

int greatest_prime_factor(int number) {
  List<int> factors = prime_factorization(number);
  int m = factors[0];
  int i = 1;
  while (i < factors.length) {
    if (factors[i] > m) {
    m = factors[i];
  }
    i = i + 1;
  }
  return m;
}

int smallest_prime_factor(int number) {
  List<int> factors = prime_factorization(number);
  int m = factors[0];
  int i = 1;
  while (i < factors.length) {
    if (factors[i] < m) {
    m = factors[i];
  }
    i = i + 1;
  }
  return m;
}

int kg_v(int number1, int number2) {
  if (number1 < 1 || number2 < 1) {
    _error("numbers must be positive");
  }
  int g = gcd_iter(number1, number2);
  return number1 ~/ g * number2;
}

bool is_even(int number) {
  return number % 2 == 0;
}

bool is_odd(int number) {
  return number % 2 != 0;
}

List<int> goldbach(int number) {
  if (!is_even(number) || number <= 2) {
    _error("number must be even and > 2");
  }
  List<int> primes = get_prime_numbers(number);
  int i = 0;
  while (i < primes.length) {
    int j = i + 1;
    while (j < primes.length) {
    if (primes[i] + primes[j] == number) {
    return [primes[i], primes[j]];
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return ([] as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
}

int get_prime(int n) {
  if (n < 0) {
    _error("n must be non-negative");
  }
  int index = 0;
  int ans = 2;
  while (index < n) {
    index = index + 1;
    ans = ans + 1;
    while (!is_prime(ans)) {
    ans = ans + 1;
  }
  }
  return ans;
}

List<int> get_primes_between(int p1, int p2) {
  bool bad1 = !is_prime(p1);
  bool bad2 = !is_prime(p2);
  if (bad1 || bad2 || p1 >= p2) {
    _error("arguments must be prime and p1 < p2");
  }
  int _num = p1 + 1;
  while (_num < p2) {
    if (is_prime(_num)) {
    break;
  }
    _num = _num + 1;
  }
  List<int> ans = <int>[];
  while (_num < p2) {
    ans = [...ans, _num];
    _num = _num + 1;
    while (_num < p2) {
    if (is_prime(_num)) {
    break;
  }
    _num = _num + 1;
  }
  }
  return ans;
}

List<int> get_divisors(int n) {
  if (n < 1) {
    _error("n must be >= 1");
  }
  List<int> ans = <int>[];
  int d = 1;
  while (d <= n) {
    if (n % d == 0) {
    ans = [...ans, d];
  }
    d = d + 1;
  }
  return ans;
}

bool is_perfect_number(int number) {
  if (number <= 1) {
    _error("number must be > 1");
  }
  List<int> divisors = get_divisors(number);
  int sum = 0;
  int i = 0;
  while (i < divisors.length - 1) {
    sum = sum + divisors[i];
    i = i + 1;
  }
  return sum == number;
}

List<int> simplify_fraction(int numerator, int denominator) {
  if (denominator == 0) {
    _error("denominator cannot be zero");
  }
  int g = gcd_iter(abs_int(numerator), abs_int(denominator));
  return [numerator ~/ g, denominator ~/ g];
}

int factorial(int n) {
  if (n < 0) {
    _error("n must be >= 0");
  }
  int ans = 1;
  int i = 1;
  while (i <= n) {
    ans = ans * i;
    i = i + 1;
  }
  return ans;
}

int fib(int n) {
  if (n < 0) {
    _error("n must be >= 0");
  }
  if (n <= 1) {
    return 1;
  }
  int tmp = 0;
  int fib1 = 1;
  int ans = 1;
  int i = 0;
  while (i < n - 1) {
    tmp = ans;
    ans = ans + fib1;
    fib1 = tmp;
    i = i + 1;
  }
  return ans;
}

void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print(_str(is_prime(97)));
  print(_str(sieve_er(20)));
  print(_str(get_prime_numbers(20)));
  print(_str(prime_factorization(287)));
  print(_str(greatest_prime_factor(287)));
  print(_str(smallest_prime_factor(287)));
  print(_str(kg_v(8, 10)));
  print(_str(goldbach(28)));
  print(_str(get_prime(8)));
  print(_str(get_primes_between(3, 23)));
  print(_str(get_divisors(28)));
  print(_str(is_perfect_number(28)));
  print(_str(simplify_fraction(10, 20)));
  print(_str(factorial(5)));
  print(_str(fib(10)));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
