// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Complex {
  double re;
  double im;
  Complex({required this.re, required this.im});
}

Complex c_add(Complex a, Complex b) {
  return Complex(re: a.re + b.re, im: a.im + b.im);
}

Complex c_sub(Complex a, Complex b) {
  return Complex(re: a.re - b.re, im: a.im - b.im);
}

Complex c_mul(Complex a, Complex b) {
  return Complex(re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re);
}

Complex c_mul_scalar(Complex a, double s) {
  return Complex(re: a.re * s, im: a.im * s);
}

Complex c_div_scalar(Complex a, double s) {
  return Complex(re: a.re / s, im: a.im / s);
}

double PI = 3.141592653589793;
double sin_taylor(double x) {
  double term = x;
  double sum = x;
  int i = 1;
  while (i < 10) {
    double k1 = 2.0 * i.toDouble();
    double k2 = k1 + 1.0;
    term = -term * x * x / (k1 * k2);
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

double cos_taylor(double x) {
  double term = 1.0;
  double sum = 1.0;
  int i = 1;
  while (i < 10) {
    double k1 = 2.0 * i.toDouble() - 1.0;
    double k2 = 2.0 * i.toDouble();
    term = -term * x * x / (k1 * k2);
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

Complex exp_i(double theta) {
  return Complex(re: cos_taylor(theta), im: sin_taylor(theta));
}

List<Complex> make_complex_list(int n, Complex value) {
  List<Complex> arr = <Complex>[];
  int i = 0;
  while (i < n) {
    arr = [...arr, value];
    i = i + 1;
  }
  return arr;
}

List<Complex> fft(List<Complex> a, bool invert) {
  int n = a.length;
  if (n == 1) {
    return [a[0]];
  }
  List<Complex> a0 = <Complex>[];
  List<Complex> a1 = <Complex>[];
  int i = 0;
  while (i < n ~/ 2) {
    a0 = [...a0, a[2 * i]];
    a1 = [...a1, a[2 * i + 1]];
    i = i + 1;
  }
  List<Complex> y0 = fft(a0, invert);
  List<Complex> y1 = fft(a1, invert);
  double angle = 2.0 * PI / n.toDouble() * (invert ? -1.0 : 1.0);
  Complex w = Complex(re: 1.0, im: 0.0);
  Complex wn = exp_i(angle);
  List<Complex> y = make_complex_list(n, Complex(re: 0.0, im: 0.0));
  i = 0;
  while (i < n ~/ 2) {
    Complex t = c_mul(w, y1[i]);
    Complex u = y0[i];
    Complex even = c_add(u, t);
    Complex odd = c_sub(u, t);
    if (invert) {
    even = c_div_scalar(even, 2.0);
    odd = c_div_scalar(odd, 2.0);
  }
    while (y.length <= i) { y.add(null as dynamic); } y[i] = even;
    while (y.length <= i + n ~/ 2) { y.add(null as dynamic); } y[i + n ~/ 2] = odd;
    w = c_mul(w, wn);
    i = i + 1;
  }
  return y;
}

double floor(double x) {
  dynamic i = x.toInt();
  if (i.toDouble() > x) {
    i = i - 1;
  }
  return i.toDouble();
}

double pow10(int n) {
  double p = 1.0;
  int i = 0;
  while (i < n) {
    p = p * 10.0;
    i = i + 1;
  }
  return p;
}

double round_to(double x, int ndigits) {
  double m = pow10(ndigits);
  return floor(x * m + 0.5) / m;
}

String list_to_string(List<double> l) {
  String s = "[";
  int i = 0;
  while (i < l.length) {
    s = s + _str(l[i]);
    if (i + 1 < l.length) {
    s = s + ", ";
  }
    i = i + 1;
  }
  s = s + "]";
  return s;
}

List<double> multiply_poly(List<double> a, List<double> b) {
  int n = 1;
  while (n < a.length + b.length - 1) {
    n = n * 2;
  }
  List<Complex> fa = make_complex_list(n, Complex(re: 0.0, im: 0.0));
  List<Complex> fb = make_complex_list(n, Complex(re: 0.0, im: 0.0));
  int i = 0;
  while (i < a.length) {
    while (fa.length <= i) { fa.add(null as dynamic); } fa[i] = Complex(re: a[i], im: 0.0);
    i = i + 1;
  }
  i = 0;
  while (i < b.length) {
    while (fb.length <= i) { fb.add(null as dynamic); } fb[i] = Complex(re: b[i], im: 0.0);
    i = i + 1;
  }
  fa = fft(fa, false);
  fb = fft(fb, false);
  i = 0;
  while (i < n) {
    while (fa.length <= i) { fa.add(null as dynamic); } fa[i] = c_mul(fa[i], fb[i]);
    i = i + 1;
  }
  fa = fft(fa, true);
  List<double> res = <double>[];
  i = 0;
  while (i < a.length + b.length - 1) {
    Complex val = fa[i];
    res = [...res, round_to(val.re, 8)];
    i = i + 1;
  }
  while (res.length > 0 && res[res.length - 1] == 0.0) {
    res = res.sublist(0, res.length - 1);
  }
  return res;
}

List<double> A = [0.0, 1.0, 0.0, 2.0];
List<double> B = [2.0, 3.0, 4.0, 0.0];
List<double> product = multiply_poly(A, B);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print(list_to_string(product));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
