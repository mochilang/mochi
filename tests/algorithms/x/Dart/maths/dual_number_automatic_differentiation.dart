// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Dual {
  double real;
  List<double> duals;
  Dual({required this.real, required this.duals});
}

Dual make_dual(double real, int rank) {
  List<double> ds = <double>[];
  int i = 0;
  while (i < rank) {
    ds = [...ds, 1.0];
    i = i + 1;
  }
  return Dual(real: real, duals: ds);
}

Dual dual_from_list(double real, List<double> ds) {
  return Dual(real: real, duals: ds);
}

Dual dual_add(Dual a, Dual b) {
  List<double> s_dual = <double>[];
  int i = 0;
  while (i < a.duals.length) {
    s_dual = [...s_dual, a.duals[i]];
    i = i + 1;
  }
  List<double> o_dual = <double>[];
  int j = 0;
  while (j < b.duals.length) {
    o_dual = [...o_dual, b.duals[j]];
    j = j + 1;
  }
  if (s_dual.length > o_dual.length) {
    int diff = s_dual.length - o_dual.length;
    int k = 0;
    while (k < diff) {
    o_dual = [...o_dual, 1.0];
    k = k + 1;
  };
  } else {
    if (s_dual.length < o_dual.length) {
    int diff2 = o_dual.length - s_dual.length;
    int k2 = 0;
    while (k2 < diff2) {
    s_dual = [...s_dual, 1.0];
    k2 = k2 + 1;
  };
  };
  }
  List<double> new_duals = <double>[];
  int idx = 0;
  while (idx < s_dual.length) {
    new_duals = [...new_duals, s_dual[idx] + o_dual[idx]];
    idx = idx + 1;
  }
  return Dual(real: a.real + b.real, duals: new_duals);
}

Dual dual_add_real(Dual a, double b) {
  List<double> ds = <double>[];
  int i = 0;
  while (i < a.duals.length) {
    ds = [...ds, a.duals[i]];
    i = i + 1;
  }
  return Dual(real: a.real + b, duals: ds);
}

Dual dual_mul(Dual a, Dual b) {
  int new_len = a.duals.length + b.duals.length + 1;
  List<double> new_duals = <double>[];
  int idx = 0;
  while (idx < new_len) {
    new_duals = [...new_duals, 0.0];
    idx = idx + 1;
  }
  int i = 0;
  while (i < a.duals.length) {
    int j = 0;
    while (j < b.duals.length) {
    int pos = i + j + 1;
    double val = new_duals[pos] + a.duals[i] * b.duals[j];
    while (new_duals.length <= pos) { new_duals.add(0); } new_duals[pos] = val;
    j = j + 1;
  }
    i = i + 1;
  }
  int k = 0;
  while (k < a.duals.length) {
    double val = new_duals[k] + a.duals[k] * b.real;
    while (new_duals.length <= k) { new_duals.add(0); } new_duals[k] = val;
    k = k + 1;
  }
  int l = 0;
  while (l < b.duals.length) {
    double val = new_duals[l] + b.duals[l] * a.real;
    while (new_duals.length <= l) { new_duals.add(0); } new_duals[l] = val;
    l = l + 1;
  }
  return Dual(real: a.real * b.real, duals: new_duals);
}

Dual dual_mul_real(Dual a, double b) {
  List<double> ds = <double>[];
  int i = 0;
  while (i < a.duals.length) {
    ds = [...ds, a.duals[i] * b];
    i = i + 1;
  }
  return Dual(real: a.real * b, duals: ds);
}

Dual dual_pow(Dual x, int n) {
  if (n < 0) {
    throw Exception("power must be a positive integer");
  }
  if (n == 0) {
    return Dual(real: 1.0, duals: []);
  }
  Dual res = x;
  int i = 1;
  while (i < n) {
    res = dual_mul(res, x);
    i = i + 1;
  }
  return res;
}

double factorial(int n) {
  double res = 1.0;
  int i = 2;
  while (i <= n) {
    res = res * (i as double);
    i = i + 1;
  }
  return res;
}

double differentiate(dynamic func, double position, int order) {
  Dual d = make_dual(position, 1);
  dynamic result = func(d);
  if (order == 0) {
    return result.real;
  }
  return result.duals[order - 1] * factorial(order);
}

void test_differentiate() {
  Dual f1(Dual x) {
  return dual_pow(x, 2);
}
  if (differentiate(f1, 2.0, 2) != 2.0) {
    throw Exception("f1 failed");
  }
  Dual f2(Dual x) {
  return dual_mul(dual_pow(x, 2), dual_pow(x, 4));
}
  if (differentiate(f2, 9.0, 2) != 196830.0) {
    throw Exception("f2 failed");
  }
  Dual f3(Dual y) {
  return dual_mul_real(dual_pow(dual_add_real(y, 3.0), 6), 0.5);
}
  if (differentiate(f3, 3.5, 4) != 7605.0) {
    throw Exception("f3 failed");
  }
  Dual f4(Dual y) {
  return dual_pow(y, 2);
}
  if (differentiate(f4, 4.0, 3) != 0.0) {
    throw Exception("f4 failed");
  }
}

void _main() {
  test_differentiate();
  Dual f(Dual y) {
  return dual_mul(dual_pow(y, 2), dual_pow(y, 4));
}
  double res = differentiate(f, 9.0, 2);
  print(res);
}

void _start() {
  _main();
}

void main() => _start();
