// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class QR {
  List<List<double>> q;
  List<List<double>> r;
  QR({required this.q, required this.r});
}

double sqrt_approx(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double sign(double x) {
  if (x >= 0.0) {
    return 1.0;
  } else {
    return -1.0;
  }
}

double vector_norm(List<double> v) {
  double sum = 0.0;
  int i = 0;
  while (i < v.length) {
    sum = sum + v[i] * v[i];
    i = i + 1;
  }
  double n = sqrt_approx(sum);
  return n;
}

List<List<double>> identity_matrix(int n) {
  List<List<double>> mat = <List<double>>[];
  int i = 0;
  while (i < n) {
    List<double> row = <double>[];
    int j = 0;
    while (j < n) {
    if (i == j) {
    row = [...row, 1.0];
  } else {
    row = [...row, 0.0];
  }
    j = j + 1;
  }
    mat = ([...mat, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return mat;
}

List<List<double>> copy_matrix(List<List<double>> a) {
  List<List<double>> mat = <List<double>>[];
  int i = 0;
  while (i < a.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < a[i].length) {
    row = [...row, a[i][j]];
    j = j + 1;
  }
    mat = ([...mat, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return mat;
}

List<List<double>> matmul(List<List<double>> a, List<List<double>> b) {
  int m = a.length;
  int n = a[0].length;
  int p = b[0].length;
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < m) {
    List<double> row = <double>[];
    int j = 0;
    while (j < p) {
    double sum = 0.0;
    int k = 0;
    while (k < n) {
    sum = sum + a[i][k] * b[k][j];
    k = k + 1;
  }
    row = [...row, sum];
    j = j + 1;
  }
    res = ([...res, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

QR qr_decomposition(List<List<double>> a) {
  int m = a.length;
  int n = a[0].length;
  int t = (m < n ? m : n);
  List<List<double>> q = identity_matrix(m);
  List<List<double>> r = copy_matrix(a);
  int k = 0;
  while (k < t - 1) {
    List<double> x = <double>[];
    int i = k;
    while (i < m) {
    x = [...x, r[i][k]];
    i = i + 1;
  }
    List<double> e1 = <double>[];
    i = 0;
    while (i < x.length) {
    if (i == 0) {
    e1 = [...e1, 1.0];
  } else {
    e1 = [...e1, 0.0];
  }
    i = i + 1;
  }
    double alpha = vector_norm(x);
    double s = sign(x[0]) * alpha;
    List<double> v = <double>[];
    i = 0;
    while (i < x.length) {
    v = [...v, x[i] + s * e1[i]];
    i = i + 1;
  }
    double vnorm = vector_norm(v);
    i = 0;
    while (i < v.length) {
    while (v.length <= i) { v.add(0); } v[i] = v[i] / vnorm;
    i = i + 1;
  }
    int size = v.length;
    List<List<double>> qk_small = <List<double>>[];
    i = 0;
    while (i < size) {
    List<double> row = <double>[];
    int j = 0;
    while (j < size) {
    double delta = (i == j ? 1.0 : 0.0);
    row = [...row, delta - 2.0 * v[i] * v[j]];
    j = j + 1;
  }
    qk_small = ([...qk_small, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
    List<List<double>> qk = identity_matrix(m);
    i = 0;
    while (i < size) {
    int j = 0;
    while (j < size) {
    while (qk[k + i]!.length <= k + j) { qk[k + i]!.add(0); } qk[k + i]![k + j] = qk_small[i][j];
    j = j + 1;
  }
    i = i + 1;
  }
    q = matmul(q, qk);
    r = matmul(qk, r);
    k = k + 1;
  }
  return QR(q: q, r: r);
}

void print_matrix(List<List<double>> mat) {
  int i = 0;
  while (i < mat.length) {
    String line = "";
    int j = 0;
    while (j < mat[i].length) {
    line = line + _str(mat[i][j]);
    if (j + 1 < mat[i].length) {
    line = line + " ";
  }
    j = j + 1;
  }
    print(line);
    i = i + 1;
  }
}

List<List<double>> A = [[12.0, -51.0, 4.0], [6.0, 167.0, -68.0], [-4.0, 24.0, -41.0]];
QR result = qr_decomposition(A);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print_matrix(result.q);
  print_matrix(result.r);
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
