// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

int MOD = 4294967296;
String ASCII = " !\"#\$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
int ord(String ch) {
  int i = 0;
  while (i < ASCII.length) {
    if (_substr(ASCII, i, i + 1) == ch) {
    return 32 + i;
  }
    i = i + 1;
  }
  return 0;
}

int pow2(int n) {
  int res = 1;
  int i = 0;
  while (i < n) {
    res = res * 2;
    i = i + 1;
  }
  return res;
}

int bit_and(int a, int b) {
  int x = a;
  int y = b;
  int res = 0;
  int bit = 1;
  int i = 0;
  while (i < 32) {
    if (x % 2 == 1 && y % 2 == 1) {
    res = res + bit;
  }
    x = x ~/ 2;
    y = y ~/ 2;
    bit = bit * 2;
    i = i + 1;
  }
  return res;
}

int bit_or(int a, int b) {
  int x = a;
  int y = b;
  int res = 0;
  int bit = 1;
  int i = 0;
  while (i < 32) {
    int abit = x % 2;
    int bbit = y % 2;
    if (abit == 1 || bbit == 1) {
    res = res + bit;
  }
    x = x ~/ 2;
    y = y ~/ 2;
    bit = bit * 2;
    i = i + 1;
  }
  return res;
}

int bit_xor(int a, int b) {
  int x = a;
  int y = b;
  int res = 0;
  int bit = 1;
  int i = 0;
  while (i < 32) {
    int abit = x % 2;
    int bbit = y % 2;
    if (abit == 1 && bbit == 0 || abit == 0 && bbit == 1) {
    res = res + bit;
  }
    x = x ~/ 2;
    y = y ~/ 2;
    bit = bit * 2;
    i = i + 1;
  }
  return res;
}

int bit_not(int a) {
  return MOD - 1 - a;
}

int rotate_left(int n, int b) {
  int left = n * pow2(b) % MOD;
  int right = n ~/ pow2(32 - b);
  return (left + right) % MOD;
}

String to_hex32(int n) {
  String digits = "0123456789abcdef";
  int _num = n;
  String s = "";
  if (_num == 0) {
    s = "0";
  }
  while (_num > 0) {
    int d = _num % 16;
    s = _substr(digits, d, d + 1) + s;
    _num = _num ~/ 16;
  }
  while (s.length < 8) {
    s = "0" + s;
  }
  if (s.length > 8) {
    s = _substr(s, s.length - 8, s.length);
  }
  return s;
}

String sha1(String message) {
  List<int> bytes = <int>[];
  int i = 0;
  while (i < message.length) {
    bytes = [...bytes, ord(_substr(message, i, i + 1))];
    i = i + 1;
  }
  bytes = [...bytes, 128];
  while ((bytes.length + 8) % 64 != 0) {
    bytes = [...bytes, 0];
  }
  int bit_len = message.length * 8;
  List<int> len_bytes = [0, 0, 0, 0, 0, 0, 0, 0];
  int bl = bit_len;
  int k = 7;
  while (k >= 0) {
    while (len_bytes.length <= k) { len_bytes.add(0); } len_bytes[k] = bl % 256;
    bl = bl ~/ 256;
    k = k - 1;
  }
  int j = 0;
  while (j < 8) {
    bytes = [...bytes, len_bytes[j]];
    j = j + 1;
  }
  List<List<int>> blocks = <List<int>>[];
  int pos = 0;
  while (pos < bytes.length) {
    List<int> block = <int>[];
    int j2 = 0;
    while (j2 < 64) {
    block = [...block, bytes[pos + j2]];
    j2 = j2 + 1;
  }
    blocks = ([...blocks, block] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    pos = pos + 64;
  }
  int h0 = 1732584193;
  int h1 = 4023233417;
  int h2 = 2562383102;
  int h3 = 271733878;
  int h4 = 3285377520;
  int bindex = 0;
  while (bindex < blocks.length) {
    List<int> block = blocks[bindex];
    List<int> w = <int>[];
    int t = 0;
    while (t < 16) {
    int j3 = t * 4;
    int word = ((block[j3] * 256 + block[j3 + 1]) * 256 + block[j3 + 2]) * 256 + block[j3 + 3];
    w = [...w, word];
    t = t + 1;
  }
    while (t < 80) {
    int tmp = bit_xor(bit_xor(bit_xor(w[t - 3], w[t - 8]), w[t - 14]), w[t - 16]);
    w = [...w, rotate_left(tmp, 1)];
    t = t + 1;
  }
    int a = h0;
    int b = h1;
    int c = h2;
    int d = h3;
    int e = h4;
    int i2 = 0;
    while (i2 < 80) {
    int f = 0;
    int kconst = 0;
    if (i2 < 20) {
    f = bit_or(bit_and(b, c), bit_and(bit_not(b), d));
    kconst = 1518500249;
  } else {
    if (i2 < 40) {
    f = bit_xor(bit_xor(b, c), d);
    kconst = 1859775393;
  } else {
    if (i2 < 60) {
    f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d));
    kconst = 2400959708;
  } else {
    f = bit_xor(bit_xor(b, c), d);
    kconst = 3395469782;
  };
  };
  }
    int temp = (rotate_left(a, 5) + f + e + kconst + w[i2]) % MOD;
    e = d;
    d = c;
    c = rotate_left(b, 30);
    b = a;
    a = temp;
    i2 = i2 + 1;
  }
    h0 = (h0 + a) % MOD;
    h1 = (h1 + b) % MOD;
    h2 = (h2 + c) % MOD;
    h3 = (h3 + d) % MOD;
    h4 = (h4 + e) % MOD;
    bindex = bindex + 1;
  }
  return to_hex32(h0) + to_hex32(h1) + to_hex32(h2) + to_hex32(h3) + to_hex32(h4);
}

void _main() {
  print(sha1("Test String"));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
