// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double absf(double x) {
  if (x < 0.0) {
    return -x;
  }
  return x;
}

double fmod(double a, double b) {
  return a - b * (a / b as int);
}

int roundf(double x) {
  if (x >= 0.0) {
    return x + 0.5 as int;
  }
  return x - 0.5 as int;
}

double maxf(double a, double b, double c) {
  double m = a;
  if (b > m) {
    m = b;
  }
  if (c > m) {
    m = c;
  }
  return m;
}

double minf(double a, double b, double c) {
  double m = a;
  if (b < m) {
    m = b;
  }
  if (c < m) {
    m = c;
  }
  return m;
}

List<int> hsv_to_rgb(double hue, double saturation, double value) {
  if (hue < 0.0 || hue > 360.0) {
    print("hue should be between 0 and 360");
    return ([] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  if (saturation < 0.0 || saturation > 1.0) {
    print("saturation should be between 0 and 1");
    return ([] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  if (value < 0.0 || value > 1.0) {
    print("value should be between 0 and 1");
    return ([] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  double chroma = value * saturation;
  double hue_section = hue / 60.0;
  double second_largest_component = chroma * (1.0 - absf(fmod(hue_section, 2.0) - 1.0));
  double match_value = value - chroma;
  int red = 0;
  int green = 0;
  int blue = 0;
  if (hue_section >= 0.0 && hue_section <= 1.0) {
    red = roundf(255.0 * (chroma + match_value));
    green = roundf(255.0 * (second_largest_component + match_value));
    blue = roundf(255.0 * match_value);
  } else {
    if (hue_section > 1.0 && hue_section <= 2.0) {
    red = roundf(255.0 * (second_largest_component + match_value));
    green = roundf(255.0 * (chroma + match_value));
    blue = roundf(255.0 * match_value);
  } else {
    if (hue_section > 2.0 && hue_section <= 3.0) {
    red = roundf(255.0 * match_value);
    green = roundf(255.0 * (chroma + match_value));
    blue = roundf(255.0 * (second_largest_component + match_value));
  } else {
    if (hue_section > 3.0 && hue_section <= 4.0) {
    red = roundf(255.0 * match_value);
    green = roundf(255.0 * (second_largest_component + match_value));
    blue = roundf(255.0 * (chroma + match_value));
  } else {
    if (hue_section > 4.0 && hue_section <= 5.0) {
    red = roundf(255.0 * (second_largest_component + match_value));
    green = roundf(255.0 * match_value);
    blue = roundf(255.0 * (chroma + match_value));
  } else {
    red = roundf(255.0 * (chroma + match_value));
    green = roundf(255.0 * match_value);
    blue = roundf(255.0 * (second_largest_component + match_value));
  };
  };
  };
  };
  }
  return [red, green, blue];
}

List<double> rgb_to_hsv(int red, int green, int blue) {
  if (red < 0 || red > 255) {
    print("red should be between 0 and 255");
    return List<double>.from([]);
  }
  if (green < 0 || green > 255) {
    print("green should be between 0 and 255");
    return List<double>.from([]);
  }
  if (blue < 0 || blue > 255) {
    print("blue should be between 0 and 255");
    return List<double>.from([]);
  }
  double float_red = red / 255.0;
  double float_green = green / 255.0;
  double float_blue = blue / 255.0;
  double value = maxf(float_red, float_green, float_blue);
  double min_val = minf(float_red, float_green, float_blue);
  double chroma = value - min_val;
  double saturation = (value == 0.0 ? 0.0 : chroma / value);
  double hue = 0;
  if (chroma == 0.0) {
    hue = 0.0;
  } else {
    if (value == float_red) {
    hue = 60.0 * (0.0 + (float_green - float_blue) / chroma);
  } else {
    if (value == float_green) {
    hue = 60.0 * (2.0 + (float_blue - float_red) / chroma);
  } else {
    hue = 60.0 * (4.0 + (float_red - float_green) / chroma);
  };
  };
  }
  hue = fmod(hue + 360.0, 360.0);
  return [hue, saturation, value];
}

bool approximately_equal_hsv(List<double> hsv1, List<double> hsv2) {
  bool check_hue = absf(hsv1[0] - hsv2[0]) < 0.2;
  bool check_saturation = absf(hsv1[1] - hsv2[1]) < 0.002;
  bool check_value = absf(hsv1[2] - hsv2[2]) < 0.002;
  return check_hue && check_saturation && check_value;
}

List<int> rgb = hsv_to_rgb(180.0, 0.5, 0.5);
List<double> hsv = rgb_to_hsv(64, 128, 128);
void main() {
  print((rgb).toString());
  print((hsv).toString());
  print((approximately_equal_hsv(hsv, [180.0, 0.5, 0.5])).toString());
}
