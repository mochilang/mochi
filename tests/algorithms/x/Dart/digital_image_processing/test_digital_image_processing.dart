// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

int clamp_byte(int x) {
  if (x < 0) {
    return 0;
  }
  if (x > 255) {
    return 255;
  }
  return x;
}

List<List<int>> convert_to_negative(List<List<int>> img) {
  int h = img.length;
  int w = img[0].length;
  List<List<int>> out = <List<int>>[];
  int y = 0;
  while (y < h) {
    List<int> row = <int>[];
    int x = 0;
    while (x < w) {
    row = [...row, 255 - img[y][x]];
    x = x + 1;
  }
    out = ([...out, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    y = y + 1;
  }
  return out;
}

List<List<int>> change_contrast(List<List<int>> img, int factor) {
  int h = img.length;
  int w = img[0].length;
  List<List<int>> out = <List<int>>[];
  int y = 0;
  while (y < h) {
    List<int> row = <int>[];
    int x = 0;
    while (x < w) {
    int p = img[y][x];
    int v = (p - 128) * factor ~/ 100 + 128;
    v = clamp_byte(v);
    row = [...row, v];
    x = x + 1;
  }
    out = ([...out, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    y = y + 1;
  }
  return out;
}

List<List<double>> gen_gaussian_kernel(int n, double sigma) {
  if (n == 3) {
    return [[1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0], [2.0 / 16.0, 4.0 / 16.0, 2.0 / 16.0], [1.0 / 16.0, 2.0 / 16.0, 1.0 / 16.0]];
  }
  List<List<double>> k = <List<double>>[];
  int i = 0;
  while (i < n) {
    List<double> row = <double>[];
    int j = 0;
    while (j < n) {
    row = [...row, 0.0];
    j = j + 1;
  }
    k = ([...k, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return k;
}

List<List<int>> img_convolve(List<List<int>> img, List<List<double>> kernel) {
  int h = img.length;
  int w = img[0].length;
  List<List<int>> out = <List<int>>[];
  int y = 0;
  while (y < h) {
    List<int> row = <int>[];
    int x = 0;
    while (x < w) {
    double acc = 0.0;
    int ky = 0;
    while (ky < kernel.length) {
    int kx = 0;
    while (kx < kernel[0].length) {
    int iy = y + ky - 1;
    int ix = x + kx - 1;
    int pixel = 0;
    if (iy >= 0 && iy < h && ix >= 0 && ix < w) {
    pixel = img[iy][ix];
  }
    acc = acc + kernel[ky][kx] * (1.0 * pixel);
    kx = kx + 1;
  }
    ky = ky + 1;
  }
    row = [...row, int.parse(acc)];
    x = x + 1;
  }
    out = ([...out, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    y = y + 1;
  }
  return out;
}

List<int> sort_ints(List<int> xs) {
  List<int> arr = xs;
  int i = 0;
  while (i < arr.length) {
    int j = 0;
    while (j < arr.length - 1 - i) {
    if (arr[j] > arr[j + 1]) {
    int tmp = arr[j];
    while (arr.length <= j) { arr.add(0); } arr[j] = arr[j + 1];
    while (arr.length <= j + 1) { arr.add(0); } arr[j + 1] = tmp;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return arr;
}

List<List<int>> median_filter(List<List<int>> img, int k) {
  int h = img.length;
  int w = img[0].length;
  int offset = k ~/ 2;
  List<List<int>> out = <List<int>>[];
  int y = 0;
  while (y < h) {
    List<int> row = <int>[];
    int x = 0;
    while (x < w) {
    List<int> vals = <int>[];
    int ky = 0;
    while (ky < k) {
    int kx = 0;
    while (kx < k) {
    int iy = y + ky - offset;
    int ix = x + kx - offset;
    int pixel = 0;
    if (iy >= 0 && iy < h && ix >= 0 && ix < w) {
    pixel = img[iy][ix];
  }
    vals = [...vals, pixel];
    kx = kx + 1;
  }
    ky = ky + 1;
  }
    List<int> sorted = sort_ints(vals);
    row = [...row, sorted[sorted.length ~/ 2]];
    x = x + 1;
  }
    out = ([...out, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    y = y + 1;
  }
  return out;
}

int iabs(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

List<List<int>> sobel_filter(List<List<int>> img) {
  List<List<int>> gx = [[1, 0, -1], [2, 0, -2], [1, 0, -1]];
  List<List<int>> gy = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]];
  int h = img.length;
  int w = img[0].length;
  List<List<int>> out = <List<int>>[];
  int y = 0;
  while (y < h) {
    List<int> row = <int>[];
    int x = 0;
    while (x < w) {
    int sx = 0;
    int sy = 0;
    int ky = 0;
    while (ky < 3) {
    int kx = 0;
    while (kx < 3) {
    int iy = y + ky - 1;
    int ix = x + kx - 1;
    int pixel = 0;
    if (iy >= 0 && iy < h && ix >= 0 && ix < w) {
    pixel = img[iy][ix];
  }
    sx = sx + gx[ky][kx] * pixel;
    sy = sy + gy[ky][kx] * pixel;
    kx = kx + 1;
  }
    ky = ky + 1;
  }
    row = [...row, iabs(sx) + iabs(sy)];
    x = x + 1;
  }
    out = ([...out, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    y = y + 1;
  }
  return out;
}

List<int> get_neighbors_pixel(List<List<int>> img, int x, int y) {
  int h = img.length;
  int w = img[0].length;
  List<int> neighbors = <int>[];
  int dy = -1;
  while (dy <= 1) {
    int dx = -1;
    while (dx <= 1) {
    if (!(dx == 0 && dy == 0)) {
    int ny = y + dy;
    int nx = x + dx;
    int val = 0;
    if (ny >= 0 && ny < h && nx >= 0 && nx < w) {
    val = img[ny][nx];
  };
    neighbors = [...neighbors, val];
  }
    dx = dx + 1;
  }
    dy = dy + 1;
  }
  return neighbors;
}

int pow2(int e) {
  int r = 1;
  int i = 0;
  while (i < e) {
    r = r * 2;
    i = i + 1;
  }
  return r;
}

int local_binary_value(List<List<int>> img, int x, int y) {
  int center = img[y][x];
  List<int> neighbors = get_neighbors_pixel(img, x, y);
  int v = 0;
  int i = 0;
  while (i < neighbors.length) {
    if (neighbors[i] >= center) {
    v = v + pow2(i);
  }
    i = i + 1;
  }
  return v;
}

List<List<int>> local_binary_pattern(List<List<int>> img) {
  int h = img.length;
  int w = img[0].length;
  List<List<int>> out = <List<int>>[];
  int y = 0;
  while (y < h) {
    List<int> row = <int>[];
    int x = 0;
    while (x < w) {
    row = [...row, local_binary_value(img, x, y)];
    x = x + 1;
  }
    out = ([...out, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    y = y + 1;
  }
  return out;
}

List<List<int>> img = [[52, 55, 61], [62, 59, 55], [63, 65, 66]];
List<List<int>> negative = convert_to_negative(img);
List<List<int>> contrast = change_contrast(img, 110);
List<List<double>> kernel = gen_gaussian_kernel(3, 1.0);
List<List<double>> laplace = [[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]];
List<List<int>> convolved = img_convolve(img, laplace);
List<List<int>> medianed = median_filter(img, 3);
List<List<int>> sobel = sobel_filter(img);
List<List<int>> lbp_img = local_binary_pattern(img);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print("[" + negative.join(', ') + "]");
  print("[" + contrast.join(', ') + "]");
  print("[" + kernel.join(', ') + "]");
  print("[" + convolved.join(', ') + "]");
  print("[" + medianed.join(', ') + "]");
  print("[" + sobel.join(', ') + "]");
  print("[" + lbp_img.join(', ') + "]");
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
