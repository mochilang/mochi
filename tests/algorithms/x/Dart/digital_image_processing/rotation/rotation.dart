// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

List<List<double>> mat_inverse3(List<List<double>> m) {
  double a = m[0][0];
  double b = m[0][1];
  double c = m[0][2];
  double d = m[1][0];
  double e = m[1][1];
  double f = m[1][2];
  double g = m[2][0];
  double h = m[2][1];
  double i = m[2][2];
  double det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
  if (det == 0.0) {
    throw Exception("singular matrix");
  }
  double adj00 = e * i - f * h;
  double adj01 = c * h - b * i;
  double adj02 = b * f - c * e;
  double adj10 = f * g - d * i;
  double adj11 = a * i - c * g;
  double adj12 = c * d - a * f;
  double adj20 = d * h - e * g;
  double adj21 = b * g - a * h;
  double adj22 = a * e - b * d;
  List<List<double>> inv = <List<double>>[];
  inv = ((inv..add([adj00 / det, adj01 / det, adj02 / det])) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  inv = ((inv..add([adj10 / det, adj11 / det, adj12 / det])) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  inv = ((inv..add([adj20 / det, adj21 / det, adj22 / det])) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  return inv;
}

List<double> mat_vec_mul(List<List<double>> m, List<double> v) {
  List<double> res = <double>[];
  int i = 0;
  while (i < 3) {
    double val = m[i][0] * v[0] + m[i][1] * v[1] + m[i][2] * v[2];
    res = (res..add(val));
    i = i + 1;
  }
  return res;
}

List<List<int>> create_matrix(int rows, int cols, int value) {
  List<List<int>> result = <List<int>>[];
  int r = 0;
  while (r < rows) {
    List<int> row = <int>[];
    int c = 0;
    while (c < cols) {
    row = (row..add(value));
    c = c + 1;
  }
    result = ((result..add(row)) as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    r = r + 1;
  }
  return result;
}

int round_to_int(double x) {
  if (x >= 0.0) {
    return (x + 0.5).toInt();
  }
  return (x - 0.5).toInt();
}

List<List<int>> get_rotation(List<List<int>> img, List<List<double>> pt1, List<List<double>> pt2, int rows, int cols) {
  List<List<double>> src = [[pt1[0][0], pt1[0][1], 1.0], [pt1[1][0], pt1[1][1], 1.0], [pt1[2][0], pt1[2][1], 1.0]];
  List<List<double>> inv = mat_inverse3(src);
  List<double> vecx = [pt2[0][0], pt2[1][0], pt2[2][0]];
  List<double> vecy = [pt2[0][1], pt2[1][1], pt2[2][1]];
  List<double> avec = mat_vec_mul(inv, vecx);
  List<double> bvec = mat_vec_mul(inv, vecy);
  double a0 = avec[0];
  double a1 = avec[1];
  double a2 = avec[2];
  double b0 = bvec[0];
  double b1 = bvec[1];
  double b2 = bvec[2];
  List<List<int>> out = create_matrix(rows, cols, 0);
  int y = 0;
  while (y < rows) {
    int x = 0;
    while (x < cols) {
    double xf = a0 * (1.0 * x) + a1 * (1.0 * y) + a2;
    double yf = b0 * (1.0 * x) + b1 * (1.0 * y) + b2;
    int sx = round_to_int(xf);
    int sy = round_to_int(yf);
    if (sx >= 0 && sx < cols && sy >= 0 && sy < rows) {
    while (out[sy]!.length <= sx) { out[sy]!.add(0); } out[sy]![sx] = img[y][x];
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return out;
}

List<List<int>> img = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
List<List<double>> pts1 = [[0.0, 0.0], [2.0, 0.0], [0.0, 2.0]];
List<List<double>> pts2 = [[0.0, 2.0], [0.0, 0.0], [2.0, 2.0]];
List<List<int>> rotated = get_rotation(img, pts1, pts2, 3, 3);
void main() {
  print(_str(rotated));
}
