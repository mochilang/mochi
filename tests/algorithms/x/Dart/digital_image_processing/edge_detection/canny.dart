// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

double PI = 3.141592653589793;
double sqrtApprox(double x) {
  double guess = x / 2.0;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double atanApprox(double x) {
  if (x > 1.0) {
    return PI / 2.0 - x / (x * x + 0.28);
  }
  if (x < -1.0) {
    return -PI / 2.0 - x / (x * x + 0.28);
  }
  return x / (1.0 + 0.28 * x * x);
}

double atan2Approx(double y, double x) {
  if (x > 0.0) {
    double r = atanApprox(y / x);
    return r;
  }
  if (x < 0.0) {
    if (y >= 0.0) {
    return atanApprox(y / x) + PI;
  };
    return atanApprox(y / x) - PI;
  }
  if (y > 0.0) {
    return PI / 2.0;
  }
  if (y < 0.0) {
    return -PI / 2.0;
  }
  return 0.0;
}

double deg(double rad) {
  return rad * 180.0 / PI;
}

List<List<double>> GAUSSIAN_KERNEL = [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]];
List<List<double>> SOBEL_GX = [[-1.0, 0.0, 1.0], [-2.0, 0.0, 2.0], [-1.0, 0.0, 1.0]];
List<List<double>> SOBEL_GY = [[1.0, 2.0, 1.0], [0.0, 0.0, 0.0], [-1.0, -2.0, -1.0]];
List<List<double>> zero_matrix(int h, int w) {
  List<List<double>> out = <List<double>>[];
  int i = 0;
  while (i < h) {
    List<double> row = <double>[];
    int j = 0;
    while (j < w) {
    row = (row..add(0.0));
    j = j + 1;
  }
    out = ((out..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return out;
}

List<List<double>> convolve(List<List<double>> img, List<List<double>> kernel) {
  int h = img.length;
  int w = img[0].length;
  int k = kernel.length;
  int pad = k ~/ 2;
  List<List<double>> out = zero_matrix(h, w);
  int y = pad;
  while (y < h - pad) {
    int x = pad;
    while (x < w - pad) {
    double sum = 0.0;
    int ky = 0;
    while (ky < k) {
    int kx = 0;
    while (kx < k) {
    double pixel = img[y - pad + ky][x - pad + kx];
    double weight = kernel[ky][kx];
    sum = sum + pixel * weight;
    kx = kx + 1;
  }
    ky = ky + 1;
  }
    while (out[y]!.length <= x) { out[y]!.add(0); } out[y]![x] = sum;
    x = x + 1;
  }
    y = y + 1;
  }
  return out;
}

List<List<double>> gaussian_blur(List<List<double>> img) {
  return convolve(img, GAUSSIAN_KERNEL);
}

Map<String, List<List<double>>> sobel_filter(List<List<double>> img) {
  List<List<double>> gx = convolve(img, SOBEL_GX);
  List<List<double>> gy = convolve(img, SOBEL_GY);
  int h = img.length;
  int w = img[0].length;
  List<List<double>> grad = zero_matrix(h, w);
  List<List<double>> dir = zero_matrix(h, w);
  int i = 0;
  while (i < h) {
    int j = 0;
    while (j < w) {
    double gxx = gx[i][j];
    double gyy = gy[i][j];
    while (grad[i]!.length <= j) { grad[i]!.add(0); } grad[i]![j] = sqrtApprox(gxx * gxx + gyy * gyy);
    while (dir[i]!.length <= j) { dir[i]!.add(0); } dir[i]![j] = deg(atan2Approx(gyy, gxx)) + 180.0;
    j = j + 1;
  }
    i = i + 1;
  }
  return {"grad": grad, "dir": dir};
}

List<List<double>> suppress_non_maximum(int h, int w, List<List<double>> direction, List<List<double>> grad) {
  List<List<double>> dest = zero_matrix(h, w);
  int r = 1;
  while (r < h - 1) {
    int c = 1;
    while (c < w - 1) {
    double angle = direction[r][c];
    double q = 0.0;
    double p = 0.0;
    if (angle >= 0.0 && angle < 22.5 || angle >= 157.5 && angle <= 180.0 || angle >= 337.5) {
    q = grad[r][c + 1];
    p = grad[r][c - 1];
  } else {
    if (angle >= 22.5 && angle < 67.5 || angle >= 202.5 && angle < 247.5) {
    q = grad[r + 1][c - 1];
    p = grad[r - 1][c + 1];
  } else {
    if (angle >= 67.5 && angle < 112.5 || angle >= 247.5 && angle < 292.5) {
    q = grad[r + 1][c];
    p = grad[r - 1][c];
  } else {
    q = grad[r - 1][c - 1];
    p = grad[r + 1][c + 1];
  };
  };
  }
    if (grad[r][c] >= q && grad[r][c] >= p) {
    while (dest[r]!.length <= c) { dest[r]!.add(0); } dest[r]![c] = grad[r][c];
  }
    c = c + 1;
  }
    r = r + 1;
  }
  return dest;
}

void double_threshold(int h, int w, List<List<double>> img, double low, double high, double weak, double strong) {
  int r = 0;
  while (r < h) {
    int c = 0;
    while (c < w) {
    double v = img[r][c];
    if (v >= high) {
    while (img[r]!.length <= c) { img[r]!.add(0); } img[r]![c] = strong;
  } else {
    if (v < low) {
    while (img[r]!.length <= c) { img[r]!.add(0); } img[r]![c] = 0.0;
  } else {
    while (img[r]!.length <= c) { img[r]!.add(0); } img[r]![c] = weak;
  };
  }
    c = c + 1;
  }
    r = r + 1;
  }
}

void track_edge(int h, int w, List<List<double>> img, double weak, double strong) {
  int r = 1;
  while (r < h - 1) {
    int c = 1;
    while (c < w - 1) {
    if (img[r][c] == weak) {
    if (img[r + 1][c] == strong || img[r - 1][c] == strong || img[r][c + 1] == strong || img[r][c - 1] == strong || img[r - 1][c - 1] == strong || img[r - 1][c + 1] == strong || img[r + 1][c - 1] == strong || img[r + 1][c + 1] == strong) {
    while (img[r]!.length <= c) { img[r]!.add(0); } img[r]![c] = strong;
  } else {
    while (img[r]!.length <= c) { img[r]!.add(0); } img[r]![c] = 0.0;
  };
  }
    c = c + 1;
  }
    r = r + 1;
  }
}

List<List<double>> canny(List<List<double>> image, double low, double high, double weak, double strong) {
  List<List<double>> blurred = gaussian_blur(image);
  Map<String, List<List<double>>> sob = sobel_filter(blurred);
  List<List<double>> grad = sob["grad"]!;
  List<List<double>> direction = sob["dir"]!;
  int h = image.length;
  int w = image[0].length;
  List<List<double>> suppressed = suppress_non_maximum(h, w, direction, grad);
  double_threshold(h, w, suppressed, low, high, weak, strong);
  track_edge(h, w, suppressed, weak, strong);
  return suppressed;
}

void print_image(List<List<double>> img) {
  int r = 0;
  while (r < img.length) {
    int c = 0;
    String line = "";
    while (c < img[r].length) {
    line = line + _str((img[r][c]).toInt()) + " ";
    c = c + 1;
  }
    print(line);
    r = r + 1;
  }
}

List<List<double>> image = [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]];
List<List<double>> edges = canny(image, 20.0, 40.0, 128.0, 255.0);
void main() {
  print_image(edges);
}
