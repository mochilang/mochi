// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

double PI = 3.141592653589793;
double abs(double x) {
  if (x < 0.0) {
    return -x;
  }
  return x;
}

double sqrtApprox(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x;
  int i = 0;
  while (i < 10) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double expApprox(double x) {
  double term = 1.0;
  double sum = 1.0;
  int n = 1;
  while (n < 10) {
    term = term * x / (n.toDouble());
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

List<List<double>> vec_gaussian(List<List<double>> mat, double variance) {
  int i = 0;
  List<List<double>> out = <List<double>>[];
  while (i < mat.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < mat[i].length) {
    double v = mat[i][j];
    double e = -(v * v) / (2.0 * variance);
    row = List<double>.from(row + [expApprox(e)]);
    j = j + 1;
  }
    out = (out + [row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return out;
}

List<List<double>> get_slice(List<List<double>> img, int x, int y, int kernel_size) {
  int half = kernel_size ~/ 2;
  int i = x - half;
  List<List<double>> slice = <List<double>>[];
  while (i <= x + half) {
    List<double> row = <double>[];
    int j = y - half;
    while (j <= y + half) {
    row = List<double>.from(row + [img[i][j]]);
    j = j + 1;
  }
    slice = (slice + [row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return slice;
}

List<List<double>> get_gauss_kernel(int kernel_size, double spatial_variance) {
  List<List<double>> arr = <List<double>>[];
  int i = 0;
  while (i < kernel_size) {
    List<double> row = <double>[];
    int j = 0;
    while (j < kernel_size) {
    double di = i - kernel_size ~/ 2.toDouble();
    double dj = j - kernel_size ~/ 2.toDouble();
    double dist = sqrtApprox(di * di + dj * dj);
    row = List<double>.from(row + [dist]);
    j = j + 1;
  }
    arr = (arr + [row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return vec_gaussian(arr, spatial_variance);
}

List<List<double>> elementwise_sub(List<List<double>> mat, double value) {
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < mat.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < mat[i].length) {
    row = List<double>.from(row + [mat[i][j] - value]);
    j = j + 1;
  }
    res = (res + [row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

List<List<double>> elementwise_mul(List<List<double>> a, List<List<double>> b) {
  List<List<double>> res = <List<double>>[];
  int i = 0;
  while (i < a.length) {
    List<double> row = <double>[];
    int j = 0;
    while (j < a[i].length) {
    row = List<double>.from(row + [a[i][j] * b[i][j]]);
    j = j + 1;
  }
    res = (res + [row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return res;
}

double matrix_sum(List<List<double>> mat) {
  double total = 0.0;
  int i = 0;
  while (i < mat.length) {
    int j = 0;
    while (j < mat[i].length) {
    total = total + mat[i][j];
    j = j + 1;
  }
    i = i + 1;
  }
  return total;
}

double bilateral_filter(List<List<double>> img, double spatial_variance, double intensity_variance, int kernel_size) {
  List<List<double>> gauss_ker = get_gauss_kernel(kernel_size, spatial_variance);
  List<List<double>> img_s = img;
  double center = img_s[kernel_size ~/ 2][kernel_size ~/ 2];
  List<List<double>> img_i = elementwise_sub(img_s, center);
  List<List<double>> img_ig = vec_gaussian(img_i, intensity_variance);
  List<List<double>> weights = elementwise_mul(gauss_ker, img_ig);
  List<List<double>> vals = elementwise_mul(img_s, weights);
  double sum_weights = matrix_sum(weights);
  double val = 0.0;
  if (sum_weights != 0.0) {
    val = matrix_sum(vals) / sum_weights;
  }
  return val;
}

List<List<double>> img = [[0.2, 0.3, 0.4], [0.3, 0.4, 0.5], [0.4, 0.5, 0.6]];
double result = bilateral_filter(img, 1.0, 1.0, 3);
void main() {
  print(result);
}
