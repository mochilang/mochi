// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

double PI = 3.141592653589793;
double absf(double x) {
  if (x < 0.0) {
    return -x;
  }
  return x;
}

double sqrtApprox(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x / 2.0;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double atanApprox(double x) {
  if (x > 1.0) {
    return PI / 2.0 - x / (x * x + 0.28);
  }
  if (x < -1.0) {
    return -PI / 2.0 - x / (x * x + 0.28);
  }
  return x / (1.0 + 0.28 * x * x);
}

double atan2Approx(double y, double x) {
  if (x == 0.0) {
    if (y > 0.0) {
    return PI / 2.0;
  };
    if (y < 0.0) {
    return -PI / 2.0;
  };
    return 0.0;
  }
  double a = atanApprox(y / x);
  if (x > 0.0) {
    return a;
  }
  if (y >= 0.0) {
    return a + PI;
  }
  return a - PI;
}

List<List<double>> zeros(int h, int w) {
  List<List<double>> m = <List<double>>[];
  int y = 0;
  while (y < h) {
    List<double> row = <double>[];
    int x = 0;
    while (x < w) {
    row = (row..add(0.0));
    x = x + 1;
  }
    m = ((m..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    y = y + 1;
  }
  return m;
}

List<List<double>> pad_edge(List<List<double>> img, int pad) {
  int h = img.length;
  int w = img[0].length;
  List<List<double>> out = zeros(h + pad * 2, w + pad * 2);
  int y = 0;
  while (y < h + pad * 2) {
    int x = 0;
    while (x < w + pad * 2) {
    int sy = y - pad;
    if (sy < 0) {
    sy = 0;
  }
    if (sy >= h) {
    sy = h - 1;
  }
    int sx = x - pad;
    if (sx < 0) {
    sx = 0;
  }
    if (sx >= w) {
    sx = w - 1;
  }
    while (out[y]!.length <= x) { out[y]!.add(0); } out[y]![x] = img[sy][sx];
    x = x + 1;
  }
    y = y + 1;
  }
  return out;
}

List<List<double>> img_convolve(List<List<double>> img, List<List<int>> kernel) {
  int h = img.length;
  int w = img[0].length;
  int k = kernel.length;
  int pad = k ~/ 2;
  List<List<double>> padded = pad_edge(img, pad);
  List<List<double>> out = zeros(h, w);
  int y = 0;
  while (y < h) {
    int x = 0;
    while (x < w) {
    double sum = 0.0;
    int i = 0;
    while (i < k) {
    int j = 0;
    while (j < k) {
    sum = sum + padded[y + i][x + j] * (kernel[i][j].toDouble());
    j = j + 1;
  }
    i = i + 1;
  }
    while (out[y]!.length <= x) { out[y]!.add(0); } out[y]![x] = sum;
    x = x + 1;
  }
    y = y + 1;
  }
  return out;
}

List<List<double>> abs_matrix(List<List<double>> mat) {
  int h = mat.length;
  int w = mat[0].length;
  List<List<double>> out = zeros(h, w);
  int y = 0;
  while (y < h) {
    int x = 0;
    while (x < w) {
    double v = mat[y][x];
    if (v < 0.0) {
    while (out[y]!.length <= x) { out[y]!.add(0); } out[y]![x] = -v;
  } else {
    while (out[y]!.length <= x) { out[y]!.add(0); } out[y]![x] = v;
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return out;
}

double max_matrix(List<List<double>> mat) {
  double max_val = mat[0][0];
  int y = 0;
  while (y < mat.length) {
    int x = 0;
    while (x < mat[0].length) {
    if (mat[y][x] > max_val) {
    max_val = mat[y][x];
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return max_val;
}

List<List<double>> scale_matrix(List<List<double>> mat, double factor) {
  int h = mat.length;
  int w = mat[0].length;
  List<List<double>> out = zeros(h, w);
  int y = 0;
  while (y < h) {
    int x = 0;
    while (x < w) {
    while (out[y]!.length <= x) { out[y]!.add(0); } out[y]![x] = mat[y][x] * factor;
    x = x + 1;
  }
    y = y + 1;
  }
  return out;
}

List<List<List<double>>> sobel_filter(List<List<int>> image) {
  int h = image.length;
  int w = image[0].length;
  List<List<double>> img = <List<double>>[];
  int y0 = 0;
  while (y0 < h) {
    List<double> row = <double>[];
    int x0 = 0;
    while (x0 < w) {
    row = (row..add(image[y0][x0].toDouble()));
    x0 = x0 + 1;
  }
    img = ((img..add(row)) as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    y0 = y0 + 1;
  }
  List<List<int>> kernel_x = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
  List<List<int>> kernel_y = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]];
  List<List<double>> dst_x = abs_matrix(img_convolve(img, kernel_x));
  List<List<double>> dst_y = abs_matrix(img_convolve(img, kernel_y));
  double max_x = max_matrix(dst_x);
  double max_y = max_matrix(dst_y);
  dst_x = scale_matrix(dst_x, 255.0 / max_x);
  dst_y = scale_matrix(dst_y, 255.0 / max_y);
  List<List<double>> mag = zeros(h, w);
  List<List<double>> theta = zeros(h, w);
  int y = 0;
  while (y < h) {
    int x = 0;
    while (x < w) {
    double gx = dst_x[y][x];
    double gy = dst_y[y][x];
    while (mag[y]!.length <= x) { mag[y]!.add(0); } mag[y]![x] = sqrtApprox(gx * gx + gy * gy);
    while (theta[y]!.length <= x) { theta[y]!.add(0); } theta[y]![x] = atan2Approx(gy, gx);
    x = x + 1;
  }
    y = y + 1;
  }
  double max_m = max_matrix(mag);
  mag = scale_matrix(mag, 255.0 / max_m);
  return [mag, theta];
}

void print_matrix_int(List<List<double>> mat) {
  int y = 0;
  while (y < mat.length) {
    String line = "";
    int x = 0;
    while (x < mat[y].length) {
    line = line + _str((mat[y][x]).toInt());
    if (x < mat[y].length - 1) {
    line = line + " ";
  }
    x = x + 1;
  }
    print(line);
    y = y + 1;
  }
}

void print_matrix_float(List<List<double>> mat) {
  int y = 0;
  while (y < mat.length) {
    String line = "";
    int x = 0;
    while (x < mat[y].length) {
    line = line + _str(mat[y][x]);
    if (x < mat[y].length - 1) {
    line = line + " ";
  }
    x = x + 1;
  }
    print(line);
    y = y + 1;
  }
}

void _main() {
  List<List<int>> img = [[10, 10, 10, 10, 10], [10, 50, 50, 50, 10], [10, 50, 80, 50, 10], [10, 50, 50, 50, 10], [10, 10, 10, 10, 10]];
  List<List<List<double>>> res = sobel_filter(img);
  List<List<double>> mag = res[0];
  List<List<double>> theta = res[1];
  print_matrix_int(mag);
  print_matrix_float(theta);
}

void _start() {
  _main();
}

void main() => _start();
