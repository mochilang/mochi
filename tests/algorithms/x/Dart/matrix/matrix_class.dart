// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Matrix {
  List<List<double>> data;
  int rows;
  int cols;
  Matrix({required this.data, required this.rows, required this.cols});
}

Matrix make_matrix(List<List<double>> values) {
  int r = values.length;
  if (r == 0) {
    return Matrix(data: [], rows: 0, cols: 0);
  }
  int c = values[0].length;
  int i = 0;
  while (i < r) {
    if (values[i].length != c) {
    return Matrix(data: [], rows: 0, cols: 0);
  }
    i = i + 1;
  }
  return Matrix(data: values, rows: r, cols: c);
}

List<List<double>> matrix_columns(Matrix m) {
  List<List<double>> cols = <List<double>>[];
  int j = 0;
  while (j < m.cols) {
    List<double> col = <double>[];
    int i = 0;
    while (i < m.rows) {
    col = [...col, m.data[i][j]];
    i = i + 1;
  }
    cols = ([...cols, col] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    j = j + 1;
  }
  return cols;
}

Matrix matrix_identity(Matrix m) {
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m.cols) {
    double v = (i == j ? 1.0 : 0.0);
    row = [...row, v];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: m.rows, cols: m.cols);
}

double matrix_minor(Matrix m, int r, int c) {
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    if (i != r) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m.cols) {
    if (j != c) {
    row = [...row, m.data[i][j]];
  }
    j = j + 1;
  };
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  }
    i = i + 1;
  }
  Matrix sub = Matrix(data: vals, rows: m.rows - 1, cols: m.cols - 1);
  return matrix_determinant(sub);
}

double matrix_cofactor(Matrix m, int r, int c) {
  double minor = matrix_minor(m, r, c);
  if ((r + c) % 2 == 0) {
    return minor;
  }
  return -1.0 * minor;
}

Matrix matrix_minors(Matrix m) {
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m.cols) {
    row = [...row, matrix_minor(m, i, j)];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: m.rows, cols: m.cols);
}

Matrix matrix_cofactors(Matrix m) {
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m.cols) {
    row = [...row, matrix_cofactor(m, i, j)];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: m.rows, cols: m.cols);
}

double matrix_determinant(Matrix m) {
  if (m.rows != m.cols) {
    return 0.0;
  }
  if (m.rows == 0) {
    return 0.0;
  }
  if (m.rows == 1) {
    return m.data[0][0];
  }
  if (m.rows == 2) {
    return m.data[0][0] * m.data[1][1] - m.data[0][1] * m.data[1][0];
  }
  double sum = 0.0;
  int j = 0;
  while (j < m.cols) {
    sum = sum + m.data[0][j] * matrix_cofactor(m, 0, j);
    j = j + 1;
  }
  return sum;
}

bool matrix_is_invertible(Matrix m) {
  return matrix_determinant(m) != 0.0;
}

Matrix matrix_adjugate(Matrix m) {
  Matrix cof = matrix_cofactors(m);
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m.cols) {
    row = [...row, cof.data[j][i]];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: m.rows, cols: m.cols);
}

Matrix matrix_inverse(Matrix m) {
  double det = matrix_determinant(m);
  if (det == 0.0) {
    return Matrix(data: [], rows: 0, cols: 0);
  }
  Matrix adj = matrix_adjugate(m);
  return matrix_mul_scalar(adj, 1.0 / det);
}

Matrix matrix_add_row(Matrix m, List<double> row) {
  List<List<double>> newData = m.data;
  newData = ([...newData, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
  return Matrix(data: newData, rows: m.rows + 1, cols: m.cols);
}

Matrix matrix_add_column(Matrix m, List<double> col) {
  List<List<double>> newData = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    newData = ([...newData, [...m.data[i], col[i]]] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: newData, rows: m.rows, cols: m.cols + 1);
}

Matrix matrix_mul_scalar(Matrix m, double s) {
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < m.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < m.cols) {
    row = [...row, m.data[i][j] * s];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: m.rows, cols: m.cols);
}

Matrix matrix_neg(Matrix m) {
  return matrix_mul_scalar(m, -1.0);
}

Matrix matrix_add(Matrix a, Matrix b) {
  if (a.rows != b.rows || a.cols != b.cols) {
    return Matrix(data: [], rows: 0, cols: 0);
  }
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < a.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < a.cols) {
    row = [...row, a.data[i][j] + b.data[i][j]];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: a.rows, cols: a.cols);
}

Matrix matrix_sub(Matrix a, Matrix b) {
  if (a.rows != b.rows || a.cols != b.cols) {
    return Matrix(data: [], rows: 0, cols: 0);
  }
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < a.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < a.cols) {
    row = [...row, a.data[i][j] - b.data[i][j]];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: a.rows, cols: a.cols);
}

double matrix_dot(List<double> row, List<double> col) {
  double sum = 0.0;
  int i = 0;
  while (i < row.length) {
    sum = sum + row[i] * col[i];
    i = i + 1;
  }
  return sum;
}

Matrix matrix_mul(Matrix a, Matrix b) {
  if (a.cols != b.rows) {
    return Matrix(data: [], rows: 0, cols: 0);
  }
  List<List<double>> bcols = matrix_columns(b);
  List<List<double>> vals = <List<double>>[];
  int i = 0;
  while (i < a.rows) {
    List<double> row = <double>[];
    int j = 0;
    while (j < b.cols) {
    row = [...row, matrix_dot(a.data[i], bcols[j])];
    j = j + 1;
  }
    vals = ([...vals, row] as List).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return Matrix(data: vals, rows: a.rows, cols: b.cols);
}

Matrix matrix_pow(Matrix m, int p) {
  if (p == 0) {
    return matrix_identity(m);
  }
  if (p < 0) {
    if (matrix_is_invertible(m)) {
    return matrix_pow(matrix_inverse(m), -p);
  };
    return Matrix(data: [], rows: 0, cols: 0);
  }
  Matrix result = m;
  int i = 1;
  while (i < p) {
    result = matrix_mul(result, m);
    i = i + 1;
  }
  return result;
}

String matrix_to_string(Matrix m) {
  if (m.rows == 0) {
    return "[]";
  }
  String s = "[";
  int i = 0;
  while (i < m.rows) {
    s = s + "[";
    int j = 0;
    while (j < m.cols) {
    s = s + (m.data[i][j]).toString();
    if (j < m.cols - 1) {
    s = s + " ";
  }
    j = j + 1;
  }
    s = s + "]";
    if (i < m.rows - 1) {
    s = s + "\n ";
  }
    i = i + 1;
  }
  s = s + "]";
  return s;
}

void _main() {
  Matrix m = make_matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]);
  print(matrix_to_string(m));
  print((matrix_columns(m)).toString());
  print((m.rows).toString() + "," + (m.cols).toString());
  print((matrix_is_invertible(m)).toString());
  print(matrix_to_string(matrix_identity(m)));
  print((matrix_determinant(m)).toString());
  print(matrix_to_string(matrix_minors(m)));
  print(matrix_to_string(matrix_cofactors(m)));
  print(matrix_to_string(matrix_adjugate(m)));
  Matrix m2 = matrix_mul_scalar(m, 3.0);
  print(matrix_to_string(m2));
  print(matrix_to_string(matrix_add(m, m2)));
  print(matrix_to_string(matrix_sub(m, m2)));
  print(matrix_to_string(matrix_pow(m, 3)));
  Matrix m3 = matrix_add_row(m, [10.0, 11.0, 12.0]);
  print(matrix_to_string(m3));
  Matrix m4 = matrix_add_column(m2, [8.0, 16.0, 32.0]);
  print(matrix_to_string(matrix_mul(m3, m4)));
}

void _start() {
  _main();
}

void main() => _start();
