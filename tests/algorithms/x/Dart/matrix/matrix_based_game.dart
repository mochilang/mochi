// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Coord {
  int x;
  int y;
  Coord({required this.x, required this.y});
}

class PlayResult {
  List<List<String>> matrix;
  int score;
  PlayResult({required this.matrix, required this.score});
}

bool is_alnum(String ch) {
  return ch.compareTo("0") >= 0 && ch.compareTo("9") <= 0 || ch.compareTo("A") >= 0 && ch.compareTo("Z") <= 0 || ch.compareTo("a") >= 0 && ch.compareTo("z") <= 0;
}

int to_int(String token) {
  int res = 0;
  int i = 0;
  while (i < token.length) {
    res = res * 10 + ((_substr(token, i, i + 1)).codeUnitAt(0));
    i = i + 1;
  }
  return res;
}

List<String> split(String s, String sep) {
  List<String> res = <String>[];
  String current = "";
  int i = 0;
  while (i < s.length) {
    String ch = _substr(s, i, i + 1);
    if (ch == sep) {
    res = [...res, current];
    current = "";
  } else {
    current = current + ch;
  }
    i = i + 1;
  }
  res = [...res, current];
  return res;
}

List<Coord> parse_moves(String input_str) {
  dynamic pairs = input_str.split(",");
  List<Coord> moves = <Coord>[];
  int i = 0;
  while (i < pairs.length) {
    dynamic pair = pairs[i];
    List<String> numbers = <String>[];
    String _num = "";
    int j = 0;
    while (j < pair.length) {
    String ch = _substr(pair, j, j + 1);
    if (ch == " ") {
    if (_num != "") {
    numbers = [...numbers, _num];
    _num = "";
  };
  } else {
    _num = _num + ch;
  }
    j = j + 1;
  }
    if (_num != "") {
    numbers = [...numbers, _num];
  }
    if (numbers.length != 2) {
    throw Exception("Each move must have exactly two numbers.");
  }
    int x = to_int(numbers[0]);
    int y = to_int(numbers[1]);
    moves = [...moves, Coord(x: x, y: y)];
    i = i + 1;
  }
  return moves;
}

void validate_matrix_size(int size) {
  if (size <= 0) {
    throw Exception("Matrix size must be a positive integer.");
  }
}

void validate_matrix_content(List<String> matrix, int size) {
  if (matrix.length != size) {
    throw Exception("The matrix dont match with size.");
  }
  int i = 0;
  while (i < size) {
    String row = matrix[i];
    if (row.length != size) {
    throw Exception("Each row in the matrix must have exactly " + (size).toString() + " characters.");
  }
    int j = 0;
    while (j < size) {
    String ch = _substr(row, j, j + 1);
    if (!is_alnum(ch)) {
    throw Exception("Matrix rows can only contain letters and numbers.");
  }
    j = j + 1;
  }
    i = i + 1;
  }
}

void validate_moves(List<Coord> moves, int size) {
  int i = 0;
  while (i < moves.length) {
    Coord mv = moves[i];
    if (mv.x < 0 || mv.x >= size || mv.y < 0 || mv.y >= size) {
    throw Exception("Move is out of bounds for a matrix.");
  }
    i = i + 1;
  }
}

bool contains(List<Coord> pos, int r, int c) {
  int i = 0;
  while (i < pos.length) {
    Coord p = pos[i];
    if (p.x == r && p.y == c) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

List<Coord> find_repeat(List<List<String>> matrix_g, int row, int column, int size) {
  column = size - 1 - column;
  List<Coord> visited = <Coord>[];
  List<Coord> repeated = <Coord>[];
  String color = matrix_g[column][row];
  if (color == "-") {
    return repeated;
  }
  List<Coord> stack = [Coord(x: column, y: row)];
  while (stack.length > 0) {
    int idx = stack.length - 1;
    Coord pos = stack[idx];
    stack = stack.sublist(0, idx);
    if (pos.x < 0 || pos.x >= size || pos.y < 0 || pos.y >= size) {
    continue;
  }
    if (contains(visited, pos.x, pos.y)) {
    continue;
  }
    visited = [...visited, pos];
    if (matrix_g[pos.x][pos.y] == color) {
    repeated = [...repeated, pos];
    stack = [...stack, Coord(x: pos.x - 1, y: pos.y)];
    stack = [...stack, Coord(x: pos.x + 1, y: pos.y)];
    stack = [...stack, Coord(x: pos.x, y: pos.y - 1)];
    stack = [...stack, Coord(x: pos.x, y: pos.y + 1)];
  }
  }
  return repeated;
}

int increment_score(int count) {
  return count * (count + 1) ~/ 2;
}

List<List<String>> move_x(List<List<String>> matrix_g, int column, int size) {
  List<String> new_list = <String>[];
  int row = 0;
  while (row < size) {
    String val = matrix_g[row][column];
    if (val != "-") {
    new_list = [...new_list, val];
  } else {
    new_list = List<String>.from([...[val], ...new_list]);
  }
    row = row + 1;
  }
  row = 0;
  while (row < size) {
    while (matrix_g[row]!.length <= column) { matrix_g[row]!.add(""); } matrix_g[row]![column] = new_list[row];
    row = row + 1;
  }
  return matrix_g;
}

List<List<String>> move_y(List<List<String>> matrix_g, int size) {
  List<int> empty_cols = <int>[];
  int column = size - 1;
  while (column >= 0) {
    int row = 0;
    bool all_empty = true;
    while (row < size) {
    if (matrix_g[row][column] != "-") {
    all_empty = false;
    break;
  }
    row = row + 1;
  }
    if (all_empty) {
    empty_cols = [...empty_cols, column];
  }
    column = column - 1;
  }
  int i = 0;
  while (i < empty_cols.length) {
    int col = empty_cols[i];
    int c = col + 1;
    while (c < size) {
    int r = 0;
    while (r < size) {
    while (matrix_g[r]!.length <= c - 1) { matrix_g[r]!.add(""); } matrix_g[r]![c - 1] = matrix_g[r][c];
    r = r + 1;
  }
    c = c + 1;
  }
    int r = 0;
    while (r < size) {
    while (matrix_g[r]!.length <= size - 1) { matrix_g[r]!.add(""); } matrix_g[r]![size - 1] = "-";
    r = r + 1;
  }
    i = i + 1;
  }
  return matrix_g;
}

PlayResult play(List<List<String>> matrix_g, int pos_x, int pos_y, int size) {
  List<Coord> same_colors = find_repeat(matrix_g, pos_x, pos_y, size);
  if (same_colors.length != 0) {
    int i = 0;
    while (i < same_colors.length) {
    Coord p = same_colors[i];
    while (matrix_g[p.x]!.length <= p.y) { matrix_g[p.x]!.add(""); } matrix_g[p.x]![p.y] = "-";
    i = i + 1;
  };
    int column = 0;
    while (column < size) {
    matrix_g = move_x(matrix_g, column, size);
    column = column + 1;
  };
    matrix_g = move_y(matrix_g, size);
  }
  int sc = increment_score(same_colors.length);
  return PlayResult(matrix: matrix_g, score: sc);
}

List<List<String>> build_matrix(List<String> matrix) {
  List<List<String>> res = <List<String>>[];
  int i = 0;
  while (i < matrix.length) {
    String row = matrix[i];
    List<String> row_list = <String>[];
    int j = 0;
    while (j < row.length) {
    row_list = [...row_list, _substr(row, j, j + 1)];
    j = j + 1;
  }
    res = ([...res, row_list] as List).map((e) => (List<String>.from(e) as List<String>)).toList();
    i = i + 1;
  }
  return res;
}

int process_game(int size, List<String> matrix, List<Coord> moves) {
  List<List<String>> game_matrix = build_matrix(matrix);
  int total = 0;
  int i = 0;
  while (i < moves.length) {
    Coord mv = moves[i];
    PlayResult res = play(game_matrix, mv.x, mv.y, size);
    game_matrix = res.matrix;
    total = total + res.score;
    i = i + 1;
  }
  return total;
}

void _main() {
  int size = 4;
  List<String> matrix = ["RRBG", "RBBG", "YYGG", "XYGG"];
  List<Coord> moves = parse_moves("0 1,1 1");
  validate_matrix_size(size);
  validate_matrix_content(matrix, size);
  validate_moves(moves, size);
  int score = process_game(size, matrix, moves);
  print((score).toString());
}

void _start() {
  _main();
}

void main() => _start();
