// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Edge {
  int u;
  int v;
  int w;
  Edge({required this.u, required this.v, required this.w});
}

class Graph {
  List<Edge> edges;
  int num_nodes;
  Graph({required this.edges, required this.num_nodes});
}

class DS {
  List<int> parent;
  List<int> rank;
  DS({required this.parent, required this.rank});
}

class FindResult {
  DS ds;
  int root;
  FindResult({required this.ds, required this.root});
}

Graph new_graph() {
  return Graph(edges: [], num_nodes: 0);
}

Graph add_edge(Graph g, int u, int v, int w) {
  List<Edge> es = g.edges;
  es = [...es, Edge(u: u, v: v, w: w)];
  int n = g.num_nodes;
  if (u > n) {
    n = u;
  }
  if (v > n) {
    n = v;
  }
  return Graph(edges: es, num_nodes: n);
}

DS make_ds(int n) {
  List<int> parent = <int>[];
  List<int> rank = <int>[];
  int i = 0;
  while (i <= n) {
    parent = [...parent, i];
    rank = [...rank, 0];
    i = i + 1;
  }
  return DS(parent: parent, rank: rank);
}

FindResult find_set(DS ds, int x) {
  if (ds.parent[x] == x) {
    return FindResult(ds: ds, root: x);
  }
  FindResult res = find_set(ds, ds.parent[x]);
  List<int> p = res.ds.parent;
  while (p.length <= x) { p.add(0); } p[x] = res.root;
  return FindResult(ds: DS(parent: p, rank: res.ds.rank), root: res.root);
}

DS union_set(DS ds, int x, int y) {
  FindResult fx = find_set(ds, x);
  DS ds1 = fx.ds;
  int x_root = fx.root;
  FindResult fy = find_set(ds1, y);
  DS ds2 = fy.ds;
  int y_root = fy.root;
  if (x_root == y_root) {
    return ds2;
  }
  List<int> p = ds2.parent;
  List<int> r = ds2.rank;
  if (r[x_root] > r[y_root]) {
    while (p.length <= y_root) { p.add(0); } p[y_root] = x_root;
  } else {
    while (p.length <= x_root) { p.add(0); } p[x_root] = y_root;
    if (r[x_root] == r[y_root]) {
    while (r.length <= y_root) { r.add(0); } r[y_root] = r[y_root] + 1;
  };
  }
  return DS(parent: p, rank: r);
}

List<Edge> sort_edges(List<Edge> edges) {
  List<Edge> arr = edges;
  int i = 1;
  while (i < arr.length) {
    Edge key = arr[i];
    int j = i - 1;
    while (j >= 0) {
    Edge temp = arr[j];
    if (temp.w > key.w || temp.w == key.w && (temp.u > key.u || temp.u == key.u && temp.v > key.v)) {
    while (arr.length <= j + 1) { arr.add(null as dynamic); } arr[j + 1] = temp;
    j = j - 1;
  } else {
    break;
  }
  }
    while (arr.length <= j + 1) { arr.add(null as dynamic); } arr[j + 1] = key;
    i = i + 1;
  }
  return arr;
}

Graph kruskal(Graph g) {
  List<Edge> edges = sort_edges(g.edges);
  DS ds = make_ds(g.num_nodes);
  List<Edge> mst_edges = <Edge>[];
  int i = 0;
  int added = 0;
  while (added < g.num_nodes - 1 && i < edges.length) {
    Edge e = edges[i];
    i = i + 1;
    FindResult fu = find_set(ds, e.u);
    ds = fu.ds;
    int ru = fu.root;
    FindResult fv = find_set(ds, e.v);
    ds = fv.ds;
    int rv = fv.root;
    if (ru != rv) {
    mst_edges = [...mst_edges, e];
    added = added + 1;
    ds = union_set(ds, ru, rv);
  }
  }
  return Graph(edges: mst_edges, num_nodes: g.num_nodes);
}

void print_mst(Graph g) {
  List<Edge> es = sort_edges(g.edges);
  for (var e in es) {
    print((e.u).toString() + "-" + (e.v).toString() + ":" + (e.w).toString());
  }
}

void _main() {
  Graph g = new_graph();
  g = add_edge(g, 1, 2, 1);
  g = add_edge(g, 2, 3, 2);
  g = add_edge(g, 3, 4, 1);
  g = add_edge(g, 3, 5, 100);
  g = add_edge(g, 4, 5, 5);
  Graph mst = kruskal(g);
  print_mst(mst);
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
