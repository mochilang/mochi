// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Pos {
  int y;
  int x;
  Pos({required this.y, required this.x});
}

class Node {
  Pos pos;
  int g_cost;
  double h_cost;
  double f_cost;
  List<Pos> path;
  Node({required this.pos, required this.g_cost, required this.h_cost, required this.f_cost, required this.path});
}

int HEURISTIC = 0;
List<List<int>> grid = [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]];
List<List<int>> delta = [[-1, 0], [0, -1], [1, 0], [0, 1]];
int abs(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

double sqrtApprox(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x;
  int i = 0;
  while (i < 10) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double heuristic(Pos a, Pos b) {
  int dy = a.y - b.y;
  int dx = a.x - b.x;
  if (HEURISTIC == 1) {
    return (dy.abs() + dx.abs()).toDouble();
  }
  double dyf = (dy).toDouble();
  double dxf = (dx).toDouble();
  return sqrtApprox(dyf * dyf + dxf * dxf);
}

bool pos_equal(Pos a, Pos b) {
  return a.y == b.y && a.x == b.x;
}

bool contains_pos(List<Pos> lst, Pos p) {
  int i = 0;
  while (i < lst.length) {
    if (pos_equal(lst[i], p)) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

int open_index_of_pos(List<Node> open, Pos p) {
  int i = 0;
  while (i < open.length) {
    if (pos_equal(open[i].pos, p)) {
    return i;
  }
    i = i + 1;
  }
  return 0 - 1;
}

List<Node> remove_node_at(List<Node> nodes, int idx) {
  List<Node> res = <Node>[];
  int i = 0;
  while (i < nodes.length) {
    if (i != idx) {
    res = [...res, nodes[i]];
  }
    i = i + 1;
  }
  return res;
}

List<Pos> append_pos_list(List<Pos> path, Pos p) {
  List<Pos> res = <Pos>[];
  int i = 0;
  while (i < path.length) {
    res = [...res, path[i]];
    i = i + 1;
  }
  res = [...res, p];
  return res;
}

List<Pos> reverse_pos_list(List<Pos> lst) {
  List<Pos> res = <Pos>[];
  int i = lst.length - 1;
  while (i >= 0) {
    res = [...res, lst[i]];
    i = i - 1;
  }
  return res;
}

List<Pos> concat_pos_lists(List<Pos> a, List<Pos> b) {
  List<Pos> res = <Pos>[];
  int i = 0;
  while (i < a.length) {
    res = [...res, a[i]];
    i = i + 1;
  }
  int j = 0;
  while (j < b.length) {
    res = [...res, b[j]];
    j = j + 1;
  }
  return res;
}

List<Pos> get_successors(Pos p) {
  List<Pos> res = <Pos>[];
  int i = 0;
  while (i < delta.length) {
    int nx = p.x + delta[i][1];
    int ny = p.y + delta[i][0];
    if (nx >= 0 && ny >= 0 && nx < grid[0].length && ny < grid.length) {
    if (grid[ny][nx] == 0) {
    res = [...res, Pos(y: ny, x: nx)];
  };
  }
    i = i + 1;
  }
  return res;
}

int find_lowest_f(List<Node> open) {
  int best = 0;
  int i = 1;
  while (i < open.length) {
    if (open[i].f_cost < open[best].f_cost) {
    best = i;
  }
    i = i + 1;
  }
  return best;
}

List<Pos> astar(Pos start, Pos goal) {
  double h0 = heuristic(start, goal);
  List<Node> open = [Node(pos: start, g_cost: 0, h_cost: h0, f_cost: h0, path: [start])];
  List<Pos> closed = <Pos>[];
  while (open.length > 0) {
    int idx = find_lowest_f(open);
    Node current = open[idx];
    open = remove_node_at(open, idx);
    if (pos_equal(current.pos, goal)) {
    return current.path;
  }
    closed = [...closed, current.pos];
    List<Pos> succ = get_successors(current.pos);
    int i = 0;
    while (i < succ.length) {
    Pos pos = succ[i];
    if (contains_pos(closed, pos)) {
    i = i + 1;
    continue;
  }
    int tentative_g = current.g_cost + 1;
    int idx_open = open_index_of_pos(open, pos);
    if (idx_open == 0 - 1 || tentative_g < open[idx_open].g_cost) {
    List<Pos> new_path = append_pos_list(current.path, pos);
    double h = heuristic(pos, goal);
    double f = ((tentative_g).toDouble()) + h;
    if (idx_open != 0 - 1) {
    open = remove_node_at(open, idx_open);
  };
    open = [...open, Node(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)];
  }
    i = i + 1;
  }
  }
  return [start];
}

List<Pos> combine_paths(Node fwd, Node bwd) {
  List<Pos> bwd_copy = <Pos>[];
  int i = 0;
  while (i < bwd.path.length - 1) {
    bwd_copy = [...bwd_copy, bwd.path[i]];
    i = i + 1;
  }
  bwd_copy = reverse_pos_list(bwd_copy);
  return concat_pos_lists(fwd.path, bwd_copy);
}

List<Pos> bidirectional_astar(Pos start, Pos goal) {
  double hf = heuristic(start, goal);
  double hb = heuristic(goal, start);
  List<Node> open_f = [Node(pos: start, g_cost: 0, h_cost: hf, f_cost: hf, path: [start])];
  List<Node> open_b = [Node(pos: goal, g_cost: 0, h_cost: hb, f_cost: hb, path: [goal])];
  List<Pos> closed_f = <Pos>[];
  List<Pos> closed_b = <Pos>[];
  while (open_f.length > 0 && open_b.length > 0) {
    int idx_f = find_lowest_f(open_f);
    Node current_f = open_f[idx_f];
    open_f = remove_node_at(open_f, idx_f);
    int idx_b = find_lowest_f(open_b);
    Node current_b = open_b[idx_b];
    open_b = remove_node_at(open_b, idx_b);
    if (pos_equal(current_f.pos, current_b.pos)) {
    return combine_paths(current_f, current_b);
  }
    closed_f = [...closed_f, current_f.pos];
    closed_b = [...closed_b, current_b.pos];
    List<Pos> succ_f = get_successors(current_f.pos);
    int i = 0;
    while (i < succ_f.length) {
    Pos pos = succ_f[i];
    if (contains_pos(closed_f, pos)) {
    i = i + 1;
    continue;
  }
    int tentative_g = current_f.g_cost + 1;
    double h = heuristic(pos, current_b.pos);
    double f = ((tentative_g).toDouble()) + h;
    int idx_open = open_index_of_pos(open_f, pos);
    if (idx_open == 0 - 1 || tentative_g < open_f[idx_open].g_cost) {
    List<Pos> new_path = append_pos_list(current_f.path, pos);
    if (idx_open != 0 - 1) {
    open_f = remove_node_at(open_f, idx_open);
  };
    open_f = [...open_f, Node(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)];
  }
    i = i + 1;
  }
    List<Pos> succ_b = get_successors(current_b.pos);
    i = 0;
    while (i < succ_b.length) {
    Pos pos = succ_b[i];
    if (contains_pos(closed_b, pos)) {
    i = i + 1;
    continue;
  }
    int tentative_g = current_b.g_cost + 1;
    double h = heuristic(pos, current_f.pos);
    double f = ((tentative_g).toDouble()) + h;
    int idx_open = open_index_of_pos(open_b, pos);
    if (idx_open == 0 - 1 || tentative_g < open_b[idx_open].g_cost) {
    List<Pos> new_path = append_pos_list(current_b.path, pos);
    if (idx_open != 0 - 1) {
    open_b = remove_node_at(open_b, idx_open);
  };
    open_b = [...open_b, Node(pos: pos, g_cost: tentative_g, h_cost: h, f_cost: f, path: new_path)];
  }
    i = i + 1;
  }
  }
  return [start];
}

String path_to_string(List<Pos> path) {
  if (path.length == 0) {
    return "[]";
  }
  String s = "[(" + _str(path[0].y) + ", " + _str(path[0].x) + ")";
  int i = 1;
  while (i < path.length) {
    s = s + ", (" + _str(path[i].y) + ", " + _str(path[i].x) + ")";
    i = i + 1;
  }
  s = s + "]";
  return s;
}

Pos start = Pos(y: 0, x: 0);
Pos goal = Pos(y: grid.length - 1, x: grid[0].length - 1);
List<Pos> path1 = astar(start, goal);
List<Pos> path2 = bidirectional_astar(start, goal);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print(path_to_string(path1));
  print(path_to_string(path2));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
