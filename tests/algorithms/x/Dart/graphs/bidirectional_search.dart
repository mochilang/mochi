// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class ExpandResult {
  List<int> queue;
  int head;
  Map<int, int> parents;
  Map<int, bool> visited;
  int intersection;
  bool found;
  ExpandResult({required this.queue, required this.head, required this.parents, required this.visited, required this.intersection, required this.found});
}

class SearchResult {
  List<int> path;
  bool ok;
  SearchResult({required this.path, required this.ok});
}

ExpandResult expand_search(Map<int, List<int>> graph, List<int> queue, int head, Map<int, int> parents, Map<int, bool> visited, Map<int, bool> opposite_visited) {
  if (head >= queue.length) {
    return ExpandResult(queue: queue, head: head, parents: parents, visited: visited, intersection: 0 - 1, found: false);
  }
  int current = queue[head];
  head = head + 1;
  List<int> neighbors = graph[current]!;
  List<int> q = queue;
  Map<int, int> p = parents;
  Map<int, bool> v = visited;
  int i = 0;
  while (i < neighbors.length) {
    int neighbor = neighbors[i];
    if ((v[neighbor] ?? false)) {
    i = i + 1;
    continue;
  }
    v[neighbor] = true;
    p[neighbor] = current;
    q = [...q, neighbor];
    if ((opposite_visited[neighbor] ?? false)) {
    return ExpandResult(queue: q, head: head, parents: p, visited: v, intersection: neighbor, found: true);
  }
    i = i + 1;
  }
  return ExpandResult(queue: q, head: head, parents: p, visited: v, intersection: 0 - 1, found: false);
}

List<int> construct_path(int current, Map<int, int> parents) {
  List<int> path = <int>[];
  int node = current;
  while (node != 0 - 1) {
    path = [...path, node];
    node = parents[node]!;
  }
  return path;
}

List<int> reverse_list(List<int> xs) {
  List<int> res = <int>[];
  int i = xs.length;
  while (i > 0) {
    i = i - 1;
    res = [...res, xs[i]];
  }
  return res;
}

SearchResult bidirectional_search(Map<int, List<int>> g, int start, int goal) {
  if (start == goal) {
    return SearchResult(path: [start], ok: true);
  }
  Map<int, int> forward_parents = <int, int>{};
  forward_parents[start] = 0 - 1;
  Map<int, int> backward_parents = <int, int>{};
  backward_parents[goal] = 0 - 1;
  Map<int, bool> forward_visited = <int, bool>{};
  forward_visited[start] = true;
  Map<int, bool> backward_visited = <int, bool>{};
  backward_visited[goal] = true;
  List<int> forward_queue = [start];
  List<int> backward_queue = [goal];
  int forward_head = 0;
  int backward_head = 0;
  int intersection = 0 - 1;
  while (forward_head < forward_queue.length && backward_head < backward_queue.length && intersection == 0 - 1) {
    ExpandResult res = expand_search(g, forward_queue, forward_head, forward_parents, forward_visited, backward_visited);
    forward_queue = res.queue;
    forward_head = res.head;
    forward_parents = res.parents;
    forward_visited = res.visited;
    if (res.found) {
    intersection = res.intersection;
    break;
  }
    res = expand_search(g, backward_queue, backward_head, backward_parents, backward_visited, forward_visited);
    backward_queue = res.queue;
    backward_head = res.head;
    backward_parents = res.parents;
    backward_visited = res.visited;
    if (res.found) {
    intersection = res.intersection;
    break;
  }
  }
  if (intersection == 0 - 1) {
    return SearchResult(path: [], ok: false);
  }
  List<int> forward_path = construct_path(intersection, forward_parents);
  forward_path = reverse_list(forward_path);
  int back_start = backward_parents[intersection]!;
  List<int> backward_path = construct_path(back_start, backward_parents);
  List<int> result = forward_path;
  int j = 0;
  while (j < backward_path.length) {
    result = [...result, backward_path[j]];
    j = j + 1;
  }
  return SearchResult(path: result, ok: true);
}

bool is_edge(Map<int, List<int>> g, int u, int v) {
  List<int> neighbors = g[u]!;
  int i = 0;
  while (i < neighbors.length) {
    if (neighbors[i] == v) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

bool path_exists(Map<int, List<int>> g, List<int> path) {
  if (path.length == 0) {
    return false;
  }
  int i = 0;
  while (i + 1 < path.length) {
    if (!is_edge(g, path[i], path[i + 1])) {
    return false;
  }
    i = i + 1;
  }
  return true;
}

void print_path(Map<int, List<int>> g, int s, int t) {
  SearchResult res = bidirectional_search(g, s, t);
  if (res.ok && path_exists(g, res.path)) {
    print("Path from " + (s).toString() + " to " + (t).toString() + ": " + (res.path).toString());
  } else {
    print("Path from " + (s).toString() + " to " + (t).toString() + ": None");
  }
}

void _main() {
  Map<int, List<int>> graph = {0: [1, 2], 1: [0, 3, 4], 2: [0, 5, 6], 3: [1, 7], 4: [1, 8], 5: [2, 9], 6: [2, 10], 7: [3, 11], 8: [4, 11], 9: [5, 11], 10: [6, 11], 11: [7, 8, 9, 10]};
  print_path(graph, 0, 11);
  print_path(graph, 5, 5);
  Map<int, List<int>> disconnected = {0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3]};
  print_path(disconnected, 0, 3);
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
