// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Edge {
  int u;
  int v;
  int w;
  Edge({required this.u, required this.v, required this.w});
}

class Graph {
  int num_nodes;
  List<Edge> edges;
  Map<int, int> component;
  Graph({required this.num_nodes, required this.edges, required this.component});
}

class UnionResult {
  Graph graph;
  List<int> component_size;
  UnionResult({required this.graph, required this.component_size});
}

Graph new_graph(int num_nodes) {
  return Graph(num_nodes: num_nodes, edges: [], component: {});
}

Graph add_edge(Graph g, int u, int v, int w) {
  List<Edge> es = g.edges;
  es = [...es, Edge(u: u, v: v, w: w)];
  return Graph(num_nodes: g.num_nodes, edges: es, component: g.component);
}

int find_component(Graph g, int node) {
  if ((g.component[node] ?? 0) == node) {
    return node;
  }
  return find_component(g, (g.component[node] ?? 0));
}

Graph set_component(Graph g, int node) {
  if ((g.component[node] ?? 0) != node) {
    Map<int, int> comp = g.component;
    int k = 0;
    while (k < g.num_nodes) {
    comp[k] = find_component(g, k);
    k = k + 1;
  };
    g = Graph(num_nodes: g.num_nodes, edges: g.edges, component: comp);
  }
  return g;
}

UnionResult union(Graph g, List<int> component_size, int u, int v) {
  List<int> comp_size = component_size;
  Map<int, int> comp = g.component;
  if (comp_size[u] <= comp_size[v]) {
    comp[u] = v;
    while (comp_size.length <= v) { comp_size.add(0); } comp_size[v] = comp_size[v] + comp_size[u];
    g = Graph(num_nodes: g.num_nodes, edges: g.edges, component: comp);
    g = set_component(g, u);
  } else {
    comp[v] = u;
    while (comp_size.length <= u) { comp_size.add(0); } comp_size[u] = comp_size[u] + comp_size[v];
    g = Graph(num_nodes: g.num_nodes, edges: g.edges, component: comp);
    g = set_component(g, v);
  }
  return UnionResult(graph: g, component_size: comp_size);
}

List<Edge> create_empty_edges(int n) {
  List<Edge> res = <Edge>[];
  int i = 0;
  while (i < n) {
    res = [...res, Edge(u: 0 - 1, v: 0 - 1, w: 0 - 1)];
    i = i + 1;
  }
  return res;
}

int boruvka(Graph g) {
  List<int> component_size = <int>[];
  int i = 0;
  while (i < g.num_nodes) {
    component_size = [...component_size, 1];
    Map<int, int> comp = g.component;
    comp[i] = i;
    g = Graph(num_nodes: g.num_nodes, edges: g.edges, component: comp);
    i = i + 1;
  }
  int mst_weight = 0;
  int num_components = g.num_nodes;
  List<Edge> minimum_weight_edge = create_empty_edges(g.num_nodes);
  while (num_components > 1) {
    for (Edge e in g.edges) {
    int u = e.u;
    int v = e.v;
    int w = e.w;
    int u_comp = g.component[u]!;
    int v_comp = g.component[v]!;
    if (u_comp != v_comp) {
    Edge current_u = minimum_weight_edge[u_comp];
    if (current_u.u == 0 - 1 || current_u.w > w) {
    while (minimum_weight_edge.length <= u_comp) { minimum_weight_edge.add(null as dynamic); } minimum_weight_edge[u_comp] = Edge(u: u, v: v, w: w);
  };
    Edge current_v = minimum_weight_edge[v_comp];
    if (current_v.u == 0 - 1 || current_v.w > w) {
    while (minimum_weight_edge.length <= v_comp) { minimum_weight_edge.add(null as dynamic); } minimum_weight_edge[v_comp] = Edge(u: u, v: v, w: w);
  };
  }
  }
    for (Edge e in minimum_weight_edge) {
    if (e.u != 0 - 1) {
    int u = e.u;
    int v = e.v;
    int w = e.w;
    int u_comp = g.component[u]!;
    int v_comp = g.component[v]!;
    if (u_comp != v_comp) {
    mst_weight = mst_weight + w;
    UnionResult res = union(g, component_size, u_comp, v_comp);
    g = res.graph;
    component_size = res.component_size;
    print("Added edge [" + _str(u) + " - " + _str(v) + "]");
    print("Added weight: " + _str(w));
    print("");
    num_components = num_components - 1;
  };
  }
  }
    minimum_weight_edge = create_empty_edges(g.num_nodes);
  }
  print("The total weight of the minimal spanning tree is: " + _str(mst_weight));
  return mst_weight;
}

void _main() {
  Graph g = new_graph(8);
  List<List<int>> edges = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4], [3, 4, 8], [4, 5, 10], [4, 6, 6], [4, 7, 5], [5, 7, 15], [6, 7, 4]];
  for (List<int> e in edges) {
    g = add_edge(g, e[0], e[1], e[2]);
  }
  boruvka(g);
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
