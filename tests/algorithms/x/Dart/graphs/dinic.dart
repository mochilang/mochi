// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Dinic {
  int n;
  List<int> lvl;
  List<int> ptr;
  List<int> q;
  List<List<List<int>>> adj;
  Dinic({required this.n, required this.lvl, required this.ptr, required this.q, required this.adj});
}

int INF = 1000000000;
int pow2(int k) {
  int res = 1;
  int i = 0;
  while (i < k) {
    res = res * 2;
    i = i + 1;
  }
  return res;
}

int min2(int a, int b) {
  if (a < b) {
    return a;
  }
  return b;
}

Dinic new_dinic(int n) {
  List<int> lvl = <int>[];
  List<int> ptr = <int>[];
  List<int> q = <int>[];
  List<List<List<int>>> adj = <List<List<int>>>[];
  int i = 0;
  while (i < n) {
    lvl = [...lvl, 0];
    ptr = [...ptr, 0];
    q = [...q, 0];
    List<List<int>> edges = <List<int>>[];
    adj = ([...adj, edges] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e as List<int>)).toList() as List<List<int>>)).toList();
    i = i + 1;
  }
  return Dinic(n: n, lvl: lvl, ptr: ptr, q: q, adj: adj);
}

dynamic add_edge(Dinic g, int a, int b, int c, int rcap) {
  List<List<List<int>>> adj = g.adj;
  List<List<int>> list_a = adj[a];
  List<List<int>> list_b = adj[b];
  List<int> e1 = [b, list_b.length, c, 0];
  List<int> e2 = [a, list_a.length, rcap, 0];
  list_a = ([...list_a, e1] as List<dynamic>).map((e) => (e as List<int>)).toList();
  list_b = ([...list_b, e2] as List<dynamic>).map((e) => (e as List<int>)).toList();
  while (adj.length <= a) { adj.add(<List<int>>[]); } adj[a] = list_a;
  while (adj.length <= b) { adj.add(<List<int>>[]); } adj[b] = list_b;
  g.adj = adj;
}

int dfs(Dinic g, int v, int sink, int flow) {
  if (v == sink || flow == 0) {
    return flow;
  }
  List<int> ptr = g.ptr;
  int i = ptr[v];
  List<List<List<int>>> adj_all = g.adj;
  List<List<int>> adj_v = adj_all[v];
  while (i < adj_v.length) {
    List<int> e = adj_v[i];
    int to = e[0];
    if (g.lvl[to] == g.lvl[v] + 1) {
    int avail = e[2] - e[3];
    int pushed = dfs(g, to, sink, min2(flow, avail));
    if (pushed > 0) {
    while (e.length <= 3) { e.add(0); } e[3] = e[3] + pushed;
    while (adj_v.length <= i) { adj_v.add(<int>[]); } adj_v[i] = e;
    List<List<int>> adj_to = adj_all[to];
    List<int> back = adj_to[e[1]];
    while (back.length <= 3) { back.add(0); } back[3] = back[3] - pushed;
    while (adj_to.length <= e[1]) { adj_to.add(<int>[]); } adj_to[e[1]] = back;
    while (adj_all.length <= to) { adj_all.add(<List<int>>[]); } adj_all[to] = adj_to;
    while (adj_all.length <= v) { adj_all.add(<List<int>>[]); } adj_all[v] = adj_v;
    g.adj = adj_all;
    return pushed;
  };
  }
    i = i + 1;
    while (ptr.length <= v) { ptr.add(0); } ptr[v] = i;
  }
  g.ptr = ptr;
  while (adj_all.length <= v) { adj_all.add(<List<int>>[]); } adj_all[v] = adj_v;
  g.adj = adj_all;
  return 0;
}

int max_flow(Dinic g, int source, int sink) {
  int flow = 0;
  int l = 0;
  while (l < 31) {
    int threshold = pow2(30 - l);
    while (true) {
    List<int> lvl = <int>[];
    List<int> ptr = <int>[];
    int i = 0;
    while (i < g.n) {
    lvl = [...lvl, 0];
    ptr = [...ptr, 0];
    i = i + 1;
  }
    g.lvl = lvl;
    g.ptr = ptr;
    int qi = 0;
    int qe = 1;
    while (lvl.length <= source) { lvl.add(0); } lvl[source] = 1;
    g.lvl = lvl;
    List<int> q = g.q;
    while (q.length <= 0) { q.add(0); } q[0] = source;
    while (qi < qe && g.lvl[sink] == 0) {
    int v = q[qi];
    qi = qi + 1;
    List<List<int>> edges = g.adj[v];
    int j = 0;
    while (j < edges.length) {
    List<int> e = edges[j];
    int to = e[0];
    int residual = e[2] - e[3];
    List<int> lvl_inner = g.lvl;
    if (lvl_inner[to] == 0 && residual >= threshold) {
    while (q.length <= qe) { q.add(0); } q[qe] = to;
    qe = qe + 1;
    while (lvl_inner.length <= to) { lvl_inner.add(0); } lvl_inner[to] = lvl_inner[v] + 1;
    g.lvl = lvl_inner;
  }
    j = j + 1;
  }
  }
    int p = dfs(g, source, sink, INF);
    while (p > 0) {
    flow = flow + p;
    p = dfs(g, source, sink, INF);
  }
    if (g.lvl[sink] == 0) {
    break;
  }
  }
    l = l + 1;
  }
  return flow;
}

Dinic graph = new_dinic(10);
int source = 0;
int sink = 9;
int v = 1;
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  while (v < 5) {
    add_edge(graph, source, v, 1, 0);
    v = v + 1;
  }
  v = 5;
  while (v < 9) {
    add_edge(graph, v, sink, 1, 0);
    v = v + 1;
  }
  v = 1;
  while (v < 5) {
    add_edge(graph, v, v + 4, 1, 0);
    v = v + 1;
  }
  print(_str(max_flow(graph, source, sink)));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
