// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Pos {
  int y;
  int x;
  Pos({required this.y, required this.x});
}

class Node {
  int pos_x;
  int pos_y;
  int goal_x;
  int goal_y;
  int g_cost;
  int f_cost;
  List<Pos> path;
  Node({required this.pos_x, required this.pos_y, required this.goal_x, required this.goal_y, required this.g_cost, required this.f_cost, required this.path});
}

int abs(int x) {
  if (x < 0) {
    return 0 - x;
  }
  return x;
}

int manhattan(int x1, int y1, int x2, int y2) {
  return (x1 - x2).abs() + (y1 - y2).abs();
}

List<Pos> clone_path(List<Pos> p) {
  List<Pos> res = <Pos>[];
  int i = 0;
  while (i < p.length) {
    res = [...res, p[i]];
    i = i + 1;
  }
  return res;
}

Node make_node(int pos_x, int pos_y, int goal_x, int goal_y, int g_cost, List<Pos> path) {
  int f = manhattan(pos_x, pos_y, goal_x, goal_y);
  return Node(pos_x: pos_x, pos_y: pos_y, goal_x: goal_x, goal_y: goal_y, g_cost: g_cost, f_cost: f, path: path);
}

List<Pos> delta = [Pos(y: -1, x: 0), Pos(y: 0, x: -1), Pos(y: 1, x: 0), Pos(y: 0, x: 1)];
bool node_equal(Node a, Node b) {
  return a.pos_x == b.pos_x && a.pos_y == b.pos_y;
}

bool contains(List<Node> nodes, Node node) {
  int i = 0;
  while (i < nodes.length) {
    if (node_equal(nodes[i], node)) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

List<Node> sort_nodes(List<Node> nodes) {
  List<Node> arr = nodes;
  int i = 1;
  while (i < arr.length) {
    Node key_node = arr[i];
    int j = i - 1;
    while (j >= 0) {
    Node temp = arr[j];
    if (temp.f_cost > key_node.f_cost) {
    while (arr.length <= j + 1) { arr.add(null as dynamic); } arr[j + 1] = temp;
    j = j - 1;
  } else {
    break;
  }
  }
    while (arr.length <= j + 1) { arr.add(null as dynamic); } arr[j + 1] = key_node;
    i = i + 1;
  }
  return arr;
}

List<Node> get_successors(List<List<int>> grid, Node parent, Pos target) {
  List<Node> res = <Node>[];
  int i = 0;
  while (i < delta.length) {
    Pos d = delta[i];
    int pos_x = parent.pos_x + d.x;
    int pos_y = parent.pos_y + d.y;
    if (pos_x >= 0 && pos_x < grid[0].length && pos_y >= 0 && pos_y < grid.length && grid[pos_y][pos_x] == 0) {
    List<Pos> new_path = clone_path(parent.path);
    new_path = [...new_path, Pos(y: pos_y, x: pos_x)];
    res = [...res, make_node(pos_x, pos_y, target.x, target.y, parent.g_cost + 1, new_path)];
  }
    i = i + 1;
  }
  return res;
}

List<Pos> greedy_best_first(List<List<int>> grid, Pos init, Pos goal) {
  List<Pos> start_path = [init];
  Node start = make_node(init.x, init.y, goal.x, goal.y, 0, start_path);
  List<Node> open_nodes = [start];
  List<Node> closed_nodes = <Node>[];
  while (open_nodes.length > 0) {
    open_nodes = sort_nodes(open_nodes);
    Node current = open_nodes[0];
    List<Node> new_open = <Node>[];
    int idx = 1;
    while (idx < open_nodes.length) {
    new_open = [...new_open, open_nodes[idx]];
    idx = idx + 1;
  }
    open_nodes = new_open;
    if (current.pos_x == goal.x && current.pos_y == goal.y) {
    return current.path;
  }
    closed_nodes = [...closed_nodes, current];
    List<Node> successors = get_successors(grid, current, goal);
    int i = 0;
    while (i < successors.length) {
    Node child = successors[i];
    if (!closed_nodes.contains(child) && !open_nodes.contains(child)) {
    open_nodes = [...open_nodes, child];
  }
    i = i + 1;
  }
  }
  List<Pos> r = [init];
  return r;
}

List<List<List<int>>> TEST_GRIDS = [[[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]], [[0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0]], [[0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0]]];
void print_grid(List<List<int>> grid) {
  int i = 0;
  while (i < grid.length) {
    print((grid[i]).toString());
    i = i + 1;
  }
}

void _main() {
  int idx = 0;
  while (idx < TEST_GRIDS.length) {
    print("==grid-" + (idx + 1).toString() + "==");
    List<List<int>> grid = TEST_GRIDS[idx];
    Pos init = Pos(y: 0, x: 0);
    Pos goal = Pos(y: grid.length - 1, x: grid[0].length - 1);
    print_grid(grid);
    print("------");
    List<Pos> path = greedy_best_first(grid, init, goal);
    int j = 0;
    while (j < path.length) {
    Pos p = path[j];
    while (grid[p.y]!.length <= p.x) { grid[p.y]!.add(0); } grid[p.y]![p.x] = 2;
    j = j + 1;
  }
    print_grid(grid);
    idx = idx + 1;
  }
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
