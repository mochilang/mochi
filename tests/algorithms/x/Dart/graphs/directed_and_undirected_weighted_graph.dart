// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { var i = v.toInt(); if (i == 0) return '0'; return i.toString(); } return v.toString(); }

class DirectedGraph {
  Map<int, List<List<int>>> graph;
  DirectedGraph({required this.graph});
}

class Graph {
  Map<int, List<List<int>>> graph;
  Graph({required this.graph});
}

bool list_contains_int(List<int> xs, int x) {
  int i = 0;
  while (i < xs.length) {
    if (xs[i] == x) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

bool edge_exists(List<List<int>> edges, int w, int v) {
  int i = 0;
  while (i < edges.length) {
    if (edges[i][0] == w && edges[i][1] == v) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

int first_key(Map<int, List<List<int>>> m) {
  for (int k in m.keys) {
    return k;
  }
  return 0;
}

int rand_range(int low, int high) {
  return _now() % (high - low) + low;
}

DirectedGraph dg_make_graph() {
  return DirectedGraph(graph: {});
}

void dg_add_pair(DirectedGraph g, int u, int v, int w) {
  if (g.graph.containsKey(u)) {
    List<List<int>> edges = g.graph[u]!;
    if (!edge_exists(edges, w, v)) {
    edges = ([...edges, [w, v]] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    Map<int, List<List<int>>> m = g.graph;
    m[u] = edges;
    g.graph = m;
  };
  } else {
    Map<int, List<List<int>>> m0 = g.graph;
    m0[u] = [[w, v]];
    g.graph = m0;
  }
  if (!g.graph.containsKey(v)) {
    Map<int, List<List<int>>> m1 = g.graph;
    m1[v] = ([] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    g.graph = m1;
  }
}

void dg_remove_pair(DirectedGraph g, int u, int v) {
  if (g.graph.containsKey(u)) {
    List<List<int>> edges = g.graph[u]!;
    List<List<int>> new_edges = <List<int>>[];
    int i = 0;
    while (i < edges.length) {
    if (edges[i][1] != v) {
    new_edges = ([...new_edges, edges[i]] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  }
    i = i + 1;
  };
    Map<int, List<List<int>>> m = g.graph;
    m[u] = new_edges;
    g.graph = m;
  }
}

List<int> dg_all_nodes(DirectedGraph g) {
  List<int> res = <int>[];
  for (int k in g.graph.keys) {
    res = [...res, k];
  }
  return res;
}

List<int> dg_dfs_util(DirectedGraph g, int node, Map<int, bool> visited, List<int> order, int d) {
  visited[node] = true;
  order = [...order, node];
  if (d != -1 && node == d) {
    return order;
  }
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    order = dg_dfs_util(g, neigh, visited, order, d);
    if (d != -1 && order[order.length - 1] == d) {
    return order;
  };
  }
    i = i + 1;
  }
  return order;
}

List<int> dg_dfs(DirectedGraph g, int s, int d) {
  if (s == d) {
    return ([] as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  int start = (s == -2 ? first_key(g.graph) : s);
  Map<int, bool> visited = <int, bool>{};
  List<int> order = <int>[];
  order = dg_dfs_util(g, start, visited, order, d);
  return order;
}

List<int> dg_bfs(DirectedGraph g, int s) {
  List<int> queue = <int>[];
  Map<int, bool> visited = <int, bool>{};
  List<int> order = <int>[];
  int start = (s == -2 ? first_key(g.graph) : s);
  queue = [...queue, start];
  visited[start] = true;
  while (queue.length > 0) {
    int node = queue[0];
    queue = queue.sublist(1, queue.length);
    order = [...order, node];
    List<List<int>> edges = g.graph[node]!;
    int i = 0;
    while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    queue = [...queue, neigh];
    visited[neigh] = true;
  }
    i = i + 1;
  }
  }
  return order;
}

int dg_in_degree(DirectedGraph g, int u) {
  int count = 0;
  for (int k in g.graph.keys) {
    List<List<int>> edges = g.graph[k]!;
    int i = 0;
    while (i < edges.length) {
    if (edges[i][1] == u) {
    count = count + 1;
  }
    i = i + 1;
  }
  }
  return count;
}

int dg_out_degree(DirectedGraph g, int u) {
  if (g.graph.containsKey(u)) {
    return (g.graph[u]!).length;
  }
  return 0;
}

List<int> dg_topo_util(DirectedGraph g, int node, Map<int, bool> visited, List<int> stack) {
  visited[node] = true;
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    stack = dg_topo_util(g, neigh, visited, stack);
  }
    i = i + 1;
  }
  stack = [...stack, node];
  return stack;
}

List<int> dg_topological_sort(DirectedGraph g) {
  Map<int, bool> visited = <int, bool>{};
  List<int> stack = <int>[];
  for (int k in g.graph.keys) {
    if (!visited.containsKey(k)) {
    stack = dg_topo_util(g, k, visited, stack);
  }
  }
  List<int> res = <int>[];
  int i = stack.length - 1;
  while (i >= 0) {
    res = [...res, stack[i]];
    i = i - 1;
  }
  return res;
}

List<int> dg_cycle_util(DirectedGraph g, int node, Map<int, bool> visited, Map<int, bool> rec, List<int> res) {
  visited[node] = true;
  rec[node] = true;
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    res = dg_cycle_util(g, neigh, visited, rec, res);
  } else {
    if (rec[neigh]!) {
    if (!list_contains_int(res, neigh)) {
    res = [...res, neigh];
  };
    if (!list_contains_int(res, node)) {
    res = [...res, node];
  };
  };
  }
    i = i + 1;
  }
  rec[node] = false;
  return res;
}

List<int> dg_cycle_nodes(DirectedGraph g) {
  Map<int, bool> visited = <int, bool>{};
  Map<int, bool> rec = <int, bool>{};
  List<int> res = <int>[];
  for (int k in g.graph.keys) {
    if (!visited.containsKey(k)) {
    res = dg_cycle_util(g, k, visited, rec, res);
  }
  }
  return res;
}

bool dg_has_cycle_util(DirectedGraph g, int node, Map<int, bool> visited, Map<int, bool> rec) {
  visited[node] = true;
  rec[node] = true;
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    if (dg_has_cycle_util(g, neigh, visited, rec)) {
    return true;
  };
  } else {
    if (rec[neigh]!) {
    return true;
  };
  }
    i = i + 1;
  }
  rec[node] = false;
  return false;
}

bool dg_has_cycle(DirectedGraph g) {
  Map<int, bool> visited = <int, bool>{};
  Map<int, bool> rec = <int, bool>{};
  for (int k in g.graph.keys) {
    if (!visited.containsKey(k)) {
    if (dg_has_cycle_util(g, k, visited, rec)) {
    return true;
  };
  }
  }
  return false;
}

void dg_fill_graph_randomly(DirectedGraph g, int c) {
  int count = c;
  if (count == -1) {
    count = rand_range(10, 10010);
  }
  int i = 0;
  while (i < count) {
    int edge_count = rand_range(1, 103);
    int j = 0;
    while (j < edge_count) {
    int n = rand_range(0, count);
    if (n != i) {
    dg_add_pair(g, i, n, 1);
  }
    j = j + 1;
  }
    i = i + 1;
  }
}

int dg_dfs_time(DirectedGraph g, int s, int e) {
  int begin = _now();
  dg_dfs(g, s, e);
  int end = _now();
  return end - begin;
}

int dg_bfs_time(DirectedGraph g, int s) {
  int begin = _now();
  dg_bfs(g, s);
  int end = _now();
  return end - begin;
}

Graph g_make_graph() {
  return Graph(graph: {});
}

void g_add_pair(Graph g, int u, int v, int w) {
  if (g.graph.containsKey(u)) {
    List<List<int>> edges = g.graph[u]!;
    if (!edge_exists(edges, w, v)) {
    edges = ([...edges, [w, v]] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    Map<int, List<List<int>>> m = g.graph;
    m[u] = edges;
    g.graph = m;
  };
  } else {
    Map<int, List<List<int>>> m0 = g.graph;
    m0[u] = [[w, v]];
    g.graph = m0;
  }
  if (g.graph.containsKey(v)) {
    List<List<int>> edges2 = g.graph[v]!;
    if (!edge_exists(edges2, w, u)) {
    edges2 = ([...edges2, [w, u]] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    Map<int, List<List<int>>> m2 = g.graph;
    m2[v] = edges2;
    g.graph = m2;
  };
  } else {
    Map<int, List<List<int>>> m3 = g.graph;
    m3[v] = [[w, u]];
    g.graph = m3;
  }
}

void g_remove_pair(Graph g, int u, int v) {
  if (g.graph.containsKey(u)) {
    List<List<int>> edges = g.graph[u]!;
    List<List<int>> new_edges = <List<int>>[];
    int i = 0;
    while (i < edges.length) {
    if (edges[i][1] != v) {
    new_edges = ([...new_edges, edges[i]] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  }
    i = i + 1;
  };
    Map<int, List<List<int>>> m = g.graph;
    m[u] = new_edges;
    g.graph = m;
  }
  if (g.graph.containsKey(v)) {
    List<List<int>> edges2 = g.graph[v]!;
    List<List<int>> new_edges2 = <List<int>>[];
    int j = 0;
    while (j < edges2.length) {
    if (edges2[j][1] != u) {
    new_edges2 = ([...new_edges2, edges2[j]] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  }
    j = j + 1;
  };
    Map<int, List<List<int>>> m2 = g.graph;
    m2[v] = new_edges2;
    g.graph = m2;
  }
}

List<int> g_all_nodes(Graph g) {
  List<int> res = <int>[];
  for (int k in g.graph.keys) {
    res = [...res, k];
  }
  return res;
}

List<int> g_dfs_util(Graph g, int node, Map<int, bool> visited, List<int> order, int d) {
  visited[node] = true;
  order = [...order, node];
  if (d != -1 && node == d) {
    return order;
  }
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    order = g_dfs_util(g, neigh, visited, order, d);
    if (d != -1 && order[order.length - 1] == d) {
    return order;
  };
  }
    i = i + 1;
  }
  return order;
}

List<int> g_dfs(Graph g, int s, int d) {
  if (s == d) {
    return ([] as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  int start = (s == -2 ? first_key(g.graph) : s);
  Map<int, bool> visited = <int, bool>{};
  List<int> order = <int>[];
  order = g_dfs_util(g, start, visited, order, d);
  return order;
}

List<int> g_bfs(Graph g, int s) {
  List<int> queue = <int>[];
  Map<int, bool> visited = <int, bool>{};
  List<int> order = <int>[];
  int start = (s == -2 ? first_key(g.graph) : s);
  queue = [...queue, start];
  visited[start] = true;
  while (queue.length > 0) {
    int node = queue[0];
    queue = queue.sublist(1, queue.length);
    order = [...order, node];
    List<List<int>> edges = g.graph[node]!;
    int i = 0;
    while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    queue = [...queue, neigh];
    visited[neigh] = true;
  }
    i = i + 1;
  }
  }
  return order;
}

int g_degree(Graph g, int u) {
  if (g.graph.containsKey(u)) {
    return (g.graph[u]!).length;
  }
  return 0;
}

List<int> g_cycle_util(Graph g, int node, Map<int, bool> visited, int parent, List<int> res) {
  visited[node] = true;
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    res = g_cycle_util(g, neigh, visited, node, res);
  } else {
    if (neigh != parent) {
    if (!list_contains_int(res, neigh)) {
    res = [...res, neigh];
  };
    if (!list_contains_int(res, node)) {
    res = [...res, node];
  };
  };
  }
    i = i + 1;
  }
  return res;
}

List<int> g_cycle_nodes(Graph g) {
  Map<int, bool> visited = <int, bool>{};
  List<int> res = <int>[];
  for (int k in g.graph.keys) {
    if (!visited.containsKey(k)) {
    res = g_cycle_util(g, k, visited, -1, res);
  }
  }
  return res;
}

bool g_has_cycle_util(Graph g, int node, Map<int, bool> visited, int parent) {
  visited[node] = true;
  List<List<int>> edges = g.graph[node]!;
  int i = 0;
  while (i < edges.length) {
    int neigh = edges[i][1];
    if (!visited.containsKey(neigh)) {
    if (g_has_cycle_util(g, neigh, visited, node)) {
    return true;
  };
  } else {
    if (neigh != parent) {
    return true;
  };
  }
    i = i + 1;
  }
  return false;
}

bool g_has_cycle(Graph g) {
  Map<int, bool> visited = <int, bool>{};
  for (int k in g.graph.keys) {
    if (!visited.containsKey(k)) {
    if (g_has_cycle_util(g, k, visited, -1)) {
    return true;
  };
  }
  }
  return false;
}

void g_fill_graph_randomly(Graph g, int c) {
  int count = c;
  if (count == -1) {
    count = rand_range(10, 10010);
  }
  int i = 0;
  while (i < count) {
    int edge_count = rand_range(1, 103);
    int j = 0;
    while (j < edge_count) {
    int n = rand_range(0, count);
    if (n != i) {
    g_add_pair(g, i, n, 1);
  }
    j = j + 1;
  }
    i = i + 1;
  }
}

int g_dfs_time(Graph g, int s, int e) {
  int begin = _now();
  g_dfs(g, s, e);
  int end = _now();
  return end - begin;
}

int g_bfs_time(Graph g, int s) {
  int begin = _now();
  g_bfs(g, s);
  int end = _now();
  return end - begin;
}

void _main() {
  DirectedGraph dg = dg_make_graph();
  dg_add_pair(dg, 0, 1, 5);
  dg_add_pair(dg, 0, 2, 3);
  dg_add_pair(dg, 1, 3, 2);
  dg_add_pair(dg, 2, 3, 4);
  print(_str(dg_dfs(dg, -2, -1)));
  print(_str(dg_bfs(dg, -2)));
  print(_str(dg_in_degree(dg, 3)));
  print(_str(dg_out_degree(dg, 0)));
  print(_str(dg_topological_sort(dg)));
  print(_str(dg_has_cycle(dg)));
  Graph ug = g_make_graph();
  g_add_pair(ug, 0, 1, 1);
  g_add_pair(ug, 1, 2, 1);
  g_add_pair(ug, 2, 0, 1);
  print(_str(g_dfs(ug, -2, -1)));
  print(_str(g_bfs(ug, -2)));
  print(_str(g_degree(ug, 1)));
  print(_str(g_has_cycle(ug)));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
