// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

dynamic dfs(Map<int, List<int>> g, int s) {
  Map<int, bool> visited = <int, bool>{};
  List<int> stack = <int>[];
  visited[s] = true;
  stack = [...stack, s];
  print(s);
  while (stack.length > 0) {
    int u = stack[stack.length - 1];
    bool found = false;
    for (int v in (g[u]!)) {
    if (!visited.containsKey(v)) {
    visited[v] = true;
    stack = [...stack, v];
    print(v);
    found = true;
    break;
  }
  }
    if (!found) {
    stack = (stack.sublist(0, stack.length - 1) as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  }
}

dynamic bfs(Map<int, List<int>> g, int s) {
  Map<int, bool> visited = <int, bool>{};
  List<int> q = <int>[];
  visited[s] = true;
  q = [...q, s];
  print(s);
  while (q.length > 0) {
    int u = q[0];
    q = (q.sublist(1, q.length) as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
    for (int v in (g[u]!)) {
    if (!visited.containsKey(v)) {
    visited[v] = true;
    q = [...q, v];
    print(v);
  }
  }
  }
}

List<int> sort_ints(List<int> a) {
  List<int> arr = a;
  int i = 0;
  while (i < arr.length) {
    int j = 0;
    while (j < arr.length - i - 1) {
    if (arr[j] > arr[j + 1]) {
    int tmp = arr[j];
    while (arr.length <= j) { arr.add(0); } arr[j] = arr[j + 1];
    while (arr.length <= j + 1) { arr.add(0); } arr[j + 1] = tmp;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return arr;
}

dynamic dijkstra(Map<int, List<List<int>>> g, int s) {
  Map<int, int> dist = <int, int>{};
  dist[s] = 0;
  Map<int, int> path = <int, int>{};
  path[s] = 0;
  List<int> known = <int>[];
  List<int> keys = [s];
  while (known.length < keys.length) {
    int mini = 100000;
    int u = -1;
    int i = 0;
    while (i < keys.length) {
    int k = keys[i];
    int d = dist[k]!;
    if (!known.contains(k) && d < mini) {
    mini = d;
    u = k;
  }
    i = i + 1;
  }
    known = [...known, u];
    for (List<int> e in (g[u]!)) {
    int v = e[0];
    int w = e[1];
    if (!keys.contains(v)) {
    keys = [...keys, v];
  }
    int alt = (dist[u] ?? 0) + w;
    int cur = (dist.containsKey(v) ? (dist[v] ?? 0) : 100000);
    if (!known.contains(v) && alt < cur) {
    dist[v] = alt;
    path[v] = u;
  }
  }
  }
  List<int> ordered = sort_ints(keys);
  int idx = 0;
  while (idx < ordered.length) {
    int k = ordered[idx];
    if (k != s) {
    print((dist[k] ?? 0));
  }
    idx = idx + 1;
  }
}

dynamic topo(Map<int, List<int>> g, int n) {
  List<int> ind = <int>[];
  int i = 0;
  while (i <= n) {
    ind = [...ind, 0];
    i = i + 1;
  }
  int node = 1;
  while (node <= n) {
    for (int v in (g[node]!)) {
    while (ind.length <= v) { ind.add(0); } ind[v] = ind[v] + 1;
  }
    node = node + 1;
  }
  List<int> q = <int>[];
  int j = 1;
  while (j <= n) {
    if (ind[j] == 0) {
    q = [...q, j];
  }
    j = j + 1;
  }
  while (q.length > 0) {
    int v = q[0];
    q = (q.sublist(1, q.length) as List<dynamic>).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
    print(v);
    for (int w in (g[v]!)) {
    while (ind.length <= w) { ind.add(0); } ind[w] = ind[w] - 1;
    if (ind[w] == 0) {
    q = [...q, w];
  }
  }
  }
}

dynamic floyd(List<List<int>> a) {
  int n = a.length;
  List<List<int>> dist = <List<int>>[];
  int i = 0;
  while (i < n) {
    List<int> row = <int>[];
    int j = 0;
    while (j < n) {
    row = [...row, a[i][j]];
    j = j + 1;
  }
    dist = ([...dist, row] as List<dynamic>).map((e) => (e as List<int>)).toList();
    i = i + 1;
  }
  int k = 0;
  while (k < n) {
    int ii = 0;
    while (ii < n) {
    int jj = 0;
    while (jj < n) {
    if (dist[ii][jj] > dist[ii][k] + dist[k][jj]) {
    while (dist[ii]!.length <= jj) { dist[ii]!.add(0); } dist[ii]![jj] = dist[ii][k] + dist[k][jj];
  }
    jj = jj + 1;
  }
    ii = ii + 1;
  }
    k = k + 1;
  }
  print(dist);
}

int prim(Map<int, List<List<int>>> g, int s, int n) {
  Map<int, int> dist = <int, int>{};
  dist[s] = 0;
  List<int> known = <int>[];
  List<int> keys = [s];
  int total = 0;
  while (known.length < n) {
    int mini = 100000;
    int u = -1;
    int i = 0;
    while (i < keys.length) {
    int k = keys[i];
    int d = dist[k]!;
    if (!known.contains(k) && d < mini) {
    mini = d;
    u = k;
  }
    i = i + 1;
  }
    known = [...known, u];
    total = total + mini;
    for (List<int> e in (g[u]!)) {
    int v = e[0];
    int w = e[1];
    if (!keys.contains(v)) {
    keys = [...keys, v];
  }
    int cur = (dist.containsKey(v) ? (dist[v] ?? 0) : 100000);
    if (!known.contains(v) && w < cur) {
    dist[v] = w;
  }
  }
  }
  return total;
}

List<List<int>> sort_edges(List<List<int>> edges) {
  List<List<int>> es = edges;
  int i = 0;
  while (i < es.length) {
    int j = 0;
    while (j < es.length - i - 1) {
    if (es[j][2] > es[j + 1][2]) {
    List<int> tmp = es[j];
    while (es.length <= j) { es.add(<int>[]); } es[j] = es[j + 1];
    while (es.length <= j + 1) { es.add(<int>[]); } es[j + 1] = tmp;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return es;
}

int find_parent(List<int> parent, int x) {
  int r = x;
  while (parent[r] != r) {
    r = parent[r];
  }
  return r;
}

void union_parent(List<int> parent, int a, int b) {
  while (parent.length <= a) { parent.add(0); } parent[a] = b;
}

int kruskal(List<List<int>> edges, int n) {
  List<List<int>> es = sort_edges(edges);
  List<int> parent = <int>[];
  int i = 0;
  while (i <= n) {
    parent = [...parent, i];
    i = i + 1;
  }
  int total = 0;
  int count = 0;
  int idx = 0;
  while (count < n - 1 && idx < es.length) {
    List<int> e = es[idx];
    idx = idx + 1;
    int u = e[0];
    int v = e[1];
    int w = e[2];
    int ru = find_parent(parent, u);
    int rv = find_parent(parent, v);
    if (ru != rv) {
    union_parent(parent, ru, rv);
    total = total + w;
    count = count + 1;
  }
  }
  return total;
}

List<int> find_isolated_nodes(Map<int, List<int>> g, List<int> nodes) {
  List<int> isolated = <int>[];
  for (int node in nodes) {
    if ((g[node]!).length == 0) {
    isolated = [...isolated, node];
  }
  }
  return isolated;
}

Map<int, List<int>> g_dfs = {1: [2, 3], 2: [4, 5], 3: [], 4: [], 5: []};
Map<int, List<int>> g_bfs = {1: [2, 3], 2: [4, 5], 3: [6, 7], 4: [], 5: [8], 6: [], 7: [], 8: []};
Map<int, List<List<int>>> g_weighted = {1: [[2, 7], [3, 9], [6, 14]], 2: [[1, 7], [3, 10], [4, 15]], 3: [[1, 9], [2, 10], [4, 11], [6, 2]], 4: [[2, 15], [3, 11], [5, 6]], 5: [[4, 6], [6, 9]], 6: [[1, 14], [3, 2], [5, 9]]};
Map<int, List<int>> g_topo = {1: [2, 3], 2: [4], 3: [4], 4: []};
List<List<int>> matrix = [[0, 5, 9, 100000], [100000, 0, 2, 8], [100000, 100000, 0, 7], [4, 100000, 100000, 0]];
Map<int, List<List<int>>> g_prim = {1: [[2, 1], [3, 3]], 2: [[1, 1], [3, 1], [4, 6]], 3: [[1, 3], [2, 1], [4, 2]], 4: [[2, 6], [3, 2]]};
List<List<int>> edges_kruskal = [[1, 2, 1], [2, 3, 2], [1, 3, 2], [3, 4, 1]];
Map<int, List<int>> g_iso = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []};
List<int> iso = find_isolated_nodes(g_iso, [1, 2, 3, 4]);
void main() {
  dfs(g_dfs, 1);
  bfs(g_bfs, 1);
  dijkstra(g_weighted, 1);
  topo(g_topo, 4);
  floyd(matrix);
  print(prim(g_prim, 1, 4));
  print(kruskal(edges_kruskal, 4));
  print("[" + iso.join(', ') + "]");
}
