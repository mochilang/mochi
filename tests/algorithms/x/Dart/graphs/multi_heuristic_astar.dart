// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Pos {
  int x;
  int y;
  Pos({required this.x, required this.y});
}

class PQNode {
  Pos pos;
  double pri;
  PQNode({required this.pos, required this.pri});
}

class PQPopResult {
  List<PQNode> pq;
  PQNode node;
  PQPopResult({required this.pq, required this.node});
}

double W1 = 1.0;
double W2 = 1.0;
int n = 20;
int n_heuristic = 3;
double INF = 1000000000.0;
int t = 1;
bool pos_equal(Pos a, Pos b) {
  return a.x == b.x && a.y == b.y;
}

String pos_key(Pos p) {
  return _str(p.x) + "," + _str(p.y);
}

double sqrtApprox(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x;
  int i = 0;
  while (i < 10) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double consistent_heuristic(Pos p, Pos goal) {
  double dx = (p.x - goal.x).toDouble();
  double dy = (p.y - goal.y).toDouble();
  return sqrtApprox(dx * dx + dy * dy);
}

int iabs(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

double heuristic_1(Pos p, Pos goal) {
  return (iabs(p.x - goal.x) + iabs(p.y - goal.y)).toDouble();
}

double heuristic_2(Pos p, Pos goal) {
  double h = consistent_heuristic(p, goal);
  return h / ((t).toDouble());
}

double heuristic(int i, Pos p, Pos goal) {
  if (i == 0) {
    return consistent_heuristic(p, goal);
  }
  if (i == 1) {
    return heuristic_1(p, goal);
  }
  return heuristic_2(p, goal);
}

double key_fn(Pos start, int i, Pos goal, Map<String, double> g_func) {
  double g = g_func[pos_key(start)]!;
  return g + W1 * heuristic(i, start, goal);
}

bool valid(Pos p) {
  if (p.x < 0 || p.x > n - 1) {
    return false;
  }
  if (p.y < 0 || p.y > n - 1) {
    return false;
  }
  return true;
}

List<Pos> blocks = [Pos(x: 0, y: 1), Pos(x: 1, y: 1), Pos(x: 2, y: 1), Pos(x: 3, y: 1), Pos(x: 4, y: 1), Pos(x: 5, y: 1), Pos(x: 6, y: 1), Pos(x: 7, y: 1), Pos(x: 8, y: 1), Pos(x: 9, y: 1), Pos(x: 10, y: 1), Pos(x: 11, y: 1), Pos(x: 12, y: 1), Pos(x: 13, y: 1), Pos(x: 14, y: 1), Pos(x: 15, y: 1), Pos(x: 16, y: 1), Pos(x: 17, y: 1), Pos(x: 18, y: 1), Pos(x: 19, y: 1)];
bool in_blocks(Pos p) {
  int i = 0;
  while (i < blocks.length) {
    if (pos_equal(blocks[i], p)) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

List<PQNode> pq_put(List<PQNode> pq, Pos node, double pri) {
  bool updated = false;
  int i = 0;
  while (i < pq.length) {
    if (pos_equal(pq[i].pos, node)) {
    if (pri < pq[i].pri) {
    while (pq.length <= i) { pq.add(null as dynamic); } pq[i] = PQNode(pos: node, pri: pri);
  };
    updated = true;
  }
    i = i + 1;
  }
  if (!updated) {
    pq = [...pq, PQNode(pos: node, pri: pri)];
  }
  return pq;
}

double pq_minkey(List<PQNode> pq) {
  if (pq.length == 0) {
    return INF;
  }
  PQNode first = pq[0];
  double m = first.pri;
  int i = 1;
  while (i < pq.length) {
    PQNode item = pq[i];
    if (item.pri < m) {
    m = item.pri;
  }
    i = i + 1;
  }
  return m;
}

PQPopResult pq_pop_min(List<PQNode> pq) {
  PQNode best = pq[0];
  int idx = 0;
  int i = 1;
  while (i < pq.length) {
    if (pq[i].pri < best.pri) {
    best = pq[i];
    idx = i;
  }
    i = i + 1;
  }
  List<PQNode> new_pq = <PQNode>[];
  i = 0;
  while (i < pq.length) {
    if (i != idx) {
    new_pq = [...new_pq, pq[i]];
  }
    i = i + 1;
  }
  return PQPopResult(pq: new_pq, node: best);
}

List<PQNode> pq_remove(List<PQNode> pq, Pos node) {
  List<PQNode> new_pq = <PQNode>[];
  int i = 0;
  while (i < pq.length) {
    if (!pos_equal(pq[i].pos, node)) {
    new_pq = [...new_pq, pq[i]];
  }
    i = i + 1;
  }
  return new_pq;
}

List<Pos> reconstruct(Map<String, Pos> back_pointer, Pos goal, Pos start) {
  List<Pos> path = <Pos>[];
  Pos current = goal;
  String key = pos_key(current);
  path = [...path, current];
  while (!pos_equal(current, start)) {
    current = back_pointer[key]!;
    key = pos_key(current);
    path = [...path, current];
  }
  List<Pos> rev = <Pos>[];
  int i = path.length - 1;
  while (i >= 0) {
    rev = [...rev, path[i]];
    i = i - 1;
  }
  return rev;
}

List<Pos> neighbours(Pos p) {
  Pos left = Pos(x: p.x - 1, y: p.y);
  Pos right = Pos(x: p.x + 1, y: p.y);
  Pos up = Pos(x: p.x, y: p.y + 1);
  Pos down = Pos(x: p.x, y: p.y - 1);
  return [left, right, up, down];
}

void multi_a_star(Pos start, Pos goal, int n_heuristic) {
  Map<String, double> g_function = <String, double>{};
  Map<String, Pos> back_pointer = <String, Pos>{};
  Map<String, bool> visited = <String, bool>{};
  List<List<PQNode>> open_list = <List<PQNode>>[];
  g_function[pos_key(start)] = 0.0;
  g_function[pos_key(goal)] = INF;
  back_pointer[pos_key(start)] = Pos(x: -1, y: -1);
  back_pointer[pos_key(goal)] = Pos(x: -1, y: -1);
  visited[pos_key(start)] = true;
  int i = 0;
  while (i < n_heuristic) {
    open_list = [...open_list, []];
    double pri = key_fn(start, i, goal, g_function);
    while (open_list.length <= i) { open_list.add(<PQNode>[]); } open_list[i] = pq_put(open_list[i], start, pri);
    i = i + 1;
  }
  while (pq_minkey(open_list[0]) < INF) {
    int chosen = 0;
    i = 1;
    while (i < n_heuristic) {
    if (pq_minkey(open_list[i]) <= W2 * pq_minkey(open_list[0])) {
    chosen = i;
    break;
  }
    i = i + 1;
  }
    if (chosen != 0) {
    t = t + 1;
  }
    PQPopResult pair = pq_pop_min(open_list[chosen]);
    while (open_list.length <= chosen) { open_list.add(<PQNode>[]); } open_list[chosen] = pair.pq;
    PQNode current = pair.node;
    i = 0;
    while (i < n_heuristic) {
    if (i != chosen) {
    while (open_list.length <= i) { open_list.add(<PQNode>[]); } open_list[i] = pq_remove(open_list[i], current.pos);
  }
    i = i + 1;
  }
    String ckey = pos_key(current.pos);
    if (visited.containsKey(ckey)) {
    continue;
  }
    visited[ckey] = true;
    if (pos_equal(current.pos, goal)) {
    List<Pos> path = reconstruct(back_pointer, goal, start);
    int j = 0;
    while (j < path.length) {
    Pos p = path[j];
    print("(" + _str(p.x) + "," + _str(p.y) + ")");
    j = j + 1;
  };
    return;
  }
    List<Pos> neighs = neighbours(current.pos);
    int k = 0;
    while (k < neighs.length) {
    Pos nb = neighs[k];
    if (valid(nb) && in_blocks(nb) == false) {
    String nkey = pos_key(nb);
    double tentative = (g_function[ckey]!) + 1.0;
    if (!g_function.containsKey(nkey) || tentative < (g_function[nkey]!)) {
    g_function[nkey] = tentative;
    back_pointer[nkey] = current.pos;
    i = 0;
    while (i < n_heuristic) {
    double pri2 = tentative + W1 * heuristic(i, nb, goal);
    while (open_list.length <= i) { open_list.add(<PQNode>[]); } open_list[i] = pq_put(open_list[i], nb, pri2);
    i = i + 1;
  };
  };
  }
    k = k + 1;
  }
  }
  print("No path found to goal");
}

Pos start = Pos(x: 0, y: 0);
Pos goal = Pos(x: n - 1, y: n - 1);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  multi_a_star(start, goal, n_heuristic);
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
