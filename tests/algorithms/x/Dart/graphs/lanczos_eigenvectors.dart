// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { var i = v.toInt(); if (i == 0) return '0'; return i.toString(); } return v.toString(); }


Never _error(String msg) {
  throw Exception(msg);
}

class LanczosResult {
  List<List<double>> t;
  List<List<double>> q;
  LanczosResult({required this.t, required this.q});
}

class EigenResult {
  List<double> values;
  List<List<double>> vectors;
  EigenResult({required this.values, required this.vectors});
}

int seed = 123456789;
int rand() {
  seed = (seed * 1103515245 + 12345) % 2147483648;
  return seed;
}

double random() {
  return 1.0 * rand() / 2147483648.0;
}

double sqrtApprox(double x) {
  if (x <= 0.0) {
    return 0.0;
  }
  double guess = x;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double absf(double x) {
  return (x < 0.0 ? -x : x);
}

double dot(List<double> a, List<double> b) {
  double s = 0.0;
  int i = 0;
  while (i < a.length) {
    s = s + a[i] * b[i];
    i = i + 1;
  }
  return s;
}

List<double> vector_scale(List<double> v, double s) {
  List<double> res = <double>[];
  int i = 0;
  while (i < v.length) {
    res = [...res, v[i] * s];
    i = i + 1;
  }
  return res;
}

List<double> vector_sub(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = [...res, a[i] - b[i]];
    i = i + 1;
  }
  return res;
}

List<double> vector_add(List<double> a, List<double> b) {
  List<double> res = <double>[];
  int i = 0;
  while (i < a.length) {
    res = [...res, a[i] + b[i]];
    i = i + 1;
  }
  return res;
}

List<List<double>> zeros_matrix(int r, int c) {
  List<List<double>> m = <List<double>>[];
  int i = 0;
  while (i < r) {
    List<double> row = <double>[];
    int j = 0;
    while (j < c) {
    row = [...row, 0.0];
    j = j + 1;
  }
    m = ([...m, row] as List<dynamic>).map((e) => (List<double>.from(e) as List<double>)).toList();
    i = i + 1;
  }
  return m;
}

List<double> column(List<List<double>> m, int idx) {
  List<double> col = <double>[];
  int i = 0;
  while (i < m.length) {
    col = [...col, m[i][idx]];
    i = i + 1;
  }
  return col;
}

dynamic validate_adjacency_list(List<List<int>> graph) {
  int i = 0;
  while (i < graph.length) {
    int j = 0;
    while (j < graph[i].length) {
    int v = graph[i][j];
    if (v < 0 || v >= graph.length) {
    _error("Invalid neighbor");
  }
    j = j + 1;
  }
    i = i + 1;
  }
}

List<double> multiply_matrix_vector(List<List<int>> graph, List<double> vector) {
  int n = graph.length;
  if (vector.length != n) {
    _error("Vector length must match number of nodes");
  }
  List<double> result = <double>[];
  int i = 0;
  while (i < n) {
    double sum = 0.0;
    int j = 0;
    while (j < graph[i].length) {
    int nb = graph[i][j];
    sum = sum + vector[nb];
    j = j + 1;
  }
    result = [...result, sum];
    i = i + 1;
  }
  return result;
}

LanczosResult lanczos_iteration(List<List<int>> graph, int k) {
  int n = graph.length;
  if (k < 1 || k > n) {
    _error("invalid number of eigenvectors");
  }
  List<List<double>> q = zeros_matrix(n, k);
  List<List<double>> t = zeros_matrix(k, k);
  List<double> v = <double>[];
  int i = 0;
  while (i < n) {
    v = [...v, random()];
    i = i + 1;
  }
  double ss = 0.0;
  i = 0;
  while (i < n) {
    ss = ss + v[i] * v[i];
    i = i + 1;
  }
  double vnorm = sqrtApprox(ss);
  i = 0;
  while (i < n) {
    while (q[i]!.length <= 0) { q[i]!.add(0); } q[i]![0] = v[i] / vnorm;
    i = i + 1;
  }
  double beta = 0.0;
  int j = 0;
  while (j < k) {
    List<double> w = multiply_matrix_vector(graph, column(q, j));
    if (j > 0) {
    w = vector_sub(w, vector_scale(column(q, j - 1), beta));
  }
    double alpha = dot(column(q, j), w);
    w = vector_sub(w, vector_scale(column(q, j), alpha));
    double ss2 = 0.0;
    int p = 0;
    while (p < n) {
    ss2 = ss2 + w[p] * w[p];
    p = p + 1;
  }
    beta = sqrtApprox(ss2);
    while (t[j]!.length <= j) { t[j]!.add(0); } t[j]![j] = alpha;
    if (j < k - 1) {
    while (t[j]!.length <= j + 1) { t[j]!.add(0); } t[j]![j + 1] = beta;
    while (t[j + 1]!.length <= j) { t[j + 1]!.add(0); } t[j + 1]![j] = beta;
    if (beta > 0.0000000001) {
    List<double> wnorm = vector_scale(w, 1.0 / beta);
    int r = 0;
    while (r < n) {
    while (q[r]!.length <= j + 1) { q[r]!.add(0); } q[r]![j + 1] = wnorm[r];
    r = r + 1;
  };
  };
  }
    j = j + 1;
  }
  return LanczosResult(t: t, q: q);
}

EigenResult jacobi_eigen(List<List<double>> a_in, int max_iter) {
  int n = a_in.length;
  List<List<double>> a = a_in;
  List<List<double>> v = zeros_matrix(n, n);
  int i = 0;
  while (i < n) {
    while (v[i]!.length <= i) { v[i]!.add(0); } v[i]![i] = 1.0;
    i = i + 1;
  }
  int iter = 0;
  while (iter < max_iter) {
    int p = 0;
    int q = 1;
    double max = absf(a[p][q]);
    i = 0;
    while (i < n) {
    int j = i + 1;
    while (j < n) {
    double val = absf(a[i][j]);
    if (val > max) {
    max = val;
    p = i;
    q = j;
  }
    j = j + 1;
  }
    i = i + 1;
  }
    if (max < 0.00000001) {
    break;
  }
    double app = a[p][p];
    double aqq = a[q][q];
    double apq = a[p][q];
    double theta = (aqq - app) / (2.0 * apq);
    double t = 1.0 / (absf(theta) + sqrtApprox(theta * theta + 1.0));
    if (theta < 0.0) {
    t = -t;
  }
    double c = 1.0 / sqrtApprox(1.0 + t * t);
    double s = t * c;
    double tau = s / (1.0 + c);
    while (a[p]!.length <= p) { a[p]!.add(0); } a[p]![p] = app - t * apq;
    while (a[q]!.length <= q) { a[q]!.add(0); } a[q]![q] = aqq + t * apq;
    while (a[p]!.length <= q) { a[p]!.add(0); } a[p]![q] = 0.0;
    while (a[q]!.length <= p) { a[q]!.add(0); } a[q]![p] = 0.0;
    int k = 0;
    while (k < n) {
    if (k != p && k != q) {
    double akp = a[k][p];
    double akq = a[k][q];
    while (a[k]!.length <= p) { a[k]!.add(0); } a[k]![p] = akp - s * (akq + tau * akp);
    while (a[p]!.length <= k) { a[p]!.add(0); } a[p]![k] = a[k][p];
    while (a[k]!.length <= q) { a[k]!.add(0); } a[k]![q] = akq + s * (akp - tau * akq);
    while (a[q]!.length <= k) { a[q]!.add(0); } a[q]![k] = a[k][q];
  }
    k = k + 1;
  }
    k = 0;
    while (k < n) {
    double vkp = v[k][p];
    double vkq = v[k][q];
    while (v[k]!.length <= p) { v[k]!.add(0); } v[k]![p] = vkp - s * (vkq + tau * vkp);
    while (v[k]!.length <= q) { v[k]!.add(0); } v[k]![q] = vkq + s * (vkp - tau * vkq);
    k = k + 1;
  }
    iter = iter + 1;
  }
  List<double> eigenvalues = <double>[];
  i = 0;
  while (i < n) {
    eigenvalues = [...eigenvalues, a[i][i]];
    i = i + 1;
  }
  return EigenResult(values: eigenvalues, vectors: v);
}

List<List<double>> matmul(List<List<double>> a, List<List<double>> b) {
  int rows = a.length;
  int cols = b[0].length;
  int inner = b.length;
  List<List<double>> m = zeros_matrix(rows, cols);
  int i = 0;
  while (i < rows) {
    int j = 0;
    while (j < cols) {
    double s = 0.0;
    int k = 0;
    while (k < inner) {
    s = s + a[i][k] * b[k][j];
    k = k + 1;
  }
    while (m[i]!.length <= j) { m[i]!.add(0); } m[i]![j] = s;
    j = j + 1;
  }
    i = i + 1;
  }
  return m;
}

EigenResult sort_eigenpairs(List<double> vals, List<List<double>> vecs) {
  int n = vals.length;
  List<double> values = vals;
  List<List<double>> vectors = vecs;
  int i = 0;
  while (i < n) {
    int j = 0;
    while (j < n - 1) {
    if (values[j].compareTo(values[j + 1]) < 0) {
    double tmp = values[j];
    while (values.length <= j) { values.add(0); } values[j] = values[j + 1];
    while (values.length <= j + 1) { values.add(0); } values[j + 1] = tmp;
    int r = 0;
    while (r < vectors.length) {
    double tv = vectors[r][j];
    while (vectors[r]!.length <= j) { vectors[r]!.add(0); } vectors[r]![j] = vectors[r][j + 1];
    while (vectors[r]!.length <= j + 1) { vectors[r]!.add(0); } vectors[r]![j + 1] = tv;
    r = r + 1;
  };
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return EigenResult(values: values, vectors: vectors);
}

EigenResult find_lanczos_eigenvectors(List<List<int>> graph, int k) {
  validate_adjacency_list(graph);
  LanczosResult res = lanczos_iteration(graph, k);
  EigenResult eig = jacobi_eigen(res.t, 50);
  EigenResult sorted = sort_eigenpairs(eig.values, eig.vectors);
  List<List<double>> final_vectors = matmul(res.q, sorted.vectors);
  return EigenResult(values: sorted.values, vectors: final_vectors);
}

String list_to_string(List<double> arr) {
  String s = "[";
  int i = 0;
  while (i < arr.length) {
    s = s + _str(arr[i]);
    if (i < arr.length - 1) {
    s = s + ", ";
  }
    i = i + 1;
  }
  return s + "]";
}

String matrix_to_string(List<List<double>> m) {
  String s = "[";
  int i = 0;
  while (i < m.length) {
    s = s + list_to_string(m[i]);
    if (i < m.length - 1) {
    s = s + "; ";
  }
    i = i + 1;
  }
  return s + "]";
}

List<List<int>> graph = [[1, 2], [0, 2], [0, 1]];
EigenResult result = find_lanczos_eigenvectors(graph, 2);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print(list_to_string(result.values));
  print(matrix_to_string(result.vectors));
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
