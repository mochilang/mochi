// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class SearchResult {
  List<List<int>> path;
  List<List<int>> action;
  SearchResult({required this.path, required this.action});
}

List<List<int>> DIRECTIONS = [[-1, 0], [0, -1], [1, 0], [0, 1]];
int iabs(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

SearchResult search(List<List<int>> grid, List<int> init, List<int> goal, int cost, List<List<int>> heuristic) {
  List<List<int>> closed = <List<int>>[];
  int r = 0;
  while (r < grid.length) {
    List<int> row = <int>[];
    int c = 0;
    while (c < grid[0].length) {
    row = [...row, 0];
    c = c + 1;
  }
    closed = ([...closed, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    r = r + 1;
  }
  while (closed[init[0]]!.length <= init[1]) { closed[init[0]]!.add(0); } closed[init[0]]![init[1]] = 1;
  List<List<int>> action = <List<int>>[];
  r = 0;
  while (r < grid.length) {
    List<int> row = <int>[];
    int c = 0;
    while (c < grid[0].length) {
    row = [...row, 0];
    c = c + 1;
  }
    action = ([...action, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    r = r + 1;
  }
  int x = init[0];
  int y = init[1];
  int g = 0;
  int f = g + heuristic[x][y];
  List<List<int>> cell = [[f, g, x, y]];
  bool found = false;
  bool resign = false;
  while (!found && !resign) {
    if (cell.length == 0) {
    throw Exception("Algorithm is unable to find solution");
  } else {
    int best_i = 0;
    int best_f = cell[0][0];
    int i = 1;
    while (i < cell.length) {
    if (cell[i][0] < best_f) {
    best_f = cell[i][0];
    best_i = i;
  }
    i = i + 1;
  };
    List<int> next_cell = cell[best_i];
    List<List<int>> new_cell = <List<int>>[];
    i = 0;
    while (i < cell.length) {
    if (i != best_i) {
    new_cell = ([...new_cell, cell[i]] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  }
    i = i + 1;
  };
    cell = new_cell;
    x = next_cell[2];
    y = next_cell[3];
    g = next_cell[1];
    if (x == goal[0] && y == goal[1]) {
    found = true;
  } else {
    int d = 0;
    while (d < DIRECTIONS.length) {
    int x2 = x + DIRECTIONS[d][0];
    int y2 = y + DIRECTIONS[d][1];
    if (x2 >= 0 && x2 < grid.length && y2 >= 0 && y2 < grid[0].length && closed[x2][y2] == 0 && grid[x2][y2] == 0) {
    int g2 = g + cost;
    int f2 = g2 + heuristic[x2][y2];
    cell = ([...cell, [f2, g2, x2, y2]] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    while (closed[x2]!.length <= y2) { closed[x2]!.add(0); } closed[x2]![y2] = 1;
    while (action[x2]!.length <= y2) { action[x2]!.add(0); } action[x2]![y2] = d;
  }
    d = d + 1;
  };
  };
  }
  }
  List<List<int>> invpath = <List<int>>[];
  x = goal[0];
  y = goal[1];
  invpath = ([...invpath, [x, y]] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  while (x != init[0] || y != init[1]) {
    int dir = action[x][y];
    int x2 = x - DIRECTIONS[dir][0];
    int y2 = y - DIRECTIONS[dir][1];
    x = x2;
    y = y2;
    invpath = ([...invpath, [x, y]] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  }
  List<List<int>> path = <List<int>>[];
  int idx = invpath.length - 1;
  while (idx >= 0) {
    path = ([...path, invpath[idx]] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    idx = idx - 1;
  }
  return SearchResult(path: path, action: action);
}

void _main() {
  List<List<int>> grid = [[0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0]];
  List<int> init = [0, 0];
  List<int> goal = [grid.length - 1, grid[0].length - 1];
  int cost = 1;
  List<List<int>> heuristic = <List<int>>[];
  int i = 0;
  while (i < grid.length) {
    List<int> row = <int>[];
    int j = 0;
    while (j < grid[0].length) {
    int h = iabs(i - goal[0]) + iabs(j - goal[1]);
    if (grid[i][j] == 1) {
    row = [...row, 99];
  } else {
    row = [...row, h];
  }
    j = j + 1;
  }
    heuristic = ([...heuristic, row] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    i = i + 1;
  }
  SearchResult result = search(grid, init, goal, cost, heuristic);
  print("ACTION MAP");
  int rr = 0;
  while (rr < result.action.length) {
    print(result.action[rr]);
    rr = rr + 1;
  }
  int p = 0;
  while (p < result.path.length) {
    print(result.path[p]);
    p = p + 1;
  }
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
