// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class Node {
  String name;
  List<String> inbound;
  List<String> outbound;
  Node({required this.name, required this.inbound, required this.outbound});
}

String node_to_string(Node n) {
  return "<node=" + n.name + " inbound=" + (n.inbound).join() + " outbound=" + (n.outbound).join() + ">";
}

Map<String, double> page_rank(List<Node> nodes, int limit, double d) {
  Map<String, double> ranks = <String, double>{};
  for (Node n in nodes) {
    ranks[n.name] = 1.0;
  }
  Map<String, double> outbounds = <String, double>{};
  for (Node n in nodes) {
    outbounds[n.name] = 1.0 * n.outbound.length;
  }
  int i = 0;
  while (i < limit) {
    print("======= Iteration " + _str(i + 1) + " =======");
    for (Node n in nodes) {
    double sum_val = 0.0;
    for (String ib in n.inbound) {
    sum_val = sum_val + (ranks[ib]!) / (outbounds[ib]!);
  }
    ranks[n.name] = 1.0 - d + d * sum_val;
  }
    print(ranks);
    i = i + 1;
  }
  return ranks;
}

List<String> names = ["A", "B", "C"];
List<List<int>> graph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]];
List<Node> nodes = <Node>[];
int ri = 0;
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  for (String name in names) {
    nodes = [...nodes, Node(name: name, inbound: [], outbound: [])];
  }
  while (ri < graph.length) {
    List<int> row = graph[ri];
    int ci = 0;
    while (ci < row.length) {
    if (row[ci] == 1) {
    Node n_in = nodes[ci];
    n_in.inbound = [...n_in.inbound, names[ri]];
    while (nodes.length <= ci) { nodes.add(null as dynamic); } nodes[ci] = n_in;
    Node n_out = nodes[ri];
    n_out.outbound = [...n_out.outbound, names[ci]];
    while (nodes.length <= ri) { nodes.add(null as dynamic); } nodes[ri] = n_out;
  }
    ci = ci + 1;
  }
    ri = ri + 1;
  }
  print("======= Nodes =======");
  for (Node n in nodes) {
    print(n);
  }
  page_rank(nodes, 3, 0.85);
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
