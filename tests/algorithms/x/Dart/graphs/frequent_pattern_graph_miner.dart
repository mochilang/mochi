// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) => v.toString();

class NodesData {
  Map<String, List<String>> map;
  List<String> keys;
  NodesData({required this.map, required this.keys});
}

class ClusterData {
  Map<int, List<String>> clusters;
  List<int> weights;
  ClusterData({required this.clusters, required this.weights});
}

class GraphData {
  Map<String, List<String>> edges;
  List<String> keys;
  GraphData({required this.edges, required this.keys});
}

List<List<List<String>>> EDGE_ARRAY = [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]];
bool contains(List<String> lst, String item) {
  for (String v in lst) {
    if (v == item) {
    return true;
  }
  }
  return false;
}

List<String> get_distinct_edge(List<List<List<String>>> edge_array) {
  List<String> distinct = <String>[];
  for (List<List<String>> row in edge_array) {
    for (List<String> item in row) {
    String e = item[0];
    if (!contains(distinct, e)) {
    distinct = [...distinct, e];
  }
  }
  }
  return distinct;
}

String get_bitcode(List<List<List<String>>> edge_array, String de) {
  String bitcode = "";
  int i = 0;
  while (i < edge_array.length) {
    bool found = false;
    for (List<String> item in edge_array[i]) {
    if (item[0] == de) {
    found = true;
    break;
  }
  }
    if (found) {
    bitcode = bitcode + "1";
  } else {
    bitcode = bitcode + "0";
  }
    i = i + 1;
  }
  return bitcode;
}

int count_ones(String s) {
  int c = 0;
  int i = 0;
  while (i < s.length) {
    if (_substr(s, i, i + 1) == "1") {
    c = c + 1;
  }
    i = i + 1;
  }
  return c;
}

List<Map<String, String>> get_frequency_table(List<List<List<String>>> edge_array) {
  List<String> distinct = get_distinct_edge(edge_array);
  List<Map<String, String>> table = <Map<String, String>>[];
  for (String e in distinct) {
    String bit = get_bitcode(edge_array, e);
    int cnt = count_ones(bit);
    Map<String, String> entry = {"edge": e, "count": _str(cnt), "bit": bit};
    table = [...table, entry];
  }
  int i = 0;
  while (i < table.length) {
    int max_i = i;
    int j = i + 1;
    while (j < table.length) {
    if (int.parse((table[j]["count"] ?? "")) > int.parse((table[max_i]["count"] ?? ""))) {
    max_i = j;
  }
    j = j + 1;
  }
    Map<String, String> tmp = table[i];
    while (table.length <= i) { table.add(<String, String>{}); } table[i] = table[max_i];
    while (table.length <= max_i) { table.add(<String, String>{}); } table[max_i] = tmp;
    i = i + 1;
  }
  return table;
}

NodesData get_nodes(List<Map<String, String>> freq_table) {
  Map<String, List<String>> nodes = <String, List<String>>{};
  List<String> keys = <String>[];
  for (Map<String, String> f in freq_table) {
    String code = f["bit"]!;
    String edge = f["edge"]!;
    if (nodes.containsKey(code)) {
    nodes[code] = [...(nodes[code]!), edge];
  } else {
    nodes[code] = [edge];
    keys = [...keys, code];
  }
  }
  return NodesData(map: nodes, keys: keys);
}

ClusterData get_cluster(NodesData nodes) {
  Map<int, List<String>> clusters = <int, List<String>>{};
  List<int> weights = <int>[];
  int i = 0;
  while (i < nodes.keys.length) {
    String code = nodes.keys[i];
    int wt = count_ones(code);
    if (clusters.containsKey(wt)) {
    clusters[wt] = [...(clusters[wt]!), code];
  } else {
    clusters[wt] = [code];
    weights = [...weights, wt];
  }
    i = i + 1;
  }
  return ClusterData(clusters: clusters, weights: weights);
}

List<int> get_support(ClusterData clusters) {
  List<int> sup = <int>[];
  int i = 0;
  while (i < clusters.weights.length) {
    int w = clusters.weights[i];
    sup = [...sup, w * 100 ~/ clusters.weights.length];
    i = i + 1;
  }
  return sup;
}

bool contains_bits(String a, String b) {
  int i = 0;
  while (i < a.length) {
    String c1 = _substr(a, i, i + 1);
    String c2 = _substr(b, i, i + 1);
    if (c1 == "1" && c2 != "1") {
    return false;
  }
    i = i + 1;
  }
  return true;
}

int max_cluster_key(ClusterData clusters) {
  int m = 0;
  int i = 0;
  while (i < clusters.weights.length) {
    int w = clusters.weights[i];
    if (w > m) {
    m = w;
  }
    i = i + 1;
  }
  return m;
}

List<String> get_cluster_codes(ClusterData clusters, int wt) {
  if (clusters.clusters.containsKey(wt)) {
    return (clusters.clusters[wt]!);
  }
  return List<String>.from([]);
}

List<String> create_edge(NodesData nodes, Map<String, List<String>> graph, List<String> gkeys, ClusterData clusters, int c1, int maxk) {
  List<String> keys = gkeys;
  List<String> codes1 = get_cluster_codes(clusters, c1);
  int idx1 = 0;
  while (idx1 < codes1.length) {
    String i_code = codes1[idx1];
    int count = 0;
    int c2 = c1 + 1;
    while (c2 <= maxk) {
    List<String> codes2 = get_cluster_codes(clusters, c2);
    int j = 0;
    while (j < codes2.length) {
    String j_code = codes2[j];
    if (contains_bits(i_code, j_code)) {
    if (graph.containsKey(i_code)) {
    graph[i_code] = [...(graph[i_code]!), j_code];
  } else {
    graph[i_code] = [j_code];
    if (!contains(keys, i_code)) {
    keys = [...keys, i_code];
  };
  };
    if (!contains(keys, j_code)) {
    keys = [...keys, j_code];
  };
    count = count + 1;
  }
    j = j + 1;
  }
    if (count == 0) {
    c2 = c2 + 1;
  } else {
    break;
  }
  }
    idx1 = idx1 + 1;
  }
  return keys;
}

GraphData construct_graph(ClusterData clusters, NodesData nodes) {
  int maxk = max_cluster_key(clusters);
  List<String> top_codes = get_cluster_codes(clusters, maxk);
  Map<String, List<String>> graph = <String, List<String>>{};
  List<String> keys = ["Header"];
  graph["Header"] = List<String>.from([]);
  int i = 0;
  while (i < top_codes.length) {
    String code = top_codes[i];
    graph["Header"] = [...(graph["Header"]!), code];
    graph[code] = ["Header"];
    keys = [...keys, code];
    i = i + 1;
  }
  int c = 1;
  while (c < maxk) {
    keys = create_edge(nodes, graph, keys, clusters, c, maxk);
    c = c + 1;
  }
  return GraphData(edges: graph, keys: keys);
}

List<List<String>> paths = <List<String>>[];
List<String> copy_list(List<String> lst) {
  List<String> n = <String>[];
  for (String v in lst) {
    n = [...n, v];
  }
  return n;
}

dynamic my_dfs(Map<String, List<String>> graph, String start, String end, List<String> path) {
  List<String> new_path = copy_list(path);
  new_path = [...new_path, start];
  if (start == end) {
    paths = ([...paths, new_path] as List<dynamic>).map((e) => (List<String>.from(e) as List<String>)).toList();
    return;
  }
  for (String node in (graph[start]!)) {
    bool seen = false;
    for (String p in new_path) {
    if (p == node) {
    seen = true;
  }
  }
    if (!seen) {
    my_dfs(graph, node, end, new_path);
  }
  }
}

dynamic find_freq_subgraph_given_support(int s, ClusterData clusters, GraphData graph) {
  int k = s * clusters.weights.length ~/ 100;
  List<String> codes = get_cluster_codes(clusters, k);
  int i = 0;
  while (i < codes.length) {
    my_dfs(graph.edges, codes[i], "Header", <String>[]);
    i = i + 1;
  }
}

List<String> node_edges(NodesData nodes, String code) {
  return (nodes.map[code]!);
}

List<List<List<String>>> freq_subgraphs_edge_list(List<List<String>> paths, NodesData nodes) {
  List<List<List<String>>> freq_sub_el = <List<List<String>>>[];
  for (List<String> path in paths) {
    List<List<String>> el = <List<String>>[];
    int j = 0;
    while (j < path.length - 1) {
    String code = path[j];
    List<String> edge_list = node_edges(nodes, code);
    int e = 0;
    while (e < edge_list.length) {
    String edge = edge_list[e];
    String a = _substr(edge, 0, 1);
    String b = _substr(edge, 1, 2);
    el = ([...el, [a, b]] as List<dynamic>).map((e) => (List<String>.from(e) as List<String>)).toList();
    e = e + 1;
  }
    j = j + 1;
  }
    freq_sub_el = ([...freq_sub_el, el] as List<dynamic>).map((e) => ((e as List<dynamic>).map((e) => (List<String>.from(e) as List<String>)).toList() as List<List<String>>)).toList();
  }
  return freq_sub_el;
}

dynamic print_all(NodesData nodes, List<int> support, ClusterData clusters, GraphData graph, List<List<List<String>>> freq_subgraph_edge_list) {
  print("\nNodes\n");
  int i = 0;
  while (i < nodes.keys.length) {
    String code = nodes.keys[i];
    print(code);
    print((nodes.map[code]!));
    i = i + 1;
  }
  print("\nSupport\n");
  print(support);
  print("\nCluster\n");
  int j = 0;
  while (j < clusters.weights.length) {
    int w = clusters.weights[j];
    print(_str(w) + ":" + _str((clusters.clusters[w]!)));
    j = j + 1;
  }
  print("\nGraph\n");
  int k = 0;
  while (k < graph.keys.length) {
    String key = graph.keys[k];
    print(key);
    print((graph.edges[key]!));
    k = k + 1;
  }
  print("\nEdge List of Frequent subgraphs\n");
  for (List<List<String>> el in freq_subgraph_edge_list) {
    print(el);
  }
}

void _main() {
  List<Map<String, String>> frequency_table = get_frequency_table(EDGE_ARRAY);
  NodesData nodes = get_nodes(frequency_table);
  ClusterData clusters = get_cluster(nodes);
  List<int> support = get_support(clusters);
  GraphData graph = construct_graph(clusters, nodes);
  find_freq_subgraph_given_support(60, clusters, graph);
  List<List<List<String>>> freq_subgraph_edge_list = freq_subgraphs_edge_list(paths, nodes);
  print_all(nodes, support, clusters, graph, freq_subgraph_edge_list);
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
