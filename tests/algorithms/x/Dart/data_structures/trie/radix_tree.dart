// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

class RadixNode {
  String prefix;
  bool is_leaf;
  Map<String, int> children;
  RadixNode({required this.prefix, required this.is_leaf, required this.children});
}

class RadixTree {
  List<RadixNode> nodes;
  RadixTree({required this.nodes});
}

class MatchResult {
  String common;
  String rem_prefix;
  String rem_word;
  MatchResult({required this.common, required this.rem_prefix, required this.rem_word});
}

RadixNode new_node(String prefix, bool is_leaf) {
  return RadixNode(prefix: prefix, is_leaf: is_leaf, children: {});
}

RadixTree new_tree() {
  List<RadixNode> nodes = [new_node("", false)];
  return RadixTree(nodes: nodes);
}

MatchResult match_prefix(RadixNode node, String word) {
  int x = 0;
  String p = node.prefix;
  String w = word;
  int min_len = p.length;
  if (w.length < min_len) {
    min_len = w.length;
  }
  while (x < min_len) {
    if (_substr(p, x, x + 1) != _substr(w, x, x + 1)) {
    break;
  }
    x = x + 1;
  }
  String common = _substr(p, 0, x);
  String rem_prefix = _substr(p, x, p.length);
  String rem_word = _substr(w, x, w.length);
  return MatchResult(common: common, rem_prefix: rem_prefix, rem_word: rem_word);
}

void insert_many(RadixTree tree, List<String> words) {
  for (String w in words) {
    insert(tree, 0, w);
  }
}

void insert(RadixTree tree, int idx, String word) {
  List<RadixNode> nodes = tree.nodes;
  RadixNode node = nodes[idx];
  if (node.prefix == word && !node.is_leaf) {
    node.is_leaf = true;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    tree.nodes = nodes;
    return;
  }
  String first = _substr(word, 0, 1);
  Map<String, int> children = node.children;
  if (!has_key(children, first)) {
    int new_idx = nodes.length;
    nodes = (nodes..add(new_node(word, true)));
    children[first] = new_idx;
    node.children = children;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    tree.nodes = nodes;
    return;
  }
  int child_idx = children[first]!;
  RadixNode child = nodes[child_idx];
  MatchResult res = match_prefix(child, word);
  if (res.rem_prefix == "") {
    insert(tree, child_idx, res.rem_word);
    return;
  }
  child.prefix = res.rem_prefix;
  while (nodes.length <= child_idx) { nodes.add(null as dynamic); } nodes[child_idx] = child;
  Map<String, int> new_children = <String, int>{};
  new_children[_substr(res.rem_prefix, 0, 1)] = child_idx;
  int new_idx = nodes.length;
  nodes = (nodes..add(new_node(res.common, false)));
  nodes[new_idx]!.children = new_children;
  if (res.rem_word == "") {
    nodes[new_idx]!.is_leaf = true;
  } else {
    insert(tree, new_idx, res.rem_word);
  }
  children[first] = new_idx;
  node.children = children;
  while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
  tree.nodes = nodes;
}

bool find(RadixTree tree, int idx, String word) {
  List<RadixNode> nodes = tree.nodes;
  RadixNode node = nodes[idx];
  String first = _substr(word, 0, 1);
  Map<String, int> children = node.children;
  if (!has_key(children, first)) {
    return false;
  }
  int child_idx = children[first]!;
  RadixNode child = nodes[child_idx];
  MatchResult res = match_prefix(child, word);
  if (res.rem_prefix != "") {
    return false;
  }
  if (res.rem_word == "") {
    return child.is_leaf;
  }
  return find(tree, child_idx, res.rem_word);
}

Map<String, int> remove_key(Map<String, int> m, String k) {
  Map<String, int> out = <String, int>{};
  for (String key in m.keys) {
    if (key != k) {
    out[key] = m[key]!;
  }
  }
  return out;
}

bool has_key(Map<String, int> m, String k) {
  for (String key in m.keys) {
    if (key == k) {
    return true;
  }
  }
  return false;
}

bool delete(RadixTree tree, int idx, String word) {
  List<RadixNode> nodes = tree.nodes;
  RadixNode node = nodes[idx];
  String first = _substr(word, 0, 1);
  Map<String, int> children = node.children;
  if (!has_key(children, first)) {
    return false;
  }
  int child_idx = children[first]!;
  RadixNode child = nodes[child_idx];
  MatchResult res = match_prefix(child, word);
  if (res.rem_prefix != "") {
    return false;
  }
  if (res.rem_word != "") {
    bool deleted = delete(tree, child_idx, res.rem_word);
    if (deleted) {
    nodes = tree.nodes;
    node = nodes[idx];
  };
    return deleted;
  }
  if (!child.is_leaf) {
    return false;
  }
  if (child.children.length == 0) {
    children = remove_key(children, first);
    node.children = children;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    tree.nodes = nodes;
    if (children.length == 1 && !node.is_leaf) {
    String only_key = "";
    for (String k in children.keys) {
    only_key = k;
  };
    int merge_idx = children[only_key]!;
    RadixNode merge_node = nodes[merge_idx];
    node.is_leaf = merge_node.is_leaf;
    node.prefix = node.prefix + merge_node.prefix;
    node.children = merge_node.children;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    tree.nodes = nodes;
  };
  } else {
    if (child.children.length > 1) {
    child.is_leaf = false;
    while (nodes.length <= child_idx) { nodes.add(null as dynamic); } nodes[child_idx] = child;
    tree.nodes = nodes;
  } else {
    String only_key = "";
    for (String k in child.children.keys) {
    only_key = k;
  };
    int merge_idx = child.children[only_key]!;
    RadixNode merge_node = nodes[merge_idx];
    child.is_leaf = merge_node.is_leaf;
    child.prefix = child.prefix + merge_node.prefix;
    child.children = merge_node.children;
    while (nodes.length <= child_idx) { nodes.add(null as dynamic); } nodes[child_idx] = child;
    tree.nodes = nodes;
  };
  }
  return true;
}

void print_tree(RadixTree tree, int idx, int height) {
  List<RadixNode> nodes = tree.nodes;
  RadixNode node = nodes[idx];
  if (node.prefix != "") {
    String line = "";
    int i = 0;
    while (i < height) {
    line = line + "-";
    i = i + 1;
  };
    line = line + " " + node.prefix;
    if (node.is_leaf) {
    line = line + "  (leaf)";
  };
    print(line);
  }
  Map<String, int> children = node.children;
  for (String k in children.keys) {
    int child_idx = children[k]!;
    print_tree(tree, child_idx, height + 1);
  }
}

bool test_trie() {
  List<String> words = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"];
  RadixTree tree = new_tree();
  insert_many(tree, words);
  bool ok = true;
  for (String w in words) {
    if (!find(tree, 0, w)) {
    ok = false;
  }
  }
  if (find(tree, 0, "bandanas")) {
    ok = false;
  }
  if (find(tree, 0, "apps")) {
    ok = false;
  }
  delete(tree, 0, "all");
  if (find(tree, 0, "all")) {
    ok = false;
  }
  delete(tree, 0, "banana");
  if (find(tree, 0, "banana")) {
    ok = false;
  }
  if (!find(tree, 0, "bananas")) {
    ok = false;
  }
  return ok;
}

void pytests() {
  if (!test_trie()) {
    throw Exception("test failed");
  }
}

void _main() {
  RadixTree tree = new_tree();
  List<String> words = ["banana", "bananas", "bandanas", "bandana", "band", "apple", "all", "beast"];
  insert_many(tree, words);
  print("Words: " + _str(words));
  print("Tree:");
  print_tree(tree, 0, 0);
}

void _start() {
  _main();
}

void main() => _start();
