// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

class Node {
  Map<String, int> children;
  bool is_leaf;
  Node({required this.children, required this.is_leaf});
}

class Trie {
  List<Node> nodes;
  Trie({required this.nodes});
}

Trie new_trie() {
  return Trie(nodes: [Node(children: {}, is_leaf: false)]);
}

Map<String, int> remove_key(Map<String, int> m, String k) {
  Map<String, int> out = <String, int>{};
  for (String key in m.keys) {
    if (key != k) {
    out[key] = m[key]!;
  }
  }
  return out;
}

void insert(Trie trie, String word) {
  List<Node> nodes = trie.nodes;
  int curr = 0;
  int i = 0;
  while (i < word.length) {
    String ch = word.substring(i, i + 1);
    int child_idx = -1;
    Map<String, int> children = nodes[curr].children;
    if (children.containsKey(ch)) {
    child_idx = children[ch]!;
  } else {
    Node new_node = Node(children: {}, is_leaf: false);
    nodes = [...nodes, new_node];
    child_idx = nodes.length - 1;
    Map<String, int> new_children = children;
    new_children[ch] = child_idx;
    Node node = nodes[curr];
    node.children = new_children;
    while (nodes.length <= curr) { nodes.add(null as dynamic); } nodes[curr] = node;
  }
    curr = child_idx;
    i = i + 1;
  }
  Node node = nodes[curr];
  node.is_leaf = true;
  while (nodes.length <= curr) { nodes.add(null as dynamic); } nodes[curr] = node;
  trie.nodes = nodes;
}

void insert_many(Trie trie, List<String> words) {
  for (String w in words) {
    insert(trie, w);
  }
}

bool find(Trie trie, String word) {
  List<Node> nodes = trie.nodes;
  int curr = 0;
  int i = 0;
  while (i < word.length) {
    String ch = word.substring(i, i + 1);
    Map<String, int> children = nodes[curr].children;
    if (!children.containsKey(ch)) {
    return false;
  }
    curr = children[ch]!;
    i = i + 1;
  }
  Node node = nodes[curr];
  return node.is_leaf;
}

void delete(Trie trie, String word) {
  List<Node> nodes = trie.nodes;
  bool _delete(int idx, int pos) {
  if (pos == word.length) {
    Node node = nodes[idx];
    if (node.is_leaf == false) {
    return false;
  };
    node.is_leaf = false;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    return node.children.length == 0;
  }
  Node node = nodes[idx];
  Map<String, int> children = node.children;
  String ch = word.substring(pos, pos + 1);
  if (!children.containsKey(ch)) {
    return false;
  }
  int child_idx = children[ch]!;
  bool should_delete = _delete(child_idx, pos + 1);
  node = nodes[idx];
  if (should_delete) {
    Map<String, int> new_children = remove_key(node.children, ch);
    node.children = new_children;
    while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
    return new_children.length == 0 && node.is_leaf == false;
  }
  while (nodes.length <= idx) { nodes.add(null as dynamic); } nodes[idx] = node;
  return false;
}
  _delete(0, 0);
  trie.nodes = nodes;
}

void print_words(Trie trie) {
  void dfs(int idx, String word) {
  Node node = trie.nodes[idx];
  if (node.is_leaf) {
    print(word);
  }
  for (String key in node.children.keys) {
    dfs((node.children[key] ?? 0), word + key);
  }
}
  dfs(0, "");
}

bool test_trie() {
  List<String> words = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"];
  Trie trie = new_trie();
  insert_many(trie, words);
  bool ok = true;
  for (String w in words) {
    ok = ok && find(trie, w);
  }
  ok = ok && find(trie, "banana");
  bool t = find(trie, "bandanas");
  ok = ok && t == false;
  bool t2 = find(trie, "apps");
  ok = ok && t2 == false;
  ok = ok && find(trie, "apple");
  ok = ok && find(trie, "all");
  delete(trie, "all");
  bool t3 = find(trie, "all");
  ok = ok && t3 == false;
  delete(trie, "banana");
  bool t4 = find(trie, "banana");
  ok = ok && t4 == false;
  ok = ok && find(trie, "bananas");
  return ok;
}

void print_results(String msg, bool passes) {
  if (passes) {
    print(msg + " works!");
  } else {
    print(msg + " doesn't work :(");
  }
}

Trie trie = new_trie();
void main() {
  print_results("Testing trie functionality", test_trie());
}
