// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _str(dynamic v) => v.toString();

class HashTableWithLinkedList {
  int size_table;
  int charge_factor;
  List<List<int>> values;
  Map<int, List<int>> keys;
  HashTableWithLinkedList({required this.size_table, required this.charge_factor, required this.values, required this.keys});
}

HashTableWithLinkedList make_table(int size_table, int charge_factor) {
  List<List<int>> vals = <List<int>>[];
  int i = 0;
  while (i < size_table) {
    vals = [...vals, []];
    i = i + 1;
  }
  return HashTableWithLinkedList(size_table: size_table, charge_factor: charge_factor, values: vals, keys: {});
}

int hash_function(HashTableWithLinkedList ht, int key) {
  int res = key % ht.size_table;
  if (res < 0) {
    res = res + ht.size_table;
  }
  return res;
}

List<int> prepend(List<int> lst, int value) {
  List<int> result = [value];
  int i = 0;
  while (i < lst.length) {
    result = [...result, lst[i]];
    i = i + 1;
  }
  return result;
}

void set_value(HashTableWithLinkedList ht, int key, int data) {
  List<int> current = ht.values[key];
  List<int> updated = prepend(current, data);
  List<List<int>> vals = ht.values;
  while (vals.length <= key) { vals.add(<int>[]); } vals[key] = updated;
  ht.values = vals;
  Map<int, List<int>> ks = ht.keys;
  ks[key] = updated;
  ht.keys = ks;
}

int count_empty(HashTableWithLinkedList ht) {
  int count = 0;
  int i = 0;
  while (i < ht.values.length) {
    if (ht.values[i].length == 0) {
    count = count + 1;
  }
    i = i + 1;
  }
  return count;
}

double balanced_factor(HashTableWithLinkedList ht) {
  int total = 0;
  int i = 0;
  while (i < ht.values.length) {
    total = total + (ht.charge_factor - ht.values[i].length);
    i = i + 1;
  }
  return total.toDouble() / ht.size_table.toDouble() * ht.charge_factor.toDouble();
}

int collision_resolution(HashTableWithLinkedList ht, int key) {
  if (!(ht.values[key].length == ht.charge_factor && count_empty(ht) == 0)) {
    return key;
  }
  int new_key = (key + 1) % ht.size_table;
  int steps = 0;
  while (ht.values[new_key].length == ht.charge_factor && steps < ht.size_table - 1) {
    new_key = (new_key + 1) % ht.size_table;
    steps = steps + 1;
  }
  if (ht.values[new_key].length < ht.charge_factor) {
    return new_key;
  }
  return -1;
}

void insert(HashTableWithLinkedList ht, int data) {
  int key = hash_function(ht, data);
  if (ht.values[key].length == 0 || ht.values[key].length < ht.charge_factor) {
    set_value(ht, key, data);
    return;
  }
  int dest = collision_resolution(ht, key);
  if (dest >= 0) {
    set_value(ht, dest, data);
  } else {
    print("table full");
  }
}

void _main() {
  HashTableWithLinkedList ht = make_table(3, 2);
  insert(ht, 10);
  insert(ht, 20);
  insert(ht, 30);
  insert(ht, 40);
  insert(ht, 50);
  print(_str(ht.values));
  print(_str(balanced_factor(ht)));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
