// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class HashTableWithLinkedList {
  int size_table;
  int charge_factor;
  List<List<int>> values;
  Map<int, List<int>> keys;
  HashTableWithLinkedList({required this.size_table, required this.charge_factor, required this.values, required this.keys});
}

HashTableWithLinkedList make_table(int size_table, int charge_factor) {
  List<List<int>> vals = <List<int>>[];
  int i = 0;
  while (i < size_table) {
    vals = [...vals, []];
    i = i + 1;
  }
  return HashTableWithLinkedList(size_table: size_table, charge_factor: charge_factor, values: vals, keys: {});
}

int hash_function(HashTableWithLinkedList ht, int key) {
  int res = key % ht.size_table;
  if (res < 0) {
    res = res + ht.size_table;
  }
  return res;
}

List<int> prepend(List<int> lst, int value) {
  List<int> result = [value];
  int i = 0;
  while (i < lst.length) {
    result = [...result, lst[i]];
    i = i + 1;
  }
  return result;
}

void set_value(HashTableWithLinkedList ht, int key, int data) {
  List<int> current = ht.values[key];
  List<int> updated = prepend(current, data);
  List<List<int>> vals = ht.values;
  while (vals.length <= key) { vals.add(<int>[]); } vals[key] = updated;
  ht.values = vals;
  Map<int, List<int>> ks = ht.keys;
  ks[key] = updated;
  ht.keys = ks;
}

int count_empty(HashTableWithLinkedList ht) {
  int count = 0;
  int i = 0;
  while (i < ht.values.length) {
    if (ht.values[i].length == 0) {
    count = count + 1;
  }
    i = i + 1;
  }
  return count;
}

double balanced_factor(HashTableWithLinkedList ht) {
  int total = 0;
  int i = 0;
  while (i < ht.values.length) {
    total = total + (ht.charge_factor - ht.values[i].length);
    i = i + 1;
  }
  return (total as double) / (ht.size_table as double) * (ht.charge_factor as double);
}

int collision_resolution(HashTableWithLinkedList ht, int key) {
  if (!(ht.values[key].length == ht.charge_factor && count_empty(ht) == 0)) {
    return key;
  }
  int new_key = (key + 1) % ht.size_table;
  int steps = 0;
  while (ht.values[new_key].length == ht.charge_factor && steps < ht.size_table - 1) {
    new_key = (new_key + 1) % ht.size_table;
    steps = steps + 1;
  }
  if (ht.values[new_key].length < ht.charge_factor) {
    return new_key;
  }
  return -1;
}

void insert(HashTableWithLinkedList ht, int data) {
  int key = hash_function(ht, data);
  if (ht.values[key].length == 0 || ht.values[key].length < ht.charge_factor) {
    set_value(ht, key, data);
    return;
  }
  int dest = collision_resolution(ht, key);
  if (dest >= 0) {
    set_value(ht, dest, data);
  } else {
    print("table full");
  }
}

void _main() {
  HashTableWithLinkedList ht = make_table(3, 2);
  insert(ht, 10);
  insert(ht, 20);
  insert(ht, 30);
  insert(ht, 40);
  insert(ht, 50);
  print((ht.values).toString());
  print((balanced_factor(ht)).toString());
}

void _start() {
  _main();
}

void main() => _start();
