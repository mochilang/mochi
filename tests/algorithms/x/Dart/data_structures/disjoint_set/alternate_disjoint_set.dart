// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class DisjointSet {
  List<int> set_counts;
  int max_set;
  List<int> ranks;
  List<int> parents;
  DisjointSet({required this.set_counts, required this.max_set, required this.ranks, required this.parents});
}

int max_list(List<int> xs) {
  int m = xs[0];
  int i = 1;
  while (i < xs.length) {
    if (xs[i] > m) {
    m = xs[i];
  }
    i = i + 1;
  }
  return m;
}

DisjointSet disjoint_set_new(List<int> set_counts) {
  int max_set = max_list(set_counts);
  int num_sets = set_counts.length;
  List<int> ranks = <int>[];
  List<int> parents = <int>[];
  int i = 0;
  while (i < num_sets) {
    ranks = [...ranks, 1];
    parents = [...parents, i];
    i = i + 1;
  }
  return DisjointSet(set_counts: set_counts, max_set: max_set, ranks: ranks, parents: parents);
}

int get_parent(DisjointSet ds, int idx) {
  if (ds.parents[idx] == idx) {
    return idx;
  }
  List<int> parents = ds.parents;
  while (parents.length <= idx) { parents.add(0); } parents[idx] = get_parent(ds, parents[idx]);
  ds.parents = parents;
  return ds.parents[idx];
}

bool merge(DisjointSet ds, int src, int dst) {
  int src_parent = get_parent(ds, src);
  int dst_parent = get_parent(ds, dst);
  if (src_parent == dst_parent) {
    return false;
  }
  if (ds.ranks[dst_parent] >= ds.ranks[src_parent]) {
    List<int> counts = ds.set_counts;
    while (counts.length <= dst_parent) { counts.add(0); } counts[dst_parent] = counts[dst_parent] + counts[src_parent];
    while (counts.length <= src_parent) { counts.add(0); } counts[src_parent] = 0;
    ds.set_counts = counts;
    List<int> parents = ds.parents;
    while (parents.length <= src_parent) { parents.add(0); } parents[src_parent] = dst_parent;
    ds.parents = parents;
    if (ds.ranks[dst_parent] == ds.ranks[src_parent]) {
    List<int> ranks = ds.ranks;
    while (ranks.length <= dst_parent) { ranks.add(0); } ranks[dst_parent] = ranks[dst_parent] + 1;
    ds.ranks = ranks;
  };
    int joined = ds.set_counts[dst_parent];
    if (joined > ds.max_set) {
    ds.max_set = joined;
  };
  } else {
    List<int> counts = ds.set_counts;
    while (counts.length <= src_parent) { counts.add(0); } counts[src_parent] = counts[src_parent] + counts[dst_parent];
    while (counts.length <= dst_parent) { counts.add(0); } counts[dst_parent] = 0;
    ds.set_counts = counts;
    List<int> parents = ds.parents;
    while (parents.length <= dst_parent) { parents.add(0); } parents[dst_parent] = src_parent;
    ds.parents = parents;
    int joined = ds.set_counts[src_parent];
    if (joined > ds.max_set) {
    ds.max_set = joined;
  };
  }
  return true;
}

DisjointSet ds = disjoint_set_new([1, 1, 1]);
void main() {
  print(merge(ds, 1, 2));
  print(merge(ds, 0, 2));
  print(merge(ds, 0, 1));
  print(get_parent(ds, 0));
  print(get_parent(ds, 1));
  print(ds.max_set);
}
