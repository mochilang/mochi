// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Node {
  int data;
  int prev_index;
  int next_index;
  Node({required this.data, required this.prev_index, required this.next_index});
}

class LinkedList {
  List<Node> nodes;
  int head_idx;
  int tail_idx;
  LinkedList({required this.nodes, required this.head_idx, required this.tail_idx});
}

LinkedList empty_list() {
  return LinkedList(nodes: [], head_idx: -1, tail_idx: -1);
}

int get_head_data(LinkedList ll) {
  if (ll.head_idx == -1) {
    return -1;
  }
  Node node = ll.nodes[ll.head_idx];
  return node.data;
}

int get_tail_data(LinkedList ll) {
  if (ll.tail_idx == -1) {
    return -1;
  }
  Node node = ll.nodes[ll.tail_idx];
  return node.data;
}

void insert_before_node(LinkedList ll, int idx, int new_idx) {
  List<Node> nodes = ll.nodes;
  Node new_node = nodes[new_idx];
  new_node.next_index = idx;
  Node node = nodes[idx];
  int p = node.prev_index;
  new_node.prev_index = p;
  while (nodes.length <= new_idx) { nodes.add(null); } nodes[new_idx] = new_node;
  if (p == -1) {
    ll.head_idx = new_idx;
  } else {
    Node prev_node = nodes[p];
    prev_node.next_index = new_idx;
    while (nodes.length <= p) { nodes.add(null); } nodes[p] = prev_node;
  }
  node.prev_index = new_idx;
  while (nodes.length <= idx) { nodes.add(null); } nodes[idx] = node;
  ll.nodes = nodes;
}

void insert_after_node(LinkedList ll, int idx, int new_idx) {
  List<Node> nodes = ll.nodes;
  Node new_node = nodes[new_idx];
  new_node.prev_index = idx;
  Node node = nodes[idx];
  int nxt = node.next_index;
  new_node.next_index = nxt;
  while (nodes.length <= new_idx) { nodes.add(null); } nodes[new_idx] = new_node;
  if (nxt == -1) {
    ll.tail_idx = new_idx;
  } else {
    Node next_node = nodes[nxt];
    next_node.prev_index = new_idx;
    while (nodes.length <= nxt) { nodes.add(null); } nodes[nxt] = next_node;
  }
  node.next_index = new_idx;
  while (nodes.length <= idx) { nodes.add(null); } nodes[idx] = node;
  ll.nodes = nodes;
}

void set_head(LinkedList ll, int idx) {
  if (ll.head_idx == -1) {
    ll.head_idx = idx;
    ll.tail_idx = idx;
  } else {
    insert_before_node(ll, ll.head_idx, idx);
  }
}

void set_tail(LinkedList ll, int idx) {
  if (ll.tail_idx == -1) {
    ll.head_idx = idx;
    ll.tail_idx = idx;
  } else {
    insert_after_node(ll, ll.tail_idx, idx);
  }
}

void insert(LinkedList ll, int value) {
  List<Node> nodes = ll.nodes;
  nodes = [...nodes, Node(data: value, prev_index: -1, next_index: -1)];
  int idx = nodes.length - 1;
  ll.nodes = nodes;
  if (ll.head_idx == -1) {
    ll.head_idx = idx;
    ll.tail_idx = idx;
  } else {
    insert_after_node(ll, ll.tail_idx, idx);
  }
}

void insert_at_position(LinkedList ll, int position, int value) {
  int current = ll.head_idx;
  int current_pos = 1;
  while (current != -1) {
    if (current_pos == position) {
    List<Node> nodes = ll.nodes;
    nodes = [...nodes, Node(data: value, prev_index: -1, next_index: -1)];
    int new_idx = nodes.length - 1;
    ll.nodes = nodes;
    insert_before_node(ll, current, new_idx);
    return;
  }
    Node node = ll.nodes[current];
    current = node.next_index;
    current_pos = current_pos + 1;
  }
  insert(ll, value);
}

int get_node(LinkedList ll, int item) {
  int current = ll.head_idx;
  while (current != -1) {
    Node node = ll.nodes[current];
    if (node.data == item) {
    return current;
  }
    current = node.next_index;
  }
  return -1;
}

void remove_node_pointers(LinkedList ll, int idx) {
  List<Node> nodes = ll.nodes;
  Node node = nodes[idx];
  int nxt = node.next_index;
  int p = node.prev_index;
  if (nxt != -1) {
    Node nxt_node = nodes[nxt];
    nxt_node.prev_index = p;
    while (nodes.length <= nxt) { nodes.add(null); } nodes[nxt] = nxt_node;
  }
  if (p != -1) {
    Node prev_node = nodes[p];
    prev_node.next_index = nxt;
    while (nodes.length <= p) { nodes.add(null); } nodes[p] = prev_node;
  }
  node.next_index = -1;
  node.prev_index = -1;
  while (nodes.length <= idx) { nodes.add(null); } nodes[idx] = node;
  ll.nodes = nodes;
}

void delete_value(LinkedList ll, int value) {
  int idx = get_node(ll, value);
  if (idx == -1) {
    return;
  }
  if (idx == ll.head_idx) {
    Node node = ll.nodes[idx];
    ll.head_idx = node.next_index;
  }
  if (idx == ll.tail_idx) {
    Node node = ll.nodes[idx];
    ll.tail_idx = node.prev_index;
  }
  remove_node_pointers(ll, idx);
}

bool contains(LinkedList ll, int value) {
  return get_node(ll, value) != -1;
}

bool is_empty(LinkedList ll) {
  return ll.head_idx == -1;
}

String to_string(LinkedList ll) {
  String res = "";
  bool first = true;
  int current = ll.head_idx;
  while (current != -1) {
    Node node = ll.nodes[current];
    String val = (node.data).toString();
    if (first) {
    res = val;
    first = false;
  } else {
    res = res + " " + val;
  }
    current = node.next_index;
  }
  return res;
}

void print_list(LinkedList ll) {
  int current = ll.head_idx;
  while (current != -1) {
    Node node = ll.nodes[current];
    print((node.data).toString());
    current = node.next_index;
  }
}

void _main() {
  LinkedList ll = empty_list();
  print((get_head_data(ll)).toString());
  print((get_tail_data(ll)).toString());
  print((is_empty(ll)).toString());
  insert(ll, 10);
  print((get_head_data(ll)).toString());
  print((get_tail_data(ll)).toString());
  insert_at_position(ll, 3, 20);
  print((get_head_data(ll)).toString());
  print((get_tail_data(ll)).toString());
  List<Node> nodes = ll.nodes;
  nodes = [...nodes, Node(data: 1000, prev_index: -1, next_index: -1)];
  int idx_head = nodes.length - 1;
  ll.nodes = nodes;
  set_head(ll, idx_head);
  nodes = ll.nodes;
  nodes = [...nodes, Node(data: 2000, prev_index: -1, next_index: -1)];
  int idx_tail = nodes.length - 1;
  ll.nodes = nodes;
  set_tail(ll, idx_tail);
  print_list(ll);
  print((is_empty(ll)).toString());
  print_list(ll);
  print((ll.contains(10)).toString());
  delete_value(ll, 10);
  print((ll.contains(10)).toString());
  delete_value(ll, 2000);
  print((get_tail_data(ll)).toString());
  delete_value(ll, 1000);
  print((get_tail_data(ll)).toString());
  print((get_head_data(ll)).toString());
  print_list(ll);
  delete_value(ll, 20);
  print_list(ll);
  int i = 1;
  while (i < 10) {
    insert(ll, i);
    i = i + 1;
  }
  print_list(ll);
  LinkedList ll2 = empty_list();
  insert_at_position(ll2, 1, 10);
  print(to_string(ll2));
  insert_at_position(ll2, 2, 20);
  print(to_string(ll2));
  insert_at_position(ll2, 1, 30);
  print(to_string(ll2));
  insert_at_position(ll2, 3, 40);
  print(to_string(ll2));
  insert_at_position(ll2, 5, 50);
  print(to_string(ll2));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
