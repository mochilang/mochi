// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

BigInt NIL = BigInt.from(0 - 1);
int MAX_LEVEL = 6;
double P = 0.5;
int seed = 1;
double random() {
  seed = (seed * 13 + 7) % 100;
  return (seed as double) / 100.0;
}

int random_level() {
  int lvl = 1;
  while (random() < P && lvl < MAX_LEVEL) {
    lvl = lvl + 1;
  }
  return lvl;
}

List<int> empty_forward() {
  List<int> f = <int>[];
  int i = 0;
  while (i < MAX_LEVEL) {
    f = ([...f, NIL] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
    i = i + 1;
  }
  return f;
}

List<int> node_keys = <int>[];
List<int> node_vals = <int>[];
List<List<int>> node_forwards = <List<int>>[];
int level = 1;
void init() {
  node_keys = [-1];
  node_vals = [0];
  node_forwards = [empty_forward()];
  level = 1;
}

void insert(int key, int value) {
  List<int> update = <int>[];
  int i = 0;
  while (i < MAX_LEVEL) {
    update = [...update, 0];
    i = i + 1;
  }
  int x = 0;
  i = level - 1;
  while (i >= 0) {
    while (BigInt.from(node_forwards[x][i]) != NIL && node_keys[node_forwards[x][i]] < key) {
    x = node_forwards[x][i];
  }
    while (update.length <= i) { update.add(0); } update[i] = x;
    i = i - 1;
  }
  x = node_forwards[x][0];
  if (BigInt.from(x) != NIL && node_keys[x] == key) {
    while (node_vals.length <= x) { node_vals.add(0); } node_vals[x] = value;
    return;
  }
  int lvl = random_level();
  if (lvl > level) {
    int j = level;
    while (j < lvl) {
    while (update.length <= j) { update.add(0); } update[j] = 0;
    j = j + 1;
  };
    level = lvl;
  }
  node_keys = [...node_keys, key];
  node_vals = [...node_vals, value];
  List<int> forwards = empty_forward();
  int idx = node_keys.length - 1;
  i = 0;
  while (i < lvl) {
    while (forwards.length <= i) { forwards.add(0); } forwards[i] = node_forwards[update[i]][i];
    while (node_forwards[update[i]]!.length <= i) { node_forwards[update[i]]!.add(0); } node_forwards[update[i]]![i] = idx;
    i = i + 1;
  }
  node_forwards = ([...node_forwards, forwards] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
}

int find(int key) {
  int x = 0;
  int i = level - 1;
  while (i >= 0) {
    while (BigInt.from(node_forwards[x][i]) != NIL && node_keys[node_forwards[x][i]] < key) {
    x = node_forwards[x][i];
  }
    i = i - 1;
  }
  x = node_forwards[x][0];
  if (BigInt.from(x) != NIL && node_keys[x] == key) {
    return node_vals[x];
  }
  return -1;
}

void delete(int key) {
  List<int> update = <int>[];
  int i = 0;
  while (i < MAX_LEVEL) {
    update = [...update, 0];
    i = i + 1;
  }
  int x = 0;
  i = level - 1;
  while (i >= 0) {
    while (BigInt.from(node_forwards[x][i]) != NIL && node_keys[node_forwards[x][i]] < key) {
    x = node_forwards[x][i];
  }
    while (update.length <= i) { update.add(0); } update[i] = x;
    i = i - 1;
  }
  x = node_forwards[x][0];
  if (BigInt.from(x) == NIL || node_keys[x] != key) {
    return;
  }
  i = 0;
  while (i < level) {
    if (node_forwards[update[i]][i] == x) {
    while (node_forwards[update[i]]!.length <= i) { node_forwards[update[i]]!.add(0); } node_forwards[update[i]]![i] = node_forwards[x][i];
  }
    i = i + 1;
  }
  while (level > 1 && BigInt.from(node_forwards[0][level - 1]) == NIL) {
    level = level - 1;
  }
}

String to_string() {
  String s = "";
  int x = node_forwards[0][0];
  while (BigInt.from(x) != NIL) {
    if (s != "") {
    s = s + " -> ";
  }
    s = s + (node_keys[x]).toString() + ":" + (node_vals[x]).toString();
    x = node_forwards[x][0];
  }
  return s;
}

void _main() {
  init();
  insert(2, 2);
  insert(4, 4);
  insert(6, 4);
  insert(4, 5);
  insert(8, 4);
  insert(9, 4);
  delete(4);
  print(to_string());
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
