// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class KDNode {
  List<double> point;
  int left;
  int right;
  KDNode({required this.point, required this.left, required this.right});
}

List<KDNode> tree = <KDNode>[];
List<List<double>> sort_points(List<List<double>> points, int axis) {
  List<List<double>> arr = points;
  int i = 0;
  while (i < arr.length) {
    int j = 0;
    while (j < arr.length - 1) {
    if (arr[j][axis] > arr[j + 1][axis]) {
    List<double> tmp = arr[j];
    while (arr.length <= j) { arr.add(<double>[]); } arr[j] = arr[j + 1];
    while (arr.length <= j + 1) { arr.add(<double>[]); } arr[j + 1] = tmp;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return arr;
}

int build_kdtree(List<List<double>> points, int depth) {
  if (points.length == 0) {
    return 0 - 1;
  }
  int k = points[0].length;
  int axis = depth % k;
  List<List<double>> sorted = sort_points(points, axis);
  int median_idx = sorted.length ~/ 2;
  List<List<double>> left_points = sorted.sublist(0, median_idx);
  List<List<double>> right_points = sorted.sublist(median_idx + 1, sorted.length);
  int idx = tree.length;
  tree = [...tree, KDNode(point: sorted[median_idx], left: 0 - 1, right: 0 - 1)];
  int left_idx = build_kdtree(left_points, depth + 1);
  int right_idx = build_kdtree(right_points, depth + 1);
  KDNode node = tree[idx];
  node.left = left_idx;
  node.right = right_idx;
  while (tree.length <= idx) { tree.add(null as dynamic); } tree[idx] = node;
  return idx;
}

List<List<double>> pts = [[2.0, 3.0], [5.0, 4.0], [9.0, 6.0], [4.0, 7.0], [8.0, 1.0], [7.0, 2.0]];
int root = build_kdtree(pts, 0);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print((tree).toString());
  print(root);
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
