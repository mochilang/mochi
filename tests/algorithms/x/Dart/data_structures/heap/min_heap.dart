// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Node {
  String name;
  int val;
  Node({required this.name, required this.val});
}

class MinHeap {
  List<Node> heap;
  Map<String, int> idx_of_element;
  Map<String, int> heap_dict;
  MinHeap({required this.heap, required this.idx_of_element, required this.heap_dict});
}

int get_parent_idx(int idx) {
  return (idx - 1) ~/ 2;
}

int get_left_child_idx(int idx) {
  return idx * 2 + 1;
}

int get_right_child_idx(int idx) {
  return idx * 2 + 2;
}

Map<String, int> remove_key(Map<String, int> m, String k) {
  Map<String, int> out = <String, int>{};
  for (String key in m.keys) {
    if (key != k) {
    out[key] = m[key]!;
  }
  }
  return out;
}

List<Node> slice_without_last(List<Node> xs) {
  List<Node> res = <Node>[];
  int i = 0;
  while (i < xs.length - 1) {
    res = [...res, xs[i]];
    i = i + 1;
  }
  return res;
}

void sift_down(MinHeap mh, int idx) {
  List<Node> heap = mh.heap;
  Map<String, int> idx_map = mh.idx_of_element;
  int i = idx;
  while (true) {
    int left = get_left_child_idx(i);
    int right = get_right_child_idx(i);
    int smallest = i;
    if (left < heap.length && heap[left].val < heap[smallest].val) {
    smallest = left;
  }
    if (right < heap.length && heap[right].val < heap[smallest].val) {
    smallest = right;
  }
    if (smallest != i) {
    Node tmp = heap[i];
    while (heap.length <= i) { heap.add(null as dynamic); } heap[i] = heap[smallest];
    while (heap.length <= smallest) { heap.add(null as dynamic); } heap[smallest] = tmp;
    idx_map[heap[i].name] = i;
    idx_map[heap[smallest].name] = smallest;
    i = smallest;
  } else {
    break;
  }
  }
  mh.heap = heap;
  mh.idx_of_element = idx_map;
}

void sift_up(MinHeap mh, int idx) {
  List<Node> heap = mh.heap;
  Map<String, int> idx_map = mh.idx_of_element;
  int i = idx;
  int p = get_parent_idx(i);
  while (p >= 0 && heap[p].val > heap[i].val) {
    Node tmp = heap[p];
    while (heap.length <= p) { heap.add(null as dynamic); } heap[p] = heap[i];
    while (heap.length <= i) { heap.add(null as dynamic); } heap[i] = tmp;
    idx_map[heap[p].name] = p;
    idx_map[heap[i].name] = i;
    i = p;
    p = get_parent_idx(i);
  }
  mh.heap = heap;
  mh.idx_of_element = idx_map;
}

MinHeap new_min_heap(List<Node> array) {
  Map<String, int> idx_map = <String, int>{};
  Map<String, int> val_map = <String, int>{};
  List<Node> heap = array;
  int i = 0;
  while (i < array.length) {
    Node n = array[i];
    idx_map[n.name] = i;
    val_map[n.name] = n.val;
    i = i + 1;
  }
  MinHeap mh = MinHeap(heap: heap, idx_of_element: idx_map, heap_dict: val_map);
  int start = get_parent_idx(array.length - 1);
  while (start >= 0) {
    sift_down(mh, start);
    start = start - 1;
  }
  return mh;
}

Node peek(MinHeap mh) {
  return mh.heap[0];
}

Node remove_min(MinHeap mh) {
  List<Node> heap = mh.heap;
  Map<String, int> idx_map = mh.idx_of_element;
  Map<String, int> val_map = mh.heap_dict;
  int last_idx = heap.length - 1;
  Node top = heap[0];
  Node last = heap[last_idx];
  while (heap.length <= 0) { heap.add(null as dynamic); } heap[0] = last;
  idx_map[last.name] = 0;
  heap = slice_without_last(heap);
  idx_map = remove_key(idx_map, top.name);
  val_map = remove_key(val_map, top.name);
  mh.heap = heap;
  mh.idx_of_element = idx_map;
  mh.heap_dict = val_map;
  if (heap.length > 0) {
    sift_down(mh, 0);
  }
  return top;
}

void insert(MinHeap mh, Node node) {
  List<Node> heap = mh.heap;
  Map<String, int> idx_map = mh.idx_of_element;
  Map<String, int> val_map = mh.heap_dict;
  heap = [...heap, node];
  int idx = heap.length - 1;
  idx_map[node.name] = idx;
  val_map[node.name] = node.val;
  mh.heap = heap;
  mh.idx_of_element = idx_map;
  mh.heap_dict = val_map;
  sift_up(mh, idx);
}

bool is_empty(MinHeap mh) {
  return mh.heap.length == 0;
}

int get_value(MinHeap mh, String key) {
  return (mh.heap_dict[key])!;
}

void decrease_key(MinHeap mh, Node node, int new_value) {
  List<Node> heap = mh.heap;
  Map<String, int> val_map = mh.heap_dict;
  Map<String, int> idx_map = mh.idx_of_element;
  int idx = idx_map[node.name]!;
  if (!(heap[idx].val > new_value)) {
    throw Exception("newValue must be less than current value");
  }
  node.val = new_value;
  heap[idx]!.val = new_value;
  val_map[node.name] = new_value;
  mh.heap = heap;
  mh.heap_dict = val_map;
  sift_up(mh, idx);
}

String node_to_string(Node n) {
  return "Node(" + n.name + ", " + (n.val).toString() + ")";
}

Node r = Node(name: "R", val: -1);
Node b = Node(name: "B", val: 6);
Node a = Node(name: "A", val: 3);
Node x = Node(name: "X", val: 1);
Node e = Node(name: "E", val: 4);
MinHeap my_min_heap = new_min_heap([r, b, a, x, e]);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print("Min Heap - before decrease key");
  for (Node n in my_min_heap.heap) {
    print(node_to_string(n));
  }
  print("Min Heap - After decrease key of node [B -> -17]");
  decrease_key(my_min_heap, b, -17);
  for (Node n in my_min_heap.heap) {
    print(node_to_string(n));
  }
  print((get_value(my_min_heap, "B")).toString());
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
