// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Heap {
  List<List<int>> arr;
  Map<int, int> pos_map;
  int size;
  dynamic key;
  Heap({required this.arr, required this.pos_map, required this.size, required this.key});
}

Heap new_heap(dynamic key) {
  return Heap(arr: [], pos_map: {}, size: 0, key: key);
}

int parent(int i) {
  if (i > 0) {
    return (i - 1) ~/ 2;
  }
  return -1;
}

int left(int i, int size) {
  int l = 2 * i + 1;
  if (l < size) {
    return l;
  }
  return -1;
}

int right(int i, int size) {
  int r = 2 * i + 2;
  if (r < size) {
    return r;
  }
  return -1;
}

dynamic swap(Heap h, int i, int j) {
  List<List<int>> arr = h.arr;
  int item_i = arr[i][0];
  int item_j = arr[j][0];
  Map<int, int> pm = h.pos_map;
  pm[item_i] = j + 1;
  pm[item_j] = i + 1;
  h.pos_map = pm;
  List<int> tmp = arr[i];
  while (arr.length <= i) { arr.add(<int>[]); } arr[i] = arr[j];
  while (arr.length <= j) { arr.add(<int>[]); } arr[j] = tmp;
  h.arr = arr;
}

bool cmp(Heap h, int i, int j) {
  List<List<int>> arr = h.arr;
  return arr[i][1] < arr[j][1];
}

int get_valid_parent(Heap h, int i) {
  int vp = i;
  int l = left(i, h.size);
  if (l != 0 - 1 && cmp(h, l, vp) == false) {
    vp = l;
  }
  int r = right(i, h.size);
  if (r != 0 - 1 && cmp(h, r, vp) == false) {
    vp = r;
  }
  return vp;
}

dynamic heapify_up(Heap h, int index) {
  int idx = index;
  int p = parent(idx);
  while (p != 0 - 1 && cmp(h, idx, p) == false) {
    swap(h, idx, p);
    idx = p;
    p = parent(p);
  }
}

dynamic heapify_down(Heap h, int index) {
  int idx = index;
  int vp = get_valid_parent(h, idx);
  while (vp != idx) {
    swap(h, idx, vp);
    idx = vp;
    vp = get_valid_parent(h, idx);
  }
}

dynamic update_item(Heap h, int item, int item_value) {
  Map<int, int> pm = h.pos_map;
  if (pm[item]! == 0) {
    return;
  }
  int index = pm[item]! - 1;
  List<List<int>> arr = h.arr;
  while (arr.length <= index) { arr.add(<int>[]); } arr[index] = ([item, h.key(item_value)] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  h.arr = arr;
  h.pos_map = pm;
  heapify_up(h, index);
  heapify_down(h, index);
}

dynamic delete_item(Heap h, int item) {
  Map<int, int> pm = h.pos_map;
  if (pm[item]! == 0) {
    return;
  }
  int index = pm[item]! - 1;
  pm[item] = 0;
  List<List<int>> arr = h.arr;
  int last_index = h.size - 1;
  if (index != last_index) {
    while (arr.length <= index) { arr.add(<int>[]); } arr[index] = arr[last_index];
    int moved = arr[index][0];
    pm[moved] = index + 1;
  }
  h.size = h.size - 1;
  h.arr = arr;
  h.pos_map = pm;
  if (h.size > index) {
    heapify_up(h, index);
    heapify_down(h, index);
  }
}

dynamic insert_item(Heap h, int item, int item_value) {
  List<List<int>> arr = h.arr;
  int arr_len = arr.length;
  if (arr_len == h.size) {
    arr = [...arr, [item, h.key(item_value)]];
  } else {
    while (arr.length <= h.size) { arr.add(<int>[]); } arr[h.size] = ([item, h.key(item_value)] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
  Map<int, int> pm = h.pos_map;
  pm[item] = h.size + 1;
  h.size = h.size + 1;
  h.arr = arr;
  h.pos_map = pm;
  heapify_up(h, h.size - 1);
}

List<int> get_top(Heap h) {
  List<List<int>> arr = h.arr;
  if (h.size > 0) {
    return arr[0];
  }
  return ([] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
}

List<int> extract_top(Heap h) {
  List<int> top = get_top(h);
  if (top.length > 0) {
    delete_item(h, top[0]);
  }
  return top;
}

int identity(int x) {
  return x;
}

int negate(int x) {
  return 0 - x;
}

Heap h = new_heap(identity);
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  insert_item(h, 5, 34);
  insert_item(h, 6, 31);
  insert_item(h, 7, 37);
  print((get_top(h)).toString());
  print((extract_top(h)).toString());
  print((extract_top(h)).toString());
  print((extract_top(h)).toString());
  h = new_heap(negate);
  insert_item(h, 5, 34);
  insert_item(h, 6, 31);
  insert_item(h, 7, 37);
  print((get_top(h)).toString());
  print((extract_top(h)).toString());
  print((extract_top(h)).toString());
  print((extract_top(h)).toString());
  insert_item(h, 8, 45);
  insert_item(h, 9, 40);
  insert_item(h, 10, 50);
  print((get_top(h)).toString());
  update_item(h, 10, 30);
  print((get_top(h)).toString());
  delete_item(h, 10);
  print((get_top(h)).toString());
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
