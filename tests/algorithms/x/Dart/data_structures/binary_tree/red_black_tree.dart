// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class RBTree {
  List<List<int>> nodes;
  int root;
  RBTree({required this.nodes, required this.root});
}

int LABEL = 0;
int COLOR = 1;
int PARENT = 2;
int LEFT = 3;
int RIGHT = 4;
int NEG_ONE = -1;
RBTree make_tree() {
  return RBTree(nodes: [], root: -1);
}

RBTree rotate_left(RBTree t, int x) {
  List<List<int>> nodes = t.nodes;
  int y = nodes[x][RIGHT];
  int yLeft = nodes[y][LEFT];
  while (nodes[x]!.length <= RIGHT) { nodes[x]!.add(0); } nodes[x]![RIGHT] = yLeft;
  if (yLeft != NEG_ONE) {
    while (nodes[yLeft]!.length <= PARENT) { nodes[yLeft]!.add(0); } nodes[yLeft]![PARENT] = x;
  }
  int xParent = nodes[x][PARENT];
  while (nodes[y]!.length <= PARENT) { nodes[y]!.add(0); } nodes[y]![PARENT] = xParent;
  if (xParent == NEG_ONE) {
    t.root = y;
  } else {
    if (x == nodes[xParent][LEFT]) {
    while (nodes[xParent]!.length <= LEFT) { nodes[xParent]!.add(0); } nodes[xParent]![LEFT] = y;
  } else {
    while (nodes[xParent]!.length <= RIGHT) { nodes[xParent]!.add(0); } nodes[xParent]![RIGHT] = y;
  };
  }
  while (nodes[y]!.length <= LEFT) { nodes[y]!.add(0); } nodes[y]![LEFT] = x;
  while (nodes[x]!.length <= PARENT) { nodes[x]!.add(0); } nodes[x]![PARENT] = y;
  t.nodes = nodes;
  return t;
}

RBTree rotate_right(RBTree t, int x) {
  List<List<int>> nodes = t.nodes;
  int y = nodes[x][LEFT];
  int yRight = nodes[y][RIGHT];
  while (nodes[x]!.length <= LEFT) { nodes[x]!.add(0); } nodes[x]![LEFT] = yRight;
  if (yRight != NEG_ONE) {
    while (nodes[yRight]!.length <= PARENT) { nodes[yRight]!.add(0); } nodes[yRight]![PARENT] = x;
  }
  int xParent = nodes[x][PARENT];
  while (nodes[y]!.length <= PARENT) { nodes[y]!.add(0); } nodes[y]![PARENT] = xParent;
  if (xParent == NEG_ONE) {
    t.root = y;
  } else {
    if (x == nodes[xParent][RIGHT]) {
    while (nodes[xParent]!.length <= RIGHT) { nodes[xParent]!.add(0); } nodes[xParent]![RIGHT] = y;
  } else {
    while (nodes[xParent]!.length <= LEFT) { nodes[xParent]!.add(0); } nodes[xParent]![LEFT] = y;
  };
  }
  while (nodes[y]!.length <= RIGHT) { nodes[y]!.add(0); } nodes[y]![RIGHT] = x;
  while (nodes[x]!.length <= PARENT) { nodes[x]!.add(0); } nodes[x]![PARENT] = y;
  t.nodes = nodes;
  return t;
}

RBTree insert_fix(RBTree t, int z) {
  List<List<int>> nodes = t.nodes;
  while (z != t.root && nodes[nodes[z][PARENT]][COLOR] == 1) {
    if (nodes[z][PARENT] == nodes[nodes[nodes[z][PARENT]][PARENT]][LEFT]) {
    int y = nodes[nodes[nodes[z][PARENT]][PARENT]][RIGHT];
    if (y != NEG_ONE && nodes[y][COLOR] == 1) {
    while (nodes[nodes[z][PARENT]]!.length <= COLOR) { nodes[nodes[z][PARENT]]!.add(0); } nodes[nodes[z][PARENT]]![COLOR] = 0;
    while (nodes[y]!.length <= COLOR) { nodes[y]!.add(0); } nodes[y]![COLOR] = 0;
    int gp = nodes[nodes[z][PARENT]][PARENT];
    while (nodes[gp]!.length <= COLOR) { nodes[gp]!.add(0); } nodes[gp]![COLOR] = 1;
    z = gp;
  } else {
    if (z == nodes[nodes[z][PARENT]][RIGHT]) {
    z = nodes[z][PARENT];
    t.nodes = nodes;
    t = rotate_left(t, z);
    nodes = t.nodes;
  };
    while (nodes[nodes[z][PARENT]]!.length <= COLOR) { nodes[nodes[z][PARENT]]!.add(0); } nodes[nodes[z][PARENT]]![COLOR] = 0;
    int gp = nodes[nodes[z][PARENT]][PARENT];
    while (nodes[gp]!.length <= COLOR) { nodes[gp]!.add(0); } nodes[gp]![COLOR] = 1;
    t.nodes = nodes;
    t = rotate_right(t, gp);
    nodes = t.nodes;
  };
  } else {
    int y = nodes[nodes[nodes[z][PARENT]][PARENT]][LEFT];
    if (y != NEG_ONE && nodes[y][COLOR] == 1) {
    while (nodes[nodes[z][PARENT]]!.length <= COLOR) { nodes[nodes[z][PARENT]]!.add(0); } nodes[nodes[z][PARENT]]![COLOR] = 0;
    while (nodes[y]!.length <= COLOR) { nodes[y]!.add(0); } nodes[y]![COLOR] = 0;
    int gp = nodes[nodes[z][PARENT]][PARENT];
    while (nodes[gp]!.length <= COLOR) { nodes[gp]!.add(0); } nodes[gp]![COLOR] = 1;
    z = gp;
  } else {
    if (z == nodes[nodes[z][PARENT]][LEFT]) {
    z = nodes[z][PARENT];
    t.nodes = nodes;
    t = rotate_right(t, z);
    nodes = t.nodes;
  };
    while (nodes[nodes[z][PARENT]]!.length <= COLOR) { nodes[nodes[z][PARENT]]!.add(0); } nodes[nodes[z][PARENT]]![COLOR] = 0;
    int gp = nodes[nodes[z][PARENT]][PARENT];
    while (nodes[gp]!.length <= COLOR) { nodes[gp]!.add(0); } nodes[gp]![COLOR] = 1;
    t.nodes = nodes;
    t = rotate_left(t, gp);
    nodes = t.nodes;
  };
  }
  }
  nodes = t.nodes;
  while (nodes[t.root]!.length <= COLOR) { nodes[t.root]!.add(0); } nodes[t.root]![COLOR] = 0;
  t.nodes = nodes;
  return t;
}

RBTree tree_insert(RBTree t, int v) {
  List<List<int>> nodes = t.nodes;
  List<int> node = [v, 1, -1, -1, -1];
  nodes = ([...nodes, node] as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  int idx = nodes.length - 1;
  int y = NEG_ONE;
  int x = t.root;
  while (x != NEG_ONE) {
    y = x;
    if (v < nodes[x][LABEL]) {
    x = nodes[x][LEFT];
  } else {
    x = nodes[x][RIGHT];
  }
  }
  while (nodes[idx]!.length <= PARENT) { nodes[idx]!.add(0); } nodes[idx]![PARENT] = y;
  if (y == NEG_ONE) {
    t.root = idx;
  } else {
    if (v < nodes[y][LABEL]) {
    while (nodes[y]!.length <= LEFT) { nodes[y]!.add(0); } nodes[y]![LEFT] = idx;
  } else {
    while (nodes[y]!.length <= RIGHT) { nodes[y]!.add(0); } nodes[y]![RIGHT] = idx;
  };
  }
  t.nodes = nodes;
  t = insert_fix(t, idx);
  return t;
}

List<int> inorder(RBTree t, int x, List<int> acc) {
  if (x == NEG_ONE) {
    return acc;
  }
  acc = inorder(t, t.nodes[x][LEFT], acc);
  acc = [...acc, t.nodes[x][LABEL]];
  acc = inorder(t, t.nodes[x][RIGHT], acc);
  return acc;
}

void _main() {
  RBTree t = make_tree();
  List<int> values = [10, 20, 30, 15, 25, 5, 1];
  int i = 0;
  while (i < values.length) {
    t = tree_insert(t, values[i]);
    i = i + 1;
  }
  List<int> res = <int>[];
  res = inorder(t, t.root, res);
  print((res).toString());
}

void _start() {
  _main();
}

void main() => _start();
