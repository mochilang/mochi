// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

List<List<int>> make_symmetric_tree() {
  return [[1, 1, 2], [2, 3, 4], [2, 5, 6], [3, -1, -1], [4, -1, -1], [4, -1, -1], [3, -1, -1]];
}

List<List<int>> make_asymmetric_tree() {
  return [[1, 1, 2], [2, 3, 4], [2, 5, 6], [3, -1, -1], [4, -1, -1], [3, -1, -1], [4, -1, -1]];
}

bool is_symmetric_tree(List<List<int>> tree) {
  List<int> stack = [tree[0][1], tree[0][2]];
  while (stack.length >= 2) {
    int left = stack[stack.length - 2];
    int right = stack[stack.length - 1];
    stack = stack.sublist(0, stack.length - 2);
    if (left == -1 && right == -1) {
    continue;
  }
    if (left == -1 || right == -1) {
    return false;
  }
    List<int> lnode = tree[left];
    List<int> rnode = tree[right];
    if (lnode[0] != rnode[0]) {
    return false;
  }
    stack = [...stack, lnode[1]];
    stack = [...stack, rnode[2]];
    stack = [...stack, lnode[2]];
    stack = [...stack, rnode[1]];
  }
  return true;
}

List<List<int>> symmetric_tree = make_symmetric_tree();
List<List<int>> asymmetric_tree = make_asymmetric_tree();
void main() {
  print((is_symmetric_tree(symmetric_tree)).toString());
  print((is_symmetric_tree(asymmetric_tree)).toString());
}
