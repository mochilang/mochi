// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Tree {
  List<int> values;
  List<int> lefts;
  List<int> rights;
  int root;
  Tree({required this.values, required this.lefts, required this.rights, required this.root});
}

class Pair {
  int idx;
  int hd;
  Pair({required this.idx, required this.hd});
}

BigInt NIL = BigInt.from(0 - 1);
Tree make_tree() {
  return Tree(values: [3, 9, 20, 15, 7], lefts: [1, NIL, 3, NIL, NIL], rights: [2, NIL, 4, NIL, NIL], root: 0);
}

int index_of(List<int> xs, int x) {
  int i = 0;
  while (i < xs.length) {
    if (xs[i] == x) {
    return i;
  }
    i = i + 1;
  }
  return (NIL).toInt();
}

void sort_pairs(List<int> hds, List<int> vals) {
  int i = 0;
  while (i < hds.length) {
    int j = i;
    while (j > 0 && hds[j - 1] > hds[j]) {
    int hd_tmp = hds[j - 1];
    while (hds.length <= j - 1) { hds.add(0); } hds[j - 1] = hds[j];
    while (hds.length <= j) { hds.add(0); } hds[j] = hd_tmp;
    int val_tmp = vals[j - 1];
    while (vals.length <= j - 1) { vals.add(0); } vals[j - 1] = vals[j];
    while (vals.length <= j) { vals.add(0); } vals[j] = val_tmp;
    j = j - 1;
  }
    i = i + 1;
  }
}

List<int> right_view(Tree t) {
  List<int> res = <int>[];
  List<int> queue = [t.root];
  while (queue.length > 0) {
    int size = queue.length;
    int i = 0;
    while (i < size) {
    int idx = queue[i];
    if (BigInt.from(t.lefts[idx]) != NIL) {
    queue = [...queue, t.lefts[idx]];
  }
    if (BigInt.from(t.rights[idx]) != NIL) {
    queue = [...queue, t.rights[idx]];
  }
    i = i + 1;
  }
    res = [...res, t.values[queue[size - 1]]];
    queue = queue.sublist(size, queue.length);
  }
  return res;
}

List<int> left_view(Tree t) {
  List<int> res = <int>[];
  List<int> queue = [t.root];
  while (queue.length > 0) {
    int size = queue.length;
    int i = 0;
    while (i < size) {
    int idx = queue[i];
    if (BigInt.from(t.lefts[idx]) != NIL) {
    queue = [...queue, t.lefts[idx]];
  }
    if (BigInt.from(t.rights[idx]) != NIL) {
    queue = [...queue, t.rights[idx]];
  }
    i = i + 1;
  }
    res = [...res, t.values[queue[0]]];
    queue = queue.sublist(size, queue.length);
  }
  return res;
}

List<int> top_view(Tree t) {
  List<int> hds = <int>[];
  List<int> vals = <int>[];
  List<int> queue_idx = [t.root];
  List<int> queue_hd = [0];
  while (queue_idx.length > 0) {
    int idx = queue_idx[0];
    queue_idx = queue_idx.sublist(1, queue_idx.length);
    int hd = queue_hd[0];
    queue_hd = queue_hd.sublist(1, queue_hd.length);
    if (BigInt.from(index_of(hds, hd)) == NIL) {
    hds = [...hds, hd];
    vals = [...vals, t.values[idx]];
  }
    if (BigInt.from(t.lefts[idx]) != NIL) {
    queue_idx = [...queue_idx, t.lefts[idx]];
    queue_hd = [...queue_hd, hd - 1];
  }
    if (BigInt.from(t.rights[idx]) != NIL) {
    queue_idx = [...queue_idx, t.rights[idx]];
    queue_hd = [...queue_hd, hd + 1];
  }
  }
  sort_pairs(hds, vals);
  return vals;
}

List<int> bottom_view(Tree t) {
  List<int> hds = <int>[];
  List<int> vals = <int>[];
  List<int> queue_idx = [t.root];
  List<int> queue_hd = [0];
  while (queue_idx.length > 0) {
    int idx = queue_idx[0];
    queue_idx = queue_idx.sublist(1, queue_idx.length);
    int hd = queue_hd[0];
    queue_hd = queue_hd.sublist(1, queue_hd.length);
    int pos = index_of(hds, hd);
    if (BigInt.from(pos) == NIL) {
    hds = [...hds, hd];
    vals = [...vals, t.values[idx]];
  } else {
    while (vals.length <= pos) { vals.add(0); } vals[pos] = t.values[idx];
  }
    if (BigInt.from(t.lefts[idx]) != NIL) {
    queue_idx = [...queue_idx, t.lefts[idx]];
    queue_hd = [...queue_hd, hd - 1];
  }
    if (BigInt.from(t.rights[idx]) != NIL) {
    queue_idx = [...queue_idx, t.rights[idx]];
    queue_hd = [...queue_hd, hd + 1];
  }
  }
  sort_pairs(hds, vals);
  return vals;
}

Tree tree = make_tree();
void main() {
  print("[" + right_view(tree).join(', ') + "]");
  print("[" + left_view(tree).join(', ') + "]");
  print("[" + top_view(tree).join(', ') + "]");
  print("[" + bottom_view(tree).join(', ') + "]");
}
