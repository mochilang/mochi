// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Node {
  int start;
  int end;
  int val;
  int mid;
  int left;
  int right;
  Node({required this.start, required this.end, required this.val, required this.mid, required this.left, required this.right});
}

class BuildResult {
  List<Node> nodes;
  int idx;
  BuildResult({required this.nodes, required this.idx});
}

class SegmentTree {
  List<int> arr;
  int op;
  SegmentTree({required this.arr, required this.op});
}

int combine(int a, int b, int op) {
  if (op == 0) {
    return a + b;
  }
  if (op == 1) {
    if (a > b) {
    return a;
  };
    return b;
  }
  if (a < b) {
    return a;
  }
  return b;
}

BuildResult build_tree(List<Node> nodes, List<int> arr, int start, int end, int op) {
  if (start == end) {
    Node node = Node(start: start, end: end, val: arr[start], mid: start, left: -1, right: -1);
    List<Node> new_nodes = [...nodes, node];
    return BuildResult(nodes: new_nodes, idx: new_nodes.length - 1);
  }
  int mid = (start + end) ~/ 2;
  BuildResult left_res = build_tree(nodes, arr, start, mid, op);
  BuildResult right_res = build_tree(left_res.nodes, arr, mid + 1, end, op);
  Node left_node = right_res.nodes[left_res.idx];
  Node right_node = right_res.nodes[right_res.idx];
  int val = combine(left_node.val, right_node.val, op);
  Node parent = Node(start: start, end: end, val: val, mid: mid, left: left_res.idx, right: right_res.idx);
  List<Node> new_nodes = [...right_res.nodes, parent];
  return BuildResult(nodes: new_nodes, idx: new_nodes.length - 1);
}

SegmentTree new_segment_tree(List<int> collection, int op) {
  return SegmentTree(arr: collection, op: op);
}

SegmentTree update(SegmentTree tree, int i, int val) {
  List<int> new_arr = <int>[];
  int idx = 0;
  while (idx < tree.arr.length) {
    if (idx == i) {
    new_arr = [...new_arr, val];
  } else {
    new_arr = [...new_arr, tree.arr[idx]];
  }
    idx = idx + 1;
  }
  return SegmentTree(arr: new_arr, op: tree.op);
}

int query_range(SegmentTree tree, int i, int j) {
  int result = tree.arr[i];
  int idx = i + 1;
  while (idx <= j) {
    result = combine(result, tree.arr[idx], tree.op);
    idx = idx + 1;
  }
  return result;
}

List<Node> traverse(SegmentTree tree) {
  if (tree.arr.length == 0) {
    return List<Node>.from([]);
  }
  BuildResult res = build_tree(<Node>[], tree.arr, 0, tree.arr.length - 1, tree.op);
  return res.nodes;
}

String node_to_string(Node node) {
  return "SegmentTreeNode(start=" + (node.start).toString() + ", end=" + (node.end).toString() + ", val=" + (node.val).toString() + ")";
}

void print_traverse(SegmentTree tree) {
  List<Node> nodes = traverse(tree);
  int i = 0;
  while (i < nodes.length) {
    print(node_to_string(nodes[i]));
    i = i + 1;
  }
  print("");
}

List<int> arr = [2, 1, 5, 3, 4];
void main() {
  for (int op in [0, 1, 2]) {
    print("**************************************************");
    SegmentTree tree = new_segment_tree(arr, op);
    print_traverse(tree);
    tree = update(tree, 1, 5);
    print_traverse(tree);
    print(query_range(tree, 3, 4));
    print(query_range(tree, 2, 2));
    print(query_range(tree, 1, 3));
    print("");
  }
}
