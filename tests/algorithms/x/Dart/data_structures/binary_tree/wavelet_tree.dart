// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Node {
  int minn;
  int maxx;
  List<int> map_left;
  int left;
  int right;
  Node({required this.minn, required this.maxx, required this.map_left, required this.left, required this.right});
}

List<Node> nodes = <Node>[];
List<int> make_list(int length, int value) {
  List<int> lst = <int>[];
  int i = 0;
  while (i < length) {
    lst = [...lst, value];
    i = i + 1;
  }
  return lst;
}

int min_list(List<int> arr) {
  int m = arr[0];
  int i = 1;
  while (i < arr.length) {
    if (arr[i] < m) {
    m = arr[i];
  }
    i = i + 1;
  }
  return m;
}

int max_list(List<int> arr) {
  int m = arr[0];
  int i = 1;
  while (i < arr.length) {
    if (arr[i] > m) {
    m = arr[i];
  }
    i = i + 1;
  }
  return m;
}

int build_tree(List<int> arr) {
  Node n = Node(minn: min_list(arr), maxx: max_list(arr), map_left: make_list(arr.length, 0), left: -1, right: -1);
  if (n.minn == n.maxx) {
    nodes = [...nodes, n];
    return nodes.length - 1;
  }
  int pivot = (n.minn + n.maxx) ~/ 2;
  List<int> left_arr = <int>[];
  List<int> right_arr = <int>[];
  int i = 0;
  while (i < arr.length) {
    int _num = arr[i];
    if (_num <= pivot) {
    left_arr = [...left_arr, _num];
  } else {
    right_arr = [...right_arr, _num];
  }
    List<int> ml = n.map_left;
    while (ml.length <= i) { ml.add(0); } ml[i] = left_arr.length;
    n.map_left = ml;
    i = i + 1;
  }
  if (left_arr.length > 0) {
    n.left = build_tree(left_arr);
  }
  if (right_arr.length > 0) {
    n.right = build_tree(right_arr);
  }
  nodes = [...nodes, n];
  return nodes.length - 1;
}

int rank_till_index(int node_idx, int _num, int index) {
  if (index < 0 || node_idx < 0) {
    return 0;
  }
  Node node = nodes[node_idx];
  if (node.minn == node.maxx) {
    if (node.minn == _num) {
    return index + 1;
  } else {
    return 0;
  };
  }
  int pivot = (node.minn + node.maxx) ~/ 2;
  if (_num <= pivot) {
    return rank_till_index(node.left, _num, node.map_left[index] - 1);
  } else {
    return rank_till_index(node.right, _num, index - node.map_left[index]);
  }
}

int rank(int node_idx, int _num, int start, int end) {
  if (start > end) {
    return 0;
  }
  int rank_till_end = rank_till_index(node_idx, _num, end);
  int rank_before_start = rank_till_index(node_idx, _num, start - 1);
  return rank_till_end - rank_before_start;
}

int quantile(int node_idx, int index, int start, int end) {
  if (index > end - start || start > end || node_idx < 0) {
    return -1;
  }
  Node node = nodes[node_idx];
  if (node.minn == node.maxx) {
    return node.minn;
  }
  int left_start = (start == 0 ? 0 : node.map_left[start - 1]);
  int num_left = node.map_left[end] - left_start;
  if (num_left > index) {
    return quantile(node.left, index, left_start, node.map_left[end] - 1);
  } else {
    return quantile(node.right, index - num_left, start - left_start, end - node.map_left[end]);
  }
}

int range_counting(int node_idx, int start, int end, int start_num, int end_num) {
  if (start > end || node_idx < 0 || start_num > end_num) {
    return 0;
  }
  Node node = nodes[node_idx];
  if (node.minn > end_num || node.maxx < start_num) {
    return 0;
  }
  if (start_num <= node.minn && node.maxx <= end_num) {
    return end - start + 1;
  }
  int left = range_counting(node.left, (start == 0 ? 0 : node.map_left[start - 1]), node.map_left[end] - 1, start_num, end_num);
  int right = range_counting(node.right, start - (start == 0 ? 0 : node.map_left[start - 1]), end - node.map_left[end], start_num, end_num);
  return left + right;
}

List<int> test_array = [2, 1, 4, 5, 6, 0, 8, 9, 1, 2, 0, 6, 4, 2, 0, 6, 5, 3, 2, 7];
int root = build_tree(test_array);
void main() {
  print("rank_till_index 6 at 6 -> " + (rank_till_index(root, 6, 6)).toString());
  print("rank 6 in [3,13] -> " + (rank(root, 6, 3, 13)).toString());
  print("quantile index 2 in [2,5] -> " + (quantile(root, 2, 2, 5)).toString());
  print("range_counting [3,7] in [1,10] -> " + (range_counting(root, 1, 10, 3, 7)).toString());
}
