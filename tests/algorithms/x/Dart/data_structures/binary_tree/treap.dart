// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class SplitResult {
  int left;
  int right;
  SplitResult({required this.left, required this.right});
}

BigInt NIL = BigInt.from(0 - 1);
List<int> node_values = <int>[];
List<double> node_priors = <double>[];
List<int> node_lefts = <int>[];
List<int> node_rights = <int>[];
int seed = 1;
double random() {
  seed = (seed * 13 + 7) % 100;
  return (seed as double) / 100.0;
}

int new_node(int value) {
  node_values = [...node_values, value];
  node_priors = [...node_priors, random()];
  node_lefts = ([...node_lefts, NIL] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  node_rights = ([...node_rights, NIL] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  return node_values.length - 1;
}

SplitResult split(int root, int value) {
  if (BigInt.from(root) == NIL) {
    return SplitResult(left: NIL, right: NIL);
  }
  if (value < node_values[root]) {
    dynamic res = node_lefts[root].split(value);
    while (node_lefts.length <= root) { node_lefts.add(0); } node_lefts[root] = res.right;
    return SplitResult(left: res.left, right: root);
  }
  dynamic res = node_rights[root].split(value);
  while (node_rights.length <= root) { node_rights.add(0); } node_rights[root] = res.left;
  return SplitResult(left: root, right: res.right);
}

int merge(int left, int right) {
  if (BigInt.from(left) == NIL) {
    return right;
  }
  if (BigInt.from(right) == NIL) {
    return left;
  }
  if (node_priors[left] < node_priors[right]) {
    while (node_rights.length <= left) { node_rights.add(0); } node_rights[left] = merge(node_rights[left], right);
    return left;
  }
  while (node_lefts.length <= right) { node_lefts.add(0); } node_lefts[right] = merge(left, node_lefts[right]);
  return right;
}

int insert(int root, int value) {
  int node = new_node(value);
  dynamic res = root.split(value);
  return merge(merge(res.left, node), res.right);
}

int erase(int root, int value) {
  dynamic res1 = root.split(value - 1);
  dynamic res2 = res1.right.split(value);
  return merge(res1.left, res2.right);
}

List<int> inorder(int i, List<int> acc) {
  if (BigInt.from(i) == NIL) {
    return acc;
  }
  List<int> left_acc = inorder(node_lefts[i], acc);
  List<int> with_node = [...left_acc, node_values[i]];
  return inorder(node_rights[i], with_node);
}

void _main() {
  BigInt root = NIL;
  root = BigInt.from(insert((root).toInt(), 1));
  print((inorder((root).toInt(), <int>[])).toString());
  root = BigInt.from(insert((root).toInt(), 3));
  root = BigInt.from(insert((root).toInt(), 5));
  root = BigInt.from(insert((root).toInt(), 17));
  root = BigInt.from(insert((root).toInt(), 19));
  root = BigInt.from(insert((root).toInt(), 2));
  root = BigInt.from(insert((root).toInt(), 16));
  root = BigInt.from(insert((root).toInt(), 4));
  root = BigInt.from(insert((root).toInt(), 0));
  print((inorder((root).toInt(), <int>[])).toString());
  root = BigInt.from(insert((root).toInt(), 4));
  root = BigInt.from(insert((root).toInt(), 4));
  root = BigInt.from(insert((root).toInt(), 4));
  print((inorder((root).toInt(), <int>[])).toString());
  root = BigInt.from(erase((root).toInt(), 0));
  print((inorder((root).toInt(), <int>[])).toString());
  root = BigInt.from(erase((root).toInt(), 4));
  print((inorder((root).toInt(), <int>[])).toString());
}

void _start() {
  _main();
}

void main() => _start();
