// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Node {
  int data;
  int next;
  int prev;
  Node({required this.data, required this.next, required this.prev});
}

class Stack {
  List<Node> nodes;
  int head;
  Stack({required this.nodes, required this.head});
}

class PopResult {
  Stack stack;
  int value;
  bool ok;
  PopResult({required this.stack, required this.value, required this.ok});
}

class TopResult {
  int value;
  bool ok;
  TopResult({required this.value, required this.ok});
}

Stack empty_stack() {
  return Stack(nodes: [], head: 0 - 1);
}

Stack push(Stack stack, int value) {
  List<Node> nodes = stack.nodes;
  int idx = nodes.length;
  Node new_node = Node(data: value, next: stack.head, prev: 0 - 1);
  nodes = [...nodes, new_node];
  if (stack.head != 0 - 1) {
    Node head_node = nodes[stack.head];
    head_node.prev = idx;
    while (nodes.length <= stack.head) { nodes.add(null); } nodes[stack.head] = head_node;
  }
  return Stack(nodes: nodes, head: idx);
}

PopResult pop(Stack stack) {
  if (stack.head == 0 - 1) {
    return PopResult(stack: stack, value: 0, ok: false);
  }
  List<Node> nodes = stack.nodes;
  Node head_node = nodes[stack.head];
  int value = head_node.data;
  int next_idx = head_node.next;
  if (next_idx != 0 - 1) {
    Node next_node = nodes[next_idx];
    next_node.prev = 0 - 1;
    while (nodes.length <= next_idx) { nodes.add(null); } nodes[next_idx] = next_node;
  }
  Stack new_stack = Stack(nodes: nodes, head: next_idx);
  return PopResult(stack: new_stack, value: value, ok: true);
}

TopResult top(Stack stack) {
  if (stack.head == 0 - 1) {
    return TopResult(value: 0, ok: false);
  }
  Node node = stack.nodes[stack.head];
  return TopResult(value: node.data, ok: true);
}

int size(Stack stack) {
  int count = 0;
  int idx = stack.head;
  while (idx != 0 - 1) {
    count = count + 1;
    Node node = stack.nodes[idx];
    idx = node.next;
  }
  return count;
}

bool is_empty(Stack stack) {
  return stack.head == 0 - 1;
}

void print_stack(Stack stack) {
  print("stack elements are:");
  int idx = stack.head;
  String s = "";
  while (idx != 0 - 1) {
    Node node = stack.nodes[idx];
    s = s + (node.data).toString() + "->";
    idx = node.next;
  }
  if (s.length > 0) {
    print(s);
  }
}

void _main() {
  Stack stack = empty_stack();
  print("Stack operations using Doubly LinkedList");
  stack = push(stack, 4);
  stack = push(stack, 5);
  stack = push(stack, 6);
  stack = push(stack, 7);
  print_stack(stack);
  TopResult t = top(stack);
  if (t.ok) {
    print("Top element is " + (t.value).toString());
  } else {
    print("Top element is None");
  }
  print("Size of the stack is " + (size(stack)).toString());
  PopResult p = pop(stack);
  stack = p.stack;
  p = pop(stack);
  stack = p.stack;
  print_stack(stack);
  print("stack is empty: " + (is_empty(stack)).toString());
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
