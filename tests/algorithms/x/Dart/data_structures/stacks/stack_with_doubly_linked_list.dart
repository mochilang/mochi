// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { var i = v.toInt(); if (i == 0) return '0'; return i.toString(); } return v.toString(); }

class Node {
  int data;
  int next;
  int prev;
  Node({required this.data, required this.next, required this.prev});
}

class Stack {
  List<Node> nodes;
  int head;
  Stack({required this.nodes, required this.head});
}

class PopResult {
  Stack stack;
  int value;
  bool ok;
  PopResult({required this.stack, required this.value, required this.ok});
}

class TopResult {
  int value;
  bool ok;
  TopResult({required this.value, required this.ok});
}

Stack empty_stack() {
  return Stack(nodes: [], head: 0 - 1);
}

Stack push(Stack stack, int value) {
  List<Node> nodes = stack.nodes;
  int idx = nodes.length;
  Node new_node = Node(data: value, next: stack.head, prev: 0 - 1);
  nodes = [...nodes, new_node];
  if (stack.head != 0 - 1) {
    Node head_node = nodes[stack.head];
    head_node.prev = idx;
    while (nodes.length <= stack.head) { nodes.add(null as dynamic); } nodes[stack.head] = head_node;
  }
  return Stack(nodes: nodes, head: idx);
}

PopResult pop(Stack stack) {
  if (stack.head == 0 - 1) {
    return PopResult(stack: stack, value: 0, ok: false);
  }
  List<Node> nodes = stack.nodes;
  Node head_node = nodes[stack.head];
  int value = head_node.data;
  int next_idx = head_node.next;
  if (next_idx != 0 - 1) {
    Node next_node = nodes[next_idx];
    next_node.prev = 0 - 1;
    while (nodes.length <= next_idx) { nodes.add(null as dynamic); } nodes[next_idx] = next_node;
  }
  Stack new_stack = Stack(nodes: nodes, head: next_idx);
  return PopResult(stack: new_stack, value: value, ok: true);
}

TopResult top(Stack stack) {
  if (stack.head == 0 - 1) {
    return TopResult(value: 0, ok: false);
  }
  Node node = stack.nodes[stack.head];
  return TopResult(value: node.data, ok: true);
}

int size(Stack stack) {
  int count = 0;
  int idx = stack.head;
  while (idx != 0 - 1) {
    count = count + 1;
    Node node = stack.nodes[idx];
    idx = node.next;
  }
  return count;
}

bool is_empty(Stack stack) {
  return stack.head == 0 - 1;
}

void print_stack(Stack stack) {
  print("stack elements are:");
  int idx = stack.head;
  String s = "";
  while (idx != 0 - 1) {
    Node node = stack.nodes[idx];
    s = s + _str(node.data) + "->";
    idx = node.next;
  }
  if (s.length > 0) {
    print(s);
  }
}

void _main() {
  Stack stack = empty_stack();
  print("Stack operations using Doubly LinkedList");
  stack = push(stack, 4);
  stack = push(stack, 5);
  stack = push(stack, 6);
  stack = push(stack, 7);
  print_stack(stack);
  TopResult t = top(stack);
  if (t.ok) {
    print("Top element is " + _str(t.value));
  } else {
    print("Top element is None");
  }
  print("Size of the stack is " + _str(size(stack)));
  PopResult p = pop(stack);
  stack = p.stack;
  p = pop(stack);
  stack = p.stack;
  print_stack(stack);
  print("stack is empty: " + _str(is_empty(stack)));
}

void _start() {
  _main();
}

void main() => _start();
