// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

double PI = 3.141592653589793;
double AXIS_A = 6378137.0;
double AXIS_B = 6356752.314245;
double RADIUS = 6378137.0;
double to_radians(double deg) {
  return deg * PI / 180.0;
}

double sin_taylor(double x) {
  double term = x;
  double sum = x;
  int i = 1;
  while (i < 10) {
    double k1 = 2.0 * (i as double);
    double k2 = k1 + 1.0;
    term = -term * x * x / (k1 * k2);
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

double cos_taylor(double x) {
  double term = 1.0;
  double sum = 1.0;
  int i = 1;
  while (i < 10) {
    double k1 = 2.0 * (i as double) - 1.0;
    double k2 = 2.0 * (i as double);
    term = -term * x * x / (k1 * k2);
    sum = sum + term;
    i = i + 1;
  }
  return sum;
}

double tan_approx(double x) {
  return sin_taylor(x) / cos_taylor(x);
}

double sqrtApprox(double x) {
  double guess = x / 2.0;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

double atanApprox(double x) {
  if (x > 1.0) {
    return PI / 2.0 - x / (x * x + 0.28);
  }
  if (x < -1.0) {
    return -PI / 2.0 - x / (x * x + 0.28);
  }
  return x / (1.0 + 0.28 * x * x);
}

double atan2Approx(double y, double x) {
  if (x > 0.0) {
    double val = atanApprox(y / x);
    return val;
  }
  if (x < 0.0) {
    if (y >= 0.0) {
    return atanApprox(y / x) + PI;
  };
    return atanApprox(y / x) - PI;
  }
  if (y > 0.0) {
    return PI / 2.0;
  }
  if (y < 0.0) {
    return -PI / 2.0;
  }
  return 0.0;
}

double asinApprox(double x) {
  double denom = sqrtApprox(1.0 - x * x);
  double res = atan2Approx(x, denom);
  return res;
}

double haversine_distance(double lat1, double lon1, double lat2, double lon2) {
  double flattening = (AXIS_A - AXIS_B) / AXIS_A;
  double phi_1 = atanApprox((1.0 - flattening) * tan_approx(to_radians(lat1)));
  double phi_2 = atanApprox((1.0 - flattening) * tan_approx(to_radians(lat2)));
  double lambda_1 = to_radians(lon1);
  double lambda_2 = to_radians(lon2);
  double sin_sq_phi = sin_taylor((phi_2 - phi_1) / 2.0);
  double sin_sq_lambda = sin_taylor((lambda_2 - lambda_1) / 2.0);
  sin_sq_phi = sin_sq_phi * sin_sq_phi;
  sin_sq_lambda = sin_sq_lambda * sin_sq_lambda;
  double h_value = sqrtApprox(sin_sq_phi + cos_taylor(phi_1) * cos_taylor(phi_2) * sin_sq_lambda);
  return 2.0 * RADIUS * asinApprox(h_value);
}

List<double> SAN_FRANCISCO = [37.774856, -122.424227];
List<double> YOSEMITE = [37.864742, -119.537521];
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print((haversine_distance(SAN_FRANCISCO[0], SAN_FRANCISCO[1], YOSEMITE[0], YOSEMITE[1])).toString());
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
