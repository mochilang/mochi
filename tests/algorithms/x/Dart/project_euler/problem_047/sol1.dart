// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

List<int> run(int n) {
  int limit = 200000;
  Map<int, int> counts = <int, int>{};
  int p = 2;
  while (p <= limit) {
    if (!counts.containsKey(p)) {
    int m = p;
    while (m <= limit) {
    if (counts.containsKey(m)) {
    counts[m] = (counts[m] ?? 0) + 1;
  } else {
    counts[m] = 1;
  }
    m = m + p;
  };
  }
    p = p + 1;
  }
  int streak = 0;
  int _num = 2;
  while (_num <= limit) {
    int c = (counts.containsKey(_num) ? (counts[_num] ?? 0) : 0);
    if (c == n) {
    streak = streak + 1;
    if (streak == n) {
    List<int> result = <int>[];
    int start = _num - n + 1;
    int j = 0;
    while (j < n) {
    result = (result..add(start + j));
    j = j + 1;
  };
    return result;
  };
  } else {
    streak = 0;
  }
    _num = _num + 1;
  }
  return ([] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
}

int solution(int n) {
  List<int> res = run(n);
  return res[0];
}

void main() {
  print(_str(solution(4)));
}
