// Generated by Mochi transpiler
String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

class FractionPair {
  int num;
  int den;
  FractionPair({required this.num, required this.den});
}

int gcd(int a, int b) {
  int x = (a < 0 ? -a : a);
  int y = (b < 0 ? -b : b);
  while (y != 0) {
    int t = x % y;
    x = y;
    y = t;
  }
  return x;
}

bool is_digit_cancelling(int _num, int den) {
  if (_num >= den) {
    return false;
  }
  int num_unit = _num % 10;
  int num_tens = _num ~/ 10;
  int den_unit = den % 10;
  int den_tens = den ~/ 10;
  if (num_unit != den_tens) {
    return false;
  }
  if (den_unit == 0) {
    return false;
  }
  return _num * den_unit == num_tens * den;
}

List<FractionPair> find_fractions() {
  List<FractionPair> sols = <FractionPair>[];
  int _num = 10;
  while (_num < 100) {
    int den = _num + 1;
    while (den < 100) {
    if (is_digit_cancelling(_num, den)) {
    sols = (sols..add(FractionPair(num: _num, den: den)));
  }
    den = den + 1;
  }
    _num = _num + 1;
  }
  return sols;
}

int solution() {
  List<FractionPair> fracs = find_fractions();
  int num_prod = 1;
  int den_prod = 1;
  int i = 0;
  while (i < fracs.length) {
    FractionPair f = fracs[i];
    num_prod = num_prod * f.num;
    den_prod = den_prod * f.den;
    i = i + 1;
  }
  int g = gcd(num_prod, den_prod);
  return den_prod ~/ g;
}

void _main() {
  print(_str(solution()));
}

void _start() {
  _main();
}

void main() => _start();
