// Generated by Mochi transpiler
dynamic _substr(dynamic s, num start, num end) {
  int n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  if (s is String) {
    return s.substring(s0, e0);
  }
  return s.sublist(s0, e0);
}

String _str(dynamic v) { if (v is double && v == v.roundToDouble()) { return v.toInt().toString(); } return v.toString(); }

bool is_prime(int number) {
  if (1 < number && number < 4) {
    return true;
  }
  if (number < 2 || number % 2 == 0 || number % 3 == 0) {
    return false;
  }
  int i = 5;
  while (i * i <= number) {
    if (number % i == 0 || number % (i + 2) == 0) {
    return false;
  }
    i = i + 6;
  }
  return true;
}

bool search(int target, List<int> arr) {
  int left = 0;
  int right = arr.length - 1;
  while (left <= right) {
    int middle = (left + right) ~/ 2;
    if (arr[middle] == target) {
    return true;
  }
    if (arr[middle] < target) {
    left = middle + 1;
  } else {
    right = middle - 1;
  }
  }
  return false;
}

List<int> sort_int(List<int> xs) {
  List<int> arr = xs;
  int i = 0;
  while (i < arr.length) {
    int j = i + 1;
    while (j < arr.length) {
    if (arr[j] < arr[i]) {
    int tmp = arr[i];
    while (arr.length <= i) { arr.add(0); } arr[i] = arr[j];
    while (arr.length <= j) { arr.add(0); } arr[j] = tmp;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return arr;
}

List<int> permutations_of_number(int n) {
  String s = _str(n);
  List<int> d = <int>[];
  int i = 0;
  while (i < s.length) {
    d = (d..add(int.parse(s.substring(i, i + 1))));
    i = i + 1;
  }
  List<int> res = <int>[];
  int a = 0;
  while (a < d.length) {
    int b = 0;
    while (b < d.length) {
    if (b != a) {
    int c = 0;
    while (c < d.length) {
    if (c != a && c != b) {
    int e = 0;
    while (e < d.length) {
    if (e != a && e != b && e != c) {
    int val = d[a] * 1000 + d[b] * 100 + d[c] * 10 + d[e];
    res = (res..add(val));
  }
    e = e + 1;
  };
  }
    c = c + 1;
  };
  }
    b = b + 1;
  }
    a = a + 1;
  }
  return res;
}

int abs_int(int x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

bool contains_int(List<int> xs, int v) {
  int i = 0;
  while (i < xs.length) {
    if (xs[i] == v) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

int solution() {
  List<int> prime_list = <int>[];
  int n = 1001;
  while (n < 10000) {
    if (is_prime(n)) {
    prime_list = (prime_list..add(n));
  }
    n = n + 2;
  }
  List<List<int>> candidates = <List<int>>[];
  int i = 0;
  while (i < prime_list.length) {
    int number = prime_list[i];
    List<int> tmp = <int>[];
    List<int> perms = permutations_of_number(number);
    int j = 0;
    while (j < perms.length) {
    int prime = perms[j];
    if (prime % 2 != 0 && search(prime, prime_list)) {
    tmp = (tmp..add(prime));
  }
    j = j + 1;
  }
    tmp = sort_int(tmp);
    if (tmp.length >= 3) {
    candidates = ((candidates..add(tmp)) as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
  }
    i = i + 1;
  }
  List<List<int>> passed = <List<int>>[];
  i = 0;
  while (i < candidates.length) {
    List<int> candidate = candidates[i];
    bool found = false;
    int a = 0;
    while (a < candidate.length) {
    int b = a + 1;
    while (b < candidate.length) {
    int c = b + 1;
    while (c < candidate.length) {
    int x = candidate[a];
    int y = candidate[b];
    int z = candidate[c];
    if (abs_int(x - y) == abs_int(y - z) && x != y && x != z && y != z) {
    List<int> triple = sort_int([x, y, z]);
    passed = ((passed..add(triple)) as List).map((e) => ((e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList() as List<int>)).toList();
    found = true;
    break;
  }
    c = c + 1;
  }
    if (found) {
    break;
  }
    b = b + 1;
  }
    if (found) {
    break;
  }
    a = a + 1;
  }
    i = i + 1;
  }
  List<int> answer_nums = <int>[];
  i = 0;
  while (i < passed.length) {
    List<int> seq = passed[i];
    int val = int.parse(_str(seq[0]) + _str(seq[1]) + _str(seq[2]));
    if (!contains_int(answer_nums, val)) {
    answer_nums = (answer_nums..add(val));
  }
    i = i + 1;
  }
  int max_val = answer_nums[0];
  i = 1;
  while (i < answer_nums.length) {
    if (answer_nums[i] > max_val) {
    max_val = answer_nums[i];
  }
    i = i + 1;
  }
  return max_val;
}

void main() {
  print(solution());
}
