// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::io::Write;
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn _str_bytes(s: &str) -> Vec<i64> {
    s.as_bytes().iter().map(|b| *b as i64).collect()
}
fn _sha256(bs: Vec<i64>) -> Vec<i64> {
    let mut child = Command::new("sha256sum")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn().unwrap();
    {
        let mut stdin = child.stdin.take().unwrap();
        for b in bs.iter() { stdin.write_all(&[*b as u8]).unwrap(); }
    }
    let out = child.wait_with_output().unwrap();
    let hex = String::from_utf8_lossy(&out.stdout);
    let mut bytes = Vec::new();
    if let Some(part) = hex.split_whitespace().next() {
        for i in 0..32 {
            let byte = u8::from_str_radix(&part[i*2..i*2+2], 16).unwrap();
            bytes.push(byte as i64);
        }
    }
    bytes
}
static mut g_HEX: String = String::new();
fn main() {
    unsafe {
        g_HEX = String::from("0123456789abcdef").clone();
                let _start: i64 = _now();
        unsafe fn byte_to_hex(mut b: i64) -> String {
    let mut hi: i64 = (b / 16);
    let mut lo: i64 = (b % 16);
    return format!("{}{}", g_HEX.chars().nth(hi as usize).unwrap().to_string(), g_HEX.chars().nth(lo as usize).unwrap().to_string()).clone()
};
        unsafe fn bytes_to_hex(mut bs: Vec<i64>) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (bs.len() as i64)) {
        res = format!("{}{}", res, byte_to_hex(bs[i as usize]));
        i = (i + 1);
    }
    return res.clone()
};
        unsafe fn sha256_hex(mut s: String) -> String {
    return bytes_to_hex(_sha256(_str_bytes(s.as_str()))).clone()
};
        unsafe fn solution_001() -> String {
    let mut total: i64 = 0;
    let mut n: i64 = 0;
    while (n < 1000) {
        if (((n % 3) == 0) || ((n % 5) == 0)) {
            total = (total + n);
        }
        n = (n + 1);
    }
    return total.to_string().to_string().clone()
};
        let mut expected: String = sha256_hex(String::from("233168")).clone();
        let mut answer: String = solution_001().clone();
        let mut computed: String = sha256_hex(answer.clone()).clone();
        if (computed.as_str() == expected.as_str()) {
            println!("{}", "Problem 001 passed");
        } else {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Problem 001 failed: ", computed), " != "), expected));
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
