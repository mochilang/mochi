// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_sample: Vec<String> = Vec::new();
fn main() {
    unsafe {
        g_sample = vec![String::from("data_structures/linked_list.py").clone().clone(), String::from("data_structures/binary_tree.py").clone().clone(), String::from("math/number_theory/prime_check.py").clone().clone(), String::from("math/number_theory/greatest_common_divisor.ipynb").clone().clone()];
                let _start: i64 = _now();
        unsafe fn split(mut s: String, sep: &str) -> Vec<String> {
    let mut parts: Vec<String> = vec![];
    let mut cur: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ((((sep.len() as i64) > 0) && ((i + (sep.len() as i64)) <= (s.len() as i64))) && ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + (sep.len() as i64)) - i) as usize).collect::<String>() } == sep)) {
            parts = { let mut _v = parts.clone(); _v.push(cur.clone()); _v };
            cur = String::from("");
            i = (i + (sep.len() as i64));
        } else {
            cur = format!("{}{}", cur, { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() });
            i = (i + 1);
        }
    }
    parts = { let mut _v = parts.clone(); _v.push(cur.clone()); _v };
    return parts
};
        unsafe fn join(mut xs: Vec<String>, sep: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, sep);
        }
        res = format!("{}{}", res, xs[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
};
        unsafe fn repeat(s: &str, mut n: i64) -> String {
    let mut out: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < n) {
        out = format!("{}{}", out, s);
        i = (i + 1);
    }
    return out.clone()
};
        unsafe fn replace_char(s: &str, old: &str, new: &str) -> String {
    let mut out: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (c == old) {
            out = format!("{}{}", out, new);
        } else {
            out = format!("{}{}", out, c);
        }
        i = (i + 1);
    }
    return out.clone()
};
        unsafe fn contains(mut s: String, sub: &str) -> bool {
    if ((sub.len() as i64) == 0) {
        return true
    }
    let mut i: i64 = 0;
    while ((i + (sub.len() as i64)) <= (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + (sub.len() as i64)) - i) as usize).collect::<String>() } == sub) {
            return true
        }
        i = (i + 1);
    }
    return false
};
        unsafe fn file_extension(mut name: String) -> String {
    let mut i = ((name.len() as i64) - 1);
    while (i >= 0) {
        if ({ let tmp = &name; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.as_str() == ".") {
            return name.chars().skip(i as usize).take(usize::MAX as usize).collect::<String>()
        }
        i = (i - 1);
    }
    return String::from("").clone()
};
        unsafe fn remove_extension(mut name: String) -> String {
    let mut i = ((name.len() as i64) - 1);
    while (i >= 0) {
        if ({ let tmp = &name; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.as_str() == ".") {
            return name.chars().skip(0 as usize).take(i as usize).collect::<String>()
        }
        i = (i - 1);
    }
    return name.clone()
};
        unsafe fn title_case(s: &str) -> String {
    let mut out: String = String::from("").clone();
    let mut cap: bool = true;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (c.as_str() == " ") {
            out = format!("{}{}", out, c);
            cap = true;
        } else {
            if cap {
                out = format!("{}{}", out, (c.to_uppercase()));
                cap = false;
            } else {
                out = format!("{}{}", out, (c.to_lowercase()));
            }
        }
        i = (i + 1);
    }
    return out.clone()
};
        unsafe fn count_char(mut s: String, ch: &str) -> i64 {
    let mut cnt: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            cnt = (cnt + 1);
        }
        i = (i + 1);
    }
    return cnt
};
        unsafe fn md_prefix(mut level: i64) -> String {
    if (level == 0) {
        return String::from("\n##")
    }
    return format!("{}{}", repeat(&"  ", level), "*").clone()
};
        unsafe fn print_path(old_path: &str, new_path: &str) -> String {
    let mut old_parts: Vec<String> = old_path.split("/").map(|x| x.to_string()).collect::<Vec<String>>();
    let mut new_parts: Vec<String> = new_path.split("/").map(|x| x.to_string()).collect::<Vec<String>>();
    let mut i: i64 = 0;
    while (i < (new_parts.len() as i64)) {
        if (((i >= (old_parts.len() as i64)) || (old_parts[i as usize].clone().as_str() != new_parts[i as usize].clone().as_str())) && (new_parts[i as usize].clone().as_str() != "")) {
            let mut title: String = title_case(&replace_char(&new_parts[i as usize].clone(), &"_", &" ")).clone();
            println!("{}", format!("{}{}", format!("{}{}", md_prefix(i), " "), title));
        }
        i = (i + 1);
    }
    return new_path.to_string().clone()
};
        unsafe fn sort_strings(mut xs: Vec<String>) -> Vec<String> {
    let mut arr: Vec<String> = xs.clone();
    let mut i: i64 = 0;
    while (i < (arr.len() as i64)) {
        let mut min_idx: i64 = i;
        let mut j: i64 = (i + 1);
        while (j < (arr.len() as i64)) {
            if (arr[j as usize].clone().as_str() < arr[min_idx as usize].clone().as_str()) {
                min_idx = j;
            }
            j = (j + 1);
        }
        let mut tmp: String = arr[i as usize].clone().clone();
        arr[i as usize] = arr[min_idx as usize].clone();
        arr[min_idx as usize] = tmp.clone();
        i = (i + 1);
    }
    return arr
};
        unsafe fn good_file_paths(mut paths: Vec<String>) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    for p in paths.iter().cloned() {
        let mut parts: Vec<String> = p.split("/").map(|x| x.to_string()).collect::<Vec<String>>();
        let mut skip: bool = false;
        let mut k: i64 = 0;
        while (k < ((parts.len() as i64) - 1)) {
            let mut part: String = parts[k as usize].clone().clone();
            if ((((part.as_str() == "scripts") || (part.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>().as_str() == ".")) || (part.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>().as_str() == "_")) || contains(part.clone(), &"venv")) {
                skip = true;
            }
            k = (k + 1);
        }
        if skip {
            continue
        }
        let mut filename: String = parts[((parts.len() as i64) - 1) as usize].clone().clone();
        if (filename.as_str() == "__init__.py") {
            continue
        }
        let mut ext: String = file_extension(filename.clone()).clone();
        if ((ext.as_str() == ".py") || (ext.as_str() == ".ipynb")) {
            res = { let mut _v = res.clone(); _v.push(p.clone()); _v };
        }
    }
    return res
};
        unsafe fn print_directory_md(mut paths: Vec<String>) {
    let mut files: Vec<String> = sort_strings(good_file_paths(paths.clone()));
    let mut old_path: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (files.len() as i64)) {
        let mut fp: String = files[i as usize].clone().clone();
        let mut parts: Vec<String> = fp.split("/").map(|x| x.to_string()).collect::<Vec<String>>();
        let mut filename: String = parts[((parts.len() as i64) - 1) as usize].clone().clone();
        let mut filepath: String = String::from("").clone();
        if ((parts.len() as i64) > 1) {
            filepath = join(parts[0 as usize..((parts.len() as i64) - 1) as usize].to_vec(), &"/");
        }
        if (filepath.as_str() != old_path.as_str()) {
            old_path = print_path(&old_path, &filepath);
        }
        let mut indent: i64 = 0;
        if ((filepath.len() as i64) > 0) {
            indent = (count_char(filepath.clone(), &"/") + 1);
        }
        let mut url: String = replace_char(&fp, &" ", &"%20").clone();
        let mut name: String = title_case(&replace_char(&remove_extension(filename.clone()), &"_", &" ")).clone();
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", md_prefix(indent), " ["), name), "]("), url), ")"));
        i = (i + 1);
    }
};
        print_directory_md(g_sample.clone());
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
