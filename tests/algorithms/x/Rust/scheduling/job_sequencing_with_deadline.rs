// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Job {
    id: i64,
    deadline: i64,
    profit: i64,
}
impl std::fmt::Display for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"deadline\": {}", self.deadline)?;
        write!(f, ", ")?;
        write!(f, "\"profit\": {}", self.profit)?;
        write!(f, "}}")
    }
}

static mut g_jobs1: Vec<Job> = Vec::new();
static mut g_jobs2: Vec<Job> = Vec::new();
fn main() {
    unsafe {
        g_jobs1 = vec![];
        g_jobs2 = vec![];
                let _start: i64 = _now();
        unsafe fn sort_jobs_by_profit(mut jobs: Vec<Job>) -> Vec<Job> {
    let mut js: Vec<Job> = jobs.clone();
    let mut i: i64 = 0;
    while (i < (js.len() as i64)) {
        let mut j: i64 = 0;
        while (j < (((js.len() as i64) - i) - 1)) {
            let mut a: Job = js[j as usize].clone();
            let mut b: Job = js[(j + 1) as usize].clone();
            if (a.profit < b.profit) {
                js[j as usize] = b.clone();
                js[(j + 1) as usize] = a.clone();
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return js
};
        unsafe fn max_deadline(mut jobs: Vec<Job>) -> i64 {
    let mut max_d: i64 = 0;
    let mut i: i64 = 0;
    while (i < (jobs.len() as i64)) {
        let mut job: Job = jobs[i as usize].clone();
        let mut d: i64 = job.deadline;
        if (d > max_d) {
            max_d = d;
        }
        i = (i + 1);
    }
    return max_d
};
        unsafe fn job_sequencing_with_deadlines(mut jobs: Vec<Job>) -> Vec<i64> {
    let mut js: Vec<Job> = sort_jobs_by_profit(jobs.clone());
    let mut max_d: i64 = max_deadline(js.clone());
    let mut time_slots: Vec<i64> = vec![];
    let mut t: i64 = 0;
    while (t < max_d) {
        time_slots = { let mut _v = time_slots.clone(); _v.push((0 - 1)); _v };
        t = (t + 1);
    }
    let mut count: i64 = 0;
    let mut max_profit: i64 = 0;
    let mut i: i64 = 0;
    while (i < (js.len() as i64)) {
        let mut job: Job = js[i as usize].clone();
        let mut j: i64 = (job.deadline - 1);
        while (j >= 0) {
            if (time_slots[j as usize] == (0 - 1)) {
                time_slots[j as usize] = job.id;
                count = (count + 1);
                max_profit = (max_profit + job.profit);
                break
            }
            j = (j - 1);
        }
        i = (i + 1);
    }
    let mut result: Vec<i64> = vec![];
    result = { let mut _v = result.clone(); _v.push(count); _v };
    result = { let mut _v = result.clone(); _v.push(max_profit); _v };
    return result
};
        g_jobs1 = { let mut _v = g_jobs1.clone(); _v.push(Job {id: 1, deadline: 4, profit: 20}); _v };
        g_jobs1 = { let mut _v = g_jobs1.clone(); _v.push(Job {id: 2, deadline: 1, profit: 10}); _v };
        g_jobs1 = { let mut _v = g_jobs1.clone(); _v.push(Job {id: 3, deadline: 1, profit: 40}); _v };
        g_jobs1 = { let mut _v = g_jobs1.clone(); _v.push(Job {id: 4, deadline: 1, profit: 30}); _v };
        println!("{}", format!("{:?}", job_sequencing_with_deadlines(g_jobs1.clone())));
        g_jobs2 = { let mut _v = g_jobs2.clone(); _v.push(Job {id: 1, deadline: 2, profit: 100}); _v };
        g_jobs2 = { let mut _v = g_jobs2.clone(); _v.push(Job {id: 2, deadline: 1, profit: 19}); _v };
        g_jobs2 = { let mut _v = g_jobs2.clone(); _v.push(Job {id: 3, deadline: 2, profit: 27}); _v };
        g_jobs2 = { let mut _v = g_jobs2.clone(); _v.push(Job {id: 4, deadline: 1, profit: 25}); _v };
        g_jobs2 = { let mut _v = g_jobs2.clone(); _v.push(Job {id: 5, deadline: 1, profit: 15}); _v };
        println!("{}", format!("{:?}", job_sequencing_with_deadlines(g_jobs2.clone())));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
