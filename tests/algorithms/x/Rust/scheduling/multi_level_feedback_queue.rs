// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Process {
    process_name: String,
    arrival_time: i64,
    stop_time: i64,
    burst_time: i64,
    waiting_time: i64,
    turnaround_time: i64,
}
impl std::fmt::Display for Process {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"process_name\": \"{}\"", self.process_name)?;
        write!(f, ", ")?;
        write!(f, "\"arrival_time\": {}", self.arrival_time)?;
        write!(f, ", ")?;
        write!(f, "\"stop_time\": {}", self.stop_time)?;
        write!(f, ", ")?;
        write!(f, "\"burst_time\": {}", self.burst_time)?;
        write!(f, ", ")?;
        write!(f, "\"waiting_time\": {}", self.waiting_time)?;
        write!(f, ", ")?;
        write!(f, "\"turnaround_time\": {}", self.turnaround_time)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct MLFQ {
    number_of_queues: i64,
    time_slices: Vec<i64>,
    ready_queue: Vec<Process>,
    current_time: i64,
    finish_queue: Vec<Process>,
}
impl std::fmt::Display for MLFQ {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"number_of_queues\": {}", self.number_of_queues)?;
        write!(f, ", ")?;
        write!(f, "\"time_slices\": {:?}", self.time_slices)?;
        write!(f, ", ")?;
        write!(f, "\"ready_queue\": {:?}", self.ready_queue)?;
        write!(f, ", ")?;
        write!(f, "\"current_time\": {}", self.current_time)?;
        write!(f, ", ")?;
        write!(f, "\"finish_queue\": {:?}", self.finish_queue)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct RRResult {
    finished: Vec<Process>,
    ready: Vec<Process>,
}
impl std::fmt::Display for RRResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"finished\": {:?}", self.finished)?;
        write!(f, ", ")?;
        write!(f, "\"ready\": {:?}", self.ready)?;
        write!(f, "}}")
    }
}

static mut g_number_of_queues: i64 = 0;
static mut g_time_slices: Vec<i64> = Vec::new();
fn main() {
    unsafe {
        g_number_of_queues = 3;
        g_time_slices = vec![17, 25];
                let _start: i64 = _now();
        unsafe fn make_process(name: &str, mut arrival: i64, mut burst: i64) -> Process {
    return Process {process_name: name.to_string(), arrival_time: arrival, stop_time: arrival, burst_time: burst, waiting_time: 0, turnaround_time: 0}
};
        unsafe fn make_mlfq(mut nqueues: i64, mut time_slices: Vec<i64>, mut queue: Vec<Process>, mut current_time: i64) -> MLFQ {
    return MLFQ {number_of_queues: nqueues, time_slices: time_slices, ready_queue: queue, current_time: current_time, finish_queue: vec![]}
};
        unsafe fn calculate_sequence_of_finish_queue(mlfq: &MLFQ) -> Vec<String> {
    let mut seq: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (mlfq.finish_queue.clone().len() as i64)) {
        let mut p: Process = mlfq.finish_queue.clone()[i as usize].clone();
        seq = { let mut _v = seq.clone(); _v.push(p.process_name.clone()); _v };
        i = (i + 1);
    }
    return seq
};
        unsafe fn calculate_waiting_time(mut queue: Vec<Process>) -> Vec<i64> {
    let mut times: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (queue.len() as i64)) {
        let mut p: Process = queue[i as usize].clone();
        times = { let mut _v = times.clone(); _v.push(p.waiting_time); _v };
        i = (i + 1);
    }
    return times
};
        unsafe fn calculate_turnaround_time(mut queue: Vec<Process>) -> Vec<i64> {
    let mut times: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (queue.len() as i64)) {
        let mut p: Process = queue[i as usize].clone();
        times = { let mut _v = times.clone(); _v.push(p.turnaround_time); _v };
        i = (i + 1);
    }
    return times
};
        unsafe fn calculate_completion_time(mut queue: Vec<Process>) -> Vec<i64> {
    let mut times: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (queue.len() as i64)) {
        let mut p: Process = queue[i as usize].clone();
        times = { let mut _v = times.clone(); _v.push(p.stop_time); _v };
        i = (i + 1);
    }
    return times
};
        unsafe fn calculate_remaining_burst_time_of_processes(mut queue: Vec<Process>) -> Vec<i64> {
    let mut times: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (queue.len() as i64)) {
        let mut p: Process = queue[i as usize].clone();
        times = { let mut _v = times.clone(); _v.push(p.burst_time); _v };
        i = (i + 1);
    }
    return times
};
        unsafe fn update_waiting_time(mlfq: &MLFQ, process: &mut Process) -> i64 {
    (*process).waiting_time = (process.waiting_time + (mlfq.current_time - process.stop_time));
    return process.waiting_time
};
        unsafe fn first_come_first_served(mlfq: &mut MLFQ, mut ready_queue: Vec<Process>) -> Vec<Process> {
    let mut finished: Vec<Process> = vec![];
    let mut rq: Vec<Process> = ready_queue.clone();
    while ((rq.len() as i64) != 0) {
        let mut cp: Process = rq[0 as usize].clone();
        rq = rq[1 as usize..(rq.len() as i64) as usize].to_vec();
        if (mlfq.current_time < cp.arrival_time) {
            (*mlfq).current_time = cp.arrival_time;
        }
        update_waiting_time(mlfq, &mut cp);
        (*mlfq).current_time = (mlfq.current_time + cp.burst_time);
        cp.burst_time = 0;
        cp.turnaround_time = (mlfq.current_time - cp.arrival_time);
        cp.stop_time = mlfq.current_time;
        finished = { let mut _v = finished.clone(); _v.push(cp.clone()); _v };
    }
    (*mlfq).finish_queue = vec![mlfq.finish_queue.clone().clone(), finished.clone()].concat();
    return finished
};
        unsafe fn round_robin(mlfq: &mut MLFQ, mut ready_queue: Vec<Process>, mut time_slice: i64) -> RRResult {
    let mut finished: Vec<Process> = vec![];
    let mut rq: Vec<Process> = ready_queue.clone();
    let mut count = (rq.len() as i64);
    let mut i: i64 = 0;
    while (i < count) {
        let mut cp: Process = rq[0 as usize].clone();
        rq = rq[1 as usize..(rq.len() as i64) as usize].to_vec();
        if (mlfq.current_time < cp.arrival_time) {
            (*mlfq).current_time = cp.arrival_time;
        }
        update_waiting_time(mlfq, &mut cp);
        if (cp.burst_time > time_slice) {
            (*mlfq).current_time = (mlfq.current_time + time_slice);
            cp.burst_time = (cp.burst_time - time_slice);
            cp.stop_time = mlfq.current_time;
            rq = { let mut _v = rq.clone(); _v.push(cp.clone()); _v };
        } else {
            (*mlfq).current_time = (mlfq.current_time + cp.burst_time);
            cp.burst_time = 0;
            cp.stop_time = mlfq.current_time;
            cp.turnaround_time = (mlfq.current_time - cp.arrival_time);
            finished = { let mut _v = finished.clone(); _v.push(cp.clone()); _v };
        }
        i = (i + 1);
    }
    (*mlfq).finish_queue = vec![mlfq.finish_queue.clone().clone(), finished.clone()].concat();
    return RRResult {finished: finished, ready: rq}
};
        unsafe fn multi_level_feedback_queue(mlfq: &mut MLFQ) -> Vec<Process> {
    let mut i: i64 = 0;
    while (i < (mlfq.number_of_queues - 1)) {
        let mut rr: RRResult = round_robin(mlfq, mlfq.clone().ready_queue.clone().clone(), mlfq.clone().time_slices.clone()[i as usize]);
        (*mlfq).ready_queue = rr.ready.clone();
        i = (i + 1);
    }
    first_come_first_served(mlfq, mlfq.clone().ready_queue.clone().clone());
    return mlfq.finish_queue.clone()
};
        let mut P1: Process = make_process(&"P1", 0, 53);
        let mut P2: Process = make_process(&"P2", 0, 17);
        let mut P3: Process = make_process(&"P3", 0, 68);
        let mut P4: Process = make_process(&"P4", 0, 24);
        let mut queue: Vec<Process> = vec![P1.clone(), P2.clone(), P3.clone(), P4.clone()];
        let mut mlfq: MLFQ = make_mlfq(g_number_of_queues, g_time_slices.clone(), queue.clone(), 0);
        let mut finish_queue: Vec<Process> = multi_level_feedback_queue(&mut mlfq);
        println!("{}", format!("{}{}", "waiting time:\t\t\t", format!("{:?}", calculate_waiting_time(vec![P1.clone(), P2.clone(), P3.clone(), P4.clone()]))));
        println!("{}", format!("{}{}", "completion time:\t\t", format!("{:?}", calculate_completion_time(vec![P1.clone(), P2.clone(), P3.clone(), P4.clone()]))));
        println!("{}", format!("{}{}", "turnaround time:\t\t", format!("{:?}", calculate_turnaround_time(vec![P1.clone(), P2.clone(), P3.clone(), P4.clone()]))));
        println!("{}", format!("{}{}", "sequence of finished processes:\t", format!("{:?}", calculate_sequence_of_finish_queue(&mlfq))));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
