// Generated by Mochi transpiler v0.10.63
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_LETTERS_AND_SPACE: String = String::new();
static mut g_LOWER: String = String::new();
static mut g_UPPER: String = String::new();
fn main() {
    unsafe {
        g_LETTERS_AND_SPACE = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz \t\n");
        g_LOWER = String::from("abcdefghijklmnopqrstuvwxyz");
        g_UPPER = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
                let _start: i64 = _now();
        unsafe fn to_upper(s: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        let mut j: i64 = 0;
        let mut up: String = c.clone();
        while (j < (g_LOWER.len() as i64)) {
            if (c.as_str() == g_LOWER.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>().as_str()) {
                up = g_UPPER.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>();
                break
            }
            j = (j + 1);
        }
        res = format!("{}{}", res, up);
        i = (i + 1);
    }
    return res.clone()
};
        unsafe fn char_in(chars: &str, c: &str) -> bool {
    let mut i: i64 = 0;
    while (i < (chars.len() as i64)) {
        if (chars.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() == c) {
            return true
        }
        i = (i + 1);
    }
    return false
};
        unsafe fn remove_non_letters(message: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (message.len() as i64)) {
        let mut ch: String = message.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        if char_in(&g_LETTERS_AND_SPACE, &ch) {
            res = format!("{}{}", res, ch);
        }
        i = (i + 1);
    }
    return res.clone()
};
        unsafe fn split_spaces(text: &str) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut current: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        let mut ch: String = text.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        if (ch.as_str() == " ") {
            res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
            current = String::from("");
        } else {
            current = format!("{}{}", current, ch);
        }
        i = (i + 1);
    }
    res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
    return res
};
        unsafe fn load_dictionary() -> HashMap<String, bool> {
    let mut words: Vec<String> = vec![String::from("HELLO").clone(), String::from("WORLD").clone(), String::from("HOW").clone(), String::from("ARE").clone(), String::from("YOU").clone(), String::from("THE").clone(), String::from("QUICK").clone(), String::from("BROWN").clone(), String::from("FOX").clone(), String::from("JUMPS").clone(), String::from("OVER").clone(), String::from("LAZY").clone(), String::from("DOG").clone()];
    let mut dict: HashMap<String, bool> = HashMap::new();
    for w in words.iter().cloned() {
        dict.insert(w.clone(), true);
    }
    return dict
};
        let mut ENGLISH_WORDS: HashMap<String, bool> = load_dictionary();
        let get_english_count = move |message: &str| -> f64 {
    let mut upper: String = to_upper(&message).clone();
    let mut cleaned: String = remove_non_letters(&upper).clone();
    let mut possible: Vec<String> = split_spaces(&cleaned);
    let mut matches: i64 = 0;
    let mut total: i64 = 0;
    for w in possible.iter().cloned() {
        if (w.as_str() != "") {
            total = (total + 1);
            if ENGLISH_WORDS.contains_key(&w) {
                matches = (matches + 1);
            }
        }
    }
    if (total == 0) {
        return 0.0
    }
    return ((matches as f64) / (total as f64))
};
        let is_english = move |message: &str, word_percentage: i64, letter_percentage: i64| -> bool {
    let mut words_match: bool = ((get_english_count(&message) * 100.0) >= (word_percentage as f64));
    let mut num_letters = (remove_non_letters(&message).len() as i64);
    let mut letters_pct: f64 = if ((message.len() as i64) == 0) { 0.0 } else { (((num_letters as f64) / ((message.len() as i64) as f64)) * 100.0) };
    let mut letters_match: bool = (letters_pct >= (letter_percentage as f64));
    return (words_match && letters_match)
};
        println!("{}", is_english(&"Hello World", 20, 85).to_string());
        println!("{}", is_english(&"llold HorWd", 20, 85).to_string());
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
