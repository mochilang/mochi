// Generated by Mochi transpiler v0.10.61
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
static mut g_img: Vec<Vec<i64>> = Vec::new();
static mut g_laplace: Vec<Vec<f64>> = Vec::new();
fn main() {
    unsafe {
        g_img = vec![vec![52, 55, 61], vec![62, 59, 55], vec![63, 65, 66]];
        g_laplace = vec![vec![0.25, 0.5, 0.25], vec![0.5, -3.0, 0.5], vec![0.25, 0.5, 0.25]];
                let _start: i64 = _now();
        unsafe fn clamp_byte(mut x: i64) -> i64 {
    if (x < 0) {
        return 0
    }
    if (x > 255) {
        return 255
    }
    return x
};
        unsafe fn convert_to_negative(mut img: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut out: Vec<Vec<i64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<i64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            row = { let mut _v = row.clone(); _v.push((255 - img[y as usize].clone()[x as usize])); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
        unsafe fn change_contrast(mut img: Vec<Vec<i64>>, mut factor: i64) -> Vec<Vec<i64>> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut out: Vec<Vec<i64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<i64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut p: i64 = img[y as usize].clone()[x as usize];
            let mut v: i64 = ((((p - 128) * factor) / 100) + 128);
            v = clamp_byte(v);
            row = { let mut _v = row.clone(); _v.push(v); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
        unsafe fn gen_gaussian_kernel(mut n: i64, mut sigma: f64) -> Vec<Vec<f64>> {
    if (n == 3) {
        return vec![vec![(1.0 / 16.0), (2.0 / 16.0), (1.0 / 16.0)], vec![(2.0 / 16.0), (4.0 / 16.0), (2.0 / 16.0)], vec![(1.0 / 16.0), (2.0 / 16.0), (1.0 / 16.0)]]
    }
    let mut k: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            row = { let mut _v = row.clone(); _v.push(0.0); _v };
            j = (j + 1);
        }
        k = { let mut _v = k.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return k
};
        unsafe fn img_convolve(mut img: Vec<Vec<i64>>, mut kernel: Vec<Vec<f64>>) -> Vec<Vec<i64>> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut out: Vec<Vec<i64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<i64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut acc: f64 = 0.0;
            let mut ky: i64 = 0;
            while (ky < (kernel.len() as i64)) {
                let mut kx: i64 = 0;
                while (kx < (kernel[0 as usize].clone().len() as i64)) {
                    let mut iy: i64 = ((y + ky) - 1);
                    let mut ix: i64 = ((x + kx) - 1);
                    let mut pixel: i64 = 0;
                    if ((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w)) {
                        pixel = img[iy as usize].clone()[ix as usize];
                    }
                    acc = (acc + (kernel[ky as usize].clone()[kx as usize] * (1.0 * (pixel as f64))));
                    kx = (kx + 1);
                }
                ky = (ky + 1);
            }
            row = { let mut _v = row.clone(); _v.push((acc as i64)); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
        unsafe fn sort_ints(mut xs: Vec<i64>) -> Vec<i64> {
    let mut arr: Vec<i64> = xs.clone();
    let mut i: i64 = 0;
    while (i < (arr.len() as i64)) {
        let mut j: i64 = 0;
        while (j < (((arr.len() as i64) - 1) - i)) {
            if (arr[j as usize] > arr[(j + 1) as usize]) {
                let mut tmp: i64 = arr[j as usize];
                arr[j as usize] = arr[(j + 1) as usize];
                arr[(j + 1) as usize] = tmp;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return arr
};
        unsafe fn median_filter(mut img: Vec<Vec<i64>>, mut k: i64) -> Vec<Vec<i64>> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut offset: i64 = (k / 2);
    let mut out: Vec<Vec<i64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<i64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut vals: Vec<i64> = vec![];
            let mut ky: i64 = 0;
            while (ky < k) {
                let mut kx: i64 = 0;
                while (kx < k) {
                    let mut iy: i64 = ((y + ky) - offset);
                    let mut ix: i64 = ((x + kx) - offset);
                    let mut pixel: i64 = 0;
                    if ((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w)) {
                        pixel = img[iy as usize].clone()[ix as usize];
                    }
                    vals = { let mut _v = vals.clone(); _v.push(pixel); _v };
                    kx = (kx + 1);
                }
                ky = (ky + 1);
            }
            let mut sorted: Vec<i64> = sort_ints(vals.clone());
            row = { let mut _v = row.clone(); _v.push(sorted[((sorted.len() as i64) / 2) as usize]); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
        unsafe fn iabs(mut x: i64) -> i64 {
    if (x < 0) {
        return -x
    }
    return x
};
        unsafe fn sobel_filter(mut img: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut gx: Vec<Vec<i64>> = vec![vec![1, 0, -1], vec![2, 0, -2], vec![1, 0, -1]];
    let mut gy: Vec<Vec<i64>> = vec![vec![1, 2, 1], vec![0, 0, 0], vec![-1, -2, -1]];
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut out: Vec<Vec<i64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<i64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut sx: i64 = 0;
            let mut sy: i64 = 0;
            let mut ky: i64 = 0;
            while (ky < 3) {
                let mut kx: i64 = 0;
                while (kx < 3) {
                    let mut iy: i64 = ((y + ky) - 1);
                    let mut ix: i64 = ((x + kx) - 1);
                    let mut pixel: i64 = 0;
                    if ((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w)) {
                        pixel = img[iy as usize].clone()[ix as usize];
                    }
                    sx = (sx + (gx[ky as usize].clone()[kx as usize] * pixel));
                    sy = (sy + (gy[ky as usize].clone()[kx as usize] * pixel));
                    kx = (kx + 1);
                }
                ky = (ky + 1);
            }
            row = { let mut _v = row.clone(); _v.push((iabs(sx) + iabs(sy))); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
        unsafe fn get_neighbors_pixel(mut img: Vec<Vec<i64>>, mut x: i64, mut y: i64) -> Vec<i64> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut neighbors: Vec<i64> = vec![];
    let mut dy: i64 = -1;
    while (dy <= 1) {
        let mut dx: i64 = -1;
        while (dx <= 1) {
            if !((dx == 0) && (dy == 0)) {
                let mut ny: i64 = (y + dy);
                let mut nx: i64 = (x + dx);
                let mut val: i64 = 0;
                if ((((ny >= 0) && (ny < h)) && (nx >= 0)) && (nx < w)) {
                    val = img[ny as usize].clone()[nx as usize];
                }
                neighbors = { let mut _v = neighbors.clone(); _v.push(val); _v };
            }
            dx = (dx + 1);
        }
        dy = (dy + 1);
    }
    return neighbors
};
        unsafe fn pow2(mut e: i64) -> i64 {
    let mut r: i64 = 1;
    let mut i: i64 = 0;
    while (i < e) {
        r = (r * 2);
        i = (i + 1);
    }
    return r
};
        unsafe fn local_binary_value(mut img: Vec<Vec<i64>>, mut x: i64, mut y: i64) -> i64 {
    let mut center: i64 = img[y as usize].clone()[x as usize];
    let mut neighbors: Vec<i64> = get_neighbors_pixel(img.clone(), x, y);
    let mut v: i64 = 0;
    let mut i: i64 = 0;
    while (i < (neighbors.len() as i64)) {
        if (neighbors[i as usize] >= center) {
            v = (v + pow2(i));
        }
        i = (i + 1);
    }
    return v
};
        unsafe fn local_binary_pattern(mut img: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut out: Vec<Vec<i64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<i64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            row = { let mut _v = row.clone(); _v.push(local_binary_value(img.clone(), x, y)); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
        let mut negative: Vec<Vec<i64>> = convert_to_negative(g_img.clone().clone());
        let mut contrast: Vec<Vec<i64>> = change_contrast(g_img.clone().clone(), 110);
        let mut kernel: Vec<Vec<f64>> = gen_gaussian_kernel(3, 1.0);
        let mut convolved: Vec<Vec<i64>> = img_convolve(g_img.clone().clone(), g_laplace.clone().clone());
        let mut medianed: Vec<Vec<i64>> = median_filter(g_img.clone().clone(), 3);
        let mut sobel: Vec<Vec<i64>> = sobel_filter(g_img.clone().clone());
        let mut lbp_img: Vec<Vec<i64>> = local_binary_pattern(g_img.clone().clone());
        println!("{:?}", negative);
        println!("{:?}", contrast);
        println!("{:?}", kernel);
        println!("{:?}", convolved);
        println!("{:?}", medianed);
        println!("{:?}", sobel);
        println!("{:?}", lbp_img);
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
