// Generated by Mochi transpiler v0.10.61
static mut g_rgb_img: Vec<Vec<Vec<i64>>> = Vec::new();
static mut g_gray_img: Vec<Vec<f64>> = Vec::new();
static mut g_img1: Vec<Vec<bool>> = Vec::new();
static mut g_kernel1: Vec<Vec<i64>> = Vec::new();
static mut g_img2: Vec<Vec<bool>> = Vec::new();
static mut g_kernel2: Vec<Vec<i64>> = Vec::new();
unsafe fn rgb_to_gray(mut rgb: Vec<Vec<Vec<i64>>>) -> Vec<Vec<f64>> {
    let mut gray: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < (rgb.len() as i64)) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < (rgb[i as usize].clone().len() as i64)) {
            let mut r: f64 = (rgb[i as usize].clone()[j as usize].clone()[0 as usize] as f64);
            let mut g: f64 = (rgb[i as usize].clone()[j as usize].clone()[1 as usize] as f64);
            let mut b: f64 = (rgb[i as usize].clone()[j as usize].clone()[2 as usize] as f64);
            let mut value: f64 = (((0.2989 * r) + (0.587 * g)) + (0.114 * b));
            row = { let mut _v = row.clone(); _v.push(value); _v };
            j = (j + 1);
        }
        gray = { let mut _v = gray.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return gray
}

unsafe fn gray_to_binary(mut gray: Vec<Vec<f64>>) -> Vec<Vec<bool>> {
    let mut binary: Vec<Vec<bool>> = vec![];
    let mut i: i64 = 0;
    while (i < (gray.len() as i64)) {
        let mut row: Vec<bool> = vec![];
        let mut j: i64 = 0;
        while (j < (gray[i as usize].clone().len() as i64)) {
            row = { let mut _v = row.clone(); _v.push(((gray[i as usize].clone()[j as usize] > 127.0) && (gray[i as usize].clone()[j as usize] <= 255.0))); _v };
            j = (j + 1);
        }
        binary = { let mut _v = binary.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return binary
}

unsafe fn erosion(mut image: Vec<Vec<bool>>, mut kernel: Vec<Vec<i64>>) -> Vec<Vec<bool>> {
    let mut h = (image.len() as i64);
    let mut w = (image[0 as usize].clone().len() as i64);
    let mut k_h = (kernel.len() as i64);
    let mut k_w = (kernel[0 as usize].clone().len() as i64);
    let mut pad_y: i64 = (k_h / 2);
    let mut pad_x: i64 = (k_w / 2);
    let mut padded: Vec<Vec<bool>> = vec![];
    let mut y: i64 = 0;
    while (y < (h + (2 * pad_y))) {
        let mut row: Vec<bool> = vec![];
        let mut x: i64 = 0;
        while (x < (w + (2 * pad_x))) {
            row = { let mut _v = row.clone(); _v.push(false); _v };
            x = (x + 1);
        }
        padded = { let mut _v = padded.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    y = 0;
    while (y < h) {
        let mut x: i64 = 0;
        while (x < w) {
            padded[(pad_y + y) as usize][(pad_x + x) as usize] = image[y as usize].clone()[x as usize];
            x = (x + 1);
        }
        y = (y + 1);
    }
    let mut output: Vec<Vec<bool>> = vec![];
    y = 0;
    while (y < h) {
        let mut row_out: Vec<bool> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut sum: i64 = 0;
            let mut ky: i64 = 0;
            while (ky < k_h) {
                let mut kx: i64 = 0;
                while (kx < k_w) {
                    if ((kernel[ky as usize].clone()[kx as usize] == 1) && padded[(y + ky) as usize].clone()[(x + kx) as usize]) {
                        sum = (sum + 1);
                    }
                    kx = (kx + 1);
                }
                ky = (ky + 1);
            }
            row_out = { let mut _v = row_out.clone(); _v.push((sum == 5)); _v };
            x = (x + 1);
        }
        output = { let mut _v = output.clone(); _v.push(row_out.clone()); _v };
        y = (y + 1);
    }
    return output
}

fn main() {
    unsafe {
        g_rgb_img = vec![vec![vec![127, 255, 0]]];
        g_gray_img = vec![vec![127.0, 255.0, 0.0]];
        g_img1 = vec![vec![true, true, false]];
        g_kernel1 = vec![vec![0, 1, 0]];
        g_img2 = vec![vec![true, false, false]];
        g_kernel2 = vec![vec![1, 1, 0]];
        println!("{}", format!("{:?}", rgb_to_gray(g_rgb_img.clone().clone())));
        println!("{}", format!("{:?}", gray_to_binary(g_gray_img.clone().clone())));
        println!("{}", format!("{:?}", erosion(g_img1.clone().clone(), g_kernel1.clone().clone())));
        println!("{}", format!("{:?}", erosion(g_img2.clone().clone(), g_kernel2.clone().clone())));
    }
}
