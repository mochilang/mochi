// Generated by Mochi transpiler v0.10.61
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_PI: f64 = 0.0;
static mut g_img: Vec<Vec<i64>> = Vec::new();
fn main() {
    unsafe {
        g_PI = 3.141592653589793;
        g_img = vec![vec![52, 55, 61, 59, 79], vec![62, 59, 55, 104, 94], vec![63, 65, 66, 113, 144], vec![68, 70, 70, 126, 154], vec![70, 72, 69, 128, 155]];
                let _start: i64 = _now();
        unsafe fn expApprox(mut x: f64) -> f64 {
    let mut sum: f64 = 1.0;
    let mut term: f64 = 1.0;
    let mut n: i64 = 1;
    while (n < 10) {
        term = ((term * x) / (n as f64));
        sum = (sum + term);
        n = (n + 1);
    }
    return sum
};
        unsafe fn gen_gaussian_kernel(mut k_size: i64, mut sigma: f64) -> Vec<Vec<f64>> {
    let mut center: i64 = (k_size / 2);
    let mut kernel: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < k_size) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < k_size) {
            let mut x: f64 = ((i - center) as f64);
            let mut y: f64 = ((j - center) as f64);
            let mut exponent: f64 = -(((x * x) + (y * y)) / ((2.0 * sigma) * sigma));
            let mut value: f64 = ((1.0 / ((2.0 * g_PI) * sigma)) * expApprox(exponent));
            row = { let mut _v = row.clone(); _v.push(value); _v };
            j = (j + 1);
        }
        kernel = { let mut _v = kernel.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return kernel
};
        unsafe fn gaussian_filter(mut image: Vec<Vec<i64>>, mut k_size: i64, mut sigma: f64) -> Vec<Vec<i64>> {
    let mut height = (image.len() as i64);
    let mut width = (image[0 as usize].clone().len() as i64);
    let mut dst_height: i64 = ((height - k_size) + 1);
    let mut dst_width: i64 = ((width - k_size) + 1);
    let mut kernel: Vec<Vec<f64>> = gen_gaussian_kernel(k_size, sigma);
    let mut dst: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < dst_height) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < dst_width) {
            let mut sum: f64 = 0.0;
            let mut ki: i64 = 0;
            while (ki < k_size) {
                let mut kj: i64 = 0;
                while (kj < k_size) {
                    sum = (sum + ((image[(i + ki) as usize].clone()[(j + kj) as usize] as f64) * kernel[ki as usize].clone()[kj as usize]));
                    kj = (kj + 1);
                }
                ki = (ki + 1);
            }
            row = { let mut _v = row.clone(); _v.push((sum as i64)); _v };
            j = (j + 1);
        }
        dst = { let mut _v = dst.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return dst
};
        unsafe fn print_image(mut image: Vec<Vec<i64>>) {
    let mut i: i64 = 0;
    while (i < (image.len() as i64)) {
        println!("{:?}", image[i as usize].clone());
        i = (i + 1);
    }
};
        let mut gaussian3: Vec<Vec<i64>> = gaussian_filter(g_img.clone().clone(), 3, 1.0);
        let mut gaussian5: Vec<Vec<i64>> = gaussian_filter(g_img.clone().clone(), 5, 0.8);
        print_image(gaussian3.clone());
        print_image(gaussian5.clone());
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
