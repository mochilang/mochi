// Generated by Mochi transpiler v0.10.72
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn pad_edge(mut image: Vec<Vec<i64>>, mut pad_size: i64) -> Vec<Vec<i64>> {
    let height: i64 = (image.len() as i64);
    let width: i64 = (image[0 as usize].clone().len() as i64);
    let new_height: i64 = (height + (pad_size * 2));
    let new_width: i64 = (width + (pad_size * 2));
    let mut padded: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < new_height) {
        let mut row: Vec<i64> = vec![];
        let mut src_i: i64 = i;
        if (src_i < pad_size) {
            src_i = 0;
        }
        if (src_i >= (height + pad_size)) {
            src_i = (height - 1);
        } else {
            src_i = (src_i - pad_size);
        }
        let mut j: i64 = 0;
        while (j < new_width) {
            let mut src_j: i64 = j;
            if (src_j < pad_size) {
                src_j = 0;
            }
            if (src_j >= (width + pad_size)) {
                src_j = (width - 1);
            } else {
                src_j = (src_j - pad_size);
            }
            row = { let mut _v = row.clone(); _v.push(image[src_i as usize].clone()[src_j as usize]); _v };
            j = (j + 1);
        }
        padded = { let mut _v = padded.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return padded
};
    fn im2col(mut image: Vec<Vec<i64>>, mut block_h: i64, mut block_w: i64) -> Vec<Vec<i64>> {
    let rows: i64 = (image.len() as i64);
    let cols: i64 = (image[0 as usize].clone().len() as i64);
    let dst_height: i64 = ((rows - block_h) + 1);
    let dst_width: i64 = ((cols - block_w) + 1);
    let mut image_array: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < dst_height) {
        let mut j: i64 = 0;
        while (j < dst_width) {
            let mut window: Vec<i64> = vec![];
            let mut bi: i64 = 0;
            while (bi < block_h) {
                let mut bj: i64 = 0;
                while (bj < block_w) {
                    window = { let mut _v = window.clone(); _v.push(image[(i + bi) as usize].clone()[(j + bj) as usize]); _v };
                    bj = (bj + 1);
                }
                bi = (bi + 1);
            }
            image_array = { let mut _v = image_array.clone(); _v.push(window.clone()); _v };
            j = (j + 1);
        }
        i = (i + 1);
    }
    return image_array
};
    fn flatten(mut matrix: Vec<Vec<i64>>) -> Vec<i64> {
    let mut out: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (matrix.len() as i64)) {
        let mut j: i64 = 0;
        while (j < (matrix[i as usize].clone().len() as i64)) {
            out = { let mut _v = out.clone(); _v.push(matrix[i as usize].clone()[j as usize]); _v };
            j = (j + 1);
        }
        i = (i + 1);
    }
    return out
};
    fn dot(mut a: Vec<i64>, mut b: Vec<i64>) -> i64 {
    let mut sum: i64 = 0;
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        sum = (sum + (a[i as usize] * b[i as usize]));
        i = (i + 1);
    }
    return sum
};
    fn img_convolve(mut image: Vec<Vec<i64>>, mut kernel: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let height: i64 = (image.len() as i64);
    let width: i64 = (image[0 as usize].clone().len() as i64);
    let k_size: i64 = (kernel.len() as i64);
    let pad_size: i64 = (k_size / 2);
    let padded: Vec<Vec<i64>> = pad_edge(image.clone(), pad_size);
    let image_array: Vec<Vec<i64>> = im2col(padded.clone(), k_size, k_size);
    let kernel_flat: Vec<i64> = flatten(kernel.clone());
    let mut dst: Vec<Vec<i64>> = vec![];
    let mut idx: i64 = 0;
    let mut i: i64 = 0;
    while (i < height) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < width) {
            let val: i64 = dot(image_array[idx as usize].clone(), kernel_flat.clone());
            row = { let mut _v = row.clone(); _v.push(val); _v };
            idx = (idx + 1);
            j = (j + 1);
        }
        dst = { let mut _v = dst.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return dst
};
    fn print_matrix(mut m: Vec<Vec<i64>>) {
    let mut i: i64 = 0;
    while (i < (m.len() as i64)) {
        let mut line: String = String::new();
        let mut j: i64 = 0;
        while (j < (m[i as usize].clone().len() as i64)) {
            if (j > 0) {
                line = format!("{}{}", line, " ");
            }
            line = format!("{}{}", line, m[i as usize].clone()[j as usize].to_string());
            j = (j + 1);
        }
        println!("{}", line);
        i = (i + 1);
    }
};
    let image: Vec<Vec<i64>> = vec![vec![1, 2, 3, 0, 0].clone(), vec![4, 5, 6, 0, 0].clone(), vec![7, 8, 9, 0, 0].clone(), vec![0, 0, 0, 0, 0].clone(), vec![0, 0, 0, 0, 0].clone()];
    let laplace_kernel: Vec<Vec<i64>> = vec![vec![0, 1, 0].clone(), vec![1, -4, 1].clone(), vec![0, 1, 0].clone()];
    let result: Vec<Vec<i64>> = img_convolve(image.clone(), laplace_kernel.clone());
    print_matrix(result.clone());
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
