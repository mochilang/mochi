// Generated by Mochi transpiler v0.10.63
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct TextCounts {
    single: HashMap<String, i64>,
    double: HashMap<String, i64>,
}
impl std::fmt::Display for TextCounts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"single\": {:?}", self.single)?;
        write!(f, ", ")?;
        write!(f, "\"double\": {:?}", self.double)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn log2(mut x: f64) -> f64 {
    let mut k: f64 = 0.0;
    let mut v: f64 = x;
    while (v >= 2.0) {
        v = (v / 2.0);
        k = (k + 1.0);
    }
    while (v < 1.0) {
        v = (v * 2.0);
        k = (k - 1.0);
    }
    let z: f64 = ((v - 1.0) / (v + 1.0));
    let mut zpow: f64 = z;
    let mut sum: f64 = z;
    let mut i: i64 = 3;
    while (i <= 9) {
        zpow = ((zpow * z) * z);
        sum = (sum + (zpow / (i as f64)));
        i = (i + 2);
    }
    let ln2: f64 = 0.6931471805599453;
    return (k + ((2.0 * sum) / ln2))
};
    fn analyze_text(text: &str) -> TextCounts {
    let mut single: HashMap<String, i64> = HashMap::new();
    let mut double: HashMap<String, i64> = HashMap::new();
    let n: i64 = (text.len() as i64);
    if (n == 0) {
        return TextCounts {single: single, double: double}
    }
    let last: String = { let tmp = &text; tmp.chars().skip((n - 1) as usize).take((n - (n - 1)) as usize).collect::<String>() }.clone();
    if single.contains_key(&last) {
        single.insert(last.clone(), (single.get(last.as_str()).cloned().unwrap_or_default() + 1));
    } else {
        single.insert(last.clone(), 1);
    }
    let first: String = { let tmp = &text; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone();
    let pair0: String = format!("{}{}", " ", first).clone();
    double.insert(pair0.clone(), 1);
    let mut i: i64 = 0;
    while (i < (n - 1)) {
        let ch: String = { let tmp = &text; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if single.contains_key(&ch) {
            single.insert(ch.clone(), (single.get(ch.as_str()).cloned().unwrap_or_default() + 1));
        } else {
            single.insert(ch.clone(), 1);
        }
        let seq: String = { let tmp = &text; tmp.chars().skip(i as usize).take(((i + 2) - i) as usize).collect::<String>() }.clone();
        if double.contains_key(&seq) {
            double.insert(seq.clone(), (double.get(seq.as_str()).cloned().unwrap_or_default() + 1));
        } else {
            double.insert(seq.clone(), 1);
        }
        i = (i + 1);
    }
    return TextCounts {single: single, double: double}
};
    fn round_to_int(mut x: f64) -> i64 {
    if (x < 0.0) {
        return ((x - 0.5) as i64)
    }
    return ((x + 0.5) as i64)
};
    fn calculate_entropy(text: &str) {
    let counts: TextCounts = analyze_text(text);
    let alphas: String = String::from(" abcdefghijklmnopqrstuvwxyz").clone();
    let mut total1: i64 = 0;
    for ch in counts.single.clone().keys().cloned() {
        total1 = (total1 + counts.single.clone()[ch.as_str()]);
    }
    let mut h1: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (alphas.len() as i64)) {
        let ch: String = { let tmp = &alphas; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if counts.single.clone().contains_key(&ch) {
            let prob: f64 = ((counts.single.clone()[ch.as_str()] as f64) / (total1 as f64));
            h1 = (h1 + (prob * log2(prob)));
        }
        i = (i + 1);
    }
    let first_entropy: f64 = -h1;
    println!("{}", format!("{}{}", round_to_int(first_entropy).to_string(), ".0"));
    let mut total2: i64 = 0;
    for seq in counts.double.clone().keys().cloned() {
        total2 = (total2 + counts.double.clone()[seq.as_str()]);
    }
    let mut h2: f64 = 0.0;
    let mut a0: i64 = 0;
    while (a0 < (alphas.len() as i64)) {
        let ch0: String = { let tmp = &alphas; tmp.chars().skip(a0 as usize).take(((a0 + 1) - a0) as usize).collect::<String>() }.clone();
        let mut a1: i64 = 0;
        while (a1 < (alphas.len() as i64)) {
            let ch1: String = { let tmp = &alphas; tmp.chars().skip(a1 as usize).take(((a1 + 1) - a1) as usize).collect::<String>() }.clone();
            let seq: String = format!("{}{}", ch0, ch1).clone();
            if counts.double.clone().contains_key(&seq) {
                let prob: f64 = ((counts.double.clone()[seq.as_str()] as f64) / (total2 as f64));
                h2 = (h2 + (prob * log2(prob)));
            }
            a1 = (a1 + 1);
        }
        a0 = (a0 + 1);
    }
    let second_entropy: f64 = -h2;
    println!("{}", format!("{}{}", round_to_int(second_entropy).to_string(), ".0"));
    let diff: f64 = (second_entropy - first_entropy);
    println!("{}", format!("{}{}", round_to_int(diff).to_string(), ".0"));
};
    let text1: String = format!("{}{}", format!("{}{}", "Behind Winston's back the voice ", "from the telescreen was still "), "babbling and the overfulfilment").clone();
    calculate_entropy(&text1);
    let text3: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Had repulsive dashwoods suspicion sincerity but advantage now him. ", "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. "), "You greatest jointure saw horrible. He private he on be imagine "), "suppose. Fertile beloved evident through no service elderly is. Blind "), "there if every no so at. Own neglected you preferred way sincerity "), "delivered his attempted. To of message cottage windows do besides "), "against uncivil.  Delightful unreserved impossible few estimating "), "men favourable see entreaties. She propriety immediate was improving. "), "He or entrance humoured likewise moderate. Much nor game son say "), "feel. Fat make met can must form into gate. Me we offending prevailed "), "discovery.").clone();
    calculate_entropy(&text3);
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
