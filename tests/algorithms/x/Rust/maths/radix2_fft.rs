// Generated by Mochi transpiler v0.10.67
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Complex {
    re: f64,
    im: f64,
}
impl std::fmt::Display for Complex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"re\": {}", self.re)?;
        write!(f, ", ")?;
        write!(f, "\"im\": {}", self.im)?;
        write!(f, "}}")
    }
}

static g_PI: f64 = 3.141592653589793;
fn main() {
    unsafe {
                let _start: i64 = _now();
        fn c_add(mut a: Complex, mut b: Complex) -> Complex {
    return Complex {re: (a.re + b.re), im: (a.im + b.im)}
};
        fn c_sub(mut a: Complex, mut b: Complex) -> Complex {
    return Complex {re: (a.re - b.re), im: (a.im - b.im)}
};
        fn c_mul(mut a: Complex, mut b: Complex) -> Complex {
    return Complex {re: ((a.re * b.re) - (a.im * b.im)), im: ((a.re * b.im) + (a.im * b.re))}
};
        fn c_mul_scalar(mut a: Complex, mut s: f64) -> Complex {
    return Complex {re: (a.re * s), im: (a.im * s)}
};
        fn c_div_scalar(mut a: Complex, mut s: f64) -> Complex {
    return Complex {re: (a.re / s), im: (a.im / s)}
};
        fn sin_taylor(mut x: f64) -> f64 {
    let mut term: f64 = x;
    let mut sum: f64 = x;
    let mut i: i64 = 1;
    while (i < 10) {
        let k1: f64 = (2.0 * (i as f64));
        let k2: f64 = (k1 + 1.0);
        term = (((-term * x) * x) / (k1 * k2));
        sum = (sum + term);
        i = (i + 1);
    }
    return sum
};
        fn cos_taylor(mut x: f64) -> f64 {
    let mut term: f64 = 1.0;
    let mut sum: f64 = 1.0;
    let mut i: i64 = 1;
    while (i < 10) {
        let k1: f64 = ((2.0 * (i as f64)) - 1.0);
        let k2: f64 = (2.0 * (i as f64));
        term = (((-term * x) * x) / (k1 * k2));
        sum = (sum + term);
        i = (i + 1);
    }
    return sum
};
        let mut exp_i = |theta: f64| -> Complex {
    return Complex {re: cos_taylor(theta), im: sin_taylor(theta)}
};
        fn make_complex_list(mut n: i64, mut value: Complex) -> Vec<Complex> {
    let mut arr: Vec<Complex> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        arr = { let mut _v = arr.clone(); _v.push(value.clone()); _v };
        i = (i + 1);
    }
    return arr
};
        let mut fft = {
fn fft(PI: f64, c_add: &mut dyn FnMut(Complex, Complex) -> Complex, c_div_scalar: &mut dyn FnMut(Complex, f64) -> Complex, c_mul: &mut dyn FnMut(Complex, Complex) -> Complex, c_sub: &mut dyn FnMut(Complex, Complex) -> Complex, exp_i: &mut dyn FnMut(f64) -> Complex, make_complex_list: &mut dyn FnMut(i64, Complex) -> Vec<Complex>, a: Vec<Complex>, invert: bool) -> Vec<Complex> {
    let n: i64 = (a.len() as i64);
    if (n == 1) {
        return vec![a[0 as usize].clone().clone()]
    }
    let mut a0: Vec<Complex> = vec![];
    let mut a1: Vec<Complex> = vec![];
    let mut i: i64 = 0;
    while (i < (n / 2)) {
        a0 = { let mut _v = a0.clone(); _v.push(a[(2 * i) as usize].clone()); _v };
        a1 = { let mut _v = a1.clone(); _v.push(a[((2 * i) + 1) as usize].clone()); _v };
        i = (i + 1);
    }
    let y0: Vec<Complex> = fft(unsafe { g_PI.clone() }, c_add, c_div_scalar, c_mul, c_sub, exp_i, make_complex_list, a0.clone(), invert);
    let y1: Vec<Complex> = fft(unsafe { g_PI.clone() }, c_add, c_div_scalar, c_mul, c_sub, exp_i, make_complex_list, a1.clone(), invert);
    let angle: f64 = (((2.0 * unsafe { g_PI.clone() }) / (n as f64)) * if invert { -1.0 } else { 1.0 });
    let mut w: Complex = Complex {re: 1.0, im: 0.0};
    let wn: Complex = exp_i(angle);
    let mut y: Vec<Complex> = make_complex_list(n, Complex {re: 0.0, im: 0.0});
    i = 0;
    while (i < (n / 2)) {
        let t: Complex = c_mul(w.clone(), y1[i as usize].clone());
        let u: Complex = y0[i as usize].clone();
        let mut even: Complex = c_add(u.clone(), t.clone());
        let mut odd: Complex = c_sub(u.clone(), t.clone());
        if invert {
            even = c_div_scalar(even.clone(), 2.0);
            odd = c_div_scalar(odd.clone(), 2.0);
        }
        y[i as usize] = even.clone();
        y[(i + (n / 2)) as usize] = odd.clone();
        w = c_mul(w.clone(), wn.clone());
        i = (i + 1);
    }
    return y
}
|a: Vec<Complex>, invert: bool| -> Vec<Complex> { fft(PI, &mut c_add, &mut c_div_scalar, &mut c_mul, &mut c_sub, &mut exp_i, &mut make_complex_list, a, invert) }
};
        fn floor(mut x: f64) -> f64 {
    let mut i: i64 = (x as i64);
    if ((i as f64) > x) {
        i = (i - 1);
    }
    return (i as f64)
};
        fn pow10(mut n: i64) -> f64 {
    let mut p: f64 = 1.0;
    let mut i: i64 = 0;
    while (i < n) {
        p = (p * 10.0);
        i = (i + 1);
    }
    return p
};
        let mut round_to = |x: f64, ndigits: i64| -> f64 {
    let m: f64 = pow10(ndigits);
    return (floor(((x * m) + 0.5)) / m)
};
        fn list_to_string(mut l: Vec<f64>) -> String {
    let mut s: String = String::from("[");
    let mut i: i64 = 0;
    while (i < (l.len() as i64)) {
        s = format!("{}{}", s, l[i as usize].to_string());
        if ((i + 1) < (l.len() as i64)) {
            s = format!("{}{}", s, ", ");
        }
        i = (i + 1);
    }
    s = format!("{}{}", s, "]");
    return s.clone()
};
        let mut multiply_poly = |a: Vec<f64>, b: Vec<f64>| -> Vec<f64> {
    let mut n: i64 = 1;
    while (n < (((a.len() as i64) + (b.len() as i64)) - 1)) {
        n = (n * 2);
    }
    let mut fa: Vec<Complex> = make_complex_list(n, Complex {re: 0.0, im: 0.0});
    let mut fb: Vec<Complex> = make_complex_list(n, Complex {re: 0.0, im: 0.0});
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        fa[i as usize] = Complex {re: a[i as usize], im: 0.0};
        i = (i + 1);
    }
    i = 0;
    while (i < (b.len() as i64)) {
        fb[i as usize] = Complex {re: b[i as usize], im: 0.0};
        i = (i + 1);
    }
    fa = fft(fa.clone(), false);
    fb = fft(fb.clone(), false);
    i = 0;
    while (i < n) {
        fa[i as usize] = c_mul(fa[i as usize].clone(), fb[i as usize].clone());
        i = (i + 1);
    }
    fa = fft(fa.clone(), true);
    let mut res: Vec<f64> = vec![];
    i = 0;
    while (i < (((a.len() as i64) + (b.len() as i64)) - 1)) {
        let val: Complex = fa[i as usize].clone();
        res = { let mut _v = res.clone(); _v.push(round_to(val.re, 8)); _v };
        i = (i + 1);
    }
    while (((res.len() as i64) > 0) && (res[((res.len() as i64) - 1) as usize] == 0.0)) {
        res = res[0 as usize..((res.len() as i64) - 1) as usize].to_vec();
    }
    return res
};
        let A: Vec<f64> = vec![0.0, 1.0, 0.0, 2.0];
        let B: Vec<f64> = vec![2.0, 3.0, 4.0, 0.0];
        let product: Vec<f64> = multiply_poly(A.clone(), B.clone());
        println!("{}", list_to_string(product.clone()));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
