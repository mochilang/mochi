// Generated by Mochi transpiler v0.10.67
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct PollardResult {
    factor: i64,
    ok: bool,
}
impl std::fmt::Display for PollardResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"factor\": {}", self.factor)?;
        write!(f, ", ")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn gcd(mut a: i64, mut b: i64) -> i64 {
    let mut x: i64 = if (a < 0) { -a } else { a };
    let mut y: i64 = if (b < 0) { -b } else { b };
    while (y != 0) {
        let t: i64 = (x % y);
        x = y;
        y = t;
    }
    return x
};
    fn rand_fn(mut value: i64, mut step: i64, mut modulus: i64) -> i64 {
    return (((value * value) + step) % modulus)
};
    let mut pollard_rho = |num: i64, seed: i64, step: i64, attempts: i64| -> PollardResult {
    if (num < 2) {
        panic!("The input value cannot be less than 2");
    }
    if ((num > 2) && ((num % 2) == 0)) {
        return PollardResult {factor: 2, ok: true}
    }
    let mut s: i64 = seed;
    let mut st: i64 = step;
    let mut i: i64 = 0;
    while (i < attempts) {
        let mut tortoise: i64 = s;
        let mut hare: i64 = s;
        loop {
            tortoise = rand_fn(tortoise, st, num);
            hare = rand_fn(hare, st, num);
            hare = rand_fn(hare, st, num);
            let divisor: i64 = gcd((hare - tortoise), num);
            if (divisor == 1) {
                continue
            } else if (divisor == num) {
                break
            } else {
                return PollardResult {factor: divisor, ok: true}
            }
        }
        s = hare;
        st = (st + 1);
        i = (i + 1);
    }
    return PollardResult {factor: 0, ok: false}
};
    let mut test_pollard_rho = || {
    let r1: PollardResult = pollard_rho(8051, 2, 1, 5);
    if (!r1.ok || ((r1.factor != 83) && (r1.factor != 97))) {
        panic!("test1 failed");
    }
    let r2: PollardResult = pollard_rho(10403, 2, 1, 5);
    if (!r2.ok || ((r2.factor != 101) && (r2.factor != 103))) {
        panic!("test2 failed");
    }
    let r3: PollardResult = pollard_rho(100, 2, 1, 3);
    if (!r3.ok || (r3.factor != 2)) {
        panic!("test3 failed");
    }
    let r4: PollardResult = pollard_rho(17, 2, 1, 3);
    if r4.ok {
        panic!("test4 failed");
    }
    let r5: PollardResult = pollard_rho(((17 * 17) * 17), 2, 1, 3);
    if (!r5.ok || (r5.factor != 17)) {
        panic!("test5 failed");
    }
    let r6: PollardResult = pollard_rho(((17 * 17) * 17), 2, 1, 1);
    if r6.ok {
        panic!("test6 failed");
    }
    let r7: PollardResult = pollard_rho(((3 * 5) * 7), 2, 1, 3);
    if (!r7.ok || (r7.factor != 21)) {
        panic!("test7 failed");
    }
};
    let mut mochi_main = || {
    test_pollard_rho();
    let a: PollardResult = pollard_rho(100, 2, 1, 3);
    if a.ok {
        println!("{}", a.factor.to_string());
    } else {
        println!("{}", "None");
    }
    let b: PollardResult = pollard_rho(17, 2, 1, 3);
    if b.ok {
        println!("{}", b.factor.to_string());
    } else {
        println!("{}", "None");
    }
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
