// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_digits: String = String::new();
static mut g_i: i64 = 0;
fn main() {
    unsafe {
        g_digits = String::from("").clone();
        g_i = 1;
                let _start: i64 = _now();
        fn mod_pow(mut base: i64, mut exponent: i64, mut modulus: i64) -> i64 {
    let mut result: i64 = 1;
    let mut b: i64 = (base % modulus);
    let mut e: i64 = exponent;
    while (e > 0) {
        if ((e % 2) == 1) {
            result = ((result * b) % modulus);
        }
        b = ((b * b) % modulus);
        e = (e / 2);
    }
    return result
};
        fn pow_float(mut base: f64, mut exponent: i64) -> f64 {
    let mut exp: i64 = exponent;
    let mut result: f64 = 1.0;
    if (exp < 0) {
        exp = -exp;
    }
    let mut i: i64 = 0;
    while (i < exp) {
        result = (result * base);
        i = (i + 1);
    }
    if (exponent < 0) {
        result = (1.0 / result);
    }
    return result
};
        fn hex_digit(mut n: i64) -> String {
    if (n < 10) {
        return n.to_string().to_string()
    }
    let mut letters: Vec<String> = vec![String::from("a").clone().clone(), String::from("b").clone().clone(), String::from("c").clone().clone(), String::from("d").clone().clone(), String::from("e").clone().clone(), String::from("f").clone().clone()];
    return letters[(n - 10) as usize].clone().clone()
};
        fn floor_float(mut x: f64) -> f64 {
    let mut i: i64 = (x as i64);
    if ((i as f64) > x) {
        i = (i - 1);
    }
    return (i as f64)
};
        fn subsum(mut digit_pos_to_extract: i64, mut denominator_addend: i64, mut precision: i64) -> f64 {
    let mut total: f64 = 0.0;
    let mut sum_index: i64 = 0;
    while (sum_index < (digit_pos_to_extract + precision)) {
        let mut denominator: i64 = ((8 * sum_index) + denominator_addend);
        if (sum_index < digit_pos_to_extract) {
            let mut exponent: i64 = ((digit_pos_to_extract - 1) - sum_index);
            let mut exponential_term: i64 = mod_pow(16, exponent, denominator);
            total = (total + ((exponential_term as f64) / (denominator as f64)));
        } else {
            let mut exponent: i64 = ((digit_pos_to_extract - 1) - sum_index);
            let mut exponential_term: f64 = pow_float(16.0, exponent);
            total = (total + (exponential_term / (denominator as f64)));
        }
        sum_index = (sum_index + 1);
    }
    return total
};
        fn bailey_borwein_plouffe(mut digit_position: i64, mut precision: i64) -> String {
    if (digit_position <= 0) {
        panic!("Digit position must be a positive integer");
    }
    if (precision < 0) {
        panic!("Precision must be a nonnegative integer");
    }
    let mut sum_result: f64 = ((((4.0 * subsum(digit_position, 1, precision)) - (2.0 * subsum(digit_position, 4, precision))) - (1.0 * subsum(digit_position, 5, precision))) - (1.0 * subsum(digit_position, 6, precision)));
    let mut fraction: f64 = (sum_result - floor_float(sum_result));
    let mut digit: i64 = ((fraction * 16.0) as i64);
    let mut hd: String = hex_digit(digit).clone();
    return hd.clone()
};
        while (g_i <= 10) {
            g_digits = format!("{}{}", g_digits, bailey_borwein_plouffe(g_i, 1000));
            g_i = (g_i + 1);
        }
        println!("{}", g_digits);
        println!("{}", bailey_borwein_plouffe(5, 10000));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
