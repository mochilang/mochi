// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
static mut g_PI: f64 = 0.0;
static mut g_TWO_PI: f64 = 0.0;
fn main() {
    unsafe {
        g_PI = 3.141592653589793;
        g_TWO_PI = 6.283185307179586;
                let _start: i64 = _now();
        unsafe fn _mod(mut x: f64, mut m: f64) -> f64 {
    return (x - ((((x / m) as i64) as f64) * m))
};
        unsafe fn sin_approx(mut x: f64) -> f64 {
    let mut y: f64 = (_mod((x + g_PI), g_TWO_PI) - g_PI);
    let mut y2: f64 = (y * y);
    let mut y3: f64 = (y2 * y);
    let mut y5: f64 = (y3 * y2);
    let mut y7: f64 = (y5 * y2);
    return (((y - (y3 / 6.0)) + (y5 / 120.0)) - (y7 / 5040.0))
};
        unsafe fn cos_approx(mut x: f64) -> f64 {
    let mut y: f64 = (_mod((x + g_PI), g_TWO_PI) - g_PI);
    let mut y2: f64 = (y * y);
    let mut y4: f64 = (y2 * y2);
    let mut y6: f64 = (y4 * y2);
    return (((1.0 - (y2 / 2.0)) + (y4 / 24.0)) - (y6 / 720.0))
};
        unsafe fn tan_approx(mut x: f64) -> f64 {
    return (sin_approx(x) / cos_approx(x))
};
        unsafe fn sqrt_approx(mut x: f64) -> f64 {
    if (x <= 0.0) {
        return 0.0
    }
    let mut guess: f64 = (x / 2.0);
    let mut i: i64 = 0;
    while (i < 20) {
        guess = ((guess + (x / guess)) / 2.0);
        i = (i + 1);
    }
    return guess
};
        unsafe fn surface_area_cube(mut side_length: f64) -> f64 {
    if (side_length < 0.0) {
        println!("{}", "ValueError: surface_area_cube() only accepts non-negative values");
        return 0.0
    }
    return ((6.0 * side_length) * side_length)
};
        unsafe fn surface_area_cuboid(mut length: f64, mut breadth: f64, mut height: f64) -> f64 {
    if (((length < 0.0) || (breadth < 0.0)) || (height < 0.0)) {
        println!("{}", "ValueError: surface_area_cuboid() only accepts non-negative values");
        return 0.0
    }
    return (2.0 * (((length * breadth) + (breadth * height)) + (length * height)))
};
        unsafe fn surface_area_sphere(mut radius: f64) -> f64 {
    if (radius < 0.0) {
        println!("{}", "ValueError: surface_area_sphere() only accepts non-negative values");
        return 0.0
    }
    return (((4.0 * g_PI) * radius) * radius)
};
        unsafe fn surface_area_hemisphere(mut radius: f64) -> f64 {
    if (radius < 0.0) {
        println!("{}", "ValueError: surface_area_hemisphere() only accepts non-negative values");
        return 0.0
    }
    return (((3.0 * g_PI) * radius) * radius)
};
        unsafe fn surface_area_cone(mut radius: f64, mut height: f64) -> f64 {
    if ((radius < 0.0) || (height < 0.0)) {
        println!("{}", "ValueError: surface_area_cone() only accepts non-negative values");
        return 0.0
    }
    let mut slant: f64 = sqrt_approx(((height * height) + (radius * radius)));
    return ((g_PI * radius) * (radius + slant))
};
        unsafe fn surface_area_conical_frustum(mut radius1: f64, mut radius2: f64, mut height: f64) -> f64 {
    if (((radius1 < 0.0) || (radius2 < 0.0)) || (height < 0.0)) {
        println!("{}", "ValueError: surface_area_conical_frustum() only accepts non-negative values");
        return 0.0
    }
    let mut slant: f64 = sqrt_approx(((height * height) + ((radius1 - radius2) * (radius1 - radius2))));
    return (g_PI * (((slant * (radius1 + radius2)) + (radius1 * radius1)) + (radius2 * radius2)))
};
        unsafe fn surface_area_cylinder(mut radius: f64, mut height: f64) -> f64 {
    if ((radius < 0.0) || (height < 0.0)) {
        println!("{}", "ValueError: surface_area_cylinder() only accepts non-negative values");
        return 0.0
    }
    return (((2.0 * g_PI) * radius) * (height + radius))
};
        unsafe fn surface_area_torus(mut torus_radius: f64, mut tube_radius: f64) -> f64 {
    if ((torus_radius < 0.0) || (tube_radius < 0.0)) {
        println!("{}", "ValueError: surface_area_torus() only accepts non-negative values");
        return 0.0
    }
    if (torus_radius < tube_radius) {
        println!("{}", "ValueError: surface_area_torus() does not support spindle or self intersecting tori");
        return 0.0
    }
    return ((((4.0 * g_PI) * g_PI) * torus_radius) * tube_radius)
};
        unsafe fn area_rectangle(mut length: f64, mut width: f64) -> f64 {
    if ((length < 0.0) || (width < 0.0)) {
        println!("{}", "ValueError: area_rectangle() only accepts non-negative values");
        return 0.0
    }
    return (length * width)
};
        unsafe fn area_square(mut side_length: f64) -> f64 {
    if (side_length < 0.0) {
        println!("{}", "ValueError: area_square() only accepts non-negative values");
        return 0.0
    }
    return (side_length * side_length)
};
        unsafe fn area_triangle(mut base: f64, mut height: f64) -> f64 {
    if ((base < 0.0) || (height < 0.0)) {
        println!("{}", "ValueError: area_triangle() only accepts non-negative values");
        return 0.0
    }
    return ((base * height) / 2.0)
};
        unsafe fn area_triangle_three_sides(mut side1: f64, mut side2: f64, mut side3: f64) -> f64 {
    if (((side1 < 0.0) || (side2 < 0.0)) || (side3 < 0.0)) {
        println!("{}", "ValueError: area_triangle_three_sides() only accepts non-negative values");
        return 0.0
    }
    if ((((side1 + side2) < side3) || ((side1 + side3) < side2)) || ((side2 + side3) < side1)) {
        println!("{}", "ValueError: Given three sides do not form a triangle");
        return 0.0
    }
    let mut s: f64 = (((side1 + side2) + side3) / 2.0);
    let mut prod: f64 = (((s * (s - side1)) * (s - side2)) * (s - side3));
    let mut res: f64 = sqrt_approx(prod);
    return res
};
        unsafe fn area_parallelogram(mut base: f64, mut height: f64) -> f64 {
    if ((base < 0.0) || (height < 0.0)) {
        println!("{}", "ValueError: area_parallelogram() only accepts non-negative values");
        return 0.0
    }
    return (base * height)
};
        unsafe fn area_trapezium(mut base1: f64, mut base2: f64, mut height: f64) -> f64 {
    if (((base1 < 0.0) || (base2 < 0.0)) || (height < 0.0)) {
        println!("{}", "ValueError: area_trapezium() only accepts non-negative values");
        return 0.0
    }
    return ((0.5 * (base1 + base2)) * height)
};
        unsafe fn area_circle(mut radius: f64) -> f64 {
    if (radius < 0.0) {
        println!("{}", "ValueError: area_circle() only accepts non-negative values");
        return 0.0
    }
    return ((g_PI * radius) * radius)
};
        unsafe fn area_ellipse(mut radius_x: f64, mut radius_y: f64) -> f64 {
    if ((radius_x < 0.0) || (radius_y < 0.0)) {
        println!("{}", "ValueError: area_ellipse() only accepts non-negative values");
        return 0.0
    }
    return ((g_PI * radius_x) * radius_y)
};
        unsafe fn area_rhombus(mut diagonal1: f64, mut diagonal2: f64) -> f64 {
    if ((diagonal1 < 0.0) || (diagonal2 < 0.0)) {
        println!("{}", "ValueError: area_rhombus() only accepts non-negative values");
        return 0.0
    }
    return ((0.5 * diagonal1) * diagonal2)
};
        unsafe fn area_reg_polygon(mut sides: i64, mut length: f64) -> f64 {
    if (sides < 3) {
        println!("{}", "ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides");
        return 0.0
    }
    if (length < 0.0) {
        println!("{}", "ValueError: area_reg_polygon() only accepts non-negative values as length of a side");
        return 0.0
    }
    let mut n: f64 = (sides as f64);
    return (((n * length) * length) / (4.0 * tan_approx((g_PI / n))))
};
        println!("{}", "[DEMO] Areas of various geometric shapes:");
        println!("{}", format!("{}{}", "Rectangle: ", area_rectangle(10.0, 20.0).to_string()));
        println!("{}", format!("{}{}", "Square: ", area_square(10.0).to_string()));
        println!("{}", format!("{}{}", "Triangle: ", area_triangle(10.0, 10.0).to_string()));
        let mut TRI_THREE_SIDES: f64 = area_triangle_three_sides(5.0, 12.0, 13.0);
        println!("{}", format!("{}{}", "Triangle Three Sides: ", TRI_THREE_SIDES.to_string()));
        println!("{}", format!("{}{}", "Parallelogram: ", area_parallelogram(10.0, 20.0).to_string()));
        println!("{}", format!("{}{}", "Rhombus: ", area_rhombus(10.0, 20.0).to_string()));
        println!("{}", format!("{}{}", "Trapezium: ", area_trapezium(10.0, 20.0, 30.0).to_string()));
        println!("{}", format!("{}{}", "Circle: ", area_circle(20.0).to_string()));
        println!("{}", format!("{}{}", "Ellipse: ", area_ellipse(10.0, 20.0).to_string()));
        println!("{}", "");
        println!("{}", "Surface Areas of various geometric shapes:");
        println!("{}", format!("{}{}", "Cube: ", surface_area_cube(20.0).to_string()));
        println!("{}", format!("{}{}", "Cuboid: ", surface_area_cuboid(10.0, 20.0, 30.0).to_string()));
        println!("{}", format!("{}{}", "Sphere: ", surface_area_sphere(20.0).to_string()));
        println!("{}", format!("{}{}", "Hemisphere: ", surface_area_hemisphere(20.0).to_string()));
        println!("{}", format!("{}{}", "Cone: ", surface_area_cone(10.0, 20.0).to_string()));
        println!("{}", format!("{}{}", "Conical Frustum: ", surface_area_conical_frustum(10.0, 20.0, 30.0).to_string()));
        println!("{}", format!("{}{}", "Cylinder: ", surface_area_cylinder(10.0, 20.0).to_string()));
        println!("{}", format!("{}{}", "Torus: ", surface_area_torus(20.0, 10.0).to_string()));
        println!("{}", format!("{}{}", "Equilateral Triangle: ", area_reg_polygon(3, 10.0).to_string()));
        println!("{}", format!("{}{}", "Square: ", area_reg_polygon(4, 10.0).to_string()));
        println!("{}", format!("{}{}", "Regular Pentagon: ", area_reg_polygon(5, 10.0).to_string()));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
