// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static g_PI: f64 = 3.141592653589793;
static g_SQRT5: f64 = 2.23606797749979;
fn main() {
    unsafe {
                let _start: i64 = _now();
        fn minf(mut a: f64, mut b: f64) -> f64 {
    if (a < b) {
        return a
    }
    return b
};
        fn maxf(mut a: f64, mut b: f64) -> f64 {
    if (a > b) {
        return a
    }
    return b
};
        fn vol_cube(mut side_length: f64) -> f64 {
    if (side_length < 0.0) {
        panic!("vol_cube() only accepts non-negative values");
    }
    return ((side_length * side_length) * side_length)
};
        fn vol_spherical_cap(mut height: f64, mut radius: f64) -> f64 {
    if ((height < 0.0) || (radius < 0.0)) {
        panic!("vol_spherical_cap() only accepts non-negative values");
    }
    return (((((1.0 / 3.0) * unsafe { g_PI.clone() }) * height) * height) * ((3.0 * radius) - height))
};
        fn vol_sphere(mut radius: f64) -> f64 {
    if (radius < 0.0) {
        panic!("vol_sphere() only accepts non-negative values");
    }
    return (((((4.0 / 3.0) * unsafe { g_PI.clone() }) * radius) * radius) * radius)
};
        fn vol_spheres_intersect(mut radius_1: f64, mut radius_2: f64, mut centers_distance: f64) -> f64 {
    if (((radius_1 < 0.0) || (radius_2 < 0.0)) || (centers_distance < 0.0)) {
        panic!("vol_spheres_intersect() only accepts non-negative values");
    }
    if (centers_distance == 0.0) {
        return vol_sphere(minf(radius_1, radius_2))
    }
    let h1: f64 = ((((radius_1 - radius_2) + centers_distance) * ((radius_1 + radius_2) - centers_distance)) / (2.0 * centers_distance));
    let h2: f64 = ((((radius_2 - radius_1) + centers_distance) * ((radius_2 + radius_1) - centers_distance)) / (2.0 * centers_distance));
    return (vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1))
};
        fn vol_spheres_union(mut radius_1: f64, mut radius_2: f64, mut centers_distance: f64) -> f64 {
    if (((radius_1 <= 0.0) || (radius_2 <= 0.0)) || (centers_distance < 0.0)) {
        panic!("vol_spheres_union() only accepts non-negative values, non-zero radius");
    }
    if (centers_distance == 0.0) {
        return vol_sphere(maxf(radius_1, radius_2))
    }
    return ((vol_sphere(radius_1) + vol_sphere(radius_2)) - vol_spheres_intersect(radius_1, radius_2, centers_distance))
};
        fn vol_cuboid(mut width: f64, mut height: f64, mut length: f64) -> f64 {
    if (((width < 0.0) || (height < 0.0)) || (length < 0.0)) {
        panic!("vol_cuboid() only accepts non-negative values");
    }
    return ((width * height) * length)
};
        fn vol_cone(mut area_of_base: f64, mut height: f64) -> f64 {
    if ((height < 0.0) || (area_of_base < 0.0)) {
        panic!("vol_cone() only accepts non-negative values");
    }
    return ((area_of_base * height) / 3.0)
};
        fn vol_right_circ_cone(mut radius: f64, mut height: f64) -> f64 {
    if ((height < 0.0) || (radius < 0.0)) {
        panic!("vol_right_circ_cone() only accepts non-negative values");
    }
    return ((((unsafe { g_PI.clone() } * radius) * radius) * height) / 3.0)
};
        fn vol_prism(mut area_of_base: f64, mut height: f64) -> f64 {
    if ((height < 0.0) || (area_of_base < 0.0)) {
        panic!("vol_prism() only accepts non-negative values");
    }
    return (area_of_base * height)
};
        fn vol_pyramid(mut area_of_base: f64, mut height: f64) -> f64 {
    if ((height < 0.0) || (area_of_base < 0.0)) {
        panic!("vol_pyramid() only accepts non-negative values");
    }
    return ((area_of_base * height) / 3.0)
};
        fn vol_hemisphere(mut radius: f64) -> f64 {
    if (radius < 0.0) {
        panic!("vol_hemisphere() only accepts non-negative values");
    }
    return (((((radius * radius) * radius) * unsafe { g_PI.clone() }) * 2.0) / 3.0)
};
        fn vol_circular_cylinder(mut radius: f64, mut height: f64) -> f64 {
    if ((height < 0.0) || (radius < 0.0)) {
        panic!("vol_circular_cylinder() only accepts non-negative values");
    }
    return (((radius * radius) * height) * unsafe { g_PI.clone() })
};
        fn vol_hollow_circular_cylinder(mut inner_radius: f64, mut outer_radius: f64, mut height: f64) -> f64 {
    if (((inner_radius < 0.0) || (outer_radius < 0.0)) || (height < 0.0)) {
        panic!("vol_hollow_circular_cylinder() only accepts non-negative values");
    }
    if (outer_radius <= inner_radius) {
        panic!("outer_radius must be greater than inner_radius");
    }
    return ((unsafe { g_PI.clone() } * ((outer_radius * outer_radius) - (inner_radius * inner_radius))) * height)
};
        fn vol_conical_frustum(mut height: f64, mut radius_1: f64, mut radius_2: f64) -> f64 {
    if (((radius_1 < 0.0) || (radius_2 < 0.0)) || (height < 0.0)) {
        panic!("vol_conical_frustum() only accepts non-negative values");
    }
    return ((((1.0 / 3.0) * unsafe { g_PI.clone() }) * height) * (((radius_1 * radius_1) + (radius_2 * radius_2)) + (radius_1 * radius_2)))
};
        fn vol_torus(mut torus_radius: f64, mut tube_radius: f64) -> f64 {
    if ((torus_radius < 0.0) || (tube_radius < 0.0)) {
        panic!("vol_torus() only accepts non-negative values");
    }
    return (((((2.0 * unsafe { g_PI.clone() }) * unsafe { g_PI.clone() }) * torus_radius) * tube_radius) * tube_radius)
};
        fn vol_icosahedron(mut tri_side: f64) -> f64 {
    if (tri_side < 0.0) {
        panic!("vol_icosahedron() only accepts non-negative values");
    }
    return (((((tri_side * tri_side) * tri_side) * (3.0 + unsafe { g_SQRT5.clone() })) * 5.0) / 12.0)
};
        fn mochi_main() {
    println!("{}", "Volumes:");
    println!("{}", format!("{}{}", "Cube: ", vol_cube(2.0).to_string()));
    println!("{}", format!("{}{}", "Cuboid: ", vol_cuboid(2.0, 2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Cone: ", vol_cone(2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Right Circular Cone: ", vol_right_circ_cone(2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Prism: ", vol_prism(2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Pyramid: ", vol_pyramid(2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Sphere: ", vol_sphere(2.0).to_string()));
    println!("{}", format!("{}{}", "Hemisphere: ", vol_hemisphere(2.0).to_string()));
    println!("{}", format!("{}{}", "Circular Cylinder: ", vol_circular_cylinder(2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Torus: ", vol_torus(2.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Conical Frustum: ", vol_conical_frustum(2.0, 2.0, 4.0).to_string()));
    println!("{}", format!("{}{}", "Spherical cap: ", vol_spherical_cap(1.0, 2.0).to_string()));
    println!("{}", format!("{}{}", "Spheres intersection: ", vol_spheres_intersect(2.0, 2.0, 1.0).to_string()));
    println!("{}", format!("{}{}", "Spheres union: ", vol_spheres_union(2.0, 2.0, 1.0).to_string()));
    println!("{}", format!("{}{}", "Hollow Circular Cylinder: ", vol_hollow_circular_cylinder(1.0, 2.0, 3.0).to_string()));
    println!("{}", format!("{}{}", "Icosahedron: ", vol_icosahedron(2.5).to_string()));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
