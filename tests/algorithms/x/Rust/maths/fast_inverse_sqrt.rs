// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn pow2_int(mut n: i64) -> i64 {
    let mut result: i64 = 1;
    let mut i: i64 = 0;
    while (i < n) {
        result = (result * 2);
        i = (i + 1);
    }
    return result
};
    fn pow2_float(mut n: i64) -> f64 {
    let mut result: f64 = 1.0;
    if (n >= 0) {
        let mut i: i64 = 0;
        while (i < n) {
            result = (result * 2.0);
            i = (i + 1);
        }
    } else {
        let mut i: i64 = 0;
        let m: i64 = (0 - n);
        while (i < m) {
            result = (result / 2.0);
            i = (i + 1);
        }
    }
    return result
};
    fn lshift(mut num: i64, mut k: i64) -> i64 {
    let mut result: i64 = num;
    let mut i: i64 = 0;
    while (i < k) {
        result = (result * 2);
        i = (i + 1);
    }
    return result
};
    fn rshift(mut num: i64, mut k: i64) -> i64 {
    let mut result: i64 = num;
    let mut i: i64 = 0;
    while (i < k) {
        result = ((result - (result % 2)) / 2);
        i = (i + 1);
    }
    return result
};
    fn log2_floor(mut x: f64) -> i64 {
    let mut n: f64 = x;
    let mut e: i64 = 0;
    while (n >= 2.0) {
        n = (n / 2.0);
        e = (e + 1);
    }
    while (n < 1.0) {
        n = (n * 2.0);
        e = (e - 1);
    }
    return e
};
    fn float_to_bits(mut x: f64) -> i64 {
    let mut num: f64 = x;
    let mut sign: i64 = 0;
    if (num < 0.0) {
        sign = 1;
        num = -num;
    }
    let exp: i64 = log2_floor(num);
    let pow: f64 = pow2_float(exp);
    let normalized: f64 = (num / pow);
    let frac: f64 = (normalized - 1.0);
    let mantissa: i64 = ((frac * pow2_float(23)) as i64);
    let exp_bits: i64 = (exp + 127);
    return ((lshift(sign, 31) + lshift(exp_bits, 23)) + mantissa)
};
    fn bits_to_float(mut bits: i64) -> f64 {
    let sign_bit: i64 = (rshift(bits, 31) % 2);
    let mut sign: f64 = 1.0;
    if (sign_bit == 1) {
        sign = -1.0;
    }
    let exp_bits: i64 = (rshift(bits, 23) % 256);
    let exp: i64 = (exp_bits - 127);
    let mantissa_bits: i64 = (bits % pow2_int(23));
    let mantissa: f64 = (1.0 + ((mantissa_bits as f64) / pow2_float(23)));
    return ((sign * mantissa) * pow2_float(exp))
};
    fn absf(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
};
    fn sqrtApprox(mut x: f64) -> f64 {
    if (x <= 0.0) {
        return 0.0
    }
    let mut guess: f64 = (x / 2.0);
    let mut i: i64 = 0;
    while (i < 20) {
        guess = ((guess + (x / guess)) / 2.0);
        i = (i + 1);
    }
    return guess
};
    fn is_close(mut a: f64, mut b: f64, mut rel_tol: f64) -> bool {
    return (absf((a - b)) <= (rel_tol * absf(b)))
};
    fn fast_inverse_sqrt(mut number: f64) -> f64 {
    if (number <= 0.0) {
        panic!("Input must be a positive number.");
    }
    let i: i64 = float_to_bits(number);
    let magic: i64 = 1597463007;
    let y_bits: i64 = (magic - rshift(i, 1));
    let mut y: f64 = bits_to_float(y_bits);
    y = (y * (1.5 - (((0.5 * number) * y) * y)));
    return y
};
    fn test_fast_inverse_sqrt() {
    if (absf((fast_inverse_sqrt(10.0) - 0.3156857923527257)) > 0.0001) {
        panic!("fast_inverse_sqrt(10) failed");
    }
    if (absf((fast_inverse_sqrt(4.0) - 0.49915357479239103)) > 0.0001) {
        panic!("fast_inverse_sqrt(4) failed");
    }
    if (absf((fast_inverse_sqrt(4.1) - 0.4932849504615651)) > 0.0001) {
        panic!("fast_inverse_sqrt(4.1) failed");
    }
    let mut i: i64 = 50;
    while (i < 60) {
        let y: f64 = fast_inverse_sqrt((i as f64));
        let actual: f64 = (1.0 / sqrtApprox((i as f64)));
        if !is_close(y, actual, 0.00132) {
            panic!("relative error too high");
        }
        i = (i + 1);
    }
};
    fn mochi_main() {
    test_fast_inverse_sqrt();
    let mut i: i64 = 5;
    while (i <= 100) {
        let diff: f64 = ((1.0 / sqrtApprox((i as f64))) - fast_inverse_sqrt((i as f64)));
        println!("{}", format!("{}{}", format!("{}{}", i.to_string(), ": "), diff.to_string()));
        i = (i + 5);
    }
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
