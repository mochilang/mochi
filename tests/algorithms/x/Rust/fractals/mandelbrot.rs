// Generated by Mochi transpiler v0.10.65
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct RGB {
    r: i64,
    g: i64,
    b: i64,
}
impl std::fmt::Display for RGB {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"r\": {}", self.r)?;
        write!(f, ", ")?;
        write!(f, "\"g\": {}", self.g)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn round_int(mut x: f64) -> i64 {
    return ((x + 0.5) as i64)
};
    fn hsv_to_rgb(mut h: f64, mut s: f64, mut v: f64) -> RGB {
    let i: i64 = ((h * 6.0) as i64);
    let f: f64 = ((h * 6.0) - (i as f64));
    let p: f64 = (v * (1.0 - s));
    let q: f64 = (v * (1.0 - (f * s)));
    let t: f64 = (v * (1.0 - ((1.0 - f) * s)));
    let r#mod: i64 = (i % 6);
    let mut r: f64 = 0.0;
    let mut g: f64 = 0.0;
    let mut b: f64 = 0.0;
    if (r#mod == 0) {
        r = v;
        g = t;
        b = p;
    } else if (r#mod == 1) {
        r = q;
        g = v;
        b = p;
    } else if (r#mod == 2) {
        r = p;
        g = v;
        b = t;
    } else if (r#mod == 3) {
        r = p;
        g = q;
        b = v;
    } else if (r#mod == 4) {
        r = t;
        g = p;
        b = v;
    } else {
        r = v;
        g = p;
        b = q;
    }
    return RGB {r: round_int((r * 255.0)), g: round_int((g * 255.0)), b: round_int((b * 255.0))}
};
    fn get_distance(mut x: f64, mut y: f64, mut max_step: i64) -> f64 {
    let mut a: f64 = x;
    let mut b: f64 = y;
    let mut step: i64 = -1;
    while (step < (max_step - 1)) {
        step = (step + 1);
        let a_new: f64 = (((a * a) - (b * b)) + x);
        b = (((2.0 * a) * b) + y);
        a = a_new;
        if (((a * a) + (b * b)) > 4.0) {
            break
        }
    }
    return ((step as f64) / ((max_step - 1) as f64))
};
    fn get_black_and_white_rgb(mut distance: f64) -> RGB {
    if (distance == 1.0) {
        return RGB {r: 0, g: 0, b: 0}
    } else {
        return RGB {r: 255, g: 255, b: 255}
    }
};
    fn get_color_coded_rgb(mut distance: f64) -> RGB {
    if (distance == 1.0) {
        return RGB {r: 0, g: 0, b: 0}
    } else {
        return hsv_to_rgb(distance, 1.0, 1.0)
    }
};
    fn get_image(mut image_width: i64, mut image_height: i64, mut figure_center_x: f64, mut figure_center_y: f64, mut figure_width: f64, mut max_step: i64, mut use_distance_color_coding: bool) -> Vec<Vec<RGB>> {
    let mut img: Vec<Vec<RGB>> = vec![];
    let figure_height: f64 = ((figure_width / (image_width as f64)) * (image_height as f64));
    let mut image_y: i64 = 0;
    while (image_y < image_height) {
        let mut row: Vec<RGB> = vec![];
        let mut image_x: i64 = 0;
        while (image_x < image_width) {
            let fx: f64 = (figure_center_x + ((((image_x as f64) / (image_width as f64)) - 0.5) * figure_width));
            let fy: f64 = (figure_center_y + ((((image_y as f64) / (image_height as f64)) - 0.5) * figure_height));
            let distance: f64 = get_distance(fx, fy, max_step);
            let mut rgb: RGB = Default::default();
            if use_distance_color_coding {
                rgb = get_color_coded_rgb(distance);
            } else {
                rgb = get_black_and_white_rgb(distance);
            }
            row = { let mut _v = row.clone(); _v.push(rgb.clone()); _v };
            image_x = (image_x + 1);
        }
        img = { let mut _v = img.clone(); _v.push(row.clone()); _v };
        image_y = (image_y + 1);
    }
    return img
};
    fn rgb_to_string(mut c: RGB) -> String {
    return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "(", c.r.to_string()), ", "), c.g.to_string()), ", "), c.b.to_string()), ")").clone()
};
    let img1: Vec<Vec<RGB>> = get_image(10, 10, -0.6, 0.0, 3.2, 50, true);
    println!("{}", rgb_to_string(img1[0 as usize].clone()[0 as usize].clone()));
    let img2: Vec<Vec<RGB>> = get_image(10, 10, -0.6, 0.0, 3.2, 50, false);
    println!("{}", rgb_to_string(img2[0 as usize].clone()[0 as usize].clone()));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
