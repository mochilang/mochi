// Generated by Mochi transpiler v0.10.65
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn dfs(mut g: HashMap<i64, Vec<i64>>, mut s: i64) {
    let mut visited: HashMap<i64, bool> = HashMap::new();
    let mut stack: Vec<i64> = vec![];
    visited.insert(s.clone(), true);
    stack = { let mut _v = stack.clone(); _v.push(s); _v };
    println!("{}", s);
    while ((stack.len() as i64) > 0) {
        let u: i64 = stack[((stack.len() as i64) - 1) as usize];
        let mut found: bool = false;
        for v in g.get(&u).cloned().unwrap_or_default().iter().cloned() {
            if !visited.contains_key(&v) {
                visited.insert(v.clone(), true);
                stack = { let mut _v = stack.clone(); _v.push(v); _v };
                println!("{}", v);
                found = true;
                break
            }
        }
        if !found {
            stack = stack[0 as usize..((stack.len() as i64) - 1) as usize].to_vec();
        }
    }
};
    fn bfs(mut g: HashMap<i64, Vec<i64>>, mut s: i64) {
    let mut visited: HashMap<i64, bool> = HashMap::new();
    let mut q: Vec<i64> = vec![];
    visited.insert(s.clone(), true);
    q = { let mut _v = q.clone(); _v.push(s); _v };
    println!("{}", s);
    while ((q.len() as i64) > 0) {
        let u: i64 = q[0 as usize];
        q = q[1 as usize..(q.len() as i64) as usize].to_vec();
        for v in g.get(&u).cloned().unwrap_or_default().iter().cloned() {
            if !visited.contains_key(&v) {
                visited.insert(v.clone(), true);
                q = { let mut _v = q.clone(); _v.push(v); _v };
                println!("{}", v);
            }
        }
    }
};
    fn sort_ints(mut a: Vec<i64>) -> Vec<i64> {
    let mut arr: Vec<i64> = a.clone();
    let mut i: i64 = 0;
    while (i < (arr.len() as i64)) {
        let mut j: i64 = 0;
        while (j < (((arr.len() as i64) - i) - 1)) {
            if (arr[j as usize] > arr[(j + 1) as usize]) {
                let tmp: i64 = arr[j as usize];
                arr[j as usize] = arr[(j + 1) as usize];
                arr[(j + 1) as usize] = tmp;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return arr
};
    fn dijkstra(mut g: HashMap<i64, Vec<Vec<i64>>>, mut s: i64) {
    let mut dist: HashMap<i64, i64> = HashMap::new();
    dist.insert(s.clone(), 0);
    let mut path: HashMap<i64, i64> = HashMap::new();
    path.insert(s.clone(), 0);
    let mut known: Vec<i64> = vec![];
    let mut keys: Vec<i64> = vec![s];
    while ((known.len() as i64) < (keys.len() as i64)) {
        let mut mini: i64 = 100000;
        let mut u: i64 = -1;
        let mut i: i64 = 0;
        while (i < (keys.len() as i64)) {
            let k: i64 = keys[i as usize];
            let d: i64 = dist.get(&k).cloned().unwrap_or_default();
            if (!known.contains(&k) && (d < mini)) {
                mini = d;
                u = k;
            }
            i = (i + 1);
        }
        known = { let mut _v = known.clone(); _v.push(u); _v };
        for e in g.get(&u).cloned().unwrap_or_default().iter() {
            let v: i64 = (*e).clone()[0 as usize];
            let w: i64 = (*e).clone()[1 as usize];
            if !keys.contains(&v) {
                keys = { let mut _v = keys.clone(); _v.push(v); _v };
            }
            let alt: i64 = (dist.get(&u).cloned().unwrap_or_default() + w);
            let cur: i64 = if dist.contains_key(&v) { dist.get(&v).cloned().unwrap_or_default() } else { 100000 };
            if (!known.contains(&v) && (alt < cur)) {
                dist.insert(v.clone(), alt.clone());
                path.insert(v.clone(), u.clone());
            }
        }
    }
    let ordered: Vec<i64> = sort_ints(keys.clone());
    let mut idx: i64 = 0;
    while (idx < (ordered.len() as i64)) {
        let k: i64 = ordered[idx as usize];
        if (k != s) {
            println!("{}", dist.get(&k).cloned().unwrap_or_default());
        }
        idx = (idx + 1);
    }
};
    fn topo(mut g: HashMap<i64, Vec<i64>>, mut n: i64) {
    let mut ind: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i <= n) {
        ind = { let mut _v = ind.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut node: i64 = 1;
    while (node <= n) {
        for v in g.get(&node).cloned().unwrap_or_default().iter().cloned() {
            ind[v as usize] = (ind[v as usize] + 1);
        }
        node = (node + 1);
    }
    let mut q: Vec<i64> = vec![];
    let mut j: i64 = 1;
    while (j <= n) {
        if (ind[j as usize] == 0) {
            q = { let mut _v = q.clone(); _v.push(j); _v };
        }
        j = (j + 1);
    }
    while ((q.len() as i64) > 0) {
        let v: i64 = q[0 as usize];
        q = q[1 as usize..(q.len() as i64) as usize].to_vec();
        println!("{}", v);
        for w in g.get(&v).cloned().unwrap_or_default().iter().cloned() {
            ind[w as usize] = (ind[w as usize] - 1);
            if (ind[w as usize] == 0) {
                q = { let mut _v = q.clone(); _v.push(w); _v };
            }
        }
    }
};
    fn floyd(mut a: Vec<Vec<i64>>) {
    let n: i64 = (a.len() as i64);
    let mut dist: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            row = { let mut _v = row.clone(); _v.push(a[i as usize].clone()[j as usize]); _v };
            j = (j + 1);
        }
        dist = { let mut _v = dist.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    let mut k: i64 = 0;
    while (k < n) {
        let mut ii: i64 = 0;
        while (ii < n) {
            let mut jj: i64 = 0;
            while (jj < n) {
                if (dist[ii as usize].clone()[jj as usize] > (dist[ii as usize].clone()[k as usize] + dist[k as usize].clone()[jj as usize])) {
                    dist[ii as usize][jj as usize] = (dist[ii as usize].clone()[k as usize] + dist[k as usize].clone()[jj as usize]);
                }
                jj = (jj + 1);
            }
            ii = (ii + 1);
        }
        k = (k + 1);
    }
    println!("{:?}", format!("{:?}", dist));
};
    fn prim(mut g: HashMap<i64, Vec<Vec<i64>>>, mut s: i64, mut n: i64) -> i64 {
    let mut dist: HashMap<i64, i64> = HashMap::new();
    dist.insert(s.clone(), 0);
    let mut known: Vec<i64> = vec![];
    let mut keys: Vec<i64> = vec![s];
    let mut total: i64 = 0;
    while ((known.len() as i64) < n) {
        let mut mini: i64 = 100000;
        let mut u: i64 = -1;
        let mut i: i64 = 0;
        while (i < (keys.len() as i64)) {
            let k: i64 = keys[i as usize];
            let d: i64 = dist.get(&k).cloned().unwrap_or_default();
            if (!known.contains(&k) && (d < mini)) {
                mini = d;
                u = k;
            }
            i = (i + 1);
        }
        known = { let mut _v = known.clone(); _v.push(u); _v };
        total = (total + mini);
        for e in g.get(&u).cloned().unwrap_or_default().iter() {
            let v: i64 = (*e).clone()[0 as usize];
            let w: i64 = (*e).clone()[1 as usize];
            if !keys.contains(&v) {
                keys = { let mut _v = keys.clone(); _v.push(v); _v };
            }
            let cur: i64 = if dist.contains_key(&v) { dist.get(&v).cloned().unwrap_or_default() } else { 100000 };
            if (!known.contains(&v) && (w < cur)) {
                dist.insert(v.clone(), w.clone());
            }
        }
    }
    return total
};
    fn sort_edges(mut edges: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut es: Vec<Vec<i64>> = edges.clone();
    let mut i: i64 = 0;
    while (i < (es.len() as i64)) {
        let mut j: i64 = 0;
        while (j < (((es.len() as i64) - i) - 1)) {
            if (es[j as usize].clone()[2 as usize] > es[(j + 1) as usize].clone()[2 as usize]) {
                let tmp: Vec<i64> = es[j as usize].clone();
                es[j as usize] = es[(j + 1) as usize].clone();
                es[(j + 1) as usize] = tmp.clone();
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return es
};
    fn find_parent(mut parent: Vec<i64>, mut x: i64) -> i64 {
    let mut r: i64 = x;
    while (parent[r as usize] != r) {
        r = parent[r as usize];
    }
    return r
};
    fn union_parent(parent: &mut Vec<i64>, mut a: i64, mut b: i64) {
    (*parent)[a as usize] = b;
};
    fn kruskal(mut edges: Vec<Vec<i64>>, mut n: i64) -> i64 {
    let mut es: Vec<Vec<i64>> = sort_edges(edges.clone());
    let mut parent: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i <= n) {
        parent = { let mut _v = parent.clone(); _v.push(i); _v };
        i = (i + 1);
    }
    let mut total: i64 = 0;
    let mut count: i64 = 0;
    let mut idx: i64 = 0;
    while ((count < (n - 1)) && (idx < (es.len() as i64))) {
        let e: Vec<i64> = es[idx as usize].clone();
        idx = (idx + 1);
        let u: i64 = e[0 as usize];
        let v: i64 = e[1 as usize];
        let w: i64 = e[2 as usize];
        let ru: i64 = find_parent(parent.clone(), u);
        let rv: i64 = find_parent(parent.clone(), v);
        if (ru != rv) {
            union_parent(&mut parent, ru, rv);
            total = (total + w);
            count = (count + 1);
        }
    }
    return total
};
    fn find_isolated_nodes(mut g: HashMap<i64, Vec<i64>>, mut nodes: Vec<i64>) -> Vec<i64> {
    let mut isolated: Vec<i64> = vec![];
    for node in nodes.iter().cloned() {
        if ((g.get(&node).cloned().unwrap_or_default().len() as i64) == 0) {
            isolated = { let mut _v = isolated.clone(); _v.push(node); _v };
        }
    }
    return isolated
};
    let g_dfs: HashMap<i64, Vec<i64>> = HashMap::from([(1, vec![2, 3]), (2, vec![4, 5]), (3, vec![]), (4, vec![]), (5, vec![])]);
    let g_bfs: HashMap<i64, Vec<i64>> = HashMap::from([(1, vec![2, 3]), (2, vec![4, 5]), (3, vec![6, 7]), (4, vec![]), (5, vec![8]), (6, vec![]), (7, vec![]), (8, vec![])]);
    let g_weighted: HashMap<i64, Vec<Vec<i64>>> = HashMap::from([(1, vec![vec![2, 7].clone(), vec![3, 9].clone(), vec![6, 14].clone()]), (2, vec![vec![1, 7].clone(), vec![3, 10].clone(), vec![4, 15].clone()]), (3, vec![vec![1, 9].clone(), vec![2, 10].clone(), vec![4, 11].clone(), vec![6, 2].clone()]), (4, vec![vec![2, 15].clone(), vec![3, 11].clone(), vec![5, 6].clone()]), (5, vec![vec![4, 6].clone(), vec![6, 9].clone()]), (6, vec![vec![1, 14].clone(), vec![3, 2].clone(), vec![5, 9].clone()])]);
    let g_topo: HashMap<i64, Vec<i64>> = HashMap::from([(1, vec![2, 3]), (2, vec![4]), (3, vec![4]), (4, vec![])]);
    let matrix: Vec<Vec<i64>> = vec![vec![0, 5, 9, 100000].clone(), vec![100000, 0, 2, 8].clone(), vec![100000, 100000, 0, 7].clone(), vec![4, 100000, 100000, 0].clone()];
    let g_prim: HashMap<i64, Vec<Vec<i64>>> = HashMap::from([(1, vec![vec![2, 1].clone(), vec![3, 3].clone()]), (2, vec![vec![1, 1].clone(), vec![3, 1].clone(), vec![4, 6].clone()]), (3, vec![vec![1, 3].clone(), vec![2, 1].clone(), vec![4, 2].clone()]), (4, vec![vec![2, 6].clone(), vec![3, 2].clone()])]);
    let edges_kruskal: Vec<Vec<i64>> = vec![vec![1, 2, 1].clone(), vec![2, 3, 2].clone(), vec![1, 3, 2].clone(), vec![3, 4, 1].clone()];
    let g_iso: HashMap<i64, Vec<i64>> = HashMap::from([(1, vec![2, 3]), (2, vec![1, 3]), (3, vec![1, 2]), (4, vec![])]);
    dfs(g_dfs.clone(), 1);
    bfs(g_bfs.clone(), 1);
    dijkstra(g_weighted.clone(), 1);
    topo(g_topo.clone(), 4);
    floyd(matrix.clone());
    println!("{}", prim(g_prim.clone(), 1, 4));
    println!("{}", kruskal(edges_kruskal.clone(), 4));
    let iso: Vec<i64> = find_isolated_nodes(g_iso.clone(), vec![1, 2, 3, 4]);
    println!("{:?}", format!("{:?}", iso));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
