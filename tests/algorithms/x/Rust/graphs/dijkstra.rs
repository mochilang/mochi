// Generated by Mochi transpiler v0.10.73
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct NodeCost {
    node: String,
    cost: i64,
}
impl std::fmt::Display for NodeCost {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"node\": \"{}\"", self.node)?;
        write!(f, ", ")?;
        write!(f, "\"cost\": {}", self.cost)?;
        write!(f, "}}")
    }
}

static mut g_result: i64 = -1;
static mut g_result2: i64 = -1;
static mut g_result3: i64 = -1;
fn main() {
    unsafe {
        g_result = -1;
        g_result2 = -1;
        g_result3 = -1;
                let _start: i64 = _now();;
        let G: HashMap<String, HashMap<String, i64>> = HashMap::from([(String::from("A"), HashMap::from([(String::from("B"), 2), (String::from("C"), 5)])), (String::from("B"), HashMap::from([(String::from("A"), 2), (String::from("D"), 3), (String::from("E"), 1), (String::from("F"), 1)])), (String::from("C"), HashMap::from([(String::from("A"), 5), (String::from("F"), 3)])), (String::from("D"), HashMap::from([(String::from("B"), 3)])), (String::from("E"), HashMap::from([(String::from("B"), 4), (String::from("F"), 3)])), (String::from("F"), HashMap::from([(String::from("C"), 3), (String::from("E"), 3)]))]);;
        let mut heap: Vec<NodeCost> = vec![NodeCost {node: String::from("E"), cost: 0}.clone()];;
        let mut visited: HashMap<String, bool> = HashMap::new();;
        while ((heap.len() as i64) > 0) {
            let mut best_idx: i64 = 0;;
            let mut i: i64 = 1;;
            while (i < (heap.len() as i64)) {
                if (heap[i as usize].clone().cost < heap[best_idx as usize].clone().cost) {
                    best_idx = i;
                }
                i = (i + 1);
            }
            let best: NodeCost = heap[best_idx as usize].clone();;
            let mut new_heap: Vec<NodeCost> = vec![];;
            let mut j: i64 = 0;;
            while (j < (heap.len() as i64)) {
                if (j != best_idx) {
                    new_heap = { let mut _v = new_heap.clone(); _v.push(heap[j as usize].clone()); _v };
                }
                j = (j + 1);
            }
            heap = new_heap.clone();
            let u: String = best.node.clone().clone();;
            let cost: i64 = best.cost;;
            if visited.contains_key(&u) {
                continue
            }
            visited.insert(u.clone(), true);;
            if (u.as_str() == "C") {
                unsafe { g_result = cost };
                break
            }
            for v in G.get(u.as_str()).cloned().unwrap_or_default().keys().cloned() {
                if visited.contains_key(&v) {
                    continue
                }
                let next_cost: i64 = (cost + G.get(u.as_str()).cloned().unwrap_or_default()[v.as_str()]);;
                heap = { let mut _v = heap.clone(); _v.push(NodeCost {node: v.clone(), cost: next_cost}); _v };
            }
        }
        println!("{}", unsafe { g_result.clone() });;
        let G2: HashMap<String, HashMap<String, i64>> = HashMap::from([(String::from("B"), HashMap::from([(String::from("C"), 1)])), (String::from("C"), HashMap::from([(String::from("D"), 1)])), (String::from("D"), HashMap::from([(String::from("F"), 1)])), (String::from("E"), HashMap::from([(String::from("B"), 1), (String::from("F"), 3)])), (String::from("F"), HashMap::new())]);;
        let mut heap2: Vec<NodeCost> = vec![NodeCost {node: String::from("E"), cost: 0}.clone()];;
        let mut visited2: HashMap<String, bool> = HashMap::new();;
        while ((heap2.len() as i64) > 0) {
            let mut best2_idx: i64 = 0;;
            let mut i2: i64 = 1;;
            while (i2 < (heap2.len() as i64)) {
                if (heap2[i2 as usize].clone().cost < heap2[best2_idx as usize].clone().cost) {
                    best2_idx = i2;
                }
                i2 = (i2 + 1);
            }
            let best2: NodeCost = heap2[best2_idx as usize].clone();;
            let mut new_heap2: Vec<NodeCost> = vec![];;
            let mut j2: i64 = 0;;
            while (j2 < (heap2.len() as i64)) {
                if (j2 != best2_idx) {
                    new_heap2 = { let mut _v = new_heap2.clone(); _v.push(heap2[j2 as usize].clone()); _v };
                }
                j2 = (j2 + 1);
            }
            heap2 = new_heap2.clone();
            let u2: String = best2.node.clone().clone();;
            let cost2: i64 = best2.cost;;
            if visited2.contains_key(&u2) {
                continue
            }
            visited2.insert(u2.clone(), true);;
            if (u2.as_str() == "F") {
                unsafe { g_result2 = cost2 };
                break
            }
            for v2 in G2.get(u2.as_str()).cloned().unwrap_or_default().keys().cloned() {
                if visited2.contains_key(&v2) {
                    continue
                }
                let next_cost2: i64 = (cost2 + G2.get(u2.as_str()).cloned().unwrap_or_default()[v2.as_str()]);;
                heap2 = { let mut _v = heap2.clone(); _v.push(NodeCost {node: v2.clone(), cost: next_cost2}); _v };
            }
        }
        println!("{}", unsafe { g_result2.clone() });;
        let G3: HashMap<String, HashMap<String, i64>> = HashMap::from([(String::from("B"), HashMap::from([(String::from("C"), 1)])), (String::from("C"), HashMap::from([(String::from("D"), 1)])), (String::from("D"), HashMap::from([(String::from("F"), 1)])), (String::from("E"), HashMap::from([(String::from("B"), 1), (String::from("G"), 2)])), (String::from("F"), HashMap::new()), (String::from("G"), HashMap::from([(String::from("F"), 1)]))]);;
        let mut heap3: Vec<NodeCost> = vec![NodeCost {node: String::from("E"), cost: 0}.clone()];;
        let mut visited3: HashMap<String, bool> = HashMap::new();;
        while ((heap3.len() as i64) > 0) {
            let mut best3_idx: i64 = 0;;
            let mut i3: i64 = 1;;
            while (i3 < (heap3.len() as i64)) {
                if (heap3[i3 as usize].clone().cost < heap3[best3_idx as usize].clone().cost) {
                    best3_idx = i3;
                }
                i3 = (i3 + 1);
            }
            let best3: NodeCost = heap3[best3_idx as usize].clone();;
            let mut new_heap3: Vec<NodeCost> = vec![];;
            let mut j3: i64 = 0;;
            while (j3 < (heap3.len() as i64)) {
                if (j3 != best3_idx) {
                    new_heap3 = { let mut _v = new_heap3.clone(); _v.push(heap3[j3 as usize].clone()); _v };
                }
                j3 = (j3 + 1);
            }
            heap3 = new_heap3.clone();
            let u3: String = best3.node.clone().clone();;
            let cost3: i64 = best3.cost;;
            if visited3.contains_key(&u3) {
                continue
            }
            visited3.insert(u3.clone(), true);;
            if (u3.as_str() == "F") {
                unsafe { g_result3 = cost3 };
                break
            }
            for v3 in G3.get(u3.as_str()).cloned().unwrap_or_default().keys().cloned() {
                if visited3.contains_key(&v3) {
                    continue
                }
                let next_cost3: i64 = (cost3 + G3.get(u3.as_str()).cloned().unwrap_or_default()[v3.as_str()]);;
                heap3 = { let mut _v = heap3.clone(); _v.push(NodeCost {node: v3.clone(), cost: next_cost3}); _v };
            }
        }
        println!("{}", unsafe { g_result3.clone() });;
        let _end: i64 = _now();;
        let duration_us: i64 = ((_end - _start) / 1000);;
        let memory_bytes: i64 = _mem();;
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
