// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct NodesData {
    map: HashMap<String, Vec<String>>,
    keys: Vec<String>,
}
impl std::fmt::Display for NodesData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"map\": {:?}", self.map)?;
        write!(f, ", ")?;
        write!(f, "\"keys\": {:?}", self.keys)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct ClusterData {
    clusters: HashMap<i64, Vec<String>>,
    weights: Vec<i64>,
}
impl std::fmt::Display for ClusterData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"clusters\": {:?}", self.clusters)?;
        write!(f, ", ")?;
        write!(f, "\"weights\": {:?}", self.weights)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct GraphData {
    edges: HashMap<String, Vec<String>>,
    keys: Vec<String>,
}
impl std::fmt::Display for GraphData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"edges\": {:?}", self.edges)?;
        write!(f, ", ")?;
        write!(f, "\"keys\": {:?}", self.keys)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    let EDGE_ARRAY: Vec<Vec<Vec<String>>> = vec![vec![vec![String::from("ab").clone(), String::from("e1").clone()].clone(), vec![String::from("ac").clone(), String::from("e3").clone()].clone(), vec![String::from("ad").clone(), String::from("e5").clone()].clone(), vec![String::from("bc").clone(), String::from("e4").clone()].clone(), vec![String::from("bd").clone(), String::from("e2").clone()].clone(), vec![String::from("be").clone(), String::from("e6").clone()].clone(), vec![String::from("bh").clone(), String::from("e12").clone()].clone(), vec![String::from("cd").clone(), String::from("e2").clone()].clone(), vec![String::from("ce").clone(), String::from("e4").clone()].clone(), vec![String::from("de").clone(), String::from("e1").clone()].clone(), vec![String::from("df").clone(), String::from("e8").clone()].clone(), vec![String::from("dg").clone(), String::from("e5").clone()].clone(), vec![String::from("dh").clone(), String::from("e10").clone()].clone(), vec![String::from("ef").clone(), String::from("e3").clone()].clone(), vec![String::from("eg").clone(), String::from("e2").clone()].clone(), vec![String::from("fg").clone(), String::from("e6").clone()].clone(), vec![String::from("gh").clone(), String::from("e6").clone()].clone(), vec![String::from("hi").clone(), String::from("e3").clone()].clone()].clone(), vec![vec![String::from("ab").clone(), String::from("e1").clone()].clone(), vec![String::from("ac").clone(), String::from("e3").clone()].clone(), vec![String::from("ad").clone(), String::from("e5").clone()].clone(), vec![String::from("bc").clone(), String::from("e4").clone()].clone(), vec![String::from("bd").clone(), String::from("e2").clone()].clone(), vec![String::from("be").clone(), String::from("e6").clone()].clone(), vec![String::from("cd").clone(), String::from("e2").clone()].clone(), vec![String::from("de").clone(), String::from("e1").clone()].clone(), vec![String::from("df").clone(), String::from("e8").clone()].clone(), vec![String::from("ef").clone(), String::from("e3").clone()].clone(), vec![String::from("eg").clone(), String::from("e2").clone()].clone(), vec![String::from("fg").clone(), String::from("e6").clone()].clone()].clone(), vec![vec![String::from("ab").clone(), String::from("e1").clone()].clone(), vec![String::from("ac").clone(), String::from("e3").clone()].clone(), vec![String::from("bc").clone(), String::from("e4").clone()].clone(), vec![String::from("bd").clone(), String::from("e2").clone()].clone(), vec![String::from("de").clone(), String::from("e1").clone()].clone(), vec![String::from("df").clone(), String::from("e8").clone()].clone(), vec![String::from("dg").clone(), String::from("e5").clone()].clone(), vec![String::from("ef").clone(), String::from("e3").clone()].clone(), vec![String::from("eg").clone(), String::from("e2").clone()].clone(), vec![String::from("eh").clone(), String::from("e12").clone()].clone(), vec![String::from("fg").clone(), String::from("e6").clone()].clone(), vec![String::from("fh").clone(), String::from("e10").clone()].clone(), vec![String::from("gh").clone(), String::from("e6").clone()].clone()].clone(), vec![vec![String::from("ab").clone(), String::from("e1").clone()].clone(), vec![String::from("ac").clone(), String::from("e3").clone()].clone(), vec![String::from("bc").clone(), String::from("e4").clone()].clone(), vec![String::from("bd").clone(), String::from("e2").clone()].clone(), vec![String::from("bh").clone(), String::from("e12").clone()].clone(), vec![String::from("cd").clone(), String::from("e2").clone()].clone(), vec![String::from("df").clone(), String::from("e8").clone()].clone(), vec![String::from("dh").clone(), String::from("e10").clone()].clone()].clone(), vec![vec![String::from("ab").clone(), String::from("e1").clone()].clone(), vec![String::from("ac").clone(), String::from("e3").clone()].clone(), vec![String::from("ad").clone(), String::from("e5").clone()].clone(), vec![String::from("bc").clone(), String::from("e4").clone()].clone(), vec![String::from("bd").clone(), String::from("e2").clone()].clone(), vec![String::from("cd").clone(), String::from("e2").clone()].clone(), vec![String::from("ce").clone(), String::from("e4").clone()].clone(), vec![String::from("de").clone(), String::from("e1").clone()].clone(), vec![String::from("df").clone(), String::from("e8").clone()].clone(), vec![String::from("dg").clone(), String::from("e5").clone()].clone(), vec![String::from("ef").clone(), String::from("e3").clone()].clone(), vec![String::from("eg").clone(), String::from("e2").clone()].clone(), vec![String::from("fg").clone(), String::from("e6").clone()].clone()].clone()];
    let mut contains = |lst: Vec<String>, item: String| -> bool {
    for v in lst.iter().cloned() {
        if (v.as_str() == item.as_str()) {
            return true
        }
    }
    return false
};
    let mut get_distinct_edge = |edge_array: Vec<Vec<Vec<String>>>| -> Vec<String> {
    let mut distinct: Vec<String> = vec![];
    for row in edge_array.iter() {
        for item in (*row).clone() {
            let e: i64 = item[0 as usize];
            if !distinct.contains(&e) {
                distinct = { let mut _v = distinct.clone(); _v.push(e.to_string()); _v };
            }
        }
    }
    return distinct
};
    let mut get_bitcode = |edge_array: Vec<Vec<Vec<String>>>, de: String| -> String {
    let mut bitcode: String = String::new();
    let mut i: i64 = 0;
    while (i < (edge_array.len() as i64)) {
        let mut found: bool = false;
        for item in edge_array[i as usize].clone().iter() {
            if ((*item).clone()[0 as usize] == de) {
                found = true;
                break
            }
        }
        if found {
            bitcode = format!("{}{}", bitcode, "1");
        } else {
            bitcode = format!("{}{}", bitcode, "0");
        }
        i = (i + 1);
    }
    return bitcode.clone()
};
    let mut count_ones = |s: String| -> i64 {
    let mut c: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.as_str() == "1") {
            c = (c + 1);
        }
        i = (i + 1);
    }
    return c
};
    let mut get_frequency_table = {
fn get_frequency_table(count_ones: &fn(String) -> i64, get_bitcode: &fn(Vec<Vec<Vec<String>>>, String) -> String, get_distinct_edge: &fn(Vec<Vec<Vec<String>>>) -> Vec<String>, edge_array: Vec<Vec<Vec<String>>>) -> Vec<HashMap<String, String>> {
    let distinct: Vec<String> = get_distinct_edge(edge_array);
    let mut table: Vec<HashMap<String, String>> = vec![];
    for e in distinct.iter().cloned() {
        let bit = get_bitcode(edge_array, e);
        let cnt = count_ones(bit);
        let mut entry: HashMap<String, String> = HashMap::from([(String::from("edge"), String::from(e.clone())), (String::from("count"), format!("{}", cnt.to_string())), (String::from("bit"), format!("{}", bit))]);
        table = { let mut _v = table.clone(); _v.push(entry.clone()); _v };
    }
    let mut i: i64 = 0;
    while (i < (table.len() as i64)) {
        let mut max_i: i64 = i;
        let mut j: i64 = (i + 1);
        while (j < (table.len() as i64)) {
            if (toi(table[j as usize].clone()["count"].clone().clone()) > toi(table[max_i as usize].clone()["count"].clone().clone())) {
                max_i = j;
            }
            j = (j + 1);
        }
        let tmp: HashMap<String, String> = table[i as usize].clone();
        table[i as usize] = table[max_i as usize].clone();
        table[max_i as usize] = tmp.clone();
        i = (i + 1);
    }
    return table
}
|edge_array: Vec<Vec<Vec<String>>>| -> Vec<HashMap<String, String>> { get_frequency_table(count_ones, get_bitcode, get_distinct_edge, edge_array) }
};
    let mut get_nodes = |freq_table: Vec<HashMap<String, String>>| -> NodesData {
    let mut nodes: HashMap<String, Vec<String>> = HashMap::new();
    let mut keys: Vec<String> = vec![];
    for f in freq_table.iter() {
        let code: i64 = (*f).clone()["bit" as usize];
        let edge: i64 = (*f).clone()["edge" as usize];
        if nodes.contains_key(&code) {
            nodes.insert(code.clone(), { let mut _v = nodes.get(&code).cloned().unwrap_or_default().clone(); _v.push(edge.to_string()); _v });
        } else {
            nodes.insert(code.clone(), vec![edge]);
            keys = { let mut _v = keys.clone(); _v.push(code.to_string()); _v };
        }
    }
    return NodesData {map: nodes.clone(), keys: keys.clone()}
};
    let mut get_cluster = {
fn get_cluster(count_ones: &fn(String) -> i64, nodes: NodesData) -> ClusterData {
    let mut clusters: HashMap<i64, Vec<String>> = HashMap::new();
    let mut weights: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (nodes.keys.clone().len() as i64)) {
        let code: String = nodes.keys.clone()[i as usize].clone().clone();
        let wt = count_ones(code);
        if clusters.contains_key(&wt) {
            clusters.insert(wt.clone(), { let mut _v = clusters.get(&wt).cloned().unwrap_or_default().clone(); _v.push(code.clone()); _v });
        } else {
            clusters.insert(wt.clone(), vec![code.clone()]);
            weights = { let mut _v = weights.clone(); _v.push(wt); _v };
        }
        i = (i + 1);
    }
    return ClusterData {clusters: clusters.clone(), weights: weights.clone()}
}
|nodes: NodesData| -> ClusterData { get_cluster(count_ones, nodes) }
};
    let mut get_support = |clusters: ClusterData| -> Vec<i64> {
    let mut sup: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (clusters.weights.clone().len() as i64)) {
        let w: i64 = clusters.weights.clone()[i as usize];
        sup = { let mut _v = sup.clone(); _v.push(((w * 100) / (clusters.weights.clone().len() as i64))); _v };
        i = (i + 1);
    }
    return sup
};
    let mut contains_bits = |a: String, b: String| -> bool {
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        let c1: String = { let tmp = &a; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        let c2: String = { let tmp = &b; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if ((c1.as_str() == "1") && (c2.as_str() != "1")) {
            return false
        }
        i = (i + 1);
    }
    return true
};
    let mut max_cluster_key = |clusters: ClusterData| -> i64 {
    let mut m: i64 = 0;
    let mut i: i64 = 0;
    while (i < (clusters.weights.clone().len() as i64)) {
        let w: i64 = clusters.weights.clone()[i as usize];
        if (w > m) {
            m = w;
        }
        i = (i + 1);
    }
    return m
};
    let mut get_cluster_codes = |clusters: ClusterData, wt: i64| -> Vec<String> {
    if clusters.clusters.clone().contains_key(&wt) {
        return clusters.clusters.clone()[&wt].clone().clone()
    }
    return vec![]
};
    let mut create_edge = {
fn create_edge(get_cluster_codes: &fn(ClusterData, i64) -> Vec<String>, nodes: NodesData, graph: &mut HashMap<String, Vec<String>>, gkeys: Vec<String>, clusters: ClusterData, c1: i64, maxk: i64) -> Vec<String> {
    let mut keys: Vec<String> = gkeys.clone();
    let codes1 = get_cluster_codes(clusters.clone(), c1);
    let mut idx1: i64 = 0;
    while (idx1 < (codes1.len() as i64)) {
        let i_code: i64 = codes1[idx1 as usize];
        let mut count: i64 = 0;
        let mut c2: i64 = (c1 + 1);
        while (c2 <= maxk) {
            let codes2 = get_cluster_codes(clusters.clone(), c2);
            let mut j: i64 = 0;
            while (j < (codes2.len() as i64)) {
                let j_code: i64 = codes2[j as usize];
                if true {
                    if graph.contains_key(&i_code) {
                        graph.insert(i_code.clone(), { let mut _v = graph.get(&i_code).cloned().unwrap_or_default().clone(); _v.push(j_code.to_string()); _v });
                    } else {
                        graph.insert(i_code.clone(), vec![j_code]);
                        if !keys.contains(&i_code) {
                            keys = { let mut _v = keys.clone(); _v.push(i_code.to_string()); _v };
                        }
                    }
                    if !keys.contains(&j_code) {
                        keys = { let mut _v = keys.clone(); _v.push(j_code.to_string()); _v };
                    }
                    count = (count + 1);
                }
                j = (j + 1);
            }
            if (count == 0) {
                c2 = (c2 + 1);
            } else {
                break
            }
        }
        idx1 = (idx1 + 1);
    }
    return keys
}
|nodes: NodesData, graph: &mut HashMap<String, Vec<String>>, gkeys: Vec<String>, clusters: ClusterData, c1: i64, maxk: i64| -> Vec<String> { create_edge(get_cluster_codes, nodes, graph, gkeys, clusters, c1, maxk) }
};
    let mut construct_graph = {
fn construct_graph(create_edge: &fn(NodesData, HashMap<String, Vec<String>>, Vec<String>, ClusterData, i64, i64) -> Vec<String>, get_cluster_codes: &fn(ClusterData, i64) -> Vec<String>, max_cluster_key: &fn(ClusterData) -> i64, clusters: ClusterData, nodes: NodesData) -> GraphData {
    let maxk = max_cluster_key(clusters.clone());
    let top_codes = get_cluster_codes(clusters.clone(), maxk);
    let mut graph: HashMap<String, Vec<String>> = HashMap::new();
    let mut keys: Vec<String> = vec![String::from("Header").clone()];
    graph.insert(String::from("Header"), vec![]);
    let mut i: i64 = 0;
    while (i < (top_codes.len() as i64)) {
        let code: i64 = top_codes[i as usize];
        graph.insert(String::from("Header"), { let mut _v = graph.get("Header").cloned().unwrap_or_default().clone(); _v.push(code.to_string()); _v });
        graph.insert(code.clone(), vec![String::from("Header").clone()]);
        keys = { let mut _v = keys.clone(); _v.push(code.to_string()); _v };
        i = (i + 1);
    }
    let mut c: i64 = 1;
    while (c < maxk) {
        keys = create_edge(nodes.clone(), graph, keys, clusters.clone(), c, maxk);
        c = (c + 1);
    }
    return GraphData {edges: graph.clone(), keys: keys.clone()}
}
|clusters: ClusterData, nodes: NodesData| -> GraphData { construct_graph(create_edge, get_cluster_codes, max_cluster_key, clusters, nodes) }
};
    let mut paths: Vec<Vec<String>> = vec![];
    let mut copy_list = |lst: Vec<String>| -> Vec<String> {
    let mut n: Vec<String> = vec![];
    for v in lst.iter().cloned() {
        n = { let mut _v = n.clone(); _v.push(v.clone()); _v };
    }
    return n
};
    let mut my_dfs = {
fn my_dfs(copy_list: &fn(Vec<String>) -> Vec<String>, graph: HashMap<String, Vec<String>>, start: String, end: String, path: Vec<String>) {
    let mut new_path = copy_list(path);
    new_path = { let mut _v = new_path.clone(); _v.push(start.clone()); _v };
    if (start.as_str() == end.as_str()) {
        paths = { let mut _v = paths.clone(); _v.push(new_path.clone()); _v };
        return
    }
    for node in graph.get(start.as_str()).cloned().unwrap_or_default().iter().cloned() {
        let mut seen: bool = false;
        for p in new_path.iter().cloned() {
            if (p.as_str() == node.as_str()) {
                seen = true;
            }
        }
        if !seen {
            my_dfs(copy_list, graph.clone(), node, end, new_path.clone());
        }
    }
}
|graph: HashMap<String, Vec<String>>, start: String, end: String, path: Vec<String>| { my_dfs(copy_list, graph, start, end, path) }
};
    let mut find_freq_subgraph_given_support = {
fn find_freq_subgraph_given_support(get_cluster_codes: &fn(ClusterData, i64) -> Vec<String>, my_dfs: &fn(HashMap<String, Vec<String>>, String, String, Vec<String>) -> i64, s: i64, clusters: ClusterData, graph: GraphData) {
    let k: i64 = ((s * (clusters.weights.clone().len() as i64)) / 100);
    let codes = get_cluster_codes(clusters.clone(), k);
    let mut i: i64 = 0;
    while (i < (codes.len() as i64)) {
        my_dfs(graph.edges.clone(), codes[i as usize], "Header", vec![]);
        i = (i + 1);
    }
}
|s: i64, clusters: ClusterData, graph: GraphData| { find_freq_subgraph_given_support(get_cluster_codes, my_dfs, s, clusters, graph) }
};
    let mut node_edges = |nodes: NodesData, code: String| -> Vec<String> {
    return nodes.map.clone()[code.as_str()].clone().clone()
};
    let mut freq_subgraphs_edge_list = {
fn freq_subgraphs_edge_list(node_edges: &fn(NodesData, String) -> Vec<String>, paths: Vec<Vec<String>>, nodes: NodesData) -> Vec<Vec<Vec<String>>> {
    let mut freq_sub_el: Vec<Vec<Vec<String>>> = vec![];
    for path in paths.iter() {
        let mut el: Vec<Vec<String>> = vec![];
        let mut j: i64 = 0;
        while (j < (((*path).clone().len() as i64) - 1)) {
            let code: i64 = (*path).clone()[j as usize];
            let edge_list = node_edges(nodes.clone(), code);
            let mut e: i64 = 0;
            while (e < (edge_list.len() as i64)) {
                let edge: i64 = edge_list[e as usize];
                let a: String = { let tmp = &edge; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone();
                let b: String = { let tmp = &edge; tmp.chars().skip(1 as usize).take((2 - 1) as usize).collect::<String>() }.clone();
                el = { let mut _v = el.clone(); _v.push(vec![a.clone(), b.clone()]); _v };
                e = (e + 1);
            }
            j = (j + 1);
        }
        freq_sub_el = { let mut _v = freq_sub_el.clone(); _v.push(el.clone()); _v };
    }
    return freq_sub_el
}
|paths: Vec<Vec<String>>, nodes: NodesData| -> Vec<Vec<Vec<String>>> { freq_subgraphs_edge_list(node_edges, paths, nodes) }
};
    let mut print_all = |nodes: NodesData, support: Vec<i64>, clusters: ClusterData, graph: GraphData, freq_subgraph_edge_list: Vec<Vec<Vec<String>>>| {
    println!("{}", "\nNodes\n");
    let mut i: i64 = 0;
    while (i < (nodes.keys.clone().len() as i64)) {
        let code: String = nodes.keys.clone()[i as usize].clone().clone();
        println!("{}", code);
        println!("{:?}", format!("{:?}", nodes.map.clone()[code.as_str()].clone().clone()));
        i = (i + 1);
    }
    println!("{}", "\nSupport\n");
    println!("{:?}", format!("{:?}", support));
    println!("{}", "\nCluster\n");
    let mut j: i64 = 0;
    while (j < (clusters.weights.clone().len() as i64)) {
        let w: i64 = clusters.weights.clone()[j as usize];
        println!("{}", format!("{}{}", format!("{}{}", w.to_string(), ":"), format!("{:?}", clusters.clusters.clone()[&w].clone().clone())));
        j = (j + 1);
    }
    println!("{}", "\nGraph\n");
    let mut k: i64 = 0;
    while (k < (graph.keys.clone().len() as i64)) {
        let key: String = graph.keys.clone()[k as usize].clone().clone();
        println!("{}", key);
        println!("{:?}", format!("{:?}", graph.edges.clone()[key.as_str()].clone().clone()));
        k = (k + 1);
    }
    println!("{}", "\nEdge List of Frequent subgraphs\n");
    for el in freq_subgraph_edge_list.iter() {
        println!("{:?}", format!("{:?}", el));
    }
};
    let mut mochi_main = {
fn mochi_main(EDGE_ARRAY: &Vec<Vec<Vec<String>>>, construct_graph: &fn(ClusterData, NodesData) -> GraphData, find_freq_subgraph_given_support: &fn(i64, ClusterData, GraphData) -> i64, freq_subgraphs_edge_list: &fn(Vec<Vec<String>>, NodesData) -> Vec<Vec<Vec<String>>>, get_cluster: &fn(NodesData) -> ClusterData, get_frequency_table: &fn(Vec<Vec<Vec<String>>>) -> Vec<HashMap<String, String>>, get_nodes: &fn(Vec<HashMap<String, String>>) -> NodesData, get_support: &fn(ClusterData) -> Vec<i64>, paths: &Vec<Vec<String>>, print_all: &fn(NodesData, Vec<i64>, ClusterData, GraphData, Vec<Vec<Vec<String>>>) -> i64) {
    let frequency_table = get_frequency_table(EDGE_ARRAY.clone());
    let nodes: HashMap<String, Vec<String>> = get_nodes(frequency_table);
    let clusters: HashMap<i64, Vec<String>> = get_cluster(nodes);
    let support = get_support(clusters);
    let graph: HashMap<String, Vec<String>> = construct_graph(clusters, nodes);
    find_freq_subgraph_given_support(60, clusters, graph);
    let freq_subgraph_edge_list = freq_subgraphs_edge_list(paths.clone(), nodes);
    print_all(nodes, support, clusters, graph, freq_subgraph_edge_list);
}
|| { mochi_main(EDGE_ARRAY, construct_graph, find_freq_subgraph_given_support, freq_subgraphs_edge_list, get_cluster, get_frequency_table, get_nodes, get_support, paths, print_all) }
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
