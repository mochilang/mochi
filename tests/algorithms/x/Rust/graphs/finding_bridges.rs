// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
#[derive(Debug, Clone, Default)]
struct DfsResult {
    id: i64,
    bridges: Vec<Vec<i64>>,
}
impl std::fmt::Display for DfsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"bridges\": {:?}", self.bridges)?;
        write!(f, "}}")
    }
}

fn dfs(mut graph: HashMap<i64, Vec<i64>>, mut at: i64, mut parent: i64, visited: &mut Vec<bool>, ids: &mut Vec<i64>, low: &mut Vec<i64>, mut id: i64, mut bridges: Vec<Vec<i64>>) -> DfsResult {
    (*visited)[at as usize] = true;
    (*ids)[at as usize] = id;
    (*low)[at as usize] = id;
    let mut current_id: i64 = (id + 1);
    let mut res_bridges: Vec<Vec<i64>> = bridges.clone();
    for to in graph.get(&at).cloned().unwrap_or_default().iter().cloned() {
        if (to == parent) {
            continue
        } else if !visited[to as usize] {
            let result: DfsResult = dfs(graph.clone(), to, at, visited, ids, low, current_id, res_bridges.clone());
            current_id = result.id;
            res_bridges = result.bridges.clone();
            if (low[at as usize] > low[to as usize]) {
                (*low)[at as usize] = low[to as usize];
            }
            if (ids[at as usize] < low[to as usize]) {
                let edge: Vec<i64> = if (at < to) { vec![at, to] } else { vec![to, at] };
                res_bridges = { let mut _v = res_bridges.clone(); _v.push(edge.clone()); _v };
            }
        } else {
            if (low[at as usize] > ids[to as usize]) {
                (*low)[at as usize] = ids[to as usize];
            }
        }
    }
    return DfsResult {id: current_id, bridges: res_bridges.clone()}
}

fn compute_bridges(mut graph: HashMap<i64, Vec<i64>>) -> Vec<Vec<i64>> {
    let n: i64 = (graph.len() as i64);
    let mut visited: Vec<bool> = vec![];
    let mut ids: Vec<i64> = vec![];
    let mut low: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        visited = { let mut _v = visited.clone(); _v.push(false); _v };
        ids = { let mut _v = ids.clone(); _v.push(0); _v };
        low = { let mut _v = low.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut bridges: Vec<Vec<i64>> = vec![];
    let mut id: i64 = 0;
    i = 0;
    while (i < n) {
        if !visited[i as usize] {
            let result: DfsResult = dfs(graph.clone(), i, -1, &mut visited, &mut ids, &mut low, id, bridges.clone());
            id = result.id;
            bridges = result.bridges.clone();
        }
        i = (i + 1);
    }
    return bridges
}

fn get_demo_graph(mut index: i64) -> HashMap<i64, Vec<i64>> {
    if (index == 0) {
        return HashMap::from([(0, vec![1, 2]), (1, vec![0, 2]), (2, vec![0, 1, 3, 5]), (3, vec![2, 4]), (4, vec![3]), (5, vec![2, 6, 8]), (6, vec![5, 7]), (7, vec![6, 8]), (8, vec![5, 7])])
    }
    if (index == 1) {
        return HashMap::from([(0, vec![6]), (1, vec![9]), (2, vec![4, 5]), (3, vec![4]), (4, vec![2, 3]), (5, vec![2]), (6, vec![0, 7]), (7, vec![6]), (8, vec![]), (9, vec![1])])
    }
    if (index == 2) {
        return HashMap::from([(0, vec![4]), (1, vec![6]), (2, vec![]), (3, vec![5, 6, 7]), (4, vec![0, 6]), (5, vec![3, 8, 9]), (6, vec![1, 3, 4, 7]), (7, vec![3, 6, 8, 9]), (8, vec![5, 7]), (9, vec![5, 7])])
    }
    return HashMap::from([(0, vec![1, 3]), (1, vec![0, 2, 4]), (2, vec![1, 3, 4]), (3, vec![0, 2, 4]), (4, vec![1, 2, 3])])
}

fn main() {
    println!("{:?}", format!("{:?}", compute_bridges(get_demo_graph(0))));
    println!("{:?}", format!("{:?}", compute_bridges(get_demo_graph(1))));
    println!("{:?}", format!("{:?}", compute_bridges(get_demo_graph(2))));
    println!("{:?}", format!("{:?}", compute_bridges(get_demo_graph(3))));
    println!("{:?}", format!("{:?}", compute_bridges(HashMap::new())));
}
