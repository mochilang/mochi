// Generated by Mochi transpiler v0.10.65
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn sqrtApprox(mut x: f64) -> f64 {
    let mut guess: f64 = (x / 2.0);
    let mut i: i64 = 0;
    while (i < 20) {
        guess = ((guess + (x / guess)) / 2.0);
        i = (i + 1);
    }
    return guess
};
    fn rand_float() -> f64 {
    return (((_now() % 1000000) as f64) / 1000000.0)
};
    fn pow_float(mut base: f64, mut exp: f64) -> f64 {
    let mut result: f64 = 1.0;
    let mut i: i64 = 0;
    let e: i64 = (exp as i64);
    while (i < e) {
        result = (result * base);
        i = (i + 1);
    }
    return result
};
    fn distance(mut city1: Vec<i64>, mut city2: Vec<i64>) -> f64 {
    let dx: f64 = ((city1[0 as usize] - city2[0 as usize]) as f64);
    let dy: f64 = ((city1[1 as usize] - city2[1 as usize]) as f64);
    return sqrtApprox(((dx * dx) + (dy * dy)))
};
    fn choose_weighted(mut options: Vec<i64>, mut weights: Vec<f64>) -> i64 {
    let mut total: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (weights.len() as i64)) {
        total = (total + weights[i as usize]);
        i = (i + 1);
    }
    let r: f64 = (rand_float() * total);
    let mut accum: f64 = 0.0;
    i = 0;
    while (i < (weights.len() as i64)) {
        accum = (accum + weights[i as usize]);
        if (r <= accum) {
            return options[i as usize]
        }
        i = (i + 1);
    }
    return options[((options.len() as i64) - 1) as usize]
};
    fn city_select(mut pheromone: Vec<Vec<f64>>, mut current: i64, mut unvisited: Vec<i64>, mut alpha: f64, mut beta: f64, mut cities: HashMap<i64, Vec<i64>>) -> i64 {
    let mut probs: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (unvisited.len() as i64)) {
        let city: i64 = unvisited[i as usize];
        let dist: f64 = distance(cities.get(&city).cloned().unwrap_or_default(), cities.get(&current).cloned().unwrap_or_default());
        let trail: f64 = pheromone[city as usize].clone()[current as usize];
        let prob: f64 = (pow_float(trail, alpha) * pow_float((1.0 / dist), beta));
        probs = { let mut _v = probs.clone(); _v.push(prob); _v };
        i = (i + 1);
    }
    return choose_weighted(unvisited.clone(), probs.clone())
};
    fn pheromone_update(mut pheromone: Vec<Vec<f64>>, mut cities: HashMap<i64, Vec<i64>>, mut evaporation: f64, mut ants_route: Vec<Vec<i64>>, mut q: f64) -> Vec<Vec<f64>> {
    let n: i64 = (pheromone.len() as i64);
    let mut i: i64 = 0;
    while (i < n) {
        let mut j: i64 = 0;
        while (j < n) {
            pheromone[i as usize][j as usize] = (pheromone[i as usize].clone()[j as usize] * evaporation);
            j = (j + 1);
        }
        i = (i + 1);
    }
    let mut a: i64 = 0;
    while (a < (ants_route.len() as i64)) {
        let route: Vec<i64> = ants_route[a as usize].clone();
        let mut total: f64 = 0.0;
        let mut r: i64 = 0;
        while (r < ((route.len() as i64) - 1)) {
            total = (total + distance(cities.get(&route[r as usize]).cloned().unwrap_or_default(), cities.get(&route[(r + 1) as usize]).cloned().unwrap_or_default()));
            r = (r + 1);
        }
        let delta: f64 = (q / total);
        r = 0;
        while (r < ((route.len() as i64) - 1)) {
            let u: i64 = route[r as usize];
            let v: i64 = route[(r + 1) as usize];
            pheromone[u as usize][v as usize] = (pheromone[u as usize].clone()[v as usize] + delta);
            pheromone[v as usize][u as usize] = pheromone[u as usize].clone()[v as usize];
            r = (r + 1);
        }
        a = (a + 1);
    }
    return pheromone
};
    fn remove_value(mut lst: Vec<i64>, mut val: i64) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (lst.len() as i64)) {
        if (lst[i as usize] != val) {
            res = { let mut _v = res.clone(); _v.push(lst[i as usize]); _v };
        }
        i = (i + 1);
    }
    return res
};
    fn ant_colony(mut cities: HashMap<i64, Vec<i64>>, mut ants_num: i64, mut iterations: i64, mut evaporation: f64, mut alpha: f64, mut beta: f64, mut q: f64) {
    let n: i64 = (cities.len() as i64);
    let mut pheromone: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            row = { let mut _v = row.clone(); _v.push(1.0); _v };
            j = (j + 1);
        }
        pheromone = { let mut _v = pheromone.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    let mut best_path: Vec<i64> = vec![];
    let mut best_distance: f64 = 1000000000.0;
    let mut iter: i64 = 0;
    while (iter < iterations) {
        let mut ants_route: Vec<Vec<i64>> = vec![];
        let mut k: i64 = 0;
        while (k < ants_num) {
            let mut route: Vec<i64> = vec![0];
            let mut unvisited: Vec<i64> = vec![];
            for key in cities.keys().cloned() {
                if (key != 0) {
                    unvisited = { let mut _v = unvisited.clone(); _v.push(key); _v };
                }
            }
            let mut current: i64 = 0;
            while ((unvisited.len() as i64) > 0) {
                let next_city: i64 = city_select(pheromone.clone(), current, unvisited.clone(), alpha, beta, cities.clone());
                route = { let mut _v = route.clone(); _v.push(next_city); _v };
                unvisited = remove_value(unvisited.clone(), next_city);
                current = next_city;
            }
            route = { let mut _v = route.clone(); _v.push(0); _v };
            ants_route = { let mut _v = ants_route.clone(); _v.push(route.clone()); _v };
            k = (k + 1);
        }
        pheromone = pheromone_update(pheromone.clone(), cities.clone(), evaporation, ants_route.clone(), q);
        let mut a: i64 = 0;
        while (a < (ants_route.len() as i64)) {
            let route: Vec<i64> = ants_route[a as usize].clone();
            let mut dist: f64 = 0.0;
            let mut r: i64 = 0;
            while (r < ((route.len() as i64) - 1)) {
                dist = (dist + distance(cities.get(&route[r as usize]).cloned().unwrap_or_default(), cities.get(&route[(r + 1) as usize]).cloned().unwrap_or_default()));
                r = (r + 1);
            }
            if (dist < best_distance) {
                best_distance = dist;
                best_path = route.clone();
            }
            a = (a + 1);
        }
        iter = (iter + 1);
    }
    println!("{}", format!("{}{}", "best_path = ", format!("{:?}", best_path)));
    println!("{}", format!("{}{}", "best_distance = ", best_distance.to_string()));
};
    let cities: HashMap<i64, Vec<i64>> = HashMap::from([(0, vec![0, 0]), (1, vec![0, 5]), (2, vec![3, 8]), (3, vec![8, 10]), (4, vec![12, 8]), (5, vec![12, 4]), (6, vec![8, 0]), (7, vec![6, 2])]);
    ant_colony(cities.clone(), 10, 20, 0.7, 1.0, 5.0, 10.0);
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
