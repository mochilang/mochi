// Generated by Mochi transpiler v0.10.65
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn push_relabel_max_flow(mut graph: Vec<Vec<i64>>, mut sources: Vec<i64>, mut sinks: Vec<i64>) -> i64 {
    if (((sources.len() as i64) == 0) || ((sinks.len() as i64) == 0)) {
        return 0
    }
    let mut g: Vec<Vec<i64>> = graph.clone();
    let mut source_index: i64 = sources[0 as usize];
    let mut sink_index: i64 = sinks[0 as usize];
    if (((sources.len() as i64) > 1) || ((sinks.len() as i64) > 1)) {
        let mut max_input_flow: i64 = 0;
        let mut i: i64 = 0;
        while (i < (sources.len() as i64)) {
            let mut j: i64 = 0;
            while (j < (g[sources[i as usize] as usize].clone().len() as i64)) {
                max_input_flow = (max_input_flow + g[sources[i as usize] as usize].clone()[j as usize]);
                j = (j + 1);
            }
            i = (i + 1);
        }
        let mut size: i64 = ((g.len() as i64) + 1);
        let mut new_graph: Vec<Vec<i64>> = vec![];
        let mut zero_row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < size) {
            zero_row = { let mut _v = zero_row.clone(); _v.push(0); _v };
            j = (j + 1);
        }
        new_graph = { let mut _v = new_graph.clone(); _v.push(zero_row.clone()); _v };
        let mut r: i64 = 0;
        while (r < (g.len() as i64)) {
            let mut row: Vec<i64> = vec![0];
            let mut c: i64 = 0;
            while (c < (g[r as usize].clone().len() as i64)) {
                row = { let mut _v = row.clone(); _v.push(g[r as usize].clone()[c as usize]); _v };
                c = (c + 1);
            }
            new_graph = { let mut _v = new_graph.clone(); _v.push(row.clone()); _v };
            r = (r + 1);
        }
        g = new_graph.clone();
        i = 0;
        while (i < (sources.len() as i64)) {
            g[0 as usize][(sources[i as usize] + 1) as usize] = max_input_flow;
            i = (i + 1);
        }
        source_index = 0;
        size = ((g.len() as i64) + 1);
        new_graph = vec![];
        r = 0;
        while (r < (g.len() as i64)) {
            let mut row2: Vec<i64> = g[r as usize].clone();
            row2 = { let mut _v = row2.clone(); _v.push(0); _v };
            new_graph = { let mut _v = new_graph.clone(); _v.push(row2.clone()); _v };
            r = (r + 1);
        }
        let mut last_row: Vec<i64> = vec![];
        j = 0;
        while (j < size) {
            last_row = { let mut _v = last_row.clone(); _v.push(0); _v };
            j = (j + 1);
        }
        new_graph = { let mut _v = new_graph.clone(); _v.push(last_row.clone()); _v };
        g = new_graph.clone();
        i = 0;
        while (i < (sinks.len() as i64)) {
            g[(sinks[i as usize] + 1) as usize][(size - 1) as usize] = max_input_flow;
            i = (i + 1);
        }
        sink_index = (size - 1);
    }
    let n: i64 = (g.len() as i64);
    let mut preflow: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            row = { let mut _v = row.clone(); _v.push(0); _v };
            j = (j + 1);
        }
        preflow = { let mut _v = preflow.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    let mut heights: Vec<i64> = vec![];
    i = 0;
    while (i < n) {
        heights = { let mut _v = heights.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut excesses: Vec<i64> = vec![];
    i = 0;
    while (i < n) {
        excesses = { let mut _v = excesses.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    heights[source_index as usize] = n;
    i = 0;
    while (i < n) {
        let mut bandwidth: i64 = g[source_index as usize].clone()[i as usize];
        preflow[source_index as usize][i as usize] = (preflow[source_index as usize].clone()[i as usize] + bandwidth);
        preflow[i as usize][source_index as usize] = (preflow[i as usize].clone()[source_index as usize] - bandwidth);
        excesses[i as usize] = (excesses[i as usize] + bandwidth);
        i = (i + 1);
    }
    let mut vertices_list: Vec<i64> = vec![];
    i = 0;
    while (i < n) {
        if ((i != source_index) && (i != sink_index)) {
            vertices_list = { let mut _v = vertices_list.clone(); _v.push(i); _v };
        }
        i = (i + 1);
    }
    let mut idx: i64 = 0;
    while (idx < (vertices_list.len() as i64)) {
        let mut v: i64 = vertices_list[idx as usize];
        let mut prev_height: i64 = heights[v as usize];
        while (excesses[v as usize] > 0) {
            let mut nb: i64 = 0;
            while (nb < n) {
                if (((g[v as usize].clone()[nb as usize] - preflow[v as usize].clone()[nb as usize]) > 0) && (heights[v as usize] > heights[nb as usize])) {
                    let mut delta: i64 = excesses[v as usize];
                    let mut capacity: i64 = (g[v as usize].clone()[nb as usize] - preflow[v as usize].clone()[nb as usize]);
                    if (delta > capacity) {
                        delta = capacity;
                    }
                    preflow[v as usize][nb as usize] = (preflow[v as usize].clone()[nb as usize] + delta);
                    preflow[nb as usize][v as usize] = (preflow[nb as usize].clone()[v as usize] - delta);
                    excesses[v as usize] = (excesses[v as usize] - delta);
                    excesses[nb as usize] = (excesses[nb as usize] + delta);
                }
                nb = (nb + 1);
            }
            let mut min_height: i64 = -1;
            nb = 0;
            while (nb < n) {
                if ((g[v as usize].clone()[nb as usize] - preflow[v as usize].clone()[nb as usize]) > 0) {
                    if ((min_height == -1) || (heights[nb as usize] < min_height)) {
                        min_height = heights[nb as usize];
                    }
                }
                nb = (nb + 1);
            }
            if (min_height != -1) {
                heights[v as usize] = (min_height + 1);
            } else {
                break
            }
        }
        if (heights[v as usize] > prev_height) {
            let mut vertex: i64 = vertices_list[idx as usize];
            let mut j: i64 = idx;
            while (j > 0) {
                vertices_list[j as usize] = vertices_list[(j - 1) as usize];
                j = (j - 1);
            }
            vertices_list[0 as usize] = vertex;
            idx = 0;
        } else {
            idx = (idx + 1);
        }
    }
    let mut flow: i64 = 0;
    i = 0;
    while (i < n) {
        flow = (flow + preflow[source_index as usize].clone()[i as usize]);
        i = (i + 1);
    }
    if (flow < 0) {
        flow = -flow;
    }
    return flow
};
    let graph: Vec<Vec<i64>> = vec![vec![0, 7, 0, 0].clone(), vec![0, 0, 6, 0].clone(), vec![0, 0, 0, 8].clone(), vec![9, 0, 0, 0].clone()];
    let sources: Vec<i64> = vec![0];
    let sinks: Vec<i64> = vec![3];
    let result: i64 = push_relabel_max_flow(graph.clone(), sources.clone(), sinks.clone());
    println!("{}", format!("{}{}", "maximum flow is ", result.to_string()));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
