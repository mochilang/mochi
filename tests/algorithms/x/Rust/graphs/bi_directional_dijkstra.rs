// Generated by Mochi transpiler v0.10.65
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Edge {
    to: String,
    cost: i64,
}
impl std::fmt::Display for Edge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"to\": \"{}\"", self.to)?;
        write!(f, ", ")?;
        write!(f, "\"cost\": {}", self.cost)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct QItem {
    node: String,
    cost: i64,
}
impl std::fmt::Display for QItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"node\": \"{}\"", self.node)?;
        write!(f, ", ")?;
        write!(f, "\"cost\": {}", self.cost)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct PassResult {
    queue: Vec<QItem>,
    dist: i64,
}
impl std::fmt::Display for PassResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"queue\": {:?}", self.queue)?;
        write!(f, ", ")?;
        write!(f, "\"dist\": {}", self.dist)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn get_min_index(mut q: Vec<QItem>) -> i64 {
    let mut idx: i64 = 0;
    let mut i: i64 = 1;
    while (i < (q.len() as i64)) {
        if (q[i as usize].clone().cost < q[idx as usize].clone().cost) {
            idx = i;
        }
        i = (i + 1);
    }
    return idx
};
    fn remove_at(mut q: Vec<QItem>, mut idx: i64) -> Vec<QItem> {
    let mut res: Vec<QItem> = vec![];
    let mut i: i64 = 0;
    while (i < (q.len() as i64)) {
        if (i != idx) {
            res = { let mut _v = res.clone(); _v.push(q[i as usize].clone()); _v };
        }
        i = (i + 1);
    }
    return res
};
    fn pass_and_relaxation(mut graph: HashMap<String, Vec<Edge>>, mut v: String, mut visited_forward: HashMap<String, bool>, mut visited_backward: HashMap<String, bool>, cst_fwd: &mut HashMap<String, i64>, mut cst_bwd: HashMap<String, i64>, mut queue: Vec<QItem>, parent: &mut HashMap<String, String>, mut shortest_distance: i64) -> PassResult {
    let mut q: Vec<QItem> = queue.clone();
    let mut sd: i64 = shortest_distance;
    for e in graph.get(v.as_str()).cloned().unwrap_or_default().iter().cloned() {
        let nxt: String = e.to.clone().clone();
        let d: i64 = e.cost;
        if visited_forward.contains_key(&nxt) {
            continue
        }
        let old_cost: i64 = if cst_fwd.contains_key(&nxt) { cst_fwd.get(nxt.as_str()).cloned().unwrap_or_default() } else { 2147483647 };
        let new_cost: i64 = (cst_fwd.get(v.as_str()).cloned().unwrap_or_default() + d);
        if (new_cost < old_cost) {
            q = { let mut _v = q.clone(); _v.push(QItem {node: nxt.clone(), cost: new_cost}); _v };
            (*cst_fwd).insert(nxt.clone(), new_cost.clone());
            (*parent).insert(nxt.clone(), v.clone());
        }
        if visited_backward.contains_key(&nxt) {
            let alt: i64 = ((cst_fwd.get(v.as_str()).cloned().unwrap_or_default() + d) + cst_bwd.get(nxt.as_str()).cloned().unwrap_or_default());
            if (alt < sd) {
                sd = alt;
            }
        }
    }
    return PassResult {queue: q.clone(), dist: sd}
};
    fn bidirectional_dij(mut source: String, mut destination: String, mut graph_forward: HashMap<String, Vec<Edge>>, mut graph_backward: HashMap<String, Vec<Edge>>) -> i64 {
    let mut shortest_path_distance: i64 = -1;
    let mut visited_forward: HashMap<String, bool> = HashMap::new();
    let mut visited_backward: HashMap<String, bool> = HashMap::new();
    let mut cst_fwd: HashMap<String, i64> = HashMap::new();
    cst_fwd.insert(source.clone(), 0);
    let mut cst_bwd: HashMap<String, i64> = HashMap::new();
    cst_bwd.insert(destination.clone(), 0);
    let mut parent_forward: HashMap<String, String> = HashMap::new();
    parent_forward.insert(source.clone(), String::from(""));
    let mut parent_backward: HashMap<String, String> = HashMap::new();
    parent_backward.insert(destination.clone(), String::from(""));
    let mut queue_forward: Vec<QItem> = vec![];
    queue_forward = { let mut _v = queue_forward.clone(); _v.push(QItem {node: source.clone(), cost: 0}); _v };
    let mut queue_backward: Vec<QItem> = vec![];
    queue_backward = { let mut _v = queue_backward.clone(); _v.push(QItem {node: destination.clone(), cost: 0}); _v };
    let mut shortest_distance: i64 = 2147483647;
    if (source.as_str() == destination.as_str()) {
        return 0
    }
    while (((queue_forward.len() as i64) > 0) && ((queue_backward.len() as i64) > 0)) {
        let idx_f: i64 = get_min_index(queue_forward.clone());
        let item_f: QItem = queue_forward[idx_f as usize].clone();
        queue_forward = remove_at(queue_forward.clone(), idx_f);
        let v_fwd: String = item_f.node.clone().clone();
        visited_forward.insert(v_fwd.clone(), true);
        let idx_b: i64 = get_min_index(queue_backward.clone());
        let item_b: QItem = queue_backward[idx_b as usize].clone();
        queue_backward = remove_at(queue_backward.clone(), idx_b);
        let v_bwd: String = item_b.node.clone().clone();
        visited_backward.insert(v_bwd.clone(), true);
        let res_f: PassResult = pass_and_relaxation(graph_forward.clone(), v_fwd.clone(), visited_forward.clone(), visited_backward.clone(), &mut cst_fwd, cst_bwd.clone(), queue_forward.clone(), &mut parent_forward, shortest_distance);
        queue_forward = res_f.queue.clone();
        shortest_distance = res_f.dist;
        let res_b: PassResult = pass_and_relaxation(graph_backward.clone(), v_bwd.clone(), visited_backward.clone(), visited_forward.clone(), &mut cst_bwd, cst_fwd.clone(), queue_backward.clone(), &mut parent_backward, shortest_distance);
        queue_backward = res_b.queue.clone();
        shortest_distance = res_b.dist;
        if ((cst_fwd.get(v_fwd.as_str()).cloned().unwrap_or_default() + cst_bwd.get(v_bwd.as_str()).cloned().unwrap_or_default()) >= shortest_distance) {
            break
        }
    }
    if (shortest_distance != 2147483647) {
        shortest_path_distance = shortest_distance;
    }
    return shortest_path_distance
};
    let mut graph_fwd: HashMap<String, Vec<Edge>> = HashMap::from([(String::from("B"), vec![Edge {to: String::from("C"), cost: 1}.clone()]), (String::from("C"), vec![Edge {to: String::from("D"), cost: 1}.clone()]), (String::from("D"), vec![Edge {to: String::from("F"), cost: 1}.clone()]), (String::from("E"), vec![Edge {to: String::from("B"), cost: 1}.clone(), Edge {to: String::from("G"), cost: 2}.clone()]), (String::from("F"), vec![]), (String::from("G"), vec![Edge {to: String::from("F"), cost: 1}.clone()])]);
    let mut graph_bwd: HashMap<String, Vec<Edge>> = HashMap::from([(String::from("B"), vec![Edge {to: String::from("E"), cost: 1}.clone()]), (String::from("C"), vec![Edge {to: String::from("B"), cost: 1}.clone()]), (String::from("D"), vec![Edge {to: String::from("C"), cost: 1}.clone()]), (String::from("F"), vec![Edge {to: String::from("D"), cost: 1}.clone(), Edge {to: String::from("G"), cost: 1}.clone()]), (String::from("E"), vec![]), (String::from("G"), vec![Edge {to: String::from("E"), cost: 2}.clone()])]);
    println!("{}", bidirectional_dij(String::from("E"), String::from("F"), graph_fwd.clone(), graph_bwd.clone()).to_string());
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
