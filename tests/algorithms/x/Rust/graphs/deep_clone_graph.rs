// Generated by Mochi transpiler v0.10.73
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone)]
enum Node {
    Nil,
    N { value: i64, neighbors: Vec<Node> },
}

fn main() {
        let _start: i64 = _now();;
    fn deep_clone_graph(mut node: Node) -> Node {
    let mut clones: HashMap<i64, Node> = HashMap::new();;
    let mut dfs = |mut n: Node| -> Node {
    return match n { Node::Nil => Node::Nil, Node::N { value: v, neighbors: neigh } => {let mut result: Node = Node::Nil.clone();

return result
}, }
};;
    return dfs(node.clone())
};
    fn serialize(mut node: Node) -> String {
    let mut seen: HashMap<i64, bool> = HashMap::new();;
    let mut lines: Vec<String> = vec![];;
    let mut dfs = |mut n: Node| {
    match n { Node::Nil => {}, Node::N { value: v, neighbors: neigh } => {
seen.insert(v.clone(), true);
let mut vals: Vec<i64> = vec![];

lines = { let mut _v = lines.clone(); _v.extend(vec![format!("{}{}", format!("{}{}", v.to_string(), ":"), format!("{:?}", vals)).clone()]); _v }

}, };;
};;
    dfs(node.clone());;
    return lines.clone().join("\n").clone()
};
    let mut mochi_main = || {
    let g4: Node = Node::N { value: 4, neighbors: vec![] };;
    let g3: Node = Node::N { value: 3, neighbors: vec![g4.clone()] };;
    let g2: Node = Node::N { value: 2, neighbors: vec![g3.clone()] };;
    let g1: Node = Node::N { value: 1, neighbors: vec![g2.clone()] };;
    let clone: Node = deep_clone_graph(g1.clone());;
    println!("{}", serialize(clone.clone()));;
};;
    mochi_main();;
    let _end: i64 = _now();;
    let duration_us: i64 = ((_end - _start) / 1000);;
    let memory_bytes: i64 = _mem();;
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
