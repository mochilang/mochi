// Generated by Mochi transpiler v0.10.65
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct SMAValue {
    value: f64,
    ok: bool,
}
impl std::fmt::Display for SMAValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, ", ")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, "}}")
    }
}

static g_window_size: i64 = 3;
static mut g_idx: i64 = 0;
fn main() {
    unsafe {
        g_idx = 0;
                let _start: i64 = _now();
        fn simple_moving_average(mut data: Vec<f64>, mut window_size: i64) -> Vec<SMAValue> {
    if (window_size < 1) {
        panic!("Window size must be a positive integer");
    }
    let mut result: Vec<SMAValue> = vec![];
    let mut window_sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (data.len() as i64)) {
        window_sum = (window_sum + data[i as usize]);
        if (i >= window_size) {
            window_sum = (window_sum - data[(i - window_size) as usize]);
        }
        if (i >= (window_size - 1)) {
            let avg: f64 = (window_sum / (window_size as f64));
            result = { let mut _v = result.clone(); _v.push(SMAValue {value: avg, ok: true}); _v };
        } else {
            result = { let mut _v = result.clone(); _v.push(SMAValue {value: 0.0, ok: false}); _v };
        }
        i = (i + 1);
    }
    return result
};
        let data: Vec<f64> = vec![10.0, 12.0, 15.0, 13.0, 14.0, 16.0, 18.0, 17.0, 19.0, 21.0];
        let sma_values: Vec<SMAValue> = simple_moving_average(data.clone(), unsafe { g_window_size.clone() });
        while (unsafe { g_idx.clone() } < (sma_values.len() as i64)) {
            let item: SMAValue = sma_values[unsafe { g_idx.clone() } as usize].clone();
            if item.ok {
                println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Day ", (unsafe { g_idx.clone() } + 1).to_string()), ": "), item.value.to_string()));
            } else {
                println!("{}", format!("{}{}", format!("{}{}", "Day ", (unsafe { g_idx.clone() } + 1).to_string()), ": Not enough data for SMA"));
            }
            unsafe { g_idx = (unsafe { g_idx.clone() } + 1) };
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
