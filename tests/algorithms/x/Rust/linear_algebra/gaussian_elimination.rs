// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn retroactive_resolution(mut coefficients: Vec<Vec<f64>>, mut vector: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let rows: i64 = (coefficients.len() as i64);
    let mut x: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < rows) {
        let mut inner: Vec<f64> = vec![];
        inner = { let mut _v = inner.clone(); _v.push(0.0); _v };
        x = { let mut _v = x.clone(); _v.push(inner.clone()); _v };
        i = (i + 1);
    }
    let mut r: i64 = (rows - 1);
    while (r >= 0) {
        let mut total: f64 = 0.0;
        let mut c: i64 = (r + 1);
        while (c < rows) {
            total = (total + (coefficients[r as usize].clone()[c as usize] * x[c as usize].clone()[0 as usize]));
            c = (c + 1);
        }
        x[r as usize][0 as usize] = ((vector[r as usize].clone()[0 as usize] - total) / coefficients[r as usize].clone()[r as usize]);
        r = (r - 1);
    }
    return x
};
    fn gaussian_elimination(mut coefficients: Vec<Vec<f64>>, mut vector: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let rows: i64 = (coefficients.len() as i64);
    let columns: i64 = (coefficients[0 as usize].clone().len() as i64);
    if (rows != columns) {
        return vec![]
    }
    let mut augmented: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < rows) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < columns) {
            row = { let mut _v = row.clone(); _v.push(coefficients[i as usize].clone()[j as usize]); _v };
            j = (j + 1);
        }
        row = { let mut _v = row.clone(); _v.push(vector[i as usize].clone()[0 as usize]); _v };
        augmented = { let mut _v = augmented.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    let mut row_idx: i64 = 0;
    while (row_idx < (rows - 1)) {
        let pivot: f64 = augmented[row_idx as usize].clone()[row_idx as usize];
        let mut col: i64 = (row_idx + 1);
        while (col < rows) {
            let factor: f64 = (augmented[col as usize].clone()[row_idx as usize] / pivot);
            let mut k: i64 = row_idx;
            while (k < (columns + 1)) {
                augmented[col as usize][k as usize] = (augmented[col as usize].clone()[k as usize] - (factor * augmented[row_idx as usize].clone()[k as usize]));
                k = (k + 1);
            }
            col = (col + 1);
        }
        row_idx = (row_idx + 1);
    }
    let mut coeffs: Vec<Vec<f64>> = vec![];
    let mut vec: Vec<Vec<f64>> = vec![];
    let mut r: i64 = 0;
    while (r < rows) {
        let mut row: Vec<f64> = vec![];
        let mut c: i64 = 0;
        while (c < columns) {
            row = { let mut _v = row.clone(); _v.push(augmented[r as usize].clone()[c as usize]); _v };
            c = (c + 1);
        }
        coeffs = { let mut _v = coeffs.clone(); _v.push(row.clone()); _v };
        vec = { let mut _v = vec.clone(); _v.push(vec![augmented[r as usize].clone()[columns as usize]]); _v };
        r = (r + 1);
    }
    let x: Vec<Vec<f64>> = retroactive_resolution(coeffs.clone(), vec.clone());
    return x
};
    println!("{:?}", format!("{:?}", gaussian_elimination(vec![vec![1.0, -4.0, -2.0].clone(), vec![5.0, 2.0, -2.0].clone(), vec![1.0, -1.0, 0.0].clone()], vec![vec![-2.0].clone(), vec![-3.0].clone(), vec![4.0].clone()])));
    println!("{:?}", format!("{:?}", gaussian_elimination(vec![vec![1.0, 2.0].clone(), vec![5.0, 2.0].clone()], vec![vec![5.0].clone(), vec![5.0].clone()])));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
