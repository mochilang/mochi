// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Vector {
    components: Vec<f64>,
}
impl std::fmt::Display for Vector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"components\": {:?}", self.components)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Matrix {
    data: Vec<Vec<f64>>,
    width: i64,
    height: i64,
}
impl std::fmt::Display for Matrix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"data\": {:?}", self.data)?;
        write!(f, ", ")?;
        write!(f, "\"width\": {}", self.width)?;
        write!(f, ", ")?;
        write!(f, "\"height\": {}", self.height)?;
        write!(f, "}}")
    }
}

static g_PI: f64 = 3.141592653589793;
fn main() {
    unsafe {
                let _start: i64 = _now();
        let mut seed: i64 = 123456789;
        let mut rand = {
fn rand(seed: i64) -> i64 {
    seed = (((seed * 1103515245) + 12345) % 2147483648);
    return seed
}
|| -> i64 { rand(seed) }
};
        let mut random_int = {
fn random_int(rand: &fn() -> i64, a: i64, b: i64) -> i64 {
    let r: i64 = (rand() % ((b - a) + 1));
    return (a + r)
}
|a: i64, b: i64| -> i64 { random_int(rand, a, b) }
};
        let mut sqrtApprox = |x: f64| -> f64 {
    if (x <= 0.0) {
        return 0.0
    }
    let mut guess: f64 = x;
    let mut i: i64 = 0;
    while (i < 20) {
        guess = ((guess + (x / guess)) / 2.0);
        i = (i + 1);
    }
    return guess
};
        let mut arcsin_taylor = |x: f64| -> f64 {
    let mut term: f64 = x;
    let mut sum: f64 = x;
    let mut n: i64 = 1;
    while (n < 10) {
        let num: f64 = ((((((2.0 * (n as f64)) - 1.0) * ((2.0 * (n as f64)) - 1.0)) * x) * x) * term);
        let den: f64 = ((2.0 * (n as f64)) * ((2.0 * (n as f64)) + 1.0));
        term = (num / den);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum
};
        let mut acos_taylor = {
fn acos_taylor(PI: f64, arcsin_taylor: &fn(f64) -> f64, x: f64) -> f64 {
    return ((unsafe { g_PI.clone() } / 2.0) - arcsin_taylor(x))
}
|x: f64| -> f64 { acos_taylor(PI, arcsin_taylor, x) }
};
        let mut vector_len = |v: Vector| -> i64 {
    return (v.components.clone().len() as i64)
};
        let mut vector_to_string = |v: Vector| -> String {
    let mut s: String = String::from("(");
    let mut i: i64 = 0;
    while (i < (v.components.clone().len() as i64)) {
        s = format!("{}{}", s, v.components.clone()[i as usize].to_string());
        if (i < ((v.components.clone().len() as i64) - 1)) {
            s = format!("{}{}", s, ",");
        }
        i = (i + 1);
    }
    s = format!("{}{}", s, ")");
    return s.clone()
};
        let mut vector_add = {
fn vector_add(vector_len: &fn(Vector) -> i64, a: Vector, b: Vector) -> Vector {
    let size: i64 = vector_len(a.clone());
    if (size != vector_len(b.clone())) {
        return Vector {components: vec![]}
    }
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < size) {
        res = { let mut _v = res.clone(); _v.push((a.components.clone()[i as usize] + b.components.clone()[i as usize])); _v };
        i = (i + 1);
    }
    return Vector {components: res.clone()}
}
|a: Vector, b: Vector| -> Vector { vector_add(vector_len, a, b) }
};
        let mut vector_sub = {
fn vector_sub(vector_len: &fn(Vector) -> i64, a: Vector, b: Vector) -> Vector {
    let size: i64 = vector_len(a.clone());
    if (size != vector_len(b.clone())) {
        return Vector {components: vec![]}
    }
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < size) {
        res = { let mut _v = res.clone(); _v.push((a.components.clone()[i as usize] - b.components.clone()[i as usize])); _v };
        i = (i + 1);
    }
    return Vector {components: res.clone()}
}
|a: Vector, b: Vector| -> Vector { vector_sub(vector_len, a, b) }
};
        let mut vector_eq = {
fn vector_eq(vector_len: &fn(Vector) -> i64, a: Vector, b: Vector) -> bool {
    if (vector_len(a.clone()) != vector_len(b.clone())) {
        return false
    }
    let mut i: i64 = 0;
    while (i < vector_len(a.clone())) {
        if (a.components.clone()[i as usize] != b.components.clone()[i as usize]) {
            return false
        }
        i = (i + 1);
    }
    return true
}
|a: Vector, b: Vector| -> bool { vector_eq(vector_len, a, b) }
};
        let mut vector_mul_scalar = {
fn vector_mul_scalar(vector_len: &fn(Vector) -> i64, v: Vector, s: f64) -> Vector {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < vector_len(v.clone())) {
        res = { let mut _v = res.clone(); _v.push((v.components.clone()[i as usize] * s)); _v };
        i = (i + 1);
    }
    return Vector {components: res.clone()}
}
|v: Vector, s: f64| -> Vector { vector_mul_scalar(vector_len, v, s) }
};
        let mut vector_dot = {
fn vector_dot(vector_len: &fn(Vector) -> i64, a: Vector, b: Vector) -> f64 {
    let size: i64 = vector_len(a.clone());
    if (size != vector_len(b.clone())) {
        return 0.0
    }
    let mut sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < size) {
        sum = (sum + (a.components.clone()[i as usize] * b.components.clone()[i as usize]));
        i = (i + 1);
    }
    return sum
}
|a: Vector, b: Vector| -> f64 { vector_dot(vector_len, a, b) }
};
        let mut vector_copy = {
fn vector_copy(vector_len: &fn(Vector) -> i64, v: Vector) -> Vector {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < vector_len(v.clone())) {
        res = { let mut _v = res.clone(); _v.push(v.components.clone()[i as usize]); _v };
        i = (i + 1);
    }
    return Vector {components: res.clone()}
}
|v: Vector| -> Vector { vector_copy(vector_len, v) }
};
        let mut vector_component = |v: Vector, idx: i64| -> f64 {
    return v.components.clone()[idx as usize]
};
        let mut vector_change_component = |v: Vector, pos: i64, value: f64| -> Vector {
    let mut comps: Vec<f64> = v.components.clone();
    comps[pos as usize] = value;
    return Vector {components: comps.clone()}
};
        let mut vector_euclidean_length = {
fn vector_euclidean_length(sqrtApprox: &fn(f64) -> f64, v: Vector) -> f64 {
    let mut sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (v.components.clone().len() as i64)) {
        sum = (sum + (v.components.clone()[i as usize] * v.components.clone()[i as usize]));
        i = (i + 1);
    }
    let mut result: f64 = sqrtApprox(sum);
    return result
}
|v: Vector| -> f64 { vector_euclidean_length(sqrtApprox, v) }
};
        let mut vector_angle = {
fn vector_angle(PI: f64, acos_taylor: &fn(f64) -> f64, vector_dot: &fn(Vector, Vector) -> f64, vector_euclidean_length: &fn(Vector) -> f64, a: Vector, b: Vector, deg: bool) -> f64 {
    let num: f64 = vector_dot(a.clone(), b.clone());
    let den: f64 = (vector_euclidean_length(a.clone()) * vector_euclidean_length(b.clone()));
    let mut ang: f64 = acos_taylor((num / den));
    if deg {
        ang = ((ang * 180.0) / unsafe { g_PI.clone() });
    }
    return ang
}
|a: Vector, b: Vector, deg: bool| -> f64 { vector_angle(PI, acos_taylor, vector_dot, vector_euclidean_length, a, b, deg) }
};
        let mut zero_vector = |d: i64| -> Vector {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < d) {
        res = { let mut _v = res.clone(); _v.push(0.0); _v };
        i = (i + 1);
    }
    return Vector {components: res.clone()}
};
        let mut unit_basis_vector = |d: i64, pos: i64| -> Vector {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < d) {
        if (i == pos) {
            res = { let mut _v = res.clone(); _v.push(1.0); _v };
        } else {
            res = { let mut _v = res.clone(); _v.push(0.0); _v };
        }
        i = (i + 1);
    }
    return Vector {components: res.clone()}
};
        let mut axpy = {
fn axpy(vector_add: &fn(Vector, Vector) -> Vector, vector_mul_scalar: &fn(Vector, f64) -> Vector, s: f64, x: Vector, y: Vector) -> Vector {
    return vector_add(vector_mul_scalar(x.clone(), s), y.clone())
}
|s: f64, x: Vector, y: Vector| -> Vector { axpy(vector_add, vector_mul_scalar, s, x, y) }
};
        let mut random_vector = |n: i64, a: i64, b: i64| -> Vector {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        res = { let mut _v = res.clone(); _v.push((random_int(a, b) as f64)); _v };
        i = (i + 1);
    }
    return Vector {components: res.clone()}
};
        let mut matrix_to_string = |m: Matrix| -> String {
    let mut ans: String = String::new();
    let mut i: i64 = 0;
    while (i < m.height) {
        ans = format!("{}{}", ans, "|");
        let mut j: i64 = 0;
        while (j < m.width) {
            ans = format!("{}{}", ans, m.data.clone()[i as usize].clone()[j as usize].to_string());
            if (j < (m.width - 1)) {
                ans = format!("{}{}", ans, ",");
            }
            j = (j + 1);
        }
        ans = format!("{}{}", ans, "|\n");
        i = (i + 1);
    }
    return ans.clone()
};
        let mut matrix_add = |a: Matrix, b: Matrix| -> Matrix {
    if ((a.width != b.width) || (a.height != b.height)) {
        return Matrix {data: vec![], width: 0, height: 0}
    }
    let mut mat: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < a.height) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < a.width) {
            row = { let mut _v = row.clone(); _v.push((a.data.clone()[i as usize].clone()[j as usize] + b.data.clone()[i as usize].clone()[j as usize])); _v };
            j = (j + 1);
        }
        mat = { let mut _v = mat.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return Matrix {data: mat.clone(), width: a.width, height: a.height}
};
        let mut matrix_sub = |a: Matrix, b: Matrix| -> Matrix {
    if ((a.width != b.width) || (a.height != b.height)) {
        return Matrix {data: vec![], width: 0, height: 0}
    }
    let mut mat: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < a.height) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < a.width) {
            row = { let mut _v = row.clone(); _v.push((a.data.clone()[i as usize].clone()[j as usize] - b.data.clone()[i as usize].clone()[j as usize])); _v };
            j = (j + 1);
        }
        mat = { let mut _v = mat.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return Matrix {data: mat.clone(), width: a.width, height: a.height}
};
        let mut matrix_mul_vector = {
fn matrix_mul_vector(vector_change_component: &fn(Vector, i64, f64) -> Vector, zero_vector: &fn(i64) -> Vector, m: Matrix, v: Vector) -> Vector {
    if ((v.components.clone().len() as i64) != m.width) {
        return Vector {components: vec![]}
    }
    let mut res: Vector = zero_vector(m.height);
    let mut i: i64 = 0;
    while (i < m.height) {
        let mut sum: f64 = 0.0;
        let mut j: i64 = 0;
        while (j < m.width) {
            sum = (sum + (m.data.clone()[i as usize].clone()[j as usize] * v.components.clone()[j as usize]));
            j = (j + 1);
        }
        res = vector_change_component(res.clone(), i, sum);
        i = (i + 1);
    }
    return res
}
|m: Matrix, v: Vector| -> Vector { matrix_mul_vector(vector_change_component, zero_vector, m, v) }
};
        let mut matrix_mul_scalar = |m: Matrix, s: f64| -> Matrix {
    let mut mat: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < m.height) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < m.width) {
            row = { let mut _v = row.clone(); _v.push((m.data.clone()[i as usize].clone()[j as usize] * s)); _v };
            j = (j + 1);
        }
        mat = { let mut _v = mat.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return Matrix {data: mat.clone(), width: m.width, height: m.height}
};
        let mut matrix_component = |m: Matrix, x: i64, y: i64| -> f64 {
    return m.data.clone()[x as usize].clone()[y as usize]
};
        let mut matrix_change_component = |m: Matrix, x: i64, y: i64, value: f64| -> Matrix {
    let mut data: Vec<Vec<f64>> = m.data.clone();
    data[x as usize][y as usize] = value;
    return Matrix {data: data.clone(), width: m.width, height: m.height}
};
        let mut matrix_minor = {
fn matrix_minor(matrix_determinant: &fn(Matrix) -> f64, m: Matrix, x: i64, y: i64) -> f64 {
    if (m.height != m.width) {
        return 0.0
    }
    let mut minor: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < m.height) {
        if (i != x) {
            let mut row: Vec<f64> = vec![];
            let mut j: i64 = 0;
            while (j < m.width) {
                if (j != y) {
                    row = { let mut _v = row.clone(); _v.push(m.data.clone()[i as usize].clone()[j as usize]); _v };
                }
                j = (j + 1);
            }
            minor = { let mut _v = minor.clone(); _v.push(row.clone()); _v };
        }
        i = (i + 1);
    }
    let sub: Matrix = Matrix {data: minor.clone(), width: (m.width - 1), height: (m.height - 1)};
    return matrix_determinant(sub.clone())
}
|m: Matrix, x: i64, y: i64| -> f64 { matrix_minor(matrix_determinant, m, x, y) }
};
        let mut matrix_cofactor = {
fn matrix_cofactor(matrix_minor: &fn(Matrix, i64, i64) -> f64, m: Matrix, x: i64, y: i64) -> f64 {
    let sign: f64 = if (((x + y) % 2) == 0) { 1.0 } else { -1.0 };
    return (sign * matrix_minor(m.clone(), x, y))
}
|m: Matrix, x: i64, y: i64| -> f64 { matrix_cofactor(matrix_minor, m, x, y) }
};
        let mut matrix_determinant = {
fn matrix_determinant(matrix_cofactor: &fn(Matrix, i64, i64) -> f64, m: Matrix) -> f64 {
    if (m.height != m.width) {
        return 0.0
    }
    if (m.height == 0) {
        return 0.0
    }
    if (m.height == 1) {
        return m.data.clone()[0 as usize].clone()[0 as usize]
    }
    if (m.height == 2) {
        return ((m.data.clone()[0 as usize].clone()[0 as usize] * m.data.clone()[1 as usize].clone()[1 as usize]) - (m.data.clone()[0 as usize].clone()[1 as usize] * m.data.clone()[1 as usize].clone()[0 as usize]))
    }
    let mut sum: f64 = 0.0;
    let mut y: i64 = 0;
    while (y < m.width) {
        sum = (sum + (m.data.clone()[0 as usize].clone()[y as usize] * matrix_cofactor(m.clone(), 0, y)));
        y = (y + 1);
    }
    return sum
}
|m: Matrix| -> f64 { matrix_determinant(matrix_cofactor, m) }
};
        let mut square_zero_matrix = |n: i64| -> Matrix {
    let mut mat: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            row = { let mut _v = row.clone(); _v.push(0.0); _v };
            j = (j + 1);
        }
        mat = { let mut _v = mat.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return Matrix {data: mat.clone(), width: n, height: n}
};
        let mut random_matrix = |w: i64, h: i64, a: i64, b: i64| -> Matrix {
    let mut mat: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < h) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < w) {
            row = { let mut _v = row.clone(); _v.push((random_int(a, b) as f64)); _v };
            j = (j + 1);
        }
        mat = { let mut _v = mat.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return Matrix {data: mat.clone(), width: w, height: h}
};
        let mut mochi_main = || {
    let v1: Vector = Vector {components: vec![1.0, 2.0, 3.0]};
    let v2: Vector = Vector {components: vec![4.0, 5.0, 6.0]};
    println!("{}", vector_to_string(vector_add(v1.clone(), v2.clone())));
    println!("{}", vector_dot(v1.clone(), v2.clone()).to_string());
    println!("{}", vector_euclidean_length(v1.clone()).to_string());
    let m: Matrix = Matrix {data: vec![vec![1.0, 2.0].clone(), vec![3.0, 4.0].clone()], width: 2, height: 2};
    println!("{}", matrix_determinant(m.clone()).to_string());
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
