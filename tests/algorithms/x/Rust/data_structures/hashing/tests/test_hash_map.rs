// Generated by Mochi transpiler v0.10.61
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Entry {
    key: String,
    value: String,
}
impl std::fmt::Display for Entry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"key\": \"{}\"", self.key)?;
        write!(f, ", ")?;
        write!(f, "\"value\": \"{}\"", self.value)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct HashMap {
    entries: Vec<Entry>,
}
impl std::fmt::Display for HashMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"entries\": {:?}", self.entries)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct GetResult {
    found: bool,
    value: String,
}
impl std::fmt::Display for GetResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"found\": {}", self.found)?;
        write!(f, ", ")?;
        write!(f, "\"value\": \"{}\"", self.value)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct DelResult {
    map: HashMap,
    ok: bool,
}
impl std::fmt::Display for DelResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"map\": {}", self.map)?;
        write!(f, ", ")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn make_hash_map() -> HashMap {
    return HashMap {entries: vec![]}
};
    fn hm_len(m: &HashMap) -> i64 {
    return (m.entries.clone().len() as i64)
};
    fn hm_set(m: &HashMap, key: &str, value: &str) -> HashMap {
    let mut entries: Vec<Entry> = m.entries.clone();
    let mut updated: bool = false;
    let mut new_entries: Vec<Entry> = vec![];
    let mut i: i64 = 0;
    while (i < (entries.len() as i64)) {
        let mut e: Entry = entries[i as usize].clone();
        if (e.key.clone() == key) {
            new_entries = { let mut _v = new_entries.clone(); _v.push(Entry {key: key.to_string(), value: value.to_string()}); _v };
            updated = true;
        } else {
            new_entries = { let mut _v = new_entries.clone(); _v.push(e.clone()); _v };
        }
        i = (i + 1);
    }
    if !updated {
        new_entries = { let mut _v = new_entries.clone(); _v.push(Entry {key: key.to_string(), value: value.to_string()}); _v };
    }
    return HashMap {entries: new_entries}
};
    fn hm_get(m: &HashMap, key: &str) -> GetResult {
    let mut i: i64 = 0;
    while (i < (m.entries.clone().len() as i64)) {
        let mut e: Entry = m.entries.clone()[i as usize].clone();
        if (e.key.clone() == key) {
            return GetResult {found: true, value: e.value.clone().clone()}
        }
        i = (i + 1);
    }
    return GetResult {found: false, value: String::from("")}
};
    fn hm_del(m: &HashMap, key: &str) -> DelResult {
    let mut entries: Vec<Entry> = m.entries.clone();
    let mut new_entries: Vec<Entry> = vec![];
    let mut removed: bool = false;
    let mut i: i64 = 0;
    while (i < (entries.len() as i64)) {
        let mut e: Entry = entries[i as usize].clone();
        if (e.key.clone() == key) {
            removed = true;
        } else {
            new_entries = { let mut _v = new_entries.clone(); _v.push(e.clone()); _v };
        }
        i = (i + 1);
    }
    if removed {
        return DelResult {map: HashMap {entries: new_entries}, ok: true}
    }
    return DelResult {map: m.clone(), ok: false}
};
    fn test_add_items() -> bool {
    let mut h: HashMap = make_hash_map();
    h = hm_set(&h, &"key_a", &"val_a");
    h = hm_set(&h, &"key_b", &"val_b");
    let mut a: GetResult = hm_get(&h, &"key_a");
    let mut b: GetResult = hm_get(&h, &"key_b");
    return (((((hm_len(&h) == 2) && a.found) && b.found) && (a.value.clone().as_str() == "val_a")) && (b.value.clone().as_str() == "val_b"))
};
    fn test_overwrite_items() -> bool {
    let mut h: HashMap = make_hash_map();
    h = hm_set(&h, &"key_a", &"val_a");
    h = hm_set(&h, &"key_a", &"val_b");
    let mut a: GetResult = hm_get(&h, &"key_a");
    return (((hm_len(&h) == 1) && a.found) && (a.value.clone().as_str() == "val_b"))
};
    fn test_delete_items() -> bool {
    let mut h: HashMap = make_hash_map();
    h = hm_set(&h, &"key_a", &"val_a");
    h = hm_set(&h, &"key_b", &"val_b");
    let mut d1: DelResult = hm_del(&h, &"key_a");
    h = d1.map.clone();
    let mut d2: DelResult = hm_del(&h, &"key_b");
    h = d2.map.clone();
    h = hm_set(&h, &"key_a", &"val_a");
    let mut d3: DelResult = hm_del(&h, &"key_a");
    h = d3.map.clone();
    return (hm_len(&h) == 0)
};
    fn test_access_absent_items() -> bool {
    let mut h: HashMap = make_hash_map();
    let mut g1: GetResult = hm_get(&h, &"key_a");
    let mut d1: DelResult = hm_del(&h, &"key_a");
    h = d1.map.clone();
    h = hm_set(&h, &"key_a", &"val_a");
    let mut d2: DelResult = hm_del(&h, &"key_a");
    h = d2.map.clone();
    let mut d3: DelResult = hm_del(&h, &"key_a");
    h = d3.map.clone();
    let mut g2: GetResult = hm_get(&h, &"key_a");
    return ((((((g1.found == false) && (d1.ok == false)) && d2.ok) && (d3.ok == false)) && (g2.found == false)) && (hm_len(&h) == 0))
};
    fn test_add_with_resize_up() -> bool {
    let mut h: HashMap = make_hash_map();
    let mut i: i64 = 0;
    while (i < 5) {
        let mut s = i.to_string();
        h = hm_set(&h, &s, &s);
        i = (i + 1);
    }
    return (hm_len(&h) == 5)
};
    fn test_add_with_resize_down() -> bool {
    let mut h: HashMap = make_hash_map();
    let mut i: i64 = 0;
    while (i < 5) {
        let mut s = i.to_string();
        h = hm_set(&h, &s, &s);
        i = (i + 1);
    }
    let mut j: i64 = 0;
    while (j < 5) {
        let mut s = j.to_string();
        let mut d: DelResult = hm_del(&h, &s);
        h = d.map.clone();
        j = (j + 1);
    }
    h = hm_set(&h, &"key_a", &"val_b");
    let mut a: GetResult = hm_get(&h, &"key_a");
    return (((hm_len(&h) == 1) && a.found) && (a.value.clone().as_str() == "val_b"))
};
    println!("{}", if test_add_items() { 1 } else { 0 });
    println!("{}", if test_overwrite_items() { 1 } else { 0 });
    println!("{}", if test_delete_items() { 1 } else { 0 });
    println!("{}", if test_access_absent_items() { 1 } else { 0 });
    println!("{}", if test_add_with_resize_up() { 1 } else { 0 });
    println!("{}", if test_add_with_resize_down() { 1 } else { 0 });
    println!("{}", if true { 1 } else { 0 });
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
