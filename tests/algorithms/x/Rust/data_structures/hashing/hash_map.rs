// Generated by Mochi transpiler v0.10.60
use std::sync::LazyLock;
use std::sync::Mutex;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Bucket {
    state: i64,
    key: i64,
    val: i64,
}
impl std::fmt::Display for Bucket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"state\": {}", self.state)?;
        write!(f, ", ")?;
        write!(f, "\"key\": {}", self.key)?;
        write!(f, ", ")?;
        write!(f, "\"val\": {}", self.val)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct HashMap {
    buckets: Vec<Bucket>,
    len: i64,
    cap_num: i64,
    cap_den: i64,
    initial_size: i64,
}
impl std::fmt::Display for HashMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"buckets\": {:?}", self.buckets)?;
        write!(f, ", ")?;
        write!(f, "\"len\": {}", self.len)?;
        write!(f, ", ")?;
        write!(f, "\"cap_num\": {}", self.cap_num)?;
        write!(f, ", ")?;
        write!(f, "\"cap_den\": {}", self.cap_den)?;
        write!(f, ", ")?;
        write!(f, "\"initial_size\": {}", self.initial_size)?;
        write!(f, "}}")
    }
}

static g_hm: LazyLock<Mutex<HashMap>> = LazyLock::new(|| Mutex::new(hashmap_new(5)));
fn main() {
    unsafe {
                let _start: i64 = _now();
        unsafe fn make_buckets(mut n: i64) -> Vec<Bucket> {
    let mut buckets: Vec<Bucket> = Default::default();
    let mut i: i64 = 0;
    while (i < n) {
        buckets = { let mut _v = buckets.clone(); _v.push(Bucket {state: 0, key: 0, val: 0}); _v };
        i = (i + 1);
    }
    return buckets
};
        unsafe fn hashmap_new(mut initial_size: i64) -> HashMap {
    return HashMap {buckets: make_buckets(initial_size), len: 0, cap_num: 3, cap_den: 4, initial_size: initial_size}
};
        unsafe fn bucket_index(hm: &HashMap, mut key: i64) -> i64 {
    let mut ind: i64 = (key % (hm.buckets.clone().len() as i64));
    if (ind < 0) {
        ind = (ind + (hm.buckets.clone().len() as i64));
    }
    return ind
};
        unsafe fn next_index(hm: &HashMap, mut ind: i64) -> i64 {
    return ((ind + 1) % (hm.buckets.clone().len() as i64))
};
        unsafe fn try_set(hm: &mut HashMap, mut ind: i64, mut key: i64, mut val: i64) -> bool {
    let mut buckets: Vec<Bucket> = hm.buckets.clone();
    let mut b: Bucket = buckets[ind as usize].clone();
    if ((b.state == 0) || (b.state == 2)) {
        buckets[ind as usize] = Bucket {state: 1, key: key, val: val};
        (*hm).buckets = buckets.clone();
        (*hm).len = (hm.len + 1);
        return true
    }
    if (b.key == key) {
        buckets[ind as usize] = Bucket {state: 1, key: key, val: val};
        (*hm).buckets = buckets.clone();
        return true
    }
    return false
};
        unsafe fn is_full(hm: &HashMap) -> bool {
    let mut limit = (((hm.buckets.clone().len() as i64) * hm.cap_num) / hm.cap_den);
    return (hm.len >= limit)
};
        unsafe fn is_sparse(hm: &HashMap) -> bool {
    if ((hm.buckets.clone().len() as i64) <= hm.initial_size) {
        return false
    }
    let mut limit = (((hm.buckets.clone().len() as i64) * hm.cap_num) / (2 * hm.cap_den));
    return (hm.len < limit)
};
        unsafe fn resize(hm: &mut HashMap, mut new_size: i64) {
    let mut old: Vec<Bucket> = hm.buckets.clone();
    (*hm).buckets = make_buckets(new_size);
    (*hm).len = 0;
    let mut i: i64 = 0;
    while (i < (old.len() as i64)) {
        let mut it: Bucket = old[i as usize].clone();
        if (it.state == 1) {
            add_item(hm, it.key, it.val);
        }
        i = (i + 1);
    }
};
        unsafe fn size_up(hm: &mut HashMap) {
    resize(hm, ((hm.buckets.clone().len() as i64) * 2));
};
        unsafe fn size_down(hm: &mut HashMap) {
    resize(hm, ((hm.buckets.clone().len() as i64) / 2));
};
        unsafe fn add_item(hm: &mut HashMap, mut key: i64, mut val: i64) {
    let mut ind: i64 = bucket_index(hm, key);
    let mut i: i64 = 0;
    while (i < (hm.buckets.clone().len() as i64)) {
        if try_set(hm, ind, key, val) {
            break
        }
        ind = next_index(hm, ind);
        i = (i + 1);
    }
};
        unsafe fn hashmap_set(hm: &mut HashMap, mut key: i64, mut val: i64) {
    if is_full(hm) {
        size_up(hm);
    }
    add_item(hm, key, val);
};
        unsafe fn hashmap_get(hm: &mut HashMap, mut key: i64) -> i64 {
    let mut buckets: Vec<Bucket> = hm.buckets.clone();
    let mut ind: i64 = bucket_index(hm, key);
    let mut i: i64 = 0;
    while (i < (buckets.len() as i64)) {
        let mut it: Bucket = buckets[ind as usize].clone();
        if (it.state == 0) {
            break
        }
        if ((it.state == 1) && (it.key == key)) {
            return it.val
        }
        ind = next_index(hm, ind);
        i = (i + 1);
    }
    return 0
};
        unsafe fn hashmap_del(hm: &mut HashMap, mut key: i64) {
    let mut buckets: Vec<Bucket> = hm.buckets.clone();
    let mut ind: i64 = bucket_index(hm, key);
    let mut i: i64 = 0;
    while (i < (buckets.len() as i64)) {
        let mut it: Bucket = buckets[ind as usize].clone();
        if (it.state == 0) {
            println!("{}", format!("{}{}", "KeyError: ", key.to_string()));
            return
        }
        if ((it.state == 1) && (it.key == key)) {
            buckets[ind as usize] = Bucket {state: 2, key: 0, val: 0};
            (*hm).buckets = buckets.clone();
            (*hm).len = (hm.len - 1);
            break
        }
        ind = next_index(hm, ind);
        i = (i + 1);
    }
    if is_sparse(hm) {
        size_down(hm);
    }
};
        unsafe fn hashmap_len(hm: &HashMap) -> i64 {
    return hm.len
};
        unsafe fn hashmap_repr(hm: &HashMap) -> String {
    let mut out: String = String::from("HashMap(");
    let mut first: bool = true;
    let mut i: i64 = 0;
    while (i < (hm.buckets.clone().len() as i64)) {
        let mut b: Bucket = hm.buckets.clone()[i as usize].clone();
        if (b.state == 1) {
            if !first {
                out = format!("{}{}", out, ", ");
            } else {
                first = false;
            }
            out = format!("{}{}", format!("{}{}", format!("{}{}", out, b.key.to_string()), ": "), b.val.to_string());
        }
        i = (i + 1);
    }
    out = format!("{}{}", out, ")");
    return out.clone()
};
        hashmap_set(&mut g_hm, 1, 10);
        hashmap_set(&mut g_hm, 2, 20);
        hashmap_set(&mut g_hm, 3, 30);
        println!("{}", hashmap_repr(&g_hm));
        println!("{}", hashmap_get(&mut g_hm, 2).to_string());
        hashmap_del(&mut g_hm, 1);
        println!("{}", hashmap_repr(&g_hm));
        println!("{}", hashmap_len(&g_hm).to_string());
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
