// Generated by Mochi transpiler v0.10.61
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start: i64 = _now();
    fn slice_without_last(mut xs: Vec<f64>) -> Vec<f64> {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < ((xs.len() as i64) - 1)) {
        res = { let mut _v = res.clone(); _v.push(xs[i as usize]); _v };
        i = (i + 1);
    }
    return res
};
    fn parse_float(mut token: String) -> f64 {
    let mut sign: f64 = 1.0;
    let mut idx: i64 = 0;
    if ((token.len() as i64) > 0) {
        let mut first: String = { let tmp = &token; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone();
        if (first.as_str() == "-") {
            sign = -1.0;
            idx = 1;
        } else if (first.as_str() == "+") {
            idx = 1;
        }
    }
    let mut int_part: i64 = 0;
    while ((idx < (token.len() as i64)) && ({ let tmp = &token; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }.as_str() != ".")) {
        int_part = ((int_part * 10) + { let n: i64 = { let tmp = &token; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }.parse().unwrap(); n });
        idx = (idx + 1);
    }
    let mut result: f64 = (1.0 * (int_part as f64));
    if ((idx < (token.len() as i64)) && ({ let tmp = &token; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }.as_str() == ".")) {
        idx = (idx + 1);
        let mut place: f64 = 0.1;
        while (idx < (token.len() as i64)) {
            let mut digit = { let n: i64 = { let tmp = &token; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }.parse().unwrap(); n };
            result = (result + (place * (1.0 * (digit as f64))));
            place = (place / 10.0);
            idx = (idx + 1);
        }
    }
    return (sign * result)
};
    fn pow_float(mut base: f64, mut exp: f64) -> f64 {
    let mut result: f64 = 1.0;
    let mut i: i64 = 0;
    let mut e: i64 = (exp as i64);
    while (i < e) {
        result = (result * base);
        i = (i + 1);
    }
    return result
};
    fn apply_op(mut a: f64, mut b: f64, op: &str) -> f64 {
    if (op == "+") {
        return (a + b)
    }
    if (op == "-") {
        return (a - b)
    }
    if (op == "*") {
        return (a * b)
    }
    if (op == "/") {
        return (a / b)
    }
    if (op == "^") {
        return pow_float(a, b)
    }
    return 0.0
};
    fn evaluate(mut tokens: Vec<String>) -> f64 {
    if ((tokens.len() as i64) == 0) {
        return 0.0
    }
    let mut stack: Vec<f64> = vec![];
    for token in tokens.iter().cloned() {
        if (((((token.as_str() == "+") || (token.as_str() == "-")) || (token.as_str() == "*")) || (token.as_str() == "/")) || (token.as_str() == "^")) {
            if (((token.as_str() == "+") || (token.as_str() == "-")) && ((stack.len() as i64) < 2)) {
                let mut b: f64 = stack[((stack.len() as i64) - 1) as usize];
                stack = slice_without_last(stack.clone());
                if (token.as_str() == "-") {
                    stack = { let mut _v = stack.clone(); _v.push((0.0 - b)); _v };
                } else {
                    stack = { let mut _v = stack.clone(); _v.push(b); _v };
                }
            } else {
                let mut b: f64 = stack[((stack.len() as i64) - 1) as usize];
                stack = slice_without_last(stack.clone());
                let mut a: f64 = stack[((stack.len() as i64) - 1) as usize];
                stack = slice_without_last(stack.clone());
                let mut result: f64 = apply_op(a, b, &token);
                stack = { let mut _v = stack.clone(); _v.push(result); _v };
            }
        } else {
            stack = { let mut _v = stack.clone(); _v.push(parse_float(token.clone())); _v };
        }
    }
    if ((stack.len() as i64) != 1) {
        panic!("Invalid postfix expression");
    }
    return stack[0 as usize]
};
    println!("{}", evaluate(vec![String::from("2"), String::from("1"), String::from("+"), String::from("3"), String::from("*")]).to_string());
    println!("{}", evaluate(vec![String::from("4"), String::from("13"), String::from("5"), String::from("/"), String::from("+")]).to_string());
    println!("{}", evaluate(vec![String::from("5"), String::from("6"), String::from("9"), String::from("*"), String::from("+")]).to_string());
    println!("{}", evaluate(vec![String::from("2"), String::from("-"), String::from("3"), String::from("+")]).to_string());
    println!("{}", evaluate(vec![]).to_string());
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
