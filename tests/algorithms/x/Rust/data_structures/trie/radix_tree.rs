// Generated by Mochi transpiler v0.10.72
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct RadixNode {
    prefix: String,
    is_leaf: bool,
    children: HashMap<String, i64>,
}
impl std::fmt::Display for RadixNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"prefix\": \"{}\"", self.prefix)?;
        write!(f, ", ")?;
        write!(f, "\"is_leaf\": {}", self.is_leaf)?;
        write!(f, ", ")?;
        write!(f, "\"children\": {:?}", self.children)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct RadixTree {
    nodes: Vec<RadixNode>,
}
impl std::fmt::Display for RadixTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"nodes\": {:?}", self.nodes)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct MatchResult {
    common: String,
    rem_prefix: String,
    rem_word: String,
}
impl std::fmt::Display for MatchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"common\": \"{}\"", self.common)?;
        write!(f, ", ")?;
        write!(f, "\"rem_prefix\": \"{}\"", self.rem_prefix)?;
        write!(f, ", ")?;
        write!(f, "\"rem_word\": \"{}\"", self.rem_word)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn new_node(mut prefix: String, mut is_leaf: bool) -> RadixNode {
    return RadixNode {prefix: prefix.clone(), is_leaf: is_leaf, children: HashMap::new()}
};
    fn new_tree() -> RadixTree {
    let mut nodes: Vec<RadixNode> = vec![new_node(String::new(), false).clone()];
    return RadixTree {nodes: nodes.clone()}
};
    fn match_prefix(mut node: RadixNode, mut word: String) -> MatchResult {
    let mut x: i64 = 0;
    let mut p: String = node.prefix.clone().clone();
    let mut w: String = word.clone();
    let mut min_len: i64 = (p.len() as i64);
    if ((w.len() as i64) < min_len) {
        min_len = (w.len() as i64);
    }
    while (x < min_len) {
        if ({ let tmp = &p; tmp.chars().skip(x as usize).take(((x + 1) - x) as usize).collect::<String>() }.as_str() != { let tmp = &w; tmp.chars().skip(x as usize).take(((x + 1) - x) as usize).collect::<String>() }.as_str()) {
            break
        }
        x = (x + 1);
    }
    let common: String = { let tmp = &p; tmp.chars().skip(0 as usize).take((x - 0) as usize).collect::<String>() }.clone();
    let rem_prefix: String = { let tmp = &p; tmp.chars().skip(x as usize).take(((p.len() as i64) - x) as usize).collect::<String>() }.clone();
    let rem_word: String = { let tmp = &w; tmp.chars().skip(x as usize).take(((w.len() as i64) - x) as usize).collect::<String>() }.clone();
    return MatchResult {common: common.clone(), rem_prefix: rem_prefix.clone(), rem_word: rem_word.clone()}
};
    fn insert_many(mut tree: RadixTree, mut words: Vec<String>) {
    for w in words.iter().cloned() {
        insert(&mut tree.clone(), 0, w.clone());
    }
};
    fn insert(tree: &mut RadixTree, mut idx: i64, mut word: String) {
    let mut nodes: Vec<RadixNode> = tree.nodes.clone();
    let mut node: RadixNode = nodes[idx as usize].clone();
    if ((node.prefix.clone().as_str() == word.as_str()) && !node.is_leaf) {
        node.is_leaf = true;
        nodes[idx as usize] = node.clone();
        (*tree).nodes = nodes.clone();
        return
    }
    let first: String = { let tmp = &word; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone();
    let mut children: HashMap<String, i64> = node.children.clone();
    if !has_key(children.clone(), first.clone()) {
        let new_idx: i64 = (nodes.len() as i64);
        nodes = { let mut _v = nodes.clone(); _v.push(new_node(word.clone(), true)); _v };
        children.insert(first.clone(), new_idx.clone());
        node.children = children.clone();
        nodes[idx as usize] = node.clone();
        (*tree).nodes = nodes.clone();
        return
    }
    let child_idx: i64 = children.get(first.as_str()).cloned().unwrap_or_default();
    let mut child: RadixNode = nodes[child_idx as usize].clone();
    let res: MatchResult = match_prefix(child.clone(), word.clone());
    if (res.rem_prefix.clone().as_str() == "") {
        insert(tree, child_idx, res.rem_word.clone());
        return
    }
    child.prefix = res.rem_prefix.clone();
    nodes[child_idx as usize] = child.clone();
    let mut new_children: HashMap<String, i64> = HashMap::new();
    new_children.insert({ let tmp = &res.rem_prefix; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone(), child_idx.clone());
    let new_idx: i64 = (nodes.len() as i64);
    nodes = { let mut _v = nodes.clone(); _v.push(new_node(res.common.clone(), false)); _v };
    nodes[new_idx as usize].children = new_children.clone();
    if (res.rem_word.clone().as_str() == "") {
        nodes[new_idx as usize].is_leaf = true;
    } else {
        insert(tree, new_idx, res.rem_word.clone());
    }
    children.insert(first.clone(), new_idx.clone());
    node.children = children.clone();
    nodes[idx as usize] = node.clone();
    (*tree).nodes = nodes.clone();
};
    fn find(mut tree: RadixTree, mut idx: i64, mut word: String) -> bool {
    let mut nodes: Vec<RadixNode> = tree.nodes.clone();
    let node: RadixNode = nodes[idx as usize].clone();
    let first: String = { let tmp = &word; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone();
    let children: HashMap<String, i64> = node.children.clone();
    if !has_key(children.clone(), first.clone()) {
        return false
    }
    let child_idx: i64 = children.get(first.as_str()).cloned().unwrap_or_default();
    let child: RadixNode = nodes[child_idx as usize].clone();
    let res: MatchResult = match_prefix(child.clone(), word.clone());
    if (res.rem_prefix.clone().as_str() != "") {
        return false
    }
    if (res.rem_word.clone().as_str() == "") {
        return child.is_leaf
    }
    return find(tree.clone(), child_idx, res.rem_word.clone())
};
    fn remove_key(mut m: HashMap<String, i64>, mut k: String) -> HashMap<String, i64> {
    let mut out: HashMap<String, i64> = HashMap::new();
    for key in m.keys().cloned() {
        if (key.as_str() != k.as_str()) {
            out.insert(key.clone(), m.get(key.as_str()).cloned().unwrap_or_default());
        }
    }
    return out
};
    fn has_key(mut m: HashMap<String, i64>, mut k: String) -> bool {
    for key in m.keys().cloned() {
        if (key.as_str() == k.as_str()) {
            return true
        }
    }
    return false
};
    fn delete(tree: &mut RadixTree, mut idx: i64, mut word: String) -> bool {
    let mut nodes: Vec<RadixNode> = tree.nodes.clone();
    let mut node: RadixNode = nodes[idx as usize].clone();
    let first: String = { let tmp = &word; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.clone();
    let mut children: HashMap<String, i64> = node.children.clone();
    if !has_key(children.clone(), first.clone()) {
        return false
    }
    let child_idx: i64 = children.get(first.as_str()).cloned().unwrap_or_default();
    let mut child: RadixNode = nodes[child_idx as usize].clone();
    let res: MatchResult = match_prefix(child.clone(), word.clone());
    if (res.rem_prefix.clone().as_str() != "") {
        return false
    }
    if (res.rem_word.clone().as_str() != "") {
        let deleted: bool = delete(tree, child_idx, res.rem_word.clone());
        if deleted {
            nodes = tree.nodes.clone();
            node = nodes[idx as usize].clone();
        }
        return deleted
    }
    if !child.is_leaf {
        return false
    }
    if ((child.children.clone().len() as i64) == 0) {
        children = remove_key(children.clone(), first.clone());
        node.children = children.clone();
        nodes[idx as usize] = node.clone();
        (*tree).nodes = nodes.clone();
        if (((children.len() as i64) == 1) && !node.is_leaf) {
            let mut only_key: String = String::new();
            for k in children.keys().cloned() {
                only_key = k.clone();
            }
            let merge_idx: i64 = children.get(only_key.as_str()).cloned().unwrap_or_default();
            let merge_node: RadixNode = nodes[merge_idx as usize].clone();
            node.is_leaf = merge_node.is_leaf;
            node.prefix = format!("{}{}", node.prefix.clone(), merge_node.prefix.clone());
            node.children = merge_node.children.clone();
            nodes[idx as usize] = node.clone();
            (*tree).nodes = nodes.clone();
        }
    } else if ((child.children.clone().len() as i64) > 1) {
        child.is_leaf = false;
        nodes[child_idx as usize] = child.clone();
        (*tree).nodes = nodes.clone();
    } else {
        let mut only_key: String = String::new();
        for k in child.children.clone().keys().cloned() {
            only_key = k.clone();
        }
        let merge_idx: i64 = child.children.clone()[only_key.as_str()];
        let merge_node: RadixNode = nodes[merge_idx as usize].clone();
        child.is_leaf = merge_node.is_leaf;
        child.prefix = format!("{}{}", child.prefix.clone(), merge_node.prefix.clone());
        child.children = merge_node.children.clone();
        nodes[child_idx as usize] = child.clone();
        (*tree).nodes = nodes.clone();
    }
    return true
};
    fn print_tree(mut tree: RadixTree, mut idx: i64, mut height: i64) {
    let mut nodes: Vec<RadixNode> = tree.nodes.clone();
    let node: RadixNode = nodes[idx as usize].clone();
    if (node.prefix.clone().as_str() != "") {
        let mut line: String = String::new();
        let mut i: i64 = 0;
        while (i < height) {
            line = format!("{}{}", line, "-");
            i = (i + 1);
        }
        line = format!("{}{}", format!("{}{}", line, " "), node.prefix.clone());
        if node.is_leaf {
            line = format!("{}{}", line, "  (leaf)");
        }
        println!("{}", line);
    }
    let children: HashMap<String, i64> = node.children.clone();
    for k in children.keys().cloned() {
        let child_idx: i64 = children.get(k.as_str()).cloned().unwrap_or_default();
        print_tree(tree.clone(), child_idx, (height + 1));
    }
};
    fn test_trie() -> bool {
    let words: Vec<String> = vec![String::from("banana").clone(), String::from("bananas").clone(), String::from("bandana").clone(), String::from("band").clone(), String::from("apple").clone(), String::from("all").clone(), String::from("beast").clone()];
    let mut tree: RadixTree = new_tree();
    insert_many(tree.clone(), words.clone());
    let mut ok: bool = true;
    for w in words.iter().cloned() {
        if !find(tree.clone(), 0, w.clone()) {
            ok = false;
        }
    }
    if find(tree.clone(), 0, String::from("bandanas")) {
        ok = false;
    }
    if find(tree.clone(), 0, String::from("apps")) {
        ok = false;
    }
    delete(&mut tree, 0, String::from("all"));
    if find(tree.clone(), 0, String::from("all")) {
        ok = false;
    }
    delete(&mut tree, 0, String::from("banana"));
    if find(tree.clone(), 0, String::from("banana")) {
        ok = false;
    }
    if !find(tree.clone(), 0, String::from("bananas")) {
        ok = false;
    }
    return ok
};
    fn pytests() {
    if !test_trie() {
        panic!("test failed");
    }
};
    let mut mochi_main = || {
    let mut tree: RadixTree = new_tree();
    let words: Vec<String> = vec![String::from("banana").clone(), String::from("bananas").clone(), String::from("bandanas").clone(), String::from("bandana").clone(), String::from("band").clone(), String::from("apple").clone(), String::from("all").clone(), String::from("beast").clone()];
    insert_many(tree.clone(), words.clone());
    println!("{}", format!("{}{}", "Words: ", format!("{:?}", words)));
    println!("{}", "Tree:");
    print_tree(tree.clone(), 0, 0);
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
