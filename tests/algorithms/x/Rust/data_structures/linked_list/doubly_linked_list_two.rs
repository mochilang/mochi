// Generated by Mochi transpiler v0.10.72
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Node {
    data: i64,
    prev_index: i64,
    next_index: i64,
}
impl std::fmt::Display for Node {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"data\": {}", self.data)?;
        write!(f, ", ")?;
        write!(f, "\"prev_index\": {}", self.prev_index)?;
        write!(f, ", ")?;
        write!(f, "\"next_index\": {}", self.next_index)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct LinkedList {
    nodes: Vec<Node>,
    head_idx: i64,
    tail_idx: i64,
}
impl std::fmt::Display for LinkedList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"nodes\": {:?}", self.nodes)?;
        write!(f, ", ")?;
        write!(f, "\"head_idx\": {}", self.head_idx)?;
        write!(f, ", ")?;
        write!(f, "\"tail_idx\": {}", self.tail_idx)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn empty_list() -> LinkedList {
    return LinkedList {nodes: vec![], head_idx: -1, tail_idx: -1}
};
    fn get_head_data(mut ll: LinkedList) -> i64 {
    if (ll.head_idx == -1) {
        return -1
    }
    let node: Node = ll.nodes.clone()[ll.head_idx as usize].clone();
    return node.data
};
    fn get_tail_data(mut ll: LinkedList) -> i64 {
    if (ll.tail_idx == -1) {
        return -1
    }
    let node: Node = ll.nodes.clone()[ll.tail_idx as usize].clone();
    return node.data
};
    fn insert_before_node(ll: &mut LinkedList, mut idx: i64, mut new_idx: i64) {
    let mut nodes: Vec<Node> = ll.nodes.clone();
    let mut new_node: Node = nodes[new_idx as usize].clone();
    new_node.next_index = idx;
    let mut node: Node = nodes[idx as usize].clone();
    let p: i64 = node.prev_index;
    new_node.prev_index = p;
    nodes[new_idx as usize] = new_node.clone();
    if (p == -1) {
        (*ll).head_idx = new_idx;
    } else {
        let mut prev_node: Node = nodes[p as usize].clone();
        prev_node.next_index = new_idx;
        nodes[p as usize] = prev_node.clone();
    }
    node.prev_index = new_idx;
    nodes[idx as usize] = node.clone();
    (*ll).nodes = nodes.clone();
};
    fn insert_after_node(ll: &mut LinkedList, mut idx: i64, mut new_idx: i64) {
    let mut nodes: Vec<Node> = ll.nodes.clone();
    let mut new_node: Node = nodes[new_idx as usize].clone();
    new_node.prev_index = idx;
    let mut node: Node = nodes[idx as usize].clone();
    let nxt: i64 = node.next_index;
    new_node.next_index = nxt;
    nodes[new_idx as usize] = new_node.clone();
    if (nxt == -1) {
        (*ll).tail_idx = new_idx;
    } else {
        let mut next_node: Node = nodes[nxt as usize].clone();
        next_node.prev_index = new_idx;
        nodes[nxt as usize] = next_node.clone();
    }
    node.next_index = new_idx;
    nodes[idx as usize] = node.clone();
    (*ll).nodes = nodes.clone();
};
    fn set_head(ll: &mut LinkedList, mut idx: i64) {
    if (ll.head_idx == -1) {
        (*ll).head_idx = idx;
        (*ll).tail_idx = idx;
    } else {
        insert_before_node(ll, ll.clone().head_idx, idx);
    }
};
    fn set_tail(ll: &mut LinkedList, mut idx: i64) {
    if (ll.tail_idx == -1) {
        (*ll).head_idx = idx;
        (*ll).tail_idx = idx;
    } else {
        insert_after_node(ll, ll.clone().tail_idx, idx);
    }
};
    fn insert(ll: &mut LinkedList, mut value: i64) {
    let mut nodes: Vec<Node> = ll.nodes.clone();
    nodes = { let mut _v = nodes.clone(); _v.push(Node {data: value, prev_index: -1, next_index: -1}); _v };
    let idx: i64 = ((nodes.len() as i64) - 1);
    (*ll).nodes = nodes.clone();
    if (ll.head_idx == -1) {
        (*ll).head_idx = idx;
        (*ll).tail_idx = idx;
    } else {
        insert_after_node(ll, ll.clone().tail_idx, idx);
    }
};
    fn insert_at_position(ll: &mut LinkedList, mut position: i64, mut value: i64) {
    let mut current: i64 = ll.head_idx;
    let mut current_pos: i64 = 1;
    while (current != -1) {
        if (current_pos == position) {
            let mut nodes: Vec<Node> = ll.nodes.clone();
            nodes = { let mut _v = nodes.clone(); _v.push(Node {data: value, prev_index: -1, next_index: -1}); _v };
            let new_idx: i64 = ((nodes.len() as i64) - 1);
            (*ll).nodes = nodes.clone();
            insert_before_node(ll, current, new_idx);
            return
        }
        let node: Node = ll.nodes.clone()[current as usize].clone();
        current = node.next_index;
        current_pos = (current_pos + 1);
    }
    insert(ll, value);
};
    fn get_node(mut ll: LinkedList, mut item: i64) -> i64 {
    let mut current: i64 = ll.head_idx;
    while (current != -1) {
        let node: Node = ll.nodes.clone()[current as usize].clone();
        if (node.data == item) {
            return current
        }
        current = node.next_index;
    }
    return -1
};
    fn remove_node_pointers(ll: &mut LinkedList, mut idx: i64) {
    let mut nodes: Vec<Node> = ll.nodes.clone();
    let mut node: Node = nodes[idx as usize].clone();
    let nxt: i64 = node.next_index;
    let p: i64 = node.prev_index;
    if (nxt != -1) {
        let mut nxt_node: Node = nodes[nxt as usize].clone();
        nxt_node.prev_index = p;
        nodes[nxt as usize] = nxt_node.clone();
    }
    if (p != -1) {
        let mut prev_node: Node = nodes[p as usize].clone();
        prev_node.next_index = nxt;
        nodes[p as usize] = prev_node.clone();
    }
    node.next_index = -1;
    node.prev_index = -1;
    nodes[idx as usize] = node.clone();
    (*ll).nodes = nodes.clone();
};
    fn delete_value(ll: &mut LinkedList, mut value: i64) {
    let idx: i64 = get_node(ll.clone(), value);
    if (idx == -1) {
        return
    }
    if (idx == ll.head_idx) {
        let node: Node = ll.nodes.clone()[idx as usize].clone();
        (*ll).head_idx = node.next_index;
    }
    if (idx == ll.tail_idx) {
        let node: Node = ll.nodes.clone()[idx as usize].clone();
        (*ll).tail_idx = node.prev_index;
    }
    remove_node_pointers(ll, idx);
};
    fn contains(mut ll: LinkedList, mut value: i64) -> bool {
    return (get_node(ll.clone(), value) != -1)
};
    fn is_empty(mut ll: LinkedList) -> bool {
    return (ll.head_idx == -1)
};
    fn to_string(mut ll: LinkedList) -> String {
    let mut res: String = String::new();
    let mut first: bool = true;
    let mut current: i64 = ll.head_idx;
    while (current != -1) {
        let node: Node = ll.nodes.clone()[current as usize].clone();
        let val: String = node.data.to_string().clone();
        if first {
            res = val.clone();
            first = false;
        } else {
            res = format!("{}{}", format!("{}{}", res, " "), val);
        }
        current = node.next_index;
    }
    return res.clone()
};
    fn print_list(mut ll: LinkedList) {
    let mut current: i64 = ll.head_idx;
    while (current != -1) {
        let node: Node = ll.nodes.clone()[current as usize].clone();
        println!("{}", node.data.to_string());
        current = node.next_index;
    }
};
    let mut mochi_main = || {
    let mut ll: LinkedList = empty_list();
    println!("{}", get_head_data(ll.clone()).to_string());
    println!("{}", get_tail_data(ll.clone()).to_string());
    println!("{}", is_empty(ll.clone()).to_string());
    insert(&mut ll, 10);
    println!("{}", get_head_data(ll.clone()).to_string());
    println!("{}", get_tail_data(ll.clone()).to_string());
    insert_at_position(&mut ll, 3, 20);
    println!("{}", get_head_data(ll.clone()).to_string());
    println!("{}", get_tail_data(ll.clone()).to_string());
    let mut nodes: Vec<Node> = ll.nodes.clone();
    nodes = { let mut _v = nodes.clone(); _v.push(Node {data: 1000, prev_index: -1, next_index: -1}); _v };
    let idx_head: i64 = ((nodes.len() as i64) - 1);
    ll.nodes = nodes.clone();
    set_head(&mut ll, idx_head);
    nodes = ll.nodes.clone();
    nodes = { let mut _v = nodes.clone(); _v.push(Node {data: 2000, prev_index: -1, next_index: -1}); _v };
    let idx_tail: i64 = ((nodes.len() as i64) - 1);
    ll.nodes = nodes.clone();
    set_tail(&mut ll, idx_tail);
    print_list(ll.clone());
    println!("{}", is_empty(ll.clone()).to_string());
    print_list(ll.clone());
    println!("{}", contains(ll.clone(), 10).to_string());
    delete_value(&mut ll, 10);
    println!("{}", contains(ll.clone(), 10).to_string());
    delete_value(&mut ll, 2000);
    println!("{}", get_tail_data(ll.clone()).to_string());
    delete_value(&mut ll, 1000);
    println!("{}", get_tail_data(ll.clone()).to_string());
    println!("{}", get_head_data(ll.clone()).to_string());
    print_list(ll.clone());
    delete_value(&mut ll, 20);
    print_list(ll.clone());
    let mut i: i64 = 1;
    while (i < 10) {
        insert(&mut ll, i);
        i = (i + 1);
    }
    print_list(ll.clone());
    let mut ll2: LinkedList = empty_list();
    insert_at_position(&mut ll2, 1, 10);
    println!("{}", to_string(ll2.clone()));
    insert_at_position(&mut ll2, 2, 20);
    println!("{}", to_string(ll2.clone()));
    insert_at_position(&mut ll2, 1, 30);
    println!("{}", to_string(ll2.clone()));
    insert_at_position(&mut ll2, 3, 40);
    println!("{}", to_string(ll2.clone()));
    insert_at_position(&mut ll2, 5, 50);
    println!("{}", to_string(ll2.clone()));
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
