// Generated by Mochi transpiler v0.10.60
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_nodes: Vec<HashMap<String, i64>> = Vec::new();
fn main() {
    unsafe {
        g_nodes = vec![];
                let _start: i64 = _now();
        let mut NIL: i64 = (0 - 1);
        let new_node = move |value: i64| -> i64 {
    let mut node: HashMap<String, i64> = HashMap::from([(String::from("data"), value), (String::from("left"), NIL), (String::from("right"), NIL), (String::from("height"), 1)]);
    g_nodes = { let mut _v = g_nodes.clone().clone(); _v.push(node.clone()); _v };
    return ((g_nodes.clone().len() as i64) - 1)
};
        let get_height = move |i: i64| -> i64 {
    if (i == NIL) {
        return 0
    }
    return g_nodes.clone()[i as usize].clone()["height"]
};
        let my_max = move |a: i64, b: i64| -> i64 {
    if (a > b) {
        return a
    }
    return b
};
        let update_height = move |i: i64| {
    g_nodes[i as usize].insert(String::from("height"), (my_max(get_height(g_nodes.clone()[i as usize].clone()["left"]), get_height(g_nodes.clone()[i as usize].clone()["right"])) + 1));
};
        let right_rotation = move |i: i64| -> i64 {
    let mut left: i64 = g_nodes.clone()[i as usize].clone()["left"];
    g_nodes[i as usize].insert(String::from("left"), g_nodes.clone()[left as usize].clone()["right"]);
    g_nodes[left as usize].insert(String::from("right"), i);
    update_height(i);
    update_height(left);
    return left
};
        let left_rotation = move |i: i64| -> i64 {
    let mut right: i64 = g_nodes.clone()[i as usize].clone()["right"];
    g_nodes[i as usize].insert(String::from("right"), g_nodes.clone()[right as usize].clone()["left"]);
    g_nodes[right as usize].insert(String::from("left"), i);
    update_height(i);
    update_height(right);
    return right
};
        let lr_rotation = move |i: i64| -> i64 {
    g_nodes[i as usize].insert(String::from("left"), left_rotation(g_nodes.clone()[i as usize].clone()["left"]));
    return right_rotation(i)
};
        let rl_rotation = move |i: i64| -> i64 {
    g_nodes[i as usize].insert(String::from("right"), right_rotation(g_nodes.clone()[i as usize].clone()["right"]));
    return left_rotation(i)
};
        let insert_node = move |i: i64, value: i64| -> i64 {
    if (i == NIL) {
        return new_node(value)
    }
    if (value < g_nodes.clone()[i as usize].clone()["data"]) {
        g_nodes[i as usize].insert(String::from("left"), insert_node(g_nodes.clone()[i as usize].clone()["left"], value));
        if ((get_height(g_nodes.clone()[i as usize].clone()["left"]) - get_height(g_nodes.clone()[i as usize].clone()["right"])) == 2) {
            if (value < g_nodes.clone()[g_nodes.clone()[i as usize].clone()["left"] as usize].clone()["data"]) {
                i = right_rotation(i);
            } else {
                i = lr_rotation(i);
            }
        }
    } else {
        g_nodes[i as usize].insert(String::from("right"), insert_node(g_nodes.clone()[i as usize].clone()["right"], value));
        if ((get_height(g_nodes.clone()[i as usize].clone()["right"]) - get_height(g_nodes.clone()[i as usize].clone()["left"])) == 2) {
            if (value < g_nodes.clone()[g_nodes.clone()[i as usize].clone()["right"] as usize].clone()["data"]) {
                i = rl_rotation(i);
            } else {
                i = left_rotation(i);
            }
        }
    }
    update_height(i);
    return i
};
        let get_left_most = move |i: i64| -> i64 {
    let mut cur: i64 = i;
    while (g_nodes.clone()[cur as usize].clone()["left"] != NIL) {
        cur = g_nodes.clone()[cur as usize].clone()["left"];
    }
    return g_nodes.clone()[cur as usize].clone()["data"]
};
        let del_node = move |i: i64, value: i64| -> i64 {
    if (i == NIL) {
        return NIL
    }
    if (value < g_nodes.clone()[i as usize].clone()["data"]) {
        g_nodes[i as usize].insert(String::from("left"), del_node(g_nodes.clone()[i as usize].clone()["left"], value));
    } else if (value > g_nodes.clone()[i as usize].clone()["data"]) {
        g_nodes[i as usize].insert(String::from("right"), del_node(g_nodes.clone()[i as usize].clone()["right"], value));
    } else {
        if ((g_nodes.clone()[i as usize].clone()["left"] != NIL) && (g_nodes.clone()[i as usize].clone()["right"] != NIL)) {
            let mut temp: i64 = get_left_most(g_nodes.clone()[i as usize].clone()["right"]);
            g_nodes[i as usize].insert(String::from("data"), temp);
            g_nodes[i as usize].insert(String::from("right"), del_node(g_nodes.clone()[i as usize].clone()["right"], temp));
        } else if (g_nodes.clone()[i as usize].clone()["left"] != NIL) {
            i = g_nodes.clone()[i as usize].clone()["left"];
        } else {
            i = g_nodes.clone()[i as usize].clone()["right"];
        }
    }
    if (i == NIL) {
        return NIL
    }
    let mut lh: i64 = get_height(g_nodes.clone()[i as usize].clone()["left"]);
    let mut rh: i64 = get_height(g_nodes.clone()[i as usize].clone()["right"]);
    if ((rh - lh) == 2) {
        if (get_height(g_nodes.clone()[g_nodes.clone()[i as usize].clone()["right"] as usize].clone()["right"]) > get_height(g_nodes.clone()[g_nodes.clone()[i as usize].clone()["right"] as usize].clone()["left"])) {
            i = left_rotation(i);
        } else {
            i = rl_rotation(i);
        }
    } else if ((lh - rh) == 2) {
        if (get_height(g_nodes.clone()[g_nodes.clone()[i as usize].clone()["left"] as usize].clone()["left"]) > get_height(g_nodes.clone()[g_nodes.clone()[i as usize].clone()["left"] as usize].clone()["right"])) {
            i = right_rotation(i);
        } else {
            i = lr_rotation(i);
        }
    }
    update_height(i);
    return i
};
        let inorder = move |i: i64| -> String {
    if (i == NIL) {
        return String::from("")
    }
    let mut left: String = inorder(g_nodes.clone()[i as usize].clone()["left"]).clone();
    let mut right: String = inorder(g_nodes.clone()[i as usize].clone()["right"]).clone();
    let mut res = g_nodes.clone()[i as usize].clone()["data"].to_string();
    if (left.as_str() != "") {
        res = format!("{}{}", format!("{}{}", left, " "), res);
    }
    if (right.as_str() != "") {
        res = format!("{}{}", format!("{}{}", res, " "), right);
    }
    return res.clone()
};
        let mochi_main = move || {
    let mut nodes: Vec<i64> = vec![];
    let mut root: i64 = NIL;
    root = insert_node(root, 4);
    root = insert_node(root, 2);
    root = insert_node(root, 3);
    println!("{}", inorder(root));
    println!("{}", get_height(root).to_string());
    root = del_node(root, 3);
    println!("{}", inorder(root));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
