// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Tree {
    values: Vec<i64>,
    lefts: Vec<i64>,
    rights: Vec<i64>,
    root: i64,
}
impl std::fmt::Display for Tree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"values\": {:?}", self.values)?;
        write!(f, ", ")?;
        write!(f, "\"lefts\": {:?}", self.lefts)?;
        write!(f, ", ")?;
        write!(f, "\"rights\": {:?}", self.rights)?;
        write!(f, ", ")?;
        write!(f, "\"root\": {}", self.root)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Pair {
    idx: i64,
    hd: i64,
}
impl std::fmt::Display for Pair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"idx\": {}", self.idx)?;
        write!(f, ", ")?;
        write!(f, "\"hd\": {}", self.hd)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    let mut NIL: i64 = (0 - 1);
    let make_tree = move || -> Tree {
    return Tree {values: vec![3, 9, 20, 15, 7], lefts: vec![1, NIL, 3, NIL, NIL], rights: vec![2, NIL, 4, NIL, NIL], root: 0}
};
    let index_of = move |xs: Vec<i64>, x: i64| -> i64 {
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (xs[i as usize] == x) {
            return i
        }
        i = (i + 1);
    }
    return NIL
};
    let sort_pairs = move |hds: &mut Vec<i64>, vals: &mut Vec<i64>| {
    let mut i: i64 = 0;
    while (i < (hds.len() as i64)) {
        let mut j: i64 = i;
        while ((j > 0) && (hds[(j - 1) as usize] > hds[j as usize])) {
            let mut hd_tmp: i64 = hds[(j - 1) as usize];
            hds[(j - 1) as usize] = hds[j as usize];
            hds[j as usize] = hd_tmp;
            let mut val_tmp: i64 = vals[(j - 1) as usize];
            vals[(j - 1) as usize] = vals[j as usize];
            vals[j as usize] = val_tmp;
            j = (j - 1);
        }
        i = (i + 1);
    }
};
    let right_view = move |t: &Tree| -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut queue: Vec<i64> = vec![t.root];
    while ((queue.len() as i64) > 0) {
        let mut size = (queue.len() as i64);
        let mut i: i64 = 0;
        while (i < size) {
            let mut idx: i64 = queue[i as usize];
            if (t.lefts[idx as usize] != NIL) {
                queue = { let mut _v = queue.clone(); _v.push(t.lefts[idx as usize]); _v };
            }
            if (t.rights[idx as usize] != NIL) {
                queue = { let mut _v = queue.clone(); _v.push(t.rights[idx as usize]); _v };
            }
            i = (i + 1);
        }
        res = { let mut _v = res.clone(); _v.push(t.values[queue[(size - 1) as usize] as usize]); _v };
        queue = queue[size as usize..(queue.len() as i64) as usize].to_vec();
    }
    return res
};
    let left_view = move |t: &Tree| -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut queue: Vec<i64> = vec![t.root];
    while ((queue.len() as i64) > 0) {
        let mut size = (queue.len() as i64);
        let mut i: i64 = 0;
        while (i < size) {
            let mut idx: i64 = queue[i as usize];
            if (t.lefts[idx as usize] != NIL) {
                queue = { let mut _v = queue.clone(); _v.push(t.lefts[idx as usize]); _v };
            }
            if (t.rights[idx as usize] != NIL) {
                queue = { let mut _v = queue.clone(); _v.push(t.rights[idx as usize]); _v };
            }
            i = (i + 1);
        }
        res = { let mut _v = res.clone(); _v.push(t.values[queue[0 as usize] as usize]); _v };
        queue = queue[size as usize..(queue.len() as i64) as usize].to_vec();
    }
    return res
};
    let top_view = move |t: &Tree| -> Vec<i64> {
    let mut hds: Vec<i64> = vec![];
    let mut vals: Vec<i64> = vec![];
    let mut queue_idx: Vec<i64> = vec![t.root];
    let mut queue_hd: Vec<i64> = vec![0];
    while ((queue_idx.len() as i64) > 0) {
        let mut idx: i64 = queue_idx[0 as usize];
        queue_idx = queue_idx[1 as usize..(queue_idx.len() as i64) as usize].to_vec();
        let mut hd: i64 = queue_hd[0 as usize];
        queue_hd = queue_hd[1 as usize..(queue_hd.len() as i64) as usize].to_vec();
        if (index_of(hds.clone(), hd) == NIL) {
            hds = { let mut _v = hds.clone(); _v.push(hd); _v };
            vals = { let mut _v = vals.clone(); _v.push(t.values[idx as usize]); _v };
        }
        if (t.lefts[idx as usize] != NIL) {
            queue_idx = { let mut _v = queue_idx.clone(); _v.push(t.lefts[idx as usize]); _v };
            queue_hd = { let mut _v = queue_hd.clone(); _v.push((hd - 1)); _v };
        }
        if (t.rights[idx as usize] != NIL) {
            queue_idx = { let mut _v = queue_idx.clone(); _v.push(t.rights[idx as usize]); _v };
            queue_hd = { let mut _v = queue_hd.clone(); _v.push((hd + 1)); _v };
        }
    }
    sort_pairs(&mut hds, &mut vals);
    return vals
};
    let bottom_view = move |t: &Tree| -> Vec<i64> {
    let mut hds: Vec<i64> = vec![];
    let mut vals: Vec<i64> = vec![];
    let mut queue_idx: Vec<i64> = vec![t.root];
    let mut queue_hd: Vec<i64> = vec![0];
    while ((queue_idx.len() as i64) > 0) {
        let mut idx: i64 = queue_idx[0 as usize];
        queue_idx = queue_idx[1 as usize..(queue_idx.len() as i64) as usize].to_vec();
        let mut hd: i64 = queue_hd[0 as usize];
        queue_hd = queue_hd[1 as usize..(queue_hd.len() as i64) as usize].to_vec();
        let mut pos: i64 = index_of(hds.clone(), hd);
        if (pos == NIL) {
            hds = { let mut _v = hds.clone(); _v.push(hd); _v };
            vals = { let mut _v = vals.clone(); _v.push(t.values[idx as usize]); _v };
        } else {
            vals[pos as usize] = t.values[idx as usize];
        }
        if (t.lefts[idx as usize] != NIL) {
            queue_idx = { let mut _v = queue_idx.clone(); _v.push(t.lefts[idx as usize]); _v };
            queue_hd = { let mut _v = queue_hd.clone(); _v.push((hd - 1)); _v };
        }
        if (t.rights[idx as usize] != NIL) {
            queue_idx = { let mut _v = queue_idx.clone(); _v.push(t.rights[idx as usize]); _v };
            queue_hd = { let mut _v = queue_hd.clone(); _v.push((hd + 1)); _v };
        }
    }
    sort_pairs(&mut hds, &mut vals);
    return vals
};
    let mut tree: Tree = make_tree();
    println!("{:?}", right_view(&tree));
    println!("{:?}", left_view(&tree));
    println!("{:?}", top_view(&tree));
    println!("{:?}", bottom_view(&tree));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
