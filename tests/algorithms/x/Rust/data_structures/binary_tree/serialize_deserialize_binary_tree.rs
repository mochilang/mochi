// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone)]
enum TreeNode {
    Empty,
    Node { left: Box<TreeNode>, value: i64, right: Box<TreeNode> },
}

#[derive(Debug, Clone, Default)]
struct BuildResult {
    node: TreeNode,
    next: i64,
}
impl std::fmt::Display for BuildResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"node\": {}", self.node)?;
        write!(f, ", ")?;
        write!(f, "\"next\": {}", self.next)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn digit(ch: &str) -> i64 {
    let mut digits: String = String::from("0123456789").clone();
    let mut i: i64 = 0;
    while (i < (digits.len() as i64)) {
        if ({ let tmp = &digits; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return i
        }
        i = (i + 1);
    }
    return 0
};
    fn to_int(mut s: String) -> i64 {
    let mut i: i64 = 0;
    let mut sign: i64 = 1;
    if (((s.len() as i64) > 0) && ({ let tmp = &s; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.as_str() == "-")) {
        sign = -1;
        i = 1;
    }
    let mut num: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        num = ((num * 10) + digit(&ch));
        i = (i + 1);
    }
    return (sign * num)
};
    fn split(s: &str, sep: &str) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut current: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (ch == sep) {
            res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
            current = String::from("");
        } else {
            current = format!("{}{}", current, ch);
        }
        i = (i + 1);
    }
    res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
    return res
};
    fn serialize(node: &TreeNode) -> String {
    return match node { Empty => String::from("null"), TreeNode::Node { left: l, value: v, right: r } => format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", *v.to_string(), ","), serialize(l)), ","), serialize(r)), }.to_string().clone()
};
    fn build(mut nodes: Vec<String>, mut idx: i64) -> BuildResult {
    let mut value: String = nodes[idx as usize].clone().clone();
    if (value.as_str() == "null") {
        return BuildResult {node: TreeNode::Empty, next: (idx + 1)}
    }
    let mut left_res: BuildResult = build(nodes.clone(), (idx + 1));
    let mut right_res: BuildResult = build(nodes.clone(), left_res.next);
    let mut node: TreeNode = TreeNode::Node { left: Box::new(left_res.node.clone()), value: to_int(value.clone()), right: Box::new(right_res.node.clone()) };
    return BuildResult {node: node, next: right_res.next}
};
    fn deserialize(data: &str) -> TreeNode {
    let mut nodes = data.split(",").map(|x| x.to_string()).collect::<Vec<String>>();
    let mut res: BuildResult = build(nodes.clone(), 0);
    return res.node
};
    fn five_tree() -> TreeNode {
    let mut left_child: TreeNode = TreeNode::Node { value: 2, left: Box::new(TreeNode::Empty.clone()), right: Box::new(TreeNode::Empty.clone()) };
    let mut right_left: TreeNode = TreeNode::Node { value: 4, left: Box::new(TreeNode::Empty.clone()), right: Box::new(TreeNode::Empty.clone()) };
    let mut right_right: TreeNode = TreeNode::Node { value: 5, left: Box::new(TreeNode::Empty.clone()), right: Box::new(TreeNode::Empty.clone()) };
    let mut right_child: TreeNode = TreeNode::Node { value: 3, left: Box::new(right_left.clone()), right: Box::new(right_right.clone()) };
    return TreeNode::Node { value: 1, left: Box::new(left_child.clone()), right: Box::new(right_child.clone()) }
};
    fn mochi_main() {
    let mut root: TreeNode = five_tree();
    let mut serial: String = serialize(&root).clone();
    println!("{}", serial);
    let mut rebuilt: TreeNode = deserialize(&serial);
    let mut serial2: String = serialize(&rebuilt).clone();
    println!("{}", serial2);
    println!("{}", if (serial.as_str() == serial2.as_str()) { 1 } else { 0 });
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
