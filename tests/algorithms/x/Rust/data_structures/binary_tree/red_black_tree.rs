// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct RBTree {
    nodes: Vec<Vec<i64>>,
    root: i64,
}
impl std::fmt::Display for RBTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"nodes\": {:?}", self.nodes)?;
        write!(f, ", ")?;
        write!(f, "\"root\": {}", self.root)?;
        write!(f, "}}")
    }
}

static mut g_LABEL: i64 = 0;
static mut g_COLOR: i64 = 0;
static mut g_PARENT: i64 = 0;
static mut g_LEFT: i64 = 0;
static mut g_RIGHT: i64 = 0;
static mut g_NEG_ONE: i64 = 0;
fn main() {
    unsafe {
        g_LABEL = 0;
        g_COLOR = 1;
        g_PARENT = 2;
        g_LEFT = 3;
        g_RIGHT = 4;
        g_NEG_ONE = -1;
                let _start: i64 = _now();
        unsafe fn make_tree() -> RBTree {
    return RBTree {nodes: vec![], root: -1}
};
        unsafe fn rotate_left(mut t: RBTree, mut x: i64) -> RBTree {
    let mut nodes: Vec<Vec<i64>> = t.nodes;
    let mut y: i64 = nodes[x as usize].clone()[g_RIGHT as usize];
    let mut yLeft: i64 = nodes[y as usize].clone()[g_LEFT as usize];
    nodes[x as usize][g_RIGHT as usize] = yLeft;
    if (yLeft != g_NEG_ONE) {
        nodes[yLeft as usize][g_PARENT as usize] = x;
    }
    let mut xParent: i64 = nodes[x as usize].clone()[g_PARENT as usize];
    nodes[y as usize][g_PARENT as usize] = xParent;
    if (xParent == g_NEG_ONE) {
        t.root = y;
    } else if (x == nodes[xParent as usize].clone()[g_LEFT as usize]) {
        nodes[xParent as usize][g_LEFT as usize] = y;
    } else {
        nodes[xParent as usize][g_RIGHT as usize] = y;
    }
    nodes[y as usize][g_LEFT as usize] = x;
    nodes[x as usize][g_PARENT as usize] = y;
    t.nodes = nodes.clone();
    return t
};
        unsafe fn rotate_right(mut t: RBTree, mut x: i64) -> RBTree {
    let mut nodes: Vec<Vec<i64>> = t.nodes;
    let mut y: i64 = nodes[x as usize].clone()[g_LEFT as usize];
    let mut yRight: i64 = nodes[y as usize].clone()[g_RIGHT as usize];
    nodes[x as usize][g_LEFT as usize] = yRight;
    if (yRight != g_NEG_ONE) {
        nodes[yRight as usize][g_PARENT as usize] = x;
    }
    let mut xParent: i64 = nodes[x as usize].clone()[g_PARENT as usize];
    nodes[y as usize][g_PARENT as usize] = xParent;
    if (xParent == g_NEG_ONE) {
        t.root = y;
    } else if (x == nodes[xParent as usize].clone()[g_RIGHT as usize]) {
        nodes[xParent as usize][g_RIGHT as usize] = y;
    } else {
        nodes[xParent as usize][g_LEFT as usize] = y;
    }
    nodes[y as usize][g_RIGHT as usize] = x;
    nodes[x as usize][g_PARENT as usize] = y;
    t.nodes = nodes.clone();
    return t
};
        unsafe fn insert_fix(mut t: RBTree, mut z: i64) -> RBTree {
    let mut nodes: Vec<Vec<i64>> = t.nodes;
    while ((z != t.root) && (nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_COLOR as usize] == 1)) {
        if (nodes[z as usize].clone()[g_PARENT as usize] == nodes[nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize] as usize].clone()[g_LEFT as usize]) {
            let mut y: i64 = nodes[nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize] as usize].clone()[g_RIGHT as usize];
            if ((y != g_NEG_ONE) && (nodes[y as usize].clone()[g_COLOR as usize] == 1)) {
                nodes[nodes[z as usize][g_PARENT as usize] as usize][g_COLOR as usize] = 0;
                nodes[y as usize][g_COLOR as usize] = 0;
                let mut gp: i64 = nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize];
                nodes[gp as usize][g_COLOR as usize] = 1;
                z = gp;
            } else {
                if (z == nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_RIGHT as usize]) {
                    z = nodes[z as usize].clone()[g_PARENT as usize];
                    t.nodes = nodes.clone();
                    t = rotate_left(t, z);
                    nodes = t.nodes;
                }
                nodes[nodes[z as usize][g_PARENT as usize] as usize][g_COLOR as usize] = 0;
                let mut gp: i64 = nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize];
                nodes[gp as usize][g_COLOR as usize] = 1;
                t.nodes = nodes.clone();
                t = rotate_right(t, gp);
                nodes = t.nodes;
            }
        } else {
            let mut y: i64 = nodes[nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize] as usize].clone()[g_LEFT as usize];
            if ((y != g_NEG_ONE) && (nodes[y as usize].clone()[g_COLOR as usize] == 1)) {
                nodes[nodes[z as usize][g_PARENT as usize] as usize][g_COLOR as usize] = 0;
                nodes[y as usize][g_COLOR as usize] = 0;
                let mut gp: i64 = nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize];
                nodes[gp as usize][g_COLOR as usize] = 1;
                z = gp;
            } else {
                if (z == nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_LEFT as usize]) {
                    z = nodes[z as usize].clone()[g_PARENT as usize];
                    t.nodes = nodes.clone();
                    t = rotate_right(t, z);
                    nodes = t.nodes;
                }
                nodes[nodes[z as usize][g_PARENT as usize] as usize][g_COLOR as usize] = 0;
                let mut gp: i64 = nodes[nodes[z as usize].clone()[g_PARENT as usize] as usize].clone()[g_PARENT as usize];
                nodes[gp as usize][g_COLOR as usize] = 1;
                t.nodes = nodes.clone();
                t = rotate_left(t, gp);
                nodes = t.nodes;
            }
        }
    }
    nodes = t.nodes;
    nodes[t.root as usize][g_COLOR as usize] = 0;
    t.nodes = nodes.clone();
    return t
};
        unsafe fn tree_insert(mut t: RBTree, mut v: i64) -> RBTree {
    let mut nodes: Vec<Vec<i64>> = t.nodes;
    let mut node: Vec<i64> = vec![v, 1, -1, -1, -1];
    nodes = { let mut _v = nodes.clone(); _v.push(node.clone()); _v };
    let mut idx: i64 = ((nodes.len() as i64) - 1);
    let mut y: i64 = g_NEG_ONE;
    let mut x: i64 = t.root;
    while (x != g_NEG_ONE) {
        y = x;
        if (v < nodes[x as usize].clone()[g_LABEL as usize]) {
            x = nodes[x as usize].clone()[g_LEFT as usize];
        } else {
            x = nodes[x as usize].clone()[g_RIGHT as usize];
        }
    }
    nodes[idx as usize][g_PARENT as usize] = y;
    if (y == g_NEG_ONE) {
        t.root = idx;
    } else if (v < nodes[y as usize].clone()[g_LABEL as usize]) {
        nodes[y as usize][g_LEFT as usize] = idx;
    } else {
        nodes[y as usize][g_RIGHT as usize] = idx;
    }
    t.nodes = nodes.clone();
    t = insert_fix(t, idx);
    return t
};
        unsafe fn inorder(t: &mut RBTree, mut x: i64, mut acc: Vec<i64>) -> Vec<i64> {
    if (x == g_NEG_ONE) {
        return acc
    }
    acc = inorder(t, t.nodes.clone()[x as usize].clone()[g_LEFT as usize], acc.clone());
    acc = { let mut _v = acc.clone(); _v.push(t.nodes.clone()[x as usize].clone()[g_LABEL as usize]); _v };
    acc = inorder(t, t.nodes.clone()[x as usize].clone()[g_RIGHT as usize], acc.clone());
    return acc
};
        unsafe fn mochi_main() {
    let mut t: RBTree = make_tree();
    let mut values: Vec<i64> = vec![10, 20, 30, 15, 25, 5, 1];
    let mut i: i64 = 0;
    while (i < (values.len() as i64)) {
        t = tree_insert(t, values[i as usize]);
        i = (i + 1);
    }
    let mut res: Vec<i64> = vec![];
    res = inorder(&mut t, t.root, res.clone());
    println!("{}", format!("{:?}", res));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
