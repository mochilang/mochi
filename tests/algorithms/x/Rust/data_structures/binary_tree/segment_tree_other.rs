// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Node {
    start: i64,
    end: i64,
    val: i64,
    mid: i64,
    left: i64,
    right: i64,
}
impl std::fmt::Display for Node {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"start\": {}", self.start)?;
        write!(f, ", ")?;
        write!(f, "\"end\": {}", self.end)?;
        write!(f, ", ")?;
        write!(f, "\"val\": {}", self.val)?;
        write!(f, ", ")?;
        write!(f, "\"mid\": {}", self.mid)?;
        write!(f, ", ")?;
        write!(f, "\"left\": {}", self.left)?;
        write!(f, ", ")?;
        write!(f, "\"right\": {}", self.right)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct BuildResult {
    nodes: Vec<Node>,
    idx: i64,
}
impl std::fmt::Display for BuildResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"nodes\": {:?}", self.nodes)?;
        write!(f, ", ")?;
        write!(f, "\"idx\": {}", self.idx)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct SegmentTree {
    arr: Vec<i64>,
    op: i64,
}
impl std::fmt::Display for SegmentTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"arr\": {:?}", self.arr)?;
        write!(f, ", ")?;
        write!(f, "\"op\": {}", self.op)?;
        write!(f, "}}")
    }
}

static mut g_arr: Vec<i64> = Vec::new();
fn main() {
    unsafe {
        g_arr = vec![2, 1, 5, 3, 4];
                let _start: i64 = _now();
        unsafe fn combine(mut a: i64, mut b: i64, mut op: i64) -> i64 {
    if (op == 0) {
        return (a + b)
    }
    if (op == 1) {
        if (a > b) {
            return a
        }
        return b
    }
    if (a < b) {
        return a
    }
    return b
};
        unsafe fn build_tree(mut nodes: Vec<Node>, mut arr: Vec<i64>, mut start: i64, mut end: i64, mut op: i64) -> BuildResult {
    if (start == end) {
        let mut node: Node = Node {start: start, end: end, val: arr[start as usize], mid: start, left: -1, right: -1};
        let mut new_nodes: Vec<Node> = { let mut _v = nodes.clone(); _v.push(node.clone()); _v };
        return BuildResult {nodes: new_nodes, idx: ((new_nodes.len() as i64) - 1)}
    }
    let mut mid: i64 = ((start + end) / 2);
    let mut left_res: BuildResult = build_tree(nodes.clone(), arr.clone(), start, mid, op);
    let mut right_res: BuildResult = build_tree(left_res.nodes.clone(), arr.clone(), (mid + 1), end, op);
    let mut left_node: Node = right_res.nodes[left_res.idx as usize].clone();
    let mut right_node: Node = right_res.nodes[right_res.idx as usize].clone();
    let mut val: i64 = combine(left_node.val, right_node.val, op);
    let mut parent: Node = Node {start: start, end: end, val: val, mid: mid, left: left_res.idx, right: right_res.idx};
    let mut new_nodes: Vec<Node> = { let mut _v = right_res.nodes.clone(); _v.push(parent.clone()); _v };
    return BuildResult {nodes: new_nodes, idx: ((new_nodes.len() as i64) - 1)}
};
        unsafe fn new_segment_tree(mut collection: Vec<i64>, mut op: i64) -> SegmentTree {
    return SegmentTree {arr: collection, op: op}
};
        unsafe fn update(tree: &SegmentTree, mut i: i64, mut val: i64) -> SegmentTree {
    let mut new_arr: Vec<i64> = vec![];
    let mut idx: i64 = 0;
    while (idx < (tree.arr.clone().len() as i64)) {
        if (idx == i) {
            new_arr = { let mut _v = new_arr.clone(); _v.push(val); _v };
        } else {
            new_arr = { let mut _v = new_arr.clone(); _v.push(tree.arr.clone()[idx as usize]); _v };
        }
        idx = (idx + 1);
    }
    return SegmentTree {arr: new_arr, op: tree.op}
};
        unsafe fn query_range(tree: &SegmentTree, mut i: i64, mut j: i64) -> i64 {
    let mut result: i64 = tree.arr.clone()[i as usize];
    let mut idx: i64 = (i + 1);
    while (idx <= j) {
        result = combine(result, tree.arr.clone()[idx as usize], tree.op);
        idx = (idx + 1);
    }
    return result
};
        unsafe fn traverse(tree: &SegmentTree) -> Vec<Node> {
    if ((tree.arr.clone().len() as i64) == 0) {
        return vec![]
    }
    let mut res: BuildResult = build_tree(vec![], tree.arr.clone().clone(), 0, ((tree.arr.clone().len() as i64) - 1), tree.op);
    return res.nodes
};
        unsafe fn node_to_string(node: &Node) -> String {
    return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "SegmentTreeNode(start=", node.start.to_string()), ", end="), node.end.to_string()), ", val="), node.val.to_string()), ")").clone()
};
        unsafe fn print_traverse(tree: &SegmentTree) {
    let mut nodes: Vec<Node> = traverse(tree);
    let mut i: i64 = 0;
    while (i < (nodes.len() as i64)) {
        println!("{}", node_to_string(&nodes[i as usize].clone()));
        i = (i + 1);
    }
    println!("{}", "");
};
        for op in vec![0, 1, 2].iter().cloned() {
            println!("{}", "**************************************************");
            let mut tree: SegmentTree = new_segment_tree(g_arr.clone().clone(), op);
            print_traverse(&tree);
            tree = update(&tree, 1, 5);
            print_traverse(&tree);
            println!("{}", query_range(&tree, 3, 4));
            println!("{}", query_range(&tree, 2, 2));
            println!("{}", query_range(&tree, 1, 3));
            println!("{}", "");
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
