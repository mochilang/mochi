// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct TreeNode {
    data: i64,
    left: i64,
    right: i64,
}
impl std::fmt::Display for TreeNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"data\": {}", self.data)?;
        write!(f, ", ")?;
        write!(f, "\"left\": {}", self.left)?;
        write!(f, ", ")?;
        write!(f, "\"right\": {}", self.right)?;
        write!(f, "}}")
    }
}

static mut g_total_moves: i64 = 0;
fn main() {
    unsafe {
        g_total_moves = 0;
                let _start: i64 = _now();
        unsafe fn count_nodes(nodes: &mut Vec<TreeNode>, mut idx: i64) -> i64 {
    if (idx == 0) {
        return 0
    }
    let mut node: TreeNode = nodes[idx as usize].clone();
    return ((count_nodes(nodes, node.left) + count_nodes(nodes, node.right)) + 1)
};
        unsafe fn count_coins(nodes: &mut Vec<TreeNode>, mut idx: i64) -> i64 {
    if (idx == 0) {
        return 0
    }
    let mut node: TreeNode = nodes[idx as usize].clone();
    return ((count_coins(nodes, node.left) + count_coins(nodes, node.right)) + node.data)
};
        unsafe fn iabs(mut x: i64) -> i64 {
    if (x < 0) {
        return -x
    }
    return x
};
        unsafe fn dfs(mut nodes: Vec<TreeNode>, mut idx: i64) -> i64 {
    if (idx == 0) {
        return 0
    }
    let mut node: TreeNode = nodes[idx as usize].clone();
    let mut left_excess: i64 = dfs(nodes.clone(), node.left);
    let mut right_excess: i64 = dfs(nodes.clone(), node.right);
    let mut abs_left: i64 = iabs(left_excess);
    let mut abs_right: i64 = iabs(right_excess);
    g_total_moves = ((g_total_moves + abs_left) + abs_right);
    return (((node.data + left_excess) + right_excess) - 1)
};
        unsafe fn distribute_coins(nodes: &mut Vec<TreeNode>, mut root: i64) -> i64 {
    if (root == 0) {
        return 0
    }
    if (count_nodes(nodes, root) != count_coins(nodes, root)) {
        panic!("The nodes number should be same as the number of coins");
    }
    g_total_moves = 0;
    dfs(nodes.clone(), root);
    return g_total_moves
};
        unsafe fn mochi_main() {
    let mut example1: Vec<TreeNode> = vec![TreeNode {data: 0, left: 0, right: 0}, TreeNode {data: 3, left: 2, right: 3}, TreeNode {data: 0, left: 0, right: 0}, TreeNode {data: 0, left: 0, right: 0}];
    let mut example2: Vec<TreeNode> = vec![TreeNode {data: 0, left: 0, right: 0}, TreeNode {data: 0, left: 2, right: 3}, TreeNode {data: 3, left: 0, right: 0}, TreeNode {data: 0, left: 0, right: 0}];
    let mut example3: Vec<TreeNode> = vec![TreeNode {data: 0, left: 0, right: 0}, TreeNode {data: 0, left: 2, right: 3}, TreeNode {data: 0, left: 0, right: 0}, TreeNode {data: 3, left: 0, right: 0}];
    println!("{}", distribute_coins(&mut example1, 1));
    println!("{}", distribute_coins(&mut example2, 1));
    println!("{}", distribute_coins(&mut example3, 1));
    println!("{}", distribute_coins(&mut vec![TreeNode {data: 0, left: 0, right: 0}], 0));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
