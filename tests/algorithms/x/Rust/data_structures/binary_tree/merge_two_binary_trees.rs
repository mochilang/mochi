// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone)]
enum Tree {
    Leaf,
    Node { left: Box<Tree>, value: i64, right: Box<Tree> },
}

fn main() {
        let _start: i64 = _now();
    fn merge_two_binary_trees(t1: &Tree, t2: &Tree) -> Tree {
    return match t1 { Leaf => t2, Tree::Node { left: l1, value: v1, right: r1 } => match t2 { (*Leaf).clone() => t1, Tree::Node { left: l2, value: v2, right: r2 } => Tree::Node { left: Box::new(merge_two_binary_trees(l1, l2).clone()), value: (*v1 + *v2), right: Box::new(merge_two_binary_trees(r1, r2).clone()) }, }, }
};
    fn is_leaf(t: &Tree) -> bool {
    return match t { Leaf => true, _ => false, }
};
    fn get_left(t: &Tree) -> Tree {
    return match t { Tree::Node { left: l, value: _, right: _ } => l, _ => Tree::Leaf, }
};
    fn get_right(t: &Tree) -> Tree {
    return match t { Tree::Node { left: _, value: _, right: r } => r, _ => Tree::Leaf, }
};
    fn get_value(t: &Tree) -> i64 {
    return match t { Tree::Node { left: _, value: v, right: _ } => *v, _ => 0, }
};
    fn print_preorder(t: &mut Tree) -> i64 {
    if !is_leaf(t) {
        let mut v: i64 = get_value(t);
        let mut l: Tree = get_left(t);
        let mut r: Tree = get_right(t);
        println!("{}", v);
        print_preorder(&mut l);
        print_preorder(&mut r);
    }
};
    let mut tree1: Tree = Tree::Node { left: Box::new(Tree::Node { left: Box::new(Tree::Node { left: Box::new(Tree::Leaf.clone()), value: 4, right: Box::new(Tree::Leaf.clone()) }.clone()), value: 2, right: Box::new(Tree::Leaf.clone()) }.clone()), value: 1, right: Box::new(Tree::Node { left: Box::new(Tree::Leaf.clone()), value: 3, right: Box::new(Tree::Leaf.clone()) }.clone()) };
    let mut tree2: Tree = Tree::Node { left: Box::new(Tree::Node { left: Box::new(Tree::Leaf.clone()), value: 4, right: Box::new(Tree::Node { left: Box::new(Tree::Leaf.clone()), value: 9, right: Box::new(Tree::Leaf.clone()) }.clone()) }.clone()), value: 2, right: Box::new(Tree::Node { left: Box::new(Tree::Leaf.clone()), value: 6, right: Box::new(Tree::Node { left: Box::new(Tree::Leaf.clone()), value: 5, right: Box::new(Tree::Leaf.clone()) }.clone()) }.clone()) };
    println!("{}", "Tree1 is:");
    print_preorder(&mut tree1);
    println!("{}", "Tree2 is:");
    print_preorder(&mut tree2);
    let mut merged_tree: Tree = merge_two_binary_trees(&tree1, &tree2);
    println!("{}", "Merged Tree is:");
    print_preorder(&mut merged_tree);
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
