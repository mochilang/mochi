// Generated by Mochi transpiler v0.10.72
use std::collections::HashMap;
#[derive(Debug, Clone)]
struct Heap {
    arr: Vec<Vec<i64>>,
    pos_map: HashMap<i64, i64>,
    size: i64,
    key: fn(i64) -> i64,
}
impl std::fmt::Display for Heap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"arr\": {:?}", self.arr)?;
        write!(f, ", ")?;
        write!(f, "\"pos_map\": {:?}", self.pos_map)?;
        write!(f, ", ")?;
        write!(f, "\"size\": {}", self.size)?;
        write!(f, ", ")?;
        write!(f, "\"key\": {:?}", self.key)?;
        write!(f, "}}")
    }
}

fn new_heap(mut key: fn(i64) -> i64) -> Heap {
    return Heap {arr: vec![], pos_map: HashMap::new(), size: 0, key: key.clone()}
}

fn parent(mut i: i64) -> i64 {
    if (i > 0) {
        return ((i - 1) / 2)
    }
    return -1
}

fn left(mut i: i64, mut size: i64) -> i64 {
    let l: i64 = ((2 * i) + 1);
    if (l < size) {
        return l
    }
    return -1
}

fn right(mut i: i64, mut size: i64) -> i64 {
    let r: i64 = ((2 * i) + 2);
    if (r < size) {
        return r
    }
    return -1
}

fn swap(h: &mut Heap, mut i: i64, mut j: i64) {
    let mut arr: Vec<Vec<i64>> = h.arr.clone();
    let item_i: i64 = arr[i as usize].clone()[0 as usize];
    let item_j: i64 = arr[j as usize].clone()[0 as usize];
    let mut pm: HashMap<i64, i64> = h.pos_map.clone();
    pm.insert(item_i.clone(), (j + 1));
    pm.insert(item_j.clone(), (i + 1));
    (*h).pos_map = pm.clone();
    let tmp: Vec<i64> = arr[i as usize].clone();
    arr[i as usize] = arr[j as usize].clone();
    arr[j as usize] = tmp.clone();
    (*h).arr = arr.clone();
}

fn cmp(mut h: Heap, mut i: i64, mut j: i64) -> bool {
    let arr: Vec<Vec<i64>> = h.arr.clone();
    return (arr[i as usize].clone()[1 as usize] < arr[j as usize].clone()[1 as usize])
}

fn get_valid_parent(mut h: Heap, mut i: i64) -> i64 {
    let mut vp: i64 = i;
    let l: i64 = left(i, h.size);
    if ((l != (-1)) && (cmp(h.clone(), l, vp) == false)) {
        vp = l;
    }
    let r: i64 = right(i, h.size);
    if ((r != (-1)) && (cmp(h.clone(), r, vp) == false)) {
        vp = r;
    }
    return vp
}

fn heapify_up(mut h: Heap, mut index: i64) {
    let mut idx: i64 = index;
    let mut p: i64 = parent(idx);
    while ((p != (-1)) && (cmp(h.clone(), idx, p) == false)) {
        swap(&mut h, idx, p);
        idx = p;
        p = parent(p);
    }
}

fn heapify_down(mut h: Heap, mut index: i64) {
    let mut idx: i64 = index;
    let mut vp: i64 = get_valid_parent(h.clone(), idx);
    while (vp != idx) {
        swap(&mut h, idx, vp);
        idx = vp;
        vp = get_valid_parent(h.clone(), idx);
    }
}

fn update_item(h: &mut Heap, mut item: i64, mut item_value: i64) {
    let mut pm: HashMap<i64, i64> = h.pos_map.clone();
    if (pm.get(&item).cloned().unwrap_or_default() == 0) {
        return
    }
    let index: i64 = (pm.get(&item).cloned().unwrap_or_default() - 1);
    let mut arr: Vec<Vec<i64>> = h.arr.clone();
    arr[index as usize] = vec![item, (h.key)(item_value).clone()];
    (*h).arr = arr.clone();
    (*h).pos_map = pm.clone();
    heapify_up(h.clone(), index);
    heapify_down(h.clone(), index);
}

fn delete_item(h: &mut Heap, mut item: i64) {
    let mut pm: HashMap<i64, i64> = h.pos_map.clone();
    if (pm.get(&item).cloned().unwrap_or_default() == 0) {
        return
    }
    let index: i64 = (pm.get(&item).cloned().unwrap_or_default() - 1);
    pm.insert(item.clone(), 0);
    let mut arr: Vec<Vec<i64>> = h.arr.clone();
    let last_index: i64 = (h.size - 1);
    if (index != last_index) {
        arr[index as usize] = arr[last_index as usize].clone();
        let moved: i64 = arr[index as usize].clone()[0 as usize];
        pm.insert(moved.clone(), (index + 1));
    }
    (*h).size = (h.size - 1);
    (*h).arr = arr.clone();
    (*h).pos_map = pm.clone();
    if (h.size > index) {
        heapify_up(h.clone(), index);
        heapify_down(h.clone(), index);
    }
}

fn insert_item(h: &mut Heap, mut item: i64, mut item_value: i64) {
    let mut arr: Vec<Vec<i64>> = h.arr.clone();
    let arr_len: i64 = (arr.len() as i64);
    if (arr_len == h.size) {
        arr = { let mut _v = arr.clone(); _v.push(vec![item, (h.key)(item_value).clone()]); _v };
    } else {
        arr[(*h).size as usize] = vec![item, (h.key)(item_value).clone()];
    }
    let mut pm: HashMap<i64, i64> = h.pos_map.clone();
    pm.insert(item.clone(), (h.size + 1));
    (*h).size = (h.size + 1);
    (*h).arr = arr.clone();
    (*h).pos_map = pm.clone();
    heapify_up(h.clone(), (h.size - 1));
}

fn get_top(mut h: Heap) -> Vec<i64> {
    let arr: Vec<Vec<i64>> = h.arr.clone();
    if (h.size > 0) {
        return arr[0 as usize].clone()
    }
    return vec![]
}

fn extract_top(mut h: Heap) -> Vec<i64> {
    let top: Vec<i64> = get_top(h.clone());
    if ((top.len() as i64) > 0) {
        delete_item(&mut h, top[0 as usize]);
    }
    return top
}

fn identity(mut x: i64) -> i64 {
    return x
}

fn negate(mut x: i64) -> i64 {
    return (-x)
}

fn main() {
    let mut h: Heap = new_heap(identity);
    insert_item(&mut h, 5, 34);
    insert_item(&mut h, 6, 31);
    insert_item(&mut h, 7, 37);
    println!("{}", format!("{:?}", get_top(h.clone())));
    println!("{}", format!("{:?}", extract_top(h.clone())));
    println!("{}", format!("{:?}", extract_top(h.clone())));
    println!("{}", format!("{:?}", extract_top(h.clone())));
    h = new_heap(negate);
    insert_item(&mut h, 5, 34);
    insert_item(&mut h, 6, 31);
    insert_item(&mut h, 7, 37);
    println!("{}", format!("{:?}", get_top(h.clone())));
    println!("{}", format!("{:?}", extract_top(h.clone())));
    println!("{}", format!("{:?}", extract_top(h.clone())));
    println!("{}", format!("{:?}", extract_top(h.clone())));
    insert_item(&mut h, 8, 45);
    insert_item(&mut h, 9, 40);
    insert_item(&mut h, 10, 50);
    println!("{}", format!("{:?}", get_top(h.clone())));
    update_item(&mut h, 10, 30);
    println!("{}", format!("{:?}", get_top(h.clone())));
    delete_item(&mut h, 10);
    println!("{}", format!("{:?}", get_top(h.clone())));
}
