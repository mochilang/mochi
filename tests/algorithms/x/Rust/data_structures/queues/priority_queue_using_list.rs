// Generated by Mochi transpiler v0.10.72
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct FixedPriorityQueue {
    queues: Vec<Vec<i64>>,
}
impl std::fmt::Display for FixedPriorityQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"queues\": {:?}", self.queues)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct FPQDequeueResult {
    queue: FixedPriorityQueue,
    value: i64,
}
impl std::fmt::Display for FPQDequeueResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"queue\": {}", self.queue)?;
        write!(f, ", ")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct ElementPriorityQueue {
    queue: Vec<i64>,
}
impl std::fmt::Display for ElementPriorityQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"queue\": {:?}", self.queue)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct EPQDequeueResult {
    queue: ElementPriorityQueue,
    value: i64,
}
impl std::fmt::Display for EPQDequeueResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"queue\": {}", self.queue)?;
        write!(f, ", ")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn panic(mut msg: String) {
    println!("{}", msg);
};
    fn fpq_new() -> FixedPriorityQueue {
    return FixedPriorityQueue {queues: vec![vec![].clone(), vec![].clone(), vec![].clone()]}
};
    fn fpq_enqueue(mut fpq: FixedPriorityQueue, mut priority: i64, mut data: i64) -> FixedPriorityQueue {
    if ((priority < 0) || (priority >= (fpq.queues.clone().len() as i64))) {
        panic!("{}", String::from("Valid priorities are 0, 1, and 2"));
        return fpq
    }
    if ((fpq.queues.clone()[priority as usize].clone().len() as i64) >= 100) {
        panic!("{}", String::from("Maximum queue size is 100"));
        return fpq
    }
    let mut qs: Vec<Vec<i64>> = fpq.queues.clone();
    qs[priority as usize] = { let mut _v = qs[priority as usize].clone().clone(); _v.push(data); _v };
    fpq.queues = qs.clone();
    return fpq
};
    fn fpq_dequeue(fpq: &mut FixedPriorityQueue) -> FPQDequeueResult {
    let mut qs: Vec<Vec<i64>> = fpq.queues.clone();
    let mut i: i64 = 0;
    while (i < (qs.len() as i64)) {
        let q: Vec<i64> = qs[i as usize].clone();
        if ((q.len() as i64) > 0) {
            let val: i64 = q[0 as usize];
            let mut new_q: Vec<i64> = vec![];
            let mut j: i64 = 1;
            while (j < (q.len() as i64)) {
                new_q = { let mut _v = new_q.clone(); _v.push(q[j as usize]); _v };
                j = (j + 1);
            }
            qs[i as usize] = new_q.clone();
            (*fpq).queues = qs.clone();
            return FPQDequeueResult {queue: fpq.clone(), value: val}
        }
        i = (i + 1);
    }
    panic!("{}", String::from("All queues are empty"));
    return FPQDequeueResult {queue: fpq.clone(), value: 0}
};
    fn fpq_to_string(mut fpq: FixedPriorityQueue) -> String {
    let mut lines: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (fpq.queues.clone().len() as i64)) {
        let mut q_str: String = String::from("[");
        let mut q: Vec<i64> = fpq.queues.clone()[i as usize].clone();
        let mut j: i64 = 0;
        while (j < (q.len() as i64)) {
            if (j > 0) {
                q_str = format!("{}{}", q_str, ", ");
            }
            q_str = format!("{}{}", q_str, q[j as usize].to_string());
            j = (j + 1);
        }
        q_str = format!("{}{}", q_str, "]");
        lines = { let mut _v = lines.clone(); _v.push(format!("{}{}", format!("{}{}", format!("{}{}", "Priority ", i.to_string()), ": "), q_str)); _v };
        i = (i + 1);
    }
    let mut res: String = String::new();
    i = 0;
    while (i < (lines.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, "\n");
        }
        res = format!("{}{}", res, lines[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
};
    fn epq_new() -> ElementPriorityQueue {
    return ElementPriorityQueue {queue: vec![]}
};
    fn epq_enqueue(mut epq: ElementPriorityQueue, mut data: i64) -> ElementPriorityQueue {
    if ((epq.queue.clone().len() as i64) >= 100) {
        panic!("{}", String::from("Maximum queue size is 100"));
        return epq
    }
    epq.queue = { let mut _v = epq.queue.clone().clone(); _v.push(data); _v };
    return epq
};
    fn epq_dequeue(epq: &mut ElementPriorityQueue) -> EPQDequeueResult {
    if ((epq.queue.clone().len() as i64) == 0) {
        panic!("{}", String::from("The queue is empty"));
        return EPQDequeueResult {queue: epq.clone(), value: 0}
    }
    let mut min_val: i64 = epq.queue.clone()[0 as usize];
    let mut idx: i64 = 0;
    let mut i: i64 = 1;
    while (i < (epq.queue.clone().len() as i64)) {
        let v: i64 = epq.queue.clone()[i as usize];
        if (v < min_val) {
            min_val = v;
            idx = i;
        }
        i = (i + 1);
    }
    let mut new_q: Vec<i64> = vec![];
    i = 0;
    while (i < (epq.queue.clone().len() as i64)) {
        if (i != idx) {
            new_q = { let mut _v = new_q.clone(); _v.push(epq.queue.clone()[i as usize]); _v };
        }
        i = (i + 1);
    }
    (*epq).queue = new_q.clone();
    return EPQDequeueResult {queue: epq.clone(), value: min_val}
};
    fn epq_to_string(mut epq: ElementPriorityQueue) -> String {
    return format!("{:?}", epq.queue.clone()).clone()
};
    fn fixed_priority_queue() {
    let mut fpq: FixedPriorityQueue = fpq_new();
    fpq = fpq_enqueue(fpq.clone(), 0, 10);
    fpq = fpq_enqueue(fpq.clone(), 1, 70);
    fpq = fpq_enqueue(fpq.clone(), 0, 100);
    fpq = fpq_enqueue(fpq.clone(), 2, 1);
    fpq = fpq_enqueue(fpq.clone(), 2, 5);
    fpq = fpq_enqueue(fpq.clone(), 1, 7);
    fpq = fpq_enqueue(fpq.clone(), 2, 4);
    fpq = fpq_enqueue(fpq.clone(), 1, 64);
    fpq = fpq_enqueue(fpq.clone(), 0, 128);
    println!("{}", fpq_to_string(fpq.clone()));
    let mut res: FPQDequeueResult = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    println!("{}", fpq_to_string(fpq.clone()));
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
    res = fpq_dequeue(&mut fpq);
    fpq = res.queue.clone();
    println!("{}", res.value);
};
    fn element_priority_queue() {
    let mut epq: ElementPriorityQueue = epq_new();
    epq = epq_enqueue(epq.clone(), 10);
    epq = epq_enqueue(epq.clone(), 70);
    epq = epq_enqueue(epq.clone(), 100);
    epq = epq_enqueue(epq.clone(), 1);
    epq = epq_enqueue(epq.clone(), 5);
    epq = epq_enqueue(epq.clone(), 7);
    epq = epq_enqueue(epq.clone(), 4);
    epq = epq_enqueue(epq.clone(), 64);
    epq = epq_enqueue(epq.clone(), 128);
    println!("{}", epq_to_string(epq.clone()));
    let mut res: EPQDequeueResult = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    println!("{}", epq_to_string(epq.clone()));
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
    res = epq_dequeue(&mut epq);
    epq = res.queue.clone();
    println!("{}", res.value);
};
    let mut mochi_main = || {
    fixed_priority_queue();
    element_priority_queue();
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
