// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct DS {
    parent: Vec<i64>,
    rank: Vec<i64>,
}
impl std::fmt::Display for DS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"parent\": {:?}", self.parent)?;
        write!(f, ", ")?;
        write!(f, "\"rank\": {:?}", self.rank)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct FindResult {
    ds: DS,
    root: i64,
}
impl std::fmt::Display for FindResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"ds\": {}", self.ds)?;
        write!(f, ", ")?;
        write!(f, "\"root\": {}", self.root)?;
        write!(f, "}}")
    }
}

static mut g_ds: DS = DS { parent: Vec::new(), rank: Vec::new() };
static mut g_i: i64 = 0;
fn main() {
    unsafe {
        g_ds = DS {parent: vec![], rank: vec![]};
        g_i = 0;
                let _start: i64 = _now();
        unsafe fn make_set(ds: &DS, mut x: i64) -> DS {
    let mut p: Vec<i64> = ds.parent.clone();
    let mut r: Vec<i64> = ds.rank.clone();
    p[x as usize] = x;
    r[x as usize] = 0;
    return DS {parent: p, rank: r}
};
        unsafe fn find_set(ds: &DS, mut x: i64) -> FindResult {
    if (ds.parent.clone()[x as usize] == x) {
        return FindResult {ds: ds.clone(), root: x}
    }
    let mut res: FindResult = find_set(ds, ds.parent.clone()[x as usize]);
    let mut p: Vec<i64> = res.ds.parent;
    p[x as usize] = res.root;
    return FindResult {ds: DS {parent: p, rank: res.ds.rank}, root: res.root}
};
        unsafe fn union_set(ds: &DS, mut x: i64, mut y: i64) -> DS {
    let mut fx: FindResult = find_set(ds, x);
    let mut ds1: DS = fx.ds;
    let mut x_root: i64 = fx.root;
    let mut fy: FindResult = find_set(&ds1, y);
    let mut ds2: DS = fy.ds;
    let mut y_root: i64 = fy.root;
    if (x_root == y_root) {
        return ds2
    }
    let mut p: Vec<i64> = ds2.parent;
    let mut r: Vec<i64> = ds2.rank;
    if (r[x_root as usize] > r[y_root as usize]) {
        p[y_root as usize] = x_root;
    } else {
        p[x_root as usize] = y_root;
        if (r[x_root as usize] == r[y_root as usize]) {
            r[y_root as usize] = (r[y_root as usize] + 1);
        }
    }
    return DS {parent: p, rank: r}
};
        unsafe fn same_python_set(mut a: i64, mut b: i64) -> bool {
    if ((a < 3) && (b < 3)) {
        return true
    }
    if ((((a >= 3) && (a < 6)) && (b >= 3)) && (b < 6)) {
        return true
    }
    return false
};
        while (g_i < 6) {
            g_ds.parent = { let mut _v = g_ds.clone().parent.clone(); _v.push(0); _v };
            g_ds.rank = { let mut _v = g_ds.clone().rank.clone(); _v.push(0); _v };
            g_ds = make_set(&g_ds, g_i);
            g_i = (g_i + 1);
        }
        g_ds = union_set(&g_ds, 0, 1);
        g_ds = union_set(&g_ds, 1, 2);
        g_ds = union_set(&g_ds, 3, 4);
        g_ds = union_set(&g_ds, 3, 5);
        g_i = 0;
        while (g_i < 6) {
            let mut j: i64 = 0;
            while (j < 6) {
                let mut res_i: FindResult = find_set(&g_ds, g_i);
                g_ds = res_i.ds;
                let mut root_i: i64 = res_i.root;
                let mut res_j: FindResult = find_set(&g_ds, j);
                g_ds = res_j.ds;
                let mut root_j: i64 = res_j.root;
                let mut same: bool = same_python_set(g_i, j);
                let mut root_same: bool = (root_i == root_j);
                if same {
                    if !root_same {
                        panic!("nodes should be in same set");
                    }
                } else {
                    if root_same {
                        panic!("nodes should be in different sets");
                    }
                }
                j = (j + 1);
            }
            g_i = (g_i + 1);
        }
        g_i = 0;
        while (g_i < 6) {
            let mut res: FindResult = find_set(&g_ds, g_i);
            g_ds = res.ds;
            println!("{}", res.root.to_string());
            g_i = (g_i + 1);
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
