// Generated by Mochi transpiler v0.10.60
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct DisjointSet {
    set_counts: Vec<i64>,
    max_set: i64,
    ranks: Vec<i64>,
    parents: Vec<i64>,
}
impl std::fmt::Display for DisjointSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"set_counts\": {:?}", self.set_counts)?;
        write!(f, ", ")?;
        write!(f, "\"max_set\": {}", self.max_set)?;
        write!(f, ", ")?;
        write!(f, "\"ranks\": {:?}", self.ranks)?;
        write!(f, ", ")?;
        write!(f, "\"parents\": {:?}", self.parents)?;
        write!(f, "}}")
    }
}

static mut g_ds: DisjointSet = DisjointSet { set_counts: Vec::new(), max_set: 0, ranks: Vec::new(), parents: Vec::new() };
fn main() {
    unsafe {
        g_ds = disjoint_set_new(vec![1, 1, 1]);
                let _start: i64 = _now();
        unsafe fn max_list(mut xs: Vec<i64>) -> i64 {
    let mut m: i64 = xs[0 as usize];
    let mut i: i64 = 1;
    while (i < (xs.len() as i64)) {
        if (xs[i as usize] > m) {
            m = xs[i as usize];
        }
        i = (i + 1);
    }
    return m
};
        unsafe fn disjoint_set_new(mut set_counts: Vec<i64>) -> DisjointSet {
    let mut max_set: i64 = max_list(set_counts.clone());
    let mut num_sets = (set_counts.len() as i64);
    let mut ranks: Vec<i64> = vec![];
    let mut parents: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < num_sets) {
        ranks = { let mut _v = ranks.clone(); _v.push(1); _v };
        parents = { let mut _v = parents.clone(); _v.push(i); _v };
        i = (i + 1);
    }
    return DisjointSet {set_counts: set_counts, max_set: max_set, ranks: ranks, parents: parents}
};
        unsafe fn get_parent(ds: &mut DisjointSet, mut idx: i64) -> i64 {
    if (ds.parents.clone()[idx as usize] == idx) {
        return idx
    }
    let mut parents: Vec<i64> = ds.parents.clone();
    parents[idx as usize] = get_parent(ds, parents[idx as usize]);
    (*ds).parents = parents.clone();
    return ds.parents.clone()[idx as usize]
};
        unsafe fn merge(ds: &mut DisjointSet, mut src: i64, mut dst: i64) -> bool {
    let mut src_parent: i64 = get_parent(ds, src);
    let mut dst_parent: i64 = get_parent(ds, dst);
    if (src_parent == dst_parent) {
        return false
    }
    if (ds.ranks.clone()[dst_parent as usize] >= ds.ranks.clone()[src_parent as usize]) {
        let mut counts: Vec<i64> = ds.set_counts.clone();
        counts[dst_parent as usize] = (counts[dst_parent as usize] + counts[src_parent as usize]);
        counts[src_parent as usize] = 0;
        (*ds).set_counts = counts.clone();
        let mut parents: Vec<i64> = ds.parents.clone();
        parents[src_parent as usize] = dst_parent;
        (*ds).parents = parents.clone();
        if (ds.ranks.clone()[dst_parent as usize] == ds.ranks.clone()[src_parent as usize]) {
            let mut ranks: Vec<i64> = ds.ranks.clone();
            ranks[dst_parent as usize] = (ranks[dst_parent as usize] + 1);
            (*ds).ranks = ranks.clone();
        }
        let mut joined: i64 = ds.set_counts.clone()[dst_parent as usize];
        if (joined > ds.max_set) {
            (*ds).max_set = joined;
        }
    } else {
        let mut counts: Vec<i64> = ds.set_counts.clone();
        counts[src_parent as usize] = (counts[src_parent as usize] + counts[dst_parent as usize]);
        counts[dst_parent as usize] = 0;
        (*ds).set_counts = counts.clone();
        let mut parents: Vec<i64> = ds.parents.clone();
        parents[dst_parent as usize] = src_parent;
        (*ds).parents = parents.clone();
        let mut joined: i64 = ds.set_counts.clone()[src_parent as usize];
        if (joined > ds.max_set) {
            (*ds).max_set = joined;
        }
    }
    return true
};
        println!("{}", if merge(&mut g_ds, 1, 2) { 1 } else { 0 });
        println!("{}", if merge(&mut g_ds, 0, 2) { 1 } else { 0 });
        println!("{}", if merge(&mut g_ds, 0, 1) { 1 } else { 0 });
        println!("{}", get_parent(&mut g_ds, 0));
        println!("{}", get_parent(&mut g_ds, 1));
        println!("{}", g_ds.clone().max_set);
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
