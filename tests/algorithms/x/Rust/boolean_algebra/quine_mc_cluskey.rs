// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn compare_string(string1: &str, string2: &str) -> String {
    let mut result: String = String::from("").clone();
    let mut count: i64 = 0;
    let mut i: i64 = 0;
    while (i < (string1.len() as i64)) {
        let mut c1: String = { let tmp = &string1; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        let mut c2: String = { let tmp = &string2; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (c1.as_str() != c2.as_str()) {
            count = (count + 1);
            result = format!("{}{}", result, "_");
        } else {
            result = format!("{}{}", result, c1);
        }
        i = (i + 1);
    }
    if (count > 1) {
        return String::from("")
    }
    return result.clone()
};
    fn contains_string(mut arr: Vec<String>, value: &str) -> bool {
    let mut i: i64 = 0;
    while (i < (arr.len() as i64)) {
        if (arr[i as usize].clone() == value) {
            return true
        }
        i = (i + 1);
    }
    return false
};
    fn unique_strings(mut arr: Vec<String>) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (arr.len() as i64)) {
        if !contains_string(res.clone(), &arr[i as usize].clone()) {
            res = { let mut _v = res.clone(); _v.push(arr[i as usize].clone()); _v };
        }
        i = (i + 1);
    }
    return res
};
    fn check(mut binary: Vec<String>) -> Vec<String> {
    let mut pi: Vec<String> = vec![];
    let mut current: Vec<String> = binary;
    loop {
        let mut check1: Vec<String> = vec![];
        let mut i: i64 = 0;
        while (i < (current.len() as i64)) {
            check1 = { let mut _v = check1.clone(); _v.push("$".to_string()); _v };
            i = (i + 1);
        }
        let mut temp: Vec<String> = vec![];
        i = 0;
        while (i < (current.len() as i64)) {
            let mut j: i64 = (i + 1);
            while (j < (current.len() as i64)) {
                let mut k: String = compare_string(&current[i as usize].clone(), &current[j as usize].clone()).clone();
                if (k.as_str() == "") {
                    check1[i as usize] = String::from("*");
                    check1[j as usize] = String::from("*");
                    temp = { let mut _v = temp.clone(); _v.push("X".to_string()); _v };
                }
                j = (j + 1);
            }
            i = (i + 1);
        }
        i = 0;
        while (i < (current.len() as i64)) {
            if (check1[i as usize].clone().as_str() == "$") {
                pi = { let mut _v = pi.clone(); _v.push(current[i as usize].clone()); _v };
            }
            i = (i + 1);
        }
        if ((temp.len() as i64) == 0) {
            return pi
        }
        current = unique_strings(temp.clone());
    }
};
    fn decimal_to_binary(mut no_of_variable: i64, mut minterms: Vec<i64>) -> Vec<String> {
    let mut temp: Vec<String> = vec![];
    let mut idx: i64 = 0;
    while (idx < (minterms.len() as i64)) {
        let mut minterm: i64 = minterms[idx as usize];
        let mut string: String = String::from("").clone();
        let mut i: i64 = 0;
        while (i < no_of_variable) {
            string = format!("{}{}", (minterm % 2).to_string(), string).to_string();
            minterm = (minterm / 2);
            i = (i + 1);
        }
        temp = { let mut _v = temp.clone(); _v.push(string.clone()); _v };
        idx = (idx + 1);
    }
    return temp
};
    fn is_for_table(string1: &str, string2: &str, mut count: i64) -> bool {
    let mut count_n: i64 = 0;
    let mut i: i64 = 0;
    while (i < (string1.len() as i64)) {
        let mut c1: String = { let tmp = &string1; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        let mut c2: String = { let tmp = &string2; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (c1.as_str() != c2.as_str()) {
            count_n = (count_n + 1);
        }
        i = (i + 1);
    }
    return (count_n == count)
};
    fn count_ones(mut row: Vec<i64>) -> i64 {
    let mut c: i64 = 0;
    let mut j: i64 = 0;
    while (j < (row.len() as i64)) {
        if (row[j as usize] == 1) {
            c = (c + 1);
        }
        j = (j + 1);
    }
    return c
};
    fn selection(chart: &mut Vec<Vec<i64>>, mut prime_implicants: Vec<String>) -> Vec<String> {
    let mut temp: Vec<String> = vec![];
    let mut select: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (chart.len() as i64)) {
        select = { let mut _v = select.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut col: i64 = 0;
    while (col < (chart[0 as usize].clone().len() as i64)) {
        let mut count: i64 = 0;
        let mut row: i64 = 0;
        while (row < (chart.len() as i64)) {
            if (chart[row as usize].clone()[col as usize] == 1) {
                count = (count + 1);
            }
            row = (row + 1);
        }
        if (count == 1) {
            let mut rem: i64 = 0;
            row = 0;
            while (row < (chart.len() as i64)) {
                if (chart[row as usize].clone()[col as usize] == 1) {
                    rem = row;
                }
                row = (row + 1);
            }
            select[rem as usize] = 1;
        }
        col = (col + 1);
    }
    i = 0;
    while (i < (select.len() as i64)) {
        if (select[i as usize] == 1) {
            let mut j: i64 = 0;
            while (j < (chart[0 as usize].clone().len() as i64)) {
                if (chart[i as usize].clone()[j as usize] == 1) {
                    let mut r: i64 = 0;
                    while (r < (chart.len() as i64)) {
                        (*chart)[r as usize][j as usize] = 0;
                        r = (r + 1);
                    }
                }
                j = (j + 1);
            }
            temp = { let mut _v = temp.clone(); _v.push(prime_implicants[i as usize].clone()); _v };
        }
        i = (i + 1);
    }
    loop {
        let mut counts: Vec<i64> = vec![];
        let mut r: i64 = 0;
        while (r < (chart.len() as i64)) {
            counts = { let mut _v = counts.clone(); _v.push(count_ones(chart[r as usize].clone())); _v };
            r = (r + 1);
        }
        let mut max_n: i64 = counts[0 as usize];
        let mut rem: i64 = 0;
        let mut k: i64 = 1;
        while (k < (counts.len() as i64)) {
            if (counts[k as usize] > max_n) {
                max_n = counts[k as usize];
                rem = k;
            }
            k = (k + 1);
        }
        if (max_n == 0) {
            return temp
        }
        temp = { let mut _v = temp.clone(); _v.push(prime_implicants[rem as usize].clone()); _v };
        let mut j: i64 = 0;
        while (j < (chart[0 as usize].clone().len() as i64)) {
            if (chart[rem as usize].clone()[j as usize] == 1) {
                let mut r2: i64 = 0;
                while (r2 < (chart.len() as i64)) {
                    (*chart)[r2 as usize][j as usize] = 0;
                    r2 = (r2 + 1);
                }
            }
            j = (j + 1);
        }
    }
};
    fn count_char(mut s: String, ch: &str) -> i64 {
    let mut cnt: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            cnt = (cnt + 1);
        }
        i = (i + 1);
    }
    return cnt
};
    fn prime_implicant_chart(mut prime_implicants: Vec<String>, mut binary: Vec<String>) -> Vec<Vec<i64>> {
    let mut chart: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < (prime_implicants.len() as i64)) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < (binary.len() as i64)) {
            row = { let mut _v = row.clone(); _v.push(0); _v };
            j = (j + 1);
        }
        chart = { let mut _v = chart.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    i = 0;
    while (i < (prime_implicants.len() as i64)) {
        let mut count: i64 = count_char(prime_implicants[i as usize].clone(), &"_");
        let mut j: i64 = 0;
        while (j < (binary.len() as i64)) {
            if is_for_table(&prime_implicants[i as usize].clone(), &binary[j as usize].clone(), count) {
                chart[i as usize][j as usize] = 1;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return chart
};
    fn mochi_main() {
    let mut no_of_variable: i64 = 3;
    let mut minterms: Vec<i64> = vec![1, 5, 7];
    let mut binary: Vec<String> = decimal_to_binary(no_of_variable, minterms.clone());
    let mut prime_implicants: Vec<String> = check(binary.clone());
    println!("{}", "Prime Implicants are:");
    println!("{}", format!("{:?}", prime_implicants));
    let mut chart: Vec<Vec<i64>> = prime_implicant_chart(prime_implicants.clone(), binary.clone());
    let mut essential_prime_implicants: Vec<String> = selection(&mut chart, prime_implicants.clone());
    println!("{}", "Essential Prime Implicants are:");
    println!("{}", format!("{:?}", essential_prime_implicants));
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
