// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn pivot(mut t: Vec<Vec<f64>>, mut row: i64, mut col: i64) -> Vec<Vec<f64>> {
    let mut pivotRow: Vec<f64> = vec![];
    let pivotVal: f64 = t[row as usize].clone()[col as usize];
    for j in 0..(t[row as usize].clone().len() as i64) {
        pivotRow = { let mut _v = pivotRow.clone(); _v.push((t[row as usize].clone()[j as usize] / pivotVal)); _v };
    }
    t[row as usize] = pivotRow.clone();
    for i in 0..(t.len() as i64) {
        if (i != row) {
            let factor: f64 = t[i as usize].clone()[col as usize];
            let mut newRow: Vec<f64> = vec![];
            for j in 0..(t[i as usize].clone().len() as i64) {
                let value: f64 = (t[i as usize].clone()[j as usize] - (factor * pivotRow[j as usize]));
                newRow = { let mut _v = newRow.clone(); _v.push(value); _v };
            }
            t[i as usize] = newRow.clone();
        }
    }
    return t
};
    fn findPivot(mut t: Vec<Vec<f64>>) -> Vec<i64> {
    let mut col: i64 = 0;
    let mut minVal: f64 = 0.0;
    for j in 0..((t[0 as usize].clone().len() as i64) - 1) {
        let v: f64 = t[0 as usize].clone()[j as usize];
        if (v < minVal) {
            minVal = v;
            col = j;
        }
    }
    if (minVal >= 0.0) {
        return vec![-1, -1]
    }
    let mut row: i64 = -1;
    let mut minRatio: f64 = 0.0;
    let mut first: bool = true;
    for i in 1..(t.len() as i64) {
        let coeff: f64 = t[i as usize].clone()[col as usize];
        if (coeff > 0.0) {
            let rhs: f64 = t[i as usize].clone()[((t[i as usize].clone().len() as i64) - 1) as usize];
            let ratio: f64 = (rhs / coeff);
            if (first || (ratio < minRatio)) {
                minRatio = ratio;
                row = i;
                first = false;
            }
        }
    }
    return vec![row, col]
};
    fn interpret(mut t: Vec<Vec<f64>>, mut nVars: i64) -> HashMap<String, f64> {
    let lastCol: i64 = ((t[0 as usize].clone().len() as i64) - 1);
    let mut p: f64 = t[0 as usize].clone()[lastCol as usize];
    if (p < 0.0) {
        p = -p;
    }
    let mut result: HashMap<String, f64> = HashMap::new();
    result.insert(String::from("P"), p.clone());
    for i in 0..nVars {
        let mut nzRow: i64 = -1;
        let mut nzCount: i64 = 0;
        for r in 0..(t.len() as i64) {
            let val: f64 = t[r as usize].clone()[i as usize];
            if (val != 0.0) {
                nzCount = (nzCount + 1);
                nzRow = r;
            }
        }
        if ((nzCount == 1) && (t[nzRow as usize].clone()[i as usize] == 1.0)) {
            result.insert(format!("{}{}", "x", (i + 1).to_string()).clone(), t[nzRow as usize].clone()[lastCol as usize]);
        }
    }
    return result
};
    let mut simplex = |tab: Vec<Vec<f64>>| -> Vec<Vec<f64>> {
    let mut t: Vec<Vec<f64>> = tab.clone();
    loop {
        let p: Vec<i64> = findPivot(t.clone());
        let row: i64 = p[0 as usize];
        let col: i64 = p[1 as usize];
        if (row < 0) {
            break
        }
        t = pivot(t.clone(), row, col);
    }
    return t
};
    let mut tableau: Vec<Vec<f64>> = vec![vec![-1.0, -1.0, 0.0, 0.0, 0.0].clone(), vec![1.0, 3.0, 1.0, 0.0, 4.0].clone(), vec![3.0, 1.0, 0.0, 1.0, 4.0].clone()];
    let mut finalTab: Vec<Vec<f64>> = simplex(tableau.clone());
    let res: HashMap<String, f64> = interpret(finalTab.clone(), 2);
    println!("{}", format!("{}{}", "P: ", res.get("P").cloned().unwrap_or_default().to_string()));
    for i in 0..2 {
        let key: String = format!("{}{}", "x", (i + 1).to_string()).clone();
        if res.contains_key(&key) {
            println!("{}", format!("{}{}", format!("{}{}", key, ": "), res.get(key.as_str()).cloned().unwrap_or_default().to_string()));
        }
    }
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
