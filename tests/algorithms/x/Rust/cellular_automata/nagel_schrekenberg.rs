// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_seed: i64 = 0;
static mut g_NEG_ONE: i64 = 0;
fn main() {
    unsafe {
        g_seed = 1;
        g_NEG_ONE = -1;
                let _start: i64 = _now();
        unsafe fn rand() -> i64 {
    g_seed = (((g_seed * 1103515245) + 12345) % 2147483648);
    return g_seed
};
        unsafe fn randint(mut a: i64, mut b: i64) -> i64 {
    let mut r: i64 = rand();
    return (a + (r % ((b - a) + 1)))
};
        unsafe fn random() -> f64 {
    return ((1.0 * (rand() as f64)) / 2147483648.0)
};
        unsafe fn construct_highway(mut number_of_cells: i64, mut frequency: i64, mut initial_speed: i64, mut random_frequency: bool, mut random_speed: bool, mut max_speed: i64) -> Vec<Vec<i64>> {
    let mut row: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < number_of_cells) {
        row = { let mut _v = row.clone(); _v.push(-1); _v };
        i = (i + 1);
    }
    let mut highway: Vec<Vec<i64>> = vec![];
    highway = { let mut _v = highway.clone(); _v.push(row.clone()); _v };
    i = 0;
    if (initial_speed < 0) {
        initial_speed = 0;
    }
    while (i < number_of_cells) {
        let mut speed: i64 = initial_speed;
        if random_speed {
            speed = randint(0, max_speed);
        }
        highway[0 as usize][i as usize] = speed;
        let mut step: i64 = frequency;
        if random_frequency {
            step = randint(1, (max_speed * 2));
        }
        i = (i + step);
    }
    return highway
};
        unsafe fn get_distance(highway_now: &mut Vec<i64>, mut car_index: i64) -> i64 {
    let mut distance: i64 = 0;
    let mut i: i64 = (car_index + 1);
    while (i < (highway_now.len() as i64)) {
        if (highway_now[i as usize] > g_NEG_ONE) {
            return distance
        }
        distance = (distance + 1);
        i = (i + 1);
    }
    return (distance + get_distance(highway_now, -1))
};
        unsafe fn update(mut highway_now: Vec<i64>, mut probability: f64, mut max_speed: i64) -> Vec<i64> {
    let mut number_of_cells = (highway_now.len() as i64);
    let mut next_highway: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < number_of_cells) {
        next_highway = { let mut _v = next_highway.clone(); _v.push(-1); _v };
        i = (i + 1);
    }
    let mut car_index: i64 = 0;
    while (car_index < number_of_cells) {
        let mut speed: i64 = highway_now[car_index as usize];
        if (speed > g_NEG_ONE) {
            let mut new_speed: i64 = (speed + 1);
            if (new_speed > max_speed) {
                new_speed = max_speed;
            }
            let mut dn: i64 = (get_distance(&mut highway_now, car_index) - 1);
            if (new_speed > dn) {
                new_speed = dn;
            }
            if (random() < probability) {
                new_speed = (new_speed - 1);
                if (new_speed < 0) {
                    new_speed = 0;
                }
            }
            next_highway[car_index as usize] = new_speed;
        }
        car_index = (car_index + 1);
    }
    return next_highway
};
        unsafe fn simulate(mut highway: Vec<Vec<i64>>, mut number_of_update: i64, mut probability: f64, mut max_speed: i64) -> Vec<Vec<i64>> {
    let mut number_of_cells = (highway[0 as usize].clone().len() as i64);
    let mut i: i64 = 0;
    while (i < number_of_update) {
        let mut next_speeds: Vec<i64> = update(highway[i as usize].clone(), probability, max_speed);
        let mut real_next: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < number_of_cells) {
            real_next = { let mut _v = real_next.clone(); _v.push(-1); _v };
            j = (j + 1);
        }
        let mut k: i64 = 0;
        while (k < number_of_cells) {
            let mut speed: i64 = next_speeds[k as usize];
            if (speed > g_NEG_ONE) {
                let mut index: i64 = ((k + speed) % number_of_cells);
                real_next[index as usize] = speed;
            }
            k = (k + 1);
        }
        highway = { let mut _v = highway.clone(); _v.push(real_next.clone()); _v };
        i = (i + 1);
    }
    return highway
};
        unsafe fn mochi_main() {
    let mut ex1: Vec<Vec<i64>> = simulate(construct_highway(6, 3, 0, false, false, 2), 2, 0.0, 2);
    println!("{}", format!("{:?}", ex1));
    let mut ex2: Vec<Vec<i64>> = simulate(construct_highway(5, 2, -2, false, false, 2), 3, 0.0, 2);
    println!("{}", format!("{:?}", ex2));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
