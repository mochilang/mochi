// Generated by Mochi transpiler v0.10.59
#[derive(Debug, Clone)]
enum Huffman {
    Leaf { symbol: String, freq: i64 },
    Node { freq: i64, left: Box<Huffman>, right: Box<Huffman> },
}

fn get_freq(n: &Huffman) -> i64 {
    return match n { Huffman::Leaf { symbol: _, freq: f } => *f, Huffman::Node { freq: f, left: _, right: _ } => *f, }
}

fn sort_nodes(mut nodes: Vec<Huffman>) -> Vec<Huffman> {
    let mut arr: Vec<Huffman> = nodes;
    let mut i: i64 = 1;
    while (i < (arr.len() as i64)) {
        let mut key: Huffman = arr[i as usize].clone();
        let mut j: i64 = (i - 1);
        while ((j >= 0) && (get_freq(&arr[j as usize].clone()) > get_freq(&key))) {
            arr[(j + 1) as usize] = arr[j as usize].clone();
            j = (j - 1);
        }
        arr[(j + 1) as usize] = key.clone();
        i = (i + 1);
    }
    return arr
}

fn rest(mut nodes: Vec<Huffman>) -> Vec<Huffman> {
    let mut res: Vec<Huffman> = vec![];
    let mut i: i64 = 1;
    while (i < (nodes.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push(nodes[i as usize].clone()); _v };
        i = (i + 1);
    }
    return res
}

fn count_freq(text: &str) -> Vec<Huffman> {
    let mut chars: Vec<String> = vec![];
    let mut freqs: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        let mut c: String = { let tmp = &text; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        let mut j: i64 = 0;
        let mut found: bool = false;
        while (j < (chars.len() as i64)) {
            if (chars[j as usize].clone().as_str() == c.as_str()) {
                freqs[j as usize] = (freqs[j as usize] + 1);
                found = true;
                break
            }
            j = (j + 1);
        }
        if !found {
            chars = { let mut _v = chars.clone(); _v.push(c.clone()); _v };
            freqs = { let mut _v = freqs.clone(); _v.push(1); _v };
        }
        i = (i + 1);
    }
    let mut leaves: Vec<Huffman> = vec![];
    let mut k: i64 = 0;
    while (k < (chars.len() as i64)) {
        leaves = { let mut _v = leaves.clone(); _v.push(Huffman::Leaf { symbol: chars[k as usize].clone().clone(), freq: freqs[k as usize] }); _v };
        k = (k + 1);
    }
    return sort_nodes(leaves.clone())
}

fn build_tree(mut nodes: Vec<Huffman>) -> Huffman {
    let mut arr: Vec<Huffman> = nodes;
    while ((arr.len() as i64) > 1) {
        let mut left: Huffman = arr[0 as usize].clone();
        arr = rest(arr.clone());
        let mut right: Huffman = arr[0 as usize].clone();
        arr = rest(arr.clone());
        let mut node: Huffman = Huffman::Node { freq: (get_freq(&left) + get_freq(&right)), left: Box::new(left.clone()), right: Box::new(right.clone()) };
        arr = { let mut _v = arr.clone(); _v.push(node.clone()); _v };
        arr = sort_nodes(arr.clone());
    }
    return arr[0 as usize].clone()
}

fn concat_pairs(mut a: Vec<Vec<String>>, mut b: Vec<Vec<String>>) -> Vec<Vec<String>> {
    let mut res: Vec<Vec<String>> = a;
    let mut i: i64 = 0;
    while (i < (b.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push(b[i as usize].clone()); _v };
        i = (i + 1);
    }
    return res
}

fn collect_codes(tree: &Huffman, prefix: &str) -> Vec<Vec<String>> {
    return match tree { Huffman::Leaf { symbol: s, freq: _ } => vec![vec![(*s).clone(), prefix.to_string()]], Huffman::Node { freq: _, left: l, right: r } => concat_pairs(collect_codes(l, &format!("{}{}", prefix, "0")), collect_codes(r, &format!("{}{}", prefix, "1"))), }
}

fn find_code(mut pairs: Vec<Vec<String>>, ch: &str) -> String {
    let mut i: i64 = 0;
    while (i < (pairs.len() as i64)) {
        if (pairs[i as usize].clone()[0 as usize].clone() == ch) {
            return pairs[i as usize].clone()[1 as usize].clone()
        }
        i = (i + 1);
    }
    return String::from("").clone()
}

fn huffman_encode(text: &str) -> String {
    if (text == "") {
        return String::from("")
    }
    let mut leaves: Vec<Huffman> = count_freq(text);
    let mut tree: Huffman = build_tree(leaves.clone());
    let mut codes: Vec<Vec<String>> = collect_codes(&tree, &"");
    let mut encoded: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        let mut c: String = { let tmp = &text; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        encoded = format!("{}{}", format!("{}{}", encoded, find_code(codes.clone(), &c)), " ");
        i = (i + 1);
    }
    return encoded.clone()
}

fn main() {
    println!("{}", huffman_encode(&"beep boop beer!"));
}
