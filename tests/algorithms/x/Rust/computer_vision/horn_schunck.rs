// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start: i64 = _now();
    fn round_int(mut x: f64) -> i64 {
    if (x >= 0.0) {
        return ((x + 0.5) as i64)
    }
    return ((x - 0.5) as i64)
};
    fn zeros(mut rows: i64, mut cols: i64) -> Vec<Vec<f64>> {
    let mut res: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < rows) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < cols) {
            row = { let mut _v = row.clone(); _v.push(0.0); _v };
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return res
};
    fn warp(mut image: Vec<Vec<f64>>, mut h_flow: Vec<Vec<f64>>, mut v_flow: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut h = (image.len() as i64);
    let mut w = (image[0 as usize].clone().len() as i64);
    let mut out: Vec<Vec<f64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<f64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut sx: i64 = (x - round_int(h_flow[y as usize].clone()[x as usize]));
            let mut sy: i64 = (y - round_int(v_flow[y as usize].clone()[x as usize]));
            if ((((sx >= 0) && (sx < w)) && (sy >= 0)) && (sy < h)) {
                row = { let mut _v = row.clone(); _v.push(image[sy as usize].clone()[sx as usize]); _v };
            } else {
                row = { let mut _v = row.clone(); _v.push(0.0); _v };
            }
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
    fn convolve(mut img: Vec<Vec<f64>>, mut ker: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut h = (img.len() as i64);
    let mut w = (img[0 as usize].clone().len() as i64);
    let mut kh = (ker.len() as i64);
    let mut kw = (ker[0 as usize].clone().len() as i64);
    let mut py: i64 = (kh / 2);
    let mut px: i64 = (kw / 2);
    let mut out: Vec<Vec<f64>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<f64> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            let mut s: f64 = 0.0;
            let mut ky: i64 = 0;
            while (ky < kh) {
                let mut kx: i64 = 0;
                while (kx < kw) {
                    let mut iy: i64 = ((y + ky) - py);
                    let mut ix: i64 = ((x + kx) - px);
                    if ((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w)) {
                        s = (s + (img[iy as usize].clone()[ix as usize] * ker[ky as usize].clone()[kx as usize]));
                    }
                    kx = (kx + 1);
                }
                ky = (ky + 1);
            }
            row = { let mut _v = row.clone(); _v.push(s); _v };
            x = (x + 1);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return out
};
    fn horn_schunck(mut image0: Vec<Vec<f64>>, mut image1: Vec<Vec<f64>>, mut num_iter: i64, mut alpha: f64) -> Vec<Vec<Vec<f64>>> {
    let mut h = (image0.len() as i64);
    let mut w = (image0[0 as usize].clone().len() as i64);
    let mut u: Vec<Vec<f64>> = zeros(h, w);
    let mut v: Vec<Vec<f64>> = zeros(h, w);
    let mut kernel_x: Vec<Vec<f64>> = vec![vec![-0.25, 0.25], vec![-0.25, 0.25]];
    let mut kernel_y: Vec<Vec<f64>> = vec![vec![-0.25, -0.25], vec![0.25, 0.25]];
    let mut kernel_t: Vec<Vec<f64>> = vec![vec![0.25, 0.25], vec![0.25, 0.25]];
    let mut laplacian: Vec<Vec<f64>> = vec![vec![0.0833333333333, 0.166666666667, 0.0833333333333], vec![0.166666666667, 0.0, 0.166666666667], vec![0.0833333333333, 0.166666666667, 0.0833333333333]];
    let mut it: i64 = 0;
    while (it < num_iter) {
        let mut warped: Vec<Vec<f64>> = warp(image0.clone(), u.clone(), v.clone());
        let mut dx1: Vec<Vec<f64>> = convolve(warped.clone(), kernel_x.clone());
        let mut dx2: Vec<Vec<f64>> = convolve(image1.clone(), kernel_x.clone());
        let mut dy1: Vec<Vec<f64>> = convolve(warped.clone(), kernel_y.clone());
        let mut dy2: Vec<Vec<f64>> = convolve(image1.clone(), kernel_y.clone());
        let mut dt1: Vec<Vec<f64>> = convolve(warped.clone(), kernel_t.clone());
        let mut dt2: Vec<Vec<f64>> = convolve(image1.clone(), kernel_t.clone());
        let mut avg_u: Vec<Vec<f64>> = convolve(u.clone(), laplacian.clone());
        let mut avg_v: Vec<Vec<f64>> = convolve(v.clone(), laplacian.clone());
        let mut y: i64 = 0;
        while (y < h) {
            let mut x: i64 = 0;
            while (x < w) {
                let mut dx: f64 = (dx1[y as usize].clone()[x as usize] + dx2[y as usize].clone()[x as usize]);
                let mut dy: f64 = (dy1[y as usize].clone()[x as usize] + dy2[y as usize].clone()[x as usize]);
                let mut dt: f64 = (dt1[y as usize].clone()[x as usize] - dt2[y as usize].clone()[x as usize]);
                let mut au: f64 = avg_u[y as usize].clone()[x as usize];
                let mut av: f64 = avg_v[y as usize].clone()[x as usize];
                let mut numer: f64 = (((dx * au) + (dy * av)) + dt);
                let mut denom: f64 = (((alpha * alpha) + (dx * dx)) + (dy * dy));
                let mut upd: f64 = (numer / denom);
                u[y as usize][x as usize] = (au - (dx * upd));
                v[y as usize][x as usize] = (av - (dy * upd));
                x = (x + 1);
            }
            y = (y + 1);
        }
        it = (it + 1);
    }
    return vec![u, v]
};
    fn print_matrix(mut mat: Vec<Vec<f64>>) {
    let mut y: i64 = 0;
    while (y < (mat.len() as i64)) {
        let mut row: Vec<f64> = mat[y as usize].clone();
        let mut x: i64 = 0;
        let mut line: String = String::from("").clone();
        while (x < (row.len() as i64)) {
            line = format!("{}{}", line, round_int(row[x as usize]).to_string());
            if ((x + 1) < (row.len() as i64)) {
                line = format!("{}{}", line, " ");
            }
            x = (x + 1);
        }
        println!("{}", line);
        y = (y + 1);
    }
};
    fn mochi_main() {
    let mut image0: Vec<Vec<f64>> = vec![vec![0.0, 0.0, 2.0], vec![0.0, 0.0, 2.0]];
    let mut image1: Vec<Vec<f64>> = vec![vec![0.0, 2.0, 0.0], vec![0.0, 2.0, 0.0]];
    let mut flows: Vec<Vec<Vec<f64>>> = horn_schunck(image0.clone(), image1.clone(), 20, 0.1);
    let mut u: Vec<Vec<f64>> = flows[0 as usize].clone();
    let mut v: Vec<Vec<f64>> = flows[1 as usize].clone();
    print_matrix(u.clone());
    println!("{}", "---");
    print_matrix(v.clone());
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
