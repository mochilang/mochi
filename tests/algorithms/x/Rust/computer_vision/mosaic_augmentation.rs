// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct MosaicResult {
    img: Vec<Vec<i64>>,
    annos: Vec<Vec<f64>>,
    path: String,
}
impl std::fmt::Display for MosaicResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"img\": {:?}", self.img)?;
        write!(f, ", ")?;
        write!(f, "\"annos\": {:?}", self.annos)?;
        write!(f, ", ")?;
        write!(f, "\"path\": \"{}\"", self.path)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn update_image_and_anno(mut all_img_list: Vec<String>, mut all_annos: Vec<Vec<Vec<f64>>>, mut idxs: Vec<i64>, mut output_size: Vec<i64>, mut scale_range: Vec<f64>, mut filter_scale: f64) -> MosaicResult {
    let mut height: i64 = output_size[0 as usize];
    let mut width: i64 = output_size[1 as usize];
    let mut output_img: Vec<Vec<i64>> = Default::default();
    let mut r: i64 = 0;
    while (r < height) {
        let mut row: Vec<i64> = Default::default();
        let mut c: i64 = 0;
        while (c < width) {
            row = { let mut _v = row.clone(); _v.push(0); _v };
            c = (c + 1);
        }
        output_img = { let mut _v = output_img.clone(); _v.push(row.clone()); _v };
        r = (r + 1);
    }
    let mut scale_x: f64 = ((scale_range[0 as usize] + scale_range[1 as usize]) / 2.0);
    let mut scale_y: f64 = ((scale_range[0 as usize] + scale_range[1 as usize]) / 2.0);
    let mut divid_point_x: i64 = ((scale_x * (width as f64)) as i64);
    let mut divid_point_y: i64 = ((scale_y * (height as f64)) as i64);
    let mut new_anno: Vec<Vec<f64>> = Default::default();
    let mut path_list: Vec<String> = Default::default();
    let mut i: i64 = 0;
    while (i < (idxs.len() as i64)) {
        let mut index: i64 = idxs[i as usize];
        let mut path: String = all_img_list[index as usize].clone().clone();
        path_list = { let mut _v = path_list.clone(); _v.push(path.clone()); _v };
        let mut img_annos: Vec<Vec<f64>> = all_annos[index as usize].clone();
        if (i == 0) {
            let mut y0: i64 = 0;
            while (y0 < divid_point_y) {
                let mut x0: i64 = 0;
                while (x0 < divid_point_x) {
                    output_img[y0 as usize][x0 as usize] = (i + 1);
                    x0 = (x0 + 1);
                }
                y0 = (y0 + 1);
            }
            let mut j0: i64 = 0;
            while (j0 < (img_annos.len() as i64)) {
                let mut bbox: Vec<f64> = img_annos[j0 as usize].clone();
                let mut xmin: f64 = (bbox[1 as usize] * scale_x);
                let mut ymin: f64 = (bbox[2 as usize] * scale_y);
                let mut xmax: f64 = (bbox[3 as usize] * scale_x);
                let mut ymax: f64 = (bbox[4 as usize] * scale_y);
                new_anno = { let mut _v = new_anno.clone(); _v.push(vec![bbox[0 as usize], xmin, ymin, xmax, ymax]); _v };
                j0 = (j0 + 1);
            }
        } else if (i == 1) {
            let mut y1: i64 = 0;
            while (y1 < divid_point_y) {
                let mut x1: i64 = divid_point_x;
                while (x1 < width) {
                    output_img[y1 as usize][x1 as usize] = (i + 1);
                    x1 = (x1 + 1);
                }
                y1 = (y1 + 1);
            }
            let mut j1: i64 = 0;
            while (j1 < (img_annos.len() as i64)) {
                let mut bbox1: Vec<f64> = img_annos[j1 as usize].clone();
                let mut xmin1: f64 = (scale_x + (bbox1[1 as usize] * (1.0 - scale_x)));
                let mut ymin1: f64 = (bbox1[2 as usize] * scale_y);
                let mut xmax1: f64 = (scale_x + (bbox1[3 as usize] * (1.0 - scale_x)));
                let mut ymax1: f64 = (bbox1[4 as usize] * scale_y);
                new_anno = { let mut _v = new_anno.clone(); _v.push(vec![bbox1[0 as usize], xmin1, ymin1, xmax1, ymax1]); _v };
                j1 = (j1 + 1);
            }
        } else if (i == 2) {
            let mut y2: i64 = divid_point_y;
            while (y2 < height) {
                let mut x2: i64 = 0;
                while (x2 < divid_point_x) {
                    output_img[y2 as usize][x2 as usize] = (i + 1);
                    x2 = (x2 + 1);
                }
                y2 = (y2 + 1);
            }
            let mut j2: i64 = 0;
            while (j2 < (img_annos.len() as i64)) {
                let mut bbox2: Vec<f64> = img_annos[j2 as usize].clone();
                let mut xmin2: f64 = (bbox2[1 as usize] * scale_x);
                let mut ymin2: f64 = (scale_y + (bbox2[2 as usize] * (1.0 - scale_y)));
                let mut xmax2: f64 = (bbox2[3 as usize] * scale_x);
                let mut ymax2: f64 = (scale_y + (bbox2[4 as usize] * (1.0 - scale_y)));
                new_anno = { let mut _v = new_anno.clone(); _v.push(vec![bbox2[0 as usize], xmin2, ymin2, xmax2, ymax2]); _v };
                j2 = (j2 + 1);
            }
        } else {
            let mut y3: i64 = divid_point_y;
            while (y3 < height) {
                let mut x3: i64 = divid_point_x;
                while (x3 < width) {
                    output_img[y3 as usize][x3 as usize] = (i + 1);
                    x3 = (x3 + 1);
                }
                y3 = (y3 + 1);
            }
            let mut j3: i64 = 0;
            while (j3 < (img_annos.len() as i64)) {
                let mut bbox3: Vec<f64> = img_annos[j3 as usize].clone();
                let mut xmin3: f64 = (scale_x + (bbox3[1 as usize] * (1.0 - scale_x)));
                let mut ymin3: f64 = (scale_y + (bbox3[2 as usize] * (1.0 - scale_y)));
                let mut xmax3: f64 = (scale_x + (bbox3[3 as usize] * (1.0 - scale_x)));
                let mut ymax3: f64 = (scale_y + (bbox3[4 as usize] * (1.0 - scale_y)));
                new_anno = { let mut _v = new_anno.clone(); _v.push(vec![bbox3[0 as usize], xmin3, ymin3, xmax3, ymax3]); _v };
                j3 = (j3 + 1);
            }
        }
        i = (i + 1);
    }
    if (filter_scale > 0.0) {
        let mut filtered: Vec<Vec<f64>> = Default::default();
        let mut k: i64 = 0;
        while (k < (new_anno.len() as i64)) {
            let mut anno: Vec<f64> = new_anno[k as usize].clone();
            let mut w: f64 = (anno[3 as usize] - anno[1 as usize]);
            let mut h: f64 = (anno[4 as usize] - anno[2 as usize]);
            if ((filter_scale < w) && (filter_scale < h)) {
                filtered = { let mut _v = filtered.clone(); _v.push(anno.clone()); _v };
            }
            k = (k + 1);
        }
        new_anno = filtered.clone();
    }
    return MosaicResult {img: output_img, annos: new_anno, path: path_list[0 as usize].clone().clone()}
};
    fn mochi_main() {
    let mut all_img_list: Vec<String> = vec![String::from("img0.jpg").clone(), String::from("img1.jpg").clone(), String::from("img2.jpg").clone(), String::from("img3.jpg").clone()];
    let mut all_annos: Vec<Vec<Vec<f64>>> = vec![vec![vec![0.0, 0.1, 0.1, 0.4, 0.4]], vec![vec![1.0, 0.2, 0.3, 0.5, 0.7]], vec![vec![2.0, 0.6, 0.2, 0.9, 0.5]], vec![vec![3.0, 0.5, 0.5, 0.8, 0.8]]];
    let mut idxs: Vec<i64> = vec![0, 1, 2, 3];
    let mut output_size: Vec<i64> = vec![100, 100];
    let mut scale_range: Vec<f64> = vec![0.4, 0.6];
    let mut filter_scale: f64 = 0.05;
    let mut res: MosaicResult = update_image_and_anno(all_img_list.clone(), all_annos.clone(), idxs.clone(), output_size.clone(), scale_range.clone(), filter_scale);
    let mut new_annos: Vec<Vec<f64>> = res.annos;
    let mut path: String = res.path.clone();
    println!("{}", format!("{}{}", "Base image: ", path));
    println!("{}", format!("{}{}", "Mosaic annotation count: ", (new_annos.len() as i64).to_string()));
    let mut i: i64 = 0;
    while (i < (new_annos.len() as i64)) {
        let mut a: Vec<f64> = new_annos[i as usize].clone();
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", a[0 as usize].to_string(), " "), a[1 as usize].to_string()), " "), a[2 as usize].to_string()), " "), a[3 as usize].to_string()), " "), a[4 as usize].to_string()));
        i = (i + 1);
    }
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
