// Generated by Mochi transpiler v0.10.61
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Result {
    start: i64,
    end: i64,
    sum: f64,
}
impl std::fmt::Display for Result {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"start\": {}", self.start)?;
        write!(f, ", ")?;
        write!(f, "\"end\": {}", self.end)?;
        write!(f, ", ")?;
        write!(f, "\"sum\": {}", self.sum)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn max_cross_sum(mut arr: Vec<f64>, mut low: i64, mut mid: i64, mut high: i64) -> Result {
    let mut left_sum: f64 = -1000000000000000000.0;
    let mut max_left: i64 = -1;
    let mut sum: f64 = 0.0;
    let mut i: i64 = mid;
    while (i >= low) {
        sum = (sum + arr[i as usize]);
        if (sum > left_sum) {
            left_sum = sum;
            max_left = i;
        }
        i = (i - 1);
    }
    let mut right_sum: f64 = -1000000000000000000.0;
    let mut max_right: i64 = -1;
    sum = 0.0;
    i = (mid + 1);
    while (i <= high) {
        sum = (sum + arr[i as usize]);
        if (sum > right_sum) {
            right_sum = sum;
            max_right = i;
        }
        i = (i + 1);
    }
    return Result {start: max_left, end: max_right, sum: (left_sum + right_sum)}
};
    fn max_subarray(mut arr: Vec<f64>, mut low: i64, mut high: i64) -> Result {
    if ((arr.len() as i64) == 0) {
        return Result {start: -1, end: -1, sum: 0.0}
    }
    if (low == high) {
        return Result {start: low, end: high, sum: arr[low as usize]}
    }
    let mut mid: i64 = ((low + high) / 2);
    let mut left: Result = max_subarray(arr.clone(), low, mid);
    let mut right: Result = max_subarray(arr.clone(), (mid + 1), high);
    let mut cross: Result = max_cross_sum(arr.clone(), low, mid, high);
    if ((left.sum >= right.sum) && (left.sum >= cross.sum)) {
        return left
    }
    if ((right.sum >= left.sum) && (right.sum >= cross.sum)) {
        return right
    }
    return cross
};
    fn show(res: &Result) {
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "[", res.start.to_string()), ", "), res.end.to_string()), ", "), res.sum.to_string()), "]"));
};
    fn mochi_main() {
    let mut nums1: Vec<f64> = vec![-2.0, 1.0, -3.0, 4.0, -1.0, 2.0, 1.0, -5.0, 4.0];
    let mut res1: Result = max_subarray(nums1.clone(), 0, ((nums1.len() as i64) - 1));
    show(&res1);
    let mut nums2: Vec<f64> = vec![2.0, 8.0, 9.0];
    let mut res2: Result = max_subarray(nums2.clone(), 0, ((nums2.len() as i64) - 1));
    show(&res2);
    let mut nums3: Vec<f64> = vec![0.0, 0.0];
    let mut res3: Result = max_subarray(nums3.clone(), 0, ((nums3.len() as i64) - 1));
    show(&res3);
    let mut nums4: Vec<f64> = vec![-1.0, 0.0, 1.0];
    let mut res4: Result = max_subarray(nums4.clone(), 0, ((nums4.len() as i64) - 1));
    show(&res4);
    let mut nums5: Vec<f64> = vec![-2.0, -3.0, -1.0, -4.0, -6.0];
    let mut res5: Result = max_subarray(nums5.clone(), 0, ((nums5.len() as i64) - 1));
    show(&res5);
    let mut nums6: Vec<f64> = vec![];
    let mut res6: Result = max_subarray(nums6.clone(), 0, 0);
    show(&res6);
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
