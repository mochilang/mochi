// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct LSTMWeights {
    w_i: f64,
    u_i: f64,
    b_i: f64,
    w_f: f64,
    u_f: f64,
    b_f: f64,
    w_o: f64,
    u_o: f64,
    b_o: f64,
    w_c: f64,
    u_c: f64,
    b_c: f64,
    w_y: f64,
    b_y: f64,
}
impl std::fmt::Display for LSTMWeights {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"w_i\": {}", self.w_i)?;
        write!(f, ", ")?;
        write!(f, "\"u_i\": {}", self.u_i)?;
        write!(f, ", ")?;
        write!(f, "\"b_i\": {}", self.b_i)?;
        write!(f, ", ")?;
        write!(f, "\"w_f\": {}", self.w_f)?;
        write!(f, ", ")?;
        write!(f, "\"u_f\": {}", self.u_f)?;
        write!(f, ", ")?;
        write!(f, "\"b_f\": {}", self.b_f)?;
        write!(f, ", ")?;
        write!(f, "\"w_o\": {}", self.w_o)?;
        write!(f, ", ")?;
        write!(f, "\"u_o\": {}", self.u_o)?;
        write!(f, ", ")?;
        write!(f, "\"b_o\": {}", self.b_o)?;
        write!(f, ", ")?;
        write!(f, "\"w_c\": {}", self.w_c)?;
        write!(f, ", ")?;
        write!(f, "\"u_c\": {}", self.u_c)?;
        write!(f, ", ")?;
        write!(f, "\"b_c\": {}", self.b_c)?;
        write!(f, ", ")?;
        write!(f, "\"w_y\": {}", self.w_y)?;
        write!(f, ", ")?;
        write!(f, "\"b_y\": {}", self.b_y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct LSTMState {
    i: Vec<f64>,
    f: Vec<f64>,
    o: Vec<f64>,
    g: Vec<f64>,
    c: Vec<f64>,
    h: Vec<f64>,
}
impl std::fmt::Display for LSTMState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"i\": {:?}", self.i)?;
        write!(f, ", ")?;
        write!(f, "\"f\": {:?}", self.f)?;
        write!(f, ", ")?;
        write!(f, "\"o\": {:?}", self.o)?;
        write!(f, ", ")?;
        write!(f, "\"g\": {:?}", self.g)?;
        write!(f, ", ")?;
        write!(f, "\"c\": {:?}", self.c)?;
        write!(f, ", ")?;
        write!(f, "\"h\": {:?}", self.h)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Samples {
    x: Vec<Vec<f64>>,
    y: Vec<f64>,
}
impl std::fmt::Display for Samples {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {:?}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {:?}", self.y)?;
        write!(f, "}}")
    }
}

static mut g_data: Vec<f64> = Vec::new();
static mut g_look_back: i64 = 0;
static mut g_epochs: i64 = 0;
static mut g_lr: f64 = 0.0;
static mut g_test_seq: Vec<f64> = Vec::new();
fn main() {
    unsafe {
        g_data = vec![0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
        g_look_back = 3;
        g_epochs = 200;
        g_lr = 0.1;
        g_test_seq = vec![0.6, 0.7, 0.8];
                let _start: i64 = _now();
        unsafe fn exp_approx(mut x: f64) -> f64 {
    let mut sum: f64 = 1.0;
    let mut term: f64 = 1.0;
    let mut n: i64 = 1;
    while (n < 20) {
        term = ((term * x) / (n as f64));
        sum = (sum + term);
        n = (n + 1);
    }
    return sum
};
        unsafe fn sigmoid(mut x: f64) -> f64 {
    return (1.0 / (1.0 + exp_approx(-x)))
};
        unsafe fn tanh_approx(mut x: f64) -> f64 {
    let mut e: f64 = exp_approx((2.0 * x));
    return ((e - 1.0) / (e + 1.0))
};
        unsafe fn forward(mut seq: Vec<f64>, w: &LSTMWeights) -> LSTMState {
    let mut i_arr: Vec<f64> = vec![];
    let mut f_arr: Vec<f64> = vec![];
    let mut o_arr: Vec<f64> = vec![];
    let mut g_arr: Vec<f64> = vec![];
    let mut c_arr: Vec<f64> = vec![0.0];
    let mut h_arr: Vec<f64> = vec![0.0];
    let mut t: i64 = 0;
    while (t < (seq.len() as i64)) {
        let mut x: f64 = seq[t as usize];
        let mut h_prev: f64 = h_arr[t as usize];
        let mut c_prev: f64 = c_arr[t as usize];
        let mut i_t: f64 = sigmoid((((w.w_i * x) + (w.u_i * h_prev)) + w.b_i));
        let mut f_t: f64 = sigmoid((((w.w_f * x) + (w.u_f * h_prev)) + w.b_f));
        let mut o_t: f64 = sigmoid((((w.w_o * x) + (w.u_o * h_prev)) + w.b_o));
        let mut g_t: f64 = tanh_approx((((w.w_c * x) + (w.u_c * h_prev)) + w.b_c));
        let mut c_t: f64 = ((f_t * c_prev) + (i_t * g_t));
        let mut h_t: f64 = (o_t * tanh_approx(c_t));
        i_arr = { let mut _v = i_arr.clone(); _v.push(i_t); _v };
        f_arr = { let mut _v = f_arr.clone(); _v.push(f_t); _v };
        o_arr = { let mut _v = o_arr.clone(); _v.push(o_t); _v };
        g_arr = { let mut _v = g_arr.clone(); _v.push(g_t); _v };
        c_arr = { let mut _v = c_arr.clone(); _v.push(c_t); _v };
        h_arr = { let mut _v = h_arr.clone(); _v.push(h_t); _v };
        t = (t + 1);
    }
    return LSTMState {i: i_arr, f: f_arr, o: o_arr, g: g_arr, c: c_arr, h: h_arr}
};
        unsafe fn backward(mut seq: Vec<f64>, mut target: f64, mut w: LSTMWeights, s: &LSTMState, mut lr: f64) -> LSTMWeights {
    let mut dw_i: f64 = 0.0;
    let mut du_i: f64 = 0.0;
    let mut db_i: f64 = 0.0;
    let mut dw_f: f64 = 0.0;
    let mut du_f: f64 = 0.0;
    let mut db_f: f64 = 0.0;
    let mut dw_o: f64 = 0.0;
    let mut du_o: f64 = 0.0;
    let mut db_o: f64 = 0.0;
    let mut dw_c: f64 = 0.0;
    let mut du_c: f64 = 0.0;
    let mut db_c: f64 = 0.0;
    let mut dw_y: f64 = 0.0;
    let mut db_y: f64 = 0.0;
    let mut T: i64 = (seq.len() as i64);
    let mut h_last: f64 = s.h.clone()[T as usize];
    let mut y: f64 = ((w.w_y * h_last) + w.b_y);
    let mut dy: f64 = (y - target);
    dw_y = (dy * h_last);
    db_y = dy;
    let mut dh_next: f64 = (dy * w.w_y);
    let mut dc_next: f64 = 0.0;
    let mut t: i64 = (T - 1);
    while (t >= 0) {
        let mut i_t: f64 = s.i.clone()[t as usize];
        let mut f_t: f64 = s.f.clone()[t as usize];
        let mut o_t: f64 = s.o.clone()[t as usize];
        let mut g_t: f64 = s.g.clone()[t as usize];
        let mut c_t: f64 = s.c.clone()[(t + 1) as usize];
        let mut c_prev: f64 = s.c.clone()[t as usize];
        let mut h_prev: f64 = s.h.clone()[t as usize];
        let mut tanh_c: f64 = tanh_approx(c_t);
        let mut do_t: f64 = (dh_next * tanh_c);
        let mut da_o: f64 = ((do_t * o_t) * (1.0 - o_t));
        let mut dc: f64 = (((dh_next * o_t) * (1.0 - (tanh_c * tanh_c))) + dc_next);
        let mut di_t: f64 = (dc * g_t);
        let mut da_i: f64 = ((di_t * i_t) * (1.0 - i_t));
        let mut dg_t: f64 = (dc * i_t);
        let mut da_g: f64 = (dg_t * (1.0 - (g_t * g_t)));
        let mut df_t: f64 = (dc * c_prev);
        let mut da_f: f64 = ((df_t * f_t) * (1.0 - f_t));
        dw_i = (dw_i + (da_i * seq[t as usize]));
        du_i = (du_i + (da_i * h_prev));
        db_i = (db_i + da_i);
        dw_f = (dw_f + (da_f * seq[t as usize]));
        du_f = (du_f + (da_f * h_prev));
        db_f = (db_f + da_f);
        dw_o = (dw_o + (da_o * seq[t as usize]));
        du_o = (du_o + (da_o * h_prev));
        db_o = (db_o + da_o);
        dw_c = (dw_c + (da_g * seq[t as usize]));
        du_c = (du_c + (da_g * h_prev));
        db_c = (db_c + da_g);
        dh_next = ((((da_i * w.u_i) + (da_f * w.u_f)) + (da_o * w.u_o)) + (da_g * w.u_c));
        dc_next = (dc * f_t);
        t = (t - 1);
    }
    w.w_y = (w.w_y - (lr * dw_y));
    w.b_y = (w.b_y - (lr * db_y));
    w.w_i = (w.w_i - (lr * dw_i));
    w.u_i = (w.u_i - (lr * du_i));
    w.b_i = (w.b_i - (lr * db_i));
    w.w_f = (w.w_f - (lr * dw_f));
    w.u_f = (w.u_f - (lr * du_f));
    w.b_f = (w.b_f - (lr * db_f));
    w.w_o = (w.w_o - (lr * dw_o));
    w.u_o = (w.u_o - (lr * du_o));
    w.b_o = (w.b_o - (lr * db_o));
    w.w_c = (w.w_c - (lr * dw_c));
    w.u_c = (w.u_c - (lr * du_c));
    w.b_c = (w.b_c - (lr * db_c));
    return w
};
        unsafe fn make_samples(mut data: Vec<f64>, mut look_back: i64) -> Samples {
    let mut X: Vec<Vec<f64>> = vec![];
    let mut Y: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while ((i + look_back) < (data.len() as i64)) {
        let mut seq: Vec<f64> = data[i as usize..(i + look_back) as usize].to_vec();
        X = { let mut _v = X.clone(); _v.push(seq.clone()); _v };
        Y = { let mut _v = Y.clone(); _v.push(data[(i + look_back) as usize]); _v };
        i = (i + 1);
    }
    return Samples {x: X, y: Y}
};
        unsafe fn init_weights() -> LSTMWeights {
    return LSTMWeights {w_i: 0.1, u_i: 0.2, b_i: 0.0, w_f: 0.1, u_f: 0.2, b_f: 0.0, w_o: 0.1, u_o: 0.2, b_o: 0.0, w_c: 0.1, u_c: 0.2, b_c: 0.0, w_y: 0.1, b_y: 0.0}
};
        unsafe fn train(mut data: Vec<f64>, mut look_back: i64, mut epochs: i64, mut lr: f64) -> LSTMWeights {
    let mut samples: Samples = make_samples(data.clone(), look_back);
    let mut w: LSTMWeights = init_weights();
    let mut ep: i64 = 0;
    while (ep < epochs) {
        let mut j: i64 = 0;
        while (j < (samples.x.clone().len() as i64)) {
            let mut seq: Vec<f64> = samples.x.clone()[j as usize].clone();
            let mut target: f64 = samples.y.clone()[j as usize];
            let mut state: LSTMState = forward(seq.clone(), &w);
            w = backward(seq.clone(), target, w, &state, lr);
            j = (j + 1);
        }
        ep = (ep + 1);
    }
    return w
};
        unsafe fn predict(mut seq: Vec<f64>, w: &LSTMWeights) -> f64 {
    let mut state: LSTMState = forward(seq.clone(), w);
    let mut h_last: f64 = state.h.clone()[((state.h.clone().len() as i64) - 1) as usize];
    return ((w.w_y * h_last) + w.b_y)
};
        let mut w: LSTMWeights = train(g_data.clone(), g_look_back, g_epochs, g_lr);
        let mut pred: f64 = predict(g_test_seq.clone(), &w);
        println!("{}", format!("{}{}", "Predicted value: ", pred.to_string()));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
