// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Point {
    x: i64,
    y: i64,
}
impl std::fmt::Display for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {}", self.y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Node {
    pos: Point,
    parent: Point,
    g: i64,
    h: i64,
    f: i64,
}
impl std::fmt::Display for Node {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"pos\": {}", self.pos)?;
        write!(f, ", ")?;
        write!(f, "\"parent\": {}", self.parent)?;
        write!(f, ", ")?;
        write!(f, "\"g\": {}", self.g)?;
        write!(f, ", ")?;
        write!(f, "\"h\": {}", self.h)?;
        write!(f, ", ")?;
        write!(f, "\"f\": {}", self.f)?;
        write!(f, "}}")
    }
}

static g_world_x: i64 = 5;
static g_world_y: i64 = 5;
static g_start: Point = Point {x: 0, y: 0};
static g_goal: Point = Point {x: 4, y: 4};
fn main() {
    unsafe {
                let _start: i64 = _now();
        fn get_neighbours(mut p: Point, mut x_limit: i64, mut y_limit: i64) -> Vec<Point> {
    let deltas: Vec<Point> = vec![Point {x: (0 - 1), y: (0 - 1)}.clone(), Point {x: (0 - 1), y: 0}.clone(), Point {x: (0 - 1), y: 1}.clone(), Point {x: 0, y: (0 - 1)}.clone(), Point {x: 0, y: 1}.clone(), Point {x: 1, y: (0 - 1)}.clone(), Point {x: 1, y: 0}.clone(), Point {x: 1, y: 1}.clone()];
    let mut neighbours: Vec<Point> = vec![];
    for d in deltas.iter().cloned() {
        let nx: i64 = (p.x + d.x);
        let ny: i64 = (p.y + d.y);
        if ((((0 <= nx) && (nx < x_limit)) && (0 <= ny)) && (ny < y_limit)) {
            neighbours = { let mut _v = neighbours.clone(); _v.push(Point {x: nx, y: ny}); _v };
        }
    }
    return neighbours
};
        fn contains(mut nodes: Vec<Node>, mut p: Point) -> bool {
    for n in nodes.iter().cloned() {
        if ((n.pos.clone().x == p.x) && (n.pos.clone().y == p.y)) {
            return true
        }
    }
    return false
};
        fn get_node(mut nodes: Vec<Node>, mut p: Point) -> Node {
    for n in nodes.iter().cloned() {
        if ((n.pos.clone().x == p.x) && (n.pos.clone().y == p.y)) {
            return n
        }
    }
    return Node {pos: p.clone(), parent: Point {x: (0 - 1), y: (0 - 1)}, g: 0, h: 0, f: 0}
};
        fn astar(mut x_limit: i64, mut y_limit: i64, mut start: Point, mut goal: Point) -> Vec<Point> {
    let mut open: Vec<Node> = vec![];
    let mut closed: Vec<Node> = vec![];
    open = { let mut _v = open.clone(); _v.push(Node {pos: start.clone(), parent: Point {x: (0 - 1), y: (0 - 1)}, g: 0, h: 0, f: 0}); _v };
    let mut current: Node = open[0 as usize].clone();
    while ((open.len() as i64) > 0) {
        let mut min_index: i64 = 0;
        let mut i: i64 = 1;
        while (i < (open.len() as i64)) {
            if (open[i as usize].clone().f < open[min_index as usize].clone().f) {
                min_index = i;
            }
            i = (i + 1);
        }
        current = open[min_index as usize].clone();
        let mut new_open: Vec<Node> = vec![];
        let mut j: i64 = 0;
        while (j < (open.len() as i64)) {
            if (j != min_index) {
                new_open = { let mut _v = new_open.clone(); _v.push(open[j as usize].clone()); _v };
            }
            j = (j + 1);
        }
        open = new_open.clone();
        closed = { let mut _v = closed.clone(); _v.push(current.clone()); _v };
        if ((current.pos.clone().x == goal.x) && (current.pos.clone().y == goal.y)) {
            break
        }
        let neighbours: Vec<Point> = get_neighbours(current.pos.clone(), x_limit, y_limit);
        for np in neighbours.iter().cloned() {
            if contains(closed.clone(), np.clone()) {
                continue
            }
            let g: i64 = (current.g + 1);
            let dx: i64 = (goal.x - np.x);
            let dy: i64 = (goal.y - np.y);
            let h: i64 = ((dx * dx) + (dy * dy));
            let f: i64 = (g + h);
            let mut skip: bool = false;
            for node in open.iter().cloned() {
                if (((node.pos.clone().x == np.x) && (node.pos.clone().y == np.y)) && (node.f < f)) {
                    skip = true;
                }
            }
            if skip {
                continue
            }
            open = { let mut _v = open.clone(); _v.push(Node {pos: np.clone(), parent: current.pos.clone(), g: g, h: h, f: f}); _v };
        }
    }
    let mut path: Vec<Point> = vec![];
    path = { let mut _v = path.clone(); _v.push(current.pos.clone()); _v };
    while !((current.parent.clone().x == (0 - 1)) && (current.parent.clone().y == (0 - 1))) {
        current = get_node(closed.clone(), current.parent.clone());
        path = { let mut _v = path.clone(); _v.push(current.pos.clone()); _v };
    }
    let mut rev: Vec<Point> = vec![];
    let mut k: i64 = ((path.len() as i64) - 1);
    while (k >= 0) {
        rev = { let mut _v = rev.clone(); _v.push(path[k as usize].clone()); _v };
        k = (k - 1);
    }
    return rev
};
        fn create_world(mut x_limit: i64, mut y_limit: i64) -> Vec<Vec<i64>> {
    let mut world: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < x_limit) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < y_limit) {
            row = { let mut _v = row.clone(); _v.push(0); _v };
            j = (j + 1);
        }
        world = { let mut _v = world.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return world
};
        fn mark_path(world: &mut Vec<Vec<i64>>, mut path: Vec<Point>) {
    for p in path.iter().cloned() {
        (*world)[p.x as usize][p.y as usize] = 1;
    }
};
        fn print_world(mut world: Vec<Vec<i64>>) {
    for row in world.iter() {
        println!("{}", format!("{:?}", row));
    }
};
        let path: Vec<Point> = astar(unsafe { g_world_x.clone() }, unsafe { g_world_y.clone() }, unsafe { g_start.clone() }.clone(), unsafe { g_goal.clone() }.clone());
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "path from (", unsafe { g_start.clone() }.x.to_string()), ", "), unsafe { g_start.clone() }.y.to_string()), ") to ("), unsafe { g_goal.clone() }.x.to_string()), ", "), unsafe { g_goal.clone() }.y.to_string()), ")"));
        let mut world: Vec<Vec<i64>> = create_world(unsafe { g_world_x.clone() }, unsafe { g_world_y.clone() });
        mark_path(&mut world, path.clone());
        print_world(world.clone());
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
