// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct PCAResult {
    transformed: Vec<Vec<f64>>,
    variance_ratio: Vec<f64>,
}
impl std::fmt::Display for PCAResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"transformed\": {:?}", self.transformed)?;
        write!(f, ", ")?;
        write!(f, "\"variance_ratio\": {:?}", self.variance_ratio)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Eigen {
    values: Vec<f64>,
    vectors: Vec<Vec<f64>>,
}
impl std::fmt::Display for Eigen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"values\": {:?}", self.values)?;
        write!(f, ", ")?;
        write!(f, "\"vectors\": {:?}", self.vectors)?;
        write!(f, "}}")
    }
}

static mut g_data: Vec<Vec<f64>> = Vec::new();
static mut g_idx: i64 = 0;
fn main() {
    unsafe {
        g_data = vec![vec![2.5, 2.4].clone(), vec![0.5, 0.7].clone(), vec![2.2, 2.9].clone(), vec![1.9, 2.2].clone(), vec![3.1, 3.0].clone(), vec![2.3, 2.7].clone(), vec![2.0, 1.6].clone(), vec![1.0, 1.1].clone(), vec![1.5, 1.6].clone(), vec![1.1, 0.9].clone()];
        g_idx = 0;
                let _start: i64 = _now();
        unsafe fn sqrt(mut x: f64) -> f64 {
    let mut guess: f64 = if (x > 1.0) { (x / 2.0) } else { 1.0 };
    let mut i: i64 = 0;
    while (i < 20) {
        guess = (0.5 * (guess + (x / guess)));
        i = (i + 1);
    }
    return guess
};
        unsafe fn mean(mut xs: Vec<f64>) -> f64 {
    let mut sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        sum = (sum + xs[i as usize]);
        i = (i + 1);
    }
    return (sum / ((xs.len() as i64) as f64))
};
        unsafe fn standardize(mut data: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut n_samples: i64 = (data.len() as i64);
    let mut n_features: i64 = (data[0 as usize].clone().len() as i64);
    let mut means: Vec<f64> = vec![];
    let mut stds: Vec<f64> = vec![];
    let mut j: i64 = 0;
    while (j < n_features) {
        let mut column: Vec<f64> = vec![];
        let mut i: i64 = 0;
        while (i < n_samples) {
            column = { let mut _v = column.clone(); _v.push(data[i as usize].clone()[j as usize]); _v };
            i = (i + 1);
        }
        let mut m: f64 = mean(column.clone());
        means = { let mut _v = means.clone(); _v.push(m); _v };
        let mut variance: f64 = 0.0;
        let mut k: i64 = 0;
        while (k < n_samples) {
            let mut diff: f64 = (column[k as usize] - m);
            variance = (variance + (diff * diff));
            k = (k + 1);
        }
        stds = { let mut _v = stds.clone(); _v.push(sqrt((variance / ((n_samples - 1) as f64)))); _v };
        j = (j + 1);
    }
    let mut standardized: Vec<Vec<f64>> = vec![];
    let mut r: i64 = 0;
    while (r < n_samples) {
        let mut row: Vec<f64> = vec![];
        let mut c: i64 = 0;
        while (c < n_features) {
            row = { let mut _v = row.clone(); _v.push(((data[r as usize].clone()[c as usize] - means[c as usize]) / stds[c as usize])); _v };
            c = (c + 1);
        }
        standardized = { let mut _v = standardized.clone(); _v.push(row.clone()); _v };
        r = (r + 1);
    }
    return standardized
};
        unsafe fn covariance_matrix(mut data: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut n_samples: i64 = (data.len() as i64);
    let mut n_features: i64 = (data[0 as usize].clone().len() as i64);
    let mut cov: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < n_features) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < n_features) {
            let mut sum: f64 = 0.0;
            let mut k: i64 = 0;
            while (k < n_samples) {
                sum = (sum + (data[k as usize].clone()[i as usize] * data[k as usize].clone()[j as usize]));
                k = (k + 1);
            }
            row = { let mut _v = row.clone(); _v.push((sum / ((n_samples - 1) as f64))); _v };
            j = (j + 1);
        }
        cov = { let mut _v = cov.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return cov
};
        unsafe fn normalize(mut vec: Vec<f64>) -> Vec<f64> {
    let mut sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (vec.len() as i64)) {
        sum = (sum + (vec[i as usize] * vec[i as usize]));
        i = (i + 1);
    }
    let mut n: f64 = sqrt(sum);
    let mut res: Vec<f64> = vec![];
    let mut j: i64 = 0;
    while (j < (vec.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push((vec[j as usize] / n)); _v };
        j = (j + 1);
    }
    return res
};
        unsafe fn eigen_decomposition_2x2(mut matrix: Vec<Vec<f64>>) -> Eigen {
    let mut a: f64 = matrix[0 as usize].clone()[0 as usize];
    let mut b: f64 = matrix[0 as usize].clone()[1 as usize];
    let mut c: f64 = matrix[1 as usize].clone()[1 as usize];
    let mut diff: f64 = (a - c);
    let mut discriminant: f64 = sqrt(((diff * diff) + ((4.0 * b) * b)));
    let mut lambda1: f64 = (((a + c) + discriminant) / 2.0);
    let mut lambda2: f64 = (((a + c) - discriminant) / 2.0);
    let mut v1: Vec<f64> = Default::default();
    let mut v2: Vec<f64> = Default::default();
    if (b != 0.0) {
        v1 = normalize(vec![(lambda1 - c), b]);
        v2 = normalize(vec![(lambda2 - c), b]);
    } else {
        v1 = vec![1.0, 0.0];
        v2 = vec![0.0, 1.0];
    }
    let mut eigenvalues: Vec<f64> = vec![lambda1, lambda2];
    let mut eigenvectors: Vec<Vec<f64>> = vec![v1.clone(), v2.clone()];
    if (eigenvalues[0 as usize] < eigenvalues[1 as usize]) {
        let mut tmp_val: f64 = eigenvalues[0 as usize];
        eigenvalues[0 as usize] = eigenvalues[1 as usize];
        eigenvalues[1 as usize] = tmp_val;
        let mut tmp_vec: Vec<f64> = eigenvectors[0 as usize].clone();
        eigenvectors[0 as usize] = eigenvectors[1 as usize].clone();
        eigenvectors[1 as usize] = tmp_vec.clone();
    }
    return Eigen {values: eigenvalues, vectors: eigenvectors}
};
        unsafe fn transpose(mut matrix: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut rows: i64 = (matrix.len() as i64);
    let mut cols: i64 = (matrix[0 as usize].clone().len() as i64);
    let mut trans: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < cols) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < rows) {
            row = { let mut _v = row.clone(); _v.push(matrix[j as usize].clone()[i as usize]); _v };
            j = (j + 1);
        }
        trans = { let mut _v = trans.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return trans
};
        unsafe fn matrix_multiply(mut a: Vec<Vec<f64>>, mut b: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut rows_a: i64 = (a.len() as i64);
    let mut cols_a: i64 = (a[0 as usize].clone().len() as i64);
    let mut rows_b: i64 = (b.len() as i64);
    let mut cols_b: i64 = (b[0 as usize].clone().len() as i64);
    if (cols_a != rows_b) {
        panic!("Incompatible matrices");
    }
    let mut result: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < rows_a) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < cols_b) {
            let mut sum: f64 = 0.0;
            let mut k: i64 = 0;
            while (k < cols_a) {
                sum = (sum + (a[i as usize].clone()[k as usize] * b[k as usize].clone()[j as usize]));
                k = (k + 1);
            }
            row = { let mut _v = row.clone(); _v.push(sum); _v };
            j = (j + 1);
        }
        result = { let mut _v = result.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return result
};
        unsafe fn apply_pca(mut data: Vec<Vec<f64>>, mut n_components: i64) -> PCAResult {
    let mut standardized: Vec<Vec<f64>> = standardize(data.clone());
    let mut cov: Vec<Vec<f64>> = covariance_matrix(standardized.clone());
    let mut eig: Eigen = eigen_decomposition_2x2(cov.clone());
    let mut eigenvalues: Vec<f64> = eig.values.clone();
    let mut eigenvectors: Vec<Vec<f64>> = eig.vectors.clone();
    let mut components: Vec<Vec<f64>> = transpose(eigenvectors.clone());
    let mut transformed: Vec<Vec<f64>> = matrix_multiply(standardized.clone(), components.clone());
    let mut total: f64 = (eigenvalues[0 as usize] + eigenvalues[1 as usize]);
    let mut ratios: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < n_components) {
        ratios = { let mut _v = ratios.clone(); _v.push((eigenvalues[i as usize] / total)); _v };
        i = (i + 1);
    }
    return PCAResult {transformed: transformed, variance_ratio: ratios}
};
        let mut result: PCAResult = apply_pca(g_data.clone(), 2);
        println!("{}", "Transformed Data (first 5 rows):");
        while (g_idx < 5) {
            println!("{}", { let tmp = result.transformed.clone()[g_idx as usize].clone(); tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
            g_idx = (g_idx + 1);
        }
        println!("{}", "Explained Variance Ratio:");
        println!("{}", { let tmp = result.variance_ratio.clone(); tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
