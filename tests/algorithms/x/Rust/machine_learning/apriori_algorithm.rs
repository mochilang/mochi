// Generated by Mochi transpiler v0.10.66
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Itemset {
    items: Vec<String>,
    support: i64,
}
impl std::fmt::Display for Itemset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"items\": {:?}", self.items)?;
        write!(f, ", ")?;
        write!(f, "\"support\": {}", self.support)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn load_data() -> Vec<Vec<String>> {
    return vec![vec![String::from("milk").clone()].clone(), vec![String::from("milk").clone(), String::from("butter").clone()].clone(), vec![String::from("milk").clone(), String::from("bread").clone()].clone(), vec![String::from("milk").clone(), String::from("bread").clone(), String::from("chips").clone()].clone()]
};
    fn contains_string(mut xs: Vec<String>, mut s: String) -> bool {
    for v in xs.iter().cloned() {
        if (v.as_str() == s.as_str()) {
            return true
        }
    }
    return false
};
    fn is_subset(mut candidate: Vec<String>, mut transaction: Vec<String>) -> bool {
    for it in candidate.iter().cloned() {
        if !contains_string(transaction.clone(), it.clone()) {
            return false
        }
    }
    return true
};
    fn lists_equal(mut a: Vec<String>, mut b: Vec<String>) -> bool {
    if ((a.len() as i64) != (b.len() as i64)) {
        return false
    }
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        if (a[i as usize].clone().as_str() != b[i as usize].clone().as_str()) {
            return false
        }
        i = (i + 1);
    }
    return true
};
    fn contains_list(mut itemset: Vec<Vec<String>>, mut item: Vec<String>) -> bool {
    for l in itemset.iter() {
        if lists_equal((*l).clone().clone(), item.clone()) {
            return true
        }
    }
    return false
};
    fn count_list(mut itemset: Vec<Vec<String>>, mut item: Vec<String>) -> i64 {
    let mut c: i64 = 0;
    for l in itemset.iter() {
        if lists_equal((*l).clone().clone(), item.clone()) {
            c = (c + 1);
        }
    }
    return c
};
    fn slice_list(mut xs: Vec<Vec<String>>, mut start: i64) -> Vec<Vec<String>> {
    let mut res: Vec<Vec<String>> = vec![];
    let mut i: i64 = start;
    while (i < (xs.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push(xs[i as usize].clone()); _v };
        i = (i + 1);
    }
    return res
};
    fn combinations_lists(mut xs: Vec<Vec<String>>, mut k: i64) -> Vec<Vec<Vec<String>>> {
    let mut result: Vec<Vec<Vec<String>>> = vec![];
    if (k == 0) {
        result = { let mut _v = result.clone(); _v.push(vec![]); _v };
        return result
    }
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        let head: Vec<String> = xs[i as usize].clone();
        let tail: Vec<Vec<String>> = slice_list(xs.clone(), (i + 1));
        let tail_combos: Vec<Vec<Vec<String>>> = combinations_lists(tail.clone(), (k - 1));
        for combo in tail_combos.iter() {
            let mut new_combo: Vec<Vec<String>> = vec![];
            new_combo = { let mut _v = new_combo.clone(); _v.push(head.clone()); _v };
            for c in (*combo).clone() {
                new_combo = { let mut _v = new_combo.clone(); _v.push(c); _v };
            }
            result = { let mut _v = result.clone(); _v.push(new_combo.clone()); _v };
        }
        i = (i + 1);
    }
    return result
};
    fn prune(mut itemset: Vec<Vec<String>>, mut candidates: Vec<Vec<Vec<String>>>, mut length: i64) -> Vec<Vec<String>> {
    let mut pruned: Vec<Vec<String>> = vec![];
    for candidate in candidates.iter() {
        let mut is_subsequence: bool = true;
        for item in (*candidate).clone() {
            if (!contains_list(itemset.clone(), item.clone()) || (count_list(itemset.clone(), item.clone()) < (length - 1))) {
                is_subsequence = false;
                break
            }
        }
        if is_subsequence {
            let mut merged: Vec<String> = vec![];
            for item in (*candidate).clone() {
                for s in item {
                    if !contains_string(merged.clone(), s.to_string()) {
                        merged = { let mut _v = merged.clone(); _v.push(s.to_string()); _v };
                    }
                }
            }
            pruned = { let mut _v = pruned.clone(); _v.push(merged.clone()); _v };
        }
    }
    return pruned
};
    fn sort_strings(mut xs: Vec<String>) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    for s in xs.iter().cloned() {
        res = { let mut _v = res.clone(); _v.push(s.clone()); _v };
    }
    let mut i: i64 = 0;
    while (i < (res.len() as i64)) {
        let mut j: i64 = (i + 1);
        while (j < (res.len() as i64)) {
            if (res[j as usize].clone().as_str() < res[i as usize].clone().as_str()) {
                let tmp: String = res[i as usize].clone().clone();
                res[i as usize] = res[j as usize].clone();
                res[j as usize] = tmp.clone();
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return res
};
    fn itemset_to_string(mut xs: Vec<String>) -> String {
    let mut s: String = String::from("[");
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (i > 0) {
            s = format!("{}{}", s, ", ");
        }
        s = format!("{}{}", format!("{}{}", format!("{}{}", s, "'"), xs[i as usize].clone()), "'");
        i = (i + 1);
    }
    s = format!("{}{}", s, "]");
    return s.clone()
};
    fn apriori(mut data: Vec<Vec<String>>, mut min_support: i64) -> Vec<Itemset> {
    let mut itemset: Vec<Vec<String>> = vec![];
    for transaction in data.iter() {
        let mut t: Vec<String> = vec![];
        for v in (*transaction).clone() {
            t = { let mut _v = t.clone(); _v.push(v.to_string()); _v };
        }
        itemset = { let mut _v = itemset.clone(); _v.push(t.clone()); _v };
    }
    let mut frequent: Vec<Itemset> = vec![];
    let mut length: i64 = 1;
    while ((itemset.len() as i64) > 0) {
        let mut counts: Vec<i64> = vec![];
        let mut idx: i64 = 0;
        while (idx < (itemset.len() as i64)) {
            counts = { let mut _v = counts.clone(); _v.push(0); _v };
            idx = (idx + 1);
        }
        for transaction in data.iter() {
            let mut j: i64 = 0;
            while (j < (itemset.len() as i64)) {
                let candidate: Vec<String> = itemset[j as usize].clone();
                if is_subset(candidate.clone(), (*transaction).clone().clone()) {
                    counts[j as usize] = (counts[j as usize] + 1);
                }
                j = (j + 1);
            }
        }
        let mut new_itemset: Vec<Vec<String>> = vec![];
        let mut k: i64 = 0;
        while (k < (itemset.len() as i64)) {
            if (counts[k as usize] >= min_support) {
                new_itemset = { let mut _v = new_itemset.clone(); _v.push(itemset[k as usize].clone()); _v };
            }
            k = (k + 1);
        }
        itemset = new_itemset.clone();
        let mut m: i64 = 0;
        while (m < (itemset.len() as i64)) {
            let mut sorted_item: Vec<String> = sort_strings(itemset[m as usize].clone());
            frequent = { let mut _v = frequent.clone(); _v.push(Itemset {items: sorted_item.clone(), support: counts[m as usize]}); _v };
            m = (m + 1);
        }
        length = (length + 1);
        let combos: Vec<Vec<Vec<String>>> = combinations_lists(itemset.clone(), length);
        itemset = prune(itemset.clone(), combos.clone(), length);
    }
    return frequent
};
    let mut frequent_itemsets: Vec<Itemset> = apriori(load_data(), 2);
    for fi in frequent_itemsets.iter().cloned() {
        println!("{}", format!("{}{}", format!("{}{}", itemset_to_string(fi.items.clone().clone()), ": "), fi.support.to_string()));
    }
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
