// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Dataset {
    data: Vec<Vec<f64>>,
    target: Vec<f64>,
}
impl std::fmt::Display for Dataset {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"data\": {:?}", self.data)?;
        write!(f, ", ")?;
        write!(f, "\"target\": {:?}", self.target)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Tree {
    threshold: f64,
    left_value: f64,
    right_value: f64,
}
impl std::fmt::Display for Tree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"threshold\": {}", self.threshold)?;
        write!(f, ", ")?;
        write!(f, "\"left_value\": {}", self.left_value)?;
        write!(f, ", ")?;
        write!(f, "\"right_value\": {}", self.right_value)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn data_handling(dataset: &Dataset) -> Dataset {
    return (*dataset).clone()
};
    fn xgboost(mut features: Vec<Vec<f64>>, mut target: Vec<f64>, mut test_features: Vec<Vec<f64>>) -> Vec<f64> {
    let mut learning_rate: f64 = 0.5;
    let mut n_estimators: i64 = 3;
    let mut trees: Vec<Tree> = vec![];
    let mut predictions: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (target.len() as i64)) {
        predictions = { let mut _v = predictions.clone(); _v.push(0.0); _v };
        i = (i + 1);
    }
    let mut est: i64 = 0;
    while (est < n_estimators) {
        let mut residuals: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < (target.len() as i64)) {
            residuals = { let mut _v = residuals.clone(); _v.push((target[j as usize] - predictions[j as usize])); _v };
            j = (j + 1);
        }
        let mut sum_feat: f64 = 0.0;
        j = 0;
        while (j < (features.len() as i64)) {
            sum_feat = (sum_feat + features[j as usize].clone()[0 as usize]);
            j = (j + 1);
        }
        let mut threshold: f64 = (sum_feat / ((features.len() as i64) as f64));
        let mut left_sum: f64 = 0.0;
        let mut left_count: i64 = 0;
        let mut right_sum: f64 = 0.0;
        let mut right_count: i64 = 0;
        j = 0;
        while (j < (features.len() as i64)) {
            if (features[j as usize].clone()[0 as usize] <= threshold) {
                left_sum = (left_sum + residuals[j as usize]);
                left_count = (left_count + 1);
            } else {
                right_sum = (right_sum + residuals[j as usize]);
                right_count = (right_count + 1);
            }
            j = (j + 1);
        }
        let mut left_value: f64 = 0.0;
        if (left_count > 0) {
            left_value = (left_sum / (left_count as f64));
        }
        let mut right_value: f64 = 0.0;
        if (right_count > 0) {
            right_value = (right_sum / (right_count as f64));
        }
        j = 0;
        while (j < (features.len() as i64)) {
            if (features[j as usize].clone()[0 as usize] <= threshold) {
                predictions[j as usize] = (predictions[j as usize] + (learning_rate * left_value));
            } else {
                predictions[j as usize] = (predictions[j as usize] + (learning_rate * right_value));
            }
            j = (j + 1);
        }
        trees = { let mut _v = trees.clone(); _v.push(Tree {threshold: threshold, left_value: left_value, right_value: right_value}); _v };
        est = (est + 1);
    }
    let mut preds: Vec<f64> = vec![];
    let mut t: i64 = 0;
    while (t < (test_features.len() as i64)) {
        let mut pred: f64 = 0.0;
        let mut k: i64 = 0;
        while (k < (trees.len() as i64)) {
            if (test_features[t as usize].clone()[0 as usize] <= trees[k as usize].clone().threshold) {
                pred = (pred + (learning_rate * trees[k as usize].clone().left_value));
            } else {
                pred = (pred + (learning_rate * trees[k as usize].clone().right_value));
            }
            k = (k + 1);
        }
        preds = { let mut _v = preds.clone(); _v.push(pred); _v };
        t = (t + 1);
    }
    return preds
};
    fn mean_absolute_error(mut y_true: Vec<f64>, mut y_pred: Vec<f64>) -> f64 {
    let mut sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (y_true.len() as i64)) {
        let mut diff: f64 = (y_true[i as usize] - y_pred[i as usize]);
        if (diff < 0.0) {
            diff = -diff;
        }
        sum = (sum + diff);
        i = (i + 1);
    }
    return (sum / ((y_true.len() as i64) as f64))
};
    fn mean_squared_error(mut y_true: Vec<f64>, mut y_pred: Vec<f64>) -> f64 {
    let mut sum: f64 = 0.0;
    let mut i: i64 = 0;
    while (i < (y_true.len() as i64)) {
        let mut diff: f64 = (y_true[i as usize] - y_pred[i as usize]);
        sum = (sum + (diff * diff));
        i = (i + 1);
    }
    return (sum / ((y_true.len() as i64) as f64))
};
    fn mochi_main() {
    let mut california: Dataset = Dataset {data: vec![vec![1.0].clone(), vec![2.0].clone(), vec![3.0].clone(), vec![4.0].clone()], target: vec![2.0, 3.0, 4.0, 5.0]};
    let mut ds: Dataset = data_handling(&california);
    let mut x_train: Vec<Vec<f64>> = ds.data.clone();
    let mut y_train: Vec<f64> = ds.target.clone();
    let mut x_test: Vec<Vec<f64>> = vec![vec![1.5].clone(), vec![3.5].clone()];
    let mut y_test: Vec<f64> = vec![2.5, 4.5];
    let mut predictions: Vec<f64> = xgboost(x_train.clone(), y_train.clone(), x_test.clone());
    println!("{}", "Predictions:");
    println!("{}", { let tmp = predictions.clone(); tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
    println!("{}", "Mean Absolute Error:");
    println!("{}", format!("{:?}", mean_absolute_error(y_test.clone(), predictions.clone())));
    println!("{}", "Mean Square Error:");
    println!("{}", format!("{:?}", mean_squared_error(y_test.clone(), predictions.clone())));
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
