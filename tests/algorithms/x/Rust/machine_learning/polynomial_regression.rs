// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_xs: Vec<f64> = Vec::new();
static mut g_ys: Vec<f64> = Vec::new();
static mut g_i: i64 = 0;
fn main() {
    unsafe {
        g_xs = vec![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
        g_ys = vec![];
        g_i = 0;
                let _start: i64 = _now();
        unsafe fn design_matrix(mut xs: Vec<f64>, mut degree: i64) -> Vec<Vec<f64>> {
    let mut i: i64 = 0;
    let mut matrix: Vec<Vec<f64>> = vec![];
    while (i < (xs.len() as i64)) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        let mut pow: f64 = 1.0;
        while (j <= degree) {
            row = { let mut _v = row.clone(); _v.push(pow); _v };
            pow = (pow * xs[i as usize]);
            j = (j + 1);
        }
        matrix = { let mut _v = matrix.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return matrix
};
        unsafe fn transpose(mut matrix: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut rows: i64 = (matrix.len() as i64);
    let mut cols: i64 = (matrix[0 as usize].clone().len() as i64);
    let mut j: i64 = 0;
    let mut result: Vec<Vec<f64>> = vec![];
    while (j < cols) {
        let mut row: Vec<f64> = vec![];
        let mut i: i64 = 0;
        while (i < rows) {
            row = { let mut _v = row.clone(); _v.push(matrix[i as usize].clone()[j as usize]); _v };
            i = (i + 1);
        }
        result = { let mut _v = result.clone(); _v.push(row.clone()); _v };
        j = (j + 1);
    }
    return result
};
        unsafe fn matmul(mut A: Vec<Vec<f64>>, mut B: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut n: i64 = (A.len() as i64);
    let mut m: i64 = (A[0 as usize].clone().len() as i64);
    let mut p: i64 = (B[0 as usize].clone().len() as i64);
    let mut i: i64 = 0;
    let mut result: Vec<Vec<f64>> = vec![];
    while (i < n) {
        let mut row: Vec<f64> = vec![];
        let mut k: i64 = 0;
        while (k < p) {
            let mut sum: f64 = 0.0;
            let mut j: i64 = 0;
            while (j < m) {
                sum = (sum + (A[i as usize].clone()[j as usize] * B[j as usize].clone()[k as usize]));
                j = (j + 1);
            }
            row = { let mut _v = row.clone(); _v.push(sum); _v };
            k = (k + 1);
        }
        result = { let mut _v = result.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return result
};
        unsafe fn matvec_mul(mut A: Vec<Vec<f64>>, mut v: Vec<f64>) -> Vec<f64> {
    let mut n: i64 = (A.len() as i64);
    let mut m: i64 = (A[0 as usize].clone().len() as i64);
    let mut i: i64 = 0;
    let mut result: Vec<f64> = vec![];
    while (i < n) {
        let mut sum: f64 = 0.0;
        let mut j: i64 = 0;
        while (j < m) {
            sum = (sum + (A[i as usize].clone()[j as usize] * v[j as usize]));
            j = (j + 1);
        }
        result = { let mut _v = result.clone(); _v.push(sum); _v };
        i = (i + 1);
    }
    return result
};
        unsafe fn gaussian_elimination(mut A: Vec<Vec<f64>>, mut b: Vec<f64>) -> Vec<f64> {
    let mut n: i64 = (A.len() as i64);
    let mut M: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        M = { let mut _v = M.clone(); _v.push({ let mut _v = A[i as usize].clone().clone(); _v.push(b[i as usize]); _v }); _v };
        i = (i + 1);
    }
    let mut k: i64 = 0;
    while (k < n) {
        let mut j: i64 = (k + 1);
        while (j < n) {
            let mut factor: f64 = (M[j as usize].clone()[k as usize] / M[k as usize].clone()[k as usize]);
            let mut rowj: Vec<f64> = M[j as usize].clone();
            let mut rowk: Vec<f64> = M[k as usize].clone();
            let mut l: i64 = k;
            while (l <= n) {
                rowj[l as usize] = (rowj[l as usize] - (factor * rowk[l as usize]));
                l = (l + 1);
            }
            M[j as usize] = rowj.clone();
            j = (j + 1);
        }
        k = (k + 1);
    }
    let mut x: Vec<f64> = vec![];
    let mut t: i64 = 0;
    while (t < n) {
        x = { let mut _v = x.clone(); _v.push(0.0); _v };
        t = (t + 1);
    }
    let mut i2: i64 = (n - 1);
    while (i2 >= 0) {
        let mut sum: f64 = M[i2 as usize].clone()[n as usize];
        let mut j2: i64 = (i2 + 1);
        while (j2 < n) {
            sum = (sum - (M[i2 as usize].clone()[j2 as usize] * x[j2 as usize]));
            j2 = (j2 + 1);
        }
        x[i2 as usize] = (sum / M[i2 as usize].clone()[i2 as usize]);
        i2 = (i2 - 1);
    }
    return x
};
        unsafe fn predict(mut xs: Vec<f64>, mut coeffs: Vec<f64>) -> Vec<f64> {
    let mut i: i64 = 0;
    let mut result: Vec<f64> = vec![];
    while (i < (xs.len() as i64)) {
        let mut x: f64 = xs[i as usize];
        let mut j: i64 = 0;
        let mut pow: f64 = 1.0;
        let mut sum: f64 = 0.0;
        while (j < (coeffs.len() as i64)) {
            sum = (sum + (coeffs[j as usize] * pow));
            pow = (pow * x);
            j = (j + 1);
        }
        result = { let mut _v = result.clone(); _v.push(sum); _v };
        i = (i + 1);
    }
    return result
};
        while (g_i < (g_xs.len() as i64)) {
            let mut x: f64 = g_xs[g_i as usize];
            g_ys = { let mut _v = g_ys.clone(); _v.push((((((x * x) * x) - ((2.0 * x) * x)) + (3.0 * x)) - 5.0)); _v };
            g_i = (g_i + 1);
        }
        let mut X: Vec<Vec<f64>> = design_matrix(g_xs.clone(), 3);
        let mut Xt: Vec<Vec<f64>> = transpose(X.clone());
        let mut XtX: Vec<Vec<f64>> = matmul(Xt.clone(), X.clone());
        let mut Xty: Vec<f64> = matvec_mul(Xt.clone(), g_ys.clone());
        let mut coeffs: Vec<f64> = gaussian_elimination(XtX.clone(), Xty.clone());
        println!("{}", format!("{:?}", coeffs));
        println!("{}", format!("{:?}", predict(vec![-1.0], coeffs.clone())));
        println!("{}", format!("{:?}", predict(vec![-2.0], coeffs.clone())));
        println!("{}", format!("{:?}", predict(vec![6.0], coeffs.clone())));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
