// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn apply_table(inp: &str, mut table: Vec<i64>) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (table.len() as i64)) {
        let mut idx: i64 = (table[i as usize] - 1);
        if (idx < 0) {
            idx = ((inp.len() as i64) - 1);
        }
        res = format!("{}{}", res, inp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>());
        i = (i + 1);
    }
    return res.clone()
};
    fn left_shift(data: &str) -> String {
    return format!("{}{}", data.chars().skip(1 as usize).take(((data.len() as i64) - 1) as usize).collect::<String>(), data.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>()).clone()
};
    fn xor(a: &str, b: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while ((i < (a.len() as i64)) && (i < (b.len() as i64))) {
        if (a.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str() == b.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()) {
            res = format!("{}{}", res, "0");
        } else {
            res = format!("{}{}", res, "1");
        }
        i = (i + 1);
    }
    return res.clone()
};
    fn int_to_binary(mut n: i64) -> String {
    if (n == 0) {
        return String::from("0")
    }
    let mut res: String = String::from("").clone();
    let mut num: i64 = n;
    while (num > 0) {
        res = format!("{}{}", (num % 2).to_string(), res).to_string();
        num = (num / 2);
    }
    return res.clone()
};
    fn pad_left(s: &str, mut width: i64) -> String {
    let mut res: String = s.to_string().clone();
    while ((res.len() as i64) < width) {
        res = format!("{}{}", "0", res);
    }
    return res.clone()
};
    fn bin_to_int(s: &str) -> i64 {
    let mut result: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let digit = { let n: i64 = s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().parse().unwrap(); n };
        result = ((result * 2) + digit);
        i = (i + 1);
    }
    return result
};
    fn apply_sbox(mut s: Vec<Vec<i64>>, data: &str) -> String {
    let row_bits: String = format!("{}{}", data.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>(), data.chars().skip(((data.len() as i64) - 1) as usize).take(((data.len() as i64) - ((data.len() as i64) - 1)) as usize).collect::<String>()).clone();
    let col_bits: String = data.chars().skip(1 as usize).take((3 - 1) as usize).collect::<String>().clone();
    let row: i64 = bin_to_int(&row_bits);
    let col: i64 = bin_to_int(&col_bits);
    let val: i64 = s[row as usize].clone()[col as usize];
    let out: String = int_to_binary(val).clone();
    return out.clone()
};
    let p4_table: Vec<i64> = vec![2, 4, 3, 1];
    let mut f = move |expansion: Vec<i64>, s0: Vec<Vec<i64>>, s1: Vec<Vec<i64>>, key: &str, message: &str| -> String {
    let left: String = message.chars().skip(0 as usize).take((4 - 0) as usize).collect::<String>().clone();
    let right: String = message.chars().skip(4 as usize).take((8 - 4) as usize).collect::<String>().clone();
    let mut temp: String = apply_table(&right, expansion.clone()).clone();
    temp = xor(&temp, &key);
    let mut left_bin_str: String = apply_sbox(s0.clone(), &temp.chars().skip(0 as usize).take((4 - 0) as usize).collect::<String>()).clone();
    let mut right_bin_str: String = apply_sbox(s1.clone(), &temp.chars().skip(4 as usize).take((8 - 4) as usize).collect::<String>()).clone();
    left_bin_str = pad_left(&left_bin_str, 2);
    right_bin_str = pad_left(&right_bin_str, 2);
    temp = apply_table(&format!("{}{}", left_bin_str, right_bin_str), p4_table.clone());
    temp = xor(&left, &temp);
    return format!("{}{}", temp, right).clone()
};
    let key: String = String::from("1010000010").clone();
    let message: String = String::from("11010111").clone();
    let p8_table: Vec<i64> = vec![6, 3, 7, 4, 8, 5, 10, 9];
    let p10_table: Vec<i64> = vec![3, 5, 2, 7, 4, 10, 1, 9, 8, 6];
    let IP: Vec<i64> = vec![2, 6, 3, 1, 4, 8, 5, 7];
    let IP_inv: Vec<i64> = vec![4, 1, 3, 5, 7, 2, 8, 6];
    let expansion: Vec<i64> = vec![4, 1, 2, 3, 2, 3, 4, 1];
    let s0: Vec<Vec<i64>> = vec![vec![1, 0, 3, 2].clone(), vec![3, 2, 1, 0].clone(), vec![0, 2, 1, 3].clone(), vec![3, 1, 3, 2].clone()];
    let s1: Vec<Vec<i64>> = vec![vec![0, 1, 2, 3].clone(), vec![2, 0, 1, 3].clone(), vec![3, 0, 1, 0].clone(), vec![2, 1, 0, 3].clone()];
    let mut temp: String = apply_table(&key, p10_table.clone()).clone();
    let mut left: String = temp.chars().skip(0 as usize).take((5 - 0) as usize).collect::<String>().clone();
    let mut right: String = temp.chars().skip(5 as usize).take((10 - 5) as usize).collect::<String>().clone();
    left = left_shift(&left);
    right = left_shift(&right);
    let key1: String = apply_table(&format!("{}{}", left, right), p8_table.clone()).clone();
    left = left_shift(&left);
    right = left_shift(&right);
    left = left_shift(&left);
    right = left_shift(&right);
    let key2: String = apply_table(&format!("{}{}", left, right), p8_table.clone()).clone();
    temp = apply_table(&message, IP.clone());
    temp = f(expansion.clone(), s0.clone(), s1.clone(), &key1, &temp);
    temp = format!("{}{}", temp.chars().skip(4 as usize).take((8 - 4) as usize).collect::<String>(), temp.chars().skip(0 as usize).take((4 - 0) as usize).collect::<String>());
    temp = f(expansion.clone(), s0.clone(), s1.clone(), &key2, &temp);
    let CT: String = apply_table(&temp, IP_inv.clone()).clone();
    println!("{}", format!("{}{}", "Cipher text is: ", CT));
    temp = apply_table(&CT, IP.clone());
    temp = f(expansion.clone(), s0.clone(), s1.clone(), &key2, &temp);
    temp = format!("{}{}", temp.chars().skip(4 as usize).take((8 - 4) as usize).collect::<String>(), temp.chars().skip(0 as usize).take((4 - 0) as usize).collect::<String>());
    temp = f(expansion.clone(), s0.clone(), s1.clone(), &key1, &temp);
    let PT: String = apply_table(&temp, IP_inv.clone()).clone();
    println!("{}", format!("{}{}", "Plain text after decypting is: ", PT));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
