// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Entry {
    key: i64,
    val: i64,
    freq: i64,
    order: i64,
}
impl std::fmt::Display for Entry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"key\": {}", self.key)?;
        write!(f, ", ")?;
        write!(f, "\"val\": {}", self.val)?;
        write!(f, ", ")?;
        write!(f, "\"freq\": {}", self.freq)?;
        write!(f, ", ")?;
        write!(f, "\"order\": {}", self.order)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct LFUCache {
    entries: Vec<Entry>,
    capacity: i64,
    hits: i64,
    miss: i64,
    tick: i64,
}
impl std::fmt::Display for LFUCache {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"entries\": {:?}", self.entries)?;
        write!(f, ", ")?;
        write!(f, "\"capacity\": {}", self.capacity)?;
        write!(f, ", ")?;
        write!(f, "\"hits\": {}", self.hits)?;
        write!(f, ", ")?;
        write!(f, "\"miss\": {}", self.miss)?;
        write!(f, ", ")?;
        write!(f, "\"tick\": {}", self.tick)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct GetResult {
    cache: LFUCache,
    value: i64,
    ok: bool,
}
impl std::fmt::Display for GetResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"cache\": {}", self.cache)?;
        write!(f, ", ")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, ", ")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn lfu_new(mut cap: i64) -> LFUCache {
    return LFUCache {entries: vec![], capacity: cap, hits: 0, miss: 0, tick: 0}
};
    fn find_entry(mut entries: Vec<Entry>, mut key: i64) -> i64 {
    let mut i: i64 = 0;
    while (i < (entries.len() as i64)) {
        let e: Entry = entries[i as usize].clone();
        if (e.key == key) {
            return i
        }
        i = (i + 1);
    }
    return (0 - 1)
};
    fn lfu_get(mut cache: LFUCache, mut key: i64) -> GetResult {
    let idx: i64 = find_entry(cache.entries.clone().clone(), key);
    if (idx == (0 - 1)) {
        let new_cache: LFUCache = LFUCache {entries: cache.entries.clone(), capacity: cache.capacity, hits: cache.hits, miss: (cache.miss + 1), tick: cache.tick};
        return GetResult {cache: new_cache.clone(), value: 0, ok: false}
    }
    let mut entries: Vec<Entry> = cache.entries.clone();
    let mut e: Entry = entries[idx as usize].clone();
    e.freq = (e.freq + 1);
    let new_tick: i64 = (cache.tick + 1);
    e.order = new_tick;
    entries[idx as usize] = e.clone();
    let new_cache: LFUCache = LFUCache {entries: entries.clone(), capacity: cache.capacity, hits: (cache.hits + 1), miss: cache.miss, tick: new_tick};
    return GetResult {cache: new_cache.clone(), value: e.val, ok: true}
};
    fn remove_lfu(mut entries: Vec<Entry>) -> Vec<Entry> {
    if ((entries.len() as i64) == 0) {
        return entries
    }
    let mut min_idx: i64 = 0;
    let mut i: i64 = 1;
    while (i < (entries.len() as i64)) {
        let e: Entry = entries[i as usize].clone();
        let m: Entry = entries[min_idx as usize].clone();
        if ((e.freq < m.freq) || ((e.freq == m.freq) && (e.order < m.order))) {
            min_idx = i;
        }
        i = (i + 1);
    }
    let mut res: Vec<Entry> = vec![];
    let mut j: i64 = 0;
    while (j < (entries.len() as i64)) {
        if (j != min_idx) {
            res = { let mut _v = res.clone(); _v.push(entries[j as usize].clone()); _v };
        }
        j = (j + 1);
    }
    return res
};
    fn lfu_put(mut cache: LFUCache, mut key: i64, mut value: i64) -> LFUCache {
    let mut entries: Vec<Entry> = cache.entries.clone();
    let idx: i64 = find_entry(entries.clone(), key);
    if (idx != (0 - 1)) {
        let mut e: Entry = entries[idx as usize].clone();
        e.val = value;
        e.freq = (e.freq + 1);
        let new_tick: i64 = (cache.tick + 1);
        e.order = new_tick;
        entries[idx as usize] = e.clone();
        return LFUCache {entries: entries.clone(), capacity: cache.capacity, hits: cache.hits, miss: cache.miss, tick: new_tick}
    }
    if ((entries.len() as i64) >= cache.capacity) {
        entries = remove_lfu(entries.clone());
    }
    let new_tick: i64 = (cache.tick + 1);
    let new_entry: Entry = Entry {key: key, val: value, freq: 1, order: new_tick};
    entries = { let mut _v = entries.clone(); _v.push(new_entry.clone()); _v };
    return LFUCache {entries: entries.clone(), capacity: cache.capacity, hits: cache.hits, miss: cache.miss, tick: new_tick}
};
    fn cache_info(mut cache: LFUCache) -> String {
    return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "CacheInfo(hits=", cache.hits.to_string()), ", misses="), cache.miss.to_string()), ", capacity="), cache.capacity.to_string()), ", current_size="), (cache.entries.clone().len() as i64).to_string()), ")").clone()
};
    fn mochi_main() {
    let mut cache: LFUCache = lfu_new(2);
    cache = lfu_put(cache.clone(), 1, 1);
    cache = lfu_put(cache.clone(), 2, 2);
    let mut r: GetResult = lfu_get(cache.clone(), 1);
    cache = r.cache.clone();
    if r.ok {
        println!("{}", r.value.to_string());
    } else {
        println!("{}", "None");
    }
    cache = lfu_put(cache.clone(), 3, 3);
    r = lfu_get(cache.clone(), 2);
    cache = r.cache.clone();
    if r.ok {
        println!("{}", r.value.to_string());
    } else {
        println!("{}", "None");
    }
    cache = lfu_put(cache.clone(), 4, 4);
    r = lfu_get(cache.clone(), 1);
    cache = r.cache.clone();
    if r.ok {
        println!("{}", r.value.to_string());
    } else {
        println!("{}", "None");
    }
    r = lfu_get(cache.clone(), 3);
    cache = r.cache.clone();
    if r.ok {
        println!("{}", r.value.to_string());
    } else {
        println!("{}", "None");
    }
    r = lfu_get(cache.clone(), 4);
    cache = r.cache.clone();
    if r.ok {
        println!("{}", r.value.to_string());
    } else {
        println!("{}", "None");
    }
    println!("{}", cache_info(cache.clone()));
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
