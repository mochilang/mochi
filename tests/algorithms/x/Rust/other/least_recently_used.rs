// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct LRUCache {
    max_capacity: i64,
    store: Vec<String>,
}
impl std::fmt::Display for LRUCache {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"max_capacity\": {}", self.max_capacity)?;
        write!(f, ", ")?;
        write!(f, "\"store\": {:?}", self.store)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn new_cache(mut n: i64) -> LRUCache {
    if (n < 0) {
        panic!("n should be an integer greater than 0.");
    }
    let cap: i64 = if (n == 0) { 2147483647 } else { n };
    return LRUCache {max_capacity: cap, store: vec![]}
};
    fn remove_element(mut xs: Vec<String>, mut x: String) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut removed: bool = false;
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        let v: String = xs[i as usize].clone().clone();
        if ((removed == false) && (v.as_str() == x.as_str())) {
            removed = true;
        } else {
            res = { let mut _v = res.clone(); _v.extend(vec![v.clone()]); _v };
        }
        i = (i + 1);
    }
    return res
};
    fn refer(mut cache: LRUCache, mut x: String) -> LRUCache {
    let mut store: Vec<String> = cache.store.clone();
    let mut exists: bool = false;
    let mut i: i64 = 0;
    while (i < (store.len() as i64)) {
        if (store[i as usize].clone().as_str() == x.as_str()) {
            exists = true;
        }
        i = (i + 1);
    }
    if exists {
        store = remove_element(store.clone(), x.clone());
    } else {
        if ((store.len() as i64) == cache.max_capacity) {
            let mut new_store: Vec<String> = vec![];
            let mut j: i64 = 0;
            while (j < ((store.len() as i64) - 1)) {
                new_store = { let mut _v = new_store.clone(); _v.extend(vec![store[j as usize].clone().clone()]); _v };
                j = (j + 1);
            }
            store = new_store.clone();
        }
    }
    store = { let mut _v = vec![x.clone()].clone(); _v.extend(store); _v };
    return LRUCache {max_capacity: cache.max_capacity, store: store.clone()}
};
    fn display(mut cache: LRUCache) {
    let mut i: i64 = 0;
    while (i < (cache.store.clone().len() as i64)) {
        println!("{}", cache.store.clone()[i as usize].clone());
        i = (i + 1);
    }
};
    fn repr_item(mut s: String) -> String {
    let mut all_digits: bool = true;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let ch: String = s.chars().nth(i as usize).unwrap().to_string().clone();
        if ((ch.as_str() < "0") || (ch.as_str() > "9")) {
            all_digits = false;
        }
        i = (i + 1);
    }
    if all_digits {
        return s
    }
    return format!("{}{}", format!("{}{}", "'", s), "'").clone()
};
    fn cache_repr(mut cache: LRUCache) -> String {
    let mut res: String = format!("{}{}", format!("{}{}", "LRUCache(", cache.max_capacity.to_string()), ") => [").clone();
    let mut i: i64 = 0;
    while (i < (cache.store.clone().len() as i64)) {
        res = format!("{}{}", res, repr_item(cache.store.clone()[i as usize].clone()));
        if (i < ((cache.store.clone().len() as i64) - 1)) {
            res = format!("{}{}", res, ", ");
        }
        i = (i + 1);
    }
    res = format!("{}{}", res, "]");
    return res.clone()
};
    let mut lru: LRUCache = new_cache(4);
    lru = refer(lru.clone(), String::from("A"));
    lru = refer(lru.clone(), String::from("2"));
    lru = refer(lru.clone(), String::from("3"));
    lru = refer(lru.clone(), String::from("A"));
    lru = refer(lru.clone(), String::from("4"));
    lru = refer(lru.clone(), String::from("5"));
    let mut r: String = cache_repr(lru.clone()).clone();
    println!("{}", r);
    if (r.as_str() != "LRUCache(4) => [5, 4, 'A', 3]") {
        panic!("Assertion error");
    }
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
