// Generated by Mochi transpiler v0.10.64
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Clause {
    literals: HashMap<String, i64>,
    names: Vec<String>,
}
impl std::fmt::Display for Clause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"literals\": {:?}", self.literals)?;
        write!(f, ", ")?;
        write!(f, "\"names\": {:?}", self.names)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct EvalResult {
    value: i64,
    clause: Clause,
}
impl std::fmt::Display for EvalResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, ", ")?;
        write!(f, "\"clause\": {}", self.clause)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Formula {
    clauses: Vec<Clause>,
}
impl std::fmt::Display for Formula {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"clauses\": {:?}", self.clauses)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct DPLLResult {
    sat: bool,
    model: HashMap<String, i64>,
}
impl std::fmt::Display for DPLLResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"sat\": {}", self.sat)?;
        write!(f, ", ")?;
        write!(f, "\"model\": {:?}", self.model)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn new_clause(mut lits: Vec<String>) -> Clause {
    let mut m: HashMap<String, i64> = HashMap::new();
    let mut names: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (lits.len() as i64)) {
        let lit: String = lits[i as usize].clone().clone();
        m.insert(lit.clone(), (0 - 1));
        names = { let mut _v = names.clone(); _v.push(lit.clone()); _v };
        i = (i + 1);
    }
    return Clause {literals: m.clone(), names: names.clone()}
};
    fn assign_clause(mut c: Clause, mut model: HashMap<String, i64>) -> Clause {
    let mut lits: HashMap<String, i64> = c.literals.clone();
    let mut i: i64 = 0;
    while (i < (c.names.clone().len() as i64)) {
        let lit: String = c.names.clone()[i as usize].clone().clone();
        let symbol: String = { let tmp = &lit; tmp.chars().skip(0 as usize).take((2 - 0) as usize).collect::<String>() }.clone();
        if model.contains_key(&symbol) {
            let mut value: i64 = model.get(symbol.as_str()).cloned().unwrap_or_default();
            if (({ let tmp = &lit; tmp.chars().skip(((lit.len() as i64) - 1) as usize).take(((lit.len() as i64) - ((lit.len() as i64) - 1)) as usize).collect::<String>() }.as_str() == "'") && (value != (0 - 1))) {
                value = (1 - value);
            }
            lits.insert(lit.clone(), value);
        }
        i = (i + 1);
    }
    c.literals = lits.clone();
    return c
};
    fn evaluate_clause(mut c: Clause, mut model: HashMap<String, i64>) -> EvalResult {
    let mut i: i64 = 0;
    while (i < (c.names.clone().len() as i64)) {
        let lit: String = c.names.clone()[i as usize].clone().clone();
        let sym: String = if ({ let tmp = &lit; tmp.chars().skip(((lit.len() as i64) - 1) as usize).take(((lit.len() as i64) - ((lit.len() as i64) - 1)) as usize).collect::<String>() }.as_str() == "'") { { let tmp = &lit; tmp.chars().skip(0 as usize).take((2 - 0) as usize).collect::<String>() } } else { format!("{}{}", lit, "'") }.clone();
        if c.literals.clone().contains_key(&sym) {
            return EvalResult {value: 1, clause: c.clone()}
        }
        i = (i + 1);
    }
    c = assign_clause(c.clone(), model.clone());
    i = 0;
    while (i < (c.names.clone().len() as i64)) {
        let lit: String = c.names.clone()[i as usize].clone().clone();
        let value: i64 = c.literals.clone()[lit.as_str()];
        if (value == 1) {
            return EvalResult {value: 1, clause: c.clone()}
        }
        if (value == (0 - 1)) {
            return EvalResult {value: (0 - 1), clause: c.clone()}
        }
        i = (i + 1);
    }
    let mut any_true: i64 = 0;
    i = 0;
    while (i < (c.names.clone().len() as i64)) {
        let lit: String = c.names.clone()[i as usize].clone().clone();
        if (c.literals.clone()[lit.as_str()] == 1) {
            any_true = 1;
        }
        i = (i + 1);
    }
    return EvalResult {value: any_true, clause: c.clone()}
};
    fn new_formula(mut cs: Vec<Clause>) -> Formula {
    return Formula {clauses: cs.clone()}
};
    fn remove_symbol(mut symbols: Vec<String>, mut s: String) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (symbols.len() as i64)) {
        if (symbols[i as usize].clone().as_str() != s.as_str()) {
            res = { let mut _v = res.clone(); _v.push(symbols[i as usize].clone()); _v };
        }
        i = (i + 1);
    }
    return res
};
    fn dpll_algorithm(clauses: &mut Vec<Clause>, mut symbols: Vec<String>, mut model: HashMap<String, i64>) -> DPLLResult {
    let mut all_true: bool = true;
    let mut i: i64 = 0;
    while (i < (clauses.len() as i64)) {
        let ev: EvalResult = evaluate_clause(clauses[i as usize].clone(), model.clone());
        (*clauses)[i as usize] = ev.clause.clone();
        if (ev.value == 0) {
            return DPLLResult {sat: false, model: HashMap::new()}
        } else if (ev.value == (0 - 1)) {
            all_true = false;
        }
        i = (i + 1);
    }
    if all_true {
        return DPLLResult {sat: true, model: model.clone()}
    }
    let p: String = symbols[0 as usize].clone().clone();
    let rest: Vec<String> = remove_symbol(symbols.clone(), p.clone());
    let mut tmp1: HashMap<String, i64> = model.clone();
    let mut tmp2: HashMap<String, i64> = model.clone();
    tmp1.insert(p.clone(), 1);
    tmp2.insert(p.clone(), 0);
    let res1: DPLLResult = dpll_algorithm(clauses, rest.clone(), tmp1.clone());
    if res1.sat {
        return res1
    }
    return dpll_algorithm(clauses, rest.clone(), tmp2.clone())
};
    fn str_clause(mut c: Clause) -> String {
    let mut line: String = String::from("{").clone();
    let mut first: bool = true;
    let mut i: i64 = 0;
    while (i < (c.names.clone().len() as i64)) {
        let lit: String = c.names.clone()[i as usize].clone().clone();
        if first {
            first = false;
        } else {
            line = format!("{}{}", line, " , ");
        }
        line = format!("{}{}", line, lit);
        i = (i + 1);
    }
    line = format!("{}{}", line, "}");
    return line.clone()
};
    fn str_formula(mut f: Formula) -> String {
    let mut line: String = String::from("{").clone();
    let mut i: i64 = 0;
    while (i < (f.clauses.clone().len() as i64)) {
        line = format!("{}{}", line, str_clause(f.clauses.clone()[i as usize].clone()));
        if (i < ((f.clauses.clone().len() as i64) - 1)) {
            line = format!("{}{}", line, " , ");
        }
        i = (i + 1);
    }
    line = format!("{}{}", line, "}");
    return line.clone()
};
    let clause1: Clause = new_clause(vec![String::from("A4").clone(), String::from("A3").clone(), String::from("A5'").clone(), String::from("A1").clone(), String::from("A3'").clone()]);
    let clause2: Clause = new_clause(vec![String::from("A4").clone()]);
    let formula: Formula = new_formula(vec![clause1.clone(), clause2.clone()]);
    let formula_str: String = str_formula(formula.clone()).clone();
    let mut clauses: Vec<Clause> = vec![clause1.clone(), clause2.clone()];
    let symbols: Vec<String> = vec![String::from("A4").clone().clone(), String::from("A3").clone().clone(), String::from("A5").clone().clone(), String::from("A1").clone().clone()];
    let mut model: HashMap<String, i64> = HashMap::new();
    let result: DPLLResult = dpll_algorithm(&mut clauses, symbols.clone(), model.clone());
    if result.sat {
        println!("{}", format!("{}{}", format!("{}{}", "The formula ", formula_str), " is satisfiable."));
    } else {
        println!("{}", format!("{}{}", format!("{}{}", "The formula ", formula_str), " is not satisfiable."));
    }
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
