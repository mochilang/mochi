// Generated by Mochi transpiler v0.10.69
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn get_data(mut source_data: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut data_lists: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < (source_data.len() as i64)) {
        let row: Vec<f64> = source_data[i as usize].clone();
        let mut j: i64 = 0;
        while (j < (row.len() as i64)) {
            if ((data_lists.len() as i64) < (j + 1)) {
                let mut empty: Vec<f64> = vec![];
                data_lists = { let mut _v = data_lists.clone(); _v.push(empty.clone()); _v };
            }
            data_lists[j as usize] = { let mut _v = data_lists[j as usize].clone().clone(); _v.push(row[j as usize]); _v };
            j = (j + 1);
        }
        i = (i + 1);
    }
    return data_lists
};
    fn calculate_each_score(mut data_lists: Vec<Vec<f64>>, mut weights: Vec<i64>) -> Vec<Vec<f64>> {
    let mut score_lists: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < (data_lists.len() as i64)) {
        let dlist: Vec<f64> = data_lists[i as usize].clone();
        let weight: i64 = weights[i as usize];
        let mut mind: f64 = dlist[0 as usize];
        let mut maxd: f64 = dlist[0 as usize];
        let mut j: i64 = 1;
        while (j < (dlist.len() as i64)) {
            let val: f64 = dlist[j as usize];
            if (val < mind) {
                mind = val;
            }
            if (val > maxd) {
                maxd = val;
            }
            j = (j + 1);
        }
        let mut score: Vec<f64> = vec![];
        j = 0;
        if (weight == 0) {
            while (j < (dlist.len() as i64)) {
                let item: f64 = dlist[j as usize];
                if ((maxd - mind) == 0.0) {
                    score = { let mut _v = score.clone(); _v.push(1.0); _v };
                } else {
                    score = { let mut _v = score.clone(); _v.push((1.0 - ((item - mind) / (maxd - mind)))); _v };
                }
                j = (j + 1);
            }
        } else {
            while (j < (dlist.len() as i64)) {
                let item: f64 = dlist[j as usize];
                if ((maxd - mind) == 0.0) {
                    score = { let mut _v = score.clone(); _v.push(0.0); _v };
                } else {
                    score = { let mut _v = score.clone(); _v.push(((item - mind) / (maxd - mind))); _v };
                }
                j = (j + 1);
            }
        }
        score_lists = { let mut _v = score_lists.clone(); _v.push(score.clone()); _v };
        i = (i + 1);
    }
    return score_lists
};
    fn generate_final_scores(mut score_lists: Vec<Vec<f64>>) -> Vec<f64> {
    let count: i64 = (score_lists[0 as usize].clone().len() as i64);
    let mut final_scores: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < count) {
        final_scores = { let mut _v = final_scores.clone(); _v.push(0.0); _v };
        i = (i + 1);
    }
    i = 0;
    while (i < (score_lists.len() as i64)) {
        let slist: Vec<f64> = score_lists[i as usize].clone();
        let mut j: i64 = 0;
        while (j < (slist.len() as i64)) {
            final_scores[j as usize] = (final_scores[j as usize] + slist[j as usize]);
            j = (j + 1);
        }
        i = (i + 1);
    }
    return final_scores
};
    let mut procentual_proximity = |mut source_data: Vec<Vec<f64>>, mut weights: Vec<i64>| -> Vec<Vec<f64>> {
    let data_lists: Vec<Vec<f64>> = get_data(source_data.clone());
    let score_lists: Vec<Vec<f64>> = calculate_each_score(data_lists.clone(), weights.clone());
    let final_scores: Vec<f64> = generate_final_scores(score_lists.clone());
    let mut i: i64 = 0;
    while (i < (final_scores.len() as i64)) {
        source_data[i as usize] = { let mut _v = source_data[i as usize].clone().clone(); _v.push(final_scores[i as usize]); _v };
        i = (i + 1);
    }
    return source_data
};
    let mut vehicles: Vec<Vec<f64>> = vec![];
    vehicles = { let mut _v = vehicles.clone(); _v.push(vec![20.0, 60.0, 2012.0]); _v };
    vehicles = { let mut _v = vehicles.clone(); _v.push(vec![23.0, 90.0, 2015.0]); _v };
    vehicles = { let mut _v = vehicles.clone(); _v.push(vec![22.0, 50.0, 2011.0]); _v };
    let mut weights: Vec<i64> = vec![0, 0, 1];
    let result: Vec<Vec<f64>> = procentual_proximity(vehicles.clone(), weights.clone());
    println!("{}", format!("{:?}", result));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
