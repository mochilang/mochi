// Generated by Mochi transpiler v0.10.68
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    let DOOMSDAY_LEAP: Vec<i64> = vec![4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5];
    let DOOMSDAY_NOT_LEAP: Vec<i64> = vec![3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5];
    let WEEK_DAY_NAMES: HashMap<i64, String> = HashMap::from([(0, String::from("Sunday")), (1, String::from("Monday")), (2, String::from("Tuesday")), (3, String::from("Wednesday")), (4, String::from("Thursday")), (5, String::from("Friday")), (6, String::from("Saturday"))]);
    let mut get_week_day = |mut year: i64, mut month: i64, mut day: i64| -> String {
    if (year < 100) {
        panic!("year should be in YYYY format");
    }
    if ((month < 1) || (month > 12)) {
        panic!("month should be between 1 to 12");
    }
    if ((day < 1) || (day > 31)) {
        panic!("day should be between 1 to 31");
    }
    let century: i64 = (year / 100);
    let century_anchor: i64 = (((5 * (century % 4)) + 2) % 7);
    let centurian: i64 = (year % 100);
    let centurian_m: i64 = (centurian % 12);
    let dooms_day: i64 = (((((centurian / 12) + centurian_m) + (centurian_m / 4)) + century_anchor) % 7);
    let day_anchor: i64 = if (((year % 4) != 0) || ((centurian == 0) && ((year % 400) != 0))) { DOOMSDAY_NOT_LEAP[(month - 1) as usize] } else { DOOMSDAY_LEAP[(month - 1) as usize] };
    let mut week_day: i64 = (((dooms_day + day) - day_anchor) % 7);
    if (week_day < 0) {
        week_day = (week_day + 7);
    }
    return WEEK_DAY_NAMES.get(&week_day).cloned().unwrap_or_default().clone()
};
    println!("{}", get_week_day(2020, 10, 24));
    println!("{}", get_week_day(2017, 10, 24));
    println!("{}", get_week_day(2019, 5, 3));
    println!("{}", get_week_day(1970, 9, 16));
    println!("{}", get_week_day(1870, 8, 13));
    println!("{}", get_week_day(2040, 3, 14));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
