// Generated by Mochi transpiler v0.10.69
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct State {
    claim: Vec<i64>,
    alloc: Vec<Vec<i64>>,
    max: Vec<Vec<i64>>,
}
impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"claim\": {:?}", self.claim)?;
        write!(f, ", ")?;
        write!(f, "\"alloc\": {:?}", self.alloc)?;
        write!(f, ", ")?;
        write!(f, "\"max\": {:?}", self.max)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn processes_resource_summation(mut alloc: Vec<Vec<i64>>) -> Vec<i64> {
    let resources: i64 = (alloc[0 as usize].clone().len() as i64);
    let mut sums: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < resources) {
        let mut total: i64 = 0;
        let mut j: i64 = 0;
        while (j < (alloc.len() as i64)) {
            total = (total + alloc[j as usize].clone()[i as usize]);
            j = (j + 1);
        }
        sums = { let mut _v = sums.clone(); _v.push(total); _v };
        i = (i + 1);
    }
    return sums
};
    fn available_resources(mut claim: Vec<i64>, mut alloc_sum: Vec<i64>) -> Vec<i64> {
    let mut avail: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (claim.len() as i64)) {
        avail = { let mut _v = avail.clone(); _v.push((claim[i as usize] - alloc_sum[i as usize])); _v };
        i = (i + 1);
    }
    return avail
};
    fn need(mut max: Vec<Vec<i64>>, mut alloc: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut needs: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < (max.len() as i64)) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < (max[0 as usize].clone().len() as i64)) {
            row = { let mut _v = row.clone(); _v.push((max[i as usize].clone()[j as usize] - alloc[i as usize].clone()[j as usize])); _v };
            j = (j + 1);
        }
        needs = { let mut _v = needs.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return needs
};
    let mut pretty_print = |mut claim: Vec<i64>, mut alloc: Vec<Vec<i64>>, mut max: Vec<Vec<i64>>| {
    println!("{}", "         Allocated Resource Table");
    let mut i: i64 = 0;
    while (i < (alloc.len() as i64)) {
        let mut row: Vec<i64> = alloc[i as usize].clone();
        let mut line: String = format!("{}{}", format!("{}{}", "P", (i + 1).to_string()), "       ").clone();
        let mut j: i64 = 0;
        while (j < (row.len() as i64)) {
            line = format!("{}{}", line, row[j as usize].to_string());
            if (j < ((row.len() as i64) - 1)) {
                line = format!("{}{}", line, "        ");
            }
            j = (j + 1);
        }
        println!("{}", line);
        println!("{}", "");
        i = (i + 1);
    }
    println!("{}", "         System Resource Table");
    i = 0;
    while (i < (max.len() as i64)) {
        let mut row: Vec<i64> = max[i as usize].clone();
        let mut line: String = format!("{}{}", format!("{}{}", "P", (i + 1).to_string()), "       ").clone();
        let mut j: i64 = 0;
        while (j < (row.len() as i64)) {
            line = format!("{}{}", line, row[j as usize].to_string());
            if (j < ((row.len() as i64) - 1)) {
                line = format!("{}{}", line, "        ");
            }
            j = (j + 1);
        }
        println!("{}", line);
        println!("{}", "");
        i = (i + 1);
    }
    let mut usage: String = String::new();
    i = 0;
    while (i < (claim.len() as i64)) {
        if (i > 0) {
            usage = format!("{}{}", usage, " ");
        }
        usage = format!("{}{}", usage, claim[i as usize].to_string());
        i = (i + 1);
    }
    let mut alloc_sum: Vec<i64> = processes_resource_summation(alloc.clone());
    let mut avail: Vec<i64> = available_resources(claim.clone(), alloc_sum.clone());
    let mut avail_str: String = String::new();
    i = 0;
    while (i < (avail.len() as i64)) {
        if (i > 0) {
            avail_str = format!("{}{}", avail_str, " ");
        }
        avail_str = format!("{}{}", avail_str, avail[i as usize].to_string());
        i = (i + 1);
    }
    println!("{}", format!("{}{}", "Current Usage by Active Processes: ", usage));
    println!("{}", format!("{}{}", "Initial Available Resources:       ", avail_str));
};
    let mut bankers_algorithm = |mut claim: Vec<i64>, mut alloc: Vec<Vec<i64>>, mut max: Vec<Vec<i64>>| {
    let mut need_list: Vec<Vec<i64>> = need(max.clone(), alloc.clone());
    let mut alloc_sum: Vec<i64> = processes_resource_summation(alloc.clone());
    let mut avail: Vec<i64> = available_resources(claim.clone(), alloc_sum.clone());
    println!("{}", "__________________________________________________");
    println!("{}", "");
    let mut finished: Vec<bool> = vec![];
    let mut i: i64 = 0;
    while (i < (need_list.len() as i64)) {
        finished = { let mut _v = finished.clone(); _v.push(false); _v };
        i = (i + 1);
    }
    let mut remaining: i64 = (need_list.len() as i64);
    while (remaining > 0) {
        let mut safe: bool = false;
        let mut p: i64 = 0;
        while (p < (need_list.len() as i64)) {
            if !finished[p as usize] {
                let mut exec: bool = true;
                let mut r: i64 = 0;
                while (r < (avail.len() as i64)) {
                    if (need_list[p as usize].clone()[r as usize] > avail[r as usize]) {
                        exec = false;
                        break
                    }
                    r = (r + 1);
                }
                if exec {
                    safe = true;
                    println!("{}", format!("{}{}", format!("{}{}", "Process ", (p + 1).to_string()), " is executing."));
                    r = 0;
                    while (r < (avail.len() as i64)) {
                        avail[r as usize] = (avail[r as usize] + alloc[p as usize].clone()[r as usize]);
                        r = (r + 1);
                    }
                    let mut avail_str: String = String::new();
                    r = 0;
                    while (r < (avail.len() as i64)) {
                        if (r > 0) {
                            avail_str = format!("{}{}", avail_str, " ");
                        }
                        avail_str = format!("{}{}", avail_str, avail[r as usize].to_string());
                        r = (r + 1);
                    }
                    println!("{}", format!("{}{}", "Updated available resource stack for processes: ", avail_str));
                    println!("{}", "The process is in a safe state.");
                    println!("{}", "");
                    finished[p as usize] = true;
                    remaining = (remaining - 1);
                }
            }
            p = (p + 1);
        }
        if !safe {
            println!("{}", "System in unsafe state. Aborting...");
            println!("{}", "");
            break
        }
    }
};
    let mut claim_vector: Vec<i64> = vec![8, 5, 9, 7];
    let mut allocated_resources_table: Vec<Vec<i64>> = vec![vec![2, 0, 1, 1].clone(), vec![0, 1, 2, 1].clone(), vec![4, 0, 0, 3].clone(), vec![0, 2, 1, 0].clone(), vec![1, 0, 3, 0].clone()];
    let mut maximum_claim_table: Vec<Vec<i64>> = vec![vec![3, 2, 1, 4].clone(), vec![0, 2, 5, 2].clone(), vec![5, 1, 0, 5].clone(), vec![1, 5, 3, 0].clone(), vec![3, 0, 3, 3].clone()];
    pretty_print(claim_vector.clone(), allocated_resources_table.clone(), maximum_claim_table.clone());
    bankers_algorithm(claim_vector.clone(), allocated_resources_table.clone(), maximum_claim_table.clone());
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
