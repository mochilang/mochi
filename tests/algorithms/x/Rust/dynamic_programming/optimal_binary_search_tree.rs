// Generated by Mochi transpiler v0.10.61
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Node {
    key: i64,
    freq: i64,
}
impl std::fmt::Display for Node {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"key\": {}", self.key)?;
        write!(f, ", ")?;
        write!(f, "\"freq\": {}", self.freq)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn sort_nodes(mut nodes: Vec<Node>) -> Vec<Node> {
    let mut arr: Vec<Node> = nodes.clone();
    let mut i: i64 = 1;
    while (i < (arr.len() as i64)) {
        let mut key_node: Node = arr[i as usize].clone();
        let mut j: i64 = (i - 1);
        while (j >= 0) {
            let mut temp: Node = arr[j as usize].clone();
            if (temp.key > key_node.key) {
                arr[(j + 1) as usize] = temp.clone();
                j = (j - 1);
            } else {
                break
            }
        }
        arr[(j + 1) as usize] = key_node.clone();
        i = (i + 1);
    }
    return arr
};
    fn print_node(n: &Node) {
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Node(key=", n.key.to_string()), ", freq="), n.freq.to_string()), ")"));
};
    fn print_binary_search_tree(root: &mut Vec<Vec<i64>>, keys: &mut Vec<i64>, mut i: i64, mut j: i64, mut parent: i64, mut is_left: bool) {
    if (((i > j) || (i < 0)) || (j > ((root.len() as i64) - 1))) {
        return
    }
    let mut node: i64 = root[i as usize].clone()[j as usize];
    if (parent == -1) {
        println!("{}", format!("{}{}", keys[node as usize].to_string(), " is the root of the binary search tree."));
    } else {
        if is_left {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", keys[node as usize].to_string(), " is the left child of key "), parent.to_string()), "."));
        } else {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", keys[node as usize].to_string(), " is the right child of key "), parent.to_string()), "."));
        }
    }
    print_binary_search_tree(root, keys, i, (node - 1), keys.clone()[node as usize], true);
    print_binary_search_tree(root, keys, (node + 1), j, keys.clone()[node as usize], false);
};
    fn find_optimal_binary_search_tree(mut original_nodes: Vec<Node>) {
    let mut nodes: Vec<Node> = sort_nodes(original_nodes.clone());
    let mut n = (nodes.len() as i64);
    let mut keys: Vec<i64> = vec![];
    let mut freqs: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut node: Node = nodes[i as usize].clone();
        keys = { let mut _v = keys.clone(); _v.push(node.key); _v };
        freqs = { let mut _v = freqs.clone(); _v.push(node.freq); _v };
        i = (i + 1);
    }
    let mut dp: Vec<Vec<i64>> = vec![];
    let mut total: Vec<Vec<i64>> = vec![];
    let mut root: Vec<Vec<i64>> = vec![];
    i = 0;
    while (i < n) {
        let mut dp_row: Vec<i64> = vec![];
        let mut total_row: Vec<i64> = vec![];
        let mut root_row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            if (i == j) {
                dp_row = { let mut _v = dp_row.clone(); _v.push(freqs[i as usize]); _v };
                total_row = { let mut _v = total_row.clone(); _v.push(freqs[i as usize]); _v };
                root_row = { let mut _v = root_row.clone(); _v.push(i); _v };
            } else {
                dp_row = { let mut _v = dp_row.clone(); _v.push(0); _v };
                total_row = { let mut _v = total_row.clone(); _v.push(0); _v };
                root_row = { let mut _v = root_row.clone(); _v.push(0); _v };
            }
            j = (j + 1);
        }
        dp = { let mut _v = dp.clone(); _v.push(dp_row.clone()); _v };
        total = { let mut _v = total.clone(); _v.push(total_row.clone()); _v };
        root = { let mut _v = root.clone(); _v.push(root_row.clone()); _v };
        i = (i + 1);
    }
    let mut interval_length: i64 = 2;
    let mut INF: i64 = 2147483647;
    while (interval_length <= n) {
        i = 0;
        while (i < ((n - interval_length) + 1)) {
            let mut j: i64 = ((i + interval_length) - 1);
            dp[i as usize][j as usize] = INF;
            total[i as usize][j as usize] = (total[i as usize].clone()[(j - 1) as usize] + freqs[j as usize]);
            let mut r: i64 = root[i as usize].clone()[(j - 1) as usize];
            while (r <= root[(i + 1) as usize].clone()[j as usize]) {
                let mut left: i64 = if (r != i) { dp[i as usize].clone()[(r - 1) as usize] } else { 0 };
                let mut right: i64 = if (r != j) { dp[(r + 1) as usize].clone()[j as usize] } else { 0 };
                let mut cost: i64 = ((left + total[i as usize].clone()[j as usize]) + right);
                if (dp[i as usize].clone()[j as usize] > cost) {
                    dp[i as usize][j as usize] = cost;
                    root[i as usize][j as usize] = r;
                }
                r = (r + 1);
            }
            i = (i + 1);
        }
        interval_length = (interval_length + 1);
    }
    println!("{}", "Binary search tree nodes:");
    i = 0;
    while (i < n) {
        print_node(&nodes[i as usize].clone());
        i = (i + 1);
    }
    println!("{}", format!("{}{}", format!("{}{}", "\nThe cost of optimal BST for given tree nodes is ", dp[0 as usize].clone()[(n - 1) as usize].to_string()), "."));
    print_binary_search_tree(&mut root, &mut keys, 0, (n - 1), -1, false);
};
    fn mochi_main() {
    let mut nodes: Vec<Node> = vec![Node {key: 12, freq: 8}, Node {key: 10, freq: 34}, Node {key: 20, freq: 50}, Node {key: 42, freq: 3}, Node {key: 25, freq: 40}, Node {key: 37, freq: 30}];
    find_optimal_binary_search_tree(nodes.clone());
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
