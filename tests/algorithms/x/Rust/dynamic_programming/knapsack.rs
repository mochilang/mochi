// Generated by Mochi transpiler v0.10.64
#[derive(Debug, Clone, Default)]
struct KnapsackResult {
    value: i64,
    subset: Vec<i64>,
}
impl std::fmt::Display for KnapsackResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, ", ")?;
        write!(f, "\"subset\": {:?}", self.subset)?;
        write!(f, "}}")
    }
}

static mut g_f: Vec<Vec<i64>> = Vec::new();
static g_n: i64 = 4;
static g_w_cap: i64 = 6;
fn max_int(mut a: i64, mut b: i64) -> i64 {
    if (a > b) {
        return a
    } else {
        return b
    }
}

fn init_f(mut n: i64, mut w: i64) -> Vec<Vec<i64>> {
    let mut table: Vec<Vec<i64>> = Default::default();
    let mut i: i64 = 0;
    while (i <= n) {
        let mut row: Vec<i64> = Default::default();
        let mut j: i64 = 0;
        while (j <= w) {
            if ((i == 0) || (j == 0)) {
                row = { let mut _v = row.clone(); _v.push(0); _v };
            } else {
                row = { let mut _v = row.clone(); _v.push(-1); _v };
            }
            j = (j + 1);
        }
        table = { let mut _v = table.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return table
}

fn mf_knapsack(mut i: i64, mut wt: Vec<i64>, mut val: Vec<i64>, mut j: i64) -> i64 {
    if (unsafe { g_f.clone() }[i as usize].clone()[j as usize] < 0) {
        if (j < wt[(i - 1) as usize]) {
            unsafe { g_f[i as usize][j as usize] = mf_knapsack((i - 1), wt.clone(), val.clone(), j) };
        } else {
            let without_item: i64 = mf_knapsack((i - 1), wt.clone(), val.clone(), j);
            let with_item: i64 = (mf_knapsack((i - 1), wt.clone(), val.clone(), (j - wt[(i - 1) as usize])) + val[(i - 1) as usize]);
            unsafe { g_f[i as usize][j as usize] = max_int(without_item, with_item) };
        }
    }
    return unsafe { g_f.clone() }[i as usize].clone()[j as usize]
}

fn create_matrix(mut rows: i64, mut cols: i64) -> Vec<Vec<i64>> {
    let mut matrix: Vec<Vec<i64>> = Default::default();
    let mut i: i64 = 0;
    while (i <= rows) {
        let mut row: Vec<i64> = Default::default();
        let mut j: i64 = 0;
        while (j <= cols) {
            row = { let mut _v = row.clone(); _v.push(0); _v };
            j = (j + 1);
        }
        matrix = { let mut _v = matrix.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return matrix
}

fn knapsack(mut w: i64, mut wt: Vec<i64>, mut val: Vec<i64>, mut n: i64) -> Vec<Vec<i64>> {
    let mut dp: Vec<Vec<i64>> = create_matrix(n, w);
    let mut i: i64 = 1;
    while (i <= n) {
        let mut w_: i64 = 1;
        while (w_ <= w) {
            if (wt[(i - 1) as usize] <= w_) {
                let include: i64 = (val[(i - 1) as usize] + dp[(i - 1) as usize].clone()[(w_ - wt[(i - 1) as usize]) as usize]);
                let exclude: i64 = dp[(i - 1) as usize].clone()[w_ as usize];
                dp[i as usize][w_ as usize] = max_int(include, exclude);
            } else {
                dp[i as usize][w_ as usize] = dp[(i - 1) as usize].clone()[w_ as usize];
            }
            w_ = (w_ + 1);
        }
        i = (i + 1);
    }
    return dp
}

fn construct_solution(mut dp: Vec<Vec<i64>>, mut wt: Vec<i64>, mut i: i64, mut j: i64, mut optimal_set: Vec<i64>) -> Vec<i64> {
    if ((i > 0) && (j > 0)) {
        if (dp[(i - 1) as usize].clone()[j as usize] == dp[i as usize].clone()[j as usize]) {
            return construct_solution(dp.clone(), wt.clone(), (i - 1), j, optimal_set.clone())
        } else {
            let with_prev: Vec<i64> = construct_solution(dp.clone(), wt.clone(), (i - 1), (j - wt[(i - 1) as usize]), optimal_set.clone());
            return { let mut _v = with_prev.clone(); _v.push(i); _v }
        }
    }
    return optimal_set
}

fn knapsack_with_example_solution(mut w: i64, mut wt: Vec<i64>, mut val: Vec<i64>) -> KnapsackResult {
    let num_items: i64 = (wt.len() as i64);
    let dp_table: Vec<Vec<i64>> = knapsack(w, wt.clone(), val.clone(), num_items);
    let optimal_val: i64 = dp_table[num_items as usize].clone()[w as usize];
    let subset: Vec<i64> = construct_solution(dp_table.clone(), wt.clone(), num_items, w, vec![]);
    return KnapsackResult {value: optimal_val, subset: subset.clone()}
}

fn format_set(mut xs: Vec<i64>) -> String {
    let mut res: String = String::from("{").clone();
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        res = format!("{}{}", res, xs[i as usize].to_string());
        if ((i + 1) < (xs.len() as i64)) {
            res = format!("{}{}", res, ", ");
        }
        i = (i + 1);
    }
    res = format!("{}{}", res, "}");
    return res.clone()
}

fn main() {
    unsafe {
        let val_list: Vec<i64> = vec![3, 2, 4, 4];
        let wt_list: Vec<i64> = vec![4, 3, 2, 3];
        unsafe { g_f = init_f(unsafe { g_n.clone() }, unsafe { g_w_cap.clone() }) };
        let dp_table: Vec<Vec<i64>> = knapsack(unsafe { g_w_cap.clone() }, wt_list.clone(), val_list.clone(), unsafe { g_n.clone() });
        let optimal_solution: i64 = dp_table[unsafe { g_n.clone() } as usize].clone()[unsafe { g_w_cap.clone() } as usize];
        println!("{}", optimal_solution);
        println!("{}", mf_knapsack(unsafe { g_n.clone() }, wt_list.clone(), val_list.clone(), unsafe { g_w_cap.clone() }));
        let example: KnapsackResult = knapsack_with_example_solution(unsafe { g_w_cap.clone() }, wt_list.clone(), val_list.clone());
        println!("{}", format!("{}{}", "optimal_value = ", example.value.to_string()));
        println!("{}", format!("{}{}", "An optimal subset corresponding to the optimal value ", format_set(example.subset.clone().clone())));
    }
}
