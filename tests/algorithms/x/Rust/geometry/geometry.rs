// Generated by Mochi transpiler v0.10.65
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Angle {
    degrees: f64,
}
impl std::fmt::Display for Angle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"degrees\": {}", self.degrees)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Side {
    length: f64,
    angle: Angle,
    next: i64,
}
impl std::fmt::Display for Side {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"length\": {}", self.length)?;
        write!(f, ", ")?;
        write!(f, "\"angle\": {}", self.angle)?;
        write!(f, ", ")?;
        write!(f, "\"next\": {}", self.next)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Ellipse {
    major: f64,
    minor: f64,
}
impl std::fmt::Display for Ellipse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"major\": {}", self.major)?;
        write!(f, ", ")?;
        write!(f, "\"minor\": {}", self.minor)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Circle {
    radius: f64,
}
impl std::fmt::Display for Circle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"radius\": {}", self.radius)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Polygon {
    sides: Vec<Side>,
}
impl std::fmt::Display for Polygon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"sides\": {:?}", self.sides)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Rectangle {
    short_side: Side,
    long_side: Side,
    poly: Polygon,
}
impl std::fmt::Display for Rectangle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"short_side\": {}", self.short_side)?;
        write!(f, ", ")?;
        write!(f, "\"long_side\": {}", self.long_side)?;
        write!(f, ", ")?;
        write!(f, "\"poly\": {}", self.poly)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Square {
    side: Side,
    rect: Rectangle,
}
impl std::fmt::Display for Square {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"side\": {}", self.side)?;
        write!(f, ", ")?;
        write!(f, "\"rect\": {}", self.rect)?;
        write!(f, "}}")
    }
}

static g_PI: f64 = 3.141592653589793;
fn main() {
    unsafe {
                let _start: i64 = _now();
        fn make_angle(mut deg: f64) -> Angle {
    if ((deg < 0.0) || (deg > 360.0)) {
        panic!("degrees must be between 0 and 360");
    }
    return Angle {degrees: deg}
};
        fn make_side(mut length: f64, mut angle: Angle) -> Side {
    if (length <= 0.0) {
        panic!("length must be positive");
    }
    return Side {length: length, angle: angle.clone(), next: -1}
};
        fn ellipse_area(mut e: Ellipse) -> f64 {
    return ((unsafe { g_PI.clone() } * e.major) * e.minor)
};
        fn ellipse_perimeter(mut e: Ellipse) -> f64 {
    return (unsafe { g_PI.clone() } * (e.major + e.minor))
};
        fn circle_area(mut c: Circle) -> f64 {
    let e: Ellipse = Ellipse {major: c.radius, minor: c.radius};
    let area: f64 = ellipse_area(e.clone());
    return area
};
        fn circle_perimeter(mut c: Circle) -> f64 {
    let e: Ellipse = Ellipse {major: c.radius, minor: c.radius};
    let per: f64 = ellipse_perimeter(e.clone());
    return per
};
        fn circle_diameter(mut c: Circle) -> f64 {
    return (c.radius * 2.0)
};
        fn circle_max_parts(mut num_cuts: f64) -> f64 {
    if (num_cuts < 0.0) {
        panic!("num_cuts must be positive");
    }
    return (((num_cuts + 2.0) + (num_cuts * num_cuts)) * 0.5)
};
        fn make_polygon() -> Polygon {
    let mut s: Vec<Side> = vec![];
    return Polygon {sides: s.clone()}
};
        fn polygon_add_side(p: &mut Polygon, mut s: Side) {
    (*p).sides = { let mut _v = p.sides.clone().clone(); _v.push(s.clone()); _v };
};
        fn polygon_get_side(mut p: Polygon, mut index: i64) -> Side {
    return p.sides.clone()[index as usize].clone()
};
        fn polygon_set_side(p: &mut Polygon, mut index: i64, mut s: Side) {
    let mut tmp: Vec<Side> = p.sides.clone();
    tmp[index as usize] = s.clone();
    (*p).sides = tmp.clone();
};
        fn make_rectangle(mut short_len: f64, mut long_len: f64) -> Rectangle {
    if ((short_len <= 0.0) || (long_len <= 0.0)) {
        panic!("length must be positive");
    }
    let short: Side = make_side(short_len, make_angle(90.0));
    let long: Side = make_side(long_len, make_angle(90.0));
    let mut p: Polygon = make_polygon();
    polygon_add_side(&mut p, short.clone());
    polygon_add_side(&mut p, long.clone());
    return Rectangle {short_side: short.clone(), long_side: long.clone(), poly: p.clone()}
};
        fn rectangle_perimeter(mut r: Rectangle) -> f64 {
    return ((r.short_side.clone().length + r.long_side.clone().length) * 2.0)
};
        fn rectangle_area(mut r: Rectangle) -> f64 {
    return (r.short_side.clone().length * r.long_side.clone().length)
};
        fn make_square(mut side_len: f64) -> Square {
    let rect: Rectangle = make_rectangle(side_len, side_len);
    return Square {side: rect.short_side.clone(), rect: rect.clone()}
};
        fn square_perimeter(mut s: Square) -> f64 {
    let mut p: f64 = rectangle_perimeter(s.rect.clone());
    return p
};
        fn square_area(mut s: Square) -> f64 {
    let a: f64 = rectangle_area(s.rect.clone());
    return a
};
        fn mochi_main() {
    let a: Angle = make_angle(90.0);
    println!("{}", format!("{:?}", a.degrees));
    let s: Side = make_side(5.0, a.clone());
    println!("{}", format!("{:?}", s.length));
    let e: Ellipse = Ellipse {major: 5.0, minor: 10.0};
    println!("{}", format!("{:?}", ellipse_area(e.clone())));
    println!("{}", format!("{:?}", ellipse_perimeter(e.clone())));
    let c: Circle = Circle {radius: 5.0};
    println!("{}", format!("{:?}", circle_area(c.clone())));
    println!("{}", format!("{:?}", circle_perimeter(c.clone())));
    println!("{}", format!("{:?}", circle_diameter(c.clone())));
    println!("{}", format!("{:?}", circle_max_parts(7.0)));
    let r: Rectangle = make_rectangle(5.0, 10.0);
    println!("{}", format!("{:?}", rectangle_perimeter(r.clone())));
    println!("{}", format!("{:?}", rectangle_area(r.clone())));
    let q: Square = make_square(5.0);
    println!("{}", format!("{:?}", square_perimeter(q.clone())));
    println!("{}", format!("{:?}", square_area(q.clone())));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
