// Generated by Mochi transpiler v0.10.59
use std::collections::HashMap;
use std::sync::LazyLock;
use std::sync::Mutex;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static g_MORSE_CODE_DICT: LazyLock<Mutex<HashMap<String, String>>> = LazyLock::new(|| Mutex::new(HashMap::from([(String::from("A"), String::from(".-")), (String::from("B"), String::from("-...")), (String::from("C"), String::from("-.-.")), (String::from("D"), String::from("-..")), (String::from("E"), String::from(".")), (String::from("F"), String::from("..-.")), (String::from("G"), String::from("--.")), (String::from("H"), String::from("....")), (String::from("I"), String::from("..")), (String::from("J"), String::from(".---")), (String::from("K"), String::from("-.-")), (String::from("L"), String::from(".-..")), (String::from("M"), String::from("--")), (String::from("N"), String::from("-.")), (String::from("O"), String::from("---")), (String::from("P"), String::from(".--.")), (String::from("Q"), String::from("--.-")), (String::from("R"), String::from(".-.")), (String::from("S"), String::from("...")), (String::from("T"), String::from("-")), (String::from("U"), String::from("..-")), (String::from("V"), String::from("...-")), (String::from("W"), String::from(".--")), (String::from("X"), String::from("-..-")), (String::from("Y"), String::from("-.--")), (String::from("Z"), String::from("--..")), (String::from(" "), String::from(""))])));
static mut g_MORSE_COMBINATIONS: Vec<String> = Vec::new();
static g_REVERSE_DICT: LazyLock<Mutex<HashMap<String, String>>> = LazyLock::new(|| Mutex::new(HashMap::from([(String::from(".-"), String::from("A")), (String::from("-..."), String::from("B")), (String::from("-.-."), String::from("C")), (String::from("-.."), String::from("D")), (String::from("."), String::from("E")), (String::from("..-."), String::from("F")), (String::from("--."), String::from("G")), (String::from("...."), String::from("H")), (String::from(".."), String::from("I")), (String::from(".---"), String::from("J")), (String::from("-.-"), String::from("K")), (String::from(".-.."), String::from("L")), (String::from("--"), String::from("M")), (String::from("-."), String::from("N")), (String::from("---"), String::from("O")), (String::from(".--."), String::from("P")), (String::from("--.-"), String::from("Q")), (String::from(".-."), String::from("R")), (String::from("..."), String::from("S")), (String::from("-"), String::from("T")), (String::from("..-"), String::from("U")), (String::from("...-"), String::from("V")), (String::from(".--"), String::from("W")), (String::from("-..-"), String::from("X")), (String::from("-.--"), String::from("Y")), (String::from("--.."), String::from("Z")), (String::from(""), String::from(" "))])));
static mut g_plaintext: String = String::new();
static mut g_key: String = String::new();
fn main() {
    unsafe {
        g_MORSE_COMBINATIONS = vec![String::from("...").clone(), String::from("..-").clone(), String::from("..x").clone(), String::from(".-.").clone(), String::from(".--").clone(), String::from(".-x").clone(), String::from(".x.").clone(), String::from(".x-").clone(), String::from(".xx").clone(), String::from("-..").clone(), String::from("-.-").clone(), String::from("-.x").clone(), String::from("--.").clone(), String::from("---").clone(), String::from("--x").clone(), String::from("-x.").clone(), String::from("-x-").clone(), String::from("-xx").clone(), String::from("x..").clone(), String::from("x.-").clone(), String::from("x.x").clone(), String::from("x-.").clone(), String::from("x--").clone(), String::from("x-x").clone(), String::from("xx.").clone(), String::from("xx-").clone(), String::from("xxx").clone()];
        g_plaintext = String::from("defend the east").clone();
        g_key = String::from("ROUNDTABLE").clone();
                let _start: i64 = _now();
        unsafe fn encodeToMorse(plaintext: &str) -> String {
    let mut morse: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (plaintext.len() as i64)) {
        let mut ch: String = (plaintext[i as usize..(i + 1) as usize].to_string().to_uppercase()).clone();
        let mut code: String = String::from("").clone();
        if g_MORSE_CODE_DICT.lock().unwrap().contains_key(&ch) {
            code = g_MORSE_CODE_DICT.lock().unwrap().get(ch.as_str()).cloned().unwrap_or_default();
        }
        if (i > 0) {
            morse = format!("{}{}", morse, "x");
        }
        morse = format!("{}{}", morse, code);
        i = (i + 1);
    }
    return morse.clone()
};
        unsafe fn encryptFractionatedMorse(plaintext: &str, key: &str) -> String {
    let mut morseCode: String = encodeToMorse(plaintext).clone();
    let mut combinedKey: String = format!("{}{}", (key.to_uppercase()), "ABCDEFGHIJKLMNOPQRSTUVWXYZ").clone();
    let mut dedupKey: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (combinedKey.len() as i64)) {
        let mut ch: String = combinedKey.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        if !dedupKey.contains(ch) {
            dedupKey = format!("{}{}", dedupKey, ch);
        }
        i = (i + 1);
    }
    let mut paddingLength: i64 = (3 - ((morseCode.len() as i64) % 3));
    let mut p: i64 = 0;
    while (p < paddingLength) {
        morseCode = format!("{}{}", morseCode, "x");
        p = (p + 1);
    }
    let mut dict: HashMap<String, String> = HashMap::new();
    let mut j: i64 = 0;
    while (j < 26) {
        let mut combo: String = g_MORSE_COMBINATIONS.clone()[j as usize].clone().clone();
        let mut letter: String = dedupKey.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>().clone();
        dict.insert(combo.clone(), letter);
        j = (j + 1);
    }
    dict.insert(String::from("xxx"), "");
    let mut encrypted: String = String::from("").clone();
    let mut k: i64 = 0;
    while (k < (morseCode.len() as i64)) {
        let mut group: String = morseCode.chars().skip(k as usize).take(((k + 3) - k) as usize).collect::<String>().clone();
        encrypted = format!("{}{}", encrypted, dict.get(group.as_str()).cloned().unwrap_or_default());
        k = (k + 3);
    }
    return encrypted.clone()
};
        unsafe fn decryptFractionatedMorse(ciphertext: &str, key: &str) -> String {
    let mut combinedKey: String = format!("{}{}", (key.to_uppercase()), "ABCDEFGHIJKLMNOPQRSTUVWXYZ").clone();
    let mut dedupKey: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (combinedKey.len() as i64)) {
        let mut ch: String = combinedKey.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        if !dedupKey.contains(ch) {
            dedupKey = format!("{}{}", dedupKey, ch);
        }
        i = (i + 1);
    }
    let mut inv: HashMap<String, String> = HashMap::new();
    let mut j: i64 = 0;
    while (j < 26) {
        let mut letter: String = dedupKey.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>().clone();
        inv.insert(letter.clone(), g_MORSE_COMBINATIONS.clone()[j as usize].clone());
        j = (j + 1);
    }
    let mut morse: String = String::from("").clone();
    let mut k: i64 = 0;
    while (k < (ciphertext.len() as i64)) {
        let mut ch: String = ciphertext[k as usize..(k + 1) as usize].to_string().clone();
        if inv.contains_key(&ch) {
            morse = format!("{}{}", morse, inv.get(ch.as_str()).cloned().unwrap_or_default());
        }
        k = (k + 1);
    }
    let mut codes: Vec<String> = vec![];
    let mut current: String = String::from("").clone();
    let mut m: i64 = 0;
    while (m < (morse.len() as i64)) {
        let mut ch: String = morse.chars().skip(m as usize).take(((m + 1) - m) as usize).collect::<String>().clone();
        if (ch.as_str() == "x") {
            codes = { let mut _v = codes.clone(); _v.push(current.clone()); _v };
            current = String::from("");
        } else {
            current = format!("{}{}", current, ch);
        }
        m = (m + 1);
    }
    codes = { let mut _v = codes.clone(); _v.push(current.clone()); _v };
    let mut decrypted: String = String::from("").clone();
    let mut idx: i64 = 0;
    while (idx < (codes.len() as i64)) {
        let mut code: String = codes[idx as usize].clone().clone();
        decrypted = format!("{}{}", decrypted, g_REVERSE_DICT.lock().unwrap().get(code.as_str()).cloned().unwrap_or_default());
        idx = (idx + 1);
    }
    let mut start: i64 = 0;
    loop {
        if (start < (decrypted.len() as i64)) {
            if (decrypted.chars().skip(start as usize).take(((start + 1) - start) as usize).collect::<String>().as_str() == " ") {
                start = (start + 1);
                continue
            }
        }
        break
    }
    let mut end = (decrypted.len() as i64);
    loop {
        if (end > start) {
            if (decrypted.chars().skip((end - 1) as usize).take((end - (end - 1)) as usize).collect::<String>().as_str() == " ") {
                end = (end - 1);
                continue
            }
        }
        break
    }
    return decrypted.chars().skip(start as usize).take((end - start) as usize).collect::<String>().clone()
};
        println!("{}", format!("{} {}", "Plain Text:", g_plaintext).trim_end());
        let mut ciphertext: String = encryptFractionatedMorse(&g_plaintext, &g_key).clone();
        println!("{}", format!("{} {}", "Encrypted:", ciphertext).trim_end());
        let mut decrypted: String = decryptFractionatedMorse(&ciphertext, &g_key).clone();
        println!("{}", format!("{} {}", "Decrypted:", decrypted).trim_end());
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
