// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_BYTE_SIZE: i64 = 0;
fn main() {
    unsafe {
        g_BYTE_SIZE = 256;
                let _start: i64 = _now();
        unsafe fn pow_int(mut base: i64, mut exp: i64) -> i64 {
    let mut result: i64 = 1;
    let mut i: i64 = 0;
    while (i < exp) {
        result = (result * base);
        i = (i + 1);
    }
    return result
};
        unsafe fn mod_pow(mut base: i64, mut exponent: i64, mut modulus: i64) -> i64 {
    let mut result: i64 = 1;
    let mut b: i64 = (base % modulus);
    let mut e: i64 = exponent;
    while (e > 0) {
        if ((e % 2) == 1) {
            result = ((result * b) % modulus);
        }
        e = (e / 2);
        b = ((b * b) % modulus);
    }
    return result
};
        unsafe fn ord(ch: &str) -> i64 {
    if (ch == " ") {
        return 32
    }
    if (ch == "a") {
        return 97
    }
    if (ch == "b") {
        return 98
    }
    if (ch == "c") {
        return 99
    }
    if (ch == "d") {
        return 100
    }
    if (ch == "e") {
        return 101
    }
    if (ch == "f") {
        return 102
    }
    if (ch == "g") {
        return 103
    }
    if (ch == "h") {
        return 104
    }
    if (ch == "i") {
        return 105
    }
    if (ch == "j") {
        return 106
    }
    if (ch == "k") {
        return 107
    }
    if (ch == "l") {
        return 108
    }
    if (ch == "m") {
        return 109
    }
    if (ch == "n") {
        return 110
    }
    if (ch == "o") {
        return 111
    }
    if (ch == "p") {
        return 112
    }
    if (ch == "q") {
        return 113
    }
    if (ch == "r") {
        return 114
    }
    if (ch == "s") {
        return 115
    }
    if (ch == "t") {
        return 116
    }
    if (ch == "u") {
        return 117
    }
    if (ch == "v") {
        return 118
    }
    if (ch == "w") {
        return 119
    }
    if (ch == "x") {
        return 120
    }
    if (ch == "y") {
        return 121
    }
    if (ch == "z") {
        return 122
    }
    return 0
};
        unsafe fn chr(mut code: i64) -> String {
    if (code == 32) {
        return String::from(" ")
    }
    if (code == 97) {
        return String::from("a")
    }
    if (code == 98) {
        return String::from("b")
    }
    if (code == 99) {
        return String::from("c")
    }
    if (code == 100) {
        return String::from("d")
    }
    if (code == 101) {
        return String::from("e")
    }
    if (code == 102) {
        return String::from("f")
    }
    if (code == 103) {
        return String::from("g")
    }
    if (code == 104) {
        return String::from("h")
    }
    if (code == 105) {
        return String::from("i")
    }
    if (code == 106) {
        return String::from("j")
    }
    if (code == 107) {
        return String::from("k")
    }
    if (code == 108) {
        return String::from("l")
    }
    if (code == 109) {
        return String::from("m")
    }
    if (code == 110) {
        return String::from("n")
    }
    if (code == 111) {
        return String::from("o")
    }
    if (code == 112) {
        return String::from("p")
    }
    if (code == 113) {
        return String::from("q")
    }
    if (code == 114) {
        return String::from("r")
    }
    if (code == 115) {
        return String::from("s")
    }
    if (code == 116) {
        return String::from("t")
    }
    if (code == 117) {
        return String::from("u")
    }
    if (code == 118) {
        return String::from("v")
    }
    if (code == 119) {
        return String::from("w")
    }
    if (code == 120) {
        return String::from("x")
    }
    if (code == 121) {
        return String::from("y")
    }
    if (code == 122) {
        return String::from("z")
    }
    return String::from("").clone()
};
        unsafe fn get_blocks_from_text(message: &str, mut block_size: i64) -> Vec<i64> {
    let mut block_ints: Vec<i64> = vec![];
    let mut block_start: i64 = 0;
    while (block_start < (message.len() as i64)) {
        let mut block_int: i64 = 0;
        let mut i: i64 = block_start;
        while ((i < (block_start + block_size)) && (i < (message.len() as i64))) {
            block_int = (block_int + (ord(&message.chars().nth(i as usize).unwrap().to_string()) * pow_int(g_BYTE_SIZE, (i - block_start))));
            i = (i + 1);
        }
        block_ints = { let mut _v = block_ints.clone(); _v.push(block_int); _v };
        block_start = (block_start + block_size);
    }
    return block_ints
};
        unsafe fn get_text_from_blocks(mut block_ints: Vec<i64>, mut message_length: i64, mut block_size: i64) -> String {
    let mut message: String = String::from("").clone();
    for block_int in block_ints.iter().cloned() {
        let mut block: i64 = block_int;
        let mut i: i64 = (block_size - 1);
        let mut block_message: String = String::from("").clone();
        while (i >= 0) {
            if (((message.len() as i64) + i) < message_length) {
                let mut ascii_number: i64 = (block / pow_int(g_BYTE_SIZE, i));
                block = (block % pow_int(g_BYTE_SIZE, i));
                block_message = format!("{}{}", chr(ascii_number), block_message);
            }
            i = (i - 1);
        }
        message = format!("{}{}", message, block_message);
    }
    return message.clone()
};
        unsafe fn encrypt_message(message: &str, mut n: i64, mut e: i64, mut block_size: i64) -> Vec<i64> {
    let mut encrypted: Vec<i64> = vec![];
    let mut blocks: Vec<i64> = get_blocks_from_text(message, block_size);
    for block in blocks.iter().cloned() {
        encrypted = { let mut _v = encrypted.clone(); _v.push(mod_pow(block, e, n)); _v };
    }
    return encrypted
};
        unsafe fn decrypt_message(mut blocks: Vec<i64>, mut message_length: i64, mut n: i64, mut d: i64, mut block_size: i64) -> String {
    let mut decrypted_blocks: Vec<i64> = vec![];
    for block in blocks.iter().cloned() {
        decrypted_blocks = { let mut _v = decrypted_blocks.clone(); _v.push(mod_pow(block, d, n)); _v };
    }
    let mut message: String = String::from("").clone();
    for num in decrypted_blocks.iter().cloned() {
        message = format!("{}{}", message, chr(num));
    }
    return message.clone()
};
        unsafe fn mochi_main() {
    let mut message: String = String::from("hello world").clone();
    let mut n: i64 = 3233;
    let mut e: i64 = 17;
    let mut d: i64 = 2753;
    let mut block_size: i64 = 1;
    let mut encrypted: Vec<i64> = encrypt_message(&message, n, e, block_size);
    println!("{}", format!("{:?}", encrypted));
    let mut decrypted: String = decrypt_message(encrypted.clone(), (message.len() as i64), n, d, block_size).clone();
    println!("{}", decrypted);
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
