// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_KEY_STRING: String = String::new();
static mut g_key: Vec<Vec<i64>> = Vec::new();
fn main() {
    unsafe {
        g_KEY_STRING = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789").clone();
        g_key = vec![vec![2, 5], vec![1, 6]];
                let _start: i64 = _now();
        unsafe fn mod36(mut n: i64) -> i64 {
    let mut r: i64 = (n % 36);
    if (r < 0) {
        r = (r + 36);
    }
    return r
};
        unsafe fn gcd(mut a: i64, mut b: i64) -> i64 {
    let mut x: i64 = a;
    let mut y: i64 = b;
    while (y != 0) {
        let mut t: i64 = y;
        y = (x % y);
        x = t;
    }
    if (x < 0) {
        x = -x;
    }
    return x
};
        unsafe fn replace_letters(letter: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (g_KEY_STRING.len() as i64)) {
        if (g_KEY_STRING.chars().nth(i as usize).unwrap().to_string() == letter) {
            return i
        }
        i = (i + 1);
    }
    return 0
};
        unsafe fn replace_digits(mut num: i64) -> String {
    let mut idx: i64 = mod36(num);
    return g_KEY_STRING.chars().nth(idx as usize).unwrap().to_string().clone()
};
        unsafe fn to_upper(c: &str) -> String {
    let mut lower: String = String::from("abcdefghijklmnopqrstuvwxyz").clone();
    let mut upper: String = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ").clone();
    let mut i: i64 = 0;
    while (i < (lower.len() as i64)) {
        if (c == lower.chars().nth(i as usize).unwrap().to_string()) {
            return upper.chars().nth(i as usize).unwrap().to_string()
        }
        i = (i + 1);
    }
    return c.to_string().clone()
};
        unsafe fn process_text(text: &str, mut break_key: i64) -> String {
    let mut chars: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        let mut c: String = to_upper(&text.chars().nth(i as usize).unwrap().to_string()).clone();
        let mut j: i64 = 0;
        let mut ok: bool = false;
        while (j < (g_KEY_STRING.len() as i64)) {
            if (g_KEY_STRING.chars().nth(j as usize).unwrap().to_string().as_str() == c.as_str()) {
                ok = true;
                break
            }
            j = (j + 1);
        }
        if ok {
            chars = { let mut _v = chars.clone(); _v.push(c.clone()); _v };
        }
        i = (i + 1);
    }
    if ((chars.len() as i64) == 0) {
        return String::from("")
    }
    let mut last: String = chars[((chars.len() as i64) - 1) as usize].clone().clone();
    while (((chars.len() as i64) % break_key) != 0) {
        chars = { let mut _v = chars.clone(); _v.push(last.clone()); _v };
    }
    let mut res: String = String::from("").clone();
    let mut k: i64 = 0;
    while (k < (chars.len() as i64)) {
        res = format!("{}{}", res, chars[k as usize].clone());
        k = (k + 1);
    }
    return res.clone()
};
        unsafe fn matrix_minor(mut m: Vec<Vec<i64>>, mut row: i64, mut col: i64) -> Vec<Vec<i64>> {
    let mut res: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < (m.len() as i64)) {
        if (i != row) {
            let mut r: Vec<i64> = vec![];
            let mut j: i64 = 0;
            while (j < (m[i as usize].clone().len() as i64)) {
                if (j != col) {
                    r = { let mut _v = r.clone(); _v.push(m[i as usize].clone()[j as usize]); _v };
                }
                j = (j + 1);
            }
            res = { let mut _v = res.clone(); _v.push(r.clone()); _v };
        }
        i = (i + 1);
    }
    return res
};
        unsafe fn determinant(mut m: Vec<Vec<i64>>) -> i64 {
    let mut n = (m.len() as i64);
    if (n == 1) {
        return m[0 as usize].clone()[0 as usize]
    }
    if (n == 2) {
        return ((m[0 as usize].clone()[0 as usize] * m[1 as usize].clone()[1 as usize]) - (m[0 as usize].clone()[1 as usize] * m[1 as usize].clone()[0 as usize]))
    }
    let mut det: i64 = 0;
    let mut col: i64 = 0;
    while (col < n) {
        let mut minor_mat: Vec<Vec<i64>> = matrix_minor(m.clone(), 0, col);
        let mut sign: i64 = 1;
        if ((col % 2) == 1) {
            sign = -1;
        }
        det = (det + ((sign * m[0 as usize].clone()[col as usize]) * determinant(minor_mat.clone())));
        col = (col + 1);
    }
    return det
};
        unsafe fn cofactor_matrix(mut m: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut n = (m.len() as i64);
    let mut res: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            let mut minor_mat: Vec<Vec<i64>> = matrix_minor(m.clone(), i, j);
            let mut det_minor: i64 = determinant(minor_mat.clone());
            let mut sign: i64 = 1;
            if (((i + j) % 2) == 1) {
                sign = -1;
            }
            row = { let mut _v = row.clone(); _v.push((sign * det_minor)); _v };
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return res
};
        unsafe fn transpose(mut m: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut rows = (m.len() as i64);
    let mut cols = (m[0 as usize].clone().len() as i64);
    let mut res: Vec<Vec<i64>> = vec![];
    let mut j: i64 = 0;
    while (j < cols) {
        let mut row: Vec<i64> = vec![];
        let mut i: i64 = 0;
        while (i < rows) {
            row = { let mut _v = row.clone(); _v.push(m[i as usize].clone()[j as usize]); _v };
            i = (i + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row.clone()); _v };
        j = (j + 1);
    }
    return res
};
        unsafe fn matrix_mod(mut m: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut res: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < (m.len() as i64)) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < (m[i as usize].clone().len() as i64)) {
            row = { let mut _v = row.clone(); _v.push(mod36(m[i as usize].clone()[j as usize])); _v };
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return res
};
        unsafe fn scalar_matrix_mult(mut s: i64, mut m: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut res: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < (m.len() as i64)) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < (m[i as usize].clone().len() as i64)) {
            row = { let mut _v = row.clone(); _v.push(mod36((s * m[i as usize].clone()[j as usize]))); _v };
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return res
};
        unsafe fn adjugate(mut m: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut cof: Vec<Vec<i64>> = cofactor_matrix(m.clone());
    let mut n = (cof.len() as i64);
    let mut res: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < n) {
            row = { let mut _v = row.clone(); _v.push(cof[j as usize].clone()[i as usize]); _v };
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return res
};
        unsafe fn multiply_matrix_vector(mut m: Vec<Vec<i64>>, mut v: Vec<i64>) -> Vec<i64> {
    let mut n = (m.len() as i64);
    let mut res: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < n) {
        let mut sum: i64 = 0;
        let mut j: i64 = 0;
        while (j < n) {
            sum = (sum + (m[i as usize].clone()[j as usize] * v[j as usize]));
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(mod36(sum)); _v };
        i = (i + 1);
    }
    return res
};
        unsafe fn inverse_key(mut key: Vec<Vec<i64>>) -> Vec<Vec<i64>> {
    let mut det_val: i64 = determinant(key.clone());
    let mut det_mod: i64 = mod36(det_val);
    let mut det_inv: i64 = 0;
    let mut i: i64 = 0;
    while (i < 36) {
        if (((det_mod * i) % 36) == 1) {
            det_inv = i;
            break
        }
        i = (i + 1);
    }
    let mut adj: Vec<Vec<i64>> = adjugate(key.clone());
    let mut tmp: Vec<Vec<i64>> = scalar_matrix_mult(det_inv, adj.clone());
    let mut res: Vec<Vec<i64>> = matrix_mod(tmp.clone());
    return res
};
        unsafe fn hill_encrypt(mut key: Vec<Vec<i64>>, text: &str) -> String {
    let mut break_key = (key.len() as i64);
    let mut processed: String = process_text(text, break_key).clone();
    let mut encrypted: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (processed.len() as i64)) {
        let mut vec: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < break_key) {
            vec = { let mut _v = vec.clone(); _v.push(replace_letters(&processed.chars().nth((i + j) as usize).unwrap().to_string())); _v };
            j = (j + 1);
        }
        let mut enc_vec: Vec<i64> = multiply_matrix_vector(key.clone(), vec.clone());
        let mut k: i64 = 0;
        while (k < break_key) {
            encrypted = format!("{}{}", encrypted, replace_digits(enc_vec[k as usize]));
            k = (k + 1);
        }
        i = (i + break_key);
    }
    return encrypted.clone()
};
        unsafe fn hill_decrypt(mut key: Vec<Vec<i64>>, text: &str) -> String {
    let mut break_key = (key.len() as i64);
    let mut decrypt_key: Vec<Vec<i64>> = inverse_key(key.clone());
    let mut processed: String = process_text(text, break_key).clone();
    let mut decrypted: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (processed.len() as i64)) {
        let mut vec: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < break_key) {
            vec = { let mut _v = vec.clone(); _v.push(replace_letters(&processed.chars().nth((i + j) as usize).unwrap().to_string())); _v };
            j = (j + 1);
        }
        let mut dec_vec: Vec<i64> = multiply_matrix_vector(decrypt_key.clone(), vec.clone());
        let mut k: i64 = 0;
        while (k < break_key) {
            decrypted = format!("{}{}", decrypted, replace_digits(dec_vec[k as usize]));
            k = (k + 1);
        }
        i = (i + break_key);
    }
    return decrypted.clone()
};
        println!("{}", hill_encrypt(g_key.clone().clone(), &"testing hill cipher"));
        println!("{}", hill_encrypt(g_key.clone().clone(), &"hello"));
        println!("{}", hill_decrypt(g_key.clone().clone(), &"WHXYJOLM9C6XT085LL"));
        println!("{}", hill_decrypt(g_key.clone().clone(), &"85FF00"));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
