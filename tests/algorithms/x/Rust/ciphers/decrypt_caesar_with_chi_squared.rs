// Generated by Mochi transpiler v0.10.59
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Result {
    shift: i64,
    chi: f64,
    decoded: String,
}
impl std::fmt::Display for Result {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"shift\": {}", self.shift)?;
        write!(f, ", ")?;
        write!(f, "\"chi\": {}", self.chi)?;
        write!(f, ", ")?;
        write!(f, "\"decoded\": \"{}\"", self.decoded)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map {
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn default_alphabet() -> Vec<String> {
    return vec![String::from("a"), String::from("b"), String::from("c"), String::from("d"), String::from("e"), String::from("f"), String::from("g"), String::from("h"), String::from("i"), String::from("j"), String::from("k"), String::from("l"), String::from("m"), String::from("n"), String::from("o"), String::from("p"), String::from("q"), String::from("r"), String::from("s"), String::from("t"), String::from("u"), String::from("v"), String::from("w"), String::from("x"), String::from("y"), String::from("z")]
};
    fn default_frequencies() -> HashMap<String, f64> {
    return HashMap::from([(String::from("a"), 0.08497), (String::from("b"), 0.01492), (String::from("c"), 0.02202), (String::from("d"), 0.04253), (String::from("e"), 0.11162), (String::from("f"), 0.02228), (String::from("g"), 0.02015), (String::from("h"), 0.06094), (String::from("i"), 0.07546), (String::from("j"), 0.00153), (String::from("k"), 0.01292), (String::from("l"), 0.04025), (String::from("m"), 0.02406), (String::from("n"), 0.06749), (String::from("o"), 0.07507), (String::from("p"), 0.01929), (String::from("q"), 0.00095), (String::from("r"), 0.07587), (String::from("s"), 0.06327), (String::from("t"), 0.09356), (String::from("u"), 0.02758), (String::from("v"), 0.00978), (String::from("w"), 0.0256), (String::from("x"), 0.0015), (String::from("y"), 0.01994), (String::from("z"), 0.00077)])
};
    fn index_of(mut xs: Vec<String>, ch: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (xs[i as usize].clone() == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
    fn count_char(mut s: String, ch: &str) -> i64 {
    let mut count: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            count = (count + 1);
        }
        i = (i + 1);
    }
    return count
};
    fn decrypt_caesar_with_chi_squared(mut ciphertext: String, mut cipher_alphabet: Vec<String>, frequencies_dict: &HashMap<String, f64>, mut case_sensitive: bool) -> Result {
    let mut alphabet_letters: Vec<String> = cipher_alphabet;
    if ((alphabet_letters.len() as i64) == 0) {
        alphabet_letters = default_alphabet();
    }
    let mut frequencies: HashMap<String, f64> = frequencies_dict;
    if ((frequencies.len() as i64) == 0) {
        frequencies = default_frequencies();
    }
    if !case_sensitive {
        ciphertext = (ciphertext.to_lowercase());
    }
    let mut best_shift: i64 = 0;
    let mut best_chi: f64 = 0.0;
    let mut best_text: String = String::from("").clone();
    let mut shift: i64 = 0;
    while (shift < (alphabet_letters.len() as i64)) {
        let mut decrypted: String = String::from("").clone();
        let mut i: i64 = 0;
        while (i < (ciphertext.len() as i64)) {
            let mut ch: String = { let tmp = &ciphertext; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
            let mut idx: i64 = index_of(alphabet_letters.clone(), &(ch.to_lowercase()));
            if (idx >= 0) {
                let mut m = (alphabet_letters.len() as i64);
                let mut new_idx: i64 = ((idx - shift) % m);
                if (new_idx < 0) {
                    new_idx = (new_idx + m);
                }
                let mut new_char: String = alphabet_letters[new_idx as usize].clone().clone();
                if (case_sensitive && (ch.as_str() != (ch.to_lowercase()).as_str())) {
                    decrypted = format!("{}{}", decrypted, (new_char.to_uppercase()));
                } else {
                    decrypted = format!("{}{}", decrypted, new_char);
                }
            } else {
                decrypted = format!("{}{}", decrypted, ch);
            }
            i = (i + 1);
        }
        let mut chi: f64 = 0.0;
        let mut lowered: String = if case_sensitive { (decrypted.to_lowercase()) } else { decrypted }.clone();
        let mut j: i64 = 0;
        while (j < (alphabet_letters.len() as i64)) {
            let mut letter: String = alphabet_letters[j as usize].clone().clone();
            let mut occ: i64 = count_char(lowered.clone(), &letter);
            if (occ > 0) {
                let mut occf: f64 = (occ as f64);
                let mut expected: f64 = (frequencies.get(letter.as_str()).cloned().unwrap_or_default() * occf);
                let mut diff: f64 = (occf - expected);
                chi = (chi + (((diff * diff) / expected) * occf));
            }
            j = (j + 1);
        }
        if ((shift == 0) || (chi < best_chi)) {
            best_shift = shift;
            best_chi = chi;
            best_text = decrypted.clone();
        }
        shift = (shift + 1);
    }
    return Result {shift: best_shift, chi: best_chi, decoded: best_text.clone()}
};
    let mut r1: Result = decrypt_caesar_with_chi_squared(String::from("dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!"), vec![], &Map {}, false);
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", r1.shift.to_string(), ", "), r1.chi.to_string()), ", "), r1.decoded));
    let mut r2: Result = decrypt_caesar_with_chi_squared(String::from("crybd cdbsxq"), vec![], &Map {}, false);
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", r2.shift.to_string(), ", "), r2.chi.to_string()), ", "), r2.decoded));
    let mut r3: Result = decrypt_caesar_with_chi_squared(String::from("Crybd Cdbsxq"), vec![], &Map {}, true);
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", r3.shift.to_string(), ", "), r3.chi.to_string()), ", "), r3.decoded));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
