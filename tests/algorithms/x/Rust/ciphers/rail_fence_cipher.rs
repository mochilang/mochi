// Generated by Mochi transpiler v0.10.59
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn encrypt(mut input_string: String, mut key: i64) -> String {
    if (key <= 0) {
        panic!("Height of grid can't be 0 or negative");
    }
    if ((key == 1) || ((input_string.len() as i64) <= key)) {
        return input_string
    }
    let mut lowest: i64 = (key - 1);
    let mut temp_grid: Vec<Vec<String>> = vec![];
    let mut i: i64 = 0;
    while (i < key) {
        temp_grid = { let mut _v = temp_grid.clone(); _v.push(vec![]); _v };
        i = (i + 1);
    }
    let mut position: i64 = 0;
    while (position < (input_string.len() as i64)) {
        let mut num: i64 = (position % (lowest * 2));
        let mut alt: i64 = ((lowest * 2) - num);
        if (num > alt) {
            num = alt;
        }
        let mut row: Vec<String> = temp_grid[num as usize].clone();
        row = { let mut _v = row.clone(); _v.push({ let tmp = &input_string; tmp.chars().skip(position as usize).take(((position + 1) - position) as usize).collect::<String>() }); _v };
        temp_grid[num as usize] = row.clone();
        position = (position + 1);
    }
    let mut output: String = String::from("").clone();
    i = 0;
    while (i < key) {
        let mut row: Vec<String> = temp_grid[i as usize].clone();
        let mut j: i64 = 0;
        while (j < (row.len() as i64)) {
            output = format!("{}{}", output, row[j as usize].clone());
            j = (j + 1);
        }
        i = (i + 1);
    }
    return output.clone()
};
    fn decrypt(input_string: &str, mut key: i64) -> String {
    if (key <= 0) {
        panic!("Height of grid can't be 0 or negative");
    }
    if (key == 1) {
        return input_string.to_string()
    }
    let mut lowest: i64 = (key - 1);
    let mut counts: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < key) {
        counts = { let mut _v = counts.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut pos: i64 = 0;
    while (pos < (input_string.len() as i64)) {
        let mut num: i64 = (pos % (lowest * 2));
        let mut alt: i64 = ((lowest * 2) - num);
        if (num > alt) {
            num = alt;
        }
        counts[num as usize] = (counts[num as usize] + 1);
        pos = (pos + 1);
    }
    let mut grid: Vec<Vec<String>> = vec![];
    let mut counter: i64 = 0;
    i = 0;
    while (i < key) {
        let mut length: i64 = counts[i as usize];
        let mut slice: String = { let tmp = &input_string; tmp.chars().skip(counter as usize).take(((counter + length) - counter) as usize).collect::<String>() }.clone();
        let mut row: Vec<String> = vec![];
        let mut j: i64 = 0;
        while (j < (slice.len() as i64)) {
            row = { let mut _v = row.clone(); _v.push(slice.chars().nth(j as usize).unwrap().to_string()); _v };
            j = (j + 1);
        }
        grid = { let mut _v = grid.clone(); _v.push(row.clone()); _v };
        counter = (counter + length);
        i = (i + 1);
    }
    let mut indices: Vec<i64> = vec![];
    i = 0;
    while (i < key) {
        indices = { let mut _v = indices.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut output: String = String::from("").clone();
    pos = 0;
    while (pos < (input_string.len() as i64)) {
        let mut num: i64 = (pos % (lowest * 2));
        let mut alt: i64 = ((lowest * 2) - num);
        if (num > alt) {
            num = alt;
        }
        output = format!("{}{}", output, grid[num as usize].clone()[indices[num as usize] as usize].clone());
        indices[num as usize] = (indices[num as usize] + 1);
        pos = (pos + 1);
    }
    return output.clone()
};
    fn bruteforce(mut input_string: String) -> HashMap<i64, String> {
    let mut results: HashMap<i64, String> = HashMap::new();
    let mut key_guess: i64 = 1;
    while (key_guess < (input_string.len() as i64)) {
        results.insert(key_guess.clone(), decrypt(&input_string, key_guess));
        key_guess = (key_guess + 1);
    }
    return results
};
    println!("{}", encrypt(String::from("Hello World"), 4));
    println!("{}", decrypt(&"HWe olordll", 4));
    let mut bf: HashMap<i64, String> = bruteforce(String::from("HWe olordll"));
    println!("{}", bf.get(&4).cloned().unwrap_or_default());
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
