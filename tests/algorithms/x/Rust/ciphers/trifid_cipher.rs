// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_triagrams: Vec<String> = Vec::new();
fn main() {
    unsafe {
        g_triagrams = vec![String::from("111").clone(), String::from("112").clone(), String::from("113").clone(), String::from("121").clone(), String::from("122").clone(), String::from("123").clone(), String::from("131").clone(), String::from("132").clone(), String::from("133").clone(), String::from("211").clone(), String::from("212").clone(), String::from("213").clone(), String::from("221").clone(), String::from("222").clone(), String::from("223").clone(), String::from("231").clone(), String::from("232").clone(), String::from("233").clone(), String::from("311").clone(), String::from("312").clone(), String::from("313").clone(), String::from("321").clone(), String::from("322").clone(), String::from("323").clone(), String::from("331").clone(), String::from("332").clone(), String::from("333").clone()];
                let _start: i64 = _now();
        unsafe fn remove_spaces(s: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (c.as_str() != " ") {
            res = format!("{}{}", res, c);
        }
        i = (i + 1);
    }
    return res.clone()
};
        unsafe fn char_to_trigram(ch: &str, mut alphabet: String) -> String {
    let mut i: i64 = 0;
    while (i < (alphabet.len() as i64)) {
        if ({ let tmp = &alphabet; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return g_triagrams.clone()[i as usize].clone()
        }
        i = (i + 1);
    }
    return String::from("").clone()
};
        unsafe fn trigram_to_char(tri: &str, mut alphabet: String) -> String {
    let mut i: i64 = 0;
    while (i < (g_triagrams.clone().len() as i64)) {
        if (g_triagrams.clone()[i as usize].clone() == tri) {
            return { let tmp = &alphabet; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }
        }
        i = (i + 1);
    }
    return String::from("").clone()
};
        unsafe fn encrypt_part(part: &str, alphabet: &str) -> String {
    let mut one: String = String::from("").clone();
    let mut two: String = String::from("").clone();
    let mut three: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (part.len() as i64)) {
        let mut tri: String = char_to_trigram(&{ let tmp = &part; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }, alphabet.to_string()).clone();
        one = format!("{}{}", one, { let tmp = &tri; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() });
        two = format!("{}{}", two, { let tmp = &tri; tmp.chars().skip(1 as usize).take((2 - 1) as usize).collect::<String>() });
        three = format!("{}{}", three, { let tmp = &tri; tmp.chars().skip(2 as usize).take((3 - 2) as usize).collect::<String>() });
        i = (i + 1);
    }
    return format!("{}{}", format!("{}{}", one, two), three).clone()
};
        unsafe fn encrypt_message(message: &str, alphabet: &str, mut period: i64) -> String {
    let mut msg: String = remove_spaces(message).clone();
    let mut alpha: String = remove_spaces(alphabet).clone();
    if ((alpha.len() as i64) != 27) {
        return String::from("")
    }
    let mut encrypted_numeric: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (msg.len() as i64)) {
        let mut end: i64 = (i + period);
        if (end > (msg.len() as i64)) {
            end = (msg.len() as i64);
        }
        let mut part: String = { let tmp = &msg; tmp.chars().skip(i as usize).take((end - i) as usize).collect::<String>() }.clone();
        encrypted_numeric = format!("{}{}", encrypted_numeric, encrypt_part(&part, &alpha));
        i = (i + period);
    }
    let mut encrypted: String = String::from("").clone();
    let mut j: i64 = 0;
    while (j < (encrypted_numeric.len() as i64)) {
        let mut tri: String = { let tmp = &encrypted_numeric; tmp.chars().skip(j as usize).take(((j + 3) - j) as usize).collect::<String>() }.clone();
        encrypted = format!("{}{}", encrypted, trigram_to_char(&tri, alpha.clone()));
        j = (j + 3);
    }
    return encrypted.clone()
};
        unsafe fn decrypt_part(part: &str, alphabet: &str) -> Vec<String> {
    let mut converted: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (part.len() as i64)) {
        let mut tri: String = char_to_trigram(&{ let tmp = &part; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }, alphabet.to_string()).clone();
        converted = format!("{}{}", converted, tri);
        i = (i + 1);
    }
    let mut result: Vec<String> = vec![];
    let mut tmp: String = String::from("").clone();
    let mut j: i64 = 0;
    while (j < (converted.len() as i64)) {
        tmp = format!("{}{}", tmp, { let tmp = &converted; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() });
        if ((tmp.len() as i64) == (part.len() as i64)) {
            result = { let mut _v = result.clone(); _v.push(tmp.clone()); _v };
            tmp = String::from("");
        }
        j = (j + 1);
    }
    return result
};
        unsafe fn decrypt_message(message: &str, alphabet: &str, mut period: i64) -> String {
    let mut msg: String = remove_spaces(message).clone();
    let mut alpha: String = remove_spaces(alphabet).clone();
    if ((alpha.len() as i64) != 27) {
        return String::from("")
    }
    let mut decrypted_numeric: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (msg.len() as i64)) {
        let mut end: i64 = (i + period);
        if (end > (msg.len() as i64)) {
            end = (msg.len() as i64);
        }
        let mut part: String = { let tmp = &msg; tmp.chars().skip(i as usize).take((end - i) as usize).collect::<String>() }.clone();
        let mut groups: Vec<String> = decrypt_part(&part, &alpha);
        let mut k: i64 = 0;
        while (k < (groups[0 as usize].clone().len() as i64)) {
            let mut tri: String = format!("{}{}", format!("{}{}", { let tmp = &groups[0 as usize].clone(); tmp.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>() }, { let tmp = &groups[1 as usize].clone(); tmp.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>() }), { let tmp = &groups[2 as usize].clone(); tmp.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>() }).clone();
            decrypted_numeric = { let mut _v = decrypted_numeric.clone(); _v.push(tri.clone()); _v };
            k = (k + 1);
        }
        i = (i + period);
    }
    let mut decrypted: String = String::from("").clone();
    let mut j: i64 = 0;
    while (j < (decrypted_numeric.len() as i64)) {
        decrypted = format!("{}{}", decrypted, trigram_to_char(&decrypted_numeric[j as usize].clone(), alpha.clone()));
        j = (j + 1);
    }
    return decrypted.clone()
};
        unsafe fn mochi_main() {
    let mut msg: String = String::from("DEFEND THE EAST WALL OF THE CASTLE.").clone();
    let mut alphabet: String = String::from("EPSDUCVWYM.ZLKXNBTFGORIJHAQ").clone();
    let mut encrypted: String = encrypt_message(&msg, &alphabet, 5).clone();
    let mut decrypted: String = decrypt_message(&encrypted, &alphabet, 5).clone();
    println!("{}", format!("{}{}", "Encrypted: ", encrypted));
    println!("{}", format!("{}{}", "Decrypted: ", decrypted));
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
