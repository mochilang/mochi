// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Cipher {
    passcode: Vec<String>,
    key_list: Vec<String>,
    shift_key: i64,
}
impl std::fmt::Display for Cipher {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"passcode\": {:?}", self.passcode)?;
        write!(f, ", ")?;
        write!(f, "\"key_list\": {:?}", self.key_list)?;
        write!(f, ", ")?;
        write!(f, "\"shift_key\": {}", self.shift_key)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn ord(ch: &str) -> i64 {
    let mut digits: String = String::from("0123456789").clone();
    let mut i: i64 = 0;
    while (i < (digits.len() as i64)) {
        if ({ let tmp = &digits; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return (48 + i)
        }
        i = (i + 1);
    }
    let mut upper: String = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ").clone();
    i = 0;
    while (i < (upper.len() as i64)) {
        if ({ let tmp = &upper; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return (65 + i)
        }
        i = (i + 1);
    }
    let mut lower: String = String::from("abcdefghijklmnopqrstuvwxyz").clone();
    i = 0;
    while (i < (lower.len() as i64)) {
        if ({ let tmp = &lower; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return (97 + i)
        }
        i = (i + 1);
    }
    return 0
};
    fn neg_pos(mut iterlist: Vec<i64>) -> Vec<i64> {
    let mut i: i64 = 1;
    while (i < (iterlist.len() as i64)) {
        iterlist[i as usize] = -iterlist[i as usize];
        i = (i + 2);
    }
    return iterlist
};
    fn passcode_creator() -> Vec<String> {
    let mut choices: String = String::from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789").clone();
    let mut seed = _now();
    let mut length: i64 = (10 + (seed % 11));
    let mut password: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < length) {
        seed = (((seed * 1103515245) + 12345) % 2147483647);
        let mut idx: i64 = (seed % (choices.len() as i64));
        password = { let mut _v = password.clone(); _v.push({ let tmp = &choices; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }); _v };
        i = (i + 1);
    }
    return password
};
    fn unique_sorted(mut chars: Vec<String>) -> Vec<String> {
    let mut uniq: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (chars.len() as i64)) {
        let mut ch: String = chars[i as usize].clone().clone();
        if !uniq.contains(&ch) {
            uniq = { let mut _v = uniq.clone(); _v.push(ch.clone()); _v };
        }
        i = (i + 1);
    }
    let mut j: i64 = 0;
    while (j < (uniq.len() as i64)) {
        let mut k: i64 = (j + 1);
        let mut min_idx: i64 = j;
        while (k < (uniq.len() as i64)) {
            if (uniq[k as usize].clone().as_str() < uniq[min_idx as usize].clone().as_str()) {
                min_idx = k;
            }
            k = (k + 1);
        }
        if (min_idx != j) {
            let mut tmp: String = uniq[j as usize].clone().clone();
            uniq[j as usize] = uniq[min_idx as usize].clone();
            uniq[min_idx as usize] = tmp.clone();
        }
        j = (j + 1);
    }
    return uniq
};
    fn make_key_list(mut passcode: Vec<String>) -> Vec<String> {
    let mut key_list_options: String = String::from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n").clone();
    let mut breakpoints: Vec<String> = unique_sorted(passcode.clone());
    let mut keys_l: Vec<String> = vec![];
    let mut temp_list: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (key_list_options.len() as i64)) {
        let mut ch: String = { let tmp = &key_list_options; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        temp_list = { let mut _v = temp_list.clone(); _v.push(ch.clone()); _v };
        if (breakpoints.contains(&ch) || (i == ((key_list_options.len() as i64) - 1))) {
            let mut k = ((temp_list.len() as i64) - 1);
            while (k >= 0) {
                keys_l = { let mut _v = keys_l.clone(); _v.push(temp_list[k as usize].clone()); _v };
                k = (k - 1);
            }
            let mut temp_list: Vec<i64> = vec![];
        }
        i = (i + 1);
    }
    return keys_l
};
    fn make_shift_key(mut passcode: Vec<String>) -> i64 {
    let mut codes: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (passcode.len() as i64)) {
        codes = { let mut _v = codes.clone(); _v.push(ord(&passcode[i as usize].clone())); _v };
        i = (i + 1);
    }
    codes = neg_pos(codes.clone());
    let mut total: i64 = 0;
    i = 0;
    while (i < (codes.len() as i64)) {
        total = (total + codes[i as usize]);
        i = (i + 1);
    }
    if (total > 0) {
        return total
    }
    return (passcode.len() as i64)
};
    fn new_cipher(mut passcode_str: String) -> Cipher {
    let mut passcode: Vec<String> = vec![];
    if ((passcode_str.len() as i64) == 0) {
        passcode = passcode_creator();
    } else {
        let mut i: i64 = 0;
        while (i < (passcode_str.len() as i64)) {
            passcode = { let mut _v = passcode.clone(); _v.push({ let tmp = &passcode_str; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }); _v };
            i = (i + 1);
        }
    }
    let mut key_list: Vec<String> = make_key_list(passcode.clone());
    let mut shift_key: i64 = make_shift_key(passcode.clone());
    return Cipher {passcode: passcode, key_list: key_list, shift_key: shift_key}
};
    fn index_of(mut lst: Vec<String>, ch: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (lst.len() as i64)) {
        if (lst[i as usize].clone() == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
    fn encrypt(c: &Cipher, plaintext: &str) -> String {
    let mut encoded: String = String::from("").clone();
    let mut i: i64 = 0;
    let mut n = (c.key_list.clone().len() as i64);
    while (i < (plaintext.len() as i64)) {
        let mut ch: String = { let tmp = &plaintext; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        let mut position: i64 = index_of(c.key_list.clone().clone(), &ch);
        let mut new_pos: i64 = ((position + c.shift_key) % n);
        encoded = format!("{}{}", encoded, c.key_list.clone()[new_pos as usize].clone());
        i = (i + 1);
    }
    return encoded.clone()
};
    fn decrypt(c: &Cipher, encoded_message: &str) -> String {
    let mut decoded: String = String::from("").clone();
    let mut i: i64 = 0;
    let mut n = (c.key_list.clone().len() as i64);
    while (i < (encoded_message.len() as i64)) {
        let mut ch: String = { let tmp = &encoded_message; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        let mut position: i64 = index_of(c.key_list.clone().clone(), &ch);
        let mut new_pos: i64 = ((position - c.shift_key) % n);
        if (new_pos < 0) {
            new_pos = (new_pos + n);
        }
        decoded = format!("{}{}", decoded, c.key_list.clone()[new_pos as usize].clone());
        i = (i + 1);
    }
    return decoded.clone()
};
    fn test_end_to_end() -> String {
    let mut msg: String = String::from("Hello, this is a modified Caesar cipher").clone();
    let mut cip: Cipher = new_cipher(String::from(""));
    return decrypt(&cip, &encrypt(&cip, &msg)).clone()
};
    let mut ssc: Cipher = new_cipher(String::from("4PYIXyqeQZr44"));
    let mut encoded: String = encrypt(&ssc, &"Hello, this is a modified Caesar cipher").clone();
    println!("{}", encoded);
    println!("{}", decrypt(&ssc, &encoded));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
