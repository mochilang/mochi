// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct EdgeCount {
    count: i64,
}
impl std::fmt::Display for EdgeCount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"count\": {}", self.count)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct UserData {
    username: String,
    full_name: String,
    biography: String,
    business_email: String,
    external_url: String,
    edge_followed_by: EdgeCount,
    edge_follow: EdgeCount,
    edge_owner_to_timeline_media: EdgeCount,
    profile_pic_url_hd: String,
    is_verified: bool,
    is_private: bool,
}
impl std::fmt::Display for UserData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"username\": \"{}\"", self.username)?;
        write!(f, ", ")?;
        write!(f, "\"full_name\": \"{}\"", self.full_name)?;
        write!(f, ", ")?;
        write!(f, "\"biography\": \"{}\"", self.biography)?;
        write!(f, ", ")?;
        write!(f, "\"business_email\": \"{}\"", self.business_email)?;
        write!(f, ", ")?;
        write!(f, "\"external_url\": \"{}\"", self.external_url)?;
        write!(f, ", ")?;
        write!(f, "\"edge_followed_by\": {}", self.edge_followed_by)?;
        write!(f, ", ")?;
        write!(f, "\"edge_follow\": {}", self.edge_follow)?;
        write!(f, ", ")?;
        write!(f, "\"edge_owner_to_timeline_media\": {}", self.edge_owner_to_timeline_media)?;
        write!(f, ", ")?;
        write!(f, "\"profile_pic_url_hd\": \"{}\"", self.profile_pic_url_hd)?;
        write!(f, ", ")?;
        write!(f, "\"is_verified\": {}", self.is_verified)?;
        write!(f, ", ")?;
        write!(f, "\"is_private\": {}", self.is_private)?;
        write!(f, "}}")
    }
}

static mut g_sample_script: String = String::new();
fn main() {
    unsafe {
        g_sample_script = String::from("{\"entry_data\":{\"ProfilePage\":[{\"graphql\":{\"user\":{\"username\":\"github\",\"full_name\":\"GitHub\",\"biography\":\"Built for developers.\",\"business_email\":\"support@github.com\",\"external_url\":\"https://github.com/readme\",\"edge_followed_by\":{\"count\":120000},\"edge_follow\":{\"count\":16},\"edge_owner_to_timeline_media\":{\"count\":150},\"profile_pic_url_hd\":\"https://instagram.com/pic.jpg\",\"is_verified\":true,\"is_private\":false}}}]}}").clone();
                let _start: i64 = _now();
        unsafe fn index_of(s: &str, sub: &str) -> i64 {
    let mut i: i64 = 0;
    while (i <= ((s.len() as i64) - (sub.len() as i64))) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + (sub.len() as i64)) - i) as usize).collect::<String>() } == sub) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
        unsafe fn parse_int(s: &str) -> i64 {
    let mut value: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        value = ((value * 10) + { let n: i64 = s.chars().nth(i as usize).unwrap().to_string().parse().unwrap(); n });
        i = (i + 1);
    }
    return value
};
        unsafe fn extract_string(text: &str, key: &str) -> String {
    let mut pattern: String = format!("{}{}", format!("{}{}", "\"", key), "\":\"").clone();
    let mut start: i64 = (index_of(text, &pattern) + (pattern.len() as i64));
    let mut end: i64 = start;
    while ((end < (text.len() as i64)) && ({ let tmp = &text; tmp.chars().skip(end as usize).take(((end + 1) - end) as usize).collect::<String>() }.as_str() != "\"")) {
        end = (end + 1);
    }
    return { let tmp = &text; tmp.chars().skip(start as usize).take((end - start) as usize).collect::<String>() }.clone()
};
        unsafe fn extract_int(text: &str, key: &str) -> i64 {
    let mut pattern: String = format!("{}{}", format!("{}{}", "\"", key), "\":{\"count\":").clone();
    let mut start: i64 = (index_of(text, &pattern) + (pattern.len() as i64));
    let mut end: i64 = start;
    while (end < (text.len() as i64)) {
        let mut ch: String = text.chars().nth(end as usize).unwrap().to_string().clone();
        if ((ch.as_str() < "0") || (ch.as_str() > "9")) {
            break
        }
        end = (end + 1);
    }
    let mut digits: String = { let tmp = &text; tmp.chars().skip(start as usize).take((end - start) as usize).collect::<String>() }.clone();
    let mut num: i64 = parse_int(&digits);
    return num
};
        unsafe fn extract_bool(text: &str, key: &str) -> bool {
    let mut pattern: String = format!("{}{}", format!("{}{}", "\"", key), "\":").clone();
    let mut start: i64 = (index_of(text, &pattern) + (pattern.len() as i64));
    let mut val: String = { let tmp = &text; tmp.chars().skip(start as usize).take(((start + 5) - start) as usize).collect::<String>() }.clone();
    let mut first: String = val.chars().nth(0 as usize).unwrap().to_string().clone();
    if (first.as_str() == "t") {
        return true
    }
    return false
};
        unsafe fn extract_user_profile(script: &str) -> UserData {
    return UserData {username: extract_string(script, &"username").clone(), full_name: extract_string(script, &"full_name").clone(), biography: extract_string(script, &"biography").clone(), business_email: extract_string(script, &"business_email").clone(), external_url: extract_string(script, &"external_url").clone(), edge_followed_by: EdgeCount {count: extract_int(script, &"edge_followed_by")}, edge_follow: EdgeCount {count: extract_int(script, &"edge_follow")}, edge_owner_to_timeline_media: EdgeCount {count: extract_int(script, &"edge_owner_to_timeline_media")}, profile_pic_url_hd: extract_string(script, &"profile_pic_url_hd").clone(), is_verified: extract_bool(script, &"is_verified"), is_private: extract_bool(script, &"is_private")}
};
        let mut user: UserData = extract_user_profile(&g_sample_script);
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", user.full_name.clone(), " ("), user.username.clone()), ") is "), user.biography.clone()));
        println!("{}", format!("{}{}", "number_of_posts = ", user.edge_owner_to_timeline_media.clone().count.to_string()));
        println!("{}", format!("{}{}", "number_of_followers = ", user.edge_followed_by.clone().count.to_string()));
        println!("{}", format!("{}{}", "number_of_followings = ", user.edge_follow.clone().count.to_string()));
        println!("{}", format!("{}{}", "email = ", user.business_email.clone()));
        println!("{}", format!("{}{}", "website = ", user.external_url.clone()));
        println!("{}", format!("{}{}", "profile_picture_url = ", user.profile_pic_url_hd.clone()));
        println!("{}", format!("{}{}", "is_verified = ", user.is_verified.to_string()));
        println!("{}", format!("{}{}", "is_private = ", user.is_private.to_string()));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
