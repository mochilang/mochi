// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Job {
    title: String,
    company: String,
}
impl std::fmt::Display for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"title\": \"{}\"", self.title)?;
        write!(f, ", ")?;
        write!(f, "\"company\": \"{}\"", self.company)?;
        write!(f, "}}")
    }
}

static mut g_SAMPLE_HTML: String = String::new();
fn main() {
    unsafe {
        g_SAMPLE_HTML = String::from("<div data-tn-component=\"organicJob\"><a data-tn-element=\"jobTitle\">Android Developer</a><span class=\"company\">ABC Corp</span></div><div data-tn-component=\"organicJob\"><a data-tn-element=\"jobTitle\">iOS Engineer</a><span class=\"company\">XYZ Ltd</span></div>").clone();
                let _start: i64 = _now();
        unsafe fn indexOf(s: &str, sub: &str, mut start: i64) -> i64 {
    let mut n = (s.len() as i64);
    let mut m = (sub.len() as i64);
    let mut i: i64 = start;
    while (i <= (n - m)) {
        let mut j: i64 = 0;
        let mut ok: bool = true;
        while (j < m) {
            if ({ let tmp = &s; tmp.chars().skip((i + j) as usize).take((((i + j) + 1) - (i + j)) as usize).collect::<String>() }.as_str() != { let tmp = &sub; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }.as_str()) {
                ok = false;
                break
            }
            j = (j + 1);
        }
        if ok {
            return i
        }
        i = (i + 1);
    }
    return (0 - 1)
};
        unsafe fn splitBy(s: &str, sep: &str) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut start: i64 = 0;
    let mut sepLen = (sep.len() as i64);
    let mut idx: i64 = indexOf(s, sep, 0);
    while (idx != (0 - 1)) {
        res = { let mut _v = res.clone(); _v.push({ let tmp = &s; tmp.chars().skip(start as usize).take((idx - start) as usize).collect::<String>() }); _v };
        start = (idx + sepLen);
        idx = indexOf(s, sep, start);
    }
    res = { let mut _v = res.clone(); _v.push({ let tmp = &s; tmp.chars().skip(start as usize).take(((s.len() as i64) - start) as usize).collect::<String>() }); _v };
    return res
};
        unsafe fn between(s: &str, startTag: &str, endTag: &str) -> String {
    let mut startIdx: i64 = indexOf(s, startTag, 0);
    if (startIdx == (0 - 1)) {
        return String::from("")
    }
    startIdx = (startIdx + (startTag.len() as i64));
    let mut endIdx: i64 = indexOf(s, endTag, startIdx);
    if (endIdx == (0 - 1)) {
        return String::from("")
    }
    return { let tmp = &s; tmp.chars().skip(startIdx as usize).take((endIdx - startIdx) as usize).collect::<String>() }.clone()
};
        unsafe fn intToString(mut n: i64) -> String {
    if (n == 0) {
        return String::from("0")
    }
    let mut num: i64 = n;
    let mut digits: String = String::from("").clone();
    while (num > 0) {
        let mut d: i64 = (num % 10);
        digits = format!("{}{}", { let tmp = &"0123456789"; tmp.chars().skip(d as usize).take(((d + 1) - d) as usize).collect::<String>() }, digits);
        num = (num / 10);
    }
    return digits.clone()
};
        unsafe fn fetch_jobs(location: &str) -> Vec<Job> {
    let mut blocks: Vec<String> = splitBy(&g_SAMPLE_HTML, &"data-tn-component=\"organicJob\"");
    let mut jobs: Vec<Job> = vec![];
    let mut i: i64 = 1;
    while (i < (blocks.len() as i64)) {
        let mut block: String = blocks[i as usize].clone().clone();
        let mut title: String = between(&block, &"data-tn-element=\"jobTitle\">", &"</a>").clone();
        let mut company: String = between(&block, &"class=\"company\">", &"</span>").clone();
        jobs = { let mut _v = jobs.clone(); _v.push(Job {title: title.clone(), company: company.clone()}); _v };
        i = (i + 1);
    }
    return jobs
};
        unsafe fn mochi_main() {
    let mut jobs: Vec<Job> = fetch_jobs(&"Bangalore");
    let mut i: i64 = 0;
    while (i < (jobs.len() as i64)) {
        let mut j: Job = jobs[i as usize].clone();
        let mut idx: i64 = (i + 1);
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Job ", intToString(idx)), " is "), j.title.clone()), " at "), j.company.clone()));
        i = (i + 1);
    }
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
