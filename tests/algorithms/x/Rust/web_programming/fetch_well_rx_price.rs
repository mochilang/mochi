// Generated by Mochi transpiler v0.10.63
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_SAMPLE_HTML: String = String::new();
fn main() {
    unsafe {
        g_SAMPLE_HTML = String::from("<div class=\"grid-x pharmCard\"><p class=\"list-title\">Pharmacy A</p><span class=\"price price-large\">$10.00</span></div><div class=\"grid-x pharmCard\"><p class=\"list-title\">Pharmacy B</p><span class=\"price price-large\">$12.50</span></div>").clone();
                let _start: i64 = _now();
        unsafe fn find_substring(s: &str, sub: &str, mut from: i64) -> i64 {
    let mut i: i64 = from;
    while (i <= ((s.len() as i64) - (sub.len() as i64))) {
        let mut j: i64 = 0;
        while ((j < (sub.len() as i64)) && ({ let tmp = &s; tmp.chars().skip((i + j) as usize).take((((i + j) + 1) - (i + j)) as usize).collect::<String>() }.as_str() == { let tmp = &sub; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }.as_str())) {
            j = (j + 1);
        }
        if (j == (sub.len() as i64)) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
        unsafe fn fetch_pharmacy_and_price_list(drug_name: &str, zip_code: &str) -> Vec<HashMap<String, String>> {
    if ((drug_name == "") || (zip_code == "")) {
        return Default::default()
    }
    let mut results: Vec<HashMap<String, String>> = vec![];
    let mut pos: i64 = 0;
    let mut block_tag: String = String::from("<div class=\"grid-x pharmCard\">").clone();
    let mut name_tag: String = String::from("<p class=\"list-title\">").clone();
    let mut price_tag: String = String::from("<span class=\"price price-large\">").clone();
    loop {
        let mut div_idx: i64 = find_substring(&g_SAMPLE_HTML, &block_tag, pos);
        if (div_idx < 0) {
            break
        }
        let mut name_start: i64 = find_substring(&g_SAMPLE_HTML, &name_tag, div_idx);
        if (name_start < 0) {
            break
        }
        name_start = (name_start + (name_tag.len() as i64));
        let mut name_end: i64 = find_substring(&g_SAMPLE_HTML, &"</p>", name_start);
        if (name_end < 0) {
            break
        }
        let mut name: String = { let tmp = &g_SAMPLE_HTML; tmp.chars().skip(name_start as usize).take((name_end - name_start) as usize).collect::<String>() }.clone();
        let mut price_start: i64 = find_substring(&g_SAMPLE_HTML, &price_tag, name_end);
        if (price_start < 0) {
            break
        }
        price_start = (price_start + (price_tag.len() as i64));
        let mut price_end: i64 = find_substring(&g_SAMPLE_HTML, &"</span>", price_start);
        if (price_end < 0) {
            break
        }
        let mut price: String = { let tmp = &g_SAMPLE_HTML; tmp.chars().skip(price_start as usize).take((price_end - price_start) as usize).collect::<String>() }.clone();
        results = { let mut _v = results.clone(); _v.push(HashMap::from([(String::from("pharmacy_name"), String::from(name.clone())), (String::from("price"), String::from(price.clone()))])); _v };
        pos = price_end;
    }
    return results
};
        let mut pharmacy_price_list: Vec<HashMap<String, String>> = fetch_pharmacy_and_price_list(&"aspirin", &"30303");
        if !pharmacy_price_list.is_empty() {
            let mut i: i64 = 0;
            while (i < (pharmacy_price_list.len() as i64)) {
                let mut entry: HashMap<String, String> = pharmacy_price_list[i as usize].clone();
                println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Pharmacy: ", entry.get("pharmacy_name").cloned().unwrap_or_default()), " Price: "), entry.get("price").cloned().unwrap_or_default()));
                i = (i + 1);
            }
        } else {
            println!("{}", "No results found");
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
