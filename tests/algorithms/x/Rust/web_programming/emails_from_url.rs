// Generated by Mochi transpiler v0.10.63
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Page {
    url: String,
    html: String,
}
impl std::fmt::Display for Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"url\": \"{}\"", self.url)?;
        write!(f, ", ")?;
        write!(f, "\"html\": \"{}\"", self.html)?;
        write!(f, "}}")
    }
}

static mut g_pages: Vec<Page> = Vec::new();
static mut g_k: i64 = 0;
fn main() {
    unsafe {
        g_pages = vec![Page {url: String::from("https://example.com"), html: String::from("<html><body><a href=\"/contact\">Contact</a></body></html>")}.clone(), Page {url: String::from("https://example.com/contact"), html: String::from("<html>Contact us at info@example.com or support@example.com</html>")}.clone()];
        g_k = 0;
                let _start: i64 = _now();
        unsafe fn index_of(s: &str, ch: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if (s.chars().nth(i as usize).unwrap().to_string() == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
        unsafe fn index_of_substring(s: &str, sub: &str) -> i64 {
    let mut n = (s.len() as i64);
    let mut m = (sub.len() as i64);
    if (m == 0) {
        return 0
    }
    let mut i: i64 = 0;
    while (i <= (n - m)) {
        let mut j: i64 = 0;
        let mut is_match: bool = true;
        while (j < m) {
            if (s.chars().nth((i + j) as usize).unwrap().to_string().as_str() != sub.chars().nth(j as usize).unwrap().to_string().as_str()) {
                is_match = false;
                break
            }
            j = (j + 1);
        }
        if is_match {
            return i
        }
        i = (i + 1);
    }
    return -1
};
        unsafe fn split(s: &str, sep: &str) -> Vec<String> {
    let mut parts: Vec<String> = vec![];
    let mut last: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = s.chars().nth(i as usize).unwrap().to_string().clone();
        if (ch == sep) {
            parts = { let mut _v = parts.clone(); _v.push({ let tmp = &s; tmp.chars().skip(last as usize).take((i - last) as usize).collect::<String>() }); _v };
            last = (i + 1);
        }
        if ((i + 1) == (s.len() as i64)) {
            parts = { let mut _v = parts.clone(); _v.push({ let tmp = &s; tmp.chars().skip(last as usize).take(((i + 1) - last) as usize).collect::<String>() }); _v };
        }
        i = (i + 1);
    }
    return parts
};
        unsafe fn get_sub_domain_name(url: &str) -> String {
    let mut proto_pos: i64 = index_of_substring(url, &"://");
    let mut start: i64 = 0;
    if (proto_pos >= 0) {
        start = (proto_pos + 3);
    }
    let mut i: i64 = start;
    while (i < (url.len() as i64)) {
        if (url.chars().nth(i as usize).unwrap().to_string().as_str() == "/") {
            break
        }
        i = (i + 1);
    }
    return { let tmp = &url; tmp.chars().skip(start as usize).take((i - start) as usize).collect::<String>() }.clone()
};
        unsafe fn get_domain_name(url: &str) -> String {
    let mut sub: String = get_sub_domain_name(url).clone();
    let mut parts: Vec<String> = sub.split(".").map(|x| x.to_string()).collect::<Vec<String>>();
    if ((parts.len() as i64) >= 2) {
        return format!("{}{}", format!("{}{}", parts[((parts.len() as i64) - 2) as usize].clone(), "."), parts[((parts.len() as i64) - 1) as usize].clone())
    }
    return sub.clone()
};
        unsafe fn is_alnum(ch: &str) -> bool {
    let mut chars: String = String::from("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz").clone();
    return (index_of(&chars, ch) >= 0)
};
        unsafe fn contains(mut xs: Vec<String>, x: &str) -> bool {
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (xs[i as usize].clone() == x) {
            return true
        }
        i = (i + 1);
    }
    return false
};
        unsafe fn bubble_sort(mut xs: Vec<String>) -> Vec<String> {
    let mut arr: Vec<String> = xs.clone();
    let mut n = (arr.len() as i64);
    let mut i: i64 = 0;
    while (i < n) {
        let mut j: i64 = 0;
        while ((j + 1) < (n - i)) {
            if (arr[j as usize].clone().as_str() > arr[(j + 1) as usize].clone().as_str()) {
                let mut tmp: String = arr[j as usize].clone().clone();
                arr[j as usize] = arr[(j + 1) as usize].clone();
                arr[(j + 1) as usize] = tmp.clone();
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return arr
};
        unsafe fn extract_links(domain: &str, html: &str) -> Vec<String> {
    let mut links: Vec<String> = vec![];
    let mut pos: i64 = index_of_substring(html, &"href=");
    while (pos >= 0) {
        let mut start_quote: i64 = index_of(&{ let tmp = &html; tmp.chars().skip((pos + 5) as usize).take(((html.len() as i64) - (pos + 5)) as usize).collect::<String>() }, &"\"");
        if (start_quote < 0) {
            break
        }
        let mut rest: i64 = (((pos + 5) + start_quote) + 1);
        let mut end_quote: i64 = index_of(&{ let tmp = &html; tmp.chars().skip(rest as usize).take(((html.len() as i64) - rest) as usize).collect::<String>() }, &"\"");
        if (end_quote < 0) {
            break
        }
        let mut link: String = { let tmp = &html; tmp.chars().skip(rest as usize).take(((rest + end_quote) - rest) as usize).collect::<String>() }.clone();
        if !contains(links.clone(), &link) {
            let mut absolute: String = link.clone();
            if !((index_of_substring(&link, &"http://") == 0) || (index_of_substring(&link, &"https://") == 0)) {
                if (index_of_substring(&link, &"/") == 0) {
                    absolute = format!("{}{}", format!("{}{}", "https://", domain), link);
                } else {
                    absolute = format!("{}{}", format!("{}{}", format!("{}{}", "https://", domain), "/"), link);
                }
            }
            links = { let mut _v = links.clone(); _v.push(absolute.clone()); _v };
        }
        pos = index_of_substring(&{ let tmp = &html; tmp.chars().skip((rest + end_quote) as usize).take(((html.len() as i64) - (rest + end_quote)) as usize).collect::<String>() }, &"href=");
        if (pos >= 0) {
            pos = ((pos + rest) + end_quote);
        }
    }
    return links
};
        unsafe fn extract_emails(domain: &str, text: &str) -> Vec<String> {
    let mut emails: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        if (text.chars().nth(i as usize).unwrap().to_string().as_str() == "@") {
            if ({ let tmp = &text; tmp.chars().skip((i + 1) as usize).take((((i + 1) + (domain.len() as i64)) - (i + 1)) as usize).collect::<String>() } == domain) {
                let mut j: i64 = (i - 1);
                while ((j >= 0) && is_alnum(&text.chars().nth(j as usize).unwrap().to_string())) {
                    j = (j - 1);
                }
                let mut local: String = { let tmp = &text; tmp.chars().skip((j + 1) as usize).take((i - (j + 1)) as usize).collect::<String>() }.clone();
                if ((local.len() as i64) > 0) {
                    let mut email: String = format!("{}{}", format!("{}{}", local, "@"), domain).clone();
                    if !contains(emails.clone(), &email) {
                        emails = { let mut _v = emails.clone(); _v.push(email.clone()); _v };
                    }
                }
            }
        }
        i = (i + 1);
    }
    return emails
};
        unsafe fn find_page(mut pages: Vec<Page>, url: &str) -> String {
    let mut i: i64 = 0;
    while (i < (pages.len() as i64)) {
        let mut p: Page = pages[i as usize].clone();
        if (p.url.clone() == url) {
            return p.html.clone()
        }
        i = (i + 1);
    }
    return String::from("").clone()
};
        unsafe fn emails_from_url(url: &str, mut pages: Vec<Page>) -> Vec<String> {
    let mut domain: String = get_domain_name(url).clone();
    let mut base_html: String = find_page(pages.clone(), url).clone();
    let mut links: Vec<String> = extract_links(&domain, &base_html);
    let mut found: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (links.len() as i64)) {
        let mut html: String = find_page(pages.clone(), &links[i as usize].clone()).clone();
        let mut emails: Vec<String> = extract_emails(&domain, &html);
        let mut j: i64 = 0;
        while (j < (emails.len() as i64)) {
            if !contains(found.clone(), &emails[j as usize].clone()) {
                found = { let mut _v = found.clone(); _v.push(emails[j as usize].clone()); _v };
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    let mut sorted: Vec<String> = bubble_sort(found.clone());
    return sorted
};
        let mut emails: Vec<String> = emails_from_url(&"https://example.com", g_pages.clone());
        println!("{}", format!("{}{}", (emails.len() as i64).to_string(), " emails found:"));
        while (g_k < (emails.len() as i64)) {
            println!("{}", emails[g_k as usize].clone());
            g_k = (g_k + 1);
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
