// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn cramers_rule_2x2(mut eq1: Vec<f64>, mut eq2: Vec<f64>) -> Vec<f64> {
    if (((eq1.len() as i64) != 3) || ((eq2.len() as i64) != 3)) {
        panic!("Please enter a valid equation.");
    }
    if ((((eq1[0 as usize] == 0.0) && (eq1[1 as usize] == 0.0)) && (eq2[0 as usize] == 0.0)) && (eq2[1 as usize] == 0.0)) {
        panic!("Both a & b of two equations can't be zero.");
    }
    let a1: f64 = eq1[0 as usize];
    let b1: f64 = eq1[1 as usize];
    let c1: f64 = eq1[2 as usize];
    let a2: f64 = eq2[0 as usize];
    let b2: f64 = eq2[1 as usize];
    let c2: f64 = eq2[2 as usize];
    let determinant: f64 = ((a1 * b2) - (a2 * b1));
    let determinant_x: f64 = ((c1 * b2) - (c2 * b1));
    let determinant_y: f64 = ((a1 * c2) - (a2 * c1));
    if (determinant == 0.0) {
        if ((determinant_x == 0.0) && (determinant_y == 0.0)) {
            panic!("Infinite solutions. (Consistent system)");
        }
        panic!("No solution. (Inconsistent system)");
    }
    if ((determinant_x == 0.0) && (determinant_y == 0.0)) {
        return vec![0.0, 0.0]
    }
    let x: f64 = (determinant_x / determinant);
    let y: f64 = (determinant_y / determinant);
    return vec![x, y]
};
    fn test_cramers_rule_2x2() {
    let r1: Vec<f64> = cramers_rule_2x2(vec![2.0, 3.0, 0.0], vec![5.0, 1.0, 0.0]);
    if ((r1[0 as usize] != 0.0) || (r1[1 as usize] != 0.0)) {
        panic!("Test1 failed");
    }
    let r2: Vec<f64> = cramers_rule_2x2(vec![0.0, 4.0, 50.0], vec![2.0, 0.0, 26.0]);
    if ((r2[0 as usize] != 13.0) || (r2[1 as usize] != 12.5)) {
        panic!("Test2 failed");
    }
};
    fn mochi_main() {
    test_cramers_rule_2x2();
    println!("{}", { let tmp = cramers_rule_2x2(vec![11.0, 2.0, 30.0], vec![1.0, 0.0, 4.0]).clone(); tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
