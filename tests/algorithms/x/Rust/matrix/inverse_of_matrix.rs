// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_m2: Vec<Vec<f64>> = Vec::new();
static mut g_m3: Vec<Vec<f64>> = Vec::new();
fn main() {
    unsafe {
        g_m2 = vec![vec![2.0, 5.0].clone(), vec![2.0, 0.0].clone()];
        g_m3 = vec![vec![2.0, 5.0, 7.0].clone(), vec![2.0, 0.0, 1.0].clone(), vec![1.0, 2.0, 3.0].clone()];
                let _start: i64 = _now();
        fn inverse_of_matrix(mut matrix: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    if ((((matrix.len() as i64) == 2) && ((matrix[0 as usize].clone().len() as i64) == 2)) && ((matrix[1 as usize].clone().len() as i64) == 2)) {
        let det: f64 = ((matrix[0 as usize].clone()[0 as usize] * matrix[1 as usize].clone()[1 as usize]) - (matrix[1 as usize].clone()[0 as usize] * matrix[0 as usize].clone()[1 as usize]));
        if (det == 0.0) {
            println!("{}", "This matrix has no inverse.");
            return vec![]
        }
        return vec![vec![(matrix[1 as usize].clone()[1 as usize] / det), (-matrix[0 as usize].clone()[1 as usize] / det)].clone(), vec![(-matrix[1 as usize].clone()[0 as usize] / det), (matrix[0 as usize].clone()[0 as usize] / det)].clone()]
    } else if (((((matrix.len() as i64) == 3) && ((matrix[0 as usize].clone().len() as i64) == 3)) && ((matrix[1 as usize].clone().len() as i64) == 3)) && ((matrix[2 as usize].clone().len() as i64) == 3)) {
        let det: f64 = (((((matrix[0 as usize].clone()[0 as usize] * matrix[1 as usize].clone()[1 as usize]) * matrix[2 as usize].clone()[2 as usize]) + ((matrix[0 as usize].clone()[1 as usize] * matrix[1 as usize].clone()[2 as usize]) * matrix[2 as usize].clone()[0 as usize])) + ((matrix[0 as usize].clone()[2 as usize] * matrix[1 as usize].clone()[0 as usize]) * matrix[2 as usize].clone()[1 as usize])) - ((((matrix[0 as usize].clone()[2 as usize] * matrix[1 as usize].clone()[1 as usize]) * matrix[2 as usize].clone()[0 as usize]) + ((matrix[0 as usize].clone()[1 as usize] * matrix[1 as usize].clone()[0 as usize]) * matrix[2 as usize].clone()[2 as usize])) + ((matrix[0 as usize].clone()[0 as usize] * matrix[1 as usize].clone()[2 as usize]) * matrix[2 as usize].clone()[1 as usize])));
        if (det == 0.0) {
            println!("{}", "This matrix has no inverse.");
            return vec![]
        }
        let mut cof: Vec<Vec<f64>> = vec![vec![0.0, 0.0, 0.0].clone(), vec![0.0, 0.0, 0.0].clone(), vec![0.0, 0.0, 0.0].clone()];
        cof[0 as usize][0 as usize] = ((matrix[1 as usize].clone()[1 as usize] * matrix[2 as usize].clone()[2 as usize]) - (matrix[1 as usize].clone()[2 as usize] * matrix[2 as usize].clone()[1 as usize]));
        cof[0 as usize][1 as usize] = -((matrix[1 as usize].clone()[0 as usize] * matrix[2 as usize].clone()[2 as usize]) - (matrix[1 as usize].clone()[2 as usize] * matrix[2 as usize].clone()[0 as usize]));
        cof[0 as usize][2 as usize] = ((matrix[1 as usize].clone()[0 as usize] * matrix[2 as usize].clone()[1 as usize]) - (matrix[1 as usize].clone()[1 as usize] * matrix[2 as usize].clone()[0 as usize]));
        cof[1 as usize][0 as usize] = -((matrix[0 as usize].clone()[1 as usize] * matrix[2 as usize].clone()[2 as usize]) - (matrix[0 as usize].clone()[2 as usize] * matrix[2 as usize].clone()[1 as usize]));
        cof[1 as usize][1 as usize] = ((matrix[0 as usize].clone()[0 as usize] * matrix[2 as usize].clone()[2 as usize]) - (matrix[0 as usize].clone()[2 as usize] * matrix[2 as usize].clone()[0 as usize]));
        cof[1 as usize][2 as usize] = -((matrix[0 as usize].clone()[0 as usize] * matrix[2 as usize].clone()[1 as usize]) - (matrix[0 as usize].clone()[1 as usize] * matrix[2 as usize].clone()[0 as usize]));
        cof[2 as usize][0 as usize] = ((matrix[0 as usize].clone()[1 as usize] * matrix[1 as usize].clone()[2 as usize]) - (matrix[0 as usize].clone()[2 as usize] * matrix[1 as usize].clone()[1 as usize]));
        cof[2 as usize][1 as usize] = -((matrix[0 as usize].clone()[0 as usize] * matrix[1 as usize].clone()[2 as usize]) - (matrix[0 as usize].clone()[2 as usize] * matrix[1 as usize].clone()[0 as usize]));
        cof[2 as usize][2 as usize] = ((matrix[0 as usize].clone()[0 as usize] * matrix[1 as usize].clone()[1 as usize]) - (matrix[0 as usize].clone()[1 as usize] * matrix[1 as usize].clone()[0 as usize]));
        let mut inv: Vec<Vec<f64>> = vec![vec![0.0, 0.0, 0.0].clone(), vec![0.0, 0.0, 0.0].clone(), vec![0.0, 0.0, 0.0].clone()];
        let mut i: i64 = 0;
        while (i < 3) {
            let mut j: i64 = 0;
            while (j < 3) {
                inv[i as usize][j as usize] = (cof[j as usize].clone()[i as usize] / det);
                j = (j + 1);
            }
            i = (i + 1);
        }
        return inv
    }
    println!("{}", "Please provide a matrix of size 2x2 or 3x3.");
    return vec![]
};
        println!("{:?}", format!("{:?}", inverse_of_matrix(unsafe { g_m2.clone() }.clone())));
        println!("{:?}", format!("{:?}", inverse_of_matrix(unsafe { g_m3.clone() }.clone())));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
