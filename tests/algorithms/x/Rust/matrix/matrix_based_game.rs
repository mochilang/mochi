// Generated by Mochi transpiler v0.10.68
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Coord {
    x: i64,
    y: i64,
}
impl std::fmt::Display for Coord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {}", self.y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct PlayResult {
    matrix: Vec<Vec<String>>,
    score: i64,
}
impl std::fmt::Display for PlayResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"matrix\": {:?}", self.matrix)?;
        write!(f, ", ")?;
        write!(f, "\"score\": {}", self.score)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn is_alnum(mut ch: String) -> bool {
    return ((((ch.as_str() >= "0") && (ch.as_str() <= "9")) || ((ch.as_str() >= "A") && (ch.as_str() <= "Z"))) || ((ch.as_str() >= "a") && (ch.as_str() <= "z")))
};
    fn to_int(mut token: String) -> i64 {
    let mut res: i64 = 0;
    let mut i: i64 = 0;
    while (i < (token.len() as i64)) {
        res = ((res * 10) + { let n: i64 = { let tmp = &token; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.parse().unwrap(); n });
        i = (i + 1);
    }
    return res
};
    fn split(mut s: String, mut sep: String) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut current: String = String::new();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (ch.as_str() == sep.as_str()) {
            res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
            current = String::new();
        } else {
            current = format!("{}{}", current, ch);
        }
        i = (i + 1);
    }
    res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
    return res
};
    let mut parse_moves = |mut input_str: String| -> Vec<Coord> {
    let pairs: Vec<String> = input_str.split(",").map(|x| x.to_string()).collect::<Vec<String>>();
    let mut moves: Vec<Coord> = vec![];
    let mut i: i64 = 0;
    while (i < (pairs.len() as i64)) {
        let pair: String = pairs[i as usize].clone().clone();
        let mut numbers: Vec<String> = vec![];
        let mut num: String = String::new();
        let mut j: i64 = 0;
        while (j < (pair.len() as i64)) {
            let ch: String = { let tmp = &pair; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }.clone();
            if (ch.as_str() == " ") {
                if (num.as_str() != "") {
                    numbers = { let mut _v = numbers.clone(); _v.push(num.clone()); _v };
                    num = String::new();
                }
            } else {
                num = format!("{}{}", num, ch);
            }
            j = (j + 1);
        }
        if (num.as_str() != "") {
            numbers = { let mut _v = numbers.clone(); _v.push(num.clone()); _v };
        }
        if ((numbers.len() as i64) != 2) {
            panic!("Each move must have exactly two numbers.");
        }
        let x: i64 = to_int(numbers[0 as usize].clone());
        let y: i64 = to_int(numbers[1 as usize].clone());
        moves = { let mut _v = moves.clone(); _v.push(Coord {x: x, y: y}); _v };
        i = (i + 1);
    }
    return moves
};
    fn validate_matrix_size(mut size: i64) {
    if (size <= 0) {
        panic!("Matrix size must be a positive integer.");
    }
};
    let mut validate_matrix_content = |mut matrix: Vec<String>, mut size: i64| {
    if ((matrix.len() as i64) != size) {
        panic!("The matrix dont match with size.");
    }
    let mut i: i64 = 0;
    while (i < size) {
        let row: String = matrix[i as usize].clone().clone();
        if ((row.len() as i64) != size) {
            panic!("{}", format!("{}{}", format!("{}{}", "Each row in the matrix must have exactly ", size.to_string()), " characters."));
        }
        let mut j: i64 = 0;
        while (j < size) {
            let ch: String = { let tmp = &row; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }.clone();
            if !is_alnum(ch.clone()) {
                panic!("Matrix rows can only contain letters and numbers.");
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
};
    fn validate_moves(mut moves: Vec<Coord>, mut size: i64) {
    let mut i: i64 = 0;
    while (i < (moves.len() as i64)) {
        let mv: Coord = moves[i as usize].clone();
        if ((((mv.x < 0) || (mv.x >= size)) || (mv.y < 0)) || (mv.y >= size)) {
            panic!("Move is out of bounds for a matrix.");
        }
        i = (i + 1);
    }
};
    fn contains(mut pos: Vec<Coord>, mut r: i64, mut c: i64) -> bool {
    let mut i: i64 = 0;
    while (i < (pos.len() as i64)) {
        let p: Coord = pos[i as usize].clone();
        if ((p.x == r) && (p.y == c)) {
            return true
        }
        i = (i + 1);
    }
    return false
};
    let mut find_repeat = |mut matrix_g: Vec<Vec<String>>, mut row: i64, mut column: i64, mut size: i64| -> Vec<Coord> {
    column = ((size - 1) - column);
    let mut visited: Vec<Coord> = vec![];
    let mut repeated: Vec<Coord> = vec![];
    let color: String = matrix_g[column as usize].clone()[row as usize].clone().clone();
    if (color.as_str() == "-") {
        return repeated
    }
    let mut stack: Vec<Coord> = vec![Coord {x: column, y: row}.clone()];
    while ((stack.len() as i64) > 0) {
        let idx: i64 = ((stack.len() as i64) - 1);
        let pos: Coord = stack[idx as usize].clone();
        stack = stack[0 as usize..idx as usize].to_vec();
        if ((((pos.x < 0) || (pos.x >= size)) || (pos.y < 0)) || (pos.y >= size)) {
            continue
        }
        if contains(visited.clone(), pos.x, pos.y) {
            continue
        }
        visited = { let mut _v = visited.clone(); _v.push(pos.clone()); _v };
        if (matrix_g[pos.x as usize].clone()[pos.y as usize].clone().as_str() == color.as_str()) {
            repeated = { let mut _v = repeated.clone(); _v.push(pos.clone()); _v };
            stack = { let mut _v = stack.clone(); _v.push(Coord {x: (pos.x - 1), y: pos.y}); _v };
            stack = { let mut _v = stack.clone(); _v.push(Coord {x: (pos.x + 1), y: pos.y}); _v };
            stack = { let mut _v = stack.clone(); _v.push(Coord {x: pos.x, y: (pos.y - 1)}); _v };
            stack = { let mut _v = stack.clone(); _v.push(Coord {x: pos.x, y: (pos.y + 1)}); _v };
        }
    }
    return repeated
};
    fn increment_score(mut count: i64) -> i64 {
    return ((count * (count + 1)) / 2)
};
    fn move_x(mut matrix_g: Vec<Vec<String>>, mut column: i64, mut size: i64) -> Vec<Vec<String>> {
    let mut new_list: Vec<String> = vec![];
    let mut row: i64 = 0;
    while (row < size) {
        let val: String = matrix_g[row as usize].clone()[column as usize].clone().clone();
        if (val.as_str() != "-") {
            new_list = { let mut _v = new_list.clone(); _v.push(val.clone()); _v };
        } else {
            new_list = vec![vec![val.clone()].clone(), new_list.clone()].concat();
        }
        row = (row + 1);
    }
    row = 0;
    while (row < size) {
        matrix_g[row as usize][column as usize] = new_list[row as usize].clone();
        row = (row + 1);
    }
    return matrix_g
};
    fn move_y(mut matrix_g: Vec<Vec<String>>, mut size: i64) -> Vec<Vec<String>> {
    let mut empty_cols: Vec<i64> = vec![];
    let mut column: i64 = (size - 1);
    while (column >= 0) {
        let mut row: i64 = 0;
        let mut all_empty: bool = true;
        while (row < size) {
            if (matrix_g[row as usize].clone()[column as usize].clone().as_str() != "-") {
                all_empty = false;
                break
            }
            row = (row + 1);
        }
        if all_empty {
            empty_cols = { let mut _v = empty_cols.clone(); _v.push(column); _v };
        }
        column = (column - 1);
    }
    let mut i: i64 = 0;
    while (i < (empty_cols.len() as i64)) {
        let col: i64 = empty_cols[i as usize];
        let mut c: i64 = (col + 1);
        while (c < size) {
            let mut r: i64 = 0;
            while (r < size) {
                matrix_g[r as usize][(c - 1) as usize] = matrix_g[r as usize].clone()[c as usize].clone();
                r = (r + 1);
            }
            c = (c + 1);
        }
        let mut r: i64 = 0;
        while (r < size) {
            matrix_g[r as usize][(size - 1) as usize] = String::from("-");
            r = (r + 1);
        }
        i = (i + 1);
    }
    return matrix_g
};
    let mut play = |matrix_g: &mut Vec<Vec<String>>, mut pos_x: i64, mut pos_y: i64, mut size: i64| -> PlayResult {
    let same_colors: Vec<Coord> = find_repeat(matrix_g.clone(), pos_x, pos_y, size);
    if ((same_colors.len() as i64) != 0) {
        let mut i: i64 = 0;
        while (i < (same_colors.len() as i64)) {
            let p: Coord = same_colors[i as usize].clone();
            (*matrix_g)[p.x as usize][p.y as usize] = String::from("-");
            i = (i + 1);
        }
        let mut column: i64 = 0;
        while (column < size) {
            (*matrix_g) = move_x(matrix_g.clone(), column, size);
            column = (column + 1);
        }
        (*matrix_g) = move_y(matrix_g.clone(), size);
    }
    let sc: i64 = increment_score((same_colors.len() as i64));
    return PlayResult {matrix: matrix_g.clone(), score: sc}
};
    fn build_matrix(mut matrix: Vec<String>) -> Vec<Vec<String>> {
    let mut res: Vec<Vec<String>> = vec![];
    let mut i: i64 = 0;
    while (i < (matrix.len() as i64)) {
        let row: String = matrix[i as usize].clone().clone();
        let mut row_list: Vec<String> = vec![];
        let mut j: i64 = 0;
        while (j < (row.len() as i64)) {
            row_list = { let mut _v = row_list.clone(); _v.push({ let tmp = &row; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }); _v };
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(row_list.clone()); _v };
        i = (i + 1);
    }
    return res
};
    let mut process_game = |mut size: i64, mut matrix: Vec<String>, mut moves: Vec<Coord>| -> i64 {
    let mut game_matrix: Vec<Vec<String>> = build_matrix(matrix.clone());
    let mut total: i64 = 0;
    let mut i: i64 = 0;
    while (i < (moves.len() as i64)) {
        let mv: Coord = moves[i as usize].clone();
        let res: PlayResult = play(&mut game_matrix, mv.x, mv.y, size);
        game_matrix = res.matrix.clone();
        total = (total + res.score);
        i = (i + 1);
    }
    return total
};
    let mut mochi_main = || {
    let size: i64 = 4;
    let matrix: Vec<String> = vec![String::from("RRBG").clone(), String::from("RBBG").clone(), String::from("YYGG").clone(), String::from("XYGG").clone()];
    let moves: Vec<Coord> = parse_moves(String::from("0 1,1 1"));
    validate_matrix_size(size);
    validate_matrix_content(matrix.clone(), size);
    validate_moves(moves.clone(), size);
    let score: i64 = process_game(size, matrix.clone(), moves.clone());
    println!("{}", score.to_string());
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
