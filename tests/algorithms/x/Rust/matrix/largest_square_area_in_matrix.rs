// Generated by Mochi transpiler v0.10.68
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn update_area_of_max_square(mut row: i64, mut col: i64, mut rows: i64, mut cols: i64, mut mat: Vec<Vec<i64>>, largest_square_area: &mut Vec<i64>) -> i64 {
    if ((row >= rows) || (col >= cols)) {
        return 0
    }
    let right: i64 = update_area_of_max_square(row, (col + 1), rows, cols, mat.clone(), largest_square_area);
    let diagonal: i64 = update_area_of_max_square((row + 1), (col + 1), rows, cols, mat.clone(), largest_square_area);
    let down: i64 = update_area_of_max_square((row + 1), col, rows, cols, mat.clone(), largest_square_area);
    if (mat[row as usize].clone()[col as usize] == 1) {
        let sub: i64 = (1 + { let tmp = vec![right, diagonal, down].clone(); let mut it = tmp.iter(); let first = *it.next().unwrap_or(&Default::default()); it.fold(first, |a, b| if *b < a { *b } else { a }) });
        if (sub > largest_square_area[0 as usize]) {
            (*largest_square_area)[0 as usize] = sub;
        }
        return sub
    } else {
        return 0
    }
};
    let mut largest_square_area_in_matrix_top_down = |rows: i64, cols: i64, mat: Vec<Vec<i64>>| -> i64 {
    let mut largest: Vec<i64> = vec![0];
    update_area_of_max_square(0, 0, rows, cols, mat.clone(), &mut largest);
    return largest[0 as usize]
};
    fn update_area_of_max_square_with_dp(mut row: i64, mut col: i64, mut rows: i64, mut cols: i64, mut mat: Vec<Vec<i64>>, dp_array: &mut Vec<Vec<i64>>, largest_square_area: &mut Vec<i64>) -> i64 {
    if ((row >= rows) || (col >= cols)) {
        return 0
    }
    if (dp_array[row as usize].clone()[col as usize] != -1) {
        return dp_array[row as usize].clone()[col as usize]
    }
    let right: i64 = update_area_of_max_square_with_dp(row, (col + 1), rows, cols, mat.clone(), dp_array, largest_square_area);
    let diagonal: i64 = update_area_of_max_square_with_dp((row + 1), (col + 1), rows, cols, mat.clone(), dp_array, largest_square_area);
    let down: i64 = update_area_of_max_square_with_dp((row + 1), col, rows, cols, mat.clone(), dp_array, largest_square_area);
    if (mat[row as usize].clone()[col as usize] == 1) {
        let sub: i64 = (1 + { let tmp = vec![right, diagonal, down].clone(); let mut it = tmp.iter(); let first = *it.next().unwrap_or(&Default::default()); it.fold(first, |a, b| if *b < a { *b } else { a }) });
        if (sub > largest_square_area[0 as usize]) {
            (*largest_square_area)[0 as usize] = sub;
        }
        (*dp_array)[row as usize][col as usize] = sub;
        return sub
    } else {
        (*dp_array)[row as usize][col as usize] = 0;
        return 0
    }
};
    let mut largest_square_area_in_matrix_top_down_with_dp = |rows: i64, cols: i64, mat: Vec<Vec<i64>>| -> i64 {
    let mut largest: Vec<i64> = vec![0];
    let mut dp_array: Vec<Vec<i64>> = vec![];
    let mut r: i64 = 0;
    while (r < rows) {
        let mut row_list: Vec<i64> = vec![];
        let mut c: i64 = 0;
        while (c < cols) {
            row_list = { let mut _v = row_list.clone(); _v.push(-1); _v };
            c = (c + 1);
        }
        dp_array = { let mut _v = dp_array.clone(); _v.push(row_list.clone()); _v };
        r = (r + 1);
    }
    update_area_of_max_square_with_dp(0, 0, rows, cols, mat.clone(), &mut dp_array, &mut largest);
    return largest[0 as usize]
};
    fn largest_square_area_in_matrix_bottom_up(mut rows: i64, mut cols: i64, mut mat: Vec<Vec<i64>>) -> i64 {
    let mut dp_array: Vec<Vec<i64>> = vec![];
    let mut r: i64 = 0;
    while (r <= rows) {
        let mut row_list: Vec<i64> = vec![];
        let mut c: i64 = 0;
        while (c <= cols) {
            row_list = { let mut _v = row_list.clone(); _v.push(0); _v };
            c = (c + 1);
        }
        dp_array = { let mut _v = dp_array.clone(); _v.push(row_list.clone()); _v };
        r = (r + 1);
    }
    let mut largest: i64 = 0;
    let mut row: i64 = (rows - 1);
    while (row >= 0) {
        let mut col: i64 = (cols - 1);
        while (col >= 0) {
            let right: i64 = dp_array[row as usize].clone()[(col + 1) as usize];
            let diagonal: i64 = dp_array[(row + 1) as usize].clone()[(col + 1) as usize];
            let bottom: i64 = dp_array[(row + 1) as usize].clone()[col as usize];
            if (mat[row as usize].clone()[col as usize] == 1) {
                let value: i64 = (1 + { let tmp = vec![right, diagonal, bottom].clone(); let mut it = tmp.iter(); let first = *it.next().unwrap_or(&Default::default()); it.fold(first, |a, b| if *b < a { *b } else { a }) });
                dp_array[row as usize][col as usize] = value;
                if (value > largest) {
                    largest = value;
                }
            } else {
                dp_array[row as usize][col as usize] = 0;
            }
            col = (col - 1);
        }
        row = (row - 1);
    }
    return largest
};
    fn largest_square_area_in_matrix_bottom_up_space_optimization(mut rows: i64, mut cols: i64, mut mat: Vec<Vec<i64>>) -> i64 {
    let mut current_row: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i <= cols) {
        current_row = { let mut _v = current_row.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut next_row: Vec<i64> = vec![];
    let mut j: i64 = 0;
    while (j <= cols) {
        next_row = { let mut _v = next_row.clone(); _v.push(0); _v };
        j = (j + 1);
    }
    let mut largest: i64 = 0;
    let mut row: i64 = (rows - 1);
    while (row >= 0) {
        let mut col: i64 = (cols - 1);
        while (col >= 0) {
            let right: i64 = current_row[(col + 1) as usize];
            let diagonal: i64 = next_row[(col + 1) as usize];
            let bottom: i64 = next_row[col as usize];
            if (mat[row as usize].clone()[col as usize] == 1) {
                let value: i64 = (1 + { let tmp = vec![right, diagonal, bottom].clone(); let mut it = tmp.iter(); let first = *it.next().unwrap_or(&Default::default()); it.fold(first, |a, b| if *b < a { *b } else { a }) });
                current_row[col as usize] = value;
                if (value > largest) {
                    largest = value;
                }
            } else {
                current_row[col as usize] = 0;
            }
            col = (col - 1);
        }
        next_row = current_row.clone();
        current_row = vec![];
        let mut t: i64 = 0;
        while (t <= cols) {
            current_row = { let mut _v = current_row.clone(); _v.push(0); _v };
            t = (t + 1);
        }
        row = (row - 1);
    }
    return largest
};
    let sample: Vec<Vec<i64>> = vec![vec![1, 1].clone(), vec![1, 1].clone()];
    println!("{}", largest_square_area_in_matrix_top_down(2, 2, sample.clone()));
    println!("{}", largest_square_area_in_matrix_top_down_with_dp(2, 2, sample.clone()));
    println!("{}", largest_square_area_in_matrix_bottom_up(2, 2, sample.clone()));
    println!("{}", largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, sample.clone()));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
