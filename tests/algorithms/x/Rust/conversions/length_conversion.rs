// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn rstrip_s(mut s: String) -> String {
    if (((s.len() as i64) > 0) && (s.chars().nth(((s.len() as i64) - 1) as usize).unwrap().to_string().as_str() == "s")) {
        return { let tmp = &s; tmp.chars().skip(0 as usize).take((((s.len() as i64) - 1) - 0) as usize).collect::<String>() }
    }
    return s.clone()
};
    fn normalize_alias(u: &str) -> String {
    if (u == "millimeter") {
        return String::from("mm")
    }
    if (u == "centimeter") {
        return String::from("cm")
    }
    if (u == "meter") {
        return String::from("m")
    }
    if (u == "kilometer") {
        return String::from("km")
    }
    if (u == "inch") {
        return String::from("in")
    }
    if (u == "inche") {
        return String::from("in")
    }
    if (u == "feet") {
        return String::from("ft")
    }
    if (u == "foot") {
        return String::from("ft")
    }
    if (u == "yard") {
        return String::from("yd")
    }
    if (u == "mile") {
        return String::from("mi")
    }
    return u.to_string().clone()
};
    fn has_unit(u: &str) -> bool {
    return ((((((((u == "mm") || (u == "cm")) || (u == "m")) || (u == "km")) || (u == "in")) || (u == "ft")) || (u == "yd")) || (u == "mi"))
};
    fn from_factor(u: &str) -> f64 {
    if (u == "mm") {
        return 0.001
    }
    if (u == "cm") {
        return 0.01
    }
    if (u == "m") {
        return 1.0
    }
    if (u == "km") {
        return 1000.0
    }
    if (u == "in") {
        return 0.0254
    }
    if (u == "ft") {
        return 0.3048
    }
    if (u == "yd") {
        return 0.9144
    }
    if (u == "mi") {
        return 1609.34
    }
    return 0.0
};
    fn to_factor(u: &str) -> f64 {
    if (u == "mm") {
        return 1000.0
    }
    if (u == "cm") {
        return 100.0
    }
    if (u == "m") {
        return 1.0
    }
    if (u == "km") {
        return 0.001
    }
    if (u == "in") {
        return 39.3701
    }
    if (u == "ft") {
        return 3.28084
    }
    if (u == "yd") {
        return 1.09361
    }
    if (u == "mi") {
        return 0.000621371
    }
    return 0.0
};
    fn length_conversion(mut value: f64, from_type: &str, to_type: &str) -> f64 {
    let mut new_from: String = normalize_alias(&rstrip_s((from_type.to_lowercase()))).clone();
    let mut new_to: String = normalize_alias(&rstrip_s((to_type.to_lowercase()))).clone();
    if !has_unit(&new_from) {
        panic!("{}", format!("{}{}", format!("{}{}", "Invalid 'from_type' value: '", from_type), "'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"));
    }
    if !has_unit(&new_to) {
        panic!("{}", format!("{}{}", format!("{}{}", "Invalid 'to_type' value: '", to_type), "'.\nConversion abbreviations are: mm, cm, m, km, in, ft, yd, mi"));
    }
    return ((value * from_factor(&new_from)) * to_factor(&new_to))
};
    println!("{}", format!("{:?}", length_conversion(4.0, &"METER", &"FEET")));
    println!("{}", format!("{:?}", length_conversion(1.0, &"kilometer", &"inch")));
    println!("{}", format!("{:?}", length_conversion(2.0, &"feet", &"meter")));
    println!("{}", format!("{:?}", length_conversion(2.0, &"centimeter", &"millimeter")));
    println!("{}", format!("{:?}", length_conversion(4.0, &"yard", &"kilometer")));
    println!("{}", format!("{:?}", length_conversion(3.0, &"foot", &"inch")));
    println!("{}", format!("{:?}", length_conversion(3.0, &"mm", &"in")));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
