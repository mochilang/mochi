// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start: i64 = _now();
    fn absf(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
};
    fn fmod(mut a: f64, mut b: f64) -> f64 {
    return (a - (b * (((a / b) as i64) as f64)))
};
    fn roundf(mut x: f64) -> i64 {
    if (x >= 0.0) {
        return ((x + 0.5) as i64)
    }
    return ((x - 0.5) as i64)
};
    fn maxf(mut a: f64, mut b: f64, mut c: f64) -> f64 {
    let mut m: f64 = a;
    if (b > m) {
        m = b;
    }
    if (c > m) {
        m = c;
    }
    return m
};
    fn minf(mut a: f64, mut b: f64, mut c: f64) -> f64 {
    let mut m: f64 = a;
    if (b < m) {
        m = b;
    }
    if (c < m) {
        m = c;
    }
    return m
};
    fn hsv_to_rgb(mut hue: f64, mut saturation: f64, mut value: f64) -> Vec<i64> {
    if ((hue < 0.0) || (hue > 360.0)) {
        println!("{}", "hue should be between 0 and 360");
        return vec![]
    }
    if ((saturation < 0.0) || (saturation > 1.0)) {
        println!("{}", "saturation should be between 0 and 1");
        return vec![]
    }
    if ((value < 0.0) || (value > 1.0)) {
        println!("{}", "value should be between 0 and 1");
        return vec![]
    }
    let mut chroma: f64 = (value * saturation);
    let mut hue_section: f64 = (hue / 60.0);
    let mut second_largest_component: f64 = (chroma * (1.0 - absf((fmod(hue_section, 2.0) - 1.0))));
    let mut match_value: f64 = (value - chroma);
    let mut red: i64 = Default::default();
    let mut green: i64 = Default::default();
    let mut blue: i64 = Default::default();
    if ((hue_section >= 0.0) && (hue_section <= 1.0)) {
        red = roundf((255.0 * (chroma + match_value)));
        green = roundf((255.0 * (second_largest_component + match_value)));
        blue = roundf((255.0 * match_value));
    } else if ((hue_section > 1.0) && (hue_section <= 2.0)) {
        red = roundf((255.0 * (second_largest_component + match_value)));
        green = roundf((255.0 * (chroma + match_value)));
        blue = roundf((255.0 * match_value));
    } else if ((hue_section > 2.0) && (hue_section <= 3.0)) {
        red = roundf((255.0 * match_value));
        green = roundf((255.0 * (chroma + match_value)));
        blue = roundf((255.0 * (second_largest_component + match_value)));
    } else if ((hue_section > 3.0) && (hue_section <= 4.0)) {
        red = roundf((255.0 * match_value));
        green = roundf((255.0 * (second_largest_component + match_value)));
        blue = roundf((255.0 * (chroma + match_value)));
    } else if ((hue_section > 4.0) && (hue_section <= 5.0)) {
        red = roundf((255.0 * (second_largest_component + match_value)));
        green = roundf((255.0 * match_value));
        blue = roundf((255.0 * (chroma + match_value)));
    } else {
        red = roundf((255.0 * (chroma + match_value)));
        green = roundf((255.0 * match_value));
        blue = roundf((255.0 * (second_largest_component + match_value)));
    }
    return vec![red, green, blue]
};
    fn rgb_to_hsv(mut red: i64, mut green: i64, mut blue: i64) -> Vec<f64> {
    if ((red < 0) || (red > 255)) {
        println!("{}", "red should be between 0 and 255");
        return vec![]
    }
    if ((green < 0) || (green > 255)) {
        println!("{}", "green should be between 0 and 255");
        return vec![]
    }
    if ((blue < 0) || (blue > 255)) {
        println!("{}", "blue should be between 0 and 255");
        return vec![]
    }
    let mut float_red: f64 = ((red as f64) / 255.0);
    let mut float_green: f64 = ((green as f64) / 255.0);
    let mut float_blue: f64 = ((blue as f64) / 255.0);
    let mut value: f64 = maxf(float_red, float_green, float_blue);
    let mut min_val: f64 = minf(float_red, float_green, float_blue);
    let mut chroma: f64 = (value - min_val);
    let mut saturation: f64 = if (value == 0.0) { 0.0 } else { (chroma / value) };
    let mut hue: f64 = Default::default();
    if (chroma == 0.0) {
        hue = 0.0;
    } else if (value == float_red) {
        hue = (60.0 * (0.0 + ((float_green - float_blue) / chroma)));
    } else if (value == float_green) {
        hue = (60.0 * (2.0 + ((float_blue - float_red) / chroma)));
    } else {
        hue = (60.0 * (4.0 + ((float_red - float_green) / chroma)));
    }
    hue = fmod((hue + 360.0), 360.0);
    return vec![hue, saturation, value]
};
    fn approximately_equal_hsv(mut hsv1: Vec<f64>, mut hsv2: Vec<f64>) -> bool {
    let mut check_hue: bool = (absf((hsv1[0 as usize] - hsv2[0 as usize])) < 0.2);
    let mut check_saturation: bool = (absf((hsv1[1 as usize] - hsv2[1 as usize])) < 0.002);
    let mut check_value: bool = (absf((hsv1[2 as usize] - hsv2[2 as usize])) < 0.002);
    return ((check_hue && check_saturation) && check_value)
};
    let mut rgb: Vec<i64> = hsv_to_rgb(180.0, 0.5, 0.5);
    println!("{}", format!("{:?}", rgb));
    let mut hsv: Vec<f64> = rgb_to_hsv(64, 128, 128);
    println!("{}", format!("{:?}", hsv));
    println!("{}", approximately_equal_hsv(hsv.clone(), vec![180.0, 0.5, 0.5]).to_string());
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
