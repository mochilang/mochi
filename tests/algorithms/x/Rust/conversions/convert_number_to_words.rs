// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_ones: Vec<String> = Vec::new();
static mut g_teens: Vec<String> = Vec::new();
static mut g_tens: Vec<String> = Vec::new();
static mut g_short_powers: Vec<i64> = Vec::new();
static mut g_short_units: Vec<String> = Vec::new();
static mut g_long_powers: Vec<i64> = Vec::new();
static mut g_long_units: Vec<String> = Vec::new();
static mut g_indian_powers: Vec<i64> = Vec::new();
static mut g_indian_units: Vec<String> = Vec::new();
fn main() {
    unsafe {
        g_ones = vec![String::from("zero").clone(), String::from("one").clone(), String::from("two").clone(), String::from("three").clone(), String::from("four").clone(), String::from("five").clone(), String::from("six").clone(), String::from("seven").clone(), String::from("eight").clone(), String::from("nine").clone()];
        g_teens = vec![String::from("ten").clone(), String::from("eleven").clone(), String::from("twelve").clone(), String::from("thirteen").clone(), String::from("fourteen").clone(), String::from("fifteen").clone(), String::from("sixteen").clone(), String::from("seventeen").clone(), String::from("eighteen").clone(), String::from("nineteen").clone()];
        g_tens = vec![String::from("").clone(), String::from("").clone(), String::from("twenty").clone(), String::from("thirty").clone(), String::from("forty").clone(), String::from("fifty").clone(), String::from("sixty").clone(), String::from("seventy").clone(), String::from("eighty").clone(), String::from("ninety").clone()];
        g_short_powers = vec![15, 12, 9, 6, 3, 2];
        g_short_units = vec![String::from("quadrillion").clone(), String::from("trillion").clone(), String::from("billion").clone(), String::from("million").clone(), String::from("thousand").clone(), String::from("hundred").clone()];
        g_long_powers = vec![15, 9, 6, 3, 2];
        g_long_units = vec![String::from("billiard").clone(), String::from("milliard").clone(), String::from("million").clone(), String::from("thousand").clone(), String::from("hundred").clone()];
        g_indian_powers = vec![14, 12, 7, 5, 3, 2];
        g_indian_units = vec![String::from("crore crore").clone(), String::from("lakh crore").clone(), String::from("crore").clone(), String::from("lakh").clone(), String::from("thousand").clone(), String::from("hundred").clone()];
                let _start: i64 = _now();
        unsafe fn pow10(mut exp: i64) -> i64 {
    let mut res: i64 = 1;
    let mut i: i64 = 0;
    while (i < exp) {
        res = (res * 10);
        i = (i + 1);
    }
    return res
};
        unsafe fn max_value(system: &str) -> i64 {
    if (system == "short") {
        return (pow10(18) - 1)
    }
    if (system == "long") {
        return (pow10(21) - 1)
    }
    if (system == "indian") {
        return (pow10(19) - 1)
    }
    return 0
};
        unsafe fn join_words(mut words: Vec<String>) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (words.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, " ");
        }
        res = format!("{}{}", res, words[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
};
        unsafe fn convert_small_number(mut num: i64) -> String {
    if (num < 0) {
        return String::from("")
    }
    if (num >= 100) {
        return String::from("")
    }
    let mut tens_digit: i64 = (num / 10);
    let mut ones_digit: i64 = (num % 10);
    if (tens_digit == 0) {
        return g_ones.clone()[ones_digit as usize].clone()
    }
    if (tens_digit == 1) {
        return g_teens.clone()[ones_digit as usize].clone()
    }
    let mut hyphen: String = if (ones_digit > 0) { String::from("-") } else { String::from("") }.clone();
    let mut tail: String = if (ones_digit > 0) { g_ones.clone()[ones_digit as usize].clone() } else { String::from("") }.clone();
    return format!("{}{}", format!("{}{}", g_tens.clone()[tens_digit as usize].clone(), hyphen), tail).clone()
};
        unsafe fn convert_number(mut num: i64, mut system: String) -> String {
    let mut word_groups: Vec<String> = vec![];
    let mut n: i64 = num;
    if (n < 0) {
        word_groups = { let mut _v = word_groups.clone(); _v.push("negative".to_string()); _v };
        n = -n;
    }
    if (n > max_value(&system)) {
        return String::from("")
    }
    let mut powers: Vec<i64> = vec![];
    let mut units: Vec<String> = vec![];
    if (system.as_str() == "short") {
        powers = g_short_powers.clone().clone();
        units = g_short_units.clone().clone();
    } else {
        if (system.as_str() == "long") {
            powers = g_long_powers.clone().clone();
            units = g_long_units.clone().clone();
        } else {
            if (system.as_str() == "indian") {
                powers = g_indian_powers.clone().clone();
                units = g_indian_units.clone().clone();
            } else {
                return String::from("")
            }
        }
    }
    let mut i: i64 = 0;
    while (i < (powers.len() as i64)) {
        let mut power: i64 = powers[i as usize];
        let mut unit: String = units[i as usize].clone().clone();
        let mut divisor: i64 = pow10(power);
        let mut digit_group: i64 = (n / divisor);
        n = (n % divisor);
        if (digit_group > 0) {
            let mut word_group: String = if (digit_group >= 100) { convert_number(digit_group, system.clone()) } else { convert_small_number(digit_group) }.clone();
            word_groups = { let mut _v = word_groups.clone(); _v.push(format!("{}{}", format!("{}{}", word_group, " "), unit)); _v };
        }
        i = (i + 1);
    }
    if ((n > 0) || ((word_groups.len() as i64) == 0)) {
        word_groups = { let mut _v = word_groups.clone(); _v.push(convert_small_number(n)); _v };
    }
    let mut joined: String = join_words(word_groups.clone()).clone();
    return joined.clone()
};
        println!("{}", convert_number(123456789012345, String::from("short")));
        println!("{}", convert_number(123456789012345, String::from("long")));
        println!("{}", convert_number(123456789012345, String::from("indian")));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
