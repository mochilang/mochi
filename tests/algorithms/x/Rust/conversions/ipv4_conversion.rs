// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_hex_digits: String = String::new();
fn main() {
    unsafe {
        g_hex_digits = String::from("0123456789abcdef").clone();
                let _start: i64 = _now();
        unsafe fn split_by_dot(s: &str) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    let mut current: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = s.chars().nth(i as usize).unwrap().to_string().clone();
        if (c.as_str() == ".") {
            res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
            current = String::from("");
        } else {
            current = format!("{}{}", current, c);
        }
        i = (i + 1);
    }
    res = { let mut _v = res.clone(); _v.push(current.clone()); _v };
    return res
};
        unsafe fn parse_decimal(s: &str) -> i64 {
    if ((s.len() as i64) == 0) {
        panic!("Invalid IPv4 address format");
    }
    let mut value: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = s.chars().nth(i as usize).unwrap().to_string().clone();
        if ((c.as_str() < "0") || (c.as_str() > "9")) {
            panic!("Invalid IPv4 address format");
        }
        value = ((value * 10) + { let n: i64 = c.parse().unwrap(); n });
        i = (i + 1);
    }
    return value
};
        unsafe fn to_hex2(mut n: i64) -> String {
    let mut x: i64 = n;
    let mut res: String = String::from("").clone();
    while (x > 0) {
        let mut d: i64 = (x % 16);
        res = format!("{}{}", g_hex_digits.chars().nth(d as usize).unwrap().to_string(), res);
        x = (x / 16);
    }
    while ((res.len() as i64) < 2) {
        res = format!("{}{}", "0", res);
    }
    return res.clone()
};
        unsafe fn ipv4_to_decimal(ipv4_address: &str) -> i64 {
    let mut parts: Vec<String> = split_by_dot(ipv4_address);
    if ((parts.len() as i64) != 4) {
        panic!("Invalid IPv4 address format");
    }
    let mut result: i64 = 0;
    let mut i: i64 = 0;
    while (i < 4) {
        let mut oct: i64 = parse_decimal(&parts[i as usize].clone());
        if ((oct < 0) || (oct > 255)) {
            panic!("{}", format!("{}{}", "Invalid IPv4 octet ", oct.to_string()));
        }
        result = ((result * 256) + oct);
        i = (i + 1);
    }
    return result
};
        unsafe fn alt_ipv4_to_decimal(ipv4_address: &str) -> i64 {
    let mut parts: Vec<String> = split_by_dot(ipv4_address);
    if ((parts.len() as i64) != 4) {
        panic!("Invalid IPv4 address format");
    }
    let mut hex_str: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < 4) {
        let mut oct: i64 = parse_decimal(&parts[i as usize].clone());
        if ((oct < 0) || (oct > 255)) {
            panic!("{}", format!("{}{}", "Invalid IPv4 octet ", oct.to_string()));
        }
        hex_str = format!("{}{}", hex_str, to_hex2(oct));
        i = (i + 1);
    }
    let mut value: i64 = 0;
    let mut k: i64 = 0;
    while (k < (hex_str.len() as i64)) {
        let mut c: String = hex_str.chars().nth(k as usize).unwrap().to_string().clone();
        let mut digit: i64 = (0 - 1);
        let mut j: i64 = 0;
        while (j < (g_hex_digits.len() as i64)) {
            if (g_hex_digits.chars().nth(j as usize).unwrap().to_string().as_str() == c.as_str()) {
                digit = j;
            }
            j = (j + 1);
        }
        if (digit < 0) {
            panic!("Invalid hex digit");
        }
        value = ((value * 16) + digit);
        k = (k + 1);
    }
    return value
};
        unsafe fn decimal_to_ipv4(mut decimal_ipv4: i64) -> String {
    if ((decimal_ipv4 < 0) || (decimal_ipv4 > 4294967295)) {
        panic!("Invalid decimal IPv4 address");
    }
    let mut n: i64 = decimal_ipv4;
    let mut parts: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < 4) {
        let mut octet: i64 = (n % 256);
        parts = { let mut _v = parts.clone(); _v.push(octet.to_string().to_string()); _v };
        n = (n / 256);
        i = (i + 1);
    }
    let mut res: String = String::from("").clone();
    let mut j = ((parts.len() as i64) - 1);
    while (j >= 0) {
        res = format!("{}{}", res, parts[j as usize].clone());
        if (j > 0) {
            res = format!("{}{}", res, ".");
        }
        j = (j - 1);
    }
    return res.clone()
};
        println!("{}", ipv4_to_decimal(&"192.168.0.1"));
        println!("{}", ipv4_to_decimal(&"10.0.0.255"));
        println!("{}", alt_ipv4_to_decimal(&"192.168.0.1"));
        println!("{}", alt_ipv4_to_decimal(&"10.0.0.255"));
        println!("{}", decimal_to_ipv4(3232235521));
        println!("{}", decimal_to_ipv4(167772415));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
