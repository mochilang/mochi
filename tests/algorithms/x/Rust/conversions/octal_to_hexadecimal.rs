// Generated by Mochi transpiler v0.10.59
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_nums: Vec<String> = Vec::new();
static mut g_t: i64 = 0;
fn main() {
    unsafe {
        g_nums = vec![String::from("030").clone(), String::from("100").clone(), String::from("247").clone(), String::from("235").clone(), String::from("007").clone()];
        g_t = 0;
                let _start: i64 = _now();
        unsafe fn octal_to_hex(octal: &str) -> String {
    let mut s: String = octal.to_string().clone();
    if ((((s.len() as i64) >= 2) && (s.chars().nth(0 as usize).unwrap().to_string().as_str() == "0")) && (s.chars().nth(1 as usize).unwrap().to_string().as_str() == "o")) {
        s = { let tmp = &s; tmp.chars().skip(2 as usize).take(((s.len() as i64) - 2) as usize).collect::<String>() };
    }
    if ((s.len() as i64) == 0) {
        panic!("Empty string was passed to the function");
    }
    let mut j: i64 = 0;
    while (j < (s.len() as i64)) {
        let mut c: String = s.chars().nth(j as usize).unwrap().to_string().clone();
        if ((((((((c.as_str() != "0") && (c.as_str() != "1")) && (c.as_str() != "2")) && (c.as_str() != "3")) && (c.as_str() != "4")) && (c.as_str() != "5")) && (c.as_str() != "6")) && (c.as_str() != "7")) {
            panic!("Not a Valid Octal Number");
        }
        j = (j + 1);
    }
    let mut decimal: i64 = 0;
    let mut k: i64 = 0;
    while (k < (s.len() as i64)) {
        let mut d = { let n: i64 = s.chars().nth(k as usize).unwrap().to_string().parse().unwrap(); n };
        decimal = ((decimal * 8) + d);
        k = (k + 1);
    }
    let mut hex_chars: String = String::from("0123456789ABCDEF").clone();
    if (decimal == 0) {
        return String::from("0x")
    }
    let mut hex: String = String::from("").clone();
    while (decimal > 0) {
        let mut idx: i64 = (decimal % 16);
        hex = format!("{}{}", hex_chars.chars().nth(idx as usize).unwrap().to_string(), hex);
        decimal = (decimal / 16);
    }
    return format!("{}{}", "0x", hex).clone()
};
        while (g_t < (g_nums.clone().len() as i64)) {
            let mut num: String = g_nums.clone()[g_t as usize].clone().clone();
            println!("{}", octal_to_hex(&num));
            g_t = (g_t + 1);
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
