// Generated by Mochi transpiler v0.10.59
use std::collections::HashMap;
use std::sync::LazyLock;
use std::sync::Mutex;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
static g_time_chart: LazyLock<Mutex<HashMap<String, f64>>> = LazyLock::new(|| Mutex::new(HashMap::from([(String::from("seconds"), 1.0), (String::from("minutes"), 60.0), (String::from("hours"), 3600.0), (String::from("days"), 86400.0), (String::from("weeks"), 604800.0), (String::from("months"), 2629800.0), (String::from("years"), 31557600.0)])));
static mut g_units: Vec<String> = Vec::new();
static mut g_units_str: String = String::new();
fn main() {
    unsafe {
        g_units = vec![String::from("seconds").clone(), String::from("minutes").clone(), String::from("hours").clone(), String::from("days").clone(), String::from("weeks").clone(), String::from("months").clone(), String::from("years").clone()];
        g_units_str = String::from("seconds, minutes, hours, days, weeks, months, years").clone();
                let _start: i64 = _now();
        let mut time_chart_inverse: HashMap<String, f64> = HashMap::from([(String::from("seconds"), 1.0), (String::from("minutes"), (1.0 / 60.0)), (String::from("hours"), (1.0 / 3600.0)), (String::from("days"), (1.0 / 86400.0)), (String::from("weeks"), (1.0 / 604800.0)), (String::from("months"), (1.0 / 2629800.0)), (String::from("years"), (1.0 / 31557600.0))]);
        let contains = move |arr: Vec<String>, t: &str| -> bool {
    let mut i: i64 = 0;
    while (i < (arr.len() as i64)) {
        if (arr[i as usize].clone() == t) {
            return true
        }
        i = (i + 1);
    }
    return false
};
        let convert_time = move |time_value: f64, unit_from: &str, unit_to: &str| -> f64 {
    if (time_value < 0.0) {
        panic!("'time_value' must be a non-negative number.");
    }
    let mut from: String = (unit_from.to_lowercase()).clone();
    let mut to: String = (unit_to.to_lowercase()).clone();
    if (!g_units.clone().contains(&from) || !g_units.clone().contains(&to)) {
        let mut invalid_unit: String = from.clone();
        if g_units.clone().contains(&from) {
            invalid_unit = to.clone();
        }
        panic!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Invalid unit ", invalid_unit), " is not in "), g_units_str), "."));
    }
    let mut seconds: f64 = (time_value * { let _map = g_time_chart.lock().unwrap(); _map.get(from.as_str()).cloned().unwrap_or_default() });
    let mut converted: f64 = (seconds * time_chart_inverse.get(to.as_str()).cloned().unwrap_or_default());
    let mut scaled: f64 = (converted * 1000.0);
    let mut int_part: i64 = ((scaled + 0.5) as i64);
    return ((((int_part as f64) + 0.0) as f64) / 1000.0)
};
        println!("{}", format!("{:?}", convert_time(3600.0, &"seconds", &"hours")));
        println!("{}", format!("{:?}", convert_time(360.0, &"days", &"months")));
        println!("{}", format!("{:?}", convert_time(360.0, &"months", &"years")));
        println!("{}", format!("{:?}", convert_time(1.0, &"years", &"seconds")));
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
