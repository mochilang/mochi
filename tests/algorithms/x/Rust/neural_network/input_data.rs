// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct DataSet {
    images: Vec<Vec<i64>>,
    labels: Vec<Vec<i64>>,
    num_examples: i64,
    index_in_epoch: i64,
    epochs_completed: i64,
}
impl std::fmt::Display for DataSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"images\": {:?}", self.images)?;
        write!(f, ", ")?;
        write!(f, "\"labels\": {:?}", self.labels)?;
        write!(f, ", ")?;
        write!(f, "\"num_examples\": {}", self.num_examples)?;
        write!(f, ", ")?;
        write!(f, "\"index_in_epoch\": {}", self.index_in_epoch)?;
        write!(f, ", ")?;
        write!(f, "\"epochs_completed\": {}", self.epochs_completed)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Datasets {
    train: DataSet,
    validation: DataSet,
    test_ds: DataSet,
}
impl std::fmt::Display for Datasets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"train\": {}", self.train)?;
        write!(f, ", ")?;
        write!(f, "\"validation\": {}", self.validation)?;
        write!(f, ", ")?;
        write!(f, "\"test_ds\": {}", self.test_ds)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct BatchResult {
    dataset: DataSet,
    images: Vec<Vec<i64>>,
    labels: Vec<Vec<i64>>,
}
impl std::fmt::Display for BatchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"dataset\": {}", self.dataset)?;
        write!(f, ", ")?;
        write!(f, "\"images\": {:?}", self.images)?;
        write!(f, ", ")?;
        write!(f, "\"labels\": {:?}", self.labels)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn dense_to_one_hot(mut labels: Vec<i64>, mut num_classes: i64) -> Vec<Vec<i64>> {
    let mut result: Vec<Vec<i64>> = vec![];
    let mut i: i64 = 0;
    while (i < (labels.len() as i64)) {
        let mut row: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < num_classes) {
            if (j == labels[i as usize]) {
                row = { let mut _v = row.clone(); _v.push(1); _v };
            } else {
                row = { let mut _v = row.clone(); _v.push(0); _v };
            }
            j = (j + 1);
        }
        result = { let mut _v = result.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    return result
};
    fn new_dataset(mut images: Vec<Vec<i64>>, mut labels: Vec<Vec<i64>>) -> DataSet {
    return DataSet {images: images.clone(), labels: labels.clone(), num_examples: (images.len() as i64), index_in_epoch: 0, epochs_completed: 0}
};
    fn next_batch(ds: &DataSet, mut batch_size: i64) -> BatchResult {
    let start: i64 = ds.index_in_epoch;
    if ((start + batch_size) > ds.num_examples) {
        let rest: i64 = (ds.num_examples - start);
        let images_rest: Vec<Vec<i64>> = ds.images.clone()[start as usize..ds.num_examples as usize].to_vec();
        let labels_rest: Vec<Vec<i64>> = ds.labels.clone()[start as usize..ds.num_examples as usize].to_vec();
        let new_index: i64 = (batch_size - rest);
        let images_new: Vec<Vec<i64>> = ds.images.clone()[0 as usize..new_index as usize].to_vec();
        let labels_new: Vec<Vec<i64>> = ds.labels.clone()[0 as usize..new_index as usize].to_vec();
        let batch_images = vec![images_rest.clone(), images_new.clone()].concat();
        let batch_labels = vec![labels_rest.clone(), labels_new.clone()].concat();
        let new_ds: DataSet = DataSet {images: ds.images.clone(), labels: ds.labels.clone(), num_examples: ds.num_examples, index_in_epoch: new_index, epochs_completed: (ds.epochs_completed + 1)};
        return BatchResult {dataset: new_ds.clone(), images: batch_images.clone(), labels: batch_labels.clone()}
    } else {
        let end: i64 = (start + batch_size);
        let batch_images: Vec<Vec<i64>> = ds.images.clone()[start as usize..end as usize].to_vec();
        let batch_labels: Vec<Vec<i64>> = ds.labels.clone()[start as usize..end as usize].to_vec();
        let new_ds: DataSet = DataSet {images: ds.images.clone(), labels: ds.labels.clone(), num_examples: ds.num_examples, index_in_epoch: end, epochs_completed: ds.epochs_completed};
        return BatchResult {dataset: new_ds.clone(), images: batch_images.clone(), labels: batch_labels.clone()}
    }
};
    fn read_data_sets(mut train_images: Vec<Vec<i64>>, mut train_labels_raw: Vec<i64>, mut test_images: Vec<Vec<i64>>, mut test_labels_raw: Vec<i64>, mut validation_size: i64, mut num_classes: i64) -> Datasets {
    let train_labels: Vec<Vec<i64>> = dense_to_one_hot(train_labels_raw.clone(), num_classes);
    let test_labels: Vec<Vec<i64>> = dense_to_one_hot(test_labels_raw.clone(), num_classes);
    let validation_images: Vec<Vec<i64>> = train_images[0 as usize..validation_size as usize].to_vec();
    let validation_labels: Vec<Vec<i64>> = train_labels[0 as usize..validation_size as usize].to_vec();
    let train_images_rest: Vec<Vec<i64>> = train_images[validation_size as usize..(train_images.len() as i64) as usize].to_vec();
    let train_labels_rest: Vec<Vec<i64>> = train_labels[validation_size as usize..(train_labels.len() as i64) as usize].to_vec();
    let train: DataSet = new_dataset(train_images_rest.clone(), train_labels_rest.clone());
    let validation: DataSet = new_dataset(validation_images.clone(), validation_labels.clone());
    let testset: DataSet = new_dataset(test_images.clone(), test_labels.clone());
    return Datasets {train: train.clone(), validation: validation.clone(), test_ds: testset.clone()}
};
    fn mochi_main() {
    let train_images: Vec<Vec<i64>> = vec![vec![0, 1].clone(), vec![1, 2].clone(), vec![2, 3].clone(), vec![3, 4].clone(), vec![4, 5].clone()];
    let train_labels_raw: Vec<i64> = vec![0, 1, 2, 3, 4];
    let test_images: Vec<Vec<i64>> = vec![vec![5, 6].clone(), vec![6, 7].clone()];
    let test_labels_raw: Vec<i64> = vec![5, 6];
    let data: Datasets = read_data_sets(train_images.clone(), train_labels_raw.clone(), test_images.clone(), test_labels_raw.clone(), 2, 10);
    let mut ds: DataSet = data.train.clone();
    let mut res: BatchResult = next_batch(&ds, 2);
    ds = res.dataset.clone();
    println!("{}", format!("{:?}", res.images.clone()));
    println!("{}", format!("{:?}", res.labels.clone()));
    res = next_batch(&ds, 2);
    ds = res.dataset.clone();
    println!("{}", format!("{:?}", res.images.clone()));
    println!("{}", format!("{:?}", res.labels.clone()));
    res = next_batch(&ds, 2);
    ds = res.dataset.clone();
    println!("{}", format!("{:?}", res.images.clone()));
    println!("{}", format!("{:?}", res.labels.clone()));
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
