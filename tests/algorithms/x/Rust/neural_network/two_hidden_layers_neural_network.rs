// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Network {
    w1: Vec<Vec<f64>>,
    w2: Vec<Vec<f64>>,
    w3: Vec<Vec<f64>>,
}
impl std::fmt::Display for Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"w1\": {:?}", self.w1)?;
        write!(f, ", ")?;
        write!(f, "\"w2\": {:?}", self.w2)?;
        write!(f, ", ")?;
        write!(f, "\"w3\": {:?}", self.w3)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn exp_approx(mut x: f64) -> f64 {
    let mut sum: f64 = 1.0;
    let mut term: f64 = 1.0;
    let mut i: i64 = 1;
    while (i < 10) {
        term = ((term * x) / (i as f64));
        sum = (sum + term);
        i = (i + 1);
    }
    return sum
};
    fn sigmoid(mut x: f64) -> f64 {
    return (1.0 / (1.0 + exp_approx(-x)))
};
    fn sigmoid_derivative(mut x: f64) -> f64 {
    return (x * (1.0 - x))
};
    fn new_network() -> Network {
    return Network {w1: vec![vec![0.1, 0.2, 0.3, 0.4].clone(), vec![0.5, 0.6, 0.7, 0.8].clone(), vec![0.9, 1.0, 1.1, 1.2].clone()], w2: vec![vec![0.1, 0.2, 0.3].clone(), vec![0.4, 0.5, 0.6].clone(), vec![0.7, 0.8, 0.9].clone(), vec![1.0, 1.1, 1.2].clone()], w3: vec![vec![0.1].clone(), vec![0.2].clone(), vec![0.3].clone()]}
};
    fn feedforward(mut net: Network, mut input: Vec<f64>) -> f64 {
    let mut hidden1: Vec<f64> = vec![];
    let mut j: i64 = 0;
    while (j < 4) {
        let mut sum1: f64 = 0.0;
        let mut i: i64 = 0;
        while (i < 3) {
            sum1 = (sum1 + (input[i as usize] * net.w1.clone()[i as usize].clone()[j as usize]));
            i = (i + 1);
        }
        hidden1 = { let mut _v = hidden1.clone(); _v.push(sigmoid(sum1)); _v };
        j = (j + 1);
    }
    let mut hidden2: Vec<f64> = vec![];
    let mut k: i64 = 0;
    while (k < 3) {
        let mut sum2: f64 = 0.0;
        let mut j2: i64 = 0;
        while (j2 < 4) {
            sum2 = (sum2 + (hidden1[j2 as usize] * net.w2.clone()[j2 as usize].clone()[k as usize]));
            j2 = (j2 + 1);
        }
        hidden2 = { let mut _v = hidden2.clone(); _v.push(sigmoid(sum2)); _v };
        k = (k + 1);
    }
    let mut sum3: f64 = 0.0;
    let mut k2: i64 = 0;
    while (k2 < 3) {
        sum3 = (sum3 + (hidden2[k2 as usize] * net.w3.clone()[k2 as usize].clone()[0 as usize]));
        k2 = (k2 + 1);
    }
    let out: f64 = sigmoid(sum3);
    return out
};
    fn train(net: &mut Network, mut inputs: Vec<Vec<f64>>, mut outputs: Vec<f64>, mut iterations: i64) {
    let mut iter: i64 = 0;
    while (iter < iterations) {
        let mut s: i64 = 0;
        while (s < (inputs.len() as i64)) {
            let inp: Vec<f64> = inputs[s as usize].clone();
            let target: f64 = outputs[s as usize];
            let mut hidden1: Vec<f64> = vec![];
            let mut j: i64 = 0;
            while (j < 4) {
                let mut sum1: f64 = 0.0;
                let mut i: i64 = 0;
                while (i < 3) {
                    sum1 = (sum1 + (inp[i as usize] * net.w1.clone()[i as usize].clone()[j as usize]));
                    i = (i + 1);
                }
                hidden1 = { let mut _v = hidden1.clone(); _v.push(sigmoid(sum1)); _v };
                j = (j + 1);
            }
            let mut hidden2: Vec<f64> = vec![];
            let mut k: i64 = 0;
            while (k < 3) {
                let mut sum2: f64 = 0.0;
                let mut j2: i64 = 0;
                while (j2 < 4) {
                    sum2 = (sum2 + (hidden1[j2 as usize] * net.w2.clone()[j2 as usize].clone()[k as usize]));
                    j2 = (j2 + 1);
                }
                hidden2 = { let mut _v = hidden2.clone(); _v.push(sigmoid(sum2)); _v };
                k = (k + 1);
            }
            let mut sum3: f64 = 0.0;
            let mut k3: i64 = 0;
            while (k3 < 3) {
                sum3 = (sum3 + (hidden2[k3 as usize] * net.w3.clone()[k3 as usize].clone()[0 as usize]));
                k3 = (k3 + 1);
            }
            let output: f64 = sigmoid(sum3);
            let error: f64 = (target - output);
            let delta_output: f64 = (error * sigmoid_derivative(output));
            let mut new_w3: Vec<Vec<f64>> = vec![];
            let mut k4: i64 = 0;
            while (k4 < 3) {
                let mut w3row: Vec<f64> = net.w3.clone()[k4 as usize].clone();
                w3row[0 as usize] = (w3row[0 as usize] + (hidden2[k4 as usize] * delta_output));
                new_w3 = { let mut _v = new_w3.clone(); _v.push(w3row.clone()); _v };
                k4 = (k4 + 1);
            }
            (*net).w3 = new_w3.clone();
            let mut delta_hidden2: Vec<f64> = vec![];
            let mut k5: i64 = 0;
            while (k5 < 3) {
                let row: Vec<f64> = net.w3.clone()[k5 as usize].clone();
                let dh2: f64 = ((row[0 as usize] * delta_output) * sigmoid_derivative(hidden2[k5 as usize]));
                delta_hidden2 = { let mut _v = delta_hidden2.clone(); _v.push(dh2); _v };
                k5 = (k5 + 1);
            }
            let mut new_w2: Vec<Vec<f64>> = vec![];
            j = 0;
            while (j < 4) {
                let mut w2row: Vec<f64> = net.w2.clone()[j as usize].clone();
                let mut k6: i64 = 0;
                while (k6 < 3) {
                    w2row[k6 as usize] = (w2row[k6 as usize] + (hidden1[j as usize] * delta_hidden2[k6 as usize]));
                    k6 = (k6 + 1);
                }
                new_w2 = { let mut _v = new_w2.clone(); _v.push(w2row.clone()); _v };
                j = (j + 1);
            }
            (*net).w2 = new_w2.clone();
            let mut delta_hidden1: Vec<f64> = vec![];
            j = 0;
            while (j < 4) {
                let mut sumdh: f64 = 0.0;
                let mut k7: i64 = 0;
                while (k7 < 3) {
                    let row2: Vec<f64> = net.w2.clone()[j as usize].clone();
                    sumdh = (sumdh + (row2[k7 as usize] * delta_hidden2[k7 as usize]));
                    k7 = (k7 + 1);
                }
                delta_hidden1 = { let mut _v = delta_hidden1.clone(); _v.push((sumdh * sigmoid_derivative(hidden1[j as usize]))); _v };
                j = (j + 1);
            }
            let mut new_w1: Vec<Vec<f64>> = vec![];
            let mut i2: i64 = 0;
            while (i2 < 3) {
                let mut w1row: Vec<f64> = net.w1.clone()[i2 as usize].clone();
                j = 0;
                while (j < 4) {
                    w1row[j as usize] = (w1row[j as usize] + (inp[i2 as usize] * delta_hidden1[j as usize]));
                    j = (j + 1);
                }
                new_w1 = { let mut _v = new_w1.clone(); _v.push(w1row.clone()); _v };
                i2 = (i2 + 1);
            }
            (*net).w1 = new_w1.clone();
            s = (s + 1);
        }
        iter = (iter + 1);
    }
};
    fn predict(mut net: Network, mut input: Vec<f64>) -> i64 {
    let out: f64 = feedforward(net.clone(), input.clone());
    if (out > 0.6) {
        return 1
    }
    return 0
};
    fn example() -> i64 {
    let inputs: Vec<Vec<f64>> = vec![vec![0.0, 0.0, 0.0].clone(), vec![0.0, 0.0, 1.0].clone(), vec![0.0, 1.0, 0.0].clone(), vec![0.0, 1.0, 1.0].clone(), vec![1.0, 0.0, 0.0].clone(), vec![1.0, 0.0, 1.0].clone(), vec![1.0, 1.0, 0.0].clone(), vec![1.0, 1.0, 1.0].clone()];
    let outputs: Vec<f64> = vec![0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0];
    let mut net: Network = new_network();
    train(&mut net, inputs.clone(), outputs.clone(), 10);
    let result: i64 = predict(net.clone(), vec![1.0, 1.0, 1.0]);
    println!("{}", result.to_string());
    return result
};
    fn mochi_main() {
    example();
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
