// Generated by Mochi transpiler v0.10.68
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct CNN {
    conv_kernels: Vec<Vec<Vec<f64>>>,
    conv_bias: Vec<f64>,
    conv_step: i64,
    pool_size: i64,
    w_hidden: Vec<Vec<f64>>,
    w_out: Vec<Vec<f64>>,
    b_hidden: Vec<f64>,
    b_out: Vec<f64>,
    rate_weight: f64,
    rate_bias: f64,
}
impl std::fmt::Display for CNN {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"conv_kernels\": {:?}", self.conv_kernels)?;
        write!(f, ", ")?;
        write!(f, "\"conv_bias\": {:?}", self.conv_bias)?;
        write!(f, ", ")?;
        write!(f, "\"conv_step\": {}", self.conv_step)?;
        write!(f, ", ")?;
        write!(f, "\"pool_size\": {}", self.pool_size)?;
        write!(f, ", ")?;
        write!(f, "\"w_hidden\": {:?}", self.w_hidden)?;
        write!(f, ", ")?;
        write!(f, "\"w_out\": {:?}", self.w_out)?;
        write!(f, ", ")?;
        write!(f, "\"b_hidden\": {:?}", self.b_hidden)?;
        write!(f, ", ")?;
        write!(f, "\"b_out\": {:?}", self.b_out)?;
        write!(f, ", ")?;
        write!(f, "\"rate_weight\": {}", self.rate_weight)?;
        write!(f, ", ")?;
        write!(f, "\"rate_bias\": {}", self.rate_bias)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct TrainSample {
    image: Vec<Vec<f64>>,
    target: Vec<f64>,
}
impl std::fmt::Display for TrainSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"image\": {:?}", self.image)?;
        write!(f, ", ")?;
        write!(f, "\"target\": {:?}", self.target)?;
        write!(f, "}}")
    }
}

static mut g_seed: i64 = 1;
fn main() {
    unsafe {
        g_seed = 1;
                let _start: i64 = _now();
        fn random() -> f64 {
    unsafe { g_seed = (((unsafe { g_seed.clone() } * 13) + 7) % 100) };
    return ((unsafe { g_seed.clone() } as f64) / 100.0)
};
        let mut sigmoid = |mut x: f64| -> f64 {
    return (1.0 / (1.0 + exp(-x)))
};
        fn to_float(mut x: i64) -> f64 {
    return ((x as f64) * 1.0)
};
        fn exp(mut x: f64) -> f64 {
    return x.exp()
};
        fn convolve(mut data: Vec<Vec<f64>>, mut kernel: Vec<Vec<f64>>, mut step: i64, mut bias: f64) -> Vec<Vec<f64>> {
    let size_data: i64 = (data.len() as i64);
    let size_kernel: i64 = (kernel.len() as i64);
    let mut out: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i <= (size_data - size_kernel)) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j <= (size_data - size_kernel)) {
            let mut sum: f64 = 0.0;
            let mut a: i64 = 0;
            while (a < size_kernel) {
                let mut b: i64 = 0;
                while (b < size_kernel) {
                    sum = (sum + (data[(i + a) as usize].clone()[(j + b) as usize] * kernel[a as usize].clone()[b as usize]));
                    b = (b + 1);
                }
                a = (a + 1);
            }
            row = { let mut _v = row.clone(); _v.push(sigmoid((sum - bias))); _v };
            j = (j + step);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        i = (i + step);
    }
    return out
};
        fn average_pool(mut map: Vec<Vec<f64>>, mut size: i64) -> Vec<Vec<f64>> {
    let mut out: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < (map.len() as i64)) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < (map[i as usize].clone().len() as i64)) {
            let mut sum: f64 = 0.0;
            let mut a: i64 = 0;
            while (a < size) {
                let mut b: i64 = 0;
                while (b < size) {
                    sum = (sum + map[(i + a) as usize].clone()[(j + b) as usize]);
                    b = (b + 1);
                }
                a = (a + 1);
            }
            row = { let mut _v = row.clone(); _v.push((sum / ((size * size) as f64))); _v };
            j = (j + size);
        }
        out = { let mut _v = out.clone(); _v.push(row.clone()); _v };
        i = (i + size);
    }
    return out
};
        fn flatten(mut maps: Vec<Vec<Vec<f64>>>) -> Vec<f64> {
    let mut out: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (maps.len() as i64)) {
        let mut j: i64 = 0;
        while (j < (maps[i as usize].clone().len() as i64)) {
            let mut k: i64 = 0;
            while (k < (maps[i as usize].clone()[j as usize].clone().len() as i64)) {
                out = { let mut _v = out.clone(); _v.push(maps[i as usize].clone()[j as usize].clone()[k as usize]); _v };
                k = (k + 1);
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return out
};
        fn vec_mul_mat(mut v: Vec<f64>, mut m: Vec<Vec<f64>>) -> Vec<f64> {
    let mut cols: i64 = (m[0 as usize].clone().len() as i64);
    let mut res: Vec<f64> = vec![];
    let mut j: i64 = 0;
    while (j < cols) {
        let mut sum: f64 = 0.0;
        let mut i: i64 = 0;
        while (i < (v.len() as i64)) {
            sum = (sum + (v[i as usize] * m[i as usize].clone()[j as usize]));
            i = (i + 1);
        }
        res = { let mut _v = res.clone(); _v.push(sum); _v };
        j = (j + 1);
    }
    return res
};
        fn matT_vec_mul(mut m: Vec<Vec<f64>>, mut v: Vec<f64>) -> Vec<f64> {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (m.len() as i64)) {
        let mut sum: f64 = 0.0;
        let mut j: i64 = 0;
        while (j < (m[i as usize].clone().len() as i64)) {
            sum = (sum + (m[i as usize].clone()[j as usize] * v[j as usize]));
            j = (j + 1);
        }
        res = { let mut _v = res.clone(); _v.push(sum); _v };
        i = (i + 1);
    }
    return res
};
        fn vec_add(mut a: Vec<f64>, mut b: Vec<f64>) -> Vec<f64> {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push((a[i as usize] + b[i as usize])); _v };
        i = (i + 1);
    }
    return res
};
        fn vec_sub(mut a: Vec<f64>, mut b: Vec<f64>) -> Vec<f64> {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push((a[i as usize] - b[i as usize])); _v };
        i = (i + 1);
    }
    return res
};
        fn vec_mul(mut a: Vec<f64>, mut b: Vec<f64>) -> Vec<f64> {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push((a[i as usize] * b[i as usize])); _v };
        i = (i + 1);
    }
    return res
};
        fn vec_map_sig(mut v: Vec<f64>) -> Vec<f64> {
    let mut res: Vec<f64> = vec![];
    let mut i: i64 = 0;
    while (i < (v.len() as i64)) {
        res = { let mut _v = res.clone(); _v.push(sigmoid(v[i as usize])); _v };
        i = (i + 1);
    }
    return res
};
        fn new_cnn() -> CNN {
    let k1: Vec<Vec<f64>> = vec![vec![1.0, 0.0].clone(), vec![0.0, 1.0].clone()];
    let k2: Vec<Vec<f64>> = vec![vec![0.0, 1.0].clone(), vec![1.0, 0.0].clone()];
    let conv_kernels: Vec<Vec<Vec<f64>>> = vec![k1.clone(), k2.clone()];
    let conv_bias: Vec<f64> = vec![0.0, 0.0];
    let conv_step: i64 = 2;
    let pool_size: i64 = 2;
    let input_size: i64 = 2;
    let hidden_size: i64 = 2;
    let output_size: i64 = 2;
    let mut w_hidden: Vec<Vec<f64>> = vec![];
    let mut i: i64 = 0;
    while (i < input_size) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < hidden_size) {
            row = { let mut _v = row.clone(); _v.push((random() - 0.5)); _v };
            j = (j + 1);
        }
        w_hidden = { let mut _v = w_hidden.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    let mut w_out: Vec<Vec<f64>> = vec![];
    i = 0;
    while (i < hidden_size) {
        let mut row: Vec<f64> = vec![];
        let mut j: i64 = 0;
        while (j < output_size) {
            row = { let mut _v = row.clone(); _v.push((random() - 0.5)); _v };
            j = (j + 1);
        }
        w_out = { let mut _v = w_out.clone(); _v.push(row.clone()); _v };
        i = (i + 1);
    }
    let b_hidden: Vec<f64> = vec![0.0, 0.0];
    let b_out: Vec<f64> = vec![0.0, 0.0];
    return CNN {conv_kernels: conv_kernels.clone(), conv_bias: conv_bias.clone(), conv_step: conv_step, pool_size: pool_size, w_hidden: w_hidden.clone(), w_out: w_out.clone(), b_hidden: b_hidden.clone(), b_out: b_out.clone(), rate_weight: 0.2, rate_bias: 0.2}
};
        let mut forward = |mut cnn: CNN, mut data: Vec<Vec<f64>>| -> Vec<f64> {
    let mut maps: Vec<Vec<Vec<f64>>> = vec![];
    let mut i: i64 = 0;
    while (i < (cnn.conv_kernels.clone().len() as i64)) {
        let conv_map: Vec<Vec<f64>> = convolve(data.clone(), cnn.conv_kernels.clone()[i as usize].clone(), cnn.conv_step, cnn.conv_bias.clone()[i as usize]);
        let pooled: Vec<Vec<f64>> = average_pool(conv_map.clone(), cnn.pool_size);
        maps = { let mut _v = maps.clone(); _v.push(pooled.clone()); _v };
        i = (i + 1);
    }
    let flat: Vec<f64> = flatten(maps.clone());
    let hidden_net: Vec<f64> = vec_add(vec_mul_mat(flat.clone(), cnn.w_hidden.clone().clone()), cnn.b_hidden.clone().clone());
    let hidden_out: Vec<f64> = vec_map_sig(hidden_net.clone());
    let out_net: Vec<f64> = vec_add(vec_mul_mat(hidden_out.clone(), cnn.w_out.clone().clone()), cnn.b_out.clone().clone());
    let out: Vec<f64> = vec_map_sig(out_net.clone());
    return out
};
        let mut train = |mut cnn: CNN, mut samples: Vec<TrainSample>, mut epochs: i64| -> CNN {
    let mut w_out: Vec<Vec<f64>> = cnn.w_out.clone();
    let mut b_out: Vec<f64> = cnn.b_out.clone();
    let mut w_hidden: Vec<Vec<f64>> = cnn.w_hidden.clone();
    let mut b_hidden: Vec<f64> = cnn.b_hidden.clone();
    let mut e: i64 = 0;
    while (e < epochs) {
        let mut s: i64 = 0;
        while (s < (samples.len() as i64)) {
            let data: Vec<Vec<f64>> = samples[s as usize].clone().image.clone();
            let target: Vec<f64> = samples[s as usize].clone().target.clone();
            let mut maps: Vec<Vec<Vec<f64>>> = vec![];
            let mut i: i64 = 0;
            while (i < (cnn.conv_kernels.clone().len() as i64)) {
                let conv_map: Vec<Vec<f64>> = convolve(data.clone(), cnn.conv_kernels.clone()[i as usize].clone(), cnn.conv_step, cnn.conv_bias.clone()[i as usize]);
                let pooled: Vec<Vec<f64>> = average_pool(conv_map.clone(), cnn.pool_size);
                maps = { let mut _v = maps.clone(); _v.push(pooled.clone()); _v };
                i = (i + 1);
            }
            let flat: Vec<f64> = flatten(maps.clone());
            let hidden_net: Vec<f64> = vec_add(vec_mul_mat(flat.clone(), w_hidden.clone()), b_hidden.clone());
            let hidden_out: Vec<f64> = vec_map_sig(hidden_net.clone());
            let out_net: Vec<f64> = vec_add(vec_mul_mat(hidden_out.clone(), w_out.clone()), b_out.clone());
            let out: Vec<f64> = vec_map_sig(out_net.clone());
            let error_out: Vec<f64> = vec_sub(target.clone(), out.clone());
            let pd_out: Vec<f64> = vec_mul(error_out.clone(), vec_mul(out.clone(), vec_sub(vec![1.0, 1.0], out.clone())));
            let error_hidden: Vec<f64> = matT_vec_mul(w_out.clone(), pd_out.clone());
            let pd_hidden: Vec<f64> = vec_mul(error_hidden.clone(), vec_mul(hidden_out.clone(), vec_sub(vec![1.0, 1.0], hidden_out.clone())));
            let mut j: i64 = 0;
            while (j < (w_out.len() as i64)) {
                let mut k: i64 = 0;
                while (k < (w_out[j as usize].clone().len() as i64)) {
                    w_out[j as usize][k as usize] = (w_out[j as usize].clone()[k as usize] + ((cnn.rate_weight * hidden_out[j as usize]) * pd_out[k as usize]));
                    k = (k + 1);
                }
                j = (j + 1);
            }
            j = 0;
            while (j < (b_out.len() as i64)) {
                b_out[j as usize] = (b_out[j as usize] - (cnn.rate_bias * pd_out[j as usize]));
                j = (j + 1);
            }
            let mut i_h: i64 = 0;
            while (i_h < (w_hidden.len() as i64)) {
                let mut j_h: i64 = 0;
                while (j_h < (w_hidden[i_h as usize].clone().len() as i64)) {
                    w_hidden[i_h as usize][j_h as usize] = (w_hidden[i_h as usize].clone()[j_h as usize] + ((cnn.rate_weight * flat[i_h as usize]) * pd_hidden[j_h as usize]));
                    j_h = (j_h + 1);
                }
                i_h = (i_h + 1);
            }
            j = 0;
            while (j < (b_hidden.len() as i64)) {
                b_hidden[j as usize] = (b_hidden[j as usize] - (cnn.rate_bias * pd_hidden[j as usize]));
                j = (j + 1);
            }
            s = (s + 1);
        }
        e = (e + 1);
    }
    return CNN {conv_kernels: cnn.conv_kernels.clone(), conv_bias: cnn.conv_bias.clone(), conv_step: cnn.conv_step, pool_size: cnn.pool_size, w_hidden: w_hidden.clone(), w_out: w_out.clone(), b_hidden: b_hidden.clone(), b_out: b_out.clone(), rate_weight: cnn.rate_weight, rate_bias: cnn.rate_bias}
};
        let mut mochi_main = || {
    let cnn: CNN = new_cnn();
    let image: Vec<Vec<f64>> = vec![vec![1.0, 0.0, 1.0, 0.0].clone(), vec![0.0, 1.0, 0.0, 1.0].clone(), vec![1.0, 0.0, 1.0, 0.0].clone(), vec![0.0, 1.0, 0.0, 1.0].clone()];
    let sample: TrainSample = TrainSample {image: image.clone(), target: vec![1.0, 0.0]};
    println!("{}", format!("{} {}", "Before training:", format!("{:?}", forward(cnn.clone(), image.clone()))).trim_end());
    let trained: CNN = train(cnn.clone(), vec![sample.clone()], 50);
    println!("{}", format!("{} {}", "After training:", format!("{:?}", forward(trained.clone(), image.clone()))).trim_end());
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
