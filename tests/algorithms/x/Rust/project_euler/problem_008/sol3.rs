// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    let N: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "73167176531330624919225119674426574742355349194934", "96983520312774506326239578318016984801869478851843"), "85861560789112949495459501737958331952853208805511"), "12540698747158523863050715693290963295227443043557"), "66896648950445244523161731856403098711121722383113"), "62229893423380308135336276614282806444486645238749"), "30358907296290491560440772390713810515859307960866"), "70172427121883998797908792274921901699720888093776"), "65727333001053367881220235421809751254540594752243"), "52584907711670556013604839586446706324415722155397"), "53697817977846174064955149290862569321978468622482"), "83972241375657056057490261407972968652414535100474"), "82166370484403199890008895243450658541227588666881"), "16427171479924442928230863465674813919123162824586"), "17866458359124566529476545682848912883142607690042"), "24219022671055626321111109370544217506941658960408"), "07198403850962455444362981230987879927244284909188"), "84580156166097919133875499200524063689912560717606"), "05886116467109405077541002256983155200055935729725"), "71636269561882670428252483600823257530420752963450").clone();
    let mut str_eval = move |s: &str| -> i64 {
    let mut product: i64 = 1;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        product = (product * { let n: i64 = s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().parse().unwrap(); n });
        i = (i + 1);
    }
    return product
};
    let mut solution = move |n: &str| -> i64 {
    let mut largest_product: i64 = -1;
    let mut substr: String = n.chars().skip(0 as usize).take((13 - 0) as usize).collect::<String>().clone();
    let mut cur_index: i64 = 13;
    while (cur_index < ((n.len() as i64) - 13)) {
        if ({ let n: i64 = n.chars().skip(cur_index as usize).take(((cur_index + 1) - cur_index) as usize).collect::<String>().parse().unwrap(); n } >= { let n: i64 = substr.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>().parse().unwrap(); n }) {
            substr = format!("{}{}", substr.chars().skip(1 as usize).take(((substr.len() as i64) - 1) as usize).collect::<String>(), n.chars().skip(cur_index as usize).take(((cur_index + 1) - cur_index) as usize).collect::<String>());
            cur_index = (cur_index + 1);
        } else {
            let prod: i64 = str_eval(&substr);
            if (prod > largest_product) {
                largest_product = prod;
            }
            substr = n.chars().skip(cur_index as usize).take(((cur_index + 13) - cur_index) as usize).collect::<String>();
            cur_index = (cur_index + 13);
        }
    }
    return largest_product
};
    let mut mochi_main = move || {
    let res: i64 = solution(&N);
    println!("{}", format!("{}{}", "solution() = ", res.to_string()));
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
