// Generated by Mochi transpiler v0.10.64
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start: i64 = _now();
    let N: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "73167176531330624919225119674426574742355349194934", "96983520312774506326239578318016984801869478851843"), "85861560789112949495459501737958331952853208805511"), "12540698747158523863050715693290963295227443043557"), "66896648950445244523161731856403098711121722383113"), "62229893423380308135336276614282806444486645238749"), "30358907296290491560440772390713810515859307960866"), "70172427121883998797908792274921901699720888093776"), "65727333001053367881220235421809751254540594752243"), "52584907711670556013604839586446706324415722155397"), "53697817977846174064955149290862569321978468622482"), "83972241375657056057490261407972968652414535100474"), "82166370484403199890008895243450658541227588666881"), "16427171479924442928230863465674813919123162824586"), "17866458359124566529476545682848912883142607690042"), "24219022671055626321111109370544217506941658960408"), "07198403850962455444362981230987879927244284909188"), "84580156166097919133875499200524063689912560717606"), "05886116467109405077541002256983155200055935729725"), "71636269561882670428252483600823257530420752963450").clone();
    let mut solution = move |n: &str| -> i64 {
    let mut largest_product: i64 = 0;
    let mut i: i64 = 0;
    while (i <= ((n.len() as i64) - 13)) {
        let mut product: i64 = 1;
        let mut j: i64 = 0;
        while (j < 13) {
            product = (product * { let n: i64 = { let tmp = &n; tmp.chars().skip((i + j) as usize).take((((i + j) + 1) - (i + j)) as usize).collect::<String>() }.parse().unwrap(); n });
            j = (j + 1);
        }
        if (product > largest_product) {
            largest_product = product;
        }
        i = (i + 1);
    }
    return largest_product
};
    println!("{}", format!("{}{}", "solution() = ", solution(&N).to_string()));
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
