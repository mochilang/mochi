#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, find_index/3, slice_between/4, char_to_digit/1, parse_int/1, parse_product/1, get_amazon_product_data/1, main/0]).

% Generated by Mochi transpiler v0.10.61 (281b2bcbfe) on 2025-08-09 10:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.

find_index(S, Pat, Start) ->
    try
        I = Start,
        Fun_2 = fun Fun_2_loop(I, Pat, S, Start) ->
    case (I =< (erlang:length(S) - erlang:length(Pat))) of
        true ->
            try
                J = 0,
                Ok = true,
                Fun = fun Fun_loop(I, J, Ok, Pat, S, Start) ->
    case (J < erlang:length(Pat)) of
        true ->
            try
                case (string:substr(S, (I + J) + 1, 1) /= string:substr(Pat, J + 1, 1)) of
        true -> Ok_2 = false,
            throw({break, I, J, Ok_2, Pat, S, Start}),
            Ok_3 = Ok_2;
        _ -> Ok_3 = Ok
    end,
                J_2 = (J + 1),
                Fun_loop(I, J_2, Ok_3, Pat, S, Start)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {I, J, Ok, Pat, S, Start}
    end
end,
{I, J_2, Ok_3, Pat, S, Start} = Fun(I, J, Ok, Pat, S, Start),
                case (Ok_3 /= nil) of
        true -> throw({return, I});
        _ -> ok
    end,
                I_2 = (I + 1),
                Fun_2_loop(I_2, Pat, S, Start)
            catch
                {continue, C0, C1, C2, C3} -> Fun_2_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {I, Pat, S, Start}
    end
end,
{I_2, Pat, S, Start} = Fun_2(I, Pat, S, Start),
        -1
    catch {return, RetCatch} -> RetCatch end.

slice_between(S_2, Start_pat, End_pat, From) ->
    try
        A = find_index(S_2, Start_pat, From),
        case (A < 0) of
        true -> throw({return, ""});
        _ -> ok
    end,
        B = (A + erlang:length(Start_pat)),
        C = find_index(S_2, End_pat, B),
        case (C < 0) of
        true -> throw({return, ""});
        _ -> ok
    end,
        string:substr(S_2, B + 1, (C - B))
    catch {return, RetCatch} -> RetCatch end.

char_to_digit(C_2) ->
    try
        case (C_2 == "0") of
        true -> throw({return, 0});
        _ -> ok
    end,
        case (C_2 == "1") of
        true -> throw({return, 1});
        _ -> ok
    end,
        case (C_2 == "2") of
        true -> throw({return, 2});
        _ -> ok
    end,
        case (C_2 == "3") of
        true -> throw({return, 3});
        _ -> ok
    end,
        case (C_2 == "4") of
        true -> throw({return, 4});
        _ -> ok
    end,
        case (C_2 == "5") of
        true -> throw({return, 5});
        _ -> ok
    end,
        case (C_2 == "6") of
        true -> throw({return, 6});
        _ -> ok
    end,
        case (C_2 == "7") of
        true -> throw({return, 7});
        _ -> ok
    end,
        case (C_2 == "8") of
        true -> throw({return, 8});
        _ -> ok
    end,
        9
    catch {return, RetCatch} -> RetCatch end.

parse_int(Txt) ->
    try
        N = 0,
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(I_3, N, Txt) ->
    case (I_3 < erlang:length(Txt)) of
        true ->
            C_3 = string:substr(Txt, I_3 + 1, 1),
            case ((C_3 >= "0") andalso (C_3 =< "9")) of
        true -> N_2 = ((N * 10) + char_to_digit(C_3)),
            N_3 = N_2;
        _ -> N_3 = N
    end,
            I_4 = (I_3 + 1),
            Fun_3_loop(I_4, N_3, Txt);
        _ -> {I_3, N, Txt}
    end
end,
{I_4, N_3, Txt} = Fun_3(I_3, N, Txt),
        N_3
    catch {return, RetCatch} -> RetCatch end.

parse_product(Block) ->
    try
        Href = slice_between(Block, "href=\"", "\"", 0),
        Link = ("https://www.amazon.in" ++ Href),
        Title = slice_between(Block, ">", "</a>", find_index(Block, "<a", 0)),
        Price = slice_between(Block, "<span class=\"a-offscreen\">", "</span>", 0),
        Rating = slice_between(Block, "<span class=\"a-icon-alt\">", "</span>", 0),
        case (erlang:length(Rating) == 0) of
        true -> Rating_2 = "Not available",
            Rating_3 = Rating_2;
        _ -> Rating_3 = Rating
    end,
        Mrp = slice_between(Block, "<span class=\"a-price a-text-price\">", "</span>", 0),
        Disc = 0.0,
        case ((erlang:length(Mrp) > 0) andalso (erlang:length(Price) > 0)) of
        true -> P = parse_int(Price),
            M = parse_int(Mrp),
            case (M > 0) of
        true -> Disc_2 = mochi_safe_div(float(((M - P) * 100)), float(M)),
            Disc_3 = Disc_2;
        _ -> Disc_3 = Disc
    end,
            Disc_5 = Disc_3,
            M_2 = M,
            Mrp_3 = Mrp,
            P_2 = P;
        _ -> Mrp_2 = "",
            Disc_4 = 0.0,
            Disc_5 = Disc_4,
            M_2 = nil,
            Mrp_3 = Mrp_2,
            P_2 = nil
    end,
        #{"title" => Title, "link" => Link, "price" => Price, "rating" => Rating_3, "mrp" => Mrp_3, "discount" => Disc_5}
    catch {return, RetCatch} -> RetCatch end.

get_amazon_product_data(Product) ->
    try
        Html = "<div class=\"s-result-item\" data-component-type=\"s-search-result\"><h2><a href=\"/sample_product\">Sample Product</a></h2><span class=\"a-offscreen\">₹900</span><span class=\"a-icon-alt\">4.3 out of 5 stars</span><span class=\"a-price a-text-price\">₹1000</span></div><div class=\"s-result-item\" data-component-type=\"s-search-result\"><h2><a href=\"/item2\">Another Product</a></h2><span class=\"a-offscreen\">₹500</span><span class=\"a-icon-alt\">3.8 out of 5 stars</span><span class=\"a-price a-text-price\">₹800</span></div>",
        Out = [],
        Start_2 = 0,
        Fun_4 = fun Fun_4_loop(Html, Out, Product, Start_2) ->
    case true of
        true ->
            try
                Div_start = find_index(Html, "<div class=\"s-result-item\"", Start_2),
                case (Div_start < 0) of
        true -> throw({break, Html, Out, Product, Start_2});
        _ -> ok
    end,
                Div_end = find_index(Html, "</div>", Div_start),
                case (Div_end < 0) of
        true -> throw({break, Html, Out, Product, Start_2});
        _ -> ok
    end,
                Block_2 = string:substr(Html, Div_start + 1, (Div_end - Div_start)),
                Out_2 = lists:append((case Out of nil -> []; _ -> Out end), [parse_product(Block_2)]),
                Start_3 = (Div_end + erlang:length("</div>")),
                Fun_4_loop(Html, Out_2, Product, Start_3)
            catch
                {continue, C0, C1, C2, C3} -> Fun_4_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {Html, Out, Product, Start_2}
    end
end,
{Html, Out_2, Product, Start_3} = Fun_4(Html, Out, Product, Start_2),
        Out_2
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Products = get_amazon_product_data("laptop"),
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(I_5, Products) ->
    case (I_5 < erlang:length(Products)) of
        true ->
            P_3 = (case erlang:is_map(Products) of true -> maps:get(I_5, Products, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Products) + I_5 + 1, Products); _ -> mochi_nth(I_5 + 1, Products) end end),
            io:format("~ts~n", [mochi_repr(((((((((((maps:get("title", P_3, nil) ++ " | ") ++ maps:get("link", P_3, nil)) ++ " | ") ++ maps:get("price", P_3, nil)) ++ " | ") ++ maps:get("rating", P_3, nil)) ++ " | ") ++ maps:get("mrp", P_3, nil)) ++ " | ") ++ mochi_str(maps:get("discount", P_3, nil))))]),
            I_6 = (I_5 + 1),
            Fun_5_loop(I_6, Products);
        _ -> {I_5, Products}
    end
end,
{I_6, Products} = Fun_5(I_5, Products),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
