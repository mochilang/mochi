#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, index_of/2, index_of_substring/2, split/2, get_sub_domain_name/1, get_domain_name/1, is_alnum/1, contains/2, bubble_sort/1, extract_links/2, extract_emails/2, find_page/2, emails_from_url/2]).

% Generated by Mochi transpiler v0.10.61 (281b2bcbfe) on 2025-08-09 10:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

index_of(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < erlang:length(S)) of
        true ->
            case (string:substr(S, I + 1, 1) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, RetCatch} -> RetCatch end.

index_of_substring(S_2, Sub) ->
    try
        N = erlang:length(S_2),
        M = erlang:length(Sub),
        case (M == 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(I_3, M, N, S_2, Sub) ->
    case (I_3 =< (N - M)) of
        true ->
            try
                J = 0,
                Is_match = true,
                Fun_2 = fun Fun_2_loop(I_3, Is_match, J, M, N, S_2, Sub) ->
    case (J < M) of
        true ->
            try
                case (string:substr(S_2, (I_3 + J) + 1, 1) /= string:substr(Sub, J + 1, 1)) of
        true -> Is_match_2 = false,
            throw({break, I_3, Is_match_2, J, M, N, S_2, Sub}),
            Is_match_3 = Is_match_2;
        _ -> Is_match_3 = Is_match
    end,
                J_2 = (J + 1),
                Fun_2_loop(I_3, Is_match_3, J_2, M, N, S_2, Sub)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_2_loop(C0, C1, C2, C3, C4, C5, C6);
                {break, B0, B1, B2, B3, B4, B5, B6} -> {B0, B1, B2, B3, B4, B5, B6}
            end;
        _ -> {I_3, Is_match, J, M, N, S_2, Sub}
    end
end,
{I_3, Is_match_3, J_2, M, N, S_2, Sub} = Fun_2(I_3, Is_match, J, M, N, S_2, Sub),
                case (Is_match_3 /= nil) of
        true -> throw({return, I_3});
        _ -> ok
    end,
                I_4 = (I_3 + 1),
                Fun_3_loop(I_4, M, N, S_2, Sub)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_3_loop(C0, C1, C2, C3, C4);
                {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4}
            end;
        _ -> {I_3, M, N, S_2, Sub}
    end
end,
{I_4, M, N, S_2, Sub} = Fun_3(I_3, M, N, S_2, Sub),
        -1
    catch {return, RetCatch} -> RetCatch end.

split(S_3, Sep) ->
    try
        Parts = [],
        Last = 0,
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(I_5, Last, Parts, S_3, Sep) ->
    case (I_5 < erlang:length(S_3)) of
        true ->
            Ch_2 = string:substr(S_3, I_5 + 1, 1),
            case (Ch_2 == Sep) of
        true -> Parts_2 = lists:append((case Parts of nil -> []; _ -> Parts end), [string:substr(S_3, Last + 1, (I_5 - Last))]),
            Last_2 = (I_5 + 1),
            Last_3 = Last_2,
            Parts_3 = Parts_2;
        _ -> Last_3 = Last,
            Parts_3 = Parts
    end,
            case ((I_5 + 1) == erlang:length(S_3)) of
        true -> Parts_4 = lists:append((case Parts_3 of nil -> []; _ -> Parts_3 end), [string:substr(S_3, Last_3 + 1, ((I_5 + 1) - Last_3))]),
            Parts_5 = Parts_4;
        _ -> Parts_5 = Parts_3
    end,
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, Last_3, Parts_5, S_3, Sep);
        _ -> {I_5, Last, Parts, S_3, Sep}
    end
end,
{I_6, Last_3, Parts_5, S_3, Sep} = Fun_4(I_5, Last, Parts, S_3, Sep),
        Parts_5
    catch {return, RetCatch} -> RetCatch end.

get_sub_domain_name(Url) ->
    try
        Proto_pos = index_of_substring(Url, "://"),
        Start = 0,
        case (Proto_pos >= 0) of
        true -> Start_2 = (Proto_pos + 3),
            Start_3 = Start_2;
        _ -> Start_3 = Start
    end,
        I_7 = Start_3,
        Fun_5 = fun Fun_5_loop(I_7, Proto_pos, Start_3, Url) ->
    case (I_7 < erlang:length(Url)) of
        true ->
            try
                case (string:substr(Url, I_7 + 1, 1) == "/") of
        true -> throw({break, I_7, Proto_pos, Start_3, Url});
        _ -> ok
    end,
                I_8 = (I_7 + 1),
                Fun_5_loop(I_8, Proto_pos, Start_3, Url)
            catch
                {continue, C0, C1, C2, C3} -> Fun_5_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {I_7, Proto_pos, Start_3, Url}
    end
end,
{I_8, Proto_pos, Start_3, Url} = Fun_5(I_7, Proto_pos, Start_3, Url),
        string:substr(Url, Start_3 + 1, (I_8 - Start_3))
    catch {return, RetCatch} -> RetCatch end.

get_domain_name(Url_2) ->
    try
        Sub_2 = get_sub_domain_name(Url_2),
        Parts_6 = string:tokens(Sub_2, "."),
        case (erlang:length(Parts_6) >= 2) of
        true -> throw({return, ((string:substr(Parts_6, (erlang:length(Parts_6) - 2) + 1, 1) ++ ".") ++ string:substr(Parts_6, (erlang:length(Parts_6) - 1) + 1, 1))});
        _ -> ok
    end,
        Sub_2
    catch {return, RetCatch} -> RetCatch end.

is_alnum(Ch_3) ->
    try
        Chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
        (index_of("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", Ch_3) >= 0)
    catch {return, RetCatch} -> RetCatch end.

contains(Xs, X) ->
    try
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(I_9, X, Xs) ->
    case (I_9 < erlang:length(Xs)) of
        true ->
            case ((case erlang:is_map(Xs) of true -> maps:get(I_9, Xs, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Xs) + I_9 + 1, Xs); _ -> mochi_nth(I_9 + 1, Xs) end end) == X) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_10 = (I_9 + 1),
            Fun_6_loop(I_10, X, Xs);
        _ -> {I_9, X, Xs}
    end
end,
{I_10, X, Xs} = Fun_6(I_9, X, Xs),
        false
    catch {return, RetCatch} -> RetCatch end.

bubble_sort(Xs_2) ->
    try
        Arr = Xs_2,
        N_2 = erlang:length(Arr),
        I_11 = 0,
        Fun_8 = fun Fun_8_loop(Arr, I_11, N_2, Xs_2) ->
    case (I_11 < N_2) of
        true ->
            J_3 = 0,
            Fun_7 = fun Fun_7_loop(Arr, I_11, J_3, N_2, Xs_2) ->
    case ((J_3 + 1) < (N_2 - I_11)) of
        true ->
            case ((case erlang:is_map(Arr) of true -> maps:get(J_3, Arr, nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(Arr) + J_3 + 1, Arr); _ -> mochi_nth(J_3 + 1, Arr) end end) > (case erlang:is_map(Arr) of true -> maps:get((J_3 + 1), Arr, nil); _ -> case (J_3 + 1) < 0 of true -> mochi_nth(erlang:length(Arr) + (J_3 + 1) + 1, Arr); _ -> mochi_nth((J_3 + 1) + 1, Arr) end end)) of
        true -> Tmp = (case erlang:is_map(Arr) of true -> maps:get(J_3, Arr, nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(Arr) + J_3 + 1, Arr); _ -> mochi_nth(J_3 + 1, Arr) end end),
            Arr_2 = lists:sublist(Arr, J_3) ++ [(case erlang:is_map(Arr) of true -> maps:get((J_3 + 1), Arr, nil); _ -> case (J_3 + 1) < 0 of true -> mochi_nth(erlang:length(Arr) + (J_3 + 1) + 1, Arr); _ -> mochi_nth((J_3 + 1) + 1, Arr) end end)] ++ lists:nthtail(J_3 + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, (J_3 + 1)) ++ [Tmp] ++ lists:nthtail((J_3 + 1) + 1, Arr_2),
            Arr_4 = Arr_3,
            Tmp_2 = Tmp;
        _ -> Arr_4 = Arr,
            Tmp_2 = nil
    end,
            J_4 = (J_3 + 1),
            Fun_7_loop(Arr_4, I_11, J_4, N_2, Xs_2);
        _ -> {Arr, I_11, J_3, N_2, Xs_2}
    end
end,
{Arr_4, I_11, J_4, N_2, Xs_2} = Fun_7(Arr, I_11, J_3, N_2, Xs_2),
            I_12 = (I_11 + 1),
            Fun_8_loop(Arr_4, I_12, N_2, Xs_2);
        _ -> {Arr, I_11, N_2, Xs_2}
    end
end,
{Arr_4, I_12, N_2, Xs_2} = Fun_8(Arr, I_11, N_2, Xs_2),
        Arr_4
    catch {return, RetCatch} -> RetCatch end.

extract_links(Domain, Html) ->
    try
        Links = [],
        Pos = index_of_substring(Html, "href="),
        Fun_9 = fun Fun_9_loop(Domain, Html, Links, Pos) ->
    case (Pos >= 0) of
        true ->
            try
                Start_quote = index_of(string:substr(Html, (Pos + 5) + 1, (erlang:length(Html) - (Pos + 5))), "\""),
                case (Start_quote < 0) of
        true -> throw({break, Domain, Html, Links, Pos});
        _ -> ok
    end,
                Rest = (((Pos + 5) + Start_quote) + 1),
                End_quote = index_of(string:substr(Html, Rest + 1, (erlang:length(Html) - Rest)), "\""),
                case (End_quote < 0) of
        true -> throw({break, Domain, Html, Links, Pos});
        _ -> ok
    end,
                Link = string:substr(Html, Rest + 1, ((Rest + End_quote) - Rest)),
                case mochi_not(mochi_member(Link, Links)) of
        true -> Absolute = Link,
            case mochi_not(((index_of_substring(Link, "http://") == 0) orelse (index_of_substring(Link, "https://") == 0))) of
        true -> case (index_of_substring(Link, "/") == 0) of
        true -> Absolute_2 = (("https://" ++ Domain) ++ Link),
            Absolute_4 = Absolute_2;
        _ -> Absolute_3 = ((("https://" ++ Domain) ++ "/") ++ Link),
            Absolute_4 = Absolute_3
    end,
            Absolute_5 = Absolute_4;
        _ -> Absolute_5 = Absolute
    end,
            Links_2 = lists:append((case Links of nil -> []; _ -> Links end), [Absolute_5]),
            Absolute_6 = Absolute_5,
            Links_3 = Links_2;
        _ -> Absolute_6 = nil,
            Links_3 = Links
    end,
                Pos_2 = index_of_substring(string:substr(Html, (Rest + End_quote) + 1, (erlang:length(Html) - (Rest + End_quote))), "href="),
                case (Pos_2 >= 0) of
        true -> Pos_3 = ((Pos_2 + Rest) + End_quote),
            Pos_4 = Pos_3;
        _ -> Pos_4 = Pos_2
    end,
                Fun_9_loop(Domain, Html, Links_3, Pos_4)
            catch
                {continue, C0, C1, C2, C3} -> Fun_9_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {Domain, Html, Links, Pos}
    end
end,
{Domain, Html, Links_3, Pos_4} = Fun_9(Domain, Html, Links, Pos),
        Links_3
    catch {return, RetCatch} -> RetCatch end.

extract_emails(Domain_2, Text) ->
    try
        Emails = [],
        I_13 = 0,
        Fun_13 = fun Fun_13_loop(Domain_2, Emails, I_13, Text) ->
    case (I_13 < erlang:length(Text)) of
        true ->
            case (string:substr(Text, I_13 + 1, 1) == "@") of
        true -> case (string:substr(Text, (I_13 + 1) + 1, (((I_13 + 1) + erlang:length(Domain_2)) - (I_13 + 1))) == Domain_2) of
        true -> J_5 = (I_13 - 1),
            Fun_10 = fun Fun_10_loop(Domain_2, Emails, I_13, J_5, Text) ->
    case ((J_5 >= 0) andalso is_alnum(string:substr(Text, J_5 + 1, 1))) of
        true ->
            J_6 = (J_5 - 1),
            Fun_10_loop(Domain_2, Emails, I_13, J_6, Text);
        _ -> {Domain_2, Emails, I_13, J_5, Text}
    end
end,
{Domain_2, Emails, I_13, J_6, Text} = Fun_10(Domain_2, Emails, I_13, J_5, Text),
            Local = string:substr(Text, (J_6 + 1) + 1, (I_13 - (J_6 + 1))),
            case (erlang:length(Local) > 0) of
        true -> Email = ((Local ++ "@") ++ Domain_2),
            case mochi_not(mochi_member(Email, Emails)) of
        true -> Emails_2 = lists:append((case Emails of nil -> []; _ -> Emails end), [Email]),
            Emails_3 = Emails_2;
        _ -> Emails_3 = Emails
    end,
            Email_2 = Email,
            Emails_4 = Emails_3;
        _ -> Email_2 = nil,
            Emails_4 = Emails
    end,
            Email_3 = Email_2,
            Emails_5 = Emails_4,
            Fun_11 = Fun_10,
            J_7 = J_6,
            Local_2 = Local;
        _ -> Email_3 = nil,
            Emails_5 = Emails,
            Fun_11 = nil,
            J_7 = nil,
            Local_2 = nil
    end,
            Email_4 = Email_3,
            Emails_6 = Emails_5,
            Fun_12 = Fun_11,
            J_8 = J_7,
            Local_3 = Local_2;
        _ -> Email_4 = nil,
            Emails_6 = Emails,
            Fun_12 = nil,
            J_8 = nil,
            Local_3 = nil
    end,
            I_14 = (I_13 + 1),
            Fun_13_loop(Domain_2, Emails_6, I_14, Text);
        _ -> {Domain_2, Emails, I_13, Text}
    end
end,
{Domain_2, Emails_6, I_14, Text} = Fun_13(Domain_2, Emails, I_13, Text),
        Emails_6
    catch {return, RetCatch} -> RetCatch end.

find_page(Pages, Url_3) ->
    try
        I_15 = 0,
        Fun_14 = fun Fun_14_loop(I_15, Pages, Url_3) ->
    case (I_15 < erlang:length(Pages)) of
        true ->
            P = (case erlang:is_map(Pages) of true -> maps:get(I_15, Pages, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Pages) + I_15 + 1, Pages); _ -> mochi_nth(I_15 + 1, Pages) end end),
            case (maps:get("url", P, nil) == Url_3) of
        true -> throw({return, maps:get("html", P, nil)});
        _ -> ok
    end,
            I_16 = (I_15 + 1),
            Fun_14_loop(I_16, Pages, Url_3);
        _ -> {I_15, Pages, Url_3}
    end
end,
{I_16, Pages, Url_3} = Fun_14(I_15, Pages, Url_3),
        ""
    catch {return, RetCatch} -> RetCatch end.

emails_from_url(Url_4, Pages_2) ->
    try
        Domain_3 = get_domain_name(Url_4),
        Base_html = find_page(Pages_2, Url_4),
        Links_4 = extract_links(Domain_3, Base_html),
        Found = [],
        I_17 = 0,
        Fun_16 = fun Fun_16_loop(Base_html, Domain_3, Found, I_17, Links_4, Pages_2, Url_4) ->
    case (I_17 < erlang:length(Links_4)) of
        true ->
            Html_2 = find_page(Pages_2, (case erlang:is_map(Links_4) of true -> maps:get(I_17, Links_4, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Links_4) + I_17 + 1, Links_4); _ -> mochi_nth(I_17 + 1, Links_4) end end)),
            Emails_7 = extract_emails(Domain_3, Html_2),
            J_9 = 0,
            Fun_15 = fun Fun_15_loop(Base_html, Domain_3, Emails_7, Found, Html_2, I_17, J_9, Links_4, Pages_2, Url_4) ->
    case (J_9 < erlang:length(Emails_7)) of
        true ->
            case mochi_not(mochi_member((case erlang:is_map(Emails_7) of true -> maps:get(J_9, Emails_7, nil); _ -> case J_9 < 0 of true -> mochi_nth(erlang:length(Emails_7) + J_9 + 1, Emails_7); _ -> mochi_nth(J_9 + 1, Emails_7) end end), Found)) of
        true -> Found_2 = lists:append((case Found of nil -> []; _ -> Found end), [(case erlang:is_map(Emails_7) of true -> maps:get(J_9, Emails_7, nil); _ -> case J_9 < 0 of true -> mochi_nth(erlang:length(Emails_7) + J_9 + 1, Emails_7); _ -> mochi_nth(J_9 + 1, Emails_7) end end)]),
            Found_3 = Found_2;
        _ -> Found_3 = Found
    end,
            J_10 = (J_9 + 1),
            Fun_15_loop(Base_html, Domain_3, Emails_7, Found_3, Html_2, I_17, J_10, Links_4, Pages_2, Url_4);
        _ -> {Base_html, Domain_3, Emails_7, Found, Html_2, I_17, J_9, Links_4, Pages_2, Url_4}
    end
end,
{Base_html, Domain_3, Emails_7, Found_3, Html_2, I_17, J_10, Links_4, Pages_2, Url_4} = Fun_15(Base_html, Domain_3, Emails_7, Found, Html_2, I_17, J_9, Links_4, Pages_2, Url_4),
            I_18 = (I_17 + 1),
            Fun_16_loop(Base_html, Domain_3, Found_3, I_18, Links_4, Pages_2, Url_4);
        _ -> {Base_html, Domain_3, Found, I_17, Links_4, Pages_2, Url_4}
    end
end,
{Base_html, Domain_3, Found_3, I_18, Links_4, Pages_2, Url_4} = Fun_16(Base_html, Domain_3, Found, I_17, Links_4, Pages_2, Url_4),
        Sorted = bubble_sort(Found_3),
        Sorted
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('pages', [#{"url" => "https://example.com", "html" => "<html><body><a href=\"/contact\">Contact</a></body></html>"}, #{"url" => "https://example.com/contact", "html" => "<html>Contact us at info@example.com or support@example.com</html>"}]),
    erlang:put('emails', emails_from_url("https://example.com", erlang:get('pages'))),
    io:format("~ts~n", [mochi_repr((mochi_str(erlang:length(erlang:get('emails'))) ++ " emails found:"))]),
    erlang:put('k', 0),
    Fun_17 = fun Fun_17_loop() ->
    case (erlang:get('k') < erlang:length(erlang:get('emails'))) of
        true ->
            io:format("~ts~n", [mochi_repr((case erlang:is_map(erlang:get('emails')) of true -> maps:get(erlang:get('k'), erlang:get('emails'), nil); _ -> case erlang:get('k') < 0 of true -> mochi_nth(erlang:length(erlang:get('emails')) + erlang:get('k') + 1, erlang:get('emails')); _ -> mochi_nth(erlang:get('k') + 1, erlang:get('emails')) end end))]),
            erlang:put('k', (erlang:get('k') + 1)),
            Fun_17_loop();
        _ -> {}
    end
end,
{} = Fun_17(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
