#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pivot/3, findpivot/1, interpret/2, simplex/1]).

% Generated by Mochi transpiler v0.10.59 (647651650f) on 2025-08-07 10:43 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

pivot(T, Row, Col) ->
    try
        PivotRow = [],
        PivotVal = (case erlang:is_map((case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)) of true -> maps:get(Col, (case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end), nil); _ -> case Col < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)) + Col + 1, (case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)); _ -> mochi_nth(Col + 1, (case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)) end end),
        Fun = fun Fun_loop(List, Col, PivotRow, PivotVal, Row, T) ->
    case List of
        [] -> {Col, PivotRow, PivotVal, Row, T};
        [J|J_rest] ->
            PivotRow_2 = lists:append((case PivotRow of nil -> []; _ -> PivotRow end), [mochi_safe_div((case erlang:is_map((case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)) of true -> maps:get(J, (case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)) + J + 1, (case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)); _ -> mochi_nth(J + 1, (case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end)) end end), PivotVal)]),
            Fun_loop(J_rest, Col, PivotRow_2, PivotVal, Row, T);
        _ -> {Col, PivotRow, PivotVal, Row, T}
    end
end,
{Col, PivotRow_2, PivotVal, Row, T} = Fun(lists:seq(0, (erlang:length((case erlang:is_map(T) of true -> maps:get(Row, T, nil); _ -> case Row < 0 of true -> mochi_nth(erlang:length(T) + Row + 1, T); _ -> mochi_nth(Row + 1, T) end end))) - 1), Col, PivotRow, PivotVal, Row, T),
        T_2 = lists:sublist(T, Row) ++ [PivotRow_2] ++ lists:nthtail(Row + 1, T),
        Fun_2 = fun Fun_2_loop(List, Col, PivotRow_2, PivotVal, Row, T_2) ->
    case List of
        [] -> {Col, PivotRow_2, PivotVal, Row, T_2};
        [I|I_rest] ->
            case (I /= Row) of
        true -> Factor = (case erlang:is_map((case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)) of true -> maps:get(Col, (case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end), nil); _ -> case Col < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)) + Col + 1, (case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)); _ -> mochi_nth(Col + 1, (case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)) end end),
            NewRow = [],
            Fun_3 = fun Fun_3_loop(List, Col, Factor, I, NewRow, PivotRow_2, PivotVal, Row, T_2) ->
    case List of
        [] -> {Col, Factor, I, NewRow, PivotRow_2, PivotVal, Row, T_2};
        [J_2|J_2_rest] ->
            Value = ((case erlang:is_map((case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)) of true -> maps:get(J_2, (case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end), nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)) + J_2 + 1, (case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)); _ -> mochi_nth(J_2 + 1, (case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end)) end end) - mochi_safe_mul(Factor, (case erlang:is_map(PivotRow_2) of true -> maps:get(J_2, PivotRow_2, nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length(PivotRow_2) + J_2 + 1, PivotRow_2); _ -> mochi_nth(J_2 + 1, PivotRow_2) end end))),
            NewRow_2 = lists:append((case NewRow of nil -> []; _ -> NewRow end), [Value]),
            Fun_3_loop(J_2_rest, Col, Factor, I, NewRow_2, PivotRow_2, PivotVal, Row, T_2);
        _ -> {Col, Factor, I, NewRow, PivotRow_2, PivotVal, Row, T_2}
    end
end,
{Col, Factor, I, NewRow_2, PivotRow_2, PivotVal, Row, T_2} = Fun_3(lists:seq(0, (erlang:length((case erlang:is_map(T_2) of true -> maps:get(I, T_2, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(T_2) + I + 1, T_2); _ -> mochi_nth(I + 1, T_2) end end))) - 1), Col, Factor, I, NewRow, PivotRow_2, PivotVal, Row, T_2),
            T_3 = lists:sublist(T_2, I) ++ [NewRow_2] ++ lists:nthtail(I + 1, T_2),
            Factor_2 = Factor,
            Fun_4 = Fun_3,
            NewRow_3 = NewRow_2,
            T_4 = T_3;
        _ -> Factor_2 = nil,
            Fun_4 = Fun,
            NewRow_3 = nil,
            T_4 = T_2
    end,
            Fun_2_loop(I_rest, Col, PivotRow_2, PivotVal, Row, T_4);
        _ -> {Col, PivotRow_2, PivotVal, Row, T_2}
    end
end,
{Col, PivotRow_2, PivotVal, Row, T_4} = Fun_2(lists:seq(0, (erlang:length(T_2)) - 1), Col, PivotRow_2, PivotVal, Row, T_2),
        T_4
    catch {return, Ret} -> Ret end.

findpivot(T_5) ->
    try
        Col_2 = 0,
        MinVal = 0,
        Fun_5 = fun Fun_5_loop(List, Col_2, MinVal, T_5) ->
    case List of
        [] -> {Col_2, MinVal, T_5};
        [J_3|J_3_rest] ->
            V = (case erlang:is_map((case erlang:is_map(T_5) of true -> maps:get(0, T_5, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_5) + 0 + 1, T_5); _ -> mochi_nth(0 + 1, T_5) end end)) of true -> maps:get(J_3, (case erlang:is_map(T_5) of true -> maps:get(0, T_5, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_5) + 0 + 1, T_5); _ -> mochi_nth(0 + 1, T_5) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_5) of true -> maps:get(0, T_5, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_5) + 0 + 1, T_5); _ -> mochi_nth(0 + 1, T_5) end end)) + J_3 + 1, (case erlang:is_map(T_5) of true -> maps:get(0, T_5, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_5) + 0 + 1, T_5); _ -> mochi_nth(0 + 1, T_5) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(T_5) of true -> maps:get(0, T_5, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_5) + 0 + 1, T_5); _ -> mochi_nth(0 + 1, T_5) end end)) end end),
            case (V < MinVal) of
        true -> MinVal_2 = V,
            Col_3 = J_3,
            Col_4 = Col_3,
            MinVal_3 = MinVal_2;
        _ -> Col_4 = Col_2,
            MinVal_3 = MinVal
    end,
            Fun_5_loop(J_3_rest, Col_4, MinVal_3, T_5);
        _ -> {Col_2, MinVal, T_5}
    end
end,
{Col_4, MinVal_3, T_5} = Fun_5(lists:seq(0, ((erlang:length((case erlang:is_map(T_5) of true -> maps:get(0, T_5, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_5) + 0 + 1, T_5); _ -> mochi_nth(0 + 1, T_5) end end)) - 1)) - 1), Col_2, MinVal, T_5),
        case (MinVal_3 >= 0) of
        true -> throw({return, [-1, -1]});
        _ -> ok
    end,
        Row_2 = -1,
        MinRatio = 0,
        First = true,
        Fun_6 = fun Fun_6_loop(List, Col_4, First, MinRatio, MinVal_3, Row_2, T_5) ->
    case List of
        [] -> {Col_4, First, MinRatio, MinVal_3, Row_2, T_5};
        [I_2|I_2_rest] ->
            Coeff = (case erlang:is_map((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) of true -> maps:get(Col_4, (case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end), nil); _ -> case Col_4 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) + Col_4 + 1, (case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)); _ -> mochi_nth(Col_4 + 1, (case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) end end),
            case (Coeff > 0) of
        true -> Rhs = (case erlang:is_map((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) of true -> maps:get((erlang:length((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) - 1), (case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end), nil); _ -> case (erlang:length((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) + (erlang:length((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) - 1) + 1, (case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)); _ -> mochi_nth((erlang:length((case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) - 1) + 1, (case erlang:is_map(T_5) of true -> maps:get(I_2, T_5, nil); _ -> case I_2 < 0 of true -> mochi_nth(erlang:length(T_5) + I_2 + 1, T_5); _ -> mochi_nth(I_2 + 1, T_5) end end)) end end),
            Ratio = mochi_safe_div(Rhs, Coeff),
            case (First orelse (Ratio < MinRatio)) of
        true -> MinRatio_2 = Ratio,
            Row_3 = I_2,
            First_2 = false,
            First_3 = First_2,
            MinRatio_3 = MinRatio_2,
            Row_4 = Row_3;
        _ -> First_3 = First,
            MinRatio_3 = MinRatio,
            Row_4 = Row_2
    end,
            First_4 = First_3,
            MinRatio_4 = MinRatio_3,
            Ratio_2 = Ratio,
            Rhs_2 = Rhs,
            Row_5 = Row_4;
        _ -> First_4 = First,
            MinRatio_4 = MinRatio,
            Ratio_2 = nil,
            Rhs_2 = nil,
            Row_5 = Row_2
    end,
            Fun_6_loop(I_2_rest, Col_4, First_4, MinRatio_4, MinVal_3, Row_5, T_5);
        _ -> {Col_4, First, MinRatio, MinVal_3, Row_2, T_5}
    end
end,
{Col_4, First_4, MinRatio_4, MinVal_3, Row_5, T_5} = Fun_6(lists:seq(1, (erlang:length(T_5)) - 1), Col_4, First, MinRatio, MinVal_3, Row_2, T_5),
        [Row_5, Col_4]
    catch {return, Ret} -> Ret end.

interpret(T_6, NVars) ->
    try
        LastCol = (erlang:length((case erlang:is_map(T_6) of true -> maps:get(0, T_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_6) + 0 + 1, T_6); _ -> mochi_nth(0 + 1, T_6) end end)) - 1),
        P = (case erlang:is_map((case erlang:is_map(T_6) of true -> maps:get(0, T_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_6) + 0 + 1, T_6); _ -> mochi_nth(0 + 1, T_6) end end)) of true -> maps:get(LastCol, (case erlang:is_map(T_6) of true -> maps:get(0, T_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_6) + 0 + 1, T_6); _ -> mochi_nth(0 + 1, T_6) end end), nil); _ -> case LastCol < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_6) of true -> maps:get(0, T_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_6) + 0 + 1, T_6); _ -> mochi_nth(0 + 1, T_6) end end)) + LastCol + 1, (case erlang:is_map(T_6) of true -> maps:get(0, T_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_6) + 0 + 1, T_6); _ -> mochi_nth(0 + 1, T_6) end end)); _ -> mochi_nth(LastCol + 1, (case erlang:is_map(T_6) of true -> maps:get(0, T_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_6) + 0 + 1, T_6); _ -> mochi_nth(0 + 1, T_6) end end)) end end),
        case (P < 0) of
        true -> P_2 = -P,
            P_3 = P_2;
        _ -> P_3 = P
    end,
        Result = #{},
        Result_2 = maps:put("P", P_3, Result),
        Fun_7 = fun Fun_7_loop(List, LastCol, NVars, P_3, Result_2, T_6) ->
    case List of
        [] -> {LastCol, NVars, P_3, Result_2, T_6};
        [I_3|I_3_rest] ->
            NzRow = -1,
            NzCount = 0,
            Fun_8 = fun Fun_8_loop(List, I_3, LastCol, NVars, NzCount, NzRow, P_3, Result_2, T_6) ->
    case List of
        [] -> {I_3, LastCol, NVars, NzCount, NzRow, P_3, Result_2, T_6};
        [R|R_rest] ->
            Val = (case erlang:is_map((case erlang:is_map(T_6) of true -> maps:get(R, T_6, nil); _ -> case R < 0 of true -> mochi_nth(erlang:length(T_6) + R + 1, T_6); _ -> mochi_nth(R + 1, T_6) end end)) of true -> maps:get(I_3, (case erlang:is_map(T_6) of true -> maps:get(R, T_6, nil); _ -> case R < 0 of true -> mochi_nth(erlang:length(T_6) + R + 1, T_6); _ -> mochi_nth(R + 1, T_6) end end), nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_6) of true -> maps:get(R, T_6, nil); _ -> case R < 0 of true -> mochi_nth(erlang:length(T_6) + R + 1, T_6); _ -> mochi_nth(R + 1, T_6) end end)) + I_3 + 1, (case erlang:is_map(T_6) of true -> maps:get(R, T_6, nil); _ -> case R < 0 of true -> mochi_nth(erlang:length(T_6) + R + 1, T_6); _ -> mochi_nth(R + 1, T_6) end end)); _ -> mochi_nth(I_3 + 1, (case erlang:is_map(T_6) of true -> maps:get(R, T_6, nil); _ -> case R < 0 of true -> mochi_nth(erlang:length(T_6) + R + 1, T_6); _ -> mochi_nth(R + 1, T_6) end end)) end end),
            case (Val /= 0) of
        true -> NzCount_2 = (NzCount + 1),
            NzRow_2 = R,
            NzCount_3 = NzCount_2,
            NzRow_3 = NzRow_2;
        _ -> NzCount_3 = NzCount,
            NzRow_3 = NzRow
    end,
            Fun_8_loop(R_rest, I_3, LastCol, NVars, NzCount_3, NzRow_3, P_3, Result_2, T_6);
        _ -> {I_3, LastCol, NVars, NzCount, NzRow, P_3, Result_2, T_6}
    end
end,
{I_3, LastCol, NVars, NzCount_3, NzRow_3, P_3, Result_2, T_6} = Fun_8(lists:seq(0, (erlang:length(T_6)) - 1), I_3, LastCol, NVars, NzCount, NzRow, P_3, Result_2, T_6),
            case ((NzCount_3 == 1) andalso ((case erlang:is_map((case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)) of true -> maps:get(I_3, (case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end), nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)) + I_3 + 1, (case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)); _ -> mochi_nth(I_3 + 1, (case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)) end end) == 1)) of
        true -> Result_3 = maps:put(("x" ++ mochi_str((I_3 + 1))), (case erlang:is_map((case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)) of true -> maps:get(LastCol, (case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end), nil); _ -> case LastCol < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)) + LastCol + 1, (case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)); _ -> mochi_nth(LastCol + 1, (case erlang:is_map(T_6) of true -> maps:get(NzRow_3, T_6, nil); _ -> case NzRow_3 < 0 of true -> mochi_nth(erlang:length(T_6) + NzRow_3 + 1, T_6); _ -> mochi_nth(NzRow_3 + 1, T_6) end end)) end end), Result_2),
            Result_4 = Result_3;
        _ -> Result_4 = Result_2
    end,
            Fun_7_loop(I_3_rest, LastCol, NVars, P_3, Result_4, T_6);
        _ -> {LastCol, NVars, P_3, Result_2, T_6}
    end
end,
{LastCol, NVars, P_3, Result_4, T_6} = Fun_7(lists:seq(0, (NVars) - 1), LastCol, NVars, P_3, Result_2, T_6),
        Result_4
    catch {return, Ret} -> Ret end.

simplex(Tab) ->
    try
        T_7 = Tab,
        Fun_9 = fun Fun_9_loop(T_7, Tab) ->
    case true of
        true ->
            try
                P_4 = findpivot(T_7),
                Row_6 = (case erlang:is_map(P_4) of true -> maps:get(0, P_4, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(P_4) + 0 + 1, P_4); _ -> mochi_nth(0 + 1, P_4) end end),
                Col_5 = (case erlang:is_map(P_4) of true -> maps:get(1, P_4, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(P_4) + 1 + 1, P_4); _ -> mochi_nth(1 + 1, P_4) end end),
                case (Row_6 < 0) of
        true -> throw({break, T_7, Tab});
        _ -> ok
    end,
                T_8 = pivot(T_7, Row_6, Col_5),
                Fun_9_loop(T_8, Tab)
            catch
                {continue, C0, C1} -> Fun_9_loop(C0, C1);
                {break, B0, B1} -> {B0, B1}
            end;
        _ -> {T_7, Tab}
    end
end,
{T_8, Tab} = Fun_9(T_7, Tab),
        T_8
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('tableau', [[-1, -1, 0, 0, 0], [1, 3, 1, 0, 4], [3, 1, 0, 1, 4]]),
    erlang:put('finalTab', simplex(erlang:get('tableau'))),
    erlang:put('res', interpret(erlang:get('finalTab'), 2)),
    io:format("~ts~n", [mochi_repr(("P: " ++ mochi_str(maps:get("P", erlang:get('res'), nil))))]),
    Fun_10 = fun Fun_10_loop(List) ->
    case List of
        [] -> {};
        [I_4|I_4_rest] ->
            Key = ("x" ++ mochi_str((I_4 + 1))),
            case maps:is_key(Key, erlang:get('res')) of
        true -> io:format("~ts~n", [mochi_repr(((Key ++ ": ") ++ mochi_str(maps:get(Key, erlang:get('res'), nil))))]);
        _ -> ok
    end,
            Fun_10_loop(I_4_rest);
        _ -> {}
    end
end,
{} = Fun_10(lists:seq(0, (2) - 1)),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
