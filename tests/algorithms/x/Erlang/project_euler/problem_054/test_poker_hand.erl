#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, split/2, card_value/1, parse_hand/1, compare/2, main/0]).

% Generated by Mochi transpiler v0.10.61 (336645299d) on 2025-08-08 18:06 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

split(S, Sep) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Parts, S, Sep) ->
    case (I < erlang:length(S)) of
        true ->
            case (((erlang:length(Sep) > 0) andalso ((I + erlang:length(Sep)) =< erlang:length(S))) andalso (string:substr(S, I + 1, ((I + erlang:length(Sep)) - I)) == Sep)) of
        true -> Parts_2 = lists:append((case Parts of nil -> []; _ -> Parts end), [Cur]),
            Cur_2 = "",
            I_2 = (I + erlang:length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Parts_3 = Parts
    end,
            Fun_loop(Cur_4, I_4, Parts_3, S, Sep);
        _ -> {Cur, I, Parts, S, Sep}
    end
end,
{Cur_4, I_4, Parts_3, S, Sep} = Fun(Cur, I, Parts, S, Sep),
        Parts_4 = lists:append((case Parts_3 of nil -> []; _ -> Parts_3 end), [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

card_value(Ch) ->
    try
        case (Ch == "A") of
        true -> throw({return, 14});
        _ -> case (Ch == "K") of
        true -> throw({return, 13});
        _ -> case (Ch == "Q") of
        true -> throw({return, 12});
        _ -> case (Ch == "J") of
        true -> throw({return, 11});
        _ -> case (Ch == "T") of
        true -> throw({return, 10});
        _ -> case (Ch == "9") of
        true -> throw({return, 9});
        _ -> case (Ch == "8") of
        true -> throw({return, 8});
        _ -> case (Ch == "7") of
        true -> throw({return, 7});
        _ -> case (Ch == "6") of
        true -> throw({return, 6});
        _ -> case (Ch == "5") of
        true -> throw({return, 5});
        _ -> case (Ch == "4") of
        true -> throw({return, 4});
        _ -> case (Ch == "3") of
        true -> throw({return, 3});
        _ -> throw({return, 2})
    end
    end
    end
    end
    end
    end
    end
    end
    end
    end
    end
    end,
        nil
    catch {return, Ret} -> Ret end.

parse_hand(Hand) ->
    try
        Counts = [],
        I_5 = 0,
        Fun_2 = fun Fun_2_loop(Counts, Hand, I_5) ->
    case (I_5 =< 14) of
        true ->
            Counts_2 = lists:append((case Counts of nil -> []; _ -> Counts end), [0]),
            I_6 = (I_5 + 1),
            Fun_2_loop(Counts_2, Hand, I_6);
        _ -> {Counts, Hand, I_5}
    end
end,
{Counts_2, Hand, I_6} = Fun_2(Counts, Hand, I_5),
        Suits = [],
        Fun_3 = fun Fun_3_loop(List, Counts_2, Hand, I_6, Suits) ->
    case List of
        [] -> {Counts_2, Hand, I_6, Suits};
        [Card|Card_rest] ->
            V = card_value(lists:sublist(Card, 0 + 1, (1 - 0))),
            Counts_3 = lists:sublist(Counts_2, V) ++ [((case erlang:is_map(Counts_2) of true -> maps:get(V, Counts_2, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(Counts_2) + V + 1, Counts_2); _ -> mochi_nth(V + 1, Counts_2) end end) + 1)] ++ lists:nthtail(V + 1, Counts_2),
            Suits_2 = lists:append((case Suits of nil -> []; _ -> Suits end), [lists:sublist(Card, 1 + 1, (2 - 1))]),
            Fun_3_loop(Card_rest, Counts_3, Hand, I_6, Suits_2);
        _ -> {Counts_2, Hand, I_6, Suits}
    end
end,
{Counts_3, Hand, I_6, Suits_2} = Fun_3(string:tokens(Hand, " "), Counts_2, Hand, I_6, Suits),
        Vals = [],
        V_2 = 14,
        Fun_5 = fun Fun_5_loop(Counts_3, Hand, I_6, Suits_2, V_2, Vals) ->
    case (V_2 >= 2) of
        true ->
            C = (case erlang:is_map(Counts_3) of true -> maps:get(V_2, Counts_3, nil); _ -> case V_2 < 0 of true -> mochi_nth(erlang:length(Counts_3) + V_2 + 1, Counts_3); _ -> mochi_nth(V_2 + 1, Counts_3) end end),
            K = 0,
            Fun_4 = fun Fun_4_loop(C, Counts_3, Hand, I_6, K, Suits_2, V_2, Vals) ->
    case (K < C) of
        true ->
            Vals_2 = lists:append((case Vals of nil -> []; _ -> Vals end), [V_2]),
            K_2 = (K + 1),
            Fun_4_loop(C, Counts_3, Hand, I_6, K_2, Suits_2, V_2, Vals_2);
        _ -> {C, Counts_3, Hand, I_6, K, Suits_2, V_2, Vals}
    end
end,
{C, Counts_3, Hand, I_6, K_2, Suits_2, V_2, Vals_2} = Fun_4(C, Counts_3, Hand, I_6, K, Suits_2, V_2, Vals),
            V_3 = (V_2 - 1),
            Fun_5_loop(Counts_3, Hand, I_6, Suits_2, V_3, Vals_2);
        _ -> {Counts_3, Hand, I_6, Suits_2, V_2, Vals}
    end
end,
{Counts_3, Hand, I_6, Suits_2, V_3, Vals_2} = Fun_5(Counts_3, Hand, I_6, Suits_2, V_2, Vals),
        Is_straight = false,
        case ((((((erlang:length(Vals_2) == 5) andalso ((case erlang:is_map(Vals_2) of true -> maps:get(0, Vals_2, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Vals_2) + 0 + 1, Vals_2); _ -> mochi_nth(0 + 1, Vals_2) end end) == 14)) andalso ((case erlang:is_map(Vals_2) of true -> maps:get(1, Vals_2, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(Vals_2) + 1 + 1, Vals_2); _ -> mochi_nth(1 + 1, Vals_2) end end) == 5)) andalso ((case erlang:is_map(Vals_2) of true -> maps:get(2, Vals_2, nil); _ -> case 2 < 0 of true -> mochi_nth(erlang:length(Vals_2) + 2 + 1, Vals_2); _ -> mochi_nth(2 + 1, Vals_2) end end) == 4)) andalso ((case erlang:is_map(Vals_2) of true -> maps:get(3, Vals_2, nil); _ -> case 3 < 0 of true -> mochi_nth(erlang:length(Vals_2) + 3 + 1, Vals_2); _ -> mochi_nth(3 + 1, Vals_2) end end) == 3)) andalso ((case erlang:is_map(Vals_2) of true -> maps:get(4, Vals_2, nil); _ -> case 4 < 0 of true -> mochi_nth(erlang:length(Vals_2) + 4 + 1, Vals_2); _ -> mochi_nth(4 + 1, Vals_2) end end) == 2)) of
        true -> Is_straight_2 = true,
            Vals_3 = lists:sublist(Vals_2, 0) ++ [5] ++ lists:nthtail(0 + 1, Vals_2),
            Vals_4 = lists:sublist(Vals_3, 1) ++ [4] ++ lists:nthtail(1 + 1, Vals_3),
            Vals_5 = lists:sublist(Vals_4, 2) ++ [3] ++ lists:nthtail(2 + 1, Vals_4),
            Vals_6 = lists:sublist(Vals_5, 3) ++ [2] ++ lists:nthtail(3 + 1, Vals_5),
            Vals_7 = lists:sublist(Vals_6, 4) ++ [14] ++ lists:nthtail(4 + 1, Vals_6),
            Fun_7 = Fun_5,
            Is_straight_6 = Is_straight_2,
            J_3 = nil,
            Vals_8 = Vals_7;
        _ -> Is_straight_3 = true,
            J = 0,
            Fun_6 = fun Fun_6_loop(Counts_3, Hand, I_6, Is_straight_3, J, Suits_2, V_3, Vals_2) ->
    case (J < 4) of
        true ->
            case (((case erlang:is_map(Vals_2) of true -> maps:get(J, Vals_2, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Vals_2) + J + 1, Vals_2); _ -> mochi_nth(J + 1, Vals_2) end end) - (case erlang:is_map(Vals_2) of true -> maps:get((J + 1), Vals_2, nil); _ -> case (J + 1) < 0 of true -> mochi_nth(erlang:length(Vals_2) + (J + 1) + 1, Vals_2); _ -> mochi_nth((J + 1) + 1, Vals_2) end end)) /= 1) of
        true -> Is_straight_4 = false,
            Is_straight_5 = Is_straight_4;
        _ -> Is_straight_5 = Is_straight_3
    end,
            J_2 = (J + 1),
            Fun_6_loop(Counts_3, Hand, I_6, Is_straight_5, J_2, Suits_2, V_3, Vals_2);
        _ -> {Counts_3, Hand, I_6, Is_straight_3, J, Suits_2, V_3, Vals_2}
    end
end,
{Counts_3, Hand, I_6, Is_straight_5, J_2, Suits_2, V_3, Vals_2} = Fun_6(Counts_3, Hand, I_6, Is_straight_3, J, Suits_2, V_3, Vals_2),
            Fun_7 = Fun_6,
            Is_straight_6 = Is_straight_5,
            J_3 = J_2,
            Vals_8 = Vals_2
    end,
        Is_flush = true,
        S0 = (case erlang:is_map(Suits_2) of true -> maps:get(0, Suits_2, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Suits_2) + 0 + 1, Suits_2); _ -> mochi_nth(0 + 1, Suits_2) end end),
        T = 1,
        Fun_8 = fun Fun_8_loop(Counts_3, Hand, I_6, Is_flush, Is_straight_6, J_3, S0, Suits_2, T, V_3, Vals_8) ->
    case (T < erlang:length(Suits_2)) of
        true ->
            case ((case erlang:is_map(Suits_2) of true -> maps:get(T, Suits_2, nil); _ -> case T < 0 of true -> mochi_nth(erlang:length(Suits_2) + T + 1, Suits_2); _ -> mochi_nth(T + 1, Suits_2) end end) /= S0) of
        true -> Is_flush_2 = false,
            Is_flush_3 = Is_flush_2;
        _ -> Is_flush_3 = Is_flush
    end,
            T_2 = (T + 1),
            Fun_8_loop(Counts_3, Hand, I_6, Is_flush_3, Is_straight_6, J_3, S0, Suits_2, T_2, V_3, Vals_8);
        _ -> {Counts_3, Hand, I_6, Is_flush, Is_straight_6, J_3, S0, Suits_2, T, V_3, Vals_8}
    end
end,
{Counts_3, Hand, I_6, Is_flush_3, Is_straight_6, J_3, S0, Suits_2, T_2, V_3, Vals_8} = Fun_8(Counts_3, Hand, I_6, Is_flush, Is_straight_6, J_3, S0, Suits_2, T, V_3, Vals_8),
        Four_val = 0,
        Three_val = 0,
        Pair_vals = [],
        V_4 = 14,
        Fun_9 = fun Fun_9_loop(Counts_3, Four_val, Hand, I_6, Is_flush_3, Is_straight_6, J_3, Pair_vals, S0, Suits_2, T_2, Three_val, V_4, Vals_8) ->
    case (V_4 >= 2) of
        true ->
            case ((case erlang:is_map(Counts_3) of true -> maps:get(V_4, Counts_3, nil); _ -> case V_4 < 0 of true -> mochi_nth(erlang:length(Counts_3) + V_4 + 1, Counts_3); _ -> mochi_nth(V_4 + 1, Counts_3) end end) == 4) of
        true -> Four_val_2 = V_4,
            Four_val_3 = Four_val_2,
            Pair_vals_5 = Pair_vals,
            Three_val_4 = Three_val;
        _ -> case ((case erlang:is_map(Counts_3) of true -> maps:get(V_4, Counts_3, nil); _ -> case V_4 < 0 of true -> mochi_nth(erlang:length(Counts_3) + V_4 + 1, Counts_3); _ -> mochi_nth(V_4 + 1, Counts_3) end end) == 3) of
        true -> Three_val_2 = V_4,
            Pair_vals_4 = Pair_vals,
            Three_val_3 = Three_val_2;
        _ -> case ((case erlang:is_map(Counts_3) of true -> maps:get(V_4, Counts_3, nil); _ -> case V_4 < 0 of true -> mochi_nth(erlang:length(Counts_3) + V_4 + 1, Counts_3); _ -> mochi_nth(V_4 + 1, Counts_3) end end) == 2) of
        true -> Pair_vals_2 = lists:append((case Pair_vals of nil -> []; _ -> Pair_vals end), [V_4]),
            Pair_vals_3 = Pair_vals_2;
        _ -> Pair_vals_3 = Pair_vals
    end,
            Pair_vals_4 = Pair_vals_3,
            Three_val_3 = Three_val
    end,
            Four_val_3 = Four_val,
            Pair_vals_5 = Pair_vals_4,
            Three_val_4 = Three_val_3
    end,
            V_5 = (V_4 - 1),
            Fun_9_loop(Counts_3, Four_val_3, Hand, I_6, Is_flush_3, Is_straight_6, J_3, Pair_vals_5, S0, Suits_2, T_2, Three_val_4, V_5, Vals_8);
        _ -> {Counts_3, Four_val, Hand, I_6, Is_flush_3, Is_straight_6, J_3, Pair_vals, S0, Suits_2, T_2, Three_val, V_4, Vals_8}
    end
end,
{Counts_3, Four_val_3, Hand, I_6, Is_flush_3, Is_straight_6, J_3, Pair_vals_5, S0, Suits_2, T_2, Three_val_4, V_5, Vals_8} = Fun_9(Counts_3, Four_val, Hand, I_6, Is_flush_3, Is_straight_6, J_3, Pair_vals, S0, Suits_2, T_2, Three_val, V_4, Vals_8),
        Rank = 1,
        case (((Is_flush_3 andalso Is_straight_6) andalso ((case erlang:is_map(Vals_8) of true -> maps:get(0, Vals_8, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Vals_8) + 0 + 1, Vals_8); _ -> mochi_nth(0 + 1, Vals_8) end end) == 14)) andalso ((case erlang:is_map(Vals_8) of true -> maps:get(4, Vals_8, nil); _ -> case 4 < 0 of true -> mochi_nth(erlang:length(Vals_8) + 4 + 1, Vals_8); _ -> mochi_nth(4 + 1, Vals_8) end end) == 10)) of
        true -> Rank_2 = 10,
            Rank_20 = Rank_2;
        _ -> case (Is_flush_3 andalso Is_straight_6) of
        true -> Rank_3 = 9,
            Rank_19 = Rank_3;
        _ -> case (Four_val_3 /= 0) of
        true -> Rank_4 = 8,
            Rank_18 = Rank_4;
        _ -> case ((Three_val_4 /= 0) andalso (erlang:length(Pair_vals_5) == 1)) of
        true -> Rank_5 = 7,
            Rank_17 = Rank_5;
        _ -> case (Is_flush_3 /= nil) of
        true -> Rank_6 = 6,
            Rank_16 = Rank_6;
        _ -> case Is_straight_6 of
        true -> Rank_7 = 5,
            Rank_15 = Rank_7;
        _ -> case (Three_val_4 /= 0) of
        true -> Rank_8 = 4,
            Rank_14 = Rank_8;
        _ -> case (erlang:length(Pair_vals_5) == 2) of
        true -> Rank_9 = 3,
            Rank_13 = Rank_9;
        _ -> case (erlang:length(Pair_vals_5) == 1) of
        true -> Rank_10 = 2,
            Rank_12 = Rank_10;
        _ -> Rank_11 = 1,
            Rank_12 = Rank_11
    end,
            Rank_13 = Rank_12
    end,
            Rank_14 = Rank_13
    end,
            Rank_15 = Rank_14
    end,
            Rank_16 = Rank_15
    end,
            Rank_17 = Rank_16
    end,
            Rank_18 = Rank_17
    end,
            Rank_19 = Rank_18
    end,
            Rank_20 = Rank_19
    end,
        #{"rank" => Rank_20, "values" => Vals_8}
    catch {return, Ret} -> Ret end.

compare(A, B) ->
    try
        case (maps:get("rank", A, nil) > maps:get("rank", B, nil)) of
        true -> throw({return, "Win"});
        _ -> ok
    end,
        case (maps:get("rank", A, nil) < maps:get("rank", B, nil)) of
        true -> throw({return, "Loss"});
        _ -> ok
    end,
        I_7 = 0,
        Fun_10 = fun Fun_10_loop(A, B, I_7) ->
    case (I_7 < erlang:length(maps:get("values", A, nil))) of
        true ->
            case ((case erlang:is_map(maps:get("values", A, nil)) of true -> maps:get(I_7, maps:get("values", A, nil), nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(maps:get("values", A, nil)) + I_7 + 1, maps:get("values", A, nil)); _ -> mochi_nth(I_7 + 1, maps:get("values", A, nil)) end end) > (case erlang:is_map(maps:get("values", B, nil)) of true -> maps:get(I_7, maps:get("values", B, nil), nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(maps:get("values", B, nil)) + I_7 + 1, maps:get("values", B, nil)); _ -> mochi_nth(I_7 + 1, maps:get("values", B, nil)) end end)) of
        true -> throw({return, "Win"});
        _ -> ok
    end,
            case ((case erlang:is_map(maps:get("values", A, nil)) of true -> maps:get(I_7, maps:get("values", A, nil), nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(maps:get("values", A, nil)) + I_7 + 1, maps:get("values", A, nil)); _ -> mochi_nth(I_7 + 1, maps:get("values", A, nil)) end end) < (case erlang:is_map(maps:get("values", B, nil)) of true -> maps:get(I_7, maps:get("values", B, nil), nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(maps:get("values", B, nil)) + I_7 + 1, maps:get("values", B, nil)); _ -> mochi_nth(I_7 + 1, maps:get("values", B, nil)) end end)) of
        true -> throw({return, "Loss"});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_10_loop(A, B, I_8);
        _ -> {A, B, I_7}
    end
end,
{A, B, I_8} = Fun_10(A, B, I_7),
        "Tie"
    catch {return, Ret} -> Ret end.

main() ->
    try
        Tests = [["2H 3H 4H 5H 6H", "KS AS TS QS JS", "Loss"], ["2H 3H 4H 5H 6H", "AS AD AC AH JD", "Win"], ["AS AH 2H AD AC", "JS JD JC JH 3D", "Win"], ["2S AH 2H AS AC", "JS JD JC JH AD", "Loss"], ["2S AH 2H AS AC", "2H 3H 5H 6H 7H", "Win"]],
        Fun_11 = fun Fun_11_loop(List, Tests) ->
    case List of
        [] -> {Tests};
        [T_3|T_3_rest] ->
            Res = compare(parse_hand((case erlang:is_map(T_3) of true -> maps:get(0, T_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(T_3) + 0 + 1, T_3); _ -> mochi_nth(0 + 1, T_3) end end)), parse_hand((case erlang:is_map(T_3) of true -> maps:get(1, T_3, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(T_3) + 1 + 1, T_3); _ -> mochi_nth(1 + 1, T_3) end end))),
            io:format("~ts~n", [mochi_repr(((Res ++ " expected ") ++ (case erlang:is_map(T_3) of true -> maps:get(2, T_3, nil); _ -> case 2 < 0 of true -> mochi_nth(erlang:length(T_3) + 2 + 1, T_3); _ -> mochi_nth(2 + 1, T_3) end end)))]),
            Fun_11_loop(T_3_rest, Tests);
        _ -> {Tests}
    end
end,
{Tests} = Fun_11(Tests, Tests),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
