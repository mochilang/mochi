#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, get_totients/1, has_same_digits/2, solution/1]).

% Generated by Mochi transpiler v0.10.61 (336645299d) on 2025-08-08 18:06 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

get_totients(Max_one) ->
    try
        Totients = [],
        I = 0,
        Fun = fun Fun_loop(I, Max_one, Totients) ->
    case (I < Max_one) of
        true ->
            Totients_2 = lists:append((case Totients of nil -> []; _ -> Totients end), [I]),
            I_2 = (I + 1),
            Fun_loop(I_2, Max_one, Totients_2);
        _ -> {I, Max_one, Totients}
    end
end,
{I_2, Max_one, Totients_2} = Fun(I, Max_one, Totients),
        I_3 = 2,
        Fun_4 = fun Fun_4_loop(I_3, Max_one, Totients_2) ->
    case (I_3 < Max_one) of
        true ->
            case ((case erlang:is_map(Totients_2) of true -> maps:get(I_3, Totients_2, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Totients_2) + I_3 + 1, Totients_2); _ -> mochi_nth(I_3 + 1, Totients_2) end end) == I_3) of
        true -> X = I_3,
            Fun_2 = fun Fun_2_loop(I_3, Max_one, Totients_2, X) ->
    case (X < Max_one) of
        true ->
            Totients_3 = lists:sublist(Totients_2, X) ++ [((case erlang:is_map(Totients_2) of true -> maps:get(X, Totients_2, nil); _ -> case X < 0 of true -> mochi_nth(erlang:length(Totients_2) + X + 1, Totients_2); _ -> mochi_nth(X + 1, Totients_2) end end) - mochi_safe_div((case erlang:is_map(Totients_2) of true -> maps:get(X, Totients_2, nil); _ -> case X < 0 of true -> mochi_nth(erlang:length(Totients_2) + X + 1, Totients_2); _ -> mochi_nth(X + 1, Totients_2) end end), I_3))] ++ lists:nthtail(X + 1, Totients_2),
            X_2 = (X + I_3),
            Fun_2_loop(I_3, Max_one, Totients_3, X_2);
        _ -> {I_3, Max_one, Totients_2, X}
    end
end,
{I_3, Max_one, Totients_3, X_2} = Fun_2(I_3, Max_one, Totients_2, X),
            Fun_3 = Fun_2,
            Totients_4 = Totients_3,
            X_3 = X_2;
        _ -> Fun_3 = Fun,
            Totients_4 = Totients_2,
            X_3 = nil
    end,
            I_4 = (I_3 + 1),
            Fun_4_loop(I_4, Max_one, Totients_4);
        _ -> {I_3, Max_one, Totients_2}
    end
end,
{I_4, Max_one, Totients_4} = Fun_4(I_3, Max_one, Totients_2),
        Totients_4
    catch {return, Ret} -> Ret end.

has_same_digits(Num1, Num2) ->
    try
        Count1 = [],
        Count2 = [],
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(Count1, Count2, I_5, Num1, Num2) ->
    case (I_5 < 10) of
        true ->
            Count1_2 = lists:append((case Count1 of nil -> []; _ -> Count1 end), [0]),
            Count2_2 = lists:append((case Count2 of nil -> []; _ -> Count2 end), [0]),
            I_6 = (I_5 + 1),
            Fun_5_loop(Count1_2, Count2_2, I_6, Num1, Num2);
        _ -> {Count1, Count2, I_5, Num1, Num2}
    end
end,
{Count1_2, Count2_2, I_6, Num1, Num2} = Fun_5(Count1, Count2, I_5, Num1, Num2),
        N1 = Num1,
        N2 = Num2,
        case (N1 == 0) of
        true -> Count1_3 = lists:sublist(Count1_2, 0) ++ [((case erlang:is_map(Count1_2) of true -> maps:get(0, Count1_2, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Count1_2) + 0 + 1, Count1_2); _ -> mochi_nth(0 + 1, Count1_2) end end) + 1)] ++ lists:nthtail(0 + 1, Count1_2),
            Count1_4 = Count1_3;
        _ -> Count1_4 = Count1_2
    end,
        case (N2 == 0) of
        true -> Count2_3 = lists:sublist(Count2_2, 0) ++ [((case erlang:is_map(Count2_2) of true -> maps:get(0, Count2_2, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Count2_2) + 0 + 1, Count2_2); _ -> mochi_nth(0 + 1, Count2_2) end end) + 1)] ++ lists:nthtail(0 + 1, Count2_2),
            Count2_4 = Count2_3;
        _ -> Count2_4 = Count2_2
    end,
        Fun_6 = fun Fun_6_loop(Count1_4, Count2_4, I_6, N1, N2, Num1, Num2) ->
    case (N1 > 0) of
        true ->
            D1 = mochi_mod(N1, 10),
            Count1_5 = lists:sublist(Count1_4, D1) ++ [((case erlang:is_map(Count1_4) of true -> maps:get(D1, Count1_4, nil); _ -> case D1 < 0 of true -> mochi_nth(erlang:length(Count1_4) + D1 + 1, Count1_4); _ -> mochi_nth(D1 + 1, Count1_4) end end) + 1)] ++ lists:nthtail(D1 + 1, Count1_4),
            N1_2 = (N1 div 10),
            Fun_6_loop(Count1_5, Count2_4, I_6, N1_2, N2, Num1, Num2);
        _ -> {Count1_4, Count2_4, I_6, N1, N2, Num1, Num2}
    end
end,
{Count1_5, Count2_4, I_6, N1_2, N2, Num1, Num2} = Fun_6(Count1_4, Count2_4, I_6, N1, N2, Num1, Num2),
        Fun_7 = fun Fun_7_loop(Count1_5, Count2_4, I_6, N1_2, N2, Num1, Num2) ->
    case (N2 > 0) of
        true ->
            D2 = mochi_mod(N2, 10),
            Count2_5 = lists:sublist(Count2_4, D2) ++ [((case erlang:is_map(Count2_4) of true -> maps:get(D2, Count2_4, nil); _ -> case D2 < 0 of true -> mochi_nth(erlang:length(Count2_4) + D2 + 1, Count2_4); _ -> mochi_nth(D2 + 1, Count2_4) end end) + 1)] ++ lists:nthtail(D2 + 1, Count2_4),
            N2_2 = (N2 div 10),
            Fun_7_loop(Count1_5, Count2_5, I_6, N1_2, N2_2, Num1, Num2);
        _ -> {Count1_5, Count2_4, I_6, N1_2, N2, Num1, Num2}
    end
end,
{Count1_5, Count2_5, I_6, N1_2, N2_2, Num1, Num2} = Fun_7(Count1_5, Count2_4, I_6, N1_2, N2, Num1, Num2),
        I_7 = 0,
        Fun_8 = fun Fun_8_loop(Count1_5, Count2_5, I_7, N1_2, N2_2, Num1, Num2) ->
    case (I_7 < 10) of
        true ->
            case ((case erlang:is_map(Count1_5) of true -> maps:get(I_7, Count1_5, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Count1_5) + I_7 + 1, Count1_5); _ -> mochi_nth(I_7 + 1, Count1_5) end end) /= (case erlang:is_map(Count2_5) of true -> maps:get(I_7, Count2_5, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Count2_5) + I_7 + 1, Count2_5); _ -> mochi_nth(I_7 + 1, Count2_5) end end)) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_8_loop(Count1_5, Count2_5, I_8, N1_2, N2_2, Num1, Num2);
        _ -> {Count1_5, Count2_5, I_7, N1_2, N2_2, Num1, Num2}
    end
end,
{Count1_5, Count2_5, I_8, N1_2, N2_2, Num1, Num2} = Fun_8(Count1_5, Count2_5, I_7, N1_2, N2_2, Num1, Num2),
        true
    catch {return, Ret} -> Ret end.

solution(Max_n) ->
    try
        Min_numerator = 1,
        Min_denominator = 0,
        Totients_5 = get_totients((Max_n + 1)),
        I_9 = 2,
        Fun_9 = fun Fun_9_loop(I_9, Max_n, Min_denominator, Min_numerator, Totients_5) ->
    case (I_9 =< Max_n) of
        true ->
            T = (case erlang:is_map(Totients_5) of true -> maps:get(I_9, Totients_5, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Totients_5) + I_9 + 1, Totients_5); _ -> mochi_nth(I_9 + 1, Totients_5) end end),
            case (((I_9 * Min_denominator) < (Min_numerator * T)) andalso has_same_digits(I_9, T)) of
        true -> Min_numerator_2 = I_9,
            Min_denominator_2 = T,
            Min_denominator_3 = Min_denominator_2,
            Min_numerator_3 = Min_numerator_2;
        _ -> Min_denominator_3 = Min_denominator,
            Min_numerator_3 = Min_numerator
    end,
            I_10 = (I_9 + 1),
            Fun_9_loop(I_10, Max_n, Min_denominator_3, Min_numerator_3, Totients_5);
        _ -> {I_9, Max_n, Min_denominator, Min_numerator, Totients_5}
    end
end,
{I_10, Max_n, Min_denominator_3, Min_numerator_3, Totients_5} = Fun_9(I_9, Max_n, Min_denominator, Min_numerator, Totients_5),
        Min_numerator_3
    catch {return, Ret} -> Ret end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    io:format("~ts~n", [mochi_str(solution(10000))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
