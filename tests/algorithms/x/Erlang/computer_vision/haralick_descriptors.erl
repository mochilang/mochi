#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, abs_int/1, sqrt/1, ln/1, matrix_concurrency/2, haralick_descriptors/1]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.


mochi_mod(A, B) when B =/= 0 ->
    ((A rem B) + B) rem B;
mochi_mod(_, _) -> 0.

abs_int(N) ->
    try
        (case (N < 0) of
    true -> -N;
    _ -> N
end)
    catch {return, Ret} -> Ret end.

sqrt(X) ->
    try
        case (X =< 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        Guess = X,
        I = 0,
        Fun = fun Fun_loop(Guess, I, X) ->
    case (I < 10) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X, Guess)), 2),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X);
        _ -> {Guess, I, X}
    end
end,
{Guess_2, I_2, X} = Fun(Guess, I, X),
        Guess_2
    catch {return, Ret} -> Ret end.

ln(X_2) ->
    try
        case (X_2 =< 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        E = 2.718281828,
        N_2 = 0,
        Y = X_2,
        Fun_2 = fun Fun_2_loop(E, N_2, X_2, Y) ->
    case (Y >= E) of
        true ->
            Y_2 = mochi_safe_div(Y, E),
            N_3 = (N_2 + 1),
            Fun_2_loop(E, N_3, X_2, Y_2);
        _ -> {E, N_2, X_2, Y}
    end
end,
{E, N_3, X_2, Y_2} = Fun_2(E, N_2, X_2, Y),
        Fun_3 = fun Fun_3_loop(E, N_3, X_2, Y_2) ->
    case (Y_2 =< mochi_safe_div(1, E)) of
        true ->
            Y_3 = mochi_safe_mul(Y_2, E),
            N_4 = (N_3 - 1),
            Fun_3_loop(E, N_4, X_2, Y_3);
        _ -> {E, N_3, X_2, Y_2}
    end
end,
{E, N_4, X_2, Y_3} = Fun_3(E, N_3, X_2, Y_2),
        Y_4 = (Y_3 - 1),
        Term = Y_4,
        Result = 0,
        K = 1,
        Fun_4 = fun Fun_4_loop(E, K, N_4, Result, Term, X_2, Y_4) ->
    case (K =< 20) of
        true ->
            case (mochi_mod(K, 2) == 1) of
        true -> Result_2 = (Result + mochi_safe_div(Term, mochi_safe_mul(1, K))),
            Result_4 = Result_2;
        _ -> Result_3 = (Result - mochi_safe_div(Term, mochi_safe_mul(1, K))),
            Result_4 = Result_3
    end,
            Term_2 = mochi_safe_mul(Term, Y_4),
            K_2 = (K + 1),
            Fun_4_loop(E, K_2, N_4, Result_4, Term_2, X_2, Y_4);
        _ -> {E, K, N_4, Result, Term, X_2, Y_4}
    end
end,
{E, K_2, N_4, Result_4, Term_2, X_2, Y_4} = Fun_4(E, K, N_4, Result, Term, X_2, Y_4),
        (Result_4 + mochi_safe_mul(1, N_4))
    catch {return, Ret} -> Ret end.

matrix_concurrency(Image, Coord) ->
    try
        Offset_x = (case erlang:is_map(Coord) of true -> maps:get(0, Coord, nil); _ -> lists:nth(0 + 1, Coord) end),
        Offset_y = (case erlang:is_map(Coord) of true -> maps:get(1, Coord, nil); _ -> lists:nth(1 + 1, Coord) end),
        Max_val = 0,
        Fun_5 = fun Fun_5_loop(List, Coord, Image, Max_val, Offset_x, Offset_y) ->
    case List of
        [] -> {Coord, Image, Max_val, Offset_x, Offset_y};
        [R|R_rest] ->
            Fun_6 = fun Fun_6_loop(List, Coord, Image, Max_val, Offset_x, Offset_y, R) ->
    case List of
        [] -> {Coord, Image, Max_val, Offset_x, Offset_y, R};
        [C|C_rest] ->
            case ((case erlang:is_map((case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end)) of true -> maps:get(C, (case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end)) end) > Max_val) of
        true -> Max_val_2 = (case erlang:is_map((case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end)) of true -> maps:get(C, (case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end)) end),
            Max_val_3 = Max_val_2;
        _ -> Max_val_3 = Max_val
    end,
            Fun_6_loop(C_rest, Coord, Image, Max_val_3, Offset_x, Offset_y, R);
        _ -> {Coord, Image, Max_val, Offset_x, Offset_y, R}
    end
end,
{Coord, Image, Max_val_3, Offset_x, Offset_y, R} = Fun_6(lists:seq(0, (length((case erlang:is_map(Image) of true -> maps:get(R, Image, nil); _ -> lists:nth(R + 1, Image) end))) - 1), Coord, Image, Max_val, Offset_x, Offset_y, R),
            Fun_5_loop(R_rest, Coord, Image, Max_val_3, Offset_x, Offset_y);
        _ -> {Coord, Image, Max_val, Offset_x, Offset_y}
    end
end,
{Coord, Image, Max_val_3, Offset_x, Offset_y} = Fun_5(lists:seq(0, (length(Image)) - 1), Coord, Image, Max_val, Offset_x, Offset_y),
        Size = (Max_val_3 + 1),
        Matrix = [],
        Fun_7 = fun Fun_7_loop(List, Coord, Image, Matrix, Max_val_3, Offset_x, Offset_y, Size) ->
    case List of
        [] -> {Coord, Image, Matrix, Max_val_3, Offset_x, Offset_y, Size};
        [I_3|I_3_rest] ->
            Row = [],
            Fun_8 = fun Fun_8_loop(List, Coord, I_3, Image, Matrix, Max_val_3, Offset_x, Offset_y, Row, Size) ->
    case List of
        [] -> {Coord, I_3, Image, Matrix, Max_val_3, Offset_x, Offset_y, Row, Size};
        [J|J_rest] ->
            Row_2 = lists:append(Row, [0]),
            Fun_8_loop(J_rest, Coord, I_3, Image, Matrix, Max_val_3, Offset_x, Offset_y, Row_2, Size);
        _ -> {Coord, I_3, Image, Matrix, Max_val_3, Offset_x, Offset_y, Row, Size}
    end
end,
{Coord, I_3, Image, Matrix, Max_val_3, Offset_x, Offset_y, Row_2, Size} = Fun_8(lists:seq(0, (Size) - 1), Coord, I_3, Image, Matrix, Max_val_3, Offset_x, Offset_y, Row, Size),
            Matrix_2 = lists:append(Matrix, [Row_2]),
            Fun_7_loop(I_3_rest, Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size);
        _ -> {Coord, Image, Matrix, Max_val_3, Offset_x, Offset_y, Size}
    end
end,
{Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size} = Fun_7(lists:seq(0, (Size) - 1), Coord, Image, Matrix, Max_val_3, Offset_x, Offset_y, Size),
        Fun_9 = fun Fun_9_loop(List, Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size) ->
    case List of
        [] -> {Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size};
        [X_3|X_3_rest] ->
            Fun_10 = fun Fun_10_loop(List, Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size, X_3) ->
    case List of
        [] -> {Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size, X_3};
        [Y_5|Y_5_rest] ->
            Base = (case erlang:is_map((case erlang:is_map(Image) of true -> maps:get(X_3, Image, nil); _ -> lists:nth(X_3 + 1, Image) end)) of true -> maps:get(Y_5, (case erlang:is_map(Image) of true -> maps:get(X_3, Image, nil); _ -> lists:nth(X_3 + 1, Image) end), nil); _ -> lists:nth(Y_5 + 1, (case erlang:is_map(Image) of true -> maps:get(X_3, Image, nil); _ -> lists:nth(X_3 + 1, Image) end)) end),
            Offset = (case erlang:is_map((case erlang:is_map(Image) of true -> maps:get((X_3 + Offset_x), Image, nil); _ -> lists:nth((X_3 + Offset_x) + 1, Image) end)) of true -> maps:get((Y_5 + Offset_y), (case erlang:is_map(Image) of true -> maps:get((X_3 + Offset_x), Image, nil); _ -> lists:nth((X_3 + Offset_x) + 1, Image) end), nil); _ -> lists:nth((Y_5 + Offset_y) + 1, (case erlang:is_map(Image) of true -> maps:get((X_3 + Offset_x), Image, nil); _ -> lists:nth((X_3 + Offset_x) + 1, Image) end)) end),
            Tmp = (case erlang:is_map(Matrix_2) of true -> maps:get(Base, Matrix_2, nil); _ -> lists:nth(Base + 1, Matrix_2) end),
            Tmp_2 = lists:sublist(Tmp, Offset) ++ [((case erlang:is_map((case erlang:is_map(Matrix_2) of true -> maps:get(Base, Matrix_2, nil); _ -> lists:nth(Base + 1, Matrix_2) end)) of true -> maps:get(Offset, (case erlang:is_map(Matrix_2) of true -> maps:get(Base, Matrix_2, nil); _ -> lists:nth(Base + 1, Matrix_2) end), nil); _ -> lists:nth(Offset + 1, (case erlang:is_map(Matrix_2) of true -> maps:get(Base, Matrix_2, nil); _ -> lists:nth(Base + 1, Matrix_2) end)) end) + 1)] ++ lists:nthtail(Offset + 1, Tmp),
            Matrix_3 = lists:sublist(Matrix_2, Base) ++ [Tmp_2] ++ lists:nthtail(Base + 1, Matrix_2),
            Fun_10_loop(Y_5_rest, Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, X_3);
        _ -> {Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size, X_3}
    end
end,
{Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, X_3} = Fun_10(lists:seq(1, ((length((case erlang:is_map(Image) of true -> maps:get(X_3, Image, nil); _ -> lists:nth(X_3 + 1, Image) end)) - 1)) - 1), Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size, X_3),
            Fun_9_loop(X_3_rest, Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size);
        _ -> {Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size}
    end
end,
{Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size} = Fun_9(lists:seq(1, ((length(Image) - 1)) - 1), Coord, Image, Matrix_2, Max_val_3, Offset_x, Offset_y, Size),
        Total = 0,
        Fun_11 = fun Fun_11_loop(List, Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total) ->
    case List of
        [] -> {Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total};
        [I_4|I_4_rest] ->
            Fun_12 = fun Fun_12_loop(List, Coord, I_4, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total) ->
    case List of
        [] -> {Coord, I_4, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total};
        [J_2|J_2_rest] ->
            Total_2 = (Total + (case erlang:is_map((case erlang:is_map(Matrix_3) of true -> maps:get(I_4, Matrix_3, nil); _ -> lists:nth(I_4 + 1, Matrix_3) end)) of true -> maps:get(J_2, (case erlang:is_map(Matrix_3) of true -> maps:get(I_4, Matrix_3, nil); _ -> lists:nth(I_4 + 1, Matrix_3) end), nil); _ -> lists:nth(J_2 + 1, (case erlang:is_map(Matrix_3) of true -> maps:get(I_4, Matrix_3, nil); _ -> lists:nth(I_4 + 1, Matrix_3) end)) end)),
            Fun_12_loop(J_2_rest, Coord, I_4, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2);
        _ -> {Coord, I_4, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total}
    end
end,
{Coord, I_4, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2} = Fun_12(lists:seq(0, (Size) - 1), Coord, I_4, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total),
            Fun_11_loop(I_4_rest, Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2);
        _ -> {Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total}
    end
end,
{Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2} = Fun_11(lists:seq(0, (Size) - 1), Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total),
        case (Total_2 == 0) of
        true -> throw({return, Matrix_3});
        _ -> ok
    end,
        Fun_13 = fun Fun_13_loop(List, Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2) ->
    case List of
        [] -> {Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2};
        [I_5|I_5_rest] ->
            Fun_14 = fun Fun_14_loop(List, Coord, I_5, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2) ->
    case List of
        [] -> {Coord, I_5, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2};
        [J_3|J_3_rest] ->
            Tmp_3 = (case erlang:is_map(Matrix_3) of true -> maps:get(I_5, Matrix_3, nil); _ -> lists:nth(I_5 + 1, Matrix_3) end),
            Tmp_4 = lists:sublist(Tmp_3, J_3) ++ [mochi_safe_div((case erlang:is_map((case erlang:is_map(Matrix_3) of true -> maps:get(I_5, Matrix_3, nil); _ -> lists:nth(I_5 + 1, Matrix_3) end)) of true -> maps:get(J_3, (case erlang:is_map(Matrix_3) of true -> maps:get(I_5, Matrix_3, nil); _ -> lists:nth(I_5 + 1, Matrix_3) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Matrix_3) of true -> maps:get(I_5, Matrix_3, nil); _ -> lists:nth(I_5 + 1, Matrix_3) end)) end), Total_2)] ++ lists:nthtail(J_3 + 1, Tmp_3),
            Matrix_4 = lists:sublist(Matrix_3, I_5) ++ [Tmp_4] ++ lists:nthtail(I_5 + 1, Matrix_3),
            Fun_14_loop(J_3_rest, Coord, I_5, Image, Matrix_4, Max_val_3, Offset_x, Offset_y, Size, Total_2);
        _ -> {Coord, I_5, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2}
    end
end,
{Coord, I_5, Image, Matrix_4, Max_val_3, Offset_x, Offset_y, Size, Total_2} = Fun_14(lists:seq(0, (Size) - 1), Coord, I_5, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2),
            Fun_13_loop(I_5_rest, Coord, Image, Matrix_4, Max_val_3, Offset_x, Offset_y, Size, Total_2);
        _ -> {Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2}
    end
end,
{Coord, Image, Matrix_4, Max_val_3, Offset_x, Offset_y, Size, Total_2} = Fun_13(lists:seq(0, (Size) - 1), Coord, Image, Matrix_3, Max_val_3, Offset_x, Offset_y, Size, Total_2),
        Matrix_4
    catch {return, Ret} -> Ret end.

haralick_descriptors(Matrix_5) ->
    try
        Rows = length(Matrix_5),
        Cols = length((case erlang:is_map(Matrix_5) of true -> maps:get(0, Matrix_5, nil); _ -> lists:nth(0 + 1, Matrix_5) end)),
        Maximum_prob = 0,
        Correlation = 0,
        Energy = 0,
        Contrast = 0,
        Dissimilarity = 0,
        Inverse_difference = 0,
        Homogeneity = 0,
        Entropy = 0,
        I_6 = 0,
        Fun_16 = fun Fun_16_loop(Cols, Contrast, Correlation, Dissimilarity, Energy, Entropy, Homogeneity, I_6, Inverse_difference, Matrix_5, Maximum_prob, Rows) ->
    case (I_6 < Rows) of
        true ->
            J_4 = 0,
            Fun_15 = fun Fun_15_loop(Cols, Contrast, Correlation, Dissimilarity, Energy, Entropy, Homogeneity, I_6, Inverse_difference, J_4, Matrix_5, Maximum_prob, Rows) ->
    case (J_4 < Cols) of
        true ->
            Val = (case erlang:is_map((case erlang:is_map(Matrix_5) of true -> maps:get(I_6, Matrix_5, nil); _ -> lists:nth(I_6 + 1, Matrix_5) end)) of true -> maps:get(J_4, (case erlang:is_map(Matrix_5) of true -> maps:get(I_6, Matrix_5, nil); _ -> lists:nth(I_6 + 1, Matrix_5) end), nil); _ -> lists:nth(J_4 + 1, (case erlang:is_map(Matrix_5) of true -> maps:get(I_6, Matrix_5, nil); _ -> lists:nth(I_6 + 1, Matrix_5) end)) end),
            case (Val > Maximum_prob) of
        true -> Maximum_prob_2 = Val,
            Maximum_prob_3 = Maximum_prob_2;
        _ -> Maximum_prob_3 = Maximum_prob
    end,
            Correlation_2 = (Correlation + mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(1, I_6), J_4), Val)),
            Energy_2 = (Energy + mochi_safe_mul(Val, Val)),
            Diff = (I_6 - J_4),
            Adiff = abs_int(Diff),
            Contrast_2 = (Contrast + mochi_safe_mul(Val, mochi_safe_mul(mochi_safe_mul(1, Diff), Diff))),
            Dissimilarity_2 = (Dissimilarity + mochi_safe_mul(Val, mochi_safe_mul(1, Adiff))),
            Inverse_difference_2 = (Inverse_difference + mochi_safe_div(Val, (1 + mochi_safe_mul(1, Adiff)))),
            Homogeneity_2 = (Homogeneity + mochi_safe_div(Val, (1 + mochi_safe_mul(mochi_safe_mul(1, Diff), Diff)))),
            case (Val > 0) of
        true -> Entropy_2 = (Entropy - mochi_safe_mul(Val, ln(Val))),
            Entropy_3 = Entropy_2;
        _ -> Entropy_3 = Entropy
    end,
            J_5 = (J_4 + 1),
            Fun_15_loop(Cols, Contrast_2, Correlation_2, Dissimilarity_2, Energy_2, Entropy_3, Homogeneity_2, I_6, Inverse_difference_2, J_5, Matrix_5, Maximum_prob_3, Rows);
        _ -> {Cols, Contrast, Correlation, Dissimilarity, Energy, Entropy, Homogeneity, I_6, Inverse_difference, J_4, Matrix_5, Maximum_prob, Rows}
    end
end,
{Cols, Contrast_2, Correlation_2, Dissimilarity_2, Energy_2, Entropy_3, Homogeneity_2, I_6, Inverse_difference_2, J_5, Matrix_5, Maximum_prob_3, Rows} = Fun_15(Cols, Contrast, Correlation, Dissimilarity, Energy, Entropy, Homogeneity, I_6, Inverse_difference, J_4, Matrix_5, Maximum_prob, Rows),
            I_7 = (I_6 + 1),
            Fun_16_loop(Cols, Contrast_2, Correlation_2, Dissimilarity_2, Energy_2, Entropy_3, Homogeneity_2, I_7, Inverse_difference_2, Matrix_5, Maximum_prob_3, Rows);
        _ -> {Cols, Contrast, Correlation, Dissimilarity, Energy, Entropy, Homogeneity, I_6, Inverse_difference, Matrix_5, Maximum_prob, Rows}
    end
end,
{Cols, Contrast_2, Correlation_2, Dissimilarity_2, Energy_2, Entropy_3, Homogeneity_2, I_7, Inverse_difference_2, Matrix_5, Maximum_prob_3, Rows} = Fun_16(Cols, Contrast, Correlation, Dissimilarity, Energy, Entropy, Homogeneity, I_6, Inverse_difference, Matrix_5, Maximum_prob, Rows),
        [Maximum_prob_3, Correlation_2, Energy_2, Contrast_2, Dissimilarity_2, Inverse_difference_2, Homogeneity_2, Entropy_3]
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('image', [[0, 1, 0], [1, 0, 1], [0, 1, 0]]),
    erlang:put('glcm', matrix_concurrency(erlang:get('image'), [0, 1])),
    erlang:put('descriptors', haralick_descriptors(erlang:get('glcm'))),
    erlang:put('idx', 0),
    Fun_17 = fun Fun_17_loop() ->
    case (erlang:get('idx') < length(erlang:get('descriptors'))) of
        true ->
            io:format("~ts~n", [mochi_str((case erlang:is_map(erlang:get('descriptors')) of true -> maps:get(erlang:get('idx'), erlang:get('descriptors'), nil); _ -> lists:nth(erlang:get('idx') + 1, erlang:get('descriptors')) end))]),
            erlang:put('idx', (erlang:get('idx') + 1)),
            Fun_17_loop();
        _ -> {}
    end
end,
{} = Fun_17(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
