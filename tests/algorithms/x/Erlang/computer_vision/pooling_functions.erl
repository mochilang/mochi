#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, maxpooling/3, avgpooling/3, print_matrix/1, main/0]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

maxpooling(Arr, Size, Stride) ->
    try
        N = length(Arr),
        case ((N == 0) orelse (length((case erlang:is_map(Arr) of true -> maps:get(0, Arr, nil); _ -> lists:nth(0 + 1, Arr) end)) /= N)) of
        true -> erlang:error("The input array is not a square matrix");
        _ -> ok
    end,
        Result = [],
        I = 0,
        Fun_4 = fun Fun_4_loop(Arr, I, N, Result, Size, Stride) ->
    case ((I + Size) =< N) of
        true ->
            Row = [],
            J = 0,
            Fun_3 = fun Fun_3_loop(Arr, I, J, N, Result, Row, Size, Stride) ->
    case ((J + Size) =< N) of
        true ->
            Max_val = (case erlang:is_map((case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> lists:nth(I + 1, Arr) end)) of true -> maps:get(J, (case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> lists:nth(I + 1, Arr) end), nil); _ -> lists:nth(J + 1, (case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> lists:nth(I + 1, Arr) end)) end),
            R = I,
            Fun_2 = fun Fun_2_loop(Arr, I, J, Max_val, N, R, Result, Row, Size, Stride) ->
    case (R < (I + Size)) of
        true ->
            C = J,
            Fun = fun Fun_loop(Arr, C, I, J, Max_val, N, R, Result, Row, Size, Stride) ->
    case (C < (J + Size)) of
        true ->
            Val = (case erlang:is_map((case erlang:is_map(Arr) of true -> maps:get(R, Arr, nil); _ -> lists:nth(R + 1, Arr) end)) of true -> maps:get(C, (case erlang:is_map(Arr) of true -> maps:get(R, Arr, nil); _ -> lists:nth(R + 1, Arr) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Arr) of true -> maps:get(R, Arr, nil); _ -> lists:nth(R + 1, Arr) end)) end),
            case (Val > Max_val) of
        true -> Max_val_2 = Val,
            Max_val_3 = Max_val_2;
        _ -> Max_val_3 = Max_val
    end,
            C_2 = (C + 1),
            Fun_loop(Arr, C_2, I, J, Max_val_3, N, R, Result, Row, Size, Stride);
        _ -> {Arr, C, I, J, Max_val, N, R, Result, Row, Size, Stride}
    end
end,
{Arr, C_2, I, J, Max_val_3, N, R, Result, Row, Size, Stride} = Fun(Arr, C, I, J, Max_val, N, R, Result, Row, Size, Stride),
            R_2 = (R + 1),
            Fun_2_loop(Arr, I, J, Max_val_3, N, R_2, Result, Row, Size, Stride);
        _ -> {Arr, I, J, Max_val, N, R, Result, Row, Size, Stride}
    end
end,
{Arr, I, J, Max_val_3, N, R_2, Result, Row, Size, Stride} = Fun_2(Arr, I, J, Max_val, N, R, Result, Row, Size, Stride),
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [Max_val_3]),
            J_2 = (J + Stride),
            Fun_3_loop(Arr, I, J_2, N, Result, Row_2, Size, Stride);
        _ -> {Arr, I, J, N, Result, Row, Size, Stride}
    end
end,
{Arr, I, J_2, N, Result, Row_2, Size, Stride} = Fun_3(Arr, I, J, N, Result, Row, Size, Stride),
            Result_2 = lists:append((case Result of nil -> []; _ -> Result end), [Row_2]),
            I_2 = (I + Stride),
            Fun_4_loop(Arr, I_2, N, Result_2, Size, Stride);
        _ -> {Arr, I, N, Result, Size, Stride}
    end
end,
{Arr, I_2, N, Result_2, Size, Stride} = Fun_4(Arr, I, N, Result, Size, Stride),
        Result_2
    catch {return, Ret} -> Ret end.

avgpooling(Arr_2, Size_2, Stride_2) ->
    try
        N_2 = length(Arr_2),
        case ((N_2 == 0) orelse (length((case erlang:is_map(Arr_2) of true -> maps:get(0, Arr_2, nil); _ -> lists:nth(0 + 1, Arr_2) end)) /= N_2)) of
        true -> erlang:error("The input array is not a square matrix");
        _ -> ok
    end,
        Result_3 = [],
        I_3 = 0,
        Fun_8 = fun Fun_8_loop(Arr_2, I_3, N_2, Result_3, Size_2, Stride_2) ->
    case ((I_3 + Size_2) =< N_2) of
        true ->
            Row_3 = [],
            J_3 = 0,
            Fun_7 = fun Fun_7_loop(Arr_2, I_3, J_3, N_2, Result_3, Row_3, Size_2, Stride_2) ->
    case ((J_3 + Size_2) =< N_2) of
        true ->
            Sum = 0,
            R_3 = I_3,
            Fun_6 = fun Fun_6_loop(Arr_2, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum) ->
    case (R_3 < (I_3 + Size_2)) of
        true ->
            C_3 = J_3,
            Fun_5 = fun Fun_5_loop(Arr_2, C_3, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum) ->
    case (C_3 < (J_3 + Size_2)) of
        true ->
            Sum_2 = (Sum + (case erlang:is_map((case erlang:is_map(Arr_2) of true -> maps:get(R_3, Arr_2, nil); _ -> lists:nth(R_3 + 1, Arr_2) end)) of true -> maps:get(C_3, (case erlang:is_map(Arr_2) of true -> maps:get(R_3, Arr_2, nil); _ -> lists:nth(R_3 + 1, Arr_2) end), nil); _ -> lists:nth(C_3 + 1, (case erlang:is_map(Arr_2) of true -> maps:get(R_3, Arr_2, nil); _ -> lists:nth(R_3 + 1, Arr_2) end)) end)),
            C_4 = (C_3 + 1),
            Fun_5_loop(Arr_2, C_4, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum_2);
        _ -> {Arr_2, C_3, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum}
    end
end,
{Arr_2, C_4, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum_2} = Fun_5(Arr_2, C_3, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum),
            R_4 = (R_3 + 1),
            Fun_6_loop(Arr_2, I_3, J_3, N_2, R_4, Result_3, Row_3, Size_2, Stride_2, Sum_2);
        _ -> {Arr_2, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum}
    end
end,
{Arr_2, I_3, J_3, N_2, R_4, Result_3, Row_3, Size_2, Stride_2, Sum_2} = Fun_6(Arr_2, I_3, J_3, N_2, R_3, Result_3, Row_3, Size_2, Stride_2, Sum),
            Row_4 = lists:append((case Row_3 of nil -> []; _ -> Row_3 end), [(Sum_2 div (Size_2 * Size_2))]),
            J_4 = (J_3 + Stride_2),
            Fun_7_loop(Arr_2, I_3, J_4, N_2, Result_3, Row_4, Size_2, Stride_2);
        _ -> {Arr_2, I_3, J_3, N_2, Result_3, Row_3, Size_2, Stride_2}
    end
end,
{Arr_2, I_3, J_4, N_2, Result_3, Row_4, Size_2, Stride_2} = Fun_7(Arr_2, I_3, J_3, N_2, Result_3, Row_3, Size_2, Stride_2),
            Result_4 = lists:append((case Result_3 of nil -> []; _ -> Result_3 end), [Row_4]),
            I_4 = (I_3 + Stride_2),
            Fun_8_loop(Arr_2, I_4, N_2, Result_4, Size_2, Stride_2);
        _ -> {Arr_2, I_3, N_2, Result_3, Size_2, Stride_2}
    end
end,
{Arr_2, I_4, N_2, Result_4, Size_2, Stride_2} = Fun_8(Arr_2, I_3, N_2, Result_3, Size_2, Stride_2),
        Result_4
    catch {return, Ret} -> Ret end.

print_matrix(Mat) ->
    try
        I_5 = 0,
        Fun_10 = fun Fun_10_loop(I_5, Mat) ->
    case (I_5 < length(Mat)) of
        true ->
            Line = "",
            J_5 = 0,
            Fun_9 = fun Fun_9_loop(I_5, J_5, Line, Mat) ->
    case (J_5 < length((case erlang:is_map(Mat) of true -> maps:get(I_5, Mat, nil); _ -> lists:nth(I_5 + 1, Mat) end))) of
        true ->
            Line_2 = (Line ++ mochi_str((case erlang:is_map((case erlang:is_map(Mat) of true -> maps:get(I_5, Mat, nil); _ -> lists:nth(I_5 + 1, Mat) end)) of true -> maps:get(J_5, (case erlang:is_map(Mat) of true -> maps:get(I_5, Mat, nil); _ -> lists:nth(I_5 + 1, Mat) end), nil); _ -> lists:nth(J_5 + 1, (case erlang:is_map(Mat) of true -> maps:get(I_5, Mat, nil); _ -> lists:nth(I_5 + 1, Mat) end)) end))),
            case (J_5 < (length((case erlang:is_map(Mat) of true -> maps:get(I_5, Mat, nil); _ -> lists:nth(I_5 + 1, Mat) end)) - 1)) of
        true -> Line_3 = (Line_2 ++ " "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            J_6 = (J_5 + 1),
            Fun_9_loop(I_5, J_6, Line_4, Mat);
        _ -> {I_5, J_5, Line, Mat}
    end
end,
{I_5, J_6, Line_4, Mat} = Fun_9(I_5, J_5, Line, Mat),
            io:format("~ts~n", [mochi_repr(Line_4)]),
            I_6 = (I_5 + 1),
            Fun_10_loop(I_6, Mat);
        _ -> {I_5, Mat}
    end
end,
{I_6, Mat} = Fun_10(I_5, Mat),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Arr1 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]],
        Arr2 = [[147, 180, 122], [241, 76, 32], [126, 13, 157]],
        print_matrix(maxpooling(Arr1, 2, 2)),
        print_matrix(maxpooling(Arr2, 2, 1)),
        print_matrix(avgpooling(Arr1, 2, 2)),
        print_matrix(avgpooling(Arr2, 2, 1)),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
