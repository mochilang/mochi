#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, processes_resource_summation/1, available_resources/2, need/2, pretty_print/3, bankers_algorithm/3]).

% Generated by Mochi transpiler v0.10.64 (480fdd1e6c) on 2025-08-12 14:08 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


to_float(V) ->
    case erlang:is_float(V) of
        true -> V;
        _ -> float(V)
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

processes_resource_summation(Alloc) ->
    try
        Resources = erlang:length((case erlang:is_map(Alloc) of true -> maps:get(0, Alloc, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Alloc) + 0 + 1, Alloc); _ -> mochi_nth(0 + 1, Alloc) end end)),
        Sums = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(Alloc, I, Resources, Sums) ->
    case (I < Resources) of
        true ->
            Total = 0,
            J = 0,
            Fun = fun Fun_loop(Alloc, I, J, Resources, Sums, Total) ->
    case (J < erlang:length(Alloc)) of
        true ->
            Total_2 = (Total + (case erlang:is_map((case erlang:is_map(Alloc) of true -> maps:get(J, Alloc, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Alloc) + J + 1, Alloc); _ -> mochi_nth(J + 1, Alloc) end end)) of true -> maps:get(I, (case erlang:is_map(Alloc) of true -> maps:get(J, Alloc, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Alloc) + J + 1, Alloc); _ -> mochi_nth(J + 1, Alloc) end end), nil); _ -> case I < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Alloc) of true -> maps:get(J, Alloc, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Alloc) + J + 1, Alloc); _ -> mochi_nth(J + 1, Alloc) end end)) + I + 1, (case erlang:is_map(Alloc) of true -> maps:get(J, Alloc, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Alloc) + J + 1, Alloc); _ -> mochi_nth(J + 1, Alloc) end end)); _ -> mochi_nth(I + 1, (case erlang:is_map(Alloc) of true -> maps:get(J, Alloc, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Alloc) + J + 1, Alloc); _ -> mochi_nth(J + 1, Alloc) end end)) end end)),
            J_2 = (J + 1),
            Fun_loop(Alloc, I, J_2, Resources, Sums, Total_2);
        _ -> {Alloc, I, J, Resources, Sums, Total}
    end
end,
{Alloc, I, J_2, Resources, Sums, Total_2} = Fun(Alloc, I, J, Resources, Sums, Total),
            Sums_2 = lists:append((case Sums of nil -> []; _ -> Sums end), [Total_2]),
            I_2 = (I + 1),
            Fun_2_loop(Alloc, I_2, Resources, Sums_2);
        _ -> {Alloc, I, Resources, Sums}
    end
end,
{Alloc, I_2, Resources, Sums_2} = Fun_2(Alloc, I, Resources, Sums),
        Sums_2
    catch {return, RetCatch} -> RetCatch end.

available_resources(Claim, Alloc_sum) ->
    try
        Avail = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Alloc_sum, Avail, Claim, I_3) ->
    case (I_3 < erlang:length(Claim)) of
        true ->
            Avail_2 = lists:append((case Avail of nil -> []; _ -> Avail end), [((case erlang:is_map(Claim) of true -> maps:get(I_3, Claim, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Claim) + I_3 + 1, Claim); _ -> mochi_nth(I_3 + 1, Claim) end end) - (case erlang:is_map(Alloc_sum) of true -> maps:get(I_3, Alloc_sum, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Alloc_sum) + I_3 + 1, Alloc_sum); _ -> mochi_nth(I_3 + 1, Alloc_sum) end end))]),
            I_4 = (I_3 + 1),
            Fun_3_loop(Alloc_sum, Avail_2, Claim, I_4);
        _ -> {Alloc_sum, Avail, Claim, I_3}
    end
end,
{Alloc_sum, Avail_2, Claim, I_4} = Fun_3(Alloc_sum, Avail, Claim, I_3),
        Avail_2
    catch {return, RetCatch} -> RetCatch end.

need(Max, Alloc_2) ->
    try
        Needs = [],
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(Alloc_2, I_5, Max, Needs) ->
    case (I_5 < erlang:length(Max)) of
        true ->
            Row = [],
            J_3 = 0,
            Fun_4 = fun Fun_4_loop(Alloc_2, I_5, J_3, Max, Needs, Row) ->
    case (J_3 < erlang:length((case erlang:is_map(Max) of true -> maps:get(0, Max, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Max) + 0 + 1, Max); _ -> mochi_nth(0 + 1, Max) end end))) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [((case erlang:is_map((case erlang:is_map(Max) of true -> maps:get(I_5, Max, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Max) + I_5 + 1, Max); _ -> mochi_nth(I_5 + 1, Max) end end)) of true -> maps:get(J_3, (case erlang:is_map(Max) of true -> maps:get(I_5, Max, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Max) + I_5 + 1, Max); _ -> mochi_nth(I_5 + 1, Max) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Max) of true -> maps:get(I_5, Max, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Max) + I_5 + 1, Max); _ -> mochi_nth(I_5 + 1, Max) end end)) + J_3 + 1, (case erlang:is_map(Max) of true -> maps:get(I_5, Max, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Max) + I_5 + 1, Max); _ -> mochi_nth(I_5 + 1, Max) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Max) of true -> maps:get(I_5, Max, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Max) + I_5 + 1, Max); _ -> mochi_nth(I_5 + 1, Max) end end)) end end) - (case erlang:is_map((case erlang:is_map(Alloc_2) of true -> maps:get(I_5, Alloc_2, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Alloc_2) + I_5 + 1, Alloc_2); _ -> mochi_nth(I_5 + 1, Alloc_2) end end)) of true -> maps:get(J_3, (case erlang:is_map(Alloc_2) of true -> maps:get(I_5, Alloc_2, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Alloc_2) + I_5 + 1, Alloc_2); _ -> mochi_nth(I_5 + 1, Alloc_2) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Alloc_2) of true -> maps:get(I_5, Alloc_2, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Alloc_2) + I_5 + 1, Alloc_2); _ -> mochi_nth(I_5 + 1, Alloc_2) end end)) + J_3 + 1, (case erlang:is_map(Alloc_2) of true -> maps:get(I_5, Alloc_2, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Alloc_2) + I_5 + 1, Alloc_2); _ -> mochi_nth(I_5 + 1, Alloc_2) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Alloc_2) of true -> maps:get(I_5, Alloc_2, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Alloc_2) + I_5 + 1, Alloc_2); _ -> mochi_nth(I_5 + 1, Alloc_2) end end)) end end))]),
            J_4 = (J_3 + 1),
            Fun_4_loop(Alloc_2, I_5, J_4, Max, Needs, Row_2);
        _ -> {Alloc_2, I_5, J_3, Max, Needs, Row}
    end
end,
{Alloc_2, I_5, J_4, Max, Needs, Row_2} = Fun_4(Alloc_2, I_5, J_3, Max, Needs, Row),
            Needs_2 = lists:append((case Needs of nil -> []; _ -> Needs end), [Row_2]),
            I_6 = (I_5 + 1),
            Fun_5_loop(Alloc_2, I_6, Max, Needs_2);
        _ -> {Alloc_2, I_5, Max, Needs}
    end
end,
{Alloc_2, I_6, Max, Needs_2} = Fun_5(Alloc_2, I_5, Max, Needs),
        Needs_2
    catch {return, RetCatch} -> RetCatch end.

pretty_print(Claim_2, Alloc_3, Max_2) ->
    try
        io:format("~ts~n", [mochi_repr("         Allocated Resource Table")]),
        I_7 = 0,
        Fun_7 = fun Fun_7_loop(Alloc_3, Claim_2, I_7, Max_2) ->
    case (I_7 < erlang:length(Alloc_3)) of
        true ->
            Row_3 = (case erlang:is_map(Alloc_3) of true -> maps:get(I_7, Alloc_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Alloc_3) + I_7 + 1, Alloc_3); _ -> mochi_nth(I_7 + 1, Alloc_3) end end),
            Line = (("P" ++ mochi_str((I_7 + 1))) ++ "       "),
            J_5 = 0,
            Fun_6 = fun Fun_6_loop(Alloc_3, Claim_2, I_7, J_5, Line, Max_2, Row_3) ->
    case (J_5 < erlang:length(Row_3)) of
        true ->
            Line_2 = (Line ++ mochi_str((case erlang:is_map(Row_3) of true -> maps:get(J_5, Row_3, nil); _ -> case J_5 < 0 of true -> mochi_nth(erlang:length(Row_3) + J_5 + 1, Row_3); _ -> mochi_nth(J_5 + 1, Row_3) end end))),
            case (J_5 < (erlang:length(Row_3) - 1)) of
        true -> Line_3 = (Line_2 ++ "        "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            J_6 = (J_5 + 1),
            Fun_6_loop(Alloc_3, Claim_2, I_7, J_6, Line_4, Max_2, Row_3);
        _ -> {Alloc_3, Claim_2, I_7, J_5, Line, Max_2, Row_3}
    end
end,
{Alloc_3, Claim_2, I_7, J_6, Line_4, Max_2, Row_3} = Fun_6(Alloc_3, Claim_2, I_7, J_5, Line, Max_2, Row_3),
            io:format("~ts~n", [mochi_repr(Line_4)]),
            io:format("~ts~n", [mochi_repr("")]),
            I_8 = (I_7 + 1),
            Fun_7_loop(Alloc_3, Claim_2, I_8, Max_2);
        _ -> {Alloc_3, Claim_2, I_7, Max_2}
    end
end,
{Alloc_3, Claim_2, I_8, Max_2} = Fun_7(Alloc_3, Claim_2, I_7, Max_2),
        io:format("~ts~n", [mochi_repr("         System Resource Table")]),
        I_9 = 0,
        Fun_9 = fun Fun_9_loop(Alloc_3, Claim_2, I_9, Max_2) ->
    case (I_9 < erlang:length(Max_2)) of
        true ->
            Row_4 = (case erlang:is_map(Max_2) of true -> maps:get(I_9, Max_2, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Max_2) + I_9 + 1, Max_2); _ -> mochi_nth(I_9 + 1, Max_2) end end),
            Line_5 = (("P" ++ mochi_str((I_9 + 1))) ++ "       "),
            J_7 = 0,
            Fun_8 = fun Fun_8_loop(Alloc_3, Claim_2, I_9, J_7, Line_5, Max_2, Row_4) ->
    case (J_7 < erlang:length(Row_4)) of
        true ->
            Line_6 = (Line_5 ++ mochi_str((case erlang:is_map(Row_4) of true -> maps:get(J_7, Row_4, nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length(Row_4) + J_7 + 1, Row_4); _ -> mochi_nth(J_7 + 1, Row_4) end end))),
            case (J_7 < (erlang:length(Row_4) - 1)) of
        true -> Line_7 = (Line_6 ++ "        "),
            Line_8 = Line_7;
        _ -> Line_8 = Line_6
    end,
            J_8 = (J_7 + 1),
            Fun_8_loop(Alloc_3, Claim_2, I_9, J_8, Line_8, Max_2, Row_4);
        _ -> {Alloc_3, Claim_2, I_9, J_7, Line_5, Max_2, Row_4}
    end
end,
{Alloc_3, Claim_2, I_9, J_8, Line_8, Max_2, Row_4} = Fun_8(Alloc_3, Claim_2, I_9, J_7, Line_5, Max_2, Row_4),
            io:format("~ts~n", [mochi_repr(Line_8)]),
            io:format("~ts~n", [mochi_repr("")]),
            I_10 = (I_9 + 1),
            Fun_9_loop(Alloc_3, Claim_2, I_10, Max_2);
        _ -> {Alloc_3, Claim_2, I_9, Max_2}
    end
end,
{Alloc_3, Claim_2, I_10, Max_2} = Fun_9(Alloc_3, Claim_2, I_9, Max_2),
        Usage = "",
        I_11 = 0,
        Fun_10 = fun Fun_10_loop(Alloc_3, Claim_2, I_11, Max_2, Usage) ->
    case (I_11 < erlang:length(Claim_2)) of
        true ->
            case (I_11 > 0) of
        true -> Usage_2 = (Usage ++ " "),
            Usage_3 = Usage_2;
        _ -> Usage_3 = Usage
    end,
            Usage_4 = (Usage_3 ++ mochi_str((case erlang:is_map(Claim_2) of true -> maps:get(I_11, Claim_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Claim_2) + I_11 + 1, Claim_2); _ -> mochi_nth(I_11 + 1, Claim_2) end end))),
            I_12 = (I_11 + 1),
            Fun_10_loop(Alloc_3, Claim_2, I_12, Max_2, Usage_4);
        _ -> {Alloc_3, Claim_2, I_11, Max_2, Usage}
    end
end,
{Alloc_3, Claim_2, I_12, Max_2, Usage_4} = Fun_10(Alloc_3, Claim_2, I_11, Max_2, Usage),
        Alloc_sum_2 = processes_resource_summation(Alloc_3),
        Avail_3 = available_resources(Claim_2, Alloc_sum_2),
        Avail_str = "",
        I_13 = 0,
        Fun_11 = fun Fun_11_loop(Alloc_3, Alloc_sum_2, Avail_3, Avail_str, Claim_2, I_13, Max_2, Usage_4) ->
    case (I_13 < erlang:length(Avail_3)) of
        true ->
            case (I_13 > 0) of
        true -> Avail_str_2 = (Avail_str ++ " "),
            Avail_str_3 = Avail_str_2;
        _ -> Avail_str_3 = Avail_str
    end,
            Avail_str_4 = (Avail_str_3 ++ mochi_str((case erlang:is_map(Avail_3) of true -> maps:get(I_13, Avail_3, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(Avail_3) + I_13 + 1, Avail_3); _ -> mochi_nth(I_13 + 1, Avail_3) end end))),
            I_14 = (I_13 + 1),
            Fun_11_loop(Alloc_3, Alloc_sum_2, Avail_3, Avail_str_4, Claim_2, I_14, Max_2, Usage_4);
        _ -> {Alloc_3, Alloc_sum_2, Avail_3, Avail_str, Claim_2, I_13, Max_2, Usage_4}
    end
end,
{Alloc_3, Alloc_sum_2, Avail_3, Avail_str_4, Claim_2, I_14, Max_2, Usage_4} = Fun_11(Alloc_3, Alloc_sum_2, Avail_3, Avail_str, Claim_2, I_13, Max_2, Usage_4),
        io:format("~ts~n", [mochi_repr(("Current Usage by Active Processes: " ++ Usage_4))]),
        io:format("~ts~n", [mochi_repr(("Initial Available Resources:       " ++ Avail_str_4))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

bankers_algorithm(Claim_3, Alloc_4, Max_3) ->
    try
        Need_list = need(Max_3, Alloc_4),
        Alloc_sum_3 = processes_resource_summation(Alloc_4),
        Avail_4 = available_resources(Claim_3, Alloc_sum_3),
        io:format("~ts~n", [mochi_repr("__________________________________________________")]),
        io:format("~ts~n", [mochi_repr("")]),
        Finished = [],
        I_15 = 0,
        Fun_12 = fun Fun_12_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished, I_15, Max_3, Need_list) ->
    case (I_15 < erlang:length(Need_list)) of
        true ->
            Finished_2 = lists:append((case Finished of nil -> []; _ -> Finished end), [false]),
            I_16 = (I_15 + 1),
            Fun_12_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list);
        _ -> {Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished, I_15, Max_3, Need_list}
    end
end,
{Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list} = Fun_12(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished, I_15, Max_3, Need_list),
        Remaining = erlang:length(Need_list),
        Fun_19 = fun Fun_19_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list, Remaining) ->
    case (Remaining > 0) of
        true ->
            try
                Safe = false,
                P = 0,
                Fun_18 = fun Fun_18_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list, P, Remaining, Safe) ->
    case (P < erlang:length(Need_list)) of
        true ->
            try
                case mochi_not((case erlang:is_map(Finished_2) of true -> maps:get(P, Finished_2, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Finished_2) + P + 1, Finished_2); _ -> mochi_nth(P + 1, Finished_2) end end)) of
        true -> Exec = true,
            R = 0,
            Fun_13 = fun Fun_13_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec, Finished_2, I_16, Max_3, Need_list, P, R, Remaining, Safe) ->
    case (R < erlang:length(Avail_4)) of
        true ->
            try
                case ((case erlang:is_map((case erlang:is_map(Need_list) of true -> maps:get(P, Need_list, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Need_list) + P + 1, Need_list); _ -> mochi_nth(P + 1, Need_list) end end)) of true -> maps:get(R, (case erlang:is_map(Need_list) of true -> maps:get(P, Need_list, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Need_list) + P + 1, Need_list); _ -> mochi_nth(P + 1, Need_list) end end), nil); _ -> case R < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Need_list) of true -> maps:get(P, Need_list, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Need_list) + P + 1, Need_list); _ -> mochi_nth(P + 1, Need_list) end end)) + R + 1, (case erlang:is_map(Need_list) of true -> maps:get(P, Need_list, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Need_list) + P + 1, Need_list); _ -> mochi_nth(P + 1, Need_list) end end)); _ -> mochi_nth(R + 1, (case erlang:is_map(Need_list) of true -> maps:get(P, Need_list, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Need_list) + P + 1, Need_list); _ -> mochi_nth(P + 1, Need_list) end end)) end end) > (case erlang:is_map(Avail_4) of true -> maps:get(R, Avail_4, nil); _ -> case R < 0 of true -> mochi_nth(erlang:length(Avail_4) + R + 1, Avail_4); _ -> mochi_nth(R + 1, Avail_4) end end)) of
        true -> Exec_2 = false,
            throw({break, Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec_2, Finished_2, I_16, Max_3, Need_list, P, R, Remaining, Safe}),
            Exec_3 = Exec_2;
        _ -> Exec_3 = Exec
    end,
                R_2 = (R + 1),
                Fun_13_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_2, Remaining, Safe)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12} -> Fun_13_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12}
            end;
        _ -> {Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec, Finished_2, I_16, Max_3, Need_list, P, R, Remaining, Safe}
    end
end,
{Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_2, Remaining, Safe} = Fun_13(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec, Finished_2, I_16, Max_3, Need_list, P, R, Remaining, Safe),
            case (Exec_3 /= nil) of
        true -> Safe_2 = true,
            io:format("~ts~n", [mochi_repr((("Process " ++ mochi_str((P + 1))) ++ " is executing."))]),
            R_3 = 0,
            Fun_14 = fun Fun_14_loop(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_3, Remaining, Safe_2) ->
    case (R_3 < erlang:length(Avail_4)) of
        true ->
            Avail_5 = lists:sublist(Avail_4, R_3) ++ [((case erlang:is_map(Avail_4) of true -> maps:get(R_3, Avail_4, nil); _ -> case R_3 < 0 of true -> mochi_nth(erlang:length(Avail_4) + R_3 + 1, Avail_4); _ -> mochi_nth(R_3 + 1, Avail_4) end end) + (case erlang:is_map((case erlang:is_map(Alloc_4) of true -> maps:get(P, Alloc_4, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Alloc_4) + P + 1, Alloc_4); _ -> mochi_nth(P + 1, Alloc_4) end end)) of true -> maps:get(R_3, (case erlang:is_map(Alloc_4) of true -> maps:get(P, Alloc_4, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Alloc_4) + P + 1, Alloc_4); _ -> mochi_nth(P + 1, Alloc_4) end end), nil); _ -> case R_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Alloc_4) of true -> maps:get(P, Alloc_4, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Alloc_4) + P + 1, Alloc_4); _ -> mochi_nth(P + 1, Alloc_4) end end)) + R_3 + 1, (case erlang:is_map(Alloc_4) of true -> maps:get(P, Alloc_4, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Alloc_4) + P + 1, Alloc_4); _ -> mochi_nth(P + 1, Alloc_4) end end)); _ -> mochi_nth(R_3 + 1, (case erlang:is_map(Alloc_4) of true -> maps:get(P, Alloc_4, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Alloc_4) + P + 1, Alloc_4); _ -> mochi_nth(P + 1, Alloc_4) end end)) end end))] ++ lists:nthtail(R_3 + 1, Avail_4),
            R_4 = (R_3 + 1),
            Fun_14_loop(Alloc_4, Alloc_sum_3, Avail_5, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_4, Remaining, Safe_2);
        _ -> {Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_3, Remaining, Safe_2}
    end
end,
{Alloc_4, Alloc_sum_3, Avail_5, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_4, Remaining, Safe_2} = Fun_14(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_3, Remaining, Safe_2),
            Avail_str_5 = "",
            R_5 = 0,
            Fun_15 = fun Fun_15_loop(Alloc_4, Alloc_sum_3, Avail_5, Avail_str_5, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_5, Remaining, Safe_2) ->
    case (R_5 < erlang:length(Avail_5)) of
        true ->
            case (R_5 > 0) of
        true -> Avail_str_6 = (Avail_str_5 ++ " "),
            Avail_str_7 = Avail_str_6;
        _ -> Avail_str_7 = Avail_str_5
    end,
            Avail_str_8 = (Avail_str_7 ++ mochi_str((case erlang:is_map(Avail_5) of true -> maps:get(R_5, Avail_5, nil); _ -> case R_5 < 0 of true -> mochi_nth(erlang:length(Avail_5) + R_5 + 1, Avail_5); _ -> mochi_nth(R_5 + 1, Avail_5) end end))),
            R_6 = (R_5 + 1),
            Fun_15_loop(Alloc_4, Alloc_sum_3, Avail_5, Avail_str_8, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_6, Remaining, Safe_2);
        _ -> {Alloc_4, Alloc_sum_3, Avail_5, Avail_str_5, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_5, Remaining, Safe_2}
    end
end,
{Alloc_4, Alloc_sum_3, Avail_5, Avail_str_8, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_6, Remaining, Safe_2} = Fun_15(Alloc_4, Alloc_sum_3, Avail_5, Avail_str_5, Claim_3, Exec_3, Finished_2, I_16, Max_3, Need_list, P, R_5, Remaining, Safe_2),
            io:format("~ts~n", [mochi_repr(("Updated available resource stack for processes: " ++ Avail_str_8))]),
            io:format("~ts~n", [mochi_repr("The process is in a safe state.")]),
            io:format("~ts~n", [mochi_repr("")]),
            Finished_3 = lists:sublist(Finished_2, P) ++ [true] ++ lists:nthtail(P + 1, Finished_2),
            Remaining_2 = (Remaining - 1),
            Avail_6 = Avail_5,
            Avail_str_9 = Avail_str_8,
            Finished_4 = Finished_3,
            Fun_16 = Fun_15,
            R_7 = R_6,
            Remaining_3 = Remaining_2,
            Safe_3 = Safe_2;
        _ -> Avail_6 = Avail_4,
            Avail_str_9 = nil,
            Finished_4 = Finished_2,
            Fun_16 = Fun_13,
            R_7 = R_2,
            Remaining_3 = Remaining,
            Safe_3 = Safe
    end,
            Avail_7 = Avail_6,
            Avail_str_10 = Avail_str_9,
            Exec_4 = Exec_3,
            Finished_5 = Finished_4,
            Fun_17 = Fun_16,
            R_8 = R_7,
            Remaining_4 = Remaining_3,
            Safe_4 = Safe_3;
        _ -> Avail_7 = Avail_4,
            Avail_str_10 = nil,
            Exec_4 = nil,
            Finished_5 = Finished_2,
            Fun_17 = Fun_12,
            R_8 = nil,
            Remaining_4 = Remaining,
            Safe_4 = Safe
    end,
                P_2 = (P + 1),
                Fun_18_loop(Alloc_4, Alloc_sum_3, Avail_7, Claim_3, Finished_5, I_16, Max_3, Need_list, P_2, Remaining_4, Safe_4)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_18_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10}
            end;
        _ -> {Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list, P, Remaining, Safe}
    end
end,
{Alloc_4, Alloc_sum_3, Avail_7, Claim_3, Finished_5, I_16, Max_3, Need_list, P_2, Remaining_4, Safe_4} = Fun_18(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list, P, Remaining, Safe),
                case mochi_not(Safe_4) of
        true -> io:format("~ts~n", [mochi_repr("System in unsafe state. Aborting...")]),
            io:format("~ts~n", [mochi_repr("")]),
            throw({break, Alloc_4, Alloc_sum_3, Avail_7, Claim_3, Finished_5, I_16, Max_3, Need_list, Remaining_4});
        _ -> ok
    end,
                Fun_19_loop(Alloc_4, Alloc_sum_3, Avail_7, Claim_3, Finished_5, I_16, Max_3, Need_list, Remaining_4)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_19_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8}
            end;
        _ -> {Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list, Remaining}
    end
end,
{Alloc_4, Alloc_sum_3, Avail_7, Claim_3, Finished_5, I_16, Max_3, Need_list, Remaining_4} = Fun_19(Alloc_4, Alloc_sum_3, Avail_4, Claim_3, Finished_2, I_16, Max_3, Need_list, Remaining),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('claim_vector', [8, 5, 9, 7]),
    erlang:put('allocated_resources_table', [[2, 0, 1, 1], [0, 1, 2, 1], [4, 0, 0, 3], [0, 2, 1, 0], [1, 0, 3, 0]]),
    erlang:put('maximum_claim_table', [[3, 2, 1, 4], [0, 2, 5, 2], [5, 1, 0, 5], [1, 5, 3, 0], [3, 0, 3, 3]]),
    pretty_print(erlang:get('claim_vector'), erlang:get('allocated_resources_table'), erlang:get('maximum_claim_table')),
    bankers_algorithm(erlang:get('claim_vector'), erlang:get('allocated_resources_table'), erlang:get('maximum_claim_table')),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
