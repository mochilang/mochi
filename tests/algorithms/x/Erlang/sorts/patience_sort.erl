#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, bisect_left/2, reverse_list/1, patience_sort/1]).

% Generated by Mochi transpiler v0.10.61 (a59522f233) on 2025-08-08 19:18 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

bisect_left(Stacks, Value) ->
    try
        Low = 0,
        High = erlang:length(Stacks),
        Fun = fun Fun_loop(High, Low, Stacks, Value) ->
    case (Low < High) of
        true ->
            Mid = ((Low + High) div 2),
            Stack = (case erlang:is_map(Stacks) of true -> maps:get(Mid, Stacks, nil); _ -> case Mid < 0 of true -> mochi_nth(erlang:length(Stacks) + Mid + 1, Stacks); _ -> mochi_nth(Mid + 1, Stacks) end end),
            Top_idx = (erlang:length(Stack) - 1),
            Top = (case erlang:is_map(Stack) of true -> maps:get(Top_idx, Stack, nil); _ -> case Top_idx < 0 of true -> mochi_nth(erlang:length(Stack) + Top_idx + 1, Stack); _ -> mochi_nth(Top_idx + 1, Stack) end end),
            case (Top < Value) of
        true -> Low_2 = (Mid + 1),
            High_3 = High,
            Low_3 = Low_2;
        _ -> High_2 = Mid,
            High_3 = High_2,
            Low_3 = Low
    end,
            Fun_loop(High_3, Low_3, Stacks, Value);
        _ -> {High, Low, Stacks, Value}
    end
end,
{High_3, Low_3, Stacks, Value} = Fun(High, Low, Stacks, Value),
        Low_3
    catch {return, RetCatch} -> RetCatch end.

reverse_list(Src) ->
    try
        Res = [],
        I = (erlang:length(Src) - 1),
        Fun_2 = fun Fun_2_loop(I, Res, Src) ->
    case (I >= 0) of
        true ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(case erlang:is_map(Src) of true -> maps:get(I, Src, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Src) + I + 1, Src); _ -> mochi_nth(I + 1, Src) end end)]),
            I_2 = (I - 1),
            Fun_2_loop(I_2, Res_2, Src);
        _ -> {I, Res, Src}
    end
end,
{I_2, Res_2, Src} = Fun_2(I, Res, Src),
        Res_2
    catch {return, RetCatch} -> RetCatch end.

patience_sort(Collection) ->
    try
        Stacks_2 = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Collection, I_3, Stacks_2) ->
    case (I_3 < erlang:length(Collection)) of
        true ->
            Element = (case erlang:is_map(Collection) of true -> maps:get(I_3, Collection, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Collection) + I_3 + 1, Collection); _ -> mochi_nth(I_3 + 1, Collection) end end),
            Idx = bisect_left(Stacks_2, Element),
            case (Idx /= erlang:length(Stacks_2)) of
        true -> Stack_2 = (case erlang:is_map(Stacks_2) of true -> maps:get(Idx, Stacks_2, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Stacks_2) + Idx + 1, Stacks_2); _ -> mochi_nth(Idx + 1, Stacks_2) end end),
            Stacks_3 = lists:sublist(Stacks_2, Idx) ++ [lists:append((case Stack_2 of nil -> []; _ -> Stack_2 end), [Element])] ++ lists:nthtail(Idx + 1, Stacks_2),
            New_stack_2 = nil,
            Stack_3 = Stack_2,
            Stacks_5 = Stacks_3;
        _ -> New_stack = [Element],
            Stacks_4 = lists:append((case Stacks_2 of nil -> []; _ -> Stacks_2 end), [New_stack]),
            New_stack_2 = New_stack,
            Stack_3 = nil,
            Stacks_5 = Stacks_4
    end,
            I_4 = (I_3 + 1),
            Fun_3_loop(Collection, I_4, Stacks_5);
        _ -> {Collection, I_3, Stacks_2}
    end
end,
{Collection, I_4, Stacks_5} = Fun_3(Collection, I_3, Stacks_2),
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(Collection, I_5, Stacks_5) ->
    case (I_5 < erlang:length(Stacks_5)) of
        true ->
            Stacks_6 = lists:sublist(Stacks_5, I_5) ++ [reverse_list((case erlang:is_map(Stacks_5) of true -> maps:get(I_5, Stacks_5, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Stacks_5) + I_5 + 1, Stacks_5); _ -> mochi_nth(I_5 + 1, Stacks_5) end end))] ++ lists:nthtail(I_5 + 1, Stacks_5),
            I_6 = (I_5 + 1),
            Fun_4_loop(Collection, I_6, Stacks_6);
        _ -> {Collection, I_5, Stacks_5}
    end
end,
{Collection, I_6, Stacks_6} = Fun_4(Collection, I_5, Stacks_5),
        Indices = [],
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(Collection, I_7, Indices, Stacks_6) ->
    case (I_7 < erlang:length(Stacks_6)) of
        true ->
            Indices_2 = lists:append((case Indices of nil -> []; _ -> Indices end), [0]),
            I_8 = (I_7 + 1),
            Fun_5_loop(Collection, I_8, Indices_2, Stacks_6);
        _ -> {Collection, I_7, Indices, Stacks_6}
    end
end,
{Collection, I_8, Indices_2, Stacks_6} = Fun_5(Collection, I_7, Indices, Stacks_6),
        Total = 0,
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(Collection, I_9, Indices_2, Stacks_6, Total) ->
    case (I_9 < erlang:length(Stacks_6)) of
        true ->
            Total_2 = (Total + erlang:length((case erlang:is_map(Stacks_6) of true -> maps:get(I_9, Stacks_6, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Stacks_6) + I_9 + 1, Stacks_6); _ -> mochi_nth(I_9 + 1, Stacks_6) end end))),
            I_10 = (I_9 + 1),
            Fun_6_loop(Collection, I_10, Indices_2, Stacks_6, Total_2);
        _ -> {Collection, I_9, Indices_2, Stacks_6, Total}
    end
end,
{Collection, I_10, Indices_2, Stacks_6, Total_2} = Fun_6(Collection, I_9, Indices_2, Stacks_6, Total),
        Result = [],
        Count = 0,
        Fun_8 = fun Fun_8_loop(Collection, Count, I_10, Indices_2, Result, Stacks_6, Total_2) ->
    case (Count < Total_2) of
        true ->
            Min_val = 0,
            Min_stack = -1,
            J = 0,
            Fun_7 = fun Fun_7_loop(Collection, Count, I_10, Indices_2, J, Min_stack, Min_val, Result, Stacks_6, Total_2) ->
    case (J < erlang:length(Stacks_6)) of
        true ->
            Idx_2 = (case erlang:is_map(Indices_2) of true -> maps:get(J, Indices_2, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Indices_2) + J + 1, Indices_2); _ -> mochi_nth(J + 1, Indices_2) end end),
            case (Idx_2 < erlang:length((case erlang:is_map(Stacks_6) of true -> maps:get(J, Stacks_6, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Stacks_6) + J + 1, Stacks_6); _ -> mochi_nth(J + 1, Stacks_6) end end))) of
        true -> Val = (case erlang:is_map((case erlang:is_map(Stacks_6) of true -> maps:get(J, Stacks_6, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Stacks_6) + J + 1, Stacks_6); _ -> mochi_nth(J + 1, Stacks_6) end end)) of true -> maps:get(Idx_2, (case erlang:is_map(Stacks_6) of true -> maps:get(J, Stacks_6, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Stacks_6) + J + 1, Stacks_6); _ -> mochi_nth(J + 1, Stacks_6) end end), nil); _ -> case Idx_2 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Stacks_6) of true -> maps:get(J, Stacks_6, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Stacks_6) + J + 1, Stacks_6); _ -> mochi_nth(J + 1, Stacks_6) end end)) + Idx_2 + 1, (case erlang:is_map(Stacks_6) of true -> maps:get(J, Stacks_6, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Stacks_6) + J + 1, Stacks_6); _ -> mochi_nth(J + 1, Stacks_6) end end)); _ -> mochi_nth(Idx_2 + 1, (case erlang:is_map(Stacks_6) of true -> maps:get(J, Stacks_6, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Stacks_6) + J + 1, Stacks_6); _ -> mochi_nth(J + 1, Stacks_6) end end)) end end),
            case (Min_stack < 0) of
        true -> Min_val_2 = Val,
            Min_stack_2 = J,
            Min_stack_5 = Min_stack_2,
            Min_val_5 = Min_val_2;
        _ -> case (Val < Min_val) of
        true -> Min_val_3 = Val,
            Min_stack_3 = J,
            Min_stack_4 = Min_stack_3,
            Min_val_4 = Min_val_3;
        _ -> Min_stack_4 = Min_stack,
            Min_val_4 = Min_val
    end,
            Min_stack_5 = Min_stack_4,
            Min_val_5 = Min_val_4
    end,
            Min_stack_6 = Min_stack_5,
            Min_val_6 = Min_val_5,
            Val_2 = Val;
        _ -> Min_stack_6 = Min_stack,
            Min_val_6 = Min_val,
            Val_2 = nil
    end,
            J_2 = (J + 1),
            Fun_7_loop(Collection, Count, I_10, Indices_2, J_2, Min_stack_6, Min_val_6, Result, Stacks_6, Total_2);
        _ -> {Collection, Count, I_10, Indices_2, J, Min_stack, Min_val, Result, Stacks_6, Total_2}
    end
end,
{Collection, Count, I_10, Indices_2, J_2, Min_stack_6, Min_val_6, Result, Stacks_6, Total_2} = Fun_7(Collection, Count, I_10, Indices_2, J, Min_stack, Min_val, Result, Stacks_6, Total_2),
            Result_2 = lists:append((case Result of nil -> []; _ -> Result end), [Min_val_6]),
            Indices_3 = lists:sublist(Indices_2, Min_stack_6) ++ [((case erlang:is_map(Indices_2) of true -> maps:get(Min_stack_6, Indices_2, nil); _ -> case Min_stack_6 < 0 of true -> mochi_nth(erlang:length(Indices_2) + Min_stack_6 + 1, Indices_2); _ -> mochi_nth(Min_stack_6 + 1, Indices_2) end end) + 1)] ++ lists:nthtail(Min_stack_6 + 1, Indices_2),
            Count_2 = (Count + 1),
            Fun_8_loop(Collection, Count_2, I_10, Indices_3, Result_2, Stacks_6, Total_2);
        _ -> {Collection, Count, I_10, Indices_2, Result, Stacks_6, Total_2}
    end
end,
{Collection, Count_2, I_10, Indices_3, Result_2, Stacks_6, Total_2} = Fun_8(Collection, Count, I_10, Indices_2, Result, Stacks_6, Total_2),
        I_11 = 0,
        Fun_9 = fun Fun_9_loop(Collection, Count_2, I_11, Indices_3, Result_2, Stacks_6, Total_2) ->
    case (I_11 < erlang:length(Result_2)) of
        true ->
            Collection_2 = lists:sublist(Collection, I_11) ++ [(case erlang:is_map(Result_2) of true -> maps:get(I_11, Result_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Result_2) + I_11 + 1, Result_2); _ -> mochi_nth(I_11 + 1, Result_2) end end)] ++ lists:nthtail(I_11 + 1, Collection),
            I_12 = (I_11 + 1),
            Fun_9_loop(Collection_2, Count_2, I_12, Indices_3, Result_2, Stacks_6, Total_2);
        _ -> {Collection, Count_2, I_11, Indices_3, Result_2, Stacks_6, Total_2}
    end
end,
{Collection_2, Count_2, I_12, Indices_3, Result_2, Stacks_6, Total_2} = Fun_9(Collection, Count_2, I_11, Indices_3, Result_2, Stacks_6, Total_2),
        Collection_2
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    io:format("~ts~n", [mochi_str(patience_sort([1, 9, 5, 21, 17, 6]))]),
    io:format("~ts~n", [mochi_str(patience_sort([]))]),
    io:format("~ts~n", [mochi_str(patience_sort([-3, -17, -48]))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
