#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, make_process/3, make_mlfq/4, calculate_sequence_of_finish_queue/1, calculate_waiting_time/1, calculate_turnaround_time/1, calculate_completion_time/1, calculate_remaining_burst_time_of_processes/1, update_waiting_time/2, first_come_first_served/2, round_robin/3, multi_level_feedback_queue/1]).

% Generated by Mochi transpiler v0.10.63 (d654e04ebb) on 2025-08-11 16:20 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

make_process(Name, Arrival, Burst) ->
    try
        #{"process_name" => Name, "arrival_time" => Arrival, "stop_time" => Arrival, "burst_time" => Burst, "waiting_time" => 0, "turnaround_time" => 0}
    catch {return, RetCatch} -> RetCatch end.

make_mlfq(Nqueues, Time_slices, Queue, Current_time) ->
    try
        #{"number_of_queues" => Nqueues, "time_slices" => Time_slices, "ready_queue" => Queue, "current_time" => Current_time, "finish_queue" => []}
    catch {return, RetCatch} -> RetCatch end.

calculate_sequence_of_finish_queue(Mlfq) ->
    try
        Seq = [],
        I = 0,
        Fun = fun Fun_loop(I, Mlfq, Seq) ->
    case (I < erlang:length(maps:get("finish_queue", Mlfq, nil))) of
        true ->
            P = (case erlang:is_map(maps:get("finish_queue", Mlfq, nil)) of true -> maps:get(I, maps:get("finish_queue", Mlfq, nil), nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(maps:get("finish_queue", Mlfq, nil)) + I + 1, maps:get("finish_queue", Mlfq, nil)); _ -> mochi_nth(I + 1, maps:get("finish_queue", Mlfq, nil)) end end),
            Seq_2 = lists:append((case Seq of nil -> []; _ -> Seq end), [maps:get("process_name", P, nil)]),
            I_2 = (I + 1),
            Fun_loop(I_2, Mlfq, Seq_2);
        _ -> {I, Mlfq, Seq}
    end
end,
{I_2, Mlfq, Seq_2} = Fun(I, Mlfq, Seq),
        Seq_2
    catch {return, RetCatch} -> RetCatch end.

calculate_waiting_time(Queue_2) ->
    try
        Times = [],
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Queue_2, Times) ->
    case (I_3 < erlang:length(Queue_2)) of
        true ->
            P_2 = (case erlang:is_map(Queue_2) of true -> maps:get(I_3, Queue_2, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Queue_2) + I_3 + 1, Queue_2); _ -> mochi_nth(I_3 + 1, Queue_2) end end),
            Times_2 = lists:append((case Times of nil -> []; _ -> Times end), [maps:get("waiting_time", P_2, nil)]),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Queue_2, Times_2);
        _ -> {I_3, Queue_2, Times}
    end
end,
{I_4, Queue_2, Times_2} = Fun_2(I_3, Queue_2, Times),
        Times_2
    catch {return, RetCatch} -> RetCatch end.

calculate_turnaround_time(Queue_3) ->
    try
        Times_3 = [],
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Queue_3, Times_3) ->
    case (I_5 < erlang:length(Queue_3)) of
        true ->
            P_3 = (case erlang:is_map(Queue_3) of true -> maps:get(I_5, Queue_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Queue_3) + I_5 + 1, Queue_3); _ -> mochi_nth(I_5 + 1, Queue_3) end end),
            Times_4 = lists:append((case Times_3 of nil -> []; _ -> Times_3 end), [maps:get("turnaround_time", P_3, nil)]),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Queue_3, Times_4);
        _ -> {I_5, Queue_3, Times_3}
    end
end,
{I_6, Queue_3, Times_4} = Fun_3(I_5, Queue_3, Times_3),
        Times_4
    catch {return, RetCatch} -> RetCatch end.

calculate_completion_time(Queue_4) ->
    try
        Times_5 = [],
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(I_7, Queue_4, Times_5) ->
    case (I_7 < erlang:length(Queue_4)) of
        true ->
            P_4 = (case erlang:is_map(Queue_4) of true -> maps:get(I_7, Queue_4, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Queue_4) + I_7 + 1, Queue_4); _ -> mochi_nth(I_7 + 1, Queue_4) end end),
            Times_6 = lists:append((case Times_5 of nil -> []; _ -> Times_5 end), [maps:get("stop_time", P_4, nil)]),
            I_8 = (I_7 + 1),
            Fun_4_loop(I_8, Queue_4, Times_6);
        _ -> {I_7, Queue_4, Times_5}
    end
end,
{I_8, Queue_4, Times_6} = Fun_4(I_7, Queue_4, Times_5),
        Times_6
    catch {return, RetCatch} -> RetCatch end.

calculate_remaining_burst_time_of_processes(Queue_5) ->
    try
        Times_7 = [],
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(I_9, Queue_5, Times_7) ->
    case (I_9 < erlang:length(Queue_5)) of
        true ->
            P_5 = (case erlang:is_map(Queue_5) of true -> maps:get(I_9, Queue_5, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Queue_5) + I_9 + 1, Queue_5); _ -> mochi_nth(I_9 + 1, Queue_5) end end),
            Times_8 = lists:append((case Times_7 of nil -> []; _ -> Times_7 end), [maps:get("burst_time", P_5, nil)]),
            I_10 = (I_9 + 1),
            Fun_5_loop(I_10, Queue_5, Times_8);
        _ -> {I_9, Queue_5, Times_7}
    end
end,
{I_10, Queue_5, Times_8} = Fun_5(I_9, Queue_5, Times_7),
        Times_8
    catch {return, RetCatch} -> RetCatch end.

update_waiting_time(Mlfq_2, Process) ->
    try
        Process_2 = maps:put("waiting_time", (maps:get("waiting_time", Process, nil) + (maps:get("current_time", Mlfq_2, nil) - maps:get("stop_time", Process, nil))), Process),
        maps:get("waiting_time", Process_2, nil)
    catch {return, RetCatch} -> RetCatch end.

first_come_first_served(Mlfq_3, Ready_queue) ->
    try
        Finished = [],
        Rq = Ready_queue,
        Fun_6 = fun Fun_6_loop(Finished, Mlfq_3, Ready_queue, Rq) ->
    case (erlang:length(Rq) /= 0) of
        true ->
            Cp = (case erlang:is_map(Rq) of true -> maps:get(0, Rq, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Rq) + 0 + 1, Rq); _ -> mochi_nth(0 + 1, Rq) end end),
            Rq_2 = (case erlang:is_binary(Rq) of true -> string:substr(Rq, 1 + 1, (erlang:length(Rq) - 1)); _ -> lists:sublist(Rq, (1 + 1), (erlang:length(Rq) - 1)) end),
            case (maps:get("current_time", Mlfq_3, nil) < maps:get("arrival_time", Cp, nil)) of
        true -> Mlfq_4 = maps:put("current_time", maps:get("arrival_time", Cp, nil), Mlfq_3),
            Mlfq_5 = Mlfq_4;
        _ -> Mlfq_5 = Mlfq_3
    end,
            update_waiting_time(Mlfq_5, Cp),
            Mlfq_6 = maps:put("current_time", (maps:get("current_time", Mlfq_5, nil) + maps:get("burst_time", Cp, nil)), Mlfq_5),
            Cp_2 = maps:put("burst_time", 0, Cp),
            Cp_3 = maps:put("turnaround_time", (maps:get("current_time", Mlfq_6, nil) - maps:get("arrival_time", Cp_2, nil)), Cp_2),
            Cp_4 = maps:put("stop_time", maps:get("current_time", Mlfq_6, nil), Cp_3),
            Finished_2 = lists:append((case Finished of nil -> []; _ -> Finished end), [Cp_4]),
            Fun_6_loop(Finished_2, Mlfq_6, Ready_queue, Rq_2);
        _ -> {Finished, Mlfq_3, Ready_queue, Rq}
    end
end,
{Finished_2, Mlfq_6, Ready_queue, Rq_2} = Fun_6(Finished, Mlfq_3, Ready_queue, Rq),
        Mlfq_7 = maps:put("finish_queue", lists:append(maps:get("finish_queue", Mlfq_6, nil), Finished_2), Mlfq_6),
        Finished_2
    catch {return, RetCatch} -> RetCatch end.

round_robin(Mlfq_8, Ready_queue_2, Time_slice) ->
    try
        Finished_3 = [],
        Rq_3 = Ready_queue_2,
        Count = erlang:length(Rq_3),
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(Count, Finished_3, I_11, Mlfq_8, Ready_queue_2, Rq_3, Time_slice) ->
    case (I_11 < Count) of
        true ->
            Cp_5 = (case erlang:is_map(Rq_3) of true -> maps:get(0, Rq_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Rq_3) + 0 + 1, Rq_3); _ -> mochi_nth(0 + 1, Rq_3) end end),
            Rq_4 = (case erlang:is_binary(Rq_3) of true -> string:substr(Rq_3, 1 + 1, (erlang:length(Rq_3) - 1)); _ -> lists:sublist(Rq_3, (1 + 1), (erlang:length(Rq_3) - 1)) end),
            case (maps:get("current_time", Mlfq_8, nil) < maps:get("arrival_time", Cp_5, nil)) of
        true -> Mlfq_9 = maps:put("current_time", maps:get("arrival_time", Cp_5, nil), Mlfq_8),
            Mlfq_10 = Mlfq_9;
        _ -> Mlfq_10 = Mlfq_8
    end,
            update_waiting_time(Mlfq_10, Cp_5),
            case (maps:get("burst_time", Cp_5, nil) > Time_slice) of
        true -> Mlfq_11 = maps:put("current_time", (maps:get("current_time", Mlfq_10, nil) + Time_slice), Mlfq_10),
            Cp_6 = maps:put("burst_time", (maps:get("burst_time", Cp_5, nil) - Time_slice), Cp_5),
            Cp_7 = maps:put("stop_time", maps:get("current_time", Mlfq_11, nil), Cp_6),
            Rq_5 = lists:append((case Rq_4 of nil -> []; _ -> Rq_4 end), [Cp_7]),
            Cp_11 = Cp_7,
            Finished_5 = Finished_3,
            Mlfq_13 = Mlfq_11,
            Rq_6 = Rq_5;
        _ -> Mlfq_12 = maps:put("current_time", (maps:get("current_time", Mlfq_10, nil) + maps:get("burst_time", Cp_5, nil)), Mlfq_10),
            Cp_8 = maps:put("burst_time", 0, Cp_5),
            Cp_9 = maps:put("stop_time", maps:get("current_time", Mlfq_12, nil), Cp_8),
            Cp_10 = maps:put("turnaround_time", (maps:get("current_time", Mlfq_12, nil) - maps:get("arrival_time", Cp_9, nil)), Cp_9),
            Finished_4 = lists:append((case Finished_3 of nil -> []; _ -> Finished_3 end), [Cp_10]),
            Cp_11 = Cp_10,
            Finished_5 = Finished_4,
            Mlfq_13 = Mlfq_12,
            Rq_6 = Rq_4
    end,
            I_12 = (I_11 + 1),
            Fun_7_loop(Count, Finished_5, I_12, Mlfq_13, Ready_queue_2, Rq_6, Time_slice);
        _ -> {Count, Finished_3, I_11, Mlfq_8, Ready_queue_2, Rq_3, Time_slice}
    end
end,
{Count, Finished_5, I_12, Mlfq_13, Ready_queue_2, Rq_6, Time_slice} = Fun_7(Count, Finished_3, I_11, Mlfq_8, Ready_queue_2, Rq_3, Time_slice),
        Mlfq_14 = maps:put("finish_queue", lists:append(maps:get("finish_queue", Mlfq_13, nil), Finished_5), Mlfq_13),
        #{"finished" => Finished_5, "ready" => Rq_6}
    catch {return, RetCatch} -> RetCatch end.

multi_level_feedback_queue(Mlfq_15) ->
    try
        I_13 = 0,
        Fun_8 = fun Fun_8_loop(I_13, Mlfq_15) ->
    case (I_13 < (maps:get("number_of_queues", Mlfq_15, nil) - 1)) of
        true ->
            Rr = round_robin(Mlfq_15, maps:get("ready_queue", Mlfq_15, nil), (case erlang:is_map(maps:get("time_slices", Mlfq_15, nil)) of true -> maps:get(I_13, maps:get("time_slices", Mlfq_15, nil), nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(maps:get("time_slices", Mlfq_15, nil)) + I_13 + 1, maps:get("time_slices", Mlfq_15, nil)); _ -> mochi_nth(I_13 + 1, maps:get("time_slices", Mlfq_15, nil)) end end)),
            Mlfq_16 = maps:put("ready_queue", maps:get("ready", Rr, nil), Mlfq_15),
            I_14 = (I_13 + 1),
            Fun_8_loop(I_14, Mlfq_16);
        _ -> {I_13, Mlfq_15}
    end
end,
{I_14, Mlfq_16} = Fun_8(I_13, Mlfq_15),
        first_come_first_served(Mlfq_16, maps:get("ready_queue", Mlfq_16, nil)),
        maps:get("finish_queue", Mlfq_16, nil)
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('P1', make_process("P1", 0, 53)),
    erlang:put('P2', make_process("P2", 0, 17)),
    erlang:put('P3', make_process("P3", 0, 68)),
    erlang:put('P4', make_process("P4", 0, 24)),
    erlang:put('number_of_queues', 3),
    erlang:put('time_slices', [17, 25]),
    erlang:put('queue', [erlang:get('P1'), erlang:get('P2'), erlang:get('P3'), erlang:get('P4')]),
    erlang:put('mlfq', make_mlfq(3, erlang:get('time_slices'), erlang:get('queue'), 0)),
    erlang:put('finish_queue', multi_level_feedback_queue(erlang:get('mlfq'))),
    io:format("~ts~n", [mochi_repr(("waiting time:\t\t\t" ++ mochi_str(calculate_waiting_time([erlang:get('P1'), erlang:get('P2'), erlang:get('P3'), erlang:get('P4')]))))]),
    io:format("~ts~n", [mochi_repr(("completion time:\t\t" ++ mochi_str(calculate_completion_time([erlang:get('P1'), erlang:get('P2'), erlang:get('P3'), erlang:get('P4')]))))]),
    io:format("~ts~n", [mochi_repr(("turnaround time:\t\t" ++ mochi_str(calculate_turnaround_time([erlang:get('P1'), erlang:get('P2'), erlang:get('P3'), erlang:get('P4')]))))]),
    io:format("~ts~n", [mochi_repr(("sequence of finished processes:\t" ++ mochi_str(calculate_sequence_of_finish_queue(erlang:get('mlfq')))))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
