#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, min3/3, helper_top_down/5, min_dist_top_down/2, min_dist_bottom_up/2]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

min3(A, B, C) ->
    try
        M = A,
        case (B < M) of
        true -> M_2 = B,
            M_3 = M_2;
        _ -> M_3 = M
    end,
        case (C < M_3) of
        true -> M_4 = C,
            M_5 = M_4;
        _ -> M_5 = M_3
    end,
        M_5
    catch {return, Ret} -> Ret end.

helper_top_down(Word1, Word2, Dp, I, J) ->
    try
        case (I < 0) of
        true -> throw({return, (J + 1)});
        _ -> ok
    end,
        case (J < 0) of
        true -> throw({return, (I + 1)});
        _ -> ok
    end,
        case ((case erlang:is_map((case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)) of true -> maps:get(J, (case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end), nil); _ -> case J < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)) + J + 1, (case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)); _ -> lists:nth(J + 1, (case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)) end end) /= (0 - 1)) of
        true -> throw({return, (case erlang:is_map((case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)) of true -> maps:get(J, (case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end), nil); _ -> case J < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)) + J + 1, (case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)); _ -> lists:nth(J + 1, (case erlang:is_map(Dp) of true -> maps:get(I, Dp, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp) + I + 1, Dp); _ -> lists:nth(I + 1, Dp) end end)) end end)});
        _ -> ok
    end,
        case (string:substr(Word1, I + 1, ((I + 1) - I)) == string:substr(Word2, J + 1, ((J + 1) - J))) of
        true -> Dp_2 = lists:sublist(Dp, I) ++ [lists:sublist(lists:nth(I + 1, Dp), J) ++ [helper_top_down(Word1, Word2, Dp, (I - 1), (J - 1))] ++ lists:nthtail(J + 1, lists:nth(I + 1, Dp))] ++ lists:nthtail(I + 1, Dp),
            Delete_2 = nil,
            Dp_4 = Dp_2,
            Insert_2 = nil,
            Replace_2 = nil;
        _ -> Insert = helper_top_down(Word1, Word2, Dp, I, (J - 1)),
            Delete = helper_top_down(Word1, Word2, Dp, (I - 1), J),
            Replace = helper_top_down(Word1, Word2, Dp, (I - 1), (J - 1)),
            Dp_3 = lists:sublist(Dp, I) ++ [lists:sublist(lists:nth(I + 1, Dp), J) ++ [(1 + min3(Insert, Delete, Replace))] ++ lists:nthtail(J + 1, lists:nth(I + 1, Dp))] ++ lists:nthtail(I + 1, Dp),
            Delete_2 = Delete,
            Dp_4 = Dp_3,
            Insert_2 = Insert,
            Replace_2 = Replace
    end,
        (case erlang:is_map((case erlang:is_map(Dp_4) of true -> maps:get(I, Dp_4, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp_4) + I + 1, Dp_4); _ -> lists:nth(I + 1, Dp_4) end end)) of true -> maps:get(J, (case erlang:is_map(Dp_4) of true -> maps:get(I, Dp_4, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp_4) + I + 1, Dp_4); _ -> lists:nth(I + 1, Dp_4) end end), nil); _ -> case J < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_4) of true -> maps:get(I, Dp_4, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp_4) + I + 1, Dp_4); _ -> lists:nth(I + 1, Dp_4) end end)) + J + 1, (case erlang:is_map(Dp_4) of true -> maps:get(I, Dp_4, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp_4) + I + 1, Dp_4); _ -> lists:nth(I + 1, Dp_4) end end)); _ -> lists:nth(J + 1, (case erlang:is_map(Dp_4) of true -> maps:get(I, Dp_4, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Dp_4) + I + 1, Dp_4); _ -> lists:nth(I + 1, Dp_4) end end)) end end)
    catch {return, Ret} -> Ret end.

min_dist_top_down(Word1_2, Word2_2) ->
    try
        M_6 = erlang:length(Word1_2),
        N = erlang:length(Word2_2),
        Dp_5 = [],
        Fun = fun Fun_loop(List, Dp_5, M_6, N, Word1_2, Word2_2) ->
    case List of
        [] -> {Dp_5, M_6, N, Word1_2, Word2_2};
        [_|__rest] ->
            Row = [],
            Fun_2 = fun Fun_2_loop(List, Dp_5, M_6, N, Row, Word1_2, Word2_2) ->
    case List of
        [] -> {Dp_5, M_6, N, Row, Word1_2, Word2_2};
        [_2|_2_rest] ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [(0 - 1)]),
            Fun_2_loop(_2_rest, Dp_5, M_6, N, Row_2, Word1_2, Word2_2);
        _ -> {Dp_5, M_6, N, Row, Word1_2, Word2_2}
    end
end,
{Dp_5, M_6, N, Row_2, Word1_2, Word2_2} = Fun_2(lists:seq(0, (N) - 1), Dp_5, M_6, N, Row, Word1_2, Word2_2),
            Dp_6 = lists:append((case Dp_5 of nil -> []; _ -> Dp_5 end), [Row_2]),
            Fun_loop(__rest, Dp_6, M_6, N, Word1_2, Word2_2);
        _ -> {Dp_5, M_6, N, Word1_2, Word2_2}
    end
end,
{Dp_6, M_6, N, Word1_2, Word2_2} = Fun(lists:seq(0, (M_6) - 1), Dp_5, M_6, N, Word1_2, Word2_2),
        helper_top_down(Word1_2, Word2_2, Dp_6, (M_6 - 1), (N - 1))
    catch {return, Ret} -> Ret end.

min_dist_bottom_up(Word1_3, Word2_3) ->
    try
        M_7 = erlang:length(Word1_3),
        N_2 = erlang:length(Word2_3),
        Dp_7 = [],
        Fun_3 = fun Fun_3_loop(List, Dp_7, M_7, N_2, Word1_3, Word2_3) ->
    case List of
        [] -> {Dp_7, M_7, N_2, Word1_3, Word2_3};
        [_|__rest] ->
            Row_3 = [],
            Fun_4 = fun Fun_4_loop(List, Dp_7, M_7, N_2, Row_3, Word1_3, Word2_3) ->
    case List of
        [] -> {Dp_7, M_7, N_2, Row_3, Word1_3, Word2_3};
        [_2_2|_2_2_rest] ->
            Row_4 = lists:append((case Row_3 of nil -> []; _ -> Row_3 end), [0]),
            Fun_4_loop(_2_2_rest, Dp_7, M_7, N_2, Row_4, Word1_3, Word2_3);
        _ -> {Dp_7, M_7, N_2, Row_3, Word1_3, Word2_3}
    end
end,
{Dp_7, M_7, N_2, Row_4, Word1_3, Word2_3} = Fun_4(lists:seq(0, ((N_2 + 1)) - 1), Dp_7, M_7, N_2, Row_3, Word1_3, Word2_3),
            Dp_8 = lists:append((case Dp_7 of nil -> []; _ -> Dp_7 end), [Row_4]),
            Fun_3_loop(__rest, Dp_8, M_7, N_2, Word1_3, Word2_3);
        _ -> {Dp_7, M_7, N_2, Word1_3, Word2_3}
    end
end,
{Dp_8, M_7, N_2, Word1_3, Word2_3} = Fun_3(lists:seq(0, ((M_7 + 1)) - 1), Dp_7, M_7, N_2, Word1_3, Word2_3),
        Fun_5 = fun Fun_5_loop(List, Dp_8, M_7, N_2, Word1_3, Word2_3) ->
    case List of
        [] -> {Dp_8, M_7, N_2, Word1_3, Word2_3};
        [I_2|I_2_rest] ->
            Fun_6 = fun Fun_6_loop(List, Dp_8, I_2, M_7, N_2, Word1_3, Word2_3) ->
    case List of
        [] -> {Dp_8, I_2, M_7, N_2, Word1_3, Word2_3};
        [J_2|J_2_rest] ->
            case (I_2 == 0) of
        true -> Dp_9 = lists:sublist(Dp_8, I_2) ++ [lists:sublist(lists:nth(I_2 + 1, Dp_8), J_2) ++ [J_2] ++ lists:nthtail(J_2 + 1, lists:nth(I_2 + 1, Dp_8))] ++ lists:nthtail(I_2 + 1, Dp_8),
            Delete_6 = nil,
            Dp_15 = Dp_9,
            Insert_6 = nil,
            Replace_6 = nil;
        _ -> case (J_2 == 0) of
        true -> Dp_10 = lists:sublist(Dp_8, I_2) ++ [lists:sublist(lists:nth(I_2 + 1, Dp_8), J_2) ++ [I_2] ++ lists:nthtail(J_2 + 1, lists:nth(I_2 + 1, Dp_8))] ++ lists:nthtail(I_2 + 1, Dp_8),
            Delete_5 = nil,
            Dp_14 = Dp_10,
            Insert_5 = nil,
            Replace_5 = nil;
        _ -> case (string:substr(Word1_3, (I_2 - 1) + 1, (I_2 - (I_2 - 1))) == string:substr(Word2_3, (J_2 - 1) + 1, (J_2 - (J_2 - 1)))) of
        true -> Dp_11 = lists:sublist(Dp_8, I_2) ++ [lists:sublist(lists:nth(I_2 + 1, Dp_8), J_2) ++ [(case erlang:is_map((case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) of true -> maps:get((J_2 - 1), (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end), nil); _ -> case (J_2 - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) + (J_2 - 1) + 1, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)); _ -> lists:nth((J_2 - 1) + 1, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) end end)] ++ lists:nthtail(J_2 + 1, lists:nth(I_2 + 1, Dp_8))] ++ lists:nthtail(I_2 + 1, Dp_8),
            Delete_4 = nil,
            Dp_13 = Dp_11,
            Insert_4 = nil,
            Replace_4 = nil;
        _ -> Insert_3 = (case erlang:is_map((case erlang:is_map(Dp_8) of true -> maps:get(I_2, Dp_8, nil); _ -> case I_2 < 0 of true -> lists:nth(erlang:length(Dp_8) + I_2 + 1, Dp_8); _ -> lists:nth(I_2 + 1, Dp_8) end end)) of true -> maps:get((J_2 - 1), (case erlang:is_map(Dp_8) of true -> maps:get(I_2, Dp_8, nil); _ -> case I_2 < 0 of true -> lists:nth(erlang:length(Dp_8) + I_2 + 1, Dp_8); _ -> lists:nth(I_2 + 1, Dp_8) end end), nil); _ -> case (J_2 - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_8) of true -> maps:get(I_2, Dp_8, nil); _ -> case I_2 < 0 of true -> lists:nth(erlang:length(Dp_8) + I_2 + 1, Dp_8); _ -> lists:nth(I_2 + 1, Dp_8) end end)) + (J_2 - 1) + 1, (case erlang:is_map(Dp_8) of true -> maps:get(I_2, Dp_8, nil); _ -> case I_2 < 0 of true -> lists:nth(erlang:length(Dp_8) + I_2 + 1, Dp_8); _ -> lists:nth(I_2 + 1, Dp_8) end end)); _ -> lists:nth((J_2 - 1) + 1, (case erlang:is_map(Dp_8) of true -> maps:get(I_2, Dp_8, nil); _ -> case I_2 < 0 of true -> lists:nth(erlang:length(Dp_8) + I_2 + 1, Dp_8); _ -> lists:nth(I_2 + 1, Dp_8) end end)) end end),
            Delete_3 = (case erlang:is_map((case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) of true -> maps:get(J_2, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end), nil); _ -> case J_2 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) + J_2 + 1, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)); _ -> lists:nth(J_2 + 1, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) end end),
            Replace_3 = (case erlang:is_map((case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) of true -> maps:get((J_2 - 1), (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end), nil); _ -> case (J_2 - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) + (J_2 - 1) + 1, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)); _ -> lists:nth((J_2 - 1) + 1, (case erlang:is_map(Dp_8) of true -> maps:get((I_2 - 1), Dp_8, nil); _ -> case (I_2 - 1) < 0 of true -> lists:nth(erlang:length(Dp_8) + (I_2 - 1) + 1, Dp_8); _ -> lists:nth((I_2 - 1) + 1, Dp_8) end end)) end end),
            Dp_12 = lists:sublist(Dp_8, I_2) ++ [lists:sublist(lists:nth(I_2 + 1, Dp_8), J_2) ++ [(1 + min3(Insert_3, Delete_3, Replace_3))] ++ lists:nthtail(J_2 + 1, lists:nth(I_2 + 1, Dp_8))] ++ lists:nthtail(I_2 + 1, Dp_8),
            Delete_4 = Delete_3,
            Dp_13 = Dp_12,
            Insert_4 = Insert_3,
            Replace_4 = Replace_3
    end,
            Delete_5 = Delete_4,
            Dp_14 = Dp_13,
            Insert_5 = Insert_4,
            Replace_5 = Replace_4
    end,
            Delete_6 = Delete_5,
            Dp_15 = Dp_14,
            Insert_6 = Insert_5,
            Replace_6 = Replace_5
    end,
            Fun_6_loop(J_2_rest, Dp_15, I_2, M_7, N_2, Word1_3, Word2_3);
        _ -> {Dp_8, I_2, M_7, N_2, Word1_3, Word2_3}
    end
end,
{Dp_15, I_2, M_7, N_2, Word1_3, Word2_3} = Fun_6(lists:seq(0, ((N_2 + 1)) - 1), Dp_8, I_2, M_7, N_2, Word1_3, Word2_3),
            Fun_5_loop(I_2_rest, Dp_15, M_7, N_2, Word1_3, Word2_3);
        _ -> {Dp_8, M_7, N_2, Word1_3, Word2_3}
    end
end,
{Dp_15, M_7, N_2, Word1_3, Word2_3} = Fun_5(lists:seq(0, ((M_7 + 1)) - 1), Dp_8, M_7, N_2, Word1_3, Word2_3),
        (case erlang:is_map((case erlang:is_map(Dp_15) of true -> maps:get(M_7, Dp_15, nil); _ -> case M_7 < 0 of true -> lists:nth(erlang:length(Dp_15) + M_7 + 1, Dp_15); _ -> lists:nth(M_7 + 1, Dp_15) end end)) of true -> maps:get(N_2, (case erlang:is_map(Dp_15) of true -> maps:get(M_7, Dp_15, nil); _ -> case M_7 < 0 of true -> lists:nth(erlang:length(Dp_15) + M_7 + 1, Dp_15); _ -> lists:nth(M_7 + 1, Dp_15) end end), nil); _ -> case N_2 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_15) of true -> maps:get(M_7, Dp_15, nil); _ -> case M_7 < 0 of true -> lists:nth(erlang:length(Dp_15) + M_7 + 1, Dp_15); _ -> lists:nth(M_7 + 1, Dp_15) end end)) + N_2 + 1, (case erlang:is_map(Dp_15) of true -> maps:get(M_7, Dp_15, nil); _ -> case M_7 < 0 of true -> lists:nth(erlang:length(Dp_15) + M_7 + 1, Dp_15); _ -> lists:nth(M_7 + 1, Dp_15) end end)); _ -> lists:nth(N_2 + 1, (case erlang:is_map(Dp_15) of true -> maps:get(M_7, Dp_15, nil); _ -> case M_7 < 0 of true -> lists:nth(erlang:length(Dp_15) + M_7 + 1, Dp_15); _ -> lists:nth(M_7 + 1, Dp_15) end end)) end end)
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    io:format("~ts~n", [mochi_str(min_dist_top_down("intention", "execution"))]),
    io:format("~ts~n", [mochi_str(min_dist_top_down("intention", ""))]),
    io:format("~ts~n", [mochi_str(min_dist_top_down("", ""))]),
    io:format("~ts~n", [mochi_str(min_dist_bottom_up("intention", "execution"))]),
    io:format("~ts~n", [mochi_str(min_dist_bottom_up("intention", ""))]),
    io:format("~ts~n", [mochi_str(min_dist_bottom_up("", ""))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
