#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, new_graph/1, add_edge/4, floyd_warshall/1, show_min/3]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

new_graph(N) ->
    try
        Dp = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(Dp, I, N) ->
    case (I < N) of
        true ->
            Row = [],
            J = 0,
            Fun = fun Fun_loop(Dp, I, J, N, Row) ->
    case (J < N) of
        true ->
            case (I == J) of
        true -> Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            Row_4 = Row_2;
        _ -> Row_3 = lists:append((case Row of nil -> []; _ -> Row end), [1000000000]),
            Row_4 = Row_3
    end,
            J_2 = (J + 1),
            Fun_loop(Dp, I, J_2, N, Row_4);
        _ -> {Dp, I, J, N, Row}
    end
end,
{Dp, I, J_2, N, Row_4} = Fun(Dp, I, J, N, Row),
            Dp_2 = lists:append((case Dp of nil -> []; _ -> Dp end), [Row_4]),
            I_2 = (I + 1),
            Fun_2_loop(Dp_2, I_2, N);
        _ -> {Dp, I, N}
    end
end,
{Dp_2, I_2, N} = Fun_2(Dp, I, N),
        #{"n" => N, "dp" => Dp_2}
    catch {return, Ret} -> Ret end.

add_edge(G, U, V, W) ->
    try
        Dp_3 = maps:get("dp", G, nil),
        Row_5 = (case erlang:is_map(Dp_3) of true -> maps:get(U, Dp_3, nil); _ -> case U < 0 of true -> lists:nth(erlang:length(Dp_3) + U + 1, Dp_3); _ -> lists:nth(U + 1, Dp_3) end end),
        Row_6 = lists:sublist(Row_5, V) ++ [W] ++ lists:nthtail(V + 1, Row_5),
        Dp_4 = lists:sublist(Dp_3, U) ++ [Row_6] ++ lists:nthtail(U + 1, Dp_3),
        G_2 = maps:put("dp", Dp_4, G),
        {nil, G_2}
    catch {return, Ret} -> Ret end.

floyd_warshall(G_3) ->
    try
        Dp_5 = maps:get("dp", G_3, nil),
        K = 0,
        Fun_5 = fun Fun_5_loop(Dp_5, G_3, K) ->
    case (K < maps:get("n", G_3, nil)) of
        true ->
            I_3 = 0,
            Fun_4 = fun Fun_4_loop(Dp_5, G_3, I_3, K) ->
    case (I_3 < maps:get("n", G_3, nil)) of
        true ->
            J_3 = 0,
            Fun_3 = fun Fun_3_loop(Dp_5, G_3, I_3, J_3, K) ->
    case (J_3 < maps:get("n", G_3, nil)) of
        true ->
            Alt = ((case erlang:is_map((case erlang:is_map(Dp_5) of true -> maps:get(I_3, Dp_5, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Dp_5) + I_3 + 1, Dp_5); _ -> lists:nth(I_3 + 1, Dp_5) end end)) of true -> maps:get(K, (case erlang:is_map(Dp_5) of true -> maps:get(I_3, Dp_5, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Dp_5) + I_3 + 1, Dp_5); _ -> lists:nth(I_3 + 1, Dp_5) end end), nil); _ -> case K < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_5) of true -> maps:get(I_3, Dp_5, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Dp_5) + I_3 + 1, Dp_5); _ -> lists:nth(I_3 + 1, Dp_5) end end)) + K + 1, (case erlang:is_map(Dp_5) of true -> maps:get(I_3, Dp_5, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Dp_5) + I_3 + 1, Dp_5); _ -> lists:nth(I_3 + 1, Dp_5) end end)); _ -> lists:nth(K + 1, (case erlang:is_map(Dp_5) of true -> maps:get(I_3, Dp_5, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Dp_5) + I_3 + 1, Dp_5); _ -> lists:nth(I_3 + 1, Dp_5) end end)) end end) + (case erlang:is_map((case erlang:is_map(Dp_5) of true -> maps:get(K, Dp_5, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Dp_5) + K + 1, Dp_5); _ -> lists:nth(K + 1, Dp_5) end end)) of true -> maps:get(J_3, (case erlang:is_map(Dp_5) of true -> maps:get(K, Dp_5, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Dp_5) + K + 1, Dp_5); _ -> lists:nth(K + 1, Dp_5) end end), nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_5) of true -> maps:get(K, Dp_5, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Dp_5) + K + 1, Dp_5); _ -> lists:nth(K + 1, Dp_5) end end)) + J_3 + 1, (case erlang:is_map(Dp_5) of true -> maps:get(K, Dp_5, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Dp_5) + K + 1, Dp_5); _ -> lists:nth(K + 1, Dp_5) end end)); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Dp_5) of true -> maps:get(K, Dp_5, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Dp_5) + K + 1, Dp_5); _ -> lists:nth(K + 1, Dp_5) end end)) end end)),
            Row_7 = (case erlang:is_map(Dp_5) of true -> maps:get(I_3, Dp_5, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Dp_5) + I_3 + 1, Dp_5); _ -> lists:nth(I_3 + 1, Dp_5) end end),
            case (Alt < (case erlang:is_map(Row_7) of true -> maps:get(J_3, Row_7, nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length(Row_7) + J_3 + 1, Row_7); _ -> lists:nth(J_3 + 1, Row_7) end end)) of
        true -> Row_8 = lists:sublist(Row_7, J_3) ++ [Alt] ++ lists:nthtail(J_3 + 1, Row_7),
            Dp_6 = lists:sublist(Dp_5, I_3) ++ [Row_8] ++ lists:nthtail(I_3 + 1, Dp_5),
            Dp_7 = Dp_6,
            Row_9 = Row_8;
        _ -> Dp_7 = Dp_5,
            Row_9 = Row_7
    end,
            J_4 = (J_3 + 1),
            Fun_3_loop(Dp_7, G_3, I_3, J_4, K);
        _ -> {Dp_5, G_3, I_3, J_3, K}
    end
end,
{Dp_7, G_3, I_3, J_4, K} = Fun_3(Dp_5, G_3, I_3, J_3, K),
            I_4 = (I_3 + 1),
            Fun_4_loop(Dp_7, G_3, I_4, K);
        _ -> {Dp_5, G_3, I_3, K}
    end
end,
{Dp_7, G_3, I_4, K} = Fun_4(Dp_5, G_3, I_3, K),
            K_2 = (K + 1),
            Fun_5_loop(Dp_7, G_3, K_2);
        _ -> {Dp_5, G_3, K}
    end
end,
{Dp_7, G_3, K_2} = Fun_5(Dp_5, G_3, K),
        G_4 = maps:put("dp", Dp_7, G_3),
        {nil, G_4}
    catch {return, Ret} -> Ret end.

show_min(G_5, U_2, V_2) ->
    try
        (case erlang:is_map((case erlang:is_map(maps:get("dp", G_5, nil)) of true -> maps:get(U_2, maps:get("dp", G_5, nil), nil); _ -> case U_2 < 0 of true -> lists:nth(erlang:length(maps:get("dp", G_5, nil)) + U_2 + 1, maps:get("dp", G_5, nil)); _ -> lists:nth(U_2 + 1, maps:get("dp", G_5, nil)) end end)) of true -> maps:get(V_2, (case erlang:is_map(maps:get("dp", G_5, nil)) of true -> maps:get(U_2, maps:get("dp", G_5, nil), nil); _ -> case U_2 < 0 of true -> lists:nth(erlang:length(maps:get("dp", G_5, nil)) + U_2 + 1, maps:get("dp", G_5, nil)); _ -> lists:nth(U_2 + 1, maps:get("dp", G_5, nil)) end end), nil); _ -> case V_2 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(maps:get("dp", G_5, nil)) of true -> maps:get(U_2, maps:get("dp", G_5, nil), nil); _ -> case U_2 < 0 of true -> lists:nth(erlang:length(maps:get("dp", G_5, nil)) + U_2 + 1, maps:get("dp", G_5, nil)); _ -> lists:nth(U_2 + 1, maps:get("dp", G_5, nil)) end end)) + V_2 + 1, (case erlang:is_map(maps:get("dp", G_5, nil)) of true -> maps:get(U_2, maps:get("dp", G_5, nil), nil); _ -> case U_2 < 0 of true -> lists:nth(erlang:length(maps:get("dp", G_5, nil)) + U_2 + 1, maps:get("dp", G_5, nil)); _ -> lists:nth(U_2 + 1, maps:get("dp", G_5, nil)) end end)); _ -> lists:nth(V_2 + 1, (case erlang:is_map(maps:get("dp", G_5, nil)) of true -> maps:get(U_2, maps:get("dp", G_5, nil), nil); _ -> case U_2 < 0 of true -> lists:nth(erlang:length(maps:get("dp", G_5, nil)) + U_2 + 1, maps:get("dp", G_5, nil)); _ -> lists:nth(U_2 + 1, maps:get("dp", G_5, nil)) end end)) end end)
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('INF', 1000000000),
    erlang:put('graph', new_graph(5)),
    {_, Graph} = add_edge(erlang:get('graph'), 0, 2, 9),
    erlang:put('graph', Graph),
    {_, Graph_2} = add_edge(erlang:get('graph'), 0, 4, 10),
    erlang:put('graph', Graph_2),
    {_, Graph_3} = add_edge(erlang:get('graph'), 1, 3, 5),
    erlang:put('graph', Graph_3),
    {_, Graph_4} = add_edge(erlang:get('graph'), 2, 3, 7),
    erlang:put('graph', Graph_4),
    {_, Graph_5} = add_edge(erlang:get('graph'), 3, 0, 10),
    erlang:put('graph', Graph_5),
    {_, Graph_6} = add_edge(erlang:get('graph'), 3, 1, 2),
    erlang:put('graph', Graph_6),
    {_, Graph_7} = add_edge(erlang:get('graph'), 3, 2, 1),
    erlang:put('graph', Graph_7),
    {_, Graph_8} = add_edge(erlang:get('graph'), 3, 4, 6),
    erlang:put('graph', Graph_8),
    {_, Graph_9} = add_edge(erlang:get('graph'), 4, 1, 3),
    erlang:put('graph', Graph_9),
    {_, Graph_10} = add_edge(erlang:get('graph'), 4, 2, 4),
    erlang:put('graph', Graph_10),
    {_, Graph_11} = add_edge(erlang:get('graph'), 4, 3, 9),
    erlang:put('graph', Graph_11),
    {_, Graph_12} = floyd_warshall(erlang:get('graph')),
    erlang:put('graph', Graph_12),
    io:format("~ts~n", [mochi_str(show_min(erlang:get('graph'), 1, 4))]),
    io:format("~ts~n", [mochi_str(show_min(erlang:get('graph'), 0, 3))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
