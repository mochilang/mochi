#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, key/2, viterbi/5, join_words/1]).

% Generated by Mochi transpiler v0.10.64 (9e806895eb) on 2025-08-13 16:13 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


-compile({nowarn_unused_function, [mochi_safe_mul/2, mochi_safe_div/2]}).
mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.

key(State, Obs) ->
    try
        ((State ++ "|") ++ Obs)
    catch {return, RetCatch} -> RetCatch end.

viterbi(Observations, States, Start_p, Trans_p, Emit_p) ->
    try
        case ((erlang:length(Observations) == 0) orelse (erlang:length(States) == 0)) of
        true -> erlang:error({panic, "empty parameters"});
        _ -> ok
    end,
        Probs = #{},
        Ptrs = #{},
        First_obs = (case erlang:is_map(Observations) of true -> maps:get(0, Observations, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Observations) + 0 + 1, Observations); _ -> mochi_nth(0 + 1, Observations) end end),
        I = 0,
        Fun = fun Fun_loop(Emit_p, First_obs, I, Observations, Probs, Ptrs, Start_p, States, Trans_p) ->
    case (I < erlang:length(States)) of
        true ->
            State_2 = (case erlang:is_map(States) of true -> maps:get(I, States, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(States) + I + 1, States); _ -> mochi_nth(I + 1, States) end end),
            Probs_2 = maps:put(key(State_2, First_obs), mochi_safe_mul(maps:get(State_2, Start_p, nil), maps:get(First_obs, maps:get(State_2, Emit_p, nil), nil)), Probs),
            Ptrs_2 = maps:put(key(State_2, First_obs), "", Ptrs),
            I_2 = (I + 1),
            Fun_loop(Emit_p, First_obs, I_2, Observations, Probs_2, Ptrs_2, Start_p, States, Trans_p);
        _ -> {Emit_p, First_obs, I, Observations, Probs, Ptrs, Start_p, States, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, Observations, Probs_2, Ptrs_2, Start_p, States, Trans_p} = Fun(Emit_p, First_obs, I, Observations, Probs, Ptrs, Start_p, States, Trans_p),
        T = 1,
        Fun_4 = fun Fun_4_loop(Emit_p, First_obs, I_2, Observations, Probs_2, Ptrs_2, Start_p, States, T, Trans_p) ->
    case (T < erlang:length(Observations)) of
        true ->
            Obs_2 = (case erlang:is_map(Observations) of true -> maps:get(T, Observations, nil); _ -> case T < 0 of true -> mochi_nth(erlang:length(Observations) + T + 1, Observations); _ -> mochi_nth(T + 1, Observations) end end),
            J = 0,
            Fun_3 = fun Fun_3_loop(Emit_p, First_obs, I_2, J, Obs_2, Observations, Probs_2, Ptrs_2, Start_p, States, T, Trans_p) ->
    case (J < erlang:length(States)) of
        true ->
            State_3 = (case erlang:is_map(States) of true -> maps:get(J, States, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(States) + J + 1, States); _ -> mochi_nth(J + 1, States) end end),
            Max_prob = -1.0,
            Prev_state = "",
            K = 0,
            Fun_2 = fun Fun_2_loop(Emit_p, First_obs, I_2, J, K, Max_prob, Obs_2, Observations, Prev_state, Probs_2, Ptrs_2, Start_p, State_3, States, T, Trans_p) ->
    case (K < erlang:length(States)) of
        true ->
            State0 = (case erlang:is_map(States) of true -> maps:get(K, States, nil); _ -> case K < 0 of true -> mochi_nth(erlang:length(States) + K + 1, States); _ -> mochi_nth(K + 1, States) end end),
            Obs0 = (case erlang:is_map(Observations) of true -> maps:get((T - 1), Observations, nil); _ -> case (T - 1) < 0 of true -> mochi_nth(erlang:length(Observations) + (T - 1) + 1, Observations); _ -> mochi_nth((T - 1) + 1, Observations) end end),
            Prob_prev = maps:get(key(State0, Obs0), Probs_2, nil),
            Prob = mochi_safe_mul(mochi_safe_mul(Prob_prev, maps:get(State_3, maps:get(State0, Trans_p, nil), nil)), maps:get(Obs_2, maps:get(State_3, Emit_p, nil), nil)),
            case (Prob > Max_prob) of
        true -> Max_prob_2 = Prob,
            Prev_state_2 = State0,
            Max_prob_3 = Max_prob_2,
            Prev_state_3 = Prev_state_2;
        _ -> Max_prob_3 = Max_prob,
            Prev_state_3 = Prev_state
    end,
            K_2 = (K + 1),
            Fun_2_loop(Emit_p, First_obs, I_2, J, K_2, Max_prob_3, Obs_2, Observations, Prev_state_3, Probs_2, Ptrs_2, Start_p, State_3, States, T, Trans_p);
        _ -> {Emit_p, First_obs, I_2, J, K, Max_prob, Obs_2, Observations, Prev_state, Probs_2, Ptrs_2, Start_p, State_3, States, T, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, J, K_2, Max_prob_3, Obs_2, Observations, Prev_state_3, Probs_2, Ptrs_2, Start_p, State_3, States, T, Trans_p} = Fun_2(Emit_p, First_obs, I_2, J, K, Max_prob, Obs_2, Observations, Prev_state, Probs_2, Ptrs_2, Start_p, State_3, States, T, Trans_p),
            Probs_3 = maps:put(key(State_3, Obs_2), Max_prob_3, Probs_2),
            Ptrs_3 = maps:put(key(State_3, Obs_2), Prev_state_3, Ptrs_2),
            J_2 = (J + 1),
            Fun_3_loop(Emit_p, First_obs, I_2, J_2, Obs_2, Observations, Probs_3, Ptrs_3, Start_p, States, T, Trans_p);
        _ -> {Emit_p, First_obs, I_2, J, Obs_2, Observations, Probs_2, Ptrs_2, Start_p, States, T, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, J_2, Obs_2, Observations, Probs_3, Ptrs_3, Start_p, States, T, Trans_p} = Fun_3(Emit_p, First_obs, I_2, J, Obs_2, Observations, Probs_2, Ptrs_2, Start_p, States, T, Trans_p),
            T_2 = (T + 1),
            Fun_4_loop(Emit_p, First_obs, I_2, Observations, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p);
        _ -> {Emit_p, First_obs, I_2, Observations, Probs_2, Ptrs_2, Start_p, States, T, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, Observations, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p} = Fun_4(Emit_p, First_obs, I_2, Observations, Probs_2, Ptrs_2, Start_p, States, T, Trans_p),
        Path = [],
        N = 0,
        Fun_5 = fun Fun_5_loop(Emit_p, First_obs, I_2, N, Observations, Path, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p) ->
    case (N < erlang:length(Observations)) of
        true ->
            Path_2 = lists:append((case Path of nil -> []; _ -> Path end), [""]),
            N_2 = (N + 1),
            Fun_5_loop(Emit_p, First_obs, I_2, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p);
        _ -> {Emit_p, First_obs, I_2, N, Observations, Path, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p} = Fun_5(Emit_p, First_obs, I_2, N, Observations, Path, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p),
        Last_obs = (case erlang:is_map(Observations) of true -> maps:get((erlang:length(Observations) - 1), Observations, nil); _ -> case (erlang:length(Observations) - 1) < 0 of true -> mochi_nth(erlang:length(Observations) + (erlang:length(Observations) - 1) + 1, Observations); _ -> mochi_nth((erlang:length(Observations) - 1) + 1, Observations) end end),
        Max_final = -1.0,
        Last_state = "",
        M = 0,
        Fun_6 = fun Fun_6_loop(Emit_p, First_obs, I_2, Last_obs, Last_state, M, Max_final, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p) ->
    case (M < erlang:length(States)) of
        true ->
            State_4 = (case erlang:is_map(States) of true -> maps:get(M, States, nil); _ -> case M < 0 of true -> mochi_nth(erlang:length(States) + M + 1, States); _ -> mochi_nth(M + 1, States) end end),
            Prob_2 = maps:get(key(State_4, Last_obs), Probs_3, nil),
            case (Prob_2 > Max_final) of
        true -> Max_final_2 = Prob_2,
            Last_state_2 = State_4,
            Last_state_3 = Last_state_2,
            Max_final_3 = Max_final_2;
        _ -> Last_state_3 = Last_state,
            Max_final_3 = Max_final
    end,
            M_2 = (M + 1),
            Fun_6_loop(Emit_p, First_obs, I_2, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p);
        _ -> {Emit_p, First_obs, I_2, Last_obs, Last_state, M, Max_final, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p} = Fun_6(Emit_p, First_obs, I_2, Last_obs, Last_state, M, Max_final, N_2, Observations, Path_2, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p),
        Last_index = (erlang:length(Observations) - 1),
        Path_3 = lists:sublist(Path_2, Last_index) ++ [Last_state_3] ++ lists:nthtail(Last_index + 1, Path_2),
        Idx = Last_index,
        Fun_7 = fun Fun_7_loop(Emit_p, First_obs, I_2, Idx, Last_index, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_3, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p) ->
    case (Idx > 0) of
        true ->
            Obs_3 = (case erlang:is_map(Observations) of true -> maps:get(Idx, Observations, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Observations) + Idx + 1, Observations); _ -> mochi_nth(Idx + 1, Observations) end end),
            Prev = maps:get(key((case erlang:is_map(Path_3) of true -> maps:get(Idx, Path_3, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Path_3) + Idx + 1, Path_3); _ -> mochi_nth(Idx + 1, Path_3) end end), Obs_3), Ptrs_3, nil),
            Path_4 = lists:sublist(Path_3, (Idx - 1)) ++ [Prev] ++ lists:nthtail((Idx - 1) + 1, Path_3),
            Idx_2 = (Idx - 1),
            Fun_7_loop(Emit_p, First_obs, I_2, Idx_2, Last_index, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_4, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p);
        _ -> {Emit_p, First_obs, I_2, Idx, Last_index, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_3, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p}
    end
end,
{Emit_p, First_obs, I_2, Idx_2, Last_index, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_4, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p} = Fun_7(Emit_p, First_obs, I_2, Idx, Last_index, Last_obs, Last_state_3, M_2, Max_final_3, N_2, Observations, Path_3, Probs_3, Ptrs_3, Start_p, States, T_2, Trans_p),
        Path_4
    catch {return, RetCatch} -> RetCatch end.

join_words(Words) ->
    try
        Res = "",
        I_3 = 0,
        Fun_8 = fun Fun_8_loop(I_3, Res, Words) ->
    case (I_3 < erlang:length(Words)) of
        true ->
            case (I_3 > 0) of
        true -> Res_2 = (Res ++ " "),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ (case erlang:is_map(Words) of true -> maps:get(I_3, Words, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Words) + I_3 + 1, Words); _ -> mochi_nth(I_3 + 1, Words) end end)),
            I_4 = (I_3 + 1),
            Fun_8_loop(I_4, Res_4, Words);
        _ -> {I_3, Res, Words}
    end
end,
{I_4, Res_4, Words} = Fun_8(I_3, Res, Words),
        Res_4
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('observations', ["normal", "cold", "dizzy"]),
    erlang:put('states', ["Healthy", "Fever"]),
    erlang:put('start_p', #{"Healthy" => 0.6, "Fever" => 0.4}),
    erlang:put('trans_p', #{"Healthy" => #{"Healthy" => 0.7, "Fever" => 0.3}, "Fever" => #{"Healthy" => 0.4, "Fever" => 0.6}}),
    erlang:put('emit_p', #{"Healthy" => #{"normal" => 0.5, "cold" => 0.4, "dizzy" => 0.1}, "Fever" => #{"normal" => 0.1, "cold" => 0.3, "dizzy" => 0.6}}),
    erlang:put('result', viterbi(erlang:get('observations'), erlang:get('states'), erlang:get('start_p'), erlang:get('trans_p'), erlang:get('emit_p'))),
    io:format("~ts~n", [mochi_repr(join_words(erlang:get('result')))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
