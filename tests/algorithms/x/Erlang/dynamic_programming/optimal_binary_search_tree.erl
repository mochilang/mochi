#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, sort_nodes/1, print_node/1, print_binary_search_tree/6, find_optimal_binary_search_tree/1, main/0]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

sort_nodes(Nodes) ->
    try
        Arr = Nodes,
        I = 1,
        Fun_2 = fun Fun_2_loop(Arr, I, Nodes) ->
    case (I < erlang:length(Arr)) of
        true ->
            try
                Key_node = (case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Arr) + I + 1, Arr); _ -> lists:nth(I + 1, Arr) end end),
                J = (I - 1),
                Fun = fun Fun_loop(Arr, I, J, Key_node, Nodes) ->
    case (J >= 0) of
        true ->
            try
                Temp = (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Arr) + J + 1, Arr); _ -> lists:nth(J + 1, Arr) end end),
                case (maps:get("key", Temp, nil) > maps:get("key", Key_node, nil)) of
        true -> Arr_2 = lists:sublist(Arr, (J + 1)) ++ [Temp] ++ lists:nthtail((J + 1) + 1, Arr),
            J_2 = (J - 1),
            Arr_3 = Arr_2,
            J_3 = J_2;
        _ -> throw({break, Arr, I, J, Key_node, Nodes}),
            Arr_3 = Arr,
            J_3 = J
    end,
                Fun_loop(Arr_3, I, J_3, Key_node, Nodes)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_loop(C0, C1, C2, C3, C4);
                {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4}
            end;
        _ -> {Arr, I, J, Key_node, Nodes}
    end
end,
{Arr_3, I, J_3, Key_node, Nodes} = Fun(Arr, I, J, Key_node, Nodes),
                Arr_4 = lists:sublist(Arr_3, (J_3 + 1)) ++ [Key_node] ++ lists:nthtail((J_3 + 1) + 1, Arr_3),
                I_2 = (I + 1),
                Fun_2_loop(Arr_4, I_2, Nodes)
            catch
                {continue, C0, C1, C2} -> Fun_2_loop(C0, C1, C2);
                {break, B0, B1, B2} -> {B0, B1, B2}
            end;
        _ -> {Arr, I, Nodes}
    end
end,
{Arr_4, I_2, Nodes} = Fun_2(Arr, I, Nodes),
        Arr_4
    catch {return, Ret} -> Ret end.

print_node(N) ->
    try
        io:format("~ts~n", [mochi_repr((((("Node(key=" ++ mochi_str(maps:get("key", N, nil))) ++ ", freq=") ++ mochi_str(maps:get("freq", N, nil))) ++ ")"))]),
        nil
    catch {return, Ret} -> Ret end.

print_binary_search_tree(Root, Keys, I_3, J_4, Parent, Is_left) ->
    try
        case (((I_3 > J_4) orelse (I_3 < 0)) orelse (J_4 > (erlang:length(Root) - 1))) of
        true -> throw({return, nil});
        _ -> ok
    end,
        Node = (case erlang:is_map((case erlang:is_map(Root) of true -> maps:get(I_3, Root, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Root) + I_3 + 1, Root); _ -> lists:nth(I_3 + 1, Root) end end)) of true -> maps:get(J_4, (case erlang:is_map(Root) of true -> maps:get(I_3, Root, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Root) + I_3 + 1, Root); _ -> lists:nth(I_3 + 1, Root) end end), nil); _ -> case J_4 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Root) of true -> maps:get(I_3, Root, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Root) + I_3 + 1, Root); _ -> lists:nth(I_3 + 1, Root) end end)) + J_4 + 1, (case erlang:is_map(Root) of true -> maps:get(I_3, Root, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Root) + I_3 + 1, Root); _ -> lists:nth(I_3 + 1, Root) end end)); _ -> lists:nth(J_4 + 1, (case erlang:is_map(Root) of true -> maps:get(I_3, Root, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Root) + I_3 + 1, Root); _ -> lists:nth(I_3 + 1, Root) end end)) end end),
        case (Parent == -1) of
        true -> io:format("~ts~n", [mochi_repr((mochi_str((case erlang:is_map(Keys) of true -> maps:get(Node, Keys, nil); _ -> case Node < 0 of true -> lists:nth(erlang:length(Keys) + Node + 1, Keys); _ -> lists:nth(Node + 1, Keys) end end)) ++ " is the root of the binary search tree."))]);
        _ -> case Is_left of
        true -> io:format("~ts~n", [mochi_repr((((mochi_str((case erlang:is_map(Keys) of true -> maps:get(Node, Keys, nil); _ -> case Node < 0 of true -> lists:nth(erlang:length(Keys) + Node + 1, Keys); _ -> lists:nth(Node + 1, Keys) end end)) ++ " is the left child of key ") ++ mochi_str(Parent)) ++ "."))]);
        _ -> io:format("~ts~n", [mochi_repr((((mochi_str((case erlang:is_map(Keys) of true -> maps:get(Node, Keys, nil); _ -> case Node < 0 of true -> lists:nth(erlang:length(Keys) + Node + 1, Keys); _ -> lists:nth(Node + 1, Keys) end end)) ++ " is the right child of key ") ++ mochi_str(Parent)) ++ "."))])
    end
    end,
        print_binary_search_tree(Root, Keys, I_3, (Node - 1), (case erlang:is_map(Keys) of true -> maps:get(Node, Keys, nil); _ -> case Node < 0 of true -> lists:nth(erlang:length(Keys) + Node + 1, Keys); _ -> lists:nth(Node + 1, Keys) end end), true),
        print_binary_search_tree(Root, Keys, (Node + 1), J_4, (case erlang:is_map(Keys) of true -> maps:get(Node, Keys, nil); _ -> case Node < 0 of true -> lists:nth(erlang:length(Keys) + Node + 1, Keys); _ -> lists:nth(Node + 1, Keys) end end), false),
        nil
    catch {return, Ret} -> Ret end.

find_optimal_binary_search_tree(Original_nodes) ->
    try
        Nodes_2 = sort_nodes(Original_nodes),
        N_2 = erlang:length(Nodes_2),
        Keys_2 = [],
        Freqs = [],
        I_4 = 0,
        Fun_3 = fun Fun_3_loop(Freqs, I_4, Keys_2, N_2, Nodes_2, Original_nodes) ->
    case (I_4 < N_2) of
        true ->
            Node_2 = (case erlang:is_map(Nodes_2) of true -> maps:get(I_4, Nodes_2, nil); _ -> case I_4 < 0 of true -> lists:nth(erlang:length(Nodes_2) + I_4 + 1, Nodes_2); _ -> lists:nth(I_4 + 1, Nodes_2) end end),
            Keys_3 = lists:append((case Keys_2 of nil -> []; _ -> Keys_2 end), [maps:get("key", Node_2, nil)]),
            Freqs_2 = lists:append((case Freqs of nil -> []; _ -> Freqs end), [maps:get("freq", Node_2, nil)]),
            I_5 = (I_4 + 1),
            Fun_3_loop(Freqs_2, I_5, Keys_3, N_2, Nodes_2, Original_nodes);
        _ -> {Freqs, I_4, Keys_2, N_2, Nodes_2, Original_nodes}
    end
end,
{Freqs_2, I_5, Keys_3, N_2, Nodes_2, Original_nodes} = Fun_3(Freqs, I_4, Keys_2, N_2, Nodes_2, Original_nodes),
        Dp = [],
        Total = [],
        Root_2 = [],
        I_6 = 0,
        Fun_5 = fun Fun_5_loop(Dp, Freqs_2, I_6, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Total) ->
    case (I_6 < N_2) of
        true ->
            Dp_row = [],
            Total_row = [],
            Root_row = [],
            J_5 = 0,
            Fun_4 = fun Fun_4_loop(Dp, Dp_row, Freqs_2, I_6, J_5, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Root_row, Total, Total_row) ->
    case (J_5 < N_2) of
        true ->
            case (I_6 == J_5) of
        true -> Dp_row_2 = lists:append((case Dp_row of nil -> []; _ -> Dp_row end), [(case erlang:is_map(Freqs_2) of true -> maps:get(I_6, Freqs_2, nil); _ -> case I_6 < 0 of true -> lists:nth(erlang:length(Freqs_2) + I_6 + 1, Freqs_2); _ -> lists:nth(I_6 + 1, Freqs_2) end end)]),
            Total_row_2 = lists:append((case Total_row of nil -> []; _ -> Total_row end), [(case erlang:is_map(Freqs_2) of true -> maps:get(I_6, Freqs_2, nil); _ -> case I_6 < 0 of true -> lists:nth(erlang:length(Freqs_2) + I_6 + 1, Freqs_2); _ -> lists:nth(I_6 + 1, Freqs_2) end end)]),
            Root_row_2 = lists:append((case Root_row of nil -> []; _ -> Root_row end), [I_6]),
            Dp_row_4 = Dp_row_2,
            Root_row_4 = Root_row_2,
            Total_row_4 = Total_row_2;
        _ -> Dp_row_3 = lists:append((case Dp_row of nil -> []; _ -> Dp_row end), [0]),
            Total_row_3 = lists:append((case Total_row of nil -> []; _ -> Total_row end), [0]),
            Root_row_3 = lists:append((case Root_row of nil -> []; _ -> Root_row end), [0]),
            Dp_row_4 = Dp_row_3,
            Root_row_4 = Root_row_3,
            Total_row_4 = Total_row_3
    end,
            J_6 = (J_5 + 1),
            Fun_4_loop(Dp, Dp_row_4, Freqs_2, I_6, J_6, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Root_row_4, Total, Total_row_4);
        _ -> {Dp, Dp_row, Freqs_2, I_6, J_5, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Root_row, Total, Total_row}
    end
end,
{Dp, Dp_row_4, Freqs_2, I_6, J_6, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Root_row_4, Total, Total_row_4} = Fun_4(Dp, Dp_row, Freqs_2, I_6, J_5, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Root_row, Total, Total_row),
            Dp_2 = lists:append((case Dp of nil -> []; _ -> Dp end), [Dp_row_4]),
            Total_2 = lists:append((case Total of nil -> []; _ -> Total end), [Total_row_4]),
            Root_3 = lists:append((case Root_2 of nil -> []; _ -> Root_2 end), [Root_row_4]),
            I_7 = (I_6 + 1),
            Fun_5_loop(Dp_2, Freqs_2, I_7, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2);
        _ -> {Dp, Freqs_2, I_6, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Total}
    end
end,
{Dp_2, Freqs_2, I_7, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2} = Fun_5(Dp, Freqs_2, I_6, Keys_3, N_2, Nodes_2, Original_nodes, Root_2, Total),
        Interval_length = 2,
        INF = 2147483647,
        Fun_8 = fun Fun_8_loop(INF, Dp_2, Freqs_2, I_7, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2) ->
    case (Interval_length =< N_2) of
        true ->
            I_8 = 0,
            Fun_7 = fun Fun_7_loop(INF, Dp_2, Freqs_2, I_8, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2) ->
    case (I_8 < ((N_2 - Interval_length) + 1)) of
        true ->
            J_7 = ((I_8 + Interval_length) - 1),
            Dp_3 = lists:sublist(Dp_2, I_8) ++ [lists:sublist(lists:nth(I_8 + 1, Dp_2), J_7) ++ [INF] ++ lists:nthtail(J_7 + 1, lists:nth(I_8 + 1, Dp_2))] ++ lists:nthtail(I_8 + 1, Dp_2),
            Total_3 = lists:sublist(Total_2, I_8) ++ [lists:sublist(lists:nth(I_8 + 1, Total_2), J_7) ++ [((case erlang:is_map((case erlang:is_map(Total_2) of true -> maps:get(I_8, Total_2, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_2) + I_8 + 1, Total_2); _ -> lists:nth(I_8 + 1, Total_2) end end)) of true -> maps:get((J_7 - 1), (case erlang:is_map(Total_2) of true -> maps:get(I_8, Total_2, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_2) + I_8 + 1, Total_2); _ -> lists:nth(I_8 + 1, Total_2) end end), nil); _ -> case (J_7 - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Total_2) of true -> maps:get(I_8, Total_2, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_2) + I_8 + 1, Total_2); _ -> lists:nth(I_8 + 1, Total_2) end end)) + (J_7 - 1) + 1, (case erlang:is_map(Total_2) of true -> maps:get(I_8, Total_2, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_2) + I_8 + 1, Total_2); _ -> lists:nth(I_8 + 1, Total_2) end end)); _ -> lists:nth((J_7 - 1) + 1, (case erlang:is_map(Total_2) of true -> maps:get(I_8, Total_2, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_2) + I_8 + 1, Total_2); _ -> lists:nth(I_8 + 1, Total_2) end end)) end end) + (case erlang:is_map(Freqs_2) of true -> maps:get(J_7, Freqs_2, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Freqs_2) + J_7 + 1, Freqs_2); _ -> lists:nth(J_7 + 1, Freqs_2) end end))] ++ lists:nthtail(J_7 + 1, lists:nth(I_8 + 1, Total_2))] ++ lists:nthtail(I_8 + 1, Total_2),
            R = (case erlang:is_map((case erlang:is_map(Root_3) of true -> maps:get(I_8, Root_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Root_3) + I_8 + 1, Root_3); _ -> lists:nth(I_8 + 1, Root_3) end end)) of true -> maps:get((J_7 - 1), (case erlang:is_map(Root_3) of true -> maps:get(I_8, Root_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Root_3) + I_8 + 1, Root_3); _ -> lists:nth(I_8 + 1, Root_3) end end), nil); _ -> case (J_7 - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Root_3) of true -> maps:get(I_8, Root_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Root_3) + I_8 + 1, Root_3); _ -> lists:nth(I_8 + 1, Root_3) end end)) + (J_7 - 1) + 1, (case erlang:is_map(Root_3) of true -> maps:get(I_8, Root_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Root_3) + I_8 + 1, Root_3); _ -> lists:nth(I_8 + 1, Root_3) end end)); _ -> lists:nth((J_7 - 1) + 1, (case erlang:is_map(Root_3) of true -> maps:get(I_8, Root_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Root_3) + I_8 + 1, Root_3); _ -> lists:nth(I_8 + 1, Root_3) end end)) end end),
            Fun_6 = fun Fun_6_loop(INF, Dp_3, Freqs_2, I_8, Interval_length, J_7, Keys_3, N_2, Nodes_2, Original_nodes, R, Root_3, Total_3) ->
    case (R =< (case erlang:is_map((case erlang:is_map(Root_3) of true -> maps:get((I_8 + 1), Root_3, nil); _ -> case (I_8 + 1) < 0 of true -> lists:nth(erlang:length(Root_3) + (I_8 + 1) + 1, Root_3); _ -> lists:nth((I_8 + 1) + 1, Root_3) end end)) of true -> maps:get(J_7, (case erlang:is_map(Root_3) of true -> maps:get((I_8 + 1), Root_3, nil); _ -> case (I_8 + 1) < 0 of true -> lists:nth(erlang:length(Root_3) + (I_8 + 1) + 1, Root_3); _ -> lists:nth((I_8 + 1) + 1, Root_3) end end), nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Root_3) of true -> maps:get((I_8 + 1), Root_3, nil); _ -> case (I_8 + 1) < 0 of true -> lists:nth(erlang:length(Root_3) + (I_8 + 1) + 1, Root_3); _ -> lists:nth((I_8 + 1) + 1, Root_3) end end)) + J_7 + 1, (case erlang:is_map(Root_3) of true -> maps:get((I_8 + 1), Root_3, nil); _ -> case (I_8 + 1) < 0 of true -> lists:nth(erlang:length(Root_3) + (I_8 + 1) + 1, Root_3); _ -> lists:nth((I_8 + 1) + 1, Root_3) end end)); _ -> lists:nth(J_7 + 1, (case erlang:is_map(Root_3) of true -> maps:get((I_8 + 1), Root_3, nil); _ -> case (I_8 + 1) < 0 of true -> lists:nth(erlang:length(Root_3) + (I_8 + 1) + 1, Root_3); _ -> lists:nth((I_8 + 1) + 1, Root_3) end end)) end end)) of
        true ->
            Left = (case (R /= I_8) of
    true -> (case erlang:is_map((case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)) of true -> maps:get((R - 1), (case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end), nil); _ -> case (R - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)) + (R - 1) + 1, (case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)); _ -> lists:nth((R - 1) + 1, (case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)) end end);
    _ -> 0
end),
            Right = (case (R /= J_7) of
    true -> (case erlang:is_map((case erlang:is_map(Dp_3) of true -> maps:get((R + 1), Dp_3, nil); _ -> case (R + 1) < 0 of true -> lists:nth(erlang:length(Dp_3) + (R + 1) + 1, Dp_3); _ -> lists:nth((R + 1) + 1, Dp_3) end end)) of true -> maps:get(J_7, (case erlang:is_map(Dp_3) of true -> maps:get((R + 1), Dp_3, nil); _ -> case (R + 1) < 0 of true -> lists:nth(erlang:length(Dp_3) + (R + 1) + 1, Dp_3); _ -> lists:nth((R + 1) + 1, Dp_3) end end), nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_3) of true -> maps:get((R + 1), Dp_3, nil); _ -> case (R + 1) < 0 of true -> lists:nth(erlang:length(Dp_3) + (R + 1) + 1, Dp_3); _ -> lists:nth((R + 1) + 1, Dp_3) end end)) + J_7 + 1, (case erlang:is_map(Dp_3) of true -> maps:get((R + 1), Dp_3, nil); _ -> case (R + 1) < 0 of true -> lists:nth(erlang:length(Dp_3) + (R + 1) + 1, Dp_3); _ -> lists:nth((R + 1) + 1, Dp_3) end end)); _ -> lists:nth(J_7 + 1, (case erlang:is_map(Dp_3) of true -> maps:get((R + 1), Dp_3, nil); _ -> case (R + 1) < 0 of true -> lists:nth(erlang:length(Dp_3) + (R + 1) + 1, Dp_3); _ -> lists:nth((R + 1) + 1, Dp_3) end end)) end end);
    _ -> 0
end),
            Cost = ((Left + (case erlang:is_map((case erlang:is_map(Total_3) of true -> maps:get(I_8, Total_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_3) + I_8 + 1, Total_3); _ -> lists:nth(I_8 + 1, Total_3) end end)) of true -> maps:get(J_7, (case erlang:is_map(Total_3) of true -> maps:get(I_8, Total_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_3) + I_8 + 1, Total_3); _ -> lists:nth(I_8 + 1, Total_3) end end), nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Total_3) of true -> maps:get(I_8, Total_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_3) + I_8 + 1, Total_3); _ -> lists:nth(I_8 + 1, Total_3) end end)) + J_7 + 1, (case erlang:is_map(Total_3) of true -> maps:get(I_8, Total_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_3) + I_8 + 1, Total_3); _ -> lists:nth(I_8 + 1, Total_3) end end)); _ -> lists:nth(J_7 + 1, (case erlang:is_map(Total_3) of true -> maps:get(I_8, Total_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Total_3) + I_8 + 1, Total_3); _ -> lists:nth(I_8 + 1, Total_3) end end)) end end)) + Right),
            case ((case erlang:is_map((case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)) of true -> maps:get(J_7, (case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end), nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)) + J_7 + 1, (case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)); _ -> lists:nth(J_7 + 1, (case erlang:is_map(Dp_3) of true -> maps:get(I_8, Dp_3, nil); _ -> case I_8 < 0 of true -> lists:nth(erlang:length(Dp_3) + I_8 + 1, Dp_3); _ -> lists:nth(I_8 + 1, Dp_3) end end)) end end) > Cost) of
        true -> Dp_4 = lists:sublist(Dp_3, I_8) ++ [lists:sublist(lists:nth(I_8 + 1, Dp_3), J_7) ++ [Cost] ++ lists:nthtail(J_7 + 1, lists:nth(I_8 + 1, Dp_3))] ++ lists:nthtail(I_8 + 1, Dp_3),
            Root_4 = lists:sublist(Root_3, I_8) ++ [lists:sublist(lists:nth(I_8 + 1, Root_3), J_7) ++ [R] ++ lists:nthtail(J_7 + 1, lists:nth(I_8 + 1, Root_3))] ++ lists:nthtail(I_8 + 1, Root_3),
            Dp_5 = Dp_4,
            Root_5 = Root_4;
        _ -> Dp_5 = Dp_3,
            Root_5 = Root_3
    end,
            R_2 = (R + 1),
            Fun_6_loop(INF, Dp_5, Freqs_2, I_8, Interval_length, J_7, Keys_3, N_2, Nodes_2, Original_nodes, R_2, Root_5, Total_3);
        _ -> {INF, Dp_3, Freqs_2, I_8, Interval_length, J_7, Keys_3, N_2, Nodes_2, Original_nodes, R, Root_3, Total_3}
    end
end,
{INF, Dp_5, Freqs_2, I_8, Interval_length, J_7, Keys_3, N_2, Nodes_2, Original_nodes, R_2, Root_5, Total_3} = Fun_6(INF, Dp_3, Freqs_2, I_8, Interval_length, J_7, Keys_3, N_2, Nodes_2, Original_nodes, R, Root_3, Total_3),
            I_9 = (I_8 + 1),
            Fun_7_loop(INF, Dp_5, Freqs_2, I_9, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3);
        _ -> {INF, Dp_2, Freqs_2, I_8, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2}
    end
end,
{INF, Dp_5, Freqs_2, I_9, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3} = Fun_7(INF, Dp_2, Freqs_2, I_8, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2),
            Interval_length_2 = (Interval_length + 1),
            Fun_8_loop(INF, Dp_5, Freqs_2, I_9, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3);
        _ -> {INF, Dp_2, Freqs_2, I_7, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2}
    end
end,
{INF, Dp_5, Freqs_2, I_9, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3} = Fun_8(INF, Dp_2, Freqs_2, I_7, Interval_length, Keys_3, N_2, Nodes_2, Original_nodes, Root_3, Total_2),
        io:format("~ts~n", [mochi_repr("Binary search tree nodes:")]),
        I_10 = 0,
        Fun_9 = fun Fun_9_loop(INF, Dp_5, Freqs_2, I_10, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3) ->
    case (I_10 < N_2) of
        true ->
            print_node((case erlang:is_map(Nodes_2) of true -> maps:get(I_10, Nodes_2, nil); _ -> case I_10 < 0 of true -> lists:nth(erlang:length(Nodes_2) + I_10 + 1, Nodes_2); _ -> lists:nth(I_10 + 1, Nodes_2) end end)),
            I_11 = (I_10 + 1),
            Fun_9_loop(INF, Dp_5, Freqs_2, I_11, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3);
        _ -> {INF, Dp_5, Freqs_2, I_10, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3}
    end
end,
{INF, Dp_5, Freqs_2, I_11, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3} = Fun_9(INF, Dp_5, Freqs_2, I_10, Interval_length_2, Keys_3, N_2, Nodes_2, Original_nodes, Root_5, Total_3),
        io:format("~ts~n", [mochi_repr((("\nThe cost of optimal BST for given tree nodes is " ++ mochi_str((case erlang:is_map((case erlang:is_map(Dp_5) of true -> maps:get(0, Dp_5, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Dp_5) + 0 + 1, Dp_5); _ -> lists:nth(0 + 1, Dp_5) end end)) of true -> maps:get((N_2 - 1), (case erlang:is_map(Dp_5) of true -> maps:get(0, Dp_5, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Dp_5) + 0 + 1, Dp_5); _ -> lists:nth(0 + 1, Dp_5) end end), nil); _ -> case (N_2 - 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dp_5) of true -> maps:get(0, Dp_5, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Dp_5) + 0 + 1, Dp_5); _ -> lists:nth(0 + 1, Dp_5) end end)) + (N_2 - 1) + 1, (case erlang:is_map(Dp_5) of true -> maps:get(0, Dp_5, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Dp_5) + 0 + 1, Dp_5); _ -> lists:nth(0 + 1, Dp_5) end end)); _ -> lists:nth((N_2 - 1) + 1, (case erlang:is_map(Dp_5) of true -> maps:get(0, Dp_5, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Dp_5) + 0 + 1, Dp_5); _ -> lists:nth(0 + 1, Dp_5) end end)) end end))) ++ "."))]),
        print_binary_search_tree(Root_5, Keys_3, 0, (N_2 - 1), -1, false),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Nodes_3 = [#{"key" => 12, "freq" => 8}, #{"key" => 10, "freq" => 34}, #{"key" => 20, "freq" => 50}, #{"key" => 42, "freq" => 3}, #{"key" => 25, "freq" => 40}, #{"key" => 37, "freq" => 30}],
        find_optimal_binary_search_tree(Nodes_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
