#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, distance_sq/2, mean/1, k_means/3, main/0]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

distance_sq(A, B) ->
    try
        Sum = 0,
        I = 0,
        Fun = fun Fun_loop(A, B, I, Sum) ->
    case (I < erlang:length(A)) of
        true ->
            Diff = ((case erlang:is_map(A) of true -> maps:get(I, A, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(A) + I + 1, A); _ -> lists:nth(I + 1, A) end end) - (case erlang:is_map(B) of true -> maps:get(I, B, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(B) + I + 1, B); _ -> lists:nth(I + 1, B) end end)),
            Sum_2 = (Sum + mochi_safe_mul(Diff, Diff)),
            I_2 = (I + 1),
            Fun_loop(A, B, I_2, Sum_2);
        _ -> {A, B, I, Sum}
    end
end,
{A, B, I_2, Sum_2} = Fun(A, B, I, Sum),
        Sum_2
    catch {return, Ret} -> Ret end.

mean(Vectors) ->
    try
        Dim = erlang:length((case erlang:is_map(Vectors) of true -> maps:get(0, Vectors, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Vectors) + 0 + 1, Vectors); _ -> lists:nth(0 + 1, Vectors) end end)),
        Res = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Dim, I_3, Res, Vectors) ->
    case (I_3 < Dim) of
        true ->
            Total = 0,
            J = 0,
            Fun_2 = fun Fun_2_loop(Dim, I_3, J, Res, Total, Vectors) ->
    case (J < erlang:length(Vectors)) of
        true ->
            Total_2 = (Total + (case erlang:is_map((case erlang:is_map(Vectors) of true -> maps:get(J, Vectors, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Vectors) + J + 1, Vectors); _ -> lists:nth(J + 1, Vectors) end end)) of true -> maps:get(I_3, (case erlang:is_map(Vectors) of true -> maps:get(J, Vectors, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Vectors) + J + 1, Vectors); _ -> lists:nth(J + 1, Vectors) end end), nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Vectors) of true -> maps:get(J, Vectors, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Vectors) + J + 1, Vectors); _ -> lists:nth(J + 1, Vectors) end end)) + I_3 + 1, (case erlang:is_map(Vectors) of true -> maps:get(J, Vectors, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Vectors) + J + 1, Vectors); _ -> lists:nth(J + 1, Vectors) end end)); _ -> lists:nth(I_3 + 1, (case erlang:is_map(Vectors) of true -> maps:get(J, Vectors, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Vectors) + J + 1, Vectors); _ -> lists:nth(J + 1, Vectors) end end)) end end)),
            J_2 = (J + 1),
            Fun_2_loop(Dim, I_3, J_2, Res, Total_2, Vectors);
        _ -> {Dim, I_3, J, Res, Total, Vectors}
    end
end,
{Dim, I_3, J_2, Res, Total_2, Vectors} = Fun_2(Dim, I_3, J, Res, Total, Vectors),
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(Total_2 div erlang:length(Vectors))]),
            I_4 = (I_3 + 1),
            Fun_3_loop(Dim, I_4, Res_2, Vectors);
        _ -> {Dim, I_3, Res, Vectors}
    end
end,
{Dim, I_4, Res_2, Vectors} = Fun_3(Dim, I_3, Res, Vectors),
        Res_2
    catch {return, Ret} -> Ret end.

k_means(Vectors_2, K, Iterations) ->
    try
        Centroids = [],
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(Centroids, I_5, Iterations, K, Vectors_2) ->
    case (I_5 < K) of
        true ->
            Centroids_2 = lists:append((case Centroids of nil -> []; _ -> Centroids end), [(case erlang:is_map(Vectors_2) of true -> maps:get(I_5, Vectors_2, nil); _ -> case I_5 < 0 of true -> lists:nth(erlang:length(Vectors_2) + I_5 + 1, Vectors_2); _ -> lists:nth(I_5 + 1, Vectors_2) end end)]),
            I_6 = (I_5 + 1),
            Fun_4_loop(Centroids_2, I_6, Iterations, K, Vectors_2);
        _ -> {Centroids, I_5, Iterations, K, Vectors_2}
    end
end,
{Centroids_2, I_6, Iterations, K, Vectors_2} = Fun_4(Centroids, I_5, Iterations, K, Vectors_2),
        Assignments = [],
        N = erlang:length(Vectors_2),
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(Assignments, Centroids_2, I_7, Iterations, K, N, Vectors_2) ->
    case (I_7 < N) of
        true ->
            Assignments_2 = lists:append((case Assignments of nil -> []; _ -> Assignments end), [0]),
            I_8 = (I_7 + 1),
            Fun_5_loop(Assignments_2, Centroids_2, I_8, Iterations, K, N, Vectors_2);
        _ -> {Assignments, Centroids_2, I_7, Iterations, K, N, Vectors_2}
    end
end,
{Assignments_2, Centroids_2, I_8, Iterations, K, N, Vectors_2} = Fun_5(Assignments, Centroids_2, I_7, Iterations, K, N, Vectors_2),
        It = 0,
        Fun_10 = fun Fun_10_loop(Assignments_2, Centroids_2, I_8, It, Iterations, K, N, Vectors_2) ->
    case (It < Iterations) of
        true ->
            V = 0,
            Fun_7 = fun Fun_7_loop(Assignments_2, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2) ->
    case (V < N) of
        true ->
            Best = 0,
            BestDist = distance_sq((case erlang:is_map(Vectors_2) of true -> maps:get(V, Vectors_2, nil); _ -> case V < 0 of true -> lists:nth(erlang:length(Vectors_2) + V + 1, Vectors_2); _ -> lists:nth(V + 1, Vectors_2) end end), (case erlang:is_map(Centroids_2) of true -> maps:get(0, Centroids_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Centroids_2) + 0 + 1, Centroids_2); _ -> lists:nth(0 + 1, Centroids_2) end end)),
            C = 1,
            Fun_6 = fun Fun_6_loop(Assignments_2, Best, BestDist, C, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2) ->
    case (C < K) of
        true ->
            D = distance_sq((case erlang:is_map(Vectors_2) of true -> maps:get(V, Vectors_2, nil); _ -> case V < 0 of true -> lists:nth(erlang:length(Vectors_2) + V + 1, Vectors_2); _ -> lists:nth(V + 1, Vectors_2) end end), (case erlang:is_map(Centroids_2) of true -> maps:get(C, Centroids_2, nil); _ -> case C < 0 of true -> lists:nth(erlang:length(Centroids_2) + C + 1, Centroids_2); _ -> lists:nth(C + 1, Centroids_2) end end)),
            case (D < BestDist) of
        true -> BestDist_2 = D,
            Best_2 = C,
            Best_3 = Best_2,
            BestDist_3 = BestDist_2;
        _ -> Best_3 = Best,
            BestDist_3 = BestDist
    end,
            C_2 = (C + 1),
            Fun_6_loop(Assignments_2, Best_3, BestDist_3, C_2, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2);
        _ -> {Assignments_2, Best, BestDist, C, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2}
    end
end,
{Assignments_2, Best_3, BestDist_3, C_2, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2} = Fun_6(Assignments_2, Best, BestDist, C, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2),
            Assignments_3 = lists:sublist(Assignments_2, V) ++ [Best_3] ++ lists:nthtail(V + 1, Assignments_2),
            V_2 = (V + 1),
            Fun_7_loop(Assignments_3, Centroids_2, I_8, It, Iterations, K, N, V_2, Vectors_2);
        _ -> {Assignments_2, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2}
    end
end,
{Assignments_3, Centroids_2, I_8, It, Iterations, K, N, V_2, Vectors_2} = Fun_7(Assignments_2, Centroids_2, I_8, It, Iterations, K, N, V, Vectors_2),
            CIdx = 0,
            Fun_9 = fun Fun_9_loop(Assignments_3, CIdx, Centroids_2, I_8, It, Iterations, K, N, V_2, Vectors_2) ->
    case (CIdx < K) of
        true ->
            Cluster = [],
            V2 = 0,
            Fun_8 = fun Fun_8_loop(Assignments_3, CIdx, Centroids_2, Cluster, I_8, It, Iterations, K, N, V_2, V2, Vectors_2) ->
    case (V2 < N) of
        true ->
            case ((case erlang:is_map(Assignments_3) of true -> maps:get(V2, Assignments_3, nil); _ -> case V2 < 0 of true -> lists:nth(erlang:length(Assignments_3) + V2 + 1, Assignments_3); _ -> lists:nth(V2 + 1, Assignments_3) end end) == CIdx) of
        true -> Cluster_2 = lists:append((case Cluster of nil -> []; _ -> Cluster end), [(case erlang:is_map(Vectors_2) of true -> maps:get(V2, Vectors_2, nil); _ -> case V2 < 0 of true -> lists:nth(erlang:length(Vectors_2) + V2 + 1, Vectors_2); _ -> lists:nth(V2 + 1, Vectors_2) end end)]),
            Cluster_3 = Cluster_2;
        _ -> Cluster_3 = Cluster
    end,
            V2_2 = (V2 + 1),
            Fun_8_loop(Assignments_3, CIdx, Centroids_2, Cluster_3, I_8, It, Iterations, K, N, V_2, V2_2, Vectors_2);
        _ -> {Assignments_3, CIdx, Centroids_2, Cluster, I_8, It, Iterations, K, N, V_2, V2, Vectors_2}
    end
end,
{Assignments_3, CIdx, Centroids_2, Cluster_3, I_8, It, Iterations, K, N, V_2, V2_2, Vectors_2} = Fun_8(Assignments_3, CIdx, Centroids_2, Cluster, I_8, It, Iterations, K, N, V_2, V2, Vectors_2),
            case (erlang:length(Cluster_3) > 0) of
        true -> Centroids_3 = lists:sublist(Centroids_2, CIdx) ++ [mean(Cluster_3)] ++ lists:nthtail(CIdx + 1, Centroids_2),
            Centroids_4 = Centroids_3;
        _ -> Centroids_4 = Centroids_2
    end,
            CIdx_2 = (CIdx + 1),
            Fun_9_loop(Assignments_3, CIdx_2, Centroids_4, I_8, It, Iterations, K, N, V_2, Vectors_2);
        _ -> {Assignments_3, CIdx, Centroids_2, I_8, It, Iterations, K, N, V_2, Vectors_2}
    end
end,
{Assignments_3, CIdx_2, Centroids_4, I_8, It, Iterations, K, N, V_2, Vectors_2} = Fun_9(Assignments_3, CIdx, Centroids_2, I_8, It, Iterations, K, N, V_2, Vectors_2),
            It_2 = (It + 1),
            Fun_10_loop(Assignments_3, Centroids_4, I_8, It_2, Iterations, K, N, Vectors_2);
        _ -> {Assignments_2, Centroids_2, I_8, It, Iterations, K, N, Vectors_2}
    end
end,
{Assignments_3, Centroids_4, I_8, It_2, Iterations, K, N, Vectors_2} = Fun_10(Assignments_2, Centroids_2, I_8, It, Iterations, K, N, Vectors_2),
        #{"centroids" => Centroids_4, "assignments" => Assignments_3}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Vectors_3 = [[1, 2], [1.5, 1.8], [5, 8], [8, 8], [1, 0.6], [9, 11]],
        Result = k_means(Vectors_3, 2, 5),
        io:format("~ts~n", [mochi_str(maps:get("centroids", Result, nil))]),
        io:format("~ts~n", [mochi_str(maps:get("assignments", Result, nil))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
