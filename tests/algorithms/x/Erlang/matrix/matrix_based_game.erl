#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, is_alnum/1, to_int/1, split/2, parse_moves/1, validate_matrix_size/1, validate_matrix_content/2, validate_moves/2, contains/3, find_repeat/4, increment_score/1, move_x/3, move_y/2, play/4, build_matrix/1, process_game/3, main/0]).

% Generated by Mochi transpiler v0.10.61 (c45765bf43) on 2025-08-08 15:36 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

is_alnum(Ch) ->
    try
        ((((Ch >= "0") andalso (Ch =< "9")) orelse ((Ch >= "A") andalso (Ch =< "Z"))) orelse ((Ch >= "a") andalso (Ch =< "z")))
    catch {return, Ret} -> Ret end.

to_int(Token) ->
    try
        Res = 0,
        I = 0,
        Fun = fun Fun_loop(I, Res, Token) ->
    case (I < erlang:length(Token)) of
        true ->
            Res_2 = ((Res * 10) + mochi_to_int(string:substr(Token, I + 1, ((I + 1) - I)))),
            I_2 = (I + 1),
            Fun_loop(I_2, Res_2, Token);
        _ -> {I, Res, Token}
    end
end,
{I_2, Res_2, Token} = Fun(I, Res, Token),
        Res_2
    catch {return, Ret} -> Ret end.

split(S, Sep) ->
    try
        Res_3 = [],
        Current = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Current, I_3, Res_3, S, Sep) ->
    case (I_3 < erlang:length(S)) of
        true ->
            Ch_2 = string:substr(S, I_3 + 1, ((I_3 + 1) - I_3)),
            case (Ch_2 == Sep) of
        true -> Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [Current]),
            Current_2 = "",
            Current_4 = Current_2,
            Res_5 = Res_4;
        _ -> Current_3 = (Current ++ Ch_2),
            Current_4 = Current_3,
            Res_5 = Res_3
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Current_4, I_4, Res_5, S, Sep);
        _ -> {Current, I_3, Res_3, S, Sep}
    end
end,
{Current_4, I_4, Res_5, S, Sep} = Fun_2(Current, I_3, Res_3, S, Sep),
        Res_6 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [Current_4]),
        Res_6
    catch {return, Ret} -> Ret end.

parse_moves(Input_str) ->
    try
        Pairs = string:tokens(Input_str, ","),
        Moves = [],
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(I_5, Input_str, Moves, Pairs) ->
    case (I_5 < erlang:length(Pairs)) of
        true ->
            Pair = string:substr(Pairs, I_5 + 1, 1),
            Numbers = [],
            Num = "",
            J = 0,
            Fun_3 = fun Fun_3_loop(I_5, Input_str, J, Moves, Num, Numbers, Pair, Pairs) ->
    case (J < erlang:length(Pair)) of
        true ->
            Ch_3 = string:substr(Pair, J + 1, ((J + 1) - J)),
            case (Ch_3 == " ") of
        true -> case (Num /= "") of
        true -> Numbers_2 = lists:append((case Numbers of nil -> []; _ -> Numbers end), [Num]),
            Num_2 = "",
            Num_3 = Num_2,
            Numbers_3 = Numbers_2;
        _ -> Num_3 = Num,
            Numbers_3 = Numbers
    end,
            Num_5 = Num_3,
            Numbers_4 = Numbers_3;
        _ -> Num_4 = (Num ++ Ch_3),
            Num_5 = Num_4,
            Numbers_4 = Numbers
    end,
            J_2 = (J + 1),
            Fun_3_loop(I_5, Input_str, J_2, Moves, Num_5, Numbers_4, Pair, Pairs);
        _ -> {I_5, Input_str, J, Moves, Num, Numbers, Pair, Pairs}
    end
end,
{I_5, Input_str, J_2, Moves, Num_5, Numbers_4, Pair, Pairs} = Fun_3(I_5, Input_str, J, Moves, Num, Numbers, Pair, Pairs),
            case (Num_5 /= "") of
        true -> Numbers_5 = lists:append((case Numbers_4 of nil -> []; _ -> Numbers_4 end), [Num_5]),
            Numbers_6 = Numbers_5;
        _ -> Numbers_6 = Numbers_4
    end,
            case (erlang:length(Numbers_6) /= 2) of
        true -> erlang:error("Each move must have exactly two numbers.");
        _ -> ok
    end,
            X = to_int((case erlang:is_map(Numbers_6) of true -> maps:get(0, Numbers_6, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Numbers_6) + 0 + 1, Numbers_6); _ -> mochi_nth(0 + 1, Numbers_6) end end)),
            Y = to_int((case erlang:is_map(Numbers_6) of true -> maps:get(1, Numbers_6, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(Numbers_6) + 1 + 1, Numbers_6); _ -> mochi_nth(1 + 1, Numbers_6) end end)),
            Moves_2 = lists:append((case Moves of nil -> []; _ -> Moves end), [#{"x" => X, "y" => Y}]),
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, Input_str, Moves_2, Pairs);
        _ -> {I_5, Input_str, Moves, Pairs}
    end
end,
{I_6, Input_str, Moves_2, Pairs} = Fun_4(I_5, Input_str, Moves, Pairs),
        Moves_2
    catch {return, Ret} -> Ret end.

validate_matrix_size(Size) ->
    try
        case (Size =< 0) of
        true -> erlang:error("Matrix size must be a positive integer.");
        _ -> ok
    end,
        nil
    catch {return, Ret} -> Ret end.

validate_matrix_content(Matrix, Size_2) ->
    try
        case (erlang:length(Matrix) /= Size_2) of
        true -> erlang:error("The matrix dont match with size.");
        _ -> ok
    end,
        I_7 = 0,
        Fun_6 = fun Fun_6_loop(I_7, Matrix, Size_2) ->
    case (I_7 < Size_2) of
        true ->
            Row = (case erlang:is_map(Matrix) of true -> maps:get(I_7, Matrix, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Matrix) + I_7 + 1, Matrix); _ -> mochi_nth(I_7 + 1, Matrix) end end),
            case (erlang:length(Row) /= Size_2) of
        true -> erlang:error((("Each row in the matrix must have exactly " ++ mochi_str(Size_2)) ++ " characters."));
        _ -> ok
    end,
            J_3 = 0,
            Fun_5 = fun Fun_5_loop(I_7, J_3, Matrix, Row, Size_2) ->
    case (J_3 < Size_2) of
        true ->
            Ch_4 = string:substr(Row, J_3 + 1, ((J_3 + 1) - J_3)),
            case mochi_not(is_alnum(Ch_4)) of
        true -> erlang:error("Matrix rows can only contain letters and numbers.");
        _ -> ok
    end,
            J_4 = (J_3 + 1),
            Fun_5_loop(I_7, J_4, Matrix, Row, Size_2);
        _ -> {I_7, J_3, Matrix, Row, Size_2}
    end
end,
{I_7, J_4, Matrix, Row, Size_2} = Fun_5(I_7, J_3, Matrix, Row, Size_2),
            I_8 = (I_7 + 1),
            Fun_6_loop(I_8, Matrix, Size_2);
        _ -> {I_7, Matrix, Size_2}
    end
end,
{I_8, Matrix, Size_2} = Fun_6(I_7, Matrix, Size_2),
        nil
    catch {return, Ret} -> Ret end.

validate_moves(Moves_3, Size_3) ->
    try
        I_9 = 0,
        Fun_7 = fun Fun_7_loop(I_9, Moves_3, Size_3) ->
    case (I_9 < erlang:length(Moves_3)) of
        true ->
            Mv = (case erlang:is_map(Moves_3) of true -> maps:get(I_9, Moves_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Moves_3) + I_9 + 1, Moves_3); _ -> mochi_nth(I_9 + 1, Moves_3) end end),
            case ((((maps:get("x", Mv, nil) < 0) orelse (maps:get("x", Mv, nil) >= Size_3)) orelse (maps:get("y", Mv, nil) < 0)) orelse (maps:get("y", Mv, nil) >= Size_3)) of
        true -> erlang:error("Move is out of bounds for a matrix.");
        _ -> ok
    end,
            I_10 = (I_9 + 1),
            Fun_7_loop(I_10, Moves_3, Size_3);
        _ -> {I_9, Moves_3, Size_3}
    end
end,
{I_10, Moves_3, Size_3} = Fun_7(I_9, Moves_3, Size_3),
        nil
    catch {return, Ret} -> Ret end.

contains(Pos, R, C) ->
    try
        I_11 = 0,
        Fun_8 = fun Fun_8_loop(C, I_11, Pos, R) ->
    case (I_11 < erlang:length(Pos)) of
        true ->
            P = (case erlang:is_map(Pos) of true -> maps:get(I_11, Pos, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Pos) + I_11 + 1, Pos); _ -> mochi_nth(I_11 + 1, Pos) end end),
            case ((maps:get("x", P, nil) == R) andalso (maps:get("y", P, nil) == C)) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_12 = (I_11 + 1),
            Fun_8_loop(C, I_12, Pos, R);
        _ -> {C, I_11, Pos, R}
    end
end,
{C, I_12, Pos, R} = Fun_8(C, I_11, Pos, R),
        false
    catch {return, Ret} -> Ret end.

find_repeat(Matrix_g, Row_2, Column, Size_4) ->
    try
        Column_2 = ((Size_4 - 1) - Column),
        Visited = [],
        Repeated = [],
        Color = (case erlang:is_map((case erlang:is_map(Matrix_g) of true -> maps:get(Column_2, Matrix_g, nil); _ -> case Column_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g) + Column_2 + 1, Matrix_g); _ -> mochi_nth(Column_2 + 1, Matrix_g) end end)) of true -> maps:get(Row_2, (case erlang:is_map(Matrix_g) of true -> maps:get(Column_2, Matrix_g, nil); _ -> case Column_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g) + Column_2 + 1, Matrix_g); _ -> mochi_nth(Column_2 + 1, Matrix_g) end end), nil); _ -> case Row_2 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Matrix_g) of true -> maps:get(Column_2, Matrix_g, nil); _ -> case Column_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g) + Column_2 + 1, Matrix_g); _ -> mochi_nth(Column_2 + 1, Matrix_g) end end)) + Row_2 + 1, (case erlang:is_map(Matrix_g) of true -> maps:get(Column_2, Matrix_g, nil); _ -> case Column_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g) + Column_2 + 1, Matrix_g); _ -> mochi_nth(Column_2 + 1, Matrix_g) end end)); _ -> mochi_nth(Row_2 + 1, (case erlang:is_map(Matrix_g) of true -> maps:get(Column_2, Matrix_g, nil); _ -> case Column_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g) + Column_2 + 1, Matrix_g); _ -> mochi_nth(Column_2 + 1, Matrix_g) end end)) end end),
        case (Color == "-") of
        true -> throw({return, Repeated});
        _ -> ok
    end,
        Stack = [#{"x" => Column_2, "y" => Row_2}],
        Fun_9 = fun Fun_9_loop(Color, Column_2, Matrix_g, Repeated, Row_2, Size_4, Stack, Visited) ->
    case (erlang:length(Stack) > 0) of
        true ->
            try
                Idx = (erlang:length(Stack) - 1),
                Pos_2 = (case erlang:is_map(Stack) of true -> maps:get(Idx, Stack, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Stack) + Idx + 1, Stack); _ -> mochi_nth(Idx + 1, Stack) end end),
                Stack_2 = lists:sublist(Stack, 0 + 1, (Idx - 0)),
                case ((((maps:get("x", Pos_2, nil) < 0) orelse (maps:get("x", Pos_2, nil) >= Size_4)) orelse (maps:get("y", Pos_2, nil) < 0)) orelse (maps:get("y", Pos_2, nil) >= Size_4)) of
        true -> throw({continue, Color, Column_2, Matrix_g, Repeated, Row_2, Size_4, Stack_2, Visited});
        _ -> ok
    end,
                case contains(Visited, maps:get("x", Pos_2, nil), maps:get("y", Pos_2, nil)) of
        true -> throw({continue, Color, Column_2, Matrix_g, Repeated, Row_2, Size_4, Stack_2, Visited});
        _ -> ok
    end,
                Visited_2 = lists:append((case Visited of nil -> []; _ -> Visited end), [Pos_2]),
                case ((case erlang:is_map((case erlang:is_map(Matrix_g) of true -> maps:get(maps:get("x", Pos_2, nil), Matrix_g, nil); _ -> case maps:get("x", Pos_2, nil) < 0 of true -> mochi_nth(erlang:length(Matrix_g) + maps:get("x", Pos_2, nil) + 1, Matrix_g); _ -> mochi_nth(maps:get("x", Pos_2, nil) + 1, Matrix_g) end end)) of true -> maps:get(maps:get("y", Pos_2, nil), (case erlang:is_map(Matrix_g) of true -> maps:get(maps:get("x", Pos_2, nil), Matrix_g, nil); _ -> case maps:get("x", Pos_2, nil) < 0 of true -> mochi_nth(erlang:length(Matrix_g) + maps:get("x", Pos_2, nil) + 1, Matrix_g); _ -> mochi_nth(maps:get("x", Pos_2, nil) + 1, Matrix_g) end end), nil); _ -> case maps:get("y", Pos_2, nil) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Matrix_g) of true -> maps:get(maps:get("x", Pos_2, nil), Matrix_g, nil); _ -> case maps:get("x", Pos_2, nil) < 0 of true -> mochi_nth(erlang:length(Matrix_g) + maps:get("x", Pos_2, nil) + 1, Matrix_g); _ -> mochi_nth(maps:get("x", Pos_2, nil) + 1, Matrix_g) end end)) + maps:get("y", Pos_2, nil) + 1, (case erlang:is_map(Matrix_g) of true -> maps:get(maps:get("x", Pos_2, nil), Matrix_g, nil); _ -> case maps:get("x", Pos_2, nil) < 0 of true -> mochi_nth(erlang:length(Matrix_g) + maps:get("x", Pos_2, nil) + 1, Matrix_g); _ -> mochi_nth(maps:get("x", Pos_2, nil) + 1, Matrix_g) end end)); _ -> mochi_nth(maps:get("y", Pos_2, nil) + 1, (case erlang:is_map(Matrix_g) of true -> maps:get(maps:get("x", Pos_2, nil), Matrix_g, nil); _ -> case maps:get("x", Pos_2, nil) < 0 of true -> mochi_nth(erlang:length(Matrix_g) + maps:get("x", Pos_2, nil) + 1, Matrix_g); _ -> mochi_nth(maps:get("x", Pos_2, nil) + 1, Matrix_g) end end)) end end) == Color) of
        true -> Repeated_2 = lists:append((case Repeated of nil -> []; _ -> Repeated end), [Pos_2]),
            Stack_3 = lists:append((case Stack_2 of nil -> []; _ -> Stack_2 end), [#{"x" => (maps:get("x", Pos_2, nil) - 1), "y" => maps:get("y", Pos_2, nil)}]),
            Stack_4 = lists:append((case Stack_3 of nil -> []; _ -> Stack_3 end), [#{"x" => (maps:get("x", Pos_2, nil) + 1), "y" => maps:get("y", Pos_2, nil)}]),
            Stack_5 = lists:append((case Stack_4 of nil -> []; _ -> Stack_4 end), [#{"x" => maps:get("x", Pos_2, nil), "y" => (maps:get("y", Pos_2, nil) - 1)}]),
            Stack_6 = lists:append((case Stack_5 of nil -> []; _ -> Stack_5 end), [#{"x" => maps:get("x", Pos_2, nil), "y" => (maps:get("y", Pos_2, nil) + 1)}]),
            Repeated_3 = Repeated_2,
            Stack_7 = Stack_6;
        _ -> Repeated_3 = Repeated,
            Stack_7 = Stack_2
    end,
                Fun_9_loop(Color, Column_2, Matrix_g, Repeated_3, Row_2, Size_4, Stack_7, Visited_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_9_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                {break, B0, B1, B2, B3, B4, B5, B6, B7} -> {B0, B1, B2, B3, B4, B5, B6, B7}
            end;
        _ -> {Color, Column_2, Matrix_g, Repeated, Row_2, Size_4, Stack, Visited}
    end
end,
{Color, Column_2, Matrix_g, Repeated_3, Row_2, Size_4, Stack_7, Visited_2} = Fun_9(Color, Column_2, Matrix_g, Repeated, Row_2, Size_4, Stack, Visited),
        Repeated_3
    catch {return, Ret} -> Ret end.

increment_score(Count) ->
    try
        ((Count * (Count + 1)) div 2)
    catch {return, Ret} -> Ret end.

move_x(Matrix_g_2, Column_3, Size_5) ->
    try
        New_list = [],
        Row_3 = 0,
        Fun_10 = fun Fun_10_loop(Column_3, Matrix_g_2, New_list, Row_3, Size_5) ->
    case (Row_3 < Size_5) of
        true ->
            Val = (case erlang:is_map((case erlang:is_map(Matrix_g_2) of true -> maps:get(Row_3, Matrix_g_2, nil); _ -> case Row_3 < 0 of true -> mochi_nth(erlang:length(Matrix_g_2) + Row_3 + 1, Matrix_g_2); _ -> mochi_nth(Row_3 + 1, Matrix_g_2) end end)) of true -> maps:get(Column_3, (case erlang:is_map(Matrix_g_2) of true -> maps:get(Row_3, Matrix_g_2, nil); _ -> case Row_3 < 0 of true -> mochi_nth(erlang:length(Matrix_g_2) + Row_3 + 1, Matrix_g_2); _ -> mochi_nth(Row_3 + 1, Matrix_g_2) end end), nil); _ -> case Column_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Matrix_g_2) of true -> maps:get(Row_3, Matrix_g_2, nil); _ -> case Row_3 < 0 of true -> mochi_nth(erlang:length(Matrix_g_2) + Row_3 + 1, Matrix_g_2); _ -> mochi_nth(Row_3 + 1, Matrix_g_2) end end)) + Column_3 + 1, (case erlang:is_map(Matrix_g_2) of true -> maps:get(Row_3, Matrix_g_2, nil); _ -> case Row_3 < 0 of true -> mochi_nth(erlang:length(Matrix_g_2) + Row_3 + 1, Matrix_g_2); _ -> mochi_nth(Row_3 + 1, Matrix_g_2) end end)); _ -> mochi_nth(Column_3 + 1, (case erlang:is_map(Matrix_g_2) of true -> maps:get(Row_3, Matrix_g_2, nil); _ -> case Row_3 < 0 of true -> mochi_nth(erlang:length(Matrix_g_2) + Row_3 + 1, Matrix_g_2); _ -> mochi_nth(Row_3 + 1, Matrix_g_2) end end)) end end),
            case (Val /= "-") of
        true -> New_list_2 = lists:append((case New_list of nil -> []; _ -> New_list end), [Val]),
            New_list_4 = New_list_2;
        _ -> New_list_3 = lists:append([Val], New_list),
            New_list_4 = New_list_3
    end,
            Row_4 = (Row_3 + 1),
            Fun_10_loop(Column_3, Matrix_g_2, New_list_4, Row_4, Size_5);
        _ -> {Column_3, Matrix_g_2, New_list, Row_3, Size_5}
    end
end,
{Column_3, Matrix_g_2, New_list_4, Row_4, Size_5} = Fun_10(Column_3, Matrix_g_2, New_list, Row_3, Size_5),
        Row_5 = 0,
        Fun_11 = fun Fun_11_loop(Column_3, Matrix_g_2, New_list_4, Row_5, Size_5) ->
    case (Row_5 < Size_5) of
        true ->
            Matrix_g_3 = lists:sublist(Matrix_g_2, Row_5) ++ [lists:sublist(lists:nth(Row_5 + 1, Matrix_g_2), Column_3) ++ [(case erlang:is_map(New_list_4) of true -> maps:get(Row_5, New_list_4, nil); _ -> case Row_5 < 0 of true -> mochi_nth(erlang:length(New_list_4) + Row_5 + 1, New_list_4); _ -> mochi_nth(Row_5 + 1, New_list_4) end end)] ++ lists:nthtail(Column_3 + 1, lists:nth(Row_5 + 1, Matrix_g_2))] ++ lists:nthtail(Row_5 + 1, Matrix_g_2),
            Row_6 = (Row_5 + 1),
            Fun_11_loop(Column_3, Matrix_g_3, New_list_4, Row_6, Size_5);
        _ -> {Column_3, Matrix_g_2, New_list_4, Row_5, Size_5}
    end
end,
{Column_3, Matrix_g_3, New_list_4, Row_6, Size_5} = Fun_11(Column_3, Matrix_g_2, New_list_4, Row_5, Size_5),
        Matrix_g_3
    catch {return, Ret} -> Ret end.

move_y(Matrix_g_4, Size_6) ->
    try
        Empty_cols = [],
        Column_4 = (Size_6 - 1),
        Fun_13 = fun Fun_13_loop(Column_4, Empty_cols, Matrix_g_4, Size_6) ->
    case (Column_4 >= 0) of
        true ->
            try
                Row_7 = 0,
                All_empty = true,
                Fun_12 = fun Fun_12_loop(All_empty, Column_4, Empty_cols, Matrix_g_4, Row_7, Size_6) ->
    case (Row_7 < Size_6) of
        true ->
            try
                case ((case erlang:is_map((case erlang:is_map(Matrix_g_4) of true -> maps:get(Row_7, Matrix_g_4, nil); _ -> case Row_7 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + Row_7 + 1, Matrix_g_4); _ -> mochi_nth(Row_7 + 1, Matrix_g_4) end end)) of true -> maps:get(Column_4, (case erlang:is_map(Matrix_g_4) of true -> maps:get(Row_7, Matrix_g_4, nil); _ -> case Row_7 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + Row_7 + 1, Matrix_g_4); _ -> mochi_nth(Row_7 + 1, Matrix_g_4) end end), nil); _ -> case Column_4 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Matrix_g_4) of true -> maps:get(Row_7, Matrix_g_4, nil); _ -> case Row_7 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + Row_7 + 1, Matrix_g_4); _ -> mochi_nth(Row_7 + 1, Matrix_g_4) end end)) + Column_4 + 1, (case erlang:is_map(Matrix_g_4) of true -> maps:get(Row_7, Matrix_g_4, nil); _ -> case Row_7 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + Row_7 + 1, Matrix_g_4); _ -> mochi_nth(Row_7 + 1, Matrix_g_4) end end)); _ -> mochi_nth(Column_4 + 1, (case erlang:is_map(Matrix_g_4) of true -> maps:get(Row_7, Matrix_g_4, nil); _ -> case Row_7 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + Row_7 + 1, Matrix_g_4); _ -> mochi_nth(Row_7 + 1, Matrix_g_4) end end)) end end) /= "-") of
        true -> All_empty_2 = false,
            throw({break, All_empty_2, Column_4, Empty_cols, Matrix_g_4, Row_7, Size_6}),
            All_empty_3 = All_empty_2;
        _ -> All_empty_3 = All_empty
    end,
                Row_8 = (Row_7 + 1),
                Fun_12_loop(All_empty_3, Column_4, Empty_cols, Matrix_g_4, Row_8, Size_6)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_12_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {All_empty, Column_4, Empty_cols, Matrix_g_4, Row_7, Size_6}
    end
end,
{All_empty_3, Column_4, Empty_cols, Matrix_g_4, Row_8, Size_6} = Fun_12(All_empty, Column_4, Empty_cols, Matrix_g_4, Row_7, Size_6),
                case (All_empty_3 /= nil) of
        true -> Empty_cols_2 = lists:append((case Empty_cols of nil -> []; _ -> Empty_cols end), [Column_4]),
            Empty_cols_3 = Empty_cols_2;
        _ -> Empty_cols_3 = Empty_cols
    end,
                Column_5 = (Column_4 - 1),
                Fun_13_loop(Column_5, Empty_cols_3, Matrix_g_4, Size_6)
            catch
                {continue, C0, C1, C2, C3} -> Fun_13_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {Column_4, Empty_cols, Matrix_g_4, Size_6}
    end
end,
{Column_5, Empty_cols_3, Matrix_g_4, Size_6} = Fun_13(Column_4, Empty_cols, Matrix_g_4, Size_6),
        I_13 = 0,
        Fun_17 = fun Fun_17_loop(Column_5, Empty_cols_3, I_13, Matrix_g_4, Size_6) ->
    case (I_13 < erlang:length(Empty_cols_3)) of
        true ->
            Col = (case erlang:is_map(Empty_cols_3) of true -> maps:get(I_13, Empty_cols_3, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(Empty_cols_3) + I_13 + 1, Empty_cols_3); _ -> mochi_nth(I_13 + 1, Empty_cols_3) end end),
            C_2 = (Col + 1),
            Fun_15 = fun Fun_15_loop(C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_4, Size_6) ->
    case (C_2 < Size_6) of
        true ->
            R_2 = 0,
            Fun_14 = fun Fun_14_loop(C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_4, R_2, Size_6) ->
    case (R_2 < Size_6) of
        true ->
            Matrix_g_5 = lists:sublist(Matrix_g_4, R_2) ++ [lists:sublist(lists:nth(R_2 + 1, Matrix_g_4), (C_2 - 1)) ++ [(case erlang:is_map((case erlang:is_map(Matrix_g_4) of true -> maps:get(R_2, Matrix_g_4, nil); _ -> case R_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + R_2 + 1, Matrix_g_4); _ -> mochi_nth(R_2 + 1, Matrix_g_4) end end)) of true -> maps:get(C_2, (case erlang:is_map(Matrix_g_4) of true -> maps:get(R_2, Matrix_g_4, nil); _ -> case R_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + R_2 + 1, Matrix_g_4); _ -> mochi_nth(R_2 + 1, Matrix_g_4) end end), nil); _ -> case C_2 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Matrix_g_4) of true -> maps:get(R_2, Matrix_g_4, nil); _ -> case R_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + R_2 + 1, Matrix_g_4); _ -> mochi_nth(R_2 + 1, Matrix_g_4) end end)) + C_2 + 1, (case erlang:is_map(Matrix_g_4) of true -> maps:get(R_2, Matrix_g_4, nil); _ -> case R_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + R_2 + 1, Matrix_g_4); _ -> mochi_nth(R_2 + 1, Matrix_g_4) end end)); _ -> mochi_nth(C_2 + 1, (case erlang:is_map(Matrix_g_4) of true -> maps:get(R_2, Matrix_g_4, nil); _ -> case R_2 < 0 of true -> mochi_nth(erlang:length(Matrix_g_4) + R_2 + 1, Matrix_g_4); _ -> mochi_nth(R_2 + 1, Matrix_g_4) end end)) end end)] ++ lists:nthtail((C_2 - 1) + 1, lists:nth(R_2 + 1, Matrix_g_4))] ++ lists:nthtail(R_2 + 1, Matrix_g_4),
            R_3 = (R_2 + 1),
            Fun_14_loop(C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, R_3, Size_6);
        _ -> {C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_4, R_2, Size_6}
    end
end,
{C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, R_3, Size_6} = Fun_14(C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_4, R_2, Size_6),
            C_3 = (C_2 + 1),
            Fun_15_loop(C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, Size_6);
        _ -> {C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_4, Size_6}
    end
end,
{C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, Size_6} = Fun_15(C_2, Col, Column_5, Empty_cols_3, I_13, Matrix_g_4, Size_6),
            R_4 = 0,
            Fun_16 = fun Fun_16_loop(C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, R_4, Size_6) ->
    case (R_4 < Size_6) of
        true ->
            Matrix_g_6 = lists:sublist(Matrix_g_5, R_4) ++ [lists:sublist(lists:nth(R_4 + 1, Matrix_g_5), (Size_6 - 1)) ++ ["-"] ++ lists:nthtail((Size_6 - 1) + 1, lists:nth(R_4 + 1, Matrix_g_5))] ++ lists:nthtail(R_4 + 1, Matrix_g_5),
            R_5 = (R_4 + 1),
            Fun_16_loop(C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_6, R_5, Size_6);
        _ -> {C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, R_4, Size_6}
    end
end,
{C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_6, R_5, Size_6} = Fun_16(C_3, Col, Column_5, Empty_cols_3, I_13, Matrix_g_5, R_4, Size_6),
            I_14 = (I_13 + 1),
            Fun_17_loop(Column_5, Empty_cols_3, I_14, Matrix_g_6, Size_6);
        _ -> {Column_5, Empty_cols_3, I_13, Matrix_g_4, Size_6}
    end
end,
{Column_5, Empty_cols_3, I_14, Matrix_g_6, Size_6} = Fun_17(Column_5, Empty_cols_3, I_13, Matrix_g_4, Size_6),
        Matrix_g_6
    catch {return, Ret} -> Ret end.

play(Matrix_g_7, Pos_x, Pos_y, Size_7) ->
    try
        Same_colors = find_repeat(Matrix_g_7, Pos_x, Pos_y, Size_7),
        case (erlang:length(Same_colors) /= 0) of
        true -> I_15 = 0,
            Fun_18 = fun Fun_18_loop(I_15, Matrix_g_7, Pos_x, Pos_y, Same_colors, Size_7) ->
    case (I_15 < erlang:length(Same_colors)) of
        true ->
            P_2 = (case erlang:is_map(Same_colors) of true -> maps:get(I_15, Same_colors, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Same_colors) + I_15 + 1, Same_colors); _ -> mochi_nth(I_15 + 1, Same_colors) end end),
            Matrix_g_8 = lists:sublist(Matrix_g_7, maps:get("x", P_2, nil)) ++ [lists:sublist(lists:nth(maps:get("x", P_2, nil) + 1, Matrix_g_7), maps:get("y", P_2, nil)) ++ ["-"] ++ lists:nthtail(maps:get("y", P_2, nil) + 1, lists:nth(maps:get("x", P_2, nil) + 1, Matrix_g_7))] ++ lists:nthtail(maps:get("x", P_2, nil) + 1, Matrix_g_7),
            I_16 = (I_15 + 1),
            Fun_18_loop(I_16, Matrix_g_8, Pos_x, Pos_y, Same_colors, Size_7);
        _ -> {I_15, Matrix_g_7, Pos_x, Pos_y, Same_colors, Size_7}
    end
end,
{I_16, Matrix_g_8, Pos_x, Pos_y, Same_colors, Size_7} = Fun_18(I_15, Matrix_g_7, Pos_x, Pos_y, Same_colors, Size_7),
            Column_6 = 0,
            Fun_19 = fun Fun_19_loop(Column_6, I_16, Matrix_g_8, Pos_x, Pos_y, Same_colors, Size_7) ->
    case (Column_6 < Size_7) of
        true ->
            Matrix_g_9 = move_x(Matrix_g_8, Column_6, Size_7),
            Column_7 = (Column_6 + 1),
            Fun_19_loop(Column_7, I_16, Matrix_g_9, Pos_x, Pos_y, Same_colors, Size_7);
        _ -> {Column_6, I_16, Matrix_g_8, Pos_x, Pos_y, Same_colors, Size_7}
    end
end,
{Column_7, I_16, Matrix_g_9, Pos_x, Pos_y, Same_colors, Size_7} = Fun_19(Column_6, I_16, Matrix_g_8, Pos_x, Pos_y, Same_colors, Size_7),
            Matrix_g_10 = move_y(Matrix_g_9, Size_7),
            Column_8 = Column_7,
            Fun_20 = Fun_19,
            I_17 = I_16,
            Matrix_g_11 = Matrix_g_10;
        _ -> Column_8 = nil,
            Fun_20 = nil,
            I_17 = nil,
            Matrix_g_11 = Matrix_g_7
    end,
        Sc = increment_score(erlang:length(Same_colors)),
        #{"matrix" => Matrix_g_11, "score" => Sc}
    catch {return, Ret} -> Ret end.

build_matrix(Matrix_2) ->
    try
        Res_7 = [],
        I_18 = 0,
        Fun_22 = fun Fun_22_loop(I_18, Matrix_2, Res_7) ->
    case (I_18 < erlang:length(Matrix_2)) of
        true ->
            Row_9 = (case erlang:is_map(Matrix_2) of true -> maps:get(I_18, Matrix_2, nil); _ -> case I_18 < 0 of true -> mochi_nth(erlang:length(Matrix_2) + I_18 + 1, Matrix_2); _ -> mochi_nth(I_18 + 1, Matrix_2) end end),
            Row_list = [],
            J_5 = 0,
            Fun_21 = fun Fun_21_loop(I_18, J_5, Matrix_2, Res_7, Row_9, Row_list) ->
    case (J_5 < erlang:length(Row_9)) of
        true ->
            Row_list_2 = lists:append((case Row_list of nil -> []; _ -> Row_list end), [string:substr(Row_9, J_5 + 1, ((J_5 + 1) - J_5))]),
            J_6 = (J_5 + 1),
            Fun_21_loop(I_18, J_6, Matrix_2, Res_7, Row_9, Row_list_2);
        _ -> {I_18, J_5, Matrix_2, Res_7, Row_9, Row_list}
    end
end,
{I_18, J_6, Matrix_2, Res_7, Row_9, Row_list_2} = Fun_21(I_18, J_5, Matrix_2, Res_7, Row_9, Row_list),
            Res_8 = lists:append((case Res_7 of nil -> []; _ -> Res_7 end), [Row_list_2]),
            I_19 = (I_18 + 1),
            Fun_22_loop(I_19, Matrix_2, Res_8);
        _ -> {I_18, Matrix_2, Res_7}
    end
end,
{I_19, Matrix_2, Res_8} = Fun_22(I_18, Matrix_2, Res_7),
        Res_8
    catch {return, Ret} -> Ret end.

process_game(Size_8, Matrix_3, Moves_4) ->
    try
        Game_matrix = build_matrix(Matrix_3),
        Total = 0,
        I_20 = 0,
        Fun_23 = fun Fun_23_loop(Game_matrix, I_20, Matrix_3, Moves_4, Size_8, Total) ->
    case (I_20 < erlang:length(Moves_4)) of
        true ->
            Mv_2 = (case erlang:is_map(Moves_4) of true -> maps:get(I_20, Moves_4, nil); _ -> case I_20 < 0 of true -> mochi_nth(erlang:length(Moves_4) + I_20 + 1, Moves_4); _ -> mochi_nth(I_20 + 1, Moves_4) end end),
            Res_9 = play(Game_matrix, maps:get("x", Mv_2, nil), maps:get("y", Mv_2, nil), Size_8),
            Game_matrix_2 = maps:get("matrix", Res_9, nil),
            Total_2 = (Total + maps:get("score", Res_9, nil)),
            I_21 = (I_20 + 1),
            Fun_23_loop(Game_matrix_2, I_21, Matrix_3, Moves_4, Size_8, Total_2);
        _ -> {Game_matrix, I_20, Matrix_3, Moves_4, Size_8, Total}
    end
end,
{Game_matrix_2, I_21, Matrix_3, Moves_4, Size_8, Total_2} = Fun_23(Game_matrix, I_20, Matrix_3, Moves_4, Size_8, Total),
        Total_2
    catch {return, Ret} -> Ret end.

main() ->
    try
        Size_9 = 4,
        Matrix_4 = ["RRBG", "RBBG", "YYGG", "XYGG"],
        Moves_5 = parse_moves("0 1,1 1"),
        validate_matrix_size(4),
        validate_matrix_content(Matrix_4, 4),
        validate_moves(Moves_5, 4),
        Score = process_game(4, Matrix_4, Moves_5),
        io:format("~ts~n", [mochi_str(Score)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
