#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, exp_approx/1, sigmoid/1, tanh_approx/1, forward/2, backward/5, make_samples/2, init_weights/0, train/4, predict/2]).

% Generated by Mochi transpiler v0.10.59 (589dcb03e5) on 2025-08-07 12:04 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

exp_approx(X) ->
    try
        Sum = 1.0,
        Term = 1.0,
        N = 1,
        Fun = fun Fun_loop(N, Sum, Term, X) ->
    case (N < 20) of
        true ->
            Term_2 = mochi_safe_div(mochi_safe_mul(Term, X), float(N)),
            Sum_2 = (Sum + Term_2),
            N_2 = (N + 1),
            Fun_loop(N_2, Sum_2, Term_2, X);
        _ -> {N, Sum, Term, X}
    end
end,
{N_2, Sum_2, Term_2, X} = Fun(N, Sum, Term, X),
        Sum_2
    catch {return, Ret} -> Ret end.

sigmoid(X_2) ->
    try
        mochi_safe_div(1.0, (1.0 + exp_approx(-X_2)))
    catch {return, Ret} -> Ret end.

tanh_approx(X_3) ->
    try
        E = exp_approx(mochi_safe_mul(2.0, X_3)),
        mochi_safe_div((E - 1.0), (E + 1.0))
    catch {return, Ret} -> Ret end.

forward(Seq, W) ->
    try
        I_arr = [],
        F_arr = [],
        O_arr = [],
        G_arr = [],
        C_arr = [0.0],
        H_arr = [0.0],
        T = 0,
        Fun_2 = fun Fun_2_loop(C_arr, F_arr, G_arr, H_arr, I_arr, O_arr, Seq, T, W) ->
    case (T < erlang:length(Seq)) of
        true ->
            X_4 = (case erlang:is_map(Seq) of true -> maps:get(T, Seq, nil); _ -> case T < 0 of true -> mochi_nth(erlang:length(Seq) + T + 1, Seq); _ -> mochi_nth(T + 1, Seq) end end),
            H_prev = (case erlang:is_map(H_arr) of true -> maps:get(T, H_arr, nil); _ -> case T < 0 of true -> mochi_nth(erlang:length(H_arr) + T + 1, H_arr); _ -> mochi_nth(T + 1, H_arr) end end),
            C_prev = (case erlang:is_map(C_arr) of true -> maps:get(T, C_arr, nil); _ -> case T < 0 of true -> mochi_nth(erlang:length(C_arr) + T + 1, C_arr); _ -> mochi_nth(T + 1, C_arr) end end),
            I_t = sigmoid(((mochi_safe_mul(maps:get("w_i", W, nil), X_4) + mochi_safe_mul(maps:get("u_i", W, nil), H_prev)) + maps:get("b_i", W, nil))),
            F_t = sigmoid(((mochi_safe_mul(maps:get("w_f", W, nil), X_4) + mochi_safe_mul(maps:get("u_f", W, nil), H_prev)) + maps:get("b_f", W, nil))),
            O_t = sigmoid(((mochi_safe_mul(maps:get("w_o", W, nil), X_4) + mochi_safe_mul(maps:get("u_o", W, nil), H_prev)) + maps:get("b_o", W, nil))),
            G_t = tanh_approx(((mochi_safe_mul(maps:get("w_c", W, nil), X_4) + mochi_safe_mul(maps:get("u_c", W, nil), H_prev)) + maps:get("b_c", W, nil))),
            C_t = (mochi_safe_mul(F_t, C_prev) + mochi_safe_mul(I_t, G_t)),
            H_t = mochi_safe_mul(O_t, tanh_approx(C_t)),
            I_arr_2 = lists:append((case I_arr of nil -> []; _ -> I_arr end), [I_t]),
            F_arr_2 = lists:append((case F_arr of nil -> []; _ -> F_arr end), [F_t]),
            O_arr_2 = lists:append((case O_arr of nil -> []; _ -> O_arr end), [O_t]),
            G_arr_2 = lists:append((case G_arr of nil -> []; _ -> G_arr end), [G_t]),
            C_arr_2 = lists:append((case C_arr of nil -> []; _ -> C_arr end), [C_t]),
            H_arr_2 = lists:append((case H_arr of nil -> []; _ -> H_arr end), [H_t]),
            T_2 = (T + 1),
            Fun_2_loop(C_arr_2, F_arr_2, G_arr_2, H_arr_2, I_arr_2, O_arr_2, Seq, T_2, W);
        _ -> {C_arr, F_arr, G_arr, H_arr, I_arr, O_arr, Seq, T, W}
    end
end,
{C_arr_2, F_arr_2, G_arr_2, H_arr_2, I_arr_2, O_arr_2, Seq, T_2, W} = Fun_2(C_arr, F_arr, G_arr, H_arr, I_arr, O_arr, Seq, T, W),
        #{"i" => I_arr_2, "f" => F_arr_2, "o" => O_arr_2, "g" => G_arr_2, "c" => C_arr_2, "h" => H_arr_2}
    catch {return, Ret} -> Ret end.

backward(Seq_2, Target, W_2, S, Lr) ->
    try
        Dw_i = 0.0,
        Du_i = 0.0,
        Db_i = 0.0,
        Dw_f = 0.0,
        Du_f = 0.0,
        Db_f = 0.0,
        Dw_o = 0.0,
        Du_o = 0.0,
        Db_o = 0.0,
        Dw_c = 0.0,
        Du_c = 0.0,
        Db_c = 0.0,
        Dw_y = 0.0,
        Db_y = 0.0,
        T = erlang:length(Seq_2),
        H_last = (case erlang:is_map(maps:get("h", S, nil)) of true -> maps:get(T, maps:get("h", S, nil), nil); _ -> case T < 0 of true -> mochi_nth(erlang:length(maps:get("h", S, nil)) + T + 1, maps:get("h", S, nil)); _ -> mochi_nth(T + 1, maps:get("h", S, nil)) end end),
        Y = (mochi_safe_mul(maps:get("w_y", W_2, nil), H_last) + maps:get("b_y", W_2, nil)),
        Dy = (Y - Target),
        Dw_y_2 = mochi_safe_mul(Dy, H_last),
        Db_y_2 = Dy,
        Dh_next = mochi_safe_mul(Dy, maps:get("w_y", W_2, nil)),
        Dc_next = 0.0,
        T_3 = (T - 1),
        Fun_3 = fun Fun_3_loop(T, Db_c, Db_f, Db_i, Db_o, Db_y_2, Dc_next, Dh_next, Du_c, Du_f, Du_i, Du_o, Dw_c, Dw_f, Dw_i, Dw_o, Dw_y_2, Dy, H_last, Lr, S, Seq_2, T_3, Target, W_2, Y) ->
    case (T_3 >= 0) of
        true ->
            I_t_2 = (case erlang:is_map(maps:get("i", S, nil)) of true -> maps:get(T_3, maps:get("i", S, nil), nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(maps:get("i", S, nil)) + T_3 + 1, maps:get("i", S, nil)); _ -> mochi_nth(T_3 + 1, maps:get("i", S, nil)) end end),
            F_t_2 = (case erlang:is_map(maps:get("f", S, nil)) of true -> maps:get(T_3, maps:get("f", S, nil), nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(maps:get("f", S, nil)) + T_3 + 1, maps:get("f", S, nil)); _ -> mochi_nth(T_3 + 1, maps:get("f", S, nil)) end end),
            O_t_2 = (case erlang:is_map(maps:get("o", S, nil)) of true -> maps:get(T_3, maps:get("o", S, nil), nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(maps:get("o", S, nil)) + T_3 + 1, maps:get("o", S, nil)); _ -> mochi_nth(T_3 + 1, maps:get("o", S, nil)) end end),
            G_t_2 = (case erlang:is_map(maps:get("g", S, nil)) of true -> maps:get(T_3, maps:get("g", S, nil), nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(maps:get("g", S, nil)) + T_3 + 1, maps:get("g", S, nil)); _ -> mochi_nth(T_3 + 1, maps:get("g", S, nil)) end end),
            C_t_2 = (case erlang:is_map(maps:get("c", S, nil)) of true -> maps:get((T_3 + 1), maps:get("c", S, nil), nil); _ -> case (T_3 + 1) < 0 of true -> mochi_nth(erlang:length(maps:get("c", S, nil)) + (T_3 + 1) + 1, maps:get("c", S, nil)); _ -> mochi_nth((T_3 + 1) + 1, maps:get("c", S, nil)) end end),
            C_prev_2 = (case erlang:is_map(maps:get("c", S, nil)) of true -> maps:get(T_3, maps:get("c", S, nil), nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(maps:get("c", S, nil)) + T_3 + 1, maps:get("c", S, nil)); _ -> mochi_nth(T_3 + 1, maps:get("c", S, nil)) end end),
            H_prev_2 = (case erlang:is_map(maps:get("h", S, nil)) of true -> maps:get(T_3, maps:get("h", S, nil), nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(maps:get("h", S, nil)) + T_3 + 1, maps:get("h", S, nil)); _ -> mochi_nth(T_3 + 1, maps:get("h", S, nil)) end end),
            Tanh_c = tanh_approx(C_t_2),
            Do_t = mochi_safe_mul(Dh_next, Tanh_c),
            Da_o = mochi_safe_mul(mochi_safe_mul(Do_t, O_t_2), (1.0 - O_t_2)),
            Dc = (mochi_safe_mul(mochi_safe_mul(Dh_next, O_t_2), (1.0 - mochi_safe_mul(Tanh_c, Tanh_c))) + Dc_next),
            Di_t = mochi_safe_mul(Dc, G_t_2),
            Da_i = mochi_safe_mul(mochi_safe_mul(Di_t, I_t_2), (1.0 - I_t_2)),
            Dg_t = mochi_safe_mul(Dc, I_t_2),
            Da_g = mochi_safe_mul(Dg_t, (1.0 - mochi_safe_mul(G_t_2, G_t_2))),
            Df_t = mochi_safe_mul(Dc, C_prev_2),
            Da_f = mochi_safe_mul(mochi_safe_mul(Df_t, F_t_2), (1.0 - F_t_2)),
            Dw_i_2 = (Dw_i + mochi_safe_mul(Da_i, (case erlang:is_map(Seq_2) of true -> maps:get(T_3, Seq_2, nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(Seq_2) + T_3 + 1, Seq_2); _ -> mochi_nth(T_3 + 1, Seq_2) end end))),
            Du_i_2 = (Du_i + mochi_safe_mul(Da_i, H_prev_2)),
            Db_i_2 = (Db_i + Da_i),
            Dw_f_2 = (Dw_f + mochi_safe_mul(Da_f, (case erlang:is_map(Seq_2) of true -> maps:get(T_3, Seq_2, nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(Seq_2) + T_3 + 1, Seq_2); _ -> mochi_nth(T_3 + 1, Seq_2) end end))),
            Du_f_2 = (Du_f + mochi_safe_mul(Da_f, H_prev_2)),
            Db_f_2 = (Db_f + Da_f),
            Dw_o_2 = (Dw_o + mochi_safe_mul(Da_o, (case erlang:is_map(Seq_2) of true -> maps:get(T_3, Seq_2, nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(Seq_2) + T_3 + 1, Seq_2); _ -> mochi_nth(T_3 + 1, Seq_2) end end))),
            Du_o_2 = (Du_o + mochi_safe_mul(Da_o, H_prev_2)),
            Db_o_2 = (Db_o + Da_o),
            Dw_c_2 = (Dw_c + mochi_safe_mul(Da_g, (case erlang:is_map(Seq_2) of true -> maps:get(T_3, Seq_2, nil); _ -> case T_3 < 0 of true -> mochi_nth(erlang:length(Seq_2) + T_3 + 1, Seq_2); _ -> mochi_nth(T_3 + 1, Seq_2) end end))),
            Du_c_2 = (Du_c + mochi_safe_mul(Da_g, H_prev_2)),
            Db_c_2 = (Db_c + Da_g),
            Dh_next_2 = (((mochi_safe_mul(Da_i, maps:get("u_i", W_2, nil)) + mochi_safe_mul(Da_f, maps:get("u_f", W_2, nil))) + mochi_safe_mul(Da_o, maps:get("u_o", W_2, nil))) + mochi_safe_mul(Da_g, maps:get("u_c", W_2, nil))),
            Dc_next_2 = mochi_safe_mul(Dc, F_t_2),
            T_4 = (T_3 - 1),
            Fun_3_loop(T, Db_c_2, Db_f_2, Db_i_2, Db_o_2, Db_y_2, Dc_next_2, Dh_next_2, Du_c_2, Du_f_2, Du_i_2, Du_o_2, Dw_c_2, Dw_f_2, Dw_i_2, Dw_o_2, Dw_y_2, Dy, H_last, Lr, S, Seq_2, T_4, Target, W_2, Y);
        _ -> {T, Db_c, Db_f, Db_i, Db_o, Db_y_2, Dc_next, Dh_next, Du_c, Du_f, Du_i, Du_o, Dw_c, Dw_f, Dw_i, Dw_o, Dw_y_2, Dy, H_last, Lr, S, Seq_2, T_3, Target, W_2, Y}
    end
end,
{T, Db_c_2, Db_f_2, Db_i_2, Db_o_2, Db_y_2, Dc_next_2, Dh_next_2, Du_c_2, Du_f_2, Du_i_2, Du_o_2, Dw_c_2, Dw_f_2, Dw_i_2, Dw_o_2, Dw_y_2, Dy, H_last, Lr, S, Seq_2, T_4, Target, W_2, Y} = Fun_3(T, Db_c, Db_f, Db_i, Db_o, Db_y_2, Dc_next, Dh_next, Du_c, Du_f, Du_i, Du_o, Dw_c, Dw_f, Dw_i, Dw_o, Dw_y_2, Dy, H_last, Lr, S, Seq_2, T_3, Target, W_2, Y),
        W_3 = maps:put("w_y", (maps:get("w_y", W_2, nil) - mochi_safe_mul(Lr, Dw_y_2)), W_2),
        W_4 = maps:put("b_y", (maps:get("b_y", W_3, nil) - mochi_safe_mul(Lr, Db_y_2)), W_3),
        W_5 = maps:put("w_i", (maps:get("w_i", W_4, nil) - mochi_safe_mul(Lr, Dw_i_2)), W_4),
        W_6 = maps:put("u_i", (maps:get("u_i", W_5, nil) - mochi_safe_mul(Lr, Du_i_2)), W_5),
        W_7 = maps:put("b_i", (maps:get("b_i", W_6, nil) - mochi_safe_mul(Lr, Db_i_2)), W_6),
        W_8 = maps:put("w_f", (maps:get("w_f", W_7, nil) - mochi_safe_mul(Lr, Dw_f_2)), W_7),
        W_9 = maps:put("u_f", (maps:get("u_f", W_8, nil) - mochi_safe_mul(Lr, Du_f_2)), W_8),
        W_10 = maps:put("b_f", (maps:get("b_f", W_9, nil) - mochi_safe_mul(Lr, Db_f_2)), W_9),
        W_11 = maps:put("w_o", (maps:get("w_o", W_10, nil) - mochi_safe_mul(Lr, Dw_o_2)), W_10),
        W_12 = maps:put("u_o", (maps:get("u_o", W_11, nil) - mochi_safe_mul(Lr, Du_o_2)), W_11),
        W_13 = maps:put("b_o", (maps:get("b_o", W_12, nil) - mochi_safe_mul(Lr, Db_o_2)), W_12),
        W_14 = maps:put("w_c", (maps:get("w_c", W_13, nil) - mochi_safe_mul(Lr, Dw_c_2)), W_13),
        W_15 = maps:put("u_c", (maps:get("u_c", W_14, nil) - mochi_safe_mul(Lr, Du_c_2)), W_14),
        W_16 = maps:put("b_c", (maps:get("b_c", W_15, nil) - mochi_safe_mul(Lr, Db_c_2)), W_15),
        W_16
    catch {return, Ret} -> Ret end.

make_samples(Data, Look_back) ->
    try
        X = [],
        Y = [],
        I = 0,
        Fun_4 = fun Fun_4_loop(X, Y, Data, I, Look_back) ->
    case ((I + Look_back) < erlang:length(Data)) of
        true ->
            Seq_3 = (case erlang:is_binary(Data) of true -> string:substr(Data, I + 1, ((I + Look_back) - I)); _ -> lists:sublist(Data, (I + 1), ((I + Look_back) - I)) end),
            X_2 = lists:append((case X of nil -> []; _ -> X end), [Seq_3]),
            Y_2 = lists:append((case Y of nil -> []; _ -> Y end), [(case erlang:is_map(Data) of true -> maps:get((I + Look_back), Data, nil); _ -> case (I + Look_back) < 0 of true -> mochi_nth(erlang:length(Data) + (I + Look_back) + 1, Data); _ -> mochi_nth((I + Look_back) + 1, Data) end end)]),
            I_2 = (I + 1),
            Fun_4_loop(X_2, Y_2, Data, I_2, Look_back);
        _ -> {X, Y, Data, I, Look_back}
    end
end,
{X_2, Y_2, Data, I_2, Look_back} = Fun_4(X, Y, Data, I, Look_back),
        #{"x" => X_2, "y" => Y_2}
    catch {return, Ret} -> Ret end.

init_weights() ->
    try
        #{"w_i" => 0.1, "u_i" => 0.2, "b_i" => 0.0, "w_f" => 0.1, "u_f" => 0.2, "b_f" => 0.0, "w_o" => 0.1, "u_o" => 0.2, "b_o" => 0.0, "w_c" => 0.1, "u_c" => 0.2, "b_c" => 0.0, "w_y" => 0.1, "b_y" => 0.0}
    catch {return, Ret} -> Ret end.

train(Data_2, Look_back_2, Epochs, Lr_2) ->
    try
        Samples = make_samples(Data_2, Look_back_2),
        W_17 = init_weights(),
        Ep = 0,
        Fun_6 = fun Fun_6_loop(Data_2, Ep, Epochs, Look_back_2, Lr_2, Samples, W_17) ->
    case (Ep < Epochs) of
        true ->
            J = 0,
            Fun_5 = fun Fun_5_loop(Data_2, Ep, Epochs, J, Look_back_2, Lr_2, Samples, W_17) ->
    case (J < erlang:length(maps:get("x", Samples, nil))) of
        true ->
            Seq_4 = (case erlang:is_map(maps:get("x", Samples, nil)) of true -> maps:get(J, maps:get("x", Samples, nil), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(maps:get("x", Samples, nil)) + J + 1, maps:get("x", Samples, nil)); _ -> mochi_nth(J + 1, maps:get("x", Samples, nil)) end end),
            Target_2 = (case erlang:is_map(maps:get("y", Samples, nil)) of true -> maps:get(J, maps:get("y", Samples, nil), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(maps:get("y", Samples, nil)) + J + 1, maps:get("y", Samples, nil)); _ -> mochi_nth(J + 1, maps:get("y", Samples, nil)) end end),
            State = forward(Seq_4, W_17),
            W_18 = backward(Seq_4, Target_2, W_17, State, Lr_2),
            J_2 = (J + 1),
            Fun_5_loop(Data_2, Ep, Epochs, J_2, Look_back_2, Lr_2, Samples, W_18);
        _ -> {Data_2, Ep, Epochs, J, Look_back_2, Lr_2, Samples, W_17}
    end
end,
{Data_2, Ep, Epochs, J_2, Look_back_2, Lr_2, Samples, W_18} = Fun_5(Data_2, Ep, Epochs, J, Look_back_2, Lr_2, Samples, W_17),
            Ep_2 = (Ep + 1),
            Fun_6_loop(Data_2, Ep_2, Epochs, Look_back_2, Lr_2, Samples, W_18);
        _ -> {Data_2, Ep, Epochs, Look_back_2, Lr_2, Samples, W_17}
    end
end,
{Data_2, Ep_2, Epochs, Look_back_2, Lr_2, Samples, W_18} = Fun_6(Data_2, Ep, Epochs, Look_back_2, Lr_2, Samples, W_17),
        W_18
    catch {return, Ret} -> Ret end.

predict(Seq_5, W_19) ->
    try
        State_2 = forward(Seq_5, W_19),
        H_last_2 = (case erlang:is_map(maps:get("h", State_2, nil)) of true -> maps:get((erlang:length(maps:get("h", State_2, nil)) - 1), maps:get("h", State_2, nil), nil); _ -> case (erlang:length(maps:get("h", State_2, nil)) - 1) < 0 of true -> mochi_nth(erlang:length(maps:get("h", State_2, nil)) + (erlang:length(maps:get("h", State_2, nil)) - 1) + 1, maps:get("h", State_2, nil)); _ -> mochi_nth((erlang:length(maps:get("h", State_2, nil)) - 1) + 1, maps:get("h", State_2, nil)) end end),
        (mochi_safe_mul(maps:get("w_y", W_19, nil), H_last_2) + maps:get("b_y", W_19, nil))
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('data', [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]),
    erlang:put('look_back', 3),
    erlang:put('epochs', 200),
    erlang:put('lr', 0.1),
    erlang:put('w', train(erlang:get('data'), 3, 200, 0.1)),
    erlang:put('test_seq', [0.6, 0.7, 0.8]),
    erlang:put('pred', predict(erlang:get('test_seq'), erlang:get('w'))),
    io:format("~ts~n", [mochi_repr(("Predicted value: " ++ mochi_str(erlang:get('pred'))))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
