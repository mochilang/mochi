#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, load_data/0, contains_string/2, is_subset/2, lists_equal/2, contains_list/2, count_list/2, slice_list/2, combinations_lists/2, prune/3, sort_strings/1, itemset_to_string/1, apriori/2]).

% Generated by Mochi transpiler v0.10.65 (63755001db)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


toi(V) ->
    mochi_to_int(V).


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    erlang:float_to_list(V, [short]);
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

load_data() ->
    try
        [["milk"], ["milk", "butter"], ["milk", "bread"], ["milk", "bread", "chips"]]
    catch {return, RetCatch} -> RetCatch end.

contains_string(Xs, S) ->
    try
        Fun = fun Fun_loop(List, S, Xs) ->
    case List of
        [] -> {S, Xs};
        [V|V_rest] ->
            case (V == S) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_loop(V_rest, S, Xs);
        _ -> {S, Xs}
    end
end,
{S, Xs} = Fun(Xs, S, Xs),
        false
    catch {return, RetCatch} -> RetCatch end.

is_subset(Candidate, Transaction) ->
    try
        Fun_2 = fun Fun_2_loop(List, Candidate, Transaction) ->
    case List of
        [] -> {Candidate, Transaction};
        [It|It_rest] ->
            case mochi_not(contains_string(Transaction, It)) of
        true -> throw({return, false});
        _ -> ok
    end,
            Fun_2_loop(It_rest, Candidate, Transaction);
        _ -> {Candidate, Transaction}
    end
end,
{Candidate, Transaction} = Fun_2(Candidate, Candidate, Transaction),
        true
    catch {return, RetCatch} -> RetCatch end.

lists_equal(A, B) ->
    try
        case (erlang:length(A) /= erlang:length(B)) of
        true -> throw({return, false});
        _ -> ok
    end,
        I = 0,
        Fun_3 = fun Fun_3_loop(A, B, I) ->
    case (I < erlang:length(A)) of
        true ->
            case ((case erlang:is_map(A) of true -> maps:get(I, A, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(A) + I + 1, A); _ -> mochi_nth(I + 1, A) end end) /= (case erlang:is_map(B) of true -> maps:get(I, B, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(B) + I + 1, B); _ -> mochi_nth(I + 1, B) end end)) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_3_loop(A, B, I_2);
        _ -> {A, B, I}
    end
end,
{A, B, I_2} = Fun_3(A, B, I),
        true
    catch {return, RetCatch} -> RetCatch end.

contains_list(Itemset, Item) ->
    try
        Fun_4 = fun Fun_4_loop(List, Item, Itemset) ->
    case List of
        [] -> {Item, Itemset};
        [L|L_rest] ->
            case lists_equal(L, Item) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_4_loop(L_rest, Item, Itemset);
        _ -> {Item, Itemset}
    end
end,
{Item, Itemset} = Fun_4(Itemset, Item, Itemset),
        false
    catch {return, RetCatch} -> RetCatch end.

count_list(Itemset_2, Item_2) ->
    try
        C = 0,
        Fun_5 = fun Fun_5_loop(List, C, Item_2, Itemset_2) ->
    case List of
        [] -> {C, Item_2, Itemset_2};
        [L_2|L_2_rest] ->
            case lists_equal(L_2, Item_2) of
        true -> C_2 = (C + 1),
            C_3 = C_2;
        _ -> C_3 = C
    end,
            Fun_5_loop(L_2_rest, C_3, Item_2, Itemset_2);
        _ -> {C, Item_2, Itemset_2}
    end
end,
{C_3, Item_2, Itemset_2} = Fun_5(Itemset_2, C, Item_2, Itemset_2),
        C_3
    catch {return, RetCatch} -> RetCatch end.

slice_list(Xs_2, Start) ->
    try
        Res = [],
        I_3 = Start,
        Fun_6 = fun Fun_6_loop(I_3, Res, Start, Xs_2) ->
    case (I_3 < erlang:length(Xs_2)) of
        true ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(case erlang:is_map(Xs_2) of true -> maps:get(I_3, Xs_2, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Xs_2) + I_3 + 1, Xs_2); _ -> mochi_nth(I_3 + 1, Xs_2) end end)]),
            I_4 = (I_3 + 1),
            Fun_6_loop(I_4, Res_2, Start, Xs_2);
        _ -> {I_3, Res, Start, Xs_2}
    end
end,
{I_4, Res_2, Start, Xs_2} = Fun_6(I_3, Res, Start, Xs_2),
        Res_2
    catch {return, RetCatch} -> RetCatch end.

combinations_lists(Xs_3, K) ->
    try
        Result = [],
        case (K == 0) of
        true -> Result_2 = lists:append((case Result of nil -> []; _ -> Result end), [[]]),
            throw({return, Result_2}),
            Result_3 = Result_2;
        _ -> Result_3 = Result
    end,
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(I_5, K, Result_3, Xs_3) ->
    case (I_5 < erlang:length(Xs_3)) of
        true ->
            Head = (case erlang:is_map(Xs_3) of true -> maps:get(I_5, Xs_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Xs_3) + I_5 + 1, Xs_3); _ -> mochi_nth(I_5 + 1, Xs_3) end end),
            Tail = slice_list(Xs_3, (I_5 + 1)),
            Tail_combos = combinations_lists(Tail, (K - 1)),
            Fun_7 = fun Fun_7_loop(List, Head, I_5, K, Result_3, Tail, Tail_combos, Xs_3) ->
    case List of
        [] -> {Head, I_5, K, Result_3, Tail, Tail_combos, Xs_3};
        [Combo|Combo_rest] ->
            New_combo = [],
            New_combo_2 = lists:append((case New_combo of nil -> []; _ -> New_combo end), [Head]),
            Fun_8 = fun Fun_8_loop(List, Combo, Head, I_5, K, New_combo_2, Result_3, Tail, Tail_combos, Xs_3) ->
    case List of
        [] -> {Combo, Head, I_5, K, New_combo_2, Result_3, Tail, Tail_combos, Xs_3};
        [C_4|C_4_rest] ->
            New_combo_3 = lists:append((case New_combo_2 of nil -> []; _ -> New_combo_2 end), [C_4]),
            Fun_8_loop(C_4_rest, Combo, Head, I_5, K, New_combo_3, Result_3, Tail, Tail_combos, Xs_3);
        _ -> {Combo, Head, I_5, K, New_combo_2, Result_3, Tail, Tail_combos, Xs_3}
    end
end,
{Combo, Head, I_5, K, New_combo_3, Result_3, Tail, Tail_combos, Xs_3} = Fun_8(Combo, Combo, Head, I_5, K, New_combo_2, Result_3, Tail, Tail_combos, Xs_3),
            Result_4 = lists:append((case Result_3 of nil -> []; _ -> Result_3 end), [New_combo_3]),
            Fun_7_loop(Combo_rest, Head, I_5, K, Result_4, Tail, Tail_combos, Xs_3);
        _ -> {Head, I_5, K, Result_3, Tail, Tail_combos, Xs_3}
    end
end,
{Head, I_5, K, Result_4, Tail, Tail_combos, Xs_3} = Fun_7(Tail_combos, Head, I_5, K, Result_3, Tail, Tail_combos, Xs_3),
            I_6 = (I_5 + 1),
            Fun_9_loop(I_6, K, Result_4, Xs_3);
        _ -> {I_5, K, Result_3, Xs_3}
    end
end,
{I_6, K, Result_4, Xs_3} = Fun_9(I_5, K, Result_3, Xs_3),
        Result_4
    catch {return, RetCatch} -> RetCatch end.

prune(Itemset_3, Candidates, Length) ->
    try
        Pruned = [],
        Fun_10 = fun Fun_10_loop(List, Candidates, Itemset_3, Length, Pruned) ->
    case List of
        [] -> {Candidates, Itemset_3, Length, Pruned};
        [Candidate_2|Candidate_2_rest] ->
        try
            Is_subsequence = true,
            Fun_11 = fun Fun_11_loop(List, Candidate_2, Candidates, Is_subsequence, Itemset_3, Length, Pruned) ->
    case List of
        [] -> {Candidate_2, Candidates, Is_subsequence, Itemset_3, Length, Pruned};
        [Item_3|Item_3_rest] ->
        try
            case (mochi_not(contains_list(Itemset_3, Item_3)) orelse (count_list(Itemset_3, Item_3) < (Length - 1))) of
        true -> Is_subsequence_2 = false,
            throw({break, Candidate_2, Candidates, Is_subsequence_2, Itemset_3, Length, Pruned}),
            Is_subsequence_3 = Is_subsequence_2;
        _ -> Is_subsequence_3 = Is_subsequence
    end,
            Fun_11_loop(Item_3_rest, Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Pruned)
        catch
            {continue, C0, C1, C2, C3, C4, C5} -> Fun_11_loop(Item_3_rest, C0, C1, C2, C3, C4, C5);
            {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5};
            break -> {Candidate_2, Candidates, Is_subsequence, Itemset_3, Length, Pruned}
        end;
        _ -> {Candidate_2, Candidates, Is_subsequence, Itemset_3, Length, Pruned}
    end
end,
{Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Pruned} = Fun_11(Candidate_2, Candidate_2, Candidates, Is_subsequence, Itemset_3, Length, Pruned),
            case Is_subsequence_3 of
        true -> Merged = [],
            Fun_12 = fun Fun_12_loop(List, Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Merged, Pruned) ->
    case List of
        [] -> {Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Merged, Pruned};
        [Item_4|Item_4_rest] ->
            Fun_13 = fun Fun_13_loop(List, Candidate_2, Candidates, Is_subsequence_3, Item_4, Itemset_3, Length, Merged, Pruned) ->
    case List of
        [] -> {Candidate_2, Candidates, Is_subsequence_3, Item_4, Itemset_3, Length, Merged, Pruned};
        [S_2|S_2_rest] ->
            case mochi_not(contains_string(Merged, S_2)) of
        true -> Merged_2 = lists:append((case Merged of nil -> []; _ -> Merged end), [S_2]),
            Merged_3 = Merged_2;
        _ -> Merged_3 = Merged
    end,
            Fun_13_loop(S_2_rest, Candidate_2, Candidates, Is_subsequence_3, Item_4, Itemset_3, Length, Merged_3, Pruned);
        _ -> {Candidate_2, Candidates, Is_subsequence_3, Item_4, Itemset_3, Length, Merged, Pruned}
    end
end,
{Candidate_2, Candidates, Is_subsequence_3, Item_4, Itemset_3, Length, Merged_3, Pruned} = Fun_13(Item_4, Candidate_2, Candidates, Is_subsequence_3, Item_4, Itemset_3, Length, Merged, Pruned),
            Fun_12_loop(Item_4_rest, Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Merged_3, Pruned);
        _ -> {Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Merged, Pruned}
    end
end,
{Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Merged_3, Pruned} = Fun_12(Candidate_2, Candidate_2, Candidates, Is_subsequence_3, Itemset_3, Length, Merged, Pruned),
            Pruned_2 = lists:append((case Pruned of nil -> []; _ -> Pruned end), [Merged_3]),
            Fun_14 = Fun_12,
            Merged_4 = Merged_3,
            Pruned_3 = Pruned_2;
        _ -> Fun_14 = Fun_11,
            Merged_4 = nil,
            Pruned_3 = Pruned
    end,
            Fun_10_loop(Candidate_2_rest, Candidates, Itemset_3, Length, Pruned_3)
        catch
            {continue, C0, C1, C2, C3} -> Fun_10_loop(Candidate_2_rest, C0, C1, C2, C3);
            {break, B0, B1, B2, B3} -> {B0, B1, B2, B3};
            break -> {Candidates, Itemset_3, Length, Pruned}
        end;
        _ -> {Candidates, Itemset_3, Length, Pruned}
    end
end,
{Candidates, Itemset_3, Length, Pruned_3} = Fun_10(Candidates, Candidates, Itemset_3, Length, Pruned),
        Pruned_3
    catch {return, RetCatch} -> RetCatch end.

sort_strings(Xs_4) ->
    try
        Res_3 = [],
        Fun_15 = fun Fun_15_loop(List, Res_3, Xs_4) ->
    case List of
        [] -> {Res_3, Xs_4};
        [S_3|S_3_rest] ->
            Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [S_3]),
            Fun_15_loop(S_3_rest, Res_4, Xs_4);
        _ -> {Res_3, Xs_4}
    end
end,
{Res_4, Xs_4} = Fun_15(Xs_4, Res_3, Xs_4),
        I_7 = 0,
        Fun_17 = fun Fun_17_loop(I_7, Res_4, Xs_4) ->
    case (I_7 < erlang:length(Res_4)) of
        true ->
            J = (I_7 + 1),
            Fun_16 = fun Fun_16_loop(I_7, J, Res_4, Xs_4) ->
    case (J < erlang:length(Res_4)) of
        true ->
            case ((case erlang:is_map(Res_4) of true -> maps:get(J, Res_4, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Res_4) + J + 1, Res_4); _ -> mochi_nth(J + 1, Res_4) end end) < (case erlang:is_map(Res_4) of true -> maps:get(I_7, Res_4, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Res_4) + I_7 + 1, Res_4); _ -> mochi_nth(I_7 + 1, Res_4) end end)) of
        true -> Tmp = (case erlang:is_map(Res_4) of true -> maps:get(I_7, Res_4, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Res_4) + I_7 + 1, Res_4); _ -> mochi_nth(I_7 + 1, Res_4) end end),
            Res_5 = lists:sublist(Res_4, I_7) ++ [(case erlang:is_map(Res_4) of true -> maps:get(J, Res_4, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Res_4) + J + 1, Res_4); _ -> mochi_nth(J + 1, Res_4) end end)] ++ lists:nthtail(I_7 + 1, Res_4),
            Res_6 = lists:sublist(Res_5, J) ++ [Tmp] ++ lists:nthtail(J + 1, Res_5),
            Res_7 = Res_6,
            Tmp_2 = Tmp;
        _ -> Res_7 = Res_4,
            Tmp_2 = nil
    end,
            J_2 = (J + 1),
            Fun_16_loop(I_7, J_2, Res_7, Xs_4);
        _ -> {I_7, J, Res_4, Xs_4}
    end
end,
{I_7, J_2, Res_7, Xs_4} = Fun_16(I_7, J, Res_4, Xs_4),
            I_8 = (I_7 + 1),
            Fun_17_loop(I_8, Res_7, Xs_4);
        _ -> {I_7, Res_4, Xs_4}
    end
end,
{I_8, Res_7, Xs_4} = Fun_17(I_7, Res_4, Xs_4),
        Res_7
    catch {return, RetCatch} -> RetCatch end.

itemset_to_string(Xs_5) ->
    try
        S_4 = "[",
        I_9 = 0,
        Fun_18 = fun Fun_18_loop(I_9, S_4, Xs_5) ->
    case (I_9 < erlang:length(Xs_5)) of
        true ->
            case (I_9 > 0) of
        true -> S_5 = (S_4 ++ ", "),
            S_6 = S_5;
        _ -> S_6 = S_4
    end,
            S_7 = (((S_6 ++ "'") ++ (case erlang:is_map(Xs_5) of true -> maps:get(I_9, Xs_5, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Xs_5) + I_9 + 1, Xs_5); _ -> mochi_nth(I_9 + 1, Xs_5) end end)) ++ "'"),
            I_10 = (I_9 + 1),
            Fun_18_loop(I_10, S_7, Xs_5);
        _ -> {I_9, S_4, Xs_5}
    end
end,
{I_10, S_7, Xs_5} = Fun_18(I_9, S_4, Xs_5),
        S_8 = (S_7 ++ "]"),
        S_8
    catch {return, RetCatch} -> RetCatch end.

apriori(Data, Min_support) ->
    try
        Itemset_4 = [],
        Fun_19 = fun Fun_19_loop(List, Data, Itemset_4, Min_support) ->
    case List of
        [] -> {Data, Itemset_4, Min_support};
        [Transaction_2|Transaction_2_rest] ->
            T = [],
            Fun_20 = fun Fun_20_loop(List, Data, Itemset_4, Min_support, T, Transaction_2) ->
    case List of
        [] -> {Data, Itemset_4, Min_support, T, Transaction_2};
        [V_2|V_2_rest] ->
            T_2 = lists:append((case T of nil -> []; _ -> T end), [V_2]),
            Fun_20_loop(V_2_rest, Data, Itemset_4, Min_support, T_2, Transaction_2);
        _ -> {Data, Itemset_4, Min_support, T, Transaction_2}
    end
end,
{Data, Itemset_4, Min_support, T_2, Transaction_2} = Fun_20(Transaction_2, Data, Itemset_4, Min_support, T, Transaction_2),
            Itemset_5 = lists:append((case Itemset_4 of nil -> []; _ -> Itemset_4 end), [T_2]),
            Fun_19_loop(Transaction_2_rest, Data, Itemset_5, Min_support);
        _ -> {Data, Itemset_4, Min_support}
    end
end,
{Data, Itemset_5, Min_support} = Fun_19(Data, Data, Itemset_4, Min_support),
        Frequent = [],
        Length_2 = 1,
        Fun_26 = fun Fun_26_loop(Data, Frequent, Itemset_5, Length_2, Min_support) ->
    case (erlang:length(Itemset_5) > 0) of
        true ->
            Counts = [],
            Idx = 0,
            Fun_21 = fun Fun_21_loop(Counts, Data, Frequent, Idx, Itemset_5, Length_2, Min_support) ->
    case (Idx < erlang:length(Itemset_5)) of
        true ->
            Counts_2 = lists:append((case Counts of nil -> []; _ -> Counts end), [0]),
            Idx_2 = (Idx + 1),
            Fun_21_loop(Counts_2, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support);
        _ -> {Counts, Data, Frequent, Idx, Itemset_5, Length_2, Min_support}
    end
end,
{Counts_2, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support} = Fun_21(Counts, Data, Frequent, Idx, Itemset_5, Length_2, Min_support),
            Fun_22 = fun Fun_22_loop(List, Counts_2, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support) ->
    case List of
        [] -> {Counts_2, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support};
        [Transaction_3|Transaction_3_rest] ->
            J_3 = 0,
            Fun_23 = fun Fun_23_loop(Counts_2, Data, Frequent, Idx_2, Itemset_5, J_3, Length_2, Min_support, Transaction_3) ->
    case (J_3 < erlang:length(Itemset_5)) of
        true ->
            Candidate_3 = (case erlang:is_map(Itemset_5) of true -> maps:get(J_3, Itemset_5, nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(Itemset_5) + J_3 + 1, Itemset_5); _ -> mochi_nth(J_3 + 1, Itemset_5) end end),
            case is_subset(Candidate_3, Transaction_3) of
        true -> Counts_3 = lists:sublist(Counts_2, J_3) ++ [((case erlang:is_map(Counts_2) of true -> maps:get(J_3, Counts_2, nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(Counts_2) + J_3 + 1, Counts_2); _ -> mochi_nth(J_3 + 1, Counts_2) end end) + 1)] ++ lists:nthtail(J_3 + 1, Counts_2),
            Counts_4 = Counts_3;
        _ -> Counts_4 = Counts_2
    end,
            J_4 = (J_3 + 1),
            Fun_23_loop(Counts_4, Data, Frequent, Idx_2, Itemset_5, J_4, Length_2, Min_support, Transaction_3);
        _ -> {Counts_2, Data, Frequent, Idx_2, Itemset_5, J_3, Length_2, Min_support, Transaction_3}
    end
end,
{Counts_4, Data, Frequent, Idx_2, Itemset_5, J_4, Length_2, Min_support, Transaction_3} = Fun_23(Counts_2, Data, Frequent, Idx_2, Itemset_5, J_3, Length_2, Min_support, Transaction_3),
            Fun_22_loop(Transaction_3_rest, Counts_4, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support);
        _ -> {Counts_2, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support}
    end
end,
{Counts_4, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support} = Fun_22(Data, Counts_2, Data, Frequent, Idx_2, Itemset_5, Length_2, Min_support),
            New_itemset = [],
            K_2 = 0,
            Fun_24 = fun Fun_24_loop(Counts_4, Data, Frequent, Idx_2, Itemset_5, K_2, Length_2, Min_support, New_itemset) ->
    case (K_2 < erlang:length(Itemset_5)) of
        true ->
            case ((case erlang:is_map(Counts_4) of true -> maps:get(K_2, Counts_4, nil); _ -> case K_2 < 0 of true -> mochi_nth(erlang:length(Counts_4) + K_2 + 1, Counts_4); _ -> mochi_nth(K_2 + 1, Counts_4) end end) >= Min_support) of
        true -> New_itemset_2 = lists:append((case New_itemset of nil -> []; _ -> New_itemset end), [(case erlang:is_map(Itemset_5) of true -> maps:get(K_2, Itemset_5, nil); _ -> case K_2 < 0 of true -> mochi_nth(erlang:length(Itemset_5) + K_2 + 1, Itemset_5); _ -> mochi_nth(K_2 + 1, Itemset_5) end end)]),
            New_itemset_3 = New_itemset_2;
        _ -> New_itemset_3 = New_itemset
    end,
            K_3 = (K_2 + 1),
            Fun_24_loop(Counts_4, Data, Frequent, Idx_2, Itemset_5, K_3, Length_2, Min_support, New_itemset_3);
        _ -> {Counts_4, Data, Frequent, Idx_2, Itemset_5, K_2, Length_2, Min_support, New_itemset}
    end
end,
{Counts_4, Data, Frequent, Idx_2, Itemset_5, K_3, Length_2, Min_support, New_itemset_3} = Fun_24(Counts_4, Data, Frequent, Idx_2, Itemset_5, K_2, Length_2, Min_support, New_itemset),
            Itemset_6 = New_itemset_3,
            M = 0,
            Fun_25 = fun Fun_25_loop(Counts_4, Data, Frequent, Idx_2, Itemset_6, K_3, Length_2, M, Min_support, New_itemset_3) ->
    case (M < erlang:length(Itemset_6)) of
        true ->
            Sorted_item = sort_strings((case erlang:is_map(Itemset_6) of true -> maps:get(M, Itemset_6, nil); _ -> case M < 0 of true -> mochi_nth(erlang:length(Itemset_6) + M + 1, Itemset_6); _ -> mochi_nth(M + 1, Itemset_6) end end)),
            Frequent_2 = lists:append((case Frequent of nil -> []; _ -> Frequent end), [#{"items" => Sorted_item, "support" => (case erlang:is_map(Counts_4) of true -> maps:get(M, Counts_4, nil); _ -> case M < 0 of true -> mochi_nth(erlang:length(Counts_4) + M + 1, Counts_4); _ -> mochi_nth(M + 1, Counts_4) end end)}]),
            M_2 = (M + 1),
            Fun_25_loop(Counts_4, Data, Frequent_2, Idx_2, Itemset_6, K_3, Length_2, M_2, Min_support, New_itemset_3);
        _ -> {Counts_4, Data, Frequent, Idx_2, Itemset_6, K_3, Length_2, M, Min_support, New_itemset_3}
    end
end,
{Counts_4, Data, Frequent_2, Idx_2, Itemset_6, K_3, Length_2, M_2, Min_support, New_itemset_3} = Fun_25(Counts_4, Data, Frequent, Idx_2, Itemset_6, K_3, Length_2, M, Min_support, New_itemset_3),
            Length_3 = (Length_2 + 1),
            Combos = combinations_lists(Itemset_6, Length_3),
            Itemset_7 = prune(Itemset_6, Combos, Length_3),
            Fun_26_loop(Data, Frequent_2, Itemset_7, Length_3, Min_support);
        _ -> {Data, Frequent, Itemset_5, Length_2, Min_support}
    end
end,
{Data, Frequent_2, Itemset_7, Length_3, Min_support} = Fun_26(Data, Frequent, Itemset_5, Length_2, Min_support),
        Frequent_2
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('frequent_itemsets', apriori(load_data(), 2)),
    Fun_27 = fun Fun_27_loop(List) ->
    case List of
        [] -> {};
        [Fi|Fi_rest] ->
            io:format("~ts~n", [mochi_repr(((itemset_to_string(maps:get("items", Fi, nil)) ++ ": ") ++ mochi_str(maps:get("support", Fi, nil))))]),
            Fun_27_loop(Fi_rest);
        _ -> {}
    end
end,
{} = Fun_27(erlang:get('frequent_itemsets')),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
