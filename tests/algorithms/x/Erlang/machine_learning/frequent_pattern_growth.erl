#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, make_node/3, update_header/2, update_tree/4, sort_items/2, create_tree/2, ascend_tree/2, find_prefix_path/2, mine_tree/5, list_to_string/1, main/0]).

% Generated by Mochi transpiler v0.10.65 (01d44ffe1b)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


toi(V) ->
    mochi_to_int(V).


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    erlang:float_to_list(V, [short]);
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

make_node(Name, Count, Parent) ->
    try
        #{"name" => Name, "count" => Count, "parent" => Parent, "children" => #{}, "node_link" => nil}
    catch {return, RetCatch} -> RetCatch end.

update_header(Node_to_test, Target_node) ->
    try
        Current = Node_to_test,
        Fun = fun Fun_loop(Current, Node_to_test, Target_node) ->
    case (maps:get("node_link", Current, nil) /= nil) of
        true ->
            Current_2 = maps:get("node_link", Current, nil),
            Fun_loop(Current_2, Node_to_test, Target_node);
        _ -> {Current, Node_to_test, Target_node}
    end
end,
{Current_2, Node_to_test, Target_node} = Fun(Current, Node_to_test, Target_node),
        Current_3 = maps:put("node_link", Target_node, Current_2),
        nil
    catch {return, RetCatch} -> RetCatch end.

update_tree(Items, In_tree, Header_table, Count_2) ->
    try
        First = (case erlang:is_map(Items) of true -> maps:get(0, Items, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Items) + 0 + 1, Items); _ -> mochi_nth(0 + 1, Items) end end),
        Children = maps:get("children", In_tree, nil),
        case maps:is_key(First, Children) of
        true -> Child = maps:get(First, Children, nil),
            Child_2 = maps:put("count", (maps:get("count", Child, nil) + Count_2), Child),
            Children_2 = maps:put(First, Child_2, Children),
            In_tree_2 = maps:put("children", Children_2, In_tree),
            Child_3 = Child_2,
            Children_4 = Children_2,
            Entry_4 = nil,
            Header_table_3 = Header_table,
            In_tree_4 = In_tree_2,
            New_node_2 = nil;
        _ -> New_node = make_node(First, Count_2, In_tree),
            Children_3 = maps:put(First, New_node, Children),
            In_tree_3 = maps:put("children", Children_3, In_tree),
            Entry = (case erlang:is_map(Header_table) of true -> maps:get(First, Header_table, nil); _ -> case First < 0 of true -> mochi_nth(erlang:length(Header_table) + First + 1, Header_table); _ -> mochi_nth(First + 1, Header_table) end end),
            case (maps:get("node", Entry, nil) == nil) of
        true -> Entry_2 = maps:put("node", New_node, Entry),
            Entry_3 = Entry_2;
        _ -> update_header(maps:get("node", Entry, nil), New_node),
            Entry_3 = Entry
    end,
            Header_table_2 = lists:sublist(Header_table, First) ++ [Entry_3] ++ lists:nthtail(First + 1, Header_table),
            Child_3 = nil,
            Children_4 = Children_3,
            Entry_4 = Entry_3,
            Header_table_3 = Header_table_2,
            In_tree_4 = In_tree_3,
            New_node_2 = New_node
    end,
        case (erlang:length(Items) > 1) of
        true -> Rest = lists:sublist(Items, 1 + 1, (erlang:length(Items) - 1)),
            update_tree(Rest, maps:get(First, Children_4, nil), Header_table_3, Count_2),
            Rest_2 = Rest;
        _ -> Rest_2 = nil
    end,
        nil
    catch {return, RetCatch} -> RetCatch end.

sort_items(Items_2, Header_table_4) ->
    try
        Arr = Items_2,
        I = 0,
        Fun_3 = fun Fun_3_loop(Arr, Header_table_4, I, Items_2) ->
    case (I < erlang:length(Arr)) of
        true ->
            J = (I + 1),
            Fun_2 = fun Fun_2_loop(Arr, Header_table_4, I, Items_2, J) ->
    case (J < erlang:length(Arr)) of
        true ->
            case (maps:get("count", (case erlang:is_map(Header_table_4) of true -> maps:get((case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Arr) + I + 1, Arr); _ -> mochi_nth(I + 1, Arr) end end), Header_table_4, nil); _ -> case (case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Arr) + I + 1, Arr); _ -> mochi_nth(I + 1, Arr) end end) < 0 of true -> mochi_nth(erlang:length(Header_table_4) + (case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Arr) + I + 1, Arr); _ -> mochi_nth(I + 1, Arr) end end) + 1, Header_table_4); _ -> mochi_nth((case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Arr) + I + 1, Arr); _ -> mochi_nth(I + 1, Arr) end end) + 1, Header_table_4) end end), nil) < maps:get("count", (case erlang:is_map(Header_table_4) of true -> maps:get((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end), Header_table_4, nil); _ -> case (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end) < 0 of true -> mochi_nth(erlang:length(Header_table_4) + (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end) + 1, Header_table_4); _ -> mochi_nth((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end) + 1, Header_table_4) end end), nil)) of
        true -> Tmp = (case erlang:is_map(Arr) of true -> maps:get(I, Arr, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Arr) + I + 1, Arr); _ -> mochi_nth(I + 1, Arr) end end),
            Arr_2 = lists:sublist(Arr, I) ++ [(case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end)] ++ lists:nthtail(I + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr_2),
            Arr_4 = Arr_3,
            Tmp_2 = Tmp;
        _ -> Arr_4 = Arr,
            Tmp_2 = nil
    end,
            J_2 = (J + 1),
            Fun_2_loop(Arr_4, Header_table_4, I, Items_2, J_2);
        _ -> {Arr, Header_table_4, I, Items_2, J}
    end
end,
{Arr_4, Header_table_4, I, Items_2, J_2} = Fun_2(Arr, Header_table_4, I, Items_2, J),
            I_2 = (I + 1),
            Fun_3_loop(Arr_4, Header_table_4, I_2, Items_2);
        _ -> {Arr, Header_table_4, I, Items_2}
    end
end,
{Arr_4, Header_table_4, I_2, Items_2} = Fun_3(Arr, Header_table_4, I, Items_2),
        Arr_4
    catch {return, RetCatch} -> RetCatch end.

create_tree(Data_set, Min_sup) ->
    try
        Counts = #{},
        I_3 = 0,
        Fun_5 = fun Fun_5_loop(Counts, Data_set, I_3, Min_sup) ->
    case (I_3 < erlang:length(Data_set)) of
        true ->
            Trans = (case erlang:is_map(Data_set) of true -> maps:get(I_3, Data_set, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Data_set) + I_3 + 1, Data_set); _ -> mochi_nth(I_3 + 1, Data_set) end end),
            J_3 = 0,
            Fun_4 = fun Fun_4_loop(Counts, Data_set, I_3, J_3, Min_sup, Trans) ->
    case (J_3 < erlang:length(Trans)) of
        true ->
            Item = (case erlang:is_map(Trans) of true -> maps:get(J_3, Trans, nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(Trans) + J_3 + 1, Trans); _ -> mochi_nth(J_3 + 1, Trans) end end),
            case maps:is_key(Item, Counts) of
        true -> Counts_2 = maps:put(Item, (maps:get(Item, Counts, nil) + 1), Counts),
            Counts_4 = Counts_2;
        _ -> Counts_3 = maps:put(Item, 1, Counts),
            Counts_4 = Counts_3
    end,
            J_4 = (J_3 + 1),
            Fun_4_loop(Counts_4, Data_set, I_3, J_4, Min_sup, Trans);
        _ -> {Counts, Data_set, I_3, J_3, Min_sup, Trans}
    end
end,
{Counts_4, Data_set, I_3, J_4, Min_sup, Trans} = Fun_4(Counts, Data_set, I_3, J_3, Min_sup, Trans),
            I_4 = (I_3 + 1),
            Fun_5_loop(Counts_4, Data_set, I_4, Min_sup);
        _ -> {Counts, Data_set, I_3, Min_sup}
    end
end,
{Counts_4, Data_set, I_4, Min_sup} = Fun_5(Counts, Data_set, I_3, Min_sup),
        Header_table_5 = #{},
        Fun_6 = fun Fun_6_loop(List, Counts_4, Data_set, Header_table_5, I_4, Min_sup) ->
    case List of
        [] -> {Counts_4, Data_set, Header_table_5, I_4, Min_sup};
        [K|K_rest] ->
            Cnt = (case erlang:is_map(Counts_4) of true -> maps:get(K, Counts_4, nil); _ -> case K < 0 of true -> mochi_nth(erlang:length(Counts_4) + K + 1, Counts_4); _ -> mochi_nth(K + 1, Counts_4) end end),
            case (Cnt >= Min_sup) of
        true -> Header_table_6 = maps:put(K, #{"count" => Cnt, "node" => nil}, Header_table_5),
            Header_table_7 = Header_table_6;
        _ -> Header_table_7 = Header_table_5
    end,
            Fun_6_loop(K_rest, Counts_4, Data_set, Header_table_7, I_4, Min_sup);
        _ -> {Counts_4, Data_set, Header_table_5, I_4, Min_sup}
    end
end,
{Counts_4, Data_set, Header_table_7, I_4, Min_sup} = Fun_6(maps:keys(Counts_4), Counts_4, Data_set, Header_table_5, I_4, Min_sup),
        Freq_items = [],
        Fun_7 = fun Fun_7_loop(List, Counts_4, Data_set, Freq_items, Header_table_7, I_4, Min_sup) ->
    case List of
        [] -> {Counts_4, Data_set, Freq_items, Header_table_7, I_4, Min_sup};
        [K_2|K_2_rest] ->
            Freq_items_2 = lists:append((case Freq_items of nil -> []; _ -> Freq_items end), [K_2]),
            Fun_7_loop(K_2_rest, Counts_4, Data_set, Freq_items_2, Header_table_7, I_4, Min_sup);
        _ -> {Counts_4, Data_set, Freq_items, Header_table_7, I_4, Min_sup}
    end
end,
{Counts_4, Data_set, Freq_items_2, Header_table_7, I_4, Min_sup} = Fun_7(maps:keys(Header_table_7), Counts_4, Data_set, Freq_items, Header_table_7, I_4, Min_sup),
        case (erlang:length(Freq_items_2) == 0) of
        true -> throw({return, #{"tree" => make_node("Null Set", 1, nil), "header" => #{}}});
        _ -> ok
    end,
        Fp_tree = make_node("Null Set", 1, nil),
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, Min_sup) ->
    case (I_5 < erlang:length(Data_set)) of
        true ->
            Tran = (case erlang:is_map(Data_set) of true -> maps:get(I_5, Data_set, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Data_set) + I_5 + 1, Data_set); _ -> mochi_nth(I_5 + 1, Data_set) end end),
            Local_items = [],
            J_5 = 0,
            Fun_8 = fun Fun_8_loop(Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, J_5, Local_items, Min_sup, Tran) ->
    case (J_5 < erlang:length(Tran)) of
        true ->
            Item_2 = (case erlang:is_map(Tran) of true -> maps:get(J_5, Tran, nil); _ -> case J_5 < 0 of true -> mochi_nth(erlang:length(Tran) + J_5 + 1, Tran); _ -> mochi_nth(J_5 + 1, Tran) end end),
            case maps:is_key(Item_2, Header_table_7) of
        true -> Local_items_2 = lists:append((case Local_items of nil -> []; _ -> Local_items end), [Item_2]),
            Local_items_3 = Local_items_2;
        _ -> Local_items_3 = Local_items
    end,
            J_6 = (J_5 + 1),
            Fun_8_loop(Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, J_6, Local_items_3, Min_sup, Tran);
        _ -> {Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, J_5, Local_items, Min_sup, Tran}
    end
end,
{Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, J_6, Local_items_3, Min_sup, Tran} = Fun_8(Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, J_5, Local_items, Min_sup, Tran),
            case (erlang:length(Local_items_3) > 0) of
        true -> Local_items_4 = sort_items(Local_items_3, Header_table_7),
            update_tree(Local_items_4, Fp_tree, Header_table_7, 1),
            Local_items_5 = Local_items_4;
        _ -> Local_items_5 = Local_items_3
    end,
            I_6 = (I_5 + 1),
            Fun_9_loop(Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_6, Min_sup);
        _ -> {Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, Min_sup}
    end
end,
{Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_6, Min_sup} = Fun_9(Counts_4, Data_set, Fp_tree, Freq_items_2, Header_table_7, I_5, Min_sup),
        #{"tree" => Fp_tree, "header" => Header_table_7}
    catch {return, RetCatch} -> RetCatch end.

ascend_tree(Leaf_node, Path) ->
    try
        Prefix = Path,
        case (maps:get("parent", Leaf_node, nil) /= nil) of
        true -> Prefix_2 = lists:append((case Prefix of nil -> []; _ -> Prefix end), [maps:get("name", Leaf_node, nil)]),
            Prefix_3 = ascend_tree(maps:get("parent", Leaf_node, nil), Prefix_2),
            Prefix_5 = Prefix_3;
        _ -> Prefix_4 = lists:append((case Prefix of nil -> []; _ -> Prefix end), [maps:get("name", Leaf_node, nil)]),
            Prefix_5 = Prefix_4
    end,
        Prefix_5
    catch {return, RetCatch} -> RetCatch end.

find_prefix_path(Base_pat, Tree_node) ->
    try
        Cond_pats = [],
        Node = Tree_node,
        Fun_10 = fun Fun_10_loop(Base_pat, Cond_pats, Node, Tree_node) ->
    case (Node /= nil) of
        true ->
            Prefix_6 = ascend_tree(Node, []),
            case (erlang:length(Prefix_6) > 1) of
        true -> Items_3 = lists:sublist(Prefix_6, 1 + 1, (erlang:length(Prefix_6) - 1)),
            Cond_pats_2 = lists:append((case Cond_pats of nil -> []; _ -> Cond_pats end), [#{"items" => Items_3, "count" => maps:get("count", Node, nil)}]),
            Cond_pats_3 = Cond_pats_2,
            Items_4 = Items_3;
        _ -> Cond_pats_3 = Cond_pats,
            Items_4 = nil
    end,
            Node_2 = maps:get("node_link", Node, nil),
            Fun_10_loop(Base_pat, Cond_pats_3, Node_2, Tree_node);
        _ -> {Base_pat, Cond_pats, Node, Tree_node}
    end
end,
{Base_pat, Cond_pats_3, Node_2, Tree_node} = Fun_10(Base_pat, Cond_pats, Node, Tree_node),
        Cond_pats_3
    catch {return, RetCatch} -> RetCatch end.

mine_tree(In_tree_5, Header_table_8, Min_sup_2, Pre_fix, Freq_item_list) ->
    try
        Freq_list = Freq_item_list,
        Items_5 = [],
        Fun_11 = fun Fun_11_loop(List, Freq_item_list, Freq_list, Header_table_8, In_tree_5, Items_5, Min_sup_2, Pre_fix) ->
    case List of
        [] -> {Freq_item_list, Freq_list, Header_table_8, In_tree_5, Items_5, Min_sup_2, Pre_fix};
        [K_3|K_3_rest] ->
            Items_6 = lists:append((case Items_5 of nil -> []; _ -> Items_5 end), [K_3]),
            Fun_11_loop(K_3_rest, Freq_item_list, Freq_list, Header_table_8, In_tree_5, Items_6, Min_sup_2, Pre_fix);
        _ -> {Freq_item_list, Freq_list, Header_table_8, In_tree_5, Items_5, Min_sup_2, Pre_fix}
    end
end,
{Freq_item_list, Freq_list, Header_table_8, In_tree_5, Items_6, Min_sup_2, Pre_fix} = Fun_11(Header_table_8, Freq_item_list, Freq_list, Header_table_8, In_tree_5, Items_5, Min_sup_2, Pre_fix),
        Sorted_items = Items_6,
        I_7 = 0,
        Fun_13 = fun Fun_13_loop(Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items) ->
    case (I_7 < erlang:length(Sorted_items)) of
        true ->
            J_7 = (I_7 + 1),
            Fun_12 = fun Fun_12_loop(Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, J_7, Min_sup_2, Pre_fix, Sorted_items) ->
    case (J_7 < erlang:length(Sorted_items)) of
        true ->
            case (maps:get("count", (case erlang:is_map(Header_table_8) of true -> maps:get((case erlang:is_map(Sorted_items) of true -> maps:get(I_7, Sorted_items, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + I_7 + 1, Sorted_items); _ -> mochi_nth(I_7 + 1, Sorted_items) end end), Header_table_8, nil); _ -> case (case erlang:is_map(Sorted_items) of true -> maps:get(I_7, Sorted_items, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + I_7 + 1, Sorted_items); _ -> mochi_nth(I_7 + 1, Sorted_items) end end) < 0 of true -> mochi_nth(erlang:length(Header_table_8) + (case erlang:is_map(Sorted_items) of true -> maps:get(I_7, Sorted_items, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + I_7 + 1, Sorted_items); _ -> mochi_nth(I_7 + 1, Sorted_items) end end) + 1, Header_table_8); _ -> mochi_nth((case erlang:is_map(Sorted_items) of true -> maps:get(I_7, Sorted_items, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + I_7 + 1, Sorted_items); _ -> mochi_nth(I_7 + 1, Sorted_items) end end) + 1, Header_table_8) end end), nil) > maps:get("count", (case erlang:is_map(Header_table_8) of true -> maps:get((case erlang:is_map(Sorted_items) of true -> maps:get(J_7, Sorted_items, nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + J_7 + 1, Sorted_items); _ -> mochi_nth(J_7 + 1, Sorted_items) end end), Header_table_8, nil); _ -> case (case erlang:is_map(Sorted_items) of true -> maps:get(J_7, Sorted_items, nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + J_7 + 1, Sorted_items); _ -> mochi_nth(J_7 + 1, Sorted_items) end end) < 0 of true -> mochi_nth(erlang:length(Header_table_8) + (case erlang:is_map(Sorted_items) of true -> maps:get(J_7, Sorted_items, nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + J_7 + 1, Sorted_items); _ -> mochi_nth(J_7 + 1, Sorted_items) end end) + 1, Header_table_8); _ -> mochi_nth((case erlang:is_map(Sorted_items) of true -> maps:get(J_7, Sorted_items, nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + J_7 + 1, Sorted_items); _ -> mochi_nth(J_7 + 1, Sorted_items) end end) + 1, Header_table_8) end end), nil)) of
        true -> Tmp_3 = (case erlang:is_map(Sorted_items) of true -> maps:get(I_7, Sorted_items, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + I_7 + 1, Sorted_items); _ -> mochi_nth(I_7 + 1, Sorted_items) end end),
            Sorted_items_2 = lists:sublist(Sorted_items, I_7) ++ [(case erlang:is_map(Sorted_items) of true -> maps:get(J_7, Sorted_items, nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length(Sorted_items) + J_7 + 1, Sorted_items); _ -> mochi_nth(J_7 + 1, Sorted_items) end end)] ++ lists:nthtail(I_7 + 1, Sorted_items),
            Sorted_items_3 = lists:sublist(Sorted_items_2, J_7) ++ [Tmp_3] ++ lists:nthtail(J_7 + 1, Sorted_items_2),
            Sorted_items_4 = Sorted_items_3,
            Tmp_4 = Tmp_3;
        _ -> Sorted_items_4 = Sorted_items,
            Tmp_4 = nil
    end,
            J_8 = (J_7 + 1),
            Fun_12_loop(Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, J_8, Min_sup_2, Pre_fix, Sorted_items_4);
        _ -> {Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, J_7, Min_sup_2, Pre_fix, Sorted_items}
    end
end,
{Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, J_8, Min_sup_2, Pre_fix, Sorted_items_4} = Fun_12(Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, J_7, Min_sup_2, Pre_fix, Sorted_items),
            I_8 = (I_7 + 1),
            Fun_13_loop(Freq_item_list, Freq_list, Header_table_8, I_8, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4);
        _ -> {Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items}
    end
end,
{Freq_item_list, Freq_list, Header_table_8, I_8, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4} = Fun_13(Freq_item_list, Freq_list, Header_table_8, I_7, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items),
        Idx = 0,
        Fun_16 = fun Fun_16_loop(Freq_item_list, Freq_list, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4) ->
    case (Idx < erlang:length(Sorted_items_4)) of
        true ->
            Base_pat_2 = (case erlang:is_map(Sorted_items_4) of true -> maps:get(Idx, Sorted_items_4, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Sorted_items_4) + Idx + 1, Sorted_items_4); _ -> mochi_nth(Idx + 1, Sorted_items_4) end end),
            New_freq = Pre_fix,
            New_freq_2 = lists:append((case New_freq of nil -> []; _ -> New_freq end), [Base_pat_2]),
            Freq_list_2 = lists:append((case Freq_list of nil -> []; _ -> Freq_list end), [New_freq_2]),
            Cond_pats_4 = find_prefix_path(Base_pat_2, maps:get("node", (case erlang:is_map(Header_table_8) of true -> maps:get(Base_pat_2, Header_table_8, nil); _ -> case Base_pat_2 < 0 of true -> mochi_nth(erlang:length(Header_table_8) + Base_pat_2 + 1, Header_table_8); _ -> mochi_nth(Base_pat_2 + 1, Header_table_8) end end), nil)),
            Cond_dataset = [],
            P = 0,
            Fun_15 = fun Fun_15_loop(Base_pat_2, Cond_dataset, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pre_fix, Sorted_items_4) ->
    case (P < erlang:length(Cond_pats_4)) of
        true ->
            Pat = (case erlang:is_map(Cond_pats_4) of true -> maps:get(P, Cond_pats_4, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Cond_pats_4) + P + 1, Cond_pats_4); _ -> mochi_nth(P + 1, Cond_pats_4) end end),
            R = 0,
            Fun_14 = fun Fun_14_loop(Base_pat_2, Cond_dataset, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pat, Pre_fix, R, Sorted_items_4) ->
    case (R < maps:get("count", Pat, nil)) of
        true ->
            Cond_dataset_2 = lists:append((case Cond_dataset of nil -> []; _ -> Cond_dataset end), [maps:get("items", Pat, nil)]),
            R_2 = (R + 1),
            Fun_14_loop(Base_pat_2, Cond_dataset_2, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pat, Pre_fix, R_2, Sorted_items_4);
        _ -> {Base_pat_2, Cond_dataset, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pat, Pre_fix, R, Sorted_items_4}
    end
end,
{Base_pat_2, Cond_dataset_2, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pat, Pre_fix, R_2, Sorted_items_4} = Fun_14(Base_pat_2, Cond_dataset, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pat, Pre_fix, R, Sorted_items_4),
            P_2 = (P + 1),
            Fun_15_loop(Base_pat_2, Cond_dataset_2, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P_2, Pre_fix, Sorted_items_4);
        _ -> {Base_pat_2, Cond_dataset, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pre_fix, Sorted_items_4}
    end
end,
{Base_pat_2, Cond_dataset_2, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P_2, Pre_fix, Sorted_items_4} = Fun_15(Base_pat_2, Cond_dataset, Cond_pats_4, Freq_item_list, Freq_list_2, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, New_freq_2, P, Pre_fix, Sorted_items_4),
            Res2 = create_tree(Cond_dataset_2, Min_sup_2),
            My_tree = maps:get("tree", Res2, nil),
            My_head = maps:get("header", Res2, nil),
            case (erlang:length(My_head) > 0) of
        true -> Freq_list_3 = mine_tree(My_tree, My_head, Min_sup_2, New_freq_2, Freq_list_2),
            Freq_list_4 = Freq_list_3;
        _ -> Freq_list_4 = Freq_list_2
    end,
            Idx_2 = (Idx + 1),
            Fun_16_loop(Freq_item_list, Freq_list_4, Header_table_8, I_8, Idx_2, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4);
        _ -> {Freq_item_list, Freq_list, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4}
    end
end,
{Freq_item_list, Freq_list_4, Header_table_8, I_8, Idx_2, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4} = Fun_16(Freq_item_list, Freq_list, Header_table_8, I_8, Idx, In_tree_5, Items_6, Min_sup_2, Pre_fix, Sorted_items_4),
        Freq_list_4
    catch {return, RetCatch} -> RetCatch end.

list_to_string(Xs) ->
    try
        S = "[",
        I_9 = 0,
        Fun_17 = fun Fun_17_loop(I_9, S, Xs) ->
    case (I_9 < erlang:length(Xs)) of
        true ->
            S_2 = (S ++ (case erlang:is_map(Xs) of true -> maps:get(I_9, Xs, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Xs) + I_9 + 1, Xs); _ -> mochi_nth(I_9 + 1, Xs) end end)),
            case (I_9 < (erlang:length(Xs) - 1)) of
        true -> S_3 = (S_2 ++ ", "),
            S_4 = S_3;
        _ -> S_4 = S_2
    end,
            I_10 = (I_9 + 1),
            Fun_17_loop(I_10, S_4, Xs);
        _ -> {I_9, S, Xs}
    end
end,
{I_10, S_4, Xs} = Fun_17(I_9, S, Xs),
        (S_4 ++ "]")
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Data_set_2 = [["bread", "milk", "cheese"], ["bread", "milk"], ["bread", "diapers"], ["bread", "milk", "diapers"], ["milk", "diapers"], ["milk", "cheese"], ["diapers", "cheese"], ["bread", "milk", "cheese", "diapers"]],
        Res = create_tree(Data_set_2, 3),
        Fp_tree_2 = maps:get("tree", Res, nil),
        Header_table_9 = maps:get("header", Res, nil),
        Freq_items_3 = [],
        Freq_items_4 = mine_tree(Fp_tree_2, Header_table_9, 3, [], Freq_items_3),
        io:format("~ts~n", [mochi_repr(erlang:length(Data_set_2))]),
        io:format("~ts~n", [mochi_repr(erlang:length(Header_table_9))]),
        I_11 = 0,
        Fun_18 = fun Fun_18_loop(Data_set_2, Fp_tree_2, Freq_items_4, Header_table_9, I_11, Res) ->
    case (I_11 < erlang:length(Freq_items_4)) of
        true ->
            io:format("~ts~n", [mochi_repr(list_to_string((case erlang:is_map(Freq_items_4) of true -> maps:get(I_11, Freq_items_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Freq_items_4) + I_11 + 1, Freq_items_4); _ -> mochi_nth(I_11 + 1, Freq_items_4) end end)))]),
            I_12 = (I_11 + 1),
            Fun_18_loop(Data_set_2, Fp_tree_2, Freq_items_4, Header_table_9, I_12, Res);
        _ -> {Data_set_2, Fp_tree_2, Freq_items_4, Header_table_9, I_11, Res}
    end
end,
{Data_set_2, Fp_tree_2, Freq_items_4, Header_table_9, I_12, Res} = Fun_18(Data_set_2, Fp_tree_2, Freq_items_4, Header_table_9, I_11, Res),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
