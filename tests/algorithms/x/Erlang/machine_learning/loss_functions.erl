#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, absf/1, maxf/2, minf/2, clip/3, to_float/1, powf/2, ln/1, exp/1, mean/1, binary_cross_entropy/3, binary_focal_cross_entropy/5, categorical_cross_entropy/3, categorical_focal_cross_entropy/5, hinge_loss/2, huber_loss/3, mean_squared_error/2, mean_absolute_error/2, mean_squared_logarithmic_error/2, mean_absolute_percentage_error/3, perplexity_loss/3, smooth_l1_loss/3, kullback_leibler_divergence/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (ec7cf2f058) on 2025-08-07 14:07 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

absf(X) ->
    try
        (case (X < 0.0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

maxf(A, B) ->
    try
        (case (A > B) of
    true -> A;
    _ -> B
end)
    catch {return, Ret} -> Ret end.

minf(A_2, B_2) ->
    try
        (case (A_2 < B_2) of
    true -> A_2;
    _ -> B_2
end)
    catch {return, Ret} -> Ret end.

clip(X_2, Lo, Hi) ->
    try
        maxf(Lo, minf(X_2, Hi))
    catch {return, Ret} -> Ret end.

to_float(X_3) ->
    try
        mochi_safe_mul(X_3, 1.0)
    catch {return, Ret} -> Ret end.

powf(Base, Exp) ->
    try
        Result = 1.0,
        I = 0,
        N = mochi_to_int(Exp),
        Fun = fun Fun_loop(Base, Exp, I, N, Result) ->
    case (I < N) of
        true ->
            Result_2 = mochi_safe_mul(Result, Base),
            I_2 = (I + 1),
            Fun_loop(Base, Exp, I_2, N, Result_2);
        _ -> {Base, Exp, I, N, Result}
    end
end,
{Base, Exp, I_2, N, Result_2} = Fun(Base, Exp, I, N, Result),
        Result_2
    catch {return, Ret} -> Ret end.

ln(X_4) ->
    try
        case (X_4 =< 0.0) of
        true -> erlang:error("ln domain error");
        _ -> ok
    end,
        Y = mochi_safe_div((X_4 - 1.0), (X_4 + 1.0)),
        Y2 = mochi_safe_mul(Y, Y),
        Term = Y,
        Sum = 0.0,
        K = 0,
        Fun_2 = fun Fun_2_loop(K, Sum, Term, X_4, Y, Y2) ->
    case (K < 10) of
        true ->
            Denom = to_float(((2 * K) + 1)),
            Sum_2 = (Sum + mochi_safe_div(Term, Denom)),
            Term_2 = mochi_safe_mul(Term, Y2),
            K_2 = (K + 1),
            Fun_2_loop(K_2, Sum_2, Term_2, X_4, Y, Y2);
        _ -> {K, Sum, Term, X_4, Y, Y2}
    end
end,
{K_2, Sum_2, Term_2, X_4, Y, Y2} = Fun_2(K, Sum, Term, X_4, Y, Y2),
        mochi_safe_mul(2.0, Sum_2)
    catch {return, Ret} -> Ret end.

exp(X_5) ->
    try
        Term_3 = 1.0,
        Sum_3 = 1.0,
        N_2 = 1,
        Fun_3 = fun Fun_3_loop(N_2, Sum_3, Term_3, X_5) ->
    case (N_2 < 20) of
        true ->
            Term_4 = mochi_safe_div(mochi_safe_mul(Term_3, X_5), to_float(N_2)),
            Sum_4 = (Sum_3 + Term_4),
            N_3 = (N_2 + 1),
            Fun_3_loop(N_3, Sum_4, Term_4, X_5);
        _ -> {N_2, Sum_3, Term_3, X_5}
    end
end,
{N_3, Sum_4, Term_4, X_5} = Fun_3(N_2, Sum_3, Term_3, X_5),
        Sum_4
    catch {return, Ret} -> Ret end.

mean(V) ->
    try
        Total = 0.0,
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(I_3, Total, V) ->
    case (I_3 < erlang:length(V)) of
        true ->
            Total_2 = (Total + (case erlang:is_map(V) of true -> maps:get(I_3, V, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(V) + I_3 + 1, V); _ -> mochi_nth(I_3 + 1, V) end end)),
            I_4 = (I_3 + 1),
            Fun_4_loop(I_4, Total_2, V);
        _ -> {I_3, Total, V}
    end
end,
{I_4, Total_2, V} = Fun_4(I_3, Total, V),
        mochi_safe_div(Total_2, to_float(erlang:length(V)))
    catch {return, Ret} -> Ret end.

binary_cross_entropy(Y_true, Y_pred, Epsilon) ->
    try
        case (erlang:length(Y_true) /= erlang:length(Y_pred)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Losses = [],
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(Epsilon, I_5, Losses, Y_pred, Y_true) ->
    case (I_5 < erlang:length(Y_true)) of
        true ->
            Yt = (case erlang:is_map(Y_true) of true -> maps:get(I_5, Y_true, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Y_true) + I_5 + 1, Y_true); _ -> mochi_nth(I_5 + 1, Y_true) end end),
            Yp = clip((case erlang:is_map(Y_pred) of true -> maps:get(I_5, Y_pred, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Y_pred) + I_5 + 1, Y_pred); _ -> mochi_nth(I_5 + 1, Y_pred) end end), Epsilon, (1.0 - Epsilon)),
            Loss = -(mochi_safe_mul(Yt, ln(Yp)) + mochi_safe_mul((1.0 - Yt), ln((1.0 - Yp)))),
            Losses_2 = lists:append((case Losses of nil -> []; _ -> Losses end), [Loss]),
            I_6 = (I_5 + 1),
            Fun_5_loop(Epsilon, I_6, Losses_2, Y_pred, Y_true);
        _ -> {Epsilon, I_5, Losses, Y_pred, Y_true}
    end
end,
{Epsilon, I_6, Losses_2, Y_pred, Y_true} = Fun_5(Epsilon, I_5, Losses, Y_pred, Y_true),
        mean(Losses_2)
    catch {return, Ret} -> Ret end.

binary_focal_cross_entropy(Y_true_2, Y_pred_2, Gamma, Alpha, Epsilon_2) ->
    try
        case (erlang:length(Y_true_2) /= erlang:length(Y_pred_2)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Losses_3 = [],
        I_7 = 0,
        Fun_6 = fun Fun_6_loop(Alpha, Epsilon_2, Gamma, I_7, Losses_3, Y_pred_2, Y_true_2) ->
    case (I_7 < erlang:length(Y_true_2)) of
        true ->
            Yt_2 = (case erlang:is_map(Y_true_2) of true -> maps:get(I_7, Y_true_2, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Y_true_2) + I_7 + 1, Y_true_2); _ -> mochi_nth(I_7 + 1, Y_true_2) end end),
            Yp_2 = clip((case erlang:is_map(Y_pred_2) of true -> maps:get(I_7, Y_pred_2, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Y_pred_2) + I_7 + 1, Y_pred_2); _ -> mochi_nth(I_7 + 1, Y_pred_2) end end), Epsilon_2, (1.0 - Epsilon_2)),
            Term1 = mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(Alpha, powf((1.0 - Yp_2), Gamma)), Yt_2), ln(Yp_2)),
            Term2 = mochi_safe_mul(mochi_safe_mul(mochi_safe_mul((1.0 - Alpha), powf(Yp_2, Gamma)), (1.0 - Yt_2)), ln((1.0 - Yp_2))),
            Losses_4 = lists:append((case Losses_3 of nil -> []; _ -> Losses_3 end), [-(Term1 + Term2)]),
            I_8 = (I_7 + 1),
            Fun_6_loop(Alpha, Epsilon_2, Gamma, I_8, Losses_4, Y_pred_2, Y_true_2);
        _ -> {Alpha, Epsilon_2, Gamma, I_7, Losses_3, Y_pred_2, Y_true_2}
    end
end,
{Alpha, Epsilon_2, Gamma, I_8, Losses_4, Y_pred_2, Y_true_2} = Fun_6(Alpha, Epsilon_2, Gamma, I_7, Losses_3, Y_pred_2, Y_true_2),
        mean(Losses_4)
    catch {return, Ret} -> Ret end.

categorical_cross_entropy(Y_true_3, Y_pred_3, Epsilon_3) ->
    try
        case (erlang:length(Y_true_3) /= erlang:length(Y_pred_3)) of
        true -> erlang:error("Input arrays must have the same shape.");
        _ -> ok
    end,
        Rows = erlang:length(Y_true_3),
        Total_3 = 0.0,
        I_9 = 0,
        Fun_9 = fun Fun_9_loop(Epsilon_3, I_9, Rows, Total_3, Y_pred_3, Y_true_3) ->
    case (I_9 < Rows) of
        true ->
            case (erlang:length((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) /= erlang:length((case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end))) of
        true -> erlang:error("Input arrays must have the same shape.");
        _ -> ok
    end,
            Sum_true = 0.0,
            Sum_pred = 0.0,
            J = 0,
            Fun_7 = fun Fun_7_loop(Epsilon_3, I_9, J, Rows, Sum_pred, Sum_true, Total_3, Y_pred_3, Y_true_3) ->
    case (J < erlang:length((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end))) of
        true ->
            Yt_3 = (case erlang:is_map((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) of true -> maps:get(J, (case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) + J + 1, (case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)); _ -> mochi_nth(J + 1, (case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) end end),
            Yp_3 = (case erlang:is_map((case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)) of true -> maps:get(J, (case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)) + J + 1, (case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)); _ -> mochi_nth(J + 1, (case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)) end end),
            case ((Yt_3 /= 0.0) andalso (Yt_3 /= 1.0)) of
        true -> erlang:error("y_true must be one-hot encoded.");
        _ -> ok
    end,
            Sum_true_2 = (Sum_true + Yt_3),
            Sum_pred_2 = (Sum_pred + Yp_3),
            J_2 = (J + 1),
            Fun_7_loop(Epsilon_3, I_9, J_2, Rows, Sum_pred_2, Sum_true_2, Total_3, Y_pred_3, Y_true_3);
        _ -> {Epsilon_3, I_9, J, Rows, Sum_pred, Sum_true, Total_3, Y_pred_3, Y_true_3}
    end
end,
{Epsilon_3, I_9, J_2, Rows, Sum_pred_2, Sum_true_2, Total_3, Y_pred_3, Y_true_3} = Fun_7(Epsilon_3, I_9, J, Rows, Sum_pred, Sum_true, Total_3, Y_pred_3, Y_true_3),
            case (Sum_true_2 /= 1.0) of
        true -> erlang:error("y_true must be one-hot encoded.");
        _ -> ok
    end,
            case (absf((Sum_pred_2 - 1.0)) > Epsilon_3) of
        true -> erlang:error("Predicted probabilities must sum to approximately 1.");
        _ -> ok
    end,
            J_3 = 0,
            Fun_8 = fun Fun_8_loop(Epsilon_3, I_9, J_3, Rows, Sum_pred_2, Sum_true_2, Total_3, Y_pred_3, Y_true_3) ->
    case (J_3 < erlang:length((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end))) of
        true ->
            Yp_4 = clip((case erlang:is_map((case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)) of true -> maps:get(J_3, (case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)) + J_3 + 1, (case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Y_pred_3) of true -> maps:get(I_9, Y_pred_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_pred_3) + I_9 + 1, Y_pred_3); _ -> mochi_nth(I_9 + 1, Y_pred_3) end end)) end end), Epsilon_3, 1.0),
            Total_4 = (Total_3 - mochi_safe_mul((case erlang:is_map((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) of true -> maps:get(J_3, (case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) + J_3 + 1, (case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Y_true_3) of true -> maps:get(I_9, Y_true_3, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Y_true_3) + I_9 + 1, Y_true_3); _ -> mochi_nth(I_9 + 1, Y_true_3) end end)) end end), ln(Yp_4))),
            J_4 = (J_3 + 1),
            Fun_8_loop(Epsilon_3, I_9, J_4, Rows, Sum_pred_2, Sum_true_2, Total_4, Y_pred_3, Y_true_3);
        _ -> {Epsilon_3, I_9, J_3, Rows, Sum_pred_2, Sum_true_2, Total_3, Y_pred_3, Y_true_3}
    end
end,
{Epsilon_3, I_9, J_4, Rows, Sum_pred_2, Sum_true_2, Total_4, Y_pred_3, Y_true_3} = Fun_8(Epsilon_3, I_9, J_3, Rows, Sum_pred_2, Sum_true_2, Total_3, Y_pred_3, Y_true_3),
            I_10 = (I_9 + 1),
            Fun_9_loop(Epsilon_3, I_10, Rows, Total_4, Y_pred_3, Y_true_3);
        _ -> {Epsilon_3, I_9, Rows, Total_3, Y_pred_3, Y_true_3}
    end
end,
{Epsilon_3, I_10, Rows, Total_4, Y_pred_3, Y_true_3} = Fun_9(Epsilon_3, I_9, Rows, Total_3, Y_pred_3, Y_true_3),
        Total_4
    catch {return, Ret} -> Ret end.

categorical_focal_cross_entropy(Y_true_4, Y_pred_4, Alpha_2, Gamma_2, Epsilon_4) ->
    try
        case (erlang:length(Y_true_4) /= erlang:length(Y_pred_4)) of
        true -> erlang:error("Shape of y_true and y_pred must be the same.");
        _ -> ok
    end,
        Rows_2 = erlang:length(Y_true_4),
        Cols = erlang:length((case erlang:is_map(Y_true_4) of true -> maps:get(0, Y_true_4, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + 0 + 1, Y_true_4); _ -> mochi_nth(0 + 1, Y_true_4) end end)),
        A_3 = Alpha_2,
        case (erlang:length(A_3) == 0) of
        true -> Tmp = [],
            J_5 = 0,
            Fun_10 = fun Fun_10_loop(A_3, Alpha_2, Cols, Epsilon_4, Gamma_2, J_5, Rows_2, Tmp, Y_pred_4, Y_true_4) ->
    case (J_5 < Cols) of
        true ->
            Tmp_2 = lists:append((case Tmp of nil -> []; _ -> Tmp end), [1.0]),
            J_6 = (J_5 + 1),
            Fun_10_loop(A_3, Alpha_2, Cols, Epsilon_4, Gamma_2, J_6, Rows_2, Tmp_2, Y_pred_4, Y_true_4);
        _ -> {A_3, Alpha_2, Cols, Epsilon_4, Gamma_2, J_5, Rows_2, Tmp, Y_pred_4, Y_true_4}
    end
end,
{A_3, Alpha_2, Cols, Epsilon_4, Gamma_2, J_6, Rows_2, Tmp_2, Y_pred_4, Y_true_4} = Fun_10(A_3, Alpha_2, Cols, Epsilon_4, Gamma_2, J_5, Rows_2, Tmp, Y_pred_4, Y_true_4),
            A_4 = Tmp_2,
            A_5 = A_4,
            Fun_11 = Fun_10,
            J_7 = J_6,
            Tmp_3 = Tmp_2;
        _ -> A_5 = A_3,
            Fun_11 = nil,
            J_7 = nil,
            Tmp_3 = nil
    end,
        case (erlang:length(A_5) /= Cols) of
        true -> erlang:error("Length of alpha must match the number of classes.");
        _ -> ok
    end,
        Total_5 = 0.0,
        I_11 = 0,
        Fun_14 = fun Fun_14_loop(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_7, Rows_2, Tmp_3, Total_5, Y_pred_4, Y_true_4) ->
    case (I_11 < Rows_2) of
        true ->
            case ((erlang:length((case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) /= Cols) orelse (erlang:length((case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) /= Cols)) of
        true -> erlang:error("Shape of y_true and y_pred must be the same.");
        _ -> ok
    end,
            Sum_true_3 = 0.0,
            Sum_pred_3 = 0.0,
            J_8 = 0,
            Fun_12 = fun Fun_12_loop(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_8, Rows_2, Sum_pred_3, Sum_true_3, Tmp_3, Total_5, Y_pred_4, Y_true_4) ->
    case (J_8 < Cols) of
        true ->
            Yt_4 = (case erlang:is_map((case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) of true -> maps:get(J_8, (case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end), nil); _ -> case J_8 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) + J_8 + 1, (case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)); _ -> mochi_nth(J_8 + 1, (case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) end end),
            Yp_5 = (case erlang:is_map((case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) of true -> maps:get(J_8, (case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end), nil); _ -> case J_8 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) + J_8 + 1, (case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)); _ -> mochi_nth(J_8 + 1, (case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) end end),
            case ((Yt_4 /= 0.0) andalso (Yt_4 /= 1.0)) of
        true -> erlang:error("y_true must be one-hot encoded.");
        _ -> ok
    end,
            Sum_true_4 = (Sum_true_3 + Yt_4),
            Sum_pred_4 = (Sum_pred_3 + Yp_5),
            J_9 = (J_8 + 1),
            Fun_12_loop(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_9, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4);
        _ -> {A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_8, Rows_2, Sum_pred_3, Sum_true_3, Tmp_3, Total_5, Y_pred_4, Y_true_4}
    end
end,
{A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_9, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4} = Fun_12(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_8, Rows_2, Sum_pred_3, Sum_true_3, Tmp_3, Total_5, Y_pred_4, Y_true_4),
            case (Sum_true_4 /= 1.0) of
        true -> erlang:error("y_true must be one-hot encoded.");
        _ -> ok
    end,
            case (absf((Sum_pred_4 - 1.0)) > Epsilon_4) of
        true -> erlang:error("Predicted probabilities must sum to approximately 1.");
        _ -> ok
    end,
            Row_loss = 0.0,
            J_10 = 0,
            Fun_13 = fun Fun_13_loop(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_10, Row_loss, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4) ->
    case (J_10 < Cols) of
        true ->
            Yp_6 = clip((case erlang:is_map((case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) of true -> maps:get(J_10, (case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end), nil); _ -> case J_10 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) + J_10 + 1, (case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)); _ -> mochi_nth(J_10 + 1, (case erlang:is_map(Y_pred_4) of true -> maps:get(I_11, Y_pred_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_pred_4) + I_11 + 1, Y_pred_4); _ -> mochi_nth(I_11 + 1, Y_pred_4) end end)) end end), Epsilon_4, 1.0),
            Row_loss_2 = (Row_loss + mochi_safe_mul(mochi_safe_mul(mochi_safe_mul((case erlang:is_map(A_5) of true -> maps:get(J_10, A_5, nil); _ -> case J_10 < 0 of true -> mochi_nth(erlang:length(A_5) + J_10 + 1, A_5); _ -> mochi_nth(J_10 + 1, A_5) end end), powf((1.0 - Yp_6), Gamma_2)), (case erlang:is_map((case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) of true -> maps:get(J_10, (case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end), nil); _ -> case J_10 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) + J_10 + 1, (case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)); _ -> mochi_nth(J_10 + 1, (case erlang:is_map(Y_true_4) of true -> maps:get(I_11, Y_true_4, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Y_true_4) + I_11 + 1, Y_true_4); _ -> mochi_nth(I_11 + 1, Y_true_4) end end)) end end)), ln(Yp_6))),
            J_11 = (J_10 + 1),
            Fun_13_loop(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_11, Row_loss_2, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4);
        _ -> {A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_10, Row_loss, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4}
    end
end,
{A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_11, Row_loss_2, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4} = Fun_13(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_10, Row_loss, Rows_2, Sum_pred_4, Sum_true_4, Tmp_3, Total_5, Y_pred_4, Y_true_4),
            Total_6 = (Total_5 - Row_loss_2),
            I_12 = (I_11 + 1),
            Fun_14_loop(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_12, J_11, Rows_2, Tmp_3, Total_6, Y_pred_4, Y_true_4);
        _ -> {A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_7, Rows_2, Tmp_3, Total_5, Y_pred_4, Y_true_4}
    end
end,
{A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_12, J_11, Rows_2, Tmp_3, Total_6, Y_pred_4, Y_true_4} = Fun_14(A_5, Alpha_2, Cols, Epsilon_4, Gamma_2, I_11, J_7, Rows_2, Tmp_3, Total_5, Y_pred_4, Y_true_4),
        mochi_safe_div(Total_6, to_float(Rows_2))
    catch {return, Ret} -> Ret end.

hinge_loss(Y_true_5, Y_pred_5) ->
    try
        case (erlang:length(Y_true_5) /= erlang:length(Y_pred_5)) of
        true -> erlang:error("Length of predicted and actual array must be same.");
        _ -> ok
    end,
        Losses_5 = [],
        I_13 = 0,
        Fun_15 = fun Fun_15_loop(I_13, Losses_5, Y_pred_5, Y_true_5) ->
    case (I_13 < erlang:length(Y_true_5)) of
        true ->
            Yt_5 = (case erlang:is_map(Y_true_5) of true -> maps:get(I_13, Y_true_5, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(Y_true_5) + I_13 + 1, Y_true_5); _ -> mochi_nth(I_13 + 1, Y_true_5) end end),
            case ((Yt_5 /= -1.0) andalso (Yt_5 /= 1.0)) of
        true -> erlang:error("y_true can have values -1 or 1 only.");
        _ -> ok
    end,
            Pred = (case erlang:is_map(Y_pred_5) of true -> maps:get(I_13, Y_pred_5, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(Y_pred_5) + I_13 + 1, Y_pred_5); _ -> mochi_nth(I_13 + 1, Y_pred_5) end end),
            L = maxf(0.0, (1.0 - mochi_safe_mul(Yt_5, Pred))),
            Losses_6 = lists:append((case Losses_5 of nil -> []; _ -> Losses_5 end), [L]),
            I_14 = (I_13 + 1),
            Fun_15_loop(I_14, Losses_6, Y_pred_5, Y_true_5);
        _ -> {I_13, Losses_5, Y_pred_5, Y_true_5}
    end
end,
{I_14, Losses_6, Y_pred_5, Y_true_5} = Fun_15(I_13, Losses_5, Y_pred_5, Y_true_5),
        mean(Losses_6)
    catch {return, Ret} -> Ret end.

huber_loss(Y_true_6, Y_pred_6, Delta) ->
    try
        case (erlang:length(Y_true_6) /= erlang:length(Y_pred_6)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Total_7 = 0.0,
        I_15 = 0,
        Fun_16 = fun Fun_16_loop(Delta, I_15, Total_7, Y_pred_6, Y_true_6) ->
    case (I_15 < erlang:length(Y_true_6)) of
        true ->
            Diff = ((case erlang:is_map(Y_true_6) of true -> maps:get(I_15, Y_true_6, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Y_true_6) + I_15 + 1, Y_true_6); _ -> mochi_nth(I_15 + 1, Y_true_6) end end) - (case erlang:is_map(Y_pred_6) of true -> maps:get(I_15, Y_pred_6, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Y_pred_6) + I_15 + 1, Y_pred_6); _ -> mochi_nth(I_15 + 1, Y_pred_6) end end)),
            Adiff = absf(Diff),
            case (Adiff =< Delta) of
        true -> Total_8 = (Total_7 + mochi_safe_mul(mochi_safe_mul(0.5, Diff), Diff)),
            Total_10 = Total_8;
        _ -> Total_9 = (Total_7 + mochi_safe_mul(Delta, (Adiff - mochi_safe_mul(0.5, Delta)))),
            Total_10 = Total_9
    end,
            I_16 = (I_15 + 1),
            Fun_16_loop(Delta, I_16, Total_10, Y_pred_6, Y_true_6);
        _ -> {Delta, I_15, Total_7, Y_pred_6, Y_true_6}
    end
end,
{Delta, I_16, Total_10, Y_pred_6, Y_true_6} = Fun_16(Delta, I_15, Total_7, Y_pred_6, Y_true_6),
        mochi_safe_div(Total_10, to_float(erlang:length(Y_true_6)))
    catch {return, Ret} -> Ret end.

mean_squared_error(Y_true_7, Y_pred_7) ->
    try
        case (erlang:length(Y_true_7) /= erlang:length(Y_pred_7)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Losses_7 = [],
        I_17 = 0,
        Fun_17 = fun Fun_17_loop(I_17, Losses_7, Y_pred_7, Y_true_7) ->
    case (I_17 < erlang:length(Y_true_7)) of
        true ->
            Diff_2 = ((case erlang:is_map(Y_true_7) of true -> maps:get(I_17, Y_true_7, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Y_true_7) + I_17 + 1, Y_true_7); _ -> mochi_nth(I_17 + 1, Y_true_7) end end) - (case erlang:is_map(Y_pred_7) of true -> maps:get(I_17, Y_pred_7, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Y_pred_7) + I_17 + 1, Y_pred_7); _ -> mochi_nth(I_17 + 1, Y_pred_7) end end)),
            Losses_8 = lists:append((case Losses_7 of nil -> []; _ -> Losses_7 end), [mochi_safe_mul(Diff_2, Diff_2)]),
            I_18 = (I_17 + 1),
            Fun_17_loop(I_18, Losses_8, Y_pred_7, Y_true_7);
        _ -> {I_17, Losses_7, Y_pred_7, Y_true_7}
    end
end,
{I_18, Losses_8, Y_pred_7, Y_true_7} = Fun_17(I_17, Losses_7, Y_pred_7, Y_true_7),
        mean(Losses_8)
    catch {return, Ret} -> Ret end.

mean_absolute_error(Y_true_8, Y_pred_8) ->
    try
        case (erlang:length(Y_true_8) /= erlang:length(Y_pred_8)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Total_11 = 0.0,
        I_19 = 0,
        Fun_18 = fun Fun_18_loop(I_19, Total_11, Y_pred_8, Y_true_8) ->
    case (I_19 < erlang:length(Y_true_8)) of
        true ->
            Total_12 = (Total_11 + absf(((case erlang:is_map(Y_true_8) of true -> maps:get(I_19, Y_true_8, nil); _ -> case I_19 < 0 of true -> mochi_nth(erlang:length(Y_true_8) + I_19 + 1, Y_true_8); _ -> mochi_nth(I_19 + 1, Y_true_8) end end) - (case erlang:is_map(Y_pred_8) of true -> maps:get(I_19, Y_pred_8, nil); _ -> case I_19 < 0 of true -> mochi_nth(erlang:length(Y_pred_8) + I_19 + 1, Y_pred_8); _ -> mochi_nth(I_19 + 1, Y_pred_8) end end)))),
            I_20 = (I_19 + 1),
            Fun_18_loop(I_20, Total_12, Y_pred_8, Y_true_8);
        _ -> {I_19, Total_11, Y_pred_8, Y_true_8}
    end
end,
{I_20, Total_12, Y_pred_8, Y_true_8} = Fun_18(I_19, Total_11, Y_pred_8, Y_true_8),
        mochi_safe_div(Total_12, to_float(erlang:length(Y_true_8)))
    catch {return, Ret} -> Ret end.

mean_squared_logarithmic_error(Y_true_9, Y_pred_9) ->
    try
        case (erlang:length(Y_true_9) /= erlang:length(Y_pred_9)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Total_13 = 0.0,
        I_21 = 0,
        Fun_19 = fun Fun_19_loop(I_21, Total_13, Y_pred_9, Y_true_9) ->
    case (I_21 < erlang:length(Y_true_9)) of
        true ->
            A_6 = ln((1.0 + (case erlang:is_map(Y_true_9) of true -> maps:get(I_21, Y_true_9, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Y_true_9) + I_21 + 1, Y_true_9); _ -> mochi_nth(I_21 + 1, Y_true_9) end end))),
            B_3 = ln((1.0 + (case erlang:is_map(Y_pred_9) of true -> maps:get(I_21, Y_pred_9, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Y_pred_9) + I_21 + 1, Y_pred_9); _ -> mochi_nth(I_21 + 1, Y_pred_9) end end))),
            Diff_3 = (A_6 - B_3),
            Total_14 = (Total_13 + mochi_safe_mul(Diff_3, Diff_3)),
            I_22 = (I_21 + 1),
            Fun_19_loop(I_22, Total_14, Y_pred_9, Y_true_9);
        _ -> {I_21, Total_13, Y_pred_9, Y_true_9}
    end
end,
{I_22, Total_14, Y_pred_9, Y_true_9} = Fun_19(I_21, Total_13, Y_pred_9, Y_true_9),
        mochi_safe_div(Total_14, to_float(erlang:length(Y_true_9)))
    catch {return, Ret} -> Ret end.

mean_absolute_percentage_error(Y_true_10, Y_pred_10, Epsilon_5) ->
    try
        case (erlang:length(Y_true_10) /= erlang:length(Y_pred_10)) of
        true -> erlang:error("The length of the two arrays should be the same.");
        _ -> ok
    end,
        Total_15 = 0.0,
        I_23 = 0,
        Fun_20 = fun Fun_20_loop(Epsilon_5, I_23, Total_15, Y_pred_10, Y_true_10) ->
    case (I_23 < erlang:length(Y_true_10)) of
        true ->
            Yt_6 = (case erlang:is_map(Y_true_10) of true -> maps:get(I_23, Y_true_10, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(Y_true_10) + I_23 + 1, Y_true_10); _ -> mochi_nth(I_23 + 1, Y_true_10) end end),
            case (Yt_6 == 0.0) of
        true -> Yt_7 = Epsilon_5,
            Yt_8 = Yt_7;
        _ -> Yt_8 = Yt_6
    end,
            Total_16 = (Total_15 + absf(mochi_safe_div((Yt_8 - (case erlang:is_map(Y_pred_10) of true -> maps:get(I_23, Y_pred_10, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(Y_pred_10) + I_23 + 1, Y_pred_10); _ -> mochi_nth(I_23 + 1, Y_pred_10) end end)), Yt_8))),
            I_24 = (I_23 + 1),
            Fun_20_loop(Epsilon_5, I_24, Total_16, Y_pred_10, Y_true_10);
        _ -> {Epsilon_5, I_23, Total_15, Y_pred_10, Y_true_10}
    end
end,
{Epsilon_5, I_24, Total_16, Y_pred_10, Y_true_10} = Fun_20(Epsilon_5, I_23, Total_15, Y_pred_10, Y_true_10),
        mochi_safe_div(Total_16, to_float(erlang:length(Y_true_10)))
    catch {return, Ret} -> Ret end.

perplexity_loss(Y_true_11, Y_pred_11, Epsilon_6) ->
    try
        Batch = erlang:length(Y_true_11),
        case (Batch /= erlang:length(Y_pred_11)) of
        true -> erlang:error("Batch size of y_true and y_pred must be equal.");
        _ -> ok
    end,
        Sentence_len = erlang:length((case erlang:is_map(Y_true_11) of true -> maps:get(0, Y_true_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + 0 + 1, Y_true_11); _ -> mochi_nth(0 + 1, Y_true_11) end end)),
        case (Sentence_len /= erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(0, Y_pred_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + 0 + 1, Y_pred_11); _ -> mochi_nth(0 + 1, Y_pred_11) end end))) of
        true -> erlang:error("Sentence length of y_true and y_pred must be equal.");
        _ -> ok
    end,
        Vocab_size = erlang:length((case erlang:is_map((case erlang:is_map(Y_pred_11) of true -> maps:get(0, Y_pred_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + 0 + 1, Y_pred_11); _ -> mochi_nth(0 + 1, Y_pred_11) end end)) of true -> maps:get(0, (case erlang:is_map(Y_pred_11) of true -> maps:get(0, Y_pred_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + 0 + 1, Y_pred_11); _ -> mochi_nth(0 + 1, Y_pred_11) end end), nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(0, Y_pred_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + 0 + 1, Y_pred_11); _ -> mochi_nth(0 + 1, Y_pred_11) end end)) + 0 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(0, Y_pred_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + 0 + 1, Y_pred_11); _ -> mochi_nth(0 + 1, Y_pred_11) end end)); _ -> mochi_nth(0 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(0, Y_pred_11, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + 0 + 1, Y_pred_11); _ -> mochi_nth(0 + 1, Y_pred_11) end end)) end end)),
        B_4 = 0,
        Total_perp = 0.0,
        Fun_22 = fun Fun_22_loop(B_4, Batch, Epsilon_6, Sentence_len, Total_perp, Vocab_size, Y_pred_11, Y_true_11) ->
    case (B_4 < Batch) of
        true ->
            case ((erlang:length((case erlang:is_map(Y_true_11) of true -> maps:get(B_4, Y_true_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + B_4 + 1, Y_true_11); _ -> mochi_nth(B_4 + 1, Y_true_11) end end)) /= Sentence_len) orelse (erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) /= Sentence_len)) of
        true -> erlang:error("Sentence length of y_true and y_pred must be equal.");
        _ -> ok
    end,
            Sum_log = 0.0,
            J_12 = 0,
            Fun_21 = fun Fun_21_loop(B_4, Batch, Epsilon_6, J_12, Sentence_len, Sum_log, Total_perp, Vocab_size, Y_pred_11, Y_true_11) ->
    case (J_12 < Sentence_len) of
        true ->
            Label = (case erlang:is_map((case erlang:is_map(Y_true_11) of true -> maps:get(B_4, Y_true_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + B_4 + 1, Y_true_11); _ -> mochi_nth(B_4 + 1, Y_true_11) end end)) of true -> maps:get(J_12, (case erlang:is_map(Y_true_11) of true -> maps:get(B_4, Y_true_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + B_4 + 1, Y_true_11); _ -> mochi_nth(B_4 + 1, Y_true_11) end end), nil); _ -> case J_12 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_true_11) of true -> maps:get(B_4, Y_true_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + B_4 + 1, Y_true_11); _ -> mochi_nth(B_4 + 1, Y_true_11) end end)) + J_12 + 1, (case erlang:is_map(Y_true_11) of true -> maps:get(B_4, Y_true_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + B_4 + 1, Y_true_11); _ -> mochi_nth(B_4 + 1, Y_true_11) end end)); _ -> mochi_nth(J_12 + 1, (case erlang:is_map(Y_true_11) of true -> maps:get(B_4, Y_true_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_true_11) + B_4 + 1, Y_true_11); _ -> mochi_nth(B_4 + 1, Y_true_11) end end)) end end),
            case (Label >= Vocab_size) of
        true -> erlang:error("Label value must not be greater than vocabulary size.");
        _ -> ok
    end,
            Prob = clip((case erlang:is_map((case erlang:is_map((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) of true -> maps:get(J_12, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end), nil); _ -> case J_12 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) + J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)); _ -> mochi_nth(J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) end end)) of true -> maps:get(Label, (case erlang:is_map((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) of true -> maps:get(J_12, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end), nil); _ -> case J_12 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) + J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)); _ -> mochi_nth(J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) end end), nil); _ -> case Label < 0 of true -> mochi_nth(erlang:length((case erlang:is_map((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) of true -> maps:get(J_12, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end), nil); _ -> case J_12 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) + J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)); _ -> mochi_nth(J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) end end)) + Label + 1, (case erlang:is_map((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) of true -> maps:get(J_12, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end), nil); _ -> case J_12 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) + J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)); _ -> mochi_nth(J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) end end)); _ -> mochi_nth(Label + 1, (case erlang:is_map((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) of true -> maps:get(J_12, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end), nil); _ -> case J_12 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) + J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)); _ -> mochi_nth(J_12 + 1, (case erlang:is_map(Y_pred_11) of true -> maps:get(B_4, Y_pred_11, nil); _ -> case B_4 < 0 of true -> mochi_nth(erlang:length(Y_pred_11) + B_4 + 1, Y_pred_11); _ -> mochi_nth(B_4 + 1, Y_pred_11) end end)) end end)) end end), Epsilon_6, 1.0),
            Sum_log_2 = (Sum_log + ln(Prob)),
            J_13 = (J_12 + 1),
            Fun_21_loop(B_4, Batch, Epsilon_6, J_13, Sentence_len, Sum_log_2, Total_perp, Vocab_size, Y_pred_11, Y_true_11);
        _ -> {B_4, Batch, Epsilon_6, J_12, Sentence_len, Sum_log, Total_perp, Vocab_size, Y_pred_11, Y_true_11}
    end
end,
{B_4, Batch, Epsilon_6, J_13, Sentence_len, Sum_log_2, Total_perp, Vocab_size, Y_pred_11, Y_true_11} = Fun_21(B_4, Batch, Epsilon_6, J_12, Sentence_len, Sum_log, Total_perp, Vocab_size, Y_pred_11, Y_true_11),
            Mean_log = mochi_safe_div(Sum_log_2, to_float(Sentence_len)),
            Perp = exp(-Mean_log),
            Total_perp_2 = (Total_perp + Perp),
            B_5 = (B_4 + 1),
            Fun_22_loop(B_5, Batch, Epsilon_6, Sentence_len, Total_perp_2, Vocab_size, Y_pred_11, Y_true_11);
        _ -> {B_4, Batch, Epsilon_6, Sentence_len, Total_perp, Vocab_size, Y_pred_11, Y_true_11}
    end
end,
{B_5, Batch, Epsilon_6, Sentence_len, Total_perp_2, Vocab_size, Y_pred_11, Y_true_11} = Fun_22(B_4, Batch, Epsilon_6, Sentence_len, Total_perp, Vocab_size, Y_pred_11, Y_true_11),
        mochi_safe_div(Total_perp_2, to_float(Batch))
    catch {return, Ret} -> Ret end.

smooth_l1_loss(Y_true_12, Y_pred_12, Beta) ->
    try
        case (erlang:length(Y_true_12) /= erlang:length(Y_pred_12)) of
        true -> erlang:error("The length of the two arrays should be the same.");
        _ -> ok
    end,
        Total_17 = 0.0,
        I_25 = 0,
        Fun_23 = fun Fun_23_loop(Beta, I_25, Total_17, Y_pred_12, Y_true_12) ->
    case (I_25 < erlang:length(Y_true_12)) of
        true ->
            Diff_4 = absf(((case erlang:is_map(Y_true_12) of true -> maps:get(I_25, Y_true_12, nil); _ -> case I_25 < 0 of true -> mochi_nth(erlang:length(Y_true_12) + I_25 + 1, Y_true_12); _ -> mochi_nth(I_25 + 1, Y_true_12) end end) - (case erlang:is_map(Y_pred_12) of true -> maps:get(I_25, Y_pred_12, nil); _ -> case I_25 < 0 of true -> mochi_nth(erlang:length(Y_pred_12) + I_25 + 1, Y_pred_12); _ -> mochi_nth(I_25 + 1, Y_pred_12) end end))),
            case (Diff_4 < Beta) of
        true -> Total_18 = (Total_17 + mochi_safe_div(mochi_safe_mul(mochi_safe_mul(0.5, Diff_4), Diff_4), Beta)),
            Total_20 = Total_18;
        _ -> Total_19 = ((Total_17 + Diff_4) - mochi_safe_mul(0.5, Beta)),
            Total_20 = Total_19
    end,
            I_26 = (I_25 + 1),
            Fun_23_loop(Beta, I_26, Total_20, Y_pred_12, Y_true_12);
        _ -> {Beta, I_25, Total_17, Y_pred_12, Y_true_12}
    end
end,
{Beta, I_26, Total_20, Y_pred_12, Y_true_12} = Fun_23(Beta, I_25, Total_17, Y_pred_12, Y_true_12),
        mochi_safe_div(Total_20, to_float(erlang:length(Y_true_12)))
    catch {return, Ret} -> Ret end.

kullback_leibler_divergence(Y_true_13, Y_pred_13) ->
    try
        case (erlang:length(Y_true_13) /= erlang:length(Y_pred_13)) of
        true -> erlang:error("Input arrays must have the same length.");
        _ -> ok
    end,
        Total_21 = 0.0,
        I_27 = 0,
        Fun_24 = fun Fun_24_loop(I_27, Total_21, Y_pred_13, Y_true_13) ->
    case (I_27 < erlang:length(Y_true_13)) of
        true ->
            Total_22 = (Total_21 + mochi_safe_mul((case erlang:is_map(Y_true_13) of true -> maps:get(I_27, Y_true_13, nil); _ -> case I_27 < 0 of true -> mochi_nth(erlang:length(Y_true_13) + I_27 + 1, Y_true_13); _ -> mochi_nth(I_27 + 1, Y_true_13) end end), ln(mochi_safe_div((case erlang:is_map(Y_true_13) of true -> maps:get(I_27, Y_true_13, nil); _ -> case I_27 < 0 of true -> mochi_nth(erlang:length(Y_true_13) + I_27 + 1, Y_true_13); _ -> mochi_nth(I_27 + 1, Y_true_13) end end), (case erlang:is_map(Y_pred_13) of true -> maps:get(I_27, Y_pred_13, nil); _ -> case I_27 < 0 of true -> mochi_nth(erlang:length(Y_pred_13) + I_27 + 1, Y_pred_13); _ -> mochi_nth(I_27 + 1, Y_pred_13) end end))))),
            I_28 = (I_27 + 1),
            Fun_24_loop(I_28, Total_22, Y_pred_13, Y_true_13);
        _ -> {I_27, Total_21, Y_pred_13, Y_true_13}
    end
end,
{I_28, Total_22, Y_pred_13, Y_true_13} = Fun_24(I_27, Total_21, Y_pred_13, Y_true_13),
        Total_22
    catch {return, Ret} -> Ret end.

main() ->
    try
        Y_true_bc = [0.0, 1.0, 1.0, 0.0, 1.0],
        Y_pred_bc = [0.2, 0.7, 0.9, 0.3, 0.8],
        io:format("~ts~n", [mochi_repr(binary_cross_entropy(Y_true_bc, Y_pred_bc, 0.000000000000001))]),
        io:format("~ts~n", [mochi_repr(binary_focal_cross_entropy(Y_true_bc, Y_pred_bc, 2.0, 0.25, 0.000000000000001))]),
        Y_true_cce = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]],
        Y_pred_cce = [[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]],
        io:format("~ts~n", [mochi_repr(categorical_cross_entropy(Y_true_cce, Y_pred_cce, 0.000000000000001))]),
        Alpha_3 = [0.6, 0.2, 0.7],
        io:format("~ts~n", [mochi_repr(categorical_focal_cross_entropy(Y_true_cce, Y_pred_cce, Alpha_3, 2.0, 0.000000000000001))]),
        Y_true_hinge = [-1.0, 1.0, 1.0, -1.0, 1.0],
        Y_pred_hinge = [-4.0, -0.3, 0.7, 5.0, 10.0],
        io:format("~ts~n", [mochi_repr(hinge_loss(Y_true_hinge, Y_pred_hinge))]),
        Y_true_huber = [0.9, 10.0, 2.0, 1.0, 5.2],
        Y_pred_huber = [0.8, 2.1, 2.9, 4.2, 5.2],
        io:format("~ts~n", [mochi_repr(huber_loss(Y_true_huber, Y_pred_huber, 1.0))]),
        io:format("~ts~n", [mochi_repr(mean_squared_error(Y_true_huber, Y_pred_huber))]),
        io:format("~ts~n", [mochi_repr(mean_absolute_error(Y_true_huber, Y_pred_huber))]),
        io:format("~ts~n", [mochi_repr(mean_squared_logarithmic_error(Y_true_huber, Y_pred_huber))]),
        Y_true_mape = [10.0, 20.0, 30.0, 40.0],
        Y_pred_mape = [12.0, 18.0, 33.0, 45.0],
        io:format("~ts~n", [mochi_repr(mean_absolute_percentage_error(Y_true_mape, Y_pred_mape, 0.000000000000001))]),
        Y_true_perp = [[1, 4], [2, 3]],
        Y_pred_perp = [[[0.28, 0.19, 0.21, 0.15, 0.17], [0.24, 0.19, 0.09, 0.18, 0.3]], [[0.03, 0.26, 0.21, 0.18, 0.32], [0.28, 0.1, 0.33, 0.15, 0.14]]],
        io:format("~ts~n", [mochi_repr(perplexity_loss(Y_true_perp, Y_pred_perp, 0.0000001))]),
        Y_true_smooth = [3.0, 5.0, 2.0, 7.0],
        Y_pred_smooth = [2.9, 4.8, 2.1, 7.2],
        io:format("~ts~n", [mochi_repr(smooth_l1_loss(Y_true_smooth, Y_pred_smooth, 1.0))]),
        Y_true_kl = [0.2, 0.3, 0.5],
        Y_pred_kl = [0.3, 0.3, 0.4],
        io:format("~ts~n", [mochi_repr(kullback_leibler_divergence(Y_true_kl, Y_pred_kl))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
