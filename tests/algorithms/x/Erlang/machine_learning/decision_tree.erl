#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, mod/2, sin/1, rand/0, mean/1, mean_squared_error/2, train_tree/4, predict/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (ec7cf2f058) on 2025-08-07 14:07 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

mod(X, M) ->
    try
        (X - mochi_safe_mul(float(mochi_to_int(mochi_safe_div(X, M))), M))
    catch {return, Ret} -> Ret end.

sin(X_2) ->
    try
        Y = (mod((X_2 + 3.141592653589793), 6.283185307179586) - 3.141592653589793),
        Y2 = mochi_safe_mul(Y, Y),
        Y3 = mochi_safe_mul(Y2, Y),
        Y5 = mochi_safe_mul(Y3, Y2),
        Y7 = mochi_safe_mul(Y5, Y2),
        (((Y - mochi_safe_div(Y3, 6.0)) + mochi_safe_div(Y5, 120.0)) - mochi_safe_div(Y7, 5040.0))
    catch {return, Ret} -> Ret end.

rand() ->
    try
        erlang:put('seed', mochi_mod(((1103515245 * erlang:get('seed')) + 12345), 2147483648)),
        mochi_safe_div(float(erlang:get('seed')), 2147483648.0)
    catch {return, Ret} -> Ret end.

mean(Vals) ->
    try
        Sum = 0.0,
        I = 0,
        Fun = fun Fun_loop(I, Sum, Vals) ->
    case (I < erlang:length(Vals)) of
        true ->
            Sum_2 = (Sum + (case erlang:is_map(Vals) of true -> maps:get(I, Vals, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Vals) + I + 1, Vals); _ -> mochi_nth(I + 1, Vals) end end)),
            I_2 = (I + 1),
            Fun_loop(I_2, Sum_2, Vals);
        _ -> {I, Sum, Vals}
    end
end,
{I_2, Sum_2, Vals} = Fun(I, Sum, Vals),
        mochi_safe_div(Sum_2, erlang:length(Vals))
    catch {return, Ret} -> Ret end.

mean_squared_error(Labels, Prediction) ->
    try
        Total = 0.0,
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Labels, Prediction, Total) ->
    case (I_3 < erlang:length(Labels)) of
        true ->
            Diff = ((case erlang:is_map(Labels) of true -> maps:get(I_3, Labels, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Labels) + I_3 + 1, Labels); _ -> mochi_nth(I_3 + 1, Labels) end end) - Prediction),
            Total_2 = (Total + mochi_safe_mul(Diff, Diff)),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Labels, Prediction, Total_2);
        _ -> {I_3, Labels, Prediction, Total}
    end
end,
{I_4, Labels, Prediction, Total_2} = Fun_2(I_3, Labels, Prediction, Total),
        mochi_safe_div(Total_2, erlang:length(Labels))
    catch {return, Ret} -> Ret end.

train_tree(X_3, Y_2, Depth, Min_leaf_size) ->
    try
        case (erlang:length(X_3) < (2 * Min_leaf_size)) of
        true -> throw({return, #{"tag" => "leaf", "prediction" => mean(Y_2)}});
        _ -> ok
    end,
        case (Depth == 1) of
        true -> throw({return, #{"tag" => "leaf", "prediction" => mean(Y_2)}});
        _ -> ok
    end,
        Best_split = 0,
        Min_error = mochi_safe_mul(mean_squared_error(X_3, mean(Y_2)), 2.0),
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Best_split, Depth, I_5, Min_error, Min_leaf_size, X_3, Y_2) ->
    case (I_5 < erlang:length(X_3)) of
        true ->
            case (erlang:length(lists:sublist(X_3, 0 + 1, (I_5 - 0))) < Min_leaf_size) of
        true -> I_6 = I_5,
            Best_split_5 = Best_split,
            Err_3 = nil,
            Err_left_3 = nil,
            Err_right_3 = nil,
            I_9 = I_6,
            Min_error_5 = Min_error;
        _ -> case (erlang:length(lists:sublist(X_3, I_5 + 1, length(X_3) - I_5)) < Min_leaf_size) of
        true -> I_7 = I_5,
            Best_split_4 = Best_split,
            Err_2 = nil,
            Err_left_2 = nil,
            Err_right_2 = nil,
            I_8 = I_7,
            Min_error_4 = Min_error;
        _ -> Err_left = mean_squared_error(lists:sublist(X_3, 0 + 1, (I_5 - 0)), mean(lists:sublist(Y_2, 0 + 1, (I_5 - 0)))),
            Err_right = mean_squared_error(lists:sublist(X_3, I_5 + 1, length(X_3) - I_5), mean(lists:sublist(Y_2, I_5 + 1, length(Y_2) - I_5))),
            Err = (Err_left + Err_right),
            case (Err < Min_error) of
        true -> Best_split_2 = I_5,
            Min_error_2 = Err,
            Best_split_3 = Best_split_2,
            Min_error_3 = Min_error_2;
        _ -> Best_split_3 = Best_split,
            Min_error_3 = Min_error
    end,
            Best_split_4 = Best_split_3,
            Err_2 = Err,
            Err_left_2 = Err_left,
            Err_right_2 = Err_right,
            I_8 = I_5,
            Min_error_4 = Min_error_3
    end,
            Best_split_5 = Best_split_4,
            Err_3 = Err_2,
            Err_left_3 = Err_left_2,
            Err_right_3 = Err_right_2,
            I_9 = I_8,
            Min_error_5 = Min_error_4
    end,
            I_10 = (I_9 + 1),
            Fun_3_loop(Best_split_5, Depth, I_10, Min_error_5, Min_leaf_size, X_3, Y_2);
        _ -> {Best_split, Depth, I_5, Min_error, Min_leaf_size, X_3, Y_2}
    end
end,
{Best_split_5, Depth, I_10, Min_error_5, Min_leaf_size, X_3, Y_2} = Fun_3(Best_split, Depth, I_5, Min_error, Min_leaf_size, X_3, Y_2),
        case (Best_split_5 /= 0) of
        true -> Left_x = lists:sublist(X_3, 0 + 1, (Best_split_5 - 0)),
            Left_y = lists:sublist(Y_2, 0 + 1, (Best_split_5 - 0)),
            Right_x = lists:sublist(X_3, Best_split_5 + 1, length(X_3) - Best_split_5),
            Right_y = lists:sublist(Y_2, Best_split_5 + 1, length(Y_2) - Best_split_5),
            Boundary = (case erlang:is_map(X_3) of true -> maps:get(Best_split_5, X_3, nil); _ -> case Best_split_5 < 0 of true -> mochi_nth(erlang:length(X_3) + Best_split_5 + 1, X_3); _ -> mochi_nth(Best_split_5 + 1, X_3) end end),
            Left_tree = train_tree(Left_x, Left_y, (Depth - 1), Min_leaf_size),
            Right_tree = train_tree(Right_x, Right_y, (Depth - 1), Min_leaf_size),
            throw({return, #{"tag" => "branch", "decision_boundary" => Boundary, "left" => Left_tree, "right" => Right_tree}}),
            Boundary_2 = Boundary,
            Left_tree_2 = Left_tree,
            Left_x_2 = Left_x,
            Left_y_2 = Left_y,
            Right_tree_2 = Right_tree,
            Right_x_2 = Right_x,
            Right_y_2 = Right_y;
        _ -> Boundary_2 = nil,
            Left_tree_2 = nil,
            Left_x_2 = nil,
            Left_y_2 = nil,
            Right_tree_2 = nil,
            Right_x_2 = nil,
            Right_y_2 = nil
    end,
        #{"tag" => "leaf", "prediction" => mean(Y_2)}
    catch {return, Ret} -> Ret end.

predict(Tree, Value) ->
    try
        (case Tree of
    #{"tag" := "leaf", "prediction" := P} -> P;
    #{"tag" := "branch", "decision_boundary" := B, "left" := L, "right" := R} -> (case (Value >= B) of
    true -> predict(R, Value);
    _ -> predict(L, Value)
end)
end)
    catch {return, Ret} -> Ret end.

main() ->
    try
        X_4 = [],
        V = -1.0,
        Fun_4 = fun Fun_4_loop(V, X_4) ->
    case (V < 1.0) of
        true ->
            X_5 = lists:append((case X_4 of nil -> []; _ -> X_4 end), [V]),
            V_2 = (V + 0.005),
            Fun_4_loop(V_2, X_5);
        _ -> {V, X_4}
    end
end,
{V_2, X_5} = Fun_4(V, X_4),
        Y_3 = [],
        I_11 = 0,
        Fun_5 = fun Fun_5_loop(I_11, V_2, X_5, Y_3) ->
    case (I_11 < erlang:length(X_5)) of
        true ->
            Y_4 = lists:append((case Y_3 of nil -> []; _ -> Y_3 end), [sin((case erlang:is_map(X_5) of true -> maps:get(I_11, X_5, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(X_5) + I_11 + 1, X_5); _ -> mochi_nth(I_11 + 1, X_5) end end))]),
            I_12 = (I_11 + 1),
            Fun_5_loop(I_12, V_2, X_5, Y_4);
        _ -> {I_11, V_2, X_5, Y_3}
    end
end,
{I_12, V_2, X_5, Y_4} = Fun_5(I_11, V_2, X_5, Y_3),
        Tree_2 = train_tree(X_5, Y_4, 10, 10),
        Test_cases = [],
        I_13 = 0,
        Fun_6 = fun Fun_6_loop(I_13, Test_cases, Tree_2, V_2, X_5, Y_4) ->
    case (I_13 < 10) of
        true ->
            Test_cases_2 = lists:append((case Test_cases of nil -> []; _ -> Test_cases end), [(mochi_safe_mul(rand(), 2.0) - 1.0)]),
            I_14 = (I_13 + 1),
            Fun_6_loop(I_14, Test_cases_2, Tree_2, V_2, X_5, Y_4);
        _ -> {I_13, Test_cases, Tree_2, V_2, X_5, Y_4}
    end
end,
{I_14, Test_cases_2, Tree_2, V_2, X_5, Y_4} = Fun_6(I_13, Test_cases, Tree_2, V_2, X_5, Y_4),
        Predictions = [],
        I_15 = 0,
        Fun_7 = fun Fun_7_loop(I_15, Predictions, Test_cases_2, Tree_2, V_2, X_5, Y_4) ->
    case (I_15 < erlang:length(Test_cases_2)) of
        true ->
            Predictions_2 = lists:append((case Predictions of nil -> []; _ -> Predictions end), [predict(Tree_2, (case erlang:is_map(Test_cases_2) of true -> maps:get(I_15, Test_cases_2, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Test_cases_2) + I_15 + 1, Test_cases_2); _ -> mochi_nth(I_15 + 1, Test_cases_2) end end))]),
            I_16 = (I_15 + 1),
            Fun_7_loop(I_16, Predictions_2, Test_cases_2, Tree_2, V_2, X_5, Y_4);
        _ -> {I_15, Predictions, Test_cases_2, Tree_2, V_2, X_5, Y_4}
    end
end,
{I_16, Predictions_2, Test_cases_2, Tree_2, V_2, X_5, Y_4} = Fun_7(I_15, Predictions, Test_cases_2, Tree_2, V_2, X_5, Y_4),
        Sum_err = 0.0,
        I_17 = 0,
        Fun_8 = fun Fun_8_loop(I_17, Predictions_2, Sum_err, Test_cases_2, Tree_2, V_2, X_5, Y_4) ->
    case (I_17 < erlang:length(Test_cases_2)) of
        true ->
            Diff_2 = ((case erlang:is_map(Predictions_2) of true -> maps:get(I_17, Predictions_2, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Predictions_2) + I_17 + 1, Predictions_2); _ -> mochi_nth(I_17 + 1, Predictions_2) end end) - (case erlang:is_map(Test_cases_2) of true -> maps:get(I_17, Test_cases_2, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Test_cases_2) + I_17 + 1, Test_cases_2); _ -> mochi_nth(I_17 + 1, Test_cases_2) end end)),
            Sum_err_2 = (Sum_err + mochi_safe_mul(Diff_2, Diff_2)),
            I_18 = (I_17 + 1),
            Fun_8_loop(I_18, Predictions_2, Sum_err_2, Test_cases_2, Tree_2, V_2, X_5, Y_4);
        _ -> {I_17, Predictions_2, Sum_err, Test_cases_2, Tree_2, V_2, X_5, Y_4}
    end
end,
{I_18, Predictions_2, Sum_err_2, Test_cases_2, Tree_2, V_2, X_5, Y_4} = Fun_8(I_17, Predictions_2, Sum_err, Test_cases_2, Tree_2, V_2, X_5, Y_4),
        Avg_error = mochi_safe_div(Sum_err_2, erlang:length(Test_cases_2)),
        io:format("~ts~n", [mochi_repr(("Test values: " ++ mochi_str(Test_cases_2)))]),
        io:format("~ts~n", [mochi_repr(("Predictions: " ++ mochi_str(Predictions_2)))]),
        io:format("~ts~n", [mochi_repr(("Average error: " ++ mochi_str(Avg_error)))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    erlang:put('TWO_PI', 6.283185307179586),
    erlang:put('seed', 123456789),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
