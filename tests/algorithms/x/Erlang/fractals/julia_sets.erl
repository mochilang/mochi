#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, complex_add/2, complex_mul/2, sqrtapprox/1, complex_abs/1, sin_taylor/1, cos_taylor/1, exp_taylor/1, complex_exp/1, eval_quadratic/2, eval_exponential/2, iterate_function/5, prepare_grid/2, julia_demo/0]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

complex_add(A, B) ->
    try
        #{"re" => (maps:get("re", A, nil) + maps:get("re", B, nil)), "im" => (maps:get("im", A, nil) + maps:get("im", B, nil))}
    catch {return, Ret} -> Ret end.

complex_mul(A_2, B_2) ->
    try
        Real = (mochi_safe_mul(maps:get("re", A_2, nil), maps:get("re", B_2, nil)) - mochi_safe_mul(maps:get("im", A_2, nil), maps:get("im", B_2, nil))),
        Imag = (mochi_safe_mul(maps:get("re", A_2, nil), maps:get("im", B_2, nil)) + mochi_safe_mul(maps:get("im", A_2, nil), maps:get("re", B_2, nil))),
        #{"re" => Real, "im" => Imag}
    catch {return, Ret} -> Ret end.

sqrtapprox(X) ->
    try
        Guess = mochi_safe_div(X, 2),
        I = 0,
        Fun = fun Fun_loop(Guess, I, X) ->
    case (I < 20) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X, Guess)), 2),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X);
        _ -> {Guess, I, X}
    end
end,
{Guess_2, I_2, X} = Fun(Guess, I, X),
        Guess_2
    catch {return, Ret} -> Ret end.

complex_abs(A_3) ->
    try
        sqrtapprox((mochi_safe_mul(maps:get("re", A_3, nil), maps:get("re", A_3, nil)) + mochi_safe_mul(maps:get("im", A_3, nil), maps:get("im", A_3, nil))))
    catch {return, Ret} -> Ret end.

sin_taylor(X_2) ->
    try
        Term = X_2,
        Sum = X_2,
        I_3 = 1,
        Fun_2 = fun Fun_2_loop(I_3, Sum, Term, X_2) ->
    case (I_3 < 10) of
        true ->
            K1 = mochi_safe_mul(2, float(I_3)),
            K2 = (mochi_safe_mul(2, float(I_3)) + 1),
            Term_2 = mochi_safe_div(mochi_safe_mul(mochi_safe_mul(-Term, X_2), X_2), mochi_safe_mul(K1, K2)),
            Sum_2 = (Sum + Term_2),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Sum_2, Term_2, X_2);
        _ -> {I_3, Sum, Term, X_2}
    end
end,
{I_4, Sum_2, Term_2, X_2} = Fun_2(I_3, Sum, Term, X_2),
        Sum_2
    catch {return, Ret} -> Ret end.

cos_taylor(X_3) ->
    try
        Term_3 = 1,
        Sum_3 = 1,
        I_5 = 1,
        Fun_3 = fun Fun_3_loop(I_5, Sum_3, Term_3, X_3) ->
    case (I_5 < 10) of
        true ->
            K1_2 = (mochi_safe_mul(2, float(I_5)) - 1),
            K2_2 = mochi_safe_mul(2, float(I_5)),
            Term_4 = mochi_safe_div(mochi_safe_mul(mochi_safe_mul(-Term_3, X_3), X_3), mochi_safe_mul(K1_2, K2_2)),
            Sum_4 = (Sum_3 + Term_4),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Sum_4, Term_4, X_3);
        _ -> {I_5, Sum_3, Term_3, X_3}
    end
end,
{I_6, Sum_4, Term_4, X_3} = Fun_3(I_5, Sum_3, Term_3, X_3),
        Sum_4
    catch {return, Ret} -> Ret end.

exp_taylor(X_4) ->
    try
        Term_5 = 1,
        Sum_5 = 1,
        I_7 = 1,
        Fun_4 = fun Fun_4_loop(I_7, Sum_5, Term_5, X_4) ->
    case (I_7 < 20) of
        true ->
            Term_6 = mochi_safe_div(mochi_safe_mul(Term_5, X_4), I_7),
            Sum_6 = (Sum_5 + Term_6),
            I_8 = (I_7 + 1),
            Fun_4_loop(I_8, Sum_6, Term_6, X_4);
        _ -> {I_7, Sum_5, Term_5, X_4}
    end
end,
{I_8, Sum_6, Term_6, X_4} = Fun_4(I_7, Sum_5, Term_5, X_4),
        Sum_6
    catch {return, Ret} -> Ret end.

complex_exp(Z) ->
    try
        E = exp_taylor(maps:get("re", Z, nil)),
        #{"re" => mochi_safe_mul(E, cos_taylor(maps:get("im", Z, nil))), "im" => mochi_safe_mul(E, sin_taylor(maps:get("im", Z, nil)))}
    catch {return, Ret} -> Ret end.

eval_quadratic(C, Z_2) ->
    try
        complex_add(complex_mul(Z_2, Z_2), C)
    catch {return, Ret} -> Ret end.

eval_exponential(C_2, Z_3) ->
    try
        complex_add(complex_exp(Z_3), C_2)
    catch {return, Ret} -> Ret end.

iterate_function(Eval_function, C_3, Nb_iterations, Z0, Infinity) ->
    try
        Z_n = Z0,
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(C_3, Eval_function, I_9, Infinity, Nb_iterations, Z0, Z_n) ->
    case (I_9 < Nb_iterations) of
        true ->
            Z_n_2 = Eval_function(C_3, Z_n),
            case (complex_abs(Z_n_2) > Infinity) of
        true -> throw({return, Z_n_2});
        _ -> ok
    end,
            I_10 = (I_9 + 1),
            Fun_5_loop(C_3, Eval_function, I_10, Infinity, Nb_iterations, Z0, Z_n_2);
        _ -> {C_3, Eval_function, I_9, Infinity, Nb_iterations, Z0, Z_n}
    end
end,
{C_3, Eval_function, I_10, Infinity, Nb_iterations, Z0, Z_n_2} = Fun_5(C_3, Eval_function, I_9, Infinity, Nb_iterations, Z0, Z_n),
        Z_n_2
    catch {return, Ret} -> Ret end.

prepare_grid(Window_size, Nb_pixels) ->
    try
        Grid = [],
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(Grid, I_11, Nb_pixels, Window_size) ->
    case (I_11 < Nb_pixels) of
        true ->
            Row = [],
            J = 0,
            Fun_6 = fun Fun_6_loop(Grid, I_11, J, Nb_pixels, Row, Window_size) ->
    case (J < Nb_pixels) of
        true ->
            Real_2 = (-Window_size + mochi_safe_div(mochi_safe_mul(mochi_safe_mul(2, Window_size), float(I_11)), float((Nb_pixels - 1)))),
            Imag_2 = (-Window_size + mochi_safe_div(mochi_safe_mul(mochi_safe_mul(2, Window_size), float(J)), float((Nb_pixels - 1)))),
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [#{"re" => Real_2, "im" => Imag_2}]),
            J_2 = (J + 1),
            Fun_6_loop(Grid, I_11, J_2, Nb_pixels, Row_2, Window_size);
        _ -> {Grid, I_11, J, Nb_pixels, Row, Window_size}
    end
end,
{Grid, I_11, J_2, Nb_pixels, Row_2, Window_size} = Fun_6(Grid, I_11, J, Nb_pixels, Row, Window_size),
            Grid_2 = lists:append((case Grid of nil -> []; _ -> Grid end), [Row_2]),
            I_12 = (I_11 + 1),
            Fun_7_loop(Grid_2, I_12, Nb_pixels, Window_size);
        _ -> {Grid, I_11, Nb_pixels, Window_size}
    end
end,
{Grid_2, I_12, Nb_pixels, Window_size} = Fun_7(Grid, I_11, Nb_pixels, Window_size),
        Grid_2
    catch {return, Ret} -> Ret end.

julia_demo() ->
    try
        Grid_3 = prepare_grid(1, 5),
        C_poly = #{"re" => -0.4, "im" => 0.6},
        C_exp = #{"re" => -2, "im" => 0},
        Poly_result = [],
        Exp_result = [],
        Y = 0,
        Fun_9 = fun Fun_9_loop(C_exp, C_poly, Exp_result, Grid_3, Poly_result, Y) ->
    case (Y < erlang:length(Grid_3)) of
        true ->
            Row_poly = [],
            Row_exp = [],
            X_5 = 0,
            Fun_8 = fun Fun_8_loop(C_exp, C_poly, Exp_result, Grid_3, Poly_result, Row_exp, Row_poly, X_5, Y) ->
    case (X_5 < erlang:length((case erlang:is_map(Grid_3) of true -> maps:get(Y, Grid_3, nil); _ -> case Y < 0 of true -> lists:nth(erlang:length(Grid_3) + Y + 1, Grid_3); _ -> lists:nth(Y + 1, Grid_3) end end))) of
        true ->
            Z0_2 = (case erlang:is_map((case erlang:is_map(Grid_3) of true -> maps:get(Y, Grid_3, nil); _ -> case Y < 0 of true -> lists:nth(erlang:length(Grid_3) + Y + 1, Grid_3); _ -> lists:nth(Y + 1, Grid_3) end end)) of true -> maps:get(X_5, (case erlang:is_map(Grid_3) of true -> maps:get(Y, Grid_3, nil); _ -> case Y < 0 of true -> lists:nth(erlang:length(Grid_3) + Y + 1, Grid_3); _ -> lists:nth(Y + 1, Grid_3) end end), nil); _ -> case X_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Grid_3) of true -> maps:get(Y, Grid_3, nil); _ -> case Y < 0 of true -> lists:nth(erlang:length(Grid_3) + Y + 1, Grid_3); _ -> lists:nth(Y + 1, Grid_3) end end)) + X_5 + 1, (case erlang:is_map(Grid_3) of true -> maps:get(Y, Grid_3, nil); _ -> case Y < 0 of true -> lists:nth(erlang:length(Grid_3) + Y + 1, Grid_3); _ -> lists:nth(Y + 1, Grid_3) end end)); _ -> lists:nth(X_5 + 1, (case erlang:is_map(Grid_3) of true -> maps:get(Y, Grid_3, nil); _ -> case Y < 0 of true -> lists:nth(erlang:length(Grid_3) + Y + 1, Grid_3); _ -> lists:nth(Y + 1, Grid_3) end end)) end end),
            Z_poly = iterate_function(fun eval_quadratic/2, C_poly, 20, Z0_2, 4),
            Z_exp = iterate_function(fun eval_exponential/2, C_exp, 10, Z0_2, 1.0e+10),
            Row_poly_2 = lists:append((case Row_poly of nil -> []; _ -> Row_poly end), [(case (complex_abs(Z_poly) < 2) of
    true -> 1;
    _ -> 0
end)]),
            Row_exp_2 = lists:append((case Row_exp of nil -> []; _ -> Row_exp end), [(case (complex_abs(Z_exp) < 10000) of
    true -> 1;
    _ -> 0
end)]),
            X_6 = (X_5 + 1),
            Fun_8_loop(C_exp, C_poly, Exp_result, Grid_3, Poly_result, Row_exp_2, Row_poly_2, X_6, Y);
        _ -> {C_exp, C_poly, Exp_result, Grid_3, Poly_result, Row_exp, Row_poly, X_5, Y}
    end
end,
{C_exp, C_poly, Exp_result, Grid_3, Poly_result, Row_exp_2, Row_poly_2, X_6, Y} = Fun_8(C_exp, C_poly, Exp_result, Grid_3, Poly_result, Row_exp, Row_poly, X_5, Y),
            Poly_result_2 = lists:append((case Poly_result of nil -> []; _ -> Poly_result end), [Row_poly_2]),
            Exp_result_2 = lists:append((case Exp_result of nil -> []; _ -> Exp_result end), [Row_exp_2]),
            Y_2 = (Y + 1),
            Fun_9_loop(C_exp, C_poly, Exp_result_2, Grid_3, Poly_result_2, Y_2);
        _ -> {C_exp, C_poly, Exp_result, Grid_3, Poly_result, Y}
    end
end,
{C_exp, C_poly, Exp_result_2, Grid_3, Poly_result_2, Y_2} = Fun_9(C_exp, C_poly, Exp_result, Grid_3, Poly_result, Y),
        io:format("~ts~n", [mochi_repr(Poly_result_2)]),
        io:format("~ts~n", [mochi_repr(Exp_result_2)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    julia_demo(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
