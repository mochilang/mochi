#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, is_valid/5, place_word/5, remove_word/5, solve_crossword/3]).

% Generated by Mochi transpiler v0.10.59 (4cd36c2212) on 2025-08-06 20:43 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = string:replace(S, ",", " ", all),
    string:replace(S1, "\"", "", all).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    string:replace(S, ",", ", ", all).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

is_valid(Puzzle, Word, Row, Col, Vertical) ->
    try
        Fun = fun Fun_loop(List, Col, Puzzle, Row, Vertical, Word) ->
    case List of
        [] -> {Col, Puzzle, Row, Vertical, Word};
        [I|I_rest] ->
            case Vertical of
        true -> case (((Row + I) >= length(Puzzle)) orelse ((case erlang:is_map((case erlang:is_map(Puzzle) of true -> maps:get((Row + I), Puzzle, nil); _ -> lists:nth((Row + I) + 1, Puzzle) end)) of true -> maps:get(Col, (case erlang:is_map(Puzzle) of true -> maps:get((Row + I), Puzzle, nil); _ -> lists:nth((Row + I) + 1, Puzzle) end), nil); _ -> lists:nth(Col + 1, (case erlang:is_map(Puzzle) of true -> maps:get((Row + I), Puzzle, nil); _ -> lists:nth((Row + I) + 1, Puzzle) end)) end) /= "")) of
        true -> throw({return, false});
        _ -> ok
    end;
        _ -> case (((Col + I) >= length((case erlang:is_map(Puzzle) of true -> maps:get(0, Puzzle, nil); _ -> lists:nth(0 + 1, Puzzle) end))) orelse ((case erlang:is_map((case erlang:is_map(Puzzle) of true -> maps:get(Row, Puzzle, nil); _ -> lists:nth(Row + 1, Puzzle) end)) of true -> maps:get((Col + I), (case erlang:is_map(Puzzle) of true -> maps:get(Row, Puzzle, nil); _ -> lists:nth(Row + 1, Puzzle) end), nil); _ -> lists:nth((Col + I) + 1, (case erlang:is_map(Puzzle) of true -> maps:get(Row, Puzzle, nil); _ -> lists:nth(Row + 1, Puzzle) end)) end) /= "")) of
        true -> throw({return, false});
        _ -> ok
    end
    end,
            Fun_loop(I_rest, Col, Puzzle, Row, Vertical, Word);
        _ -> {Col, Puzzle, Row, Vertical, Word}
    end
end,
{Col, Puzzle, Row, Vertical, Word} = Fun(lists:seq(0, (length(Word)) - 1), Col, Puzzle, Row, Vertical, Word),
        true
    catch {return, Ret} -> Ret end.

place_word(Puzzle_2, Word_2, Row_2, Col_2, Vertical_2) ->
    try
        Fun_2 = fun Fun_2_loop(List, Col_2, Puzzle_2, Row_2, Vertical_2, Word_2) ->
    case List of
        [] -> {Col_2, Puzzle_2, Row_2, Vertical_2, Word_2};
        [I_2|I_2_rest] ->
            Ch = string:substr(Word_2, I_2 + 1, 1),
            case Vertical_2 of
        true -> Tmp = (case erlang:is_map(Puzzle_2) of true -> maps:get((Row_2 + I_2), Puzzle_2, nil); _ -> lists:nth((Row_2 + I_2) + 1, Puzzle_2) end),
            Tmp_2 = lists:sublist(Tmp, Col_2) ++ [Ch] ++ lists:nthtail(Col_2 + 1, Tmp),
            Puzzle_3 = lists:sublist(Puzzle_2, (Row_2 + I_2)) ++ [Tmp_2] ++ lists:nthtail((Row_2 + I_2) + 1, Puzzle_2),
            Puzzle_5 = Puzzle_3,
            Tmp_5 = Tmp_2;
        _ -> Tmp_3 = (case erlang:is_map(Puzzle_2) of true -> maps:get(Row_2, Puzzle_2, nil); _ -> lists:nth(Row_2 + 1, Puzzle_2) end),
            Tmp_4 = lists:sublist(Tmp_3, (Col_2 + I_2)) ++ [Ch] ++ lists:nthtail((Col_2 + I_2) + 1, Tmp_3),
            Puzzle_4 = lists:sublist(Puzzle_2, Row_2) ++ [Tmp_4] ++ lists:nthtail(Row_2 + 1, Puzzle_2),
            Puzzle_5 = Puzzle_4,
            Tmp_5 = Tmp_4
    end,
            Fun_2_loop(I_2_rest, Col_2, Puzzle_5, Row_2, Vertical_2, Word_2);
        _ -> {Col_2, Puzzle_2, Row_2, Vertical_2, Word_2}
    end
end,
{Col_2, Puzzle_5, Row_2, Vertical_2, Word_2} = Fun_2(lists:seq(0, (length(Word_2)) - 1), Col_2, Puzzle_2, Row_2, Vertical_2, Word_2),
        nil
    catch {return, Ret} -> Ret end.

remove_word(Puzzle_6, Word_3, Row_3, Col_3, Vertical_3) ->
    try
        Fun_3 = fun Fun_3_loop(List, Col_3, Puzzle_6, Row_3, Vertical_3, Word_3) ->
    case List of
        [] -> {Col_3, Puzzle_6, Row_3, Vertical_3, Word_3};
        [I_3|I_3_rest] ->
            case Vertical_3 of
        true -> Tmp_6 = (case erlang:is_map(Puzzle_6) of true -> maps:get((Row_3 + I_3), Puzzle_6, nil); _ -> lists:nth((Row_3 + I_3) + 1, Puzzle_6) end),
            Tmp_7 = lists:sublist(Tmp_6, Col_3) ++ [""] ++ lists:nthtail(Col_3 + 1, Tmp_6),
            Puzzle_7 = lists:sublist(Puzzle_6, (Row_3 + I_3)) ++ [Tmp_7] ++ lists:nthtail((Row_3 + I_3) + 1, Puzzle_6),
            Puzzle_9 = Puzzle_7,
            Tmp_10 = Tmp_7;
        _ -> Tmp_8 = (case erlang:is_map(Puzzle_6) of true -> maps:get(Row_3, Puzzle_6, nil); _ -> lists:nth(Row_3 + 1, Puzzle_6) end),
            Tmp_9 = lists:sublist(Tmp_8, (Col_3 + I_3)) ++ [""] ++ lists:nthtail((Col_3 + I_3) + 1, Tmp_8),
            Puzzle_8 = lists:sublist(Puzzle_6, Row_3) ++ [Tmp_9] ++ lists:nthtail(Row_3 + 1, Puzzle_6),
            Puzzle_9 = Puzzle_8,
            Tmp_10 = Tmp_9
    end,
            Fun_3_loop(I_3_rest, Col_3, Puzzle_9, Row_3, Vertical_3, Word_3);
        _ -> {Col_3, Puzzle_6, Row_3, Vertical_3, Word_3}
    end
end,
{Col_3, Puzzle_9, Row_3, Vertical_3, Word_3} = Fun_3(lists:seq(0, (length(Word_3)) - 1), Col_3, Puzzle_6, Row_3, Vertical_3, Word_3),
        nil
    catch {return, Ret} -> Ret end.

solve_crossword(Puzzle_10, Words, Used) ->
    try
        Fun_4 = fun Fun_4_loop(List, Puzzle_10, Used, Words) ->
    case List of
        [] -> {Puzzle_10, Used, Words};
        [Row_4|Row_4_rest] ->
            Fun_5 = fun Fun_5_loop(List, Puzzle_10, Row_4, Used, Words) ->
    case List of
        [] -> {Puzzle_10, Row_4, Used, Words};
        [Col_4|Col_4_rest] ->
            case ((case erlang:is_map((case erlang:is_map(Puzzle_10) of true -> maps:get(Row_4, Puzzle_10, nil); _ -> lists:nth(Row_4 + 1, Puzzle_10) end)) of true -> maps:get(Col_4, (case erlang:is_map(Puzzle_10) of true -> maps:get(Row_4, Puzzle_10, nil); _ -> lists:nth(Row_4 + 1, Puzzle_10) end), nil); _ -> lists:nth(Col_4 + 1, (case erlang:is_map(Puzzle_10) of true -> maps:get(Row_4, Puzzle_10, nil); _ -> lists:nth(Row_4 + 1, Puzzle_10) end)) end) == "") of
        true -> Fun_6 = fun Fun_6_loop(List, Col_4, Puzzle_10, Row_4, Used, Words) ->
    case List of
        [] -> {Col_4, Puzzle_10, Row_4, Used, Words};
        [I_4|I_4_rest] ->
            case mochi_not((case erlang:is_map(Used) of true -> maps:get(I_4, Used, nil); _ -> lists:nth(I_4 + 1, Used) end)) of
        true -> Word_4 = (case erlang:is_map(Words) of true -> maps:get(I_4, Words, nil); _ -> lists:nth(I_4 + 1, Words) end),
            Fun_7 = fun Fun_7_loop(List, Col_4, I_4, Puzzle_10, Row_4, Used, Word_4, Words) ->
    case List of
        [] -> {Col_4, I_4, Puzzle_10, Row_4, Used, Word_4, Words};
        [Vertical_4|Vertical_4_rest] ->
            case is_valid(Puzzle_10, Word_4, Row_4, Col_4, Vertical_4) of
        true -> place_word(Puzzle_10, Word_4, Row_4, Col_4, Vertical_4),
            Used_2 = lists:sublist(Used, I_4) ++ [true] ++ lists:nthtail(I_4 + 1, Used),
            case solve_crossword(Puzzle_10, Words, Used_2) of
        true -> throw({return, true});
        _ -> ok
    end,
            Used_3 = lists:sublist(Used_2, I_4) ++ [false] ++ lists:nthtail(I_4 + 1, Used_2),
            remove_word(Puzzle_10, Word_4, Row_4, Col_4, Vertical_4),
            Used_4 = Used_3;
        _ -> Used_4 = Used
    end,
            Fun_7_loop(Vertical_4_rest, Col_4, I_4, Puzzle_10, Row_4, Used_4, Word_4, Words);
        _ -> {Col_4, I_4, Puzzle_10, Row_4, Used, Word_4, Words}
    end
end,
{Col_4, I_4, Puzzle_10, Row_4, Used_4, Word_4, Words} = Fun_7([true, false], Col_4, I_4, Puzzle_10, Row_4, Used, Word_4, Words),
            Fun_8 = Fun_7,
            Used_5 = Used_4,
            Word_5 = Word_4;
        _ -> Fun_8 = nil,
            Used_5 = Used,
            Word_5 = nil
    end,
            Fun_6_loop(I_4_rest, Col_4, Puzzle_10, Row_4, Used_5, Words);
        _ -> {Col_4, Puzzle_10, Row_4, Used, Words}
    end
end,
{Col_4, Puzzle_10, Row_4, Used_5, Words} = Fun_6(lists:seq(0, (length(Words)) - 1), Col_4, Puzzle_10, Row_4, Used, Words),
            throw({return, false}),
            Fun_9 = Fun_6,
            Used_6 = Used_5;
        _ -> Fun_9 = nil,
            Used_6 = Used
    end,
            Fun_5_loop(Col_4_rest, Puzzle_10, Row_4, Used_6, Words);
        _ -> {Puzzle_10, Row_4, Used, Words}
    end
end,
{Puzzle_10, Row_4, Used_6, Words} = Fun_5(lists:seq(0, (length((case erlang:is_map(Puzzle_10) of true -> maps:get(0, Puzzle_10, nil); _ -> lists:nth(0 + 1, Puzzle_10) end))) - 1), Puzzle_10, Row_4, Used, Words),
            Fun_4_loop(Row_4_rest, Puzzle_10, Used_6, Words);
        _ -> {Puzzle_10, Used, Words}
    end
end,
{Puzzle_10, Used_6, Words} = Fun_4(lists:seq(0, (length(Puzzle_10)) - 1), Puzzle_10, Used, Words),
        true
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('puzzle', [["", "", ""], ["", "", ""], ["", "", ""]]),
    erlang:put('words', ["cat", "dog", "car"]),
    erlang:put('used', [false, false, false]),
    case solve_crossword(erlang:get('puzzle'), erlang:get('words'), erlang:get('used')) of
        true -> io:format("~ts~n", [mochi_repr("Solution found:")]),
            Fun_10 = fun Fun_10_loop(List) ->
    case List of
        [] -> {};
        [Row_5|Row_5_rest] ->
            io:format("~ts~n", [mochi_repr(Row_5)]),
            Fun_10_loop(Row_5_rest);
        _ -> {}
    end
end,
{} = Fun_10(erlang:get('puzzle')),
            Fun_11 = Fun_10;
        _ -> io:format("~ts~n", [mochi_repr("No solution found:")]),
            Fun_11 = nil
    end,
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
