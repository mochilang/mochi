#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, contains/2, repeat/2, build_board/2, depth_first_search/4, n_queens_solution/1]).

% Generated by Mochi transpiler v0.10.59 (4cd36c2212) on 2025-08-06 20:43 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


mochi_repeat(S, N) when is_binary(S) ->
    binary:copy(S, mochi_to_int(N));
mochi_repeat(S, N) when is_list(S) ->
    string:copies(S, mochi_to_int(N));
mochi_repeat(_, _) -> [].


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = string:replace(S, ",", " ", all),
    string:replace(S1, "\"", "", all).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    string:replace(S, ",", ", ", all).

contains(Xs, X) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, X, Xs) ->
    case (I < length(Xs)) of
        true ->
            case ((case erlang:is_map(Xs) of true -> maps:get(I, Xs, nil); _ -> lists:nth(I + 1, Xs) end) == X) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, X, Xs);
        _ -> {I, X, Xs}
    end
end,
{I_2, X, Xs} = Fun(I, X, Xs),
        false
    catch {return, Ret} -> Ret end.

repeat(S, Times) ->
    try
        Result = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Result, S, Times) ->
    case (I_3 < Times) of
        true ->
            Result_2 = (Result ++ S),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Result_2, S, Times);
        _ -> {I_3, Result, S, Times}
    end
end,
{I_4, Result_2, S, Times} = Fun_2(I_3, Result, S, Times),
        Result_2
    catch {return, Ret} -> Ret end.

build_board(Pos, N) ->
    try
        Board = [],
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Board, I_5, N, Pos) ->
    case (I_5 < length(Pos)) of
        true ->
            Col = (case erlang:is_map(Pos) of true -> maps:get(I_5, Pos, nil); _ -> lists:nth(I_5 + 1, Pos) end),
            Line = ((mochi_repeat(". ", Col) ++ "Q ") ++ mochi_repeat(". ", ((N - 1) - Col))),
            Board_2 = lists:append(Board, [Line]),
            I_6 = (I_5 + 1),
            Fun_3_loop(Board_2, I_6, N, Pos);
        _ -> {Board, I_5, N, Pos}
    end
end,
{Board_2, I_6, N, Pos} = Fun_3(Board, I_5, N, Pos),
        Board_2
    catch {return, Ret} -> Ret end.

depth_first_search(Pos_2, Dr, Dl, N_2) ->
    try
        Row = length(Pos_2),
        case (Row == N_2) of
        true -> Single = [],
            Single_2 = lists:append(Single, [build_board(Pos_2, N_2)]),
            throw({return, Single_2}),
            Single_3 = Single_2;
        _ -> Single_3 = nil
    end,
        Boards = [],
        Col_2 = 0,
        Fun_4 = fun Fun_4_loop(Boards, Col_2, Dl, Dr, N_2, Pos_2, Row, Single_3) ->
    case (Col_2 < N_2) of
        true ->
            try
                case ((mochi_member(Col_2, Pos_2) orelse mochi_member((Row - Col_2), Dr)) orelse mochi_member((Row + Col_2), Dl)) of
        true -> Col_3 = (Col_2 + 1),
            throw({continue, Boards, Col_3, Dl, Dr, N_2, Pos_2, Row, Single_3}),
            Col_4 = Col_3;
        _ -> Col_4 = Col_2
    end,
                Result_3 = depth_first_search(lists:append(Pos_2, [Col_4]), lists:append(Dr, [(Row - Col_4)]), lists:append(Dl, [(Row + Col_4)]), N_2),
                Boards_2 = lists:append(Boards, Result_3),
                Col_5 = (Col_4 + 1),
                Fun_4_loop(Boards_2, Col_5, Dl, Dr, N_2, Pos_2, Row, Single_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_4_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                break -> {Boards, Col_2, Dl, Dr, N_2, Pos_2, Row, Single_3}
            end;
        _ -> {Boards, Col_2, Dl, Dr, N_2, Pos_2, Row, Single_3}
    end
end,
{Boards_2, Col_5, Dl, Dr, N_2, Pos_2, Row, Single_3} = Fun_4(Boards, Col_2, Dl, Dr, N_2, Pos_2, Row, Single_3),
        Boards_2
    catch {return, Ret} -> Ret end.

n_queens_solution(N_3) ->
    try
        Boards_3 = depth_first_search([], [], [], N_3),
        I_7 = 0,
        Fun_6 = fun Fun_6_loop(Boards_3, I_7, N_3) ->
    case (I_7 < length(Boards_3)) of
        true ->
            J = 0,
            Fun_5 = fun Fun_5_loop(Boards_3, I_7, J, N_3) ->
    case (J < length((case erlang:is_map(Boards_3) of true -> maps:get(I_7, Boards_3, nil); _ -> lists:nth(I_7 + 1, Boards_3) end))) of
        true ->
            io:format("~ts~n", [mochi_repr((case erlang:is_map((case erlang:is_map(Boards_3) of true -> maps:get(I_7, Boards_3, nil); _ -> lists:nth(I_7 + 1, Boards_3) end)) of true -> maps:get(J, (case erlang:is_map(Boards_3) of true -> maps:get(I_7, Boards_3, nil); _ -> lists:nth(I_7 + 1, Boards_3) end), nil); _ -> lists:nth(J + 1, (case erlang:is_map(Boards_3) of true -> maps:get(I_7, Boards_3, nil); _ -> lists:nth(I_7 + 1, Boards_3) end)) end))]),
            J_2 = (J + 1),
            Fun_5_loop(Boards_3, I_7, J_2, N_3);
        _ -> {Boards_3, I_7, J, N_3}
    end
end,
{Boards_3, I_7, J_2, N_3} = Fun_5(Boards_3, I_7, J, N_3),
            io:format("~ts~n", [mochi_repr("")]),
            I_8 = (I_7 + 1),
            Fun_6_loop(Boards_3, I_8, N_3);
        _ -> {Boards_3, I_7, N_3}
    end
end,
{Boards_3, I_8, N_3} = Fun_6(Boards_3, I_7, N_3),
        io:format("~ts ~ts~n", [mochi_repr(length(Boards_3)), mochi_repr("solutions were found.")]),
        length(Boards_3)
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    n_queens_solution(4),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
