#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, compare_string/2, contains_string/2, unique_strings/1, check/1, decimal_to_binary/2, is_for_table/3, count_ones/1, selection/2, count_char/2, prime_implicant_chart/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (f521f86a07) on 2025-08-06 21:30 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

compare_string(String1, String2) ->
    try
        Result = "",
        Count = 0,
        I = 0,
        Fun = fun Fun_loop(Count, I, Result, String1, String2) ->
    case (I < length(String1)) of
        true ->
            C1 = string:substr(String1, I + 1, ((I + 1) - I)),
            C2 = string:substr(String2, I + 1, ((I + 1) - I)),
            case (C1 /= C2) of
        true -> Count_2 = (Count + 1),
            Result_2 = (Result ++ "_"),
            Count_3 = Count_2,
            Result_4 = Result_2;
        _ -> Result_3 = (Result ++ C1),
            Count_3 = Count,
            Result_4 = Result_3
    end,
            I_2 = (I + 1),
            Fun_loop(Count_3, I_2, Result_4, String1, String2);
        _ -> {Count, I, Result, String1, String2}
    end
end,
{Count_3, I_2, Result_4, String1, String2} = Fun(Count, I, Result, String1, String2),
        case (Count_3 > 1) of
        true -> throw({return, ""});
        _ -> ok
    end,
        Result_4
    catch {return, Ret} -> Ret end.

contains_string(Arr, Value) ->
    try
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Arr, I_3, Value) ->
    case (I_3 < length(Arr)) of
        true ->
            case ((case erlang:is_map(Arr) of true -> maps:get(I_3, Arr, nil); _ -> lists:nth(I_3 + 1, Arr) end) == Value) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Arr, I_4, Value);
        _ -> {Arr, I_3, Value}
    end
end,
{Arr, I_4, Value} = Fun_2(Arr, I_3, Value),
        false
    catch {return, Ret} -> Ret end.

unique_strings(Arr_2) ->
    try
        Res = [],
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Arr_2, I_5, Res) ->
    case (I_5 < length(Arr_2)) of
        true ->
            case mochi_not(contains_string(Res, (case erlang:is_map(Arr_2) of true -> maps:get(I_5, Arr_2, nil); _ -> lists:nth(I_5 + 1, Arr_2) end))) of
        true -> Res_2 = lists:append(Res, [(case erlang:is_map(Arr_2) of true -> maps:get(I_5, Arr_2, nil); _ -> lists:nth(I_5 + 1, Arr_2) end)]),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(Arr_2, I_6, Res_3);
        _ -> {Arr_2, I_5, Res}
    end
end,
{Arr_2, I_6, Res_3} = Fun_3(Arr_2, I_5, Res),
        Res_3
    catch {return, Ret} -> Ret end.

check(Binary) ->
    try
        Pi = [],
        Current = Binary,
        Fun_8 = fun Fun_8_loop(Binary, Current, Pi) ->
    case true of
        true ->
            Check1 = [],
            I_7 = 0,
            Fun_4 = fun Fun_4_loop(Binary, Check1, Current, I_7, Pi) ->
    case (I_7 < length(Current)) of
        true ->
            Check1_2 = lists:append(Check1, ["$"]),
            I_8 = (I_7 + 1),
            Fun_4_loop(Binary, Check1_2, Current, I_8, Pi);
        _ -> {Binary, Check1, Current, I_7, Pi}
    end
end,
{Binary, Check1_2, Current, I_8, Pi} = Fun_4(Binary, Check1, Current, I_7, Pi),
            Temp = [],
            I_9 = 0,
            Fun_6 = fun Fun_6_loop(Binary, Check1_2, Current, I_9, Pi, Temp) ->
    case (I_9 < length(Current)) of
        true ->
            J = (I_9 + 1),
            Fun_5 = fun Fun_5_loop(Binary, Check1_2, Current, I_9, J, Pi, Temp) ->
    case (J < length(Current)) of
        true ->
            K = compare_string((case erlang:is_map(Current) of true -> maps:get(I_9, Current, nil); _ -> lists:nth(I_9 + 1, Current) end), (case erlang:is_map(Current) of true -> maps:get(J, Current, nil); _ -> lists:nth(J + 1, Current) end)),
            case (K == "") of
        true -> Check1_3 = lists:sublist(Check1_2, I_9) ++ ["*"] ++ lists:nthtail(I_9 + 1, Check1_2),
            Check1_4 = lists:sublist(Check1_3, J) ++ ["*"] ++ lists:nthtail(J + 1, Check1_3),
            Temp_2 = lists:append(Temp, ["X"]),
            Check1_5 = Check1_4,
            Temp_3 = Temp_2;
        _ -> Check1_5 = Check1_2,
            Temp_3 = Temp
    end,
            J_2 = (J + 1),
            Fun_5_loop(Binary, Check1_5, Current, I_9, J_2, Pi, Temp_3);
        _ -> {Binary, Check1_2, Current, I_9, J, Pi, Temp}
    end
end,
{Binary, Check1_5, Current, I_9, J_2, Pi, Temp_3} = Fun_5(Binary, Check1_2, Current, I_9, J, Pi, Temp),
            I_10 = (I_9 + 1),
            Fun_6_loop(Binary, Check1_5, Current, I_10, Pi, Temp_3);
        _ -> {Binary, Check1_2, Current, I_9, Pi, Temp}
    end
end,
{Binary, Check1_5, Current, I_10, Pi, Temp_3} = Fun_6(Binary, Check1_2, Current, I_9, Pi, Temp),
            I_11 = 0,
            Fun_7 = fun Fun_7_loop(Binary, Check1_5, Current, I_11, Pi, Temp_3) ->
    case (I_11 < length(Current)) of
        true ->
            case ((case erlang:is_map(Check1_5) of true -> maps:get(I_11, Check1_5, nil); _ -> lists:nth(I_11 + 1, Check1_5) end) == "$") of
        true -> Pi_2 = lists:append(Pi, [(case erlang:is_map(Current) of true -> maps:get(I_11, Current, nil); _ -> lists:nth(I_11 + 1, Current) end)]),
            Pi_3 = Pi_2;
        _ -> Pi_3 = Pi
    end,
            I_12 = (I_11 + 1),
            Fun_7_loop(Binary, Check1_5, Current, I_12, Pi_3, Temp_3);
        _ -> {Binary, Check1_5, Current, I_11, Pi, Temp_3}
    end
end,
{Binary, Check1_5, Current, I_12, Pi_3, Temp_3} = Fun_7(Binary, Check1_5, Current, I_11, Pi, Temp_3),
            case (length(Temp_3) == 0) of
        true -> throw({return, Pi_3});
        _ -> ok
    end,
            Current_2 = unique_strings(Temp_3),
            Fun_8_loop(Binary, Current_2, Pi_3);
        _ -> {Binary, Current, Pi}
    end
end,
{Binary, Current_2, Pi_3} = Fun_8(Binary, Current, Pi),
        nil
    catch {return, Ret} -> Ret end.

decimal_to_binary(No_of_variable, Minterms) ->
    try
        Temp_4 = [],
        Idx = 0,
        Fun_10 = fun Fun_10_loop(Idx, Minterms, No_of_variable, Temp_4) ->
    case (Idx < length(Minterms)) of
        true ->
            Minterm = (case erlang:is_map(Minterms) of true -> maps:get(Idx, Minterms, nil); _ -> lists:nth(Idx + 1, Minterms) end),
            String = "",
            I_13 = 0,
            Fun_9 = fun Fun_9_loop(I_13, Idx, Minterm, Minterms, No_of_variable, String, Temp_4) ->
    case (I_13 < No_of_variable) of
        true ->
            String_2 = (mochi_str((Minterm rem 2)) ++ String),
            Minterm_2 = (Minterm div 2),
            I_14 = (I_13 + 1),
            Fun_9_loop(I_14, Idx, Minterm_2, Minterms, No_of_variable, String_2, Temp_4);
        _ -> {I_13, Idx, Minterm, Minterms, No_of_variable, String, Temp_4}
    end
end,
{I_14, Idx, Minterm_2, Minterms, No_of_variable, String_2, Temp_4} = Fun_9(I_13, Idx, Minterm, Minterms, No_of_variable, String, Temp_4),
            Temp_5 = lists:append(Temp_4, [String_2]),
            Idx_2 = (Idx + 1),
            Fun_10_loop(Idx_2, Minterms, No_of_variable, Temp_5);
        _ -> {Idx, Minterms, No_of_variable, Temp_4}
    end
end,
{Idx_2, Minterms, No_of_variable, Temp_5} = Fun_10(Idx, Minterms, No_of_variable, Temp_4),
        Temp_5
    catch {return, Ret} -> Ret end.

is_for_table(String1_2, String2_2, Count_4) ->
    try
        Count_n = 0,
        I_15 = 0,
        Fun_11 = fun Fun_11_loop(Count_4, Count_n, I_15, String1_2, String2_2) ->
    case (I_15 < length(String1_2)) of
        true ->
            C1_2 = string:substr(String1_2, I_15 + 1, ((I_15 + 1) - I_15)),
            C2_2 = string:substr(String2_2, I_15 + 1, ((I_15 + 1) - I_15)),
            case (C1_2 /= C2_2) of
        true -> Count_n_2 = (Count_n + 1),
            Count_n_3 = Count_n_2;
        _ -> Count_n_3 = Count_n
    end,
            I_16 = (I_15 + 1),
            Fun_11_loop(Count_4, Count_n_3, I_16, String1_2, String2_2);
        _ -> {Count_4, Count_n, I_15, String1_2, String2_2}
    end
end,
{Count_4, Count_n_3, I_16, String1_2, String2_2} = Fun_11(Count_4, Count_n, I_15, String1_2, String2_2),
        (Count_n_3 == Count_4)
    catch {return, Ret} -> Ret end.

count_ones(Row) ->
    try
        C = 0,
        J_3 = 0,
        Fun_12 = fun Fun_12_loop(C, J_3, Row) ->
    case (J_3 < length(Row)) of
        true ->
            case ((case erlang:is_map(Row) of true -> maps:get(J_3, Row, nil); _ -> lists:nth(J_3 + 1, Row) end) == 1) of
        true -> C_2 = (C + 1),
            C_3 = C_2;
        _ -> C_3 = C
    end,
            J_4 = (J_3 + 1),
            Fun_12_loop(C_3, J_4, Row);
        _ -> {C, J_3, Row}
    end
end,
{C_3, J_4, Row} = Fun_12(C, J_3, Row),
        C_3
    catch {return, Ret} -> Ret end.

selection(Chart, Prime_implicants) ->
    try
        Temp_6 = [],
        Select = [],
        I_17 = 0,
        Fun_13 = fun Fun_13_loop(Chart, I_17, Prime_implicants, Select, Temp_6) ->
    case (I_17 < length(Chart)) of
        true ->
            Select_2 = lists:append(Select, [0]),
            I_18 = (I_17 + 1),
            Fun_13_loop(Chart, I_18, Prime_implicants, Select_2, Temp_6);
        _ -> {Chart, I_17, Prime_implicants, Select, Temp_6}
    end
end,
{Chart, I_18, Prime_implicants, Select_2, Temp_6} = Fun_13(Chart, I_17, Prime_implicants, Select, Temp_6),
        Col = 0,
        Fun_17 = fun Fun_17_loop(Chart, Col, I_18, Prime_implicants, Select_2, Temp_6) ->
    case (Col < length((case erlang:is_map(Chart) of true -> maps:get(0, Chart, nil); _ -> lists:nth(0 + 1, Chart) end))) of
        true ->
            Count_5 = 0,
            Row_2 = 0,
            Fun_14 = fun Fun_14_loop(Chart, Col, Count_5, I_18, Prime_implicants, Row_2, Select_2, Temp_6) ->
    case (Row_2 < length(Chart)) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Chart) of true -> maps:get(Row_2, Chart, nil); _ -> lists:nth(Row_2 + 1, Chart) end)) of true -> maps:get(Col, (case erlang:is_map(Chart) of true -> maps:get(Row_2, Chart, nil); _ -> lists:nth(Row_2 + 1, Chart) end), nil); _ -> lists:nth(Col + 1, (case erlang:is_map(Chart) of true -> maps:get(Row_2, Chart, nil); _ -> lists:nth(Row_2 + 1, Chart) end)) end) == 1) of
        true -> Count_6 = (Count_5 + 1),
            Count_7 = Count_6;
        _ -> Count_7 = Count_5
    end,
            Row_3 = (Row_2 + 1),
            Fun_14_loop(Chart, Col, Count_7, I_18, Prime_implicants, Row_3, Select_2, Temp_6);
        _ -> {Chart, Col, Count_5, I_18, Prime_implicants, Row_2, Select_2, Temp_6}
    end
end,
{Chart, Col, Count_7, I_18, Prime_implicants, Row_3, Select_2, Temp_6} = Fun_14(Chart, Col, Count_5, I_18, Prime_implicants, Row_2, Select_2, Temp_6),
            case (Count_7 == 1) of
        true -> Rem = 0,
            Row_4 = 0,
            Fun_15 = fun Fun_15_loop(Chart, Col, Count_7, I_18, Prime_implicants, Rem, Row_4, Select_2, Temp_6) ->
    case (Row_4 < length(Chart)) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Chart) of true -> maps:get(Row_4, Chart, nil); _ -> lists:nth(Row_4 + 1, Chart) end)) of true -> maps:get(Col, (case erlang:is_map(Chart) of true -> maps:get(Row_4, Chart, nil); _ -> lists:nth(Row_4 + 1, Chart) end), nil); _ -> lists:nth(Col + 1, (case erlang:is_map(Chart) of true -> maps:get(Row_4, Chart, nil); _ -> lists:nth(Row_4 + 1, Chart) end)) end) == 1) of
        true -> Rem_2 = Row_4,
            Rem_3 = Rem_2;
        _ -> Rem_3 = Rem
    end,
            Row_5 = (Row_4 + 1),
            Fun_15_loop(Chart, Col, Count_7, I_18, Prime_implicants, Rem_3, Row_5, Select_2, Temp_6);
        _ -> {Chart, Col, Count_7, I_18, Prime_implicants, Rem, Row_4, Select_2, Temp_6}
    end
end,
{Chart, Col, Count_7, I_18, Prime_implicants, Rem_3, Row_5, Select_2, Temp_6} = Fun_15(Chart, Col, Count_7, I_18, Prime_implicants, Rem, Row_4, Select_2, Temp_6),
            Select_3 = lists:sublist(Select_2, Rem_3) ++ [1] ++ lists:nthtail(Rem_3 + 1, Select_2),
            Fun_16 = Fun_15,
            Rem_4 = Rem_3,
            Row_6 = Row_5,
            Select_4 = Select_3;
        _ -> Fun_16 = Fun_14,
            Rem_4 = nil,
            Row_6 = Row_3,
            Select_4 = Select_2
    end,
            Col_2 = (Col + 1),
            Fun_17_loop(Chart, Col_2, I_18, Prime_implicants, Select_4, Temp_6);
        _ -> {Chart, Col, I_18, Prime_implicants, Select_2, Temp_6}
    end
end,
{Chart, Col_2, I_18, Prime_implicants, Select_4, Temp_6} = Fun_17(Chart, Col, I_18, Prime_implicants, Select_2, Temp_6),
        I_19 = 0,
        Fun_22 = fun Fun_22_loop(Chart, Col_2, I_19, Prime_implicants, Select_4, Temp_6) ->
    case (I_19 < length(Select_4)) of
        true ->
            case ((case erlang:is_map(Select_4) of true -> maps:get(I_19, Select_4, nil); _ -> lists:nth(I_19 + 1, Select_4) end) == 1) of
        true -> J_5 = 0,
            Fun_20 = fun Fun_20_loop(Chart, Col_2, I_19, J_5, Prime_implicants, Select_4, Temp_6) ->
    case (J_5 < length((case erlang:is_map(Chart) of true -> maps:get(0, Chart, nil); _ -> lists:nth(0 + 1, Chart) end))) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Chart) of true -> maps:get(I_19, Chart, nil); _ -> lists:nth(I_19 + 1, Chart) end)) of true -> maps:get(J_5, (case erlang:is_map(Chart) of true -> maps:get(I_19, Chart, nil); _ -> lists:nth(I_19 + 1, Chart) end), nil); _ -> lists:nth(J_5 + 1, (case erlang:is_map(Chart) of true -> maps:get(I_19, Chart, nil); _ -> lists:nth(I_19 + 1, Chart) end)) end) == 1) of
        true -> R = 0,
            Fun_18 = fun Fun_18_loop(Chart, Col_2, I_19, J_5, Prime_implicants, R, Select_4, Temp_6) ->
    case (R < length(Chart)) of
        true ->
            Tmp = (case erlang:is_map(Chart) of true -> maps:get(R, Chart, nil); _ -> lists:nth(R + 1, Chart) end),
            Tmp_2 = lists:sublist(Tmp, J_5) ++ [0] ++ lists:nthtail(J_5 + 1, Tmp),
            Chart_2 = lists:sublist(Chart, R) ++ [Tmp_2] ++ lists:nthtail(R + 1, Chart),
            R_2 = (R + 1),
            Fun_18_loop(Chart_2, Col_2, I_19, J_5, Prime_implicants, R_2, Select_4, Temp_6);
        _ -> {Chart, Col_2, I_19, J_5, Prime_implicants, R, Select_4, Temp_6}
    end
end,
{Chart_2, Col_2, I_19, J_5, Prime_implicants, R_2, Select_4, Temp_6} = Fun_18(Chart, Col_2, I_19, J_5, Prime_implicants, R, Select_4, Temp_6),
            Chart_3 = Chart_2,
            Fun_19 = Fun_18,
            R_3 = R_2;
        _ -> Chart_3 = Chart,
            Fun_19 = Fun_17,
            R_3 = nil
    end,
            J_6 = (J_5 + 1),
            Fun_20_loop(Chart_3, Col_2, I_19, J_6, Prime_implicants, Select_4, Temp_6);
        _ -> {Chart, Col_2, I_19, J_5, Prime_implicants, Select_4, Temp_6}
    end
end,
{Chart_3, Col_2, I_19, J_6, Prime_implicants, Select_4, Temp_6} = Fun_20(Chart, Col_2, I_19, J_5, Prime_implicants, Select_4, Temp_6),
            Temp_7 = lists:append(Temp_6, [(case erlang:is_map(Prime_implicants) of true -> maps:get(I_19, Prime_implicants, nil); _ -> lists:nth(I_19 + 1, Prime_implicants) end)]),
            Chart_4 = Chart_3,
            Fun_21 = Fun_20,
            J_7 = J_6,
            Temp_8 = Temp_7;
        _ -> Chart_4 = Chart,
            Fun_21 = Fun_17,
            J_7 = nil,
            Temp_8 = Temp_6
    end,
            I_20 = (I_19 + 1),
            Fun_22_loop(Chart_4, Col_2, I_20, Prime_implicants, Select_4, Temp_8);
        _ -> {Chart, Col_2, I_19, Prime_implicants, Select_4, Temp_6}
    end
end,
{Chart_4, Col_2, I_20, Prime_implicants, Select_4, Temp_8} = Fun_22(Chart, Col_2, I_19, Prime_implicants, Select_4, Temp_6),
        Fun_28 = fun Fun_28_loop(Chart_4, Col_2, I_20, Prime_implicants, Select_4, Temp_8) ->
    case true of
        true ->
            Counts = [],
            R_4 = 0,
            Fun_23 = fun Fun_23_loop(Chart_4, Col_2, Counts, I_20, Prime_implicants, R_4, Select_4, Temp_8) ->
    case (R_4 < length(Chart_4)) of
        true ->
            Counts_2 = lists:append(Counts, [count_ones((case erlang:is_map(Chart_4) of true -> maps:get(R_4, Chart_4, nil); _ -> lists:nth(R_4 + 1, Chart_4) end))]),
            R_5 = (R_4 + 1),
            Fun_23_loop(Chart_4, Col_2, Counts_2, I_20, Prime_implicants, R_5, Select_4, Temp_8);
        _ -> {Chart_4, Col_2, Counts, I_20, Prime_implicants, R_4, Select_4, Temp_8}
    end
end,
{Chart_4, Col_2, Counts_2, I_20, Prime_implicants, R_5, Select_4, Temp_8} = Fun_23(Chart_4, Col_2, Counts, I_20, Prime_implicants, R_4, Select_4, Temp_8),
            Max_n = (case erlang:is_map(Counts_2) of true -> maps:get(0, Counts_2, nil); _ -> lists:nth(0 + 1, Counts_2) end),
            Rem_5 = 0,
            K_2 = 1,
            Fun_24 = fun Fun_24_loop(Chart_4, Col_2, Counts_2, I_20, K_2, Max_n, Prime_implicants, R_5, Rem_5, Select_4, Temp_8) ->
    case (K_2 < length(Counts_2)) of
        true ->
            case ((case erlang:is_map(Counts_2) of true -> maps:get(K_2, Counts_2, nil); _ -> lists:nth(K_2 + 1, Counts_2) end) > Max_n) of
        true -> Max_n_2 = (case erlang:is_map(Counts_2) of true -> maps:get(K_2, Counts_2, nil); _ -> lists:nth(K_2 + 1, Counts_2) end),
            Rem_6 = K_2,
            Max_n_3 = Max_n_2,
            Rem_7 = Rem_6;
        _ -> Max_n_3 = Max_n,
            Rem_7 = Rem_5
    end,
            K_3 = (K_2 + 1),
            Fun_24_loop(Chart_4, Col_2, Counts_2, I_20, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_8);
        _ -> {Chart_4, Col_2, Counts_2, I_20, K_2, Max_n, Prime_implicants, R_5, Rem_5, Select_4, Temp_8}
    end
end,
{Chart_4, Col_2, Counts_2, I_20, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_8} = Fun_24(Chart_4, Col_2, Counts_2, I_20, K_2, Max_n, Prime_implicants, R_5, Rem_5, Select_4, Temp_8),
            case (Max_n_3 == 0) of
        true -> throw({return, Temp_8});
        _ -> ok
    end,
            Temp_9 = lists:append(Temp_8, [(case erlang:is_map(Prime_implicants) of true -> maps:get(Rem_7, Prime_implicants, nil); _ -> lists:nth(Rem_7 + 1, Prime_implicants) end)]),
            J_8 = 0,
            Fun_27 = fun Fun_27_loop(Chart_4, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_9) ->
    case (J_8 < length((case erlang:is_map(Chart_4) of true -> maps:get(0, Chart_4, nil); _ -> lists:nth(0 + 1, Chart_4) end))) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Chart_4) of true -> maps:get(Rem_7, Chart_4, nil); _ -> lists:nth(Rem_7 + 1, Chart_4) end)) of true -> maps:get(J_8, (case erlang:is_map(Chart_4) of true -> maps:get(Rem_7, Chart_4, nil); _ -> lists:nth(Rem_7 + 1, Chart_4) end), nil); _ -> lists:nth(J_8 + 1, (case erlang:is_map(Chart_4) of true -> maps:get(Rem_7, Chart_4, nil); _ -> lists:nth(Rem_7 + 1, Chart_4) end)) end) == 1) of
        true -> R2 = 0,
            Fun_25 = fun Fun_25_loop(Chart_4, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, R2, Rem_7, Select_4, Temp_9) ->
    case (R2 < length(Chart_4)) of
        true ->
            Tmp_3 = (case erlang:is_map(Chart_4) of true -> maps:get(R2, Chart_4, nil); _ -> lists:nth(R2 + 1, Chart_4) end),
            Tmp_4 = lists:sublist(Tmp_3, J_8) ++ [0] ++ lists:nthtail(J_8 + 1, Tmp_3),
            Chart_5 = lists:sublist(Chart_4, R2) ++ [Tmp_4] ++ lists:nthtail(R2 + 1, Chart_4),
            R2_2 = (R2 + 1),
            Fun_25_loop(Chart_5, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, R2_2, Rem_7, Select_4, Temp_9);
        _ -> {Chart_4, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, R2, Rem_7, Select_4, Temp_9}
    end
end,
{Chart_5, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, R2_2, Rem_7, Select_4, Temp_9} = Fun_25(Chart_4, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, R2, Rem_7, Select_4, Temp_9),
            Chart_6 = Chart_5,
            Fun_26 = Fun_25,
            R2_3 = R2_2;
        _ -> Chart_6 = Chart_4,
            Fun_26 = Fun_24,
            R2_3 = nil
    end,
            J_9 = (J_8 + 1),
            Fun_27_loop(Chart_6, Col_2, Counts_2, I_20, J_9, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_9);
        _ -> {Chart_4, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_9}
    end
end,
{Chart_6, Col_2, Counts_2, I_20, J_9, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_9} = Fun_27(Chart_4, Col_2, Counts_2, I_20, J_8, K_3, Max_n_3, Prime_implicants, R_5, Rem_7, Select_4, Temp_9),
            Fun_28_loop(Chart_6, Col_2, I_20, Prime_implicants, Select_4, Temp_9);
        _ -> {Chart_4, Col_2, I_20, Prime_implicants, Select_4, Temp_8}
    end
end,
{Chart_6, Col_2, I_20, Prime_implicants, Select_4, Temp_9} = Fun_28(Chart_4, Col_2, I_20, Prime_implicants, Select_4, Temp_8),
        nil
    catch {return, Ret} -> Ret end.

count_char(S, Ch) ->
    try
        Cnt = 0,
        I_21 = 0,
        Fun_29 = fun Fun_29_loop(Ch, Cnt, I_21, S) ->
    case (I_21 < length(S)) of
        true ->
            case (string:substr(S, I_21 + 1, ((I_21 + 1) - I_21)) == Ch) of
        true -> Cnt_2 = (Cnt + 1),
            Cnt_3 = Cnt_2;
        _ -> Cnt_3 = Cnt
    end,
            I_22 = (I_21 + 1),
            Fun_29_loop(Ch, Cnt_3, I_22, S);
        _ -> {Ch, Cnt, I_21, S}
    end
end,
{Ch, Cnt_3, I_22, S} = Fun_29(Ch, Cnt, I_21, S),
        Cnt_3
    catch {return, Ret} -> Ret end.

prime_implicant_chart(Prime_implicants_2, Binary_2) ->
    try
        Chart_7 = [],
        I_23 = 0,
        Fun_31 = fun Fun_31_loop(Binary_2, Chart_7, I_23, Prime_implicants_2) ->
    case (I_23 < length(Prime_implicants_2)) of
        true ->
            Row_7 = [],
            J_10 = 0,
            Fun_30 = fun Fun_30_loop(Binary_2, Chart_7, I_23, J_10, Prime_implicants_2, Row_7) ->
    case (J_10 < length(Binary_2)) of
        true ->
            Row_8 = lists:append(Row_7, [0]),
            J_11 = (J_10 + 1),
            Fun_30_loop(Binary_2, Chart_7, I_23, J_11, Prime_implicants_2, Row_8);
        _ -> {Binary_2, Chart_7, I_23, J_10, Prime_implicants_2, Row_7}
    end
end,
{Binary_2, Chart_7, I_23, J_11, Prime_implicants_2, Row_8} = Fun_30(Binary_2, Chart_7, I_23, J_10, Prime_implicants_2, Row_7),
            Chart_8 = lists:append(Chart_7, [Row_8]),
            I_24 = (I_23 + 1),
            Fun_31_loop(Binary_2, Chart_8, I_24, Prime_implicants_2);
        _ -> {Binary_2, Chart_7, I_23, Prime_implicants_2}
    end
end,
{Binary_2, Chart_8, I_24, Prime_implicants_2} = Fun_31(Binary_2, Chart_7, I_23, Prime_implicants_2),
        I_25 = 0,
        Fun_33 = fun Fun_33_loop(Binary_2, Chart_8, I_25, Prime_implicants_2) ->
    case (I_25 < length(Prime_implicants_2)) of
        true ->
            Count_8 = count_char((case erlang:is_map(Prime_implicants_2) of true -> maps:get(I_25, Prime_implicants_2, nil); _ -> lists:nth(I_25 + 1, Prime_implicants_2) end), "_"),
            J_12 = 0,
            Fun_32 = fun Fun_32_loop(Binary_2, Chart_8, Count_8, I_25, J_12, Prime_implicants_2) ->
    case (J_12 < length(Binary_2)) of
        true ->
            case is_for_table((case erlang:is_map(Prime_implicants_2) of true -> maps:get(I_25, Prime_implicants_2, nil); _ -> lists:nth(I_25 + 1, Prime_implicants_2) end), (case erlang:is_map(Binary_2) of true -> maps:get(J_12, Binary_2, nil); _ -> lists:nth(J_12 + 1, Binary_2) end), Count_8) of
        true -> Tmp_5 = (case erlang:is_map(Chart_8) of true -> maps:get(I_25, Chart_8, nil); _ -> lists:nth(I_25 + 1, Chart_8) end),
            Tmp_6 = lists:sublist(Tmp_5, J_12) ++ [1] ++ lists:nthtail(J_12 + 1, Tmp_5),
            Chart_9 = lists:sublist(Chart_8, I_25) ++ [Tmp_6] ++ lists:nthtail(I_25 + 1, Chart_8),
            Chart_10 = Chart_9,
            Tmp_7 = Tmp_6;
        _ -> Chart_10 = Chart_8,
            Tmp_7 = nil
    end,
            J_13 = (J_12 + 1),
            Fun_32_loop(Binary_2, Chart_10, Count_8, I_25, J_13, Prime_implicants_2);
        _ -> {Binary_2, Chart_8, Count_8, I_25, J_12, Prime_implicants_2}
    end
end,
{Binary_2, Chart_10, Count_8, I_25, J_13, Prime_implicants_2} = Fun_32(Binary_2, Chart_8, Count_8, I_25, J_12, Prime_implicants_2),
            I_26 = (I_25 + 1),
            Fun_33_loop(Binary_2, Chart_10, I_26, Prime_implicants_2);
        _ -> {Binary_2, Chart_8, I_25, Prime_implicants_2}
    end
end,
{Binary_2, Chart_10, I_26, Prime_implicants_2} = Fun_33(Binary_2, Chart_8, I_25, Prime_implicants_2),
        Chart_10
    catch {return, Ret} -> Ret end.

main() ->
    try
        No_of_variable_2 = 3,
        Minterms_2 = [1, 5, 7],
        Binary_3 = decimal_to_binary(3, Minterms_2),
        Prime_implicants_3 = check(Binary_3),
        io:format("~ts~n", [mochi_repr("Prime Implicants are:")]),
        io:format("~ts~n", [mochi_str(Prime_implicants_3)]),
        Chart_11 = prime_implicant_chart(Prime_implicants_3, Binary_3),
        Essential_prime_implicants = selection(Chart_11, Prime_implicants_3),
        io:format("~ts~n", [mochi_repr("Essential Prime Implicants are:")]),
        io:format("~ts~n", [mochi_str(Essential_prime_implicants)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
