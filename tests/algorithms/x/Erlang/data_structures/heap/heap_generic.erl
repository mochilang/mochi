#!/usr/bin/env escript
-module(main).
-compile([export_vars, nowarn_export_vars, nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, new_heap/1, parent/1, left/2, right/2, swap/3, cmp/3, get_valid_parent/2, heapify_up/2, heapify_down/2, update_item/3, delete_item/2, insert_item/3, get_top/1, extract_top/1, identity/1, negate/1]).

% Generated by Mochi transpiler v0.10.72 (17da928c0a)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> case V of
                true -> 1;
                false -> 0;
                _ -> list_to_integer(V)
            end
        end
    end.


toi(V) ->
    mochi_to_int(V).


mochi_to_float(V) ->
    case erlang:is_float(V) of
        true -> V;
        _ -> float(V)
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_list(V) ->
    "[" ++ string:join([mochi_str(E) || E <- V], " ") ++ "]";
mochi_str(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false -> erlang:float_to_list(V, [short])
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_idiv(A, B) ->
    Q = A div B,
    R = A rem B,
    case ((R /= 0) andalso ((B < 0 andalso R > 0) orelse (B > 0 andalso R < 0))) of
        true -> Q - 1;
        false -> Q
    end.

new_heap(Key) ->
    try
        #{"arr" => [], "pos_map" => #{}, "size" => 0, "key" => Key}
    catch {return, RetCatch} -> RetCatch end.

parent(I) ->
    try
        (case (I > 0) of
    true -> mochi_idiv((I - 1), 2);
    _ -> -1
end)
    catch {return, RetCatch} -> RetCatch end.

left(I_2, Size) ->
    try
        L = ((2 * I_2) + 1),
        case (L < Size) of
        true -> throw({return, L});
        _ -> ok
    end,
        -1
    catch {return, RetCatch} -> RetCatch end.

right(I_3, Size_2) ->
    try
        R = ((2 * I_3) + 2),
        case (R < Size_2) of
        true -> throw({return, R});
        _ -> ok
    end,
        -1
    catch {return, RetCatch} -> RetCatch end.

swap(H, I_4, J) ->
    try
        Arr = maps:get("arr", H, nil),
        Item_i = (case erlang:is_map((case erlang:is_map(Arr) of true -> maps:get(I_4, Arr, nil); _ -> case I_4 < 0 of true -> mochi_nth(erlang:length(Arr) + I_4 + 1, Arr); _ -> mochi_nth(I_4 + 1, Arr) end end)) of true -> maps:get(0, (case erlang:is_map(Arr) of true -> maps:get(I_4, Arr, nil); _ -> case I_4 < 0 of true -> mochi_nth(erlang:length(Arr) + I_4 + 1, Arr); _ -> mochi_nth(I_4 + 1, Arr) end end), nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Arr) of true -> maps:get(I_4, Arr, nil); _ -> case I_4 < 0 of true -> mochi_nth(erlang:length(Arr) + I_4 + 1, Arr); _ -> mochi_nth(I_4 + 1, Arr) end end)) + 0 + 1, (case erlang:is_map(Arr) of true -> maps:get(I_4, Arr, nil); _ -> case I_4 < 0 of true -> mochi_nth(erlang:length(Arr) + I_4 + 1, Arr); _ -> mochi_nth(I_4 + 1, Arr) end end)); _ -> mochi_nth(0 + 1, (case erlang:is_map(Arr) of true -> maps:get(I_4, Arr, nil); _ -> case I_4 < 0 of true -> mochi_nth(erlang:length(Arr) + I_4 + 1, Arr); _ -> mochi_nth(I_4 + 1, Arr) end end)) end end),
        Item_j = (case erlang:is_map((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end)) of true -> maps:get(0, (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end), nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end)) + 0 + 1, (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end)); _ -> mochi_nth(0 + 1, (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end)) end end),
        Pm = maps:get("pos_map", H, nil),
        Pm_2 = maps:put(Item_i, (J + 1), Pm),
        Pm_3 = maps:put(Item_j, (I_4 + 1), Pm_2),
        H_2 = maps:put("pos_map", Pm_3, H),
        Tmp = (case erlang:is_map(Arr) of true -> maps:get(I_4, Arr, nil); _ -> case I_4 < 0 of true -> mochi_nth(erlang:length(Arr) + I_4 + 1, Arr); _ -> mochi_nth(I_4 + 1, Arr) end end),
        Arr_2 = lists:sublist(Arr, I_4) ++ [(case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end)] ++ lists:nthtail(I_4 + 1, Arr),
        Arr_3 = lists:sublist(Arr_2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr_2),
        H_3 = maps:put("arr", Arr_3, H_2),
        {nil, H_3}
    catch {return, RetCatch} -> RetCatch end.

cmp(H_4, I_5, J_2) ->
    try
        Arr_4 = maps:get("arr", H_4, nil),
        ((case erlang:is_map((case erlang:is_map(Arr_4) of true -> maps:get(I_5, Arr_4, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Arr_4) + I_5 + 1, Arr_4); _ -> mochi_nth(I_5 + 1, Arr_4) end end)) of true -> maps:get(1, (case erlang:is_map(Arr_4) of true -> maps:get(I_5, Arr_4, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Arr_4) + I_5 + 1, Arr_4); _ -> mochi_nth(I_5 + 1, Arr_4) end end), nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Arr_4) of true -> maps:get(I_5, Arr_4, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Arr_4) + I_5 + 1, Arr_4); _ -> mochi_nth(I_5 + 1, Arr_4) end end)) + 1 + 1, (case erlang:is_map(Arr_4) of true -> maps:get(I_5, Arr_4, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Arr_4) + I_5 + 1, Arr_4); _ -> mochi_nth(I_5 + 1, Arr_4) end end)); _ -> mochi_nth(1 + 1, (case erlang:is_map(Arr_4) of true -> maps:get(I_5, Arr_4, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Arr_4) + I_5 + 1, Arr_4); _ -> mochi_nth(I_5 + 1, Arr_4) end end)) end end) < (case erlang:is_map((case erlang:is_map(Arr_4) of true -> maps:get(J_2, Arr_4, nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length(Arr_4) + J_2 + 1, Arr_4); _ -> mochi_nth(J_2 + 1, Arr_4) end end)) of true -> maps:get(1, (case erlang:is_map(Arr_4) of true -> maps:get(J_2, Arr_4, nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length(Arr_4) + J_2 + 1, Arr_4); _ -> mochi_nth(J_2 + 1, Arr_4) end end), nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Arr_4) of true -> maps:get(J_2, Arr_4, nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length(Arr_4) + J_2 + 1, Arr_4); _ -> mochi_nth(J_2 + 1, Arr_4) end end)) + 1 + 1, (case erlang:is_map(Arr_4) of true -> maps:get(J_2, Arr_4, nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length(Arr_4) + J_2 + 1, Arr_4); _ -> mochi_nth(J_2 + 1, Arr_4) end end)); _ -> mochi_nth(1 + 1, (case erlang:is_map(Arr_4) of true -> maps:get(J_2, Arr_4, nil); _ -> case J_2 < 0 of true -> mochi_nth(erlang:length(Arr_4) + J_2 + 1, Arr_4); _ -> mochi_nth(J_2 + 1, Arr_4) end end)) end end))
    catch {return, RetCatch} -> RetCatch end.

get_valid_parent(H_5, I_6) ->
    try
        Vp = I_6,
        L_2 = left(I_6, maps:get("size", H_5, nil)),
        Vp_3 = (case ((L_2 /= (0 - 1)) andalso (cmp(H_5, L_2, Vp) == false)) of
        true -> Vp_2 = L_2,
            Vp_2;
        _ -> Vp
    end),
        R_2 = right(I_6, maps:get("size", H_5, nil)),
        Vp_5 = (case ((R_2 /= (0 - 1)) andalso (cmp(H_5, R_2, Vp_3) == false)) of
        true -> Vp_4 = R_2,
            Vp_4;
        _ -> Vp_3
    end),
        Vp_5
    catch {return, RetCatch} -> RetCatch end.

heapify_up(H_6, Index) ->
    try
        Idx = Index,
        P = parent(Idx),
        Fun = fun Fun_loop(H_6, Idx, Index, P) ->
    case ((P /= (0 - 1)) andalso (cmp(H_6, Idx, P) == false)) of
        true ->
            H_res = swap(H_6, Idx, P),
            H_tmp = element(2, H_res),
            H_7 = H_tmp,
            Idx_2 = P,
            P_2 = parent(P),
            Fun_loop(H_7, Idx_2, Index, P_2);
        _ -> {H_6, Idx, Index, P}
    end
end,
{H_7, Idx_2, Index, P_2} = Fun(H_6, Idx, Index, P),
        {nil, H_7}
    catch {return, RetCatch} -> RetCatch end.

heapify_down(H_8, Index_2) ->
    try
        Idx_3 = Index_2,
        Vp_6 = get_valid_parent(H_8, Idx_3),
        Fun_2 = fun Fun_2_loop(H_8, Idx_3, Index_2, Vp_6) ->
    case (Vp_6 /= Idx_3) of
        true ->
            H_res_2 = swap(H_8, Idx_3, Vp_6),
            H_tmp_2 = element(2, H_res_2),
            H_9 = H_tmp_2,
            Idx_4 = Vp_6,
            Vp_7 = get_valid_parent(H_9, Idx_4),
            Fun_2_loop(H_9, Idx_4, Index_2, Vp_7);
        _ -> {H_8, Idx_3, Index_2, Vp_6}
    end
end,
{H_9, Idx_4, Index_2, Vp_7} = Fun_2(H_8, Idx_3, Index_2, Vp_6),
        {nil, H_9}
    catch {return, RetCatch} -> RetCatch end.

update_item(H_10, Item, Item_value) ->
    try
        Pm_4 = maps:get("pos_map", H_10, nil),
        case (maps:get(Item, Pm_4, nil) == 0) of
        true -> throw({return, nil});
        _ -> ok
    end,
        Index_3 = (maps:get(Item, Pm_4, nil) - 1),
        Arr_5 = maps:get("arr", H_10, nil),
        Arr_6 = lists:sublist(Arr_5, Index_3) ++ [[Item, nil]] ++ lists:nthtail(Index_3 + 1, Arr_5),
        H_11 = maps:put("arr", Arr_6, H_10),
        H_12 = maps:put("pos_map", Pm_4, H_11),
        H_res_3 = heapify_up(H_12, Index_3),
        H_tmp_3 = element(2, H_res_3),
        H_13 = H_tmp_3,
        H_res_4 = heapify_down(H_13, Index_3),
        H_tmp_4 = element(2, H_res_4),
        H_14 = H_tmp_4,
        {nil, H_14}
    catch {return, RetCatch} -> RetCatch end.

delete_item(H_15, Item_2) ->
    try
        Pm_5 = maps:get("pos_map", H_15, nil),
        case (maps:get(Item_2, Pm_5, nil) == 0) of
        true -> throw({return, nil});
        _ -> ok
    end,
        Index_4 = (maps:get(Item_2, Pm_5, nil) - 1),
        Pm_6 = maps:put(Item_2, 0, Pm_5),
        Arr_7 = maps:get("arr", H_15, nil),
        Last_index = (maps:get("size", H_15, nil) - 1),
        Pm_8 = (case (Index_4 /= Last_index) of
        true -> Arr_8 = lists:sublist(Arr_7, Index_4) ++ [(case erlang:is_map(Arr_7) of true -> maps:get(Last_index, Arr_7, nil); _ -> case Last_index < 0 of true -> mochi_nth(erlang:length(Arr_7) + Last_index + 1, Arr_7); _ -> mochi_nth(Last_index + 1, Arr_7) end end)] ++ lists:nthtail(Index_4 + 1, Arr_7),
            Moved = (case erlang:is_map((case erlang:is_map(Arr_8) of true -> maps:get(Index_4, Arr_8, nil); _ -> case Index_4 < 0 of true -> mochi_nth(erlang:length(Arr_8) + Index_4 + 1, Arr_8); _ -> mochi_nth(Index_4 + 1, Arr_8) end end)) of true -> maps:get(0, (case erlang:is_map(Arr_8) of true -> maps:get(Index_4, Arr_8, nil); _ -> case Index_4 < 0 of true -> mochi_nth(erlang:length(Arr_8) + Index_4 + 1, Arr_8); _ -> mochi_nth(Index_4 + 1, Arr_8) end end), nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Arr_8) of true -> maps:get(Index_4, Arr_8, nil); _ -> case Index_4 < 0 of true -> mochi_nth(erlang:length(Arr_8) + Index_4 + 1, Arr_8); _ -> mochi_nth(Index_4 + 1, Arr_8) end end)) + 0 + 1, (case erlang:is_map(Arr_8) of true -> maps:get(Index_4, Arr_8, nil); _ -> case Index_4 < 0 of true -> mochi_nth(erlang:length(Arr_8) + Index_4 + 1, Arr_8); _ -> mochi_nth(Index_4 + 1, Arr_8) end end)); _ -> mochi_nth(0 + 1, (case erlang:is_map(Arr_8) of true -> maps:get(Index_4, Arr_8, nil); _ -> case Index_4 < 0 of true -> mochi_nth(erlang:length(Arr_8) + Index_4 + 1, Arr_8); _ -> mochi_nth(Index_4 + 1, Arr_8) end end)) end end),
            Pm_7 = maps:put(Moved, (Index_4 + 1), Pm_6),
            Arr_9 = Arr_8,
            Moved_2 = Moved,
            Pm_7;
        _ -> Arr_9 = Arr_7,
            Moved_2 = nil,
            Pm_6
    end),
        H_16 = maps:put("size", (maps:get("size", H_15, nil) - 1), H_15),
        H_17 = maps:put("arr", Arr_9, H_16),
        H_18 = maps:put("pos_map", Pm_8, H_17),
        H_tmp_7 = (case (maps:get("size", H_18, nil) > Index_4) of
        true -> H_res_5 = heapify_up(H_18, Index_4),
            H_tmp_5 = element(2, H_res_5),
            H_19 = H_tmp_5,
            H_res_6 = heapify_down(H_19, Index_4),
            H_tmp_6 = element(2, H_res_6),
            H_20 = H_tmp_6,
            H_21 = H_20,
            H_res_7 = H_res_6,
            H_tmp_6;
        _ -> H_21 = H_18,
            H_res_7 = nil,
            nil
    end),
        {nil, H_21}
    catch {return, RetCatch} -> RetCatch end.

insert_item(H_22, Item_3, Item_value_2) ->
    try
        Arr_10 = maps:get("arr", H_22, nil),
        Arr_len = erlang:length(Arr_10),
        Arr_13 = (case (Arr_len == maps:get("size", H_22, nil)) of
        true -> Arr_11 = lists:append((case Arr_10 of nil -> []; _ -> Arr_10 end), [[Item_3, nil]]),
            Arr_11;
        _ -> Arr_12 = lists:sublist(Arr_10, maps:get("size", H_22, nil)) ++ [[Item_3, nil]] ++ lists:nthtail(maps:get("size", H_22, nil) + 1, Arr_10),
            Arr_12
    end),
        Pm_9 = maps:get("pos_map", H_22, nil),
        Pm_10 = maps:put(Item_3, (maps:get("size", H_22, nil) + 1), Pm_9),
        H_23 = maps:put("size", (maps:get("size", H_22, nil) + 1), H_22),
        H_24 = maps:put("arr", Arr_13, H_23),
        H_25 = maps:put("pos_map", Pm_10, H_24),
        H_res_8 = heapify_up(H_25, (maps:get("size", H_25, nil) - 1)),
        H_tmp_8 = element(2, H_res_8),
        H_26 = H_tmp_8,
        {nil, H_26}
    catch {return, RetCatch} -> RetCatch end.

get_top(H_27) ->
    try
        Arr_14 = maps:get("arr", H_27, nil),
        case (maps:get("size", H_27, nil) > 0) of
        true -> throw({return, (case erlang:is_map(Arr_14) of true -> maps:get(0, Arr_14, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Arr_14) + 0 + 1, Arr_14); _ -> mochi_nth(0 + 1, Arr_14) end end)});
        _ -> ok
    end,
        []
    catch {return, RetCatch} -> RetCatch end.

extract_top(H_28) ->
    try
        Top = get_top(H_28),
        H_tmp_10 = (case (erlang:length(Top) > 0) of
        true -> H_res_9 = delete_item(H_28, (case erlang:is_map(Top) of true -> maps:get(0, Top, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Top) + 0 + 1, Top); _ -> mochi_nth(0 + 1, Top) end end)),
            H_tmp_9 = element(2, H_res_9),
            H_29 = H_tmp_9,
            H_30 = H_29,
            H_res_10 = H_res_9,
            H_tmp_9;
        _ -> H_30 = H_28,
            H_res_10 = nil,
            nil
    end),
        Top
    catch {return, RetCatch} -> RetCatch end.

identity(X) ->
    try
        X
    catch {return, RetCatch} -> RetCatch end.

negate(X_2) ->
    try
        (0 - X_2)
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('h', new_heap(fun identity/1)),
    {_, H_31} = insert_item(erlang:get('h'), 5, 34),
    erlang:put('h', H_31),
    {_, H_32} = insert_item(erlang:get('h'), 6, 31),
    erlang:put('h', H_32),
    {_, H_33} = insert_item(erlang:get('h'), 7, 37),
    erlang:put('h', H_33),
    io:format("~s~n", [mochi_str(get_top(erlang:get('h')))]),
    io:format("~s~n", [mochi_str(extract_top(erlang:get('h')))]),
    io:format("~s~n", [mochi_str(extract_top(erlang:get('h')))]),
    io:format("~s~n", [mochi_str(extract_top(erlang:get('h')))]),
    erlang:put('h', new_heap(fun negate/1)),
    {_, H_34} = insert_item(erlang:get('h'), 5, 34),
    erlang:put('h', H_34),
    {_, H_35} = insert_item(erlang:get('h'), 6, 31),
    erlang:put('h', H_35),
    {_, H_36} = insert_item(erlang:get('h'), 7, 37),
    erlang:put('h', H_36),
    io:format("~s~n", [mochi_str(get_top(erlang:get('h')))]),
    io:format("~s~n", [mochi_str(extract_top(erlang:get('h')))]),
    io:format("~s~n", [mochi_str(extract_top(erlang:get('h')))]),
    io:format("~s~n", [mochi_str(extract_top(erlang:get('h')))]),
    {_, H_37} = insert_item(erlang:get('h'), 8, 45),
    erlang:put('h', H_37),
    {_, H_38} = insert_item(erlang:get('h'), 9, 40),
    erlang:put('h', H_38),
    {_, H_39} = insert_item(erlang:get('h'), 10, 50),
    erlang:put('h', H_39),
    io:format("~s~n", [mochi_str(get_top(erlang:get('h')))]),
    {_, H_40} = update_item(erlang:get('h'), 10, 30),
    erlang:put('h', H_40),
    io:format("~s~n", [mochi_str(get_top(erlang:get('h')))]),
    {_, H_41} = delete_item(erlang:get('h'), 10),
    erlang:put('h', H_41),
    io:format("~s~n", [mochi_str(get_top(erlang:get('h')))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~p~n", [Err])
    end.
