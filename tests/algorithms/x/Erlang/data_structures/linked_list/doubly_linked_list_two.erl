#!/usr/bin/env escript
-module(main).
-compile([export_vars, nowarn_export_vars, nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, empty_list/0, get_head_data/1, get_tail_data/1, insert_before_node/3, insert_after_node/3, set_head/2, set_tail/2, insert/2, insert_at_position/3, get_node/2, remove_node_pointers/2, delete_value/2, contains/2, is_empty/1, to_string/1, print_list/1, main/0]).

% Generated by Mochi transpiler v0.10.72 (b9a682dda0)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> case V of
                true -> 1;
                false -> 0;
                _ -> list_to_integer(V)
            end
        end
    end.


toi(V) ->
    mochi_to_int(V).


mochi_to_float(V) ->
    case erlang:is_float(V) of
        true -> V;
        _ -> float(V)
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) ->
                K = case Key of
                    <<_/binary>> -> Key;
                    _ when is_integer(Key) -> <<Key>>;
                    _ -> list_to_binary(Key)
                end,
                binary:match(Coll, K) /= nomatch;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


mochi_format(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false ->
            S = lists:flatten(io_lib:format("~.15f", [V])),
            re:replace(S, "\\.?0+$", "", [global, {return, list}])
    end;
mochi_format(V) when is_integer(V) -> integer_to_list(V);
mochi_format(V) when is_binary(V) -> V;
mochi_format(V) when is_list(V) -> mochi_str(V);
mochi_format(V) -> lists:flatten(io_lib:format("~p", [V])).


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_list(V) ->
    case io_lib:printable_list(V) of
        true -> V;
        false -> "[" ++ string:join([mochi_str(E) || E <- V], " ") ++ "]"
    end;
mochi_str(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false -> erlang:float_to_list(V, [short])
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

empty_list() ->
    try
        #{"nodes" => [], "head_idx" => -1, "tail_idx" => -1}
    catch {return, RetCatch} -> RetCatch end.

get_head_data(Ll) ->
    try
        case (maps:get("head_idx", Ll, nil) == -1) of
        true -> throw({return, -1});
        _ -> ok
    end,
        Node = (case erlang:is_map(maps:get("nodes", Ll, nil)) of true -> maps:get(maps:get("head_idx", Ll, nil), maps:get("nodes", Ll, nil), nil); _ -> case maps:get("head_idx", Ll, nil) < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll, nil)) + maps:get("head_idx", Ll, nil) + 1, maps:get("nodes", Ll, nil)); _ -> mochi_nth(maps:get("head_idx", Ll, nil) + 1, maps:get("nodes", Ll, nil)) end end),
        maps:get("data", Node, nil)
    catch {return, RetCatch} -> RetCatch end.

get_tail_data(Ll_2) ->
    try
        case (maps:get("tail_idx", Ll_2, nil) == -1) of
        true -> throw({return, -1});
        _ -> ok
    end,
        Node_2 = (case erlang:is_map(maps:get("nodes", Ll_2, nil)) of true -> maps:get(maps:get("tail_idx", Ll_2, nil), maps:get("nodes", Ll_2, nil), nil); _ -> case maps:get("tail_idx", Ll_2, nil) < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_2, nil)) + maps:get("tail_idx", Ll_2, nil) + 1, maps:get("nodes", Ll_2, nil)); _ -> mochi_nth(maps:get("tail_idx", Ll_2, nil) + 1, maps:get("nodes", Ll_2, nil)) end end),
        maps:get("data", Node_2, nil)
    catch {return, RetCatch} -> RetCatch end.

insert_before_node(Ll_3, Idx, New_idx) ->
    try
        Nodes = maps:get("nodes", Ll_3, nil),
        New_node = (case erlang:is_map(Nodes) of true -> maps:get(New_idx, Nodes, nil); _ -> case New_idx < 0 of true -> mochi_nth(erlang:length(Nodes) + New_idx + 1, Nodes); _ -> mochi_nth(New_idx + 1, Nodes) end end),
        New_node_2 = maps:put("next_index", Idx, New_node),
        Node_3 = (case erlang:is_map(Nodes) of true -> maps:get(Idx, Nodes, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Nodes) + Idx + 1, Nodes); _ -> mochi_nth(Idx + 1, Nodes) end end),
        P = maps:get("prev_index", Node_3, nil),
        New_node_3 = maps:put("prev_index", P, New_node_2),
        Nodes_2 = lists:sublist(Nodes, New_idx) ++ [New_node_3] ++ lists:nthtail(New_idx + 1, Nodes),
        Prev_node_3 = (case (P == -1) of
        true -> Ll_4 = maps:put("head_idx", New_idx, Ll_3),
            Ll_5 = Ll_4,
            Nodes_4 = Nodes_2,
            nil;
        _ -> Prev_node = (case erlang:is_map(Nodes_2) of true -> maps:get(P, Nodes_2, nil); _ -> case P < 0 of true -> mochi_nth(erlang:length(Nodes_2) + P + 1, Nodes_2); _ -> mochi_nth(P + 1, Nodes_2) end end),
            Prev_node_2 = maps:put("next_index", New_idx, Prev_node),
            Nodes_3 = lists:sublist(Nodes_2, P) ++ [Prev_node_2] ++ lists:nthtail(P + 1, Nodes_2),
            Ll_5 = Ll_3,
            Nodes_4 = Nodes_3,
            Prev_node_2
    end),
        Node_4 = maps:put("prev_index", New_idx, Node_3),
        Nodes_5 = lists:sublist(Nodes_4, Idx) ++ [Node_4] ++ lists:nthtail(Idx + 1, Nodes_4),
        Ll_6 = maps:put("nodes", Nodes_5, Ll_5),
        {nil, Ll_6}
    catch {return, RetCatch} -> RetCatch end.

insert_after_node(Ll_7, Idx_2, New_idx_2) ->
    try
        Nodes_6 = maps:get("nodes", Ll_7, nil),
        New_node_4 = (case erlang:is_map(Nodes_6) of true -> maps:get(New_idx_2, Nodes_6, nil); _ -> case New_idx_2 < 0 of true -> mochi_nth(erlang:length(Nodes_6) + New_idx_2 + 1, Nodes_6); _ -> mochi_nth(New_idx_2 + 1, Nodes_6) end end),
        New_node_5 = maps:put("prev_index", Idx_2, New_node_4),
        Node_5 = (case erlang:is_map(Nodes_6) of true -> maps:get(Idx_2, Nodes_6, nil); _ -> case Idx_2 < 0 of true -> mochi_nth(erlang:length(Nodes_6) + Idx_2 + 1, Nodes_6); _ -> mochi_nth(Idx_2 + 1, Nodes_6) end end),
        Nxt = maps:get("next_index", Node_5, nil),
        New_node_6 = maps:put("next_index", Nxt, New_node_5),
        Nodes_7 = lists:sublist(Nodes_6, New_idx_2) ++ [New_node_6] ++ lists:nthtail(New_idx_2 + 1, Nodes_6),
        Nodes_9 = (case (Nxt == -1) of
        true -> Ll_8 = maps:put("tail_idx", New_idx_2, Ll_7),
            Ll_9 = Ll_8,
            Next_node_3 = nil,
            Nodes_7;
        _ -> Next_node = (case erlang:is_map(Nodes_7) of true -> maps:get(Nxt, Nodes_7, nil); _ -> case Nxt < 0 of true -> mochi_nth(erlang:length(Nodes_7) + Nxt + 1, Nodes_7); _ -> mochi_nth(Nxt + 1, Nodes_7) end end),
            Next_node_2 = maps:put("prev_index", New_idx_2, Next_node),
            Nodes_8 = lists:sublist(Nodes_7, Nxt) ++ [Next_node_2] ++ lists:nthtail(Nxt + 1, Nodes_7),
            Ll_9 = Ll_7,
            Next_node_3 = Next_node_2,
            Nodes_8
    end),
        Node_6 = maps:put("next_index", New_idx_2, Node_5),
        Nodes_10 = lists:sublist(Nodes_9, Idx_2) ++ [Node_6] ++ lists:nthtail(Idx_2 + 1, Nodes_9),
        Ll_10 = maps:put("nodes", Nodes_10, Ll_9),
        {nil, Ll_10}
    catch {return, RetCatch} -> RetCatch end.

set_head(Ll_11, Idx_3) ->
    try
        Ll_res_2 = (case (maps:get("head_idx", Ll_11, nil) == -1) of
        true -> Ll_12 = maps:put("head_idx", Idx_3, Ll_11),
            Ll_13 = maps:put("tail_idx", Idx_3, Ll_12),
            Ll_15 = Ll_13,
            nil;
        _ -> Ll_res = insert_before_node(Ll_11, maps:get("head_idx", Ll_11, nil), Idx_3),
            Ll_14 = element(2, Ll_res),
            Ll_15 = Ll_14,
            Ll_res
    end),
        nil
    catch {return, RetCatch} -> RetCatch end.

set_tail(Ll_16, Idx_4) ->
    try
        Ll_res_4 = (case (maps:get("tail_idx", Ll_16, nil) == -1) of
        true -> Ll_17 = maps:put("head_idx", Idx_4, Ll_16),
            Ll_18 = maps:put("tail_idx", Idx_4, Ll_17),
            Ll_20 = Ll_18,
            nil;
        _ -> Ll_res_3 = insert_after_node(Ll_16, maps:get("tail_idx", Ll_16, nil), Idx_4),
            Ll_19 = element(2, Ll_res_3),
            Ll_20 = Ll_19,
            Ll_res_3
    end),
        nil
    catch {return, RetCatch} -> RetCatch end.

insert(Ll_21, Value) ->
    try
        Nodes_11 = maps:get("nodes", Ll_21, nil),
        Nodes_12 = lists:append((case Nodes_11 of nil -> []; _ -> Nodes_11 end), [#{"data" => Value, "prev_index" => -1, "next_index" => -1}]),
        Idx_5 = (erlang:length(Nodes_12) - 1),
        Ll_22 = maps:put("nodes", Nodes_12, Ll_21),
        Ll_res_6 = (case (maps:get("head_idx", Ll_22, nil) == -1) of
        true -> Ll_23 = maps:put("head_idx", Idx_5, Ll_22),
            Ll_24 = maps:put("tail_idx", Idx_5, Ll_23),
            Ll_26 = Ll_24,
            nil;
        _ -> Ll_res_5 = insert_after_node(Ll_22, maps:get("tail_idx", Ll_22, nil), Idx_5),
            Ll_25 = element(2, Ll_res_5),
            Ll_26 = Ll_25,
            Ll_res_5
    end),
        {nil, Ll_26}
    catch {return, RetCatch} -> RetCatch end.

insert_at_position(Ll_27, Position, Value_2) ->
    try
        Current = maps:get("head_idx", Ll_27, nil),
        Current_pos = 1,
        Fun = fun Fun_loop(Current, Current_pos, Ll_27, Position, Value_2) ->
    case (Current /= -1) of
        true ->
            Nodes_15 = (case (Current_pos == Position) of
        true -> Nodes_13 = maps:get("nodes", Ll_27, nil),
            Nodes_14 = lists:append((case Nodes_13 of nil -> []; _ -> Nodes_13 end), [#{"data" => Value_2, "prev_index" => -1, "next_index" => -1}]),
            New_idx_3 = (erlang:length(Nodes_14) - 1),
            Ll_28 = maps:put("nodes", Nodes_14, Ll_27),
            Ll_res_7 = insert_before_node(Ll_28, Current, New_idx_3),
            Ll_29 = element(2, Ll_res_7),
            throw({return, Ll_29}),
            Ll_30 = Ll_29,
            Ll_res_8 = Ll_res_7,
            New_idx_4 = New_idx_3,
            Nodes_14;
        _ -> Ll_30 = Ll_27,
            Ll_res_8 = nil,
            New_idx_4 = nil,
            nil
    end),
            Node_7 = (case erlang:is_map(maps:get("nodes", Ll_30, nil)) of true -> maps:get(Current, maps:get("nodes", Ll_30, nil), nil); _ -> case Current < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_30, nil)) + Current + 1, maps:get("nodes", Ll_30, nil)); _ -> mochi_nth(Current + 1, maps:get("nodes", Ll_30, nil)) end end),
            Current_2 = maps:get("next_index", Node_7, nil),
            Current_pos_2 = (Current_pos + 1),
            Fun_loop(Current_2, Current_pos_2, Ll_30, Position, Value_2);
        _ -> {Current, Current_pos, Ll_27, Position, Value_2}
    end
end,
{Current_2, Current_pos_2, Ll_30, Position, Value_2} = Fun(Current, Current_pos, Ll_27, Position, Value_2),
        Ll_30_res = insert(Ll_30, Value_2),
        Ll_30 = element(2, Ll_30_res),
        nil
    catch {return, RetCatch} -> RetCatch end.

get_node(Ll_31, Item) ->
    try
        Current_3 = maps:get("head_idx", Ll_31, nil),
        Fun_2 = fun Fun_2_loop(Current_3, Item, Ll_31) ->
    case (Current_3 /= -1) of
        true ->
            Node_8 = (case erlang:is_map(maps:get("nodes", Ll_31, nil)) of true -> maps:get(Current_3, maps:get("nodes", Ll_31, nil), nil); _ -> case Current_3 < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_31, nil)) + Current_3 + 1, maps:get("nodes", Ll_31, nil)); _ -> mochi_nth(Current_3 + 1, maps:get("nodes", Ll_31, nil)) end end),
            case (maps:get("data", Node_8, nil) == Item) of
        true -> throw({return, Current_3});
        _ -> ok
    end,
            Current_4 = maps:get("next_index", Node_8, nil),
            Fun_2_loop(Current_4, Item, Ll_31);
        _ -> {Current_3, Item, Ll_31}
    end
end,
{Current_4, Item, Ll_31} = Fun_2(Current_3, Item, Ll_31),
        -1
    catch {return, RetCatch} -> RetCatch end.

remove_node_pointers(Ll_32, Idx_6) ->
    try
        Nodes_16 = maps:get("nodes", Ll_32, nil),
        Node_9 = (case erlang:is_map(Nodes_16) of true -> maps:get(Idx_6, Nodes_16, nil); _ -> case Idx_6 < 0 of true -> mochi_nth(erlang:length(Nodes_16) + Idx_6 + 1, Nodes_16); _ -> mochi_nth(Idx_6 + 1, Nodes_16) end end),
        Nxt_2 = maps:get("next_index", Node_9, nil),
        P_2 = maps:get("prev_index", Node_9, nil),
        Nxt_node_3 = (case (Nxt_2 /= -1) of
        true -> Nxt_node = (case erlang:is_map(Nodes_16) of true -> maps:get(Nxt_2, Nodes_16, nil); _ -> case Nxt_2 < 0 of true -> mochi_nth(erlang:length(Nodes_16) + Nxt_2 + 1, Nodes_16); _ -> mochi_nth(Nxt_2 + 1, Nodes_16) end end),
            Nxt_node_2 = maps:put("prev_index", P_2, Nxt_node),
            Nodes_17 = lists:sublist(Nodes_16, Nxt_2) ++ [Nxt_node_2] ++ lists:nthtail(Nxt_2 + 1, Nodes_16),
            Nodes_18 = Nodes_17,
            Nxt_node_2;
        _ -> Nodes_18 = Nodes_16,
            nil
    end),
        Prev_node_6 = (case (P_2 /= -1) of
        true -> Prev_node_4 = (case erlang:is_map(Nodes_18) of true -> maps:get(P_2, Nodes_18, nil); _ -> case P_2 < 0 of true -> mochi_nth(erlang:length(Nodes_18) + P_2 + 1, Nodes_18); _ -> mochi_nth(P_2 + 1, Nodes_18) end end),
            Prev_node_5 = maps:put("next_index", Nxt_2, Prev_node_4),
            Nodes_19 = lists:sublist(Nodes_18, P_2) ++ [Prev_node_5] ++ lists:nthtail(P_2 + 1, Nodes_18),
            Nodes_20 = Nodes_19,
            Prev_node_5;
        _ -> Nodes_20 = Nodes_18,
            nil
    end),
        Node_10 = maps:put("next_index", -1, Node_9),
        Node_11 = maps:put("prev_index", -1, Node_10),
        Nodes_21 = lists:sublist(Nodes_20, Idx_6) ++ [Node_11] ++ lists:nthtail(Idx_6 + 1, Nodes_20),
        Ll_33 = maps:put("nodes", Nodes_21, Ll_32),
        {nil, Ll_33}
    catch {return, RetCatch} -> RetCatch end.

delete_value(Ll_34, Value_3) ->
    try
        Idx_7 = get_node(Ll_34, Value_3),
        case (Idx_7 == -1) of
        true -> throw({return, nil});
        _ -> ok
    end,
        Node_13 = (case (Idx_7 == maps:get("head_idx", Ll_34, nil)) of
        true -> Node_12 = (case erlang:is_map(maps:get("nodes", Ll_34, nil)) of true -> maps:get(Idx_7, maps:get("nodes", Ll_34, nil), nil); _ -> case Idx_7 < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_34, nil)) + Idx_7 + 1, maps:get("nodes", Ll_34, nil)); _ -> mochi_nth(Idx_7 + 1, maps:get("nodes", Ll_34, nil)) end end),
            Ll_35 = maps:put("head_idx", maps:get("next_index", Node_12, nil), Ll_34),
            Ll_36 = Ll_35,
            Node_12;
        _ -> Ll_36 = Ll_34,
            nil
    end),
        Node_15 = (case (Idx_7 == maps:get("tail_idx", Ll_36, nil)) of
        true -> Node_14 = (case erlang:is_map(maps:get("nodes", Ll_36, nil)) of true -> maps:get(Idx_7, maps:get("nodes", Ll_36, nil), nil); _ -> case Idx_7 < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_36, nil)) + Idx_7 + 1, maps:get("nodes", Ll_36, nil)); _ -> mochi_nth(Idx_7 + 1, maps:get("nodes", Ll_36, nil)) end end),
            Ll_37 = maps:put("tail_idx", maps:get("prev_index", Node_14, nil), Ll_36),
            Ll_38 = Ll_37,
            Node_14;
        _ -> Ll_38 = Ll_36,
            Node_13
    end),
        Ll_res_9 = remove_node_pointers(Ll_38, Idx_7),
        Ll_39 = element(2, Ll_res_9),
        {nil, Ll_39}
    catch {return, RetCatch} -> RetCatch end.

contains(Ll_40, Value_4) ->
    try
        (get_node(Ll_40, Value_4) /= -1)
    catch {return, RetCatch} -> RetCatch end.

is_empty(Ll_41) ->
    try
        (maps:get("head_idx", Ll_41, nil) == -1)
    catch {return, RetCatch} -> RetCatch end.

to_string(Ll_42) ->
    try
        Res = "",
        First = true,
        Current_5 = maps:get("head_idx", Ll_42, nil),
        Fun_3 = fun Fun_3_loop(Current_5, First, Ll_42, Res) ->
    case (Current_5 /= -1) of
        true ->
            Node_16 = (case erlang:is_map(maps:get("nodes", Ll_42, nil)) of true -> maps:get(Current_5, maps:get("nodes", Ll_42, nil), nil); _ -> case Current_5 < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_42, nil)) + Current_5 + 1, maps:get("nodes", Ll_42, nil)); _ -> mochi_nth(Current_5 + 1, maps:get("nodes", Ll_42, nil)) end end),
            Val = mochi_str(maps:get("data", Node_16, nil)),
            Res_4 = (case First of
        true -> Res_2 = Val,
            First_2 = false,
            First_3 = First_2,
            Res_2;
        _ -> Res_3 = ((Res ++ " ") ++ Val),
            First_3 = First,
            Res_3
    end),
            Current_6 = maps:get("next_index", Node_16, nil),
            Fun_3_loop(Current_6, First_3, Ll_42, Res_4);
        _ -> {Current_5, First, Ll_42, Res}
    end
end,
{Current_6, First_3, Ll_42, Res_4} = Fun_3(Current_5, First, Ll_42, Res),
        Res_4
    catch {return, RetCatch} -> RetCatch end.

print_list(Ll_43) ->
    try
        Current_7 = maps:get("head_idx", Ll_43, nil),
        Fun_4 = fun Fun_4_loop(Current_7, Ll_43) ->
    case (Current_7 /= -1) of
        true ->
            Node_17 = (case erlang:is_map(maps:get("nodes", Ll_43, nil)) of true -> maps:get(Current_7, maps:get("nodes", Ll_43, nil), nil); _ -> case Current_7 < 0 of true -> mochi_nth(erlang:length(maps:get("nodes", Ll_43, nil)) + Current_7 + 1, maps:get("nodes", Ll_43, nil)); _ -> mochi_nth(Current_7 + 1, maps:get("nodes", Ll_43, nil)) end end),
            io:format("~s~n", [mochi_str(maps:get("data", Node_17, nil))]),
            Current_8 = maps:get("next_index", Node_17, nil),
            Fun_4_loop(Current_8, Ll_43);
        _ -> {Current_7, Ll_43}
    end
end,
{Current_8, Ll_43} = Fun_4(Current_7, Ll_43),
        nil
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Ll_44 = empty_list(),
        io:format("~s~n", [mochi_str(get_head_data(Ll_44))]),
        io:format("~s~n", [mochi_str(get_tail_data(Ll_44))]),
        io:format("~s~n", [mochi_str(is_empty(Ll_44))]),
        Ll_res_10 = insert(Ll_44, 10),
        Ll_45 = element(2, Ll_res_10),
        io:format("~s~n", [mochi_str(get_head_data(Ll_45))]),
        io:format("~s~n", [mochi_str(get_tail_data(Ll_45))]),
        insert_at_position(Ll_45, 3, 20),
        io:format("~s~n", [mochi_str(get_head_data(Ll_45))]),
        io:format("~s~n", [mochi_str(get_tail_data(Ll_45))]),
        Nodes_22 = maps:get("nodes", Ll_45, nil),
        Nodes_23 = lists:append((case Nodes_22 of nil -> []; _ -> Nodes_22 end), [#{"data" => 1000, "prev_index" => -1, "next_index" => -1}]),
        Idx_head = (erlang:length(Nodes_23) - 1),
        Ll_46 = maps:put("nodes", Nodes_23, Ll_45),
        set_head(Ll_46, Idx_head),
        Nodes_24 = maps:get("nodes", Ll_46, nil),
        Nodes_25 = lists:append((case Nodes_24 of nil -> []; _ -> Nodes_24 end), [#{"data" => 2000, "prev_index" => -1, "next_index" => -1}]),
        Idx_tail = (erlang:length(Nodes_25) - 1),
        Ll_47 = maps:put("nodes", Nodes_25, Ll_46),
        set_tail(Ll_47, Idx_tail),
        print_list(Ll_47),
        io:format("~s~n", [mochi_str(is_empty(Ll_47))]),
        print_list(Ll_47),
        io:format("~s~n", [mochi_str(mochi_member(10, Ll_47))]),
        Ll_res_11 = delete_value(Ll_47, 10),
        Ll_48 = element(2, Ll_res_11),
        io:format("~s~n", [mochi_str(mochi_member(10, Ll_48))]),
        Ll_res_12 = delete_value(Ll_48, 2000),
        Ll_49 = element(2, Ll_res_12),
        io:format("~s~n", [mochi_str(get_tail_data(Ll_49))]),
        Ll_res_13 = delete_value(Ll_49, 1000),
        Ll_50 = element(2, Ll_res_13),
        io:format("~s~n", [mochi_str(get_tail_data(Ll_50))]),
        io:format("~s~n", [mochi_str(get_head_data(Ll_50))]),
        print_list(Ll_50),
        Ll_res_14 = delete_value(Ll_50, 20),
        Ll_51 = element(2, Ll_res_14),
        print_list(Ll_51),
        I = 1,
        Fun_5 = fun Fun_5_loop(I, Idx_head, Idx_tail, Ll_51, Ll_res_14, Nodes_25) ->
    case (I < 10) of
        true ->
            Ll_res_15 = insert(Ll_51, I),
            Ll_52 = element(2, Ll_res_15),
            I_2 = (I + 1),
            Fun_5_loop(I_2, Idx_head, Idx_tail, Ll_52, Ll_res_15, Nodes_25);
        _ -> {I, Idx_head, Idx_tail, Ll_51, Ll_res_14, Nodes_25}
    end
end,
{I_2, Idx_head, Idx_tail, Ll_52, Ll_res_15, Nodes_25} = Fun_5(I, Idx_head, Idx_tail, Ll_51, Ll_res_14, Nodes_25),
        print_list(Ll_52),
        Ll2 = empty_list(),
        insert_at_position(Ll2, 1, 10),
        io:format("~s~n", [mochi_format(to_string(Ll2))]),
        insert_at_position(Ll2, 2, 20),
        io:format("~s~n", [mochi_format(to_string(Ll2))]),
        insert_at_position(Ll2, 1, 30),
        io:format("~s~n", [mochi_format(to_string(Ll2))]),
        insert_at_position(Ll2, 3, 40),
        io:format("~s~n", [mochi_format(to_string(Ll2))]),
        insert_at_position(Ll2, 5, 50),
        io:format("~s~n", [mochi_format(to_string(Ll2))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~p~n", [Err])
    end.
