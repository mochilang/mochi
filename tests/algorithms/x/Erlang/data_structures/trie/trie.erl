#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, new_trie/0, remove_key/2, insert/2, insert_many/2, find/2, delete/2, print_words/1, test_trie/0, print_results/2]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

new_trie() ->
    try
        #{"nodes" => [#{"children" => #{}, "is_leaf" => false}]}
    catch {return, Ret} -> Ret end.

remove_key(M, K) ->
    try
        Out = #{},
        Fun = fun Fun_loop(List, K, M, Out) ->
    case List of
        [] -> {K, M, Out};
        [Key|Key_rest] ->
            case (Key /= K) of
        true -> Out_2 = maps:put(Key, maps:get(Key, M, nil), Out),
            Out_3 = Out_2;
        _ -> Out_3 = Out
    end,
            Fun_loop(Key_rest, K, M, Out_3);
        _ -> {K, M, Out}
    end
end,
{K, M, Out_3} = Fun(maps:keys(M), K, M, Out),
        Out_3
    catch {return, Ret} -> Ret end.

insert(Trie, Word) ->
    try
        Nodes = maps:get("nodes", Trie, nil),
        Curr = 0,
        I = 0,
        Fun_2 = fun Fun_2_loop(Curr, I, Nodes, Trie, Word) ->
    case (I < erlang:length(Word)) of
        true ->
            Ch = string:substr(Word, I + 1, 1),
            Child_idx = -1,
            Children = maps:get("children", (case erlang:is_map(Nodes) of true -> maps:get(Curr, Nodes, nil); _ -> lists:nth(Curr + 1, Nodes) end), nil),
            case maps:is_key(Ch, Children) of
        true -> Child_idx_2 = maps:get(Ch, Children, nil),
            Child_idx_4 = Child_idx_2,
            New_children_3 = nil,
            New_node_2 = nil,
            Node_3 = nil,
            Nodes_4 = Nodes;
        _ -> New_node = #{"children" => #{}, "is_leaf" => false},
            Nodes_2 = lists:append((case Nodes of nil -> []; _ -> Nodes end), [New_node]),
            Child_idx_3 = (erlang:length(Nodes_2) - 1),
            New_children = Children,
            New_children_2 = maps:put(Ch, Child_idx_3, New_children),
            Node = (case erlang:is_map(Nodes_2) of true -> maps:get(Curr, Nodes_2, nil); _ -> lists:nth(Curr + 1, Nodes_2) end),
            Node_2 = maps:put("children", New_children_2, Node),
            Nodes_3 = lists:sublist(Nodes_2, Curr) ++ [Node_2] ++ lists:nthtail(Curr + 1, Nodes_2),
            Child_idx_4 = Child_idx_3,
            New_children_3 = New_children_2,
            New_node_2 = New_node,
            Node_3 = Node_2,
            Nodes_4 = Nodes_3
    end,
            Curr_2 = Child_idx_4,
            I_2 = (I + 1),
            Fun_2_loop(Curr_2, I_2, Nodes_4, Trie, Word);
        _ -> {Curr, I, Nodes, Trie, Word}
    end
end,
{Curr_2, I_2, Nodes_4, Trie, Word} = Fun_2(Curr, I, Nodes, Trie, Word),
        Node_4 = (case erlang:is_map(Nodes_4) of true -> maps:get(Curr_2, Nodes_4, nil); _ -> lists:nth(Curr_2 + 1, Nodes_4) end),
        Node_5 = maps:put("is_leaf", true, Node_4),
        Nodes_5 = lists:sublist(Nodes_4, Curr_2) ++ [Node_5] ++ lists:nthtail(Curr_2 + 1, Nodes_4),
        Trie_2 = maps:put("nodes", Nodes_5, Trie),
        {nil, Trie_2}
    catch {return, Ret} -> Ret end.

insert_many(Trie_3, Words) ->
    try
        Fun_3 = fun Fun_3_loop(List, Trie_3, Words) ->
    case List of
        [] -> {Trie_3, Words};
        [W|W_rest] ->
            {_, Trie_4} = insert(Trie_3, W),
            Fun_3_loop(W_rest, Trie_4, Words);
        _ -> {Trie_3, Words}
    end
end,
{Trie_4, Words} = Fun_3(Words, Trie_3, Words),
        {nil, Trie_4}
    catch {return, Ret} -> Ret end.

find(Trie_5, Word_2) ->
    try
        Nodes_6 = maps:get("nodes", Trie_5, nil),
        Curr_3 = 0,
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Curr_3, I_3, Nodes_6, Trie_5, Word_2) ->
    case (I_3 < erlang:length(Word_2)) of
        true ->
            Ch_2 = string:substr(Word_2, I_3 + 1, 1),
            Children_2 = maps:get("children", (case erlang:is_map(Nodes_6) of true -> maps:get(Curr_3, Nodes_6, nil); _ -> lists:nth(Curr_3 + 1, Nodes_6) end), nil),
            case mochi_not(maps:is_key(Ch_2, Children_2)) of
        true -> throw({return, false});
        _ -> ok
    end,
            Curr_4 = maps:get(Ch_2, Children_2, nil),
            I_4 = (I_3 + 1),
            Fun_4_loop(Curr_4, I_4, Nodes_6, Trie_5, Word_2);
        _ -> {Curr_3, I_3, Nodes_6, Trie_5, Word_2}
    end
end,
{Curr_4, I_4, Nodes_6, Trie_5, Word_2} = Fun_4(Curr_3, I_3, Nodes_6, Trie_5, Word_2),
        Node_6 = (case erlang:is_map(Nodes_6) of true -> maps:get(Curr_4, Nodes_6, nil); _ -> lists:nth(Curr_4 + 1, Nodes_6) end),
        maps:get("is_leaf", Node_6, nil)
    catch {return, Ret} -> Ret end.

delete(Trie_6, Word_3) ->
    try
        Nodes_7 = maps:get("nodes", Trie_6, nil),
        _delete = fun _delete(Idx, Pos) ->
    try
        case (Pos == erlang:length(Word_3)) of
        true -> Node_7 = (case erlang:is_map(Nodes_7) of true -> maps:get(Idx, Nodes_7, nil); _ -> lists:nth(Idx + 1, Nodes_7) end),
            case (maps:get("is_leaf", Node_7, nil) == false) of
        true -> throw({return, false});
        _ -> ok
    end,
            Node_8 = maps:put("is_leaf", false, Node_7),
            Nodes_8 = lists:sublist(Nodes_7, Idx) ++ [Node_8] ++ lists:nthtail(Idx + 1, Nodes_7),
            throw({return, (maps:size(maps:get("children", Node_8, nil)) == 0)}),
            Node_9 = Node_8,
            Nodes_9 = Nodes_8;
        _ -> Node_9 = nil,
            Nodes_9 = Nodes_7
    end,
        Node_10 = (case erlang:is_map(Nodes_9) of true -> maps:get(Idx, Nodes_9, nil); _ -> lists:nth(Idx + 1, Nodes_9) end),
        Children_3 = maps:get("children", Node_10, nil),
        Ch_3 = string:substr(Word_3, Pos + 1, 1),
        case mochi_not(maps:is_key(Ch_3, Children_3)) of
        true -> throw({return, false});
        _ -> ok
    end,
        Child_idx_5 = maps:get(Ch_3, Children_3, nil),
        Should_delete = _delete(Child_idx_5, (Pos + 1)),
        Node_11 = (case erlang:is_map(Nodes_9) of true -> maps:get(Idx, Nodes_9, nil); _ -> lists:nth(Idx + 1, Nodes_9) end),
        case (Should_delete /= nil) of
        true -> New_children_4 = remove_key(maps:get("children", Node_11, nil), Ch_3),
            Node_12 = maps:put("children", New_children_4, Node_11),
            Nodes_10 = lists:sublist(Nodes_9, Idx) ++ [Node_12] ++ lists:nthtail(Idx + 1, Nodes_9),
            throw({return, ((maps:size(New_children_4) == 0) andalso (maps:get("is_leaf", Node_12, nil) == false))}),
            New_children_5 = New_children_4,
            Node_13 = Node_12,
            Nodes_11 = Nodes_10;
        _ -> New_children_5 = nil,
            Node_13 = Node_11,
            Nodes_11 = Nodes_9
    end,
        Nodes_12 = lists:sublist(Nodes_11, Idx) ++ [Node_13] ++ lists:nthtail(Idx + 1, Nodes_11),
        false
    catch {return, Ret} -> Ret end
end,
        _delete(0, 0),
        Trie_7 = maps:put("nodes", Nodes_7, Trie_6),
        {nil, Trie_7}
    catch {return, Ret} -> Ret end.

print_words(Trie_8) ->
    try
        Dfs = fun Dfs(Idx_2, Word_4) ->
    try
        Node_14 = (case erlang:is_map(maps:get("nodes", Trie_8, nil)) of true -> maps:get(Idx_2, maps:get("nodes", Trie_8, nil), nil); _ -> lists:nth(Idx_2 + 1, maps:get("nodes", Trie_8, nil)) end),
        case maps:get("is_leaf", Node_14, nil) of
        true -> io:format("~ts~n", [mochi_repr(Word_4)]);
        _ -> ok
    end,
        Fun_5 = fun Fun_5_loop(List, Dfs, Idx_2, Node_14, Trie_8, Word_4) ->
    case List of
        [] -> {Dfs, Idx_2, Node_14, Trie_8, Word_4};
        [Key_2|Key_2_rest] ->
            Dfs(maps:get(Key_2, maps:get("children", Node_14, nil), nil), (Word_4 + Key_2)),
            Fun_5_loop(Key_2_rest, Dfs, Idx_2, Node_14, Trie_8, Word_4);
        _ -> {Dfs, Idx_2, Node_14, Trie_8, Word_4}
    end
end,
{Dfs, Idx_2, Node_14, Trie_8, Word_4} = Fun_5(maps:keys(maps:get("children", Node_14, nil)), Dfs, Idx_2, Node_14, Trie_8, Word_4),
        nil
    catch {return, Ret} -> Ret end
end,
        Dfs(0, ""),
        nil
    catch {return, Ret} -> Ret end.

test_trie() ->
    try
        Words_2 = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"],
        Trie_9 = new_trie(),
        {_, Trie_10} = insert_many(Trie_9, Words_2),
        Ok = true,
        Fun_6 = fun Fun_6_loop(List, Ok, Trie_10, Words_2) ->
    case List of
        [] -> {Ok, Trie_10, Words_2};
        [W_2|W_2_rest] ->
            Ok_2 = (Ok andalso find(Trie_10, W_2)),
            Fun_6_loop(W_2_rest, Ok_2, Trie_10, Words_2);
        _ -> {Ok, Trie_10, Words_2}
    end
end,
{Ok_2, Trie_10, Words_2} = Fun_6(Words_2, Ok, Trie_10, Words_2),
        Ok_3 = (Ok_2 andalso find(Trie_10, "banana")),
        T = find(Trie_10, "bandanas"),
        Ok_4 = (Ok_3 andalso (T == false)),
        T2 = find(Trie_10, "apps"),
        Ok_5 = (Ok_4 andalso (T2 == false)),
        Ok_6 = (Ok_5 andalso find(Trie_10, "apple")),
        Ok_7 = (Ok_6 andalso find(Trie_10, "all")),
        {_, Trie_11} = delete(Trie_10, "all"),
        T3 = find(Trie_11, "all"),
        Ok_8 = (Ok_7 andalso (T3 == false)),
        {_, Trie_12} = delete(Trie_11, "banana"),
        T4 = find(Trie_12, "banana"),
        Ok_9 = (Ok_8 andalso (T4 == false)),
        Ok_10 = (Ok_9 andalso find(Trie_12, "bananas")),
        Ok_10
    catch {return, Ret} -> Ret end.

print_results(Msg, Passes) ->
    try
        case Passes of
        true -> io:format("~ts~n", [mochi_repr((Msg ++ " works!"))]);
        _ -> io:format("~ts~n", [mochi_repr((Msg ++ " doesn't work :("))])
    end,
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('trie', new_trie()),
    print_results("Testing trie functionality", test_trie()),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
