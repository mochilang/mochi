#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, new_node/2, new_tree/0, match_prefix/2, insert_many/2, insert/3, find/3, remove_key/2, has_key/2, delete/3, print_tree/3, test_trie/0, pytests/0, main/0]).

% Generated by Mochi transpiler v0.10.59 (9be2afe36e) on 2025-08-07 08:51 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

new_node(Prefix, Is_leaf) ->
    try
        #{"prefix" => Prefix, "is_leaf" => Is_leaf, "children" => #{}}
    catch {return, Ret} -> Ret end.

new_tree() ->
    try
        Nodes = [new_node("", false)],
        #{"nodes" => Nodes}
    catch {return, Ret} -> Ret end.

match_prefix(Node, Word) ->
    try
        X = 0,
        P = maps:get("prefix", Node, nil),
        W = Word,
        Min_len = erlang:length(P),
        case (erlang:length(W) < Min_len) of
        true -> Min_len_2 = erlang:length(W),
            Min_len_3 = Min_len_2;
        _ -> Min_len_3 = Min_len
    end,
        Fun = fun Fun_loop(Min_len_3, Node, P, W, Word, X) ->
    case (X < Min_len_3) of
        true ->
            try
                case (string:substr(P, X + 1, ((X + 1) - X)) /= string:substr(W, X + 1, ((X + 1) - X))) of
        true -> throw({break, Min_len_3, Node, P, W, Word, X});
        _ -> ok
    end,
                X_2 = (X + 1),
                Fun_loop(Min_len_3, Node, P, W, Word, X_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {Min_len_3, Node, P, W, Word, X}
    end
end,
{Min_len_3, Node, P, W, Word, X_2} = Fun(Min_len_3, Node, P, W, Word, X),
        Common = string:substr(P, 0 + 1, (X_2 - 0)),
        Rem_prefix = string:substr(P, X_2 + 1, (erlang:length(P) - X_2)),
        Rem_word = string:substr(W, X_2 + 1, (erlang:length(W) - X_2)),
        #{"common" => Common, "rem_prefix" => Rem_prefix, "rem_word" => Rem_word}
    catch {return, Ret} -> Ret end.

insert_many(Tree, Words) ->
    try
        Fun_2 = fun Fun_2_loop(List, Tree, Words) ->
    case List of
        [] -> {Tree, Words};
        [W_2|W_2_rest] ->
            insert(Tree, 0, W_2),
            Fun_2_loop(W_2_rest, Tree, Words);
        _ -> {Tree, Words}
    end
end,
{Tree, Words} = Fun_2(Words, Tree, Words),
        nil
    catch {return, Ret} -> Ret end.

insert(Tree_2, Idx, Word_2) ->
    try
        Nodes_2 = maps:get("nodes", Tree_2, nil),
        Node_2 = (case erlang:is_map(Nodes_2) of true -> maps:get(Idx, Nodes_2, nil); _ -> lists:nth(Idx + 1, Nodes_2) end),
        case ((maps:get("prefix", Node_2, nil) == Word_2) andalso mochi_not(maps:get("is_leaf", Node_2, nil))) of
        true -> Node_3 = maps:put("is_leaf", true, Node_2),
            Nodes_3 = lists:sublist(Nodes_2, Idx) ++ [Node_3] ++ lists:nthtail(Idx + 1, Nodes_2),
            Tree_3 = maps:put("nodes", Nodes_3, Tree_2),
            throw({return, Tree_3}),
            Node_4 = Node_3,
            Nodes_4 = Nodes_3,
            Tree_4 = Tree_3;
        _ -> Node_4 = Node_2,
            Nodes_4 = Nodes_2,
            Tree_4 = Tree_2
    end,
        First = string:substr(Word_2, 0 + 1, (1 - 0)),
        Children = maps:get("children", Node_4, nil),
        case mochi_not(has_key(Children, First)) of
        true -> New_idx = erlang:length(Nodes_4),
            Nodes_5 = lists:append((case Nodes_4 of nil -> []; _ -> Nodes_4 end), [new_node(Word_2, true)]),
            Children_2 = lists:sublist(Children, First) ++ [New_idx] ++ lists:nthtail(First + 1, Children),
            Node_5 = maps:put("children", Children_2, Node_4),
            Nodes_6 = lists:sublist(Nodes_5, Idx) ++ [Node_5] ++ lists:nthtail(Idx + 1, Nodes_5),
            Tree_5 = maps:put("nodes", Nodes_6, Tree_4),
            throw({return, Tree_5}),
            Children_3 = Children_2,
            New_idx_2 = New_idx,
            Node_6 = Node_5,
            Nodes_7 = Nodes_6,
            Tree_6 = Tree_5;
        _ -> Children_3 = Children,
            New_idx_2 = nil,
            Node_6 = Node_4,
            Nodes_7 = Nodes_4,
            Tree_6 = Tree_4
    end,
        Child_idx = maps:get(First, Children_3, nil),
        Child = (case erlang:is_map(Nodes_7) of true -> maps:get(Child_idx, Nodes_7, nil); _ -> lists:nth(Child_idx + 1, Nodes_7) end),
        Res = match_prefix(Child, Word_2),
        case (maps:get("rem_prefix", Res, nil) == "") of
        true -> insert(Tree_6, Child_idx, maps:get("rem_word", Res, nil)),
            throw({return, nil});
        _ -> ok
    end,
        Child_2 = maps:put("prefix", maps:get("rem_prefix", Res, nil), Child),
        Nodes_8 = lists:sublist(Nodes_7, Child_idx) ++ [Child_2] ++ lists:nthtail(Child_idx + 1, Nodes_7),
        New_children = #{},
        New_children_2 = lists:sublist(New_children, string:substr(maps:get("rem_prefix", Res, nil), 0 + 1, (1 - 0))) ++ [Child_idx] ++ lists:nthtail(string:substr(maps:get("rem_prefix", Res, nil), 0 + 1, (1 - 0)) + 1, New_children),
        New_idx_3 = erlang:length(Nodes_8),
        Nodes_9 = lists:append((case Nodes_8 of nil -> []; _ -> Nodes_8 end), [new_node(maps:get("common", Res, nil), false)]),
        Nodes_10 = lists:sublist(Nodes_9, New_idx_3) ++ [maps:put("children", New_children_2, lists:nth(New_idx_3 + 1, Nodes_9) )] ++ lists:nthtail(New_idx_3 + 1, Nodes_9),
        case (maps:get("rem_word", Res, nil) == "") of
        true -> Nodes_11 = lists:sublist(Nodes_10, New_idx_3) ++ [maps:put("is_leaf", true, lists:nth(New_idx_3 + 1, Nodes_10) )] ++ lists:nthtail(New_idx_3 + 1, Nodes_10),
            Nodes_12 = Nodes_11;
        _ -> insert(Tree_6, New_idx_3, maps:get("rem_word", Res, nil)),
            Nodes_12 = Nodes_10
    end,
        Children_4 = lists:sublist(Children_3, First) ++ [New_idx_3] ++ lists:nthtail(First + 1, Children_3),
        Node_7 = maps:put("children", Children_4, Node_6),
        Nodes_13 = lists:sublist(Nodes_12, Idx) ++ [Node_7] ++ lists:nthtail(Idx + 1, Nodes_12),
        Tree_7 = maps:put("nodes", Nodes_13, Tree_6),
        {nil, Tree_7}
    catch {return, Ret} -> Ret end.

find(Tree_8, Idx_2, Word_3) ->
    try
        Nodes_14 = maps:get("nodes", Tree_8, nil),
        Node_8 = (case erlang:is_map(Nodes_14) of true -> maps:get(Idx_2, Nodes_14, nil); _ -> lists:nth(Idx_2 + 1, Nodes_14) end),
        First_2 = string:substr(Word_3, 0 + 1, (1 - 0)),
        Children_5 = maps:get("children", Node_8, nil),
        case mochi_not(has_key(Children_5, First_2)) of
        true -> throw({return, false});
        _ -> ok
    end,
        Child_idx_2 = maps:get(First_2, Children_5, nil),
        Child_3 = (case erlang:is_map(Nodes_14) of true -> maps:get(Child_idx_2, Nodes_14, nil); _ -> lists:nth(Child_idx_2 + 1, Nodes_14) end),
        Res_2 = match_prefix(Child_3, Word_3),
        case (maps:get("rem_prefix", Res_2, nil) /= "") of
        true -> throw({return, false});
        _ -> ok
    end,
        case (maps:get("rem_word", Res_2, nil) == "") of
        true -> throw({return, maps:get("is_leaf", Child_3, nil)});
        _ -> ok
    end,
        find(Tree_8, Child_idx_2, maps:get("rem_word", Res_2, nil))
    catch {return, Ret} -> Ret end.

remove_key(M, K) ->
    try
        Out = #{},
        Fun_3 = fun Fun_3_loop(List, K, M, Out) ->
    case List of
        [] -> {K, M, Out};
        [Key|Key_rest] ->
            case (Key /= K) of
        true -> Out_2 = lists:sublist(Out, Key) ++ [maps:get(Key, M, nil)] ++ lists:nthtail(Key + 1, Out),
            Out_3 = Out_2;
        _ -> Out_3 = Out
    end,
            Fun_3_loop(Key_rest, K, M, Out_3);
        _ -> {K, M, Out}
    end
end,
{K, M, Out_3} = Fun_3(maps:keys(M), K, M, Out),
        Out_3
    catch {return, Ret} -> Ret end.

has_key(M_2, K_2) ->
    try
        Fun_4 = fun Fun_4_loop(List, K_2, M_2) ->
    case List of
        [] -> {K_2, M_2};
        [Key_2|Key_2_rest] ->
            case (Key_2 == K_2) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_4_loop(Key_2_rest, K_2, M_2);
        _ -> {K_2, M_2}
    end
end,
{K_2, M_2} = Fun_4(maps:keys(M_2), K_2, M_2),
        false
    catch {return, Ret} -> Ret end.

delete(Tree_9, Idx_3, Word_4) ->
    try
        Nodes_15 = maps:get("nodes", Tree_9, nil),
        Node_9 = (case erlang:is_map(Nodes_15) of true -> maps:get(Idx_3, Nodes_15, nil); _ -> lists:nth(Idx_3 + 1, Nodes_15) end),
        First_3 = string:substr(Word_4, 0 + 1, (1 - 0)),
        Children_6 = maps:get("children", Node_9, nil),
        case mochi_not(has_key(Children_6, First_3)) of
        true -> throw({return, false});
        _ -> ok
    end,
        Child_idx_3 = maps:get(First_3, Children_6, nil),
        Child_4 = (case erlang:is_map(Nodes_15) of true -> maps:get(Child_idx_3, Nodes_15, nil); _ -> lists:nth(Child_idx_3 + 1, Nodes_15) end),
        Res_3 = match_prefix(Child_4, Word_4),
        case (maps:get("rem_prefix", Res_3, nil) /= "") of
        true -> throw({return, false});
        _ -> ok
    end,
        case (maps:get("rem_word", Res_3, nil) /= "") of
        true -> Deleted = delete(Tree_9, Child_idx_3, maps:get("rem_word", Res_3, nil)),
            case Deleted of
        true -> Nodes_16 = maps:get("nodes", Tree_9, nil),
            Node_10 = (case erlang:is_map(Nodes_16) of true -> maps:get(Idx_3, Nodes_16, nil); _ -> lists:nth(Idx_3 + 1, Nodes_16) end),
            Node_11 = Node_10,
            Nodes_17 = Nodes_16;
        _ -> Node_11 = Node_9,
            Nodes_17 = Nodes_15
    end,
            throw({return, Deleted}),
            Deleted_2 = Deleted,
            Node_12 = Node_11,
            Nodes_18 = Nodes_17;
        _ -> Deleted_2 = nil,
            Node_12 = Node_9,
            Nodes_18 = Nodes_15
    end,
        case mochi_not(maps:get("is_leaf", Child_4, nil)) of
        true -> throw({return, false});
        _ -> ok
    end,
        case (erlang:length(maps:get("children", Child_4, nil)) == 0) of
        true -> Children_7 = remove_key(Children_6, First_3),
            Node_13 = maps:put("children", Children_7, Node_12),
            Nodes_19 = lists:sublist(Nodes_18, Idx_3) ++ [Node_13] ++ lists:nthtail(Idx_3 + 1, Nodes_18),
            Tree_10 = maps:put("nodes", Nodes_19, Tree_9),
            case ((maps:size(Children_7) == 1) andalso mochi_not(maps:get("is_leaf", Node_13, nil))) of
        true -> Only_key = "",
            Fun_5 = fun Fun_5_loop(List, Child_4, Child_idx_3, Children_7, Deleted_2, First_3, Idx_3, Node_13, Nodes_19, Only_key, Res_3, Tree_10, Word_4) ->
    case List of
        [] -> {Child_4, Child_idx_3, Children_7, Deleted_2, First_3, Idx_3, Node_13, Nodes_19, Only_key, Res_3, Tree_10, Word_4};
        [K_3|K_3_rest] ->
            Only_key_2 = K_3,
            Fun_5_loop(K_3_rest, Child_4, Child_idx_3, Children_7, Deleted_2, First_3, Idx_3, Node_13, Nodes_19, Only_key_2, Res_3, Tree_10, Word_4);
        _ -> {Child_4, Child_idx_3, Children_7, Deleted_2, First_3, Idx_3, Node_13, Nodes_19, Only_key, Res_3, Tree_10, Word_4}
    end
end,
{Child_4, Child_idx_3, Children_7, Deleted_2, First_3, Idx_3, Node_13, Nodes_19, Only_key_2, Res_3, Tree_10, Word_4} = Fun_5(maps:keys(Children_7), Child_4, Child_idx_3, Children_7, Deleted_2, First_3, Idx_3, Node_13, Nodes_19, Only_key, Res_3, Tree_10, Word_4),
            Merge_idx = maps:get(Only_key_2, Children_7, nil),
            Merge_node = (case erlang:is_map(Nodes_19) of true -> maps:get(Merge_idx, Nodes_19, nil); _ -> lists:nth(Merge_idx + 1, Nodes_19) end),
            Node_14 = maps:put("is_leaf", maps:get("is_leaf", Merge_node, nil), Node_13),
            Node_15 = maps:put("prefix", (maps:get("prefix", Node_14, nil) + maps:get("prefix", Merge_node, nil)), Node_14),
            Node_16 = maps:put("children", maps:get("children", Merge_node, nil), Node_15),
            Nodes_20 = lists:sublist(Nodes_19, Idx_3) ++ [Node_16] ++ lists:nthtail(Idx_3 + 1, Nodes_19),
            Tree_11 = maps:put("nodes", Nodes_20, Tree_10),
            Fun_6 = Fun_5,
            Merge_idx_2 = Merge_idx,
            Merge_node_2 = Merge_node,
            Node_17 = Node_16,
            Nodes_21 = Nodes_20,
            Only_key_3 = Only_key_2,
            Tree_12 = Tree_11;
        _ -> Fun_6 = nil,
            Merge_idx_2 = nil,
            Merge_node_2 = nil,
            Node_17 = Node_13,
            Nodes_21 = Nodes_19,
            Only_key_3 = nil,
            Tree_12 = Tree_10
    end,
            Child_10 = Child_4,
            Children_8 = Children_7,
            Fun_9 = Fun_6,
            Merge_idx_5 = Merge_idx_2,
            Merge_node_5 = Merge_node_2,
            Node_18 = Node_17,
            Nodes_25 = Nodes_21,
            Only_key_7 = Only_key_3,
            Tree_16 = Tree_12;
        _ -> case (erlang:length(maps:get("children", Child_4, nil)) > 1) of
        true -> Child_5 = maps:put("is_leaf", false, Child_4),
            Nodes_22 = lists:sublist(Nodes_18, Child_idx_3) ++ [Child_5] ++ lists:nthtail(Child_idx_3 + 1, Nodes_18),
            Tree_13 = maps:put("nodes", Nodes_22, Tree_9),
            Child_9 = Child_5,
            Fun_8 = nil,
            Merge_idx_4 = nil,
            Merge_node_4 = nil,
            Nodes_24 = Nodes_22,
            Only_key_6 = nil,
            Tree_15 = Tree_13;
        _ -> Only_key_4 = "",
            Fun_7 = fun Fun_7_loop(List, Child_4, Child_idx_3, Children_6, Deleted_2, First_3, Idx_3, Node_12, Nodes_18, Only_key_4, Res_3, Tree_9, Word_4) ->
    case List of
        [] -> {Child_4, Child_idx_3, Children_6, Deleted_2, First_3, Idx_3, Node_12, Nodes_18, Only_key_4, Res_3, Tree_9, Word_4};
        [K_4|K_4_rest] ->
            Only_key_5 = K_4,
            Fun_7_loop(K_4_rest, Child_4, Child_idx_3, Children_6, Deleted_2, First_3, Idx_3, Node_12, Nodes_18, Only_key_5, Res_3, Tree_9, Word_4);
        _ -> {Child_4, Child_idx_3, Children_6, Deleted_2, First_3, Idx_3, Node_12, Nodes_18, Only_key_4, Res_3, Tree_9, Word_4}
    end
end,
{Child_4, Child_idx_3, Children_6, Deleted_2, First_3, Idx_3, Node_12, Nodes_18, Only_key_5, Res_3, Tree_9, Word_4} = Fun_7(maps:get("children", Child_4, nil), Child_4, Child_idx_3, Children_6, Deleted_2, First_3, Idx_3, Node_12, Nodes_18, Only_key_4, Res_3, Tree_9, Word_4),
            Merge_idx_3 = maps:get(Only_key_5, maps:get("children", Child_4, nil), nil),
            Merge_node_3 = (case erlang:is_map(Nodes_18) of true -> maps:get(Merge_idx_3, Nodes_18, nil); _ -> lists:nth(Merge_idx_3 + 1, Nodes_18) end),
            Child_6 = maps:put("is_leaf", maps:get("is_leaf", Merge_node_3, nil), Child_4),
            Child_7 = maps:put("prefix", (maps:get("prefix", Child_6, nil) + maps:get("prefix", Merge_node_3, nil)), Child_6),
            Child_8 = maps:put("children", maps:get("children", Merge_node_3, nil), Child_7),
            Nodes_23 = lists:sublist(Nodes_18, Child_idx_3) ++ [Child_8] ++ lists:nthtail(Child_idx_3 + 1, Nodes_18),
            Tree_14 = maps:put("nodes", Nodes_23, Tree_9),
            Child_9 = Child_8,
            Fun_8 = Fun_7,
            Merge_idx_4 = Merge_idx_3,
            Merge_node_4 = Merge_node_3,
            Nodes_24 = Nodes_23,
            Only_key_6 = Only_key_5,
            Tree_15 = Tree_14
    end,
            Child_10 = Child_9,
            Children_8 = Children_6,
            Fun_9 = Fun_8,
            Merge_idx_5 = Merge_idx_4,
            Merge_node_5 = Merge_node_4,
            Node_18 = Node_12,
            Nodes_25 = Nodes_24,
            Only_key_7 = Only_key_6,
            Tree_16 = Tree_15
    end,
        true
    catch {return, Ret} -> Ret end.

print_tree(Tree_17, Idx_4, Height) ->
    try
        Nodes_26 = maps:get("nodes", Tree_17, nil),
        Node_19 = (case erlang:is_map(Nodes_26) of true -> maps:get(Idx_4, Nodes_26, nil); _ -> lists:nth(Idx_4 + 1, Nodes_26) end),
        case (maps:get("prefix", Node_19, nil) /= "") of
        true -> Line = "",
            I = 0,
            Fun_10 = fun Fun_10_loop(Height, I, Idx_4, Line, Node_19, Nodes_26, Tree_17) ->
    case (I < Height) of
        true ->
            Line_2 = (Line ++ "-"),
            I_2 = (I + 1),
            Fun_10_loop(Height, I_2, Idx_4, Line_2, Node_19, Nodes_26, Tree_17);
        _ -> {Height, I, Idx_4, Line, Node_19, Nodes_26, Tree_17}
    end
end,
{Height, I_2, Idx_4, Line_2, Node_19, Nodes_26, Tree_17} = Fun_10(Height, I, Idx_4, Line, Node_19, Nodes_26, Tree_17),
            Line_3 = ((Line_2 ++ " ") ++ maps:get("prefix", Node_19, nil)),
            case maps:get("is_leaf", Node_19, nil) of
        true -> Line_4 = (Line_3 ++ "  (leaf)"),
            Line_5 = Line_4;
        _ -> Line_5 = Line_3
    end,
            io:format("~ts~n", [mochi_repr(Line_5)]),
            Fun_11 = Fun_10,
            I_3 = I_2,
            Line_6 = Line_5;
        _ -> Fun_11 = nil,
            I_3 = nil,
            Line_6 = nil
    end,
        Children_9 = maps:get("children", Node_19, nil),
        Fun_12 = fun Fun_12_loop(List, Children_9, Height, I_3, Idx_4, Line_6, Node_19, Nodes_26, Tree_17) ->
    case List of
        [] -> {Children_9, Height, I_3, Idx_4, Line_6, Node_19, Nodes_26, Tree_17};
        [K_5|K_5_rest] ->
            Child_idx_4 = maps:get(K_5, Children_9, nil),
            print_tree(Tree_17, Child_idx_4, (Height + 1)),
            Fun_12_loop(K_5_rest, Children_9, Height, I_3, Idx_4, Line_6, Node_19, Nodes_26, Tree_17);
        _ -> {Children_9, Height, I_3, Idx_4, Line_6, Node_19, Nodes_26, Tree_17}
    end
end,
{Children_9, Height, I_3, Idx_4, Line_6, Node_19, Nodes_26, Tree_17} = Fun_12(maps:keys(Children_9), Children_9, Height, I_3, Idx_4, Line_6, Node_19, Nodes_26, Tree_17),
        nil
    catch {return, Ret} -> Ret end.

test_trie() ->
    try
        Words_2 = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"],
        Tree_18 = new_tree(),
        insert_many(Tree_18, Words_2),
        Ok = true,
        Fun_13 = fun Fun_13_loop(List, Ok, Tree_18, Words_2) ->
    case List of
        [] -> {Ok, Tree_18, Words_2};
        [W_3|W_3_rest] ->
            case mochi_not(find(Tree_18, 0, W_3)) of
        true -> Ok_2 = false,
            Ok_3 = Ok_2;
        _ -> Ok_3 = Ok
    end,
            Fun_13_loop(W_3_rest, Ok_3, Tree_18, Words_2);
        _ -> {Ok, Tree_18, Words_2}
    end
end,
{Ok_3, Tree_18, Words_2} = Fun_13(Words_2, Ok, Tree_18, Words_2),
        case find(Tree_18, 0, "bandanas") of
        true -> Ok_4 = false,
            Ok_5 = Ok_4;
        _ -> Ok_5 = Ok_3
    end,
        case find(Tree_18, 0, "apps") of
        true -> Ok_6 = false,
            Ok_7 = Ok_6;
        _ -> Ok_7 = Ok_5
    end,
        delete(Tree_18, 0, "all"),
        case find(Tree_18, 0, "all") of
        true -> Ok_8 = false,
            Ok_9 = Ok_8;
        _ -> Ok_9 = Ok_7
    end,
        delete(Tree_18, 0, "banana"),
        case find(Tree_18, 0, "banana") of
        true -> Ok_10 = false,
            Ok_11 = Ok_10;
        _ -> Ok_11 = Ok_9
    end,
        case mochi_not(find(Tree_18, 0, "bananas")) of
        true -> Ok_12 = false,
            Ok_13 = Ok_12;
        _ -> Ok_13 = Ok_11
    end,
        Ok_13
    catch {return, Ret} -> Ret end.

pytests() ->
    try
        case mochi_not(test_trie()) of
        true -> erlang:error("test failed");
        _ -> ok
    end,
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Tree_19 = new_tree(),
        Words_3 = ["banana", "bananas", "bandanas", "bandana", "band", "apple", "all", "beast"],
        insert_many(Tree_19, Words_3),
        io:format("~ts~n", [mochi_repr(("Words: " ++ mochi_str(Words_3)))]),
        io:format("~ts~n", [mochi_repr("Tree:")]),
        print_tree(Tree_19, 0, 0),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
