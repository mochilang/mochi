#!/usr/bin/env escript
-module(main).
-compile([export_vars, nowarn_export_vars, nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, pow2/1, create_sparse/2, lowest_common_ancestor/4, breadth_first_search/5, main/0]).

% Generated by Mochi transpiler v0.10.72 (17da928c0a)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> case V of
                true -> 1;
                false -> 0;
                _ -> list_to_integer(V)
            end
        end
    end.


toi(V) ->
    mochi_to_int(V).


mochi_to_float(V) ->
    case erlang:is_float(V) of
        true -> V;
        _ -> float(V)
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


mochi_format(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false ->
            S = lists:flatten(io_lib:format("~.15f", [V])),
            re:replace(S, "\\.?0+$", "", [global, {return, list}])
    end;
mochi_format(V) when is_integer(V) -> integer_to_list(V);
mochi_format(V) when is_binary(V) -> binary_to_list(V);
mochi_format(V) when is_list(V) -> V;
mochi_format(V) -> lists:flatten(io_lib:format("~p", [V])).


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_list(V) ->
    "[" ++ string:join([mochi_str(E) || E <- V], " ") ++ "]";
mochi_str(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false -> erlang:float_to_list(V, [short])
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

pow2(Exp) ->
    try
        Res = 1,
        I = 0,
        Fun = fun Fun_loop(Exp, I, Res) ->
    case (I < Exp) of
        true ->
            Res_2 = (Res * 2),
            I_2 = (I + 1),
            Fun_loop(Exp, I_2, Res_2);
        _ -> {Exp, I, Res}
    end
end,
{Exp, I_2, Res_2} = Fun(Exp, I, Res),
        Res_2
    catch {return, RetCatch} -> RetCatch end.

create_sparse(Max_node, Parent) ->
    try
        J = 1,
        Fun_3 = fun Fun_3_loop(J, Max_node, Parent) ->
    case (pow2(J) < Max_node) of
        true ->
            I_3 = 1,
            Fun_2 = fun Fun_2_loop(I_3, J, Max_node, Parent) ->
    case (I_3 =< Max_node) of
        true ->
            Parent_2 = lists:sublist(Parent, J) ++ [(lists:sublist(lists:nth(J + 1, Parent), I_3) ++ [(case erlang:is_map((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) of true -> maps:get((case erlang:is_map((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) of true -> maps:get(I_3, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end), nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) + I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)); _ -> mochi_nth(I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) end end), (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end), nil); _ -> case (case erlang:is_map((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) of true -> maps:get(I_3, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end), nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) + I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)); _ -> mochi_nth(I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) end end) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) + (case erlang:is_map((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) of true -> maps:get(I_3, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end), nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) + I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)); _ -> mochi_nth(I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) end end) + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)); _ -> mochi_nth((case erlang:is_map((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) of true -> maps:get(I_3, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end), nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) + I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)); _ -> mochi_nth(I_3 + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) end end) + 1, (case erlang:is_map(Parent) of true -> maps:get((J - 1), Parent, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Parent) + (J - 1) + 1, Parent); _ -> mochi_nth((J - 1) + 1, Parent) end end)) end end)] ++ lists:nthtail(I_3 + 1, lists:nth(J + 1, Parent)))] ++ lists:nthtail(J + 1, Parent),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, J, Max_node, Parent_2);
        _ -> {I_3, J, Max_node, Parent}
    end
end,
{I_4, J, Max_node, Parent_2} = Fun_2(I_3, J, Max_node, Parent),
            J_2 = (J + 1),
            Fun_3_loop(J_2, Max_node, Parent_2);
        _ -> {J, Max_node, Parent}
    end
end,
{J_2, Max_node, Parent_2} = Fun_3(J, Max_node, Parent),
        Parent_2
    catch {return, RetCatch} -> RetCatch end.

lowest_common_ancestor(U, V, Level, Parent_3) ->
    try
        V_3 = (case ((case erlang:is_map(Level) of true -> maps:get(U, Level, nil); _ -> case U < 0 of true -> mochi_nth(erlang:length(Level) + U + 1, Level); _ -> mochi_nth(U + 1, Level) end end) < (case erlang:is_map(Level) of true -> maps:get(V, Level, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(Level) + V + 1, Level); _ -> mochi_nth(V + 1, Level) end end)) of
        true -> Temp = U,
            U_2 = V,
            V_2 = Temp,
            Temp_2 = Temp,
            U_3 = U_2,
            V_2;
        _ -> Temp_2 = nil,
            U_3 = U,
            V
    end),
        I_5 = 18,
        Fun_4 = fun Fun_4_loop(I_5, Level, Parent_3, Temp_2, U_3, V_3) ->
    case (I_5 >= 0) of
        true ->
            U_5 = (case (((case erlang:is_map(Level) of true -> maps:get(U_3, Level, nil); _ -> case U_3 < 0 of true -> mochi_nth(erlang:length(Level) + U_3 + 1, Level); _ -> mochi_nth(U_3 + 1, Level) end end) - pow2(I_5)) >= (case erlang:is_map(Level) of true -> maps:get(V_3, Level, nil); _ -> case V_3 < 0 of true -> mochi_nth(erlang:length(Level) + V_3 + 1, Level); _ -> mochi_nth(V_3 + 1, Level) end end)) of
        true -> U_4 = (case erlang:is_map((case erlang:is_map(Parent_3) of true -> maps:get(I_5, Parent_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_5 + 1, Parent_3); _ -> mochi_nth(I_5 + 1, Parent_3) end end)) of true -> maps:get(U_3, (case erlang:is_map(Parent_3) of true -> maps:get(I_5, Parent_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_5 + 1, Parent_3); _ -> mochi_nth(I_5 + 1, Parent_3) end end), nil); _ -> case U_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent_3) of true -> maps:get(I_5, Parent_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_5 + 1, Parent_3); _ -> mochi_nth(I_5 + 1, Parent_3) end end)) + U_3 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(I_5, Parent_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_5 + 1, Parent_3); _ -> mochi_nth(I_5 + 1, Parent_3) end end)); _ -> mochi_nth(U_3 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(I_5, Parent_3, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_5 + 1, Parent_3); _ -> mochi_nth(I_5 + 1, Parent_3) end end)) end end),
            U_4;
        _ -> U_3
    end),
            I_6 = (I_5 - 1),
            Fun_4_loop(I_6, Level, Parent_3, Temp_2, U_5, V_3);
        _ -> {I_5, Level, Parent_3, Temp_2, U_3, V_3}
    end
end,
{I_6, Level, Parent_3, Temp_2, U_5, V_3} = Fun_4(I_5, Level, Parent_3, Temp_2, U_3, V_3),
        case (U_5 == V_3) of
        true -> throw({return, U_5});
        _ -> ok
    end,
        I_7 = 18,
        Fun_5 = fun Fun_5_loop(I_7, Level, Parent_3, Temp_2, U_5, V_3) ->
    case (I_7 >= 0) of
        true ->
            Pu = (case erlang:is_map((case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)) of true -> maps:get(U_5, (case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end), nil); _ -> case U_5 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)) + U_5 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)); _ -> mochi_nth(U_5 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)) end end),
            Pv = (case erlang:is_map((case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)) of true -> maps:get(V_3, (case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end), nil); _ -> case V_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)) + V_3 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)); _ -> mochi_nth(V_3 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(I_7, Parent_3, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Parent_3) + I_7 + 1, Parent_3); _ -> mochi_nth(I_7 + 1, Parent_3) end end)) end end),
            V_5 = (case ((Pu /= 0) andalso (Pu /= Pv)) of
        true -> U_6 = Pu,
            V_4 = Pv,
            U_7 = U_6,
            V_4;
        _ -> U_7 = U_5,
            V_3
    end),
            I_8 = (I_7 - 1),
            Fun_5_loop(I_8, Level, Parent_3, Temp_2, U_7, V_5);
        _ -> {I_7, Level, Parent_3, Temp_2, U_5, V_3}
    end
end,
{I_8, Level, Parent_3, Temp_2, U_7, V_5} = Fun_5(I_7, Level, Parent_3, Temp_2, U_5, V_3),
        (case erlang:is_map((case erlang:is_map(Parent_3) of true -> maps:get(0, Parent_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Parent_3) + 0 + 1, Parent_3); _ -> mochi_nth(0 + 1, Parent_3) end end)) of true -> maps:get(U_7, (case erlang:is_map(Parent_3) of true -> maps:get(0, Parent_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Parent_3) + 0 + 1, Parent_3); _ -> mochi_nth(0 + 1, Parent_3) end end), nil); _ -> case U_7 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Parent_3) of true -> maps:get(0, Parent_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Parent_3) + 0 + 1, Parent_3); _ -> mochi_nth(0 + 1, Parent_3) end end)) + U_7 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(0, Parent_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Parent_3) + 0 + 1, Parent_3); _ -> mochi_nth(0 + 1, Parent_3) end end)); _ -> mochi_nth(U_7 + 1, (case erlang:is_map(Parent_3) of true -> maps:get(0, Parent_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Parent_3) + 0 + 1, Parent_3); _ -> mochi_nth(0 + 1, Parent_3) end end)) end end)
    catch {return, RetCatch} -> RetCatch end.

breadth_first_search(Level_2, Parent_4, Max_node_2, Graph, Root) ->
    try
        Level_3 = lists:sublist(Level_2, Root) ++ [0] ++ lists:nthtail(Root + 1, Level_2),
        Q = [],
        Q_2 = lists:append((case Q of nil -> []; _ -> Q end), [Root]),
        Head = 0,
        Fun_7 = fun Fun_7_loop(Graph, Head, Level_3, Max_node_2, Parent_4, Q_2, Root) ->
    case (Head < erlang:length(Q_2)) of
        true ->
            U_8 = (case erlang:is_map(Q_2) of true -> maps:get(Head, Q_2, nil); _ -> case Head < 0 of true -> mochi_nth(erlang:length(Q_2) + Head + 1, Q_2); _ -> mochi_nth(Head + 1, Q_2) end end),
            Head_2 = (Head + 1),
            Adj = maps:get(U_8, Graph, nil),
            J_3 = 0,
            Fun_6 = fun Fun_6_loop(Adj, Graph, Head_2, J_3, Level_3, Max_node_2, Parent_4, Q_2, Root, U_8) ->
    case (J_3 < erlang:length(Adj)) of
        true ->
            V_6 = (case erlang:is_map(Adj) of true -> maps:get(J_3, Adj, nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(Adj) + J_3 + 1, Adj); _ -> mochi_nth(J_3 + 1, Adj) end end),
            Q_4 = (case ((case erlang:is_map(Level_3) of true -> maps:get(V_6, Level_3, nil); _ -> case V_6 < 0 of true -> mochi_nth(erlang:length(Level_3) + V_6 + 1, Level_3); _ -> mochi_nth(V_6 + 1, Level_3) end end) == (0 - 1)) of
        true -> Level_4 = lists:sublist(Level_3, V_6) ++ [((case erlang:is_map(Level_3) of true -> maps:get(U_8, Level_3, nil); _ -> case U_8 < 0 of true -> mochi_nth(erlang:length(Level_3) + U_8 + 1, Level_3); _ -> mochi_nth(U_8 + 1, Level_3) end end) + 1)] ++ lists:nthtail(V_6 + 1, Level_3),
            Parent_5 = lists:sublist(Parent_4, 0) ++ [(lists:sublist(lists:nth(0 + 1, Parent_4), V_6) ++ [U_8] ++ lists:nthtail(V_6 + 1, lists:nth(0 + 1, Parent_4)))] ++ lists:nthtail(0 + 1, Parent_4),
            Q_3 = lists:append((case Q_2 of nil -> []; _ -> Q_2 end), [V_6]),
            Level_5 = Level_4,
            Parent_6 = Parent_5,
            Q_3;
        _ -> Level_5 = Level_3,
            Parent_6 = Parent_4,
            Q_2
    end),
            J_4 = (J_3 + 1),
            Fun_6_loop(Adj, Graph, Head_2, J_4, Level_5, Max_node_2, Parent_6, Q_4, Root, U_8);
        _ -> {Adj, Graph, Head_2, J_3, Level_3, Max_node_2, Parent_4, Q_2, Root, U_8}
    end
end,
{Adj, Graph, Head_2, J_4, Level_5, Max_node_2, Parent_6, Q_4, Root, U_8} = Fun_6(Adj, Graph, Head_2, J_3, Level_3, Max_node_2, Parent_4, Q_2, Root, U_8),
            Fun_7_loop(Graph, Head_2, Level_5, Max_node_2, Parent_6, Q_4, Root);
        _ -> {Graph, Head, Level_3, Max_node_2, Parent_4, Q_2, Root}
    end
end,
{Graph, Head_2, Level_5, Max_node_2, Parent_6, Q_4, Root} = Fun_7(Graph, Head, Level_3, Max_node_2, Parent_4, Q_2, Root),
        {nil, Level_5}
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Max_node_3 = 13,
        Parent_7 = [],
        I_9 = 0,
        Fun_9 = fun Fun_9_loop(I_9, Max_node_3, Parent_7) ->
    case (I_9 < 20) of
        true ->
            Row = [],
            J_5 = 0,
            Fun_8 = fun Fun_8_loop(I_9, J_5, Max_node_3, Parent_7, Row) ->
    case (J_5 < (Max_node_3 + 10)) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            J_6 = (J_5 + 1),
            Fun_8_loop(I_9, J_6, Max_node_3, Parent_7, Row_2);
        _ -> {I_9, J_5, Max_node_3, Parent_7, Row}
    end
end,
{I_9, J_6, Max_node_3, Parent_7, Row_2} = Fun_8(I_9, J_5, Max_node_3, Parent_7, Row),
            Parent_8 = lists:append((case Parent_7 of nil -> []; _ -> Parent_7 end), [Row_2]),
            I_10 = (I_9 + 1),
            Fun_9_loop(I_10, Max_node_3, Parent_8);
        _ -> {I_9, Max_node_3, Parent_7}
    end
end,
{I_10, Max_node_3, Parent_8} = Fun_9(I_9, Max_node_3, Parent_7),
        Level_6 = [],
        I_11 = 0,
        Fun_10 = fun Fun_10_loop(I_11, Level_6, Max_node_3, Parent_8) ->
    case (I_11 < (Max_node_3 + 10)) of
        true ->
            Level_7 = lists:append((case Level_6 of nil -> []; _ -> Level_6 end), [(0 - 1)]),
            I_12 = (I_11 + 1),
            Fun_10_loop(I_12, Level_7, Max_node_3, Parent_8);
        _ -> {I_11, Level_6, Max_node_3, Parent_8}
    end
end,
{I_12, Level_7, Max_node_3, Parent_8} = Fun_10(I_11, Level_6, Max_node_3, Parent_8),
        Graph_2 = #{},
        Graph_3 = maps:put(1, [2, 3, 4], Graph_2),
        Graph_4 = maps:put(2, [5], Graph_3),
        Graph_5 = maps:put(3, [6, 7], Graph_4),
        Graph_6 = maps:put(4, [8], Graph_5),
        Graph_7 = maps:put(5, [9, 10], Graph_6),
        Graph_8 = maps:put(6, [11], Graph_7),
        Graph_9 = maps:put(7, [], Graph_8),
        Graph_10 = maps:put(8, [12, 13], Graph_9),
        Graph_11 = maps:put(9, [], Graph_10),
        Graph_12 = maps:put(10, [], Graph_11),
        Graph_13 = maps:put(11, [], Graph_12),
        Graph_14 = maps:put(12, [], Graph_13),
        Graph_15 = maps:put(13, [], Graph_14),
        Level_7_res = breadth_first_search(Level_7, Parent_8, Max_node_3, Graph_15, 1),
        Level_7_tmp = element(2, Level_7_res),
        Level_7 = Level_7_tmp,
        Parent_9 = create_sparse(Max_node_3, Parent_8),
        io:format("~s~n", [mochi_format(("LCA of node 1 and 3 is: " ++ mochi_str(lowest_common_ancestor(1, 3, Level_7, Parent_9))))]),
        io:format("~s~n", [mochi_format(("LCA of node 5 and 6 is: " ++ mochi_str(lowest_common_ancestor(5, 6, Level_7, Parent_9))))]),
        io:format("~s~n", [mochi_format(("LCA of node 7 and 11 is: " ++ mochi_str(lowest_common_ancestor(7, 11, Level_7, Parent_9))))]),
        io:format("~s~n", [mochi_format(("LCA of node 6 and 7 is: " ++ mochi_str(lowest_common_ancestor(6, 7, Level_7, Parent_9))))]),
        io:format("~s~n", [mochi_format(("LCA of node 4 and 12 is: " ++ mochi_str(lowest_common_ancestor(4, 12, Level_7, Parent_9))))]),
        io:format("~s~n", [mochi_format(("LCA of node 8 and 8 is: " ++ mochi_str(lowest_common_ancestor(8, 8, Level_7, Parent_9))))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~p~n", [Err])
    end.
