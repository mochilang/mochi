#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, make_hash_map/0, hm_len/1, hm_set/3, hm_get/2, hm_del/2, test_add_items/0, test_overwrite_items/0, test_delete_items/0, test_access_absent_items/0, test_add_with_resize_up/0, test_add_with_resize_down/0]).

% Generated by Mochi transpiler v0.10.59 (52a2f6fb79) on 2025-08-07 00:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

make_hash_map() ->
    try
        #{"entries" => []}
    catch {return, Ret} -> Ret end.

hm_len(M) ->
    try
        length(maps:get("entries", M, nil))
    catch {return, Ret} -> Ret end.

hm_set(M_2, Key, Value) ->
    try
        Entries = maps:get("entries", M_2, nil),
        Updated = false,
        New_entries = [],
        I = 0,
        Fun = fun Fun_loop(Entries, I, Key, M_2, New_entries, Updated, Value) ->
    case (I < length(Entries)) of
        true ->
            E = (case erlang:is_map(Entries) of true -> maps:get(I, Entries, nil); _ -> lists:nth(I + 1, Entries) end),
            case (maps:get("key", E, nil) == Key) of
        true -> New_entries_2 = lists:append((case New_entries of nil -> []; _ -> New_entries end), [#{"key" => Key, "value" => Value}]),
            Updated_2 = true,
            New_entries_4 = New_entries_2,
            Updated_3 = Updated_2;
        _ -> New_entries_3 = lists:append((case New_entries of nil -> []; _ -> New_entries end), [E]),
            New_entries_4 = New_entries_3,
            Updated_3 = Updated
    end,
            I_2 = (I + 1),
            Fun_loop(Entries, I_2, Key, M_2, New_entries_4, Updated_3, Value);
        _ -> {Entries, I, Key, M_2, New_entries, Updated, Value}
    end
end,
{Entries, I_2, Key, M_2, New_entries_4, Updated_3, Value} = Fun(Entries, I, Key, M_2, New_entries, Updated, Value),
        case mochi_not(Updated_3) of
        true -> New_entries_5 = lists:append((case New_entries_4 of nil -> []; _ -> New_entries_4 end), [#{"key" => Key, "value" => Value}]),
            New_entries_6 = New_entries_5;
        _ -> New_entries_6 = New_entries_4
    end,
        #{"entries" => New_entries_6}
    catch {return, Ret} -> Ret end.

hm_get(M_3, Key_2) ->
    try
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Key_2, M_3) ->
    case (I_3 < length(maps:get("entries", M_3, nil))) of
        true ->
            E_2 = (case erlang:is_map(maps:get("entries", M_3, nil)) of true -> maps:get(I_3, maps:get("entries", M_3, nil), nil); _ -> lists:nth(I_3 + 1, maps:get("entries", M_3, nil)) end),
            case (maps:get("key", E_2, nil) == Key_2) of
        true -> throw({return, #{"found" => true, "value" => maps:get("value", E_2, nil)}});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Key_2, M_3);
        _ -> {I_3, Key_2, M_3}
    end
end,
{I_4, Key_2, M_3} = Fun_2(I_3, Key_2, M_3),
        #{"found" => false, "value" => ""}
    catch {return, Ret} -> Ret end.

hm_del(M_4, Key_3) ->
    try
        Entries_2 = maps:get("entries", M_4, nil),
        New_entries_7 = [],
        Removed = false,
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Entries_2, I_5, Key_3, M_4, New_entries_7, Removed) ->
    case (I_5 < length(Entries_2)) of
        true ->
            E_3 = (case erlang:is_map(Entries_2) of true -> maps:get(I_5, Entries_2, nil); _ -> lists:nth(I_5 + 1, Entries_2) end),
            case (maps:get("key", E_3, nil) == Key_3) of
        true -> Removed_2 = true,
            New_entries_9 = New_entries_7,
            Removed_3 = Removed_2;
        _ -> New_entries_8 = lists:append((case New_entries_7 of nil -> []; _ -> New_entries_7 end), [E_3]),
            New_entries_9 = New_entries_8,
            Removed_3 = Removed
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(Entries_2, I_6, Key_3, M_4, New_entries_9, Removed_3);
        _ -> {Entries_2, I_5, Key_3, M_4, New_entries_7, Removed}
    end
end,
{Entries_2, I_6, Key_3, M_4, New_entries_9, Removed_3} = Fun_3(Entries_2, I_5, Key_3, M_4, New_entries_7, Removed),
        case (Removed_3 /= nil) of
        true -> throw({return, #{"map" => #{"entries" => New_entries_9}, "ok" => true}});
        _ -> ok
    end,
        #{"map" => M_4, "ok" => false}
    catch {return, Ret} -> Ret end.

test_add_items() ->
    try
        H = make_hash_map(),
        H_2 = hm_set(H, "key_a", "val_a"),
        H_3 = hm_set(H_2, "key_b", "val_b"),
        A = hm_get(H_3, "key_a"),
        B = hm_get(H_3, "key_b"),
        (((((hm_len(H_3) == 2) andalso maps:get("found", A, nil)) andalso maps:get("found", B, nil)) andalso (maps:get("value", A, nil) == "val_a")) andalso (maps:get("value", B, nil) == "val_b"))
    catch {return, Ret} -> Ret end.

test_overwrite_items() ->
    try
        H_4 = make_hash_map(),
        H_5 = hm_set(H_4, "key_a", "val_a"),
        H_6 = hm_set(H_5, "key_a", "val_b"),
        A_2 = hm_get(H_6, "key_a"),
        (((hm_len(H_6) == 1) andalso maps:get("found", A_2, nil)) andalso (maps:get("value", A_2, nil) == "val_b"))
    catch {return, Ret} -> Ret end.

test_delete_items() ->
    try
        H_7 = make_hash_map(),
        H_8 = hm_set(H_7, "key_a", "val_a"),
        H_9 = hm_set(H_8, "key_b", "val_b"),
        D1 = hm_del(H_9, "key_a"),
        H_10 = maps:get("map", D1, nil),
        D2 = hm_del(H_10, "key_b"),
        H_11 = maps:get("map", D2, nil),
        H_12 = hm_set(H_11, "key_a", "val_a"),
        D3 = hm_del(H_12, "key_a"),
        H_13 = maps:get("map", D3, nil),
        (hm_len(H_13) == 0)
    catch {return, Ret} -> Ret end.

test_access_absent_items() ->
    try
        H_14 = make_hash_map(),
        G1 = hm_get(H_14, "key_a"),
        D1_2 = hm_del(H_14, "key_a"),
        H_15 = maps:get("map", D1_2, nil),
        H_16 = hm_set(H_15, "key_a", "val_a"),
        D2_2 = hm_del(H_16, "key_a"),
        H_17 = maps:get("map", D2_2, nil),
        D3_2 = hm_del(H_17, "key_a"),
        H_18 = maps:get("map", D3_2, nil),
        G2 = hm_get(H_18, "key_a"),
        ((((((maps:get("found", G1, nil) == false) andalso (maps:get("ok", D1_2, nil) == false)) andalso maps:get("ok", D2_2, nil)) andalso (maps:get("ok", D3_2, nil) == false)) andalso (maps:get("found", G2, nil) == false)) andalso (hm_len(H_18) == 0))
    catch {return, Ret} -> Ret end.

test_add_with_resize_up() ->
    try
        H_19 = make_hash_map(),
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(H_19, I_7) ->
    case (I_7 < 5) of
        true ->
            S = mochi_str(I_7),
            H_20 = hm_set(H_19, S, S),
            I_8 = (I_7 + 1),
            Fun_4_loop(H_20, I_8);
        _ -> {H_19, I_7}
    end
end,
{H_20, I_8} = Fun_4(H_19, I_7),
        (hm_len(H_20) == 5)
    catch {return, Ret} -> Ret end.

test_add_with_resize_down() ->
    try
        H_21 = make_hash_map(),
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(H_21, I_9) ->
    case (I_9 < 5) of
        true ->
            S_2 = mochi_str(I_9),
            H_22 = hm_set(H_21, S_2, S_2),
            I_10 = (I_9 + 1),
            Fun_5_loop(H_22, I_10);
        _ -> {H_21, I_9}
    end
end,
{H_22, I_10} = Fun_5(H_21, I_9),
        J = 0,
        Fun_6 = fun Fun_6_loop(H_22, I_10, J) ->
    case (J < 5) of
        true ->
            S_3 = mochi_str(J),
            D = hm_del(H_22, S_3),
            H_23 = maps:get("map", D, nil),
            J_2 = (J + 1),
            Fun_6_loop(H_23, I_10, J_2);
        _ -> {H_22, I_10, J}
    end
end,
{H_23, I_10, J_2} = Fun_6(H_22, I_10, J),
        H_24 = hm_set(H_23, "key_a", "val_b"),
        A_3 = hm_get(H_24, "key_a"),
        (((hm_len(H_24) == 1) andalso maps:get("found", A_3, nil)) andalso (maps:get("value", A_3, nil) == "val_b"))
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    io:format("~ts~n", [mochi_repr(test_add_items())]),
    io:format("~ts~n", [mochi_repr(test_overwrite_items())]),
    io:format("~ts~n", [mochi_repr(test_delete_items())]),
    io:format("~ts~n", [mochi_repr(test_access_absent_items())]),
    io:format("~ts~n", [mochi_repr(test_add_with_resize_up())]),
    io:format("~ts~n", [mochi_repr(test_add_with_resize_down())]),
    io:format("~ts~n", [mochi_repr(true)]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
