#!/usr/bin/env escript
-module(main).
-compile([export_vars, nowarn_export_vars, nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, make_buckets/1, hashmap_new/1, bucket_index/2, next_index/2, try_set/4, is_full/1, is_sparse/1, resize/2, size_up/1, size_down/1, add_item/3, hashmap_set/3, hashmap_get/2, hashmap_del/2, hashmap_len/1, hashmap_repr/1]).

% Generated by Mochi transpiler v0.10.72 (17da928c0a)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> case V of
                true -> 1;
                false -> 0;
                _ -> list_to_integer(V)
            end
        end
    end.


toi(V) ->
    mochi_to_int(V).


mochi_to_float(V) ->
    case erlang:is_float(V) of
        true -> V;
        _ -> float(V)
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


mochi_format(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false ->
            S = lists:flatten(io_lib:format("~.15f", [V])),
            re:replace(S, "\\.?0+$", "", [global, {return, list}])
    end;
mochi_format(V) when is_integer(V) -> integer_to_list(V);
mochi_format(V) when is_binary(V) -> binary_to_list(V);
mochi_format(V) when is_list(V) -> V;
mochi_format(V) -> lists:flatten(io_lib:format("~p", [V])).


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_list(V) ->
    "[" ++ string:join([mochi_str(E) || E <- V], " ") ++ "]";
mochi_str(V) when is_float(V) ->
    I = trunc(V),
    case V == I of
        true -> integer_to_list(I);
        false -> erlang:float_to_list(V, [short])
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.


mochi_idiv(A, B) ->
    Q = A div B,
    R = A rem B,
    case ((R /= 0) andalso ((B < 0 andalso R > 0) orelse (B > 0 andalso R < 0))) of
        true -> Q - 1;
        false -> Q
    end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> A1 - B1 * mochi_idiv(A1, B1)
    end.

make_buckets(N) ->
    try
        Buckets = nil,
        I = 0,
        Fun = fun Fun_loop(Buckets, I, N) ->
    case (I < N) of
        true ->
            Buckets_2 = lists:append((case Buckets of nil -> []; _ -> Buckets end), [#{"state" => 0, "key" => 0, "val" => 0}]),
            I_2 = (I + 1),
            Fun_loop(Buckets_2, I_2, N);
        _ -> {Buckets, I, N}
    end
end,
{Buckets_2, I_2, N} = Fun(Buckets, I, N),
        Buckets_2
    catch {return, RetCatch} -> RetCatch end.

hashmap_new(Initial_size) ->
    try
        #{"buckets" => make_buckets(Initial_size), "len" => 0, "cap_num" => 3, "cap_den" => 4, "initial_size" => Initial_size}
    catch {return, RetCatch} -> RetCatch end.

bucket_index(Hm, Key) ->
    try
        Ind = mochi_mod(Key, erlang:length(maps:get("buckets", Hm, nil))),
        Ind_3 = (case (Ind < 0) of
        true -> Ind_2 = (Ind + erlang:length(maps:get("buckets", Hm, nil))),
            Ind_2;
        _ -> Ind
    end),
        Ind_3
    catch {return, RetCatch} -> RetCatch end.

next_index(Hm_2, Ind_4) ->
    try
        mochi_mod((Ind_4 + 1), erlang:length(maps:get("buckets", Hm_2, nil)))
    catch {return, RetCatch} -> RetCatch end.

try_set(Hm_3, Ind_5, Key_2, Val) ->
    try
        Buckets_3 = maps:get("buckets", Hm_3, nil),
        B = (case erlang:is_map(Buckets_3) of true -> maps:get(Ind_5, Buckets_3, nil); _ -> case Ind_5 < 0 of true -> mochi_nth(erlang:length(Buckets_3) + Ind_5 + 1, Buckets_3); _ -> mochi_nth(Ind_5 + 1, Buckets_3) end end),
        Hm_6 = (case ((maps:get("state", B, nil) == 0) orelse (maps:get("state", B, nil) == 2)) of
        true -> Buckets_4 = lists:sublist(Buckets_3, Ind_5) ++ [#{"state" => 1, "key" => Key_2, "val" => Val}] ++ lists:nthtail(Ind_5 + 1, Buckets_3),
            Hm_4 = maps:put("buckets", Buckets_4, Hm_3),
            Hm_5 = maps:put("len", (maps:get("len", Hm_4, nil) + 1), Hm_4),
            throw({return, true}),
            Buckets_5 = Buckets_4,
            Hm_5;
        _ -> Buckets_5 = Buckets_3,
            Hm_3
    end),
        Hm_8 = (case (maps:get("key", B, nil) == Key_2) of
        true -> Buckets_6 = lists:sublist(Buckets_5, Ind_5) ++ [#{"state" => 1, "key" => Key_2, "val" => Val}] ++ lists:nthtail(Ind_5 + 1, Buckets_5),
            Hm_7 = maps:put("buckets", Buckets_6, Hm_6),
            throw({return, true}),
            Buckets_7 = Buckets_6,
            Hm_7;
        _ -> Buckets_7 = Buckets_5,
            Hm_6
    end),
        false
    catch {return, RetCatch} -> RetCatch end.

is_full(Hm_9) ->
    try
        Limit = mochi_safe_div((erlang:length(maps:get("buckets", Hm_9, nil)) * maps:get("cap_num", Hm_9, nil)), maps:get("cap_den", Hm_9, nil)),
        (maps:get("len", Hm_9, nil) >= Limit)
    catch {return, RetCatch} -> RetCatch end.

is_sparse(Hm_10) ->
    try
        case (erlang:length(maps:get("buckets", Hm_10, nil)) =< maps:get("initial_size", Hm_10, nil)) of
        true -> throw({return, false});
        _ -> ok
    end,
        Limit_2 = mochi_safe_div((erlang:length(maps:get("buckets", Hm_10, nil)) * maps:get("cap_num", Hm_10, nil)), (2 * maps:get("cap_den", Hm_10, nil))),
        (maps:get("len", Hm_10, nil) < Limit_2)
    catch {return, RetCatch} -> RetCatch end.

resize(Hm_11, New_size) ->
    try
        Old = maps:get("buckets", Hm_11, nil),
        Hm_12 = maps:put("buckets", make_buckets(New_size), Hm_11),
        Hm_13 = maps:put("len", 0, Hm_12),
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Hm_13, I_3, New_size, Old) ->
    case (I_3 < erlang:length(Old)) of
        true ->
            It = (case erlang:is_map(Old) of true -> maps:get(I_3, Old, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Old) + I_3 + 1, Old); _ -> mochi_nth(I_3 + 1, Old) end end),
            case (maps:get("state", It, nil) == 1) of
        true -> add_item(Hm_13, maps:get("key", It, nil), maps:get("val", It, nil));
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Hm_13, I_4, New_size, Old);
        _ -> {Hm_13, I_3, New_size, Old}
    end
end,
{Hm_13, I_4, New_size, Old} = Fun_2(Hm_13, I_3, New_size, Old),
        {nil, Hm_13}
    catch {return, RetCatch} -> RetCatch end.

size_up(Hm_14) ->
    try
        Hm_res = resize(Hm_14, (erlang:length(maps:get("buckets", Hm_14, nil)) * 2)),
        Hm_tmp = element(2, Hm_res),
        Hm_15 = Hm_tmp,
        {nil, Hm_15}
    catch {return, RetCatch} -> RetCatch end.

size_down(Hm_16) ->
    try
        Hm_res_2 = resize(Hm_16, mochi_safe_div(erlang:length(maps:get("buckets", Hm_16, nil)), 2)),
        Hm_tmp_2 = element(2, Hm_res_2),
        Hm_17 = Hm_tmp_2,
        {nil, Hm_17}
    catch {return, RetCatch} -> RetCatch end.

add_item(Hm_18, Key_3, Val_2) ->
    try
        Ind_6 = bucket_index(Hm_18, Key_3),
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Hm_18, I_5, Ind_6, Key_3, Val_2) ->
    case (I_5 < erlang:length(maps:get("buckets", Hm_18, nil))) of
        true ->
            try
                case try_set(Hm_18, Ind_6, Key_3, Val_2) of
        true -> throw({break, {Hm_18, I_5, Ind_6, Key_3, Val_2}});
        _ -> ok
    end,
                Ind_7 = next_index(Hm_18, Ind_6),
                I_6 = (I_5 + 1),
                Fun_3_loop(Hm_18, I_6, Ind_7, Key_3, Val_2)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_3_loop(C0, C1, C2, C3, C4);
                {break, Bs} -> Bs
            end;
        _ -> {Hm_18, I_5, Ind_6, Key_3, Val_2}
    end
end,
{Hm_18, I_6, Ind_7, Key_3, Val_2} = Fun_3(Hm_18, I_5, Ind_6, Key_3, Val_2),
        nil
    catch {return, RetCatch} -> RetCatch end.

hashmap_set(Hm_19, Key_4, Val_3) ->
    try
        Hm_tmp_4 = (case is_full(Hm_19) of
        true -> Hm_res_3 = size_up(Hm_19),
            Hm_tmp_3 = element(2, Hm_res_3),
            Hm_20 = Hm_tmp_3,
            Hm_21 = Hm_20,
            Hm_res_4 = Hm_res_3,
            Hm_tmp_3;
        _ -> Hm_21 = Hm_19,
            Hm_res_4 = nil,
            nil
    end),
        add_item(Hm_21, Key_4, Val_3),
        nil
    catch {return, RetCatch} -> RetCatch end.

hashmap_get(Hm_22, Key_5) ->
    try
        Buckets_8 = maps:get("buckets", Hm_22, nil),
        Ind_8 = bucket_index(Hm_22, Key_5),
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(Buckets_8, Hm_22, I_7, Ind_8, Key_5) ->
    case (I_7 < erlang:length(Buckets_8)) of
        true ->
            try
                It_2 = (case erlang:is_map(Buckets_8) of true -> maps:get(Ind_8, Buckets_8, nil); _ -> case Ind_8 < 0 of true -> mochi_nth(erlang:length(Buckets_8) + Ind_8 + 1, Buckets_8); _ -> mochi_nth(Ind_8 + 1, Buckets_8) end end),
                case (maps:get("state", It_2, nil) == 0) of
        true -> throw({break, {Buckets_8, Hm_22, I_7, Ind_8, Key_5}});
        _ -> ok
    end,
                case ((maps:get("state", It_2, nil) == 1) andalso (maps:get("key", It_2, nil) == Key_5)) of
        true -> throw({return, maps:get("val", It_2, nil)});
        _ -> ok
    end,
                Ind_9 = next_index(Hm_22, Ind_8),
                I_8 = (I_7 + 1),
                Fun_4_loop(Buckets_8, Hm_22, I_8, Ind_9, Key_5)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_4_loop(C0, C1, C2, C3, C4);
                {break, Bs} -> Bs
            end;
        _ -> {Buckets_8, Hm_22, I_7, Ind_8, Key_5}
    end
end,
{Buckets_8, Hm_22, I_8, Ind_9, Key_5} = Fun_4(Buckets_8, Hm_22, I_7, Ind_8, Key_5),
        0
    catch {return, RetCatch} -> RetCatch end.

hashmap_del(Hm_23, Key_6) ->
    try
        Buckets_9 = maps:get("buckets", Hm_23, nil),
        Ind_10 = bucket_index(Hm_23, Key_6),
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(Buckets_9, Hm_23, I_9, Ind_10, Key_6) ->
    case (I_9 < erlang:length(Buckets_9)) of
        true ->
            try
                It_3 = (case erlang:is_map(Buckets_9) of true -> maps:get(Ind_10, Buckets_9, nil); _ -> case Ind_10 < 0 of true -> mochi_nth(erlang:length(Buckets_9) + Ind_10 + 1, Buckets_9); _ -> mochi_nth(Ind_10 + 1, Buckets_9) end end),
                case (maps:get("state", It_3, nil) == 0) of
        true -> io:format("~s~n", [mochi_format(("KeyError: " ++ mochi_str(Key_6)))]),
            throw({return, nil});
        _ -> ok
    end,
                Hm_26 = (case ((maps:get("state", It_3, nil) == 1) andalso (maps:get("key", It_3, nil) == Key_6)) of
        true -> Buckets_10 = lists:sublist(Buckets_9, Ind_10) ++ [#{"state" => 2, "key" => 0, "val" => 0}] ++ lists:nthtail(Ind_10 + 1, Buckets_9),
            Hm_24 = maps:put("buckets", Buckets_10, Hm_23),
            Hm_25 = maps:put("len", (maps:get("len", Hm_24, nil) - 1), Hm_24),
            throw({break, {Buckets_10, Hm_25, I_9, Ind_10, Key_6}}),
            Buckets_11 = Buckets_10,
            Hm_25;
        _ -> Buckets_11 = Buckets_9,
            Hm_23
    end),
                Ind_11 = next_index(Hm_26, Ind_10),
                I_10 = (I_9 + 1),
                Fun_5_loop(Buckets_11, Hm_26, I_10, Ind_11, Key_6)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_5_loop(C0, C1, C2, C3, C4);
                {break, Bs} -> Bs
            end;
        _ -> {Buckets_9, Hm_23, I_9, Ind_10, Key_6}
    end
end,
{Buckets_11, Hm_26, I_10, Ind_11, Key_6} = Fun_5(Buckets_9, Hm_23, I_9, Ind_10, Key_6),
        Hm_26_tmp_2 = (case is_sparse(Hm_26) of
        true -> Hm_26_res = size_down(Hm_26),
            Hm_26_tmp = element(2, Hm_26_res),
            Hm_26 = Hm_26_tmp,
            Hm_26_2 = Hm_26,
            Hm_26_res_2 = Hm_26_res,
            Hm_26_tmp;
        _ -> Hm_26_2 = nil,
            Hm_26_res_2 = nil,
            nil
    end),
        nil
    catch {return, RetCatch} -> RetCatch end.

hashmap_len(Hm_27) ->
    try
        maps:get("len", Hm_27, nil)
    catch {return, RetCatch} -> RetCatch end.

hashmap_repr(Hm_28) ->
    try
        Out = "HashMap(",
        First = true,
        I_11 = 0,
        Fun_6 = fun Fun_6_loop(First, Hm_28, I_11, Out) ->
    case (I_11 < erlang:length(maps:get("buckets", Hm_28, nil))) of
        true ->
            B_2 = (case erlang:is_map(maps:get("buckets", Hm_28, nil)) of true -> maps:get(I_11, maps:get("buckets", Hm_28, nil), nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(maps:get("buckets", Hm_28, nil)) + I_11 + 1, maps:get("buckets", Hm_28, nil)); _ -> mochi_nth(I_11 + 1, maps:get("buckets", Hm_28, nil)) end end),
            Out_5 = (case (maps:get("state", B_2, nil) == 1) of
        true -> Out_3 = (case mochi_not(First) of
        true -> Out_2 = (Out ++ ", "),
            First_3 = First,
            Out_2;
        _ -> First_2 = false,
            First_3 = First_2,
            Out
    end),
            Out_4 = (((Out_3 ++ mochi_str(maps:get("key", B_2, nil))) ++ ": ") ++ mochi_str(maps:get("val", B_2, nil))),
            First_4 = First_3,
            Out_4;
        _ -> First_4 = First,
            Out
    end),
            I_12 = (I_11 + 1),
            Fun_6_loop(First_4, Hm_28, I_12, Out_5);
        _ -> {First, Hm_28, I_11, Out}
    end
end,
{First_4, Hm_28, I_12, Out_5} = Fun_6(First, Hm_28, I_11, Out),
        Out_6 = (Out_5 ++ ")"),
        Out_6
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('hm', hashmap_new(5)),
    hashmap_set(erlang:get('hm'), 1, 10),
    hashmap_set(erlang:get('hm'), 2, 20),
    hashmap_set(erlang:get('hm'), 3, 30),
    io:format("~s~n", [mochi_format(hashmap_repr(erlang:get('hm')))]),
    io:format("~s~n", [mochi_str(hashmap_get(erlang:get('hm'), 2))]),
    hashmap_del(erlang:get('hm'), 1),
    io:format("~s~n", [mochi_format(hashmap_repr(erlang:get('hm')))]),
    io:format("~s~n", [mochi_str(hashmap_len(erlang:get('hm')))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~p~n", [Err])
    end.
