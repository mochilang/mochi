#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, sqrtapprox/1, atanapprox/1, atan2approx/2, deg/1, zero_matrix/2, convolve/2, gaussian_blur/1, sobel_filter/1, suppress_non_maximum/4, double_threshold/7, track_edge/5, canny/5, print_image/1]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

sqrtapprox(X) ->
    try
        Guess = mochi_safe_div(X, 2),
        I = 0,
        Fun = fun Fun_loop(Guess, I, X) ->
    case (I < 20) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X, Guess)), 2),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X);
        _ -> {Guess, I, X}
    end
end,
{Guess_2, I_2, X} = Fun(Guess, I, X),
        Guess_2
    catch {return, Ret} -> Ret end.

atanapprox(X_2) ->
    try
        case (X_2 > 1) of
        true -> throw({return, (mochi_safe_div(3.141592653589793, 2) - mochi_safe_div(X_2, (mochi_safe_mul(X_2, X_2) + 0.28)))});
        _ -> ok
    end,
        case (X_2 < -1) of
        true -> throw({return, (mochi_safe_div(-3.141592653589793, 2) - mochi_safe_div(X_2, (mochi_safe_mul(X_2, X_2) + 0.28)))});
        _ -> ok
    end,
        mochi_safe_div(X_2, (1 + mochi_safe_mul(mochi_safe_mul(0.28, X_2), X_2)))
    catch {return, Ret} -> Ret end.

atan2approx(Y, X_3) ->
    try
        case (X_3 > 0) of
        true -> R = atanapprox(mochi_safe_div(Y, X_3)),
            throw({return, R}),
            R_2 = R;
        _ -> R_2 = nil
    end,
        case (X_3 < 0) of
        true -> case (Y >= 0) of
        true -> throw({return, (atanapprox(mochi_safe_div(Y, X_3)) + 3.141592653589793)});
        _ -> ok
    end,
            throw({return, (atanapprox(mochi_safe_div(Y, X_3)) - 3.141592653589793)});
        _ -> ok
    end,
        case (Y > 0) of
        true -> throw({return, mochi_safe_div(3.141592653589793, 2)});
        _ -> ok
    end,
        case (Y < 0) of
        true -> throw({return, mochi_safe_div(-3.141592653589793, 2)});
        _ -> ok
    end,
        0
    catch {return, Ret} -> Ret end.

deg(Rad) ->
    try
        mochi_safe_div(mochi_safe_mul(Rad, 180), 3.141592653589793)
    catch {return, Ret} -> Ret end.

zero_matrix(H, W) ->
    try
        Out = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(H, I_3, Out, W) ->
    case (I_3 < H) of
        true ->
            Row = [],
            J = 0,
            Fun_2 = fun Fun_2_loop(H, I_3, J, Out, Row, W) ->
    case (J < W) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            J_2 = (J + 1),
            Fun_2_loop(H, I_3, J_2, Out, Row_2, W);
        _ -> {H, I_3, J, Out, Row, W}
    end
end,
{H, I_3, J_2, Out, Row_2, W} = Fun_2(H, I_3, J, Out, Row, W),
            Out_2 = lists:append((case Out of nil -> []; _ -> Out end), [Row_2]),
            I_4 = (I_3 + 1),
            Fun_3_loop(H, I_4, Out_2, W);
        _ -> {H, I_3, Out, W}
    end
end,
{H, I_4, Out_2, W} = Fun_3(H, I_3, Out, W),
        Out_2
    catch {return, Ret} -> Ret end.

convolve(Img, Kernel) ->
    try
        H_2 = erlang:length(Img),
        W_2 = erlang:length((case erlang:is_map(Img) of true -> maps:get(0, Img, nil); _ -> lists:nth(0 + 1, Img) end)),
        K = erlang:length(Kernel),
        Pad = (K div 2),
        Out_3 = zero_matrix(H_2, W_2),
        Y_2 = Pad,
        Fun_7 = fun Fun_7_loop(H_2, Img, K, Kernel, Out_3, Pad, W_2, Y_2) ->
    case (Y_2 < (H_2 - Pad)) of
        true ->
            X_4 = Pad,
            Fun_6 = fun Fun_6_loop(H_2, Img, K, Kernel, Out_3, Pad, W_2, X_4, Y_2) ->
    case (X_4 < (W_2 - Pad)) of
        true ->
            Sum = 0,
            Ky = 0,
            Fun_5 = fun Fun_5_loop(H_2, Img, K, Kernel, Ky, Out_3, Pad, Sum, W_2, X_4, Y_2) ->
    case (Ky < K) of
        true ->
            Kx = 0,
            Fun_4 = fun Fun_4_loop(H_2, Img, K, Kernel, Kx, Ky, Out_3, Pad, Sum, W_2, X_4, Y_2) ->
    case (Kx < K) of
        true ->
            Pixel = (case erlang:is_map((case erlang:is_map(Img) of true -> maps:get(((Y_2 - Pad) + Ky), Img, nil); _ -> lists:nth(((Y_2 - Pad) + Ky) + 1, Img) end)) of true -> maps:get(((X_4 - Pad) + Kx), (case erlang:is_map(Img) of true -> maps:get(((Y_2 - Pad) + Ky), Img, nil); _ -> lists:nth(((Y_2 - Pad) + Ky) + 1, Img) end), nil); _ -> lists:nth(((X_4 - Pad) + Kx) + 1, (case erlang:is_map(Img) of true -> maps:get(((Y_2 - Pad) + Ky), Img, nil); _ -> lists:nth(((Y_2 - Pad) + Ky) + 1, Img) end)) end),
            Weight = (case erlang:is_map((case erlang:is_map(Kernel) of true -> maps:get(Ky, Kernel, nil); _ -> lists:nth(Ky + 1, Kernel) end)) of true -> maps:get(Kx, (case erlang:is_map(Kernel) of true -> maps:get(Ky, Kernel, nil); _ -> lists:nth(Ky + 1, Kernel) end), nil); _ -> lists:nth(Kx + 1, (case erlang:is_map(Kernel) of true -> maps:get(Ky, Kernel, nil); _ -> lists:nth(Ky + 1, Kernel) end)) end),
            Sum_2 = (Sum + mochi_safe_mul(Pixel, Weight)),
            Kx_2 = (Kx + 1),
            Fun_4_loop(H_2, Img, K, Kernel, Kx_2, Ky, Out_3, Pad, Sum_2, W_2, X_4, Y_2);
        _ -> {H_2, Img, K, Kernel, Kx, Ky, Out_3, Pad, Sum, W_2, X_4, Y_2}
    end
end,
{H_2, Img, K, Kernel, Kx_2, Ky, Out_3, Pad, Sum_2, W_2, X_4, Y_2} = Fun_4(H_2, Img, K, Kernel, Kx, Ky, Out_3, Pad, Sum, W_2, X_4, Y_2),
            Ky_2 = (Ky + 1),
            Fun_5_loop(H_2, Img, K, Kernel, Ky_2, Out_3, Pad, Sum_2, W_2, X_4, Y_2);
        _ -> {H_2, Img, K, Kernel, Ky, Out_3, Pad, Sum, W_2, X_4, Y_2}
    end
end,
{H_2, Img, K, Kernel, Ky_2, Out_3, Pad, Sum_2, W_2, X_4, Y_2} = Fun_5(H_2, Img, K, Kernel, Ky, Out_3, Pad, Sum, W_2, X_4, Y_2),
            Out_4 = lists:sublist(Out_3, Y_2) ++ [lists:sublist(lists:nth(Y_2 + 1, Out_3), X_4) ++ [Sum_2] ++ lists:nthtail(X_4 + 1, lists:nth(Y_2 + 1, Out_3))] ++ lists:nthtail(Y_2 + 1, Out_3),
            X_5 = (X_4 + 1),
            Fun_6_loop(H_2, Img, K, Kernel, Out_4, Pad, W_2, X_5, Y_2);
        _ -> {H_2, Img, K, Kernel, Out_3, Pad, W_2, X_4, Y_2}
    end
end,
{H_2, Img, K, Kernel, Out_4, Pad, W_2, X_5, Y_2} = Fun_6(H_2, Img, K, Kernel, Out_3, Pad, W_2, X_4, Y_2),
            Y_3 = (Y_2 + 1),
            Fun_7_loop(H_2, Img, K, Kernel, Out_4, Pad, W_2, Y_3);
        _ -> {H_2, Img, K, Kernel, Out_3, Pad, W_2, Y_2}
    end
end,
{H_2, Img, K, Kernel, Out_4, Pad, W_2, Y_3} = Fun_7(H_2, Img, K, Kernel, Out_3, Pad, W_2, Y_2),
        Out_4
    catch {return, Ret} -> Ret end.

gaussian_blur(Img_2) ->
    try
        convolve(Img_2, erlang:get('GAUSSIAN_KERNEL'))
    catch {return, Ret} -> Ret end.

sobel_filter(Img_3) ->
    try
        Gx = convolve(Img_3, erlang:get('SOBEL_GX')),
        Gy = convolve(Img_3, erlang:get('SOBEL_GY')),
        H_3 = erlang:length(Img_3),
        W_3 = erlang:length((case erlang:is_map(Img_3) of true -> maps:get(0, Img_3, nil); _ -> lists:nth(0 + 1, Img_3) end)),
        Grad = zero_matrix(H_3, W_3),
        Dir = zero_matrix(H_3, W_3),
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(Dir, Grad, Gx, Gy, H_3, I_5, Img_3, W_3) ->
    case (I_5 < H_3) of
        true ->
            J_3 = 0,
            Fun_8 = fun Fun_8_loop(Dir, Grad, Gx, Gy, H_3, I_5, Img_3, J_3, W_3) ->
    case (J_3 < W_3) of
        true ->
            Gxx = (case erlang:is_map((case erlang:is_map(Gx) of true -> maps:get(I_5, Gx, nil); _ -> lists:nth(I_5 + 1, Gx) end)) of true -> maps:get(J_3, (case erlang:is_map(Gx) of true -> maps:get(I_5, Gx, nil); _ -> lists:nth(I_5 + 1, Gx) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Gx) of true -> maps:get(I_5, Gx, nil); _ -> lists:nth(I_5 + 1, Gx) end)) end),
            Gyy = (case erlang:is_map((case erlang:is_map(Gy) of true -> maps:get(I_5, Gy, nil); _ -> lists:nth(I_5 + 1, Gy) end)) of true -> maps:get(J_3, (case erlang:is_map(Gy) of true -> maps:get(I_5, Gy, nil); _ -> lists:nth(I_5 + 1, Gy) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Gy) of true -> maps:get(I_5, Gy, nil); _ -> lists:nth(I_5 + 1, Gy) end)) end),
            Grad_2 = lists:sublist(Grad, I_5) ++ [lists:sublist(lists:nth(I_5 + 1, Grad), J_3) ++ [sqrtapprox((mochi_safe_mul(Gxx, Gxx) + mochi_safe_mul(Gyy, Gyy)))] ++ lists:nthtail(J_3 + 1, lists:nth(I_5 + 1, Grad))] ++ lists:nthtail(I_5 + 1, Grad),
            Dir_2 = lists:sublist(Dir, I_5) ++ [lists:sublist(lists:nth(I_5 + 1, Dir), J_3) ++ [(deg(atan2approx(Gyy, Gxx)) + 180)] ++ lists:nthtail(J_3 + 1, lists:nth(I_5 + 1, Dir))] ++ lists:nthtail(I_5 + 1, Dir),
            J_4 = (J_3 + 1),
            Fun_8_loop(Dir_2, Grad_2, Gx, Gy, H_3, I_5, Img_3, J_4, W_3);
        _ -> {Dir, Grad, Gx, Gy, H_3, I_5, Img_3, J_3, W_3}
    end
end,
{Dir_2, Grad_2, Gx, Gy, H_3, I_5, Img_3, J_4, W_3} = Fun_8(Dir, Grad, Gx, Gy, H_3, I_5, Img_3, J_3, W_3),
            I_6 = (I_5 + 1),
            Fun_9_loop(Dir_2, Grad_2, Gx, Gy, H_3, I_6, Img_3, W_3);
        _ -> {Dir, Grad, Gx, Gy, H_3, I_5, Img_3, W_3}
    end
end,
{Dir_2, Grad_2, Gx, Gy, H_3, I_6, Img_3, W_3} = Fun_9(Dir, Grad, Gx, Gy, H_3, I_5, Img_3, W_3),
        #{"grad" => Grad_2, "dir" => Dir_2}
    catch {return, Ret} -> Ret end.

suppress_non_maximum(H_4, W_4, Direction, Grad_3) ->
    try
        Dest = zero_matrix(H_4, W_4),
        R_3 = 1,
        Fun_11 = fun Fun_11_loop(Dest, Direction, Grad_3, H_4, R_3, W_4) ->
    case (R_3 < (H_4 - 1)) of
        true ->
            C = 1,
            Fun_10 = fun Fun_10_loop(C, Dest, Direction, Grad_3, H_4, R_3, W_4) ->
    case (C < (W_4 - 1)) of
        true ->
            Angle = (case erlang:is_map((case erlang:is_map(Direction) of true -> maps:get(R_3, Direction, nil); _ -> lists:nth(R_3 + 1, Direction) end)) of true -> maps:get(C, (case erlang:is_map(Direction) of true -> maps:get(R_3, Direction, nil); _ -> lists:nth(R_3 + 1, Direction) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Direction) of true -> maps:get(R_3, Direction, nil); _ -> lists:nth(R_3 + 1, Direction) end)) end),
            Q = 0,
            P = 0,
            case ((((Angle >= 0) andalso (Angle < 22.5)) orelse ((Angle >= 157.5) andalso (Angle =< 180))) orelse (Angle >= 337.5)) of
        true -> Q_2 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) of true -> maps:get((C + 1), (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end), nil); _ -> lists:nth((C + 1) + 1, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) end),
            P_2 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) of true -> maps:get((C - 1), (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end), nil); _ -> lists:nth((C - 1) + 1, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) end),
            P_8 = P_2,
            Q_8 = Q_2;
        _ -> case (((Angle >= 22.5) andalso (Angle < 67.5)) orelse ((Angle >= 202.5) andalso (Angle < 247.5))) of
        true -> Q_3 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end)) of true -> maps:get((C - 1), (case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end), nil); _ -> lists:nth((C - 1) + 1, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end)) end),
            P_3 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end)) of true -> maps:get((C + 1), (case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end), nil); _ -> lists:nth((C + 1) + 1, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end)) end),
            P_7 = P_3,
            Q_7 = Q_3;
        _ -> case (((Angle >= 67.5) andalso (Angle < 112.5)) orelse ((Angle >= 247.5) andalso (Angle < 292.5))) of
        true -> Q_4 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end)) of true -> maps:get(C, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end)) end),
            P_4 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end)) of true -> maps:get(C, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end)) end),
            P_6 = P_4,
            Q_6 = Q_4;
        _ -> Q_5 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end)) of true -> maps:get((C - 1), (case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end), nil); _ -> lists:nth((C - 1) + 1, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 - 1), Grad_3, nil); _ -> lists:nth((R_3 - 1) + 1, Grad_3) end)) end),
            P_5 = (case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end)) of true -> maps:get((C + 1), (case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end), nil); _ -> lists:nth((C + 1) + 1, (case erlang:is_map(Grad_3) of true -> maps:get((R_3 + 1), Grad_3, nil); _ -> lists:nth((R_3 + 1) + 1, Grad_3) end)) end),
            P_6 = P_5,
            Q_6 = Q_5
    end,
            P_7 = P_6,
            Q_7 = Q_6
    end,
            P_8 = P_7,
            Q_8 = Q_7
    end,
            case (((case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) of true -> maps:get(C, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) end) >= Q_8) andalso ((case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) of true -> maps:get(C, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) end) >= P_8)) of
        true -> Dest_2 = lists:sublist(Dest, R_3) ++ [lists:sublist(lists:nth(R_3 + 1, Dest), C) ++ [(case erlang:is_map((case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) of true -> maps:get(C, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(Grad_3) of true -> maps:get(R_3, Grad_3, nil); _ -> lists:nth(R_3 + 1, Grad_3) end)) end)] ++ lists:nthtail(C + 1, lists:nth(R_3 + 1, Dest))] ++ lists:nthtail(R_3 + 1, Dest),
            Dest_3 = Dest_2;
        _ -> Dest_3 = Dest
    end,
            C_2 = (C + 1),
            Fun_10_loop(C_2, Dest_3, Direction, Grad_3, H_4, R_3, W_4);
        _ -> {C, Dest, Direction, Grad_3, H_4, R_3, W_4}
    end
end,
{C_2, Dest_3, Direction, Grad_3, H_4, R_3, W_4} = Fun_10(C, Dest, Direction, Grad_3, H_4, R_3, W_4),
            R_4 = (R_3 + 1),
            Fun_11_loop(Dest_3, Direction, Grad_3, H_4, R_4, W_4);
        _ -> {Dest, Direction, Grad_3, H_4, R_3, W_4}
    end
end,
{Dest_3, Direction, Grad_3, H_4, R_4, W_4} = Fun_11(Dest, Direction, Grad_3, H_4, R_3, W_4),
        Dest_3
    catch {return, Ret} -> Ret end.

double_threshold(H_5, W_5, Img_4, Low, High, Weak, Strong) ->
    try
        R_5 = 0,
        Fun_13 = fun Fun_13_loop(H_5, High, Img_4, Low, R_5, Strong, W_5, Weak) ->
    case (R_5 < H_5) of
        true ->
            C_3 = 0,
            Fun_12 = fun Fun_12_loop(C_3, H_5, High, Img_4, Low, R_5, Strong, W_5, Weak) ->
    case (C_3 < W_5) of
        true ->
            V = (case erlang:is_map((case erlang:is_map(Img_4) of true -> maps:get(R_5, Img_4, nil); _ -> lists:nth(R_5 + 1, Img_4) end)) of true -> maps:get(C_3, (case erlang:is_map(Img_4) of true -> maps:get(R_5, Img_4, nil); _ -> lists:nth(R_5 + 1, Img_4) end), nil); _ -> lists:nth(C_3 + 1, (case erlang:is_map(Img_4) of true -> maps:get(R_5, Img_4, nil); _ -> lists:nth(R_5 + 1, Img_4) end)) end),
            case (V >= High) of
        true -> Img_5 = lists:sublist(Img_4, R_5) ++ [lists:sublist(lists:nth(R_5 + 1, Img_4), C_3) ++ [Strong] ++ lists:nthtail(C_3 + 1, lists:nth(R_5 + 1, Img_4))] ++ lists:nthtail(R_5 + 1, Img_4),
            Img_9 = Img_5;
        _ -> case (V < Low) of
        true -> Img_6 = lists:sublist(Img_4, R_5) ++ [lists:sublist(lists:nth(R_5 + 1, Img_4), C_3) ++ [0] ++ lists:nthtail(C_3 + 1, lists:nth(R_5 + 1, Img_4))] ++ lists:nthtail(R_5 + 1, Img_4),
            Img_8 = Img_6;
        _ -> Img_7 = lists:sublist(Img_4, R_5) ++ [lists:sublist(lists:nth(R_5 + 1, Img_4), C_3) ++ [Weak] ++ lists:nthtail(C_3 + 1, lists:nth(R_5 + 1, Img_4))] ++ lists:nthtail(R_5 + 1, Img_4),
            Img_8 = Img_7
    end,
            Img_9 = Img_8
    end,
            C_4 = (C_3 + 1),
            Fun_12_loop(C_4, H_5, High, Img_9, Low, R_5, Strong, W_5, Weak);
        _ -> {C_3, H_5, High, Img_4, Low, R_5, Strong, W_5, Weak}
    end
end,
{C_4, H_5, High, Img_9, Low, R_5, Strong, W_5, Weak} = Fun_12(C_3, H_5, High, Img_4, Low, R_5, Strong, W_5, Weak),
            R_6 = (R_5 + 1),
            Fun_13_loop(H_5, High, Img_9, Low, R_6, Strong, W_5, Weak);
        _ -> {H_5, High, Img_4, Low, R_5, Strong, W_5, Weak}
    end
end,
{H_5, High, Img_9, Low, R_6, Strong, W_5, Weak} = Fun_13(H_5, High, Img_4, Low, R_5, Strong, W_5, Weak),
        nil
    catch {return, Ret} -> Ret end.

track_edge(H_6, W_6, Img_10, Weak_2, Strong_2) ->
    try
        R_7 = 1,
        Fun_15 = fun Fun_15_loop(H_6, Img_10, R_7, Strong_2, W_6, Weak_2) ->
    case (R_7 < (H_6 - 1)) of
        true ->
            C_5 = 1,
            Fun_14 = fun Fun_14_loop(C_5, H_6, Img_10, R_7, Strong_2, W_6, Weak_2) ->
    case (C_5 < (W_6 - 1)) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end)) of true -> maps:get(C_5, (case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end), nil); _ -> lists:nth(C_5 + 1, (case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end)) end) == Weak_2) of
        true -> case (((((((((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end)) of true -> maps:get(C_5, (case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end), nil); _ -> lists:nth(C_5 + 1, (case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end)) end) == Strong_2) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end)) of true -> maps:get(C_5, (case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end), nil); _ -> lists:nth(C_5 + 1, (case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end)) end) == Strong_2)) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end)) of true -> maps:get((C_5 + 1), (case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end), nil); _ -> lists:nth((C_5 + 1) + 1, (case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end)) end) == Strong_2)) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end)) of true -> maps:get((C_5 - 1), (case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end), nil); _ -> lists:nth((C_5 - 1) + 1, (case erlang:is_map(Img_10) of true -> maps:get(R_7, Img_10, nil); _ -> lists:nth(R_7 + 1, Img_10) end)) end) == Strong_2)) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end)) of true -> maps:get((C_5 - 1), (case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end), nil); _ -> lists:nth((C_5 - 1) + 1, (case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end)) end) == Strong_2)) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end)) of true -> maps:get((C_5 + 1), (case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end), nil); _ -> lists:nth((C_5 + 1) + 1, (case erlang:is_map(Img_10) of true -> maps:get((R_7 - 1), Img_10, nil); _ -> lists:nth((R_7 - 1) + 1, Img_10) end)) end) == Strong_2)) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end)) of true -> maps:get((C_5 - 1), (case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end), nil); _ -> lists:nth((C_5 - 1) + 1, (case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end)) end) == Strong_2)) orelse ((case erlang:is_map((case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end)) of true -> maps:get((C_5 + 1), (case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end), nil); _ -> lists:nth((C_5 + 1) + 1, (case erlang:is_map(Img_10) of true -> maps:get((R_7 + 1), Img_10, nil); _ -> lists:nth((R_7 + 1) + 1, Img_10) end)) end) == Strong_2)) of
        true -> Img_11 = lists:sublist(Img_10, R_7) ++ [lists:sublist(lists:nth(R_7 + 1, Img_10), C_5) ++ [Strong_2] ++ lists:nthtail(C_5 + 1, lists:nth(R_7 + 1, Img_10))] ++ lists:nthtail(R_7 + 1, Img_10),
            Img_13 = Img_11;
        _ -> Img_12 = lists:sublist(Img_10, R_7) ++ [lists:sublist(lists:nth(R_7 + 1, Img_10), C_5) ++ [0] ++ lists:nthtail(C_5 + 1, lists:nth(R_7 + 1, Img_10))] ++ lists:nthtail(R_7 + 1, Img_10),
            Img_13 = Img_12
    end,
            Img_14 = Img_13;
        _ -> Img_14 = Img_10
    end,
            C_6 = (C_5 + 1),
            Fun_14_loop(C_6, H_6, Img_14, R_7, Strong_2, W_6, Weak_2);
        _ -> {C_5, H_6, Img_10, R_7, Strong_2, W_6, Weak_2}
    end
end,
{C_6, H_6, Img_14, R_7, Strong_2, W_6, Weak_2} = Fun_14(C_5, H_6, Img_10, R_7, Strong_2, W_6, Weak_2),
            R_8 = (R_7 + 1),
            Fun_15_loop(H_6, Img_14, R_8, Strong_2, W_6, Weak_2);
        _ -> {H_6, Img_10, R_7, Strong_2, W_6, Weak_2}
    end
end,
{H_6, Img_14, R_8, Strong_2, W_6, Weak_2} = Fun_15(H_6, Img_10, R_7, Strong_2, W_6, Weak_2),
        nil
    catch {return, Ret} -> Ret end.

canny(Image, Low_2, High_2, Weak_3, Strong_3) ->
    try
        Blurred = gaussian_blur(Image),
        Sob = sobel_filter(Blurred),
        Grad_4 = maps:get("grad", Sob, nil),
        Direction_2 = maps:get("dir", Sob, nil),
        H_7 = erlang:length(Image),
        W_7 = erlang:length((case erlang:is_map(Image) of true -> maps:get(0, Image, nil); _ -> lists:nth(0 + 1, Image) end)),
        Suppressed = suppress_non_maximum(H_7, W_7, Direction_2, Grad_4),
        double_threshold(H_7, W_7, Suppressed, Low_2, High_2, Weak_3, Strong_3),
        track_edge(H_7, W_7, Suppressed, Weak_3, Strong_3),
        Suppressed
    catch {return, Ret} -> Ret end.

print_image(Img_15) ->
    try
        R_9 = 0,
        Fun_17 = fun Fun_17_loop(Img_15, R_9) ->
    case (R_9 < erlang:length(Img_15)) of
        true ->
            C_7 = 0,
            Line = "",
            Fun_16 = fun Fun_16_loop(C_7, Img_15, Line, R_9) ->
    case (C_7 < erlang:length((case erlang:is_map(Img_15) of true -> maps:get(R_9, Img_15, nil); _ -> lists:nth(R_9 + 1, Img_15) end))) of
        true ->
            Line_2 = ((Line ++ mochi_str(mochi_to_int((case erlang:is_map((case erlang:is_map(Img_15) of true -> maps:get(R_9, Img_15, nil); _ -> lists:nth(R_9 + 1, Img_15) end)) of true -> maps:get(C_7, (case erlang:is_map(Img_15) of true -> maps:get(R_9, Img_15, nil); _ -> lists:nth(R_9 + 1, Img_15) end), nil); _ -> lists:nth(C_7 + 1, (case erlang:is_map(Img_15) of true -> maps:get(R_9, Img_15, nil); _ -> lists:nth(R_9 + 1, Img_15) end)) end)))) ++ " "),
            C_8 = (C_7 + 1),
            Fun_16_loop(C_8, Img_15, Line_2, R_9);
        _ -> {C_7, Img_15, Line, R_9}
    end
end,
{C_8, Img_15, Line_2, R_9} = Fun_16(C_7, Img_15, Line, R_9),
            io:format("~ts~n", [mochi_repr(Line_2)]),
            R_10 = (R_9 + 1),
            Fun_17_loop(Img_15, R_10);
        _ -> {Img_15, R_9}
    end
end,
{Img_15, R_10} = Fun_17(Img_15, R_9),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    erlang:put('GAUSSIAN_KERNEL', [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]]),
    erlang:put('SOBEL_GX', [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]),
    erlang:put('SOBEL_GY', [[1, 2, 1], [0, 0, 0], [-1, -2, -1]]),
    erlang:put('image', [[0, 0, 0, 0, 0], [0, 255, 255, 255, 0], [0, 255, 255, 255, 0], [0, 255, 255, 255, 0], [0, 0, 0, 0, 0]]),
    erlang:put('edges', canny(erlang:get('image'), 20, 40, 128, 255)),
    print_image(erlang:get('edges')),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
