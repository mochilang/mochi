#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, absf/1, sqrtapprox/1, atanapprox/1, atan2approx/2, zeros/2, pad_edge/2, img_convolve/2, abs_matrix/1, max_matrix/1, scale_matrix/2, sobel_filter/1, print_matrix_int/1, print_matrix_float/1, main/0]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

absf(X) ->
    try
        (case (X < 0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

sqrtapprox(X_2) ->
    try
        case (X_2 =< 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        Guess = mochi_safe_div(X_2, 2),
        I = 0,
        Fun = fun Fun_loop(Guess, I, X_2) ->
    case (I < 20) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X_2, Guess)), 2),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X_2);
        _ -> {Guess, I, X_2}
    end
end,
{Guess_2, I_2, X_2} = Fun(Guess, I, X_2),
        Guess_2
    catch {return, Ret} -> Ret end.

atanapprox(X_3) ->
    try
        case (X_3 > 1) of
        true -> throw({return, (mochi_safe_div(3.141592653589793, 2) - mochi_safe_div(X_3, (mochi_safe_mul(X_3, X_3) + 0.28)))});
        _ -> ok
    end,
        case (X_3 < -1) of
        true -> throw({return, (mochi_safe_div(-3.141592653589793, 2) - mochi_safe_div(X_3, (mochi_safe_mul(X_3, X_3) + 0.28)))});
        _ -> ok
    end,
        mochi_safe_div(X_3, (1 + mochi_safe_mul(mochi_safe_mul(0.28, X_3), X_3)))
    catch {return, Ret} -> Ret end.

atan2approx(Y, X_4) ->
    try
        case (X_4 == 0) of
        true -> case (Y > 0) of
        true -> throw({return, mochi_safe_div(3.141592653589793, 2)});
        _ -> ok
    end,
            case (Y < 0) of
        true -> throw({return, mochi_safe_div(-3.141592653589793, 2)});
        _ -> ok
    end,
            throw({return, 0});
        _ -> ok
    end,
        A = atanapprox(mochi_safe_div(Y, X_4)),
        case (X_4 > 0) of
        true -> throw({return, A});
        _ -> ok
    end,
        case (Y >= 0) of
        true -> throw({return, (A + 3.141592653589793)});
        _ -> ok
    end,
        (A - 3.141592653589793)
    catch {return, Ret} -> Ret end.

zeros(H, W) ->
    try
        M = [],
        Y_2 = 0,
        Fun_3 = fun Fun_3_loop(H, M, W, Y_2) ->
    case (Y_2 < H) of
        true ->
            Row = [],
            X_5 = 0,
            Fun_2 = fun Fun_2_loop(H, M, Row, W, X_5, Y_2) ->
    case (X_5 < W) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            X_6 = (X_5 + 1),
            Fun_2_loop(H, M, Row_2, W, X_6, Y_2);
        _ -> {H, M, Row, W, X_5, Y_2}
    end
end,
{H, M, Row_2, W, X_6, Y_2} = Fun_2(H, M, Row, W, X_5, Y_2),
            M_2 = lists:append((case M of nil -> []; _ -> M end), [Row_2]),
            Y_3 = (Y_2 + 1),
            Fun_3_loop(H, M_2, W, Y_3);
        _ -> {H, M, W, Y_2}
    end
end,
{H, M_2, W, Y_3} = Fun_3(H, M, W, Y_2),
        M_2
    catch {return, Ret} -> Ret end.

pad_edge(Img, Pad) ->
    try
        H_2 = erlang:length(Img),
        W_2 = erlang:length((case erlang:is_map(Img) of true -> maps:get(0, Img, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Img) + 0 + 1, Img); _ -> lists:nth(0 + 1, Img) end end)),
        Out = zeros((H_2 + (Pad * 2)), (W_2 + (Pad * 2))),
        Y_4 = 0,
        Fun_5 = fun Fun_5_loop(H_2, Img, Out, Pad, W_2, Y_4) ->
    case (Y_4 < (H_2 + (Pad * 2))) of
        true ->
            X_7 = 0,
            Fun_4 = fun Fun_4_loop(H_2, Img, Out, Pad, W_2, X_7, Y_4) ->
    case (X_7 < (W_2 + (Pad * 2))) of
        true ->
            Sy = (Y_4 - Pad),
            case (Sy < 0) of
        true -> Sy_2 = 0,
            Sy_3 = Sy_2;
        _ -> Sy_3 = Sy
    end,
            case (Sy_3 >= H_2) of
        true -> Sy_4 = (H_2 - 1),
            Sy_5 = Sy_4;
        _ -> Sy_5 = Sy_3
    end,
            Sx = (X_7 - Pad),
            case (Sx < 0) of
        true -> Sx_2 = 0,
            Sx_3 = Sx_2;
        _ -> Sx_3 = Sx
    end,
            case (Sx_3 >= W_2) of
        true -> Sx_4 = (W_2 - 1),
            Sx_5 = Sx_4;
        _ -> Sx_5 = Sx_3
    end,
            Out_2 = lists:sublist(Out, Y_4) ++ [lists:sublist(lists:nth(Y_4 + 1, Out), X_7) ++ [(case erlang:is_map((case erlang:is_map(Img) of true -> maps:get(Sy_5, Img, nil); _ -> case Sy_5 < 0 of true -> lists:nth(erlang:length(Img) + Sy_5 + 1, Img); _ -> lists:nth(Sy_5 + 1, Img) end end)) of true -> maps:get(Sx_5, (case erlang:is_map(Img) of true -> maps:get(Sy_5, Img, nil); _ -> case Sy_5 < 0 of true -> lists:nth(erlang:length(Img) + Sy_5 + 1, Img); _ -> lists:nth(Sy_5 + 1, Img) end end), nil); _ -> case Sx_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Img) of true -> maps:get(Sy_5, Img, nil); _ -> case Sy_5 < 0 of true -> lists:nth(erlang:length(Img) + Sy_5 + 1, Img); _ -> lists:nth(Sy_5 + 1, Img) end end)) + Sx_5 + 1, (case erlang:is_map(Img) of true -> maps:get(Sy_5, Img, nil); _ -> case Sy_5 < 0 of true -> lists:nth(erlang:length(Img) + Sy_5 + 1, Img); _ -> lists:nth(Sy_5 + 1, Img) end end)); _ -> lists:nth(Sx_5 + 1, (case erlang:is_map(Img) of true -> maps:get(Sy_5, Img, nil); _ -> case Sy_5 < 0 of true -> lists:nth(erlang:length(Img) + Sy_5 + 1, Img); _ -> lists:nth(Sy_5 + 1, Img) end end)) end end)] ++ lists:nthtail(X_7 + 1, lists:nth(Y_4 + 1, Out))] ++ lists:nthtail(Y_4 + 1, Out),
            X_8 = (X_7 + 1),
            Fun_4_loop(H_2, Img, Out_2, Pad, W_2, X_8, Y_4);
        _ -> {H_2, Img, Out, Pad, W_2, X_7, Y_4}
    end
end,
{H_2, Img, Out_2, Pad, W_2, X_8, Y_4} = Fun_4(H_2, Img, Out, Pad, W_2, X_7, Y_4),
            Y_5 = (Y_4 + 1),
            Fun_5_loop(H_2, Img, Out_2, Pad, W_2, Y_5);
        _ -> {H_2, Img, Out, Pad, W_2, Y_4}
    end
end,
{H_2, Img, Out_2, Pad, W_2, Y_5} = Fun_5(H_2, Img, Out, Pad, W_2, Y_4),
        Out_2
    catch {return, Ret} -> Ret end.

img_convolve(Img_2, Kernel) ->
    try
        H_3 = erlang:length(Img_2),
        W_3 = erlang:length((case erlang:is_map(Img_2) of true -> maps:get(0, Img_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Img_2) + 0 + 1, Img_2); _ -> lists:nth(0 + 1, Img_2) end end)),
        K = erlang:length(Kernel),
        Pad_2 = (K div 2),
        Padded = pad_edge(Img_2, Pad_2),
        Out_3 = zeros(H_3, W_3),
        Y_6 = 0,
        Fun_9 = fun Fun_9_loop(H_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, W_3, Y_6) ->
    case (Y_6 < H_3) of
        true ->
            X_9 = 0,
            Fun_8 = fun Fun_8_loop(H_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, W_3, X_9, Y_6) ->
    case (X_9 < W_3) of
        true ->
            Sum = 0,
            I_3 = 0,
            Fun_7 = fun Fun_7_loop(H_3, I_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, Sum, W_3, X_9, Y_6) ->
    case (I_3 < K) of
        true ->
            J = 0,
            Fun_6 = fun Fun_6_loop(H_3, I_3, Img_2, J, K, Kernel, Out_3, Pad_2, Padded, Sum, W_3, X_9, Y_6) ->
    case (J < K) of
        true ->
            Sum_2 = (Sum + mochi_safe_mul((case erlang:is_map((case erlang:is_map(Padded) of true -> maps:get((Y_6 + I_3), Padded, nil); _ -> case (Y_6 + I_3) < 0 of true -> lists:nth(erlang:length(Padded) + (Y_6 + I_3) + 1, Padded); _ -> lists:nth((Y_6 + I_3) + 1, Padded) end end)) of true -> maps:get((X_9 + J), (case erlang:is_map(Padded) of true -> maps:get((Y_6 + I_3), Padded, nil); _ -> case (Y_6 + I_3) < 0 of true -> lists:nth(erlang:length(Padded) + (Y_6 + I_3) + 1, Padded); _ -> lists:nth((Y_6 + I_3) + 1, Padded) end end), nil); _ -> case (X_9 + J) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Padded) of true -> maps:get((Y_6 + I_3), Padded, nil); _ -> case (Y_6 + I_3) < 0 of true -> lists:nth(erlang:length(Padded) + (Y_6 + I_3) + 1, Padded); _ -> lists:nth((Y_6 + I_3) + 1, Padded) end end)) + (X_9 + J) + 1, (case erlang:is_map(Padded) of true -> maps:get((Y_6 + I_3), Padded, nil); _ -> case (Y_6 + I_3) < 0 of true -> lists:nth(erlang:length(Padded) + (Y_6 + I_3) + 1, Padded); _ -> lists:nth((Y_6 + I_3) + 1, Padded) end end)); _ -> lists:nth((X_9 + J) + 1, (case erlang:is_map(Padded) of true -> maps:get((Y_6 + I_3), Padded, nil); _ -> case (Y_6 + I_3) < 0 of true -> lists:nth(erlang:length(Padded) + (Y_6 + I_3) + 1, Padded); _ -> lists:nth((Y_6 + I_3) + 1, Padded) end end)) end end), float((case erlang:is_map((case erlang:is_map(Kernel) of true -> maps:get(I_3, Kernel, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Kernel) + I_3 + 1, Kernel); _ -> lists:nth(I_3 + 1, Kernel) end end)) of true -> maps:get(J, (case erlang:is_map(Kernel) of true -> maps:get(I_3, Kernel, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Kernel) + I_3 + 1, Kernel); _ -> lists:nth(I_3 + 1, Kernel) end end), nil); _ -> case J < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Kernel) of true -> maps:get(I_3, Kernel, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Kernel) + I_3 + 1, Kernel); _ -> lists:nth(I_3 + 1, Kernel) end end)) + J + 1, (case erlang:is_map(Kernel) of true -> maps:get(I_3, Kernel, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Kernel) + I_3 + 1, Kernel); _ -> lists:nth(I_3 + 1, Kernel) end end)); _ -> lists:nth(J + 1, (case erlang:is_map(Kernel) of true -> maps:get(I_3, Kernel, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Kernel) + I_3 + 1, Kernel); _ -> lists:nth(I_3 + 1, Kernel) end end)) end end)))),
            J_2 = (J + 1),
            Fun_6_loop(H_3, I_3, Img_2, J_2, K, Kernel, Out_3, Pad_2, Padded, Sum_2, W_3, X_9, Y_6);
        _ -> {H_3, I_3, Img_2, J, K, Kernel, Out_3, Pad_2, Padded, Sum, W_3, X_9, Y_6}
    end
end,
{H_3, I_3, Img_2, J_2, K, Kernel, Out_3, Pad_2, Padded, Sum_2, W_3, X_9, Y_6} = Fun_6(H_3, I_3, Img_2, J, K, Kernel, Out_3, Pad_2, Padded, Sum, W_3, X_9, Y_6),
            I_4 = (I_3 + 1),
            Fun_7_loop(H_3, I_4, Img_2, K, Kernel, Out_3, Pad_2, Padded, Sum_2, W_3, X_9, Y_6);
        _ -> {H_3, I_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, Sum, W_3, X_9, Y_6}
    end
end,
{H_3, I_4, Img_2, K, Kernel, Out_3, Pad_2, Padded, Sum_2, W_3, X_9, Y_6} = Fun_7(H_3, I_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, Sum, W_3, X_9, Y_6),
            Out_4 = lists:sublist(Out_3, Y_6) ++ [lists:sublist(lists:nth(Y_6 + 1, Out_3), X_9) ++ [Sum_2] ++ lists:nthtail(X_9 + 1, lists:nth(Y_6 + 1, Out_3))] ++ lists:nthtail(Y_6 + 1, Out_3),
            X_10 = (X_9 + 1),
            Fun_8_loop(H_3, Img_2, K, Kernel, Out_4, Pad_2, Padded, W_3, X_10, Y_6);
        _ -> {H_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, W_3, X_9, Y_6}
    end
end,
{H_3, Img_2, K, Kernel, Out_4, Pad_2, Padded, W_3, X_10, Y_6} = Fun_8(H_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, W_3, X_9, Y_6),
            Y_7 = (Y_6 + 1),
            Fun_9_loop(H_3, Img_2, K, Kernel, Out_4, Pad_2, Padded, W_3, Y_7);
        _ -> {H_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, W_3, Y_6}
    end
end,
{H_3, Img_2, K, Kernel, Out_4, Pad_2, Padded, W_3, Y_7} = Fun_9(H_3, Img_2, K, Kernel, Out_3, Pad_2, Padded, W_3, Y_6),
        Out_4
    catch {return, Ret} -> Ret end.

abs_matrix(Mat) ->
    try
        H_4 = erlang:length(Mat),
        W_4 = erlang:length((case erlang:is_map(Mat) of true -> maps:get(0, Mat, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat) + 0 + 1, Mat); _ -> lists:nth(0 + 1, Mat) end end)),
        Out_5 = zeros(H_4, W_4),
        Y_8 = 0,
        Fun_11 = fun Fun_11_loop(H_4, Mat, Out_5, W_4, Y_8) ->
    case (Y_8 < H_4) of
        true ->
            X_11 = 0,
            Fun_10 = fun Fun_10_loop(H_4, Mat, Out_5, W_4, X_11, Y_8) ->
    case (X_11 < W_4) of
        true ->
            V = (case erlang:is_map((case erlang:is_map(Mat) of true -> maps:get(Y_8, Mat, nil); _ -> case Y_8 < 0 of true -> lists:nth(erlang:length(Mat) + Y_8 + 1, Mat); _ -> lists:nth(Y_8 + 1, Mat) end end)) of true -> maps:get(X_11, (case erlang:is_map(Mat) of true -> maps:get(Y_8, Mat, nil); _ -> case Y_8 < 0 of true -> lists:nth(erlang:length(Mat) + Y_8 + 1, Mat); _ -> lists:nth(Y_8 + 1, Mat) end end), nil); _ -> case X_11 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat) of true -> maps:get(Y_8, Mat, nil); _ -> case Y_8 < 0 of true -> lists:nth(erlang:length(Mat) + Y_8 + 1, Mat); _ -> lists:nth(Y_8 + 1, Mat) end end)) + X_11 + 1, (case erlang:is_map(Mat) of true -> maps:get(Y_8, Mat, nil); _ -> case Y_8 < 0 of true -> lists:nth(erlang:length(Mat) + Y_8 + 1, Mat); _ -> lists:nth(Y_8 + 1, Mat) end end)); _ -> lists:nth(X_11 + 1, (case erlang:is_map(Mat) of true -> maps:get(Y_8, Mat, nil); _ -> case Y_8 < 0 of true -> lists:nth(erlang:length(Mat) + Y_8 + 1, Mat); _ -> lists:nth(Y_8 + 1, Mat) end end)) end end),
            case (V < 0) of
        true -> Out_6 = lists:sublist(Out_5, Y_8) ++ [lists:sublist(lists:nth(Y_8 + 1, Out_5), X_11) ++ [-V] ++ lists:nthtail(X_11 + 1, lists:nth(Y_8 + 1, Out_5))] ++ lists:nthtail(Y_8 + 1, Out_5),
            Out_8 = Out_6;
        _ -> Out_7 = lists:sublist(Out_5, Y_8) ++ [lists:sublist(lists:nth(Y_8 + 1, Out_5), X_11) ++ [V] ++ lists:nthtail(X_11 + 1, lists:nth(Y_8 + 1, Out_5))] ++ lists:nthtail(Y_8 + 1, Out_5),
            Out_8 = Out_7
    end,
            X_12 = (X_11 + 1),
            Fun_10_loop(H_4, Mat, Out_8, W_4, X_12, Y_8);
        _ -> {H_4, Mat, Out_5, W_4, X_11, Y_8}
    end
end,
{H_4, Mat, Out_8, W_4, X_12, Y_8} = Fun_10(H_4, Mat, Out_5, W_4, X_11, Y_8),
            Y_9 = (Y_8 + 1),
            Fun_11_loop(H_4, Mat, Out_8, W_4, Y_9);
        _ -> {H_4, Mat, Out_5, W_4, Y_8}
    end
end,
{H_4, Mat, Out_8, W_4, Y_9} = Fun_11(H_4, Mat, Out_5, W_4, Y_8),
        Out_8
    catch {return, Ret} -> Ret end.

max_matrix(Mat_2) ->
    try
        Max_val = (case erlang:is_map((case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> lists:nth(0 + 1, Mat_2) end end)) of true -> maps:get(0, (case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> lists:nth(0 + 1, Mat_2) end end), nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> lists:nth(0 + 1, Mat_2) end end)) + 0 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> lists:nth(0 + 1, Mat_2) end end)); _ -> lists:nth(0 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> lists:nth(0 + 1, Mat_2) end end)) end end),
        Y_10 = 0,
        Fun_13 = fun Fun_13_loop(Mat_2, Max_val, Y_10) ->
    case (Y_10 < erlang:length(Mat_2)) of
        true ->
            X_13 = 0,
            Fun_12 = fun Fun_12_loop(Mat_2, Max_val, X_13, Y_10) ->
    case (X_13 < erlang:length((case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> lists:nth(0 + 1, Mat_2) end end))) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)) of true -> maps:get(X_13, (case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end), nil); _ -> case X_13 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)) + X_13 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)); _ -> lists:nth(X_13 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)) end end) > Max_val) of
        true -> Max_val_2 = (case erlang:is_map((case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)) of true -> maps:get(X_13, (case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end), nil); _ -> case X_13 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)) + X_13 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)); _ -> lists:nth(X_13 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(Y_10, Mat_2, nil); _ -> case Y_10 < 0 of true -> lists:nth(erlang:length(Mat_2) + Y_10 + 1, Mat_2); _ -> lists:nth(Y_10 + 1, Mat_2) end end)) end end),
            Max_val_3 = Max_val_2;
        _ -> Max_val_3 = Max_val
    end,
            X_14 = (X_13 + 1),
            Fun_12_loop(Mat_2, Max_val_3, X_14, Y_10);
        _ -> {Mat_2, Max_val, X_13, Y_10}
    end
end,
{Mat_2, Max_val_3, X_14, Y_10} = Fun_12(Mat_2, Max_val, X_13, Y_10),
            Y_11 = (Y_10 + 1),
            Fun_13_loop(Mat_2, Max_val_3, Y_11);
        _ -> {Mat_2, Max_val, Y_10}
    end
end,
{Mat_2, Max_val_3, Y_11} = Fun_13(Mat_2, Max_val, Y_10),
        Max_val_3
    catch {return, Ret} -> Ret end.

scale_matrix(Mat_3, Factor) ->
    try
        H_5 = erlang:length(Mat_3),
        W_5 = erlang:length((case erlang:is_map(Mat_3) of true -> maps:get(0, Mat_3, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Mat_3) + 0 + 1, Mat_3); _ -> lists:nth(0 + 1, Mat_3) end end)),
        Out_9 = zeros(H_5, W_5),
        Y_12 = 0,
        Fun_15 = fun Fun_15_loop(Factor, H_5, Mat_3, Out_9, W_5, Y_12) ->
    case (Y_12 < H_5) of
        true ->
            X_15 = 0,
            Fun_14 = fun Fun_14_loop(Factor, H_5, Mat_3, Out_9, W_5, X_15, Y_12) ->
    case (X_15 < W_5) of
        true ->
            Out_10 = lists:sublist(Out_9, Y_12) ++ [lists:sublist(lists:nth(Y_12 + 1, Out_9), X_15) ++ [mochi_safe_mul((case erlang:is_map((case erlang:is_map(Mat_3) of true -> maps:get(Y_12, Mat_3, nil); _ -> case Y_12 < 0 of true -> lists:nth(erlang:length(Mat_3) + Y_12 + 1, Mat_3); _ -> lists:nth(Y_12 + 1, Mat_3) end end)) of true -> maps:get(X_15, (case erlang:is_map(Mat_3) of true -> maps:get(Y_12, Mat_3, nil); _ -> case Y_12 < 0 of true -> lists:nth(erlang:length(Mat_3) + Y_12 + 1, Mat_3); _ -> lists:nth(Y_12 + 1, Mat_3) end end), nil); _ -> case X_15 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat_3) of true -> maps:get(Y_12, Mat_3, nil); _ -> case Y_12 < 0 of true -> lists:nth(erlang:length(Mat_3) + Y_12 + 1, Mat_3); _ -> lists:nth(Y_12 + 1, Mat_3) end end)) + X_15 + 1, (case erlang:is_map(Mat_3) of true -> maps:get(Y_12, Mat_3, nil); _ -> case Y_12 < 0 of true -> lists:nth(erlang:length(Mat_3) + Y_12 + 1, Mat_3); _ -> lists:nth(Y_12 + 1, Mat_3) end end)); _ -> lists:nth(X_15 + 1, (case erlang:is_map(Mat_3) of true -> maps:get(Y_12, Mat_3, nil); _ -> case Y_12 < 0 of true -> lists:nth(erlang:length(Mat_3) + Y_12 + 1, Mat_3); _ -> lists:nth(Y_12 + 1, Mat_3) end end)) end end), Factor)] ++ lists:nthtail(X_15 + 1, lists:nth(Y_12 + 1, Out_9))] ++ lists:nthtail(Y_12 + 1, Out_9),
            X_16 = (X_15 + 1),
            Fun_14_loop(Factor, H_5, Mat_3, Out_10, W_5, X_16, Y_12);
        _ -> {Factor, H_5, Mat_3, Out_9, W_5, X_15, Y_12}
    end
end,
{Factor, H_5, Mat_3, Out_10, W_5, X_16, Y_12} = Fun_14(Factor, H_5, Mat_3, Out_9, W_5, X_15, Y_12),
            Y_13 = (Y_12 + 1),
            Fun_15_loop(Factor, H_5, Mat_3, Out_10, W_5, Y_13);
        _ -> {Factor, H_5, Mat_3, Out_9, W_5, Y_12}
    end
end,
{Factor, H_5, Mat_3, Out_10, W_5, Y_13} = Fun_15(Factor, H_5, Mat_3, Out_9, W_5, Y_12),
        Out_10
    catch {return, Ret} -> Ret end.

sobel_filter(Image) ->
    try
        H_6 = erlang:length(Image),
        W_6 = erlang:length((case erlang:is_map(Image) of true -> maps:get(0, Image, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Image) + 0 + 1, Image); _ -> lists:nth(0 + 1, Image) end end)),
        Img_3 = [],
        Y0 = 0,
        Fun_17 = fun Fun_17_loop(H_6, Image, Img_3, W_6, Y0) ->
    case (Y0 < H_6) of
        true ->
            Row_3 = [],
            X0 = 0,
            Fun_16 = fun Fun_16_loop(H_6, Image, Img_3, Row_3, W_6, X0, Y0) ->
    case (X0 < W_6) of
        true ->
            Row_4 = lists:append((case Row_3 of nil -> []; _ -> Row_3 end), [float((case erlang:is_map((case erlang:is_map(Image) of true -> maps:get(Y0, Image, nil); _ -> case Y0 < 0 of true -> lists:nth(erlang:length(Image) + Y0 + 1, Image); _ -> lists:nth(Y0 + 1, Image) end end)) of true -> maps:get(X0, (case erlang:is_map(Image) of true -> maps:get(Y0, Image, nil); _ -> case Y0 < 0 of true -> lists:nth(erlang:length(Image) + Y0 + 1, Image); _ -> lists:nth(Y0 + 1, Image) end end), nil); _ -> case X0 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Image) of true -> maps:get(Y0, Image, nil); _ -> case Y0 < 0 of true -> lists:nth(erlang:length(Image) + Y0 + 1, Image); _ -> lists:nth(Y0 + 1, Image) end end)) + X0 + 1, (case erlang:is_map(Image) of true -> maps:get(Y0, Image, nil); _ -> case Y0 < 0 of true -> lists:nth(erlang:length(Image) + Y0 + 1, Image); _ -> lists:nth(Y0 + 1, Image) end end)); _ -> lists:nth(X0 + 1, (case erlang:is_map(Image) of true -> maps:get(Y0, Image, nil); _ -> case Y0 < 0 of true -> lists:nth(erlang:length(Image) + Y0 + 1, Image); _ -> lists:nth(Y0 + 1, Image) end end)) end end))]),
            X0_2 = (X0 + 1),
            Fun_16_loop(H_6, Image, Img_3, Row_4, W_6, X0_2, Y0);
        _ -> {H_6, Image, Img_3, Row_3, W_6, X0, Y0}
    end
end,
{H_6, Image, Img_3, Row_4, W_6, X0_2, Y0} = Fun_16(H_6, Image, Img_3, Row_3, W_6, X0, Y0),
            Img_4 = lists:append((case Img_3 of nil -> []; _ -> Img_3 end), [Row_4]),
            Y0_2 = (Y0 + 1),
            Fun_17_loop(H_6, Image, Img_4, W_6, Y0_2);
        _ -> {H_6, Image, Img_3, W_6, Y0}
    end
end,
{H_6, Image, Img_4, W_6, Y0_2} = Fun_17(H_6, Image, Img_3, W_6, Y0),
        Kernel_x = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],
        Kernel_y = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]],
        Dst_x = abs_matrix(img_convolve(Img_4, Kernel_x)),
        Dst_y = abs_matrix(img_convolve(Img_4, Kernel_y)),
        Max_x = max_matrix(Dst_x),
        Max_y = max_matrix(Dst_y),
        Dst_x_2 = scale_matrix(Dst_x, mochi_safe_div(255, Max_x)),
        Dst_y_2 = scale_matrix(Dst_y, mochi_safe_div(255, Max_y)),
        Mag = zeros(H_6, W_6),
        Theta = zeros(H_6, W_6),
        Y_14 = 0,
        Fun_19 = fun Fun_19_loop(Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag, Max_x, Max_y, Theta, W_6, Y_14, Y0_2) ->
    case (Y_14 < H_6) of
        true ->
            X_17 = 0,
            Fun_18 = fun Fun_18_loop(Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag, Max_x, Max_y, Theta, W_6, X_17, Y_14, Y0_2) ->
    case (X_17 < W_6) of
        true ->
            Gx = (case erlang:is_map((case erlang:is_map(Dst_x_2) of true -> maps:get(Y_14, Dst_x_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_x_2) + Y_14 + 1, Dst_x_2); _ -> lists:nth(Y_14 + 1, Dst_x_2) end end)) of true -> maps:get(X_17, (case erlang:is_map(Dst_x_2) of true -> maps:get(Y_14, Dst_x_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_x_2) + Y_14 + 1, Dst_x_2); _ -> lists:nth(Y_14 + 1, Dst_x_2) end end), nil); _ -> case X_17 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dst_x_2) of true -> maps:get(Y_14, Dst_x_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_x_2) + Y_14 + 1, Dst_x_2); _ -> lists:nth(Y_14 + 1, Dst_x_2) end end)) + X_17 + 1, (case erlang:is_map(Dst_x_2) of true -> maps:get(Y_14, Dst_x_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_x_2) + Y_14 + 1, Dst_x_2); _ -> lists:nth(Y_14 + 1, Dst_x_2) end end)); _ -> lists:nth(X_17 + 1, (case erlang:is_map(Dst_x_2) of true -> maps:get(Y_14, Dst_x_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_x_2) + Y_14 + 1, Dst_x_2); _ -> lists:nth(Y_14 + 1, Dst_x_2) end end)) end end),
            Gy = (case erlang:is_map((case erlang:is_map(Dst_y_2) of true -> maps:get(Y_14, Dst_y_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_y_2) + Y_14 + 1, Dst_y_2); _ -> lists:nth(Y_14 + 1, Dst_y_2) end end)) of true -> maps:get(X_17, (case erlang:is_map(Dst_y_2) of true -> maps:get(Y_14, Dst_y_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_y_2) + Y_14 + 1, Dst_y_2); _ -> lists:nth(Y_14 + 1, Dst_y_2) end end), nil); _ -> case X_17 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dst_y_2) of true -> maps:get(Y_14, Dst_y_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_y_2) + Y_14 + 1, Dst_y_2); _ -> lists:nth(Y_14 + 1, Dst_y_2) end end)) + X_17 + 1, (case erlang:is_map(Dst_y_2) of true -> maps:get(Y_14, Dst_y_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_y_2) + Y_14 + 1, Dst_y_2); _ -> lists:nth(Y_14 + 1, Dst_y_2) end end)); _ -> lists:nth(X_17 + 1, (case erlang:is_map(Dst_y_2) of true -> maps:get(Y_14, Dst_y_2, nil); _ -> case Y_14 < 0 of true -> lists:nth(erlang:length(Dst_y_2) + Y_14 + 1, Dst_y_2); _ -> lists:nth(Y_14 + 1, Dst_y_2) end end)) end end),
            Mag_2 = lists:sublist(Mag, Y_14) ++ [lists:sublist(lists:nth(Y_14 + 1, Mag), X_17) ++ [sqrtapprox((mochi_safe_mul(Gx, Gx) + mochi_safe_mul(Gy, Gy)))] ++ lists:nthtail(X_17 + 1, lists:nth(Y_14 + 1, Mag))] ++ lists:nthtail(Y_14 + 1, Mag),
            Theta_2 = lists:sublist(Theta, Y_14) ++ [lists:sublist(lists:nth(Y_14 + 1, Theta), X_17) ++ [atan2approx(Gy, Gx)] ++ lists:nthtail(X_17 + 1, lists:nth(Y_14 + 1, Theta))] ++ lists:nthtail(Y_14 + 1, Theta),
            X_18 = (X_17 + 1),
            Fun_18_loop(Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag_2, Max_x, Max_y, Theta_2, W_6, X_18, Y_14, Y0_2);
        _ -> {Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag, Max_x, Max_y, Theta, W_6, X_17, Y_14, Y0_2}
    end
end,
{Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag_2, Max_x, Max_y, Theta_2, W_6, X_18, Y_14, Y0_2} = Fun_18(Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag, Max_x, Max_y, Theta, W_6, X_17, Y_14, Y0_2),
            Y_15 = (Y_14 + 1),
            Fun_19_loop(Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag_2, Max_x, Max_y, Theta_2, W_6, Y_15, Y0_2);
        _ -> {Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag, Max_x, Max_y, Theta, W_6, Y_14, Y0_2}
    end
end,
{Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag_2, Max_x, Max_y, Theta_2, W_6, Y_15, Y0_2} = Fun_19(Dst_x_2, Dst_y_2, H_6, Image, Img_4, Kernel_x, Kernel_y, Mag, Max_x, Max_y, Theta, W_6, Y_14, Y0_2),
        Max_m = max_matrix(Mag_2),
        Mag_3 = scale_matrix(Mag_2, mochi_safe_div(255, Max_m)),
        [Mag_3, Theta_2]
    catch {return, Ret} -> Ret end.

print_matrix_int(Mat_4) ->
    try
        Y_16 = 0,
        Fun_21 = fun Fun_21_loop(Mat_4, Y_16) ->
    case (Y_16 < erlang:length(Mat_4)) of
        true ->
            Line = "",
            X_19 = 0,
            Fun_20 = fun Fun_20_loop(Line, Mat_4, X_19, Y_16) ->
    case (X_19 < erlang:length((case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end))) of
        true ->
            Line_2 = (Line ++ mochi_str(mochi_to_int((case erlang:is_map((case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end)) of true -> maps:get(X_19, (case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end), nil); _ -> case X_19 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end)) + X_19 + 1, (case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end)); _ -> lists:nth(X_19 + 1, (case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end)) end end)))),
            case (X_19 < (erlang:length((case erlang:is_map(Mat_4) of true -> maps:get(Y_16, Mat_4, nil); _ -> case Y_16 < 0 of true -> lists:nth(erlang:length(Mat_4) + Y_16 + 1, Mat_4); _ -> lists:nth(Y_16 + 1, Mat_4) end end)) - 1)) of
        true -> Line_3 = (Line_2 ++ " "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            X_20 = (X_19 + 1),
            Fun_20_loop(Line_4, Mat_4, X_20, Y_16);
        _ -> {Line, Mat_4, X_19, Y_16}
    end
end,
{Line_4, Mat_4, X_20, Y_16} = Fun_20(Line, Mat_4, X_19, Y_16),
            io:format("~ts~n", [mochi_repr(Line_4)]),
            Y_17 = (Y_16 + 1),
            Fun_21_loop(Mat_4, Y_17);
        _ -> {Mat_4, Y_16}
    end
end,
{Mat_4, Y_17} = Fun_21(Mat_4, Y_16),
        nil
    catch {return, Ret} -> Ret end.

print_matrix_float(Mat_5) ->
    try
        Y_18 = 0,
        Fun_23 = fun Fun_23_loop(Mat_5, Y_18) ->
    case (Y_18 < erlang:length(Mat_5)) of
        true ->
            Line_5 = "",
            X_21 = 0,
            Fun_22 = fun Fun_22_loop(Line_5, Mat_5, X_21, Y_18) ->
    case (X_21 < erlang:length((case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end))) of
        true ->
            Line_6 = (Line_5 ++ mochi_str((case erlang:is_map((case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end)) of true -> maps:get(X_21, (case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end), nil); _ -> case X_21 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end)) + X_21 + 1, (case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end)); _ -> lists:nth(X_21 + 1, (case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end)) end end))),
            case (X_21 < (erlang:length((case erlang:is_map(Mat_5) of true -> maps:get(Y_18, Mat_5, nil); _ -> case Y_18 < 0 of true -> lists:nth(erlang:length(Mat_5) + Y_18 + 1, Mat_5); _ -> lists:nth(Y_18 + 1, Mat_5) end end)) - 1)) of
        true -> Line_7 = (Line_6 ++ " "),
            Line_8 = Line_7;
        _ -> Line_8 = Line_6
    end,
            X_22 = (X_21 + 1),
            Fun_22_loop(Line_8, Mat_5, X_22, Y_18);
        _ -> {Line_5, Mat_5, X_21, Y_18}
    end
end,
{Line_8, Mat_5, X_22, Y_18} = Fun_22(Line_5, Mat_5, X_21, Y_18),
            io:format("~ts~n", [mochi_repr(Line_8)]),
            Y_19 = (Y_18 + 1),
            Fun_23_loop(Mat_5, Y_19);
        _ -> {Mat_5, Y_18}
    end
end,
{Mat_5, Y_19} = Fun_23(Mat_5, Y_18),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Img_5 = [[10, 10, 10, 10, 10], [10, 50, 50, 50, 10], [10, 50, 80, 50, 10], [10, 50, 50, 50, 10], [10, 10, 10, 10, 10]],
        Res = sobel_filter(Img_5),
        Mag_4 = (case erlang:is_map(Res) of true -> maps:get(0, Res, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Res) + 0 + 1, Res); _ -> lists:nth(0 + 1, Res) end end),
        Theta_3 = (case erlang:is_map(Res) of true -> maps:get(1, Res, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(Res) + 1 + 1, Res); _ -> lists:nth(1 + 1, Res) end end),
        print_matrix_int(Mag_4),
        print_matrix_float(Theta_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
