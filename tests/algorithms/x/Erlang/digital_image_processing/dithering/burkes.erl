#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, get_greyscale/3, zeros/2, burkes_dither/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

get_greyscale(Blue, Green, Red) ->
    try
        B = float(Blue),
        G = float(Green),
        R = float(Red),
        mochi_to_int(((mochi_safe_mul(0.114, B) + mochi_safe_mul(0.587, G)) + mochi_safe_mul(0.299, R)))
    catch {return, Ret} -> Ret end.

zeros(H, W) ->
    try
        Table = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(H, I, Table, W) ->
    case (I < H) of
        true ->
            Row = [],
            J = 0,
            Fun = fun Fun_loop(H, I, J, Row, Table, W) ->
    case (J < W) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            J_2 = (J + 1),
            Fun_loop(H, I, J_2, Row_2, Table, W);
        _ -> {H, I, J, Row, Table, W}
    end
end,
{H, I, J_2, Row_2, Table, W} = Fun(H, I, J, Row, Table, W),
            Table_2 = lists:append((case Table of nil -> []; _ -> Table end), [Row_2]),
            I_2 = (I + 1),
            Fun_2_loop(H, I_2, Table_2, W);
        _ -> {H, I, Table, W}
    end
end,
{H, I_2, Table_2, W} = Fun_2(H, I, Table, W),
        Table_2
    catch {return, Ret} -> Ret end.

burkes_dither(Img, Threshold) ->
    try
        Height = erlang:length(Img),
        Width = erlang:length((case erlang:is_map(Img) of true -> maps:get(0, Img, nil); _ -> lists:nth(0 + 1, Img) end)),
        Error_table = zeros((Height + 1), (Width + 4)),
        Output = [],
        Y = 0,
        Fun_4 = fun Fun_4_loop(Error_table, Height, Img, Output, Threshold, Width, Y) ->
    case (Y < Height) of
        true ->
            Row_3 = [],
            X = 0,
            Fun_3 = fun Fun_3_loop(Error_table, Height, Img, Output, Row_3, Threshold, Width, X, Y) ->
    case (X < Width) of
        true ->
            Px = (case erlang:is_map((case erlang:is_map(Img) of true -> maps:get(Y, Img, nil); _ -> lists:nth(Y + 1, Img) end)) of true -> maps:get(X, (case erlang:is_map(Img) of true -> maps:get(Y, Img, nil); _ -> lists:nth(Y + 1, Img) end), nil); _ -> lists:nth(X + 1, (case erlang:is_map(Img) of true -> maps:get(Y, Img, nil); _ -> lists:nth(Y + 1, Img) end)) end),
            Grey = get_greyscale((case erlang:is_map(Px) of true -> maps:get(0, Px, nil); _ -> lists:nth(0 + 1, Px) end), (case erlang:is_map(Px) of true -> maps:get(1, Px, nil); _ -> lists:nth(1 + 1, Px) end), (case erlang:is_map(Px) of true -> maps:get(2, Px, nil); _ -> lists:nth(2 + 1, Px) end)),
            Total = (Grey + (case erlang:is_map((case erlang:is_map(Error_table) of true -> maps:get(Y, Error_table, nil); _ -> lists:nth(Y + 1, Error_table) end)) of true -> maps:get((X + 2), (case erlang:is_map(Error_table) of true -> maps:get(Y, Error_table, nil); _ -> lists:nth(Y + 1, Error_table) end), nil); _ -> lists:nth((X + 2) + 1, (case erlang:is_map(Error_table) of true -> maps:get(Y, Error_table, nil); _ -> lists:nth(Y + 1, Error_table) end)) end)),
            New_val = 0,
            Current_error = 0,
            case (Threshold > Total) of
        true -> New_val_2 = 0,
            Current_error_2 = Total,
            Current_error_4 = Current_error_2,
            New_val_4 = New_val_2;
        _ -> New_val_3 = 255,
            Current_error_3 = (Total - 255),
            Current_error_4 = Current_error_3,
            New_val_4 = New_val_3
    end,
            Row_4 = lists:append((case Row_3 of nil -> []; _ -> Row_3 end), [New_val_4]),
            Error_table_2 = lists:sublist(Error_table, Y) ++ [lists:sublist(lists:nth(Y + 1, Error_table), (X + 3)) ++ [((case erlang:is_map((case erlang:is_map(Error_table) of true -> maps:get(Y, Error_table, nil); _ -> lists:nth(Y + 1, Error_table) end)) of true -> maps:get((X + 3), (case erlang:is_map(Error_table) of true -> maps:get(Y, Error_table, nil); _ -> lists:nth(Y + 1, Error_table) end), nil); _ -> lists:nth((X + 3) + 1, (case erlang:is_map(Error_table) of true -> maps:get(Y, Error_table, nil); _ -> lists:nth(Y + 1, Error_table) end)) end) + ((8 * Current_error_4) div 32))] ++ lists:nthtail((X + 3) + 1, lists:nth(Y + 1, Error_table))] ++ lists:nthtail(Y + 1, Error_table),
            Error_table_3 = lists:sublist(Error_table_2, Y) ++ [lists:sublist(lists:nth(Y + 1, Error_table_2), (X + 4)) ++ [((case erlang:is_map((case erlang:is_map(Error_table_2) of true -> maps:get(Y, Error_table_2, nil); _ -> lists:nth(Y + 1, Error_table_2) end)) of true -> maps:get((X + 4), (case erlang:is_map(Error_table_2) of true -> maps:get(Y, Error_table_2, nil); _ -> lists:nth(Y + 1, Error_table_2) end), nil); _ -> lists:nth((X + 4) + 1, (case erlang:is_map(Error_table_2) of true -> maps:get(Y, Error_table_2, nil); _ -> lists:nth(Y + 1, Error_table_2) end)) end) + ((4 * Current_error_4) div 32))] ++ lists:nthtail((X + 4) + 1, lists:nth(Y + 1, Error_table_2))] ++ lists:nthtail(Y + 1, Error_table_2),
            Error_table_4 = lists:sublist(Error_table_3, (Y + 1)) ++ [lists:sublist(lists:nth((Y + 1) + 1, Error_table_3), (X + 2)) ++ [((case erlang:is_map((case erlang:is_map(Error_table_3) of true -> maps:get((Y + 1), Error_table_3, nil); _ -> lists:nth((Y + 1) + 1, Error_table_3) end)) of true -> maps:get((X + 2), (case erlang:is_map(Error_table_3) of true -> maps:get((Y + 1), Error_table_3, nil); _ -> lists:nth((Y + 1) + 1, Error_table_3) end), nil); _ -> lists:nth((X + 2) + 1, (case erlang:is_map(Error_table_3) of true -> maps:get((Y + 1), Error_table_3, nil); _ -> lists:nth((Y + 1) + 1, Error_table_3) end)) end) + ((8 * Current_error_4) div 32))] ++ lists:nthtail((X + 2) + 1, lists:nth((Y + 1) + 1, Error_table_3))] ++ lists:nthtail((Y + 1) + 1, Error_table_3),
            Error_table_5 = lists:sublist(Error_table_4, (Y + 1)) ++ [lists:sublist(lists:nth((Y + 1) + 1, Error_table_4), (X + 3)) ++ [((case erlang:is_map((case erlang:is_map(Error_table_4) of true -> maps:get((Y + 1), Error_table_4, nil); _ -> lists:nth((Y + 1) + 1, Error_table_4) end)) of true -> maps:get((X + 3), (case erlang:is_map(Error_table_4) of true -> maps:get((Y + 1), Error_table_4, nil); _ -> lists:nth((Y + 1) + 1, Error_table_4) end), nil); _ -> lists:nth((X + 3) + 1, (case erlang:is_map(Error_table_4) of true -> maps:get((Y + 1), Error_table_4, nil); _ -> lists:nth((Y + 1) + 1, Error_table_4) end)) end) + ((4 * Current_error_4) div 32))] ++ lists:nthtail((X + 3) + 1, lists:nth((Y + 1) + 1, Error_table_4))] ++ lists:nthtail((Y + 1) + 1, Error_table_4),
            Error_table_6 = lists:sublist(Error_table_5, (Y + 1)) ++ [lists:sublist(lists:nth((Y + 1) + 1, Error_table_5), (X + 4)) ++ [((case erlang:is_map((case erlang:is_map(Error_table_5) of true -> maps:get((Y + 1), Error_table_5, nil); _ -> lists:nth((Y + 1) + 1, Error_table_5) end)) of true -> maps:get((X + 4), (case erlang:is_map(Error_table_5) of true -> maps:get((Y + 1), Error_table_5, nil); _ -> lists:nth((Y + 1) + 1, Error_table_5) end), nil); _ -> lists:nth((X + 4) + 1, (case erlang:is_map(Error_table_5) of true -> maps:get((Y + 1), Error_table_5, nil); _ -> lists:nth((Y + 1) + 1, Error_table_5) end)) end) + ((2 * Current_error_4) div 32))] ++ lists:nthtail((X + 4) + 1, lists:nth((Y + 1) + 1, Error_table_5))] ++ lists:nthtail((Y + 1) + 1, Error_table_5),
            Error_table_7 = lists:sublist(Error_table_6, (Y + 1)) ++ [lists:sublist(lists:nth((Y + 1) + 1, Error_table_6), (X + 1)) ++ [((case erlang:is_map((case erlang:is_map(Error_table_6) of true -> maps:get((Y + 1), Error_table_6, nil); _ -> lists:nth((Y + 1) + 1, Error_table_6) end)) of true -> maps:get((X + 1), (case erlang:is_map(Error_table_6) of true -> maps:get((Y + 1), Error_table_6, nil); _ -> lists:nth((Y + 1) + 1, Error_table_6) end), nil); _ -> lists:nth((X + 1) + 1, (case erlang:is_map(Error_table_6) of true -> maps:get((Y + 1), Error_table_6, nil); _ -> lists:nth((Y + 1) + 1, Error_table_6) end)) end) + ((4 * Current_error_4) div 32))] ++ lists:nthtail((X + 1) + 1, lists:nth((Y + 1) + 1, Error_table_6))] ++ lists:nthtail((Y + 1) + 1, Error_table_6),
            Error_table_8 = lists:sublist(Error_table_7, (Y + 1)) ++ [lists:sublist(lists:nth((Y + 1) + 1, Error_table_7), X) ++ [((case erlang:is_map((case erlang:is_map(Error_table_7) of true -> maps:get((Y + 1), Error_table_7, nil); _ -> lists:nth((Y + 1) + 1, Error_table_7) end)) of true -> maps:get(X, (case erlang:is_map(Error_table_7) of true -> maps:get((Y + 1), Error_table_7, nil); _ -> lists:nth((Y + 1) + 1, Error_table_7) end), nil); _ -> lists:nth(X + 1, (case erlang:is_map(Error_table_7) of true -> maps:get((Y + 1), Error_table_7, nil); _ -> lists:nth((Y + 1) + 1, Error_table_7) end)) end) + ((2 * Current_error_4) div 32))] ++ lists:nthtail(X + 1, lists:nth((Y + 1) + 1, Error_table_7))] ++ lists:nthtail((Y + 1) + 1, Error_table_7),
            X_2 = (X + 1),
            Fun_3_loop(Error_table_8, Height, Img, Output, Row_4, Threshold, Width, X_2, Y);
        _ -> {Error_table, Height, Img, Output, Row_3, Threshold, Width, X, Y}
    end
end,
{Error_table_8, Height, Img, Output, Row_4, Threshold, Width, X_2, Y} = Fun_3(Error_table, Height, Img, Output, Row_3, Threshold, Width, X, Y),
            Output_2 = lists:append((case Output of nil -> []; _ -> Output end), [Row_4]),
            Y_2 = (Y + 1),
            Fun_4_loop(Error_table_8, Height, Img, Output_2, Threshold, Width, Y_2);
        _ -> {Error_table, Height, Img, Output, Threshold, Width, Y}
    end
end,
{Error_table_8, Height, Img, Output_2, Threshold, Width, Y_2} = Fun_4(Error_table, Height, Img, Output, Threshold, Width, Y),
        Output_2
    catch {return, Ret} -> Ret end.

main() ->
    try
        Img_2 = [[[0, 0, 0], [64, 64, 64], [128, 128, 128], [192, 192, 192]], [[255, 255, 255], [200, 200, 200], [150, 150, 150], [100, 100, 100]], [[30, 144, 255], [255, 0, 0], [0, 255, 0], [0, 0, 255]], [[50, 100, 150], [80, 160, 240], [70, 140, 210], [60, 120, 180]]],
        Result = burkes_dither(Img_2, 128),
        Y_3 = 0,
        Fun_6 = fun Fun_6_loop(Img_2, Result, Y_3) ->
    case (Y_3 < erlang:length(Result)) of
        true ->
            Line = "",
            X_3 = 0,
            Fun_5 = fun Fun_5_loop(Img_2, Line, Result, X_3, Y_3) ->
    case (X_3 < erlang:length((case erlang:is_map(Result) of true -> maps:get(Y_3, Result, nil); _ -> lists:nth(Y_3 + 1, Result) end))) of
        true ->
            Line_2 = (Line ++ mochi_str((case erlang:is_map((case erlang:is_map(Result) of true -> maps:get(Y_3, Result, nil); _ -> lists:nth(Y_3 + 1, Result) end)) of true -> maps:get(X_3, (case erlang:is_map(Result) of true -> maps:get(Y_3, Result, nil); _ -> lists:nth(Y_3 + 1, Result) end), nil); _ -> lists:nth(X_3 + 1, (case erlang:is_map(Result) of true -> maps:get(Y_3, Result, nil); _ -> lists:nth(Y_3 + 1, Result) end)) end))),
            case (X_3 < (erlang:length((case erlang:is_map(Result) of true -> maps:get(Y_3, Result, nil); _ -> lists:nth(Y_3 + 1, Result) end)) - 1)) of
        true -> Line_3 = (Line_2 ++ " "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            X_4 = (X_3 + 1),
            Fun_5_loop(Img_2, Line_4, Result, X_4, Y_3);
        _ -> {Img_2, Line, Result, X_3, Y_3}
    end
end,
{Img_2, Line_4, Result, X_4, Y_3} = Fun_5(Img_2, Line, Result, X_3, Y_3),
            io:format("~ts~n", [mochi_repr(Line_4)]),
            Y_4 = (Y_3 + 1),
            Fun_6_loop(Img_2, Result, Y_4);
        _ -> {Img_2, Result, Y_3}
    end
end,
{Img_2, Result, Y_4} = Fun_6(Img_2, Result, Y_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
