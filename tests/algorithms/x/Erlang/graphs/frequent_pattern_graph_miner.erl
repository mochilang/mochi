#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, contains/2, get_distinct_edge/1, get_bitcode/2, count_ones/1, get_frequency_table/1, get_nodes/1, get_cluster/1, get_support/1, contains_bits/2, max_cluster_key/1, get_cluster_codes/2, create_edge/6, construct_graph/2, copy_list/1, my_dfs/4, find_freq_subgraph_given_support/3, node_edges/2, freq_subgraphs_edge_list/2, print_all/5, main/0]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

contains(Lst, Item) ->
    try
        Fun = fun Fun_loop(List, Item, Lst) ->
    case List of
        [] -> {Item, Lst};
        [V|V_rest] ->
            case (V == Item) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_loop(V_rest, Item, Lst);
        _ -> {Item, Lst}
    end
end,
{Item, Lst} = Fun(Lst, Item, Lst),
        false
    catch {return, Ret} -> Ret end.

get_distinct_edge(Edge_array) ->
    try
        Distinct = [],
        Fun_2 = fun Fun_2_loop(List, Distinct, Edge_array) ->
    case List of
        [] -> {Distinct, Edge_array};
        [Row|Row_rest] ->
            Fun_3 = fun Fun_3_loop(List, Distinct, Edge_array, Row) ->
    case List of
        [] -> {Distinct, Edge_array, Row};
        [Item_2|Item_2_rest] ->
            E = (case erlang:is_map(Item_2) of true -> maps:get(0, Item_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Item_2) + 0 + 1, Item_2); _ -> lists:nth(0 + 1, Item_2) end end),
            case mochi_not(mochi_member(E, Distinct)) of
        true -> Distinct_2 = lists:append((case Distinct of nil -> []; _ -> Distinct end), [E]),
            Distinct_3 = Distinct_2;
        _ -> Distinct_3 = Distinct
    end,
            Fun_3_loop(Item_2_rest, Distinct_3, Edge_array, Row);
        _ -> {Distinct, Edge_array, Row}
    end
end,
{Distinct_3, Edge_array, Row} = Fun_3(Row, Distinct, Edge_array, Row),
            Fun_2_loop(Row_rest, Distinct_3, Edge_array);
        _ -> {Distinct, Edge_array}
    end
end,
{Distinct_3, Edge_array} = Fun_2(Edge_array, Distinct, Edge_array),
        Distinct_3
    catch {return, Ret} -> Ret end.

get_bitcode(Edge_array_2, De) ->
    try
        Bitcode = "",
        I = 0,
        Fun_5 = fun Fun_5_loop(Bitcode, De, Edge_array_2, I) ->
    case (I < erlang:length(Edge_array_2)) of
        true ->
            try
                Found = false,
                Fun_4 = fun Fun_4_loop(List, Bitcode, De, Edge_array_2, Found, I) ->
    case List of
        [] -> {Bitcode, De, Edge_array_2, Found, I};
        [Item_3|Item_3_rest] ->
        try
            case ((case erlang:is_map(Item_3) of true -> maps:get(0, Item_3, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Item_3) + 0 + 1, Item_3); _ -> lists:nth(0 + 1, Item_3) end end) == De) of
        true -> Found_2 = true,
            throw({break, Bitcode, De, Edge_array_2, Found_2, I}),
            Found_3 = Found_2;
        _ -> Found_3 = Found
    end,
            Fun_4_loop(Item_3_rest, Bitcode, De, Edge_array_2, Found_3, I)
        catch
            {continue, C0, C1, C2, C3, C4} -> Fun_4_loop(Item_3_rest, C0, C1, C2, C3, C4);
            {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4};
            break -> {Bitcode, De, Edge_array_2, Found, I}
        end;
        _ -> {Bitcode, De, Edge_array_2, Found, I}
    end
end,
{Bitcode, De, Edge_array_2, Found_3, I} = Fun_4((case erlang:is_map(Edge_array_2) of true -> maps:get(I, Edge_array_2, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Edge_array_2) + I + 1, Edge_array_2); _ -> lists:nth(I + 1, Edge_array_2) end end), Bitcode, De, Edge_array_2, Found, I),
                case Found_3 of
        true -> Bitcode_2 = (Bitcode ++ "1"),
            Bitcode_4 = Bitcode_2;
        _ -> Bitcode_3 = (Bitcode ++ "0"),
            Bitcode_4 = Bitcode_3
    end,
                I_2 = (I + 1),
                Fun_5_loop(Bitcode_4, De, Edge_array_2, I_2)
            catch
                {continue, C0, C1, C2, C3} -> Fun_5_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {Bitcode, De, Edge_array_2, I}
    end
end,
{Bitcode_4, De, Edge_array_2, I_2} = Fun_5(Bitcode, De, Edge_array_2, I),
        Bitcode_4
    catch {return, Ret} -> Ret end.

count_ones(S) ->
    try
        C = 0,
        I_3 = 0,
        Fun_6 = fun Fun_6_loop(C, I_3, S) ->
    case (I_3 < erlang:length(S)) of
        true ->
            case (string:substr(S, I_3 + 1, ((I_3 + 1) - I_3)) == "1") of
        true -> C_2 = (C + 1),
            C_3 = C_2;
        _ -> C_3 = C
    end,
            I_4 = (I_3 + 1),
            Fun_6_loop(C_3, I_4, S);
        _ -> {C, I_3, S}
    end
end,
{C_3, I_4, S} = Fun_6(C, I_3, S),
        C_3
    catch {return, Ret} -> Ret end.

get_frequency_table(Edge_array_3) ->
    try
        Distinct_4 = get_distinct_edge(Edge_array_3),
        Table = [],
        Fun_7 = fun Fun_7_loop(List, Distinct_4, Edge_array_3, Table) ->
    case List of
        [] -> {Distinct_4, Edge_array_3, Table};
        [E_2|E_2_rest] ->
            Bit = get_bitcode(Edge_array_3, E_2),
            Cnt = count_ones(Bit),
            Entry = #{"edge" => E_2, "count" => mochi_str(Cnt), "bit" => Bit},
            Table_2 = lists:append((case Table of nil -> []; _ -> Table end), [Entry]),
            Fun_7_loop(E_2_rest, Distinct_4, Edge_array_3, Table_2);
        _ -> {Distinct_4, Edge_array_3, Table}
    end
end,
{Distinct_4, Edge_array_3, Table_2} = Fun_7(Distinct_4, Distinct_4, Edge_array_3, Table),
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(Distinct_4, Edge_array_3, I_5, Table_2) ->
    case (I_5 < erlang:length(Table_2)) of
        true ->
            Max_i = I_5,
            J = (I_5 + 1),
            Fun_8 = fun Fun_8_loop(Distinct_4, Edge_array_3, I_5, J, Max_i, Table_2) ->
    case (J < erlang:length(Table_2)) of
        true ->
            case (toi(maps:get("count", (case erlang:is_map(Table_2) of true -> maps:get(J, Table_2, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Table_2) + J + 1, Table_2); _ -> lists:nth(J + 1, Table_2) end end), nil)) > toi(maps:get("count", (case erlang:is_map(Table_2) of true -> maps:get(Max_i, Table_2, nil); _ -> case Max_i < 0 of true -> lists:nth(erlang:length(Table_2) + Max_i + 1, Table_2); _ -> lists:nth(Max_i + 1, Table_2) end end), nil))) of
        true -> Max_i_2 = J,
            Max_i_3 = Max_i_2;
        _ -> Max_i_3 = Max_i
    end,
            J_2 = (J + 1),
            Fun_8_loop(Distinct_4, Edge_array_3, I_5, J_2, Max_i_3, Table_2);
        _ -> {Distinct_4, Edge_array_3, I_5, J, Max_i, Table_2}
    end
end,
{Distinct_4, Edge_array_3, I_5, J_2, Max_i_3, Table_2} = Fun_8(Distinct_4, Edge_array_3, I_5, J, Max_i, Table_2),
            Tmp = (case erlang:is_map(Table_2) of true -> maps:get(I_5, Table_2, nil); _ -> case I_5 < 0 of true -> lists:nth(erlang:length(Table_2) + I_5 + 1, Table_2); _ -> lists:nth(I_5 + 1, Table_2) end end),
            Table_3 = lists:sublist(Table_2, I_5) ++ [(case erlang:is_map(Table_2) of true -> maps:get(Max_i_3, Table_2, nil); _ -> case Max_i_3 < 0 of true -> lists:nth(erlang:length(Table_2) + Max_i_3 + 1, Table_2); _ -> lists:nth(Max_i_3 + 1, Table_2) end end)] ++ lists:nthtail(I_5 + 1, Table_2),
            Table_4 = lists:sublist(Table_3, Max_i_3) ++ [Tmp] ++ lists:nthtail(Max_i_3 + 1, Table_3),
            I_6 = (I_5 + 1),
            Fun_9_loop(Distinct_4, Edge_array_3, I_6, Table_4);
        _ -> {Distinct_4, Edge_array_3, I_5, Table_2}
    end
end,
{Distinct_4, Edge_array_3, I_6, Table_4} = Fun_9(Distinct_4, Edge_array_3, I_5, Table_2),
        Table_4
    catch {return, Ret} -> Ret end.

get_nodes(Freq_table) ->
    try
        Nodes = #{},
        Keys = [],
        Fun_10 = fun Fun_10_loop(List, Freq_table, Keys, Nodes) ->
    case List of
        [] -> {Freq_table, Keys, Nodes};
        [F|F_rest] ->
            Code = maps:get("bit", F, nil),
            Edge = maps:get("edge", F, nil),
            case maps:is_key(Code, Nodes) of
        true -> Nodes_2 = maps:put(Code, lists:append((case maps:get(Code, Nodes, nil) of nil -> []; _ -> maps:get(Code, Nodes, nil) end), [Edge]), Nodes),
            Keys_3 = Keys,
            Nodes_4 = Nodes_2;
        _ -> Nodes_3 = maps:put(Code, [Edge], Nodes),
            Keys_2 = lists:append((case Keys of nil -> []; _ -> Keys end), [Code]),
            Keys_3 = Keys_2,
            Nodes_4 = Nodes_3
    end,
            Fun_10_loop(F_rest, Freq_table, Keys_3, Nodes_4);
        _ -> {Freq_table, Keys, Nodes}
    end
end,
{Freq_table, Keys_3, Nodes_4} = Fun_10(Freq_table, Freq_table, Keys, Nodes),
        #{"map" => Nodes_4, "keys" => Keys_3}
    catch {return, Ret} -> Ret end.

get_cluster(Nodes_5) ->
    try
        Clusters = #{},
        Weights = [],
        I_7 = 0,
        Fun_11 = fun Fun_11_loop(Clusters, I_7, Nodes_5, Weights) ->
    case (I_7 < erlang:length(maps:get("keys", Nodes_5, nil))) of
        true ->
            Code_2 = (case erlang:is_map(maps:get("keys", Nodes_5, nil)) of true -> maps:get(I_7, maps:get("keys", Nodes_5, nil), nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(maps:get("keys", Nodes_5, nil)) + I_7 + 1, maps:get("keys", Nodes_5, nil)); _ -> lists:nth(I_7 + 1, maps:get("keys", Nodes_5, nil)) end end),
            Wt = count_ones(Code_2),
            case maps:is_key(Wt, Clusters) of
        true -> Clusters_2 = maps:put(Wt, lists:append((case maps:get(Wt, Clusters, nil) of nil -> []; _ -> maps:get(Wt, Clusters, nil) end), [Code_2]), Clusters),
            Clusters_4 = Clusters_2,
            Weights_3 = Weights;
        _ -> Clusters_3 = maps:put(Wt, [Code_2], Clusters),
            Weights_2 = lists:append((case Weights of nil -> []; _ -> Weights end), [Wt]),
            Clusters_4 = Clusters_3,
            Weights_3 = Weights_2
    end,
            I_8 = (I_7 + 1),
            Fun_11_loop(Clusters_4, I_8, Nodes_5, Weights_3);
        _ -> {Clusters, I_7, Nodes_5, Weights}
    end
end,
{Clusters_4, I_8, Nodes_5, Weights_3} = Fun_11(Clusters, I_7, Nodes_5, Weights),
        #{"clusters" => Clusters_4, "weights" => Weights_3}
    catch {return, Ret} -> Ret end.

get_support(Clusters_5) ->
    try
        Sup = [],
        I_9 = 0,
        Fun_12 = fun Fun_12_loop(Clusters_5, I_9, Sup) ->
    case (I_9 < erlang:length(maps:get("weights", Clusters_5, nil))) of
        true ->
            W = (case erlang:is_map(maps:get("weights", Clusters_5, nil)) of true -> maps:get(I_9, maps:get("weights", Clusters_5, nil), nil); _ -> case I_9 < 0 of true -> lists:nth(erlang:length(maps:get("weights", Clusters_5, nil)) + I_9 + 1, maps:get("weights", Clusters_5, nil)); _ -> lists:nth(I_9 + 1, maps:get("weights", Clusters_5, nil)) end end),
            Sup_2 = lists:append((case Sup of nil -> []; _ -> Sup end), [((W * 100) div erlang:length(maps:get("weights", Clusters_5, nil)))]),
            I_10 = (I_9 + 1),
            Fun_12_loop(Clusters_5, I_10, Sup_2);
        _ -> {Clusters_5, I_9, Sup}
    end
end,
{Clusters_5, I_10, Sup_2} = Fun_12(Clusters_5, I_9, Sup),
        Sup_2
    catch {return, Ret} -> Ret end.

contains_bits(A, B) ->
    try
        I_11 = 0,
        Fun_13 = fun Fun_13_loop(A, B, I_11) ->
    case (I_11 < erlang:length(A)) of
        true ->
            C1 = string:substr(A, I_11 + 1, ((I_11 + 1) - I_11)),
            C2 = string:substr(B, I_11 + 1, ((I_11 + 1) - I_11)),
            case ((C1 == "1") andalso (C2 /= "1")) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_12 = (I_11 + 1),
            Fun_13_loop(A, B, I_12);
        _ -> {A, B, I_11}
    end
end,
{A, B, I_12} = Fun_13(A, B, I_11),
        true
    catch {return, Ret} -> Ret end.

max_cluster_key(Clusters_6) ->
    try
        M = 0,
        I_13 = 0,
        Fun_14 = fun Fun_14_loop(Clusters_6, I_13, M) ->
    case (I_13 < erlang:length(maps:get("weights", Clusters_6, nil))) of
        true ->
            W_2 = (case erlang:is_map(maps:get("weights", Clusters_6, nil)) of true -> maps:get(I_13, maps:get("weights", Clusters_6, nil), nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(maps:get("weights", Clusters_6, nil)) + I_13 + 1, maps:get("weights", Clusters_6, nil)); _ -> lists:nth(I_13 + 1, maps:get("weights", Clusters_6, nil)) end end),
            case (W_2 > M) of
        true -> M_2 = W_2,
            M_3 = M_2;
        _ -> M_3 = M
    end,
            I_14 = (I_13 + 1),
            Fun_14_loop(Clusters_6, I_14, M_3);
        _ -> {Clusters_6, I_13, M}
    end
end,
{Clusters_6, I_14, M_3} = Fun_14(Clusters_6, I_13, M),
        M_3
    catch {return, Ret} -> Ret end.

get_cluster_codes(Clusters_7, Wt_2) ->
    try
        (case maps:is_key(Wt_2, maps:get("clusters", Clusters_7, nil)) of
    true -> maps:get(Wt_2, maps:get("clusters", Clusters_7, nil), nil);
    _ -> []
end)
    catch {return, Ret} -> Ret end.

create_edge(Nodes_6, Graph, Gkeys, Clusters_8, C1_2, Maxk) ->
    try
        Keys_4 = Gkeys,
        Codes1 = get_cluster_codes(Clusters_8, C1_2),
        Idx1 = 0,
        Fun_17 = fun Fun_17_loop(C1_2, Clusters_8, Codes1, Gkeys, Graph, Idx1, Keys_4, Maxk, Nodes_6) ->
    case (Idx1 < erlang:length(Codes1)) of
        true ->
            try
                I_code = (case erlang:is_map(Codes1) of true -> maps:get(Idx1, Codes1, nil); _ -> case Idx1 < 0 of true -> lists:nth(erlang:length(Codes1) + Idx1 + 1, Codes1); _ -> lists:nth(Idx1 + 1, Codes1) end end),
                Count = 0,
                C2_2 = (C1_2 + 1),
                Fun_16 = fun Fun_16_loop(C1_2, C2_2, Clusters_8, Codes1, Count, Gkeys, Graph, I_code, Idx1, Keys_4, Maxk, Nodes_6) ->
    case (C2_2 =< Maxk) of
        true ->
            try
                Codes2 = get_cluster_codes(Clusters_8, C2_2),
                J_3 = 0,
                Fun_15 = fun Fun_15_loop(C1_2, C2_2, Clusters_8, Codes1, Codes2, Count, Gkeys, Graph, I_code, Idx1, J_3, Keys_4, Maxk, Nodes_6) ->
    case (J_3 < erlang:length(Codes2)) of
        true ->
            J_code = (case erlang:is_map(Codes2) of true -> maps:get(J_3, Codes2, nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length(Codes2) + J_3 + 1, Codes2); _ -> lists:nth(J_3 + 1, Codes2) end end),
            case contains_bits(I_code, J_code) of
        true -> case maps:is_key(I_code, Graph) of
        true -> Graph_2 = maps:put(I_code, lists:append((case maps:get(I_code, Graph, nil) of nil -> []; _ -> maps:get(I_code, Graph, nil) end), [J_code]), Graph),
            Graph_4 = Graph_2,
            Keys_7 = Keys_4;
        _ -> Graph_3 = maps:put(I_code, [J_code], Graph),
            case mochi_not(mochi_member(I_code, Keys_4)) of
        true -> Keys_5 = lists:append((case Keys_4 of nil -> []; _ -> Keys_4 end), [I_code]),
            Keys_6 = Keys_5;
        _ -> Keys_6 = Keys_4
    end,
            Graph_4 = Graph_3,
            Keys_7 = Keys_6
    end,
            case mochi_not(mochi_member(J_code, Keys_7)) of
        true -> Keys_8 = lists:append((case Keys_7 of nil -> []; _ -> Keys_7 end), [J_code]),
            Keys_9 = Keys_8;
        _ -> Keys_9 = Keys_7
    end,
            Count_2 = (Count + 1),
            Count_3 = Count_2,
            Graph_5 = Graph_4,
            Keys_10 = Keys_9;
        _ -> Count_3 = Count,
            Graph_5 = Graph,
            Keys_10 = Keys_4
    end,
            J_4 = (J_3 + 1),
            Fun_15_loop(C1_2, C2_2, Clusters_8, Codes1, Codes2, Count_3, Gkeys, Graph_5, I_code, Idx1, J_4, Keys_10, Maxk, Nodes_6);
        _ -> {C1_2, C2_2, Clusters_8, Codes1, Codes2, Count, Gkeys, Graph, I_code, Idx1, J_3, Keys_4, Maxk, Nodes_6}
    end
end,
{C1_2, C2_2, Clusters_8, Codes1, Codes2, Count_3, Gkeys, Graph_5, I_code, Idx1, J_4, Keys_10, Maxk, Nodes_6} = Fun_15(C1_2, C2_2, Clusters_8, Codes1, Codes2, Count, Gkeys, Graph, I_code, Idx1, J_3, Keys_4, Maxk, Nodes_6),
                case (Count_3 == 0) of
        true -> C2_3 = (C2_2 + 1),
            C2_4 = C2_3;
        _ -> throw({break, C1_2, C2_2, Clusters_8, Codes1, Count_3, Gkeys, Graph_5, I_code, Idx1, Keys_10, Maxk, Nodes_6}),
            C2_4 = C2_2
    end,
                Fun_16_loop(C1_2, C2_4, Clusters_8, Codes1, Count_3, Gkeys, Graph_5, I_code, Idx1, Keys_10, Maxk, Nodes_6)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11} -> Fun_16_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11}
            end;
        _ -> {C1_2, C2_2, Clusters_8, Codes1, Count, Gkeys, Graph, I_code, Idx1, Keys_4, Maxk, Nodes_6}
    end
end,
{C1_2, C2_4, Clusters_8, Codes1, Count_3, Gkeys, Graph_5, I_code, Idx1, Keys_10, Maxk, Nodes_6} = Fun_16(C1_2, C2_2, Clusters_8, Codes1, Count, Gkeys, Graph, I_code, Idx1, Keys_4, Maxk, Nodes_6),
                Idx1_2 = (Idx1 + 1),
                Fun_17_loop(C1_2, Clusters_8, Codes1, Gkeys, Graph_5, Idx1_2, Keys_10, Maxk, Nodes_6)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_17_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8}
            end;
        _ -> {C1_2, Clusters_8, Codes1, Gkeys, Graph, Idx1, Keys_4, Maxk, Nodes_6}
    end
end,
{C1_2, Clusters_8, Codes1, Gkeys, Graph_5, Idx1_2, Keys_10, Maxk, Nodes_6} = Fun_17(C1_2, Clusters_8, Codes1, Gkeys, Graph, Idx1, Keys_4, Maxk, Nodes_6),
        Keys_10
    catch {return, Ret} -> Ret end.

construct_graph(Clusters_9, Nodes_7) ->
    try
        Maxk_2 = max_cluster_key(Clusters_9),
        Top_codes = get_cluster_codes(Clusters_9, Maxk_2),
        Graph_6 = #{},
        Keys_11 = ["Header"],
        Graph_7 = maps:put("Header", [], Graph_6),
        I_15 = 0,
        Fun_18 = fun Fun_18_loop(Clusters_9, Graph_7, I_15, Keys_11, Maxk_2, Nodes_7, Top_codes) ->
    case (I_15 < erlang:length(Top_codes)) of
        true ->
            Code_3 = (case erlang:is_map(Top_codes) of true -> maps:get(I_15, Top_codes, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Top_codes) + I_15 + 1, Top_codes); _ -> lists:nth(I_15 + 1, Top_codes) end end),
            Graph_8 = maps:put("Header", lists:append((case maps:get("Header", Graph_7, nil) of nil -> []; _ -> maps:get("Header", Graph_7, nil) end), [Code_3]), Graph_7),
            Graph_9 = maps:put(Code_3, ["Header"], Graph_8),
            Keys_12 = lists:append((case Keys_11 of nil -> []; _ -> Keys_11 end), [Code_3]),
            I_16 = (I_15 + 1),
            Fun_18_loop(Clusters_9, Graph_9, I_16, Keys_12, Maxk_2, Nodes_7, Top_codes);
        _ -> {Clusters_9, Graph_7, I_15, Keys_11, Maxk_2, Nodes_7, Top_codes}
    end
end,
{Clusters_9, Graph_9, I_16, Keys_12, Maxk_2, Nodes_7, Top_codes} = Fun_18(Clusters_9, Graph_7, I_15, Keys_11, Maxk_2, Nodes_7, Top_codes),
        C_4 = 1,
        Fun_19 = fun Fun_19_loop(C_4, Clusters_9, Graph_9, I_16, Keys_12, Maxk_2, Nodes_7, Top_codes) ->
    case (C_4 < Maxk_2) of
        true ->
            Keys_13 = create_edge(Nodes_7, Graph_9, Keys_12, Clusters_9, C_4, Maxk_2),
            C_5 = (C_4 + 1),
            Fun_19_loop(C_5, Clusters_9, Graph_9, I_16, Keys_13, Maxk_2, Nodes_7, Top_codes);
        _ -> {C_4, Clusters_9, Graph_9, I_16, Keys_12, Maxk_2, Nodes_7, Top_codes}
    end
end,
{C_5, Clusters_9, Graph_9, I_16, Keys_13, Maxk_2, Nodes_7, Top_codes} = Fun_19(C_4, Clusters_9, Graph_9, I_16, Keys_12, Maxk_2, Nodes_7, Top_codes),
        #{"edges" => Graph_9, "keys" => Keys_13}
    catch {return, Ret} -> Ret end.

copy_list(Lst_2) ->
    try
        N = [],
        Fun_20 = fun Fun_20_loop(List, Lst_2, N) ->
    case List of
        [] -> {Lst_2, N};
        [V_2|V_2_rest] ->
            N_2 = lists:append((case N of nil -> []; _ -> N end), [V_2]),
            Fun_20_loop(V_2_rest, Lst_2, N_2);
        _ -> {Lst_2, N}
    end
end,
{Lst_2, N_2} = Fun_20(Lst_2, Lst_2, N),
        N_2
    catch {return, Ret} -> Ret end.

my_dfs(Graph_10, Start, End, Path) ->
    try
        New_path = copy_list(Path),
        New_path_2 = lists:append((case New_path of nil -> []; _ -> New_path end), [Start]),
        case (Start == End) of
        true -> erlang:put('paths', lists:append((case erlang:get('paths') of nil -> []; _ -> erlang:get('paths') end), [New_path_2])),
            throw({return, nil});
        _ -> ok
    end,
        Fun_21 = fun Fun_21_loop(List, End, Graph_10, New_path_2, Path, Start) ->
    case List of
        [] -> {End, Graph_10, New_path_2, Path, Start};
        [Node|Node_rest] ->
            Seen = false,
            Fun_22 = fun Fun_22_loop(List, End, Graph_10, New_path_2, Node, Path, Seen, Start) ->
    case List of
        [] -> {End, Graph_10, New_path_2, Node, Path, Seen, Start};
        [P|P_rest] ->
            case (P == Node) of
        true -> Seen_2 = true,
            Seen_3 = Seen_2;
        _ -> Seen_3 = Seen
    end,
            Fun_22_loop(P_rest, End, Graph_10, New_path_2, Node, Path, Seen_3, Start);
        _ -> {End, Graph_10, New_path_2, Node, Path, Seen, Start}
    end
end,
{End, Graph_10, New_path_2, Node, Path, Seen_3, Start} = Fun_22(New_path_2, End, Graph_10, New_path_2, Node, Path, Seen, Start),
            case mochi_not(Seen_3) of
        true -> my_dfs(Graph_10, Node, End, New_path_2);
        _ -> ok
    end,
            Fun_21_loop(Node_rest, End, Graph_10, New_path_2, Path, Start);
        _ -> {End, Graph_10, New_path_2, Path, Start}
    end
end,
{End, Graph_10, New_path_2, Path, Start} = Fun_21(maps:get(Start, Graph_10, nil), End, Graph_10, New_path_2, Path, Start),
        nil
    catch {return, Ret} -> Ret end.

find_freq_subgraph_given_support(S_2, Clusters_10, Graph_11) ->
    try
        K = ((S_2 * erlang:length(maps:get("weights", Clusters_10, nil))) div 100),
        Codes = get_cluster_codes(Clusters_10, K),
        I_17 = 0,
        Fun_23 = fun Fun_23_loop(Clusters_10, Codes, Graph_11, I_17, K, S_2) ->
    case (I_17 < erlang:length(Codes)) of
        true ->
            my_dfs(maps:get("edges", Graph_11, nil), (case erlang:is_map(Codes) of true -> maps:get(I_17, Codes, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Codes) + I_17 + 1, Codes); _ -> lists:nth(I_17 + 1, Codes) end end), "Header", []),
            I_18 = (I_17 + 1),
            Fun_23_loop(Clusters_10, Codes, Graph_11, I_18, K, S_2);
        _ -> {Clusters_10, Codes, Graph_11, I_17, K, S_2}
    end
end,
{Clusters_10, Codes, Graph_11, I_18, K, S_2} = Fun_23(Clusters_10, Codes, Graph_11, I_17, K, S_2),
        nil
    catch {return, Ret} -> Ret end.

node_edges(Nodes_8, Code_4) ->
    try
        maps:get(Code_4, maps:get("map", Nodes_8, nil), nil)
    catch {return, Ret} -> Ret end.

freq_subgraphs_edge_list(Paths, Nodes_9) ->
    try
        Freq_sub_el = [],
        Fun_24 = fun Fun_24_loop(List, Freq_sub_el, Nodes_9, Paths) ->
    case List of
        [] -> {Freq_sub_el, Nodes_9, Paths};
        [Path_2|Path_2_rest] ->
            El = [],
            J_5 = 0,
            Fun_26 = fun Fun_26_loop(El, Freq_sub_el, J_5, Nodes_9, Path_2, Paths) ->
    case (J_5 < (erlang:length(Path_2) - 1)) of
        true ->
            Code_5 = (case erlang:is_map(Path_2) of true -> maps:get(J_5, Path_2, nil); _ -> case J_5 < 0 of true -> lists:nth(erlang:length(Path_2) + J_5 + 1, Path_2); _ -> lists:nth(J_5 + 1, Path_2) end end),
            Edge_list = node_edges(Nodes_9, Code_5),
            E_3 = 0,
            Fun_25 = fun Fun_25_loop(Code_5, E_3, Edge_list, El, Freq_sub_el, J_5, Nodes_9, Path_2, Paths) ->
    case (E_3 < erlang:length(Edge_list)) of
        true ->
            Edge_2 = (case erlang:is_map(Edge_list) of true -> maps:get(E_3, Edge_list, nil); _ -> case E_3 < 0 of true -> lists:nth(erlang:length(Edge_list) + E_3 + 1, Edge_list); _ -> lists:nth(E_3 + 1, Edge_list) end end),
            A_2 = string:substr(Edge_2, 0 + 1, (1 - 0)),
            B_2 = string:substr(Edge_2, 1 + 1, (2 - 1)),
            El_2 = lists:append((case El of nil -> []; _ -> El end), [[A_2, B_2]]),
            E_4 = (E_3 + 1),
            Fun_25_loop(Code_5, E_4, Edge_list, El_2, Freq_sub_el, J_5, Nodes_9, Path_2, Paths);
        _ -> {Code_5, E_3, Edge_list, El, Freq_sub_el, J_5, Nodes_9, Path_2, Paths}
    end
end,
{Code_5, E_4, Edge_list, El_2, Freq_sub_el, J_5, Nodes_9, Path_2, Paths} = Fun_25(Code_5, E_3, Edge_list, El, Freq_sub_el, J_5, Nodes_9, Path_2, Paths),
            J_6 = (J_5 + 1),
            Fun_26_loop(El_2, Freq_sub_el, J_6, Nodes_9, Path_2, Paths);
        _ -> {El, Freq_sub_el, J_5, Nodes_9, Path_2, Paths}
    end
end,
{El_2, Freq_sub_el, J_6, Nodes_9, Path_2, Paths} = Fun_26(El, Freq_sub_el, J_5, Nodes_9, Path_2, Paths),
            Freq_sub_el_2 = lists:append((case Freq_sub_el of nil -> []; _ -> Freq_sub_el end), [El_2]),
            Fun_24_loop(Path_2_rest, Freq_sub_el_2, Nodes_9, Paths);
        _ -> {Freq_sub_el, Nodes_9, Paths}
    end
end,
{Freq_sub_el_2, Nodes_9, Paths} = Fun_24(erlang:get('paths'), Freq_sub_el, Nodes_9, Paths),
        Freq_sub_el_2
    catch {return, Ret} -> Ret end.

print_all(Nodes_10, Support, Clusters_11, Graph_12, Freq_subgraph_edge_list) ->
    try
        io:format("~ts~n", [mochi_repr("\nNodes\n")]),
        I_19 = 0,
        Fun_27 = fun Fun_27_loop(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_19, Nodes_10, Support) ->
    case (I_19 < erlang:length(maps:get("keys", Nodes_10, nil))) of
        true ->
            Code_6 = (case erlang:is_map(maps:get("keys", Nodes_10, nil)) of true -> maps:get(I_19, maps:get("keys", Nodes_10, nil), nil); _ -> case I_19 < 0 of true -> lists:nth(erlang:length(maps:get("keys", Nodes_10, nil)) + I_19 + 1, maps:get("keys", Nodes_10, nil)); _ -> lists:nth(I_19 + 1, maps:get("keys", Nodes_10, nil)) end end),
            io:format("~ts~n", [mochi_repr(Code_6)]),
            io:format("~ts~n", [mochi_repr(maps:get(Code_6, maps:get("map", Nodes_10, nil), nil))]),
            I_20 = (I_19 + 1),
            Fun_27_loop(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, Nodes_10, Support);
        _ -> {Clusters_11, Freq_subgraph_edge_list, Graph_12, I_19, Nodes_10, Support}
    end
end,
{Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, Nodes_10, Support} = Fun_27(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_19, Nodes_10, Support),
        io:format("~ts~n", [mochi_repr("\nSupport\n")]),
        io:format("~ts~n", [mochi_repr(Support)]),
        io:format("~ts~n", [mochi_repr("\nCluster\n")]),
        J_7 = 0,
        Fun_28 = fun Fun_28_loop(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_7, Nodes_10, Support) ->
    case (J_7 < erlang:length(maps:get("weights", Clusters_11, nil))) of
        true ->
            W_3 = (case erlang:is_map(maps:get("weights", Clusters_11, nil)) of true -> maps:get(J_7, maps:get("weights", Clusters_11, nil), nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(maps:get("weights", Clusters_11, nil)) + J_7 + 1, maps:get("weights", Clusters_11, nil)); _ -> lists:nth(J_7 + 1, maps:get("weights", Clusters_11, nil)) end end),
            io:format("~ts~n", [mochi_repr(((mochi_str(W_3) ++ ":") ++ mochi_str(maps:get(W_3, maps:get("clusters", Clusters_11, nil), nil))))]),
            J_8 = (J_7 + 1),
            Fun_28_loop(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, Nodes_10, Support);
        _ -> {Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_7, Nodes_10, Support}
    end
end,
{Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, Nodes_10, Support} = Fun_28(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_7, Nodes_10, Support),
        io:format("~ts~n", [mochi_repr("\nGraph\n")]),
        K_2 = 0,
        Fun_29 = fun Fun_29_loop(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_2, Nodes_10, Support) ->
    case (K_2 < erlang:length(maps:get("keys", Graph_12, nil))) of
        true ->
            Key = (case erlang:is_map(maps:get("keys", Graph_12, nil)) of true -> maps:get(K_2, maps:get("keys", Graph_12, nil), nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(maps:get("keys", Graph_12, nil)) + K_2 + 1, maps:get("keys", Graph_12, nil)); _ -> lists:nth(K_2 + 1, maps:get("keys", Graph_12, nil)) end end),
            io:format("~ts~n", [mochi_repr(Key)]),
            io:format("~ts~n", [mochi_repr(maps:get(Key, maps:get("edges", Graph_12, nil), nil))]),
            K_3 = (K_2 + 1),
            Fun_29_loop(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support);
        _ -> {Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_2, Nodes_10, Support}
    end
end,
{Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support} = Fun_29(Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_2, Nodes_10, Support),
        io:format("~ts~n", [mochi_repr("\nEdge List of Frequent subgraphs\n")]),
        Fun_30 = fun Fun_30_loop(List, Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support) ->
    case List of
        [] -> {Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support};
        [El_3|El_3_rest] ->
            io:format("~ts~n", [mochi_repr(El_3)]),
            Fun_30_loop(El_3_rest, Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support);
        _ -> {Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support}
    end
end,
{Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support} = Fun_30(Freq_subgraph_edge_list, Clusters_11, Freq_subgraph_edge_list, Graph_12, I_20, J_8, K_3, Nodes_10, Support),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Frequency_table = get_frequency_table(erlang:get('EDGE_ARRAY')),
        Nodes_11 = get_nodes(Frequency_table),
        Clusters_12 = get_cluster(Nodes_11),
        Support_2 = get_support(Clusters_12),
        Graph_13 = construct_graph(Clusters_12, Nodes_11),
        find_freq_subgraph_given_support(60, Clusters_12, Graph_13),
        Freq_subgraph_edge_list_2 = freq_subgraphs_edge_list(erlang:get('paths'), Nodes_11),
        print_all(Nodes_11, Support_2, Clusters_12, Graph_13, Freq_subgraph_edge_list_2),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('EDGE_ARRAY', [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]]),
    erlang:put('paths', []),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
