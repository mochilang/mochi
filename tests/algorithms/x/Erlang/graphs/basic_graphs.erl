#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, dfs/2, bfs/2, sort_ints/1, dijkstra/2, topo/2, floyd/1, prim/3, sort_edges/1, find_parent/2, union_parent/3, kruskal/2, find_isolated_nodes/2]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

dfs(G, S) ->
    try
        Visited = #{},
        Stack = [],
        Visited_2 = maps:put(S, true, Visited),
        Stack_2 = lists:append((case Stack of nil -> []; _ -> Stack end), [S]),
        io:format("~ts~n", [mochi_repr(S)]),
        Fun_2 = fun Fun_2_loop(G, S, Stack_2, Visited_2) ->
    case (erlang:length(Stack_2) > 0) of
        true ->
            try
                U = (case erlang:is_map(Stack_2) of true -> maps:get((erlang:length(Stack_2) - 1), Stack_2, nil); _ -> case (erlang:length(Stack_2) - 1) < 0 of true -> lists:nth(erlang:length(Stack_2) + (erlang:length(Stack_2) - 1) + 1, Stack_2); _ -> lists:nth((erlang:length(Stack_2) - 1) + 1, Stack_2) end end),
                Found = false,
                Fun = fun Fun_loop(List, Found, G, S, Stack_2, U, Visited_2) ->
    case List of
        [] -> {Found, G, S, Stack_2, U, Visited_2};
        [V|V_rest] ->
        try
            case mochi_not(maps:is_key(V, Visited_2)) of
        true -> Visited_3 = maps:put(V, true, Visited_2),
            Stack_3 = lists:append((case Stack_2 of nil -> []; _ -> Stack_2 end), [V]),
            io:format("~ts~n", [mochi_repr(V)]),
            Found_2 = true,
            throw({break, Found_2, G, S, Stack_3, U, Visited_3}),
            Found_3 = Found_2,
            Stack_4 = Stack_3,
            Visited_4 = Visited_3;
        _ -> Found_3 = Found,
            Stack_4 = Stack_2,
            Visited_4 = Visited_2
    end,
            Fun_loop(V_rest, Found_3, G, S, Stack_4, U, Visited_4)
        catch
            {continue, C0, C1, C2, C3, C4, C5} -> Fun_loop(V_rest, C0, C1, C2, C3, C4, C5);
            {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5};
            break -> {Found, G, S, Stack_2, U, Visited_2}
        end;
        _ -> {Found, G, S, Stack_2, U, Visited_2}
    end
end,
{Found_3, G, S, Stack_4, U, Visited_4} = Fun(maps:get(U, G, nil), Found, G, S, Stack_2, U, Visited_2),
                case mochi_not(Found_3) of
        true -> Stack_5 = (case erlang:is_binary(Stack_4) of true -> string:substr(Stack_4, 0 + 1, ((erlang:length(Stack_4) - 1) - 0)); _ -> lists:sublist(Stack_4, (0 + 1), ((erlang:length(Stack_4) - 1) - 0)) end),
            Stack_6 = Stack_5;
        _ -> Stack_6 = Stack_4
    end,
                Fun_2_loop(G, S, Stack_6, Visited_4)
            catch
                {continue, C0, C1, C2, C3} -> Fun_2_loop(C0, C1, C2, C3);
                {break, B0, B1, B2, B3} -> {B0, B1, B2, B3}
            end;
        _ -> {G, S, Stack_2, Visited_2}
    end
end,
{G, S, Stack_6, Visited_4} = Fun_2(G, S, Stack_2, Visited_2),
        nil
    catch {return, Ret} -> Ret end.

bfs(G_2, S_2) ->
    try
        Visited_5 = #{},
        Q = [],
        Visited_6 = maps:put(S_2, true, Visited_5),
        Q_2 = lists:append((case Q of nil -> []; _ -> Q end), [S_2]),
        io:format("~ts~n", [mochi_repr(S_2)]),
        Fun_4 = fun Fun_4_loop(G_2, Q_2, S_2, Visited_6) ->
    case (erlang:length(Q_2) > 0) of
        true ->
            U_2 = (case erlang:is_map(Q_2) of true -> maps:get(0, Q_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Q_2) + 0 + 1, Q_2); _ -> lists:nth(0 + 1, Q_2) end end),
            Q_3 = (case erlang:is_binary(Q_2) of true -> string:substr(Q_2, 1 + 1, (erlang:length(Q_2) - 1)); _ -> lists:sublist(Q_2, (1 + 1), (erlang:length(Q_2) - 1)) end),
            Fun_3 = fun Fun_3_loop(List, G_2, Q_3, S_2, U_2, Visited_6) ->
    case List of
        [] -> {G_2, Q_3, S_2, U_2, Visited_6};
        [V_2|V_2_rest] ->
            case mochi_not(maps:is_key(V_2, Visited_6)) of
        true -> Visited_7 = maps:put(V_2, true, Visited_6),
            Q_4 = lists:append((case Q_3 of nil -> []; _ -> Q_3 end), [V_2]),
            io:format("~ts~n", [mochi_repr(V_2)]),
            Q_5 = Q_4,
            Visited_8 = Visited_7;
        _ -> Q_5 = Q_3,
            Visited_8 = Visited_6
    end,
            Fun_3_loop(V_2_rest, G_2, Q_5, S_2, U_2, Visited_8);
        _ -> {G_2, Q_3, S_2, U_2, Visited_6}
    end
end,
{G_2, Q_5, S_2, U_2, Visited_8} = Fun_3(maps:get(U_2, G_2, nil), G_2, Q_3, S_2, U_2, Visited_6),
            Fun_4_loop(G_2, Q_5, S_2, Visited_8);
        _ -> {G_2, Q_2, S_2, Visited_6}
    end
end,
{G_2, Q_5, S_2, Visited_8} = Fun_4(G_2, Q_2, S_2, Visited_6),
        nil
    catch {return, Ret} -> Ret end.

sort_ints(A) ->
    try
        Arr = A,
        I = 0,
        Fun_6 = fun Fun_6_loop(A, Arr, I) ->
    case (I < erlang:length(Arr)) of
        true ->
            J = 0,
            Fun_5 = fun Fun_5_loop(A, Arr, I, J) ->
    case (J < ((erlang:length(Arr) - I) - 1)) of
        true ->
            case ((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Arr) + J + 1, Arr); _ -> lists:nth(J + 1, Arr) end end) > (case erlang:is_map(Arr) of true -> maps:get((J + 1), Arr, nil); _ -> case (J + 1) < 0 of true -> lists:nth(erlang:length(Arr) + (J + 1) + 1, Arr); _ -> lists:nth((J + 1) + 1, Arr) end end)) of
        true -> Tmp = (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Arr) + J + 1, Arr); _ -> lists:nth(J + 1, Arr) end end),
            Arr_2 = lists:sublist(Arr, J) ++ [(case erlang:is_map(Arr) of true -> maps:get((J + 1), Arr, nil); _ -> case (J + 1) < 0 of true -> lists:nth(erlang:length(Arr) + (J + 1) + 1, Arr); _ -> lists:nth((J + 1) + 1, Arr) end end)] ++ lists:nthtail(J + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, (J + 1)) ++ [Tmp] ++ lists:nthtail((J + 1) + 1, Arr_2),
            Arr_4 = Arr_3,
            Tmp_2 = Tmp;
        _ -> Arr_4 = Arr,
            Tmp_2 = nil
    end,
            J_2 = (J + 1),
            Fun_5_loop(A, Arr_4, I, J_2);
        _ -> {A, Arr, I, J}
    end
end,
{A, Arr_4, I, J_2} = Fun_5(A, Arr, I, J),
            I_2 = (I + 1),
            Fun_6_loop(A, Arr_4, I_2);
        _ -> {A, Arr, I}
    end
end,
{A, Arr_4, I_2} = Fun_6(A, Arr, I),
        Arr_4
    catch {return, Ret} -> Ret end.

dijkstra(G_3, S_3) ->
    try
        Dist = #{},
        Dist_2 = maps:put(S_3, 0, Dist),
        Path = #{},
        Path_2 = maps:put(S_3, 0, Path),
        Known = [],
        Keys = [S_3],
        Fun_9 = fun Fun_9_loop(Dist_2, G_3, Keys, Known, Path_2, S_3) ->
    case (erlang:length(Known) < erlang:length(Keys)) of
        true ->
            Mini = 100000,
            U_3 = -1,
            I_3 = 0,
            Fun_7 = fun Fun_7_loop(Dist_2, G_3, I_3, Keys, Known, Mini, Path_2, S_3, U_3) ->
    case (I_3 < erlang:length(Keys)) of
        true ->
            K = (case erlang:is_map(Keys) of true -> maps:get(I_3, Keys, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Keys) + I_3 + 1, Keys); _ -> lists:nth(I_3 + 1, Keys) end end),
            D = maps:get(K, Dist_2, nil),
            case (mochi_not(mochi_member(K, Known)) andalso (D < Mini)) of
        true -> Mini_2 = D,
            U_4 = K,
            Mini_3 = Mini_2,
            U_5 = U_4;
        _ -> Mini_3 = Mini,
            U_5 = U_3
    end,
            I_4 = (I_3 + 1),
            Fun_7_loop(Dist_2, G_3, I_4, Keys, Known, Mini_3, Path_2, S_3, U_5);
        _ -> {Dist_2, G_3, I_3, Keys, Known, Mini, Path_2, S_3, U_3}
    end
end,
{Dist_2, G_3, I_4, Keys, Known, Mini_3, Path_2, S_3, U_5} = Fun_7(Dist_2, G_3, I_3, Keys, Known, Mini, Path_2, S_3, U_3),
            Known_2 = lists:append((case Known of nil -> []; _ -> Known end), [U_5]),
            Fun_8 = fun Fun_8_loop(List, Dist_2, G_3, I_4, Keys, Known_2, Mini_3, Path_2, S_3, U_5) ->
    case List of
        [] -> {Dist_2, G_3, I_4, Keys, Known_2, Mini_3, Path_2, S_3, U_5};
        [E|E_rest] ->
            V_3 = (case erlang:is_map(E) of true -> maps:get(0, E, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(E) + 0 + 1, E); _ -> lists:nth(0 + 1, E) end end),
            W = (case erlang:is_map(E) of true -> maps:get(1, E, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E) + 1 + 1, E); _ -> lists:nth(1 + 1, E) end end),
            case mochi_not(mochi_member(V_3, Keys)) of
        true -> Keys_2 = lists:append((case Keys of nil -> []; _ -> Keys end), [V_3]),
            Keys_3 = Keys_2;
        _ -> Keys_3 = Keys
    end,
            Alt = (maps:get(U_5, Dist_2, nil) + W),
            Cur = (case maps:is_key(V_3, Dist_2) of
    true -> maps:get(V_3, Dist_2, nil);
    _ -> 100000
end),
            case (mochi_not(mochi_member(V_3, Known_2)) andalso (Alt < Cur)) of
        true -> Dist_3 = maps:put(V_3, Alt, Dist_2),
            Path_3 = maps:put(V_3, U_5, Path_2),
            Dist_4 = Dist_3,
            Path_4 = Path_3;
        _ -> Dist_4 = Dist_2,
            Path_4 = Path_2
    end,
            Fun_8_loop(E_rest, Dist_4, G_3, I_4, Keys_3, Known_2, Mini_3, Path_4, S_3, U_5);
        _ -> {Dist_2, G_3, I_4, Keys, Known_2, Mini_3, Path_2, S_3, U_5}
    end
end,
{Dist_4, G_3, I_4, Keys_3, Known_2, Mini_3, Path_4, S_3, U_5} = Fun_8(maps:get(U_5, G_3, nil), Dist_2, G_3, I_4, Keys, Known_2, Mini_3, Path_2, S_3, U_5),
            Fun_9_loop(Dist_4, G_3, Keys_3, Known_2, Path_4, S_3);
        _ -> {Dist_2, G_3, Keys, Known, Path_2, S_3}
    end
end,
{Dist_4, G_3, Keys_3, Known_2, Path_4, S_3} = Fun_9(Dist_2, G_3, Keys, Known, Path_2, S_3),
        Ordered = sort_ints(Keys_3),
        Idx = 0,
        Fun_10 = fun Fun_10_loop(Dist_4, G_3, Idx, Keys_3, Known_2, Ordered, Path_4, S_3) ->
    case (Idx < erlang:length(Ordered)) of
        true ->
            K_2 = (case erlang:is_map(Ordered) of true -> maps:get(Idx, Ordered, nil); _ -> case Idx < 0 of true -> lists:nth(erlang:length(Ordered) + Idx + 1, Ordered); _ -> lists:nth(Idx + 1, Ordered) end end),
            case (K_2 /= S_3) of
        true -> io:format("~ts~n", [mochi_repr((case erlang:is_map(Dist_4) of true -> maps:get(K_2, Dist_4, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(Dist_4) + K_2 + 1, Dist_4); _ -> lists:nth(K_2 + 1, Dist_4) end end))]);
        _ -> ok
    end,
            Idx_2 = (Idx + 1),
            Fun_10_loop(Dist_4, G_3, Idx_2, Keys_3, Known_2, Ordered, Path_4, S_3);
        _ -> {Dist_4, G_3, Idx, Keys_3, Known_2, Ordered, Path_4, S_3}
    end
end,
{Dist_4, G_3, Idx_2, Keys_3, Known_2, Ordered, Path_4, S_3} = Fun_10(Dist_4, G_3, Idx, Keys_3, Known_2, Ordered, Path_4, S_3),
        nil
    catch {return, Ret} -> Ret end.

topo(G_4, N) ->
    try
        Ind = [],
        I_5 = 0,
        Fun_11 = fun Fun_11_loop(G_4, I_5, Ind, N) ->
    case (I_5 =< N) of
        true ->
            Ind_2 = lists:append((case Ind of nil -> []; _ -> Ind end), [0]),
            I_6 = (I_5 + 1),
            Fun_11_loop(G_4, I_6, Ind_2, N);
        _ -> {G_4, I_5, Ind, N}
    end
end,
{G_4, I_6, Ind_2, N} = Fun_11(G_4, I_5, Ind, N),
        Node = 1,
        Fun_13 = fun Fun_13_loop(G_4, I_6, Ind_2, N, Node) ->
    case (Node =< N) of
        true ->
            Fun_12 = fun Fun_12_loop(List, G_4, I_6, Ind_2, N, Node) ->
    case List of
        [] -> {G_4, I_6, Ind_2, N, Node};
        [V_4|V_4_rest] ->
            Ind_3 = lists:sublist(Ind_2, V_4) ++ [((case erlang:is_map(Ind_2) of true -> maps:get(V_4, Ind_2, nil); _ -> case V_4 < 0 of true -> lists:nth(erlang:length(Ind_2) + V_4 + 1, Ind_2); _ -> lists:nth(V_4 + 1, Ind_2) end end) + 1)] ++ lists:nthtail(V_4 + 1, Ind_2),
            Fun_12_loop(V_4_rest, G_4, I_6, Ind_3, N, Node);
        _ -> {G_4, I_6, Ind_2, N, Node}
    end
end,
{G_4, I_6, Ind_3, N, Node} = Fun_12(maps:get(Node, G_4, nil), G_4, I_6, Ind_2, N, Node),
            Node_2 = (Node + 1),
            Fun_13_loop(G_4, I_6, Ind_3, N, Node_2);
        _ -> {G_4, I_6, Ind_2, N, Node}
    end
end,
{G_4, I_6, Ind_3, N, Node_2} = Fun_13(G_4, I_6, Ind_2, N, Node),
        Q_6 = [],
        J_3 = 1,
        Fun_14 = fun Fun_14_loop(G_4, I_6, Ind_3, J_3, N, Node_2, Q_6) ->
    case (J_3 =< N) of
        true ->
            case ((case erlang:is_map(Ind_3) of true -> maps:get(J_3, Ind_3, nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length(Ind_3) + J_3 + 1, Ind_3); _ -> lists:nth(J_3 + 1, Ind_3) end end) == 0) of
        true -> Q_7 = lists:append((case Q_6 of nil -> []; _ -> Q_6 end), [J_3]),
            Q_8 = Q_7;
        _ -> Q_8 = Q_6
    end,
            J_4 = (J_3 + 1),
            Fun_14_loop(G_4, I_6, Ind_3, J_4, N, Node_2, Q_8);
        _ -> {G_4, I_6, Ind_3, J_3, N, Node_2, Q_6}
    end
end,
{G_4, I_6, Ind_3, J_4, N, Node_2, Q_8} = Fun_14(G_4, I_6, Ind_3, J_3, N, Node_2, Q_6),
        Fun_16 = fun Fun_16_loop(G_4, I_6, Ind_3, J_4, N, Node_2, Q_8) ->
    case (erlang:length(Q_8) > 0) of
        true ->
            V_5 = (case erlang:is_map(Q_8) of true -> maps:get(0, Q_8, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Q_8) + 0 + 1, Q_8); _ -> lists:nth(0 + 1, Q_8) end end),
            Q_9 = (case erlang:is_binary(Q_8) of true -> string:substr(Q_8, 1 + 1, (erlang:length(Q_8) - 1)); _ -> lists:sublist(Q_8, (1 + 1), (erlang:length(Q_8) - 1)) end),
            io:format("~ts~n", [mochi_repr(V_5)]),
            Fun_15 = fun Fun_15_loop(List, G_4, I_6, Ind_3, J_4, N, Node_2, Q_9, V_5) ->
    case List of
        [] -> {G_4, I_6, Ind_3, J_4, N, Node_2, Q_9, V_5};
        [W_2|W_2_rest] ->
            Ind_4 = lists:sublist(Ind_3, W_2) ++ [((case erlang:is_map(Ind_3) of true -> maps:get(W_2, Ind_3, nil); _ -> case W_2 < 0 of true -> lists:nth(erlang:length(Ind_3) + W_2 + 1, Ind_3); _ -> lists:nth(W_2 + 1, Ind_3) end end) - 1)] ++ lists:nthtail(W_2 + 1, Ind_3),
            case ((case erlang:is_map(Ind_4) of true -> maps:get(W_2, Ind_4, nil); _ -> case W_2 < 0 of true -> lists:nth(erlang:length(Ind_4) + W_2 + 1, Ind_4); _ -> lists:nth(W_2 + 1, Ind_4) end end) == 0) of
        true -> Q_10 = lists:append((case Q_9 of nil -> []; _ -> Q_9 end), [W_2]),
            Q_11 = Q_10;
        _ -> Q_11 = Q_9
    end,
            Fun_15_loop(W_2_rest, G_4, I_6, Ind_4, J_4, N, Node_2, Q_11, V_5);
        _ -> {G_4, I_6, Ind_3, J_4, N, Node_2, Q_9, V_5}
    end
end,
{G_4, I_6, Ind_4, J_4, N, Node_2, Q_11, V_5} = Fun_15(maps:get(V_5, G_4, nil), G_4, I_6, Ind_3, J_4, N, Node_2, Q_9, V_5),
            Fun_16_loop(G_4, I_6, Ind_4, J_4, N, Node_2, Q_11);
        _ -> {G_4, I_6, Ind_3, J_4, N, Node_2, Q_8}
    end
end,
{G_4, I_6, Ind_4, J_4, N, Node_2, Q_11} = Fun_16(G_4, I_6, Ind_3, J_4, N, Node_2, Q_8),
        nil
    catch {return, Ret} -> Ret end.

floyd(A_2) ->
    try
        N_2 = erlang:length(A_2),
        Dist_5 = [],
        I_7 = 0,
        Fun_18 = fun Fun_18_loop(A_2, Dist_5, I_7, N_2) ->
    case (I_7 < N_2) of
        true ->
            Row = [],
            J_5 = 0,
            Fun_17 = fun Fun_17_loop(A_2, Dist_5, I_7, J_5, N_2, Row) ->
    case (J_5 < N_2) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [(case erlang:is_map((case erlang:is_map(A_2) of true -> maps:get(I_7, A_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(A_2) + I_7 + 1, A_2); _ -> lists:nth(I_7 + 1, A_2) end end)) of true -> maps:get(J_5, (case erlang:is_map(A_2) of true -> maps:get(I_7, A_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(A_2) + I_7 + 1, A_2); _ -> lists:nth(I_7 + 1, A_2) end end), nil); _ -> case J_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_2) of true -> maps:get(I_7, A_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(A_2) + I_7 + 1, A_2); _ -> lists:nth(I_7 + 1, A_2) end end)) + J_5 + 1, (case erlang:is_map(A_2) of true -> maps:get(I_7, A_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(A_2) + I_7 + 1, A_2); _ -> lists:nth(I_7 + 1, A_2) end end)); _ -> lists:nth(J_5 + 1, (case erlang:is_map(A_2) of true -> maps:get(I_7, A_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(A_2) + I_7 + 1, A_2); _ -> lists:nth(I_7 + 1, A_2) end end)) end end)]),
            J_6 = (J_5 + 1),
            Fun_17_loop(A_2, Dist_5, I_7, J_6, N_2, Row_2);
        _ -> {A_2, Dist_5, I_7, J_5, N_2, Row}
    end
end,
{A_2, Dist_5, I_7, J_6, N_2, Row_2} = Fun_17(A_2, Dist_5, I_7, J_5, N_2, Row),
            Dist_6 = lists:append((case Dist_5 of nil -> []; _ -> Dist_5 end), [Row_2]),
            I_8 = (I_7 + 1),
            Fun_18_loop(A_2, Dist_6, I_8, N_2);
        _ -> {A_2, Dist_5, I_7, N_2}
    end
end,
{A_2, Dist_6, I_8, N_2} = Fun_18(A_2, Dist_5, I_7, N_2),
        K_3 = 0,
        Fun_21 = fun Fun_21_loop(A_2, Dist_6, I_8, K_3, N_2) ->
    case (K_3 < N_2) of
        true ->
            Ii = 0,
            Fun_20 = fun Fun_20_loop(A_2, Dist_6, I_8, Ii, K_3, N_2) ->
    case (Ii < N_2) of
        true ->
            Jj = 0,
            Fun_19 = fun Fun_19_loop(A_2, Dist_6, I_8, Ii, Jj, K_3, N_2) ->
    case (Jj < N_2) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) of true -> maps:get(Jj, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end), nil); _ -> case Jj < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) + Jj + 1, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)); _ -> lists:nth(Jj + 1, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) end end) > ((case erlang:is_map((case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) of true -> maps:get(K_3, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end), nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) + K_3 + 1, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)); _ -> lists:nth(K_3 + 1, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) end end) + (case erlang:is_map((case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)) of true -> maps:get(Jj, (case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end), nil); _ -> case Jj < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)) + Jj + 1, (case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)); _ -> lists:nth(Jj + 1, (case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)) end end))) of
        true -> Dist_7 = lists:sublist(Dist_6, Ii) ++ [lists:sublist(lists:nth(Ii + 1, Dist_6), Jj) ++ [((case erlang:is_map((case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) of true -> maps:get(K_3, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end), nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) + K_3 + 1, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)); _ -> lists:nth(K_3 + 1, (case erlang:is_map(Dist_6) of true -> maps:get(Ii, Dist_6, nil); _ -> case Ii < 0 of true -> lists:nth(erlang:length(Dist_6) + Ii + 1, Dist_6); _ -> lists:nth(Ii + 1, Dist_6) end end)) end end) + (case erlang:is_map((case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)) of true -> maps:get(Jj, (case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end), nil); _ -> case Jj < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)) + Jj + 1, (case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)); _ -> lists:nth(Jj + 1, (case erlang:is_map(Dist_6) of true -> maps:get(K_3, Dist_6, nil); _ -> case K_3 < 0 of true -> lists:nth(erlang:length(Dist_6) + K_3 + 1, Dist_6); _ -> lists:nth(K_3 + 1, Dist_6) end end)) end end))] ++ lists:nthtail(Jj + 1, lists:nth(Ii + 1, Dist_6))] ++ lists:nthtail(Ii + 1, Dist_6),
            Dist_8 = Dist_7;
        _ -> Dist_8 = Dist_6
    end,
            Jj_2 = (Jj + 1),
            Fun_19_loop(A_2, Dist_8, I_8, Ii, Jj_2, K_3, N_2);
        _ -> {A_2, Dist_6, I_8, Ii, Jj, K_3, N_2}
    end
end,
{A_2, Dist_8, I_8, Ii, Jj_2, K_3, N_2} = Fun_19(A_2, Dist_6, I_8, Ii, Jj, K_3, N_2),
            Ii_2 = (Ii + 1),
            Fun_20_loop(A_2, Dist_8, I_8, Ii_2, K_3, N_2);
        _ -> {A_2, Dist_6, I_8, Ii, K_3, N_2}
    end
end,
{A_2, Dist_8, I_8, Ii_2, K_3, N_2} = Fun_20(A_2, Dist_6, I_8, Ii, K_3, N_2),
            K_4 = (K_3 + 1),
            Fun_21_loop(A_2, Dist_8, I_8, K_4, N_2);
        _ -> {A_2, Dist_6, I_8, K_3, N_2}
    end
end,
{A_2, Dist_8, I_8, K_4, N_2} = Fun_21(A_2, Dist_6, I_8, K_3, N_2),
        io:format("~ts~n", [mochi_repr(Dist_8)]),
        nil
    catch {return, Ret} -> Ret end.

prim(G_5, S_4, N_3) ->
    try
        Dist_9 = #{},
        Dist_10 = maps:put(S_4, 0, Dist_9),
        Known_3 = [],
        Keys_4 = [S_4],
        Total = 0,
        Fun_24 = fun Fun_24_loop(Dist_10, G_5, Keys_4, Known_3, N_3, S_4, Total) ->
    case (erlang:length(Known_3) < N_3) of
        true ->
            Mini_4 = 100000,
            U_6 = -1,
            I_9 = 0,
            Fun_22 = fun Fun_22_loop(Dist_10, G_5, I_9, Keys_4, Known_3, Mini_4, N_3, S_4, Total, U_6) ->
    case (I_9 < erlang:length(Keys_4)) of
        true ->
            K_5 = (case erlang:is_map(Keys_4) of true -> maps:get(I_9, Keys_4, nil); _ -> case I_9 < 0 of true -> lists:nth(erlang:length(Keys_4) + I_9 + 1, Keys_4); _ -> lists:nth(I_9 + 1, Keys_4) end end),
            D_2 = maps:get(K_5, Dist_10, nil),
            case (mochi_not(mochi_member(K_5, Known_3)) andalso (D_2 < Mini_4)) of
        true -> Mini_5 = D_2,
            U_7 = K_5,
            Mini_6 = Mini_5,
            U_8 = U_7;
        _ -> Mini_6 = Mini_4,
            U_8 = U_6
    end,
            I_10 = (I_9 + 1),
            Fun_22_loop(Dist_10, G_5, I_10, Keys_4, Known_3, Mini_6, N_3, S_4, Total, U_8);
        _ -> {Dist_10, G_5, I_9, Keys_4, Known_3, Mini_4, N_3, S_4, Total, U_6}
    end
end,
{Dist_10, G_5, I_10, Keys_4, Known_3, Mini_6, N_3, S_4, Total, U_8} = Fun_22(Dist_10, G_5, I_9, Keys_4, Known_3, Mini_4, N_3, S_4, Total, U_6),
            Known_4 = lists:append((case Known_3 of nil -> []; _ -> Known_3 end), [U_8]),
            Total_2 = (Total + Mini_6),
            Fun_23 = fun Fun_23_loop(List, Dist_10, G_5, I_10, Keys_4, Known_4, Mini_6, N_3, S_4, Total_2, U_8) ->
    case List of
        [] -> {Dist_10, G_5, I_10, Keys_4, Known_4, Mini_6, N_3, S_4, Total_2, U_8};
        [E_2|E_2_rest] ->
            V_6 = (case erlang:is_map(E_2) of true -> maps:get(0, E_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(E_2) + 0 + 1, E_2); _ -> lists:nth(0 + 1, E_2) end end),
            W_3 = (case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end),
            case mochi_not(mochi_member(V_6, Keys_4)) of
        true -> Keys_5 = lists:append((case Keys_4 of nil -> []; _ -> Keys_4 end), [V_6]),
            Keys_6 = Keys_5;
        _ -> Keys_6 = Keys_4
    end,
            Cur_2 = (case maps:is_key(V_6, Dist_10) of
    true -> maps:get(V_6, Dist_10, nil);
    _ -> 100000
end),
            case (mochi_not(mochi_member(V_6, Known_4)) andalso (W_3 < Cur_2)) of
        true -> Dist_11 = maps:put(V_6, W_3, Dist_10),
            Dist_12 = Dist_11;
        _ -> Dist_12 = Dist_10
    end,
            Fun_23_loop(E_2_rest, Dist_12, G_5, I_10, Keys_6, Known_4, Mini_6, N_3, S_4, Total_2, U_8);
        _ -> {Dist_10, G_5, I_10, Keys_4, Known_4, Mini_6, N_3, S_4, Total_2, U_8}
    end
end,
{Dist_12, G_5, I_10, Keys_6, Known_4, Mini_6, N_3, S_4, Total_2, U_8} = Fun_23(maps:get(U_8, G_5, nil), Dist_10, G_5, I_10, Keys_4, Known_4, Mini_6, N_3, S_4, Total_2, U_8),
            Fun_24_loop(Dist_12, G_5, Keys_6, Known_4, N_3, S_4, Total_2);
        _ -> {Dist_10, G_5, Keys_4, Known_3, N_3, S_4, Total}
    end
end,
{Dist_12, G_5, Keys_6, Known_4, N_3, S_4, Total_2} = Fun_24(Dist_10, G_5, Keys_4, Known_3, N_3, S_4, Total),
        Total_2
    catch {return, Ret} -> Ret end.

sort_edges(Edges) ->
    try
        Es = Edges,
        I_11 = 0,
        Fun_26 = fun Fun_26_loop(Edges, Es, I_11) ->
    case (I_11 < erlang:length(Es)) of
        true ->
            J_7 = 0,
            Fun_25 = fun Fun_25_loop(Edges, Es, I_11, J_7) ->
    case (J_7 < ((erlang:length(Es) - I_11) - 1)) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Es) of true -> maps:get(J_7, Es, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Es) + J_7 + 1, Es); _ -> lists:nth(J_7 + 1, Es) end end)) of true -> maps:get(2, (case erlang:is_map(Es) of true -> maps:get(J_7, Es, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Es) + J_7 + 1, Es); _ -> lists:nth(J_7 + 1, Es) end end), nil); _ -> case 2 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Es) of true -> maps:get(J_7, Es, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Es) + J_7 + 1, Es); _ -> lists:nth(J_7 + 1, Es) end end)) + 2 + 1, (case erlang:is_map(Es) of true -> maps:get(J_7, Es, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Es) + J_7 + 1, Es); _ -> lists:nth(J_7 + 1, Es) end end)); _ -> lists:nth(2 + 1, (case erlang:is_map(Es) of true -> maps:get(J_7, Es, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Es) + J_7 + 1, Es); _ -> lists:nth(J_7 + 1, Es) end end)) end end) > (case erlang:is_map((case erlang:is_map(Es) of true -> maps:get((J_7 + 1), Es, nil); _ -> case (J_7 + 1) < 0 of true -> lists:nth(erlang:length(Es) + (J_7 + 1) + 1, Es); _ -> lists:nth((J_7 + 1) + 1, Es) end end)) of true -> maps:get(2, (case erlang:is_map(Es) of true -> maps:get((J_7 + 1), Es, nil); _ -> case (J_7 + 1) < 0 of true -> lists:nth(erlang:length(Es) + (J_7 + 1) + 1, Es); _ -> lists:nth((J_7 + 1) + 1, Es) end end), nil); _ -> case 2 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Es) of true -> maps:get((J_7 + 1), Es, nil); _ -> case (J_7 + 1) < 0 of true -> lists:nth(erlang:length(Es) + (J_7 + 1) + 1, Es); _ -> lists:nth((J_7 + 1) + 1, Es) end end)) + 2 + 1, (case erlang:is_map(Es) of true -> maps:get((J_7 + 1), Es, nil); _ -> case (J_7 + 1) < 0 of true -> lists:nth(erlang:length(Es) + (J_7 + 1) + 1, Es); _ -> lists:nth((J_7 + 1) + 1, Es) end end)); _ -> lists:nth(2 + 1, (case erlang:is_map(Es) of true -> maps:get((J_7 + 1), Es, nil); _ -> case (J_7 + 1) < 0 of true -> lists:nth(erlang:length(Es) + (J_7 + 1) + 1, Es); _ -> lists:nth((J_7 + 1) + 1, Es) end end)) end end)) of
        true -> Tmp_3 = (case erlang:is_map(Es) of true -> maps:get(J_7, Es, nil); _ -> case J_7 < 0 of true -> lists:nth(erlang:length(Es) + J_7 + 1, Es); _ -> lists:nth(J_7 + 1, Es) end end),
            Es_2 = lists:sublist(Es, J_7) ++ [(case erlang:is_map(Es) of true -> maps:get((J_7 + 1), Es, nil); _ -> case (J_7 + 1) < 0 of true -> lists:nth(erlang:length(Es) + (J_7 + 1) + 1, Es); _ -> lists:nth((J_7 + 1) + 1, Es) end end)] ++ lists:nthtail(J_7 + 1, Es),
            Es_3 = lists:sublist(Es_2, (J_7 + 1)) ++ [Tmp_3] ++ lists:nthtail((J_7 + 1) + 1, Es_2),
            Es_4 = Es_3,
            Tmp_4 = Tmp_3;
        _ -> Es_4 = Es,
            Tmp_4 = nil
    end,
            J_8 = (J_7 + 1),
            Fun_25_loop(Edges, Es_4, I_11, J_8);
        _ -> {Edges, Es, I_11, J_7}
    end
end,
{Edges, Es_4, I_11, J_8} = Fun_25(Edges, Es, I_11, J_7),
            I_12 = (I_11 + 1),
            Fun_26_loop(Edges, Es_4, I_12);
        _ -> {Edges, Es, I_11}
    end
end,
{Edges, Es_4, I_12} = Fun_26(Edges, Es, I_11),
        Es_4
    catch {return, Ret} -> Ret end.

find_parent(Parent, X) ->
    try
        R = X,
        Fun_27 = fun Fun_27_loop(Parent, R, X) ->
    case ((case erlang:is_map(Parent) of true -> maps:get(R, Parent, nil); _ -> case R < 0 of true -> lists:nth(erlang:length(Parent) + R + 1, Parent); _ -> lists:nth(R + 1, Parent) end end) /= R) of
        true ->
            R_2 = (case erlang:is_map(Parent) of true -> maps:get(R, Parent, nil); _ -> case R < 0 of true -> lists:nth(erlang:length(Parent) + R + 1, Parent); _ -> lists:nth(R + 1, Parent) end end),
            Fun_27_loop(Parent, R_2, X);
        _ -> {Parent, R, X}
    end
end,
{Parent, R_2, X} = Fun_27(Parent, R, X),
        R_2
    catch {return, Ret} -> Ret end.

union_parent(Parent_2, A_3, B) ->
    try
        Parent_3 = lists:sublist(Parent_2, A_3) ++ [B] ++ lists:nthtail(A_3 + 1, Parent_2),
        {nil, Parent_3}
    catch {return, Ret} -> Ret end.

kruskal(Edges_2, N_4) ->
    try
        Es_5 = sort_edges(Edges_2),
        Parent_4 = [],
        I_13 = 0,
        Fun_28 = fun Fun_28_loop(Edges_2, Es_5, I_13, N_4, Parent_4) ->
    case (I_13 =< N_4) of
        true ->
            Parent_5 = lists:append((case Parent_4 of nil -> []; _ -> Parent_4 end), [I_13]),
            I_14 = (I_13 + 1),
            Fun_28_loop(Edges_2, Es_5, I_14, N_4, Parent_5);
        _ -> {Edges_2, Es_5, I_13, N_4, Parent_4}
    end
end,
{Edges_2, Es_5, I_14, N_4, Parent_5} = Fun_28(Edges_2, Es_5, I_13, N_4, Parent_4),
        Total_3 = 0,
        Count = 0,
        Idx_3 = 0,
        Fun_29 = fun Fun_29_loop(Count, Edges_2, Es_5, I_14, Idx_3, N_4, Parent_5, Total_3) ->
    case ((Count < (N_4 - 1)) andalso (Idx_3 < erlang:length(Es_5))) of
        true ->
            E_3 = (case erlang:is_map(Es_5) of true -> maps:get(Idx_3, Es_5, nil); _ -> case Idx_3 < 0 of true -> lists:nth(erlang:length(Es_5) + Idx_3 + 1, Es_5); _ -> lists:nth(Idx_3 + 1, Es_5) end end),
            Idx_4 = (Idx_3 + 1),
            U_9 = (case erlang:is_map(E_3) of true -> maps:get(0, E_3, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(E_3) + 0 + 1, E_3); _ -> lists:nth(0 + 1, E_3) end end),
            V_7 = (case erlang:is_map(E_3) of true -> maps:get(1, E_3, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_3) + 1 + 1, E_3); _ -> lists:nth(1 + 1, E_3) end end),
            W_4 = (case erlang:is_map(E_3) of true -> maps:get(2, E_3, nil); _ -> case 2 < 0 of true -> lists:nth(erlang:length(E_3) + 2 + 1, E_3); _ -> lists:nth(2 + 1, E_3) end end),
            Ru = find_parent(Parent_5, U_9),
            Rv = find_parent(Parent_5, V_7),
            case (Ru /= Rv) of
        true -> {_, Parent_5} = union_parent(Parent_5, Ru, Rv),
            Total_4 = (Total_3 + W_4),
            Count_2 = (Count + 1),
            Parent_5_2 = Parent_5,
            Count_3 = Count_2,
            Total_5 = Total_4;
        _ -> Parent_5_2 = nil,
            Count_3 = Count,
            Total_5 = Total_3
    end,
            Fun_29_loop(Count_3, Edges_2, Es_5, I_14, Idx_4, N_4, Parent_5, Total_5);
        _ -> {Count, Edges_2, Es_5, I_14, Idx_3, N_4, Parent_5, Total_3}
    end
end,
{Count_3, Edges_2, Es_5, I_14, Idx_4, N_4, Parent_5, Total_5} = Fun_29(Count, Edges_2, Es_5, I_14, Idx_3, N_4, Parent_5, Total_3),
        Total_5
    catch {return, Ret} -> Ret end.

find_isolated_nodes(G_6, Nodes) ->
    try
        Isolated = [],
        Fun_30 = fun Fun_30_loop(List, G_6, Isolated, Nodes) ->
    case List of
        [] -> {G_6, Isolated, Nodes};
        [Node_3|Node_3_rest] ->
            case (erlang:length(maps:get(Node_3, G_6, nil)) == 0) of
        true -> Isolated_2 = lists:append((case Isolated of nil -> []; _ -> Isolated end), [Node_3]),
            Isolated_3 = Isolated_2;
        _ -> Isolated_3 = Isolated
    end,
            Fun_30_loop(Node_3_rest, G_6, Isolated_3, Nodes);
        _ -> {G_6, Isolated, Nodes}
    end
end,
{G_6, Isolated_3, Nodes} = Fun_30(Nodes, G_6, Isolated, Nodes),
        Isolated_3
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('g_dfs', #{1 => [2, 3], 2 => [4, 5], 3 => [], 4 => [], 5 => []}),
    erlang:put('g_bfs', #{1 => [2, 3], 2 => [4, 5], 3 => [6, 7], 4 => [], 5 => [8], 6 => [], 7 => [], 8 => []}),
    erlang:put('g_weighted', #{1 => [[2, 7], [3, 9], [6, 14]], 2 => [[1, 7], [3, 10], [4, 15]], 3 => [[1, 9], [2, 10], [4, 11], [6, 2]], 4 => [[2, 15], [3, 11], [5, 6]], 5 => [[4, 6], [6, 9]], 6 => [[1, 14], [3, 2], [5, 9]]}),
    erlang:put('g_topo', #{1 => [2, 3], 2 => [4], 3 => [4], 4 => []}),
    erlang:put('matrix', [[0, 5, 9, 100000], [100000, 0, 2, 8], [100000, 100000, 0, 7], [4, 100000, 100000, 0]]),
    erlang:put('g_prim', #{1 => [[2, 1], [3, 3]], 2 => [[1, 1], [3, 1], [4, 6]], 3 => [[1, 3], [2, 1], [4, 2]], 4 => [[2, 6], [3, 2]]}),
    erlang:put('edges_kruskal', [[1, 2, 1], [2, 3, 2], [1, 3, 2], [3, 4, 1]]),
    erlang:put('g_iso', #{1 => [2, 3], 2 => [1, 3], 3 => [1, 2], 4 => []}),
    dfs(erlang:get('g_dfs'), 1),
    bfs(erlang:get('g_bfs'), 1),
    dijkstra(erlang:get('g_weighted'), 1),
    topo(erlang:get('g_topo'), 4),
    floyd(erlang:get('matrix')),
    io:format("~ts~n", [mochi_repr(prim(erlang:get('g_prim'), 1, 4))]),
    io:format("~ts~n", [mochi_repr(kruskal(erlang:get('edges_kruskal'), 4))]),
    erlang:put('iso', find_isolated_nodes(erlang:get('g_iso'), [1, 2, 3, 4])),
    io:format("~ts~n", [mochi_repr(erlang:get('iso'))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
