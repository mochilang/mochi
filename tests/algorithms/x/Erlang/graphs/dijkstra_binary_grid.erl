#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, key/1, path_to_string/1, dijkstra/4, print_result/1]).

% Generated by Mochi transpiler v0.10.65 (428ea06e9a)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


toi(V) ->
    mochi_to_int(V).


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) ->
                K = case Key of
                    <<_/binary>> -> Key;
                    _ when is_integer(Key) -> <<Key>>;
                    _ -> list_to_binary(Key)
                end,
                binary:match(Coll, K) /= nomatch;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    erlang:float_to_list(V, [short]);
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

key(P) ->
    try
        ((mochi_str(maps:get("x", P, nil)) ++ ",") ++ mochi_str(maps:get("y", P, nil)))
    catch {return, RetCatch} -> RetCatch end.

path_to_string(Path) ->
    try
        S = "[",
        I = 0,
        Fun = fun Fun_loop(I, Path, S) ->
    case (I < erlang:length(Path)) of
        true ->
            Pt = (case erlang:is_map(Path) of true -> maps:get(I, Path, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Path) + I + 1, Path); _ -> mochi_nth(I + 1, Path) end end),
            S_2 = (((((S ++ "(") ++ mochi_str(maps:get("x", Pt, nil))) ++ ", ") ++ mochi_str(maps:get("y", Pt, nil))) ++ ")"),
            case (I < (erlang:length(Path) - 1)) of
        true -> S_3 = (S_2 ++ ", "),
            S_4 = S_3;
        _ -> S_4 = S_2
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, Path, S_4);
        _ -> {I, Path, S}
    end
end,
{I_2, Path, S_4} = Fun(I, Path, S),
        S_5 = (S_4 ++ "]"),
        S_5
    catch {return, RetCatch} -> RetCatch end.

dijkstra(Grid, Source, Destination, Allow_diagonal) ->
    try
        Rows = erlang:length(Grid),
        Cols = erlang:length((case erlang:is_map(Grid) of true -> maps:get(0, Grid, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Grid) + 0 + 1, Grid); _ -> mochi_nth(0 + 1, Grid) end end)),
        Dx = [-1, 1, 0, 0],
        Dy = [0, 0, -1, 1],
        case Allow_diagonal of
        true -> Dx_2 = lists:append(Dx, [-1, -1, 1, 1]),
            Dy_2 = lists:append(Dy, [-1, 1, -1, 1]),
            Dx_3 = Dx_2,
            Dy_3 = Dy_2;
        _ -> Dx_3 = Dx,
            Dy_3 = Dy
    end,
        INF = 1000000000000.0,
        Queue = [Source],
        Front = 0,
        Dist_map = #{key(Source) => 0.0},
        Prev = #{},
        Fun_3 = fun Fun_3_loop(INF, Allow_diagonal, Cols, Destination, Dist_map, Dx_3, Dy_3, Front, Grid, Prev, Queue, Rows, Source) ->
    case (Front < erlang:length(Queue)) of
        true ->
            try
                Current = (case erlang:is_map(Queue) of true -> maps:get(Front, Queue, nil); _ -> case Front < 0 of true -> mochi_nth(erlang:length(Queue) + Front + 1, Queue); _ -> mochi_nth(Front + 1, Queue) end end),
                Front_2 = (Front + 1),
                Cur_key = key(Current),
                case ((maps:get("x", Current, nil) == maps:get("x", Destination, nil)) andalso (maps:get("y", Current, nil) == maps:get("y", Destination, nil))) of
        true -> throw({break, INF, Allow_diagonal, Cols, Destination, Dist_map, Dx_3, Dy_3, Front_2, Grid, Prev, Queue, Rows, Source});
        _ -> ok
    end,
                I_3 = 0,
                Fun_2 = fun Fun_2_loop(INF, Allow_diagonal, Cols, Cur_key, Current, Destination, Dist_map, Dx_3, Dy_3, Front_2, Grid, I_3, Prev, Queue, Rows, Source) ->
    case (I_3 < erlang:length(Dx_3)) of
        true ->
            Nx = (maps:get("x", Current, nil) + (case erlang:is_map(Dx_3) of true -> maps:get(I_3, Dx_3, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Dx_3) + I_3 + 1, Dx_3); _ -> mochi_nth(I_3 + 1, Dx_3) end end)),
            Ny = (maps:get("y", Current, nil) + (case erlang:is_map(Dy_3) of true -> maps:get(I_3, Dy_3, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Dy_3) + I_3 + 1, Dy_3); _ -> mochi_nth(I_3 + 1, Dy_3) end end)),
            case ((((Nx >= 0) andalso (Nx < Rows)) andalso (Ny >= 0)) andalso (Ny < Cols)) of
        true -> case ((case erlang:is_map((case erlang:is_map(Grid) of true -> maps:get(Nx, Grid, nil); _ -> case Nx < 0 of true -> mochi_nth(erlang:length(Grid) + Nx + 1, Grid); _ -> mochi_nth(Nx + 1, Grid) end end)) of true -> maps:get(Ny, (case erlang:is_map(Grid) of true -> maps:get(Nx, Grid, nil); _ -> case Nx < 0 of true -> mochi_nth(erlang:length(Grid) + Nx + 1, Grid); _ -> mochi_nth(Nx + 1, Grid) end end), nil); _ -> case Ny < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Grid) of true -> maps:get(Nx, Grid, nil); _ -> case Nx < 0 of true -> mochi_nth(erlang:length(Grid) + Nx + 1, Grid); _ -> mochi_nth(Nx + 1, Grid) end end)) + Ny + 1, (case erlang:is_map(Grid) of true -> maps:get(Nx, Grid, nil); _ -> case Nx < 0 of true -> mochi_nth(erlang:length(Grid) + Nx + 1, Grid); _ -> mochi_nth(Nx + 1, Grid) end end)); _ -> mochi_nth(Ny + 1, (case erlang:is_map(Grid) of true -> maps:get(Nx, Grid, nil); _ -> case Nx < 0 of true -> mochi_nth(erlang:length(Grid) + Nx + 1, Grid); _ -> mochi_nth(Nx + 1, Grid) end end)) end end) == 1) of
        true -> N_key = ((mochi_str(Nx) ++ ",") ++ mochi_str(Ny)),
            case mochi_not(maps:is_key(N_key, Dist_map)) of
        true -> Dist_map_2 = maps:put(N_key, (maps:get(Cur_key, Dist_map, nil) + 1.0), Dist_map),
            Prev_2 = maps:put(N_key, Current, Prev),
            Queue_2 = lists:append((case Queue of nil -> []; _ -> Queue end), [#{"x" => Nx, "y" => Ny}]),
            Dist_map_3 = Dist_map_2,
            Prev_3 = Prev_2,
            Queue_3 = Queue_2;
        _ -> Dist_map_3 = Dist_map,
            Prev_3 = Prev,
            Queue_3 = Queue
    end,
            Dist_map_4 = Dist_map_3,
            N_key_2 = N_key,
            Prev_4 = Prev_3,
            Queue_4 = Queue_3;
        _ -> Dist_map_4 = Dist_map,
            N_key_2 = nil,
            Prev_4 = Prev,
            Queue_4 = Queue
    end,
            Dist_map_5 = Dist_map_4,
            N_key_3 = N_key_2,
            Prev_5 = Prev_4,
            Queue_5 = Queue_4;
        _ -> Dist_map_5 = Dist_map,
            N_key_3 = nil,
            Prev_5 = Prev,
            Queue_5 = Queue
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(INF, Allow_diagonal, Cols, Cur_key, Current, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, I_4, Prev_5, Queue_5, Rows, Source);
        _ -> {INF, Allow_diagonal, Cols, Cur_key, Current, Destination, Dist_map, Dx_3, Dy_3, Front_2, Grid, I_3, Prev, Queue, Rows, Source}
    end
end,
{INF, Allow_diagonal, Cols, Cur_key, Current, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, I_4, Prev_5, Queue_5, Rows, Source} = Fun_2(INF, Allow_diagonal, Cols, Cur_key, Current, Destination, Dist_map, Dx_3, Dy_3, Front_2, Grid, I_3, Prev, Queue, Rows, Source),
                Fun_3_loop(INF, Allow_diagonal, Cols, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Prev_5, Queue_5, Rows, Source)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12} -> Fun_3_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12}
            end;
        _ -> {INF, Allow_diagonal, Cols, Destination, Dist_map, Dx_3, Dy_3, Front, Grid, Prev, Queue, Rows, Source}
    end
end,
{INF, Allow_diagonal, Cols, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Prev_5, Queue_5, Rows, Source} = Fun_3(INF, Allow_diagonal, Cols, Destination, Dist_map, Dx_3, Dy_3, Front, Grid, Prev, Queue, Rows, Source),
        Dest_key = key(Destination),
        case mochi_member(Dest_key, Dist_map_5) of
        true -> Path_rev = [Destination],
            Step_key = Dest_key,
            Step_pt = Destination,
            Fun_4 = fun Fun_4_loop(INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Path_rev, Prev_5, Queue_5, Rows, Source, Step_key, Step_pt) ->
    case (Step_key /= key(Source)) of
        true ->
            Step_pt_2 = maps:get(Step_key, Prev_5, nil),
            Step_key_2 = key(Step_pt_2),
            Path_rev_2 = lists:append((case Path_rev of nil -> []; _ -> Path_rev end), [Step_pt_2]),
            Fun_4_loop(INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2);
        _ -> {INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Path_rev, Prev_5, Queue_5, Rows, Source, Step_key, Step_pt}
    end
end,
{INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2} = Fun_4(INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, Path_rev, Prev_5, Queue_5, Rows, Source, Step_key, Step_pt),
            Path_2 = [],
            K = (erlang:length(Path_rev_2) - 1),
            Fun_5 = fun Fun_5_loop(INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, K, Path_2, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2) ->
    case (K >= 0) of
        true ->
            Path_3 = lists:append((case Path_2 of nil -> []; _ -> Path_2 end), [(case erlang:is_map(Path_rev_2) of true -> maps:get(K, Path_rev_2, nil); _ -> case K < 0 of true -> mochi_nth(erlang:length(Path_rev_2) + K + 1, Path_rev_2); _ -> mochi_nth(K + 1, Path_rev_2) end end)]),
            K_2 = (K - 1),
            Fun_5_loop(INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, K_2, Path_3, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2);
        _ -> {INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, K, Path_2, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2}
    end
end,
{INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, K_2, Path_3, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2} = Fun_5(INF, Allow_diagonal, Cols, Dest_key, Destination, Dist_map_5, Dx_3, Dy_3, Front_2, Grid, K, Path_2, Path_rev_2, Prev_5, Queue_5, Rows, Source, Step_key_2, Step_pt_2),
            throw({return, #{"distance" => maps:get(Dest_key, Dist_map_5, nil), "path" => Path_3}}),
            Fun_6 = Fun_5,
            K_3 = K_2,
            Path_4 = Path_3,
            Path_rev_3 = Path_rev_2,
            Step_key_3 = Step_key_2,
            Step_pt_3 = Step_pt_2;
        _ -> Fun_6 = Fun_3,
            K_3 = nil,
            Path_4 = nil,
            Path_rev_3 = nil,
            Step_key_3 = nil,
            Step_pt_3 = nil
    end,
        #{"distance" => INF, "path" => []}
    catch {return, RetCatch} -> RetCatch end.

print_result(Res) ->
    try
        io:format("~ts~n", [mochi_repr(((mochi_str(maps:get("distance", Res, nil)) ++ ", ") ++ path_to_string(maps:get("path", Res, nil))))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('grid1', [[1, 1, 1], [0, 1, 0], [0, 1, 1]]),
    print_result(dijkstra(erlang:get('grid1'), #{"x" => 0, "y" => 0}, #{"x" => 2, "y" => 2}, false)),
    print_result(dijkstra(erlang:get('grid1'), #{"x" => 0, "y" => 0}, #{"x" => 2, "y" => 2}, true)),
    erlang:put('grid2', [[1, 1, 1], [0, 0, 1], [0, 1, 1]]),
    print_result(dijkstra(erlang:get('grid2'), #{"x" => 0, "y" => 0}, #{"x" => 2, "y" => 2}, false)),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
