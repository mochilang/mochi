#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, prims_algo/1, iabs/1]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

prims_algo(Graph) ->
    try
        INF = 2147483647,
        Dist = #{},
        Parent = #{},
        Queue = [],
        Fun = fun Fun_loop(List, INF, Dist, Graph, Parent, Queue) ->
    case List of
        [] -> {INF, Dist, Graph, Parent, Queue};
        [Node|Node_rest] ->
            Dist_2 = maps:put(Node, 2147483647, Dist),
            Parent_2 = maps:put(Node, "", Parent),
            Queue_2 = lists:append((case Queue of nil -> []; _ -> Queue end), [#{"node" => Node, "weight" => 2147483647}]),
            Fun_loop(Node_rest, INF, Dist_2, Graph, Parent_2, Queue_2);
        _ -> {INF, Dist, Graph, Parent, Queue}
    end
end,
{INF, Dist_2, Graph, Parent_2, Queue_2} = Fun(maps:keys(Graph), INF, Dist, Graph, Parent, Queue),
        case (erlang:length(Queue_2) == 0) of
        true -> throw({return, #{"dist" => Dist_2, "parent" => Parent_2}});
        _ -> ok
    end,
        Min_idx = 0,
        I = 1,
        Fun_2 = fun Fun_2_loop(INF, Dist_2, Graph, I, Min_idx, Parent_2, Queue_2) ->
    case (I < erlang:length(Queue_2)) of
        true ->
            case (maps:get("weight", (case erlang:is_map(Queue_2) of true -> maps:get(I, Queue_2, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Queue_2) + I + 1, Queue_2); _ -> lists:nth(I + 1, Queue_2) end end), nil) < maps:get("weight", (case erlang:is_map(Queue_2) of true -> maps:get(Min_idx, Queue_2, nil); _ -> case Min_idx < 0 of true -> lists:nth(erlang:length(Queue_2) + Min_idx + 1, Queue_2); _ -> lists:nth(Min_idx + 1, Queue_2) end end), nil)) of
        true -> Min_idx_2 = I,
            Min_idx_3 = Min_idx_2;
        _ -> Min_idx_3 = Min_idx
    end,
            I_2 = (I + 1),
            Fun_2_loop(INF, Dist_2, Graph, I_2, Min_idx_3, Parent_2, Queue_2);
        _ -> {INF, Dist_2, Graph, I, Min_idx, Parent_2, Queue_2}
    end
end,
{INF, Dist_2, Graph, I_2, Min_idx_3, Parent_2, Queue_2} = Fun_2(INF, Dist_2, Graph, I, Min_idx, Parent_2, Queue_2),
        Start_node = (case erlang:is_map(Queue_2) of true -> maps:get(Min_idx_3, Queue_2, nil); _ -> case Min_idx_3 < 0 of true -> lists:nth(erlang:length(Queue_2) + Min_idx_3 + 1, Queue_2); _ -> lists:nth(Min_idx_3 + 1, Queue_2) end end),
        Start = maps:get("node", Start_node, nil),
        New_q = [],
        J = 0,
        Fun_3 = fun Fun_3_loop(INF, Dist_2, Graph, I_2, J, Min_idx_3, New_q, Parent_2, Queue_2, Start, Start_node) ->
    case (J < erlang:length(Queue_2)) of
        true ->
            case (J /= Min_idx_3) of
        true -> New_q_2 = lists:append((case New_q of nil -> []; _ -> New_q end), [(case erlang:is_map(Queue_2) of true -> maps:get(J, Queue_2, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Queue_2) + J + 1, Queue_2); _ -> lists:nth(J + 1, Queue_2) end end)]),
            New_q_3 = New_q_2;
        _ -> New_q_3 = New_q
    end,
            J_2 = (J + 1),
            Fun_3_loop(INF, Dist_2, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_2, Start, Start_node);
        _ -> {INF, Dist_2, Graph, I_2, J, Min_idx_3, New_q, Parent_2, Queue_2, Start, Start_node}
    end
end,
{INF, Dist_2, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_2, Start, Start_node} = Fun_3(INF, Dist_2, Graph, I_2, J, Min_idx_3, New_q, Parent_2, Queue_2, Start, Start_node),
        Queue_3 = New_q_3,
        Dist_3 = maps:put(Start, 0, Dist_2),
        Fun_4 = fun Fun_4_loop(List, INF, Dist_3, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_3, Start, Start_node) ->
    case List of
        [] -> {INF, Dist_3, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_3, Start, Start_node};
        [Neighbour|Neighbour_rest] ->
        try
            W = maps:get(Neighbour, maps:get(Start, Graph, nil), nil),
            case (maps:get(Neighbour, Dist_3, nil) > (maps:get(Start, Dist_3, nil) + W)) of
        true -> Dist_4 = maps:put(Neighbour, (maps:get(Start, Dist_3, nil) + W), Dist_3),
            Parent_3 = maps:put(Neighbour, Start, Parent_2),
            K = 0,
            Fun_5 = fun Fun_5_loop(INF, Dist_4, Graph, I_2, J_2, K, Min_idx_3, Neighbour, New_q_3, Parent_3, Queue_3, Start, Start_node, W) ->
    case (K < erlang:length(Queue_3)) of
        true ->
            try
                case (maps:get("node", (case erlang:is_map(Queue_3) of true -> maps:get(K, Queue_3, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Queue_3) + K + 1, Queue_3); _ -> lists:nth(K + 1, Queue_3) end end), nil) == Neighbour) of
        true -> Queue_4 = lists:sublist(Queue_3, K) ++ [maps:put("weight", maps:get(Neighbour, Dist_4, nil), lists:nth(K + 1, Queue_3) )] ++ lists:nthtail(K + 1, Queue_3),
            throw({break, INF, Dist_4, Graph, I_2, J_2, K, Min_idx_3, Neighbour, New_q_3, Parent_3, Queue_4, Start, Start_node, W}),
            Queue_5 = Queue_4;
        _ -> Queue_5 = Queue_3
    end,
                K_2 = (K + 1),
                Fun_5_loop(INF, Dist_4, Graph, I_2, J_2, K_2, Min_idx_3, Neighbour, New_q_3, Parent_3, Queue_5, Start, Start_node, W)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13}
            end;
        _ -> {INF, Dist_4, Graph, I_2, J_2, K, Min_idx_3, Neighbour, New_q_3, Parent_3, Queue_3, Start, Start_node, W}
    end
end,
{INF, Dist_4, Graph, I_2, J_2, K_2, Min_idx_3, Neighbour, New_q_3, Parent_3, Queue_5, Start, Start_node, W} = Fun_5(INF, Dist_4, Graph, I_2, J_2, K, Min_idx_3, Neighbour, New_q_3, Parent_3, Queue_3, Start, Start_node, W),
            Dist_5 = Dist_4,
            Fun_6 = Fun_5,
            K_3 = K_2,
            Parent_4 = Parent_3,
            Queue_6 = Queue_5;
        _ -> Dist_5 = Dist_3,
            Fun_6 = Fun_3,
            K_3 = nil,
            Parent_4 = Parent_2,
            Queue_6 = Queue_3
    end,
            Fun_4_loop(Neighbour_rest, INF, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_4, Queue_6, Start, Start_node)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_4_loop(Neighbour_rest, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
            {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10};
            break -> {INF, Dist_3, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_3, Start, Start_node}
        end;
        _ -> {INF, Dist_3, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_3, Start, Start_node}
    end
end,
{INF, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_4, Queue_6, Start, Start_node} = Fun_4(maps:keys(maps:get(Start, Graph, nil)), INF, Dist_3, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_2, Queue_3, Start, Start_node),
        Fun_12 = fun Fun_12_loop(INF, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_4, Queue_6, Start, Start_node) ->
    case (erlang:length(Queue_6) > 0) of
        true ->
            try
                Best_idx = 0,
                P = 1,
                Fun_7 = fun Fun_7_loop(INF, Best_idx, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, P, Parent_4, Queue_6, Start, Start_node) ->
    case (P < erlang:length(Queue_6)) of
        true ->
            case (maps:get("weight", (case erlang:is_map(Queue_6) of true -> maps:get(P, Queue_6, nil); _ -> case P < 0 of true -> lists:nth(erlang:length(Queue_6) + P + 1, Queue_6); _ -> lists:nth(P + 1, Queue_6) end end), nil) < maps:get("weight", (case erlang:is_map(Queue_6) of true -> maps:get(Best_idx, Queue_6, nil); _ -> case Best_idx < 0 of true -> lists:nth(erlang:length(Queue_6) + Best_idx + 1, Queue_6); _ -> lists:nth(Best_idx + 1, Queue_6) end end), nil)) of
        true -> Best_idx_2 = P,
            Best_idx_3 = Best_idx_2;
        _ -> Best_idx_3 = Best_idx
    end,
            P_2 = (P + 1),
            Fun_7_loop(INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, P_2, Parent_4, Queue_6, Start, Start_node);
        _ -> {INF, Best_idx, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, P, Parent_4, Queue_6, Start, Start_node}
    end
end,
{INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, P_2, Parent_4, Queue_6, Start, Start_node} = Fun_7(INF, Best_idx, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, P, Parent_4, Queue_6, Start, Start_node),
                Node_entry = (case erlang:is_map(Queue_6) of true -> maps:get(Best_idx_3, Queue_6, nil); _ -> case Best_idx_3 < 0 of true -> lists:nth(erlang:length(Queue_6) + Best_idx_3 + 1, Queue_6); _ -> lists:nth(Best_idx_3 + 1, Queue_6) end end),
                Node_2 = maps:get("node", Node_entry, nil),
                Tmp = [],
                Q = 0,
                Fun_8 = fun Fun_8_loop(INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q, Queue_6, Start, Start_node, Tmp) ->
    case (Q < erlang:length(Queue_6)) of
        true ->
            case (Q /= Best_idx_3) of
        true -> Tmp_2 = lists:append((case Tmp of nil -> []; _ -> Tmp end), [(case erlang:is_map(Queue_6) of true -> maps:get(Q, Queue_6, nil); _ -> case Q < 0 of true -> lists:nth(erlang:length(Queue_6) + Q + 1, Queue_6); _ -> lists:nth(Q + 1, Queue_6) end end)]),
            Tmp_3 = Tmp_2;
        _ -> Tmp_3 = Tmp
    end,
            Q_2 = (Q + 1),
            Fun_8_loop(INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_6, Start, Start_node, Tmp_3);
        _ -> {INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q, Queue_6, Start, Start_node, Tmp}
    end
end,
{INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_6, Start, Start_node, Tmp_3} = Fun_8(INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q, Queue_6, Start, Start_node, Tmp),
                Queue_7 = Tmp_3,
                Fun_9 = fun Fun_9_loop(List, INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_7, Start, Start_node, Tmp_3) ->
    case List of
        [] -> {INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_7, Start, Start_node, Tmp_3};
        [Neighbour_2|Neighbour_2_rest] ->
        try
            W_2 = maps:get(Neighbour_2, maps:get(Node_2, Graph, nil), nil),
            case (maps:get(Neighbour_2, Dist_5, nil) > (maps:get(Node_2, Dist_5, nil) + W_2)) of
        true -> Dist_6 = maps:put(Neighbour_2, (maps:get(Node_2, Dist_5, nil) + W_2), Dist_5),
            Parent_5 = maps:put(Neighbour_2, Node_2, Parent_4),
            R = 0,
            Fun_10 = fun Fun_10_loop(INF, Best_idx_3, Dist_6, Graph, I_2, J_2, Min_idx_3, Neighbour_2, New_q_3, Node_2, Node_entry, P_2, Parent_5, Q_2, Queue_7, R, Start, Start_node, Tmp_3, W_2) ->
    case (R < erlang:length(Queue_7)) of
        true ->
            try
                case (maps:get("node", (case erlang:is_map(Queue_7) of true -> maps:get(R, Queue_7, nil); _ -> case R < 0 of true -> lists:nth(erlang:length(Queue_7) + R + 1, Queue_7); _ -> lists:nth(R + 1, Queue_7) end end), nil) == Neighbour_2) of
        true -> Queue_8 = lists:sublist(Queue_7, R) ++ [maps:put("weight", maps:get(Neighbour_2, Dist_6, nil), lists:nth(R + 1, Queue_7) )] ++ lists:nthtail(R + 1, Queue_7),
            throw({break, INF, Best_idx_3, Dist_6, Graph, I_2, J_2, Min_idx_3, Neighbour_2, New_q_3, Node_2, Node_entry, P_2, Parent_5, Q_2, Queue_8, R, Start, Start_node, Tmp_3, W_2}),
            Queue_9 = Queue_8;
        _ -> Queue_9 = Queue_7
    end,
                R_2 = (R + 1),
                Fun_10_loop(INF, Best_idx_3, Dist_6, Graph, I_2, J_2, Min_idx_3, Neighbour_2, New_q_3, Node_2, Node_entry, P_2, Parent_5, Q_2, Queue_9, R_2, Start, Start_node, Tmp_3, W_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19} -> Fun_10_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16, C17, C18, C19);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19}
            end;
        _ -> {INF, Best_idx_3, Dist_6, Graph, I_2, J_2, Min_idx_3, Neighbour_2, New_q_3, Node_2, Node_entry, P_2, Parent_5, Q_2, Queue_7, R, Start, Start_node, Tmp_3, W_2}
    end
end,
{INF, Best_idx_3, Dist_6, Graph, I_2, J_2, Min_idx_3, Neighbour_2, New_q_3, Node_2, Node_entry, P_2, Parent_5, Q_2, Queue_9, R_2, Start, Start_node, Tmp_3, W_2} = Fun_10(INF, Best_idx_3, Dist_6, Graph, I_2, J_2, Min_idx_3, Neighbour_2, New_q_3, Node_2, Node_entry, P_2, Parent_5, Q_2, Queue_7, R, Start, Start_node, Tmp_3, W_2),
            Dist_7 = Dist_6,
            Fun_11 = Fun_10,
            Parent_6 = Parent_5,
            Queue_10 = Queue_9,
            R_3 = R_2;
        _ -> Dist_7 = Dist_5,
            Fun_11 = Fun_8,
            Parent_6 = Parent_4,
            Queue_10 = Queue_7,
            R_3 = nil
    end,
            Fun_9_loop(Neighbour_2_rest, INF, Best_idx_3, Dist_7, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_6, Q_2, Queue_10, Start, Start_node, Tmp_3)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16} -> Fun_9_loop(Neighbour_2_rest, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16);
            {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16};
            break -> {INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_7, Start, Start_node, Tmp_3}
        end;
        _ -> {INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_7, Start, Start_node, Tmp_3}
    end
end,
{INF, Best_idx_3, Dist_7, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_6, Q_2, Queue_10, Start, Start_node, Tmp_3} = Fun_9(maps:keys(maps:get(Node_2, Graph, nil)), INF, Best_idx_3, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Node_2, Node_entry, P_2, Parent_4, Q_2, Queue_7, Start, Start_node, Tmp_3),
                Fun_12_loop(INF, Dist_7, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_6, Queue_10, Start, Start_node)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_12_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10}
            end;
        _ -> {INF, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_4, Queue_6, Start, Start_node}
    end
end,
{INF, Dist_7, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_6, Queue_10, Start, Start_node} = Fun_12(INF, Dist_5, Graph, I_2, J_2, Min_idx_3, New_q_3, Parent_4, Queue_6, Start, Start_node),
        #{"dist" => Dist_7, "parent" => Parent_6}
    catch {return, Ret} -> Ret end.

iabs(X) ->
    try
        (case (X < 0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('graph', #{}),
    Graph_tmp = lists:sublist(erlang:get('graph'), "a") ++ [#{"b" => 3, "c" => 15}] ++ lists:nthtail("a" + 1, erlang:get('graph')),
    erlang:put('graph', Graph_tmp),
    Graph_tmp_2 = lists:sublist(erlang:get('graph'), "b") ++ [#{"a" => 3, "c" => 10, "d" => 100}] ++ lists:nthtail("b" + 1, erlang:get('graph')),
    erlang:put('graph', Graph_tmp_2),
    Graph_tmp_3 = lists:sublist(erlang:get('graph'), "c") ++ [#{"a" => 15, "b" => 10, "d" => 5}] ++ lists:nthtail("c" + 1, erlang:get('graph')),
    erlang:put('graph', Graph_tmp_3),
    Graph_tmp_4 = lists:sublist(erlang:get('graph'), "d") ++ [#{"b" => 100, "c" => 5}] ++ lists:nthtail("d" + 1, erlang:get('graph')),
    erlang:put('graph', Graph_tmp_4),
    erlang:put('res', prims_algo(erlang:get('graph'))),
    erlang:put('dist', maps:get("dist", erlang:get('res'), nil)),
    io:format("~ts~n", [mochi_str(iabs((maps:get("a", erlang:get('dist'), nil) - maps:get("b", erlang:get('dist'), nil))))]),
    io:format("~ts~n", [mochi_str(iabs((maps:get("d", erlang:get('dist'), nil) - maps:get("b", erlang:get('dist'), nil))))]),
    io:format("~ts~n", [mochi_str(iabs((maps:get("a", erlang:get('dist'), nil) - maps:get("c", erlang:get('dist'), nil))))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
