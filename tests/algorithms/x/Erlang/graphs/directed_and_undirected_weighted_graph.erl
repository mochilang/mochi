#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, list_contains_int/2, edge_exists/3, first_key/1, rand_range/2, dg_make_graph/0, dg_add_pair/4, dg_remove_pair/3, dg_all_nodes/1, dg_dfs_util/5, dg_dfs/3, dg_bfs/2, dg_in_degree/2, dg_out_degree/2, dg_topo_util/4, dg_topological_sort/1, dg_cycle_util/5, dg_cycle_nodes/1, dg_has_cycle_util/4, dg_has_cycle/1, dg_fill_graph_randomly/2, dg_dfs_time/3, dg_bfs_time/2, g_make_graph/0, g_add_pair/4, g_remove_pair/3, g_all_nodes/1, g_dfs_util/5, g_dfs/3, g_bfs/2, g_degree/2, g_cycle_util/5, g_cycle_nodes/1, g_has_cycle_util/4, g_has_cycle/1, g_fill_graph_randomly/2, g_dfs_time/3, g_bfs_time/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_mod(A, B) when B =/= 0 ->
    ((A rem B) + B) rem B;
mochi_mod(_, _) -> 0.

list_contains_int(Xs, X) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, X, Xs) ->
    case (I < erlang:length(Xs)) of
        true ->
            case ((case erlang:is_map(Xs) of true -> maps:get(I, Xs, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Xs) + I + 1, Xs); _ -> lists:nth(I + 1, Xs) end end) == X) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, X, Xs);
        _ -> {I, X, Xs}
    end
end,
{I_2, X, Xs} = Fun(I, X, Xs),
        false
    catch {return, Ret} -> Ret end.

edge_exists(Edges, W, V) ->
    try
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Edges, I_3, V, W) ->
    case (I_3 < erlang:length(Edges)) of
        true ->
            case (((case erlang:is_map((case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)) of true -> maps:get(0, (case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end), nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)) + 0 + 1, (case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)); _ -> lists:nth(0 + 1, (case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)) end end) == W) andalso ((case erlang:is_map((case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)) of true -> maps:get(1, (case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)) + 1 + 1, (case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)); _ -> lists:nth(1 + 1, (case erlang:is_map(Edges) of true -> maps:get(I_3, Edges, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Edges) + I_3 + 1, Edges); _ -> lists:nth(I_3 + 1, Edges) end end)) end end) == V)) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Edges, I_4, V, W);
        _ -> {Edges, I_3, V, W}
    end
end,
{Edges, I_4, V, W} = Fun_2(Edges, I_3, V, W),
        false
    catch {return, Ret} -> Ret end.

first_key(M) ->
    try
        Fun_3 = fun Fun_3_loop(List, M) ->
    case List of
        [] -> {M};
        [K|K_rest] ->
            throw({return, K}),
            Fun_3_loop(K_rest, M);
        _ -> {M}
    end
end,
{M} = Fun_3(maps:keys(M), M),
        0
    catch {return, Ret} -> Ret end.

rand_range(Low, High) ->
    try
        (mochi_mod(mochi_now(), (High - Low)) + Low)
    catch {return, Ret} -> Ret end.

dg_make_graph() ->
    try
        #{"graph" => #{}}
    catch {return, Ret} -> Ret end.

dg_add_pair(G, U, V_2, W_2) ->
    try
        case maps:is_key(U, maps:get("graph", G, nil)) of
        true -> Edges_2 = maps:get(U, maps:get("graph", G, nil), nil),
            case mochi_not(edge_exists(Edges_2, W_2, V_2)) of
        true -> Edges_3 = lists:append((case Edges_2 of nil -> []; _ -> Edges_2 end), [[W_2, V_2]]),
            M_2 = maps:get("graph", G, nil),
            M_3 = maps:put(U, Edges_3, M_2),
            G_2 = maps:put("graph", M_3, G),
            Edges_4 = Edges_3,
            G_3 = G_2,
            M_4 = M_3;
        _ -> Edges_4 = Edges_2,
            G_3 = G,
            M_4 = nil
    end,
            Edges_5 = Edges_4,
            G_5 = G_3,
            M_5 = M_4,
            M0_3 = nil;
        _ -> M0 = maps:get("graph", G, nil),
            M0_2 = maps:put(U, [[W_2, V_2]], M0),
            G_4 = maps:put("graph", M0_2, G),
            Edges_5 = nil,
            G_5 = G_4,
            M_5 = nil,
            M0_3 = M0_2
    end,
        case mochi_not(maps:is_key(V_2, maps:get("graph", G_5, nil))) of
        true -> M1 = maps:get("graph", G_5, nil),
            M1_2 = maps:put(V_2, [], M1),
            G_6 = maps:put("graph", M1_2, G_5),
            G_7 = G_6,
            M1_3 = M1_2;
        _ -> G_7 = G_5,
            M1_3 = nil
    end,
        nil
    catch {return, Ret} -> Ret end.

dg_remove_pair(G_8, U_2, V_3) ->
    try
        case maps:is_key(U_2, maps:get("graph", G_8, nil)) of
        true -> Edges_6 = maps:get(U_2, maps:get("graph", G_8, nil), nil),
            New_edges = [],
            I_5 = 0,
            Fun_4 = fun Fun_4_loop(Edges_6, G_8, I_5, New_edges, U_2, V_3) ->
    case (I_5 < maps:size(Edges_6)) of
        true ->
            case ((case erlang:is_map(maps:get(I_5, Edges_6, nil)) of true -> maps:get(1, maps:get(I_5, Edges_6, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_5, Edges_6, nil)) + 1 + 1, maps:get(I_5, Edges_6, nil)); _ -> lists:nth(1 + 1, maps:get(I_5, Edges_6, nil)) end end) /= V_3) of
        true -> New_edges_2 = lists:append((case New_edges of nil -> []; _ -> New_edges end), [maps:get(I_5, Edges_6, nil)]),
            New_edges_3 = New_edges_2;
        _ -> New_edges_3 = New_edges
    end,
            I_6 = (I_5 + 1),
            Fun_4_loop(Edges_6, G_8, I_6, New_edges_3, U_2, V_3);
        _ -> {Edges_6, G_8, I_5, New_edges, U_2, V_3}
    end
end,
{Edges_6, G_8, I_6, New_edges_3, U_2, V_3} = Fun_4(Edges_6, G_8, I_5, New_edges, U_2, V_3),
            M_6 = maps:get("graph", G_8, nil),
            M_7 = maps:put(U_2, New_edges_3, M_6),
            G_9 = maps:put("graph", M_7, G_8),
            Edges_7 = Edges_6,
            Fun_5 = Fun_4,
            G_10 = G_9,
            I_7 = I_6,
            M_8 = M_7,
            New_edges_4 = New_edges_3;
        _ -> Edges_7 = nil,
            Fun_5 = nil,
            G_10 = G_8,
            I_7 = nil,
            M_8 = nil,
            New_edges_4 = nil
    end,
        nil
    catch {return, Ret} -> Ret end.

dg_all_nodes(G_11) ->
    try
        Res = [],
        Fun_6 = fun Fun_6_loop(List, G_11, Res) ->
    case List of
        [] -> {G_11, Res};
        [K_2|K_2_rest] ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [K_2]),
            Fun_6_loop(K_2_rest, G_11, Res_2);
        _ -> {G_11, Res}
    end
end,
{G_11, Res_2} = Fun_6(maps:keys(maps:get("graph", G_11, nil)), G_11, Res),
        Res_2
    catch {return, Ret} -> Ret end.

dg_dfs_util(G_12, Node, Visited, Order, D) ->
    try
        Visited_2 = maps:put(Node, true, Visited),
        Order_2 = lists:append((case Order of nil -> []; _ -> Order end), [Node]),
        case ((D /= -1) andalso (Node == D)) of
        true -> throw({return, Order_2});
        _ -> ok
    end,
        Edges_8 = maps:get(Node, maps:get("graph", G_12, nil), nil),
        I_8 = 0,
        Fun_7 = fun Fun_7_loop(D, Edges_8, G_12, I_8, Node, Order_2, Visited_2) ->
    case (I_8 < maps:size(Edges_8)) of
        true ->
            Neigh = (case erlang:is_map(maps:get(I_8, Edges_8, nil)) of true -> maps:get(1, maps:get(I_8, Edges_8, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_8, Edges_8, nil)) + 1 + 1, maps:get(I_8, Edges_8, nil)); _ -> lists:nth(1 + 1, maps:get(I_8, Edges_8, nil)) end end),
            case mochi_not(maps:is_key(Neigh, Visited_2)) of
        true -> Order_3 = dg_dfs_util(G_12, Neigh, Visited_2, Order_2, D),
            case ((D /= -1) andalso ((case erlang:is_map(Order_3) of true -> maps:get((erlang:length(Order_3) - 1), Order_3, nil); _ -> case (erlang:length(Order_3) - 1) < 0 of true -> lists:nth(erlang:length(Order_3) + (erlang:length(Order_3) - 1) + 1, Order_3); _ -> lists:nth((erlang:length(Order_3) - 1) + 1, Order_3) end end) == D)) of
        true -> throw({return, Order_3});
        _ -> ok
    end,
            Order_4 = Order_3;
        _ -> Order_4 = Order_2
    end,
            I_9 = (I_8 + 1),
            Fun_7_loop(D, Edges_8, G_12, I_9, Node, Order_4, Visited_2);
        _ -> {D, Edges_8, G_12, I_8, Node, Order_2, Visited_2}
    end
end,
{D, Edges_8, G_12, I_9, Node, Order_4, Visited_2} = Fun_7(D, Edges_8, G_12, I_8, Node, Order_2, Visited_2),
        Order_4
    catch {return, Ret} -> Ret end.

dg_dfs(G_13, S, D_2) ->
    try
        case (S == D_2) of
        true -> throw({return, []});
        _ -> ok
    end,
        Start = (case (S == -2) of
    true -> first_key(maps:get("graph", G_13, nil));
    _ -> S
end),
        Visited_3 = #{},
        Order_5 = [],
        Order_6 = dg_dfs_util(G_13, Start, Visited_3, Order_5, D_2),
        Order_6
    catch {return, Ret} -> Ret end.

dg_bfs(G_14, S_2) ->
    try
        Queue = [],
        Visited_4 = #{},
        Order_7 = [],
        Start_2 = (case (S_2 == -2) of
    true -> first_key(maps:get("graph", G_14, nil));
    _ -> S_2
end),
        Queue_2 = lists:append((case Queue of nil -> []; _ -> Queue end), [Start_2]),
        Visited_5 = maps:put(Start_2, true, Visited_4),
        Fun_9 = fun Fun_9_loop(G_14, Order_7, Queue_2, S_2, Start_2, Visited_5) ->
    case (erlang:length(Queue_2) > 0) of
        true ->
            Node_2 = (case erlang:is_map(Queue_2) of true -> maps:get(0, Queue_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Queue_2) + 0 + 1, Queue_2); _ -> lists:nth(0 + 1, Queue_2) end end),
            Queue_3 = lists:sublist(Queue_2, 1 + 1, (erlang:length(Queue_2) - 1)),
            Order_8 = lists:append((case Order_7 of nil -> []; _ -> Order_7 end), [Node_2]),
            Edges_9 = maps:get(Node_2, maps:get("graph", G_14, nil), nil),
            I_10 = 0,
            Fun_8 = fun Fun_8_loop(Edges_9, G_14, I_10, Node_2, Order_8, Queue_3, S_2, Start_2, Visited_5) ->
    case (I_10 < maps:size(Edges_9)) of
        true ->
            Neigh_2 = (case erlang:is_map(maps:get(I_10, Edges_9, nil)) of true -> maps:get(1, maps:get(I_10, Edges_9, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_10, Edges_9, nil)) + 1 + 1, maps:get(I_10, Edges_9, nil)); _ -> lists:nth(1 + 1, maps:get(I_10, Edges_9, nil)) end end),
            case mochi_not(maps:is_key(Neigh_2, Visited_5)) of
        true -> Queue_4 = lists:append((case Queue_3 of nil -> []; _ -> Queue_3 end), [Neigh_2]),
            Visited_6 = maps:put(Neigh_2, true, Visited_5),
            Queue_5 = Queue_4,
            Visited_7 = Visited_6;
        _ -> Queue_5 = Queue_3,
            Visited_7 = Visited_5
    end,
            I_11 = (I_10 + 1),
            Fun_8_loop(Edges_9, G_14, I_11, Node_2, Order_8, Queue_5, S_2, Start_2, Visited_7);
        _ -> {Edges_9, G_14, I_10, Node_2, Order_8, Queue_3, S_2, Start_2, Visited_5}
    end
end,
{Edges_9, G_14, I_11, Node_2, Order_8, Queue_5, S_2, Start_2, Visited_7} = Fun_8(Edges_9, G_14, I_10, Node_2, Order_8, Queue_3, S_2, Start_2, Visited_5),
            Fun_9_loop(G_14, Order_8, Queue_5, S_2, Start_2, Visited_7);
        _ -> {G_14, Order_7, Queue_2, S_2, Start_2, Visited_5}
    end
end,
{G_14, Order_8, Queue_5, S_2, Start_2, Visited_7} = Fun_9(G_14, Order_7, Queue_2, S_2, Start_2, Visited_5),
        Order_8
    catch {return, Ret} -> Ret end.

dg_in_degree(G_15, U_3) ->
    try
        Count = 0,
        Fun_10 = fun Fun_10_loop(List, Count, G_15, U_3) ->
    case List of
        [] -> {Count, G_15, U_3};
        [K_3|K_3_rest] ->
            Edges_10 = maps:get(K_3, maps:get("graph", G_15, nil), nil),
            I_12 = 0,
            Fun_11 = fun Fun_11_loop(Count, Edges_10, G_15, I_12, K_3, U_3) ->
    case (I_12 < maps:size(Edges_10)) of
        true ->
            case ((case erlang:is_map(maps:get(I_12, Edges_10, nil)) of true -> maps:get(1, maps:get(I_12, Edges_10, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_12, Edges_10, nil)) + 1 + 1, maps:get(I_12, Edges_10, nil)); _ -> lists:nth(1 + 1, maps:get(I_12, Edges_10, nil)) end end) == U_3) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            I_13 = (I_12 + 1),
            Fun_11_loop(Count_3, Edges_10, G_15, I_13, K_3, U_3);
        _ -> {Count, Edges_10, G_15, I_12, K_3, U_3}
    end
end,
{Count_3, Edges_10, G_15, I_13, K_3, U_3} = Fun_11(Count, Edges_10, G_15, I_12, K_3, U_3),
            Fun_10_loop(K_3_rest, Count_3, G_15, U_3);
        _ -> {Count, G_15, U_3}
    end
end,
{Count_3, G_15, U_3} = Fun_10(maps:keys(maps:get("graph", G_15, nil)), Count, G_15, U_3),
        Count_3
    catch {return, Ret} -> Ret end.

dg_out_degree(G_16, U_4) ->
    try
        (case maps:is_key(U_4, maps:get("graph", G_16, nil)) of
    true -> maps:size(maps:get(U_4, maps:get("graph", G_16, nil), nil));
    _ -> 0
end)
    catch {return, Ret} -> Ret end.

dg_topo_util(G_17, Node_3, Visited_8, Stack) ->
    try
        Visited_9 = maps:put(Node_3, true, Visited_8),
        Edges_11 = maps:get(Node_3, maps:get("graph", G_17, nil), nil),
        I_14 = 0,
        Fun_12 = fun Fun_12_loop(Edges_11, G_17, I_14, Node_3, Stack, Visited_9) ->
    case (I_14 < maps:size(Edges_11)) of
        true ->
            Neigh_3 = (case erlang:is_map(maps:get(I_14, Edges_11, nil)) of true -> maps:get(1, maps:get(I_14, Edges_11, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_14, Edges_11, nil)) + 1 + 1, maps:get(I_14, Edges_11, nil)); _ -> lists:nth(1 + 1, maps:get(I_14, Edges_11, nil)) end end),
            case mochi_not(maps:is_key(Neigh_3, Visited_9)) of
        true -> Stack_2 = dg_topo_util(G_17, Neigh_3, Visited_9, Stack),
            Stack_3 = Stack_2;
        _ -> Stack_3 = Stack
    end,
            I_15 = (I_14 + 1),
            Fun_12_loop(Edges_11, G_17, I_15, Node_3, Stack_3, Visited_9);
        _ -> {Edges_11, G_17, I_14, Node_3, Stack, Visited_9}
    end
end,
{Edges_11, G_17, I_15, Node_3, Stack_3, Visited_9} = Fun_12(Edges_11, G_17, I_14, Node_3, Stack, Visited_9),
        Stack_4 = lists:append((case Stack_3 of nil -> []; _ -> Stack_3 end), [Node_3]),
        Stack_4
    catch {return, Ret} -> Ret end.

dg_topological_sort(G_18) ->
    try
        Visited_10 = #{},
        Stack_5 = [],
        Fun_13 = fun Fun_13_loop(List, G_18, Stack_5, Visited_10) ->
    case List of
        [] -> {G_18, Stack_5, Visited_10};
        [K_4|K_4_rest] ->
            case mochi_not(maps:is_key(K_4, Visited_10)) of
        true -> Stack_6 = dg_topo_util(G_18, K_4, Visited_10, Stack_5),
            Stack_7 = Stack_6;
        _ -> Stack_7 = Stack_5
    end,
            Fun_13_loop(K_4_rest, G_18, Stack_7, Visited_10);
        _ -> {G_18, Stack_5, Visited_10}
    end
end,
{G_18, Stack_7, Visited_10} = Fun_13(maps:keys(maps:get("graph", G_18, nil)), G_18, Stack_5, Visited_10),
        Res_3 = [],
        I_16 = (erlang:length(Stack_7) - 1),
        Fun_14 = fun Fun_14_loop(G_18, I_16, Res_3, Stack_7, Visited_10) ->
    case (I_16 >= 0) of
        true ->
            Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [(case erlang:is_map(Stack_7) of true -> maps:get(I_16, Stack_7, nil); _ -> case I_16 < 0 of true -> lists:nth(erlang:length(Stack_7) + I_16 + 1, Stack_7); _ -> lists:nth(I_16 + 1, Stack_7) end end)]),
            I_17 = (I_16 - 1),
            Fun_14_loop(G_18, I_17, Res_4, Stack_7, Visited_10);
        _ -> {G_18, I_16, Res_3, Stack_7, Visited_10}
    end
end,
{G_18, I_17, Res_4, Stack_7, Visited_10} = Fun_14(G_18, I_16, Res_3, Stack_7, Visited_10),
        Res_4
    catch {return, Ret} -> Ret end.

dg_cycle_util(G_19, Node_4, Visited_11, Rec, Res_5) ->
    try
        Visited_12 = maps:put(Node_4, true, Visited_11),
        Rec_2 = maps:put(Node_4, true, Rec),
        Edges_12 = maps:get(Node_4, maps:get("graph", G_19, nil), nil),
        I_18 = 0,
        Fun_15 = fun Fun_15_loop(Edges_12, G_19, I_18, Node_4, Rec_2, Res_5, Visited_12) ->
    case (I_18 < maps:size(Edges_12)) of
        true ->
            Neigh_4 = (case erlang:is_map(maps:get(I_18, Edges_12, nil)) of true -> maps:get(1, maps:get(I_18, Edges_12, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_18, Edges_12, nil)) + 1 + 1, maps:get(I_18, Edges_12, nil)); _ -> lists:nth(1 + 1, maps:get(I_18, Edges_12, nil)) end end),
            case mochi_not(maps:is_key(Neigh_4, Visited_12)) of
        true -> Res_6 = dg_cycle_util(G_19, Neigh_4, Visited_12, Rec_2, Res_5),
            Res_12 = Res_6;
        _ -> case maps:get(Neigh_4, Rec_2, nil) of
        true -> case mochi_not(list_contains_int(Res_5, Neigh_4)) of
        true -> Res_7 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [Neigh_4]),
            Res_8 = Res_7;
        _ -> Res_8 = Res_5
    end,
            case mochi_not(list_contains_int(Res_8, Node_4)) of
        true -> Res_9 = lists:append((case Res_8 of nil -> []; _ -> Res_8 end), [Node_4]),
            Res_10 = Res_9;
        _ -> Res_10 = Res_8
    end,
            Res_11 = Res_10;
        _ -> Res_11 = Res_5
    end,
            Res_12 = Res_11
    end,
            I_19 = (I_18 + 1),
            Fun_15_loop(Edges_12, G_19, I_19, Node_4, Rec_2, Res_12, Visited_12);
        _ -> {Edges_12, G_19, I_18, Node_4, Rec_2, Res_5, Visited_12}
    end
end,
{Edges_12, G_19, I_19, Node_4, Rec_2, Res_12, Visited_12} = Fun_15(Edges_12, G_19, I_18, Node_4, Rec_2, Res_5, Visited_12),
        Rec_3 = maps:put(Node_4, false, Rec_2),
        Res_12
    catch {return, Ret} -> Ret end.

dg_cycle_nodes(G_20) ->
    try
        Visited_13 = #{},
        Rec_4 = #{},
        Res_13 = [],
        Fun_16 = fun Fun_16_loop(List, G_20, Rec_4, Res_13, Visited_13) ->
    case List of
        [] -> {G_20, Rec_4, Res_13, Visited_13};
        [K_5|K_5_rest] ->
            case mochi_not(maps:is_key(K_5, Visited_13)) of
        true -> Res_14 = dg_cycle_util(G_20, K_5, Visited_13, Rec_4, Res_13),
            Res_15 = Res_14;
        _ -> Res_15 = Res_13
    end,
            Fun_16_loop(K_5_rest, G_20, Rec_4, Res_15, Visited_13);
        _ -> {G_20, Rec_4, Res_13, Visited_13}
    end
end,
{G_20, Rec_4, Res_15, Visited_13} = Fun_16(maps:keys(maps:get("graph", G_20, nil)), G_20, Rec_4, Res_13, Visited_13),
        Res_15
    catch {return, Ret} -> Ret end.

dg_has_cycle_util(G_21, Node_5, Visited_14, Rec_5) ->
    try
        Visited_15 = maps:put(Node_5, true, Visited_14),
        Rec_6 = maps:put(Node_5, true, Rec_5),
        Edges_13 = maps:get(Node_5, maps:get("graph", G_21, nil), nil),
        I_20 = 0,
        Fun_17 = fun Fun_17_loop(Edges_13, G_21, I_20, Node_5, Rec_6, Visited_15) ->
    case (I_20 < maps:size(Edges_13)) of
        true ->
            Neigh_5 = (case erlang:is_map(maps:get(I_20, Edges_13, nil)) of true -> maps:get(1, maps:get(I_20, Edges_13, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_20, Edges_13, nil)) + 1 + 1, maps:get(I_20, Edges_13, nil)); _ -> lists:nth(1 + 1, maps:get(I_20, Edges_13, nil)) end end),
            case mochi_not(maps:is_key(Neigh_5, Visited_15)) of
        true -> case dg_has_cycle_util(G_21, Neigh_5, Visited_15, Rec_6) of
        true -> throw({return, true});
        _ -> ok
    end;
        _ -> case maps:get(Neigh_5, Rec_6, nil) of
        true -> throw({return, true});
        _ -> ok
    end
    end,
            I_21 = (I_20 + 1),
            Fun_17_loop(Edges_13, G_21, I_21, Node_5, Rec_6, Visited_15);
        _ -> {Edges_13, G_21, I_20, Node_5, Rec_6, Visited_15}
    end
end,
{Edges_13, G_21, I_21, Node_5, Rec_6, Visited_15} = Fun_17(Edges_13, G_21, I_20, Node_5, Rec_6, Visited_15),
        Rec_7 = maps:put(Node_5, false, Rec_6),
        false
    catch {return, Ret} -> Ret end.

dg_has_cycle(G_22) ->
    try
        Visited_16 = #{},
        Rec_8 = #{},
        Fun_18 = fun Fun_18_loop(List, G_22, Rec_8, Visited_16) ->
    case List of
        [] -> {G_22, Rec_8, Visited_16};
        [K_6|K_6_rest] ->
            case mochi_not(maps:is_key(K_6, Visited_16)) of
        true -> case dg_has_cycle_util(G_22, K_6, Visited_16, Rec_8) of
        true -> throw({return, true});
        _ -> ok
    end;
        _ -> ok
    end,
            Fun_18_loop(K_6_rest, G_22, Rec_8, Visited_16);
        _ -> {G_22, Rec_8, Visited_16}
    end
end,
{G_22, Rec_8, Visited_16} = Fun_18(maps:keys(maps:get("graph", G_22, nil)), G_22, Rec_8, Visited_16),
        false
    catch {return, Ret} -> Ret end.

dg_fill_graph_randomly(G_23, C) ->
    try
        Count_4 = C,
        case (Count_4 == -1) of
        true -> Count_5 = rand_range(10, 10010),
            Count_6 = Count_5;
        _ -> Count_6 = Count_4
    end,
        I_22 = 0,
        Fun_20 = fun Fun_20_loop(C, Count_6, G_23, I_22) ->
    case (I_22 < Count_6) of
        true ->
            Edge_count = rand_range(1, 103),
            J = 0,
            Fun_19 = fun Fun_19_loop(C, Count_6, Edge_count, G_23, I_22, J) ->
    case (J < Edge_count) of
        true ->
            N = rand_range(0, Count_6),
            case (N /= I_22) of
        true -> dg_add_pair(G_23, I_22, N, 1);
        _ -> ok
    end,
            J_2 = (J + 1),
            Fun_19_loop(C, Count_6, Edge_count, G_23, I_22, J_2);
        _ -> {C, Count_6, Edge_count, G_23, I_22, J}
    end
end,
{C, Count_6, Edge_count, G_23, I_22, J_2} = Fun_19(C, Count_6, Edge_count, G_23, I_22, J),
            I_23 = (I_22 + 1),
            Fun_20_loop(C, Count_6, G_23, I_23);
        _ -> {C, Count_6, G_23, I_22}
    end
end,
{C, Count_6, G_23, I_23} = Fun_20(C, Count_6, G_23, I_22),
        nil
    catch {return, Ret} -> Ret end.

dg_dfs_time(G_24, S_3, E) ->
    try
        Begin = mochi_now(),
        dg_dfs(G_24, S_3, E),
        End = mochi_now(),
        (End - Begin)
    catch {return, Ret} -> Ret end.

dg_bfs_time(G_25, S_4) ->
    try
        Begin_2 = mochi_now(),
        dg_bfs(G_25, S_4),
        End_2 = mochi_now(),
        (End_2 - Begin_2)
    catch {return, Ret} -> Ret end.

g_make_graph() ->
    try
        #{"graph" => #{}}
    catch {return, Ret} -> Ret end.

g_add_pair(G_26, U_5, V_4, W_3) ->
    try
        case maps:is_key(U_5, maps:get("graph", G_26, nil)) of
        true -> Edges_14 = maps:get(U_5, maps:get("graph", G_26, nil), nil),
            case mochi_not(edge_exists(Edges_14, W_3, V_4)) of
        true -> Edges_15 = lists:append((case Edges_14 of nil -> []; _ -> Edges_14 end), [[W_3, V_4]]),
            M_9 = maps:get("graph", G_26, nil),
            M_10 = maps:put(U_5, Edges_15, M_9),
            G_27 = maps:put("graph", M_10, G_26),
            Edges_16 = Edges_15,
            G_28 = G_27,
            M_11 = M_10;
        _ -> Edges_16 = Edges_14,
            G_28 = G_26,
            M_11 = nil
    end,
            Edges_17 = Edges_16,
            G_30 = G_28,
            M_12 = M_11,
            M0_6 = nil;
        _ -> M0_4 = maps:get("graph", G_26, nil),
            M0_5 = maps:put(U_5, [[W_3, V_4]], M0_4),
            G_29 = maps:put("graph", M0_5, G_26),
            Edges_17 = nil,
            G_30 = G_29,
            M_12 = nil,
            M0_6 = M0_5
    end,
        case maps:is_key(V_4, maps:get("graph", G_30, nil)) of
        true -> Edges2 = maps:get(V_4, maps:get("graph", G_30, nil), nil),
            case mochi_not(edge_exists(Edges2, W_3, U_5)) of
        true -> Edges2_2 = lists:append((case Edges2 of nil -> []; _ -> Edges2 end), [[W_3, U_5]]),
            M2 = maps:get("graph", G_30, nil),
            M2_2 = maps:put(V_4, Edges2_2, M2),
            G_31 = maps:put("graph", M2_2, G_30),
            Edges2_3 = Edges2_2,
            G_32 = G_31,
            M2_3 = M2_2;
        _ -> Edges2_3 = Edges2,
            G_32 = G_30,
            M2_3 = nil
    end,
            Edges2_4 = Edges2_3,
            G_34 = G_32,
            M2_4 = M2_3,
            M3_3 = nil;
        _ -> M3 = maps:get("graph", G_30, nil),
            M3_2 = maps:put(V_4, [[W_3, U_5]], M3),
            G_33 = maps:put("graph", M3_2, G_30),
            Edges2_4 = nil,
            G_34 = G_33,
            M2_4 = nil,
            M3_3 = M3_2
    end,
        nil
    catch {return, Ret} -> Ret end.

g_remove_pair(G_35, U_6, V_5) ->
    try
        case maps:is_key(U_6, maps:get("graph", G_35, nil)) of
        true -> Edges_18 = maps:get(U_6, maps:get("graph", G_35, nil), nil),
            New_edges_5 = [],
            I_24 = 0,
            Fun_21 = fun Fun_21_loop(Edges_18, G_35, I_24, New_edges_5, U_6, V_5) ->
    case (I_24 < maps:size(Edges_18)) of
        true ->
            case ((case erlang:is_map(maps:get(I_24, Edges_18, nil)) of true -> maps:get(1, maps:get(I_24, Edges_18, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_24, Edges_18, nil)) + 1 + 1, maps:get(I_24, Edges_18, nil)); _ -> lists:nth(1 + 1, maps:get(I_24, Edges_18, nil)) end end) /= V_5) of
        true -> New_edges_6 = lists:append((case New_edges_5 of nil -> []; _ -> New_edges_5 end), [maps:get(I_24, Edges_18, nil)]),
            New_edges_7 = New_edges_6;
        _ -> New_edges_7 = New_edges_5
    end,
            I_25 = (I_24 + 1),
            Fun_21_loop(Edges_18, G_35, I_25, New_edges_7, U_6, V_5);
        _ -> {Edges_18, G_35, I_24, New_edges_5, U_6, V_5}
    end
end,
{Edges_18, G_35, I_25, New_edges_7, U_6, V_5} = Fun_21(Edges_18, G_35, I_24, New_edges_5, U_6, V_5),
            M_13 = maps:get("graph", G_35, nil),
            M_14 = maps:put(U_6, New_edges_7, M_13),
            G_36 = maps:put("graph", M_14, G_35),
            Edges_19 = Edges_18,
            Fun_22 = Fun_21,
            G_37 = G_36,
            I_26 = I_25,
            M_15 = M_14,
            New_edges_8 = New_edges_7;
        _ -> Edges_19 = nil,
            Fun_22 = nil,
            G_37 = G_35,
            I_26 = nil,
            M_15 = nil,
            New_edges_8 = nil
    end,
        case maps:is_key(V_5, maps:get("graph", G_37, nil)) of
        true -> Edges2_5 = maps:get(V_5, maps:get("graph", G_37, nil), nil),
            New_edges2 = [],
            J_3 = 0,
            Fun_23 = fun Fun_23_loop(Edges_19, Edges2_5, G_37, I_26, J_3, M_15, New_edges_8, New_edges2, U_6, V_5) ->
    case (J_3 < maps:size(Edges2_5)) of
        true ->
            case ((case erlang:is_map(maps:get(J_3, Edges2_5, nil)) of true -> maps:get(1, maps:get(J_3, Edges2_5, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(J_3, Edges2_5, nil)) + 1 + 1, maps:get(J_3, Edges2_5, nil)); _ -> lists:nth(1 + 1, maps:get(J_3, Edges2_5, nil)) end end) /= U_6) of
        true -> New_edges2_2 = lists:append((case New_edges2 of nil -> []; _ -> New_edges2 end), [maps:get(J_3, Edges2_5, nil)]),
            New_edges2_3 = New_edges2_2;
        _ -> New_edges2_3 = New_edges2
    end,
            J_4 = (J_3 + 1),
            Fun_23_loop(Edges_19, Edges2_5, G_37, I_26, J_4, M_15, New_edges_8, New_edges2_3, U_6, V_5);
        _ -> {Edges_19, Edges2_5, G_37, I_26, J_3, M_15, New_edges_8, New_edges2, U_6, V_5}
    end
end,
{Edges_19, Edges2_5, G_37, I_26, J_4, M_15, New_edges_8, New_edges2_3, U_6, V_5} = Fun_23(Edges_19, Edges2_5, G_37, I_26, J_3, M_15, New_edges_8, New_edges2, U_6, V_5),
            M2_5 = maps:get("graph", G_37, nil),
            M2_6 = maps:put(V_5, New_edges2_3, M2_5),
            G_38 = maps:put("graph", M2_6, G_37),
            Edges2_6 = Edges2_5,
            Fun_24 = Fun_23,
            G_39 = G_38,
            J_5 = J_4,
            M2_7 = M2_6,
            New_edges2_4 = New_edges2_3;
        _ -> Edges2_6 = nil,
            Fun_24 = Fun_22,
            G_39 = G_37,
            J_5 = nil,
            M2_7 = nil,
            New_edges2_4 = nil
    end,
        nil
    catch {return, Ret} -> Ret end.

g_all_nodes(G_40) ->
    try
        Res_16 = [],
        Fun_25 = fun Fun_25_loop(List, G_40, Res_16) ->
    case List of
        [] -> {G_40, Res_16};
        [K_7|K_7_rest] ->
            Res_17 = lists:append((case Res_16 of nil -> []; _ -> Res_16 end), [K_7]),
            Fun_25_loop(K_7_rest, G_40, Res_17);
        _ -> {G_40, Res_16}
    end
end,
{G_40, Res_17} = Fun_25(maps:keys(maps:get("graph", G_40, nil)), G_40, Res_16),
        Res_17
    catch {return, Ret} -> Ret end.

g_dfs_util(G_41, Node_6, Visited_17, Order_9, D_3) ->
    try
        Visited_18 = maps:put(Node_6, true, Visited_17),
        Order_10 = lists:append((case Order_9 of nil -> []; _ -> Order_9 end), [Node_6]),
        case ((D_3 /= -1) andalso (Node_6 == D_3)) of
        true -> throw({return, Order_10});
        _ -> ok
    end,
        Edges_20 = maps:get(Node_6, maps:get("graph", G_41, nil), nil),
        I_27 = 0,
        Fun_26 = fun Fun_26_loop(D_3, Edges_20, G_41, I_27, Node_6, Order_10, Visited_18) ->
    case (I_27 < maps:size(Edges_20)) of
        true ->
            Neigh_6 = (case erlang:is_map(maps:get(I_27, Edges_20, nil)) of true -> maps:get(1, maps:get(I_27, Edges_20, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_27, Edges_20, nil)) + 1 + 1, maps:get(I_27, Edges_20, nil)); _ -> lists:nth(1 + 1, maps:get(I_27, Edges_20, nil)) end end),
            case mochi_not(maps:is_key(Neigh_6, Visited_18)) of
        true -> Order_11 = g_dfs_util(G_41, Neigh_6, Visited_18, Order_10, D_3),
            case ((D_3 /= -1) andalso ((case erlang:is_map(Order_11) of true -> maps:get((erlang:length(Order_11) - 1), Order_11, nil); _ -> case (erlang:length(Order_11) - 1) < 0 of true -> lists:nth(erlang:length(Order_11) + (erlang:length(Order_11) - 1) + 1, Order_11); _ -> lists:nth((erlang:length(Order_11) - 1) + 1, Order_11) end end) == D_3)) of
        true -> throw({return, Order_11});
        _ -> ok
    end,
            Order_12 = Order_11;
        _ -> Order_12 = Order_10
    end,
            I_28 = (I_27 + 1),
            Fun_26_loop(D_3, Edges_20, G_41, I_28, Node_6, Order_12, Visited_18);
        _ -> {D_3, Edges_20, G_41, I_27, Node_6, Order_10, Visited_18}
    end
end,
{D_3, Edges_20, G_41, I_28, Node_6, Order_12, Visited_18} = Fun_26(D_3, Edges_20, G_41, I_27, Node_6, Order_10, Visited_18),
        Order_12
    catch {return, Ret} -> Ret end.

g_dfs(G_42, S_5, D_4) ->
    try
        case (S_5 == D_4) of
        true -> throw({return, []});
        _ -> ok
    end,
        Start_3 = (case (S_5 == -2) of
    true -> first_key(maps:get("graph", G_42, nil));
    _ -> S_5
end),
        Visited_19 = #{},
        Order_13 = [],
        Order_14 = g_dfs_util(G_42, Start_3, Visited_19, Order_13, D_4),
        Order_14
    catch {return, Ret} -> Ret end.

g_bfs(G_43, S_6) ->
    try
        Queue_6 = [],
        Visited_20 = #{},
        Order_15 = [],
        Start_4 = (case (S_6 == -2) of
    true -> first_key(maps:get("graph", G_43, nil));
    _ -> S_6
end),
        Queue_7 = lists:append((case Queue_6 of nil -> []; _ -> Queue_6 end), [Start_4]),
        Visited_21 = maps:put(Start_4, true, Visited_20),
        Fun_28 = fun Fun_28_loop(G_43, Order_15, Queue_7, S_6, Start_4, Visited_21) ->
    case (erlang:length(Queue_7) > 0) of
        true ->
            Node_7 = (case erlang:is_map(Queue_7) of true -> maps:get(0, Queue_7, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Queue_7) + 0 + 1, Queue_7); _ -> lists:nth(0 + 1, Queue_7) end end),
            Queue_8 = lists:sublist(Queue_7, 1 + 1, (erlang:length(Queue_7) - 1)),
            Order_16 = lists:append((case Order_15 of nil -> []; _ -> Order_15 end), [Node_7]),
            Edges_21 = maps:get(Node_7, maps:get("graph", G_43, nil), nil),
            I_29 = 0,
            Fun_27 = fun Fun_27_loop(Edges_21, G_43, I_29, Node_7, Order_16, Queue_8, S_6, Start_4, Visited_21) ->
    case (I_29 < maps:size(Edges_21)) of
        true ->
            Neigh_7 = (case erlang:is_map(maps:get(I_29, Edges_21, nil)) of true -> maps:get(1, maps:get(I_29, Edges_21, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_29, Edges_21, nil)) + 1 + 1, maps:get(I_29, Edges_21, nil)); _ -> lists:nth(1 + 1, maps:get(I_29, Edges_21, nil)) end end),
            case mochi_not(maps:is_key(Neigh_7, Visited_21)) of
        true -> Queue_9 = lists:append((case Queue_8 of nil -> []; _ -> Queue_8 end), [Neigh_7]),
            Visited_22 = maps:put(Neigh_7, true, Visited_21),
            Queue_10 = Queue_9,
            Visited_23 = Visited_22;
        _ -> Queue_10 = Queue_8,
            Visited_23 = Visited_21
    end,
            I_30 = (I_29 + 1),
            Fun_27_loop(Edges_21, G_43, I_30, Node_7, Order_16, Queue_10, S_6, Start_4, Visited_23);
        _ -> {Edges_21, G_43, I_29, Node_7, Order_16, Queue_8, S_6, Start_4, Visited_21}
    end
end,
{Edges_21, G_43, I_30, Node_7, Order_16, Queue_10, S_6, Start_4, Visited_23} = Fun_27(Edges_21, G_43, I_29, Node_7, Order_16, Queue_8, S_6, Start_4, Visited_21),
            Fun_28_loop(G_43, Order_16, Queue_10, S_6, Start_4, Visited_23);
        _ -> {G_43, Order_15, Queue_7, S_6, Start_4, Visited_21}
    end
end,
{G_43, Order_16, Queue_10, S_6, Start_4, Visited_23} = Fun_28(G_43, Order_15, Queue_7, S_6, Start_4, Visited_21),
        Order_16
    catch {return, Ret} -> Ret end.

g_degree(G_44, U_7) ->
    try
        (case maps:is_key(U_7, maps:get("graph", G_44, nil)) of
    true -> maps:size(maps:get(U_7, maps:get("graph", G_44, nil), nil));
    _ -> 0
end)
    catch {return, Ret} -> Ret end.

g_cycle_util(G_45, Node_8, Visited_24, Parent, Res_18) ->
    try
        Visited_25 = maps:put(Node_8, true, Visited_24),
        Edges_22 = maps:get(Node_8, maps:get("graph", G_45, nil), nil),
        I_31 = 0,
        Fun_29 = fun Fun_29_loop(Edges_22, G_45, I_31, Node_8, Parent, Res_18, Visited_25) ->
    case (I_31 < maps:size(Edges_22)) of
        true ->
            Neigh_8 = (case erlang:is_map(maps:get(I_31, Edges_22, nil)) of true -> maps:get(1, maps:get(I_31, Edges_22, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_31, Edges_22, nil)) + 1 + 1, maps:get(I_31, Edges_22, nil)); _ -> lists:nth(1 + 1, maps:get(I_31, Edges_22, nil)) end end),
            case mochi_not(maps:is_key(Neigh_8, Visited_25)) of
        true -> Res_19 = g_cycle_util(G_45, Neigh_8, Visited_25, Node_8, Res_18),
            Res_25 = Res_19;
        _ -> case (Neigh_8 /= Parent) of
        true -> case mochi_not(list_contains_int(Res_18, Neigh_8)) of
        true -> Res_20 = lists:append((case Res_18 of nil -> []; _ -> Res_18 end), [Neigh_8]),
            Res_21 = Res_20;
        _ -> Res_21 = Res_18
    end,
            case mochi_not(list_contains_int(Res_21, Node_8)) of
        true -> Res_22 = lists:append((case Res_21 of nil -> []; _ -> Res_21 end), [Node_8]),
            Res_23 = Res_22;
        _ -> Res_23 = Res_21
    end,
            Res_24 = Res_23;
        _ -> Res_24 = Res_18
    end,
            Res_25 = Res_24
    end,
            I_32 = (I_31 + 1),
            Fun_29_loop(Edges_22, G_45, I_32, Node_8, Parent, Res_25, Visited_25);
        _ -> {Edges_22, G_45, I_31, Node_8, Parent, Res_18, Visited_25}
    end
end,
{Edges_22, G_45, I_32, Node_8, Parent, Res_25, Visited_25} = Fun_29(Edges_22, G_45, I_31, Node_8, Parent, Res_18, Visited_25),
        Res_25
    catch {return, Ret} -> Ret end.

g_cycle_nodes(G_46) ->
    try
        Visited_26 = #{},
        Res_26 = [],
        Fun_30 = fun Fun_30_loop(List, G_46, Res_26, Visited_26) ->
    case List of
        [] -> {G_46, Res_26, Visited_26};
        [K_8|K_8_rest] ->
            case mochi_not(maps:is_key(K_8, Visited_26)) of
        true -> Res_27 = g_cycle_util(G_46, K_8, Visited_26, -1, Res_26),
            Res_28 = Res_27;
        _ -> Res_28 = Res_26
    end,
            Fun_30_loop(K_8_rest, G_46, Res_28, Visited_26);
        _ -> {G_46, Res_26, Visited_26}
    end
end,
{G_46, Res_28, Visited_26} = Fun_30(maps:keys(maps:get("graph", G_46, nil)), G_46, Res_26, Visited_26),
        Res_28
    catch {return, Ret} -> Ret end.

g_has_cycle_util(G_47, Node_9, Visited_27, Parent_2) ->
    try
        Visited_28 = maps:put(Node_9, true, Visited_27),
        Edges_23 = maps:get(Node_9, maps:get("graph", G_47, nil), nil),
        I_33 = 0,
        Fun_31 = fun Fun_31_loop(Edges_23, G_47, I_33, Node_9, Parent_2, Visited_28) ->
    case (I_33 < maps:size(Edges_23)) of
        true ->
            Neigh_9 = (case erlang:is_map(maps:get(I_33, Edges_23, nil)) of true -> maps:get(1, maps:get(I_33, Edges_23, nil), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(maps:get(I_33, Edges_23, nil)) + 1 + 1, maps:get(I_33, Edges_23, nil)); _ -> lists:nth(1 + 1, maps:get(I_33, Edges_23, nil)) end end),
            case mochi_not(maps:is_key(Neigh_9, Visited_28)) of
        true -> case g_has_cycle_util(G_47, Neigh_9, Visited_28, Node_9) of
        true -> throw({return, true});
        _ -> ok
    end;
        _ -> case (Neigh_9 /= Parent_2) of
        true -> throw({return, true});
        _ -> ok
    end
    end,
            I_34 = (I_33 + 1),
            Fun_31_loop(Edges_23, G_47, I_34, Node_9, Parent_2, Visited_28);
        _ -> {Edges_23, G_47, I_33, Node_9, Parent_2, Visited_28}
    end
end,
{Edges_23, G_47, I_34, Node_9, Parent_2, Visited_28} = Fun_31(Edges_23, G_47, I_33, Node_9, Parent_2, Visited_28),
        false
    catch {return, Ret} -> Ret end.

g_has_cycle(G_48) ->
    try
        Visited_29 = #{},
        Fun_32 = fun Fun_32_loop(List, G_48, Visited_29) ->
    case List of
        [] -> {G_48, Visited_29};
        [K_9|K_9_rest] ->
            case mochi_not(maps:is_key(K_9, Visited_29)) of
        true -> case g_has_cycle_util(G_48, K_9, Visited_29, -1) of
        true -> throw({return, true});
        _ -> ok
    end;
        _ -> ok
    end,
            Fun_32_loop(K_9_rest, G_48, Visited_29);
        _ -> {G_48, Visited_29}
    end
end,
{G_48, Visited_29} = Fun_32(maps:keys(maps:get("graph", G_48, nil)), G_48, Visited_29),
        false
    catch {return, Ret} -> Ret end.

g_fill_graph_randomly(G_49, C_2) ->
    try
        Count_7 = C_2,
        case (Count_7 == -1) of
        true -> Count_8 = rand_range(10, 10010),
            Count_9 = Count_8;
        _ -> Count_9 = Count_7
    end,
        I_35 = 0,
        Fun_34 = fun Fun_34_loop(C_2, Count_9, G_49, I_35) ->
    case (I_35 < Count_9) of
        true ->
            Edge_count_2 = rand_range(1, 103),
            J_6 = 0,
            Fun_33 = fun Fun_33_loop(C_2, Count_9, Edge_count_2, G_49, I_35, J_6) ->
    case (J_6 < Edge_count_2) of
        true ->
            N_2 = rand_range(0, Count_9),
            case (N_2 /= I_35) of
        true -> g_add_pair(G_49, I_35, N_2, 1);
        _ -> ok
    end,
            J_7 = (J_6 + 1),
            Fun_33_loop(C_2, Count_9, Edge_count_2, G_49, I_35, J_7);
        _ -> {C_2, Count_9, Edge_count_2, G_49, I_35, J_6}
    end
end,
{C_2, Count_9, Edge_count_2, G_49, I_35, J_7} = Fun_33(C_2, Count_9, Edge_count_2, G_49, I_35, J_6),
            I_36 = (I_35 + 1),
            Fun_34_loop(C_2, Count_9, G_49, I_36);
        _ -> {C_2, Count_9, G_49, I_35}
    end
end,
{C_2, Count_9, G_49, I_36} = Fun_34(C_2, Count_9, G_49, I_35),
        nil
    catch {return, Ret} -> Ret end.

g_dfs_time(G_50, S_7, E_2) ->
    try
        Begin_3 = mochi_now(),
        g_dfs(G_50, S_7, E_2),
        End_3 = mochi_now(),
        (End_3 - Begin_3)
    catch {return, Ret} -> Ret end.

g_bfs_time(G_51, S_8) ->
    try
        Begin_4 = mochi_now(),
        g_bfs(G_51, S_8),
        End_4 = mochi_now(),
        (End_4 - Begin_4)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Dg = dg_make_graph(),
        dg_add_pair(Dg, 0, 1, 5),
        dg_add_pair(Dg, 0, 2, 3),
        dg_add_pair(Dg, 1, 3, 2),
        dg_add_pair(Dg, 2, 3, 4),
        io:format("~ts~n", [mochi_str(dg_dfs(Dg, -2, -1))]),
        io:format("~ts~n", [mochi_str(dg_bfs(Dg, -2))]),
        io:format("~ts~n", [mochi_str(dg_in_degree(Dg, 3))]),
        io:format("~ts~n", [mochi_str(dg_out_degree(Dg, 0))]),
        io:format("~ts~n", [mochi_str(dg_topological_sort(Dg))]),
        io:format("~ts~n", [mochi_str(dg_has_cycle(Dg))]),
        Ug = g_make_graph(),
        g_add_pair(Ug, 0, 1, 1),
        g_add_pair(Ug, 1, 2, 1),
        g_add_pair(Ug, 2, 0, 1),
        io:format("~ts~n", [mochi_str(g_dfs(Ug, -2, -1))]),
        io:format("~ts~n", [mochi_str(g_bfs(Ug, -2))]),
        io:format("~ts~n", [mochi_str(g_degree(Ug, 1))]),
        io:format("~ts~n", [mochi_str(g_has_cycle(Ug))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
