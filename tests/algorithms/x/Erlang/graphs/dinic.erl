#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow2/1, min2/2, new_dinic/1, add_edge/5, dfs/4, max_flow/3]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

pow2(K) ->
    try
        Res = 1,
        I = 0,
        Fun = fun Fun_loop(I, K, Res) ->
    case (I < K) of
        true ->
            Res_2 = (Res * 2),
            I_2 = (I + 1),
            Fun_loop(I_2, K, Res_2);
        _ -> {I, K, Res}
    end
end,
{I_2, K, Res_2} = Fun(I, K, Res),
        Res_2
    catch {return, Ret} -> Ret end.

min2(A, B) ->
    try
        (case (A < B) of
    true -> A;
    _ -> B
end)
    catch {return, Ret} -> Ret end.

new_dinic(N) ->
    try
        Lvl = [],
        Ptr = [],
        Q = [],
        Adj = [],
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Adj, I_3, Lvl, N, Ptr, Q) ->
    case (I_3 < N) of
        true ->
            Lvl_2 = lists:append((case Lvl of nil -> []; _ -> Lvl end), [0]),
            Ptr_2 = lists:append((case Ptr of nil -> []; _ -> Ptr end), [0]),
            Q_2 = lists:append((case Q of nil -> []; _ -> Q end), [0]),
            Edges = [],
            Adj_2 = lists:append((case Adj of nil -> []; _ -> Adj end), [Edges]),
            I_4 = (I_3 + 1),
            Fun_2_loop(Adj_2, I_4, Lvl_2, N, Ptr_2, Q_2);
        _ -> {Adj, I_3, Lvl, N, Ptr, Q}
    end
end,
{Adj_2, I_4, Lvl_2, N, Ptr_2, Q_2} = Fun_2(Adj, I_3, Lvl, N, Ptr, Q),
        #{"n" => N, "lvl" => Lvl_2, "ptr" => Ptr_2, "q" => Q_2, "adj" => Adj_2}
    catch {return, Ret} -> Ret end.

add_edge(G, A_2, B_2, C, Rcap) ->
    try
        Adj_3 = maps:get("adj", G, nil),
        List_a = (case erlang:is_map(Adj_3) of true -> maps:get(A_2, Adj_3, nil); _ -> case A_2 < 0 of true -> lists:nth(erlang:length(Adj_3) + A_2 + 1, Adj_3); _ -> lists:nth(A_2 + 1, Adj_3) end end),
        List_b = (case erlang:is_map(Adj_3) of true -> maps:get(B_2, Adj_3, nil); _ -> case B_2 < 0 of true -> lists:nth(erlang:length(Adj_3) + B_2 + 1, Adj_3); _ -> lists:nth(B_2 + 1, Adj_3) end end),
        E1 = [B_2, erlang:length(List_b), C, 0],
        E2 = [A_2, erlang:length(List_a), Rcap, 0],
        List_a_2 = lists:append((case List_a of nil -> []; _ -> List_a end), [E1]),
        List_b_2 = lists:append((case List_b of nil -> []; _ -> List_b end), [E2]),
        Adj_4 = lists:sublist(Adj_3, A_2) ++ [List_a_2] ++ lists:nthtail(A_2 + 1, Adj_3),
        Adj_5 = lists:sublist(Adj_4, B_2) ++ [List_b_2] ++ lists:nthtail(B_2 + 1, Adj_4),
        G_2 = maps:put("adj", Adj_5, G),
        {nil, G_2}
    catch {return, Ret} -> Ret end.

dfs(G_3, V, Sink, Flow) ->
    try
        case ((V == Sink) orelse (Flow == 0)) of
        true -> throw({return, Flow});
        _ -> ok
    end,
        Ptr_3 = maps:get("ptr", G_3, nil),
        I_5 = (case erlang:is_map(Ptr_3) of true -> maps:get(V, Ptr_3, nil); _ -> case V < 0 of true -> lists:nth(erlang:length(Ptr_3) + V + 1, Ptr_3); _ -> lists:nth(V + 1, Ptr_3) end end),
        Adj_all = maps:get("adj", G_3, nil),
        Adj_v = (case erlang:is_map(Adj_all) of true -> maps:get(V, Adj_all, nil); _ -> case V < 0 of true -> lists:nth(erlang:length(Adj_all) + V + 1, Adj_all); _ -> lists:nth(V + 1, Adj_all) end end),
        Fun_3 = fun Fun_3_loop(Adj_all, Adj_v, Flow, G_3, I_5, Ptr_3, Sink, V) ->
    case (I_5 < erlang:length(Adj_v)) of
        true ->
            E = (case erlang:is_map(Adj_v) of true -> maps:get(I_5, Adj_v, nil); _ -> case I_5 < 0 of true -> lists:nth(erlang:length(Adj_v) + I_5 + 1, Adj_v); _ -> lists:nth(I_5 + 1, Adj_v) end end),
            To = (case erlang:is_map(E) of true -> maps:get(0, E, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(E) + 0 + 1, E); _ -> lists:nth(0 + 1, E) end end),
            case ((case erlang:is_map(maps:get("lvl", G_3, nil)) of true -> maps:get(To, maps:get("lvl", G_3, nil), nil); _ -> case To < 0 of true -> lists:nth(erlang:length(maps:get("lvl", G_3, nil)) + To + 1, maps:get("lvl", G_3, nil)); _ -> lists:nth(To + 1, maps:get("lvl", G_3, nil)) end end) == ((case erlang:is_map(maps:get("lvl", G_3, nil)) of true -> maps:get(V, maps:get("lvl", G_3, nil), nil); _ -> case V < 0 of true -> lists:nth(erlang:length(maps:get("lvl", G_3, nil)) + V + 1, maps:get("lvl", G_3, nil)); _ -> lists:nth(V + 1, maps:get("lvl", G_3, nil)) end end) + 1)) of
        true -> Avail = ((case erlang:is_map(E) of true -> maps:get(2, E, nil); _ -> case 2 < 0 of true -> lists:nth(erlang:length(E) + 2 + 1, E); _ -> lists:nth(2 + 1, E) end end) - (case erlang:is_map(E) of true -> maps:get(3, E, nil); _ -> case 3 < 0 of true -> lists:nth(erlang:length(E) + 3 + 1, E); _ -> lists:nth(3 + 1, E) end end)),
            Pushed = dfs(G_3, To, Sink, min2(Flow, Avail)),
            case (Pushed > 0) of
        true -> E_2 = lists:sublist(E, 3) ++ [((case erlang:is_map(E) of true -> maps:get(3, E, nil); _ -> case 3 < 0 of true -> lists:nth(erlang:length(E) + 3 + 1, E); _ -> lists:nth(3 + 1, E) end end) + Pushed)] ++ lists:nthtail(3 + 1, E),
            Adj_v_2 = lists:sublist(Adj_v, I_5) ++ [E_2] ++ lists:nthtail(I_5 + 1, Adj_v),
            Adj_to = (case erlang:is_map(Adj_all) of true -> maps:get(To, Adj_all, nil); _ -> case To < 0 of true -> lists:nth(erlang:length(Adj_all) + To + 1, Adj_all); _ -> lists:nth(To + 1, Adj_all) end end),
            Back = (case erlang:is_map(Adj_to) of true -> maps:get((case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end), Adj_to, nil); _ -> case (case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end) < 0 of true -> lists:nth(erlang:length(Adj_to) + (case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end) + 1, Adj_to); _ -> lists:nth((case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end) + 1, Adj_to) end end),
            Back_2 = lists:sublist(Back, 3) ++ [((case erlang:is_map(Back) of true -> maps:get(3, Back, nil); _ -> case 3 < 0 of true -> lists:nth(erlang:length(Back) + 3 + 1, Back); _ -> lists:nth(3 + 1, Back) end end) - Pushed)] ++ lists:nthtail(3 + 1, Back),
            Adj_to_2 = lists:sublist(Adj_to, (case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end)) ++ [Back_2] ++ lists:nthtail((case erlang:is_map(E_2) of true -> maps:get(1, E_2, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(E_2) + 1 + 1, E_2); _ -> lists:nth(1 + 1, E_2) end end) + 1, Adj_to),
            Adj_all_2 = lists:sublist(Adj_all, To) ++ [Adj_to_2] ++ lists:nthtail(To + 1, Adj_all),
            Adj_all_3 = lists:sublist(Adj_all_2, V) ++ [Adj_v_2] ++ lists:nthtail(V + 1, Adj_all_2),
            G_4 = maps:put("adj", Adj_all_3, G_3),
            throw({return, Pushed}),
            Adj_all_4 = Adj_all_3,
            Adj_to_3 = Adj_to_2,
            Adj_v_3 = Adj_v_2,
            Back_3 = Back_2,
            E_3 = E_2,
            G_5 = G_4;
        _ -> Adj_all_4 = Adj_all,
            Adj_to_3 = nil,
            Adj_v_3 = Adj_v,
            Back_3 = nil,
            E_3 = E,
            G_5 = G_3
    end,
            Adj_all_5 = Adj_all_4,
            Adj_to_4 = Adj_to_3,
            Adj_v_4 = Adj_v_3,
            Avail_2 = Avail,
            Back_4 = Back_3,
            E_4 = E_3,
            G_6 = G_5,
            Pushed_2 = Pushed;
        _ -> Adj_all_5 = Adj_all,
            Adj_to_4 = nil,
            Adj_v_4 = Adj_v,
            Avail_2 = nil,
            Back_4 = nil,
            E_4 = E,
            G_6 = G_3,
            Pushed_2 = nil
    end,
            I_6 = (I_5 + 1),
            Ptr_4 = lists:sublist(Ptr_3, V) ++ [I_6] ++ lists:nthtail(V + 1, Ptr_3),
            Fun_3_loop(Adj_all_5, Adj_v_4, Flow, G_6, I_6, Ptr_4, Sink, V);
        _ -> {Adj_all, Adj_v, Flow, G_3, I_5, Ptr_3, Sink, V}
    end
end,
{Adj_all_5, Adj_v_4, Flow, G_6, I_6, Ptr_4, Sink, V} = Fun_3(Adj_all, Adj_v, Flow, G_3, I_5, Ptr_3, Sink, V),
        G_7 = maps:put("ptr", Ptr_4, G_6),
        Adj_all_6 = lists:sublist(Adj_all_5, V) ++ [Adj_v_4] ++ lists:nthtail(V + 1, Adj_all_5),
        G_8 = maps:put("adj", Adj_all_6, G_7),
        {nil, G_8}
    catch {return, Ret} -> Ret end.

max_flow(G_9, Source, Sink_2) ->
    try
        Flow_2 = 0,
        L = 0,
        Fun_9 = fun Fun_9_loop(Flow_2, G_9, L, Sink_2, Source) ->
    case (L < 31) of
        true ->
            try
                Threshold = pow2((30 - L)),
                Fun_8 = fun Fun_8_loop(Flow_2, G_9, L, Sink_2, Source, Threshold) ->
    case true of
        true ->
            try
                Lvl_3 = [],
                Ptr_5 = [],
                I_7 = 0,
                Fun_4 = fun Fun_4_loop(Flow_2, G_9, I_7, L, Lvl_3, Ptr_5, Sink_2, Source, Threshold) ->
    case (I_7 < maps:get("n", G_9, nil)) of
        true ->
            Lvl_4 = lists:append((case Lvl_3 of nil -> []; _ -> Lvl_3 end), [0]),
            Ptr_6 = lists:append((case Ptr_5 of nil -> []; _ -> Ptr_5 end), [0]),
            I_8 = (I_7 + 1),
            Fun_4_loop(Flow_2, G_9, I_8, L, Lvl_4, Ptr_6, Sink_2, Source, Threshold);
        _ -> {Flow_2, G_9, I_7, L, Lvl_3, Ptr_5, Sink_2, Source, Threshold}
    end
end,
{Flow_2, G_9, I_8, L, Lvl_4, Ptr_6, Sink_2, Source, Threshold} = Fun_4(Flow_2, G_9, I_7, L, Lvl_3, Ptr_5, Sink_2, Source, Threshold),
                G_10 = maps:put("lvl", Lvl_4, G_9),
                G_11 = maps:put("ptr", Ptr_6, G_10),
                Qi = 0,
                Qe = 1,
                Lvl_5 = lists:sublist(Lvl_4, Source) ++ [1] ++ lists:nthtail(Source + 1, Lvl_4),
                G_12 = maps:put("lvl", Lvl_5, G_11),
                Q_3 = maps:get("q", G_12, nil),
                Q_4 = lists:sublist(Q_3, 0) ++ [Source] ++ lists:nthtail(0 + 1, Q_3),
                Fun_6 = fun Fun_6_loop(Flow_2, G_12, I_8, L, Lvl_5, Ptr_6, Q_4, Qe, Qi, Sink_2, Source, Threshold) ->
    case ((Qi < Qe) andalso ((case erlang:is_map(maps:get("lvl", G_12, nil)) of true -> maps:get(Sink_2, maps:get("lvl", G_12, nil), nil); _ -> case Sink_2 < 0 of true -> lists:nth(erlang:length(maps:get("lvl", G_12, nil)) + Sink_2 + 1, maps:get("lvl", G_12, nil)); _ -> lists:nth(Sink_2 + 1, maps:get("lvl", G_12, nil)) end end) == 0)) of
        true ->
            V_2 = (case erlang:is_map(Q_4) of true -> maps:get(Qi, Q_4, nil); _ -> case Qi < 0 of true -> lists:nth(erlang:length(Q_4) + Qi + 1, Q_4); _ -> lists:nth(Qi + 1, Q_4) end end),
            Qi_2 = (Qi + 1),
            Edges_2 = (case erlang:is_map(maps:get("adj", G_12, nil)) of true -> maps:get(V_2, maps:get("adj", G_12, nil), nil); _ -> case V_2 < 0 of true -> lists:nth(erlang:length(maps:get("adj", G_12, nil)) + V_2 + 1, maps:get("adj", G_12, nil)); _ -> lists:nth(V_2 + 1, maps:get("adj", G_12, nil)) end end),
            J = 0,
            Fun_5 = fun Fun_5_loop(Edges_2, Flow_2, G_12, I_8, J, L, Lvl_5, Ptr_6, Q_4, Qe, Qi_2, Sink_2, Source, Threshold, V_2) ->
    case (J < erlang:length(Edges_2)) of
        true ->
            E_5 = (case erlang:is_map(Edges_2) of true -> maps:get(J, Edges_2, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Edges_2) + J + 1, Edges_2); _ -> lists:nth(J + 1, Edges_2) end end),
            To_2 = (case erlang:is_map(E_5) of true -> maps:get(0, E_5, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(E_5) + 0 + 1, E_5); _ -> lists:nth(0 + 1, E_5) end end),
            Residual = ((case erlang:is_map(E_5) of true -> maps:get(2, E_5, nil); _ -> case 2 < 0 of true -> lists:nth(erlang:length(E_5) + 2 + 1, E_5); _ -> lists:nth(2 + 1, E_5) end end) - (case erlang:is_map(E_5) of true -> maps:get(3, E_5, nil); _ -> case 3 < 0 of true -> lists:nth(erlang:length(E_5) + 3 + 1, E_5); _ -> lists:nth(3 + 1, E_5) end end)),
            Lvl_inner = maps:get("lvl", G_12, nil),
            case (((case erlang:is_map(Lvl_inner) of true -> maps:get(To_2, Lvl_inner, nil); _ -> case To_2 < 0 of true -> lists:nth(erlang:length(Lvl_inner) + To_2 + 1, Lvl_inner); _ -> lists:nth(To_2 + 1, Lvl_inner) end end) == 0) andalso (Residual >= Threshold)) of
        true -> Q_5 = lists:sublist(Q_4, Qe) ++ [To_2] ++ lists:nthtail(Qe + 1, Q_4),
            Qe_2 = (Qe + 1),
            Lvl_inner_2 = lists:sublist(Lvl_inner, To_2) ++ [((case erlang:is_map(Lvl_inner) of true -> maps:get(V_2, Lvl_inner, nil); _ -> case V_2 < 0 of true -> lists:nth(erlang:length(Lvl_inner) + V_2 + 1, Lvl_inner); _ -> lists:nth(V_2 + 1, Lvl_inner) end end) + 1)] ++ lists:nthtail(To_2 + 1, Lvl_inner),
            G_13 = maps:put("lvl", Lvl_inner_2, G_12),
            G_14 = G_13,
            Lvl_inner_3 = Lvl_inner_2,
            Q_6 = Q_5,
            Qe_3 = Qe_2;
        _ -> G_14 = G_12,
            Lvl_inner_3 = Lvl_inner,
            Q_6 = Q_4,
            Qe_3 = Qe
    end,
            J_2 = (J + 1),
            Fun_5_loop(Edges_2, Flow_2, G_14, I_8, J_2, L, Lvl_5, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold, V_2);
        _ -> {Edges_2, Flow_2, G_12, I_8, J, L, Lvl_5, Ptr_6, Q_4, Qe, Qi_2, Sink_2, Source, Threshold, V_2}
    end
end,
{Edges_2, Flow_2, G_14, I_8, J_2, L, Lvl_5, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold, V_2} = Fun_5(Edges_2, Flow_2, G_12, I_8, J, L, Lvl_5, Ptr_6, Q_4, Qe, Qi_2, Sink_2, Source, Threshold, V_2),
            Fun_6_loop(Flow_2, G_14, I_8, L, Lvl_5, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold);
        _ -> {Flow_2, G_12, I_8, L, Lvl_5, Ptr_6, Q_4, Qe, Qi, Sink_2, Source, Threshold}
    end
end,
{Flow_2, G_14, I_8, L, Lvl_5, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold} = Fun_6(Flow_2, G_12, I_8, L, Lvl_5, Ptr_6, Q_4, Qe, Qi, Sink_2, Source, Threshold),
                {P, G_14} = dfs(G_14, Source, Sink_2, 1000000000),
                Fun_7 = fun Fun_7_loop(G_14, Flow_2, G_14, I_8, L, Lvl_5, P, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold) ->
    case (P > 0) of
        true ->
            Flow_3 = (Flow_2 + P),
            {P_2, G_14_2} = dfs(G_14, Source, Sink_2, 1000000000),
            Fun_7_loop(G_14_2, Flow_3, G_14, I_8, L, Lvl_5, P_2, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold);
        _ -> {G_14, Flow_2, G_14, I_8, L, Lvl_5, P, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold}
    end
end,
{G_14_2, Flow_3, G_14, I_8, L, Lvl_5, P_2, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold} = Fun_7(G_14, Flow_2, G_14, I_8, L, Lvl_5, P, Ptr_6, Q_6, Qe_3, Qi_2, Sink_2, Source, Threshold),
                case ((case erlang:is_map(maps:get("lvl", G_14, nil)) of true -> maps:get(Sink_2, maps:get("lvl", G_14, nil), nil); _ -> case Sink_2 < 0 of true -> lists:nth(erlang:length(maps:get("lvl", G_14, nil)) + Sink_2 + 1, maps:get("lvl", G_14, nil)); _ -> lists:nth(Sink_2 + 1, maps:get("lvl", G_14, nil)) end end) == 0) of
        true -> throw({break, Flow_3, G_14, L, Sink_2, Source, Threshold});
        _ -> ok
    end,
                Fun_8_loop(Flow_3, G_14, L, Sink_2, Source, Threshold)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_8_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {Flow_2, G_9, L, Sink_2, Source, Threshold}
    end
end,
{Flow_3, G_14, L, Sink_2, Source, Threshold} = Fun_8(Flow_2, G_9, L, Sink_2, Source, Threshold),
                L_2 = (L + 1),
                Fun_9_loop(Flow_3, G_14, L_2, Sink_2, Source)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_9_loop(C0, C1, C2, C3, C4);
                {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4}
            end;
        _ -> {Flow_2, G_9, L, Sink_2, Source}
    end
end,
{Flow_3, G_14, L_2, Sink_2, Source} = Fun_9(Flow_2, G_9, L, Sink_2, Source),
        Flow_3
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('INF', 1000000000),
    erlang:put('graph', new_dinic(10)),
    erlang:put('source', 0),
    erlang:put('sink', 9),
    erlang:put('v', 1),
    Fun_10 = fun Fun_10_loop() ->
    case (erlang:get('v') < 5) of
        true ->
            {_, Graph} = add_edge(erlang:get('graph'), 0, erlang:get('v'), 1, 0),
            erlang:put('graph', Graph),
            erlang:put('v', (erlang:get('v') + 1)),
            Fun_10_loop();
        _ -> {}
    end
end,
{} = Fun_10(),
    erlang:put('v', 5),
    Fun_11 = fun Fun_11_loop() ->
    case (erlang:get('v') < 9) of
        true ->
            {_, Graph_2} = add_edge(erlang:get('graph'), erlang:get('v'), 9, 1, 0),
            erlang:put('graph', Graph_2),
            erlang:put('v', (erlang:get('v') + 1)),
            Fun_11_loop();
        _ -> {}
    end
end,
{} = Fun_11(),
    erlang:put('v', 1),
    Fun_12 = fun Fun_12_loop() ->
    case (erlang:get('v') < 5) of
        true ->
            {_, Graph_3} = add_edge(erlang:get('graph'), erlang:get('v'), (erlang:get('v') + 4), 1, 0),
            erlang:put('graph', Graph_3),
            erlang:put('v', (erlang:get('v') + 1)),
            Fun_12_loop();
        _ -> {}
    end
end,
{} = Fun_12(),
    io:format("~ts~n", [mochi_str(max_flow(erlang:get('graph'), 0, 9))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
