#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, get_min_index/1, remove_at/2, pass_and_relaxation/9, bidirectional_dij/4]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

get_min_index(Q) ->
    try
        Idx = 0,
        I = 1,
        Fun = fun Fun_loop(I, Idx, Q) ->
    case (I < erlang:length(Q)) of
        true ->
            case (maps:get("cost", (case erlang:is_map(Q) of true -> maps:get(I, Q, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Q) + I + 1, Q); _ -> lists:nth(I + 1, Q) end end), nil) < maps:get("cost", (case erlang:is_map(Q) of true -> maps:get(Idx, Q, nil); _ -> case Idx < 0 of true -> lists:nth(erlang:length(Q) + Idx + 1, Q); _ -> lists:nth(Idx + 1, Q) end end), nil)) of
        true -> Idx_2 = I,
            Idx_3 = Idx_2;
        _ -> Idx_3 = Idx
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, Idx_3, Q);
        _ -> {I, Idx, Q}
    end
end,
{I_2, Idx_3, Q} = Fun(I, Idx, Q),
        Idx_3
    catch {return, Ret} -> Ret end.

remove_at(Q_2, Idx_4) ->
    try
        Res = [],
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Idx_4, Q_2, Res) ->
    case (I_3 < erlang:length(Q_2)) of
        true ->
            case (I_3 /= Idx_4) of
        true -> Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(case erlang:is_map(Q_2) of true -> maps:get(I_3, Q_2, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Q_2) + I_3 + 1, Q_2); _ -> lists:nth(I_3 + 1, Q_2) end end)]),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Idx_4, Q_2, Res_3);
        _ -> {I_3, Idx_4, Q_2, Res}
    end
end,
{I_4, Idx_4, Q_2, Res_3} = Fun_2(I_3, Idx_4, Q_2, Res),
        Res_3
    catch {return, Ret} -> Ret end.

pass_and_relaxation(Graph, V, Visited_forward, Visited_backward, Cst_fwd, Cst_bwd, Queue, Parent, Shortest_distance) ->
    try
        Q_3 = Queue,
        Sd = Shortest_distance,
        Fun_3 = fun Fun_3_loop(List, Cst_bwd, Cst_fwd, Graph, Parent, Q_3, Queue, Sd, Shortest_distance, V, Visited_backward, Visited_forward) ->
    case List of
        [] -> {Cst_bwd, Cst_fwd, Graph, Parent, Q_3, Queue, Sd, Shortest_distance, V, Visited_backward, Visited_forward};
        [E|E_rest] ->
        try
            Nxt = maps:get("to", E, nil),
            D = maps:get("cost", E, nil),
            case maps:is_key(Nxt, Visited_forward) of
        true -> throw({continue, Cst_bwd, Cst_fwd, Graph, Parent, Q_3, Queue, Sd, Shortest_distance, V, Visited_backward, Visited_forward});
        _ -> ok
    end,
            Old_cost = (case maps:is_key(Nxt, Cst_fwd) of
    true -> maps:get(Nxt, Cst_fwd, nil);
    _ -> 2147483647
end),
            New_cost = (maps:get(V, Cst_fwd, nil) + D),
            case (New_cost < Old_cost) of
        true -> Q_4 = lists:append((case Q_3 of nil -> []; _ -> Q_3 end), [#{"node" => Nxt, "cost" => New_cost}]),
            Cst_fwd_2 = maps:put(Nxt, New_cost, Cst_fwd),
            Parent_2 = maps:put(Nxt, V, Parent),
            Cst_fwd_3 = Cst_fwd_2,
            Parent_3 = Parent_2,
            Q_5 = Q_4;
        _ -> Cst_fwd_3 = Cst_fwd,
            Parent_3 = Parent,
            Q_5 = Q_3
    end,
            case maps:is_key(Nxt, Visited_backward) of
        true -> Alt = ((maps:get(V, Cst_fwd_3, nil) + D) + maps:get(Nxt, Cst_bwd, nil)),
            case (Alt < Sd) of
        true -> Sd_2 = Alt,
            Sd_3 = Sd_2;
        _ -> Sd_3 = Sd
    end,
            Alt_2 = Alt,
            Sd_4 = Sd_3;
        _ -> Alt_2 = nil,
            Sd_4 = Sd
    end,
            Fun_3_loop(E_rest, Cst_bwd, Cst_fwd_3, Graph, Parent_3, Q_5, Queue, Sd_4, Shortest_distance, V, Visited_backward, Visited_forward)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_3_loop(E_rest, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
            {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10};
            break -> {Cst_bwd, Cst_fwd, Graph, Parent, Q_3, Queue, Sd, Shortest_distance, V, Visited_backward, Visited_forward}
        end;
        _ -> {Cst_bwd, Cst_fwd, Graph, Parent, Q_3, Queue, Sd, Shortest_distance, V, Visited_backward, Visited_forward}
    end
end,
{Cst_bwd, Cst_fwd_3, Graph, Parent_3, Q_5, Queue, Sd_4, Shortest_distance, V, Visited_backward, Visited_forward} = Fun_3(maps:get(V, Graph, nil), Cst_bwd, Cst_fwd, Graph, Parent, Q_3, Queue, Sd, Shortest_distance, V, Visited_backward, Visited_forward),
        #{"queue" => Q_5, "dist" => Sd_4}
    catch {return, Ret} -> Ret end.

bidirectional_dij(Source, Destination, Graph_forward, Graph_backward) ->
    try
        Shortest_path_distance = -1,
        Visited_forward_2 = #{},
        Visited_backward_2 = #{},
        Cst_fwd_4 = #{},
        Cst_fwd_5 = maps:put(Source, 0, Cst_fwd_4),
        Cst_bwd_2 = #{},
        Cst_bwd_3 = maps:put(Destination, 0, Cst_bwd_2),
        Parent_forward = #{},
        Parent_forward_2 = maps:put(Source, "", Parent_forward),
        Parent_backward = #{},
        Parent_backward_2 = maps:put(Destination, "", Parent_backward),
        Queue_forward = [],
        Queue_forward_2 = lists:append((case Queue_forward of nil -> []; _ -> Queue_forward end), [#{"node" => Source, "cost" => 0}]),
        Queue_backward = [],
        Queue_backward_2 = lists:append((case Queue_backward of nil -> []; _ -> Queue_backward end), [#{"node" => Destination, "cost" => 0}]),
        Shortest_distance_2 = 2147483647,
        case (Source == Destination) of
        true -> throw({return, 0});
        _ -> ok
    end,
        Fun_4 = fun Fun_4_loop(Cst_bwd_3, Cst_fwd_5, Destination, Graph_backward, Graph_forward, Parent_backward_2, Parent_forward_2, Queue_backward_2, Queue_forward_2, Shortest_distance_2, Shortest_path_distance, Source, Visited_backward_2, Visited_forward_2) ->
    case ((erlang:length(Queue_forward_2) > 0) andalso (erlang:length(Queue_backward_2) > 0)) of
        true ->
            try
                Idx_f = get_min_index(Queue_forward_2),
                Item_f = (case erlang:is_map(Queue_forward_2) of true -> maps:get(Idx_f, Queue_forward_2, nil); _ -> case Idx_f < 0 of true -> lists:nth(erlang:length(Queue_forward_2) + Idx_f + 1, Queue_forward_2); _ -> lists:nth(Idx_f + 1, Queue_forward_2) end end),
                Queue_forward_3 = remove_at(Queue_forward_2, Idx_f),
                V_fwd = maps:get("node", Item_f, nil),
                Visited_forward_3 = maps:put(V_fwd, true, Visited_forward_2),
                Idx_b = get_min_index(Queue_backward_2),
                Item_b = (case erlang:is_map(Queue_backward_2) of true -> maps:get(Idx_b, Queue_backward_2, nil); _ -> case Idx_b < 0 of true -> lists:nth(erlang:length(Queue_backward_2) + Idx_b + 1, Queue_backward_2); _ -> lists:nth(Idx_b + 1, Queue_backward_2) end end),
                Queue_backward_3 = remove_at(Queue_backward_2, Idx_b),
                V_bwd = maps:get("node", Item_b, nil),
                Visited_backward_3 = maps:put(V_bwd, true, Visited_backward_2),
                Res_f = pass_and_relaxation(Graph_forward, V_fwd, Visited_forward_3, Visited_backward_3, Cst_fwd_5, Cst_bwd_3, Queue_forward_3, Parent_forward_2, Shortest_distance_2),
                Queue_forward_4 = maps:get("queue", Res_f, nil),
                Shortest_distance_3 = maps:get("dist", Res_f, nil),
                Res_b = pass_and_relaxation(Graph_backward, V_bwd, Visited_backward_3, Visited_forward_3, Cst_bwd_3, Cst_fwd_5, Queue_backward_3, Parent_backward_2, Shortest_distance_3),
                Queue_backward_4 = maps:get("queue", Res_b, nil),
                Shortest_distance_4 = maps:get("dist", Res_b, nil),
                case ((maps:get(V_fwd, Cst_fwd_5, nil) + maps:get(V_bwd, Cst_bwd_3, nil)) >= Shortest_distance_4) of
        true -> throw({break, Cst_bwd_3, Cst_fwd_5, Destination, Graph_backward, Graph_forward, Parent_backward_2, Parent_forward_2, Queue_backward_4, Queue_forward_4, Shortest_distance_4, Shortest_path_distance, Source, Visited_backward_3, Visited_forward_3});
        _ -> ok
    end,
                Fun_4_loop(Cst_bwd_3, Cst_fwd_5, Destination, Graph_backward, Graph_forward, Parent_backward_2, Parent_forward_2, Queue_backward_4, Queue_forward_4, Shortest_distance_4, Shortest_path_distance, Source, Visited_backward_3, Visited_forward_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13} -> Fun_4_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13}
            end;
        _ -> {Cst_bwd_3, Cst_fwd_5, Destination, Graph_backward, Graph_forward, Parent_backward_2, Parent_forward_2, Queue_backward_2, Queue_forward_2, Shortest_distance_2, Shortest_path_distance, Source, Visited_backward_2, Visited_forward_2}
    end
end,
{Cst_bwd_3, Cst_fwd_5, Destination, Graph_backward, Graph_forward, Parent_backward_2, Parent_forward_2, Queue_backward_4, Queue_forward_4, Shortest_distance_4, Shortest_path_distance, Source, Visited_backward_3, Visited_forward_3} = Fun_4(Cst_bwd_3, Cst_fwd_5, Destination, Graph_backward, Graph_forward, Parent_backward_2, Parent_forward_2, Queue_backward_2, Queue_forward_2, Shortest_distance_2, Shortest_path_distance, Source, Visited_backward_2, Visited_forward_2),
        case (Shortest_distance_4 /= 2147483647) of
        true -> Shortest_path_distance_2 = Shortest_distance_4,
            Shortest_path_distance_3 = Shortest_path_distance_2;
        _ -> Shortest_path_distance_3 = Shortest_path_distance
    end,
        Shortest_path_distance_3
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('graph_fwd', #{"B" => [#{"to" => "C", "cost" => 1}], "C" => [#{"to" => "D", "cost" => 1}], "D" => [#{"to" => "F", "cost" => 1}], "E" => [#{"to" => "B", "cost" => 1}, #{"to" => "G", "cost" => 2}], "F" => [], "G" => [#{"to" => "F", "cost" => 1}]}),
    erlang:put('graph_bwd', #{"B" => [#{"to" => "E", "cost" => 1}], "C" => [#{"to" => "B", "cost" => 1}], "D" => [#{"to" => "C", "cost" => 1}], "F" => [#{"to" => "D", "cost" => 1}, #{"to" => "G", "cost" => 1}], "E" => [], "G" => [#{"to" => "E", "cost" => 2}]}),
    io:format("~ts~n", [mochi_str(bidirectional_dij("E", "F", erlang:get('graph_fwd'), erlang:get('graph_bwd')))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
