#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_exported_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, pos_equal/2, pos_key/1, sqrtapprox/1, consistent_heuristic/2, iabs/1, heuristic_1/2, heuristic_2/2, heuristic/3, key_fn/4, valid/1, in_blocks/1, pq_put/3, pq_minkey/1, pq_pop_min/1, pq_remove/2, reconstruct/3, neighbours/1, multi_a_star/3]).

% Generated by Mochi transpiler v0.10.66 (8fdd1fe3d6)


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


toi(V) ->
    mochi_to_int(V).


mochi_to_float(V) ->
    case erlang:is_float(V) of
        true -> V;
        _ -> float(V)
    end.


to_float(V) ->
    mochi_to_float(V).


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    erlang:float_to_list(V, [short]);
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


-compile({nowarn_unused_function, [mochi_safe_mul/2, mochi_safe_div/2]}).
mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.

pos_equal(A, B) ->
    try
        ((maps:get("x", A, nil) == maps:get("x", B, nil)) andalso (maps:get("y", A, nil) == maps:get("y", B, nil)))
    catch {return, RetCatch} -> RetCatch end.

pos_key(P) ->
    try
        ((mochi_str(maps:get("x", P, nil)) ++ ",") ++ mochi_str(maps:get("y", P, nil)))
    catch {return, RetCatch} -> RetCatch end.

sqrtapprox(X) ->
    try
        case (X =< 0.0) of
        true -> throw({return, 0.0});
        _ -> ok
    end,
        Guess = X,
        I = 0,
        Fun = fun Fun_loop(Guess, I, X) ->
    case (I < 10) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X, Guess)), 2.0),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X);
        _ -> {Guess, I, X}
    end
end,
{Guess_2, I_2, X} = Fun(Guess, I, X),
        Guess_2
    catch {return, RetCatch} -> RetCatch end.

consistent_heuristic(P_2, Goal) ->
    try
        Dx = float((maps:get("x", P_2, nil) - maps:get("x", Goal, nil))),
        Dy = float((maps:get("y", P_2, nil) - maps:get("y", Goal, nil))),
        sqrtapprox((mochi_safe_mul(Dx, Dx) + mochi_safe_mul(Dy, Dy)))
    catch {return, RetCatch} -> RetCatch end.

iabs(X_2) ->
    try
        (case (X_2 < 0) of
    true -> -X_2;
    _ -> X_2
end)
    catch {return, RetCatch} -> RetCatch end.

heuristic_1(P_3, Goal_2) ->
    try
        float((iabs((maps:get("x", P_3, nil) - maps:get("x", Goal_2, nil))) + iabs((maps:get("y", P_3, nil) - maps:get("y", Goal_2, nil)))))
    catch {return, RetCatch} -> RetCatch end.

heuristic_2(P_4, Goal_3) ->
    try
        H = consistent_heuristic(P_4, Goal_3),
        mochi_safe_div(H, float(erlang:get('t')))
    catch {return, RetCatch} -> RetCatch end.

heuristic(I_3, P_5, Goal_4) ->
    try
        case (I_3 == 0) of
        true -> throw({return, consistent_heuristic(P_5, Goal_4)});
        _ -> ok
    end,
        case (I_3 == 1) of
        true -> throw({return, heuristic_1(P_5, Goal_4)});
        _ -> ok
    end,
        heuristic_2(P_5, Goal_4)
    catch {return, RetCatch} -> RetCatch end.

key_fn(Start, I_4, Goal_5, G_func) ->
    try
        G = maps:get(pos_key(Start), G_func, nil),
        (G + mochi_safe_mul(1.0, heuristic(I_4, Start, Goal_5)))
    catch {return, RetCatch} -> RetCatch end.

valid(P_6) ->
    try
        case ((maps:get("x", P_6, nil) < 0) orelse (maps:get("x", P_6, nil) > (20 - 1))) of
        true -> throw({return, false});
        _ -> ok
    end,
        case ((maps:get("y", P_6, nil) < 0) orelse (maps:get("y", P_6, nil) > (20 - 1))) of
        true -> throw({return, false});
        _ -> ok
    end,
        true
    catch {return, RetCatch} -> RetCatch end.

in_blocks(P_7) ->
    try
        I_5 = 0,
        Fun_2 = fun Fun_2_loop(I_5, P_7) ->
    case (I_5 < erlang:length(erlang:get('blocks'))) of
        true ->
            case pos_equal((case erlang:is_map(erlang:get('blocks')) of true -> maps:get(I_5, erlang:get('blocks'), nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(erlang:get('blocks')) + I_5 + 1, erlang:get('blocks')); _ -> mochi_nth(I_5 + 1, erlang:get('blocks')) end end), P_7) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_6 = (I_5 + 1),
            Fun_2_loop(I_6, P_7);
        _ -> {I_5, P_7}
    end
end,
{I_6, P_7} = Fun_2(I_5, P_7),
        false
    catch {return, RetCatch} -> RetCatch end.

pq_put(Pq, Node, Pri) ->
    try
        Updated = false,
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(I_7, Node, Pq, Pri, Updated) ->
    case (I_7 < erlang:length(Pq)) of
        true ->
            case pos_equal(maps:get("pos", (case erlang:is_map(Pq) of true -> maps:get(I_7, Pq, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Pq) + I_7 + 1, Pq); _ -> mochi_nth(I_7 + 1, Pq) end end), nil), Node) of
        true -> case (Pri < maps:get("pri", (case erlang:is_map(Pq) of true -> maps:get(I_7, Pq, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Pq) + I_7 + 1, Pq); _ -> mochi_nth(I_7 + 1, Pq) end end), nil)) of
        true -> Pq_2 = lists:sublist(Pq, I_7) ++ [#{"pos" => Node, "pri" => Pri}] ++ lists:nthtail(I_7 + 1, Pq),
            Pq_3 = Pq_2;
        _ -> Pq_3 = Pq
    end,
            Updated_2 = true,
            Pq_4 = Pq_3,
            Updated_3 = Updated_2;
        _ -> Pq_4 = Pq,
            Updated_3 = Updated
    end,
            I_8 = (I_7 + 1),
            Fun_3_loop(I_8, Node, Pq_4, Pri, Updated_3);
        _ -> {I_7, Node, Pq, Pri, Updated}
    end
end,
{I_8, Node, Pq_4, Pri, Updated_3} = Fun_3(I_7, Node, Pq, Pri, Updated),
        case mochi_not(Updated_3) of
        true -> Pq_5 = lists:append((case Pq_4 of nil -> []; _ -> Pq_4 end), [#{"pos" => Node, "pri" => Pri}]),
            Pq_6 = Pq_5;
        _ -> Pq_6 = Pq_4
    end,
        Pq_6
    catch {return, RetCatch} -> RetCatch end.

pq_minkey(Pq_7) ->
    try
        case (erlang:length(Pq_7) == 0) of
        true -> throw({return, 1000000000.0});
        _ -> ok
    end,
        First = (case erlang:is_map(Pq_7) of true -> maps:get(0, Pq_7, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Pq_7) + 0 + 1, Pq_7); _ -> mochi_nth(0 + 1, Pq_7) end end),
        M = maps:get("pri", First, nil),
        I_9 = 1,
        Fun_4 = fun Fun_4_loop(First, I_9, M, Pq_7) ->
    case (I_9 < erlang:length(Pq_7)) of
        true ->
            Item = (case erlang:is_map(Pq_7) of true -> maps:get(I_9, Pq_7, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Pq_7) + I_9 + 1, Pq_7); _ -> mochi_nth(I_9 + 1, Pq_7) end end),
            case (maps:get("pri", Item, nil) < M) of
        true -> M_2 = maps:get("pri", Item, nil),
            M_3 = M_2;
        _ -> M_3 = M
    end,
            I_10 = (I_9 + 1),
            Fun_4_loop(First, I_10, M_3, Pq_7);
        _ -> {First, I_9, M, Pq_7}
    end
end,
{First, I_10, M_3, Pq_7} = Fun_4(First, I_9, M, Pq_7),
        M_3
    catch {return, RetCatch} -> RetCatch end.

pq_pop_min(Pq_8) ->
    try
        Best = (case erlang:is_map(Pq_8) of true -> maps:get(0, Pq_8, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Pq_8) + 0 + 1, Pq_8); _ -> mochi_nth(0 + 1, Pq_8) end end),
        Idx = 0,
        I_11 = 1,
        Fun_5 = fun Fun_5_loop(Best, I_11, Idx, Pq_8) ->
    case (I_11 < erlang:length(Pq_8)) of
        true ->
            case (maps:get("pri", (case erlang:is_map(Pq_8) of true -> maps:get(I_11, Pq_8, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Pq_8) + I_11 + 1, Pq_8); _ -> mochi_nth(I_11 + 1, Pq_8) end end), nil) < maps:get("pri", Best, nil)) of
        true -> Best_2 = (case erlang:is_map(Pq_8) of true -> maps:get(I_11, Pq_8, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Pq_8) + I_11 + 1, Pq_8); _ -> mochi_nth(I_11 + 1, Pq_8) end end),
            Idx_2 = I_11,
            Best_3 = Best_2,
            Idx_3 = Idx_2;
        _ -> Best_3 = Best,
            Idx_3 = Idx
    end,
            I_12 = (I_11 + 1),
            Fun_5_loop(Best_3, I_12, Idx_3, Pq_8);
        _ -> {Best, I_11, Idx, Pq_8}
    end
end,
{Best_3, I_12, Idx_3, Pq_8} = Fun_5(Best, I_11, Idx, Pq_8),
        New_pq = [],
        I_13 = 0,
        Fun_6 = fun Fun_6_loop(Best_3, I_13, Idx_3, New_pq, Pq_8) ->
    case (I_13 < erlang:length(Pq_8)) of
        true ->
            case (I_13 /= Idx_3) of
        true -> New_pq_2 = lists:append((case New_pq of nil -> []; _ -> New_pq end), [(case erlang:is_map(Pq_8) of true -> maps:get(I_13, Pq_8, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(Pq_8) + I_13 + 1, Pq_8); _ -> mochi_nth(I_13 + 1, Pq_8) end end)]),
            New_pq_3 = New_pq_2;
        _ -> New_pq_3 = New_pq
    end,
            I_14 = (I_13 + 1),
            Fun_6_loop(Best_3, I_14, Idx_3, New_pq_3, Pq_8);
        _ -> {Best_3, I_13, Idx_3, New_pq, Pq_8}
    end
end,
{Best_3, I_14, Idx_3, New_pq_3, Pq_8} = Fun_6(Best_3, I_13, Idx_3, New_pq, Pq_8),
        #{"pq" => New_pq_3, "node" => Best_3}
    catch {return, RetCatch} -> RetCatch end.

pq_remove(Pq_9, Node_2) ->
    try
        New_pq_4 = [],
        I_15 = 0,
        Fun_7 = fun Fun_7_loop(I_15, New_pq_4, Node_2, Pq_9) ->
    case (I_15 < erlang:length(Pq_9)) of
        true ->
            case mochi_not(pos_equal(maps:get("pos", (case erlang:is_map(Pq_9) of true -> maps:get(I_15, Pq_9, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Pq_9) + I_15 + 1, Pq_9); _ -> mochi_nth(I_15 + 1, Pq_9) end end), nil), Node_2)) of
        true -> New_pq_5 = lists:append((case New_pq_4 of nil -> []; _ -> New_pq_4 end), [(case erlang:is_map(Pq_9) of true -> maps:get(I_15, Pq_9, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Pq_9) + I_15 + 1, Pq_9); _ -> mochi_nth(I_15 + 1, Pq_9) end end)]),
            New_pq_6 = New_pq_5;
        _ -> New_pq_6 = New_pq_4
    end,
            I_16 = (I_15 + 1),
            Fun_7_loop(I_16, New_pq_6, Node_2, Pq_9);
        _ -> {I_15, New_pq_4, Node_2, Pq_9}
    end
end,
{I_16, New_pq_6, Node_2, Pq_9} = Fun_7(I_15, New_pq_4, Node_2, Pq_9),
        New_pq_6
    catch {return, RetCatch} -> RetCatch end.

reconstruct(Back_pointer, Goal_6, Start_2) ->
    try
        Path = [],
        Current = Goal_6,
        Key = pos_key(Current),
        Path_2 = lists:append((case Path of nil -> []; _ -> Path end), [Current]),
        Fun_8 = fun Fun_8_loop(Back_pointer, Current, Goal_6, Key, Path_2, Start_2) ->
    case mochi_not(pos_equal(Current, Start_2)) of
        true ->
            Current_2 = maps:get(Key, Back_pointer, nil),
            Key_2 = pos_key(Current_2),
            Path_3 = lists:append((case Path_2 of nil -> []; _ -> Path_2 end), [Current_2]),
            Fun_8_loop(Back_pointer, Current_2, Goal_6, Key_2, Path_3, Start_2);
        _ -> {Back_pointer, Current, Goal_6, Key, Path_2, Start_2}
    end
end,
{Back_pointer, Current_2, Goal_6, Key_2, Path_3, Start_2} = Fun_8(Back_pointer, Current, Goal_6, Key, Path_2, Start_2),
        Rev = [],
        I_17 = (erlang:length(Path_3) - 1),
        Fun_9 = fun Fun_9_loop(Back_pointer, Current_2, Goal_6, I_17, Key_2, Path_3, Rev, Start_2) ->
    case (I_17 >= 0) of
        true ->
            Rev_2 = lists:append((case Rev of nil -> []; _ -> Rev end), [(case erlang:is_map(Path_3) of true -> maps:get(I_17, Path_3, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Path_3) + I_17 + 1, Path_3); _ -> mochi_nth(I_17 + 1, Path_3) end end)]),
            I_18 = (I_17 - 1),
            Fun_9_loop(Back_pointer, Current_2, Goal_6, I_18, Key_2, Path_3, Rev_2, Start_2);
        _ -> {Back_pointer, Current_2, Goal_6, I_17, Key_2, Path_3, Rev, Start_2}
    end
end,
{Back_pointer, Current_2, Goal_6, I_18, Key_2, Path_3, Rev_2, Start_2} = Fun_9(Back_pointer, Current_2, Goal_6, I_17, Key_2, Path_3, Rev, Start_2),
        Rev_2
    catch {return, RetCatch} -> RetCatch end.

neighbours(P_8) ->
    try
        Left = #{"x" => (maps:get("x", P_8, nil) - 1), "y" => maps:get("y", P_8, nil)},
        Right = #{"x" => (maps:get("x", P_8, nil) + 1), "y" => maps:get("y", P_8, nil)},
        Up = #{"x" => maps:get("x", P_8, nil), "y" => (maps:get("y", P_8, nil) + 1)},
        Down = #{"x" => maps:get("x", P_8, nil), "y" => (maps:get("y", P_8, nil) - 1)},
        [Left, Right, Up, Down]
    catch {return, RetCatch} -> RetCatch end.

multi_a_star(Start_3, Goal_7, N_heuristic) ->
    try
        G_function = #{},
        Back_pointer_2 = #{},
        Visited = #{},
        Open_list = [],
        G_function_2 = maps:put(pos_key(Start_3), 0.0, G_function),
        G_function_3 = maps:put(pos_key(Goal_7), 1000000000.0, G_function_2),
        Back_pointer_3 = maps:put(pos_key(Start_3), #{"x" => -1, "y" => -1}, Back_pointer_2),
        Back_pointer_4 = maps:put(pos_key(Goal_7), #{"x" => -1, "y" => -1}, Back_pointer_3),
        Visited_2 = maps:put(pos_key(Start_3), true, Visited),
        I_19 = 0,
        Fun_10 = fun Fun_10_loop(Back_pointer_4, G_function_3, Goal_7, I_19, N_heuristic, Open_list, Start_3, Visited_2) ->
    case (I_19 < erlang:get('n_heuristic')) of
        true ->
            Open_list_2 = lists:append((case Open_list of nil -> []; _ -> Open_list end), [[]]),
            Pri_2 = key_fn(Start_3, I_19, Goal_7, G_function_3),
            Open_list_3 = lists:sublist(Open_list_2, I_19) ++ [pq_put((case erlang:is_map(Open_list_2) of true -> maps:get(I_19, Open_list_2, nil); _ -> case I_19 < 0 of true -> mochi_nth(erlang:length(Open_list_2) + I_19 + 1, Open_list_2); _ -> mochi_nth(I_19 + 1, Open_list_2) end end), Start_3, Pri_2)] ++ lists:nthtail(I_19 + 1, Open_list_2),
            I_20 = (I_19 + 1),
            Fun_10_loop(Back_pointer_4, G_function_3, Goal_7, I_20, N_heuristic, Open_list_3, Start_3, Visited_2);
        _ -> {Back_pointer_4, G_function_3, Goal_7, I_19, N_heuristic, Open_list, Start_3, Visited_2}
    end
end,
{Back_pointer_4, G_function_3, Goal_7, I_20, N_heuristic, Open_list_3, Start_3, Visited_2} = Fun_10(Back_pointer_4, G_function_3, Goal_7, I_19, N_heuristic, Open_list, Start_3, Visited_2),
        Fun_19 = fun Fun_19_loop(Back_pointer_4, G_function_3, Goal_7, I_20, N_heuristic, Open_list_3, Start_3, Visited_2) ->
    case (pq_minkey((case erlang:is_map(Open_list_3) of true -> maps:get(0, Open_list_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Open_list_3) + 0 + 1, Open_list_3); _ -> mochi_nth(0 + 1, Open_list_3) end end)) < 1000000000.0) of
        true ->
            try
                Chosen = 0,
                I_21 = 1,
                Fun_11 = fun Fun_11_loop(Back_pointer_4, Chosen, G_function_3, Goal_7, I_21, N_heuristic, Open_list_3, Start_3, Visited_2) ->
    case (I_21 < erlang:get('n_heuristic')) of
        true ->
            try
                case (pq_minkey((case erlang:is_map(Open_list_3) of true -> maps:get(I_21, Open_list_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Open_list_3) + I_21 + 1, Open_list_3); _ -> mochi_nth(I_21 + 1, Open_list_3) end end)) =< mochi_safe_mul(1.0, pq_minkey((case erlang:is_map(Open_list_3) of true -> maps:get(0, Open_list_3, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Open_list_3) + 0 + 1, Open_list_3); _ -> mochi_nth(0 + 1, Open_list_3) end end)))) of
        true -> Chosen_2 = I_21,
            throw({break, Back_pointer_4, Chosen_2, G_function_3, Goal_7, I_21, N_heuristic, Open_list_3, Start_3, Visited_2}),
            Chosen_3 = Chosen_2;
        _ -> Chosen_3 = Chosen
    end,
                I_22 = (I_21 + 1),
                Fun_11_loop(Back_pointer_4, Chosen_3, G_function_3, Goal_7, I_22, N_heuristic, Open_list_3, Start_3, Visited_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_11_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8}
            end;
        _ -> {Back_pointer_4, Chosen, G_function_3, Goal_7, I_21, N_heuristic, Open_list_3, Start_3, Visited_2}
    end
end,
{Back_pointer_4, Chosen_3, G_function_3, Goal_7, I_22, N_heuristic, Open_list_3, Start_3, Visited_2} = Fun_11(Back_pointer_4, Chosen, G_function_3, Goal_7, I_21, N_heuristic, Open_list_3, Start_3, Visited_2),
                case (Chosen_3 /= 0) of
        true -> erlang:put('t', (erlang:get('t') + 1));
        _ -> ok
    end,
                Pair = pq_pop_min((case erlang:is_map(Open_list_3) of true -> maps:get(Chosen_3, Open_list_3, nil); _ -> case Chosen_3 < 0 of true -> mochi_nth(erlang:length(Open_list_3) + Chosen_3 + 1, Open_list_3); _ -> mochi_nth(Chosen_3 + 1, Open_list_3) end end)),
                Open_list_4 = lists:sublist(Open_list_3, Chosen_3) ++ [maps:get("pq", Pair, nil)] ++ lists:nthtail(Chosen_3 + 1, Open_list_3),
                Current_3 = maps:get("node", Pair, nil),
                I_23 = 0,
                Fun_12 = fun Fun_12_loop(Back_pointer_4, Chosen_3, Current_3, G_function_3, Goal_7, I_23, N_heuristic, Open_list_4, Pair, Start_3, Visited_2) ->
    case (I_23 < erlang:get('n_heuristic')) of
        true ->
            case (I_23 /= Chosen_3) of
        true -> Open_list_5 = lists:sublist(Open_list_4, I_23) ++ [pq_remove((case erlang:is_map(Open_list_4) of true -> maps:get(I_23, Open_list_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(Open_list_4) + I_23 + 1, Open_list_4); _ -> mochi_nth(I_23 + 1, Open_list_4) end end), maps:get("pos", Current_3, nil))] ++ lists:nthtail(I_23 + 1, Open_list_4),
            Open_list_6 = Open_list_5;
        _ -> Open_list_6 = Open_list_4
    end,
            I_24 = (I_23 + 1),
            Fun_12_loop(Back_pointer_4, Chosen_3, Current_3, G_function_3, Goal_7, I_24, N_heuristic, Open_list_6, Pair, Start_3, Visited_2);
        _ -> {Back_pointer_4, Chosen_3, Current_3, G_function_3, Goal_7, I_23, N_heuristic, Open_list_4, Pair, Start_3, Visited_2}
    end
end,
{Back_pointer_4, Chosen_3, Current_3, G_function_3, Goal_7, I_24, N_heuristic, Open_list_6, Pair, Start_3, Visited_2} = Fun_12(Back_pointer_4, Chosen_3, Current_3, G_function_3, Goal_7, I_23, N_heuristic, Open_list_4, Pair, Start_3, Visited_2),
                Ckey = pos_key(maps:get("pos", Current_3, nil)),
                case maps:is_key(Ckey, Visited_2) of
        true -> throw({continue, Back_pointer_4, G_function_3, Goal_7, I_24, N_heuristic, Open_list_6, Start_3, Visited_2});
        _ -> ok
    end,
                Visited_3 = maps:put(Ckey, true, Visited_2),
                case pos_equal(maps:get("pos", Current_3, nil), Goal_7) of
        true -> Path_4 = reconstruct(Back_pointer_4, Goal_7, Start_3),
            J = 0,
            Fun_13 = fun Fun_13_loop(Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J, N_heuristic, Open_list_6, Pair, Path_4, Start_3, Visited_3) ->
    case (J < erlang:length(Path_4)) of
        true ->
            P_9 = (case erlang:is_map(Path_4) of true -> maps:get(J, Path_4, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Path_4) + J + 1, Path_4); _ -> mochi_nth(J + 1, Path_4) end end),
            io:format("~ts~n", [mochi_repr((((("(" ++ mochi_str(maps:get("x", P_9, nil))) ++ ",") ++ mochi_str(maps:get("y", P_9, nil))) ++ ")"))]),
            J_2 = (J + 1),
            Fun_13_loop(Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J_2, N_heuristic, Open_list_6, Pair, Path_4, Start_3, Visited_3);
        _ -> {Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J, N_heuristic, Open_list_6, Pair, Path_4, Start_3, Visited_3}
    end
end,
{Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J_2, N_heuristic, Open_list_6, Pair, Path_4, Start_3, Visited_3} = Fun_13(Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J, N_heuristic, Open_list_6, Pair, Path_4, Start_3, Visited_3),
            throw({return, nil}),
            Fun_14 = Fun_13,
            J_3 = J_2,
            Path_5 = Path_4;
        _ -> Fun_14 = Fun_12,
            J_3 = nil,
            Path_5 = nil
    end,
                Neighs = neighbours(maps:get("pos", Current_3, nil)),
                K = 0,
                Fun_18 = fun Fun_18_loop(Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J_3, K, N_heuristic, Neighs, Open_list_6, Pair, Path_5, Start_3, Visited_3) ->
    case (K < erlang:length(Neighs)) of
        true ->
            Nb = (case erlang:is_map(Neighs) of true -> maps:get(K, Neighs, nil); _ -> case K < 0 of true -> mochi_nth(erlang:length(Neighs) + K + 1, Neighs); _ -> mochi_nth(K + 1, Neighs) end end),
            case (valid(Nb) andalso (in_blocks(Nb) == false)) of
        true -> Nkey = pos_key(Nb),
            Tentative = (maps:get(Ckey, G_function_3, nil) + 1.0),
            case (mochi_not(maps:is_key(Nkey, G_function_3)) orelse (Tentative < maps:get(Nkey, G_function_3, nil))) of
        true -> G_function_4 = maps:put(Nkey, Tentative, G_function_3),
            Back_pointer_5 = maps:put(Nkey, maps:get("pos", Current_3, nil), Back_pointer_4),
            I_25 = 0,
            Fun_15 = fun Fun_15_loop(Back_pointer_5, Chosen_3, Ckey, Current_3, G_function_4, Goal_7, I_25, J_3, K, N_heuristic, Nb, Neighs, Nkey, Open_list_6, Pair, Path_5, Start_3, Tentative, Visited_3) ->
    case (I_25 < erlang:get('n_heuristic')) of
        true ->
            Pri2 = (Tentative + mochi_safe_mul(1.0, heuristic(I_25, Nb, Goal_7))),
            Open_list_7 = lists:sublist(Open_list_6, I_25) ++ [pq_put((case erlang:is_map(Open_list_6) of true -> maps:get(I_25, Open_list_6, nil); _ -> case I_25 < 0 of true -> mochi_nth(erlang:length(Open_list_6) + I_25 + 1, Open_list_6); _ -> mochi_nth(I_25 + 1, Open_list_6) end end), Nb, Pri2)] ++ lists:nthtail(I_25 + 1, Open_list_6),
            I_26 = (I_25 + 1),
            Fun_15_loop(Back_pointer_5, Chosen_3, Ckey, Current_3, G_function_4, Goal_7, I_26, J_3, K, N_heuristic, Nb, Neighs, Nkey, Open_list_7, Pair, Path_5, Start_3, Tentative, Visited_3);
        _ -> {Back_pointer_5, Chosen_3, Ckey, Current_3, G_function_4, Goal_7, I_25, J_3, K, N_heuristic, Nb, Neighs, Nkey, Open_list_6, Pair, Path_5, Start_3, Tentative, Visited_3}
    end
end,
{Back_pointer_5, Chosen_3, Ckey, Current_3, G_function_4, Goal_7, I_26, J_3, K, N_heuristic, Nb, Neighs, Nkey, Open_list_7, Pair, Path_5, Start_3, Tentative, Visited_3} = Fun_15(Back_pointer_5, Chosen_3, Ckey, Current_3, G_function_4, Goal_7, I_25, J_3, K, N_heuristic, Nb, Neighs, Nkey, Open_list_6, Pair, Path_5, Start_3, Tentative, Visited_3),
            Back_pointer_6 = Back_pointer_5,
            Fun_16 = Fun_15,
            G_function_5 = G_function_4,
            I_27 = I_26,
            Open_list_8 = Open_list_7;
        _ -> Back_pointer_6 = Back_pointer_4,
            Fun_16 = Fun_14,
            G_function_5 = G_function_3,
            I_27 = I_24,
            Open_list_8 = Open_list_6
    end,
            Back_pointer_7 = Back_pointer_6,
            Fun_17 = Fun_16,
            G_function_6 = G_function_5,
            I_28 = I_27,
            Nkey_2 = Nkey,
            Open_list_9 = Open_list_8,
            Tentative_2 = Tentative;
        _ -> Back_pointer_7 = Back_pointer_4,
            Fun_17 = Fun_14,
            G_function_6 = G_function_3,
            I_28 = I_24,
            Nkey_2 = nil,
            Open_list_9 = Open_list_6,
            Tentative_2 = nil
    end,
            K_2 = (K + 1),
            Fun_18_loop(Back_pointer_7, Chosen_3, Ckey, Current_3, G_function_6, Goal_7, I_28, J_3, K_2, N_heuristic, Neighs, Open_list_9, Pair, Path_5, Start_3, Visited_3);
        _ -> {Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J_3, K, N_heuristic, Neighs, Open_list_6, Pair, Path_5, Start_3, Visited_3}
    end
end,
{Back_pointer_7, Chosen_3, Ckey, Current_3, G_function_6, Goal_7, I_28, J_3, K_2, N_heuristic, Neighs, Open_list_9, Pair, Path_5, Start_3, Visited_3} = Fun_18(Back_pointer_4, Chosen_3, Ckey, Current_3, G_function_3, Goal_7, I_24, J_3, K, N_heuristic, Neighs, Open_list_6, Pair, Path_5, Start_3, Visited_3),
                Fun_19_loop(Back_pointer_7, G_function_6, Goal_7, I_28, N_heuristic, Open_list_9, Start_3, Visited_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_19_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                {break, B0, B1, B2, B3, B4, B5, B6, B7} -> {B0, B1, B2, B3, B4, B5, B6, B7}
            end;
        _ -> {Back_pointer_4, G_function_3, Goal_7, I_20, N_heuristic, Open_list_3, Start_3, Visited_2}
    end
end,
{Back_pointer_7, G_function_6, Goal_7, I_28, N_heuristic, Open_list_9, Start_3, Visited_3} = Fun_19(Back_pointer_4, G_function_3, Goal_7, I_20, N_heuristic, Open_list_3, Start_3, Visited_2),
        io:format("~ts~n", [mochi_repr("No path found to goal")]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('W1', 1.0),
    erlang:put('W2', 1.0),
    erlang:put('n', 20),
    erlang:put('n_heuristic', 3),
    erlang:put('INF', 1000000000.0),
    erlang:put('t', 1),
    erlang:put('blocks', [#{"x" => 0, "y" => 1}, #{"x" => 1, "y" => 1}, #{"x" => 2, "y" => 1}, #{"x" => 3, "y" => 1}, #{"x" => 4, "y" => 1}, #{"x" => 5, "y" => 1}, #{"x" => 6, "y" => 1}, #{"x" => 7, "y" => 1}, #{"x" => 8, "y" => 1}, #{"x" => 9, "y" => 1}, #{"x" => 10, "y" => 1}, #{"x" => 11, "y" => 1}, #{"x" => 12, "y" => 1}, #{"x" => 13, "y" => 1}, #{"x" => 14, "y" => 1}, #{"x" => 15, "y" => 1}, #{"x" => 16, "y" => 1}, #{"x" => 17, "y" => 1}, #{"x" => 18, "y" => 1}, #{"x" => 19, "y" => 1}]),
    erlang:put('start', #{"x" => 0, "y" => 0}),
    erlang:put('goal', #{"x" => (20 - 1), "y" => (20 - 1)}),
    multi_a_star(erlang:get('start'), erlang:get('goal'), 3),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
