#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, new_adjacency_list/1, add_edge/4, push_front/2, pop_front/1, front/1, get_shortest_path/3]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

new_adjacency_list(Size) ->
    try
        G = [],
        I = 0,
        Fun = fun Fun_loop(G, I, Size) ->
    case (I < Size) of
        true ->
            G_2 = lists:append((case G of nil -> []; _ -> G end), [[]]),
            I_2 = (I + 1),
            Fun_loop(G_2, I_2, Size);
        _ -> {G, I, Size}
    end
end,
{G_2, I_2, Size} = Fun(G, I, Size),
        #{"graph" => G_2, "size" => Size}
    catch {return, Ret} -> Ret end.

add_edge(Al, From_vertex, To_vertex, Weight) ->
    try
        case mochi_not(((Weight == 0) orelse (Weight == 1))) of
        true -> erlang:error("Edge weight must be either 0 or 1.");
        _ -> ok
    end,
        case ((To_vertex < 0) orelse (To_vertex >= maps:get("size", Al, nil))) of
        true -> erlang:error("Vertex indexes must be in [0; size).");
        _ -> ok
    end,
        G_3 = maps:get("graph", Al, nil),
        Edges = (case erlang:is_map(G_3) of true -> maps:get(From_vertex, G_3, nil); _ -> case From_vertex < 0 of true -> lists:nth(erlang:length(G_3) + From_vertex + 1, G_3); _ -> lists:nth(From_vertex + 1, G_3) end end),
        G_4 = lists:sublist(G_3, From_vertex) ++ [lists:append((case Edges of nil -> []; _ -> Edges end), [#{"destination_vertex" => To_vertex, "weight" => Weight}])] ++ lists:nthtail(From_vertex + 1, G_3),
        Al_2 = maps:put("graph", G_4, Al),
        {nil, Al_2}
    catch {return, Ret} -> Ret end.

push_front(Q, V) ->
    try
        Res = [V],
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Q, Res, V) ->
    case (I_3 < erlang:length(Q)) of
        true ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(case erlang:is_map(Q) of true -> maps:get(I_3, Q, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Q) + I_3 + 1, Q); _ -> lists:nth(I_3 + 1, Q) end end)]),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Q, Res_2, V);
        _ -> {I_3, Q, Res, V}
    end
end,
{I_4, Q, Res_2, V} = Fun_2(I_3, Q, Res, V),
        Res_2
    catch {return, Ret} -> Ret end.

pop_front(Q_2) ->
    try
        Res_3 = [],
        I_5 = 1,
        Fun_3 = fun Fun_3_loop(I_5, Q_2, Res_3) ->
    case (I_5 < erlang:length(Q_2)) of
        true ->
            Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [(case erlang:is_map(Q_2) of true -> maps:get(I_5, Q_2, nil); _ -> case I_5 < 0 of true -> lists:nth(erlang:length(Q_2) + I_5 + 1, Q_2); _ -> lists:nth(I_5 + 1, Q_2) end end)]),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Q_2, Res_4);
        _ -> {I_5, Q_2, Res_3}
    end
end,
{I_6, Q_2, Res_4} = Fun_3(I_5, Q_2, Res_3),
        Res_4
    catch {return, Ret} -> Ret end.

front(Q_3) ->
    try
        (case erlang:is_map(Q_3) of true -> maps:get(0, Q_3, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Q_3) + 0 + 1, Q_3); _ -> lists:nth(0 + 1, Q_3) end end)
    catch {return, Ret} -> Ret end.

get_shortest_path(Al_3, Start_vertex, Finish_vertex) ->
    try
        Queue = [Start_vertex],
        Distances = [],
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(Al_3, Distances, Finish_vertex, I_7, Queue, Start_vertex) ->
    case (I_7 < maps:get("size", Al_3, nil)) of
        true ->
            Distances_2 = lists:append((case Distances of nil -> []; _ -> Distances end), [-1]),
            I_8 = (I_7 + 1),
            Fun_4_loop(Al_3, Distances_2, Finish_vertex, I_8, Queue, Start_vertex);
        _ -> {Al_3, Distances, Finish_vertex, I_7, Queue, Start_vertex}
    end
end,
{Al_3, Distances_2, Finish_vertex, I_8, Queue, Start_vertex} = Fun_4(Al_3, Distances, Finish_vertex, I_7, Queue, Start_vertex),
        Distances_3 = lists:sublist(Distances_2, Start_vertex) ++ [0] ++ lists:nthtail(Start_vertex + 1, Distances_2),
        Fun_6 = fun Fun_6_loop(Al_3, Distances_3, Finish_vertex, I_8, Queue, Start_vertex) ->
    case (erlang:length(Queue) > 0) of
        true ->
            try
                Current_vertex = front(Queue),
                Queue_2 = pop_front(Queue),
                Current_distance = (case erlang:is_map(Distances_3) of true -> maps:get(Current_vertex, Distances_3, nil); _ -> case Current_vertex < 0 of true -> lists:nth(erlang:length(Distances_3) + Current_vertex + 1, Distances_3); _ -> lists:nth(Current_vertex + 1, Distances_3) end end),
                Edges_2 = (case erlang:is_map(maps:get("graph", Al_3, nil)) of true -> maps:get(Current_vertex, maps:get("graph", Al_3, nil), nil); _ -> case Current_vertex < 0 of true -> lists:nth(erlang:length(maps:get("graph", Al_3, nil)) + Current_vertex + 1, maps:get("graph", Al_3, nil)); _ -> lists:nth(Current_vertex + 1, maps:get("graph", Al_3, nil)) end end),
                J = 0,
                Fun_5 = fun Fun_5_loop(Al_3, Current_distance, Current_vertex, Distances_3, Edges_2, Finish_vertex, I_8, J, Queue_2, Start_vertex) ->
    case (J < erlang:length(Edges_2)) of
        true ->
            try
                Edge = (case erlang:is_map(Edges_2) of true -> maps:get(J, Edges_2, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Edges_2) + J + 1, Edges_2); _ -> lists:nth(J + 1, Edges_2) end end),
                New_distance = (Current_distance + maps:get("weight", Edge, nil)),
                Dest = maps:get("destination_vertex", Edge, nil),
                Dest_distance = (case erlang:is_map(Distances_3) of true -> maps:get(Dest, Distances_3, nil); _ -> case Dest < 0 of true -> lists:nth(erlang:length(Distances_3) + Dest + 1, Distances_3); _ -> lists:nth(Dest + 1, Distances_3) end end),
                case ((Dest_distance >= 0) andalso (New_distance >= Dest_distance)) of
        true -> J_2 = (J + 1),
            throw({continue, Al_3, Current_distance, Current_vertex, Distances_3, Edges_2, Finish_vertex, I_8, J_2, Queue_2, Start_vertex}),
            J_3 = J_2;
        _ -> J_3 = J
    end,
                Distances_4 = lists:sublist(Distances_3, Dest) ++ [New_distance] ++ lists:nthtail(Dest + 1, Distances_3),
                case (maps:get("weight", Edge, nil) == 0) of
        true -> Queue_3 = push_front(Queue_2, Dest),
            Queue_5 = Queue_3;
        _ -> Queue_4 = lists:append((case Queue_2 of nil -> []; _ -> Queue_2 end), [Dest]),
            Queue_5 = Queue_4
    end,
                J_4 = (J_3 + 1),
                Fun_5_loop(Al_3, Current_distance, Current_vertex, Distances_4, Edges_2, Finish_vertex, I_8, J_4, Queue_5, Start_vertex)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9}
            end;
        _ -> {Al_3, Current_distance, Current_vertex, Distances_3, Edges_2, Finish_vertex, I_8, J, Queue_2, Start_vertex}
    end
end,
{Al_3, Current_distance, Current_vertex, Distances_4, Edges_2, Finish_vertex, I_8, J_4, Queue_5, Start_vertex} = Fun_5(Al_3, Current_distance, Current_vertex, Distances_3, Edges_2, Finish_vertex, I_8, J, Queue_2, Start_vertex),
                Fun_6_loop(Al_3, Distances_4, Finish_vertex, I_8, Queue_5, Start_vertex)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_6_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {Al_3, Distances_3, Finish_vertex, I_8, Queue, Start_vertex}
    end
end,
{Al_3, Distances_4, Finish_vertex, I_8, Queue_5, Start_vertex} = Fun_6(Al_3, Distances_3, Finish_vertex, I_8, Queue, Start_vertex),
        Result = (case erlang:is_map(Distances_4) of true -> maps:get(Finish_vertex, Distances_4, nil); _ -> case Finish_vertex < 0 of true -> lists:nth(erlang:length(Distances_4) + Finish_vertex + 1, Distances_4); _ -> lists:nth(Finish_vertex + 1, Distances_4) end end),
        case (Result < 0) of
        true -> erlang:error("No path from start_vertex to finish_vertex.");
        _ -> ok
    end,
        Result
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('g', new_adjacency_list(11)),
    {_, G_5} = add_edge(erlang:get('g'), 0, 1, 0),
    erlang:put('g', G_5),
    {_, G_6} = add_edge(erlang:get('g'), 0, 3, 1),
    erlang:put('g', G_6),
    {_, G_7} = add_edge(erlang:get('g'), 1, 2, 0),
    erlang:put('g', G_7),
    {_, G_8} = add_edge(erlang:get('g'), 2, 3, 0),
    erlang:put('g', G_8),
    {_, G_9} = add_edge(erlang:get('g'), 4, 2, 1),
    erlang:put('g', G_9),
    {_, G_10} = add_edge(erlang:get('g'), 4, 5, 1),
    erlang:put('g', G_10),
    {_, G_11} = add_edge(erlang:get('g'), 4, 6, 1),
    erlang:put('g', G_11),
    {_, G_12} = add_edge(erlang:get('g'), 5, 9, 0),
    erlang:put('g', G_12),
    {_, G_13} = add_edge(erlang:get('g'), 6, 7, 1),
    erlang:put('g', G_13),
    {_, G_14} = add_edge(erlang:get('g'), 7, 8, 1),
    erlang:put('g', G_14),
    {_, G_15} = add_edge(erlang:get('g'), 8, 10, 1),
    erlang:put('g', G_15),
    {_, G_16} = add_edge(erlang:get('g'), 9, 7, 0),
    erlang:put('g', G_16),
    {_, G_17} = add_edge(erlang:get('g'), 9, 10, 1),
    erlang:put('g', G_17),
    io:format("~ts~n", [mochi_str(get_shortest_path(erlang:get('g'), 0, 3))]),
    io:format("~ts~n", [mochi_str(get_shortest_path(erlang:get('g'), 4, 10))]),
    io:format("~ts~n", [mochi_str(get_shortest_path(erlang:get('g'), 4, 8))]),
    io:format("~ts~n", [mochi_str(get_shortest_path(erlang:get('g'), 0, 1))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
