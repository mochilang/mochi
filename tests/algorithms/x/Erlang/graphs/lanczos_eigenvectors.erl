#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, rand/0, random/0, sqrtapprox/1, absf/1, dot/2, vector_scale/2, vector_sub/2, vector_add/2, zeros_matrix/2, column/2, validate_adjacency_list/1, multiply_matrix_vector/2, lanczos_iteration/2, jacobi_eigen/2, matmul/2, sort_eigenpairs/2, find_lanczos_eigenvectors/2, list_to_string/1, matrix_to_string/1]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.


mochi_mod(A, B) when B =/= 0 ->
    ((A rem B) + B) rem B;
mochi_mod(_, _) -> 0.

rand() ->
    try
        erlang:put('seed', mochi_mod(((erlang:get('seed') * 1103515245) + 12345), 2147483648)),
        erlang:get('seed')
    catch {return, Ret} -> Ret end.

random() ->
    try
        mochi_safe_div(mochi_safe_mul(1, rand()), 2.147483648e+09)
    catch {return, Ret} -> Ret end.

sqrtapprox(X) ->
    try
        case (X =< 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        Guess = X,
        I = 0,
        Fun = fun Fun_loop(Guess, I, X) ->
    case (I < 20) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X, Guess)), 2),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X);
        _ -> {Guess, I, X}
    end
end,
{Guess_2, I_2, X} = Fun(Guess, I, X),
        Guess_2
    catch {return, Ret} -> Ret end.

absf(X_2) ->
    try
        (case (X_2 < 0) of
    true -> -X_2;
    _ -> X_2
end)
    catch {return, Ret} -> Ret end.

dot(A, B) ->
    try
        S = 0,
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(A, B, I_3, S) ->
    case (I_3 < erlang:length(A)) of
        true ->
            S_2 = (S + mochi_safe_mul((case erlang:is_map(A) of true -> maps:get(I_3, A, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(A) + I_3 + 1, A); _ -> lists:nth(I_3 + 1, A) end end), (case erlang:is_map(B) of true -> maps:get(I_3, B, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(B) + I_3 + 1, B); _ -> lists:nth(I_3 + 1, B) end end))),
            I_4 = (I_3 + 1),
            Fun_2_loop(A, B, I_4, S_2);
        _ -> {A, B, I_3, S}
    end
end,
{A, B, I_4, S_2} = Fun_2(A, B, I_3, S),
        S_2
    catch {return, Ret} -> Ret end.

vector_scale(V, S_3) ->
    try
        Res = [],
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Res, S_3, V) ->
    case (I_5 < erlang:length(V)) of
        true ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [mochi_safe_mul((case erlang:is_map(V) of true -> maps:get(I_5, V, nil); _ -> case I_5 < 0 of true -> lists:nth(erlang:length(V) + I_5 + 1, V); _ -> lists:nth(I_5 + 1, V) end end), S_3)]),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Res_2, S_3, V);
        _ -> {I_5, Res, S_3, V}
    end
end,
{I_6, Res_2, S_3, V} = Fun_3(I_5, Res, S_3, V),
        Res_2
    catch {return, Ret} -> Ret end.

vector_sub(A_2, B_2) ->
    try
        Res_3 = [],
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(A_2, B_2, I_7, Res_3) ->
    case (I_7 < erlang:length(A_2)) of
        true ->
            Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [((case erlang:is_map(A_2) of true -> maps:get(I_7, A_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(A_2) + I_7 + 1, A_2); _ -> lists:nth(I_7 + 1, A_2) end end) - (case erlang:is_map(B_2) of true -> maps:get(I_7, B_2, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(B_2) + I_7 + 1, B_2); _ -> lists:nth(I_7 + 1, B_2) end end))]),
            I_8 = (I_7 + 1),
            Fun_4_loop(A_2, B_2, I_8, Res_4);
        _ -> {A_2, B_2, I_7, Res_3}
    end
end,
{A_2, B_2, I_8, Res_4} = Fun_4(A_2, B_2, I_7, Res_3),
        Res_4
    catch {return, Ret} -> Ret end.

vector_add(A_3, B_3) ->
    try
        Res_5 = [],
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(A_3, B_3, I_9, Res_5) ->
    case (I_9 < erlang:length(A_3)) of
        true ->
            Res_6 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [((case erlang:is_map(A_3) of true -> maps:get(I_9, A_3, nil); _ -> case I_9 < 0 of true -> lists:nth(erlang:length(A_3) + I_9 + 1, A_3); _ -> lists:nth(I_9 + 1, A_3) end end) + (case erlang:is_map(B_3) of true -> maps:get(I_9, B_3, nil); _ -> case I_9 < 0 of true -> lists:nth(erlang:length(B_3) + I_9 + 1, B_3); _ -> lists:nth(I_9 + 1, B_3) end end))]),
            I_10 = (I_9 + 1),
            Fun_5_loop(A_3, B_3, I_10, Res_6);
        _ -> {A_3, B_3, I_9, Res_5}
    end
end,
{A_3, B_3, I_10, Res_6} = Fun_5(A_3, B_3, I_9, Res_5),
        Res_6
    catch {return, Ret} -> Ret end.

zeros_matrix(R, C) ->
    try
        M = [],
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(C, I_11, M, R) ->
    case (I_11 < R) of
        true ->
            Row = [],
            J = 0,
            Fun_6 = fun Fun_6_loop(C, I_11, J, M, R, Row) ->
    case (J < C) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            J_2 = (J + 1),
            Fun_6_loop(C, I_11, J_2, M, R, Row_2);
        _ -> {C, I_11, J, M, R, Row}
    end
end,
{C, I_11, J_2, M, R, Row_2} = Fun_6(C, I_11, J, M, R, Row),
            M_2 = lists:append((case M of nil -> []; _ -> M end), [Row_2]),
            I_12 = (I_11 + 1),
            Fun_7_loop(C, I_12, M_2, R);
        _ -> {C, I_11, M, R}
    end
end,
{C, I_12, M_2, R} = Fun_7(C, I_11, M, R),
        M_2
    catch {return, Ret} -> Ret end.

column(M_3, Idx) ->
    try
        Col = [],
        I_13 = 0,
        Fun_8 = fun Fun_8_loop(Col, I_13, Idx, M_3) ->
    case (I_13 < erlang:length(M_3)) of
        true ->
            Col_2 = lists:append((case Col of nil -> []; _ -> Col end), [(case erlang:is_map((case erlang:is_map(M_3) of true -> maps:get(I_13, M_3, nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(M_3) + I_13 + 1, M_3); _ -> lists:nth(I_13 + 1, M_3) end end)) of true -> maps:get(Idx, (case erlang:is_map(M_3) of true -> maps:get(I_13, M_3, nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(M_3) + I_13 + 1, M_3); _ -> lists:nth(I_13 + 1, M_3) end end), nil); _ -> case Idx < 0 of true -> lists:nth(erlang:length((case erlang:is_map(M_3) of true -> maps:get(I_13, M_3, nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(M_3) + I_13 + 1, M_3); _ -> lists:nth(I_13 + 1, M_3) end end)) + Idx + 1, (case erlang:is_map(M_3) of true -> maps:get(I_13, M_3, nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(M_3) + I_13 + 1, M_3); _ -> lists:nth(I_13 + 1, M_3) end end)); _ -> lists:nth(Idx + 1, (case erlang:is_map(M_3) of true -> maps:get(I_13, M_3, nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(M_3) + I_13 + 1, M_3); _ -> lists:nth(I_13 + 1, M_3) end end)) end end)]),
            I_14 = (I_13 + 1),
            Fun_8_loop(Col_2, I_14, Idx, M_3);
        _ -> {Col, I_13, Idx, M_3}
    end
end,
{Col_2, I_14, Idx, M_3} = Fun_8(Col, I_13, Idx, M_3),
        Col_2
    catch {return, Ret} -> Ret end.

validate_adjacency_list(Graph) ->
    try
        I_15 = 0,
        Fun_10 = fun Fun_10_loop(Graph, I_15) ->
    case (I_15 < erlang:length(Graph)) of
        true ->
            J_3 = 0,
            Fun_9 = fun Fun_9_loop(Graph, I_15, J_3) ->
    case (J_3 < erlang:length((case erlang:is_map(Graph) of true -> maps:get(I_15, Graph, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Graph) + I_15 + 1, Graph); _ -> lists:nth(I_15 + 1, Graph) end end))) of
        true ->
            V_2 = (case erlang:is_map((case erlang:is_map(Graph) of true -> maps:get(I_15, Graph, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Graph) + I_15 + 1, Graph); _ -> lists:nth(I_15 + 1, Graph) end end)) of true -> maps:get(J_3, (case erlang:is_map(Graph) of true -> maps:get(I_15, Graph, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Graph) + I_15 + 1, Graph); _ -> lists:nth(I_15 + 1, Graph) end end), nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Graph) of true -> maps:get(I_15, Graph, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Graph) + I_15 + 1, Graph); _ -> lists:nth(I_15 + 1, Graph) end end)) + J_3 + 1, (case erlang:is_map(Graph) of true -> maps:get(I_15, Graph, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Graph) + I_15 + 1, Graph); _ -> lists:nth(I_15 + 1, Graph) end end)); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Graph) of true -> maps:get(I_15, Graph, nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(Graph) + I_15 + 1, Graph); _ -> lists:nth(I_15 + 1, Graph) end end)) end end),
            case ((V_2 < 0) orelse (V_2 >= erlang:length(Graph))) of
        true -> erlang:error("Invalid neighbor");
        _ -> ok
    end,
            J_4 = (J_3 + 1),
            Fun_9_loop(Graph, I_15, J_4);
        _ -> {Graph, I_15, J_3}
    end
end,
{Graph, I_15, J_4} = Fun_9(Graph, I_15, J_3),
            I_16 = (I_15 + 1),
            Fun_10_loop(Graph, I_16);
        _ -> {Graph, I_15}
    end
end,
{Graph, I_16} = Fun_10(Graph, I_15),
        nil
    catch {return, Ret} -> Ret end.

multiply_matrix_vector(Graph_2, Vector) ->
    try
        N = erlang:length(Graph_2),
        case (erlang:length(Vector) /= N) of
        true -> erlang:error("Vector length must match number of nodes");
        _ -> ok
    end,
        Result = [],
        I_17 = 0,
        Fun_12 = fun Fun_12_loop(Graph_2, I_17, N, Result, Vector) ->
    case (I_17 < N) of
        true ->
            Sum = 0,
            J_5 = 0,
            Fun_11 = fun Fun_11_loop(Graph_2, I_17, J_5, N, Result, Sum, Vector) ->
    case (J_5 < erlang:length((case erlang:is_map(Graph_2) of true -> maps:get(I_17, Graph_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Graph_2) + I_17 + 1, Graph_2); _ -> lists:nth(I_17 + 1, Graph_2) end end))) of
        true ->
            Nb = (case erlang:is_map((case erlang:is_map(Graph_2) of true -> maps:get(I_17, Graph_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Graph_2) + I_17 + 1, Graph_2); _ -> lists:nth(I_17 + 1, Graph_2) end end)) of true -> maps:get(J_5, (case erlang:is_map(Graph_2) of true -> maps:get(I_17, Graph_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Graph_2) + I_17 + 1, Graph_2); _ -> lists:nth(I_17 + 1, Graph_2) end end), nil); _ -> case J_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Graph_2) of true -> maps:get(I_17, Graph_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Graph_2) + I_17 + 1, Graph_2); _ -> lists:nth(I_17 + 1, Graph_2) end end)) + J_5 + 1, (case erlang:is_map(Graph_2) of true -> maps:get(I_17, Graph_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Graph_2) + I_17 + 1, Graph_2); _ -> lists:nth(I_17 + 1, Graph_2) end end)); _ -> lists:nth(J_5 + 1, (case erlang:is_map(Graph_2) of true -> maps:get(I_17, Graph_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Graph_2) + I_17 + 1, Graph_2); _ -> lists:nth(I_17 + 1, Graph_2) end end)) end end),
            Sum_2 = (Sum + (case erlang:is_map(Vector) of true -> maps:get(Nb, Vector, nil); _ -> case Nb < 0 of true -> lists:nth(erlang:length(Vector) + Nb + 1, Vector); _ -> lists:nth(Nb + 1, Vector) end end)),
            J_6 = (J_5 + 1),
            Fun_11_loop(Graph_2, I_17, J_6, N, Result, Sum_2, Vector);
        _ -> {Graph_2, I_17, J_5, N, Result, Sum, Vector}
    end
end,
{Graph_2, I_17, J_6, N, Result, Sum_2, Vector} = Fun_11(Graph_2, I_17, J_5, N, Result, Sum, Vector),
            Result_2 = lists:append((case Result of nil -> []; _ -> Result end), [Sum_2]),
            I_18 = (I_17 + 1),
            Fun_12_loop(Graph_2, I_18, N, Result_2, Vector);
        _ -> {Graph_2, I_17, N, Result, Vector}
    end
end,
{Graph_2, I_18, N, Result_2, Vector} = Fun_12(Graph_2, I_17, N, Result, Vector),
        Result_2
    catch {return, Ret} -> Ret end.

lanczos_iteration(Graph_3, K) ->
    try
        N_2 = erlang:length(Graph_3),
        case ((K < 1) orelse (K > N_2)) of
        true -> erlang:error("invalid number of eigenvectors");
        _ -> ok
    end,
        Q = zeros_matrix(N_2, K),
        T = zeros_matrix(K, K),
        V_3 = [],
        I_19 = 0,
        Fun_13 = fun Fun_13_loop(Graph_3, I_19, K, N_2, Q, T, V_3) ->
    case (I_19 < N_2) of
        true ->
            V_4 = lists:append((case V_3 of nil -> []; _ -> V_3 end), [random()]),
            I_20 = (I_19 + 1),
            Fun_13_loop(Graph_3, I_20, K, N_2, Q, T, V_4);
        _ -> {Graph_3, I_19, K, N_2, Q, T, V_3}
    end
end,
{Graph_3, I_20, K, N_2, Q, T, V_4} = Fun_13(Graph_3, I_19, K, N_2, Q, T, V_3),
        Ss = 0,
        I_21 = 0,
        Fun_14 = fun Fun_14_loop(Graph_3, I_21, K, N_2, Q, Ss, T, V_4) ->
    case (I_21 < N_2) of
        true ->
            Ss_2 = (Ss + mochi_safe_mul((case erlang:is_map(V_4) of true -> maps:get(I_21, V_4, nil); _ -> case I_21 < 0 of true -> lists:nth(erlang:length(V_4) + I_21 + 1, V_4); _ -> lists:nth(I_21 + 1, V_4) end end), (case erlang:is_map(V_4) of true -> maps:get(I_21, V_4, nil); _ -> case I_21 < 0 of true -> lists:nth(erlang:length(V_4) + I_21 + 1, V_4); _ -> lists:nth(I_21 + 1, V_4) end end))),
            I_22 = (I_21 + 1),
            Fun_14_loop(Graph_3, I_22, K, N_2, Q, Ss_2, T, V_4);
        _ -> {Graph_3, I_21, K, N_2, Q, Ss, T, V_4}
    end
end,
{Graph_3, I_22, K, N_2, Q, Ss_2, T, V_4} = Fun_14(Graph_3, I_21, K, N_2, Q, Ss, T, V_4),
        Vnorm = sqrtapprox(Ss_2),
        I_23 = 0,
        Fun_15 = fun Fun_15_loop(Graph_3, I_23, K, N_2, Q, Ss_2, T, V_4, Vnorm) ->
    case (I_23 < N_2) of
        true ->
            Q_2 = lists:sublist(Q, I_23) ++ [lists:sublist(lists:nth(I_23 + 1, Q), 0) ++ [mochi_safe_div((case erlang:is_map(V_4) of true -> maps:get(I_23, V_4, nil); _ -> case I_23 < 0 of true -> lists:nth(erlang:length(V_4) + I_23 + 1, V_4); _ -> lists:nth(I_23 + 1, V_4) end end), Vnorm)] ++ lists:nthtail(0 + 1, lists:nth(I_23 + 1, Q))] ++ lists:nthtail(I_23 + 1, Q),
            I_24 = (I_23 + 1),
            Fun_15_loop(Graph_3, I_24, K, N_2, Q_2, Ss_2, T, V_4, Vnorm);
        _ -> {Graph_3, I_23, K, N_2, Q, Ss_2, T, V_4, Vnorm}
    end
end,
{Graph_3, I_24, K, N_2, Q_2, Ss_2, T, V_4, Vnorm} = Fun_15(Graph_3, I_23, K, N_2, Q, Ss_2, T, V_4, Vnorm),
        Beta = 0,
        J_7 = 0,
        Fun_20 = fun Fun_20_loop(Beta, Graph_3, I_24, J_7, K, N_2, Q_2, Ss_2, T, V_4, Vnorm) ->
    case (J_7 < K) of
        true ->
            W = multiply_matrix_vector(Graph_3, column(Q_2, J_7)),
            case (J_7 > 0) of
        true -> W_2 = vector_sub(W, vector_scale(column(Q_2, (J_7 - 1)), Beta)),
            W_3 = W_2;
        _ -> W_3 = W
    end,
            Alpha = dot(column(Q_2, J_7), W_3),
            W_4 = vector_sub(W_3, vector_scale(column(Q_2, J_7), Alpha)),
            Ss2 = 0,
            P = 0,
            Fun_16 = fun Fun_16_loop(Alpha, Beta, Graph_3, I_24, J_7, K, N_2, P, Q_2, Ss_2, Ss2, T, V_4, Vnorm, W_4) ->
    case (P < N_2) of
        true ->
            Ss2_2 = (Ss2 + mochi_safe_mul((case erlang:is_map(W_4) of true -> maps:get(P, W_4, nil); _ -> case P < 0 of true -> lists:nth(erlang:length(W_4) + P + 1, W_4); _ -> lists:nth(P + 1, W_4) end end), (case erlang:is_map(W_4) of true -> maps:get(P, W_4, nil); _ -> case P < 0 of true -> lists:nth(erlang:length(W_4) + P + 1, W_4); _ -> lists:nth(P + 1, W_4) end end))),
            P_2 = (P + 1),
            Fun_16_loop(Alpha, Beta, Graph_3, I_24, J_7, K, N_2, P_2, Q_2, Ss_2, Ss2_2, T, V_4, Vnorm, W_4);
        _ -> {Alpha, Beta, Graph_3, I_24, J_7, K, N_2, P, Q_2, Ss_2, Ss2, T, V_4, Vnorm, W_4}
    end
end,
{Alpha, Beta, Graph_3, I_24, J_7, K, N_2, P_2, Q_2, Ss_2, Ss2_2, T, V_4, Vnorm, W_4} = Fun_16(Alpha, Beta, Graph_3, I_24, J_7, K, N_2, P, Q_2, Ss_2, Ss2, T, V_4, Vnorm, W_4),
            Beta_2 = sqrtapprox(Ss2_2),
            T_2 = lists:sublist(T, J_7) ++ [lists:sublist(lists:nth(J_7 + 1, T), J_7) ++ [Alpha] ++ lists:nthtail(J_7 + 1, lists:nth(J_7 + 1, T))] ++ lists:nthtail(J_7 + 1, T),
            case (J_7 < (K - 1)) of
        true -> T_3 = lists:sublist(T_2, J_7) ++ [lists:sublist(lists:nth(J_7 + 1, T_2), (J_7 + 1)) ++ [Beta_2] ++ lists:nthtail((J_7 + 1) + 1, lists:nth(J_7 + 1, T_2))] ++ lists:nthtail(J_7 + 1, T_2),
            T_4 = lists:sublist(T_3, (J_7 + 1)) ++ [lists:sublist(lists:nth((J_7 + 1) + 1, T_3), J_7) ++ [Beta_2] ++ lists:nthtail(J_7 + 1, lists:nth((J_7 + 1) + 1, T_3))] ++ lists:nthtail((J_7 + 1) + 1, T_3),
            case (Beta_2 > 1.0e-10) of
        true -> Wnorm = vector_scale(W_4, mochi_safe_div(1, Beta_2)),
            R_2 = 0,
            Fun_17 = fun Fun_17_loop(Alpha, Beta_2, Graph_3, I_24, J_7, K, N_2, P_2, Q_2, R_2, Ss_2, Ss2_2, T_4, V_4, Vnorm, W_4, Wnorm) ->
    case (R_2 < N_2) of
        true ->
            Q_3 = lists:sublist(Q_2, R_2) ++ [lists:sublist(lists:nth(R_2 + 1, Q_2), (J_7 + 1)) ++ [(case erlang:is_map(Wnorm) of true -> maps:get(R_2, Wnorm, nil); _ -> case R_2 < 0 of true -> lists:nth(erlang:length(Wnorm) + R_2 + 1, Wnorm); _ -> lists:nth(R_2 + 1, Wnorm) end end)] ++ lists:nthtail((J_7 + 1) + 1, lists:nth(R_2 + 1, Q_2))] ++ lists:nthtail(R_2 + 1, Q_2),
            R_3 = (R_2 + 1),
            Fun_17_loop(Alpha, Beta_2, Graph_3, I_24, J_7, K, N_2, P_2, Q_3, R_3, Ss_2, Ss2_2, T_4, V_4, Vnorm, W_4, Wnorm);
        _ -> {Alpha, Beta_2, Graph_3, I_24, J_7, K, N_2, P_2, Q_2, R_2, Ss_2, Ss2_2, T_4, V_4, Vnorm, W_4, Wnorm}
    end
end,
{Alpha, Beta_2, Graph_3, I_24, J_7, K, N_2, P_2, Q_3, R_3, Ss_2, Ss2_2, T_4, V_4, Vnorm, W_4, Wnorm} = Fun_17(Alpha, Beta_2, Graph_3, I_24, J_7, K, N_2, P_2, Q_2, R_2, Ss_2, Ss2_2, T_4, V_4, Vnorm, W_4, Wnorm),
            Fun_18 = Fun_17,
            Q_4 = Q_3,
            R_4 = R_3,
            Wnorm_2 = Wnorm;
        _ -> Fun_18 = Fun_16,
            Q_4 = Q_2,
            R_4 = nil,
            Wnorm_2 = nil
    end,
            Fun_19 = Fun_18,
            Q_5 = Q_4,
            R_5 = R_4,
            T_5 = T_4,
            Wnorm_3 = Wnorm_2;
        _ -> Fun_19 = Fun_16,
            Q_5 = Q_2,
            R_5 = nil,
            T_5 = T_2,
            Wnorm_3 = nil
    end,
            J_8 = (J_7 + 1),
            Fun_20_loop(Beta_2, Graph_3, I_24, J_8, K, N_2, Q_5, Ss_2, T_5, V_4, Vnorm);
        _ -> {Beta, Graph_3, I_24, J_7, K, N_2, Q_2, Ss_2, T, V_4, Vnorm}
    end
end,
{Beta_2, Graph_3, I_24, J_8, K, N_2, Q_5, Ss_2, T_5, V_4, Vnorm} = Fun_20(Beta, Graph_3, I_24, J_7, K, N_2, Q_2, Ss_2, T, V_4, Vnorm),
        #{"t" => T_5, "q" => Q_5}
    catch {return, Ret} -> Ret end.

jacobi_eigen(A_in, Max_iter) ->
    try
        N_3 = erlang:length(A_in),
        A_4 = A_in,
        V_5 = zeros_matrix(N_3, N_3),
        I_25 = 0,
        Fun_21 = fun Fun_21_loop(A_4, A_in, I_25, Max_iter, N_3, V_5) ->
    case (I_25 < N_3) of
        true ->
            V_6 = lists:sublist(V_5, I_25) ++ [lists:sublist(lists:nth(I_25 + 1, V_5), I_25) ++ [1] ++ lists:nthtail(I_25 + 1, lists:nth(I_25 + 1, V_5))] ++ lists:nthtail(I_25 + 1, V_5),
            I_26 = (I_25 + 1),
            Fun_21_loop(A_4, A_in, I_26, Max_iter, N_3, V_6);
        _ -> {A_4, A_in, I_25, Max_iter, N_3, V_5}
    end
end,
{A_4, A_in, I_26, Max_iter, N_3, V_6} = Fun_21(A_4, A_in, I_25, Max_iter, N_3, V_5),
        Iter = 0,
        Fun_26 = fun Fun_26_loop(A_4, A_in, I_26, Iter, Max_iter, N_3, V_6) ->
    case (Iter < Max_iter) of
        true ->
            try
                P_3 = 0,
                Q_6 = 1,
                Max = absf((case erlang:is_map((case erlang:is_map(A_4) of true -> maps:get(P_3, A_4, nil); _ -> case P_3 < 0 of true -> lists:nth(erlang:length(A_4) + P_3 + 1, A_4); _ -> lists:nth(P_3 + 1, A_4) end end)) of true -> maps:get(Q_6, (case erlang:is_map(A_4) of true -> maps:get(P_3, A_4, nil); _ -> case P_3 < 0 of true -> lists:nth(erlang:length(A_4) + P_3 + 1, A_4); _ -> lists:nth(P_3 + 1, A_4) end end), nil); _ -> case Q_6 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_4) of true -> maps:get(P_3, A_4, nil); _ -> case P_3 < 0 of true -> lists:nth(erlang:length(A_4) + P_3 + 1, A_4); _ -> lists:nth(P_3 + 1, A_4) end end)) + Q_6 + 1, (case erlang:is_map(A_4) of true -> maps:get(P_3, A_4, nil); _ -> case P_3 < 0 of true -> lists:nth(erlang:length(A_4) + P_3 + 1, A_4); _ -> lists:nth(P_3 + 1, A_4) end end)); _ -> lists:nth(Q_6 + 1, (case erlang:is_map(A_4) of true -> maps:get(P_3, A_4, nil); _ -> case P_3 < 0 of true -> lists:nth(erlang:length(A_4) + P_3 + 1, A_4); _ -> lists:nth(P_3 + 1, A_4) end end)) end end)),
                I_27 = 0,
                Fun_23 = fun Fun_23_loop(A_4, A_in, I_27, Iter, Max, Max_iter, N_3, P_3, Q_6, V_6) ->
    case (I_27 < N_3) of
        true ->
            J_9 = (I_27 + 1),
            Fun_22 = fun Fun_22_loop(A_4, A_in, I_27, Iter, J_9, Max, Max_iter, N_3, P_3, Q_6, V_6) ->
    case (J_9 < N_3) of
        true ->
            Val = absf((case erlang:is_map((case erlang:is_map(A_4) of true -> maps:get(I_27, A_4, nil); _ -> case I_27 < 0 of true -> lists:nth(erlang:length(A_4) + I_27 + 1, A_4); _ -> lists:nth(I_27 + 1, A_4) end end)) of true -> maps:get(J_9, (case erlang:is_map(A_4) of true -> maps:get(I_27, A_4, nil); _ -> case I_27 < 0 of true -> lists:nth(erlang:length(A_4) + I_27 + 1, A_4); _ -> lists:nth(I_27 + 1, A_4) end end), nil); _ -> case J_9 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_4) of true -> maps:get(I_27, A_4, nil); _ -> case I_27 < 0 of true -> lists:nth(erlang:length(A_4) + I_27 + 1, A_4); _ -> lists:nth(I_27 + 1, A_4) end end)) + J_9 + 1, (case erlang:is_map(A_4) of true -> maps:get(I_27, A_4, nil); _ -> case I_27 < 0 of true -> lists:nth(erlang:length(A_4) + I_27 + 1, A_4); _ -> lists:nth(I_27 + 1, A_4) end end)); _ -> lists:nth(J_9 + 1, (case erlang:is_map(A_4) of true -> maps:get(I_27, A_4, nil); _ -> case I_27 < 0 of true -> lists:nth(erlang:length(A_4) + I_27 + 1, A_4); _ -> lists:nth(I_27 + 1, A_4) end end)) end end)),
            case (Val > Max) of
        true -> Max_2 = Val,
            P_4 = I_27,
            Q_7 = J_9,
            Max_3 = Max_2,
            P_5 = P_4,
            Q_8 = Q_7;
        _ -> Max_3 = Max,
            P_5 = P_3,
            Q_8 = Q_6
    end,
            J_10 = (J_9 + 1),
            Fun_22_loop(A_4, A_in, I_27, Iter, J_10, Max_3, Max_iter, N_3, P_5, Q_8, V_6);
        _ -> {A_4, A_in, I_27, Iter, J_9, Max, Max_iter, N_3, P_3, Q_6, V_6}
    end
end,
{A_4, A_in, I_27, Iter, J_10, Max_3, Max_iter, N_3, P_5, Q_8, V_6} = Fun_22(A_4, A_in, I_27, Iter, J_9, Max, Max_iter, N_3, P_3, Q_6, V_6),
            I_28 = (I_27 + 1),
            Fun_23_loop(A_4, A_in, I_28, Iter, Max_3, Max_iter, N_3, P_5, Q_8, V_6);
        _ -> {A_4, A_in, I_27, Iter, Max, Max_iter, N_3, P_3, Q_6, V_6}
    end
end,
{A_4, A_in, I_28, Iter, Max_3, Max_iter, N_3, P_5, Q_8, V_6} = Fun_23(A_4, A_in, I_27, Iter, Max, Max_iter, N_3, P_3, Q_6, V_6),
                case (Max_3 < 1.0e-08) of
        true -> throw({break, A_4, A_in, I_28, Iter, Max_iter, N_3, V_6});
        _ -> ok
    end,
                App = (case erlang:is_map((case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)) of true -> maps:get(P_5, (case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end), nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)) + P_5 + 1, (case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)); _ -> lists:nth(P_5 + 1, (case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)) end end),
                Aqq = (case erlang:is_map((case erlang:is_map(A_4) of true -> maps:get(Q_8, A_4, nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length(A_4) + Q_8 + 1, A_4); _ -> lists:nth(Q_8 + 1, A_4) end end)) of true -> maps:get(Q_8, (case erlang:is_map(A_4) of true -> maps:get(Q_8, A_4, nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length(A_4) + Q_8 + 1, A_4); _ -> lists:nth(Q_8 + 1, A_4) end end), nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_4) of true -> maps:get(Q_8, A_4, nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length(A_4) + Q_8 + 1, A_4); _ -> lists:nth(Q_8 + 1, A_4) end end)) + Q_8 + 1, (case erlang:is_map(A_4) of true -> maps:get(Q_8, A_4, nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length(A_4) + Q_8 + 1, A_4); _ -> lists:nth(Q_8 + 1, A_4) end end)); _ -> lists:nth(Q_8 + 1, (case erlang:is_map(A_4) of true -> maps:get(Q_8, A_4, nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length(A_4) + Q_8 + 1, A_4); _ -> lists:nth(Q_8 + 1, A_4) end end)) end end),
                Apq = (case erlang:is_map((case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)) of true -> maps:get(Q_8, (case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end), nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)) + Q_8 + 1, (case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)); _ -> lists:nth(Q_8 + 1, (case erlang:is_map(A_4) of true -> maps:get(P_5, A_4, nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length(A_4) + P_5 + 1, A_4); _ -> lists:nth(P_5 + 1, A_4) end end)) end end),
                Theta = mochi_safe_div((Aqq - App), mochi_safe_mul(2, Apq)),
                T_6 = mochi_safe_div(1, (absf(Theta) + sqrtapprox((mochi_safe_mul(Theta, Theta) + 1)))),
                case (Theta < 0) of
        true -> T_7 = -T_6,
            T_8 = T_7;
        _ -> T_8 = T_6
    end,
                C_2 = mochi_safe_div(1, sqrtapprox((1 + mochi_safe_mul(T_8, T_8)))),
                S_4 = mochi_safe_mul(T_8, C_2),
                Tau = mochi_safe_div(S_4, (1 + C_2)),
                A_5 = lists:sublist(A_4, P_5) ++ [lists:sublist(lists:nth(P_5 + 1, A_4), P_5) ++ [(App - mochi_safe_mul(T_8, Apq))] ++ lists:nthtail(P_5 + 1, lists:nth(P_5 + 1, A_4))] ++ lists:nthtail(P_5 + 1, A_4),
                A_6 = lists:sublist(A_5, Q_8) ++ [lists:sublist(lists:nth(Q_8 + 1, A_5), Q_8) ++ [(Aqq + mochi_safe_mul(T_8, Apq))] ++ lists:nthtail(Q_8 + 1, lists:nth(Q_8 + 1, A_5))] ++ lists:nthtail(Q_8 + 1, A_5),
                A_7 = lists:sublist(A_6, P_5) ++ [lists:sublist(lists:nth(P_5 + 1, A_6), Q_8) ++ [0] ++ lists:nthtail(Q_8 + 1, lists:nth(P_5 + 1, A_6))] ++ lists:nthtail(P_5 + 1, A_6),
                A_8 = lists:sublist(A_7, Q_8) ++ [lists:sublist(lists:nth(Q_8 + 1, A_7), P_5) ++ [0] ++ lists:nthtail(P_5 + 1, lists:nth(Q_8 + 1, A_7))] ++ lists:nthtail(Q_8 + 1, A_7),
                K_2 = 0,
                Fun_24 = fun Fun_24_loop(A_8, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_2, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6) ->
    case (K_2 < N_3) of
        true ->
            case ((K_2 /= P_5) andalso (K_2 /= Q_8)) of
        true -> Akp = (case erlang:is_map((case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)) of true -> maps:get(P_5, (case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end), nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)) + P_5 + 1, (case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)); _ -> lists:nth(P_5 + 1, (case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)) end end),
            Akq = (case erlang:is_map((case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)) of true -> maps:get(Q_8, (case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end), nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)) + Q_8 + 1, (case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)); _ -> lists:nth(Q_8 + 1, (case erlang:is_map(A_8) of true -> maps:get(K_2, A_8, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_8) + K_2 + 1, A_8); _ -> lists:nth(K_2 + 1, A_8) end end)) end end),
            A_9 = lists:sublist(A_8, K_2) ++ [lists:sublist(lists:nth(K_2 + 1, A_8), P_5) ++ [(Akp - mochi_safe_mul(S_4, (Akq + mochi_safe_mul(Tau, Akp))))] ++ lists:nthtail(P_5 + 1, lists:nth(K_2 + 1, A_8))] ++ lists:nthtail(K_2 + 1, A_8),
            A_10 = lists:sublist(A_9, P_5) ++ [lists:sublist(lists:nth(P_5 + 1, A_9), K_2) ++ [(case erlang:is_map((case erlang:is_map(A_9) of true -> maps:get(K_2, A_9, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_9) + K_2 + 1, A_9); _ -> lists:nth(K_2 + 1, A_9) end end)) of true -> maps:get(P_5, (case erlang:is_map(A_9) of true -> maps:get(K_2, A_9, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_9) + K_2 + 1, A_9); _ -> lists:nth(K_2 + 1, A_9) end end), nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_9) of true -> maps:get(K_2, A_9, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_9) + K_2 + 1, A_9); _ -> lists:nth(K_2 + 1, A_9) end end)) + P_5 + 1, (case erlang:is_map(A_9) of true -> maps:get(K_2, A_9, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_9) + K_2 + 1, A_9); _ -> lists:nth(K_2 + 1, A_9) end end)); _ -> lists:nth(P_5 + 1, (case erlang:is_map(A_9) of true -> maps:get(K_2, A_9, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_9) + K_2 + 1, A_9); _ -> lists:nth(K_2 + 1, A_9) end end)) end end)] ++ lists:nthtail(K_2 + 1, lists:nth(P_5 + 1, A_9))] ++ lists:nthtail(P_5 + 1, A_9),
            A_11 = lists:sublist(A_10, K_2) ++ [lists:sublist(lists:nth(K_2 + 1, A_10), Q_8) ++ [(Akq + mochi_safe_mul(S_4, (Akp - mochi_safe_mul(Tau, Akq))))] ++ lists:nthtail(Q_8 + 1, lists:nth(K_2 + 1, A_10))] ++ lists:nthtail(K_2 + 1, A_10),
            A_12 = lists:sublist(A_11, Q_8) ++ [lists:sublist(lists:nth(Q_8 + 1, A_11), K_2) ++ [(case erlang:is_map((case erlang:is_map(A_11) of true -> maps:get(K_2, A_11, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_11) + K_2 + 1, A_11); _ -> lists:nth(K_2 + 1, A_11) end end)) of true -> maps:get(Q_8, (case erlang:is_map(A_11) of true -> maps:get(K_2, A_11, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_11) + K_2 + 1, A_11); _ -> lists:nth(K_2 + 1, A_11) end end), nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_11) of true -> maps:get(K_2, A_11, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_11) + K_2 + 1, A_11); _ -> lists:nth(K_2 + 1, A_11) end end)) + Q_8 + 1, (case erlang:is_map(A_11) of true -> maps:get(K_2, A_11, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_11) + K_2 + 1, A_11); _ -> lists:nth(K_2 + 1, A_11) end end)); _ -> lists:nth(Q_8 + 1, (case erlang:is_map(A_11) of true -> maps:get(K_2, A_11, nil); _ -> case K_2 < 0 of true -> lists:nth(erlang:length(A_11) + K_2 + 1, A_11); _ -> lists:nth(K_2 + 1, A_11) end end)) end end)] ++ lists:nthtail(K_2 + 1, lists:nth(Q_8 + 1, A_11))] ++ lists:nthtail(Q_8 + 1, A_11),
            A_13 = A_12,
            Akp_2 = Akp,
            Akq_2 = Akq;
        _ -> A_13 = A_8,
            Akp_2 = nil,
            Akq_2 = nil
    end,
            K_3 = (K_2 + 1),
            Fun_24_loop(A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_3, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6);
        _ -> {A_8, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_2, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6}
    end
end,
{A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_3, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6} = Fun_24(A_8, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_2, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6),
                K_4 = 0,
                Fun_25 = fun Fun_25_loop(A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_4, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6) ->
    case (K_4 < N_3) of
        true ->
            Vkp = (case erlang:is_map((case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)) of true -> maps:get(P_5, (case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end), nil); _ -> case P_5 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)) + P_5 + 1, (case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)); _ -> lists:nth(P_5 + 1, (case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)) end end),
            Vkq = (case erlang:is_map((case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)) of true -> maps:get(Q_8, (case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end), nil); _ -> case Q_8 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)) + Q_8 + 1, (case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)); _ -> lists:nth(Q_8 + 1, (case erlang:is_map(V_6) of true -> maps:get(K_4, V_6, nil); _ -> case K_4 < 0 of true -> lists:nth(erlang:length(V_6) + K_4 + 1, V_6); _ -> lists:nth(K_4 + 1, V_6) end end)) end end),
            V_7 = lists:sublist(V_6, K_4) ++ [lists:sublist(lists:nth(K_4 + 1, V_6), P_5) ++ [(Vkp - mochi_safe_mul(S_4, (Vkq + mochi_safe_mul(Tau, Vkp))))] ++ lists:nthtail(P_5 + 1, lists:nth(K_4 + 1, V_6))] ++ lists:nthtail(K_4 + 1, V_6),
            V_8 = lists:sublist(V_7, K_4) ++ [lists:sublist(lists:nth(K_4 + 1, V_7), Q_8) ++ [(Vkq + mochi_safe_mul(S_4, (Vkp - mochi_safe_mul(Tau, Vkq))))] ++ lists:nthtail(Q_8 + 1, lists:nth(K_4 + 1, V_7))] ++ lists:nthtail(K_4 + 1, V_7),
            K_5 = (K_4 + 1),
            Fun_25_loop(A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_5, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_8);
        _ -> {A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_4, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6}
    end
end,
{A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_5, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_8} = Fun_25(A_13, A_in, App, Apq, Aqq, C_2, I_28, Iter, K_4, Max_3, Max_iter, N_3, P_5, Q_8, S_4, T_8, Tau, Theta, V_6),
                Iter_2 = (Iter + 1),
                Fun_26_loop(A_13, A_in, I_28, Iter_2, Max_iter, N_3, V_8)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_26_loop(C0, C1, C2, C3, C4, C5, C6);
                {break, B0, B1, B2, B3, B4, B5, B6} -> {B0, B1, B2, B3, B4, B5, B6}
            end;
        _ -> {A_4, A_in, I_26, Iter, Max_iter, N_3, V_6}
    end
end,
{A_13, A_in, I_28, Iter_2, Max_iter, N_3, V_8} = Fun_26(A_4, A_in, I_26, Iter, Max_iter, N_3, V_6),
        Eigenvalues = [],
        I_29 = 0,
        Fun_27 = fun Fun_27_loop(A_13, A_in, Eigenvalues, I_29, Iter_2, Max_iter, N_3, V_8) ->
    case (I_29 < N_3) of
        true ->
            Eigenvalues_2 = lists:append((case Eigenvalues of nil -> []; _ -> Eigenvalues end), [(case erlang:is_map((case erlang:is_map(A_13) of true -> maps:get(I_29, A_13, nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length(A_13) + I_29 + 1, A_13); _ -> lists:nth(I_29 + 1, A_13) end end)) of true -> maps:get(I_29, (case erlang:is_map(A_13) of true -> maps:get(I_29, A_13, nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length(A_13) + I_29 + 1, A_13); _ -> lists:nth(I_29 + 1, A_13) end end), nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_13) of true -> maps:get(I_29, A_13, nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length(A_13) + I_29 + 1, A_13); _ -> lists:nth(I_29 + 1, A_13) end end)) + I_29 + 1, (case erlang:is_map(A_13) of true -> maps:get(I_29, A_13, nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length(A_13) + I_29 + 1, A_13); _ -> lists:nth(I_29 + 1, A_13) end end)); _ -> lists:nth(I_29 + 1, (case erlang:is_map(A_13) of true -> maps:get(I_29, A_13, nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length(A_13) + I_29 + 1, A_13); _ -> lists:nth(I_29 + 1, A_13) end end)) end end)]),
            I_30 = (I_29 + 1),
            Fun_27_loop(A_13, A_in, Eigenvalues_2, I_30, Iter_2, Max_iter, N_3, V_8);
        _ -> {A_13, A_in, Eigenvalues, I_29, Iter_2, Max_iter, N_3, V_8}
    end
end,
{A_13, A_in, Eigenvalues_2, I_30, Iter_2, Max_iter, N_3, V_8} = Fun_27(A_13, A_in, Eigenvalues, I_29, Iter_2, Max_iter, N_3, V_8),
        #{"values" => Eigenvalues_2, "vectors" => V_8}
    catch {return, Ret} -> Ret end.

matmul(A_14, B_4) ->
    try
        Rows = erlang:length(A_14),
        Cols = erlang:length((case erlang:is_map(B_4) of true -> maps:get(0, B_4, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(B_4) + 0 + 1, B_4); _ -> lists:nth(0 + 1, B_4) end end)),
        Inner = erlang:length(B_4),
        M_4 = zeros_matrix(Rows, Cols),
        I_31 = 0,
        Fun_30 = fun Fun_30_loop(A_14, B_4, Cols, I_31, Inner, M_4, Rows) ->
    case (I_31 < Rows) of
        true ->
            J_11 = 0,
            Fun_29 = fun Fun_29_loop(A_14, B_4, Cols, I_31, Inner, J_11, M_4, Rows) ->
    case (J_11 < Cols) of
        true ->
            S_5 = 0,
            K_6 = 0,
            Fun_28 = fun Fun_28_loop(A_14, B_4, Cols, I_31, Inner, J_11, K_6, M_4, Rows, S_5) ->
    case (K_6 < Inner) of
        true ->
            S_6 = (S_5 + mochi_safe_mul((case erlang:is_map((case erlang:is_map(A_14) of true -> maps:get(I_31, A_14, nil); _ -> case I_31 < 0 of true -> lists:nth(erlang:length(A_14) + I_31 + 1, A_14); _ -> lists:nth(I_31 + 1, A_14) end end)) of true -> maps:get(K_6, (case erlang:is_map(A_14) of true -> maps:get(I_31, A_14, nil); _ -> case I_31 < 0 of true -> lists:nth(erlang:length(A_14) + I_31 + 1, A_14); _ -> lists:nth(I_31 + 1, A_14) end end), nil); _ -> case K_6 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(A_14) of true -> maps:get(I_31, A_14, nil); _ -> case I_31 < 0 of true -> lists:nth(erlang:length(A_14) + I_31 + 1, A_14); _ -> lists:nth(I_31 + 1, A_14) end end)) + K_6 + 1, (case erlang:is_map(A_14) of true -> maps:get(I_31, A_14, nil); _ -> case I_31 < 0 of true -> lists:nth(erlang:length(A_14) + I_31 + 1, A_14); _ -> lists:nth(I_31 + 1, A_14) end end)); _ -> lists:nth(K_6 + 1, (case erlang:is_map(A_14) of true -> maps:get(I_31, A_14, nil); _ -> case I_31 < 0 of true -> lists:nth(erlang:length(A_14) + I_31 + 1, A_14); _ -> lists:nth(I_31 + 1, A_14) end end)) end end), (case erlang:is_map((case erlang:is_map(B_4) of true -> maps:get(K_6, B_4, nil); _ -> case K_6 < 0 of true -> lists:nth(erlang:length(B_4) + K_6 + 1, B_4); _ -> lists:nth(K_6 + 1, B_4) end end)) of true -> maps:get(J_11, (case erlang:is_map(B_4) of true -> maps:get(K_6, B_4, nil); _ -> case K_6 < 0 of true -> lists:nth(erlang:length(B_4) + K_6 + 1, B_4); _ -> lists:nth(K_6 + 1, B_4) end end), nil); _ -> case J_11 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(B_4) of true -> maps:get(K_6, B_4, nil); _ -> case K_6 < 0 of true -> lists:nth(erlang:length(B_4) + K_6 + 1, B_4); _ -> lists:nth(K_6 + 1, B_4) end end)) + J_11 + 1, (case erlang:is_map(B_4) of true -> maps:get(K_6, B_4, nil); _ -> case K_6 < 0 of true -> lists:nth(erlang:length(B_4) + K_6 + 1, B_4); _ -> lists:nth(K_6 + 1, B_4) end end)); _ -> lists:nth(J_11 + 1, (case erlang:is_map(B_4) of true -> maps:get(K_6, B_4, nil); _ -> case K_6 < 0 of true -> lists:nth(erlang:length(B_4) + K_6 + 1, B_4); _ -> lists:nth(K_6 + 1, B_4) end end)) end end))),
            K_7 = (K_6 + 1),
            Fun_28_loop(A_14, B_4, Cols, I_31, Inner, J_11, K_7, M_4, Rows, S_6);
        _ -> {A_14, B_4, Cols, I_31, Inner, J_11, K_6, M_4, Rows, S_5}
    end
end,
{A_14, B_4, Cols, I_31, Inner, J_11, K_7, M_4, Rows, S_6} = Fun_28(A_14, B_4, Cols, I_31, Inner, J_11, K_6, M_4, Rows, S_5),
            M_5 = lists:sublist(M_4, I_31) ++ [lists:sublist(lists:nth(I_31 + 1, M_4), J_11) ++ [S_6] ++ lists:nthtail(J_11 + 1, lists:nth(I_31 + 1, M_4))] ++ lists:nthtail(I_31 + 1, M_4),
            J_12 = (J_11 + 1),
            Fun_29_loop(A_14, B_4, Cols, I_31, Inner, J_12, M_5, Rows);
        _ -> {A_14, B_4, Cols, I_31, Inner, J_11, M_4, Rows}
    end
end,
{A_14, B_4, Cols, I_31, Inner, J_12, M_5, Rows} = Fun_29(A_14, B_4, Cols, I_31, Inner, J_11, M_4, Rows),
            I_32 = (I_31 + 1),
            Fun_30_loop(A_14, B_4, Cols, I_32, Inner, M_5, Rows);
        _ -> {A_14, B_4, Cols, I_31, Inner, M_4, Rows}
    end
end,
{A_14, B_4, Cols, I_32, Inner, M_5, Rows} = Fun_30(A_14, B_4, Cols, I_31, Inner, M_4, Rows),
        M_5
    catch {return, Ret} -> Ret end.

sort_eigenpairs(Vals, Vecs) ->
    try
        N_4 = erlang:length(Vals),
        Values = Vals,
        Vectors = Vecs,
        I_33 = 0,
        Fun_34 = fun Fun_34_loop(I_33, N_4, Vals, Values, Vecs, Vectors) ->
    case (I_33 < N_4) of
        true ->
            J_13 = 0,
            Fun_33 = fun Fun_33_loop(I_33, J_13, N_4, Vals, Values, Vecs, Vectors) ->
    case (J_13 < (N_4 - 1)) of
        true ->
            case ((case erlang:is_map(Values) of true -> maps:get(J_13, Values, nil); _ -> case J_13 < 0 of true -> lists:nth(erlang:length(Values) + J_13 + 1, Values); _ -> lists:nth(J_13 + 1, Values) end end) < (case erlang:is_map(Values) of true -> maps:get((J_13 + 1), Values, nil); _ -> case (J_13 + 1) < 0 of true -> lists:nth(erlang:length(Values) + (J_13 + 1) + 1, Values); _ -> lists:nth((J_13 + 1) + 1, Values) end end)) of
        true -> Tmp = (case erlang:is_map(Values) of true -> maps:get(J_13, Values, nil); _ -> case J_13 < 0 of true -> lists:nth(erlang:length(Values) + J_13 + 1, Values); _ -> lists:nth(J_13 + 1, Values) end end),
            Values_2 = lists:sublist(Values, J_13) ++ [(case erlang:is_map(Values) of true -> maps:get((J_13 + 1), Values, nil); _ -> case (J_13 + 1) < 0 of true -> lists:nth(erlang:length(Values) + (J_13 + 1) + 1, Values); _ -> lists:nth((J_13 + 1) + 1, Values) end end)] ++ lists:nthtail(J_13 + 1, Values),
            Values_3 = lists:sublist(Values_2, (J_13 + 1)) ++ [Tmp] ++ lists:nthtail((J_13 + 1) + 1, Values_2),
            R_6 = 0,
            Fun_31 = fun Fun_31_loop(I_33, J_13, N_4, R_6, Tmp, Vals, Values_3, Vecs, Vectors) ->
    case (R_6 < erlang:length(Vectors)) of
        true ->
            Tv = (case erlang:is_map((case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)) of true -> maps:get(J_13, (case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end), nil); _ -> case J_13 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)) + J_13 + 1, (case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)); _ -> lists:nth(J_13 + 1, (case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)) end end),
            Vectors_2 = lists:sublist(Vectors, R_6) ++ [lists:sublist(lists:nth(R_6 + 1, Vectors), J_13) ++ [(case erlang:is_map((case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)) of true -> maps:get((J_13 + 1), (case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end), nil); _ -> case (J_13 + 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)) + (J_13 + 1) + 1, (case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)); _ -> lists:nth((J_13 + 1) + 1, (case erlang:is_map(Vectors) of true -> maps:get(R_6, Vectors, nil); _ -> case R_6 < 0 of true -> lists:nth(erlang:length(Vectors) + R_6 + 1, Vectors); _ -> lists:nth(R_6 + 1, Vectors) end end)) end end)] ++ lists:nthtail(J_13 + 1, lists:nth(R_6 + 1, Vectors))] ++ lists:nthtail(R_6 + 1, Vectors),
            Vectors_3 = lists:sublist(Vectors_2, R_6) ++ [lists:sublist(lists:nth(R_6 + 1, Vectors_2), (J_13 + 1)) ++ [Tv] ++ lists:nthtail((J_13 + 1) + 1, lists:nth(R_6 + 1, Vectors_2))] ++ lists:nthtail(R_6 + 1, Vectors_2),
            R_7 = (R_6 + 1),
            Fun_31_loop(I_33, J_13, N_4, R_7, Tmp, Vals, Values_3, Vecs, Vectors_3);
        _ -> {I_33, J_13, N_4, R_6, Tmp, Vals, Values_3, Vecs, Vectors}
    end
end,
{I_33, J_13, N_4, R_7, Tmp, Vals, Values_3, Vecs, Vectors_3} = Fun_31(I_33, J_13, N_4, R_6, Tmp, Vals, Values_3, Vecs, Vectors),
            Fun_32 = Fun_31,
            R_8 = R_7,
            Tmp_2 = Tmp,
            Values_4 = Values_3,
            Vectors_4 = Vectors_3;
        _ -> Fun_32 = nil,
            R_8 = nil,
            Tmp_2 = nil,
            Values_4 = Values,
            Vectors_4 = Vectors
    end,
            J_14 = (J_13 + 1),
            Fun_33_loop(I_33, J_14, N_4, Vals, Values_4, Vecs, Vectors_4);
        _ -> {I_33, J_13, N_4, Vals, Values, Vecs, Vectors}
    end
end,
{I_33, J_14, N_4, Vals, Values_4, Vecs, Vectors_4} = Fun_33(I_33, J_13, N_4, Vals, Values, Vecs, Vectors),
            I_34 = (I_33 + 1),
            Fun_34_loop(I_34, N_4, Vals, Values_4, Vecs, Vectors_4);
        _ -> {I_33, N_4, Vals, Values, Vecs, Vectors}
    end
end,
{I_34, N_4, Vals, Values_4, Vecs, Vectors_4} = Fun_34(I_33, N_4, Vals, Values, Vecs, Vectors),
        #{"values" => Values_4, "vectors" => Vectors_4}
    catch {return, Ret} -> Ret end.

find_lanczos_eigenvectors(Graph_4, K_8) ->
    try
        validate_adjacency_list(Graph_4),
        Res_7 = lanczos_iteration(Graph_4, K_8),
        Eig = jacobi_eigen(maps:get("t", Res_7, nil), 50),
        Sorted = sort_eigenpairs(maps:get("values", Eig, nil), maps:get("vectors", Eig, nil)),
        Final_vectors = matmul(maps:get("q", Res_7, nil), maps:get("vectors", Sorted, nil)),
        #{"values" => maps:get("values", Sorted, nil), "vectors" => Final_vectors}
    catch {return, Ret} -> Ret end.

list_to_string(Arr) ->
    try
        S_7 = "[",
        I_35 = 0,
        Fun_35 = fun Fun_35_loop(Arr, I_35, S_7) ->
    case (I_35 < erlang:length(Arr)) of
        true ->
            S_8 = (S_7 ++ mochi_str((case erlang:is_map(Arr) of true -> maps:get(I_35, Arr, nil); _ -> case I_35 < 0 of true -> lists:nth(erlang:length(Arr) + I_35 + 1, Arr); _ -> lists:nth(I_35 + 1, Arr) end end))),
            case (I_35 < (erlang:length(Arr) - 1)) of
        true -> S_9 = (S_8 ++ ", "),
            S_10 = S_9;
        _ -> S_10 = S_8
    end,
            I_36 = (I_35 + 1),
            Fun_35_loop(Arr, I_36, S_10);
        _ -> {Arr, I_35, S_7}
    end
end,
{Arr, I_36, S_10} = Fun_35(Arr, I_35, S_7),
        (S_10 ++ "]")
    catch {return, Ret} -> Ret end.

matrix_to_string(M_6) ->
    try
        S_11 = "[",
        I_37 = 0,
        Fun_36 = fun Fun_36_loop(I_37, M_6, S_11) ->
    case (I_37 < erlang:length(M_6)) of
        true ->
            S_12 = (S_11 ++ list_to_string((case erlang:is_map(M_6) of true -> maps:get(I_37, M_6, nil); _ -> case I_37 < 0 of true -> lists:nth(erlang:length(M_6) + I_37 + 1, M_6); _ -> lists:nth(I_37 + 1, M_6) end end))),
            case (I_37 < (erlang:length(M_6) - 1)) of
        true -> S_13 = (S_12 ++ "; "),
            S_14 = S_13;
        _ -> S_14 = S_12
    end,
            I_38 = (I_37 + 1),
            Fun_36_loop(I_38, M_6, S_14);
        _ -> {I_37, M_6, S_11}
    end
end,
{I_38, M_6, S_14} = Fun_36(I_37, M_6, S_11),
        (S_14 ++ "]")
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('seed', 123456789),
    erlang:put('graph', [[1, 2], [0, 2], [0, 1]]),
    erlang:put('result', find_lanczos_eigenvectors(erlang:get('graph'), 2)),
    io:format("~ts~n", [mochi_repr(list_to_string(maps:get("values", erlang:get('result'), nil)))]),
    io:format("~ts~n", [mochi_repr(matrix_to_string(maps:get("vectors", erlang:get('result'), nil)))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
