#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, tarjan/1, create_graph/2, main/0]).

% Generated by Mochi transpiler v0.10.63 (c4022ac673) on 2025-08-12 08:38 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

tarjan(G) ->
    try
        N = erlang:length(G),
        Stack = [],
        On_stack = [],
        Index_of = [],
        Lowlink_of = [],
        I = 0,
        Fun = fun Fun_loop(G, I, Index_of, Lowlink_of, N, On_stack, Stack) ->
    case (I < N) of
        true ->
            On_stack_2 = lists:append((case On_stack of nil -> []; _ -> On_stack end), [false]),
            Index_of_2 = lists:append((case Index_of of nil -> []; _ -> Index_of end), [(0 - 1)]),
            Lowlink_of_2 = lists:append((case Lowlink_of of nil -> []; _ -> Lowlink_of end), [(0 - 1)]),
            I_2 = (I + 1),
            Fun_loop(G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack);
        _ -> {G, I, Index_of, Lowlink_of, N, On_stack, Stack}
    end
end,
{G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack} = Fun(G, I, Index_of, Lowlink_of, N, On_stack, Stack),
        Components = [],
        Strong_connect = fun Strong_connect(V, Index) ->
    try
        Index_of_3 = lists:sublist(Index_of_2, V) ++ [Index] ++ lists:nthtail(V + 1, Index_of_2),
        Lowlink_of_3 = lists:sublist(Lowlink_of_2, V) ++ [Index] ++ lists:nthtail(V + 1, Lowlink_of_2),
        Current_index = (Index + 1),
        Stack_2 = lists:append((case Stack of nil -> []; _ -> Stack end), [V]),
        On_stack_3 = lists:sublist(On_stack_2, V) ++ [true] ++ lists:nthtail(V + 1, On_stack_2),
        Fun_2 = fun Fun_2_loop(List, Components, Current_index, G, I_2, Index, Index_of_3, Lowlink_of_3, N, On_stack_3, Stack_2, Strong_connect, V) ->
    case List of
        [] -> {Components, Current_index, G, I_2, Index, Index_of_3, Lowlink_of_3, N, On_stack_3, Stack_2, Strong_connect, V};
        [W|W_rest] ->
            case ((case erlang:is_map(Index_of_3) of true -> maps:get(W, Index_of_3, nil); _ -> case W < 0 of true -> mochi_nth(erlang:length(Index_of_3) + W + 1, Index_of_3); _ -> mochi_nth(W + 1, Index_of_3) end end) == (0 - 1)) of
        true -> Current_index_2 = Strong_connect(W, Current_index),
            case ((case erlang:is_map(Lowlink_of_3) of true -> maps:get(W, Lowlink_of_3, nil); _ -> case W < 0 of true -> mochi_nth(erlang:length(Lowlink_of_3) + W + 1, Lowlink_of_3); _ -> mochi_nth(W + 1, Lowlink_of_3) end end) < (case erlang:is_map(Lowlink_of_3) of true -> maps:get(V, Lowlink_of_3, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(Lowlink_of_3) + V + 1, Lowlink_of_3); _ -> mochi_nth(V + 1, Lowlink_of_3) end end)) of
        true -> Lowlink_of_4 = lists:sublist(Lowlink_of_3, V) ++ [(case erlang:is_map(Lowlink_of_3) of true -> maps:get(W, Lowlink_of_3, nil); _ -> case W < 0 of true -> mochi_nth(erlang:length(Lowlink_of_3) + W + 1, Lowlink_of_3); _ -> mochi_nth(W + 1, Lowlink_of_3) end end)] ++ lists:nthtail(V + 1, Lowlink_of_3),
            Lowlink_of_5 = Lowlink_of_4;
        _ -> Lowlink_of_5 = Lowlink_of_3
    end,
            Current_index_3 = Current_index_2,
            Lowlink_of_9 = Lowlink_of_5;
        _ -> case (case erlang:is_map(On_stack_3) of true -> maps:get(W, On_stack_3, nil); _ -> case W < 0 of true -> mochi_nth(erlang:length(On_stack_3) + W + 1, On_stack_3); _ -> mochi_nth(W + 1, On_stack_3) end end) of
        true -> case ((case erlang:is_map(Lowlink_of_3) of true -> maps:get(W, Lowlink_of_3, nil); _ -> case W < 0 of true -> mochi_nth(erlang:length(Lowlink_of_3) + W + 1, Lowlink_of_3); _ -> mochi_nth(W + 1, Lowlink_of_3) end end) < (case erlang:is_map(Lowlink_of_3) of true -> maps:get(V, Lowlink_of_3, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(Lowlink_of_3) + V + 1, Lowlink_of_3); _ -> mochi_nth(V + 1, Lowlink_of_3) end end)) of
        true -> Lowlink_of_6 = lists:sublist(Lowlink_of_3, V) ++ [(case erlang:is_map(Lowlink_of_3) of true -> maps:get(W, Lowlink_of_3, nil); _ -> case W < 0 of true -> mochi_nth(erlang:length(Lowlink_of_3) + W + 1, Lowlink_of_3); _ -> mochi_nth(W + 1, Lowlink_of_3) end end)] ++ lists:nthtail(V + 1, Lowlink_of_3),
            Lowlink_of_7 = Lowlink_of_6;
        _ -> Lowlink_of_7 = Lowlink_of_3
    end,
            Lowlink_of_8 = Lowlink_of_7;
        _ -> Lowlink_of_8 = Lowlink_of_3
    end,
            Current_index_3 = Current_index,
            Lowlink_of_9 = Lowlink_of_8
    end,
            Fun_2_loop(W_rest, Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_3, Stack_2, Strong_connect, V);
        _ -> {Components, Current_index, G, I_2, Index, Index_of_3, Lowlink_of_3, N, On_stack_3, Stack_2, Strong_connect, V}
    end
end,
{Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_3, Stack_2, Strong_connect, V} = Fun_2((case erlang:is_map(G) of true -> maps:get(V, G, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(G) + V + 1, G); _ -> mochi_nth(V + 1, G) end end), Components, Current_index, G, I_2, Index, Index_of_3, Lowlink_of_3, N, On_stack_3, Stack_2, Strong_connect, V),
        case ((case erlang:is_map(Lowlink_of_9) of true -> maps:get(V, Lowlink_of_9, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(Lowlink_of_9) + V + 1, Lowlink_of_9); _ -> mochi_nth(V + 1, Lowlink_of_9) end end) == (case erlang:is_map(Index_of_3) of true -> maps:get(V, Index_of_3, nil); _ -> case V < 0 of true -> mochi_nth(erlang:length(Index_of_3) + V + 1, Index_of_3); _ -> mochi_nth(V + 1, Index_of_3) end end)) of
        true -> Component = [],
            W_2 = (case erlang:is_map(Stack_2) of true -> maps:get((erlang:length(Stack_2) - 1), Stack_2, nil); _ -> case (erlang:length(Stack_2) - 1) < 0 of true -> mochi_nth(erlang:length(Stack_2) + (erlang:length(Stack_2) - 1) + 1, Stack_2); _ -> mochi_nth((erlang:length(Stack_2) - 1) + 1, Stack_2) end end),
            Stack_3 = lists:sublist(Stack_2, 0 + 1, ((erlang:length(Stack_2) - 1) - 0)),
            On_stack_4 = lists:sublist(On_stack_3, W_2) ++ [false] ++ lists:nthtail(W_2 + 1, On_stack_3),
            Component_2 = lists:append((case Component of nil -> []; _ -> Component end), [W_2]),
            Fun_3 = fun Fun_3_loop(Component_2, Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_4, Stack_3, Strong_connect, V, W_2) ->
    case (W_2 /= V) of
        true ->
            W_3 = (case erlang:is_map(Stack_3) of true -> maps:get((erlang:length(Stack_3) - 1), Stack_3, nil); _ -> case (erlang:length(Stack_3) - 1) < 0 of true -> mochi_nth(erlang:length(Stack_3) + (erlang:length(Stack_3) - 1) + 1, Stack_3); _ -> mochi_nth((erlang:length(Stack_3) - 1) + 1, Stack_3) end end),
            Stack_4 = lists:sublist(Stack_3, 0 + 1, ((erlang:length(Stack_3) - 1) - 0)),
            On_stack_5 = lists:sublist(On_stack_4, W_3) ++ [false] ++ lists:nthtail(W_3 + 1, On_stack_4),
            Component_3 = lists:append((case Component_2 of nil -> []; _ -> Component_2 end), [W_3]),
            Fun_3_loop(Component_3, Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_5, Stack_4, Strong_connect, V, W_3);
        _ -> {Component_2, Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_4, Stack_3, Strong_connect, V, W_2}
    end
end,
{Component_3, Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_5, Stack_4, Strong_connect, V, W_3} = Fun_3(Component_2, Components, Current_index_3, G, I_2, Index, Index_of_3, Lowlink_of_9, N, On_stack_4, Stack_3, Strong_connect, V, W_2),
            Components_2 = lists:append((case Components of nil -> []; _ -> Components end), [Component_3]),
            Component_4 = Component_3,
            Components_3 = Components_2,
            Fun_4 = Fun_3,
            On_stack_6 = On_stack_5,
            Stack_5 = Stack_4,
            W_4 = W_3;
        _ -> Component_4 = nil,
            Components_3 = Components,
            Fun_4 = Fun_2,
            On_stack_6 = On_stack_3,
            Stack_5 = Stack_2,
            W_4 = nil
    end,
        Current_index_3
    catch {return, RetCatch} -> RetCatch end
end,
        V_2 = 0,
        Fun_5 = fun Fun_5_loop(Components, G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack, Strong_connect, V_2) ->
    case (V_2 < N) of
        true ->
            case ((case erlang:is_map(Index_of_2) of true -> maps:get(V_2, Index_of_2, nil); _ -> case V_2 < 0 of true -> mochi_nth(erlang:length(Index_of_2) + V_2 + 1, Index_of_2); _ -> mochi_nth(V_2 + 1, Index_of_2) end end) == (0 - 1)) of
        true -> Strong_connect(V_2, 0);
        _ -> ok
    end,
            V_3 = (V_2 + 1),
            Fun_5_loop(Components, G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack, Strong_connect, V_3);
        _ -> {Components, G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack, Strong_connect, V_2}
    end
end,
{Components, G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack, Strong_connect, V_3} = Fun_5(Components, G, I_2, Index_of_2, Lowlink_of_2, N, On_stack_2, Stack, Strong_connect, V_2),
        Components
    catch {return, RetCatch} -> RetCatch end.

create_graph(N_2, Edges) ->
    try
        G_2 = [],
        I_3 = 0,
        Fun_6 = fun Fun_6_loop(Edges, G_2, I_3, N_2) ->
    case (I_3 < N_2) of
        true ->
            G_3 = lists:append((case G_2 of nil -> []; _ -> G_2 end), [[]]),
            I_4 = (I_3 + 1),
            Fun_6_loop(Edges, G_3, I_4, N_2);
        _ -> {Edges, G_2, I_3, N_2}
    end
end,
{Edges, G_3, I_4, N_2} = Fun_6(Edges, G_2, I_3, N_2),
        Fun_7 = fun Fun_7_loop(List, Edges, G_3, I_4, N_2) ->
    case List of
        [] -> {Edges, G_3, I_4, N_2};
        [E|E_rest] ->
            U = (case erlang:is_map(E) of true -> maps:get(0, E, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(E) + 0 + 1, E); _ -> mochi_nth(0 + 1, E) end end),
            V_4 = (case erlang:is_map(E) of true -> maps:get(1, E, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(E) + 1 + 1, E); _ -> mochi_nth(1 + 1, E) end end),
            G_4 = lists:sublist(G_3, U) ++ [lists:append((case (case erlang:is_map(G_3) of true -> maps:get(U, G_3, nil); _ -> case U < 0 of true -> mochi_nth(erlang:length(G_3) + U + 1, G_3); _ -> mochi_nth(U + 1, G_3) end end) of nil -> []; _ -> (case erlang:is_map(G_3) of true -> maps:get(U, G_3, nil); _ -> case U < 0 of true -> mochi_nth(erlang:length(G_3) + U + 1, G_3); _ -> mochi_nth(U + 1, G_3) end end) end), [V_4])] ++ lists:nthtail(U + 1, G_3),
            Fun_7_loop(E_rest, Edges, G_4, I_4, N_2);
        _ -> {Edges, G_3, I_4, N_2}
    end
end,
{Edges, G_4, I_4, N_2} = Fun_7(Edges, Edges, G_3, I_4, N_2),
        G_4
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        N_vertices = 7,
        Source = [0, 0, 1, 2, 3, 3, 4, 4, 6],
        Target = [1, 3, 2, 0, 1, 4, 5, 6, 5],
        Edges_2 = [],
        I_5 = 0,
        Fun_8 = fun Fun_8_loop(Edges_2, I_5, N_vertices, Source, Target) ->
    case (I_5 < erlang:length(Source)) of
        true ->
            Edges_3 = lists:append((case Edges_2 of nil -> []; _ -> Edges_2 end), [[(case erlang:is_map(Source) of true -> maps:get(I_5, Source, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Source) + I_5 + 1, Source); _ -> mochi_nth(I_5 + 1, Source) end end), (case erlang:is_map(Target) of true -> maps:get(I_5, Target, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Target) + I_5 + 1, Target); _ -> mochi_nth(I_5 + 1, Target) end end)]]),
            I_6 = (I_5 + 1),
            Fun_8_loop(Edges_3, I_6, N_vertices, Source, Target);
        _ -> {Edges_2, I_5, N_vertices, Source, Target}
    end
end,
{Edges_3, I_6, N_vertices, Source, Target} = Fun_8(Edges_2, I_5, N_vertices, Source, Target),
        G_5 = create_graph(N_vertices, Edges_3),
        io:format("~ts~n", [mochi_str(tarjan(G_5))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
