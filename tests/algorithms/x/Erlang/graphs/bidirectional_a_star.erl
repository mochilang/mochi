#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, abs/1, sqrtapprox/1, heuristic/2, pos_equal/2, contains_pos/2, open_index_of_pos/2, remove_node_at/2, append_pos_list/2, reverse_pos_list/1, concat_pos_lists/2, get_successors/1, find_lowest_f/1, astar/2, combine_paths/2, bidirectional_astar/2, path_to_string/1]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

abs(X) ->
    try
        (case (X < 0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

sqrtapprox(X_2) ->
    try
        case (X_2 =< 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        Guess = X_2,
        I = 0,
        Fun = fun Fun_loop(Guess, I, X_2) ->
    case (I < 10) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X_2, Guess)), 2),
            I_2 = (I + 1),
            Fun_loop(Guess_2, I_2, X_2);
        _ -> {Guess, I, X_2}
    end
end,
{Guess_2, I_2, X_2} = Fun(Guess, I, X_2),
        Guess_2
    catch {return, Ret} -> Ret end.

heuristic(A, B) ->
    try
        Dy = (maps:get("y", A, nil) - maps:get("y", B, nil)),
        Dx = (maps:get("x", A, nil) - maps:get("x", B, nil)),
        case (0 == 1) of
        true -> throw({return, float((erlang:abs(Dy) + erlang:abs(Dx)))});
        _ -> ok
    end,
        Dyf = float(Dy),
        Dxf = float(Dx),
        sqrtapprox((mochi_safe_mul(Dyf, Dyf) + mochi_safe_mul(Dxf, Dxf)))
    catch {return, Ret} -> Ret end.

pos_equal(A_2, B_2) ->
    try
        ((maps:get("y", A_2, nil) == maps:get("y", B_2, nil)) andalso (maps:get("x", A_2, nil) == maps:get("x", B_2, nil)))
    catch {return, Ret} -> Ret end.

contains_pos(Lst, P) ->
    try
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Lst, P) ->
    case (I_3 < erlang:length(Lst)) of
        true ->
            case pos_equal((case erlang:is_map(Lst) of true -> maps:get(I_3, Lst, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Lst) + I_3 + 1, Lst); _ -> lists:nth(I_3 + 1, Lst) end end), P) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Lst, P);
        _ -> {I_3, Lst, P}
    end
end,
{I_4, Lst, P} = Fun_2(I_3, Lst, P),
        false
    catch {return, Ret} -> Ret end.

open_index_of_pos(Open, P_2) ->
    try
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Open, P_2) ->
    case (I_5 < erlang:length(Open)) of
        true ->
            case pos_equal(maps:get("pos", (case erlang:is_map(Open) of true -> maps:get(I_5, Open, nil); _ -> case I_5 < 0 of true -> lists:nth(erlang:length(Open) + I_5 + 1, Open); _ -> lists:nth(I_5 + 1, Open) end end), nil), P_2) of
        true -> throw({return, I_5});
        _ -> ok
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Open, P_2);
        _ -> {I_5, Open, P_2}
    end
end,
{I_6, Open, P_2} = Fun_3(I_5, Open, P_2),
        (0 - 1)
    catch {return, Ret} -> Ret end.

remove_node_at(Nodes, Idx) ->
    try
        Res = [],
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(I_7, Idx, Nodes, Res) ->
    case (I_7 < erlang:length(Nodes)) of
        true ->
            case (I_7 /= Idx) of
        true -> Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(case erlang:is_map(Nodes) of true -> maps:get(I_7, Nodes, nil); _ -> case I_7 < 0 of true -> lists:nth(erlang:length(Nodes) + I_7 + 1, Nodes); _ -> lists:nth(I_7 + 1, Nodes) end end)]),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            I_8 = (I_7 + 1),
            Fun_4_loop(I_8, Idx, Nodes, Res_3);
        _ -> {I_7, Idx, Nodes, Res}
    end
end,
{I_8, Idx, Nodes, Res_3} = Fun_4(I_7, Idx, Nodes, Res),
        Res_3
    catch {return, Ret} -> Ret end.

append_pos_list(Path, P_3) ->
    try
        Res_4 = [],
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(I_9, P_3, Path, Res_4) ->
    case (I_9 < erlang:length(Path)) of
        true ->
            Res_5 = lists:append((case Res_4 of nil -> []; _ -> Res_4 end), [(case erlang:is_map(Path) of true -> maps:get(I_9, Path, nil); _ -> case I_9 < 0 of true -> lists:nth(erlang:length(Path) + I_9 + 1, Path); _ -> lists:nth(I_9 + 1, Path) end end)]),
            I_10 = (I_9 + 1),
            Fun_5_loop(I_10, P_3, Path, Res_5);
        _ -> {I_9, P_3, Path, Res_4}
    end
end,
{I_10, P_3, Path, Res_5} = Fun_5(I_9, P_3, Path, Res_4),
        Res_6 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [P_3]),
        Res_6
    catch {return, Ret} -> Ret end.

reverse_pos_list(Lst_2) ->
    try
        Res_7 = [],
        I_11 = (erlang:length(Lst_2) - 1),
        Fun_6 = fun Fun_6_loop(I_11, Lst_2, Res_7) ->
    case (I_11 >= 0) of
        true ->
            Res_8 = lists:append((case Res_7 of nil -> []; _ -> Res_7 end), [(case erlang:is_map(Lst_2) of true -> maps:get(I_11, Lst_2, nil); _ -> case I_11 < 0 of true -> lists:nth(erlang:length(Lst_2) + I_11 + 1, Lst_2); _ -> lists:nth(I_11 + 1, Lst_2) end end)]),
            I_12 = (I_11 - 1),
            Fun_6_loop(I_12, Lst_2, Res_8);
        _ -> {I_11, Lst_2, Res_7}
    end
end,
{I_12, Lst_2, Res_8} = Fun_6(I_11, Lst_2, Res_7),
        Res_8
    catch {return, Ret} -> Ret end.

concat_pos_lists(A_3, B_3) ->
    try
        Res_9 = [],
        I_13 = 0,
        Fun_7 = fun Fun_7_loop(A_3, B_3, I_13, Res_9) ->
    case (I_13 < erlang:length(A_3)) of
        true ->
            Res_10 = lists:append((case Res_9 of nil -> []; _ -> Res_9 end), [(case erlang:is_map(A_3) of true -> maps:get(I_13, A_3, nil); _ -> case I_13 < 0 of true -> lists:nth(erlang:length(A_3) + I_13 + 1, A_3); _ -> lists:nth(I_13 + 1, A_3) end end)]),
            I_14 = (I_13 + 1),
            Fun_7_loop(A_3, B_3, I_14, Res_10);
        _ -> {A_3, B_3, I_13, Res_9}
    end
end,
{A_3, B_3, I_14, Res_10} = Fun_7(A_3, B_3, I_13, Res_9),
        J = 0,
        Fun_8 = fun Fun_8_loop(A_3, B_3, I_14, J, Res_10) ->
    case (J < erlang:length(B_3)) of
        true ->
            Res_11 = lists:append((case Res_10 of nil -> []; _ -> Res_10 end), [(case erlang:is_map(B_3) of true -> maps:get(J, B_3, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(B_3) + J + 1, B_3); _ -> lists:nth(J + 1, B_3) end end)]),
            J_2 = (J + 1),
            Fun_8_loop(A_3, B_3, I_14, J_2, Res_11);
        _ -> {A_3, B_3, I_14, J, Res_10}
    end
end,
{A_3, B_3, I_14, J_2, Res_11} = Fun_8(A_3, B_3, I_14, J, Res_10),
        Res_11
    catch {return, Ret} -> Ret end.

get_successors(P_4) ->
    try
        Res_12 = [],
        I_15 = 0,
        Fun_9 = fun Fun_9_loop(I_15, P_4, Res_12) ->
    case (I_15 < erlang:length(erlang:get('delta'))) of
        true ->
            Nx = (maps:get("x", P_4, nil) + (case erlang:is_map((case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)) of true -> maps:get(1, (case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end), nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)) + 1 + 1, (case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)); _ -> lists:nth(1 + 1, (case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)) end end)),
            Ny = (maps:get("y", P_4, nil) + (case erlang:is_map((case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)) of true -> maps:get(0, (case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end), nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)) + 0 + 1, (case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)); _ -> lists:nth(0 + 1, (case erlang:is_map(erlang:get('delta')) of true -> maps:get(I_15, erlang:get('delta'), nil); _ -> case I_15 < 0 of true -> lists:nth(erlang:length(erlang:get('delta')) + I_15 + 1, erlang:get('delta')); _ -> lists:nth(I_15 + 1, erlang:get('delta')) end end)) end end)),
            case ((((Nx >= 0) andalso (Ny >= 0)) andalso (Nx < erlang:length((case erlang:is_map(erlang:get('grid')) of true -> maps:get(0, erlang:get('grid'), nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + 0 + 1, erlang:get('grid')); _ -> lists:nth(0 + 1, erlang:get('grid')) end end)))) andalso (Ny < erlang:length(erlang:get('grid')))) of
        true -> case ((case erlang:is_map((case erlang:is_map(erlang:get('grid')) of true -> maps:get(Ny, erlang:get('grid'), nil); _ -> case Ny < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + Ny + 1, erlang:get('grid')); _ -> lists:nth(Ny + 1, erlang:get('grid')) end end)) of true -> maps:get(Nx, (case erlang:is_map(erlang:get('grid')) of true -> maps:get(Ny, erlang:get('grid'), nil); _ -> case Ny < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + Ny + 1, erlang:get('grid')); _ -> lists:nth(Ny + 1, erlang:get('grid')) end end), nil); _ -> case Nx < 0 of true -> lists:nth(erlang:length((case erlang:is_map(erlang:get('grid')) of true -> maps:get(Ny, erlang:get('grid'), nil); _ -> case Ny < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + Ny + 1, erlang:get('grid')); _ -> lists:nth(Ny + 1, erlang:get('grid')) end end)) + Nx + 1, (case erlang:is_map(erlang:get('grid')) of true -> maps:get(Ny, erlang:get('grid'), nil); _ -> case Ny < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + Ny + 1, erlang:get('grid')); _ -> lists:nth(Ny + 1, erlang:get('grid')) end end)); _ -> lists:nth(Nx + 1, (case erlang:is_map(erlang:get('grid')) of true -> maps:get(Ny, erlang:get('grid'), nil); _ -> case Ny < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + Ny + 1, erlang:get('grid')); _ -> lists:nth(Ny + 1, erlang:get('grid')) end end)) end end) == 0) of
        true -> Res_13 = lists:append((case Res_12 of nil -> []; _ -> Res_12 end), [#{"y" => Ny, "x" => Nx}]),
            Res_14 = Res_13;
        _ -> Res_14 = Res_12
    end,
            Res_15 = Res_14;
        _ -> Res_15 = Res_12
    end,
            I_16 = (I_15 + 1),
            Fun_9_loop(I_16, P_4, Res_15);
        _ -> {I_15, P_4, Res_12}
    end
end,
{I_16, P_4, Res_15} = Fun_9(I_15, P_4, Res_12),
        Res_15
    catch {return, Ret} -> Ret end.

find_lowest_f(Open_2) ->
    try
        Best = 0,
        I_17 = 1,
        Fun_10 = fun Fun_10_loop(Best, I_17, Open_2) ->
    case (I_17 < erlang:length(Open_2)) of
        true ->
            case (maps:get("f_cost", (case erlang:is_map(Open_2) of true -> maps:get(I_17, Open_2, nil); _ -> case I_17 < 0 of true -> lists:nth(erlang:length(Open_2) + I_17 + 1, Open_2); _ -> lists:nth(I_17 + 1, Open_2) end end), nil) < maps:get("f_cost", (case erlang:is_map(Open_2) of true -> maps:get(Best, Open_2, nil); _ -> case Best < 0 of true -> lists:nth(erlang:length(Open_2) + Best + 1, Open_2); _ -> lists:nth(Best + 1, Open_2) end end), nil)) of
        true -> Best_2 = I_17,
            Best_3 = Best_2;
        _ -> Best_3 = Best
    end,
            I_18 = (I_17 + 1),
            Fun_10_loop(Best_3, I_18, Open_2);
        _ -> {Best, I_17, Open_2}
    end
end,
{Best_3, I_18, Open_2} = Fun_10(Best, I_17, Open_2),
        Best_3
    catch {return, Ret} -> Ret end.

astar(Start, Goal) ->
    try
        H0 = heuristic(Start, Goal),
        Open_3 = [#{"pos" => Start, "g_cost" => 0, "h_cost" => H0, "f_cost" => H0, "path" => [Start]}],
        Closed = [],
        Fun_12 = fun Fun_12_loop(Closed, Goal, H0, Open_3, Start) ->
    case (erlang:length(Open_3) > 0) of
        true ->
            try
                Idx_2 = find_lowest_f(Open_3),
                Current = (case erlang:is_map(Open_3) of true -> maps:get(Idx_2, Open_3, nil); _ -> case Idx_2 < 0 of true -> lists:nth(erlang:length(Open_3) + Idx_2 + 1, Open_3); _ -> lists:nth(Idx_2 + 1, Open_3) end end),
                Open_4 = remove_node_at(Open_3, Idx_2),
                case pos_equal(maps:get("pos", Current, nil), Goal) of
        true -> throw({return, maps:get("path", Current, nil)});
        _ -> ok
    end,
                Closed_2 = lists:append((case Closed of nil -> []; _ -> Closed end), [maps:get("pos", Current, nil)]),
                Succ = get_successors(maps:get("pos", Current, nil)),
                I_19 = 0,
                Fun_11 = fun Fun_11_loop(Closed_2, Current, Goal, H0, I_19, Idx_2, Open_4, Start, Succ) ->
    case (I_19 < erlang:length(Succ)) of
        true ->
            try
                Pos = (case erlang:is_map(Succ) of true -> maps:get(I_19, Succ, nil); _ -> case I_19 < 0 of true -> lists:nth(erlang:length(Succ) + I_19 + 1, Succ); _ -> lists:nth(I_19 + 1, Succ) end end),
                case contains_pos(Closed_2, Pos) of
        true -> I_20 = (I_19 + 1),
            throw({continue, Closed_2, Current, Goal, H0, I_20, Idx_2, Open_4, Start, Succ}),
            I_21 = I_20;
        _ -> I_21 = I_19
    end,
                Tentative_g = (maps:get("g_cost", Current, nil) + 1),
                Idx_open = open_index_of_pos(Open_4, Pos),
                case ((Idx_open == (0 - 1)) orelse (Tentative_g < maps:get("g_cost", (case erlang:is_map(Open_4) of true -> maps:get(Idx_open, Open_4, nil); _ -> case Idx_open < 0 of true -> lists:nth(erlang:length(Open_4) + Idx_open + 1, Open_4); _ -> lists:nth(Idx_open + 1, Open_4) end end), nil))) of
        true -> New_path = append_pos_list(maps:get("path", Current, nil), Pos),
            H = heuristic(Pos, Goal),
            F = (float(Tentative_g) + H),
            case (Idx_open /= (0 - 1)) of
        true -> Open_5 = remove_node_at(Open_4, Idx_open),
            Open_6 = Open_5;
        _ -> Open_6 = Open_4
    end,
            Open_7 = lists:append((case Open_6 of nil -> []; _ -> Open_6 end), [#{"pos" => Pos, "g_cost" => Tentative_g, "h_cost" => H, "f_cost" => F, "path" => New_path}]),
            F_2 = F,
            H_2 = H,
            New_path_2 = New_path,
            Open_8 = Open_7;
        _ -> F_2 = nil,
            H_2 = nil,
            New_path_2 = nil,
            Open_8 = Open_4
    end,
                I_22 = (I_21 + 1),
                Fun_11_loop(Closed_2, Current, Goal, H0, I_22, Idx_2, Open_8, Start, Succ)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_11_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8}
            end;
        _ -> {Closed_2, Current, Goal, H0, I_19, Idx_2, Open_4, Start, Succ}
    end
end,
{Closed_2, Current, Goal, H0, I_22, Idx_2, Open_8, Start, Succ} = Fun_11(Closed_2, Current, Goal, H0, I_19, Idx_2, Open_4, Start, Succ),
                Fun_12_loop(Closed_2, Goal, H0, Open_8, Start)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_12_loop(C0, C1, C2, C3, C4);
                {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4}
            end;
        _ -> {Closed, Goal, H0, Open_3, Start}
    end
end,
{Closed_2, Goal, H0, Open_8, Start} = Fun_12(Closed, Goal, H0, Open_3, Start),
        [Start]
    catch {return, Ret} -> Ret end.

combine_paths(Fwd, Bwd) ->
    try
        Bwd_copy = [],
        I_23 = 0,
        Fun_13 = fun Fun_13_loop(Bwd, Bwd_copy, Fwd, I_23) ->
    case (I_23 < (erlang:length(maps:get("path", Bwd, nil)) - 1)) of
        true ->
            Bwd_copy_2 = lists:append((case Bwd_copy of nil -> []; _ -> Bwd_copy end), [(case erlang:is_map(maps:get("path", Bwd, nil)) of true -> maps:get(I_23, maps:get("path", Bwd, nil), nil); _ -> case I_23 < 0 of true -> lists:nth(erlang:length(maps:get("path", Bwd, nil)) + I_23 + 1, maps:get("path", Bwd, nil)); _ -> lists:nth(I_23 + 1, maps:get("path", Bwd, nil)) end end)]),
            I_24 = (I_23 + 1),
            Fun_13_loop(Bwd, Bwd_copy_2, Fwd, I_24);
        _ -> {Bwd, Bwd_copy, Fwd, I_23}
    end
end,
{Bwd, Bwd_copy_2, Fwd, I_24} = Fun_13(Bwd, Bwd_copy, Fwd, I_23),
        Bwd_copy_3 = reverse_pos_list(Bwd_copy_2),
        concat_pos_lists(maps:get("path", Fwd, nil), Bwd_copy_3)
    catch {return, Ret} -> Ret end.

bidirectional_astar(Start_2, Goal_2) ->
    try
        Hf = heuristic(Start_2, Goal_2),
        Hb = heuristic(Goal_2, Start_2),
        Open_f = [#{"pos" => Start_2, "g_cost" => 0, "h_cost" => Hf, "f_cost" => Hf, "path" => [Start_2]}],
        Open_b = [#{"pos" => Goal_2, "g_cost" => 0, "h_cost" => Hb, "f_cost" => Hb, "path" => [Goal_2]}],
        Closed_f = [],
        Closed_b = [],
        Fun_16 = fun Fun_16_loop(Closed_b, Closed_f, Goal_2, Hb, Hf, Open_b, Open_f, Start_2) ->
    case ((erlang:length(Open_f) > 0) andalso (erlang:length(Open_b) > 0)) of
        true ->
            try
                Idx_f = find_lowest_f(Open_f),
                Current_f = (case erlang:is_map(Open_f) of true -> maps:get(Idx_f, Open_f, nil); _ -> case Idx_f < 0 of true -> lists:nth(erlang:length(Open_f) + Idx_f + 1, Open_f); _ -> lists:nth(Idx_f + 1, Open_f) end end),
                Open_f_2 = remove_node_at(Open_f, Idx_f),
                Idx_b = find_lowest_f(Open_b),
                Current_b = (case erlang:is_map(Open_b) of true -> maps:get(Idx_b, Open_b, nil); _ -> case Idx_b < 0 of true -> lists:nth(erlang:length(Open_b) + Idx_b + 1, Open_b); _ -> lists:nth(Idx_b + 1, Open_b) end end),
                Open_b_2 = remove_node_at(Open_b, Idx_b),
                case pos_equal(maps:get("pos", Current_f, nil), maps:get("pos", Current_b, nil)) of
        true -> throw({return, combine_paths(Current_f, Current_b)});
        _ -> ok
    end,
                Closed_f_2 = lists:append((case Closed_f of nil -> []; _ -> Closed_f end), [maps:get("pos", Current_f, nil)]),
                Closed_b_2 = lists:append((case Closed_b of nil -> []; _ -> Closed_b end), [maps:get("pos", Current_b, nil)]),
                Succ_f = get_successors(maps:get("pos", Current_f, nil)),
                I_25 = 0,
                Fun_14 = fun Fun_14_loop(Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_25, Idx_b, Idx_f, Open_b_2, Open_f_2, Start_2, Succ_f) ->
    case (I_25 < erlang:length(Succ_f)) of
        true ->
            try
                Pos_2 = (case erlang:is_map(Succ_f) of true -> maps:get(I_25, Succ_f, nil); _ -> case I_25 < 0 of true -> lists:nth(erlang:length(Succ_f) + I_25 + 1, Succ_f); _ -> lists:nth(I_25 + 1, Succ_f) end end),
                case contains_pos(Closed_f_2, Pos_2) of
        true -> I_26 = (I_25 + 1),
            throw({continue, Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_26, Idx_b, Idx_f, Open_b_2, Open_f_2, Start_2, Succ_f}),
            I_27 = I_26;
        _ -> I_27 = I_25
    end,
                Tentative_g_2 = (maps:get("g_cost", Current_f, nil) + 1),
                H_3 = heuristic(Pos_2, maps:get("pos", Current_b, nil)),
                F_3 = (float(Tentative_g_2) + H_3),
                Idx_open_2 = open_index_of_pos(Open_f_2, Pos_2),
                case ((Idx_open_2 == (0 - 1)) orelse (Tentative_g_2 < maps:get("g_cost", (case erlang:is_map(Open_f_2) of true -> maps:get(Idx_open_2, Open_f_2, nil); _ -> case Idx_open_2 < 0 of true -> lists:nth(erlang:length(Open_f_2) + Idx_open_2 + 1, Open_f_2); _ -> lists:nth(Idx_open_2 + 1, Open_f_2) end end), nil))) of
        true -> New_path_3 = append_pos_list(maps:get("path", Current_f, nil), Pos_2),
            case (Idx_open_2 /= (0 - 1)) of
        true -> Open_f_3 = remove_node_at(Open_f_2, Idx_open_2),
            Open_f_4 = Open_f_3;
        _ -> Open_f_4 = Open_f_2
    end,
            Open_f_5 = lists:append((case Open_f_4 of nil -> []; _ -> Open_f_4 end), [#{"pos" => Pos_2, "g_cost" => Tentative_g_2, "h_cost" => H_3, "f_cost" => F_3, "path" => New_path_3}]),
            New_path_4 = New_path_3,
            Open_f_6 = Open_f_5;
        _ -> New_path_4 = nil,
            Open_f_6 = Open_f_2
    end,
                I_28 = (I_27 + 1),
                Fun_14_loop(Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_28, Idx_b, Idx_f, Open_b_2, Open_f_6, Start_2, Succ_f)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13} -> Fun_14_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13}
            end;
        _ -> {Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_25, Idx_b, Idx_f, Open_b_2, Open_f_2, Start_2, Succ_f}
    end
end,
{Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_28, Idx_b, Idx_f, Open_b_2, Open_f_6, Start_2, Succ_f} = Fun_14(Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_25, Idx_b, Idx_f, Open_b_2, Open_f_2, Start_2, Succ_f),
                Succ_b = get_successors(maps:get("pos", Current_b, nil)),
                I_29 = 0,
                Fun_15 = fun Fun_15_loop(Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_29, Idx_b, Idx_f, Open_b_2, Open_f_6, Start_2, Succ_b, Succ_f) ->
    case (I_29 < erlang:length(Succ_b)) of
        true ->
            try
                Pos_3 = (case erlang:is_map(Succ_b) of true -> maps:get(I_29, Succ_b, nil); _ -> case I_29 < 0 of true -> lists:nth(erlang:length(Succ_b) + I_29 + 1, Succ_b); _ -> lists:nth(I_29 + 1, Succ_b) end end),
                case contains_pos(Closed_b_2, Pos_3) of
        true -> I_30 = (I_29 + 1),
            throw({continue, Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_30, Idx_b, Idx_f, Open_b_2, Open_f_6, Start_2, Succ_b, Succ_f}),
            I_31 = I_30;
        _ -> I_31 = I_29
    end,
                Tentative_g_3 = (maps:get("g_cost", Current_b, nil) + 1),
                H_4 = heuristic(Pos_3, maps:get("pos", Current_f, nil)),
                F_4 = (float(Tentative_g_3) + H_4),
                Idx_open_3 = open_index_of_pos(Open_b_2, Pos_3),
                case ((Idx_open_3 == (0 - 1)) orelse (Tentative_g_3 < maps:get("g_cost", (case erlang:is_map(Open_b_2) of true -> maps:get(Idx_open_3, Open_b_2, nil); _ -> case Idx_open_3 < 0 of true -> lists:nth(erlang:length(Open_b_2) + Idx_open_3 + 1, Open_b_2); _ -> lists:nth(Idx_open_3 + 1, Open_b_2) end end), nil))) of
        true -> New_path_5 = append_pos_list(maps:get("path", Current_b, nil), Pos_3),
            case (Idx_open_3 /= (0 - 1)) of
        true -> Open_b_3 = remove_node_at(Open_b_2, Idx_open_3),
            Open_b_4 = Open_b_3;
        _ -> Open_b_4 = Open_b_2
    end,
            Open_b_5 = lists:append((case Open_b_4 of nil -> []; _ -> Open_b_4 end), [#{"pos" => Pos_3, "g_cost" => Tentative_g_3, "h_cost" => H_4, "f_cost" => F_4, "path" => New_path_5}]),
            New_path_6 = New_path_5,
            Open_b_6 = Open_b_5;
        _ -> New_path_6 = nil,
            Open_b_6 = Open_b_2
    end,
                I_32 = (I_31 + 1),
                Fun_15_loop(Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_32, Idx_b, Idx_f, Open_b_6, Open_f_6, Start_2, Succ_b, Succ_f)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14} -> Fun_15_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14}
            end;
        _ -> {Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_29, Idx_b, Idx_f, Open_b_2, Open_f_6, Start_2, Succ_b, Succ_f}
    end
end,
{Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_32, Idx_b, Idx_f, Open_b_6, Open_f_6, Start_2, Succ_b, Succ_f} = Fun_15(Closed_b_2, Closed_f_2, Current_b, Current_f, Goal_2, Hb, Hf, I_29, Idx_b, Idx_f, Open_b_2, Open_f_6, Start_2, Succ_b, Succ_f),
                Fun_16_loop(Closed_b_2, Closed_f_2, Goal_2, Hb, Hf, Open_b_6, Open_f_6, Start_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_16_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                {break, B0, B1, B2, B3, B4, B5, B6, B7} -> {B0, B1, B2, B3, B4, B5, B6, B7}
            end;
        _ -> {Closed_b, Closed_f, Goal_2, Hb, Hf, Open_b, Open_f, Start_2}
    end
end,
{Closed_b_2, Closed_f_2, Goal_2, Hb, Hf, Open_b_6, Open_f_6, Start_2} = Fun_16(Closed_b, Closed_f, Goal_2, Hb, Hf, Open_b, Open_f, Start_2),
        [Start_2]
    catch {return, Ret} -> Ret end.

path_to_string(Path_2) ->
    try
        case (erlang:length(Path_2) == 0) of
        true -> throw({return, "[]"});
        _ -> ok
    end,
        S = (((("[(" ++ mochi_str(maps:get("y", (case erlang:is_map(Path_2) of true -> maps:get(0, Path_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Path_2) + 0 + 1, Path_2); _ -> lists:nth(0 + 1, Path_2) end end), nil))) ++ ", ") ++ mochi_str(maps:get("x", (case erlang:is_map(Path_2) of true -> maps:get(0, Path_2, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Path_2) + 0 + 1, Path_2); _ -> lists:nth(0 + 1, Path_2) end end), nil))) ++ ")"),
        I_33 = 1,
        Fun_17 = fun Fun_17_loop(I_33, Path_2, S) ->
    case (I_33 < erlang:length(Path_2)) of
        true ->
            S_2 = (((((S ++ ", (") ++ mochi_str(maps:get("y", (case erlang:is_map(Path_2) of true -> maps:get(I_33, Path_2, nil); _ -> case I_33 < 0 of true -> lists:nth(erlang:length(Path_2) + I_33 + 1, Path_2); _ -> lists:nth(I_33 + 1, Path_2) end end), nil))) ++ ", ") ++ mochi_str(maps:get("x", (case erlang:is_map(Path_2) of true -> maps:get(I_33, Path_2, nil); _ -> case I_33 < 0 of true -> lists:nth(erlang:length(Path_2) + I_33 + 1, Path_2); _ -> lists:nth(I_33 + 1, Path_2) end end), nil))) ++ ")"),
            I_34 = (I_33 + 1),
            Fun_17_loop(I_34, Path_2, S_2);
        _ -> {I_33, Path_2, S}
    end
end,
{I_34, Path_2, S_2} = Fun_17(I_33, Path_2, S),
        S_3 = (S_2 ++ "]"),
        S_3
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('HEURISTIC', 0),
    erlang:put('grid', [[0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0]]),
    erlang:put('delta', [[-1, 0], [0, -1], [1, 0], [0, 1]]),
    erlang:put('start', #{"y" => 0, "x" => 0}),
    erlang:put('goal', #{"y" => (erlang:length(erlang:get('grid')) - 1), "x" => (erlang:length((case erlang:is_map(erlang:get('grid')) of true -> maps:get(0, erlang:get('grid'), nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(erlang:get('grid')) + 0 + 1, erlang:get('grid')); _ -> lists:nth(0 + 1, erlang:get('grid')) end end)) - 1)}),
    erlang:put('path1', astar(erlang:get('start'), erlang:get('goal'))),
    io:format("~ts~n", [mochi_repr(path_to_string(erlang:get('path1')))]),
    erlang:put('path2', bidirectional_astar(erlang:get('start'), erlang:get('goal'))),
    io:format("~ts~n", [mochi_repr(path_to_string(erlang:get('path2')))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
