#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, ord/1, to_little_endian/1, int_to_bits/2, bits_to_int/1, to_hex/1, reformat_hex/1, preprocess/1, get_block_words/1, bit_and/2, bit_or/2, bit_xor/2, not_32/1, sum_32/2, lshift/2, rshift/2, left_rotate_32/2, md5_me/1]).

% Generated by Mochi transpiler v0.10.59 (589dcb03e5) on 2025-08-07 12:04 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_mod(A, B) when B =/= 0 ->
    ((A rem B) + B) rem B;
mochi_mod(_, _) -> 0.

ord(Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I) ->
    case (I < erlang:length(" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~")) of
        true ->
            case (string:substr(" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, (32 + I)});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2);
        _ -> {Ch, I}
    end
end,
{Ch, I_2} = Fun(Ch, I),
        0
    catch {return, Ret} -> Ret end.

to_little_endian(S) ->
    try
        case (erlang:length(S) /= 32) of
        true -> erlang:error("Input must be of length 32");
        _ -> ok
    end,
        (((string:substr(S, 24 + 1, (32 - 24)) ++ string:substr(S, 16 + 1, (24 - 16))) ++ string:substr(S, 8 + 1, (16 - 8))) ++ string:substr(S, 0 + 1, (8 - 0)))
    catch {return, Ret} -> Ret end.

int_to_bits(N, Width) ->
    try
        Bits = "",
        Num = N,
        Fun_2 = fun Fun_2_loop(Bits, N, Num, Width) ->
    case (Num > 0) of
        true ->
            Bits_2 = (mochi_str(mochi_mod(Num, 2)) ++ Bits),
            Num_2 = (Num div 2),
            Fun_2_loop(Bits_2, N, Num_2, Width);
        _ -> {Bits, N, Num, Width}
    end
end,
{Bits_2, N, Num_2, Width} = Fun_2(Bits, N, Num, Width),
        Fun_3 = fun Fun_3_loop(Bits_2, N, Num_2, Width) ->
    case (erlang:length(Bits_2) < Width) of
        true ->
            Bits_3 = ("0" ++ Bits_2),
            Fun_3_loop(Bits_3, N, Num_2, Width);
        _ -> {Bits_2, N, Num_2, Width}
    end
end,
{Bits_3, N, Num_2, Width} = Fun_3(Bits_2, N, Num_2, Width),
        case (erlang:length(Bits_3) > Width) of
        true -> Bits_4 = string:substr(Bits_3, (erlang:length(Bits_3) - Width) + 1, (erlang:length(Bits_3) - (erlang:length(Bits_3) - Width))),
            Bits_5 = Bits_4;
        _ -> Bits_5 = Bits_3
    end,
        Bits_5
    catch {return, Ret} -> Ret end.

bits_to_int(Bits_6) ->
    try
        Num_3 = 0,
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Bits_6, I_3, Num_3) ->
    case (I_3 < erlang:length(Bits_6)) of
        true ->
            case (string:substr(Bits_6, I_3 + 1, ((I_3 + 1) - I_3)) == "1") of
        true -> Num_4 = ((Num_3 * 2) + 1),
            Num_6 = Num_4;
        _ -> Num_5 = (Num_3 * 2),
            Num_6 = Num_5
    end,
            I_4 = (I_3 + 1),
            Fun_4_loop(Bits_6, I_4, Num_6);
        _ -> {Bits_6, I_3, Num_3}
    end
end,
{Bits_6, I_4, Num_6} = Fun_4(Bits_6, I_3, Num_3),
        Num_6
    catch {return, Ret} -> Ret end.

to_hex(N_2) ->
    try
        Digits = "0123456789abcdef",
        case (N_2 == 0) of
        true -> throw({return, "0"});
        _ -> ok
    end,
        Num_7 = N_2,
        S_2 = "",
        Fun_5 = fun Fun_5_loop(Digits, N_2, Num_7, S_2) ->
    case (Num_7 > 0) of
        true ->
            D = mochi_mod(Num_7, 16),
            S_3 = (string:substr(Digits, D + 1, ((D + 1) - D)) ++ S_2),
            Num_8 = (Num_7 div 16),
            Fun_5_loop(Digits, N_2, Num_8, S_3);
        _ -> {Digits, N_2, Num_7, S_2}
    end
end,
{Digits, N_2, Num_8, S_3} = Fun_5(Digits, N_2, Num_7, S_2),
        S_3
    catch {return, Ret} -> Ret end.

reformat_hex(I_5) ->
    try
        case (I_5 < 0) of
        true -> erlang:error("Input must be non-negative");
        _ -> ok
    end,
        Hex = to_hex(I_5),
        Fun_6 = fun Fun_6_loop(Hex, I_5) ->
    case (erlang:length(Hex) < 8) of
        true ->
            Hex_2 = ("0" ++ Hex),
            Fun_6_loop(Hex_2, I_5);
        _ -> {Hex, I_5}
    end
end,
{Hex_2, I_5} = Fun_6(Hex, I_5),
        case (erlang:length(Hex_2) > 8) of
        true -> Hex_3 = string:substr(Hex_2, (erlang:length(Hex_2) - 8) + 1, (erlang:length(Hex_2) - (erlang:length(Hex_2) - 8))),
            Hex_4 = Hex_3;
        _ -> Hex_4 = Hex_2
    end,
        Le = "",
        J = (erlang:length(Hex_4) - 2),
        Fun_7 = fun Fun_7_loop(Hex_4, I_5, J, Le) ->
    case (J >= 0) of
        true ->
            Le_2 = (Le ++ string:substr(Hex_4, J + 1, ((J + 2) - J))),
            J_2 = (J - 2),
            Fun_7_loop(Hex_4, I_5, J_2, Le_2);
        _ -> {Hex_4, I_5, J, Le}
    end
end,
{Hex_4, I_5, J_2, Le_2} = Fun_7(Hex_4, I_5, J, Le),
        Le_2
    catch {return, Ret} -> Ret end.

preprocess(Message) ->
    try
        Bit_string = "",
        I_6 = 0,
        Fun_8 = fun Fun_8_loop(Bit_string, I_6, Message) ->
    case (I_6 < erlang:length(Message)) of
        true ->
            Ch_2 = string:substr(Message, I_6 + 1, ((I_6 + 1) - I_6)),
            Bit_string_2 = (Bit_string ++ int_to_bits(ord(Ch_2), 8)),
            I_7 = (I_6 + 1),
            Fun_8_loop(Bit_string_2, I_7, Message);
        _ -> {Bit_string, I_6, Message}
    end
end,
{Bit_string_2, I_7, Message} = Fun_8(Bit_string, I_6, Message),
        Start_len = int_to_bits(erlang:length(Bit_string_2), 64),
        Bit_string_3 = (Bit_string_2 ++ "1"),
        Fun_9 = fun Fun_9_loop(Bit_string_3, I_7, Message, Start_len) ->
    case (mochi_mod(erlang:length(Bit_string_3), 512) /= 448) of
        true ->
            Bit_string_4 = (Bit_string_3 ++ "0"),
            Fun_9_loop(Bit_string_4, I_7, Message, Start_len);
        _ -> {Bit_string_3, I_7, Message, Start_len}
    end
end,
{Bit_string_4, I_7, Message, Start_len} = Fun_9(Bit_string_3, I_7, Message, Start_len),
        Bit_string_5 = ((Bit_string_4 ++ to_little_endian(string:substr(Start_len, 32 + 1, (64 - 32)))) ++ to_little_endian(string:substr(Start_len, 0 + 1, (32 - 0)))),
        Bit_string_5
    catch {return, Ret} -> Ret end.

get_block_words(Bit_string_6) ->
    try
        case (mochi_mod(erlang:length(Bit_string_6), 512) /= 0) of
        true -> erlang:error("Input must have length that's a multiple of 512");
        _ -> ok
    end,
        Blocks = [],
        Pos = 0,
        Fun_11 = fun Fun_11_loop(Bit_string_6, Blocks, Pos) ->
    case (Pos < erlang:length(Bit_string_6)) of
        true ->
            Block = [],
            I_8 = 0,
            Fun_10 = fun Fun_10_loop(Bit_string_6, Block, Blocks, I_8, Pos) ->
    case (I_8 < 512) of
        true ->
            Part = string:substr(Bit_string_6, (Pos + I_8) + 1, (((Pos + I_8) + 32) - (Pos + I_8))),
            Word = bits_to_int(to_little_endian(Part)),
            Block_2 = lists:append((case Block of nil -> []; _ -> Block end), [Word]),
            I_9 = (I_8 + 32),
            Fun_10_loop(Bit_string_6, Block_2, Blocks, I_9, Pos);
        _ -> {Bit_string_6, Block, Blocks, I_8, Pos}
    end
end,
{Bit_string_6, Block_2, Blocks, I_9, Pos} = Fun_10(Bit_string_6, Block, Blocks, I_8, Pos),
            Blocks_2 = lists:append((case Blocks of nil -> []; _ -> Blocks end), [Block_2]),
            Pos_2 = (Pos + 512),
            Fun_11_loop(Bit_string_6, Blocks_2, Pos_2);
        _ -> {Bit_string_6, Blocks, Pos}
    end
end,
{Bit_string_6, Blocks_2, Pos_2} = Fun_11(Bit_string_6, Blocks, Pos),
        Blocks_2
    catch {return, Ret} -> Ret end.

bit_and(A, B) ->
    try
        X = A,
        Y = B,
        Res = 0,
        Bit = 1,
        I_10 = 0,
        Fun_12 = fun Fun_12_loop(A, B, Bit, I_10, Res, X, Y) ->
    case (I_10 < 32) of
        true ->
            case ((mochi_mod(X, 2) == 1) andalso (mochi_mod(Y, 2) == 1)) of
        true -> Res_2 = (Res + Bit),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            X_2 = (X div 2),
            Y_2 = (Y div 2),
            Bit_2 = (Bit * 2),
            I_11 = (I_10 + 1),
            Fun_12_loop(A, B, Bit_2, I_11, Res_3, X_2, Y_2);
        _ -> {A, B, Bit, I_10, Res, X, Y}
    end
end,
{A, B, Bit_2, I_11, Res_3, X_2, Y_2} = Fun_12(A, B, Bit, I_10, Res, X, Y),
        Res_3
    catch {return, Ret} -> Ret end.

bit_or(A_2, B_2) ->
    try
        X_3 = A_2,
        Y_3 = B_2,
        Res_4 = 0,
        Bit_3 = 1,
        I_12 = 0,
        Fun_13 = fun Fun_13_loop(A_2, B_2, Bit_3, I_12, Res_4, X_3, Y_3) ->
    case (I_12 < 32) of
        true ->
            Abit = mochi_mod(X_3, 2),
            Bbit = mochi_mod(Y_3, 2),
            case ((Abit == 1) orelse (Bbit == 1)) of
        true -> Res_5 = (Res_4 + Bit_3),
            Res_6 = Res_5;
        _ -> Res_6 = Res_4
    end,
            X_4 = (X_3 div 2),
            Y_4 = (Y_3 div 2),
            Bit_4 = (Bit_3 * 2),
            I_13 = (I_12 + 1),
            Fun_13_loop(A_2, B_2, Bit_4, I_13, Res_6, X_4, Y_4);
        _ -> {A_2, B_2, Bit_3, I_12, Res_4, X_3, Y_3}
    end
end,
{A_2, B_2, Bit_4, I_13, Res_6, X_4, Y_4} = Fun_13(A_2, B_2, Bit_3, I_12, Res_4, X_3, Y_3),
        Res_6
    catch {return, Ret} -> Ret end.

bit_xor(A_3, B_3) ->
    try
        X_5 = A_3,
        Y_5 = B_3,
        Res_7 = 0,
        Bit_5 = 1,
        I_14 = 0,
        Fun_14 = fun Fun_14_loop(A_3, B_3, Bit_5, I_14, Res_7, X_5, Y_5) ->
    case (I_14 < 32) of
        true ->
            Abit_2 = mochi_mod(X_5, 2),
            Bbit_2 = mochi_mod(Y_5, 2),
            case (mochi_mod((Abit_2 + Bbit_2), 2) == 1) of
        true -> Res_8 = (Res_7 + Bit_5),
            Res_9 = Res_8;
        _ -> Res_9 = Res_7
    end,
            X_6 = (X_5 div 2),
            Y_6 = (Y_5 div 2),
            Bit_6 = (Bit_5 * 2),
            I_15 = (I_14 + 1),
            Fun_14_loop(A_3, B_3, Bit_6, I_15, Res_9, X_6, Y_6);
        _ -> {A_3, B_3, Bit_5, I_14, Res_7, X_5, Y_5}
    end
end,
{A_3, B_3, Bit_6, I_15, Res_9, X_6, Y_6} = Fun_14(A_3, B_3, Bit_5, I_14, Res_7, X_5, Y_5),
        Res_9
    catch {return, Ret} -> Ret end.

not_32(I_16) ->
    try
        case (I_16 < 0) of
        true -> erlang:error("Input must be non-negative");
        _ -> ok
    end,
        (4294967295 - I_16)
    catch {return, Ret} -> Ret end.

sum_32(A_4, B_4) ->
    try
        mochi_mod((A_4 + B_4), 4294967296)
    catch {return, Ret} -> Ret end.

lshift(Num_9, K) ->
    try
        Result = mochi_mod(Num_9, 4294967296),
        I_17 = 0,
        Fun_15 = fun Fun_15_loop(I_17, K, Num_9, Result) ->
    case (I_17 < K) of
        true ->
            Result_2 = mochi_mod((Result * 2), 4294967296),
            I_18 = (I_17 + 1),
            Fun_15_loop(I_18, K, Num_9, Result_2);
        _ -> {I_17, K, Num_9, Result}
    end
end,
{I_18, K, Num_9, Result_2} = Fun_15(I_17, K, Num_9, Result),
        Result_2
    catch {return, Ret} -> Ret end.

rshift(Num_10, K_2) ->
    try
        Result_3 = Num_10,
        I_19 = 0,
        Fun_16 = fun Fun_16_loop(I_19, K_2, Num_10, Result_3) ->
    case (I_19 < K_2) of
        true ->
            Result_4 = (Result_3 div 2),
            I_20 = (I_19 + 1),
            Fun_16_loop(I_20, K_2, Num_10, Result_4);
        _ -> {I_19, K_2, Num_10, Result_3}
    end
end,
{I_20, K_2, Num_10, Result_4} = Fun_16(I_19, K_2, Num_10, Result_3),
        Result_4
    catch {return, Ret} -> Ret end.

left_rotate_32(I_21, Shift) ->
    try
        case (I_21 < 0) of
        true -> erlang:error("Input must be non-negative");
        _ -> ok
    end,
        case (Shift < 0) of
        true -> erlang:error("Shift must be non-negative");
        _ -> ok
    end,
        Left = lshift(I_21, Shift),
        Right = rshift(I_21, (32 - Shift)),
        mochi_mod((Left + Right), 4294967296)
    catch {return, Ret} -> Ret end.

md5_me(Message_2) ->
    try
        Bit_string_7 = preprocess(Message_2),
        Added_consts = [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745],
        Shift_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21],
        A0 = 1732584193,
        B0 = 4023233417,
        C0 = 2562383102,
        D0 = 271733878,
        Blocks_3 = get_block_words(Bit_string_7),
        Bi = 0,
        Fun_18 = fun Fun_18_loop(A0, Added_consts, B0, Bi, Bit_string_7, Blocks_3, C0, D0, Message_2, Shift_amounts) ->
    case (Bi < erlang:length(Blocks_3)) of
        true ->
            Block_3 = (case erlang:is_map(Blocks_3) of true -> maps:get(Bi, Blocks_3, nil); _ -> case Bi < 0 of true -> mochi_nth(erlang:length(Blocks_3) + Bi + 1, Blocks_3); _ -> mochi_nth(Bi + 1, Blocks_3) end end),
            A_5 = A0,
            B_5 = B0,
            C = C0,
            D_2 = D0,
            I_22 = 0,
            Fun_17 = fun Fun_17_loop(A_5, A0, Added_consts, B_5, B0, Bi, Bit_string_7, Block_3, Blocks_3, C, C0, D_2, D0, I_22, Message_2, Shift_amounts) ->
    case (I_22 < 64) of
        true ->
            F = 0,
            G = 0,
            case (I_22 =< 15) of
        true -> F_2 = bit_xor(D_2, bit_and(B_5, bit_xor(C, D_2))),
            G_2 = I_22,
            F_8 = F_2,
            G_8 = G_2;
        _ -> case (I_22 =< 31) of
        true -> F_3 = bit_xor(C, bit_and(D_2, bit_xor(B_5, C))),
            G_3 = mochi_mod(((5 * I_22) + 1), 16),
            F_7 = F_3,
            G_7 = G_3;
        _ -> case (I_22 =< 47) of
        true -> F_4 = bit_xor(bit_xor(B_5, C), D_2),
            G_4 = mochi_mod(((3 * I_22) + 5), 16),
            F_6 = F_4,
            G_6 = G_4;
        _ -> F_5 = bit_xor(C, bit_or(B_5, not_32(D_2))),
            G_5 = mochi_mod((7 * I_22), 16),
            F_6 = F_5,
            G_6 = G_5
    end,
            F_7 = F_6,
            G_7 = G_6
    end,
            F_8 = F_7,
            G_8 = G_7
    end,
            F_9 = sum_32(F_8, A_5),
            F_10 = sum_32(F_9, (case erlang:is_map(Added_consts) of true -> maps:get(I_22, Added_consts, nil); _ -> case I_22 < 0 of true -> mochi_nth(erlang:length(Added_consts) + I_22 + 1, Added_consts); _ -> mochi_nth(I_22 + 1, Added_consts) end end)),
            F_11 = sum_32(F_10, (case erlang:is_map(Block_3) of true -> maps:get(G_8, Block_3, nil); _ -> case G_8 < 0 of true -> mochi_nth(erlang:length(Block_3) + G_8 + 1, Block_3); _ -> mochi_nth(G_8 + 1, Block_3) end end)),
            Rotated = left_rotate_32(F_11, (case erlang:is_map(Shift_amounts) of true -> maps:get(I_22, Shift_amounts, nil); _ -> case I_22 < 0 of true -> mochi_nth(erlang:length(Shift_amounts) + I_22 + 1, Shift_amounts); _ -> mochi_nth(I_22 + 1, Shift_amounts) end end)),
            New_b = sum_32(B_5, Rotated),
            A_6 = D_2,
            D_3 = C,
            C_2 = B_5,
            B_6 = New_b,
            I_23 = (I_22 + 1),
            Fun_17_loop(A_6, A0, Added_consts, B_6, B0, Bi, Bit_string_7, Block_3, Blocks_3, C_2, C0, D_3, D0, I_23, Message_2, Shift_amounts);
        _ -> {A_5, A0, Added_consts, B_5, B0, Bi, Bit_string_7, Block_3, Blocks_3, C, C0, D_2, D0, I_22, Message_2, Shift_amounts}
    end
end,
{A_6, A0, Added_consts, B_6, B0, Bi, Bit_string_7, Block_3, Blocks_3, C_2, C0, D_3, D0, I_23, Message_2, Shift_amounts} = Fun_17(A_5, A0, Added_consts, B_5, B0, Bi, Bit_string_7, Block_3, Blocks_3, C, C0, D_2, D0, I_22, Message_2, Shift_amounts),
            A0_2 = sum_32(A0, A_6),
            B0_2 = sum_32(B0, B_6),
            C0_2 = sum_32(C0, C_2),
            D0_2 = sum_32(D0, D_3),
            Bi_2 = (Bi + 1),
            Fun_18_loop(A0_2, Added_consts, B0_2, Bi_2, Bit_string_7, Blocks_3, C0_2, D0_2, Message_2, Shift_amounts);
        _ -> {A0, Added_consts, B0, Bi, Bit_string_7, Blocks_3, C0, D0, Message_2, Shift_amounts}
    end
end,
{A0_2, Added_consts, B0_2, Bi_2, Bit_string_7, Blocks_3, C0_2, D0_2, Message_2, Shift_amounts} = Fun_18(A0, Added_consts, B0, Bi, Bit_string_7, Blocks_3, C0, D0, Message_2, Shift_amounts),
        Digest = (((reformat_hex(A0_2) ++ reformat_hex(B0_2)) ++ reformat_hex(C0_2)) ++ reformat_hex(D0_2)),
        Digest
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('MOD', 4294967296),
    erlang:put('ASCII', " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
