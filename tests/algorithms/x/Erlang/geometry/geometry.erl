#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, make_angle/1, make_side/2, ellipse_area/1, ellipse_perimeter/1, circle_area/1, circle_perimeter/1, circle_diameter/1, circle_max_parts/1, make_polygon/0, polygon_add_side/2, polygon_get_side/2, polygon_set_side/3, make_rectangle/2, rectangle_perimeter/1, rectangle_area/1, make_square/1, square_perimeter/1, square_area/1, main/0]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

make_angle(Deg) ->
    try
        case ((Deg < 0) orelse (Deg > 360)) of
        true -> erlang:error("degrees must be between 0 and 360");
        _ -> ok
    end,
        #{"degrees" => Deg}
    catch {return, Ret} -> Ret end.

make_side(Length, Angle) ->
    try
        case (Length =< 0) of
        true -> erlang:error("length must be positive");
        _ -> ok
    end,
        #{"length" => Length, "angle" => Angle, "next" => -1}
    catch {return, Ret} -> Ret end.

ellipse_area(E) ->
    try
        mochi_safe_mul(mochi_safe_mul(3.141592653589793, maps:get("major", E, nil)), maps:get("minor", E, nil))
    catch {return, Ret} -> Ret end.

ellipse_perimeter(E_2) ->
    try
        mochi_safe_mul(3.141592653589793, (maps:get("major", E_2, nil) + maps:get("minor", E_2, nil)))
    catch {return, Ret} -> Ret end.

circle_area(C) ->
    try
        E_3 = #{"major" => maps:get("radius", C, nil), "minor" => maps:get("radius", C, nil)},
        Area = ellipse_area(E_3),
        Area
    catch {return, Ret} -> Ret end.

circle_perimeter(C_2) ->
    try
        E_4 = #{"major" => maps:get("radius", C_2, nil), "minor" => maps:get("radius", C_2, nil)},
        Per = ellipse_perimeter(E_4),
        Per
    catch {return, Ret} -> Ret end.

circle_diameter(C_3) ->
    try
        mochi_safe_mul(maps:get("radius", C_3, nil), 2)
    catch {return, Ret} -> Ret end.

circle_max_parts(Num_cuts) ->
    try
        case (Num_cuts < 0) of
        true -> erlang:error("num_cuts must be positive");
        _ -> ok
    end,
        mochi_safe_mul(((Num_cuts + 2) + mochi_safe_mul(Num_cuts, Num_cuts)), 0.5)
    catch {return, Ret} -> Ret end.

make_polygon() ->
    try
        S = [],
        #{"sides" => S}
    catch {return, Ret} -> Ret end.

polygon_add_side(P, S_2) ->
    try
        P_2 = maps:put("sides", lists:append((case maps:get("sides", P, nil) of nil -> []; _ -> maps:get("sides", P, nil) end), [S_2]), P),
        {nil, P_2}
    catch {return, Ret} -> Ret end.

polygon_get_side(P_3, Index) ->
    try
        (case erlang:is_map(maps:get("sides", P_3, nil)) of true -> maps:get(Index, maps:get("sides", P_3, nil), nil); _ -> case Index < 0 of true -> lists:nth(erlang:length(maps:get("sides", P_3, nil)) + Index + 1, maps:get("sides", P_3, nil)); _ -> lists:nth(Index + 1, maps:get("sides", P_3, nil)) end end)
    catch {return, Ret} -> Ret end.

polygon_set_side(P_4, Index_2, S_3) ->
    try
        Tmp = maps:get("sides", P_4, nil),
        Tmp_2 = lists:sublist(Tmp, Index_2) ++ [S_3] ++ lists:nthtail(Index_2 + 1, Tmp),
        P_5 = maps:put("sides", Tmp_2, P_4),
        {nil, P_5}
    catch {return, Ret} -> Ret end.

make_rectangle(Short_len, Long_len) ->
    try
        case ((Short_len =< 0) orelse (Long_len =< 0)) of
        true -> erlang:error("length must be positive");
        _ -> ok
    end,
        Short = make_side(Short_len, make_angle(90)),
        Long = make_side(Long_len, make_angle(90)),
        P_6 = make_polygon(),
        {_, P_7} = polygon_add_side(P_6, Short),
        {_, P_8} = polygon_add_side(P_7, Long),
        #{"short_side" => Short, "long_side" => Long, "poly" => P_8}
    catch {return, Ret} -> Ret end.

rectangle_perimeter(R) ->
    try
        mochi_safe_mul((maps:get("length", maps:get("short_side", R, nil), nil) + maps:get("length", maps:get("long_side", R, nil), nil)), 2)
    catch {return, Ret} -> Ret end.

rectangle_area(R_2) ->
    try
        mochi_safe_mul(maps:get("length", maps:get("short_side", R_2, nil), nil), maps:get("length", maps:get("long_side", R_2, nil), nil))
    catch {return, Ret} -> Ret end.

make_square(Side_len) ->
    try
        Rect = make_rectangle(Side_len, Side_len),
        #{"side" => maps:get("short_side", Rect, nil), "rect" => Rect}
    catch {return, Ret} -> Ret end.

square_perimeter(S_4) ->
    try
        P_9 = rectangle_perimeter(maps:get("rect", S_4, nil)),
        P_9
    catch {return, Ret} -> Ret end.

square_area(S_5) ->
    try
        A = rectangle_area(maps:get("rect", S_5, nil)),
        A
    catch {return, Ret} -> Ret end.

main() ->
    try
        A_2 = make_angle(90),
        io:format("~ts~n", [mochi_repr(maps:get("degrees", A_2, nil))]),
        S_6 = make_side(5, A_2),
        io:format("~ts~n", [mochi_repr(maps:get("length", S_6, nil))]),
        E_5 = #{"major" => 5, "minor" => 10},
        io:format("~ts~n", [mochi_repr(ellipse_area(E_5))]),
        io:format("~ts~n", [mochi_repr(ellipse_perimeter(E_5))]),
        C_4 = #{"radius" => 5},
        io:format("~ts~n", [mochi_repr(circle_area(C_4))]),
        io:format("~ts~n", [mochi_repr(circle_perimeter(C_4))]),
        io:format("~ts~n", [mochi_repr(circle_diameter(C_4))]),
        io:format("~ts~n", [mochi_repr(circle_max_parts(7))]),
        R_3 = make_rectangle(5, 10),
        io:format("~ts~n", [mochi_repr(rectangle_perimeter(R_3))]),
        io:format("~ts~n", [mochi_repr(rectangle_area(R_3))]),
        Q = make_square(5),
        io:format("~ts~n", [mochi_repr(square_perimeter(Q))]),
        io:format("~ts~n", [mochi_repr(square_area(Q))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
