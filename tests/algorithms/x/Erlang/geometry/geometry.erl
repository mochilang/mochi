#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars, nowarn_export_vars, nowarn_export_all, nowarn_unused_expr, nowarn_unused_function]).
-export([main/1, make_angle/1, make_side/2, ellipse_area/1, ellipse_perimeter/1, circle_area/1, circle_perimeter/1, circle_diameter/1, circle_max_parts/1, make_polygon/0, polygon_add_side/2, polygon_get_side/2, polygon_set_side/3, make_rectangle/2, rectangle_perimeter/1, rectangle_area/1, make_square/1, square_perimeter/1, square_area/1, main/0]).

% Generated by Mochi transpiler v0.10.64 (2a849c314b) on 2025-08-13 15:58 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, [mochi_nth/2]}).
-spec mochi_nth(integer(), list()) -> any().
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, [mochi_str/1]}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, [mochi_repr/1]}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


-compile({nowarn_unused_function, [mochi_safe_mul/2, mochi_safe_div/2]}).
mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.

make_angle(Deg) ->
    try
        case ((Deg < 0.0) orelse (Deg > 360.0)) of
        true -> erlang:error({panic, "degrees must be between 0 and 360"});
        _ -> ok
    end,
        #{"degrees" => Deg}
    catch {return, RetCatch} -> RetCatch end.

make_side(Length, Angle) ->
    try
        case (Length =< 0.0) of
        true -> erlang:error({panic, "length must be positive"});
        _ -> ok
    end,
        #{"length" => Length, "angle" => Angle, "next" => -1}
    catch {return, RetCatch} -> RetCatch end.

ellipse_area(E) ->
    try
        mochi_safe_mul(mochi_safe_mul(3.141592653589793, maps:get("major", E, nil)), maps:get("minor", E, nil))
    catch {return, RetCatch} -> RetCatch end.

ellipse_perimeter(E_2) ->
    try
        mochi_safe_mul(3.141592653589793, (maps:get("major", E_2, nil) + maps:get("minor", E_2, nil)))
    catch {return, RetCatch} -> RetCatch end.

circle_area(C) ->
    try
        E_3 = #{"major" => maps:get("radius", C, nil), "minor" => maps:get("radius", C, nil)},
        Area = ellipse_area(E_3),
        Area
    catch {return, RetCatch} -> RetCatch end.

circle_perimeter(C_2) ->
    try
        E_4 = #{"major" => maps:get("radius", C_2, nil), "minor" => maps:get("radius", C_2, nil)},
        Per = ellipse_perimeter(E_4),
        Per
    catch {return, RetCatch} -> RetCatch end.

circle_diameter(C_3) ->
    try
        mochi_safe_mul(maps:get("radius", C_3, nil), 2.0)
    catch {return, RetCatch} -> RetCatch end.

circle_max_parts(Num_cuts) ->
    try
        case (Num_cuts < 0.0) of
        true -> erlang:error({panic, "num_cuts must be positive"});
        _ -> ok
    end,
        mochi_safe_mul(((Num_cuts + 2.0) + mochi_safe_mul(Num_cuts, Num_cuts)), 0.5)
    catch {return, RetCatch} -> RetCatch end.

make_polygon() ->
    try
        S = [],
        #{"sides" => S}
    catch {return, RetCatch} -> RetCatch end.

polygon_add_side(P, S_2) ->
    try
        P_2 = maps:put("sides", lists:append((case maps:get("sides", P, nil) of nil -> []; _ -> maps:get("sides", P, nil) end), [S_2]), P),
        {nil, P_2}
    catch {return, RetCatch} -> RetCatch end.

polygon_get_side(P_3, Index) ->
    try
        (case erlang:is_map(maps:get("sides", P_3, nil)) of true -> maps:get(Index, maps:get("sides", P_3, nil), nil); _ -> case Index < 0 of true -> mochi_nth(erlang:length(maps:get("sides", P_3, nil)) + Index + 1, maps:get("sides", P_3, nil)); _ -> mochi_nth(Index + 1, maps:get("sides", P_3, nil)) end end)
    catch {return, RetCatch} -> RetCatch end.

polygon_set_side(P_4, Index_2, S_3) ->
    try
        Tmp = maps:get("sides", P_4, nil),
        Tmp_2 = lists:sublist(Tmp, Index_2) ++ [S_3] ++ lists:nthtail(Index_2 + 1, Tmp),
        P_5 = maps:put("sides", Tmp_2, P_4),
        {nil, P_5}
    catch {return, RetCatch} -> RetCatch end.

make_rectangle(Short_len, Long_len) ->
    try
        case ((Short_len =< 0.0) orelse (Long_len =< 0.0)) of
        true -> erlang:error({panic, "length must be positive"});
        _ -> ok
    end,
        Short = make_side(Short_len, make_angle(90.0)),
        Long = make_side(Long_len, make_angle(90.0)),
        P_6 = make_polygon(),
        P_res = polygon_add_side(P_6, Short),
        P_tmp = element(2, P_res),
        P_6 = P_tmp,
        P_res_2 = polygon_add_side(P_6, Long),
        P_tmp_2 = element(2, P_res_2),
        P_6 = P_tmp_2,
        #{"short_side" => Short, "long_side" => Long, "poly" => P_6}
    catch {return, RetCatch} -> RetCatch end.

rectangle_perimeter(R) ->
    try
        mochi_safe_mul((maps:get("length", maps:get("short_side", R, nil), nil) + maps:get("length", maps:get("long_side", R, nil), nil)), 2.0)
    catch {return, RetCatch} -> RetCatch end.

rectangle_area(R_2) ->
    try
        mochi_safe_mul(maps:get("length", maps:get("short_side", R_2, nil), nil), maps:get("length", maps:get("long_side", R_2, nil), nil))
    catch {return, RetCatch} -> RetCatch end.

make_square(Side_len) ->
    try
        Rect = make_rectangle(Side_len, Side_len),
        #{"side" => maps:get("short_side", Rect, nil), "rect" => Rect}
    catch {return, RetCatch} -> RetCatch end.

square_perimeter(S_4) ->
    try
        P_7 = rectangle_perimeter(maps:get("rect", S_4, nil)),
        P_7
    catch {return, RetCatch} -> RetCatch end.

square_area(S_5) ->
    try
        A = rectangle_area(maps:get("rect", S_5, nil)),
        A
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        A_2 = make_angle(90.0),
        io:format("~ts~n", [mochi_repr(maps:get("degrees", A_2, nil))]),
        S_6 = make_side(5.0, A_2),
        io:format("~ts~n", [mochi_repr(maps:get("length", S_6, nil))]),
        E_5 = #{"major" => 5.0, "minor" => 10.0},
        io:format("~ts~n", [mochi_repr(ellipse_area(E_5))]),
        io:format("~ts~n", [mochi_repr(ellipse_perimeter(E_5))]),
        C_4 = #{"radius" => 5.0},
        io:format("~ts~n", [mochi_repr(circle_area(C_4))]),
        io:format("~ts~n", [mochi_repr(circle_perimeter(C_4))]),
        io:format("~ts~n", [mochi_repr(circle_diameter(C_4))]),
        io:format("~ts~n", [mochi_repr(circle_max_parts(7.0))]),
        R_3 = make_rectangle(5.0, 10.0),
        io:format("~ts~n", [mochi_repr(rectangle_perimeter(R_3))]),
        io:format("~ts~n", [mochi_repr(rectangle_area(R_3))]),
        Q = make_square(5.0),
        io:format("~ts~n", [mochi_repr(square_perimeter(Q))]),
        io:format("~ts~n", [mochi_repr(square_area(Q))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
